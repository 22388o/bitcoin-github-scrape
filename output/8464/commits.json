[
  {
    "sha": "f9f86d71f3e5117ec6bab2bed04f656a95dda896",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmOWY4NmQ3MWYzZTUxMTdlYzZiYWIyYmVkMDRmNjU2YTk1ZGRhODk2",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-05T02:11:38Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:45Z"
      },
      "message": "Add the MAX_SCRIPTCHECKS const to consensus. Can be safely reduced to the minimum of various consensus parameters",
      "tree": {
        "sha": "8f640c3f90b1543163184f35dd3a0fce78b8e560",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8f640c3f90b1543163184f35dd3a0fce78b8e560"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f9f86d71f3e5117ec6bab2bed04f656a95dda896",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f9f86d71f3e5117ec6bab2bed04f656a95dda896",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f9f86d71f3e5117ec6bab2bed04f656a95dda896",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f9f86d71f3e5117ec6bab2bed04f656a95dda896/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2b23dbaee5b88d7237144e14eff01391e2cc201d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2b23dbaee5b88d7237144e14eff01391e2cc201d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2b23dbaee5b88d7237144e14eff01391e2cc201d"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 1,
      "deletions": 0
    },
    "files": [
      {
        "sha": "4b8fb048cef66499f30217ff36a405b20c898479",
        "filename": "src/consensus/consensus.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f9f86d71f3e5117ec6bab2bed04f656a95dda896/src/consensus/consensus.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f9f86d71f3e5117ec6bab2bed04f656a95dda896/src/consensus/consensus.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/consensus.h?ref=f9f86d71f3e5117ec6bab2bed04f656a95dda896",
        "patch": "@@ -19,6 +19,7 @@ static const int64_t MAX_BLOCK_SIGOPS_COST = 80000;\n /** Coinbase transaction outputs can only be spent after this number of new blocks (network rule) */\n static const int COINBASE_MATURITY = 100;\n \n+static const unsigned long long MAX_SCRIPTCHECKS = static_cast<unsigned long long>(MAX_BLOCK_SERIALIZED_SIZE)/41;\n /** Flags for nSequence and nLockTime locks */\n enum {\n     /* Interpret sequence numbers as relative lock-time constraints. */"
      }
    ]
  },
  {
    "sha": "61540f7d4761864362280fd62e5c9712c342f77b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MTU0MGY3ZDQ3NjE4NjQzNjIyODBmZDYyZTVjOTcxMmMzNDJmNzdi",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-05T02:34:02Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:45Z"
      },
      "message": "refactor templating and initialization",
      "tree": {
        "sha": "00eee5b7b5c5401caed5274b8a7c90274e32d313",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/00eee5b7b5c5401caed5274b8a7c90274e32d313"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/61540f7d4761864362280fd62e5c9712c342f77b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/61540f7d4761864362280fd62e5c9712c342f77b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/61540f7d4761864362280fd62e5c9712c342f77b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/61540f7d4761864362280fd62e5c9712c342f77b/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f9f86d71f3e5117ec6bab2bed04f656a95dda896",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f9f86d71f3e5117ec6bab2bed04f656a95dda896",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f9f86d71f3e5117ec6bab2bed04f656a95dda896"
      }
    ],
    "stats": {
      "total": 52,
      "additions": 32,
      "deletions": 20
    },
    "files": [
      {
        "sha": "49da7a4bcd7540051784d785e750271080020a4e",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 18,
        "deletions": 6,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/61540f7d4761864362280fd62e5c9712c342f77b/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/61540f7d4761864362280fd62e5c9712c342f77b/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=61540f7d4761864362280fd62e5c9712c342f77b",
        "patch": "@@ -26,7 +26,7 @@ class CCheckQueueControl;\n   * the master is done adding work, it temporarily joins the worker pool\n   * as an N'th worker, until all jobs are done.\n   */\n-template <typename T>\n+template <typename T, size_t J size_t W>\n class CCheckQueue\n {\n private:\n@@ -63,7 +63,7 @@ class CCheckQueue\n     bool fQuit;\n \n     //! The maximum number of elements to be processed in one batch\n-    unsigned int nBatchSize;\n+    unsigned int nBatchSize = 128;\n \n     /** Internal function that does bulk of the verification work. */\n     bool Loop(bool fMaster = false)\n@@ -127,6 +127,9 @@ class CCheckQueue\n     }\n \n public:\n+    typedef T JOB_TYPE;\n+    static const size_t MAX_JOBS = J;\n+    static const size_t MAX_WORKERS = W;\n     //! Create a new check queue\n     CCheckQueue(unsigned int nBatchSizeIn) : nIdle(0), nTotal(0), fAllOk(true), nTodo(0), fQuit(false), nBatchSize(nBatchSizeIn) {}\n \n@@ -167,21 +170,30 @@ class CCheckQueue\n         return (nTotal == nIdle && nTodo == 0 && fAllOk == true);\n     }\n \n+    void init(size_t nScriptCheckThreads) \n+    {\n+        if (nScriptCheckThreads) {\n+            for (int i=0; i<nScriptCheckThreads-1; i++) {\n+                boost::thread t([=](){Loop();});\n+                t.detach();\n+        }\n+    }\n+\n };\n \n /** \n  * RAII-style controller object for a CCheckQueue that guarantees the passed\n  * queue is finished before continuing.\n  */\n-template <typename T>\n+template <typename Q>\n class CCheckQueueControl\n {\n private:\n-    CCheckQueue<T>* pqueue;\n+    Q* pqueue;\n     bool fDone;\n \n public:\n-    CCheckQueueControl(CCheckQueue<T>* pqueueIn) : pqueue(pqueueIn), fDone(false)\n+    CCheckQueueControl(Q* pqueueIn) : pqueue(pqueueIn), fDone(false)\n     {\n         // passed queue is supposed to be unused, or NULL\n         if (pqueue != NULL) {\n@@ -199,7 +211,7 @@ class CCheckQueueControl\n         return fRet;\n     }\n \n-    void Add(std::vector<T>& vChecks)\n+    void Add(std::vector<typename Q::JOB_TYPE>& vChecks)\n     {\n         if (pqueue != NULL)\n             pqueue->Add(vChecks);"
      },
      {
        "sha": "a4ec50ed77b82fdaddb4c83b08f4f419b9659241",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/61540f7d4761864362280fd62e5c9712c342f77b/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/61540f7d4761864362280fd62e5c9712c342f77b/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=61540f7d4761864362280fd62e5c9712c342f77b",
        "patch": "@@ -1069,10 +1069,7 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n     LogPrintf(\"Using at most %i connections (%i file descriptors available)\\n\", nMaxConnections, nFD);\n \n     LogPrintf(\"Using %u threads for script verification\\n\", nScriptCheckThreads);\n-    if (nScriptCheckThreads) {\n-        for (int i=0; i<nScriptCheckThreads-1; i++)\n-            threadGroup.create_thread(&ThreadScriptCheck);\n-    }\n+    SetupCCheckQueue(nScriptCheckThreads);\n \n     // Start the lightweight task scheduler thread\n     CScheduler::Function serviceLoop = boost::bind(&CScheduler::serviceQueue, &scheduler);"
      },
      {
        "sha": "d979b60fd024d2485326af26128934654c5330c0",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 6,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/61540f7d4761864362280fd62e5c9712c342f77b/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/61540f7d4761864362280fd62e5c9712c342f77b/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=61540f7d4761864362280fd62e5c9712c342f77b",
        "patch": "@@ -2231,12 +2231,13 @@ void static FlushBlockFile(bool fFinalize = false)\n \n bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos, unsigned int nAddSize);\n \n-static CCheckQueue<CScriptCheck> scriptcheckqueue(128);\n+static CCheckQueue<CScriptCheck, MAX_SCRIPTCHECKS, MAX_SCRIPTCHECK_THREADS> scriptcheckqueue;\n+void StopCCheckQueue() {\n \n-void ThreadScriptCheck() {\n-    RenameThread(\"bitcoin-scriptch\");\n-    scriptcheckqueue.Thread();\n-}\n+};\n+void SetupCCheckQueue(size_t RT_N_SCRIPTCHECK_THREADS) {\n+    scriptcheckqueue.init(RT_N_SCRIPTCHECK_THREADS);\n+};\n \n // Protected by cs_main\n VersionBitsCache versionbitscache;\n@@ -2394,7 +2395,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n \n     CBlockUndo blockundo;\n \n-    CCheckQueueControl<CScriptCheck> control(fScriptChecks && nScriptCheckThreads ? &scriptcheckqueue : NULL);\n+    CCheckQueueControl<decltype(scriptcheckqueue)> control(fScriptChecks && nScriptCheckThreads ? &scriptcheckqueue : NULL);\n \n     std::vector<uint256> vOrphanErase;\n     std::vector<int> prevheights;\n@@ -2460,6 +2461,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n             if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, nScriptCheckThreads ? &vChecks : NULL))\n                 return error(\"ConnectBlock(): CheckInputs on %s failed with %s\",\n                     tx.GetHash().ToString(), FormatStateMessage(state));\n+\n             control.Add(vChecks);\n         }\n "
      },
      {
        "sha": "34006a2327f85d8cdc3efd8a04866727e3552962",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/61540f7d4761864362280fd62e5c9712c342f77b/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/61540f7d4761864362280fd62e5c9712c342f77b/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=61540f7d4761864362280fd62e5c9712c342f77b",
        "patch": "@@ -246,8 +246,10 @@ bool ProcessMessages(CNode* pfrom);\n  * @param[in]   pto             The node which we are sending messages to.\n  */\n bool SendMessages(CNode* pto);\n-/** Run an instance of the script checking thread */\n-void ThreadScriptCheck();\n+/** Make global checkqueue destructor visible */\n+void StopCCheckQueue();\n+/** Make global checkqueue thread-adder visible */\n+void SetupCCheckQueue(size_t RT_N_SCRIPTCHECK_THREADS);\n /** Check whether we are doing an initial block download (synchronizing from disk or network) */\n bool IsInitialBlockDownload();\n /** Format a string that describes several potential problems detected by the core."
      },
      {
        "sha": "e321cf1d60dbe1682f9c1782c3bdf86ca7605c26",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/61540f7d4761864362280fd62e5c9712c342f77b/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/61540f7d4761864362280fd62e5c9712c342f77b/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=61540f7d4761864362280fd62e5c9712c342f77b",
        "patch": "@@ -66,8 +66,7 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n             BOOST_CHECK(ok);\n         }\n         nScriptCheckThreads = 3;\n-        for (int i=0; i < nScriptCheckThreads-1; i++)\n-            threadGroup.create_thread(&ThreadScriptCheck);\n+        SetupCCheckQueue(nScriptCheckThreads);\n         RegisterNodeSignals(GetNodeSignals());\n }\n "
      }
    ]
  },
  {
    "sha": "62e05da902d159160e824a6bee4cc9de80d5d901",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MmUwNWRhOTAyZDE1OTE2MGU4MjRhNmJlZTRjYzlkZTgwZDVkOTAx",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-05T02:41:24Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:45Z"
      },
      "message": "Re-Implement the CheckQueue to only use lockfree atomics",
      "tree": {
        "sha": "b9b8a37229b7a9d21eb299d2e3fc5c1ec8c1af99",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b9b8a37229b7a9d21eb299d2e3fc5c1ec8c1af99"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/62e05da902d159160e824a6bee4cc9de80d5d901",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/62e05da902d159160e824a6bee4cc9de80d5d901",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/62e05da902d159160e824a6bee4cc9de80d5d901",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/62e05da902d159160e824a6bee4cc9de80d5d901/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "61540f7d4761864362280fd62e5c9712c342f77b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/61540f7d4761864362280fd62e5c9712c342f77b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/61540f7d4761864362280fd62e5c9712c342f77b"
      }
    ],
    "stats": {
      "total": 520,
      "additions": 389,
      "deletions": 131
    },
    "files": [
      {
        "sha": "106059e93d90a7209c490e3bd4cf9bbf27ce228f",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 389,
        "deletions": 131,
        "changes": 520,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/62e05da902d159160e824a6bee4cc9de80d5d901/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/62e05da902d159160e824a6bee4cc9de80d5d901/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=62e05da902d159160e824a6bee4cc9de80d5d901",
        "patch": "@@ -5,179 +5,437 @@\n #ifndef BITCOIN_CHECKQUEUE_H\n #define BITCOIN_CHECKQUEUE_H\n \n-#include <algorithm>\n #include <vector>\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include <atomic>\n+#include <thread>\n+#include <chrono>\n+#include <sstream>\n+#include <iostream>\n+// This should be ignored eventually, but needs testing to ensure this works on more platforms\n+static_assert(ATOMIC_BOOL_LOCK_FREE, \"shared_status not lock free\");\n+static_assert(ATOMIC_LONG_LOCK_FREE, \"shared_status not lock free\");\n+static_assert(ATOMIC_LLONG_LOCK_FREE, \"shared_status not lock free\");\n \n-#include <boost/foreach.hpp>\n-#include <boost/thread/condition_variable.hpp>\n-#include <boost/thread/locks.hpp>\n-#include <boost/thread/mutex.hpp>\n \n-template <typename T>\n-class CCheckQueueControl;\n-\n-/** \n- * Queue for verifications that have to be performed.\n-  * The verifications are represented by a type T, which must provide an\n-  * operator(), returning a bool.\n-  *\n-  * One thread (the master) is assumed to push batches of verifications\n-  * onto the queue, where they are processed by N-1 worker threads. When\n-  * the master is done adding work, it temporarily joins the worker pool\n-  * as an N'th worker, until all jobs are done.\n-  */\n-template <typename T, size_t J size_t W>\n-class CCheckQueue\n+/** CCheckQueue_Internals contains various components that otherwise could live inside\n+ * of CCheckQueue, but is separate for easier testability and modularity */\n+namespace CCheckQueue_Internals\n {\n-private:\n-    //! Mutex to protect the inner state\n-    boost::mutex mutex;\n+/** job_array holds the atomic flags and the job data for the queue\n+     * and provides methods to assist in accessing or adding jobs.\n+     */\n+template <typename Q>\n+class job_array\n+{\n+    /** the raw check type */\n+    std::array<typename Q::JOB_TYPE, Q::MAX_JOBS> checks;\n+    /** atomic flags which are used to reserve a check from checks\n+             * C++11 standard guarantees that these are atomic on all platforms\n+             * */\n+    std::array<std::atomic_flag, Q::MAX_JOBS> flags;\n+    /** used as the insertion point into the array. */\n+    typename decltype(checks)::iterator next_free_index;\n \n-    //! Worker threads block on this when out of work\n-    boost::condition_variable condWorker;\n+public:\n+    job_array() : next_free_index(checks.begin())\n+    {\n+        for (auto& i : flags)\n+            i.clear();\n+    }\n+    /** add swaps a vector of checks into the checks array and increments the pointer\n+             * not threadsafe */\n+    void add(std::vector<typename Q::JOB_TYPE>& vChecks)\n+    {\n+        for (typename Q::JOB_TYPE& check : vChecks)\n+            check.swap(*(next_free_index++));\n+    }\n \n-    //! Master thread blocks on this when out of work\n-    boost::condition_variable condMaster;\n+    /** reserve tries to set a flag for an element \n+             * and returns if it was successful */\n+    bool reserve(const size_t i)\n+    {\n+        return !flags[i].test_and_set();\n+    }\n \n-    //! The queue of elements to be processed.\n-    //! As the order of booleans doesn't matter, it is used as a LIFO (stack)\n-    std::vector<T> queue;\n+    /** reset_flag resets a flag */\n+    void reset_flag(const size_t i)\n+    {\n+        flags[i].clear();\n+    }\n+\n+    /** eval runs a check at specified index */\n+    bool eval(const size_t i)\n+    {\n+        return checks[i]();\n+    }\n+\n+    /** reset_jobs resets the insertion index only, so should only be run on master.\n+             *\n+             * The caller must ensure that forall i, checks[i] is destructed and flags[i] is\n+             * reset.\n+             *\n+             * NOTE: This cleanup done \"for free\" elsewhere\n+             *      - checksi] is destructed by master on swap\n+             *      - flags[i] is reset by each thread while waiting to be cleared for duty\n+             */\n+    void reset_jobs()\n+    {\n+        next_free_index = checks.begin();\n+    }\n \n-    //! The number of workers (including the master) that are idle.\n-    int nIdle;\n+};\n+/* round_barrier is used to communicate that a thread has finished\n+     * all work and reported any bad checks it might have seen.\n+     *\n+     * Results should normally be cached thread locally (once a thread is done, it\n+     * will not mark itself un-done so no need to read the atomic twice)\n+     */\n \n-    //! The total number of workers (including the master).\n-    int nTotal;\n+template <typename Q>\n+class round_barrier\n+{\n+    std::array<std::atomic_bool, Q::MAX_WORKERS> state;\n+    size_t RT_N_SCRIPTCHECK_THREADS;\n \n-    //! The temporary evaluation result.\n-    bool fAllOk;\n+public:\n+    /** Default state is false so that first round looks like no prior round*/\n+    round_barrier() : RT_N_SCRIPTCHECK_THREADS(0) {}\n \n-    /**\n-     * Number of verifications that haven't completed yet.\n-     * This includes elements that are no longer queued, but still in the\n-     * worker's own batches.\n+    void init(const size_t rt)\n+    {\n+        RT_N_SCRIPTCHECK_THREADS = rt;\n+    }\n+\n+    void mark_done(const size_t id)\n+    {\n+        state[id] = true;\n+    }\n+\n+    /** Iterates from [0,upto) to fetch status updates on unfinished workers.\n+             *\n+             * @param upto \n+             * @returns if all entries up to upto were true*/\n+    bool load_done() const\n+    {\n+        bool x = true;\n+        for (auto i = 0; i < RT_N_SCRIPTCHECK_THREADS; i++) {\n+            x = x && state[i].load();\n+        }\n+        return x;\n+    }\n+\n+    /** resets one bool\n+             *\n+             */\n+    void reset(const size_t i)\n+    {\n+        state[i] = false;\n+    }\n+\n+    /** Perfroms a read of the state \n+            */\n+    bool is_done(const size_t i) const\n+    {\n+        return state[i];\n+    }\n+};\n+/* PriorityWorkQueue exists to help threads select work \n+     * to do in a cache friendly way. As long as all entries added are\n+     * popped it will be correct. Performance comes from intelligently\n+     * chosing the order.\n+     *\n+     * Each thread has a unique id, and preferentiall evaluates\n+     * jobs in an index i such that  i == id (mod RT_N_SCRIPTCHECK_THREADS) in increasing\n+     * order.\n+     *\n+     * After id aligned work is finished, the thread walks sequentially\n+     * through its neighbors (id +1%RT_N_SCRIPTCHECK_THREADS, id+2% RT_N_SCRIPTCHECK_THREADS) to find work.\n+     *\n+     * TODO: future optimizations\n+     *     - Abort (by clearing)\n+     *       remaining on backwards walk if one that is reserved\n+     *       already, because it means either the worker's stuff is done\n+     *       OR it already has 2 (or more) workers already who will finish it.\n+     *     - Use an interval set rather than a vector (maybe)\n+     *     - Select thread by most amount of work remaining \n+     *       (requires coordination)\n+     *     - Preferentially help 0 (the master) as it joins last\n+     *     - have two levels of empty, priority_empty and all_empty\n+     *       (check for more work when priority_empty)\n+     *\n      */\n-    unsigned int nTodo;\n+template <typename Q>\n+class PriorityWorkQueue\n+{\n+    std::array<size_t, Q::MAX_WORKERS> n_done;\n+    /** The Worker's ID */\n+    const size_t id;\n+    /** The number of workers that bitcoind started with, eg, RunTime Number ScriptCheck Threads  */\n+    const size_t RT_N_SCRIPTCHECK_THREADS;\n+    /** Stores the total inserted since the last reset (ignores pop) */\n+    size_t total;\n+    /** a cache of the last queue we were popping from, reset on adds and (circularly) incremented on pops \n+             * Otherwise pops have an O(workers) term, this keeps pop amortized constant */\n+    size_t id2_cache;\n \n-    //! Whether we're shutting down.\n-    bool fQuit;\n \n-    //! The maximum number of elements to be processed in one batch\n-    unsigned int nBatchSize = 128;\n+public:\n+    PriorityWorkQueue(){};\n+    PriorityWorkQueue(size_t id_, size_t RT_N_SCRIPTCHECK_THREADS_) : n_done(), id(id_), RT_N_SCRIPTCHECK_THREADS(RT_N_SCRIPTCHECK_THREADS_), total(0), id2_cache((id_ + 1) % RT_N_SCRIPTCHECK_THREADS){};\n+    /** adds entries for execution [total, n)\n+             * Places entries in the proper bucket\n+             * Resets the next thread to help (id2_cache) if work was added\n+             */\n+    void add(const size_t n)\n+    {\n+        if (n > total) {\n+            total = n;\n+            id2_cache = (id + 1) % RT_N_SCRIPTCHECK_THREADS;\n+        }\n+    }\n+    size_t get_total() const\n+    {\n+        return total;\n+    }\n+\n \n-    /** Internal function that does bulk of the verification work. */\n-    bool Loop(bool fMaster = false)\n+    /* Get one first from out own work stack (take the first one) and then try from neighbors sequentially\n+             * (from the last one on that neighbors stack)\n+             */\n+    bool pop(size_t& val, const bool no_stealing)\n     {\n-        boost::condition_variable& cond = fMaster ? condMaster : condWorker;\n-        std::vector<T> vChecks;\n-        vChecks.reserve(nBatchSize);\n-        unsigned int nNow = 0;\n-        bool fOk = true;\n-        do {\n-            {\n-                boost::unique_lock<boost::mutex> lock(mutex);\n-                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n-                if (nNow) {\n-                    fAllOk &= fOk;\n-                    nTodo -= nNow;\n-                    if (nTodo == 0 && !fMaster)\n-                        // We processed the last element; inform the master it can exit and return the result\n-                        condMaster.notify_one();\n-                } else {\n-                    // first iteration\n-                    nTotal++;\n-                }\n-                // logically, the do loop starts here\n-                while (queue.empty()) {\n-                    if ((fMaster || fQuit) && nTodo == 0) {\n-                        nTotal--;\n-                        bool fRet = fAllOk;\n-                        // reset the status for new work later\n-                        if (fMaster)\n-                            fAllOk = true;\n-                        // return the current status\n-                        return fRet;\n-                    }\n-                    nIdle++;\n-                    cond.wait(lock); // wait\n-                    nIdle--;\n-                }\n-                // Decide how many work units to process now.\n-                // * Do not try to do everything at once, but aim for increasingly smaller batches so\n-                //   all workers finish approximately simultaneously.\n-                // * Try to account for idle jobs which will instantly start helping.\n-                // * Don't do batches smaller than 1 (duh), or larger than nBatchSize.\n-                nNow = std::max(1U, std::min(nBatchSize, (unsigned int)queue.size() / (nTotal + nIdle + 1)));\n-                vChecks.resize(nNow);\n-                for (unsigned int i = 0; i < nNow; i++) {\n-                    // We want the lock on the mutex to be as short as possible, so swap jobs from the global\n-                    // queue to the local batch vector instead of copying.\n-                    vChecks[i].swap(queue.back());\n-                    queue.pop_back();\n-                }\n-                // Check whether we need to do work at all\n-                fOk = fAllOk;\n+        val = (id + (n_done[id]) * RT_N_SCRIPTCHECK_THREADS);\n+        if (val < total) {\n+            ++n_done[id];\n+            return true;\n+        }\n+        if (no_stealing)\n+            return false;\n+        // Iterate untill id2 wraps around to id.\n+        for (; id2_cache != id; id2_cache = (id2_cache + 1) % RT_N_SCRIPTCHECK_THREADS) {\n+            val = (id2_cache + (n_done[id2_cache]) * RT_N_SCRIPTCHECK_THREADS);\n+            if (val < total) {\n+                ++n_done[id2_cache];\n+                return true;\n             }\n-            // execute work\n-            BOOST_FOREACH (T& check, vChecks)\n-                if (fOk)\n-                    fOk = check();\n-            vChecks.clear();\n-        } while (true);\n+        }\n+        return false;\n     }\n+};\n+\n+/** status_container stores the \n+     * shared state for all nodes\n+     *\n+     * TODO: cache align things.*/\n+template <typename Q>\n+struct status_container {\n+    /** nTodo and  materJoined can be packed into one struct if desired*/\n+    std::atomic<size_t> nTodo;\n+    /** true if all checks were successful, false if any failure occurs */\n+    std::atomic<bool> fAllOk;\n+    /** true if the master has joined, false otherwise. A round may not terminate unless masterJoined */\n+    std::atomic<bool> masterJoined;\n+    /** used to count how many threads have finished cleanup operations */\n+    std::atomic_uint nFinishedCleanup;\n+\n+    status_container() : nTodo(0), fAllOk(true), masterJoined(false), nFinishedCleanup(0) {}\n+};\n+}\n+\n+\n+/** Queue for verifications that have to be performed.\n+ *\n+ * The verifications are represented by a type T, which must provide an\n+ * operator()(), returning a bool.\n+ *\n+ * One thread (the master) is assumed to push batches of verifications\n+ * onto the queue, where they are processed by N-1 worker threads. When\n+ * the master is done adding work, it temporarily joins the worker pool\n+ * as an N'th worker, until all jobs are done.\n+ *\n+ * @tparam T the type of callable check object\n+ * @tparam J the maximum number of jobs possible \n+ * @tparam W the maximum number of workers possible\n+ */\n \n+template <typename T, size_t J, size_t W>\n+class CCheckQueue;\n+template <typename T, size_t J, size_t W>\n+class CCheckQueue\n+{\n public:\n     typedef T JOB_TYPE;\n     static const size_t MAX_JOBS = J;\n     static const size_t MAX_WORKERS = W;\n-    //! Create a new check queue\n-    CCheckQueue(unsigned int nBatchSizeIn) : nIdle(0), nTotal(0), fAllOk(true), nTodo(0), fQuit(false), nBatchSize(nBatchSizeIn) {}\n+    // We use the Proto version so that we can pass it to job_array, status_container, etc\n+\n+private:\n+    CCheckQueue_Internals::job_array<CCheckQueue<T, J, W> > jobs;\n+    CCheckQueue_Internals::status_container<CCheckQueue<T, J, W> > status;\n+    CCheckQueue_Internals::round_barrier<CCheckQueue<T, J, W> > done_round;\n+    std::atomic<bool> should_sleep;\n+    size_t RT_N_SCRIPTCHECK_THREADS;\n+\n+\n+    void wait_all_finished_cleanup() const\n+    {\n+        while (status.nFinishedCleanup.load() != RT_N_SCRIPTCHECK_THREADS - 1)\n+            ;\n+    }\n+    void maybe_sleep() const\n+    {\n+        while (should_sleep)\n+            std::this_thread::sleep_for(std::chrono::microseconds(100));\n+    }\n+\n+    size_t consume(const size_t ID)\n+    {\n+        CCheckQueue_Internals::PriorityWorkQueue<CCheckQueue<T, J, W> > work_queue(ID, RT_N_SCRIPTCHECK_THREADS);\n+        bool no_stealing;\n+        bool got_data;\n+        size_t job_id;\n+        do {\n+            // Note: Must check masterJoined before nTodo, otherwise\n+            // {Thread A: nTodo.load();} {Thread B:nTodo++; masterJoined = true;} {Thread A: masterJoined.load()}\n+            no_stealing = !status.masterJoined.load();\n+            work_queue.add(status.nTodo.load());\n+            (got_data = work_queue.pop(job_id, no_stealing)) && jobs.reserve(job_id) && (jobs.eval(job_id) || (status.fAllOk.store(false), false));\n+        } while (status.fAllOk.load() && (no_stealing || got_data));\n+        return work_queue.get_total();\n+    }\n+    /** Internal function that does bulk of the verification work. */\n+    bool Loop(const size_t ID)\n+    {\n+        for (;;) {\n+            if (ID != 0)\n+                maybe_sleep();\n+\n+            size_t prev_total = consume(ID);\n+\n+            // We only break out of the loop when there is no more work and the master had joined.\n+            // We won't find more work later, so mark ourselves as completed\n+            // Any error would have already been reported\n+            // If we don't wait for the master to join, it is because an error check was found. Not waiting would cause a race condtion.\n+            while (!status.masterJoined.load())\n+                ;\n+            done_round.mark_done(ID);\n+\n+            // If we are the master:\n+            //  1) Wait till all threads finish\n+            //  2) read fAllOk\n+            //  3) Tell threads to sleep (otherwise, they may stay up)\n+            //  4) Mark master as gone\n+            //  5) return\n+            if (ID == 0) {\n+                while (!done_round.load_done())\n+                    ;\n+                bool fRet = status.fAllOk;\n+                sleep();\n+                status.masterJoined.store(false);\n+                return fRet;\n+            }\n \n+            // We wait until the master reports leaving explicitly\n+            while (status.masterJoined.load())\n+                ;\n+\n+            // Have ID == 1 perform cleanup as the \"slave master slave\" as ID == 1 is always there if multicore\n+            // This frees the master to return with the result before the cleanup occurs\n+            // And allows for the ID == 1 to do the master's cleanup for it\n+            // We can immediately begin cleanup because all threads waited for master to\n+            // exit on previous round and master waited for all workers.\n+\n+\n+            // We reset all the flags we think we'll use (also warms cache)\n+            for (size_t i = ID; i < prev_total; i += RT_N_SCRIPTCHECK_THREADS)\n+                jobs.reset_flag(i);\n+            ++status.nFinishedCleanup;\n+            if (ID == 1) {\n+                // Reset master flags too -- if ID == 0, it's not wrong just not needed\n+                for (size_t i = 0; i < prev_total; i += RT_N_SCRIPTCHECK_THREADS)\n+                    jobs.reset_flag(i);\n+\n+\n+                status.nTodo.store(0);\n+                status.fAllOk.store(true);\n+\n+                // TODO: In the future, other mutually excluded cleanup tasks can go here\n+\n+                // Wait until all threads are either master or idle, otherwise resetting could prevent finishing\n+                // because of cleanup occuring after others are running in main section\n+                wait_all_finished_cleanup();\n+                status.nFinishedCleanup.store(0);\n+                // We have all the threads wait on their done_round to be reset, so we\n+                // Release all the threads, master must be last to keep master from rejoining\n+                for (auto i = RT_N_SCRIPTCHECK_THREADS; i > 0;)\n+                    done_round.reset(--i);\n+            }\n+            while (done_round.is_done(ID))\n+                ;\n+        }\n+    }\n+\n+public:\n+    CCheckQueue() : jobs(), status(), done_round(), should_sleep(true), RT_N_SCRIPTCHECK_THREADS(0)\n+    {\n+    }\n+\n+    void wait_for_cleanup() const\n+    {\n+        while (done_round.is_done(0)) {\n+        }\n+    }\n+    void reset_jobs()\n+    {\n+        jobs.reset_jobs();\n+    }\n     //! Worker thread\n-    void Thread()\n+    void Thread(size_t ID)\n     {\n-        Loop();\n+        RenameThread(\"bitcoin-scriptcheck\");\n+        Loop(ID);\n     }\n \n+\n     //! Wait until execution finishes, and return whether all evaluations were successful.\n     bool Wait()\n     {\n-        return Loop(true);\n+        status.masterJoined.store(true);\n+        return Loop(0);\n     }\n \n     //! Add a batch of checks to the queue\n     void Add(std::vector<T>& vChecks)\n     {\n-        boost::unique_lock<boost::mutex> lock(mutex);\n-        BOOST_FOREACH (T& check, vChecks) {\n-            queue.push_back(T());\n-            check.swap(queue.back());\n-        }\n-        nTodo += vChecks.size();\n-        if (vChecks.size() == 1)\n-            condWorker.notify_one();\n-        else if (vChecks.size() > 1)\n-            condWorker.notify_all();\n+        jobs.add(vChecks);\n+        size_t vs = vChecks.size();\n+        status.nTodo.fetch_add(vs);\n     }\n \n     ~CCheckQueue()\n     {\n     }\n \n-    bool IsIdle()\n+    void init(const size_t RT_N_SCRIPTCHECK_THREADS_)\n     {\n-        boost::unique_lock<boost::mutex> lock(mutex);\n-        return (nTotal == nIdle && nTodo == 0 && fAllOk == true);\n-    }\n+        RT_N_SCRIPTCHECK_THREADS = RT_N_SCRIPTCHECK_THREADS_;\n+        done_round.init(RT_N_SCRIPTCHECK_THREADS);\n \n-    void init(size_t nScriptCheckThreads) \n-    {\n-        if (nScriptCheckThreads) {\n-            for (int i=0; i<nScriptCheckThreads-1; i++) {\n-                boost::thread t([=](){Loop();});\n-                t.detach();\n+        for (size_t id = 1; id < RT_N_SCRIPTCHECK_THREADS; ++id) {\n+            std::thread t([=]() {Loop(id); });\n+            t.detach();\n         }\n     }\n+    void wakeup()\n+    {\n+        should_sleep.store(false);\n+    }\n+    void sleep()\n+    {\n+        should_sleep.store(true);\n+    }\n \n };\n \n@@ -195,10 +453,10 @@ class CCheckQueueControl\n public:\n     CCheckQueueControl(Q* pqueueIn) : pqueue(pqueueIn), fDone(false)\n     {\n-        // passed queue is supposed to be unused, or NULL\n-        if (pqueue != NULL) {\n-            bool isIdle = pqueue->IsIdle();\n-            assert(isIdle);\n+        if (pqueue) {\n+            pqueue->wakeup();\n+            pqueue->wait_for_cleanup();\n+            pqueue->reset_jobs();\n         }\n     }\n "
      }
    ]
  },
  {
    "sha": "9d10b67aec18932f0d1380a2042645e0f5e7ed76",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZDEwYjY3YWVjMTg5MzJmMGQxMzgwYTIwNDI2NDVlMGY1ZTdlZDc2",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-05T02:50:01Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "add tests for lockfree checkqueue",
      "tree": {
        "sha": "a1a1676e0c911c9eafa797ad751c599e40b1a98f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a1a1676e0c911c9eafa797ad751c599e40b1a98f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9d10b67aec18932f0d1380a2042645e0f5e7ed76",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9d10b67aec18932f0d1380a2042645e0f5e7ed76",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9d10b67aec18932f0d1380a2042645e0f5e7ed76",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9d10b67aec18932f0d1380a2042645e0f5e7ed76/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "62e05da902d159160e824a6bee4cc9de80d5d901",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/62e05da902d159160e824a6bee4cc9de80d5d901",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/62e05da902d159160e824a6bee4cc9de80d5d901"
      }
    ],
    "stats": {
      "total": 439,
      "additions": 431,
      "deletions": 8
    },
    "files": [
      {
        "sha": "758c7a9ff3d32a01d46718c635d76a6ab5bbf6f9",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9d10b67aec18932f0d1380a2042645e0f5e7ed76/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9d10b67aec18932f0d1380a2042645e0f5e7ed76/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=9d10b67aec18932f0d1380a2042645e0f5e7ed76",
        "patch": "@@ -89,7 +89,8 @@ BITCOIN_TESTS =\\\n   test/versionbits_tests.cpp \\\n   test/uint256_tests.cpp \\\n   test/univalue_tests.cpp \\\n-  test/util_tests.cpp\n+  test/util_tests.cpp \\\n+  test/checkqueue_tests.cpp\n \n if ENABLE_WALLET\n BITCOIN_TESTS += \\"
      },
      {
        "sha": "6911511ecaca918870819e69ff8ff762e4bed934",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 112,
        "deletions": 7,
        "changes": 119,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9d10b67aec18932f0d1380a2042645e0f5e7ed76/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9d10b67aec18932f0d1380a2042645e0f5e7ed76/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=9d10b67aec18932f0d1380a2042645e0f5e7ed76",
        "patch": "@@ -85,6 +85,10 @@ class job_array\n         next_free_index = checks.begin();\n     }\n \n+    decltype(&checks) TEST_get_checks()\n+    {\n+        return Q::TEST ? &checks : nullptr;\n+    }\n };\n /* round_barrier is used to communicate that a thread has finished\n      * all work and reported any bad checks it might have seen.\n@@ -260,24 +264,43 @@ struct status_container {\n  * @tparam W the maximum number of workers possible\n  */\n \n-template <typename T, size_t J, size_t W>\n+enum testing_level : int {\n+    disabled = 0,\n+    enable_functions = 1,\n+    enable_logging = 2\n+};\n+constexpr testing_level operator&(testing_level a, testing_level b)\n+{\n+    return static_cast<testing_level>(static_cast<int>(a) & static_cast<int>(b));\n+}\n+\n+constexpr testing_level operator|(testing_level a, testing_level b)\n+{\n+    return static_cast<testing_level>(static_cast<int>(a) | static_cast<int>(b));\n+}\n+template <typename T, size_t J, size_t W, testing_level TEST_ENABLE = testing_level::disabled>\n class CCheckQueue;\n-template <typename T, size_t J, size_t W>\n+template <typename T, size_t J, size_t W, testing_level TEST_ENABLE>\n class CCheckQueue\n {\n public:\n     typedef T JOB_TYPE;\n     static const size_t MAX_JOBS = J;\n     static const size_t MAX_WORKERS = W;\n+    static const testing_level TEST = TEST_ENABLE;\n     // We use the Proto version so that we can pass it to job_array, status_container, etc\n \n private:\n-    CCheckQueue_Internals::job_array<CCheckQueue<T, J, W> > jobs;\n-    CCheckQueue_Internals::status_container<CCheckQueue<T, J, W> > status;\n-    CCheckQueue_Internals::round_barrier<CCheckQueue<T, J, W> > done_round;\n+    CCheckQueue_Internals::job_array<CCheckQueue<T, J, W, TEST> > jobs;\n+    CCheckQueue_Internals::status_container<CCheckQueue<T, J, W, TEST> > status;\n+    CCheckQueue_Internals::round_barrier<CCheckQueue<T, J, W, TEST> > done_round;\n     std::atomic<bool> should_sleep;\n     size_t RT_N_SCRIPTCHECK_THREADS;\n \n+    //state only for testing\n+    mutable std::atomic<size_t> test_log_seq;\n+    mutable std::array<std::ostringstream, MAX_WORKERS> test_log;\n+\n \n     void wait_all_finished_cleanup() const\n     {\n@@ -292,7 +315,10 @@ class CCheckQueue\n \n     size_t consume(const size_t ID)\n     {\n-        CCheckQueue_Internals::PriorityWorkQueue<CCheckQueue<T, J, W> > work_queue(ID, RT_N_SCRIPTCHECK_THREADS);\n+        if (TEST & testing_level::enable_logging)\n+            test_log[ID] << \"[[\" << ++test_log_seq << \"]] \"\n+                         << \"Worker ID [\" << ID << \"] in consume\\n\";\n+        CCheckQueue_Internals::PriorityWorkQueue<CCheckQueue<T, J, W, TEST> > work_queue(ID, RT_N_SCRIPTCHECK_THREADS);\n         bool no_stealing;\n         bool got_data;\n         size_t job_id;\n@@ -303,6 +329,9 @@ class CCheckQueue\n             work_queue.add(status.nTodo.load());\n             (got_data = work_queue.pop(job_id, no_stealing)) && jobs.reserve(job_id) && (jobs.eval(job_id) || (status.fAllOk.store(false), false));\n         } while (status.fAllOk.load() && (no_stealing || got_data));\n+        if (TEST & testing_level::enable_logging)\n+            test_log[ID] << \"[[\" << ++test_log_seq << \"]] \"\n+                         << \"Worker ID [\" << ID << \"] leaving consume. fAllOk was \" << status.fAllOk.load() << \"\\n\";\n         return work_queue.get_total();\n     }\n     /** Internal function that does bulk of the verification work. */\n@@ -312,8 +341,16 @@ class CCheckQueue\n             if (ID != 0)\n                 maybe_sleep();\n \n+            if (TEST & testing_level::enable_logging)\n+                test_log[ID] << \"[[\" << ++test_log_seq << \"]] \"\n+                             << \"Worker ID [\" << ID << \"] starting\\n\";\n+\n             size_t prev_total = consume(ID);\n \n+            if (TEST & testing_level::enable_logging)\n+                test_log[ID] << \"[[\" << ++test_log_seq << \"]] \"\n+                             << \"Worker ID [\" << ID << \"] saw up to \" << prev_total << \" master was \" << status.masterJoined.load() << \" nTodo \" << status.nTodo.load() << '\\n';\n+\n             // We only break out of the loop when there is no more work and the master had joined.\n             // We won't find more work later, so mark ourselves as completed\n             // Any error would have already been reported\n@@ -331,6 +368,9 @@ class CCheckQueue\n             if (ID == 0) {\n                 while (!done_round.load_done())\n                     ;\n+                if (TEST & testing_level::enable_logging)\n+                    test_log[ID] << \"[[\" << ++test_log_seq << \"]] \"\n+                                 << \"Worker ID [\" << ID << \"] saw all threads finished\\n\";\n                 bool fRet = status.fAllOk;\n                 sleep();\n                 status.masterJoined.store(false);\n@@ -340,6 +380,9 @@ class CCheckQueue\n             // We wait until the master reports leaving explicitly\n             while (status.masterJoined.load())\n                 ;\n+            if (TEST & testing_level::enable_logging)\n+                test_log[ID] << \"[[\" << ++test_log_seq << \"]] \"\n+                             << \"Worker ID [\" << ID << \"] saw master leave\\n\";\n \n             // Have ID == 1 perform cleanup as the \"slave master slave\" as ID == 1 is always there if multicore\n             // This frees the master to return with the result before the cleanup occurs\n@@ -357,6 +400,9 @@ class CCheckQueue\n                 for (size_t i = 0; i < prev_total; i += RT_N_SCRIPTCHECK_THREADS)\n                     jobs.reset_flag(i);\n \n+                if (TEST & testing_level::enable_logging)\n+                    test_log[ID] << \"[[\" << ++test_log_seq << \"]] \"\n+                                 << \"Resetting nTodo and fAllOk\" << '\\n';\n \n                 status.nTodo.store(0);\n                 status.fAllOk.store(true);\n@@ -378,14 +424,17 @@ class CCheckQueue\n     }\n \n public:\n-    CCheckQueue() : jobs(), status(), done_round(), should_sleep(true), RT_N_SCRIPTCHECK_THREADS(0)\n+    CCheckQueue() : jobs(), status(), done_round(), should_sleep(true), RT_N_SCRIPTCHECK_THREADS(0), test_log_seq(0)\n     {\n     }\n \n     void wait_for_cleanup() const\n     {\n         while (done_round.is_done(0)) {\n         }\n+        if (TEST & testing_level::enable_logging)\n+            test_log[0] << \"[[\" << ++test_log_seq << \"]] \"\n+                        << \"Worker ID [\" << 0 << \"] cleanup waiting done!\\n\";\n     }\n     void reset_jobs()\n     {\n@@ -403,6 +452,11 @@ class CCheckQueue\n     bool Wait()\n     {\n         status.masterJoined.store(true);\n+\n+        if (TEST & testing_level::enable_logging)\n+            test_log[0] << \"[[\" << ++test_log_seq << \"]] \"\n+                        << \"Master just set masterJoined\\n\";\n+\n         return Loop(0);\n     }\n \n@@ -412,6 +466,10 @@ class CCheckQueue\n         jobs.add(vChecks);\n         size_t vs = vChecks.size();\n         status.nTodo.fetch_add(vs);\n+\n+        if (TEST & testing_level::enable_logging)\n+            test_log[0] << \"[[\" << ++test_log_seq << \"]] \"\n+                        << \"Added \" << vs << \" values. nTodo was \" << status.nTodo.load() - vs << \" now is \" << status.nTodo.load() << \" \\n\";\n     }\n \n     ~CCheckQueue()\n@@ -437,6 +495,53 @@ class CCheckQueue\n         should_sleep.store(true);\n     }\n \n+    size_t TEST_consume(const size_t ID)\n+    {\n+        return TEST & testing_level::enable_functions ? consume(ID) : 0;\n+    }\n+    void TEST_set_masterJoined(const bool b)\n+    {\n+        if (TEST & testing_level::enable_functions)\n+            status.masterJoined.store(b);\n+    }\n+\n+    size_t TEST_count_set_flags()\n+    {\n+        auto count = 0;\n+        if (TEST & testing_level::enable_functions)\n+            for (auto t = 0; t < MAX_JOBS; ++t)\n+                count += jobs.reserve(t) ? 0 : 1;\n+        return count;\n+    }\n+    void TEST_reset_all_flags()\n+    {\n+        if (TEST & testing_level::enable_functions)\n+            for (auto t = 0; t < MAX_JOBS; ++t)\n+                jobs.reset_flag(t);\n+    }\n+    void TEST_dump_log(const size_t upto) const\n+    {\n+        if (TEST & testing_level::enable_functions & testing_level::enable_logging)\n+            for (auto i = 0; i < upto; ++i)\n+                LogPrintf(\"\\n------------------\\n%s\\n------------------\\n\\n\", test_log[i].str());\n+    }\n+\n+    void TEST_erase_log() const\n+    {\n+        if (TEST & testing_level::enable_functions & testing_level::enable_logging)\n+            for (auto i = 0; i < MAX_WORKERS; ++i) {\n+                test_log[i].str(\"\");\n+                test_log[i].clear();\n+            }\n+    }\n+    decltype(status) * TEST_introspect_status()\n+    {\n+        return TEST & testing_level::enable_functions ? &status : nullptr;\n+    }\n+    decltype(jobs) * TEST_introspect_jobs()\n+    {\n+        return TEST & testing_level::enable_functions ? &jobs : nullptr;\n+    }\n };\n \n /** "
      },
      {
        "sha": "9aff22c723dfcf26f4e93d0cd7ef0a6c50b7c605",
        "filename": "src/test/checkqueue_tests.cpp",
        "status": "added",
        "additions": 317,
        "deletions": 0,
        "changes": 317,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9d10b67aec18932f0d1380a2042645e0f5e7ed76/src/test/checkqueue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9d10b67aec18932f0d1380a2042645e0f5e7ed76/src/test/checkqueue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkqueue_tests.cpp?ref=9d10b67aec18932f0d1380a2042645e0f5e7ed76",
        "patch": "@@ -0,0 +1,317 @@\n+// Copyright (c) 2012-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+#include <atomic>\n+\n+#include <boost/thread.hpp>\n+#include <boost/bind.hpp>\n+#include <unordered_set>\n+\n+#include \"random.h\"\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, BasicTestingSetup)\n+\n+// Logging off by default because of memory leak\n+static const testing_level TEST = testing_level::enable_functions;\n+\n+struct FakeJob {\n+};\n+\n+typedef CCheckQueue<FakeJob, (size_t)100000, 16, TEST> big_queue;\n+typedef CCheckQueue<FakeJob, (size_t)2000, 16, TEST> medium_queue;\n+\n+struct big_queue_proto {\n+    typedef big_queue::JOB_TYPE JOB_TYPE;\n+    static const size_t MAX_JOBS = big_queue::MAX_JOBS;\n+    static const size_t MAX_WORKERS = big_queue::MAX_WORKERS;\n+};\n+\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    fPrintToConsole = true;\n+    static std::atomic<size_t> n_calls;\n+    struct FailingJob {\n+        bool f;\n+        bool call_state;\n+        size_t tag;\n+        FailingJob(bool fails) : f(fails), call_state(false), tag(0xdeadbeef){};\n+        FailingJob() : f(true), call_state(false){};\n+        bool operator()()\n+        {\n+            n_calls++;\n+            call_state = true;\n+            return !f;\n+        }\n+        void swap(FailingJob& x)\n+        {\n+            std::swap(f, x.f);\n+\n+            std::swap(call_state, x.call_state);\n+            std::swap(tag, x.tag);\n+        };\n+    };\n+    static CCheckQueue<FailingJob, (size_t)1000, 16, testing_level::enable_functions> fail_queue;\n+    size_t nThreads = 8;\n+    fail_queue.init(nThreads);\n+\n+    for (size_t i = 10; i < 1001; ++i) {\n+        n_calls = 0;\n+        CCheckQueueControl<decltype(fail_queue)> control(&fail_queue);\n+        size_t checksum = 0;\n+\n+        std::vector<FailingJob> vChecks;\n+        vChecks.reserve(i);\n+        for (size_t x = 0; x < i; ++x)\n+            vChecks.push_back(FailingJob{});\n+        if (i > 0)\n+            vChecks[0].f = true;\n+        while (!vChecks.empty()) {\n+            size_t r = GetRand(10);\n+            std::vector<FailingJob> vChecks2;\n+            vChecks2.reserve(r);\n+            for (size_t k = 0; k < r && !vChecks.empty(); k++) {\n+                vChecks2.emplace_back(vChecks.back());\n+                vChecks.pop_back();\n+            }\n+            checksum += vChecks2.size();\n+            control.Add(vChecks2);\n+        }\n+        BOOST_REQUIRE(checksum == i);\n+        bool success = control.Wait();\n+        if (success && i > 0) {\n+            size_t nChecked = 0;\n+            auto jobs = fail_queue.TEST_introspect_jobs()->TEST_get_checks();\n+            for (size_t x = 0; x < i; ++x)\n+                if ((*jobs)[x].call_state)\n+                    nChecked++;\n+            fail_queue.TEST_dump_log(nThreads);\n+            fail_queue.TEST_erase_log();\n+            BOOST_MESSAGE(\"Failed to see failure on round \" << i << \" only counted \" << nChecked << \" flags (by job_array).\");\n+            BOOST_MESSAGE(\"Failed to see failure on round \" << i << \" only counted \" << n_calls << \" flags (by atomic).\");\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            fail_queue.TEST_erase_log();\n+            BOOST_REQUIRE(success);\n+        }\n+        fail_queue.TEST_erase_log();\n+    }\n+    fPrintToConsole = false;\n+}\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_PriorityWorkQueue)\n+{\n+    CCheckQueue_Internals::PriorityWorkQueue<medium_queue> work(0, 16);\n+    auto m = 0;\n+    work.add(100);\n+    size_t x = 0;\n+    work.pop(x, false);\n+    BOOST_REQUIRE(x == 0);\n+    work.pop(x, false);\n+    BOOST_REQUIRE(x == 16);\n+    m = 2;\n+    while (work.pop(x, false)) {\n+        ++m;\n+    }\n+    BOOST_REQUIRE(m == 100);\n+    work.add(200);\n+    std::unordered_set<size_t> results;\n+    while (work.pop(x, false)) {\n+        results.insert(x);\n+        ++m;\n+    }\n+    for (auto i = 100; i < 200; ++i) {\n+        BOOST_REQUIRE(results.count(i));\n+        results.erase(i);\n+    }\n+    BOOST_REQUIRE(results.empty());\n+    BOOST_REQUIRE(m == 200);\n+\n+    work.add(300);\n+    work.pop(x, false);\n+    work.add(400);\n+    do {\n+        results.insert(x);\n+        ++m;\n+    } while (work.pop(x, false));\n+    for (auto i = 200; i < 400; ++i) {\n+        BOOST_REQUIRE(results.count(i));\n+        results.erase(i);\n+    }\n+    for (auto i : results)\n+        BOOST_TEST_MESSAGE(\"\" << i);\n+\n+    BOOST_REQUIRE(results.empty());\n+    BOOST_REQUIRE(m == 400);\n+}\n+\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_job_array)\n+{\n+    boost::thread_group threadGroup;\n+    static CCheckQueue_Internals::job_array<big_queue_proto> jobs;\n+    static std::atomic<size_t> m;\n+    for (size_t i = 0; i < big_queue::MAX_JOBS; ++i)\n+        jobs.reset_flag(i);\n+    m = 0;\n+    threadGroup.create_thread([]() {\n+            for (size_t i = 0; i < big_queue::MAX_JOBS; ++i)\n+            m += jobs.reserve(i) ? 1 : 0;\n+    });\n+\n+    threadGroup.create_thread([]() {\n+            for (size_t i = 0; i < big_queue::MAX_JOBS; ++i)\n+            m += jobs.reserve(i) ? 1 : 0;\n+    });\n+    threadGroup.join_all();\n+\n+    BOOST_REQUIRE(m == big_queue::MAX_JOBS);\n+}\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_round_barrier)\n+{\n+    boost::thread_group threadGroup;\n+    static CCheckQueue_Internals::round_barrier<big_queue> barrier;\n+    size_t nThreads = 8;\n+    barrier.init(nThreads);\n+    for (size_t i = 0; i < nThreads; ++i)\n+        barrier.reset(i);\n+    for (size_t i = 0; i < nThreads; ++i)\n+        threadGroup.create_thread([=]() {\n+            barrier.mark_done(i);\n+            while (!barrier.load_done());\n+        });\n+\n+    threadGroup.join_all();\n+}\n+\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_consume)\n+{\n+    struct FakeJobNoWork {\n+        bool operator()()\n+        {\n+            return true;\n+        }\n+        void swap(FakeJobNoWork& x){};\n+    };\n+    static CCheckQueue<FakeJobNoWork, (size_t)100000, 10, testing_level::enable_functions> fast_queue{};\n+    size_t nThreads = 8;\n+    fast_queue.init(nThreads);\n+    std::array<std::atomic<size_t>, 8> results;\n+    std::atomic<size_t> spawned{0};\n+\n+    boost::thread_group threadGroup;\n+\n+    for (auto& a : results)\n+        a = 0;\n+    for (size_t i = 0; i < nThreads; ++i)\n+        threadGroup.create_thread([&, i]() {\n+            ++spawned;\n+            results[i] = fast_queue.TEST_consume(i);\n+        });\n+\n+    threadGroup.create_thread([&]() {\n+        while (spawned != nThreads);\n+        for (auto y = 0; y < 10; ++y) {\n+            std::vector<FakeJobNoWork> w;\n+            for (auto x = 0; x< 100; ++x) {\n+                w.push_back(FakeJobNoWork{});\n+            }\n+            fast_queue.Add(w);\n+            MilliSleep(1);\n+        }\n+        fast_queue.TEST_set_masterJoined(true);\n+    });\n+\n+    threadGroup.join_all();\n+\n+\n+    for (auto& a : results) {\n+        if (a != 1000) {\n+            BOOST_TEST_MESSAGE(\"Error, Got: \" << a);\n+            BOOST_REQUIRE(a == 1000);\n+        }\n+    }\n+    size_t count = fast_queue.TEST_count_set_flags();\n+    BOOST_TEST_MESSAGE(\"Got: \" << count);\n+    BOOST_REQUIRE(count == 1000);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Performance)\n+{\n+    struct FakeJobNoWork {\n+        bool operator()()\n+        {\n+            return true;\n+        }\n+        void swap(FakeJobNoWork& x){};\n+    };\n+    static CCheckQueue<FakeJobNoWork, (size_t)100000, 16> fast_queue;\n+    size_t nThreads = 8;\n+    fast_queue.init(nThreads);\n+\n+    std::vector<FakeJobNoWork> vChecks;\n+    vChecks.reserve(100);\n+    auto start_time = GetTimeMicros();\n+    size_t ROUNDS = 10000;\n+    for (size_t i = 0; i < ROUNDS; ++i) {\n+        size_t total = 0;\n+        {\n+            CCheckQueueControl<decltype(fast_queue)> control(&fast_queue);\n+            for (size_t j = 0; j < 101; ++j) {\n+                size_t r = 30;\n+                total += r;\n+                vChecks.clear();\n+                for (size_t k = 0; k < r; ++k)\n+                    vChecks.push_back(FakeJobNoWork{});\n+                control.Add(vChecks);\n+            }\n+        }\n+    }\n+    auto end_time = GetTimeMicros();\n+    BOOST_TEST_MESSAGE(\"Perf Test took \" << end_time - start_time << \" microseconds for \" << ROUNDS << \" rounds, \" << (ROUNDS * 1000000.0) / (end_time - start_time) << \"rps\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct)\n+{\n+    static std::atomic<size_t> n_calls;\n+    struct FakeJobCheckCompletion {\n+        bool operator()()\n+        {\n+            ++n_calls;\n+            return true;\n+        }\n+        void swap(FakeJobCheckCompletion& x){};\n+    };\n+    static CCheckQueue<FakeJobCheckCompletion, (size_t)100, 16> small_queue;\n+    size_t nThreads = 8;\n+    small_queue.init(nThreads);\n+\n+    for (size_t i = 0; i < 101; ++i) {\n+        size_t total = i;\n+        n_calls = 0;\n+        {\n+            CCheckQueueControl<decltype(small_queue)> control(&small_queue);\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<FakeJobCheckCompletion> vChecks;\n+                vChecks.reserve(r);\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    vChecks.push_back(FakeJobCheckCompletion{});\n+                }\n+                control.Add(vChecks);\n+            }\n+        }\n+        if (n_calls != i) {\n+            BOOST_REQUIRE(n_calls == i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << n_calls);\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "9c6b136473b9605b6c4927ad4444f97b403c7169",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YzZiMTM2NDczYjk2MDViNmM0OTI3YWQ0NDQ0Zjk3YjQwM2M3MTY5",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-05T13:05:59Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "directly emplace jobs rather than create & swap",
      "tree": {
        "sha": "417a4b6ed31404ce48160326af4de94616ed714c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/417a4b6ed31404ce48160326af4de94616ed714c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9c6b136473b9605b6c4927ad4444f97b403c7169",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9c6b136473b9605b6c4927ad4444f97b403c7169",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9c6b136473b9605b6c4927ad4444f97b403c7169",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9c6b136473b9605b6c4927ad4444f97b403c7169/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9d10b67aec18932f0d1380a2042645e0f5e7ed76",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9d10b67aec18932f0d1380a2042645e0f5e7ed76",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9d10b67aec18932f0d1380a2042645e0f5e7ed76"
      }
    ],
    "stats": {
      "total": 48,
      "additions": 36,
      "deletions": 12
    },
    "files": [
      {
        "sha": "621885d485988e395c025e5fa74be98faa627dcf",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9c6b136473b9605b6c4927ad4444f97b403c7169/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9c6b136473b9605b6c4927ad4444f97b403c7169/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=9c6b136473b9605b6c4927ad4444f97b403c7169",
        "patch": "@@ -51,6 +51,9 @@ class job_array\n         for (typename Q::JOB_TYPE& check : vChecks)\n             check.swap(*(next_free_index++));\n     }\n+    typename decltype(checks)::iterator * get_next_free_index() {\n+        return &next_free_index;\n+    }\n \n     /** reserve tries to set a flag for an element \n              * and returns if it was successful */\n@@ -472,6 +475,13 @@ class CCheckQueue\n                         << \"Added \" << vs << \" values. nTodo was \" << status.nTodo.load() - vs << \" now is \" << status.nTodo.load() << \" \\n\";\n     }\n \n+    void Add(std::ptrdiff_t vs)\n+    {\n+        status.nTodo.fetch_add(vs);\n+        if (TEST & testing_level::enable_logging)\n+            test_log[0] << \"[[\" << ++test_log_seq << \"]] \"\n+                        << \"Added \" << vs << \" values. nTodo was \" << status.nTodo.load() - vs << \" now is \" << status.nTodo.load() << \" \\n\";\n+    }\n     ~CCheckQueue()\n     {\n     }\n@@ -495,6 +505,11 @@ class CCheckQueue\n         should_sleep.store(true);\n     }\n \n+\n+    JOB_TYPE ** get_next_free_index() {\n+        return jobs.get_next_free_index();\n+    }\n+\n     size_t TEST_consume(const size_t ID)\n     {\n         return TEST & testing_level::enable_functions ? consume(ID) : 0;\n@@ -579,6 +594,15 @@ class CCheckQueueControl\n         if (pqueue != NULL)\n             pqueue->Add(vChecks);\n     }\n+    void Add(std::ptrdiff_t d)\n+    {\n+        if (pqueue != NULL)\n+            pqueue->Add(d);\n+    }\n+\n+    typename Q::JOB_TYPE ** get_next_free_index() {\n+        return pqueue ? pqueue->get_next_free_index() : nullptr;\n+    }\n \n     ~CCheckQueueControl()\n     {"
      },
      {
        "sha": "d76bf23c280cb4e500837d69480bc4e898e0f220",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9c6b136473b9605b6c4927ad4444f97b403c7169/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9c6b136473b9605b6c4927ad4444f97b403c7169/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=9c6b136473b9605b6c4927ad4444f97b403c7169",
        "patch": "@@ -1969,15 +1969,13 @@ bool CheckTxInputs(const CTransaction& tx, CValidationState& state, const CCoins\n }\n }// namespace Consensus\n \n-bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheStore, std::vector<CScriptCheck> *pvChecks)\n+bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheStore, CScriptCheck **pvChecks)\n {\n     if (!tx.IsCoinBase())\n     {\n         if (!Consensus::CheckTxInputs(tx, state, inputs, GetSpendHeight(inputs)))\n             return false;\n \n-        if (pvChecks)\n-            pvChecks->reserve(tx.vin.size());\n \n         // The first loop above does all the inexpensive checks.\n         // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n@@ -1996,11 +1994,12 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                 assert(coins);\n \n                 // Verify signature\n-                CScriptCheck check(*coins, tx, i, flags, cacheStore);\n-                if (pvChecks) {\n-                    pvChecks->push_back(CScriptCheck());\n-                    check.swap(pvChecks->back());\n-                } else if (!check()) {\n+                CScriptCheck check;\n+                bool validMemory = pvChecks && *pvChecks;\n+                if (validMemory)\n+                    (*pvChecks)->~CScriptCheck();\n+                new(validMemory ? (*pvChecks)++ : &check) CScriptCheck(*coins, tx, i, flags, cacheStore);\n+                if (!validMemory && !check()) {\n                     if (flags & STANDARD_NOT_MANDATORY_VERIFY_FLAGS) {\n                         // Check whether the failure was caused by a\n                         // non-mandatory script verification check, such as\n@@ -2456,13 +2455,14 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n         {\n             nFees += view.GetValueIn(tx)-tx.GetValueOut();\n \n-            std::vector<CScriptCheck> vChecks;\n             bool fCacheResults = fJustCheck; /* Don't cache results if we're actually connecting blocks (still consult the cache, though) */\n-            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, nScriptCheckThreads ? &vChecks : NULL))\n+            CScriptCheck **  ptr = control.get_next_free_index();\n+            CScriptCheck * initial = *ptr;\n+            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, nScriptCheckThreads ? ptr : NULL))\n                 return error(\"ConnectBlock(): CheckInputs on %s failed with %s\",\n                     tx.GetHash().ToString(), FormatStateMessage(state));\n \n-            control.Add(vChecks);\n+            control.Add(std::distance(initial, *ptr));\n         }\n \n         CTxUndo undoDummy;"
      },
      {
        "sha": "9070d7cc99d91ce29a976a0bc7db6b64339783cf",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9c6b136473b9605b6c4927ad4444f97b403c7169/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9c6b136473b9605b6c4927ad4444f97b403c7169/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=9c6b136473b9605b6c4927ad4444f97b403c7169",
        "patch": "@@ -349,7 +349,7 @@ int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& i\n  * instead of being performed inline.\n  */\n bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &view, bool fScriptChecks,\n-                 unsigned int flags, bool cacheStore, std::vector<CScriptCheck> *pvChecks = NULL);\n+                 unsigned int flags, bool cacheStore, CScriptCheck **pvChecks = NULL);\n \n /** Apply the effects of this transaction on the UTXO set represented by view */\n void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, int nHeight);"
      }
    ]
  },
  {
    "sha": "f93524ed483546503b37c4480818989529984aa4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmOTM1MjRlZDQ4MzU0NjUwM2IzN2M0NDgwODE4OTg5NTI5OTg0YWE0",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-05T21:51:52Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "Remove BOOST_MESSAGE in test/checkqueue_tests.cpp because it's deprecated and breaks the build",
      "tree": {
        "sha": "51adea53fe03a54964921a556a0e5fe17df2c048",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/51adea53fe03a54964921a556a0e5fe17df2c048"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f93524ed483546503b37c4480818989529984aa4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f93524ed483546503b37c4480818989529984aa4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f93524ed483546503b37c4480818989529984aa4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f93524ed483546503b37c4480818989529984aa4/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9c6b136473b9605b6c4927ad4444f97b403c7169",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9c6b136473b9605b6c4927ad4444f97b403c7169",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9c6b136473b9605b6c4927ad4444f97b403c7169"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 0,
      "deletions": 2
    },
    "files": [
      {
        "sha": "e07f4284afc2e2a9016dc04d96ce221c7824f64f",
        "filename": "src/test/checkqueue_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f93524ed483546503b37c4480818989529984aa4/src/test/checkqueue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f93524ed483546503b37c4480818989529984aa4/src/test/checkqueue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkqueue_tests.cpp?ref=f93524ed483546503b37c4480818989529984aa4",
        "patch": "@@ -93,8 +93,6 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n                     nChecked++;\n             fail_queue.TEST_dump_log(nThreads);\n             fail_queue.TEST_erase_log();\n-            BOOST_MESSAGE(\"Failed to see failure on round \" << i << \" only counted \" << nChecked << \" flags (by job_array).\");\n-            BOOST_MESSAGE(\"Failed to see failure on round \" << i << \" only counted \" << n_calls << \" flags (by atomic).\");\n             BOOST_REQUIRE(!success);\n         } else if (i == 0) {\n             fail_queue.TEST_erase_log();"
      }
    ]
  },
  {
    "sha": "849f5ca6f512ca8d1981d8fd8e00bc5ecf915752",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4NDlmNWNhNmY1MTJjYThkMTk4MWQ4ZmQ4ZTAwYmM1ZWNmOTE1NzUy",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-05T22:21:21Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "turn compiler static_assert to pragma message",
      "tree": {
        "sha": "dfa47703162ba75aaa8227ead8dfdddb8b7b49a6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/dfa47703162ba75aaa8227ead8dfdddb8b7b49a6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/849f5ca6f512ca8d1981d8fd8e00bc5ecf915752",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/849f5ca6f512ca8d1981d8fd8e00bc5ecf915752",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/849f5ca6f512ca8d1981d8fd8e00bc5ecf915752",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/849f5ca6f512ca8d1981d8fd8e00bc5ecf915752/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f93524ed483546503b37c4480818989529984aa4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f93524ed483546503b37c4480818989529984aa4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f93524ed483546503b37c4480818989529984aa4"
      }
    ],
    "stats": {
      "total": 15,
      "additions": 11,
      "deletions": 4
    },
    "files": [
      {
        "sha": "383ad667ad34d02c749e5b008159f2b2bea48956",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 11,
        "deletions": 4,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/849f5ca6f512ca8d1981d8fd8e00bc5ecf915752/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/849f5ca6f512ca8d1981d8fd8e00bc5ecf915752/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=849f5ca6f512ca8d1981d8fd8e00bc5ecf915752",
        "patch": "@@ -13,10 +13,17 @@\n #include <chrono>\n #include <sstream>\n #include <iostream>\n-// This should be ignored eventually, but needs testing to ensure this works on more platforms\n-static_assert(ATOMIC_BOOL_LOCK_FREE, \"shared_status not lock free\");\n-static_assert(ATOMIC_LONG_LOCK_FREE, \"shared_status not lock free\");\n-static_assert(ATOMIC_LLONG_LOCK_FREE, \"shared_status not lock free\");\n+\n+\n+#ifndef ATOMIC_BOOL_LOCK_FREE\n+#pragma message(\"std::atomic<bool> is not lock free\")\n+#endif\n+#ifndef ATOMIC_LONG_LOCK_FREE\n+#pragma message(\"std::atomic<uint32_t> is not lock free\")\n+#endif\n+#ifndef ATOMIC_LLONG_LOCK_FREE\n+#pragma message(\"std::atomic<uint64_t> is not lock free\")\n+#endif\n \n \n /** CCheckQueue_Internals contains various components that otherwise could live inside"
      }
    ]
  },
  {
    "sha": "ec12a438bbdd9b2824e50e217c43c91e5b292dc0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplYzEyYTQzOGJiZGQ5YjI4MjRlNTBlMjE3YzQzYzkxZTViMjkyZGMw",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-06T02:16:42Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "Make the testing setup of CCheckQueue threads only occur one time, which can cause tests to hang otherwise. (Maybe the one time setup is something that should make it into the SetupCCheckQueue code itself)",
      "tree": {
        "sha": "35baf4e1fa6220f69d507eff2f5a4338907da751",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/35baf4e1fa6220f69d507eff2f5a4338907da751"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ec12a438bbdd9b2824e50e217c43c91e5b292dc0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ec12a438bbdd9b2824e50e217c43c91e5b292dc0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ec12a438bbdd9b2824e50e217c43c91e5b292dc0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ec12a438bbdd9b2824e50e217c43c91e5b292dc0/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "849f5ca6f512ca8d1981d8fd8e00bc5ecf915752",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/849f5ca6f512ca8d1981d8fd8e00bc5ecf915752",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/849f5ca6f512ca8d1981d8fd8e00bc5ecf915752"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 4,
      "deletions": 1
    },
    "files": [
      {
        "sha": "5e6073daac704071aead1f66f6d75abde64f5fa1",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ec12a438bbdd9b2824e50e217c43c91e5b292dc0/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ec12a438bbdd9b2824e50e217c43c91e5b292dc0/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=ec12a438bbdd9b2824e50e217c43c91e5b292dc0",
        "patch": "@@ -47,6 +47,7 @@ BasicTestingSetup::~BasicTestingSetup()\n \n TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(chainName)\n {\n+    static std::atomic_flag one_time_setup = ATOMIC_FLAG_INIT;\n     const CChainParams& chainparams = Params();\n         // Ideally we'd move all the RPC tests to the functional testing framework\n         // instead of unit tests, but for now we need these here.\n@@ -66,7 +67,9 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n             BOOST_CHECK(ok);\n         }\n         nScriptCheckThreads = 3;\n-        SetupCCheckQueue(nScriptCheckThreads);\n+\n+        if (!one_time_setup.test_and_set())\n+            SetupCCheckQueue(nScriptCheckThreads);\n         RegisterNodeSignals(GetNodeSignals());\n }\n "
      }
    ]
  },
  {
    "sha": "211d4bb2b6fced0af1f1900fb5c4af28515fb12a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMTFkNGJiMmI2ZmNlZDBhZjFmMTkwMGZiNWM0YWYyODUxNWZiMTJh",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-09T18:44:47Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "Explicit shutdown of checkqueue as implicit thread collection seemed to cause segfaults",
      "tree": {
        "sha": "041f51a2558dff7fdce1c03056b8c304372604a1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/041f51a2558dff7fdce1c03056b8c304372604a1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/211d4bb2b6fced0af1f1900fb5c4af28515fb12a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/211d4bb2b6fced0af1f1900fb5c4af28515fb12a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/211d4bb2b6fced0af1f1900fb5c4af28515fb12a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/211d4bb2b6fced0af1f1900fb5c4af28515fb12a/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ec12a438bbdd9b2824e50e217c43c91e5b292dc0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ec12a438bbdd9b2824e50e217c43c91e5b292dc0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ec12a438bbdd9b2824e50e217c43c91e5b292dc0"
      }
    ],
    "stats": {
      "total": 152,
      "additions": 111,
      "deletions": 41
    },
    "files": [
      {
        "sha": "a48b794bd763041e08bc5bc6dd06c86353259009",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 74,
        "deletions": 30,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/211d4bb2b6fced0af1f1900fb5c4af28515fb12a/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/211d4bb2b6fced0af1f1900fb5c4af28515fb12a/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=211d4bb2b6fced0af1f1900fb5c4af28515fb12a",
        "patch": "@@ -26,6 +26,28 @@\n #endif\n \n \n+/** Forward Declaration on CCheckQueue. Note default no testing. */\n+enum testing_level : int {\n+    disabled = 0,\n+    enable_functions = 1,\n+    enable_logging = 2\n+};\n+constexpr testing_level operator&(testing_level a, testing_level b)\n+{\n+    return static_cast<testing_level>(static_cast<int>(a) & static_cast<int>(b));\n+}\n+\n+constexpr testing_level operator|(testing_level a, testing_level b)\n+{\n+    return static_cast<testing_level>(static_cast<int>(a) | static_cast<int>(b));\n+}\n+template <typename T, size_t J, size_t W, testing_level TEST_ENABLE = testing_level::disabled>\n+class CCheckQueue;\n+/** Forward Declaration on CCheckQueueControl */\n+template <typename Q>\n+class CCheckQueueControl;\n+\n+\n /** CCheckQueue_Internals contains various components that otherwise could live inside\n  * of CCheckQueue, but is separate for easier testability and modularity */\n namespace CCheckQueue_Internals\n@@ -58,7 +80,8 @@ class job_array\n         for (typename Q::JOB_TYPE& check : vChecks)\n             check.swap(*(next_free_index++));\n     }\n-    typename decltype(checks)::iterator * get_next_free_index() {\n+    typename decltype(checks)::iterator* get_next_free_index()\n+    {\n         return &next_free_index;\n     }\n \n@@ -274,22 +297,6 @@ struct status_container {\n  * @tparam W the maximum number of workers possible\n  */\n \n-enum testing_level : int {\n-    disabled = 0,\n-    enable_functions = 1,\n-    enable_logging = 2\n-};\n-constexpr testing_level operator&(testing_level a, testing_level b)\n-{\n-    return static_cast<testing_level>(static_cast<int>(a) & static_cast<int>(b));\n-}\n-\n-constexpr testing_level operator|(testing_level a, testing_level b)\n-{\n-    return static_cast<testing_level>(static_cast<int>(a) | static_cast<int>(b));\n-}\n-template <typename T, size_t J, size_t W, testing_level TEST_ENABLE = testing_level::disabled>\n-class CCheckQueue;\n template <typename T, size_t J, size_t W, testing_level TEST_ENABLE>\n class CCheckQueue\n {\n@@ -304,23 +311,47 @@ class CCheckQueue\n     CCheckQueue_Internals::job_array<CCheckQueue<T, J, W, TEST> > jobs;\n     CCheckQueue_Internals::status_container<CCheckQueue<T, J, W, TEST> > status;\n     CCheckQueue_Internals::round_barrier<CCheckQueue<T, J, W, TEST> > done_round;\n-    std::atomic<bool> should_sleep;\n+    struct sleep_status {\n+        struct states {\n+            static const uint8_t asleep_alive = 0b00000001;\n+            static const uint8_t awake_alive = 0b00000000;\n+            static const uint8_t asleep_dead = 0b00000011;\n+            static const uint8_t awake_dead = 0b00000010;\n+        };\n+        struct switches {\n+            static const uint8_t kill_or = 0b00000010;\n+            static const uint8_t wakeup_and = 0b11111110;\n+            static const uint8_t sleep_or = 0b00000001;\n+        };\n+    };\n+    std::atomic<uint8_t> should_sleep;\n     size_t RT_N_SCRIPTCHECK_THREADS;\n \n     //state only for testing\n     mutable std::atomic<size_t> test_log_seq;\n     mutable std::array<std::ostringstream, MAX_WORKERS> test_log;\n+    std::vector<std::thread> threads;\n \n \n     void wait_all_finished_cleanup() const\n     {\n         while (status.nFinishedCleanup.load() != RT_N_SCRIPTCHECK_THREADS - 1)\n             ;\n     }\n-    void maybe_sleep() const\n+    bool maybe_sleep() const\n     {\n-        while (should_sleep)\n-            std::this_thread::sleep_for(std::chrono::microseconds(100));\n+        for (;;) {\n+            switch (should_sleep.load()) {\n+            case sleep_status::states::asleep_alive:\n+                std::this_thread::sleep_for(std::chrono::microseconds(1));\n+                break;\n+            case sleep_status::states::awake_alive:\n+                return false;\n+            case sleep_status::states::asleep_dead: // covers dead && awake\n+            case sleep_status::states::awake_dead:\n+                return true;\n+            }\n+        }\n     }\n \n     size_t consume(const size_t ID)\n@@ -348,8 +379,10 @@ class CCheckQueue\n     bool Loop(const size_t ID)\n     {\n         for (;;) {\n-            if (ID != 0)\n-                maybe_sleep();\n+            if (maybe_sleep()) {\n+                LogPrintf(\"CCheckQueue @%#010x Worker %q shutting down\\n\", this, ID);\n+                return status.fAllOk.load();\n+            }\n \n             if (TEST & testing_level::enable_logging)\n                 test_log[ID] << \"[[\" << ++test_log_seq << \"]] \"\n@@ -434,7 +467,7 @@ class CCheckQueue\n     }\n \n public:\n-    CCheckQueue() : jobs(), status(), done_round(), should_sleep(true), RT_N_SCRIPTCHECK_THREADS(0), test_log_seq(0)\n+    CCheckQueue() : jobs(), status(), done_round(), should_sleep(sleep_status::states::asleep_alive), RT_N_SCRIPTCHECK_THREADS(0), test_log_seq(0)\n     {\n     }\n \n@@ -454,6 +487,7 @@ class CCheckQueue\n     void Thread(size_t ID)\n     {\n         RenameThread(\"bitcoin-scriptcheck\");\n+        LogPrintf(\"Starting CCheckQueue Worker %q on CCheckQueue %#010x\\n\", ID, this);\n         Loop(ID);\n     }\n \n@@ -491,6 +525,7 @@ class CCheckQueue\n     }\n     ~CCheckQueue()\n     {\n+        quit();\n     }\n \n     void init(const size_t RT_N_SCRIPTCHECK_THREADS_)\n@@ -499,21 +534,29 @@ class CCheckQueue\n         done_round.init(RT_N_SCRIPTCHECK_THREADS);\n \n         for (size_t id = 1; id < RT_N_SCRIPTCHECK_THREADS; ++id) {\n-            std::thread t([=]() {Loop(id); });\n-            t.detach();\n+            std::thread t([=]() {Thread(id); });\n+            threads.push_back(std::move(t));\n         }\n     }\n     void wakeup()\n     {\n-        should_sleep.store(false);\n+        should_sleep.fetch_and(sleep_status::switches::wakeup_and);\n     }\n     void sleep()\n     {\n-        should_sleep.store(true);\n+        should_sleep.fetch_or(sleep_status::switches::sleep_or);\n+    }\n+    void quit()\n+    {\n+        should_sleep.fetch_or(sleep_status::switches::kill_or);\n+        for (auto& t : threads)\n+            t.join();\n+        threads.clear();\n     }\n \n \n-    JOB_TYPE ** get_next_free_index() {\n+    JOB_TYPE** get_next_free_index()\n+    {\n         return jobs.get_next_free_index();\n     }\n \n@@ -607,7 +650,8 @@ class CCheckQueueControl\n             pqueue->Add(d);\n     }\n \n-    typename Q::JOB_TYPE ** get_next_free_index() {\n+    typename Q::JOB_TYPE** get_next_free_index()\n+    {\n         return pqueue ? pqueue->get_next_free_index() : nullptr;\n     }\n "
      },
      {
        "sha": "5dbed61fb1ab8f07caba682f034fa1d0234f20da",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/211d4bb2b6fced0af1f1900fb5c4af28515fb12a/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/211d4bb2b6fced0af1f1900fb5c4af28515fb12a/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=211d4bb2b6fced0af1f1900fb5c4af28515fb12a",
        "patch": "@@ -199,6 +199,7 @@ void Shutdown()\n #endif\n     StopNode();\n     StopTorControl();\n+    StopCCheckQueue();\n     UnregisterNodeSignals(GetNodeSignals());\n \n     if (fFeeEstimatesInitialized)"
      },
      {
        "sha": "e3d7530b237d09f4f0ec4ee7338c6d48c981e1a5",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/211d4bb2b6fced0af1f1900fb5c4af28515fb12a/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/211d4bb2b6fced0af1f1900fb5c4af28515fb12a/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=211d4bb2b6fced0af1f1900fb5c4af28515fb12a",
        "patch": "@@ -2232,7 +2232,8 @@ bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos, unsigne\n \n static CCheckQueue<CScriptCheck, MAX_SCRIPTCHECKS, MAX_SCRIPTCHECK_THREADS> scriptcheckqueue;\n void StopCCheckQueue() {\n-\n+    LogPrintf(\"Shutting down CCheckQueue\\n\");\n+    scriptcheckqueue.quit();\n };\n void SetupCCheckQueue(size_t RT_N_SCRIPTCHECK_THREADS) {\n     scriptcheckqueue.init(RT_N_SCRIPTCHECK_THREADS);"
      },
      {
        "sha": "24b792ef6fe653ed580375e7e2e6801028776ab6",
        "filename": "src/test/checkqueue_tests.cpp",
        "status": "modified",
        "additions": 34,
        "deletions": 10,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/211d4bb2b6fced0af1f1900fb5c4af28515fb12a/src/test/checkqueue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/211d4bb2b6fced0af1f1900fb5c4af28515fb12a/src/test/checkqueue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkqueue_tests.cpp?ref=211d4bb2b6fced0af1f1900fb5c4af28515fb12a",
        "patch": "@@ -10,9 +10,9 @@\n \n #include <boost/test/unit_test.hpp>\n #include <atomic>\n+#include <thread>\n+#include <vector>\n \n-#include <boost/thread.hpp>\n-#include <boost/bind.hpp>\n #include <unordered_set>\n \n #include \"random.h\"\n@@ -21,6 +21,25 @@ BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, BasicTestingSetup)\n // Logging off by default because of memory leak\n static const testing_level TEST = testing_level::enable_functions;\n \n+class RAII_ThreadGroup {\n+    std::vector<std::thread> threadGroup;\n+    public:\n+    template <typename Callable>\n+    void create_thread(Callable c) {\n+        std::thread t(c);\n+        threadGroup.push_back(std::move(t));\n+    };\n+    void join_all(){\n+        for (auto& t: threadGroup)\n+            t.join();\n+        threadGroup.clear();\n+    };\n+    ~RAII_ThreadGroup() {\n+        join_all();\n+    };\n+\n+};\n+\n struct FakeJob {\n };\n \n@@ -150,40 +169,43 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_PriorityWorkQueue)\n \n BOOST_AUTO_TEST_CASE(test_CheckQueue_job_array)\n {\n-    boost::thread_group threadGroup;\n     static CCheckQueue_Internals::job_array<big_queue_proto> jobs;\n     static std::atomic<size_t> m;\n     for (size_t i = 0; i < big_queue::MAX_JOBS; ++i)\n         jobs.reset_flag(i);\n     m = 0;\n-    threadGroup.create_thread([]() {\n+    std::thread t([]() {\n             for (size_t i = 0; i < big_queue::MAX_JOBS; ++i)\n             m += jobs.reserve(i) ? 1 : 0;\n     });\n \n-    threadGroup.create_thread([]() {\n+\n+    std::thread t2([]() {\n             for (size_t i = 0; i < big_queue::MAX_JOBS; ++i)\n             m += jobs.reserve(i) ? 1 : 0;\n     });\n-    threadGroup.join_all();\n+    t.join();\n+    t2.join();\n \n     BOOST_REQUIRE(m == big_queue::MAX_JOBS);\n }\n BOOST_AUTO_TEST_CASE(test_CheckQueue_round_barrier)\n {\n-    boost::thread_group threadGroup;\n+    RAII_ThreadGroup threadGroup;\n     static CCheckQueue_Internals::round_barrier<big_queue> barrier;\n     size_t nThreads = 8;\n     barrier.init(nThreads);\n     for (size_t i = 0; i < nThreads; ++i)\n         barrier.reset(i);\n-    for (size_t i = 0; i < nThreads; ++i)\n+    for (size_t i = 0; i < nThreads; ++i) {\n         threadGroup.create_thread([=]() {\n             barrier.mark_done(i);\n             while (!barrier.load_done());\n         });\n+    }\n \n     threadGroup.join_all();\n+\n }\n \n BOOST_AUTO_TEST_CASE(test_CheckQueue_consume)\n@@ -201,15 +223,16 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_consume)\n     std::array<std::atomic<size_t>, 8> results;\n     std::atomic<size_t> spawned{0};\n \n-    boost::thread_group threadGroup;\n+    RAII_ThreadGroup threadGroup;\n \n     for (auto& a : results)\n         a = 0;\n-    for (size_t i = 0; i < nThreads; ++i)\n+    for (size_t i = 0; i < nThreads; ++i) {\n         threadGroup.create_thread([&, i]() {\n             ++spawned;\n             results[i] = fast_queue.TEST_consume(i);\n         });\n+    }\n \n     threadGroup.create_thread([&]() {\n         while (spawned != nThreads);\n@@ -227,6 +250,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_consume)\n     threadGroup.join_all();\n \n \n+\n     for (auto& a : results) {\n         if (a != 1000) {\n             BOOST_TEST_MESSAGE(\"Error, Got: \" << a);"
      }
    ]
  },
  {
    "sha": "fec0fdceb5223d34a3ec46393ea5b21564300f6e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZWMwZmRjZWI1MjIzZDM0YTNlYzQ2MzkzZWE1YjIxNTY0MzAwZjZl",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-09T23:59:16Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "Decrease number of threads for testing depending on platform",
      "tree": {
        "sha": "b60d9364a7d56bf99c7116145e170aaf0ad9d14b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b60d9364a7d56bf99c7116145e170aaf0ad9d14b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fec0fdceb5223d34a3ec46393ea5b21564300f6e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fec0fdceb5223d34a3ec46393ea5b21564300f6e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fec0fdceb5223d34a3ec46393ea5b21564300f6e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fec0fdceb5223d34a3ec46393ea5b21564300f6e/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "211d4bb2b6fced0af1f1900fb5c4af28515fb12a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/211d4bb2b6fced0af1f1900fb5c4af28515fb12a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/211d4bb2b6fced0af1f1900fb5c4af28515fb12a"
      }
    ],
    "stats": {
      "total": 60,
      "additions": 28,
      "deletions": 32
    },
    "files": [
      {
        "sha": "49e5e59665b6000c9243a77de87f564ee6342903",
        "filename": "src/test/checkqueue_tests.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 31,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec0fdceb5223d34a3ec46393ea5b21564300f6e/src/test/checkqueue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec0fdceb5223d34a3ec46393ea5b21564300f6e/src/test/checkqueue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkqueue_tests.cpp?ref=fec0fdceb5223d34a3ec46393ea5b21564300f6e",
        "patch": "@@ -4,10 +4,10 @@\n \n #include \"util.h\"\n #include \"utiltime.h\"\n+#include \"main.h\"\n \n #include \"test/test_bitcoin.h\"\n #include \"checkqueue.h\"\n-\n #include <boost/test/unit_test.hpp>\n #include <atomic>\n #include <thread>\n@@ -16,7 +16,7 @@\n #include <unordered_set>\n \n #include \"random.h\"\n-BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, BasicTestingSetup)\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n \n // Logging off by default because of memory leak\n static const testing_level TEST = testing_level::enable_functions;\n@@ -43,8 +43,8 @@ class RAII_ThreadGroup {\n struct FakeJob {\n };\n \n-typedef CCheckQueue<FakeJob, (size_t)100000, 16, TEST> big_queue;\n-typedef CCheckQueue<FakeJob, (size_t)2000, 16, TEST> medium_queue;\n+typedef CCheckQueue<FakeJob, (size_t)100000, MAX_SCRIPTCHECK_THREADS, TEST> big_queue;\n+typedef CCheckQueue<FakeJob, (size_t)2000, MAX_SCRIPTCHECK_THREADS, TEST> medium_queue;\n \n struct big_queue_proto {\n     typedef big_queue::JOB_TYPE JOB_TYPE;\n@@ -76,9 +76,8 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n             std::swap(tag, x.tag);\n         };\n     };\n-    static CCheckQueue<FailingJob, (size_t)1000, 16, testing_level::enable_functions> fail_queue;\n-    size_t nThreads = 8;\n-    fail_queue.init(nThreads);\n+    static CCheckQueue<FailingJob, (size_t)1000, MAX_SCRIPTCHECK_THREADS, testing_level::enable_functions> fail_queue;\n+    fail_queue.init(nScriptCheckThreads);\n \n     for (size_t i = 10; i < 1001; ++i) {\n         n_calls = 0;\n@@ -110,7 +109,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n             for (size_t x = 0; x < i; ++x)\n                 if ((*jobs)[x].call_state)\n                     nChecked++;\n-            fail_queue.TEST_dump_log(nThreads);\n+            fail_queue.TEST_dump_log(nScriptCheckThreads);\n             fail_queue.TEST_erase_log();\n             BOOST_REQUIRE(!success);\n         } else if (i == 0) {\n@@ -175,13 +174,13 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_job_array)\n         jobs.reset_flag(i);\n     m = 0;\n     std::thread t([]() {\n-            for (size_t i = 0; i < big_queue::MAX_JOBS; ++i)\n+        for (size_t i = 0; i < big_queue::MAX_JOBS; ++i)\n             m += jobs.reserve(i) ? 1 : 0;\n     });\n \n \n     std::thread t2([]() {\n-            for (size_t i = 0; i < big_queue::MAX_JOBS; ++i)\n+        for (size_t i = 0; i < big_queue::MAX_JOBS; ++i)\n             m += jobs.reserve(i) ? 1 : 0;\n     });\n     t.join();\n@@ -193,11 +192,10 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_round_barrier)\n {\n     RAII_ThreadGroup threadGroup;\n     static CCheckQueue_Internals::round_barrier<big_queue> barrier;\n-    size_t nThreads = 8;\n-    barrier.init(nThreads);\n-    for (size_t i = 0; i < nThreads; ++i)\n+    barrier.init(nScriptCheckThreads);\n+    for (int i = 0; i < nScriptCheckThreads; ++i)\n         barrier.reset(i);\n-    for (size_t i = 0; i < nThreads; ++i) {\n+    for (int i = 0; i < nScriptCheckThreads; ++i) {\n         threadGroup.create_thread([=]() {\n             barrier.mark_done(i);\n             while (!barrier.load_done());\n@@ -217,25 +215,24 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_consume)\n         }\n         void swap(FakeJobNoWork& x){};\n     };\n-    static CCheckQueue<FakeJobNoWork, (size_t)100000, 10, testing_level::enable_functions> fast_queue{};\n-    size_t nThreads = 8;\n-    fast_queue.init(nThreads);\n-    std::array<std::atomic<size_t>, 8> results;\n-    std::atomic<size_t> spawned{0};\n+    static CCheckQueue<FakeJobNoWork, (size_t)100000, MAX_SCRIPTCHECK_THREADS, testing_level::enable_functions> fast_queue{};\n+    fast_queue.init(nScriptCheckThreads);\n+    std::array<std::atomic<size_t>, MAX_SCRIPTCHECK_THREADS> results;\n+    std::atomic<int> spawned{0};\n \n     RAII_ThreadGroup threadGroup;\n \n     for (auto& a : results)\n         a = 0;\n-    for (size_t i = 0; i < nThreads; ++i) {\n+    for (int i = 0; i < nScriptCheckThreads; ++i) {\n         threadGroup.create_thread([&, i]() {\n             ++spawned;\n             results[i] = fast_queue.TEST_consume(i);\n         });\n     }\n \n     threadGroup.create_thread([&]() {\n-        while (spawned != nThreads);\n+        while (spawned != nScriptCheckThreads);\n         for (auto y = 0; y < 10; ++y) {\n             std::vector<FakeJobNoWork> w;\n             for (auto x = 0; x< 100; ++x) {\n@@ -251,10 +248,11 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_consume)\n \n \n \n-    for (auto& a : results) {\n-        if (a != 1000) {\n-            BOOST_TEST_MESSAGE(\"Error, Got: \" << a);\n-            BOOST_REQUIRE(a == 1000);\n+    for (auto a = 0; a < nScriptCheckThreads; ++a) {\n+        auto v = results[a].load();\n+        if (v != 1000) {\n+            BOOST_TEST_MESSAGE(\"Error, Got: \" << v);\n+            BOOST_REQUIRE(v == 1000);\n         }\n     }\n     size_t count = fast_queue.TEST_count_set_flags();\n@@ -272,9 +270,8 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Performance)\n         }\n         void swap(FakeJobNoWork& x){};\n     };\n-    static CCheckQueue<FakeJobNoWork, (size_t)100000, 16> fast_queue;\n-    size_t nThreads = 8;\n-    fast_queue.init(nThreads);\n+    static CCheckQueue<FakeJobNoWork, (size_t)100000, MAX_SCRIPTCHECK_THREADS> fast_queue;\n+    fast_queue.init(nScriptCheckThreads);\n \n     std::vector<FakeJobNoWork> vChecks;\n     vChecks.reserve(100);\n@@ -309,9 +306,8 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct)\n         }\n         void swap(FakeJobCheckCompletion& x){};\n     };\n-    static CCheckQueue<FakeJobCheckCompletion, (size_t)100, 16> small_queue;\n-    size_t nThreads = 8;\n-    small_queue.init(nThreads);\n+    static CCheckQueue<FakeJobCheckCompletion, (size_t)100, MAX_SCRIPTCHECK_THREADS> small_queue;\n+    small_queue.init(nScriptCheckThreads);\n \n     for (size_t i = 0; i < 101; ++i) {\n         size_t total = i;"
      },
      {
        "sha": "b899b349718f0adc553a0029be7e422e4df79334",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fec0fdceb5223d34a3ec46393ea5b21564300f6e/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fec0fdceb5223d34a3ec46393ea5b21564300f6e/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=fec0fdceb5223d34a3ec46393ea5b21564300f6e",
        "patch": "@@ -66,7 +66,7 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n             bool ok = ActivateBestChain(state, chainparams);\n             BOOST_CHECK(ok);\n         }\n-        nScriptCheckThreads = 3;\n+        nScriptCheckThreads = std::max(3, GetNumCores()); // Take at least three cores\n \n         if (!one_time_setup.test_and_set())\n             SetupCCheckQueue(nScriptCheckThreads);"
      }
    ]
  },
  {
    "sha": "f4c719910e423676856db7334f94183995e59d9f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNGM3MTk5MTBlNDIzNjc2ODU2ZGI3MzM0Zjk0MTgzOTk1ZTU5ZDlm",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-11T18:06:08Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "Move benchmarking code into benchmark suite",
      "tree": {
        "sha": "d4347a74cf109c76749b74362a3a1bc90db4533a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d4347a74cf109c76749b74362a3a1bc90db4533a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f4c719910e423676856db7334f94183995e59d9f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f4c719910e423676856db7334f94183995e59d9f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f4c719910e423676856db7334f94183995e59d9f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f4c719910e423676856db7334f94183995e59d9f/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fec0fdceb5223d34a3ec46393ea5b21564300f6e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fec0fdceb5223d34a3ec46393ea5b21564300f6e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fec0fdceb5223d34a3ec46393ea5b21564300f6e"
      }
    ],
    "stats": {
      "total": 36,
      "additions": 2,
      "deletions": 34
    },
    "files": [
      {
        "sha": "5df9ce0ccfee3c7595cdd797bedea45100822edb",
        "filename": "src/Makefile.bench.include",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4c719910e423676856db7334f94183995e59d9f/src/Makefile.bench.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4c719910e423676856db7334f94183995e59d9f/src/Makefile.bench.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.bench.include?ref=f4c719910e423676856db7334f94183995e59d9f",
        "patch": "@@ -10,7 +10,8 @@ bench_bench_bitcoin_SOURCES = \\\n   bench/Examples.cpp \\\n   bench/rollingbloom.cpp \\\n   bench/crypto_hash.cpp \\\n-  bench/base58.cpp\n+  bench/base58.cpp \\\n+  bench/checkqueue.cpp\n \n bench_bench_bitcoin_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(EVENT_CLFAGS) $(EVENT_PTHREADS_CFLAGS) -I$(builddir)/bench/\n bench_bench_bitcoin_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)"
      },
      {
        "sha": "4aec63943d3a5a7a06aa9c2f89595fbb06da1e42",
        "filename": "src/test/checkqueue_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 33,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4c719910e423676856db7334f94183995e59d9f/src/test/checkqueue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4c719910e423676856db7334f94183995e59d9f/src/test/checkqueue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkqueue_tests.cpp?ref=f4c719910e423676856db7334f94183995e59d9f",
        "patch": "@@ -261,39 +261,6 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_consume)\n }\n \n \n-BOOST_AUTO_TEST_CASE(test_CheckQueue_Performance)\n-{\n-    struct FakeJobNoWork {\n-        bool operator()()\n-        {\n-            return true;\n-        }\n-        void swap(FakeJobNoWork& x){};\n-    };\n-    static CCheckQueue<FakeJobNoWork, (size_t)100000, MAX_SCRIPTCHECK_THREADS> fast_queue;\n-    fast_queue.init(nScriptCheckThreads);\n-\n-    std::vector<FakeJobNoWork> vChecks;\n-    vChecks.reserve(100);\n-    auto start_time = GetTimeMicros();\n-    size_t ROUNDS = 10000;\n-    for (size_t i = 0; i < ROUNDS; ++i) {\n-        size_t total = 0;\n-        {\n-            CCheckQueueControl<decltype(fast_queue)> control(&fast_queue);\n-            for (size_t j = 0; j < 101; ++j) {\n-                size_t r = 30;\n-                total += r;\n-                vChecks.clear();\n-                for (size_t k = 0; k < r; ++k)\n-                    vChecks.push_back(FakeJobNoWork{});\n-                control.Add(vChecks);\n-            }\n-        }\n-    }\n-    auto end_time = GetTimeMicros();\n-    BOOST_TEST_MESSAGE(\"Perf Test took \" << end_time - start_time << \" microseconds for \" << ROUNDS << \" rounds, \" << (ROUNDS * 1000000.0) / (end_time - start_time) << \"rps\");\n-}\n \n BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct)\n {"
      }
    ]
  },
  {
    "sha": "93c3742d4c180d7c0f2fc7cf9d0f090bf32e9e0c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5M2MzNzQyZDRjMTgwZDdjMGYyZmM3Y2Y5ZDBmMDkwYmYzMmU5ZTBj",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-11T18:12:49Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "Forgot to add the new benchmark",
      "tree": {
        "sha": "f66349a8b2a6ecd2258f592dcde3a5ab5dd93f13",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f66349a8b2a6ecd2258f592dcde3a5ab5dd93f13"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/93c3742d4c180d7c0f2fc7cf9d0f090bf32e9e0c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/93c3742d4c180d7c0f2fc7cf9d0f090bf32e9e0c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/93c3742d4c180d7c0f2fc7cf9d0f090bf32e9e0c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/93c3742d4c180d7c0f2fc7cf9d0f090bf32e9e0c/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f4c719910e423676856db7334f94183995e59d9f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f4c719910e423676856db7334f94183995e59d9f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f4c719910e423676856db7334f94183995e59d9f"
      }
    ],
    "stats": {
      "total": 40,
      "additions": 40,
      "deletions": 0
    },
    "files": [
      {
        "sha": "12850f41e853e4eedc325a41888a804064f3c717",
        "filename": "src/bench/checkqueue.cpp",
        "status": "added",
        "additions": 40,
        "deletions": 0,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/93c3742d4c180d7c0f2fc7cf9d0f090bf32e9e0c/src/bench/checkqueue.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/93c3742d4c180d7c0f2fc7cf9d0f090bf32e9e0c/src/bench/checkqueue.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkqueue.cpp?ref=93c3742d4c180d7c0f2fc7cf9d0f090bf32e9e0c",
        "patch": "@@ -0,0 +1,40 @@\n+\n+// Copyright (c) 2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"bench.h\"\n+#include \"util.h\"\n+#include \"main.h\"\n+#include <vector>\n+#include \"checkqueue.h\"\n+\n+static void CCheckQueueSpeed(benchmark::State& state)\n+{\n+    struct FakeJobNoWork {\n+        bool operator()()\n+        {\n+            return true;\n+        }\n+        void swap(FakeJobNoWork& x){};\n+    };\n+    static CCheckQueue<FakeJobNoWork, (size_t)100000, MAX_SCRIPTCHECK_THREADS> fast_queue;\n+    fast_queue.init(GetNumCores());\n+    std::vector<FakeJobNoWork> vChecks;\n+    vChecks.reserve(100);\n+    while (state.KeepRunning()) {\n+        size_t total = 0;\n+        {\n+            CCheckQueueControl<decltype(fast_queue)> control(&fast_queue);\n+            for (size_t j = 0; j < 101; ++j) {\n+                size_t r = 30;\n+                total += r;\n+                vChecks.clear();\n+                for (size_t k = 0; k < r; ++k)\n+                    vChecks.push_back(FakeJobNoWork{});\n+                control.Add(vChecks);\n+            }\n+        }\n+    }\n+}\n+BENCHMARK(CCheckQueueSpeed);"
      }
    ]
  },
  {
    "sha": "ff667f996a59af5e52916993388c59373b1b995a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZjY2N2Y5OTZhNTlhZjVlNTI5MTY5OTMzODhjNTkzNzNiMWI5OTVh",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-11T20:30:56Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "Remove static instances of big things in tests. Remove some type hackery",
      "tree": {
        "sha": "b942590067b89b5cf1ef3769da686627791560d9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b942590067b89b5cf1ef3769da686627791560d9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ff667f996a59af5e52916993388c59373b1b995a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ff667f996a59af5e52916993388c59373b1b995a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ff667f996a59af5e52916993388c59373b1b995a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ff667f996a59af5e52916993388c59373b1b995a/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "93c3742d4c180d7c0f2fc7cf9d0f090bf32e9e0c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/93c3742d4c180d7c0f2fc7cf9d0f090bf32e9e0c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/93c3742d4c180d7c0f2fc7cf9d0f090bf32e9e0c"
      }
    ],
    "stats": {
      "total": 102,
      "additions": 53,
      "deletions": 49
    },
    "files": [
      {
        "sha": "fe30e2b89681f6de98fc037464eb817656bacf26",
        "filename": "src/bench/checkqueue.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ff667f996a59af5e52916993388c59373b1b995a/src/bench/checkqueue.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ff667f996a59af5e52916993388c59373b1b995a/src/bench/checkqueue.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkqueue.cpp?ref=ff667f996a59af5e52916993388c59373b1b995a",
        "patch": "@@ -18,14 +18,15 @@ static void CCheckQueueSpeed(benchmark::State& state)\n         }\n         void swap(FakeJobNoWork& x){};\n     };\n-    static CCheckQueue<FakeJobNoWork, (size_t)100000, MAX_SCRIPTCHECK_THREADS> fast_queue;\n-    fast_queue.init(GetNumCores());\n+    typedef CCheckQueue<FakeJobNoWork, (size_t)100000, MAX_SCRIPTCHECK_THREADS> T;\n+    auto fast_queue = std::unique_ptr<T>(new T());\n+    fast_queue->init(GetNumCores());\n     std::vector<FakeJobNoWork> vChecks;\n     vChecks.reserve(100);\n     while (state.KeepRunning()) {\n         size_t total = 0;\n         {\n-            CCheckQueueControl<decltype(fast_queue)> control(&fast_queue);\n+            CCheckQueueControl<T> control(fast_queue.get());\n             for (size_t j = 0; j < 101; ++j) {\n                 size_t r = 30;\n                 total += r;"
      },
      {
        "sha": "cedd01199edc2defaf3a010b8e18999022d640b0",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ff667f996a59af5e52916993388c59373b1b995a/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ff667f996a59af5e52916993388c59373b1b995a/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=ff667f996a59af5e52916993388c59373b1b995a",
        "patch": "@@ -65,7 +65,7 @@ class job_array\n              * */\n     std::array<std::atomic_flag, Q::MAX_JOBS> flags;\n     /** used as the insertion point into the array. */\n-    typename decltype(checks)::iterator next_free_index;\n+    typename Q::JOB_TYPE* next_free_index;\n \n public:\n     job_array() : next_free_index(checks.begin())\n@@ -80,7 +80,7 @@ class job_array\n         for (typename Q::JOB_TYPE& check : vChecks)\n             check.swap(*(next_free_index++));\n     }\n-    typename decltype(checks)::iterator* get_next_free_index()\n+    typename Q::JOB_TYPE** get_next_free_index()\n     {\n         return &next_free_index;\n     }\n@@ -599,11 +599,13 @@ class CCheckQueue\n                 test_log[i].clear();\n             }\n     }\n-    decltype(status) * TEST_introspect_status()\n+\n+\n+    CCheckQueue_Internals::status_container<CCheckQueue<T, J, W, TEST> >* TEST_introspect_status()\n     {\n         return TEST & testing_level::enable_functions ? &status : nullptr;\n     }\n-    decltype(jobs) * TEST_introspect_jobs()\n+    CCheckQueue_Internals::job_array<CCheckQueue<T, J, W, TEST> >* TEST_introspect_jobs()\n     {\n         return TEST & testing_level::enable_functions ? &jobs : nullptr;\n     }"
      },
      {
        "sha": "afa46eb7d71f978053e78fbbfdb5066a36c3919a",
        "filename": "src/test/checkqueue_tests.cpp",
        "status": "modified",
        "additions": 43,
        "deletions": 42,
        "changes": 85,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ff667f996a59af5e52916993388c59373b1b995a/src/test/checkqueue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ff667f996a59af5e52916993388c59373b1b995a/src/test/checkqueue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkqueue_tests.cpp?ref=ff667f996a59af5e52916993388c59373b1b995a",
        "patch": "@@ -14,7 +14,7 @@\n #include <vector>\n \n #include <unordered_set>\n-\n+#include <memory>\n #include \"random.h\"\n BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n \n@@ -45,17 +45,12 @@ struct FakeJob {\n \n typedef CCheckQueue<FakeJob, (size_t)100000, MAX_SCRIPTCHECK_THREADS, TEST> big_queue;\n typedef CCheckQueue<FakeJob, (size_t)2000, MAX_SCRIPTCHECK_THREADS, TEST> medium_queue;\n-\n-struct big_queue_proto {\n-    typedef big_queue::JOB_TYPE JOB_TYPE;\n-    static const size_t MAX_JOBS = big_queue::MAX_JOBS;\n-    static const size_t MAX_WORKERS = big_queue::MAX_WORKERS;\n-};\n+typedef typename big_queue::JOB_TYPE JT; // This is a \"recursive template\" hack\n \n BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n {\n     fPrintToConsole = true;\n-    static std::atomic<size_t> n_calls;\n+    static std::atomic<size_t> n_calls {0};\n     struct FailingJob {\n         bool f;\n         bool call_state;\n@@ -76,12 +71,14 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n             std::swap(tag, x.tag);\n         };\n     };\n-    static CCheckQueue<FailingJob, (size_t)1000, MAX_SCRIPTCHECK_THREADS, testing_level::enable_functions> fail_queue;\n-    fail_queue.init(nScriptCheckThreads);\n+    typedef CCheckQueue<FailingJob, (size_t)1000, MAX_SCRIPTCHECK_THREADS, testing_level::enable_functions> T;\n+    auto fail_queue = std::unique_ptr<T>(new T());\n+\n+    fail_queue->init(nScriptCheckThreads);\n \n     for (size_t i = 10; i < 1001; ++i) {\n         n_calls = 0;\n-        CCheckQueueControl<decltype(fail_queue)> control(&fail_queue);\n+        CCheckQueueControl<T> control(fail_queue.get());\n         size_t checksum = 0;\n \n         std::vector<FailingJob> vChecks;\n@@ -105,18 +102,18 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n         bool success = control.Wait();\n         if (success && i > 0) {\n             size_t nChecked = 0;\n-            auto jobs = fail_queue.TEST_introspect_jobs()->TEST_get_checks();\n+            auto jobs = fail_queue->TEST_introspect_jobs()->TEST_get_checks();\n             for (size_t x = 0; x < i; ++x)\n                 if ((*jobs)[x].call_state)\n                     nChecked++;\n-            fail_queue.TEST_dump_log(nScriptCheckThreads);\n-            fail_queue.TEST_erase_log();\n+            fail_queue->TEST_dump_log(nScriptCheckThreads);\n+            fail_queue->TEST_erase_log();\n             BOOST_REQUIRE(!success);\n         } else if (i == 0) {\n-            fail_queue.TEST_erase_log();\n+            fail_queue->TEST_erase_log();\n             BOOST_REQUIRE(success);\n         }\n-        fail_queue.TEST_erase_log();\n+        fail_queue->TEST_erase_log();\n     }\n     fPrintToConsole = false;\n }\n@@ -168,21 +165,22 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_PriorityWorkQueue)\n \n BOOST_AUTO_TEST_CASE(test_CheckQueue_job_array)\n {\n-    static CCheckQueue_Internals::job_array<big_queue_proto> jobs;\n-    static std::atomic<size_t> m;\n+    typedef CCheckQueue_Internals::job_array<big_queue> J;\n+    auto jobs = std::shared_ptr<J>(new J());\n+    std::atomic<size_t> m;\n     for (size_t i = 0; i < big_queue::MAX_JOBS; ++i)\n-        jobs.reset_flag(i);\n+        jobs->reset_flag(i);\n     m = 0;\n-    std::thread t([]() {\n+    std::thread t([&](std::atomic<size_t>& m) {\n         for (size_t i = 0; i < big_queue::MAX_JOBS; ++i)\n-            m += jobs.reserve(i) ? 1 : 0;\n-    });\n+            m += jobs->reserve(i) ? 1 : 0;\n+    }, std::ref(m));\n \n \n-    std::thread t2([]() {\n+    std::thread t2([&](std::atomic<size_t>& m) {\n         for (size_t i = 0; i < big_queue::MAX_JOBS; ++i)\n-            m += jobs.reserve(i) ? 1 : 0;\n-    });\n+            m += jobs->reserve(i) ? 1 : 0;\n+    }, std::ref(m));\n     t.join();\n     t2.join();\n \n@@ -191,16 +189,17 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_job_array)\n BOOST_AUTO_TEST_CASE(test_CheckQueue_round_barrier)\n {\n     RAII_ThreadGroup threadGroup;\n-    static CCheckQueue_Internals::round_barrier<big_queue> barrier;\n-    barrier.init(nScriptCheckThreads);\n+    typedef CCheckQueue_Internals::round_barrier<big_queue> B;\n+    auto barrier = std::shared_ptr<B>(new B());\n+    barrier->init(nScriptCheckThreads);\n     for (int i = 0; i < nScriptCheckThreads; ++i)\n-        barrier.reset(i);\n-    for (int i = 0; i < nScriptCheckThreads; ++i) {\n-        threadGroup.create_thread([=]() {\n-            barrier.mark_done(i);\n-            while (!barrier.load_done());\n+        barrier->reset(i);\n+\n+    for (int i = 0; i < nScriptCheckThreads; ++i) \n+        threadGroup.create_thread([&, i]() {\n+            barrier->mark_done(i);\n+            while (!barrier->load_done());\n         });\n-    }\n \n     threadGroup.join_all();\n \n@@ -215,8 +214,9 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_consume)\n         }\n         void swap(FakeJobNoWork& x){};\n     };\n-    static CCheckQueue<FakeJobNoWork, (size_t)100000, MAX_SCRIPTCHECK_THREADS, testing_level::enable_functions> fast_queue{};\n-    fast_queue.init(nScriptCheckThreads);\n+    typedef CCheckQueue<FakeJobNoWork, (size_t)100000, MAX_SCRIPTCHECK_THREADS, testing_level::enable_functions> C;\n+    auto fast_queue = std::shared_ptr<C>(new C());\n+    fast_queue->init(nScriptCheckThreads);\n     std::array<std::atomic<size_t>, MAX_SCRIPTCHECK_THREADS> results;\n     std::atomic<int> spawned{0};\n \n@@ -227,7 +227,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_consume)\n     for (int i = 0; i < nScriptCheckThreads; ++i) {\n         threadGroup.create_thread([&, i]() {\n             ++spawned;\n-            results[i] = fast_queue.TEST_consume(i);\n+            results[i] = fast_queue->TEST_consume(i);\n         });\n     }\n \n@@ -238,10 +238,10 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_consume)\n             for (auto x = 0; x< 100; ++x) {\n                 w.push_back(FakeJobNoWork{});\n             }\n-            fast_queue.Add(w);\n+            fast_queue->Add(w);\n             MilliSleep(1);\n         }\n-        fast_queue.TEST_set_masterJoined(true);\n+        fast_queue->TEST_set_masterJoined(true);\n     });\n \n     threadGroup.join_all();\n@@ -255,7 +255,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_consume)\n             BOOST_REQUIRE(v == 1000);\n         }\n     }\n-    size_t count = fast_queue.TEST_count_set_flags();\n+    size_t count = fast_queue->TEST_count_set_flags();\n     BOOST_TEST_MESSAGE(\"Got: \" << count);\n     BOOST_REQUIRE(count == 1000);\n }\n@@ -273,14 +273,15 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct)\n         }\n         void swap(FakeJobCheckCompletion& x){};\n     };\n-    static CCheckQueue<FakeJobCheckCompletion, (size_t)100, MAX_SCRIPTCHECK_THREADS> small_queue;\n-    small_queue.init(nScriptCheckThreads);\n+    typedef CCheckQueue<FakeJobCheckCompletion, (size_t)100, MAX_SCRIPTCHECK_THREADS> C;\n+    auto small_queue = std::shared_ptr<C>(new C);\n+    small_queue->init(nScriptCheckThreads);\n \n     for (size_t i = 0; i < 101; ++i) {\n         size_t total = i;\n         n_calls = 0;\n         {\n-            CCheckQueueControl<decltype(small_queue)> control(&small_queue);\n+            CCheckQueueControl<C> control(small_queue.get());\n             while (total) {\n                 size_t r = GetRand(10);\n                 std::vector<FakeJobCheckCompletion> vChecks;"
      }
    ]
  },
  {
    "sha": "1c2e855b0c323a64fe1834003764148203b138b4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxYzJlODU1YjBjMzIzYTY0ZmUxODM0MDAzNzY0MTQ4MjAzYjEzOGI0",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-11T20:46:26Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "Make checkqueue tests use smaller queues",
      "tree": {
        "sha": "24c120c0a88d303ddd4af342cf97dc6c1a63b55c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/24c120c0a88d303ddd4af342cf97dc6c1a63b55c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1c2e855b0c323a64fe1834003764148203b138b4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1c2e855b0c323a64fe1834003764148203b138b4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1c2e855b0c323a64fe1834003764148203b138b4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1c2e855b0c323a64fe1834003764148203b138b4/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ff667f996a59af5e52916993388c59373b1b995a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ff667f996a59af5e52916993388c59373b1b995a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ff667f996a59af5e52916993388c59373b1b995a"
      }
    ],
    "stats": {
      "total": 121,
      "additions": 61,
      "deletions": 60
    },
    "files": [
      {
        "sha": "223104b69bd3f196af7247293935a3433f17e77d",
        "filename": "src/test/checkqueue_tests.cpp",
        "status": "modified",
        "additions": 61,
        "deletions": 60,
        "changes": 121,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1c2e855b0c323a64fe1834003764148203b138b4/src/test/checkqueue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1c2e855b0c323a64fe1834003764148203b138b4/src/test/checkqueue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkqueue_tests.cpp?ref=1c2e855b0c323a64fe1834003764148203b138b4",
        "patch": "@@ -42,43 +42,64 @@ class RAII_ThreadGroup {\n \n struct FakeJob {\n };\n+typedef CCheckQueue<FakeJob, (size_t)1000, MAX_SCRIPTCHECK_THREADS, TEST> Standard_Queue;\n+struct FakeJobCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeJobCheckCompletion& x){};\n+};\n+std::atomic<size_t> FakeJobCheckCompletion::n_calls {0};\n+typedef CCheckQueue<FakeJobCheckCompletion, (size_t)100, MAX_SCRIPTCHECK_THREADS> Correct_Queue;\n \n-typedef CCheckQueue<FakeJob, (size_t)100000, MAX_SCRIPTCHECK_THREADS, TEST> big_queue;\n-typedef CCheckQueue<FakeJob, (size_t)2000, MAX_SCRIPTCHECK_THREADS, TEST> medium_queue;\n-typedef typename big_queue::JOB_TYPE JT; // This is a \"recursive template\" hack\n+struct FailingJob {\n+    bool f;\n+    bool call_state;\n+    size_t tag;\n+    static std::atomic<size_t> n_calls;\n+    FailingJob(bool fails) : f(fails), call_state(false), tag(0xdeadbeef){};\n+    FailingJob() : f(true), call_state(false){};\n+    bool operator()()\n+    {\n+        n_calls++;\n+        call_state = true;\n+        return !f;\n+    }\n+    void swap(FailingJob& x)\n+    {\n+        std::swap(f, x.f);\n \n+        std::swap(call_state, x.call_state);\n+        std::swap(tag, x.tag);\n+    };\n+};\n+std::atomic<size_t> FailingJob::n_calls {0};\n+typedef CCheckQueue<FailingJob, (size_t)1000, MAX_SCRIPTCHECK_THREADS, testing_level::enable_functions> Failing_Queue;\n+struct FakeJobNoWork {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeJobNoWork& x){};\n+};\n+typedef CCheckQueue<FakeJobNoWork, (size_t)1000, MAX_SCRIPTCHECK_THREADS, testing_level::enable_functions> Consume_Queue;\n+\n+typedef typename Standard_Queue::JOB_TYPE JT; // This is a \"recursive template\" hack\n+typedef CCheckQueue_Internals::job_array<Standard_Queue> J;\n+typedef CCheckQueue_Internals::round_barrier<Standard_Queue> B;\n BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n {\n     fPrintToConsole = true;\n-    static std::atomic<size_t> n_calls {0};\n-    struct FailingJob {\n-        bool f;\n-        bool call_state;\n-        size_t tag;\n-        FailingJob(bool fails) : f(fails), call_state(false), tag(0xdeadbeef){};\n-        FailingJob() : f(true), call_state(false){};\n-        bool operator()()\n-        {\n-            n_calls++;\n-            call_state = true;\n-            return !f;\n-        }\n-        void swap(FailingJob& x)\n-        {\n-            std::swap(f, x.f);\n-\n-            std::swap(call_state, x.call_state);\n-            std::swap(tag, x.tag);\n-        };\n-    };\n-    typedef CCheckQueue<FailingJob, (size_t)1000, MAX_SCRIPTCHECK_THREADS, testing_level::enable_functions> T;\n-    auto fail_queue = std::unique_ptr<T>(new T());\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue());\n \n     fail_queue->init(nScriptCheckThreads);\n \n     for (size_t i = 10; i < 1001; ++i) {\n-        n_calls = 0;\n-        CCheckQueueControl<T> control(fail_queue.get());\n+        FailingJob::n_calls = 0;\n+        CCheckQueueControl<Failing_Queue> control(fail_queue.get());\n         size_t checksum = 0;\n \n         std::vector<FailingJob> vChecks;\n@@ -119,7 +140,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n }\n BOOST_AUTO_TEST_CASE(test_CheckQueue_PriorityWorkQueue)\n {\n-    CCheckQueue_Internals::PriorityWorkQueue<medium_queue> work(0, 16);\n+    CCheckQueue_Internals::PriorityWorkQueue<Standard_Queue> work(0, 16);\n     auto m = 0;\n     work.add(100);\n     size_t x = 0;\n@@ -165,31 +186,29 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_PriorityWorkQueue)\n \n BOOST_AUTO_TEST_CASE(test_CheckQueue_job_array)\n {\n-    typedef CCheckQueue_Internals::job_array<big_queue> J;\n     auto jobs = std::shared_ptr<J>(new J());\n     std::atomic<size_t> m;\n-    for (size_t i = 0; i < big_queue::MAX_JOBS; ++i)\n+    for (size_t i = 0; i < Standard_Queue::MAX_JOBS; ++i)\n         jobs->reset_flag(i);\n     m = 0;\n     std::thread t([&](std::atomic<size_t>& m) {\n-        for (size_t i = 0; i < big_queue::MAX_JOBS; ++i)\n+        for (size_t i = 0; i < Standard_Queue::MAX_JOBS; ++i)\n             m += jobs->reserve(i) ? 1 : 0;\n     }, std::ref(m));\n \n \n     std::thread t2([&](std::atomic<size_t>& m) {\n-        for (size_t i = 0; i < big_queue::MAX_JOBS; ++i)\n+        for (size_t i = 0; i < Standard_Queue::MAX_JOBS; ++i)\n             m += jobs->reserve(i) ? 1 : 0;\n     }, std::ref(m));\n     t.join();\n     t2.join();\n \n-    BOOST_REQUIRE(m == big_queue::MAX_JOBS);\n+    BOOST_REQUIRE(m == Standard_Queue::MAX_JOBS);\n }\n BOOST_AUTO_TEST_CASE(test_CheckQueue_round_barrier)\n {\n     RAII_ThreadGroup threadGroup;\n-    typedef CCheckQueue_Internals::round_barrier<big_queue> B;\n     auto barrier = std::shared_ptr<B>(new B());\n     barrier->init(nScriptCheckThreads);\n     for (int i = 0; i < nScriptCheckThreads; ++i)\n@@ -207,15 +226,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_round_barrier)\n \n BOOST_AUTO_TEST_CASE(test_CheckQueue_consume)\n {\n-    struct FakeJobNoWork {\n-        bool operator()()\n-        {\n-            return true;\n-        }\n-        void swap(FakeJobNoWork& x){};\n-    };\n-    typedef CCheckQueue<FakeJobNoWork, (size_t)100000, MAX_SCRIPTCHECK_THREADS, testing_level::enable_functions> C;\n-    auto fast_queue = std::shared_ptr<C>(new C());\n+    auto fast_queue = std::shared_ptr<Consume_Queue>(new Consume_Queue());\n     fast_queue->init(nScriptCheckThreads);\n     std::array<std::atomic<size_t>, MAX_SCRIPTCHECK_THREADS> results;\n     std::atomic<int> spawned{0};\n@@ -264,24 +275,14 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_consume)\n \n BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct)\n {\n-    static std::atomic<size_t> n_calls;\n-    struct FakeJobCheckCompletion {\n-        bool operator()()\n-        {\n-            ++n_calls;\n-            return true;\n-        }\n-        void swap(FakeJobCheckCompletion& x){};\n-    };\n-    typedef CCheckQueue<FakeJobCheckCompletion, (size_t)100, MAX_SCRIPTCHECK_THREADS> C;\n-    auto small_queue = std::shared_ptr<C>(new C);\n+    auto small_queue = std::shared_ptr<Correct_Queue>(new Correct_Queue);\n     small_queue->init(nScriptCheckThreads);\n \n     for (size_t i = 0; i < 101; ++i) {\n         size_t total = i;\n-        n_calls = 0;\n+        FakeJobCheckCompletion::n_calls = 0;\n         {\n-            CCheckQueueControl<C> control(small_queue.get());\n+            CCheckQueueControl<Correct_Queue> control(small_queue.get());\n             while (total) {\n                 size_t r = GetRand(10);\n                 std::vector<FakeJobCheckCompletion> vChecks;\n@@ -293,9 +294,9 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct)\n                 control.Add(vChecks);\n             }\n         }\n-        if (n_calls != i) {\n-            BOOST_REQUIRE(n_calls == i);\n-            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << n_calls);\n+        if (FakeJobCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE(FakeJobCheckCompletion::n_calls == i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeJobCheckCompletion::n_calls);\n         }\n     }\n }"
      }
    ]
  },
  {
    "sha": "fc453c875307d8691cd13bdedb8f9204af7430a2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYzQ1M2M4NzUzMDdkODY5MWNkMTNiZGVkYjhmOTIwNGFmNzQzMGEy",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-14T18:17:17Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "Simplify some code removing uneeded complexity and fix an initialization error that could cause hangs",
      "tree": {
        "sha": "c72da0a7d7036d2370a37079a466d080cc3b72b1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c72da0a7d7036d2370a37079a466d080cc3b72b1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fc453c875307d8691cd13bdedb8f9204af7430a2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fc453c875307d8691cd13bdedb8f9204af7430a2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fc453c875307d8691cd13bdedb8f9204af7430a2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fc453c875307d8691cd13bdedb8f9204af7430a2/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1c2e855b0c323a64fe1834003764148203b138b4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1c2e855b0c323a64fe1834003764148203b138b4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1c2e855b0c323a64fe1834003764148203b138b4"
      }
    ],
    "stats": {
      "total": 304,
      "additions": 155,
      "deletions": 149
    },
    "files": [
      {
        "sha": "259a88dd04f616662274aa754bd0913d187ed8e6",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 145,
        "deletions": 139,
        "changes": 284,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fc453c875307d8691cd13bdedb8f9204af7430a2/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fc453c875307d8691cd13bdedb8f9204af7430a2/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=fc453c875307d8691cd13bdedb8f9204af7430a2",
        "patch": "@@ -13,6 +13,7 @@\n #include <chrono>\n #include <sstream>\n #include <iostream>\n+#include <mutex>\n \n \n #ifndef ATOMIC_BOOL_LOCK_FREE\n@@ -27,21 +28,7 @@\n \n \n /** Forward Declaration on CCheckQueue. Note default no testing. */\n-enum testing_level : int {\n-    disabled = 0,\n-    enable_functions = 1,\n-    enable_logging = 2\n-};\n-constexpr testing_level operator&(testing_level a, testing_level b)\n-{\n-    return static_cast<testing_level>(static_cast<int>(a) & static_cast<int>(b));\n-}\n-\n-constexpr testing_level operator|(testing_level a, testing_level b)\n-{\n-    return static_cast<testing_level>(static_cast<int>(a) | static_cast<int>(b));\n-}\n-template <typename T, size_t J, size_t W, testing_level TEST_ENABLE = testing_level::disabled>\n+template <typename T, size_t J, size_t W, bool TFE = false, bool TLE = false>\n class CCheckQueue;\n /** Forward Declaration on CCheckQueueControl */\n template <typename Q>\n@@ -66,13 +53,19 @@ class job_array\n     std::array<std::atomic_flag, Q::MAX_JOBS> flags;\n     /** used as the insertion point into the array. */\n     typename Q::JOB_TYPE* next_free_index;\n+    size_t RT_N_SCRIPTCHECK_THREADS;\n \n public:\n-    job_array() : next_free_index(checks.begin())\n+    job_array() : next_free_index(checks.begin()), RT_N_SCRIPTCHECK_THREADS(0)\n     {\n         for (auto& i : flags)\n             i.clear();\n     }\n+\n+    void init(const size_t rt)\n+    {\n+        RT_N_SCRIPTCHECK_THREADS = rt;\n+    }\n     /** add swaps a vector of checks into the checks array and increments the pointer\n              * not threadsafe */\n     void add(std::vector<typename Q::JOB_TYPE>& vChecks)\n@@ -98,6 +91,11 @@ class job_array\n         flags[i].clear();\n     }\n \n+    void reset_flags_for(const size_t ID, const size_t to) \n+    {\n+        for (size_t i = ID; i < to; i += RT_N_SCRIPTCHECK_THREADS)\n+            reset_flag(i);\n+    }\n     /** eval runs a check at specified index */\n     bool eval(const size_t i)\n     {\n@@ -120,7 +118,7 @@ class job_array\n \n     decltype(&checks) TEST_get_checks()\n     {\n-        return Q::TEST ? &checks : nullptr;\n+        return Q::TEST_FUNCTIONS_ENABLE ? &checks : nullptr;\n     }\n };\n /* round_barrier is used to communicate that a thread has finished\n@@ -138,14 +136,17 @@ class round_barrier\n \n public:\n     /** Default state is false so that first round looks like no prior round*/\n-    round_barrier() : RT_N_SCRIPTCHECK_THREADS(0) {}\n+    round_barrier() : RT_N_SCRIPTCHECK_THREADS(0) {\n+        for (auto& s : state)\n+            s.store(false);\n+    }\n \n     void init(const size_t rt)\n     {\n         RT_N_SCRIPTCHECK_THREADS = rt;\n     }\n \n-    void mark_done(const size_t id)\n+    void finished(const size_t id)\n     {\n         state[id] = true;\n     }\n@@ -154,13 +155,10 @@ class round_barrier\n              *\n              * @param upto \n              * @returns if all entries up to upto were true*/\n-    bool load_done() const\n+    void wait_all_finished() const\n     {\n-        bool x = true;\n-        for (auto i = 0; i < RT_N_SCRIPTCHECK_THREADS; i++) {\n-            x = x && state[i].load();\n+        for (auto i = 0; i < RT_N_SCRIPTCHECK_THREADS; i = state[i].load() ? i+1 : 0) {\n         }\n-        return x;\n     }\n \n     /** resets one bool\n@@ -171,11 +169,12 @@ class round_barrier\n         state[i] = false;\n     }\n \n-    /** Perfroms a read of the state \n+    /** Waits until state is set false\n             */\n-    bool is_done(const size_t i) const\n+    void wait_reset(const size_t i) const \n     {\n-        return state[i];\n+        while (state[i])\n+            ;\n     }\n };\n /* PriorityWorkQueue exists to help threads select work \n@@ -297,35 +296,25 @@ struct status_container {\n  * @tparam W the maximum number of workers possible\n  */\n \n-template <typename T, size_t J, size_t W, testing_level TEST_ENABLE>\n+template <typename T, size_t J, size_t W, bool TFE, bool TLE>\n class CCheckQueue\n {\n public:\n     typedef T JOB_TYPE;\n+    typedef CCheckQueue<T, J, W, TFE, TLE> SELF;\n     static const size_t MAX_JOBS = J;\n     static const size_t MAX_WORKERS = W;\n-    static const testing_level TEST = TEST_ENABLE;\n+    static const bool TEST_FUNCTIONS_ENABLE = TFE;\n+    static const bool TEST_LOGGING_ENABLE = TLE;\n     // We use the Proto version so that we can pass it to job_array, status_container, etc\n \n private:\n-    CCheckQueue_Internals::job_array<CCheckQueue<T, J, W, TEST> > jobs;\n-    CCheckQueue_Internals::status_container<CCheckQueue<T, J, W, TEST> > status;\n-    CCheckQueue_Internals::round_barrier<CCheckQueue<T, J, W, TEST> > done_round;\n-    struct sleep_status {\n-        struct states {\n-            static const uint8_t asleep_alive = 0b00000001;\n-            static const uint8_t awake_alive = 0b00000000;\n-            static const uint8_t asleep_dead = 0b00000011;\n-            static const uint8_t awake_dead = 0b00000010;\n-        };\n-        struct switches {\n-            static const uint8_t kill_or = 0b00000010;\n-            static const uint8_t wakeup_and = 0b11111110;\n-            static const uint8_t sleep_or = 0b00000001;\n-        };\n-    };\n+    CCheckQueue_Internals::job_array<SELF> jobs;\n+    CCheckQueue_Internals::status_container<SELF> status;\n+    CCheckQueue_Internals::round_barrier<SELF> barrier;\n     std::atomic<uint8_t> should_sleep;\n     size_t RT_N_SCRIPTCHECK_THREADS;\n+    std::mutex control_mtx;\n \n     //state only for testing\n     mutable std::atomic<size_t> test_log_seq;\n@@ -342,24 +331,23 @@ class CCheckQueue\n     {\n         for (;;) {\n             switch (should_sleep.load()) {\n-            case sleep_status::states::asleep_alive:\n+            case 0:\n                 std::this_thread::sleep_for(std::chrono::microseconds(1));\n                 break;\n-            case sleep_status::states::awake_alive:\n+            case 1:\n                 return false;\n-            case sleep_status::states::asleep_dead: // covers dead && awake\n-            case sleep_status::states::awake_dead:\n+            default:\n                 return true;\n             }\n         }\n     }\n \n     size_t consume(const size_t ID)\n     {\n-        if (TEST & testing_level::enable_logging)\n-            test_log[ID] << \"[[\" << ++test_log_seq << \"]] \"\n-                         << \"Worker ID [\" << ID << \"] in consume\\n\";\n-        CCheckQueue_Internals::PriorityWorkQueue<CCheckQueue<T, J, W, TEST> > work_queue(ID, RT_N_SCRIPTCHECK_THREADS);\n+        TEST_log(ID, [](std::ostringstream& o) {\n+            o << \"In consume\\n\";\n+        });\n+        CCheckQueue_Internals::PriorityWorkQueue<SELF> work_queue(ID, RT_N_SCRIPTCHECK_THREADS);\n         bool no_stealing;\n         bool got_data;\n         size_t job_id;\n@@ -370,62 +358,71 @@ class CCheckQueue\n             work_queue.add(status.nTodo.load());\n             (got_data = work_queue.pop(job_id, no_stealing)) && jobs.reserve(job_id) && (jobs.eval(job_id) || (status.fAllOk.store(false), false));\n         } while (status.fAllOk.load() && (no_stealing || got_data));\n-        if (TEST & testing_level::enable_logging)\n-            test_log[ID] << \"[[\" << ++test_log_seq << \"]] \"\n-                         << \"Worker ID [\" << ID << \"] leaving consume. fAllOk was \" << status.fAllOk.load() << \"\\n\";\n+            \n+        TEST_log(ID, [&, this](std::ostringstream& o) {\n+            o << \"Leaving consume. fAllOk was \" << status.fAllOk.load() << \"\\n\";\n+        });\n         return work_queue.get_total();\n     }\n     /** Internal function that does bulk of the verification work. */\n-    bool Loop(const size_t ID)\n+    bool Master() {\n+        const size_t ID = 0;\n+\n+        wait_for_cleanup();\n+        status.masterJoined.store(true);\n+\n+        TEST_log(ID, [&, this](std::ostringstream& o) {\n+            o << \"Master just set masterJoined\\n\";\n+        });\n+        consume(ID);\n+        barrier.finished(ID);\n+        //  1) Wait till all threads finish\n+        //  2) read fAllOk\n+        //  3) Tell threads to sleep (otherwise, they may stay up)\n+        //  4) Mark master as gone\n+        //  5) return\n+        barrier.wait_all_finished();\n+        TEST_log(ID, [&, this](std::ostringstream& o) {\n+            o << \"(Master) saw all threads finished\\n\";\n+        });\n+        bool fRet = status.fAllOk;\n+        sleep();\n+        status.masterJoined.store(false);\n+        return fRet;\n+    }\n+    void Loop(const size_t ID)\n     {\n         for (;;) {\n             if (maybe_sleep()) {\n                 LogPrintf(\"CCheckQueue @%#010x Worker %q shutting down\\n\", this, ID);\n-                return status.fAllOk.load();\n+                return;\n             }\n-\n-            if (TEST & testing_level::enable_logging)\n-                test_log[ID] << \"[[\" << ++test_log_seq << \"]] \"\n-                             << \"Worker ID [\" << ID << \"] starting\\n\";\n+            TEST_log(ID, [&, this](std::ostringstream& o) {\n+                o << \"Round starting\\n\";\n+            });\n \n             size_t prev_total = consume(ID);\n \n-            if (TEST & testing_level::enable_logging)\n-                test_log[ID] << \"[[\" << ++test_log_seq << \"]] \"\n-                             << \"Worker ID [\" << ID << \"] saw up to \" << prev_total << \" master was \" << status.masterJoined.load() << \" nTodo \" << status.nTodo.load() << '\\n';\n+            TEST_log(ID, [&, this](std::ostringstream& o) {\n+                o << \"saw up to \" << prev_total << \" master was \"\n+                << status.masterJoined.load() << \" nTodo \" << status.nTodo.load() << '\\n';\n+            });\n \n             // We only break out of the loop when there is no more work and the master had joined.\n             // We won't find more work later, so mark ourselves as completed\n             // Any error would have already been reported\n             // If we don't wait for the master to join, it is because an error check was found. Not waiting would cause a race condtion.\n             while (!status.masterJoined.load())\n                 ;\n-            done_round.mark_done(ID);\n-\n-            // If we are the master:\n-            //  1) Wait till all threads finish\n-            //  2) read fAllOk\n-            //  3) Tell threads to sleep (otherwise, they may stay up)\n-            //  4) Mark master as gone\n-            //  5) return\n-            if (ID == 0) {\n-                while (!done_round.load_done())\n-                    ;\n-                if (TEST & testing_level::enable_logging)\n-                    test_log[ID] << \"[[\" << ++test_log_seq << \"]] \"\n-                                 << \"Worker ID [\" << ID << \"] saw all threads finished\\n\";\n-                bool fRet = status.fAllOk;\n-                sleep();\n-                status.masterJoined.store(false);\n-                return fRet;\n-            }\n+            barrier.finished(ID);\n+\n \n             // We wait until the master reports leaving explicitly\n             while (status.masterJoined.load())\n                 ;\n-            if (TEST & testing_level::enable_logging)\n-                test_log[ID] << \"[[\" << ++test_log_seq << \"]] \"\n-                             << \"Worker ID [\" << ID << \"] saw master leave\\n\";\n+            TEST_log(ID, [&, this](std::ostringstream& o) {\n+                o << \"Saw master leave\\n\";\n+            });\n \n             // Have ID == 1 perform cleanup as the \"slave master slave\" as ID == 1 is always there if multicore\n             // This frees the master to return with the result before the cleanup occurs\n@@ -435,49 +432,39 @@ class CCheckQueue\n \n \n             // We reset all the flags we think we'll use (also warms cache)\n-            for (size_t i = ID; i < prev_total; i += RT_N_SCRIPTCHECK_THREADS)\n-                jobs.reset_flag(i);\n+            jobs.reset_flags_for(ID, prev_total);\n             ++status.nFinishedCleanup;\n             if (ID == 1) {\n-                // Reset master flags too -- if ID == 0, it's not wrong just not needed\n-                for (size_t i = 0; i < prev_total; i += RT_N_SCRIPTCHECK_THREADS)\n-                    jobs.reset_flag(i);\n+                // Reset master flags too\n+                jobs.reset_flags_for(0, prev_total);\n \n-                if (TEST & testing_level::enable_logging)\n-                    test_log[ID] << \"[[\" << ++test_log_seq << \"]] \"\n-                                 << \"Resetting nTodo and fAllOk\" << '\\n';\n+                TEST_log(ID, [&, this](std::ostringstream& o) {\n+                    o << \"Resetting nTodo and fAllOk\" << '\\n';\n+                });\n \n-                status.nTodo.store(0);\n-                status.fAllOk.store(true);\n \n-                // TODO: In the future, other mutually excluded cleanup tasks can go here\n-\n-                // Wait until all threads are either master or idle, otherwise resetting could prevent finishing\n-                // because of cleanup occuring after others are running in main section\n                 wait_all_finished_cleanup();\n                 status.nFinishedCleanup.store(0);\n-                // We have all the threads wait on their done_round to be reset, so we\n+                // We have all the threads wait on their barrier to be reset, so we\n                 // Release all the threads, master must be last to keep master from rejoining\n                 for (auto i = RT_N_SCRIPTCHECK_THREADS; i > 0;)\n-                    done_round.reset(--i);\n+                    barrier.reset(--i);\n             }\n-            while (done_round.is_done(ID))\n-                ;\n+            barrier.wait_reset(ID);\n         }\n     }\n \n public:\n-    CCheckQueue() : jobs(), status(), done_round(), should_sleep(sleep_status::states::asleep_alive), RT_N_SCRIPTCHECK_THREADS(0), test_log_seq(0)\n+    CCheckQueue() : jobs(), status(), barrier(), should_sleep(0), RT_N_SCRIPTCHECK_THREADS(0), test_log_seq(0)\n     {\n     }\n \n     void wait_for_cleanup() const\n     {\n-        while (done_round.is_done(0)) {\n-        }\n-        if (TEST & testing_level::enable_logging)\n-            test_log[0] << \"[[\" << ++test_log_seq << \"]] \"\n-                        << \"Worker ID [\" << 0 << \"] cleanup waiting done!\\n\";\n+        barrier.wait_reset(0);\n+        TEST_log(0, [](std::ostringstream& o) mutable {\n+            o << \"Cleanup waiting done!\\n\";\n+        });\n     }\n     void reset_jobs()\n     {\n@@ -491,17 +478,20 @@ class CCheckQueue\n         Loop(ID);\n     }\n \n+    void ControlLock() {\n+        control_mtx.lock();\n+        status.nTodo.store(0);\n+        status.fAllOk.store(true);\n+\n+    }\n+    void ControlUnlock() {\n+        control_mtx.unlock();\n+    };\n \n     //! Wait until execution finishes, and return whether all evaluations were successful.\n     bool Wait()\n     {\n-        status.masterJoined.store(true);\n-\n-        if (TEST & testing_level::enable_logging)\n-            test_log[0] << \"[[\" << ++test_log_seq << \"]] \"\n-                        << \"Master just set masterJoined\\n\";\n-\n-        return Loop(0);\n+        return Master();\n     }\n \n     //! Add a batch of checks to the queue\n@@ -511,17 +501,19 @@ class CCheckQueue\n         size_t vs = vChecks.size();\n         status.nTodo.fetch_add(vs);\n \n-        if (TEST & testing_level::enable_logging)\n-            test_log[0] << \"[[\" << ++test_log_seq << \"]] \"\n-                        << \"Added \" << vs << \" values. nTodo was \" << status.nTodo.load() - vs << \" now is \" << status.nTodo.load() << \" \\n\";\n+        TEST_log(0, [&, this](std::ostringstream& o) {\n+            o << \"Added \" << vs << \" values. nTodo was \" << status.nTodo.load() - vs\n+            << \" now is \" << status.nTodo.load() << \" \\n\";\n+        });\n     }\n \n     void Add(std::ptrdiff_t vs)\n     {\n         status.nTodo.fetch_add(vs);\n-        if (TEST & testing_level::enable_logging)\n-            test_log[0] << \"[[\" << ++test_log_seq << \"]] \"\n-                        << \"Added \" << vs << \" values. nTodo was \" << status.nTodo.load() - vs << \" now is \" << status.nTodo.load() << \" \\n\";\n+        TEST_log(0, [&, this](std::ostringstream& o) {\n+            o << \"Added \" << vs << \" values. nTodo was \" \n+            << status.nTodo.load() - vs << \" now is \" << status.nTodo.load() << \" \\n\";\n+        });\n     }\n     ~CCheckQueue()\n     {\n@@ -531,7 +523,8 @@ class CCheckQueue\n     void init(const size_t RT_N_SCRIPTCHECK_THREADS_)\n     {\n         RT_N_SCRIPTCHECK_THREADS = RT_N_SCRIPTCHECK_THREADS_;\n-        done_round.init(RT_N_SCRIPTCHECK_THREADS);\n+        barrier.init(RT_N_SCRIPTCHECK_THREADS);\n+        jobs.init(RT_N_SCRIPTCHECK_THREADS);\n \n         for (size_t id = 1; id < RT_N_SCRIPTCHECK_THREADS; ++id) {\n             std::thread t([=]() {Thread(id); });\n@@ -540,15 +533,15 @@ class CCheckQueue\n     }\n     void wakeup()\n     {\n-        should_sleep.fetch_and(sleep_status::switches::wakeup_and);\n+        ++should_sleep;\n     }\n     void sleep()\n     {\n-        should_sleep.fetch_or(sleep_status::switches::sleep_or);\n+        --should_sleep;\n     }\n     void quit()\n     {\n-        should_sleep.fetch_or(sleep_status::switches::kill_or);\n+        should_sleep.store(3);\n         for (auto& t : threads)\n             t.join();\n         threads.clear();\n@@ -562,52 +555,63 @@ class CCheckQueue\n \n     size_t TEST_consume(const size_t ID)\n     {\n-        return TEST & testing_level::enable_functions ? consume(ID) : 0;\n+        return TEST_FUNCTIONS_ENABLE ? consume(ID) : 0;\n     }\n     void TEST_set_masterJoined(const bool b)\n     {\n-        if (TEST & testing_level::enable_functions)\n+        if (TEST_FUNCTIONS_ENABLE)\n             status.masterJoined.store(b);\n     }\n \n     size_t TEST_count_set_flags()\n     {\n         auto count = 0;\n-        if (TEST & testing_level::enable_functions)\n+        if (TEST_FUNCTIONS_ENABLE)\n             for (auto t = 0; t < MAX_JOBS; ++t)\n                 count += jobs.reserve(t) ? 0 : 1;\n         return count;\n     }\n     void TEST_reset_all_flags()\n     {\n-        if (TEST & testing_level::enable_functions)\n+        if (TEST_FUNCTIONS_ENABLE)\n             for (auto t = 0; t < MAX_JOBS; ++t)\n                 jobs.reset_flag(t);\n     }\n+    template <typename Callable>\n+    void TEST_log(const size_t ID, Callable c) const\n+    {\n+        if (TEST_LOGGING_ENABLE) {\n+            test_log[ID] << \"[[\" << test_log_seq++ <<\"]] \";\n+            c(test_log[ID]);\n+        }\n+    }\n     void TEST_dump_log(const size_t upto) const\n     {\n-        if (TEST & testing_level::enable_functions & testing_level::enable_logging)\n+\n+        if (TEST_FUNCTIONS_ENABLE) {\n+            LogPrintf(\"\\n#####################\\n## Round Beginning ##\\n#####################\");\n             for (auto i = 0; i < upto; ++i)\n                 LogPrintf(\"\\n------------------\\n%s\\n------------------\\n\\n\", test_log[i].str());\n+        }\n     }\n \n     void TEST_erase_log() const\n     {\n-        if (TEST & testing_level::enable_functions & testing_level::enable_logging)\n+        if (TEST_FUNCTIONS_ENABLE)\n             for (auto i = 0; i < MAX_WORKERS; ++i) {\n                 test_log[i].str(\"\");\n                 test_log[i].clear();\n             }\n     }\n \n \n-    CCheckQueue_Internals::status_container<CCheckQueue<T, J, W, TEST> >* TEST_introspect_status()\n+    CCheckQueue_Internals::status_container<SELF>* TEST_introspect_status()\n     {\n-        return TEST & testing_level::enable_functions ? &status : nullptr;\n+        return TEST_FUNCTIONS_ENABLE ? &status : nullptr;\n     }\n-    CCheckQueue_Internals::job_array<CCheckQueue<T, J, W, TEST> >* TEST_introspect_jobs()\n+    CCheckQueue_Internals::job_array<SELF>* TEST_introspect_jobs()\n     {\n-        return TEST & testing_level::enable_functions ? &jobs : nullptr;\n+        return TEST_FUNCTIONS_ENABLE ? &jobs : nullptr;\n     }\n };\n \n@@ -626,8 +630,8 @@ class CCheckQueueControl\n     CCheckQueueControl(Q* pqueueIn) : pqueue(pqueueIn), fDone(false)\n     {\n         if (pqueue) {\n+            pqueue->ControlLock();\n             pqueue->wakeup();\n-            pqueue->wait_for_cleanup();\n             pqueue->reset_jobs();\n         }\n     }\n@@ -661,6 +665,8 @@ class CCheckQueueControl\n     {\n         if (!fDone)\n             Wait();\n+        if (pqueue)\n+            pqueue->ControlUnlock();\n     }\n };\n "
      },
      {
        "sha": "0619fa2433c1d2d2b355dca093fd9cb8aa8b7847",
        "filename": "src/test/checkqueue_tests.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 8,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fc453c875307d8691cd13bdedb8f9204af7430a2/src/test/checkqueue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fc453c875307d8691cd13bdedb8f9204af7430a2/src/test/checkqueue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkqueue_tests.cpp?ref=fc453c875307d8691cd13bdedb8f9204af7430a2",
        "patch": "@@ -18,8 +18,6 @@\n #include \"random.h\"\n BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n \n-// Logging off by default because of memory leak\n-static const testing_level TEST = testing_level::enable_functions;\n \n class RAII_ThreadGroup {\n     std::vector<std::thread> threadGroup;\n@@ -42,7 +40,7 @@ class RAII_ThreadGroup {\n \n struct FakeJob {\n };\n-typedef CCheckQueue<FakeJob, (size_t)1000, MAX_SCRIPTCHECK_THREADS, TEST> Standard_Queue;\n+typedef CCheckQueue<FakeJob, (size_t)1000, MAX_SCRIPTCHECK_THREADS, true, true> Standard_Queue;\n struct FakeJobCheckCompletion {\n     static std::atomic<size_t> n_calls;\n     bool operator()()\n@@ -53,7 +51,7 @@ struct FakeJobCheckCompletion {\n     void swap(FakeJobCheckCompletion& x){};\n };\n std::atomic<size_t> FakeJobCheckCompletion::n_calls {0};\n-typedef CCheckQueue<FakeJobCheckCompletion, (size_t)100, MAX_SCRIPTCHECK_THREADS> Correct_Queue;\n+typedef CCheckQueue<FakeJobCheckCompletion, (size_t)100, MAX_SCRIPTCHECK_THREADS, true, true> Correct_Queue;\n \n struct FailingJob {\n     bool f;\n@@ -77,15 +75,15 @@ struct FailingJob {\n     };\n };\n std::atomic<size_t> FailingJob::n_calls {0};\n-typedef CCheckQueue<FailingJob, (size_t)1000, MAX_SCRIPTCHECK_THREADS, testing_level::enable_functions> Failing_Queue;\n+typedef CCheckQueue<FailingJob, (size_t)1000, MAX_SCRIPTCHECK_THREADS, true, true> Failing_Queue;\n struct FakeJobNoWork {\n     bool operator()()\n     {\n         return true;\n     }\n     void swap(FakeJobNoWork& x){};\n };\n-typedef CCheckQueue<FakeJobNoWork, (size_t)1000, MAX_SCRIPTCHECK_THREADS, testing_level::enable_functions> Consume_Queue;\n+typedef CCheckQueue<FakeJobNoWork, (size_t)1000, MAX_SCRIPTCHECK_THREADS, true, true> Consume_Queue;\n \n typedef typename Standard_Queue::JOB_TYPE JT; // This is a \"recursive template\" hack\n typedef CCheckQueue_Internals::job_array<Standard_Queue> J;\n@@ -216,8 +214,8 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_round_barrier)\n \n     for (int i = 0; i < nScriptCheckThreads; ++i) \n         threadGroup.create_thread([&, i]() {\n-            barrier->mark_done(i);\n-            while (!barrier->load_done());\n+            barrier->finished(i);\n+            barrier->wait_all_finished();\n         });\n \n     threadGroup.join_all();\n@@ -275,6 +273,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_consume)\n \n BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct)\n {\n+    fPrintToConsole = true;\n     auto small_queue = std::shared_ptr<Correct_Queue>(new Correct_Queue);\n     small_queue->init(nScriptCheckThreads);\n \n@@ -294,6 +293,8 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct)\n                 control.Add(vChecks);\n             }\n         }\n+        small_queue->TEST_dump_log(nScriptCheckThreads);\n+        small_queue->TEST_erase_log();\n         if (FakeJobCheckCompletion::n_calls != i) {\n             BOOST_REQUIRE(FakeJobCheckCompletion::n_calls == i);\n             BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeJobCheckCompletion::n_calls);"
      },
      {
        "sha": "8f0cbd184b98d8abbd5078980a28e6b2e94f9151",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fc453c875307d8691cd13bdedb8f9204af7430a2/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fc453c875307d8691cd13bdedb8f9204af7430a2/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=fc453c875307d8691cd13bdedb8f9204af7430a2",
        "patch": "@@ -66,8 +66,7 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n             bool ok = ActivateBestChain(state, chainparams);\n             BOOST_CHECK(ok);\n         }\n-        nScriptCheckThreads = std::max(3, GetNumCores()); // Take at least three cores\n-\n+        nScriptCheckThreads = 3;\n         if (!one_time_setup.test_and_set())\n             SetupCCheckQueue(nScriptCheckThreads);\n         RegisterNodeSignals(GetNodeSignals());"
      }
    ]
  },
  {
    "sha": "112b42b5162ce7e37263d58505ab42a501420389",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMTJiNDJiNTE2MmNlN2UzNzI2M2Q1ODUwNWFiNDJhNTAxNDIwMzg5",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-14T21:14:17Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "remove deprecated Add method. Update tests to use new Add method. Some trivial refactors.",
      "tree": {
        "sha": "217a9d34cc80449839dd4f1b97c7498864b6dd7f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/217a9d34cc80449839dd4f1b97c7498864b6dd7f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/112b42b5162ce7e37263d58505ab42a501420389",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/112b42b5162ce7e37263d58505ab42a501420389",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/112b42b5162ce7e37263d58505ab42a501420389",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/112b42b5162ce7e37263d58505ab42a501420389/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fc453c875307d8691cd13bdedb8f9204af7430a2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fc453c875307d8691cd13bdedb8f9204af7430a2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fc453c875307d8691cd13bdedb8f9204af7430a2"
      }
    ],
    "stats": {
      "total": 232,
      "additions": 80,
      "deletions": 152
    },
    "files": [
      {
        "sha": "5e171441c7db69d7059c08eb77a064e9fd1981ad",
        "filename": "src/bench/checkqueue.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/112b42b5162ce7e37263d58505ab42a501420389/src/bench/checkqueue.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/112b42b5162ce7e37263d58505ab42a501420389/src/bench/checkqueue.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkqueue.cpp?ref=112b42b5162ce7e37263d58505ab42a501420389",
        "patch": "@@ -21,19 +21,18 @@ static void CCheckQueueSpeed(benchmark::State& state)\n     typedef CCheckQueue<FakeJobNoWork, (size_t)100000, MAX_SCRIPTCHECK_THREADS> T;\n     auto fast_queue = std::unique_ptr<T>(new T());\n     fast_queue->init(GetNumCores());\n-    std::vector<FakeJobNoWork> vChecks;\n-    vChecks.reserve(100);\n     while (state.KeepRunning()) {\n         size_t total = 0;\n         {\n             CCheckQueueControl<T> control(fast_queue.get());\n             for (size_t j = 0; j < 101; ++j) {\n                 size_t r = 30;\n                 total += r;\n-                vChecks.clear();\n+                auto p = control.get_next_free_index();\n+                auto p_ = *p;\n                 for (size_t k = 0; k < r; ++k)\n-                    vChecks.push_back(FakeJobNoWork{});\n-                control.Add(vChecks);\n+                    new ((*p)++) FakeJobNoWork{};\n+                control.Add(std::distance(p_, *p));\n             }\n         }\n     }"
      },
      {
        "sha": "6086b99edfc3ac229ed13d30d15e6857729f2239",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 57,
        "deletions": 130,
        "changes": 187,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/112b42b5162ce7e37263d58505ab42a501420389/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/112b42b5162ce7e37263d58505ab42a501420389/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=112b42b5162ce7e37263d58505ab42a501420389",
        "patch": "@@ -129,51 +129,46 @@ class job_array\n      */\n \n template <typename Q>\n-class round_barrier\n+class barrier\n {\n     std::array<std::atomic_bool, Q::MAX_WORKERS> state;\n     size_t RT_N_SCRIPTCHECK_THREADS;\n+    std::atomic<size_t> count;\n \n public:\n     /** Default state is false so that first round looks like no prior round*/\n-    round_barrier() : RT_N_SCRIPTCHECK_THREADS(0) {\n-        for (auto& s : state)\n-            s.store(false);\n+    barrier() : RT_N_SCRIPTCHECK_THREADS(0), count(0) {\n     }\n \n     void init(const size_t rt)\n     {\n         RT_N_SCRIPTCHECK_THREADS = rt;\n     }\n \n-    void finished(const size_t id)\n+    void finished()\n     {\n-        state[id] = true;\n+        ++count;\n     }\n \n-    /** Iterates from [0,upto) to fetch status updates on unfinished workers.\n-             *\n-             * @param upto \n-             * @returns if all entries up to upto were true*/\n     void wait_all_finished() const\n     {\n-        for (auto i = 0; i < RT_N_SCRIPTCHECK_THREADS; i = state[i].load() ? i+1 : 0) {\n-        }\n+        while (count != RT_N_SCRIPTCHECK_THREADS)\n+            ;\n     }\n \n     /** resets one bool\n              *\n              */\n-    void reset(const size_t i)\n+    void reset()\n     {\n-        state[i] = false;\n+        count.store(0);\n     }\n \n     /** Waits until state is set false\n             */\n-    void wait_reset(const size_t i) const \n+    void wait_reset() const \n     {\n-        while (state[i])\n+        while (count.load() != 0)\n             ;\n     }\n };\n@@ -273,10 +268,8 @@ struct status_container {\n     std::atomic<bool> fAllOk;\n     /** true if the master has joined, false otherwise. A round may not terminate unless masterJoined */\n     std::atomic<bool> masterJoined;\n-    /** used to count how many threads have finished cleanup operations */\n-    std::atomic_uint nFinishedCleanup;\n \n-    status_container() : nTodo(0), fAllOk(true), masterJoined(false), nFinishedCleanup(0) {}\n+    status_container() : nTodo(0), fAllOk(true), masterJoined(false){}\n };\n }\n \n@@ -311,7 +304,8 @@ class CCheckQueue\n private:\n     CCheckQueue_Internals::job_array<SELF> jobs;\n     CCheckQueue_Internals::status_container<SELF> status;\n-    CCheckQueue_Internals::round_barrier<SELF> barrier;\n+    CCheckQueue_Internals::barrier<SELF> work;\n+    CCheckQueue_Internals::barrier<SELF> cleanup;\n     std::atomic<uint8_t> should_sleep;\n     size_t RT_N_SCRIPTCHECK_THREADS;\n     std::mutex control_mtx;\n@@ -322,10 +316,17 @@ class CCheckQueue\n     std::vector<std::thread> threads;\n \n \n-    void wait_all_finished_cleanup() const\n+    void wakeup()\n     {\n-        while (status.nFinishedCleanup.load() != RT_N_SCRIPTCHECK_THREADS - 1)\n-            ;\n+        ++should_sleep;\n+    }\n+    void sleep()\n+    {\n+        --should_sleep;\n+    }\n+    void die()\n+    {\n+        should_sleep.store(3);\n     }\n     bool maybe_sleep() const\n     {\n@@ -335,9 +336,9 @@ class CCheckQueue\n                 std::this_thread::sleep_for(std::chrono::microseconds(1));\n                 break;\n             case 1:\n-                return false;\n-            default:\n                 return true;\n+            default:\n+                return false;\n             }\n         }\n     }\n@@ -368,104 +369,53 @@ class CCheckQueue\n     bool Master() {\n         const size_t ID = 0;\n \n-        wait_for_cleanup();\n+        work.wait_reset();\n         status.masterJoined.store(true);\n-\n-        TEST_log(ID, [&, this](std::ostringstream& o) {\n-            o << \"Master just set masterJoined\\n\";\n-        });\n+        TEST_log(ID, [](std::ostringstream& o) { o << \"Master just set masterJoined\\n\"; });\n         consume(ID);\n-        barrier.finished(ID);\n-        //  1) Wait till all threads finish\n-        //  2) read fAllOk\n-        //  3) Tell threads to sleep (otherwise, they may stay up)\n-        //  4) Mark master as gone\n-        //  5) return\n-        barrier.wait_all_finished();\n-        TEST_log(ID, [&, this](std::ostringstream& o) {\n-            o << \"(Master) saw all threads finished\\n\";\n-        });\n+        work.finished();\n+        work.wait_all_finished();\n+        TEST_log(ID, [](std::ostringstream& o) { o << \"(Master) saw all threads finished\\n\"; });\n         bool fRet = status.fAllOk;\n         sleep();\n         status.masterJoined.store(false);\n         return fRet;\n     }\n     void Loop(const size_t ID)\n     {\n-        for (;;) {\n-            if (maybe_sleep()) {\n-                LogPrintf(\"CCheckQueue @%#010x Worker %q shutting down\\n\", this, ID);\n-                return;\n-            }\n-            TEST_log(ID, [&, this](std::ostringstream& o) {\n-                o << \"Round starting\\n\";\n-            });\n-\n+        while (maybe_sleep()) {\n+            TEST_log(ID, [](std::ostringstream& o) {o << \"Round starting\\n\";});\n             size_t prev_total = consume(ID);\n-\n             TEST_log(ID, [&, this](std::ostringstream& o) {\n                 o << \"saw up to \" << prev_total << \" master was \"\n                 << status.masterJoined.load() << \" nTodo \" << status.nTodo.load() << '\\n';\n             });\n-\n-            // We only break out of the loop when there is no more work and the master had joined.\n-            // We won't find more work later, so mark ourselves as completed\n-            // Any error would have already been reported\n-            // If we don't wait for the master to join, it is because an error check was found. Not waiting would cause a race condtion.\n+            // Only spins here if !fAllOk, otherwise consume finished all\n             while (!status.masterJoined.load())\n                 ;\n-            barrier.finished(ID);\n-\n-\n+            work.finished();\n             // We wait until the master reports leaving explicitly\n             while (status.masterJoined.load())\n                 ;\n-            TEST_log(ID, [&, this](std::ostringstream& o) {\n-                o << \"Saw master leave\\n\";\n-            });\n-\n-            // Have ID == 1 perform cleanup as the \"slave master slave\" as ID == 1 is always there if multicore\n-            // This frees the master to return with the result before the cleanup occurs\n-            // And allows for the ID == 1 to do the master's cleanup for it\n-            // We can immediately begin cleanup because all threads waited for master to\n-            // exit on previous round and master waited for all workers.\n-\n-\n-            // We reset all the flags we think we'll use (also warms cache)\n+            TEST_log(ID, [](std::ostringstream& o) { o << \"Saw master leave\\n\"; });\n             jobs.reset_flags_for(ID, prev_total);\n-            ++status.nFinishedCleanup;\n+            cleanup.finished();\n             if (ID == 1) {\n                 // Reset master flags too\n                 jobs.reset_flags_for(0, prev_total);\n-\n-                TEST_log(ID, [&, this](std::ostringstream& o) {\n-                    o << \"Resetting nTodo and fAllOk\" << '\\n';\n-                });\n-\n-\n-                wait_all_finished_cleanup();\n-                status.nFinishedCleanup.store(0);\n-                // We have all the threads wait on their barrier to be reset, so we\n-                // Release all the threads, master must be last to keep master from rejoining\n-                for (auto i = RT_N_SCRIPTCHECK_THREADS; i > 0;)\n-                    barrier.reset(--i);\n+                cleanup.wait_all_finished();\n+                cleanup.reset();\n+                work.reset();\n             }\n-            barrier.wait_reset(ID);\n         }\n+        LogPrintf(\"CCheckQueue @%#010x Worker %q shutting down\\n\", this, ID);\n     }\n \n public:\n-    CCheckQueue() : jobs(), status(), barrier(), should_sleep(0), RT_N_SCRIPTCHECK_THREADS(0), test_log_seq(0)\n+    CCheckQueue() : jobs(), status(), work(), cleanup(), should_sleep(0), RT_N_SCRIPTCHECK_THREADS(0), test_log_seq(0)\n     {\n     }\n \n-    void wait_for_cleanup() const\n-    {\n-        barrier.wait_reset(0);\n-        TEST_log(0, [](std::ostringstream& o) mutable {\n-            o << \"Cleanup waiting done!\\n\";\n-        });\n-    }\n     void reset_jobs()\n     {\n         jobs.reset_jobs();\n@@ -480,9 +430,13 @@ class CCheckQueue\n \n     void ControlLock() {\n         control_mtx.lock();\n+        TEST_log(0, [](std::ostringstream& o) {\n+            o << \"Resetting nTodo and fAllOk\" << '\\n';\n+        });\n         status.nTodo.store(0);\n         status.fAllOk.store(true);\n-\n+        wakeup();\n+        reset_jobs();\n     }\n     void ControlUnlock() {\n         control_mtx.unlock();\n@@ -493,20 +447,15 @@ class CCheckQueue\n     {\n         return Master();\n     }\n-\n-    //! Add a batch of checks to the queue\n-    void Add(std::vector<T>& vChecks)\n+    void quit()\n     {\n-        jobs.add(vChecks);\n-        size_t vs = vChecks.size();\n-        status.nTodo.fetch_add(vs);\n-\n-        TEST_log(0, [&, this](std::ostringstream& o) {\n-            o << \"Added \" << vs << \" values. nTodo was \" << status.nTodo.load() - vs\n-            << \" now is \" << status.nTodo.load() << \" \\n\";\n-        });\n+        die();\n+        for (auto& t : threads)\n+            t.join();\n+        threads.clear();\n     }\n \n+\n     void Add(std::ptrdiff_t vs)\n     {\n         status.nTodo.fetch_add(vs);\n@@ -523,29 +472,15 @@ class CCheckQueue\n     void init(const size_t RT_N_SCRIPTCHECK_THREADS_)\n     {\n         RT_N_SCRIPTCHECK_THREADS = RT_N_SCRIPTCHECK_THREADS_;\n-        barrier.init(RT_N_SCRIPTCHECK_THREADS);\n+        work.init(RT_N_SCRIPTCHECK_THREADS);\n+        cleanup.init(RT_N_SCRIPTCHECK_THREADS-1);\n         jobs.init(RT_N_SCRIPTCHECK_THREADS);\n \n         for (size_t id = 1; id < RT_N_SCRIPTCHECK_THREADS; ++id) {\n             std::thread t([=]() {Thread(id); });\n             threads.push_back(std::move(t));\n         }\n     }\n-    void wakeup()\n-    {\n-        ++should_sleep;\n-    }\n-    void sleep()\n-    {\n-        --should_sleep;\n-    }\n-    void quit()\n-    {\n-        should_sleep.store(3);\n-        for (auto& t : threads)\n-            t.join();\n-        threads.clear();\n-    }\n \n \n     JOB_TYPE** get_next_free_index()\n@@ -623,17 +558,14 @@ template <typename Q>\n class CCheckQueueControl\n {\n private:\n-    Q* pqueue;\n+    Q * const pqueue;\n     bool fDone;\n \n public:\n     CCheckQueueControl(Q* pqueueIn) : pqueue(pqueueIn), fDone(false)\n     {\n-        if (pqueue) {\n+        if (pqueue) \n             pqueue->ControlLock();\n-            pqueue->wakeup();\n-            pqueue->reset_jobs();\n-        }\n     }\n \n     bool Wait()\n@@ -645,11 +577,6 @@ class CCheckQueueControl\n         return fRet;\n     }\n \n-    void Add(std::vector<typename Q::JOB_TYPE>& vChecks)\n-    {\n-        if (pqueue != NULL)\n-            pqueue->Add(vChecks);\n-    }\n     void Add(std::ptrdiff_t d)\n     {\n         if (pqueue != NULL)"
      },
      {
        "sha": "6c68edb5582f61b9301ce8d90b631ecf0998c6a7",
        "filename": "src/test/checkqueue_tests.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 17,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/112b42b5162ce7e37263d58505ab42a501420389/src/test/checkqueue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/112b42b5162ce7e37263d58505ab42a501420389/src/test/checkqueue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkqueue_tests.cpp?ref=112b42b5162ce7e37263d58505ab42a501420389",
        "patch": "@@ -87,7 +87,7 @@ typedef CCheckQueue<FakeJobNoWork, (size_t)1000, MAX_SCRIPTCHECK_THREADS, true,\n \n typedef typename Standard_Queue::JOB_TYPE JT; // This is a \"recursive template\" hack\n typedef CCheckQueue_Internals::job_array<Standard_Queue> J;\n-typedef CCheckQueue_Internals::round_barrier<Standard_Queue> B;\n+typedef CCheckQueue_Internals::barrier<Standard_Queue> B;\n BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n {\n     fPrintToConsole = true;\n@@ -110,12 +110,14 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n             size_t r = GetRand(10);\n             std::vector<FailingJob> vChecks2;\n             vChecks2.reserve(r);\n+            auto p = control.get_next_free_index();\n+            auto p_ = *p;\n             for (size_t k = 0; k < r && !vChecks.empty(); k++) {\n-                vChecks2.emplace_back(vChecks.back());\n+                ((*p)++)->swap(vChecks.back());\n                 vChecks.pop_back();\n             }\n-            checksum += vChecks2.size();\n-            control.Add(vChecks2);\n+            checksum += std::distance(p_, *p);\n+            control.Add(std::distance(p_, *p));\n         }\n         BOOST_REQUIRE(checksum == i);\n         bool success = control.Wait();\n@@ -207,15 +209,14 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_job_array)\n BOOST_AUTO_TEST_CASE(test_CheckQueue_round_barrier)\n {\n     RAII_ThreadGroup threadGroup;\n-    auto barrier = std::shared_ptr<B>(new B());\n-    barrier->init(nScriptCheckThreads);\n-    for (int i = 0; i < nScriptCheckThreads; ++i)\n-        barrier->reset(i);\n+    auto b = std::shared_ptr<B>(new B());\n+    b->init(nScriptCheckThreads);\n+    b->reset();\n \n     for (int i = 0; i < nScriptCheckThreads; ++i) \n         threadGroup.create_thread([&, i]() {\n-            barrier->finished(i);\n-            barrier->wait_all_finished();\n+            b->finished();\n+            b->wait_all_finished();\n         });\n \n     threadGroup.join_all();\n@@ -243,11 +244,12 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_consume)\n     threadGroup.create_thread([&]() {\n         while (spawned != nScriptCheckThreads);\n         for (auto y = 0; y < 10; ++y) {\n-            std::vector<FakeJobNoWork> w;\n+            auto p = fast_queue->get_next_free_index();\n+            auto p_ = *p;\n             for (auto x = 0; x< 100; ++x) {\n-                w.push_back(FakeJobNoWork{});\n+                new ((*p)++) FakeJobNoWork{};\n             }\n-            fast_queue->Add(w);\n+            fast_queue->Add(std::distance(p_, *p));\n             MilliSleep(1);\n         }\n         fast_queue->TEST_set_masterJoined(true);\n@@ -284,13 +286,13 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct)\n             CCheckQueueControl<Correct_Queue> control(small_queue.get());\n             while (total) {\n                 size_t r = GetRand(10);\n-                std::vector<FakeJobCheckCompletion> vChecks;\n-                vChecks.reserve(r);\n+                auto p = control.get_next_free_index();\n+                auto p_ = *p; \n                 for (size_t k = 0; k < r && total; k++) {\n                     total--;\n-                    vChecks.push_back(FakeJobCheckCompletion{});\n+                    new ((*p)++) FakeJobCheckCompletion{};\n                 }\n-                control.Add(vChecks);\n+                control.Add(std::distance(p_, *p));\n             }\n         }\n         small_queue->TEST_dump_log(nScriptCheckThreads);"
      }
    ]
  },
  {
    "sha": "37ea0e39642cb628c210fd2d5ab2b59d19481a88",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozN2VhMGUzOTY0MmNiNjI4YzIxMGZkMmQ1YWIyYjU5ZDE5NDgxYTg4",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-14T23:02:50Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "remove useless status wrapper",
      "tree": {
        "sha": "946fc09ff5fbe3b83612662bbb8aa066e9e94969",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/946fc09ff5fbe3b83612662bbb8aa066e9e94969"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/37ea0e39642cb628c210fd2d5ab2b59d19481a88",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/37ea0e39642cb628c210fd2d5ab2b59d19481a88",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/37ea0e39642cb628c210fd2d5ab2b59d19481a88",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/37ea0e39642cb628c210fd2d5ab2b59d19481a88/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "112b42b5162ce7e37263d58505ab42a501420389",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/112b42b5162ce7e37263d58505ab42a501420389",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/112b42b5162ce7e37263d58505ab42a501420389"
      }
    ],
    "stats": {
      "total": 77,
      "additions": 25,
      "deletions": 52
    },
    "files": [
      {
        "sha": "b6338ffaa5023f9b681c2b4b3d90c10faf1f28c7",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 25,
        "deletions": 52,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/37ea0e39642cb628c210fd2d5ab2b59d19481a88/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/37ea0e39642cb628c210fd2d5ab2b59d19481a88/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=37ea0e39642cb628c210fd2d5ab2b59d19481a88",
        "patch": "@@ -121,7 +121,7 @@ class job_array\n         return Q::TEST_FUNCTIONS_ENABLE ? &checks : nullptr;\n     }\n };\n-/* round_barrier is used to communicate that a thread has finished\n+/* barrier is used to communicate that a thread has finished\n      * all work and reported any bad checks it might have seen.\n      *\n      * Results should normally be cached thread locally (once a thread is done, it\n@@ -139,33 +139,23 @@ class barrier\n     /** Default state is false so that first round looks like no prior round*/\n     barrier() : RT_N_SCRIPTCHECK_THREADS(0), count(0) {\n     }\n-\n     void init(const size_t rt)\n     {\n         RT_N_SCRIPTCHECK_THREADS = rt;\n     }\n-\n     void finished()\n     {\n         ++count;\n     }\n-\n     void wait_all_finished() const\n     {\n         while (count != RT_N_SCRIPTCHECK_THREADS)\n             ;\n     }\n-\n-    /** resets one bool\n-             *\n-             */\n     void reset()\n     {\n         count.store(0);\n     }\n-\n-    /** Waits until state is set false\n-            */\n     void wait_reset() const \n     {\n         while (count.load() != 0)\n@@ -255,22 +245,6 @@ class PriorityWorkQueue\n         return false;\n     }\n };\n-\n-/** status_container stores the \n-     * shared state for all nodes\n-     *\n-     * TODO: cache align things.*/\n-template <typename Q>\n-struct status_container {\n-    /** nTodo and  materJoined can be packed into one struct if desired*/\n-    std::atomic<size_t> nTodo;\n-    /** true if all checks were successful, false if any failure occurs */\n-    std::atomic<bool> fAllOk;\n-    /** true if the master has joined, false otherwise. A round may not terminate unless masterJoined */\n-    std::atomic<bool> masterJoined;\n-\n-    status_container() : nTodo(0), fAllOk(true), masterJoined(false){}\n-};\n }\n \n \n@@ -299,17 +273,21 @@ class CCheckQueue\n     static const size_t MAX_WORKERS = W;\n     static const bool TEST_FUNCTIONS_ENABLE = TFE;\n     static const bool TEST_LOGGING_ENABLE = TLE;\n-    // We use the Proto version so that we can pass it to job_array, status_container, etc\n \n private:\n     CCheckQueue_Internals::job_array<SELF> jobs;\n-    CCheckQueue_Internals::status_container<SELF> status;\n     CCheckQueue_Internals::barrier<SELF> work;\n     CCheckQueue_Internals::barrier<SELF> cleanup;\n     std::atomic<uint8_t> should_sleep;\n     size_t RT_N_SCRIPTCHECK_THREADS;\n     std::mutex control_mtx;\n \n+    /** nTodo and  materJoined can be packed into one struct if desired*/\n+    std::atomic<size_t> nTodo;\n+    /** true if all checks were successful, false if any failure occurs */\n+    std::atomic<bool> fAllOk;\n+    /** true if the master has joined, false otherwise. A round may not terminate unless masterJoined */\n+    std::atomic<bool> masterJoined;\n     //state only for testing\n     mutable std::atomic<size_t> test_log_seq;\n     mutable std::array<std::ostringstream, MAX_WORKERS> test_log;\n@@ -355,13 +333,13 @@ class CCheckQueue\n         do {\n             // Note: Must check masterJoined before nTodo, otherwise\n             // {Thread A: nTodo.load();} {Thread B:nTodo++; masterJoined = true;} {Thread A: masterJoined.load()}\n-            no_stealing = !status.masterJoined.load();\n-            work_queue.add(status.nTodo.load());\n-            (got_data = work_queue.pop(job_id, no_stealing)) && jobs.reserve(job_id) && (jobs.eval(job_id) || (status.fAllOk.store(false), false));\n-        } while (status.fAllOk.load() && (no_stealing || got_data));\n+            no_stealing = !masterJoined.load();\n+            work_queue.add(nTodo.load());\n+            (got_data = work_queue.pop(job_id, no_stealing)) && jobs.reserve(job_id) && (jobs.eval(job_id) || (fAllOk.store(false), false));\n+        } while (fAllOk.load() && (no_stealing || got_data));\n             \n         TEST_log(ID, [&, this](std::ostringstream& o) {\n-            o << \"Leaving consume. fAllOk was \" << status.fAllOk.load() << \"\\n\";\n+            o << \"Leaving consume. fAllOk was \" << fAllOk.load() << \"\\n\";\n         });\n         return work_queue.get_total();\n     }\n@@ -370,15 +348,15 @@ class CCheckQueue\n         const size_t ID = 0;\n \n         work.wait_reset();\n-        status.masterJoined.store(true);\n+        masterJoined.store(true);\n         TEST_log(ID, [](std::ostringstream& o) { o << \"Master just set masterJoined\\n\"; });\n         consume(ID);\n         work.finished();\n         work.wait_all_finished();\n         TEST_log(ID, [](std::ostringstream& o) { o << \"(Master) saw all threads finished\\n\"; });\n-        bool fRet = status.fAllOk;\n+        bool fRet = fAllOk;\n         sleep();\n-        status.masterJoined.store(false);\n+        masterJoined.store(false);\n         return fRet;\n     }\n     void Loop(const size_t ID)\n@@ -388,14 +366,14 @@ class CCheckQueue\n             size_t prev_total = consume(ID);\n             TEST_log(ID, [&, this](std::ostringstream& o) {\n                 o << \"saw up to \" << prev_total << \" master was \"\n-                << status.masterJoined.load() << \" nTodo \" << status.nTodo.load() << '\\n';\n+                << masterJoined.load() << \" nTodo \" << nTodo.load() << '\\n';\n             });\n             // Only spins here if !fAllOk, otherwise consume finished all\n-            while (!status.masterJoined.load())\n+            while (!masterJoined.load())\n                 ;\n             work.finished();\n             // We wait until the master reports leaving explicitly\n-            while (status.masterJoined.load())\n+            while (masterJoined.load())\n                 ;\n             TEST_log(ID, [](std::ostringstream& o) { o << \"Saw master leave\\n\"; });\n             jobs.reset_flags_for(ID, prev_total);\n@@ -412,9 +390,8 @@ class CCheckQueue\n     }\n \n public:\n-    CCheckQueue() : jobs(), status(), work(), cleanup(), should_sleep(0), RT_N_SCRIPTCHECK_THREADS(0), test_log_seq(0)\n-    {\n-    }\n+    CCheckQueue() : jobs(), work(), cleanup(), should_sleep(0), RT_N_SCRIPTCHECK_THREADS(0),\n+    nTodo(0), fAllOk(true), masterJoined(false), test_log_seq(0) {}\n \n     void reset_jobs()\n     {\n@@ -433,8 +410,8 @@ class CCheckQueue\n         TEST_log(0, [](std::ostringstream& o) {\n             o << \"Resetting nTodo and fAllOk\" << '\\n';\n         });\n-        status.nTodo.store(0);\n-        status.fAllOk.store(true);\n+        nTodo.store(0);\n+        fAllOk.store(true);\n         wakeup();\n         reset_jobs();\n     }\n@@ -458,10 +435,10 @@ class CCheckQueue\n \n     void Add(std::ptrdiff_t vs)\n     {\n-        status.nTodo.fetch_add(vs);\n+        nTodo.fetch_add(vs);\n         TEST_log(0, [&, this](std::ostringstream& o) {\n             o << \"Added \" << vs << \" values. nTodo was \" \n-            << status.nTodo.load() - vs << \" now is \" << status.nTodo.load() << \" \\n\";\n+            << nTodo.load() - vs << \" now is \" << nTodo.load() << \" \\n\";\n         });\n     }\n     ~CCheckQueue()\n@@ -495,7 +472,7 @@ class CCheckQueue\n     void TEST_set_masterJoined(const bool b)\n     {\n         if (TEST_FUNCTIONS_ENABLE)\n-            status.masterJoined.store(b);\n+            masterJoined.store(b);\n     }\n \n     size_t TEST_count_set_flags()\n@@ -540,10 +517,6 @@ class CCheckQueue\n     }\n \n \n-    CCheckQueue_Internals::status_container<SELF>* TEST_introspect_status()\n-    {\n-        return TEST_FUNCTIONS_ENABLE ? &status : nullptr;\n-    }\n     CCheckQueue_Internals::job_array<SELF>* TEST_introspect_jobs()\n     {\n         return TEST_FUNCTIONS_ENABLE ? &jobs : nullptr;"
      }
    ]
  },
  {
    "sha": "41e87d821b4c5cfbd91c13c7e7d9be5b30f82131",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MWU4N2Q4MjFiNGM1Y2ZiZDkxYzEzYzdlN2Q5YmU1YjMwZjgyMTMx",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-14T23:03:17Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "disable tests printouts",
      "tree": {
        "sha": "1718b4cea39cec5ce9d6357f26230cc590fffc2d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1718b4cea39cec5ce9d6357f26230cc590fffc2d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/41e87d821b4c5cfbd91c13c7e7d9be5b30f82131",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/41e87d821b4c5cfbd91c13c7e7d9be5b30f82131",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/41e87d821b4c5cfbd91c13c7e7d9be5b30f82131",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/41e87d821b4c5cfbd91c13c7e7d9be5b30f82131/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "37ea0e39642cb628c210fd2d5ab2b59d19481a88",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/37ea0e39642cb628c210fd2d5ab2b59d19481a88",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/37ea0e39642cb628c210fd2d5ab2b59d19481a88"
      }
    ],
    "stats": {
      "total": 11,
      "additions": 4,
      "deletions": 7
    },
    "files": [
      {
        "sha": "df947ae2b87473faff596ba193e634bcd84a6db2",
        "filename": "src/test/checkqueue_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 7,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/41e87d821b4c5cfbd91c13c7e7d9be5b30f82131/src/test/checkqueue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/41e87d821b4c5cfbd91c13c7e7d9be5b30f82131/src/test/checkqueue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkqueue_tests.cpp?ref=41e87d821b4c5cfbd91c13c7e7d9be5b30f82131",
        "patch": "@@ -40,7 +40,7 @@ class RAII_ThreadGroup {\n \n struct FakeJob {\n };\n-typedef CCheckQueue<FakeJob, (size_t)1000, MAX_SCRIPTCHECK_THREADS, true, true> Standard_Queue;\n+typedef CCheckQueue<FakeJob, (size_t)1000, MAX_SCRIPTCHECK_THREADS, true, false> Standard_Queue;\n struct FakeJobCheckCompletion {\n     static std::atomic<size_t> n_calls;\n     bool operator()()\n@@ -51,7 +51,7 @@ struct FakeJobCheckCompletion {\n     void swap(FakeJobCheckCompletion& x){};\n };\n std::atomic<size_t> FakeJobCheckCompletion::n_calls {0};\n-typedef CCheckQueue<FakeJobCheckCompletion, (size_t)100, MAX_SCRIPTCHECK_THREADS, true, true> Correct_Queue;\n+typedef CCheckQueue<FakeJobCheckCompletion, (size_t)100, MAX_SCRIPTCHECK_THREADS, true, false> Correct_Queue;\n \n struct FailingJob {\n     bool f;\n@@ -75,22 +75,21 @@ struct FailingJob {\n     };\n };\n std::atomic<size_t> FailingJob::n_calls {0};\n-typedef CCheckQueue<FailingJob, (size_t)1000, MAX_SCRIPTCHECK_THREADS, true, true> Failing_Queue;\n+typedef CCheckQueue<FailingJob, (size_t)1000, MAX_SCRIPTCHECK_THREADS, true, false> Failing_Queue;\n struct FakeJobNoWork {\n     bool operator()()\n     {\n         return true;\n     }\n     void swap(FakeJobNoWork& x){};\n };\n-typedef CCheckQueue<FakeJobNoWork, (size_t)1000, MAX_SCRIPTCHECK_THREADS, true, true> Consume_Queue;\n+typedef CCheckQueue<FakeJobNoWork, (size_t)1000, MAX_SCRIPTCHECK_THREADS, true, false> Consume_Queue;\n \n typedef typename Standard_Queue::JOB_TYPE JT; // This is a \"recursive template\" hack\n typedef CCheckQueue_Internals::job_array<Standard_Queue> J;\n typedef CCheckQueue_Internals::barrier<Standard_Queue> B;\n BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n {\n-    fPrintToConsole = true;\n     auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue());\n \n     fail_queue->init(nScriptCheckThreads);\n@@ -136,7 +135,6 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n         }\n         fail_queue->TEST_erase_log();\n     }\n-    fPrintToConsole = false;\n }\n BOOST_AUTO_TEST_CASE(test_CheckQueue_PriorityWorkQueue)\n {\n@@ -275,7 +273,6 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_consume)\n \n BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct)\n {\n-    fPrintToConsole = true;\n     auto small_queue = std::shared_ptr<Correct_Queue>(new Correct_Queue);\n     small_queue->init(nScriptCheckThreads);\n "
      }
    ]
  },
  {
    "sha": "e2686e1998fdfc0a2c7d5cdd48b20d36b4a5a3e7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMjY4NmUxOTk4ZmRmYzBhMmM3ZDVjZGQ0OGIyMGQzNmI0YTVhM2U3",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-15T18:15:50Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "Minor patch to quitting code, not certain it's race-free yet",
      "tree": {
        "sha": "83d58705fbd1977d56f933356ea7667959284055",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/83d58705fbd1977d56f933356ea7667959284055"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e2686e1998fdfc0a2c7d5cdd48b20d36b4a5a3e7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e2686e1998fdfc0a2c7d5cdd48b20d36b4a5a3e7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e2686e1998fdfc0a2c7d5cdd48b20d36b4a5a3e7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e2686e1998fdfc0a2c7d5cdd48b20d36b4a5a3e7/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "41e87d821b4c5cfbd91c13c7e7d9be5b30f82131",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/41e87d821b4c5cfbd91c13c7e7d9be5b30f82131",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/41e87d821b4c5cfbd91c13c7e7d9be5b30f82131"
      }
    ],
    "stats": {
      "total": 9,
      "additions": 5,
      "deletions": 4
    },
    "files": [
      {
        "sha": "ed834f2011ba428f3832bf28dd9563b13f75f3cb",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e2686e1998fdfc0a2c7d5cdd48b20d36b4a5a3e7/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e2686e1998fdfc0a2c7d5cdd48b20d36b4a5a3e7/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=e2686e1998fdfc0a2c7d5cdd48b20d36b4a5a3e7",
        "patch": "@@ -426,6 +426,7 @@ class CCheckQueue\n     }\n     void quit()\n     {\n+        std::lock_guard<std::mutex> l(control_mtx);\n         die();\n         for (auto& t : threads)\n             t.join();\n@@ -452,6 +453,7 @@ class CCheckQueue\n         work.init(RT_N_SCRIPTCHECK_THREADS);\n         cleanup.init(RT_N_SCRIPTCHECK_THREADS-1);\n         jobs.init(RT_N_SCRIPTCHECK_THREADS);\n+        should_sleep.store(0);\n \n         for (size_t id = 1; id < RT_N_SCRIPTCHECK_THREADS; ++id) {\n             std::thread t([=]() {Thread(id); });"
      },
      {
        "sha": "3bced6bf81ff210b052bb4642b73a5da88c3a177",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e2686e1998fdfc0a2c7d5cdd48b20d36b4a5a3e7/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e2686e1998fdfc0a2c7d5cdd48b20d36b4a5a3e7/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=e2686e1998fdfc0a2c7d5cdd48b20d36b4a5a3e7",
        "patch": "@@ -47,8 +47,7 @@ BasicTestingSetup::~BasicTestingSetup()\n \n TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(chainName)\n {\n-    static std::atomic_flag one_time_setup = ATOMIC_FLAG_INIT;\n-    const CChainParams& chainparams = Params();\n+        const CChainParams& chainparams = Params();\n         // Ideally we'd move all the RPC tests to the functional testing framework\n         // instead of unit tests, but for now we need these here.\n         RegisterAllCoreRPCCommands(tableRPC);\n@@ -67,8 +66,7 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n             BOOST_CHECK(ok);\n         }\n         nScriptCheckThreads = 3;\n-        if (!one_time_setup.test_and_set())\n-            SetupCCheckQueue(nScriptCheckThreads);\n+        SetupCCheckQueue(nScriptCheckThreads);\n         RegisterNodeSignals(GetNodeSignals());\n }\n \n@@ -77,6 +75,7 @@ TestingSetup::~TestingSetup()\n         UnregisterNodeSignals(GetNodeSignals());\n         threadGroup.interrupt_all();\n         threadGroup.join_all();\n+        StopCCheckQueue();\n         UnloadBlockIndex();\n         delete pcoinsTip;\n         delete pcoinsdbview;"
      }
    ]
  },
  {
    "sha": "20a739f26ec45373b79a7e838ede381ea29474ef",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMGE3MzlmMjZlYzQ1MzczYjc5YTdlODM4ZWRlMzgxZWEyOTQ3NGVm",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-17T00:34:34Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "Critical Fix: prev_total was checked too early in the event of a fAllOk quit. Added a test which checks that unique jobs are called. Refactored a lot of code to make emplacement happen RAII style",
      "tree": {
        "sha": "e84fad6fe50710a1f9d32107a818df7dc596805c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e84fad6fe50710a1f9d32107a818df7dc596805c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/20a739f26ec45373b79a7e838ede381ea29474ef",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/20a739f26ec45373b79a7e838ede381ea29474ef",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/20a739f26ec45373b79a7e838ede381ea29474ef",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/20a739f26ec45373b79a7e838ede381ea29474ef/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e2686e1998fdfc0a2c7d5cdd48b20d36b4a5a3e7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e2686e1998fdfc0a2c7d5cdd48b20d36b4a5a3e7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e2686e1998fdfc0a2c7d5cdd48b20d36b4a5a3e7"
      }
    ],
    "stats": {
      "total": 375,
      "additions": 216,
      "deletions": 159
    },
    "files": [
      {
        "sha": "ef6c4ba6fca78d92d958ef3af2f4b7b5acf7c2b5",
        "filename": "src/bench/checkqueue.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20a739f26ec45373b79a7e838ede381ea29474ef/src/bench/checkqueue.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20a739f26ec45373b79a7e838ede381ea29474ef/src/bench/checkqueue.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkqueue.cpp?ref=20a739f26ec45373b79a7e838ede381ea29474ef",
        "patch": "@@ -28,11 +28,9 @@ static void CCheckQueueSpeed(benchmark::State& state)\n             for (size_t j = 0; j < 101; ++j) {\n                 size_t r = 30;\n                 total += r;\n-                auto p = control.get_next_free_index();\n-                auto p_ = *p;\n+                auto inserter = control.get_inserter();\n                 for (size_t k = 0; k < r; ++k)\n-                    new ((*p)++) FakeJobNoWork{};\n-                control.Add(std::distance(p_, *p));\n+                    new (inserter()) FakeJobNoWork{};\n             }\n         }\n     }"
      },
      {
        "sha": "5e2c22f0ff860e44d12c6ed632a60a58f1ee686f",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 145,
        "deletions": 110,
        "changes": 255,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20a739f26ec45373b79a7e838ede381ea29474ef/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20a739f26ec45373b79a7e838ede381ea29474ef/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=20a739f26ec45373b79a7e838ede381ea29474ef",
        "patch": "@@ -39,6 +39,26 @@ class CCheckQueueControl;\n  * of CCheckQueue, but is separate for easier testability and modularity */\n namespace CCheckQueue_Internals\n {\n+template <typename Q>\n+class inserter {\n+    Q * const queue;\n+    typename Q::JOB_TYPE * start;\n+    typename Q::JOB_TYPE * free_index;\n+    public:\n+    inserter(Q * const queueIn) :\n+       queue(queueIn), start(queue ? queue->get_next_free_index() : nullptr), free_index(start) {}\n+\n+\n+    typename Q::JOB_TYPE * operator()()\n+    {\n+        return start ? free_index++ : nullptr;\n+    }\n+    ~inserter()\n+    {\n+        if (queue)\n+            queue->Flush(std::distance(start, free_index));\n+    }\n+};\n /** job_array holds the atomic flags and the job data for the queue\n      * and provides methods to assist in accessing or adding jobs.\n      */\n@@ -56,8 +76,10 @@ class job_array\n     size_t RT_N_SCRIPTCHECK_THREADS;\n \n public:\n-    job_array() : next_free_index(checks.begin()), RT_N_SCRIPTCHECK_THREADS(0)\n+    job_array() :  next_free_index(checks.begin()), RT_N_SCRIPTCHECK_THREADS(0)\n     {\n+        for (size_t i = 0; i < Q::MAX_JOBS; ++i) \n+            checks[i] = typename Q::JOB_TYPE {};\n         for (auto& i : flags)\n             i.clear();\n     }\n@@ -66,18 +88,16 @@ class job_array\n     {\n         RT_N_SCRIPTCHECK_THREADS = rt;\n     }\n-    /** add swaps a vector of checks into the checks array and increments the pointer\n-             * not threadsafe */\n-    void add(std::vector<typename Q::JOB_TYPE>& vChecks)\n+\n+    typename Q::JOB_TYPE* get_next_free_index()\n     {\n-        for (typename Q::JOB_TYPE& check : vChecks)\n-            check.swap(*(next_free_index++));\n+        return next_free_index;\n     }\n-    typename Q::JOB_TYPE** get_next_free_index()\n+    void Add(ptrdiff_t n) \n     {\n-        return &next_free_index;\n+        next_free_index += n;\n     }\n-\n+    \n     /** reserve tries to set a flag for an element \n              * and returns if it was successful */\n     bool reserve(const size_t i)\n@@ -115,6 +135,13 @@ class job_array\n     {\n         next_free_index = checks.begin();\n     }\n+    void clear_all_data()\n+    {\n+        for (size_t i = 0; i < Q::MAX_JOBS; ++i) {\n+            typename Q::JOB_TYPE tmp {};\n+            checks[i].swap(tmp);\n+        }\n+    }\n \n     decltype(&checks) TEST_get_checks()\n     {\n@@ -225,14 +252,14 @@ class PriorityWorkQueue\n     /* Get one first from out own work stack (take the first one) and then try from neighbors sequentially\n              * (from the last one on that neighbors stack)\n              */\n-    bool pop(size_t& val, const bool no_stealing)\n+    bool pop(size_t& val, const bool stealing)\n     {\n         val = (id + (n_done[id]) * RT_N_SCRIPTCHECK_THREADS);\n         if (val < total) {\n             ++n_done[id];\n             return true;\n         }\n-        if (no_stealing)\n+        if (!stealing)\n             return false;\n         // Iterate untill id2 wraps around to id.\n         for (; id2_cache != id; id2_cache = (id2_cache + 1) % RT_N_SCRIPTCHECK_THREADS) {\n@@ -245,6 +272,42 @@ class PriorityWorkQueue\n         return false;\n     }\n };\n+\n+class atomic_condition {\n+    std::atomic<uint8_t> state;\n+    public:\n+    atomic_condition() : state(0) {};\n+    void wakeup()\n+    {\n+        ++state;\n+    }\n+    void sleep()\n+    {\n+        --state;\n+    }\n+    void kill()\n+    {\n+        state.store(3);\n+    }\n+    void resurrect()\n+    {\n+        state.store(0);\n+    }\n+    bool wait() const\n+    {\n+        for (;;) {\n+            switch (state.load()) {\n+                case 0:\n+                    std::this_thread::sleep_for(std::chrono::microseconds(1));\n+                    break;\n+                case 1:\n+                    return true;\n+                default:\n+                    return false;\n+            }\n+        }\n+    }\n+};\n }\n \n \n@@ -278,75 +341,55 @@ class CCheckQueue\n     CCheckQueue_Internals::job_array<SELF> jobs;\n     CCheckQueue_Internals::barrier<SELF> work;\n     CCheckQueue_Internals::barrier<SELF> cleanup;\n-    std::atomic<uint8_t> should_sleep;\n+    CCheckQueue_Internals::atomic_condition sleeper;\n     size_t RT_N_SCRIPTCHECK_THREADS;\n-    std::mutex control_mtx;\n-\n-    /** nTodo and  materJoined can be packed into one struct if desired*/\n-    std::atomic<size_t> nTodo;\n+    /** The number of checks put into the queue, done or not */\n+    std::atomic<size_t> nAvail;\n     /** true if all checks were successful, false if any failure occurs */\n     std::atomic<bool> fAllOk;\n     /** true if the master has joined, false otherwise. A round may not terminate unless masterJoined */\n     std::atomic<bool> masterJoined;\n-    //state only for testing\n+    /** hold handles for work */\n+    std::vector<std::thread> threads;\n+    /** Makes sure only one thread is using control functionality at a time*/\n+    std::mutex control_mtx;\n+    /** state only for testing */\n     mutable std::atomic<size_t> test_log_seq;\n     mutable std::array<std::ostringstream, MAX_WORKERS> test_log;\n-    std::vector<std::thread> threads;\n \n \n-    void wakeup()\n-    {\n-        ++should_sleep;\n-    }\n-    void sleep()\n-    {\n-        --should_sleep;\n-    }\n-    void die()\n-    {\n-        should_sleep.store(3);\n-    }\n-    bool maybe_sleep() const\n-    {\n-        for (;;) {\n-            switch (should_sleep.load()) {\n-            case 0:\n-                std::this_thread::sleep_for(std::chrono::microseconds(1));\n-                break;\n-            case 1:\n-                return true;\n-            default:\n-                return false;\n-            }\n-        }\n-    }\n \n-    size_t consume(const size_t ID)\n+    void consume(const size_t ID)\n     {\n         TEST_log(ID, [](std::ostringstream& o) {\n             o << \"In consume\\n\";\n         });\n         CCheckQueue_Internals::PriorityWorkQueue<SELF> work_queue(ID, RT_N_SCRIPTCHECK_THREADS);\n-        bool no_stealing;\n-        bool got_data;\n-        size_t job_id;\n-        do {\n-            // Note: Must check masterJoined before nTodo, otherwise\n-            // {Thread A: nTodo.load();} {Thread B:nTodo++; masterJoined = true;} {Thread A: masterJoined.load()}\n-            no_stealing = !masterJoined.load();\n-            work_queue.add(nTodo.load());\n-            (got_data = work_queue.pop(job_id, no_stealing)) && jobs.reserve(job_id) && (jobs.eval(job_id) || (fAllOk.store(false), false));\n-        } while (fAllOk.load() && (no_stealing || got_data));\n+        for (;;) {\n+            // Note: Must check masterJoined before nAvail, otherwise\n+            // {Thread A: nAvail.load();} {Thread B:nAvail++; masterJoined = true;} {Thread A: masterJoined.load()}\n+            bool stealing = masterJoined.load();\n+            work_queue.add(nAvail.load());\n+            size_t job_id;\n+            bool got_data = work_queue.pop(job_id, stealing);\n+            if (got_data && jobs.reserve(job_id)) {\n+                if (!jobs.eval(job_id)) {\n+                    fAllOk.store(false);\n+                    return;\n+                }\n+            }\n+            else if (stealing && !got_data)\n+                break;\n+\n+        } \n             \n         TEST_log(ID, [&, this](std::ostringstream& o) {\n             o << \"Leaving consume. fAllOk was \" << fAllOk.load() << \"\\n\";\n         });\n-        return work_queue.get_total();\n     }\n     /** Internal function that does bulk of the verification work. */\n     bool Master() {\n         const size_t ID = 0;\n-\n         work.wait_reset();\n         masterJoined.store(true);\n         TEST_log(ID, [](std::ostringstream& o) { o << \"Master just set masterJoined\\n\"; });\n@@ -355,22 +398,23 @@ class CCheckQueue\n         work.wait_all_finished();\n         TEST_log(ID, [](std::ostringstream& o) { o << \"(Master) saw all threads finished\\n\"; });\n         bool fRet = fAllOk;\n-        sleep();\n+        sleeper.sleep();\n         masterJoined.store(false);\n         return fRet;\n     }\n     void Loop(const size_t ID)\n     {\n-        while (maybe_sleep()) {\n+        while (sleeper.wait()) {\n             TEST_log(ID, [](std::ostringstream& o) {o << \"Round starting\\n\";});\n-            size_t prev_total = consume(ID);\n-            TEST_log(ID, [&, this](std::ostringstream& o) {\n-                o << \"saw up to \" << prev_total << \" master was \"\n-                << masterJoined.load() << \" nTodo \" << nTodo.load() << '\\n';\n-            });\n+            consume(ID);\n             // Only spins here if !fAllOk, otherwise consume finished all\n             while (!masterJoined.load())\n                 ;\n+            size_t prev_total = nAvail.load();\n+            TEST_log(ID, [&, this](std::ostringstream& o) {\n+                o << \"saw up to \" << prev_total << \" master was \"\n+                << masterJoined.load() << \" nAvail \" << nAvail.load() << '\\n';\n+            });\n             work.finished();\n             // We wait until the master reports leaving explicitly\n             while (masterJoined.load())\n@@ -390,8 +434,8 @@ class CCheckQueue\n     }\n \n public:\n-    CCheckQueue() : jobs(), work(), cleanup(), should_sleep(0), RT_N_SCRIPTCHECK_THREADS(0),\n-    nTodo(0), fAllOk(true), masterJoined(false), test_log_seq(0) {}\n+    CCheckQueue() : jobs(), work(), cleanup(), sleeper(), RT_N_SCRIPTCHECK_THREADS(0),\n+    nAvail(0), fAllOk(true), masterJoined(false), test_log_seq(0) {}\n \n     void reset_jobs()\n     {\n@@ -408,11 +452,11 @@ class CCheckQueue\n     void ControlLock() {\n         control_mtx.lock();\n         TEST_log(0, [](std::ostringstream& o) {\n-            o << \"Resetting nTodo and fAllOk\" << '\\n';\n+            o << \"Resetting nAvail and fAllOk\" << '\\n';\n         });\n-        nTodo.store(0);\n+        nAvail.store(0);\n         fAllOk.store(true);\n-        wakeup();\n+        sleeper.wakeup();\n         reset_jobs();\n     }\n     void ControlUnlock() {\n@@ -427,19 +471,23 @@ class CCheckQueue\n     void quit()\n     {\n         std::lock_guard<std::mutex> l(control_mtx);\n-        die();\n+        sleeper.kill();\n         for (auto& t : threads)\n             t.join();\n         threads.clear();\n+        jobs.clear_all_data();\n     }\n \n-\n-    void Add(std::ptrdiff_t vs)\n+    JOB_TYPE* get_next_free_index() {\n+        return jobs.get_next_free_index();\n+    }\n+    void Flush(std::ptrdiff_t n)\n     {\n-        nTodo.fetch_add(vs);\n+        nAvail.fetch_add(n);\n+        jobs.Add(n);\n         TEST_log(0, [&, this](std::ostringstream& o) {\n-            o << \"Added \" << vs << \" values. nTodo was \" \n-            << nTodo.load() - vs << \" now is \" << nTodo.load() << \" \\n\";\n+            o << \"Added \" << n << \" values. nAvail was \" \n+            << nAvail.load() - n << \" now is \" << nAvail.load() << \" \\n\";\n         });\n     }\n     ~CCheckQueue()\n@@ -449,28 +497,26 @@ class CCheckQueue\n \n     void init(const size_t RT_N_SCRIPTCHECK_THREADS_)\n     {\n+        std::lock_guard<std::mutex> l(control_mtx);\n         RT_N_SCRIPTCHECK_THREADS = RT_N_SCRIPTCHECK_THREADS_;\n         work.init(RT_N_SCRIPTCHECK_THREADS);\n         cleanup.init(RT_N_SCRIPTCHECK_THREADS-1);\n         jobs.init(RT_N_SCRIPTCHECK_THREADS);\n-        should_sleep.store(0);\n-\n+        sleeper.resurrect();\n         for (size_t id = 1; id < RT_N_SCRIPTCHECK_THREADS; ++id) {\n             std::thread t([=]() {Thread(id); });\n             threads.push_back(std::move(t));\n         }\n     }\n \n+    /** Various testing functionalities */\n \n-    JOB_TYPE** get_next_free_index()\n+    void TEST_consume(const size_t ID)\n     {\n-        return jobs.get_next_free_index();\n+        if (TEST_FUNCTIONS_ENABLE)\n+            consume(ID);\n     }\n \n-    size_t TEST_consume(const size_t ID)\n-    {\n-        return TEST_FUNCTIONS_ENABLE ? consume(ID) : 0;\n-    }\n     void TEST_set_masterJoined(const bool b)\n     {\n         if (TEST_FUNCTIONS_ENABLE)\n@@ -480,17 +526,17 @@ class CCheckQueue\n     size_t TEST_count_set_flags()\n     {\n         auto count = 0;\n-        if (TEST_FUNCTIONS_ENABLE)\n-            for (auto t = 0; t < MAX_JOBS; ++t)\n-                count += jobs.reserve(t) ? 0 : 1;\n+        for (auto t = 0; t < MAX_JOBS && TEST_FUNCTIONS_ENABLE; ++t)\n+            count += jobs.reserve(t) ? 0 : 1;\n         return count;\n     }\n+\n     void TEST_reset_all_flags()\n     {\n-        if (TEST_FUNCTIONS_ENABLE)\n-            for (auto t = 0; t < MAX_JOBS; ++t)\n-                jobs.reset_flag(t);\n+        for (auto t = 0; t < MAX_JOBS && TEST_FUNCTIONS_ENABLE; ++t)\n+            jobs.reset_flag(t);\n     }\n+\n     template <typename Callable>\n     void TEST_log(const size_t ID, Callable c) const\n     {\n@@ -499,9 +545,9 @@ class CCheckQueue\n             c(test_log[ID]);\n         }\n     }\n+\n     void TEST_dump_log(const size_t upto) const\n     {\n-\n         if (TEST_FUNCTIONS_ENABLE) {\n             LogPrintf(\"\\n#####################\\n## Round Beginning ##\\n#####################\");\n             for (auto i = 0; i < upto; ++i)\n@@ -511,14 +557,12 @@ class CCheckQueue\n \n     void TEST_erase_log() const\n     {\n-        if (TEST_FUNCTIONS_ENABLE)\n-            for (auto i = 0; i < MAX_WORKERS; ++i) {\n-                test_log[i].str(\"\");\n-                test_log[i].clear();\n-            }\n+        for (auto i = 0; i < MAX_WORKERS && TEST_FUNCTIONS_ENABLE; ++i) {\n+            test_log[i].str(\"\");\n+            test_log[i].clear();\n+        }\n     }\n \n-\n     CCheckQueue_Internals::job_array<SELF>* TEST_introspect_jobs()\n     {\n         return TEST_FUNCTIONS_ENABLE ? &jobs : nullptr;\n@@ -545,30 +589,21 @@ class CCheckQueueControl\n \n     bool Wait()\n     {\n-        if (pqueue == NULL)\n+        if (!pqueue || fDone)\n             return true;\n         bool fRet = pqueue->Wait();\n         fDone = true;\n+        pqueue->ControlUnlock();\n         return fRet;\n     }\n \n-    void Add(std::ptrdiff_t d)\n-    {\n-        if (pqueue != NULL)\n-            pqueue->Add(d);\n-    }\n-\n-    typename Q::JOB_TYPE** get_next_free_index()\n-    {\n-        return pqueue ? pqueue->get_next_free_index() : nullptr;\n+    CCheckQueue_Internals::inserter<Q> get_inserter() {\n+        return CCheckQueue_Internals::inserter<Q>(pqueue);\n     }\n \n     ~CCheckQueueControl()\n     {\n-        if (!fDone)\n-            Wait();\n-        if (pqueue)\n-            pqueue->ControlUnlock();\n+        Wait();\n     }\n };\n "
      },
      {
        "sha": "9f54be6c57f3e42bdb32443d678d201bd6a83dce",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 13,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20a739f26ec45373b79a7e838ede381ea29474ef/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20a739f26ec45373b79a7e838ede381ea29474ef/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=20a739f26ec45373b79a7e838ede381ea29474ef",
        "patch": "@@ -1969,7 +1969,7 @@ bool CheckTxInputs(const CTransaction& tx, CValidationState& state, const CCoins\n }\n }// namespace Consensus\n \n-bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheStore, CScriptCheck **pvChecks)\n+bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheStore, std::function<CScriptCheck * ()> inserter)\n {\n     if (!tx.IsCoinBase())\n     {\n@@ -1994,12 +1994,11 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                 assert(coins);\n \n                 // Verify signature\n-                CScriptCheck check;\n-                bool validMemory = pvChecks && *pvChecks;\n-                if (validMemory)\n-                    (*pvChecks)->~CScriptCheck();\n-                new(validMemory ? (*pvChecks)++ : &check) CScriptCheck(*coins, tx, i, flags, cacheStore);\n-                if (!validMemory && !check()) {\n+                CScriptCheck check =  CScriptCheck(*coins, tx, i, flags, cacheStore);\n+                CScriptCheck * const ptr = inserter();\n+                if (ptr)\n+                    ptr->swap(check);\n+                else if (!check()) {\n                     if (flags & STANDARD_NOT_MANDATORY_VERIFY_FLAGS) {\n                         // Check whether the failure was caused by a\n                         // non-mandatory script verification check, such as\n@@ -2022,6 +2021,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                     return state.DoS(100,false, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n                 }\n             }\n+\n         }\n     }\n \n@@ -2395,7 +2395,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n \n     CBlockUndo blockundo;\n \n-    CCheckQueueControl<decltype(scriptcheckqueue)> control(fScriptChecks && nScriptCheckThreads ? &scriptcheckqueue : NULL);\n+    CCheckQueueControl<decltype(scriptcheckqueue)> control(fScriptChecks && nScriptCheckThreads ? &scriptcheckqueue : nullptr);\n \n     std::vector<uint256> vOrphanErase;\n     std::vector<int> prevheights;\n@@ -2457,13 +2457,10 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n             nFees += view.GetValueIn(tx)-tx.GetValueOut();\n \n             bool fCacheResults = fJustCheck; /* Don't cache results if we're actually connecting blocks (still consult the cache, though) */\n-            CScriptCheck **  ptr = control.get_next_free_index();\n-            CScriptCheck * initial = *ptr;\n-            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, nScriptCheckThreads ? ptr : NULL))\n+            std::function<CScriptCheck*()> inserter = control.get_inserter();\n+            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, inserter))\n                 return error(\"ConnectBlock(): CheckInputs on %s failed with %s\",\n                     tx.GetHash().ToString(), FormatStateMessage(state));\n-\n-            control.Add(std::distance(initial, *ptr));\n         }\n \n         CTxUndo undoDummy;"
      },
      {
        "sha": "d7cb20d51cf4c9f6132a0b0cbaf08f9577ccb3b0",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20a739f26ec45373b79a7e838ede381ea29474ef/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20a739f26ec45373b79a7e838ede381ea29474ef/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=20a739f26ec45373b79a7e838ede381ea29474ef",
        "patch": "@@ -349,7 +349,7 @@ int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& i\n  * instead of being performed inline.\n  */\n bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &view, bool fScriptChecks,\n-                 unsigned int flags, bool cacheStore, CScriptCheck **pvChecks = NULL);\n+                 unsigned int flags, bool cacheStore, std::function<CScriptCheck * () > inserter = [](){return nullptr;});\n \n /** Apply the effects of this transaction on the UTXO set represented by view */\n void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, int nHeight);"
      },
      {
        "sha": "1e01aa7d86240fa43d1a64e21c3e045515ef6595",
        "filename": "src/test/checkqueue_tests.cpp",
        "status": "modified",
        "additions": 58,
        "deletions": 31,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20a739f26ec45373b79a7e838ede381ea29474ef/src/test/checkqueue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20a739f26ec45373b79a7e838ede381ea29474ef/src/test/checkqueue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkqueue_tests.cpp?ref=20a739f26ec45373b79a7e838ede381ea29474ef",
        "patch": "@@ -12,6 +12,7 @@\n #include <atomic>\n #include <thread>\n #include <vector>\n+#include <mutex>\n \n #include <unordered_set>\n #include <memory>\n@@ -85,6 +86,26 @@ struct FakeJobNoWork {\n };\n typedef CCheckQueue<FakeJobNoWork, (size_t)1000, MAX_SCRIPTCHECK_THREADS, true, false> Consume_Queue;\n \n+\n+struct UniqueJob {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t job_id;\n+    UniqueJob(size_t job_id_in) : job_id(job_id_in){};\n+    UniqueJob() : job_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(job_id);\n+        return true;\n+    }\n+    void swap(UniqueJob& x){std::swap(x.job_id, job_id);};\n+};\n+std::mutex UniqueJob::m;\n+std::unordered_multiset<size_t> UniqueJob::results;\n+typedef CCheckQueue<UniqueJob, (size_t)100, MAX_SCRIPTCHECK_THREADS, true, false> Unique_Queue;\n+\n+\n typedef typename Standard_Queue::JOB_TYPE JT; // This is a \"recursive template\" hack\n typedef CCheckQueue_Internals::job_array<Standard_Queue> J;\n typedef CCheckQueue_Internals::barrier<Standard_Queue> B;\n@@ -109,14 +130,12 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n             size_t r = GetRand(10);\n             std::vector<FailingJob> vChecks2;\n             vChecks2.reserve(r);\n-            auto p = control.get_next_free_index();\n-            auto p_ = *p;\n+            auto inserter = control.get_inserter();\n             for (size_t k = 0; k < r && !vChecks.empty(); k++) {\n-                ((*p)++)->swap(vChecks.back());\n+                (inserter())->swap(vChecks.back());\n                 vChecks.pop_back();\n+                ++checksum;\n             }\n-            checksum += std::distance(p_, *p);\n-            control.Add(std::distance(p_, *p));\n         }\n         BOOST_REQUIRE(checksum == i);\n         bool success = control.Wait();\n@@ -142,18 +161,18 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_PriorityWorkQueue)\n     auto m = 0;\n     work.add(100);\n     size_t x = 0;\n-    work.pop(x, false);\n+    work.pop(x, true);\n     BOOST_REQUIRE(x == 0);\n-    work.pop(x, false);\n+    work.pop(x, true);\n     BOOST_REQUIRE(x == 16);\n     m = 2;\n-    while (work.pop(x, false)) {\n+    while (work.pop(x, true)) {\n         ++m;\n     }\n     BOOST_REQUIRE(m == 100);\n     work.add(200);\n     std::unordered_set<size_t> results;\n-    while (work.pop(x, false)) {\n+    while (work.pop(x, true)) {\n         results.insert(x);\n         ++m;\n     }\n@@ -165,12 +184,12 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_PriorityWorkQueue)\n     BOOST_REQUIRE(m == 200);\n \n     work.add(300);\n-    work.pop(x, false);\n+    work.pop(x, true);\n     work.add(400);\n     do {\n         results.insert(x);\n         ++m;\n-    } while (work.pop(x, false));\n+    } while (work.pop(x, true));\n     for (auto i = 200; i < 400; ++i) {\n         BOOST_REQUIRE(results.count(i));\n         results.erase(i);\n@@ -225,29 +244,24 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_consume)\n {\n     auto fast_queue = std::shared_ptr<Consume_Queue>(new Consume_Queue());\n     fast_queue->init(nScriptCheckThreads);\n-    std::array<std::atomic<size_t>, MAX_SCRIPTCHECK_THREADS> results;\n     std::atomic<int> spawned{0};\n \n     RAII_ThreadGroup threadGroup;\n \n-    for (auto& a : results)\n-        a = 0;\n     for (int i = 0; i < nScriptCheckThreads; ++i) {\n         threadGroup.create_thread([&, i]() {\n             ++spawned;\n-            results[i] = fast_queue->TEST_consume(i);\n+            fast_queue->TEST_consume(i);\n         });\n     }\n \n     threadGroup.create_thread([&]() {\n         while (spawned != nScriptCheckThreads);\n         for (auto y = 0; y < 10; ++y) {\n-            auto p = fast_queue->get_next_free_index();\n-            auto p_ = *p;\n+            auto inserter = CCheckQueue_Internals::inserter<Consume_Queue>(fast_queue.get()); \n             for (auto x = 0; x< 100; ++x) {\n-                new ((*p)++) FakeJobNoWork{};\n+                new (inserter()) FakeJobNoWork{};\n             }\n-            fast_queue->Add(std::distance(p_, *p));\n             MilliSleep(1);\n         }\n         fast_queue->TEST_set_masterJoined(true);\n@@ -256,14 +270,6 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_consume)\n     threadGroup.join_all();\n \n \n-\n-    for (auto a = 0; a < nScriptCheckThreads; ++a) {\n-        auto v = results[a].load();\n-        if (v != 1000) {\n-            BOOST_TEST_MESSAGE(\"Error, Got: \" << v);\n-            BOOST_REQUIRE(v == 1000);\n-        }\n-    }\n     size_t count = fast_queue->TEST_count_set_flags();\n     BOOST_TEST_MESSAGE(\"Got: \" << count);\n     BOOST_REQUIRE(count == 1000);\n@@ -283,13 +289,11 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct)\n             CCheckQueueControl<Correct_Queue> control(small_queue.get());\n             while (total) {\n                 size_t r = GetRand(10);\n-                auto p = control.get_next_free_index();\n-                auto p_ = *p; \n+                auto inserter = control.get_inserter();\n                 for (size_t k = 0; k < r && total; k++) {\n                     total--;\n-                    new ((*p)++) FakeJobCheckCompletion{};\n+                    new (inserter()) FakeJobCheckCompletion{};\n                 }\n-                control.Add(std::distance(p_, *p));\n             }\n         }\n         small_queue->TEST_dump_log(nScriptCheckThreads);\n@@ -301,4 +305,27 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct)\n     }\n }\n \n+\n+\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueJob)\n+{\n+    auto queue = std::shared_ptr<Unique_Queue>(new Unique_Queue);\n+    queue->init(nScriptCheckThreads);\n+\n+    size_t COUNT = 100;\n+    size_t total = COUNT;\n+    {\n+        CCheckQueueControl<Unique_Queue> control(queue.get());\n+        while (total) {\n+            size_t r = GetRand(10);\n+            auto inserter = control.get_inserter();\n+            for (size_t k = 0; k < r && total; k++) {\n+                new (inserter()) UniqueJob{--total};\n+            }\n+        }\n+    }\n+    for (size_t i = 0; i < COUNT; ++i)\n+        BOOST_REQUIRE(UniqueJob::results.count(i) == 1);\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "47aa2b1583dcd44eaa1d1fb8a679e367eb8cc6ab",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0N2FhMmIxNTgzZGNkNDRlYWExZDFmYjhhNjc5ZTM2N2ViOGNjNmFi",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-17T01:14:59Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "Added code to clear memory after each round. Otherwise, a sequence of blocks with n, n-1, n-2, n-3... inputs with max data stored on n, n-1, n-2, n-3... could cause lots of memory to be used! (e.g., starting with n = 100,000 could use 0.2 TB of memory!  (total block memory minus memory used for m inputs summed for m = 0 to 100,000)",
      "tree": {
        "sha": "e557ee2dad80d7b0664d3807557509bff9a439b7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e557ee2dad80d7b0664d3807557509bff9a439b7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/47aa2b1583dcd44eaa1d1fb8a679e367eb8cc6ab",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/47aa2b1583dcd44eaa1d1fb8a679e367eb8cc6ab",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/47aa2b1583dcd44eaa1d1fb8a679e367eb8cc6ab",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/47aa2b1583dcd44eaa1d1fb8a679e367eb8cc6ab/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "20a739f26ec45373b79a7e838ede381ea29474ef",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/20a739f26ec45373b79a7e838ede381ea29474ef",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/20a739f26ec45373b79a7e838ede381ea29474ef"
      }
    ],
    "stats": {
      "total": 9,
      "additions": 5,
      "deletions": 4
    },
    "files": [
      {
        "sha": "a7d6eaa58a12f0442a9492e7c465ad3e0255f631",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/47aa2b1583dcd44eaa1d1fb8a679e367eb8cc6ab/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/47aa2b1583dcd44eaa1d1fb8a679e367eb8cc6ab/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=47aa2b1583dcd44eaa1d1fb8a679e367eb8cc6ab",
        "patch": "@@ -135,11 +135,11 @@ class job_array\n     {\n         next_free_index = checks.begin();\n     }\n-    void clear_all_data()\n+    void clear_check_memory()\n     {\n-        for (size_t i = 0; i < Q::MAX_JOBS; ++i) {\n+        for (auto it = checks.begin(); it != next_free_index; ++it) {\n             typename Q::JOB_TYPE tmp {};\n-            checks[i].swap(tmp);\n+            it->swap(tmp);\n         }\n     }\n \n@@ -425,6 +425,7 @@ class CCheckQueue\n             if (ID == 1) {\n                 // Reset master flags too\n                 jobs.reset_flags_for(0, prev_total);\n+                jobs.clear_check_memory();\n                 cleanup.wait_all_finished();\n                 cleanup.reset();\n                 work.reset();\n@@ -475,7 +476,7 @@ class CCheckQueue\n         for (auto& t : threads)\n             t.join();\n         threads.clear();\n-        jobs.clear_all_data();\n+        jobs.clear_check_memory();\n     }\n \n     JOB_TYPE* get_next_free_index() {"
      }
    ]
  },
  {
    "sha": "a7842e9cd35a0b73acaf2503fc0720304c7b3e34",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNzg0MmU5Y2QzNWEwYjczYWNhZjI1MDNmYzA3MjAzMDRjN2IzZTM0",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-17T01:41:15Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "Add a test that runs jobs with HUGE allocations, and makes sure they are released (by virtue of not crashing)",
      "tree": {
        "sha": "b6e5daaece33244081b4fe155a5e3362d61cb2a6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b6e5daaece33244081b4fe155a5e3362d61cb2a6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a7842e9cd35a0b73acaf2503fc0720304c7b3e34",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a7842e9cd35a0b73acaf2503fc0720304c7b3e34",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a7842e9cd35a0b73acaf2503fc0720304c7b3e34",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a7842e9cd35a0b73acaf2503fc0720304c7b3e34/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "47aa2b1583dcd44eaa1d1fb8a679e367eb8cc6ab",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/47aa2b1583dcd44eaa1d1fb8a679e367eb8cc6ab",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/47aa2b1583dcd44eaa1d1fb8a679e367eb8cc6ab"
      }
    ],
    "stats": {
      "total": 38,
      "additions": 38,
      "deletions": 0
    },
    "files": [
      {
        "sha": "0b2bc53a460adff2e3eba9aa777fc0fd9dddd606",
        "filename": "src/test/checkqueue_tests.cpp",
        "status": "modified",
        "additions": 38,
        "deletions": 0,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a7842e9cd35a0b73acaf2503fc0720304c7b3e34/src/test/checkqueue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a7842e9cd35a0b73acaf2503fc0720304c7b3e34/src/test/checkqueue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkqueue_tests.cpp?ref=a7842e9cd35a0b73acaf2503fc0720304c7b3e34",
        "patch": "@@ -328,4 +328,42 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueJob)\n         BOOST_REQUIRE(UniqueJob::results.count(i) == 1);\n }\n \n+\n+\n+struct MemoryJob {\n+    std::vector<std::array<unsigned char, 1000000>> mb_memory; \n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryJob() {};\n+    MemoryJob(bool b) {\n+        if (b)\n+            mb_memory.reserve(200);\n+    };\n+    void swap(MemoryJob& x){mb_memory.swap(x.mb_memory);};\n+};\n+typedef CCheckQueue<MemoryJob, (size_t)10000, MAX_SCRIPTCHECK_THREADS> Memory_Queue;\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Memory)\n+{\n+    auto queue = std::shared_ptr<Memory_Queue>(new Memory_Queue{});\n+    queue->init(nScriptCheckThreads);\n+\n+    for (size_t i = 9999;  i < 9999; --i) {\n+        size_t total = i;\n+        {\n+            CCheckQueueControl<Memory_Queue> control(queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                auto inserter = control.get_inserter();\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    new (inserter()) MemoryJob{total == 0};\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "39c11139640caa65ab3f254679fd20c0376ff8db",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozOWMxMTEzOTY0MGNhYTY1YWIzZjI1NDY3OWZkMjBjMDM3NmZmOGRi",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-17T01:45:35Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "reformat/move only in checkqueue tests",
      "tree": {
        "sha": "db0498cbeccc1ceb49fa4666411ab42f4fc5455b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/db0498cbeccc1ceb49fa4666411ab42f4fc5455b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/39c11139640caa65ab3f254679fd20c0376ff8db",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/39c11139640caa65ab3f254679fd20c0376ff8db",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/39c11139640caa65ab3f254679fd20c0376ff8db",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/39c11139640caa65ab3f254679fd20c0376ff8db/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a7842e9cd35a0b73acaf2503fc0720304c7b3e34",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a7842e9cd35a0b73acaf2503fc0720304c7b3e34",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a7842e9cd35a0b73acaf2503fc0720304c7b3e34"
      }
    ],
    "stats": {
      "total": 254,
      "additions": 127,
      "deletions": 127
    },
    "files": [
      {
        "sha": "8553de3b75a2eb66e8f4ee2330a6e10a99be2697",
        "filename": "src/test/checkqueue_tests.cpp",
        "status": "modified",
        "additions": 127,
        "deletions": 127,
        "changes": 254,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39c11139640caa65ab3f254679fd20c0376ff8db/src/test/checkqueue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39c11139640caa65ab3f254679fd20c0376ff8db/src/test/checkqueue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkqueue_tests.cpp?ref=39c11139640caa65ab3f254679fd20c0376ff8db",
        "patch": "@@ -20,141 +20,34 @@\n BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n \n \n-class RAII_ThreadGroup {\n+class RAII_ThreadGroup\n+{\n     std::vector<std::thread> threadGroup;\n-    public:\n+\n+public:\n     template <typename Callable>\n-    void create_thread(Callable c) {\n+    void create_thread(Callable c)\n+    {\n         std::thread t(c);\n         threadGroup.push_back(std::move(t));\n     };\n-    void join_all(){\n-        for (auto& t: threadGroup)\n+    void join_all()\n+    {\n+        for (auto& t : threadGroup)\n             t.join();\n         threadGroup.clear();\n     };\n-    ~RAII_ThreadGroup() {\n+    ~RAII_ThreadGroup()\n+    {\n         join_all();\n     };\n-\n };\n \n struct FakeJob {\n };\n typedef CCheckQueue<FakeJob, (size_t)1000, MAX_SCRIPTCHECK_THREADS, true, false> Standard_Queue;\n-struct FakeJobCheckCompletion {\n-    static std::atomic<size_t> n_calls;\n-    bool operator()()\n-    {\n-        ++n_calls;\n-        return true;\n-    }\n-    void swap(FakeJobCheckCompletion& x){};\n-};\n-std::atomic<size_t> FakeJobCheckCompletion::n_calls {0};\n-typedef CCheckQueue<FakeJobCheckCompletion, (size_t)100, MAX_SCRIPTCHECK_THREADS, true, false> Correct_Queue;\n-\n-struct FailingJob {\n-    bool f;\n-    bool call_state;\n-    size_t tag;\n-    static std::atomic<size_t> n_calls;\n-    FailingJob(bool fails) : f(fails), call_state(false), tag(0xdeadbeef){};\n-    FailingJob() : f(true), call_state(false){};\n-    bool operator()()\n-    {\n-        n_calls++;\n-        call_state = true;\n-        return !f;\n-    }\n-    void swap(FailingJob& x)\n-    {\n-        std::swap(f, x.f);\n-\n-        std::swap(call_state, x.call_state);\n-        std::swap(tag, x.tag);\n-    };\n-};\n-std::atomic<size_t> FailingJob::n_calls {0};\n-typedef CCheckQueue<FailingJob, (size_t)1000, MAX_SCRIPTCHECK_THREADS, true, false> Failing_Queue;\n-struct FakeJobNoWork {\n-    bool operator()()\n-    {\n-        return true;\n-    }\n-    void swap(FakeJobNoWork& x){};\n-};\n-typedef CCheckQueue<FakeJobNoWork, (size_t)1000, MAX_SCRIPTCHECK_THREADS, true, false> Consume_Queue;\n-\n-\n-struct UniqueJob {\n-    static std::mutex m;\n-    static std::unordered_multiset<size_t> results;\n-    size_t job_id;\n-    UniqueJob(size_t job_id_in) : job_id(job_id_in){};\n-    UniqueJob() : job_id(0){};\n-    bool operator()()\n-    {\n-        std::lock_guard<std::mutex> l(m);\n-        results.insert(job_id);\n-        return true;\n-    }\n-    void swap(UniqueJob& x){std::swap(x.job_id, job_id);};\n-};\n-std::mutex UniqueJob::m;\n-std::unordered_multiset<size_t> UniqueJob::results;\n-typedef CCheckQueue<UniqueJob, (size_t)100, MAX_SCRIPTCHECK_THREADS, true, false> Unique_Queue;\n-\n-\n typedef typename Standard_Queue::JOB_TYPE JT; // This is a \"recursive template\" hack\n-typedef CCheckQueue_Internals::job_array<Standard_Queue> J;\n-typedef CCheckQueue_Internals::barrier<Standard_Queue> B;\n-BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n-{\n-    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue());\n-\n-    fail_queue->init(nScriptCheckThreads);\n-\n-    for (size_t i = 10; i < 1001; ++i) {\n-        FailingJob::n_calls = 0;\n-        CCheckQueueControl<Failing_Queue> control(fail_queue.get());\n-        size_t checksum = 0;\n \n-        std::vector<FailingJob> vChecks;\n-        vChecks.reserve(i);\n-        for (size_t x = 0; x < i; ++x)\n-            vChecks.push_back(FailingJob{});\n-        if (i > 0)\n-            vChecks[0].f = true;\n-        while (!vChecks.empty()) {\n-            size_t r = GetRand(10);\n-            std::vector<FailingJob> vChecks2;\n-            vChecks2.reserve(r);\n-            auto inserter = control.get_inserter();\n-            for (size_t k = 0; k < r && !vChecks.empty(); k++) {\n-                (inserter())->swap(vChecks.back());\n-                vChecks.pop_back();\n-                ++checksum;\n-            }\n-        }\n-        BOOST_REQUIRE(checksum == i);\n-        bool success = control.Wait();\n-        if (success && i > 0) {\n-            size_t nChecked = 0;\n-            auto jobs = fail_queue->TEST_introspect_jobs()->TEST_get_checks();\n-            for (size_t x = 0; x < i; ++x)\n-                if ((*jobs)[x].call_state)\n-                    nChecked++;\n-            fail_queue->TEST_dump_log(nScriptCheckThreads);\n-            fail_queue->TEST_erase_log();\n-            BOOST_REQUIRE(!success);\n-        } else if (i == 0) {\n-            fail_queue->TEST_erase_log();\n-            BOOST_REQUIRE(success);\n-        }\n-        fail_queue->TEST_erase_log();\n-    }\n-}\n BOOST_AUTO_TEST_CASE(test_CheckQueue_PriorityWorkQueue)\n {\n     CCheckQueue_Internals::PriorityWorkQueue<Standard_Queue> work(0, 16);\n@@ -201,6 +94,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_PriorityWorkQueue)\n     BOOST_REQUIRE(m == 400);\n }\n \n+typedef CCheckQueue_Internals::job_array<Standard_Queue> J;\n BOOST_AUTO_TEST_CASE(test_CheckQueue_job_array)\n {\n     auto jobs = std::shared_ptr<J>(new J());\n@@ -223,23 +117,32 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_job_array)\n \n     BOOST_REQUIRE(m == Standard_Queue::MAX_JOBS);\n }\n+\n+typedef CCheckQueue_Internals::barrier<Standard_Queue> B;\n BOOST_AUTO_TEST_CASE(test_CheckQueue_round_barrier)\n {\n     RAII_ThreadGroup threadGroup;\n     auto b = std::shared_ptr<B>(new B());\n     b->init(nScriptCheckThreads);\n     b->reset();\n \n-    for (int i = 0; i < nScriptCheckThreads; ++i) \n+    for (int i = 0; i < nScriptCheckThreads; ++i)\n         threadGroup.create_thread([&, i]() {\n             b->finished();\n             b->wait_all_finished();\n         });\n \n     threadGroup.join_all();\n-\n }\n \n+struct FakeJobNoWork {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeJobNoWork& x){};\n+};\n+typedef CCheckQueue<FakeJobNoWork, (size_t)1000, MAX_SCRIPTCHECK_THREADS, true, false> Consume_Queue;\n BOOST_AUTO_TEST_CASE(test_CheckQueue_consume)\n {\n     auto fast_queue = std::shared_ptr<Consume_Queue>(new Consume_Queue());\n@@ -276,7 +179,17 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_consume)\n }\n \n \n-\n+struct FakeJobCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeJobCheckCompletion& x){};\n+};\n+std::atomic<size_t> FakeJobCheckCompletion::n_calls{0};\n+typedef CCheckQueue<FakeJobCheckCompletion, (size_t)100, MAX_SCRIPTCHECK_THREADS, true, false> Correct_Queue;\n BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct)\n {\n     auto small_queue = std::shared_ptr<Correct_Queue>(new Correct_Queue);\n@@ -305,6 +218,93 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct)\n     }\n }\n \n+struct FailingJob {\n+    bool f;\n+    bool call_state;\n+    size_t tag;\n+    static std::atomic<size_t> n_calls;\n+    FailingJob(bool fails) : f(fails), call_state(false), tag(0xdeadbeef){};\n+    FailingJob() : f(true), call_state(false){};\n+    bool operator()()\n+    {\n+        n_calls++;\n+        call_state = true;\n+        return !f;\n+    }\n+    void swap(FailingJob& x)\n+    {\n+        std::swap(f, x.f);\n+\n+        std::swap(call_state, x.call_state);\n+        std::swap(tag, x.tag);\n+    };\n+};\n+std::atomic<size_t> FailingJob::n_calls{0};\n+typedef CCheckQueue<FailingJob, (size_t)1000, MAX_SCRIPTCHECK_THREADS, true, false> Failing_Queue;\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue());\n+\n+    fail_queue->init(nScriptCheckThreads);\n+\n+    for (size_t i = 10; i < 1001; ++i) {\n+        FailingJob::n_calls = 0;\n+        CCheckQueueControl<Failing_Queue> control(fail_queue.get());\n+        size_t checksum = 0;\n+\n+        std::vector<FailingJob> vChecks;\n+        vChecks.reserve(i);\n+        for (size_t x = 0; x < i; ++x)\n+            vChecks.push_back(FailingJob{});\n+        if (i > 0)\n+            vChecks[0].f = true;\n+        while (!vChecks.empty()) {\n+            size_t r = GetRand(10);\n+            std::vector<FailingJob> vChecks2;\n+            vChecks2.reserve(r);\n+            auto inserter = control.get_inserter();\n+            for (size_t k = 0; k < r && !vChecks.empty(); k++) {\n+                (inserter())->swap(vChecks.back());\n+                vChecks.pop_back();\n+                ++checksum;\n+            }\n+        }\n+        BOOST_REQUIRE(checksum == i);\n+        bool success = control.Wait();\n+        if (success && i > 0) {\n+            size_t nChecked = 0;\n+            auto jobs = fail_queue->TEST_introspect_jobs()->TEST_get_checks();\n+            for (size_t x = 0; x < i; ++x)\n+                if ((*jobs)[x].call_state)\n+                    nChecked++;\n+            fail_queue->TEST_dump_log(nScriptCheckThreads);\n+            fail_queue->TEST_erase_log();\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            fail_queue->TEST_erase_log();\n+            BOOST_REQUIRE(success);\n+        }\n+        fail_queue->TEST_erase_log();\n+    }\n+}\n+\n+struct UniqueJob {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t job_id;\n+    UniqueJob(size_t job_id_in) : job_id(job_id_in){};\n+    UniqueJob() : job_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(job_id);\n+        return true;\n+    }\n+    void swap(UniqueJob& x) { std::swap(x.job_id, job_id); };\n+};\n+std::mutex UniqueJob::m;\n+std::unordered_multiset<size_t> UniqueJob::results;\n+typedef CCheckQueue<UniqueJob, (size_t)100, MAX_SCRIPTCHECK_THREADS, true, false> Unique_Queue;\n \n \n BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueJob)\n@@ -329,27 +329,27 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueJob)\n }\n \n \n-\n struct MemoryJob {\n-    std::vector<std::array<unsigned char, 1000000>> mb_memory; \n+    std::vector<std::array<unsigned char, 1000000> > mb_memory;\n     bool operator()()\n     {\n         return true;\n     }\n-    MemoryJob() {};\n-    MemoryJob(bool b) {\n+    MemoryJob(){};\n+    MemoryJob(bool b)\n+    {\n         if (b)\n             mb_memory.reserve(200);\n     };\n-    void swap(MemoryJob& x){mb_memory.swap(x.mb_memory);};\n+    void swap(MemoryJob& x) { mb_memory.swap(x.mb_memory); };\n };\n typedef CCheckQueue<MemoryJob, (size_t)10000, MAX_SCRIPTCHECK_THREADS> Memory_Queue;\n BOOST_AUTO_TEST_CASE(test_CheckQueue_Memory)\n {\n     auto queue = std::shared_ptr<Memory_Queue>(new Memory_Queue{});\n     queue->init(nScriptCheckThreads);\n \n-    for (size_t i = 9999;  i < 9999; --i) {\n+    for (size_t i = 9999; i < 9999; --i) {\n         size_t total = i;\n         {\n             CCheckQueueControl<Memory_Queue> control(queue.get());"
      }
    ]
  },
  {
    "sha": "43615c0502dd88b8968dd899e85e2529c4bcff7c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MzYxNWMwNTAyZGQ4OGI4OTY4ZGQ4OTllODVlMjUyOWM0YmNmZjdj",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-17T01:46:23Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "go back to using placement new for main.cpp emplacement rather than swap",
      "tree": {
        "sha": "5cf4c1caef971a63ca1be2fcbb070a2f00c482c4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5cf4c1caef971a63ca1be2fcbb070a2f00c482c4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/43615c0502dd88b8968dd899e85e2529c4bcff7c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/43615c0502dd88b8968dd899e85e2529c4bcff7c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/43615c0502dd88b8968dd899e85e2529c4bcff7c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/43615c0502dd88b8968dd899e85e2529c4bcff7c/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "39c11139640caa65ab3f254679fd20c0376ff8db",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/39c11139640caa65ab3f254679fd20c0376ff8db",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/39c11139640caa65ab3f254679fd20c0376ff8db"
      }
    ],
    "stats": {
      "total": 7,
      "additions": 3,
      "deletions": 4
    },
    "files": [
      {
        "sha": "df99a145f78590bc8f0805b935f9ac94dc5e57f3",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43615c0502dd88b8968dd899e85e2529c4bcff7c/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43615c0502dd88b8968dd899e85e2529c4bcff7c/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=43615c0502dd88b8968dd899e85e2529c4bcff7c",
        "patch": "@@ -1994,11 +1994,10 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                 assert(coins);\n \n                 // Verify signature\n-                CScriptCheck check =  CScriptCheck(*coins, tx, i, flags, cacheStore);\n+                CScriptCheck check;\n                 CScriptCheck * const ptr = inserter();\n-                if (ptr)\n-                    ptr->swap(check);\n-                else if (!check()) {\n+                new (ptr ? ptr : &check) CScriptCheck(*coins, tx, i, flags, cacheStore);\n+                if (!ptr && !check()) {\n                     if (flags & STANDARD_NOT_MANDATORY_VERIFY_FLAGS) {\n                         // Check whether the failure was caused by a\n                         // non-mandatory script verification check, such as"
      }
    ]
  },
  {
    "sha": "9cb002b3fe5b2b4abb1ad3ae6be9603327b67364",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5Y2IwMDJiM2ZlNWIyYjRhYmIxYWQzYWU2YmU5NjAzMzI3YjY3MzY0",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-18T21:51:16Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "Free memory immediately after evaluating check",
      "tree": {
        "sha": "18eddae8d0e1634111302693c73809a8cccd99f2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/18eddae8d0e1634111302693c73809a8cccd99f2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9cb002b3fe5b2b4abb1ad3ae6be9603327b67364",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9cb002b3fe5b2b4abb1ad3ae6be9603327b67364",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9cb002b3fe5b2b4abb1ad3ae6be9603327b67364",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9cb002b3fe5b2b4abb1ad3ae6be9603327b67364/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "43615c0502dd88b8968dd899e85e2529c4bcff7c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/43615c0502dd88b8968dd899e85e2529c4bcff7c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/43615c0502dd88b8968dd899e85e2529c4bcff7c"
      }
    ],
    "stats": {
      "total": 21,
      "additions": 9,
      "deletions": 12
    },
    "files": [
      {
        "sha": "37f6e347d3b3bfbb0e87d345d18aac90b9166fc6",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 9,
        "deletions": 12,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9cb002b3fe5b2b4abb1ad3ae6be9603327b67364/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9cb002b3fe5b2b4abb1ad3ae6be9603327b67364/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=9cb002b3fe5b2b4abb1ad3ae6be9603327b67364",
        "patch": "@@ -46,9 +46,9 @@ class inserter {\n     typename Q::JOB_TYPE * free_index;\n     public:\n     inserter(Q * const queueIn) :\n-       queue(queueIn), start(queue ? queue->get_next_free_index() : nullptr), free_index(start) {}\n-\n-\n+       queue(queueIn),\n+       start(queue ? queue->get_next_free_index() : nullptr),\n+       free_index(start) {}\n     typename Q::JOB_TYPE * operator()()\n     {\n         return start ? free_index++ : nullptr;\n@@ -119,7 +119,10 @@ class job_array\n     /** eval runs a check at specified index */\n     bool eval(const size_t i)\n     {\n-        return checks[i]();\n+        bool b = checks[i]();\n+        typename Q::JOB_TYPE tmp {};\n+        checks[i].swap(tmp);\n+        return b;\n     }\n \n     /** reset_jobs resets the insertion index only, so should only be run on master.\n@@ -357,13 +360,9 @@ class CCheckQueue\n     mutable std::atomic<size_t> test_log_seq;\n     mutable std::array<std::ostringstream, MAX_WORKERS> test_log;\n \n-\n-\n     void consume(const size_t ID)\n     {\n-        TEST_log(ID, [](std::ostringstream& o) {\n-            o << \"In consume\\n\";\n-        });\n+        TEST_log(ID, [](std::ostringstream& o) {o << \"In consume\\n\";});\n         CCheckQueue_Internals::PriorityWorkQueue<SELF> work_queue(ID, RT_N_SCRIPTCHECK_THREADS);\n         for (;;) {\n             // Note: Must check masterJoined before nAvail, otherwise\n@@ -383,9 +382,7 @@ class CCheckQueue\n \n         } \n             \n-        TEST_log(ID, [&, this](std::ostringstream& o) {\n-            o << \"Leaving consume. fAllOk was \" << fAllOk.load() << \"\\n\";\n-        });\n+        TEST_log(ID, [&, this](std::ostringstream& o) {o << \"Leaving consume. fAllOk was \" << fAllOk.load() << \"\\n\";});\n     }\n     /** Internal function that does bulk of the verification work. */\n     bool Master() {"
      }
    ]
  },
  {
    "sha": "147bdcc84c7974e74fee6b407ba75ca667024372",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxNDdiZGNjODRjNzk3NGU3NGZlZTZiNDA3YmE3NWNhNjY3MDI0Mzcy",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-18T21:53:53Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "rework some tests",
      "tree": {
        "sha": "220696091a4b769e13971ee2960fd6412c4b851d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/220696091a4b769e13971ee2960fd6412c4b851d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/147bdcc84c7974e74fee6b407ba75ca667024372",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/147bdcc84c7974e74fee6b407ba75ca667024372",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/147bdcc84c7974e74fee6b407ba75ca667024372",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/147bdcc84c7974e74fee6b407ba75ca667024372/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9cb002b3fe5b2b4abb1ad3ae6be9603327b67364",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9cb002b3fe5b2b4abb1ad3ae6be9603327b67364",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9cb002b3fe5b2b4abb1ad3ae6be9603327b67364"
      }
    ],
    "stats": {
      "total": 119,
      "additions": 76,
      "deletions": 43
    },
    "files": [
      {
        "sha": "dee2afcd4b1fa4716d6a3a0f634cd7817261ed65",
        "filename": "src/test/checkqueue_tests.cpp",
        "status": "modified",
        "additions": 76,
        "deletions": 43,
        "changes": 119,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/147bdcc84c7974e74fee6b407ba75ca667024372/src/test/checkqueue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/147bdcc84c7974e74fee6b407ba75ca667024372/src/test/checkqueue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkqueue_tests.cpp?ref=147bdcc84c7974e74fee6b407ba75ca667024372",
        "patch": "@@ -48,7 +48,7 @@ struct FakeJob {\n typedef CCheckQueue<FakeJob, (size_t)1000, MAX_SCRIPTCHECK_THREADS, true, false> Standard_Queue;\n typedef typename Standard_Queue::JOB_TYPE JT; // This is a \"recursive template\" hack\n \n-BOOST_AUTO_TEST_CASE(test_CheckQueue_PriorityWorkQueue)\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_PriorityWorkQueue_basic)\n {\n     CCheckQueue_Internals::PriorityWorkQueue<Standard_Queue> work(0, 16);\n     auto m = 0;\n@@ -63,35 +63,49 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_PriorityWorkQueue)\n         ++m;\n     }\n     BOOST_REQUIRE(m == 100);\n+}\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_PriorityWorkQueue_emits_all)\n+{\n+    CCheckQueue_Internals::PriorityWorkQueue<Standard_Queue> work(0, 16);\n+    auto m = 0;\n     work.add(200);\n-    std::unordered_set<size_t> results;\n+    std::unordered_multiset<size_t> results;\n+    size_t x;\n     while (work.pop(x, true)) {\n         results.insert(x);\n         ++m;\n     }\n-    for (auto i = 100; i < 200; ++i) {\n-        BOOST_REQUIRE(results.count(i));\n+    for (auto i = 0; i < 200; ++i) {\n+        BOOST_REQUIRE(results.count(i) == 1);\n         results.erase(i);\n     }\n     BOOST_REQUIRE(results.empty());\n     BOOST_REQUIRE(m == 200);\n-\n-    work.add(300);\n-    work.pop(x, true);\n-    work.add(400);\n-    do {\n+}\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_PriorityWorkQueue_stealing)\n+{\n+    CCheckQueue_Internals::PriorityWorkQueue<Standard_Queue> work(0, 16);\n+    auto m = 0;\n+    work.add(160);\n+    std::unordered_multiset<size_t> results;\n+    size_t x;\n+    while (work.pop(x, false)) {\n         results.insert(x);\n         ++m;\n-    } while (work.pop(x, true));\n-    for (auto i = 200; i < 400; ++i) {\n-        BOOST_REQUIRE(results.count(i));\n+    }\n+    for (auto i = 0; i < 160; i+=16) {\n+        BOOST_REQUIRE(results.count(i) == 1);\n         results.erase(i);\n     }\n-    for (auto i : results)\n-        BOOST_TEST_MESSAGE(\"\" << i);\n-\n     BOOST_REQUIRE(results.empty());\n-    BOOST_REQUIRE(m == 400);\n+    while (work.pop(x, true)) {\n+        results.insert(x);\n+        ++m;\n+    }\n+    for (auto i = 0; i < 160; ++i) {\n+        BOOST_REQUIRE(results.count(i) == 1 || (i %16) == 0);\n+        results.erase(i);\n+    }\n }\n \n typedef CCheckQueue_Internals::job_array<Standard_Queue> J;\n@@ -142,13 +156,12 @@ struct FakeJobNoWork {\n     }\n     void swap(FakeJobNoWork& x){};\n };\n-typedef CCheckQueue<FakeJobNoWork, (size_t)1000, MAX_SCRIPTCHECK_THREADS, true, false> Consume_Queue;\n+typedef CCheckQueue<FakeJobNoWork, (size_t)100000, MAX_SCRIPTCHECK_THREADS, true, false> Consume_Queue;\n BOOST_AUTO_TEST_CASE(test_CheckQueue_consume)\n {\n     auto fast_queue = std::shared_ptr<Consume_Queue>(new Consume_Queue());\n     fast_queue->init(nScriptCheckThreads);\n     std::atomic<int> spawned{0};\n-\n     RAII_ThreadGroup threadGroup;\n \n     for (int i = 0; i < nScriptCheckThreads; ++i) {\n@@ -158,24 +171,19 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_consume)\n         });\n     }\n \n-    threadGroup.create_thread([&]() {\n-        while (spawned != nScriptCheckThreads);\n-        for (auto y = 0; y < 10; ++y) {\n-            auto inserter = CCheckQueue_Internals::inserter<Consume_Queue>(fast_queue.get()); \n-            for (auto x = 0; x< 100; ++x) {\n-                new (inserter()) FakeJobNoWork{};\n-            }\n-            MilliSleep(1);\n-        }\n-        fast_queue->TEST_set_masterJoined(true);\n-    });\n+    while (spawned != nScriptCheckThreads);\n+    for (auto y = 0; y < 1000; ++y) {\n+        auto inserter = CCheckQueue_Internals::inserter<Consume_Queue>(fast_queue.get()); \n+        for (auto x = 0; x< 100; ++x) \n+            new (inserter()) FakeJobNoWork{};\n+    }\n+    fast_queue->TEST_set_masterJoined(true);\n \n     threadGroup.join_all();\n \n-\n     size_t count = fast_queue->TEST_count_set_flags();\n     BOOST_TEST_MESSAGE(\"Got: \" << count);\n-    BOOST_REQUIRE(count == 1000);\n+    BOOST_REQUIRE(count == 100000);\n }\n \n \n@@ -189,13 +197,13 @@ struct FakeJobCheckCompletion {\n     void swap(FakeJobCheckCompletion& x){};\n };\n std::atomic<size_t> FakeJobCheckCompletion::n_calls{0};\n-typedef CCheckQueue<FakeJobCheckCompletion, (size_t)100, MAX_SCRIPTCHECK_THREADS, true, false> Correct_Queue;\n-BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct)\n+const bool print_Correct_Queue = false;\n+typedef CCheckQueue<FakeJobCheckCompletion, (size_t)100000, MAX_SCRIPTCHECK_THREADS, true, print_Correct_Queue> Correct_Queue;\n+void Correct_Queue_range(std::vector<size_t> range)\n {\n     auto small_queue = std::shared_ptr<Correct_Queue>(new Correct_Queue);\n     small_queue->init(nScriptCheckThreads);\n-\n-    for (size_t i = 0; i < 101; ++i) {\n+    for (auto i : range) {\n         size_t total = i;\n         FakeJobCheckCompletion::n_calls = 0;\n         {\n@@ -209,14 +217,41 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct)\n                 }\n             }\n         }\n-        small_queue->TEST_dump_log(nScriptCheckThreads);\n-        small_queue->TEST_erase_log();\n+        if (print_Correct_Queue) {\n+            small_queue->TEST_dump_log(nScriptCheckThreads);\n+            small_queue->TEST_erase_log();\n+        }\n         if (FakeJobCheckCompletion::n_calls != i) {\n             BOOST_REQUIRE(FakeJobCheckCompletion::n_calls == i);\n             BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeJobCheckCompletion::n_calls);\n         }\n     }\n }\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random) \n+{\n+    std::vector<size_t> range;\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1,(size_t) GetRand(std::min((size_t) 1000, ((size_t) 100000)-i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n \n struct FailingJob {\n     bool f;\n@@ -304,28 +339,26 @@ struct UniqueJob {\n };\n std::mutex UniqueJob::m;\n std::unordered_multiset<size_t> UniqueJob::results;\n-typedef CCheckQueue<UniqueJob, (size_t)100, MAX_SCRIPTCHECK_THREADS, true, false> Unique_Queue;\n-\n-\n+typedef CCheckQueue<UniqueJob, (size_t)100000, MAX_SCRIPTCHECK_THREADS, true, false> Unique_Queue;\n BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueJob)\n {\n     auto queue = std::shared_ptr<Unique_Queue>(new Unique_Queue);\n     queue->init(nScriptCheckThreads);\n \n-    size_t COUNT = 100;\n+    size_t COUNT = 100000;\n     size_t total = COUNT;\n     {\n         CCheckQueueControl<Unique_Queue> control(queue.get());\n         while (total) {\n             size_t r = GetRand(10);\n             auto inserter = control.get_inserter();\n-            for (size_t k = 0; k < r && total; k++) {\n+            for (size_t k = 0; k < r && total; k++)\n                 new (inserter()) UniqueJob{--total};\n-            }\n         }\n     }\n     for (size_t i = 0; i < COUNT; ++i)\n         BOOST_REQUIRE(UniqueJob::results.count(i) == 1);\n+\n }\n \n "
      }
    ]
  },
  {
    "sha": "a63fd901fc3d7201397f6ac0f7958880f780a9cb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNjNmZDkwMWZjM2Q3MjAxMzk3ZjZhYzBmNzk1ODg4MGY3ODBhOWNi",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-18T23:30:35Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "Cleanup Failure test and add a new test which checks fAllOk resetting",
      "tree": {
        "sha": "4912016fec28441f2428ff4ceb49ff72c60d7c06",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4912016fec28441f2428ff4ceb49ff72c60d7c06"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a63fd901fc3d7201397f6ac0f7958880f780a9cb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a63fd901fc3d7201397f6ac0f7958880f780a9cb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a63fd901fc3d7201397f6ac0f7958880f780a9cb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a63fd901fc3d7201397f6ac0f7958880f780a9cb/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "147bdcc84c7974e74fee6b407ba75ca667024372",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/147bdcc84c7974e74fee6b407ba75ca667024372",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/147bdcc84c7974e74fee6b407ba75ca667024372"
      }
    ],
    "stats": {
      "total": 63,
      "additions": 32,
      "deletions": 31
    },
    "files": [
      {
        "sha": "a8aa286b95c1f7e0e791074fe63fcc955ffd3c4b",
        "filename": "src/test/checkqueue_tests.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 31,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a63fd901fc3d7201397f6ac0f7958880f780a9cb/src/test/checkqueue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a63fd901fc3d7201397f6ac0f7958880f780a9cb/src/test/checkqueue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkqueue_tests.cpp?ref=a63fd901fc3d7201397f6ac0f7958880f780a9cb",
        "patch": "@@ -182,7 +182,6 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_consume)\n     threadGroup.join_all();\n \n     size_t count = fast_queue->TEST_count_set_flags();\n-    BOOST_TEST_MESSAGE(\"Got: \" << count);\n     BOOST_REQUIRE(count == 100000);\n }\n \n@@ -254,57 +253,37 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n }\n \n struct FailingJob {\n-    bool f;\n+    bool fails;\n     bool call_state;\n-    size_t tag;\n-    static std::atomic<size_t> n_calls;\n-    FailingJob(bool fails) : f(fails), call_state(false), tag(0xdeadbeef){};\n-    FailingJob() : f(true), call_state(false){};\n+    FailingJob(bool fails) : fails(fails), call_state(false){};\n+    FailingJob() : fails(true), call_state(false){};\n     bool operator()()\n     {\n-        n_calls++;\n         call_state = true;\n-        return !f;\n+        return !fails;\n     }\n     void swap(FailingJob& x)\n     {\n-        std::swap(f, x.f);\n-\n+        std::swap(fails, x.fails);\n         std::swap(call_state, x.call_state);\n-        std::swap(tag, x.tag);\n     };\n };\n-std::atomic<size_t> FailingJob::n_calls{0};\n typedef CCheckQueue<FailingJob, (size_t)1000, MAX_SCRIPTCHECK_THREADS, true, false> Failing_Queue;\n BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n {\n     auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue());\n \n     fail_queue->init(nScriptCheckThreads);\n \n-    for (size_t i = 10; i < 1001; ++i) {\n-        FailingJob::n_calls = 0;\n+    for (size_t i = 0; i < 1001; ++i) {\n         CCheckQueueControl<Failing_Queue> control(fail_queue.get());\n-        size_t checksum = 0;\n-\n-        std::vector<FailingJob> vChecks;\n-        vChecks.reserve(i);\n-        for (size_t x = 0; x < i; ++x)\n-            vChecks.push_back(FailingJob{});\n-        if (i > 0)\n-            vChecks[0].f = true;\n-        while (!vChecks.empty()) {\n+        size_t remaining = i;\n+        while (remaining) {\n             size_t r = GetRand(10);\n-            std::vector<FailingJob> vChecks2;\n-            vChecks2.reserve(r);\n             auto inserter = control.get_inserter();\n-            for (size_t k = 0; k < r && !vChecks.empty(); k++) {\n-                (inserter())->swap(vChecks.back());\n-                vChecks.pop_back();\n-                ++checksum;\n-            }\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                new (inserter()) FailingJob{remaining == 1};\n         }\n-        BOOST_REQUIRE(checksum == i);\n         bool success = control.Wait();\n         if (success && i > 0) {\n             size_t nChecked = 0;\n@@ -322,6 +301,28 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n         fail_queue->TEST_erase_log();\n     }\n }\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue());\n+    std::array<FailingJob, 100> checks;\n+    fail_queue->init(nScriptCheckThreads);\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        std::array<bool, 2> result;\n+        for (size_t i : {0, 1}) {\n+            CCheckQueueControl<Failing_Queue> control(fail_queue.get());\n+            {\n+                auto inserter = control.get_inserter();\n+                for (size_t k = 0; k < 100-i; ++k)\n+                    new (inserter()) FailingJob {k == 99};\n+            }\n+            result[i] = control.Wait();\n+            fail_queue->TEST_erase_log();\n+        }\n+        BOOST_CHECK(!result[0]);\n+        BOOST_CHECK(result[1]);\n+    }\n+}\n \n struct UniqueJob {\n     static std::mutex m;"
      }
    ]
  },
  {
    "sha": "11dc3b34d829aa7b574267b21e0ecb82fc08e739",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMWRjM2IzNGQ4MjlhYTdiNTc0MjY3YjIxZTBlY2I4MmZjMDhlNzM5",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-19T07:40:34Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "Added a test that checks that cleanup happens before new job and refactored requires to give better printout",
      "tree": {
        "sha": "7275334f1210cfa1d5a8097e983d7ef21fea68bd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7275334f1210cfa1d5a8097e983d7ef21fea68bd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/11dc3b34d829aa7b574267b21e0ecb82fc08e739",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/11dc3b34d829aa7b574267b21e0ecb82fc08e739",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/11dc3b34d829aa7b574267b21e0ecb82fc08e739",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/11dc3b34d829aa7b574267b21e0ecb82fc08e739/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a63fd901fc3d7201397f6ac0f7958880f780a9cb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a63fd901fc3d7201397f6ac0f7958880f780a9cb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a63fd901fc3d7201397f6ac0f7958880f780a9cb"
      }
    ],
    "stats": {
      "total": 80,
      "additions": 70,
      "deletions": 10
    },
    "files": [
      {
        "sha": "30612cfca4e95862a5ed6ea88a98e4d0e6bcbc30",
        "filename": "src/test/checkqueue_tests.cpp",
        "status": "modified",
        "additions": 70,
        "deletions": 10,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/11dc3b34d829aa7b574267b21e0ecb82fc08e739/src/test/checkqueue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/11dc3b34d829aa7b574267b21e0ecb82fc08e739/src/test/checkqueue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkqueue_tests.cpp?ref=11dc3b34d829aa7b574267b21e0ecb82fc08e739",
        "patch": "@@ -75,10 +75,12 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_PriorityWorkQueue_emits_all)\n         results.insert(x);\n         ++m;\n     }\n+    bool b = true;\n     for (auto i = 0; i < 200; ++i) {\n-        BOOST_REQUIRE(results.count(i) == 1);\n+        b = b && results.count(i) == 1;\n         results.erase(i);\n     }\n+    BOOST_REQUIRE(b);\n     BOOST_REQUIRE(results.empty());\n     BOOST_REQUIRE(m == 200);\n }\n@@ -93,19 +95,23 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_PriorityWorkQueue_stealing)\n         results.insert(x);\n         ++m;\n     }\n+    bool b = true;\n     for (auto i = 0; i < 160; i+=16) {\n-        BOOST_REQUIRE(results.count(i) == 1);\n+        b = b &&results.count(i) == 1;\n         results.erase(i);\n     }\n+    BOOST_REQUIRE(b);\n     BOOST_REQUIRE(results.empty());\n     while (work.pop(x, true)) {\n         results.insert(x);\n         ++m;\n     }\n+    bool b2 = true;\n     for (auto i = 0; i < 160; ++i) {\n-        BOOST_REQUIRE(results.count(i) == 1 || (i %16) == 0);\n+        b2 = b2 && (results.count(i) == 1 || (i %16) == 0);\n         results.erase(i);\n     }\n+    BOOST_REQUIRE(b2);\n }\n \n typedef CCheckQueue_Internals::job_array<Standard_Queue> J;\n@@ -217,7 +223,7 @@ void Correct_Queue_range(std::vector<size_t> range)\n             }\n         }\n         if (print_Correct_Queue) {\n-            small_queue->TEST_dump_log(nScriptCheckThreads);\n+            small_queue->TEST_dump_log();\n             small_queue->TEST_erase_log();\n         }\n         if (FakeJobCheckCompletion::n_calls != i) {\n@@ -291,7 +297,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n             for (size_t x = 0; x < i; ++x)\n                 if ((*jobs)[x].call_state)\n                     nChecked++;\n-            fail_queue->TEST_dump_log(nScriptCheckThreads);\n+            fail_queue->TEST_dump_log();\n             fail_queue->TEST_erase_log();\n             BOOST_REQUIRE(!success);\n         } else if (i == 0) {\n@@ -309,14 +315,15 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n \n     for (auto times = 0; times < 10; ++times) {\n         std::array<bool, 2> result;\n-        for (size_t i : {0, 1}) {\n+        for (bool end_fails : {true, false}) {\n             CCheckQueueControl<Failing_Queue> control(fail_queue.get());\n             {\n                 auto inserter = control.get_inserter();\n-                for (size_t k = 0; k < 100-i; ++k)\n-                    new (inserter()) FailingJob {k == 99};\n+                for (size_t k = 0; k < 100; ++k)\n+                    new (inserter()) FailingJob {k == 99 && end_fails};\n             }\n-            result[i] = control.Wait();\n+            result[end_fails ? 0 : 1] = control.Wait();\n+            fail_queue->TEST_dump_log();\n             fail_queue->TEST_erase_log();\n         }\n         BOOST_CHECK(!result[0]);\n@@ -357,8 +364,10 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueJob)\n                 new (inserter()) UniqueJob{--total};\n         }\n     }\n+    bool r = true;\n     for (size_t i = 0; i < COUNT; ++i)\n-        BOOST_REQUIRE(UniqueJob::results.count(i) == 1);\n+        r = r && UniqueJob::results.count(i) == 1;\n+    BOOST_REQUIRE(r);\n \n }\n \n@@ -399,5 +408,56 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Memory)\n     }\n }\n \n+struct FrozenCleanupJob {\n+    static std::atomic<bool> frozen;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupJob() {}\n+    ~FrozenCleanupJob()\n+    {\n+        while (frozen)\n+            ;\n+    }\n+    void swap(FrozenCleanupJob& x) {};\n+};\n+\n+std::atomic<bool> FrozenCleanupJob::frozen {false};\n+typedef CCheckQueue<FrozenCleanupJob, (size_t)1000, MAX_SCRIPTCHECK_THREADS> FrozenCleanup_Queue;\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_FrozenCleanup)\n+{\n+    auto queue = std::shared_ptr<FrozenCleanup_Queue>(new FrozenCleanup_Queue{});\n+    queue->init(nScriptCheckThreads);\n+    std::thread t0([&](){\n+        CCheckQueueControl<FrozenCleanup_Queue> control(queue.get());\n+        {\n+            auto inserter = control.get_inserter();\n+            new (inserter()) FrozenCleanupJob{};\n+        }\n+        FrozenCleanupJob::frozen = true;\n+        BOOST_REQUIRE(control.Wait());\n+    });\n+    std::atomic<bool> made_control{false};\n+    std::thread t1([&](){\n+        CCheckQueueControl<FrozenCleanup_Queue> control(queue.get());\n+        made_control = true;\n+    });\n+    std::thread t2([&](){\n+        bool b = true;\n+        for (auto i = 0; i < 3000; ++i) {\n+            b = b && !made_control;\n+            MilliSleep(1);\n+        }\n+        FrozenCleanupJob::frozen = false;\n+        while (!made_control){}\n+\n+\n+    });\n+    t1.join();\n+    t2.join();\n+    t0.join();\n+\n+}\n \n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "fd9da3305ba135c04220fa68ebe347747b5e36a9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZDlkYTMzMDViYTEzNWMwNDIyMGZhNjhlYmUzNDc3NDdiNWUzNmE5",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-19T07:42:21Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "Fix cleanup waiting position. Change test_dump_log to use field RT_N_THREADS",
      "tree": {
        "sha": "c751550117c716990ab44c3f266b895c2f41a1a4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c751550117c716990ab44c3f266b895c2f41a1a4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fd9da3305ba135c04220fa68ebe347747b5e36a9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fd9da3305ba135c04220fa68ebe347747b5e36a9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fd9da3305ba135c04220fa68ebe347747b5e36a9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fd9da3305ba135c04220fa68ebe347747b5e36a9/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "11dc3b34d829aa7b574267b21e0ecb82fc08e739",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/11dc3b34d829aa7b574267b21e0ecb82fc08e739",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/11dc3b34d829aa7b574267b21e0ecb82fc08e739"
      }
    ],
    "stats": {
      "total": 18,
      "additions": 8,
      "deletions": 10
    },
    "files": [
      {
        "sha": "873817d1a03b66c7e9782984a0fa1543c3c3d4d0",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 8,
        "deletions": 10,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd9da3305ba135c04220fa68ebe347747b5e36a9/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd9da3305ba135c04220fa68ebe347747b5e36a9/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=fd9da3305ba135c04220fa68ebe347747b5e36a9",
        "patch": "@@ -387,14 +387,13 @@ class CCheckQueue\n     /** Internal function that does bulk of the verification work. */\n     bool Master() {\n         const size_t ID = 0;\n-        work.wait_reset();\n         masterJoined.store(true);\n         TEST_log(ID, [](std::ostringstream& o) { o << \"Master just set masterJoined\\n\"; });\n         consume(ID);\n         work.finished();\n         work.wait_all_finished();\n         TEST_log(ID, [](std::ostringstream& o) { o << \"(Master) saw all threads finished\\n\"; });\n-        bool fRet = fAllOk;\n+        bool fRet = fAllOk.load();\n         sleeper.sleep();\n         masterJoined.store(false);\n         return fRet;\n@@ -425,6 +424,9 @@ class CCheckQueue\n                 jobs.clear_check_memory();\n                 cleanup.wait_all_finished();\n                 cleanup.reset();\n+                TEST_log(0, [](std::ostringstream& o) { o << \"Resetting nAvail and fAllOk\\n\"; });\n+                nAvail.store(0);\n+                fAllOk.store(true);\n                 work.reset();\n             }\n         }\n@@ -449,13 +451,9 @@ class CCheckQueue\n \n     void ControlLock() {\n         control_mtx.lock();\n-        TEST_log(0, [](std::ostringstream& o) {\n-            o << \"Resetting nAvail and fAllOk\" << '\\n';\n-        });\n-        nAvail.store(0);\n-        fAllOk.store(true);\n-        sleeper.wakeup();\n         reset_jobs();\n+        sleeper.wakeup();\n+        work.wait_reset();\n     }\n     void ControlUnlock() {\n         control_mtx.unlock();\n@@ -544,11 +542,11 @@ class CCheckQueue\n         }\n     }\n \n-    void TEST_dump_log(const size_t upto) const\n+    void TEST_dump_log() const\n     {\n         if (TEST_FUNCTIONS_ENABLE) {\n             LogPrintf(\"\\n#####################\\n## Round Beginning ##\\n#####################\");\n-            for (auto i = 0; i < upto; ++i)\n+            for (auto i = 0; i < RT_N_SCRIPTCHECK_THREADS; ++i)\n                 LogPrintf(\"\\n------------------\\n%s\\n------------------\\n\\n\", test_log[i].str());\n         }\n     }"
      }
    ]
  },
  {
    "sha": "11ea533f27ec7f6f2be0796230c037eafd73e6e5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMWVhNTMzZjI3ZWM3ZjZmMmJlMDc5NjIzMGMwMzdlYWZkNzNlNmU1",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-19T18:01:32Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "Refactor some code to be a bit cleaner for inserter use",
      "tree": {
        "sha": "519104bbe1e2908bb6a4504cd00584624b19a22a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/519104bbe1e2908bb6a4504cd00584624b19a22a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/11ea533f27ec7f6f2be0796230c037eafd73e6e5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/11ea533f27ec7f6f2be0796230c037eafd73e6e5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/11ea533f27ec7f6f2be0796230c037eafd73e6e5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/11ea533f27ec7f6f2be0796230c037eafd73e6e5/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fd9da3305ba135c04220fa68ebe347747b5e36a9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fd9da3305ba135c04220fa68ebe347747b5e36a9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fd9da3305ba135c04220fa68ebe347747b5e36a9"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 11,
      "deletions": 8
    },
    "files": [
      {
        "sha": "1cdde9ba04f255e0906e888b540067afb0db2b01",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/11ea533f27ec7f6f2be0796230c037eafd73e6e5/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/11ea533f27ec7f6f2be0796230c037eafd73e6e5/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=11ea533f27ec7f6f2be0796230c037eafd73e6e5",
        "patch": "@@ -49,9 +49,13 @@ class inserter {\n        queue(queueIn),\n        start(queue ? queue->get_next_free_index() : nullptr),\n        free_index(start) {}\n+    typename Q::JOB_TYPE * operator()(typename Q::JOB_TYPE * def)\n+    {\n+        return free_index ? free_index++ : def;\n+    }\n     typename Q::JOB_TYPE * operator()()\n     {\n-        return start ? free_index++ : nullptr;\n+        return free_index++;\n     }\n     ~inserter()\n     {"
      },
      {
        "sha": "9e5704738e75a2645e1066e6925389836f04d3ca",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/11ea533f27ec7f6f2be0796230c037eafd73e6e5/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/11ea533f27ec7f6f2be0796230c037eafd73e6e5/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=11ea533f27ec7f6f2be0796230c037eafd73e6e5",
        "patch": "@@ -1969,7 +1969,7 @@ bool CheckTxInputs(const CTransaction& tx, CValidationState& state, const CCoins\n }\n }// namespace Consensus\n \n-bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheStore, std::function<CScriptCheck * ()> inserter)\n+bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheStore, std::function<CScriptCheck * (CScriptCheck *)> inserter)\n {\n     if (!tx.IsCoinBase())\n     {\n@@ -1995,9 +1995,9 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n \n                 // Verify signature\n                 CScriptCheck check;\n-                CScriptCheck * const ptr = inserter();\n-                new (ptr ? ptr : &check) CScriptCheck(*coins, tx, i, flags, cacheStore);\n-                if (!ptr && !check()) {\n+                CScriptCheck * const ptr = inserter(&check);\n+                new (ptr) CScriptCheck(*coins, tx, i, flags, cacheStore);\n+                if (ptr == &check && !check()) {\n                     if (flags & STANDARD_NOT_MANDATORY_VERIFY_FLAGS) {\n                         // Check whether the failure was caused by a\n                         // non-mandatory script verification check, such as\n@@ -2456,8 +2456,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n             nFees += view.GetValueIn(tx)-tx.GetValueOut();\n \n             bool fCacheResults = fJustCheck; /* Don't cache results if we're actually connecting blocks (still consult the cache, though) */\n-            std::function<CScriptCheck*()> inserter = control.get_inserter();\n-            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, inserter))\n+            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, control.get_inserter()))\n                 return error(\"ConnectBlock(): CheckInputs on %s failed with %s\",\n                     tx.GetHash().ToString(), FormatStateMessage(state));\n         }"
      },
      {
        "sha": "a6ab6c30e06da35b0b7c75ff3c2092eb1e5bc24a",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/11ea533f27ec7f6f2be0796230c037eafd73e6e5/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/11ea533f27ec7f6f2be0796230c037eafd73e6e5/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=11ea533f27ec7f6f2be0796230c037eafd73e6e5",
        "patch": "@@ -349,7 +349,7 @@ int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& i\n  * instead of being performed inline.\n  */\n bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &view, bool fScriptChecks,\n-                 unsigned int flags, bool cacheStore, std::function<CScriptCheck * () > inserter = [](){return nullptr;});\n+                 unsigned int flags, bool cacheStore, std::function<CScriptCheck * (CScriptCheck *) > inserter = [](CScriptCheck * d){return d;});\n \n /** Apply the effects of this transaction on the UTXO set represented by view */\n void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, int nHeight);"
      }
    ]
  },
  {
    "sha": "ef8af35062c6047b94c75cf2f701e5b176f7a148",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplZjhhZjM1MDYyYzYwNDdiOTRjNzVjZjJmNzAxZTViMTc2ZjdhMTQ4",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-19T18:38:17Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "Add core dump callstack dumps to travis (see http://jsteemann.github.io/blog/2014/10/30/getting-core-dumps-of-failed-travisci-builds/)\n\nConflicts:\n\t.travis.yml",
      "tree": {
        "sha": "157fc564c9d7e83238de3718319ecd51fd32ab13",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/157fc564c9d7e83238de3718319ecd51fd32ab13"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ef8af35062c6047b94c75cf2f701e5b176f7a148",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ef8af35062c6047b94c75cf2f701e5b176f7a148",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ef8af35062c6047b94c75cf2f701e5b176f7a148",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ef8af35062c6047b94c75cf2f701e5b176f7a148/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "11ea533f27ec7f6f2be0796230c037eafd73e6e5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/11ea533f27ec7f6f2be0796230c037eafd73e6e5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/11ea533f27ec7f6f2be0796230c037eafd73e6e5"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 9,
      "deletions": 5
    },
    "files": [
      {
        "sha": "0a12e437a0da8348aca6e861a8c3ba824dcba2b8",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 9,
        "deletions": 5,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ef8af35062c6047b94c75cf2f701e5b176f7a148/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ef8af35062c6047b94c75cf2f701e5b176f7a148/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=ef8af35062c6047b94c75cf2f701e5b176f7a148",
        "patch": "@@ -24,15 +24,15 @@ env:\n # ARM\n     - HOST=arm-linux-gnueabihf PACKAGES=\"g++-arm-linux-gnueabihf\" DEP_OPTS=\"NO_QT=1\" CHECK_DOC=1 GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports\"\n # Win32\n-    - HOST=i686-w64-mingw32 DPKG_ADD_ARCH=\"i386\" DEP_OPTS=\"NO_QT=1\" PACKAGES=\"python3 nsis g++-mingw-w64-i686 wine1.6 bc\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-reduce-exports\"\n+    - HOST=i686-w64-mingw32 DPKG_ADD_ARCH=\"i386\" DEP_OPTS=\"NO_QT=1\" PACKAGES=\"python3 nsis g++-mingw-w64-i686 wine1.6 bc gdb\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-reduce-exports\"\n # 32-bit + dash\n-    - HOST=i686-pc-linux-gnu PACKAGES=\"g++-multilib bc python3-zmq\" DEP_OPTS=\"NO_QT=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --enable-glibc-back-compat --enable-reduce-exports LDFLAGS=-static-libstdc++\" USE_SHELL=\"/bin/dash\"\n+    - HOST=i686-pc-linux-gnu PACKAGES=\"g++-multilib bc python3-zmq gdb\" DEP_OPTS=\"NO_QT=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --enable-glibc-back-compat --enable-reduce-exports LDFLAGS=-static-libstdc++\" USE_SHELL=\"/bin/dash\"\n # Win64\n-    - HOST=x86_64-w64-mingw32 DPKG_ADD_ARCH=\"i386\" DEP_OPTS=\"NO_QT=1\" PACKAGES=\"python3 nsis g++-mingw-w64-x86-64 wine1.6 bc\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-reduce-exports\"\n+    - HOST=x86_64-w64-mingw32 DPKG_ADD_ARCH=\"i386\" DEP_OPTS=\"NO_QT=1\" PACKAGES=\"python3 nsis g++-mingw-w64-x86-64 wine1.6 bc gdb\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-reduce-exports\"\n # bitcoind\n-    - HOST=x86_64-unknown-linux-gnu PACKAGES=\"bc python3-zmq\" DEP_OPTS=\"NO_QT=1 NO_UPNP=1 DEBUG=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --enable-glibc-back-compat --enable-reduce-exports CPPFLAGS=-DDEBUG_LOCKORDER\"\n+    - HOST=x86_64-unknown-linux-gnu PACKAGES=\"bc python3-zmq gdb\" DEP_OPTS=\"NO_QT=1 NO_UPNP=1 DEBUG=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --enable-glibc-back-compat --enable-reduce-exports CPPFLAGS=-DDEBUG_LOCKORDER\"\n # No wallet\n-    - HOST=x86_64-unknown-linux-gnu PACKAGES=\"python3\" DEP_OPTS=\"NO_WALLET=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports\"\n+    - HOST=x86_64-unknown-linux-gnu PACKAGES=\"python3 gdb\" DEP_OPTS=\"NO_WALLET=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports\"\n # Cross-Mac\n     - HOST=x86_64-apple-darwin11 PACKAGES=\"cmake imagemagick libcap-dev librsvg2-bin libz-dev libbz2-dev libtiff-tools python-dev\" BITCOIN_CONFIG=\"--enable-reduce-exports\" OSX_SDK=10.11 GOAL=\"deploy\"\n \n@@ -44,6 +44,7 @@ install:\n     - if [ -n \"$PACKAGES\" ]; then travis_retry sudo apt-get update; fi\n     - if [ -n \"$PACKAGES\" ]; then travis_retry sudo apt-get install --no-install-recommends --no-upgrade -qq $PACKAGES; fi\n before_script:\n+    - ulimit -c unlimited -S       # enable core dumps\n     - unset CC; unset CXX\n     - if [ \"$CHECK_DOC\" = 1 ]; then contrib/devtools/check-doc.py; fi\n     - mkdir -p depends/SDKs depends/sdk-sources\n@@ -66,3 +67,6 @@ script:\n after_script:\n     - echo $TRAVIS_COMMIT_RANGE\n     - echo $TRAVIS_COMMIT_LOG\n+after_failure:\n+    - COREFILE=$(find . -maxdepth 1 -name \"core*\" | head -n 1) # find core file\n+    - if [[ -f \"$COREFILE\" ]]; then gdb -c \"$COREFILE\" example -ex \"thread apply all bt\" -ex \"set pagination 0\" -batch; fi"
      }
    ]
  },
  {
    "sha": "0fbcf7aaabc3078d1fe6b24527e746eefb01ab31",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowZmJjZjdhYWFiYzMwNzhkMWZlNmIyNDUyN2U3NDZlZWZiMDFhYjMx",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-19T18:38:36Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "remove uneeded include",
      "tree": {
        "sha": "8ae40e5f3d859cb14cd20c14c9bdbeffe1e71487",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8ae40e5f3d859cb14cd20c14c9bdbeffe1e71487"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0fbcf7aaabc3078d1fe6b24527e746eefb01ab31",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0fbcf7aaabc3078d1fe6b24527e746eefb01ab31",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0fbcf7aaabc3078d1fe6b24527e746eefb01ab31",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0fbcf7aaabc3078d1fe6b24527e746eefb01ab31/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ef8af35062c6047b94c75cf2f701e5b176f7a148",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ef8af35062c6047b94c75cf2f701e5b176f7a148",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ef8af35062c6047b94c75cf2f701e5b176f7a148"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 0,
      "deletions": 1
    },
    "files": [
      {
        "sha": "2fc9a301c4d12597e59de09efc97bebad52c5d33",
        "filename": "src/bench/checkqueue.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0fbcf7aaabc3078d1fe6b24527e746eefb01ab31/src/bench/checkqueue.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0fbcf7aaabc3078d1fe6b24527e746eefb01ab31/src/bench/checkqueue.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkqueue.cpp?ref=0fbcf7aaabc3078d1fe6b24527e746eefb01ab31",
        "patch": "@@ -6,7 +6,6 @@\n #include \"bench.h\"\n #include \"util.h\"\n #include \"main.h\"\n-#include <vector>\n #include \"checkqueue.h\"\n \n static void CCheckQueueSpeed(benchmark::State& state)"
      }
    ]
  },
  {
    "sha": "82147ff3777b20ad6f47e6a59c61604cc094b9a2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4MjE0N2ZmMzc3N2IyMGFkNmY0N2U2YTU5YzYxNjA0Y2MwOTRiOWEy",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-19T22:41:31Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "Fixed travis file for finding core dump more likely",
      "tree": {
        "sha": "fecb401544036321191148ceaf30ae5d579091db",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fecb401544036321191148ceaf30ae5d579091db"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/82147ff3777b20ad6f47e6a59c61604cc094b9a2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/82147ff3777b20ad6f47e6a59c61604cc094b9a2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/82147ff3777b20ad6f47e6a59c61604cc094b9a2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/82147ff3777b20ad6f47e6a59c61604cc094b9a2/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0fbcf7aaabc3078d1fe6b24527e746eefb01ab31",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0fbcf7aaabc3078d1fe6b24527e746eefb01ab31",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0fbcf7aaabc3078d1fe6b24527e746eefb01ab31"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "2f9b12ade235bae593aea7232b6597c736655d09",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/82147ff3777b20ad6f47e6a59c61604cc094b9a2/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/82147ff3777b20ad6f47e6a59c61604cc094b9a2/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=82147ff3777b20ad6f47e6a59c61604cc094b9a2",
        "patch": "@@ -68,5 +68,5 @@ after_script:\n     - echo $TRAVIS_COMMIT_RANGE\n     - echo $TRAVIS_COMMIT_LOG\n after_failure:\n-    - COREFILE=$(find . -maxdepth 1 -name \"core*\" | head -n 1) # find core file\n+    - COREFILE=$(find ~  -name \"core-*\" | head -n 1) # find core file\n     - if [[ -f \"$COREFILE\" ]]; then gdb -c \"$COREFILE\" example -ex \"thread apply all bt\" -ex \"set pagination 0\" -batch; fi"
      }
    ]
  },
  {
    "sha": "1381483148a444c578fb123bfba7a3576946ff0d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMzgxNDgzMTQ4YTQ0NGM1NzhmYjEyM2JmYmE3YTM1NzY5NDZmZjBk",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-21T01:30:38Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "make travis search root for corefile",
      "tree": {
        "sha": "4c9fa693173e5671ce74f0561183e529af202195",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4c9fa693173e5671ce74f0561183e529af202195"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1381483148a444c578fb123bfba7a3576946ff0d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1381483148a444c578fb123bfba7a3576946ff0d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1381483148a444c578fb123bfba7a3576946ff0d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1381483148a444c578fb123bfba7a3576946ff0d/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "82147ff3777b20ad6f47e6a59c61604cc094b9a2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/82147ff3777b20ad6f47e6a59c61604cc094b9a2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/82147ff3777b20ad6f47e6a59c61604cc094b9a2"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "5ff6ef4e5b5e63ee4a67437204b354661d7ede24",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1381483148a444c578fb123bfba7a3576946ff0d/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1381483148a444c578fb123bfba7a3576946ff0d/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=1381483148a444c578fb123bfba7a3576946ff0d",
        "patch": "@@ -68,5 +68,5 @@ after_script:\n     - echo $TRAVIS_COMMIT_RANGE\n     - echo $TRAVIS_COMMIT_LOG\n after_failure:\n-    - COREFILE=$(find ~  -name \"core-*\" | head -n 1) # find core file\n+    - COREFILE=$(sudo find /  -name \"core-*\" | head -n 1) # find core file\n     - if [[ -f \"$COREFILE\" ]]; then gdb -c \"$COREFILE\" example -ex \"thread apply all bt\" -ex \"set pagination 0\" -batch; fi"
      }
    ]
  },
  {
    "sha": "677f91502de4799663158cf7e75b9ec6601555b7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NzdmOTE1MDJkZTQ3OTk2NjMxNThjZjdlNzViOWVjNjYwMTU1NWI3",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-21T03:33:18Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "Use unique_ptr in miner_tests",
      "tree": {
        "sha": "fee4eeae90bad31e6ceb745212d25c33fadfb355",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fee4eeae90bad31e6ceb745212d25c33fadfb355"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/677f91502de4799663158cf7e75b9ec6601555b7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/677f91502de4799663158cf7e75b9ec6601555b7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/677f91502de4799663158cf7e75b9ec6601555b7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/677f91502de4799663158cf7e75b9ec6601555b7/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1381483148a444c578fb123bfba7a3576946ff0d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1381483148a444c578fb123bfba7a3576946ff0d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1381483148a444c578fb123bfba7a3576946ff0d"
      }
    ],
    "stats": {
      "total": 124,
      "additions": 69,
      "deletions": 55
    },
    "files": [
      {
        "sha": "100ea1417602b8c64a7b8a1f02c5f0d1d5014485",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 69,
        "deletions": 55,
        "changes": 124,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/677f91502de4799663158cf7e75b9ec6601555b7/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/677f91502de4799663158cf7e75b9ec6601555b7/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=677f91502de4799663158cf7e75b9ec6601555b7",
        "patch": "@@ -75,7 +75,7 @@ bool TestSequenceLocks(const CTransaction &tx, int flags)\n // Implemented as an additional function, rather than a separate test case,\n // to allow reusing the blockchain created in CreateNewBlock_validity.\n // Note that this test assumes blockprioritysize is 0.\n-void TestPackageSelection(const CChainParams& chainparams, CScript scriptPubKey, std::vector<CTransaction *>& txFirst)\n+void TestPackageSelection(const CChainParams& chainparams, CScript scriptPubKey, std::vector<std::unique_ptr<CTransaction>>& txFirst)\n {\n     // Test the ancestor feerate transaction selection.\n     TestMemPoolEntryHelper entry;\n@@ -184,7 +184,6 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     // Note that by default, these tests run with size accounting enabled.\n     const CChainParams& chainparams = Params(CBaseChainParams::MAIN);\n     CScript scriptPubKey = CScript() << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\") << OP_CHECKSIG;\n-    CBlockTemplate *pblocktemplate;\n     CMutableTransaction tx,tx2;\n     CScript script;\n     uint256 hash;\n@@ -196,41 +195,45 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     LOCK(cs_main);\n     fCheckpointsEnabled = false;\n \n-    // Simple block creation, nothing special yet:\n-    BOOST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n-\n-    // We can't make transactions until we have inputs\n-    // Therefore, load 100 blocks :)\n     int baseheight = 0;\n-    std::vector<CTransaction*>txFirst;\n-    for (unsigned int i = 0; i < sizeof(blockinfo)/sizeof(*blockinfo); ++i)\n+    std::vector<std::unique_ptr<CTransaction>>txFirst;\n+    // Simple block creation, nothing special yet:\n     {\n-        CBlock *pblock = &pblocktemplate->block; // pointer for convenience\n-        pblock->nVersion = 1;\n-        pblock->nTime = chainActive.Tip()->GetMedianTimePast()+1;\n-        CMutableTransaction txCoinbase(pblock->vtx[0]);\n-        txCoinbase.nVersion = 1;\n-        txCoinbase.vin[0].scriptSig = CScript();\n-        txCoinbase.vin[0].scriptSig.push_back(blockinfo[i].extranonce);\n-        txCoinbase.vin[0].scriptSig.push_back(chainActive.Height());\n-        txCoinbase.vout[0].scriptPubKey = CScript();\n-        pblock->vtx[0] = CTransaction(txCoinbase);\n-        if (txFirst.size() == 0)\n-            baseheight = chainActive.Height();\n-        if (txFirst.size() < 4)\n-            txFirst.push_back(new CTransaction(pblock->vtx[0]));\n-        pblock->hashMerkleRoot = BlockMerkleRoot(*pblock);\n-        pblock->nNonce = blockinfo[i].nonce;\n-        CValidationState state;\n-        BOOST_CHECK(ProcessNewBlock(state, chainparams, NULL, pblock, true, NULL));\n-        BOOST_CHECK(state.IsValid());\n-        pblock->hashPrevBlock = pblock->GetHash();\n+        std::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n+        BOOST_CHECK(pblocktemplate);\n+\n+        // We can't make transactions until we have inputs\n+        // Therefore, load 100 blocks :)\n+        for (unsigned int i = 0; i < sizeof(blockinfo)/sizeof(*blockinfo); ++i)\n+        {\n+            CBlock *pblock = &pblocktemplate->block; // pointer for convenience\n+            pblock->nVersion = 1;\n+            pblock->nTime = chainActive.Tip()->GetMedianTimePast()+1;\n+            CMutableTransaction txCoinbase(pblock->vtx[0]);\n+            txCoinbase.nVersion = 1;\n+            txCoinbase.vin[0].scriptSig = CScript();\n+            txCoinbase.vin[0].scriptSig.push_back(blockinfo[i].extranonce);\n+            txCoinbase.vin[0].scriptSig.push_back(chainActive.Height());\n+            txCoinbase.vout[0].scriptPubKey = CScript();\n+            pblock->vtx[0] = CTransaction(txCoinbase);\n+            if (txFirst.size() == 0)\n+                baseheight = chainActive.Height();\n+            if (txFirst.size() < 4)\n+                txFirst.push_back(std::unique_ptr<CTransaction> (new CTransaction(pblock->vtx[0])));\n+            pblock->hashMerkleRoot = BlockMerkleRoot(*pblock);\n+            pblock->nNonce = blockinfo[i].nonce;\n+            CValidationState state;\n+            BOOST_CHECK(ProcessNewBlock(state, chainparams, NULL, pblock, true, NULL));\n+            BOOST_CHECK(state.IsValid());\n+            pblock->hashPrevBlock = pblock->GetHash();\n+        }\n     }\n-    delete pblocktemplate;\n \n     // Just to make sure we can still make simple blocks\n-    BOOST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n-    delete pblocktemplate;\n+    {\n+        std::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n+        BOOST_CHECK(pblocktemplate);\n+    }\n \n     const CAmount BLOCKSUBSIDY = 50*COIN;\n     const CAmount LOWFEE = CENT;\n@@ -268,8 +271,10 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         mempool.addUnchecked(hash, entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).SigOpsCost(80).FromTx(tx));\n         tx.vin[0].prevout.hash = hash;\n     }\n-    BOOST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n-    delete pblocktemplate;\n+    {\n+        std::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n+        BOOST_CHECK(pblocktemplate);\n+    }\n     mempool.clear();\n \n     // block size > limit\n@@ -289,8 +294,10 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         mempool.addUnchecked(hash, entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).FromTx(tx));\n         tx.vin[0].prevout.hash = hash;\n     }\n-    BOOST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n-    delete pblocktemplate;\n+    {\n+        std::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n+        BOOST_CHECK(pblocktemplate);\n+    }\n     mempool.clear();\n \n     // orphan in mempool, template creation fails\n@@ -313,8 +320,10 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vout[0].nValue = tx.vout[0].nValue+BLOCKSUBSIDY-HIGHERFEE; //First txn output + fresh coinbase - new txn fee\n     hash = tx.GetHash();\n     mempool.addUnchecked(hash, entry.Fee(HIGHERFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n-    BOOST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n-    delete pblocktemplate;\n+    {\n+        std::unique_ptr<CBlockTemplate> pblocktemplate (BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n+        BOOST_CHECK(pblocktemplate);\n+    }\n     mempool.clear();\n \n     // coinbase in mempool, template creation fails\n@@ -371,8 +380,10 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         next->BuildSkip();\n         chainActive.SetTip(next);\n     }\n-    BOOST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n-    delete pblocktemplate;\n+    {\n+        std::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n+        BOOST_CHECK(pblocktemplate);\n+    }\n     // Extend to a 210000-long block chain.\n     while (chainActive.Tip()->nHeight < 210000) {\n         CBlockIndex* prev = chainActive.Tip();\n@@ -384,8 +395,10 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         next->BuildSkip();\n         chainActive.SetTip(next);\n     }\n-    BOOST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n-    delete pblocktemplate;\n+    {\n+        std::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n+        BOOST_CHECK(pblocktemplate);\n+    }\n     // Delete the dummy blocks again.\n     while (chainActive.Tip()->nHeight > nHeight) {\n         CBlockIndex* del = chainActive.Tip();\n@@ -471,33 +484,34 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vin[0].nSequence = CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG | 1;\n     BOOST_CHECK(!TestSequenceLocks(tx, flags)); // Sequence locks fail\n \n-    BOOST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n+    {\n+        std::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n+        BOOST_CHECK(pblocktemplate);\n+        // None of the of the absolute height/time locked tx should have made\n+        // it into the template because we still check IsFinalTx in CreateNewBlock,\n+        // but relative locked txs will if inconsistently added to mempool.\n+        // For now these will still generate a valid template until BIP68 soft fork\n+        BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 3);\n+    }\n \n-    // None of the of the absolute height/time locked tx should have made\n-    // it into the template because we still check IsFinalTx in CreateNewBlock,\n-    // but relative locked txs will if inconsistently added to mempool.\n-    // For now these will still generate a valid template until BIP68 soft fork\n-    BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 3);\n-    delete pblocktemplate;\n     // However if we advance height by 1 and time by 512, all of them should be mined\n     for (int i = 0; i < CBlockIndex::nMedianTimeSpan; i++)\n         chainActive.Tip()->GetAncestor(chainActive.Tip()->nHeight - i)->nTime += 512; //Trick the MedianTimePast\n     chainActive.Tip()->nHeight++;\n     SetMockTime(chainActive.Tip()->GetMedianTimePast() + 1);\n \n-    BOOST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n-    BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 5);\n-    delete pblocktemplate;\n+    {\n+        std::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n+        BOOST_CHECK(pblocktemplate);\n+        BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 5);\n+    }\n \n     chainActive.Tip()->nHeight--;\n     SetMockTime(0);\n     mempool.clear();\n \n     TestPackageSelection(chainparams, scriptPubKey, txFirst);\n \n-    BOOST_FOREACH(CTransaction *_tx, txFirst)\n-        delete _tx;\n-\n     fCheckpointsEnabled = true;\n }\n "
      }
    ]
  },
  {
    "sha": "d2c886df1ba51d5a5821cd5fb7e8ae28710a24e7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMmM4ODZkZjFiYTUxZDVhNTgyMWNkNWZiN2U4YWUyODcxMGEyNGU3",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-21T21:47:11Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "Made CBlockIndex and uint256 hashes allocated in RAII containers",
      "tree": {
        "sha": "42b1fe3efcdf9b74ff974e2a3855de8568bbf23c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/42b1fe3efcdf9b74ff974e2a3855de8568bbf23c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d2c886df1ba51d5a5821cd5fb7e8ae28710a24e7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d2c886df1ba51d5a5821cd5fb7e8ae28710a24e7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d2c886df1ba51d5a5821cd5fb7e8ae28710a24e7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d2c886df1ba51d5a5821cd5fb7e8ae28710a24e7/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "677f91502de4799663158cf7e75b9ec6601555b7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/677f91502de4799663158cf7e75b9ec6601555b7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/677f91502de4799663158cf7e75b9ec6601555b7"
      }
    ],
    "stats": {
      "total": 79,
      "additions": 42,
      "deletions": 37
    },
    "files": [
      {
        "sha": "aaa92ad7b96dba8582265321dffac148000bf91f",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 42,
        "deletions": 37,
        "changes": 79,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d2c886df1ba51d5a5821cd5fb7e8ae28710a24e7/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d2c886df1ba51d5a5821cd5fb7e8ae28710a24e7/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=d2c886df1ba51d5a5821cd5fb7e8ae28710a24e7",
        "patch": "@@ -368,44 +368,49 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     mempool.clear();\n \n     // subsidy changing\n-    int nHeight = chainActive.Height();\n-    // Create an actual 209999-long block chain (without valid blocks).\n-    while (chainActive.Tip()->nHeight < 209999) {\n-        CBlockIndex* prev = chainActive.Tip();\n-        CBlockIndex* next = new CBlockIndex();\n-        next->phashBlock = new uint256(GetRandHash());\n-        pcoinsTip->SetBestBlock(next->GetBlockHash());\n-        next->pprev = prev;\n-        next->nHeight = prev->nHeight + 1;\n-        next->BuildSkip();\n-        chainActive.SetTip(next);\n-    }\n-    {\n-        std::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n-        BOOST_CHECK(pblocktemplate);\n-    }\n-    // Extend to a 210000-long block chain.\n-    while (chainActive.Tip()->nHeight < 210000) {\n-        CBlockIndex* prev = chainActive.Tip();\n-        CBlockIndex* next = new CBlockIndex();\n-        next->phashBlock = new uint256(GetRandHash());\n-        pcoinsTip->SetBestBlock(next->GetBlockHash());\n-        next->pprev = prev;\n-        next->nHeight = prev->nHeight + 1;\n-        next->BuildSkip();\n-        chainActive.SetTip(next);\n-    }\n     {\n-        std::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n-        BOOST_CHECK(pblocktemplate);\n-    }\n-    // Delete the dummy blocks again.\n-    while (chainActive.Tip()->nHeight > nHeight) {\n-        CBlockIndex* del = chainActive.Tip();\n-        chainActive.SetTip(del->pprev);\n-        pcoinsTip->SetBestBlock(del->pprev->GetBlockHash());\n-        delete del->phashBlock;\n-        delete del;\n+        CBlockIndex* reset_tip = chainActive.Tip();\n+        std::vector<uint256> random_hashes;\n+        std::vector<CBlockIndex> indexes;\n+        indexes.resize(210000, CBlockIndex());\n+        random_hashes.reserve(210000);\n+        for (auto i = 0; i < 210000; ++i) \n+            random_hashes.push_back(uint256(GetRandHash()));\n+        // Create an actual 209999-long block chain (without valid blocks).\n+        auto index_ = 0;\n+        while (chainActive.Tip()->nHeight < 209999) {\n+            CBlockIndex* prev = chainActive.Tip();\n+            CBlockIndex* next = &indexes[index_];\n+            next->phashBlock = &random_hashes[index_];\n+            pcoinsTip->SetBestBlock(next->GetBlockHash());\n+            next->pprev = prev;\n+            next->nHeight = prev->nHeight + 1;\n+            next->BuildSkip();\n+            chainActive.SetTip(next);\n+            ++index_;\n+        }\n+        {\n+            std::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n+            BOOST_CHECK(pblocktemplate);\n+        }\n+        // Extend to a 210000-long block chain.\n+        while (chainActive.Tip()->nHeight < 210000) {\n+            CBlockIndex* prev = chainActive.Tip();\n+            CBlockIndex* next = &indexes[index_];\n+            next->phashBlock = &random_hashes[index_];\n+            pcoinsTip->SetBestBlock(next->GetBlockHash());\n+            next->pprev = prev;\n+            next->nHeight = prev->nHeight + 1;\n+            next->BuildSkip();\n+            chainActive.SetTip(next);\n+            ++index_;\n+        }\n+        {\n+            std::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));\n+            BOOST_CHECK(pblocktemplate);\n+        }\n+        chainActive.SetTip(reset_tip);\n+        pcoinsTip->SetBestBlock(reset_tip->GetBlockHash());\n     }\n \n     // non-final txs in mempool"
      }
    ]
  },
  {
    "sha": "1ca29416793d0d2ff3e45713a373ade10a99dc31",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxY2EyOTQxNjc5M2QwZDJmZjNlNDU3MTNhMzczYWRlMTBhOTlkYzMx",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-25T20:06:13Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "add test-suite.log printing to travis",
      "tree": {
        "sha": "963efd869925a56fed4ad859f7ddd0f31b4aa5c7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/963efd869925a56fed4ad859f7ddd0f31b4aa5c7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1ca29416793d0d2ff3e45713a373ade10a99dc31",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1ca29416793d0d2ff3e45713a373ade10a99dc31",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1ca29416793d0d2ff3e45713a373ade10a99dc31",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1ca29416793d0d2ff3e45713a373ade10a99dc31/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d2c886df1ba51d5a5821cd5fb7e8ae28710a24e7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d2c886df1ba51d5a5821cd5fb7e8ae28710a24e7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d2c886df1ba51d5a5821cd5fb7e8ae28710a24e7"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 2,
      "deletions": 0
    },
    "files": [
      {
        "sha": "7d89f7410885c1b4d7c6bd70f8543b3e62d955b3",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ca29416793d0d2ff3e45713a373ade10a99dc31/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ca29416793d0d2ff3e45713a373ade10a99dc31/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=1ca29416793d0d2ff3e45713a373ade10a99dc31",
        "patch": "@@ -70,3 +70,5 @@ after_script:\n after_failure:\n     - COREFILE=$(sudo find /  -name \"core-*\" | head -n 1) # find core file\n     - if [[ -f \"$COREFILE\" ]]; then gdb -c \"$COREFILE\" example -ex \"thread apply all bt\" -ex \"set pagination 0\" -batch; fi\n+    - LOGFILE=$(find ~ -name \"test-suite.log\" | head -n 1)\n+    - if [[ -f \"$LOGFILE\" ]]; then  cat $LOGFILE; fi"
      }
    ]
  },
  {
    "sha": "6a0582dd4f51aa7e38605afe5fe3c1b2efd4a8f1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2YTA1ODJkZDRmNTFhYTdlMzg2MDVhZmU1ZmUzYzFiMmVmZDRhOGYx",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-26T04:24:23Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "Fixed a bug where a worker could observe nAvail and fAllOk from previous round\nThis fixes a bug where a deallocated check could be called.",
      "tree": {
        "sha": "69e5129dd2ba11dd369db618ab11a03b15b2bc35",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/69e5129dd2ba11dd369db618ab11a03b15b2bc35"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6a0582dd4f51aa7e38605afe5fe3c1b2efd4a8f1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6a0582dd4f51aa7e38605afe5fe3c1b2efd4a8f1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6a0582dd4f51aa7e38605afe5fe3c1b2efd4a8f1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6a0582dd4f51aa7e38605afe5fe3c1b2efd4a8f1/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1ca29416793d0d2ff3e45713a373ade10a99dc31",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1ca29416793d0d2ff3e45713a373ade10a99dc31",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1ca29416793d0d2ff3e45713a373ade10a99dc31"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 3,
      "deletions": 3
    },
    "files": [
      {
        "sha": "649d84558f1610060527f4643130792a7335ab61",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a0582dd4f51aa7e38605afe5fe3c1b2efd4a8f1/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a0582dd4f51aa7e38605afe5fe3c1b2efd4a8f1/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=6a0582dd4f51aa7e38605afe5fe3c1b2efd4a8f1",
        "patch": "@@ -422,15 +422,15 @@ class CCheckQueue\n             TEST_log(ID, [](std::ostringstream& o) { o << \"Saw master leave\\n\"; });\n             jobs.reset_flags_for(ID, prev_total);\n             cleanup.finished();\n+            TEST_log(ID, [](std::ostringstream& o) { o << \"Resetting nAvail and fAllOk\\n\"; });\n+            nAvail.store(0);\n+            fAllOk.store(true);\n             if (ID == 1) {\n                 // Reset master flags too\n                 jobs.reset_flags_for(0, prev_total);\n                 jobs.clear_check_memory();\n                 cleanup.wait_all_finished();\n                 cleanup.reset();\n-                TEST_log(0, [](std::ostringstream& o) { o << \"Resetting nAvail and fAllOk\\n\"; });\n-                nAvail.store(0);\n-                fAllOk.store(true);\n                 work.reset();\n             }\n         }"
      }
    ]
  },
  {
    "sha": "cc85c7ed7920803eff5f57d1357d3678646e61a7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjYzg1YzdlZDc5MjA4MDNlZmY1ZjU3ZDEzNTdkMzY3ODY0NmU2MWE3",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-29T00:49:08Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "remove boost::thread from test/test_bitcoin",
      "tree": {
        "sha": "1ca70f39a94361762b355aa28e5963172772e927",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1ca70f39a94361762b355aa28e5963172772e927"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cc85c7ed7920803eff5f57d1357d3678646e61a7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc85c7ed7920803eff5f57d1357d3678646e61a7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cc85c7ed7920803eff5f57d1357d3678646e61a7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc85c7ed7920803eff5f57d1357d3678646e61a7/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6a0582dd4f51aa7e38605afe5fe3c1b2efd4a8f1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6a0582dd4f51aa7e38605afe5fe3c1b2efd4a8f1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6a0582dd4f51aa7e38605afe5fe3c1b2efd4a8f1"
      }
    ],
    "stats": {
      "total": 27,
      "additions": 11,
      "deletions": 16
    },
    "files": [
      {
        "sha": "cf38f2a52c8b975e0638e98be5080b75406825ce",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cc85c7ed7920803eff5f57d1357d3678646e61a7/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cc85c7ed7920803eff5f57d1357d3678646e61a7/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=cc85c7ed7920803eff5f57d1357d3678646e61a7",
        "patch": "@@ -223,7 +223,7 @@ BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n     BOOST_CHECK(addrman.size() == 0);\n \n     for (unsigned int i = 1; i < 18; i++) {\n-        CService addr = ResolveService(\"250.1.1.\" + boost::to_string(i));\n+        CService addr = ResolveService(\"250.1.1.\" + std::to_string(i));\n         addrman.Add(CAddress(addr, NODE_NONE), source);\n \n         //Test 13: No collision in new table yet.\n@@ -252,7 +252,7 @@ BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n     BOOST_CHECK(addrman.size() == 0);\n \n     for (unsigned int i = 1; i < 80; i++) {\n-        CService addr = ResolveService(\"250.1.1.\" + boost::to_string(i));\n+        CService addr = ResolveService(\"250.1.1.\" + std::to_string(i));\n         addrman.Add(CAddress(addr, NODE_NONE), source);\n         addrman.Good(CAddress(addr, NODE_NONE));\n \n@@ -402,7 +402,7 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n         int octet1 = i % 256;\n         int octet2 = (i / 256) % 256;\n         int octet3 = (i / (256 * 2)) % 256;\n-        string strAddr = boost::to_string(octet1) + \".\" + boost::to_string(octet2) + \".\" + boost::to_string(octet3) + \".23\";\n+        string strAddr = std::to_string(octet1) + \".\" + std::to_string(octet2) + \".\" + std::to_string(octet3) + \".23\";\n         CAddress addr = CAddress(ResolveService(strAddr), NODE_NONE);\n         \n         // Ensure that for all addrs in addrman, isTerrible == false.\n@@ -456,8 +456,8 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n     set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n         CAddrInfo infoi = CAddrInfo(\n-            CAddress(ResolveService(\"250.1.1.\" + boost::to_string(i)), NODE_NONE),\n-            ResolveIP(\"250.1.1.\" + boost::to_string(i)));\n+            CAddress(ResolveService(\"250.1.1.\" + std::to_string(i)), NODE_NONE),\n+            ResolveIP(\"250.1.1.\" + std::to_string(i)));\n         int bucket = infoi.GetTriedBucket(nKey1);\n         buckets.insert(bucket);\n     }\n@@ -468,8 +468,8 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n     buckets.clear();\n     for (int j = 0; j < 255; j++) {\n         CAddrInfo infoj = CAddrInfo(\n-            CAddress(ResolveService(\"250.\" + boost::to_string(j) + \".1.1\"), NODE_NONE),\n-            ResolveIP(\"250.\" + boost::to_string(j) + \".1.1\"));\n+            CAddress(ResolveService(\"250.\" + std::to_string(j) + \".1.1\"), NODE_NONE),\n+            ResolveIP(\"250.\" + std::to_string(j) + \".1.1\"));\n         int bucket = infoj.GetTriedBucket(nKey1);\n         buckets.insert(bucket);\n     }\n@@ -509,8 +509,8 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n         CAddrInfo infoi = CAddrInfo(\n-            CAddress(ResolveService(\"250.1.1.\" + boost::to_string(i)), NODE_NONE),\n-            ResolveIP(\"250.1.1.\" + boost::to_string(i)));\n+            CAddress(ResolveService(\"250.1.1.\" + std::to_string(i)), NODE_NONE),\n+            ResolveIP(\"250.1.1.\" + std::to_string(i)));\n         int bucket = infoi.GetNewBucket(nKey1);\n         buckets.insert(bucket);\n     }\n@@ -522,7 +522,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     for (int j = 0; j < 4 * 255; j++) {\n         CAddrInfo infoj = CAddrInfo(CAddress(\n                                         ResolveService(\n-                                            boost::to_string(250 + (j / 255)) + \".\" + boost::to_string(j % 256) + \".1.1\"), NODE_NONE),\n+                                            std::to_string(250 + (j / 255)) + \".\" + std::to_string(j % 256) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"251.4.1.1\"));\n         int bucket = infoj.GetNewBucket(nKey1);\n         buckets.insert(bucket);\n@@ -535,7 +535,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     for (int p = 0; p < 255; p++) {\n         CAddrInfo infoj = CAddrInfo(\n             CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE),\n-            ResolveIP(\"250.\" + boost::to_string(p) + \".1.1\"));\n+            ResolveIP(\"250.\" + std::to_string(p) + \".1.1\"));\n         int bucket = infoj.GetNewBucket(nKey1);\n         buckets.insert(bucket);\n     }"
      },
      {
        "sha": "142268472eaa15ee956fc191c9758d2816b7443b",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cc85c7ed7920803eff5f57d1357d3678646e61a7/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cc85c7ed7920803eff5f57d1357d3678646e61a7/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=cc85c7ed7920803eff5f57d1357d3678646e61a7",
        "patch": "@@ -24,7 +24,6 @@\n \n #include <boost/filesystem.hpp>\n #include <boost/test/unit_test.hpp>\n-#include <boost/thread.hpp>\n \n extern bool fPrintToConsole;\n extern void noui_connect();\n@@ -73,8 +72,6 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n TestingSetup::~TestingSetup()\n {\n         UnregisterNodeSignals(GetNodeSignals());\n-        threadGroup.interrupt_all();\n-        threadGroup.join_all();\n         StopCCheckQueue();\n         UnloadBlockIndex();\n         delete pcoinsTip;"
      },
      {
        "sha": "f8c890d874e190f7fe07e8a194295e70d9f9f128",
        "filename": "src/test/test_bitcoin.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cc85c7ed7920803eff5f57d1357d3678646e61a7/src/test/test_bitcoin.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cc85c7ed7920803eff5f57d1357d3678646e61a7/src/test/test_bitcoin.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.h?ref=cc85c7ed7920803eff5f57d1357d3678646e61a7",
        "patch": "@@ -12,7 +12,6 @@\n #include \"txmempool.h\"\n \n #include <boost/filesystem.hpp>\n-#include <boost/thread.hpp>\n \n /** Basic testing setup.\n  * This just configures logging and chain parameters.\n@@ -30,7 +29,6 @@ struct BasicTestingSetup {\n struct TestingSetup: public BasicTestingSetup {\n     CCoinsViewDB *pcoinsdbview;\n     boost::filesystem::path pathTemp;\n-    boost::thread_group threadGroup;\n \n     TestingSetup(const std::string& chainName = CBaseChainParams::MAIN);\n     ~TestingSetup();"
      }
    ]
  },
  {
    "sha": "50c0ac835fb65a0356987334b2c6306378528b91",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1MGMwYWM4MzVmYjY1YTAzNTY5ODczMzRiMmM2MzA2Mzc4NTI4Yjkx",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-29T01:44:50Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "Ensure that at least 2 cores are used for benchmarking",
      "tree": {
        "sha": "eb730b4567f2244199a60c6b0edae7508b61252a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/eb730b4567f2244199a60c6b0edae7508b61252a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/50c0ac835fb65a0356987334b2c6306378528b91",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/50c0ac835fb65a0356987334b2c6306378528b91",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/50c0ac835fb65a0356987334b2c6306378528b91",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/50c0ac835fb65a0356987334b2c6306378528b91/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cc85c7ed7920803eff5f57d1357d3678646e61a7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc85c7ed7920803eff5f57d1357d3678646e61a7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cc85c7ed7920803eff5f57d1357d3678646e61a7"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "00328fedd1b7dfd7570f4301f41b18c03c1f3c9f",
        "filename": "src/bench/checkqueue.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/50c0ac835fb65a0356987334b2c6306378528b91/src/bench/checkqueue.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/50c0ac835fb65a0356987334b2c6306378528b91/src/bench/checkqueue.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkqueue.cpp?ref=50c0ac835fb65a0356987334b2c6306378528b91",
        "patch": "@@ -19,7 +19,7 @@ static void CCheckQueueSpeed(benchmark::State& state)\n     };\n     typedef CCheckQueue<FakeJobNoWork, (size_t)100000, MAX_SCRIPTCHECK_THREADS> T;\n     auto fast_queue = std::unique_ptr<T>(new T());\n-    fast_queue->init(GetNumCores());\n+    fast_queue->init(std::max(2, GetNumCores()));\n     while (state.KeepRunning()) {\n         size_t total = 0;\n         {"
      }
    ]
  },
  {
    "sha": "af2bd76294374aa4004983a67c245fa60c8e5740",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphZjJiZDc2Mjk0Mzc0YWE0MDA0OTgzYTY3YzI0NWZhNjBjOGU1NzQw",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-29T01:53:26Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "add benchmarking to travis",
      "tree": {
        "sha": "b865320cf75436463aefe033f48f983d6b637ab3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b865320cf75436463aefe033f48f983d6b637ab3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/af2bd76294374aa4004983a67c245fa60c8e5740",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af2bd76294374aa4004983a67c245fa60c8e5740",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/af2bd76294374aa4004983a67c245fa60c8e5740",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af2bd76294374aa4004983a67c245fa60c8e5740/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "50c0ac835fb65a0356987334b2c6306378528b91",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/50c0ac835fb65a0356987334b2c6306378528b91",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/50c0ac835fb65a0356987334b2c6306378528b91"
      }
    ],
    "stats": {
      "total": 12,
      "additions": 7,
      "deletions": 5
    },
    "files": [
      {
        "sha": "c94d4d0bfaeca4c64583768d16068a9bb8f45006",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 7,
        "deletions": 5,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/af2bd76294374aa4004983a67c245fa60c8e5740/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/af2bd76294374aa4004983a67c245fa60c8e5740/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=af2bd76294374aa4004983a67c245fa60c8e5740",
        "patch": "@@ -10,6 +10,7 @@ cache:\n env:\n   global:\n     - MAKEJOBS=-j3\n+    - RUN_BENCH=false\n     - RUN_TESTS=false\n     - CHECK_DOC=0\n     - BOOST_TEST_RANDOM=1$TRAVIS_BUILD_ID\n@@ -24,15 +25,15 @@ env:\n # ARM\n     - HOST=arm-linux-gnueabihf PACKAGES=\"g++-arm-linux-gnueabihf\" DEP_OPTS=\"NO_QT=1\" CHECK_DOC=1 GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports\"\n # Win32\n-    - HOST=i686-w64-mingw32 DPKG_ADD_ARCH=\"i386\" DEP_OPTS=\"NO_QT=1\" PACKAGES=\"python3 nsis g++-mingw-w64-i686 wine1.6 bc gdb\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-reduce-exports\"\n+    - HOST=i686-w64-mingw32 DPKG_ADD_ARCH=\"i386\" DEP_OPTS=\"NO_QT=1\" PACKAGES=\"python3 nsis g++-mingw-w64-i686 wine1.6 bc gdb\" RUN_BENCH=true RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-reduce-exports\"\n # 32-bit + dash\n-    - HOST=i686-pc-linux-gnu PACKAGES=\"g++-multilib bc python3-zmq gdb\" DEP_OPTS=\"NO_QT=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --enable-glibc-back-compat --enable-reduce-exports LDFLAGS=-static-libstdc++\" USE_SHELL=\"/bin/dash\"\n+    - HOST=i686-pc-linux-gnu PACKAGES=\"g++-multilib bc python3-zmq gdb\" DEP_OPTS=\"NO_QT=1\" RUN_BENCH=true RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --enable-glibc-back-compat --enable-reduce-exports LDFLAGS=-static-libstdc++\" USE_SHELL=\"/bin/dash\"\n # Win64\n-    - HOST=x86_64-w64-mingw32 DPKG_ADD_ARCH=\"i386\" DEP_OPTS=\"NO_QT=1\" PACKAGES=\"python3 nsis g++-mingw-w64-x86-64 wine1.6 bc gdb\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-reduce-exports\"\n+    - HOST=x86_64-w64-mingw32 DPKG_ADD_ARCH=\"i386\" DEP_OPTS=\"NO_QT=1\" PACKAGES=\"python3 nsis g++-mingw-w64-x86-64 wine1.6 bc gdb\" RUN_BENCH=true RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-reduce-exports\"\n # bitcoind\n-    - HOST=x86_64-unknown-linux-gnu PACKAGES=\"bc python3-zmq gdb\" DEP_OPTS=\"NO_QT=1 NO_UPNP=1 DEBUG=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --enable-glibc-back-compat --enable-reduce-exports CPPFLAGS=-DDEBUG_LOCKORDER\"\n+    - HOST=x86_64-unknown-linux-gnu PACKAGES=\"bc python3-zmq gdb\" DEP_OPTS=\"NO_QT=1 NO_UPNP=1 DEBUG=1\" RUN_BENCH=true RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --enable-glibc-back-compat --enable-reduce-exports CPPFLAGS=-DDEBUG_LOCKORDER\"\n # No wallet\n-    - HOST=x86_64-unknown-linux-gnu PACKAGES=\"python3 gdb\" DEP_OPTS=\"NO_WALLET=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports\"\n+    - HOST=x86_64-unknown-linux-gnu PACKAGES=\"python3 gdb\" DEP_OPTS=\"NO_WALLET=1\" RUN_BENCH=true RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports\"\n # Cross-Mac\n     - HOST=x86_64-apple-darwin11 PACKAGES=\"cmake imagemagick libcap-dev librsvg2-bin libz-dev libbz2-dev libtiff-tools python-dev\" BITCOIN_CONFIG=\"--enable-reduce-exports\" OSX_SDK=10.11 GOAL=\"deploy\"\n \n@@ -62,6 +63,7 @@ script:\n     - ../configure $BITCOIN_CONFIG_ALL $BITCOIN_CONFIG || ( cat config.log && false)\n     - make $MAKEJOBS $GOAL || ( echo \"Build failure. Verbose build follows.\" && make $GOAL V=1 ; false )\n     - export LD_LIBRARY_PATH=$TRAVIS_BUILD_DIR/depends/$HOST/lib\n+    - if [ \"$RUN_BENCH\" = \"true\" ]; then (cd src && make $MAKEJOBS bench); fi\n     - if [ \"$RUN_TESTS\" = \"true\" ]; then make $MAKEJOBS check VERBOSE=1; fi\n     - if [ \"$RUN_TESTS\" = \"true\" ]; then qa/pull-tester/rpc-tests.py --coverage; fi\n after_script:"
      }
    ]
  },
  {
    "sha": "2acb1ec81c06eeb75ecec5e07dc1a766c6d60216",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyYWNiMWVjODFjMDZlZWI3NWVjZWM1ZTA3ZGMxYTc2NmM2ZDYwMjE2",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-29T06:47:39Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:46Z"
      },
      "message": "Got rid of manual placement new in favor of using vector emplace_back.",
      "tree": {
        "sha": "0ffea642753013b387a387a763d1a32601a1f735",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0ffea642753013b387a387a763d1a32601a1f735"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2acb1ec81c06eeb75ecec5e07dc1a766c6d60216",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2acb1ec81c06eeb75ecec5e07dc1a766c6d60216",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2acb1ec81c06eeb75ecec5e07dc1a766c6d60216",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2acb1ec81c06eeb75ecec5e07dc1a766c6d60216/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "af2bd76294374aa4004983a67c245fa60c8e5740",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af2bd76294374aa4004983a67c245fa60c8e5740",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/af2bd76294374aa4004983a67c245fa60c8e5740"
      }
    ],
    "stats": {
      "total": 306,
      "additions": 136,
      "deletions": 170
    },
    "files": [
      {
        "sha": "cfd65b895b513a5c429cf86e1d3a852e240fd63d",
        "filename": "src/bench/checkqueue.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2acb1ec81c06eeb75ecec5e07dc1a766c6d60216/src/bench/checkqueue.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2acb1ec81c06eeb75ecec5e07dc1a766c6d60216/src/bench/checkqueue.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkqueue.cpp?ref=2acb1ec81c06eeb75ecec5e07dc1a766c6d60216",
        "patch": "@@ -17,19 +17,19 @@ static void CCheckQueueSpeed(benchmark::State& state)\n         }\n         void swap(FakeJobNoWork& x){};\n     };\n-    typedef CCheckQueue<FakeJobNoWork, (size_t)100000, MAX_SCRIPTCHECK_THREADS> T;\n+    typedef CCheckQueue<FakeJobNoWork> T;\n     auto fast_queue = std::unique_ptr<T>(new T());\n-    fast_queue->init(std::max(2, GetNumCores()));\n+    fast_queue->init(100000, std::max(2, GetNumCores()));\n     while (state.KeepRunning()) {\n         size_t total = 0;\n         {\n             CCheckQueueControl<T> control(fast_queue.get());\n             for (size_t j = 0; j < 101; ++j) {\n                 size_t r = 30;\n                 total += r;\n-                auto inserter = control.get_inserter();\n                 for (size_t k = 0; k < r; ++k)\n-                    new (inserter()) FakeJobNoWork{};\n+                    control.emplace_back(FakeJobNoWork{});\n+                control.Flush();\n             }\n         }\n     }"
      },
      {
        "sha": "8ffb0a7a0f4a771b16d6bf4713c26b1fe836ee54",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 78,
        "deletions": 116,
        "changes": 194,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2acb1ec81c06eeb75ecec5e07dc1a766c6d60216/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2acb1ec81c06eeb75ecec5e07dc1a766c6d60216/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=2acb1ec81c06eeb75ecec5e07dc1a766c6d60216",
        "patch": "@@ -28,7 +28,7 @@\n \n \n /** Forward Declaration on CCheckQueue. Note default no testing. */\n-template <typename T, size_t J, size_t W, bool TFE = false, bool TLE = false>\n+template <typename T, bool TFE = false, bool TLE = false>\n class CCheckQueue;\n /** Forward Declaration on CCheckQueueControl */\n template <typename Q>\n@@ -39,67 +39,43 @@ class CCheckQueueControl;\n  * of CCheckQueue, but is separate for easier testability and modularity */\n namespace CCheckQueue_Internals\n {\n-template <typename Q>\n-class inserter {\n-    Q * const queue;\n-    typename Q::JOB_TYPE * start;\n-    typename Q::JOB_TYPE * free_index;\n-    public:\n-    inserter(Q * const queueIn) :\n-       queue(queueIn),\n-       start(queue ? queue->get_next_free_index() : nullptr),\n-       free_index(start) {}\n-    typename Q::JOB_TYPE * operator()(typename Q::JOB_TYPE * def)\n-    {\n-        return free_index ? free_index++ : def;\n-    }\n-    typename Q::JOB_TYPE * operator()()\n-    {\n-        return free_index++;\n-    }\n-    ~inserter()\n-    {\n-        if (queue)\n-            queue->Flush(std::distance(start, free_index));\n-    }\n-};\n /** job_array holds the atomic flags and the job data for the queue\n      * and provides methods to assist in accessing or adding jobs.\n      */\n-template <typename Q>\n+template <typename T>\n class job_array\n {\n     /** the raw check type */\n-    std::array<typename Q::JOB_TYPE, Q::MAX_JOBS> checks;\n+    std::vector<T> checks;\n     /** atomic flags which are used to reserve a check from checks\n              * C++11 standard guarantees that these are atomic on all platforms\n              * */\n-    std::array<std::atomic_flag, Q::MAX_JOBS> flags;\n-    /** used as the insertion point into the array. */\n-    typename Q::JOB_TYPE* next_free_index;\n+    struct default_cleared_flag : std::atomic_flag {\n+        default_cleared_flag () : std::atomic_flag() { clear(); };\n+        default_cleared_flag (const default_cleared_flag & s) : std::atomic_flag() { clear(); };\n+    };\n+    std::vector<default_cleared_flag> flags;\n     size_t RT_N_SCRIPTCHECK_THREADS;\n \n public:\n-    job_array() :  next_free_index(checks.begin()), RT_N_SCRIPTCHECK_THREADS(0)\n+    job_array() :  RT_N_SCRIPTCHECK_THREADS(0)\n     {\n-        for (size_t i = 0; i < Q::MAX_JOBS; ++i) \n-            checks[i] = typename Q::JOB_TYPE {};\n-        for (auto& i : flags)\n-            i.clear();\n     }\n \n-    void init(const size_t rt)\n+    void init(const size_t MAX_JOBS, const size_t rt)\n     {\n         RT_N_SCRIPTCHECK_THREADS = rt;\n+        checks.reserve(MAX_JOBS);\n+        flags.resize(MAX_JOBS);\n     }\n-\n-    typename Q::JOB_TYPE* get_next_free_index()\n+    void emplace_back(T&& t)\n     {\n-        return next_free_index;\n+        checks.emplace_back(std::move(t));\n     }\n-    void Add(ptrdiff_t n) \n+\n+    size_t size()\n     {\n-        next_free_index += n;\n+        return checks.size();\n     }\n     \n     /** reserve tries to set a flag for an element \n@@ -109,50 +85,25 @@ class job_array\n         return !flags[i].test_and_set();\n     }\n \n-    /** reset_flag resets a flag */\n-    void reset_flag(const size_t i)\n-    {\n-        flags[i].clear();\n-    }\n-\n     void reset_flags_for(const size_t ID, const size_t to) \n     {\n         for (size_t i = ID; i < to; i += RT_N_SCRIPTCHECK_THREADS)\n-            reset_flag(i);\n+            flags[i].clear();\n     }\n     /** eval runs a check at specified index */\n     bool eval(const size_t i)\n     {\n-        bool b = checks[i]();\n-        typename Q::JOB_TYPE tmp {};\n-        checks[i].swap(tmp);\n-        return b;\n+        return checks[i]();\n     }\n \n-    /** reset_jobs resets the insertion index only, so should only be run on master.\n-             *\n-             * The caller must ensure that forall i, checks[i] is destructed and flags[i] is\n-             * reset.\n-             *\n-             * NOTE: This cleanup done \"for free\" elsewhere\n-             *      - checksi] is destructed by master on swap\n-             *      - flags[i] is reset by each thread while waiting to be cleared for duty\n-             */\n-    void reset_jobs()\n-    {\n-        next_free_index = checks.begin();\n-    }\n     void clear_check_memory()\n     {\n-        for (auto it = checks.begin(); it != next_free_index; ++it) {\n-            typename Q::JOB_TYPE tmp {};\n-            it->swap(tmp);\n-        }\n+        checks.clear();\n     }\n \n     decltype(&checks) TEST_get_checks()\n     {\n-        return Q::TEST_FUNCTIONS_ENABLE ? &checks : nullptr;\n+        return  &checks;\n     }\n };\n /* barrier is used to communicate that a thread has finished\n@@ -162,10 +113,8 @@ class job_array\n      * will not mark itself un-done so no need to read the atomic twice)\n      */\n \n-template <typename Q>\n class barrier\n {\n-    std::array<std::atomic_bool, Q::MAX_WORKERS> state;\n     size_t RT_N_SCRIPTCHECK_THREADS;\n     std::atomic<size_t> count;\n \n@@ -221,10 +170,9 @@ class barrier\n      *       (check for more work when priority_empty)\n      *\n      */\n-template <typename Q>\n class PriorityWorkQueue\n {\n-    std::array<size_t, Q::MAX_WORKERS> n_done;\n+    std::vector<size_t> n_done;\n     /** The Worker's ID */\n     const size_t id;\n     /** The number of workers that bitcoind started with, eg, RunTime Number ScriptCheck Threads  */\n@@ -237,8 +185,15 @@ class PriorityWorkQueue\n \n \n public:\n-    PriorityWorkQueue(){};\n-    PriorityWorkQueue(size_t id_, size_t RT_N_SCRIPTCHECK_THREADS_) : n_done(), id(id_), RT_N_SCRIPTCHECK_THREADS(RT_N_SCRIPTCHECK_THREADS_), total(0), id2_cache((id_ + 1) % RT_N_SCRIPTCHECK_THREADS){};\n+    PriorityWorkQueue(size_t id_, size_t RT_N_SCRIPTCHECK_THREADS_) : n_done(), id(id_), RT_N_SCRIPTCHECK_THREADS(RT_N_SCRIPTCHECK_THREADS_), total(0), id2_cache((id_ + 1) % RT_N_SCRIPTCHECK_THREADS){\n+        n_done.resize(RT_N_SCRIPTCHECK_THREADS);\n+    };\n+    void reset() {\n+        for (auto& i : n_done)\n+            i = 0;\n+        total = 0;\n+        id2_cache = (id +1) % RT_N_SCRIPTCHECK_THREADS;\n+    }\n     /** adds entries for execution [total, n)\n              * Places entries in the proper bucket\n              * Resets the next thread to help (id2_cache) if work was added\n@@ -333,23 +288,22 @@ class atomic_condition {\n  * @tparam W the maximum number of workers possible\n  */\n \n-template <typename T, size_t J, size_t W, bool TFE, bool TLE>\n+template <typename T, bool TFE, bool TLE>\n class CCheckQueue\n {\n public:\n     typedef T JOB_TYPE;\n-    typedef CCheckQueue<T, J, W, TFE, TLE> SELF;\n-    static const size_t MAX_JOBS = J;\n-    static const size_t MAX_WORKERS = W;\n+    typedef CCheckQueue<T, TFE, TLE> SELF;\n     static const bool TEST_FUNCTIONS_ENABLE = TFE;\n     static const bool TEST_LOGGING_ENABLE = TLE;\n \n private:\n-    CCheckQueue_Internals::job_array<SELF> jobs;\n-    CCheckQueue_Internals::barrier<SELF> work;\n-    CCheckQueue_Internals::barrier<SELF> cleanup;\n+    CCheckQueue_Internals::job_array<JOB_TYPE> jobs;\n+    CCheckQueue_Internals::barrier work;\n+    CCheckQueue_Internals::barrier cleanup;\n     CCheckQueue_Internals::atomic_condition sleeper;\n     size_t RT_N_SCRIPTCHECK_THREADS;\n+    size_t MAX_JOBS;\n     /** The number of checks put into the queue, done or not */\n     std::atomic<size_t> nAvail;\n     /** true if all checks were successful, false if any failure occurs */\n@@ -362,12 +316,10 @@ class CCheckQueue\n     std::mutex control_mtx;\n     /** state only for testing */\n     mutable std::atomic<size_t> test_log_seq;\n-    mutable std::array<std::ostringstream, MAX_WORKERS> test_log;\n+    mutable std::vector<std::unique_ptr<std::ostringstream>> test_log;\n \n-    void consume(const size_t ID)\n+    void consume(CCheckQueue_Internals::PriorityWorkQueue& work_queue)\n     {\n-        TEST_log(ID, [](std::ostringstream& o) {o << \"In consume\\n\";});\n-        CCheckQueue_Internals::PriorityWorkQueue<SELF> work_queue(ID, RT_N_SCRIPTCHECK_THREADS);\n         for (;;) {\n             // Note: Must check masterJoined before nAvail, otherwise\n             // {Thread A: nAvail.load();} {Thread B:nAvail++; masterJoined = true;} {Thread A: masterJoined.load()}\n@@ -382,18 +334,17 @@ class CCheckQueue\n                 }\n             }\n             else if (stealing && !got_data)\n-                break;\n-\n+                return;\n         } \n-            \n-        TEST_log(ID, [&, this](std::ostringstream& o) {o << \"Leaving consume. fAllOk was \" << fAllOk.load() << \"\\n\";});\n     }\n     /** Internal function that does bulk of the verification work. */\n     bool Master() {\n         const size_t ID = 0;\n+        static CCheckQueue_Internals::PriorityWorkQueue work_queue(ID, RT_N_SCRIPTCHECK_THREADS);\n+        work_queue.reset();\n         masterJoined.store(true);\n         TEST_log(ID, [](std::ostringstream& o) { o << \"Master just set masterJoined\\n\"; });\n-        consume(ID);\n+        consume(work_queue);\n         work.finished();\n         work.wait_all_finished();\n         TEST_log(ID, [](std::ostringstream& o) { o << \"(Master) saw all threads finished\\n\"; });\n@@ -404,9 +355,11 @@ class CCheckQueue\n     }\n     void Loop(const size_t ID)\n     {\n+\n+        CCheckQueue_Internals::PriorityWorkQueue work_queue(ID, RT_N_SCRIPTCHECK_THREADS);\n         while (sleeper.wait()) {\n             TEST_log(ID, [](std::ostringstream& o) {o << \"Round starting\\n\";});\n-            consume(ID);\n+            consume(work_queue);\n             // Only spins here if !fAllOk, otherwise consume finished all\n             while (!masterJoined.load())\n                 ;\n@@ -433,6 +386,7 @@ class CCheckQueue\n                 cleanup.reset();\n                 work.reset();\n             }\n+            work_queue.reset();\n         }\n         LogPrintf(\"CCheckQueue @%#010x Worker %q shutting down\\n\", this, ID);\n     }\n@@ -441,10 +395,6 @@ class CCheckQueue\n     CCheckQueue() : jobs(), work(), cleanup(), sleeper(), RT_N_SCRIPTCHECK_THREADS(0),\n     nAvail(0), fAllOk(true), masterJoined(false), test_log_seq(0) {}\n \n-    void reset_jobs()\n-    {\n-        jobs.reset_jobs();\n-    }\n     //! Worker thread\n     void Thread(size_t ID)\n     {\n@@ -455,7 +405,6 @@ class CCheckQueue\n \n     void ControlLock() {\n         control_mtx.lock();\n-        reset_jobs();\n         sleeper.wakeup();\n         work.wait_reset();\n     }\n@@ -478,13 +427,13 @@ class CCheckQueue\n         jobs.clear_check_memory();\n     }\n \n-    JOB_TYPE* get_next_free_index() {\n-        return jobs.get_next_free_index();\n+    void emplace_back(JOB_TYPE&& t) {\n+        jobs.emplace_back(std::move(t));\n     }\n-    void Flush(std::ptrdiff_t n)\n+    void Flush()\n     {\n-        nAvail.fetch_add(n);\n-        jobs.Add(n);\n+        const size_t n = jobs.size();\n+        nAvail.store(n);\n         TEST_log(0, [&, this](std::ostringstream& o) {\n             o << \"Added \" << n << \" values. nAvail was \" \n             << nAvail.load() - n << \" now is \" << nAvail.load() << \" \\n\";\n@@ -495,13 +444,16 @@ class CCheckQueue\n         quit();\n     }\n \n-    void init(const size_t RT_N_SCRIPTCHECK_THREADS_)\n+    void init(const size_t MAX_JOBS_, const size_t RT_N_SCRIPTCHECK_THREADS_)\n     {\n         std::lock_guard<std::mutex> l(control_mtx);\n+        MAX_JOBS = MAX_JOBS_;\n         RT_N_SCRIPTCHECK_THREADS = RT_N_SCRIPTCHECK_THREADS_;\n+        for (auto i = 0; i < RT_N_SCRIPTCHECK_THREADS && TEST_LOGGING_ENABLE; ++i)\n+            test_log.push_back(std::unique_ptr<std::ostringstream>(new std::ostringstream()));\n         work.init(RT_N_SCRIPTCHECK_THREADS);\n         cleanup.init(RT_N_SCRIPTCHECK_THREADS-1);\n-        jobs.init(RT_N_SCRIPTCHECK_THREADS);\n+        jobs.init(MAX_JOBS, RT_N_SCRIPTCHECK_THREADS);\n         sleeper.resurrect();\n         for (size_t id = 1; id < RT_N_SCRIPTCHECK_THREADS; ++id) {\n             std::thread t([=]() {Thread(id); });\n@@ -513,8 +465,9 @@ class CCheckQueue\n \n     void TEST_consume(const size_t ID)\n     {\n+        static CCheckQueue_Internals::PriorityWorkQueue work_queue(ID, RT_N_SCRIPTCHECK_THREADS);\n         if (TEST_FUNCTIONS_ENABLE)\n-            consume(ID);\n+            consume(work_queue);\n     }\n \n     void TEST_set_masterJoined(const bool b)\n@@ -541,29 +494,30 @@ class CCheckQueue\n     void TEST_log(const size_t ID, Callable c) const\n     {\n         if (TEST_LOGGING_ENABLE) {\n-            test_log[ID] << \"[[\" << test_log_seq++ <<\"]] \";\n-            c(test_log[ID]);\n+            *test_log[ID] << \"[[\" << test_log_seq++ <<\"]] \";\n+            c(*test_log[ID]);\n         }\n     }\n \n     void TEST_dump_log() const\n     {\n         if (TEST_FUNCTIONS_ENABLE) {\n             LogPrintf(\"\\n#####################\\n## Round Beginning ##\\n#####################\");\n-            for (auto i = 0; i < RT_N_SCRIPTCHECK_THREADS; ++i)\n-                LogPrintf(\"\\n------------------\\n%s\\n------------------\\n\\n\", test_log[i].str());\n+            for (auto& i : test_log)\n+                LogPrintf(\"\\n------------------\\n%s\\n------------------\\n\\n\", i->str());\n         }\n     }\n \n     void TEST_erase_log() const\n     {\n-        for (auto i = 0; i < MAX_WORKERS && TEST_FUNCTIONS_ENABLE; ++i) {\n-            test_log[i].str(\"\");\n-            test_log[i].clear();\n+        if (TEST_FUNCTIONS_ENABLE)\n+        for (auto& i : test_log) {\n+            i->str(\"\");\n+            i->clear();\n         }\n     }\n \n-    CCheckQueue_Internals::job_array<SELF>* TEST_introspect_jobs()\n+    CCheckQueue_Internals::job_array<JOB_TYPE>* TEST_introspect_jobs()\n     {\n         return TEST_FUNCTIONS_ENABLE ? &jobs : nullptr;\n     }\n@@ -597,8 +551,16 @@ class CCheckQueueControl\n         return fRet;\n     }\n \n-    CCheckQueue_Internals::inserter<Q> get_inserter() {\n-        return CCheckQueue_Internals::inserter<Q>(pqueue);\n+    bool emplace_back(typename Q::JOB_TYPE && j)\n+    {\n+        if (pqueue)\n+            pqueue->emplace_back(std::move(j));\n+        return !!pqueue;\n+    }\n+    void Flush()\n+    {\n+        if (pqueue)\n+            pqueue->Flush();\n     }\n \n     ~CCheckQueueControl()"
      },
      {
        "sha": "aecb463644eac0f8caaa777f72a7f0311a8d41a9",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 7,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2acb1ec81c06eeb75ecec5e07dc1a766c6d60216/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2acb1ec81c06eeb75ecec5e07dc1a766c6d60216/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=2acb1ec81c06eeb75ecec5e07dc1a766c6d60216",
        "patch": "@@ -1969,7 +1969,7 @@ bool CheckTxInputs(const CTransaction& tx, CValidationState& state, const CCoins\n }\n }// namespace Consensus\n \n-bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheStore, std::function<CScriptCheck * (CScriptCheck *)> inserter)\n+bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheStore, std::function<bool (CScriptCheck &&)> emplacer)\n {\n     if (!tx.IsCoinBase())\n     {\n@@ -1994,10 +1994,10 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                 assert(coins);\n \n                 // Verify signature\n-                CScriptCheck check;\n-                CScriptCheck * const ptr = inserter(&check);\n-                new (ptr) CScriptCheck(*coins, tx, i, flags, cacheStore);\n-                if (ptr == &check && !check()) {\n+                if (emplacer && emplacer(CScriptCheck(*coins, tx, i, flags, cacheStore)))\n+                    continue;\n+                CScriptCheck check = CScriptCheck(*coins, tx, i, flags, cacheStore);\n+                if (!check()) {\n                     if (flags & STANDARD_NOT_MANDATORY_VERIFY_FLAGS) {\n                         // Check whether the failure was caused by a\n                         // non-mandatory script verification check, such as\n@@ -2235,7 +2235,7 @@ void StopCCheckQueue() {\n     scriptcheckqueue.quit();\n };\n void SetupCCheckQueue(size_t RT_N_SCRIPTCHECK_THREADS) {\n-    scriptcheckqueue.init(RT_N_SCRIPTCHECK_THREADS);\n+    scriptcheckqueue.init(MAX_SCRIPTCHECKS, RT_N_SCRIPTCHECK_THREADS);\n };\n \n // Protected by cs_main\n@@ -2456,9 +2456,10 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n             nFees += view.GetValueIn(tx)-tx.GetValueOut();\n \n             bool fCacheResults = fJustCheck; /* Don't cache results if we're actually connecting blocks (still consult the cache, though) */\n-            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, control.get_inserter()))\n+            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, [&](CScriptCheck&& c){return control.emplace_back(std::move(c)); }))\n                 return error(\"ConnectBlock(): CheckInputs on %s failed with %s\",\n                     tx.GetHash().ToString(), FormatStateMessage(state));\n+            control.Flush();\n         }\n \n         CTxUndo undoDummy;"
      },
      {
        "sha": "ca7bf0a1da84e83ac09d48c0036e329a03286ec8",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2acb1ec81c06eeb75ecec5e07dc1a766c6d60216/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2acb1ec81c06eeb75ecec5e07dc1a766c6d60216/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=2acb1ec81c06eeb75ecec5e07dc1a766c6d60216",
        "patch": "@@ -349,7 +349,7 @@ int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& i\n  * instead of being performed inline.\n  */\n bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &view, bool fScriptChecks,\n-                 unsigned int flags, bool cacheStore, std::function<CScriptCheck * (CScriptCheck *) > inserter = [](CScriptCheck * d){return d;});\n+                 unsigned int flags, bool cacheStore, std::function<bool (CScriptCheck &&) > emplacer = nullptr);\n \n /** Apply the effects of this transaction on the UTXO set represented by view */\n void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, int nHeight);"
      },
      {
        "sha": "65fd302bb9a14e1e074d462e95cbd2e97f01824d",
        "filename": "src/test/checkqueue_tests.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 42,
        "changes": 87,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2acb1ec81c06eeb75ecec5e07dc1a766c6d60216/src/test/checkqueue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2acb1ec81c06eeb75ecec5e07dc1a766c6d60216/src/test/checkqueue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkqueue_tests.cpp?ref=2acb1ec81c06eeb75ecec5e07dc1a766c6d60216",
        "patch": "@@ -45,12 +45,12 @@ class RAII_ThreadGroup\n \n struct FakeJob {\n };\n-typedef CCheckQueue<FakeJob, (size_t)1000, MAX_SCRIPTCHECK_THREADS, true, false> Standard_Queue;\n+typedef CCheckQueue<FakeJob, true, false> Standard_Queue;\n typedef typename Standard_Queue::JOB_TYPE JT; // This is a \"recursive template\" hack\n \n BOOST_AUTO_TEST_CASE(test_CheckQueue_PriorityWorkQueue_basic)\n {\n-    CCheckQueue_Internals::PriorityWorkQueue<Standard_Queue> work(0, 16);\n+    CCheckQueue_Internals::PriorityWorkQueue work(0, 16);\n     auto m = 0;\n     work.add(100);\n     size_t x = 0;\n@@ -66,7 +66,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_PriorityWorkQueue_basic)\n }\n BOOST_AUTO_TEST_CASE(test_CheckQueue_PriorityWorkQueue_emits_all)\n {\n-    CCheckQueue_Internals::PriorityWorkQueue<Standard_Queue> work(0, 16);\n+    CCheckQueue_Internals::PriorityWorkQueue work(0, 16);\n     auto m = 0;\n     work.add(200);\n     std::unordered_multiset<size_t> results;\n@@ -86,7 +86,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_PriorityWorkQueue_emits_all)\n }\n BOOST_AUTO_TEST_CASE(test_CheckQueue_PriorityWorkQueue_stealing)\n {\n-    CCheckQueue_Internals::PriorityWorkQueue<Standard_Queue> work(0, 16);\n+    CCheckQueue_Internals::PriorityWorkQueue work(0, 16);\n     auto m = 0;\n     work.add(160);\n     std::unordered_multiset<size_t> results;\n@@ -114,35 +114,37 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_PriorityWorkQueue_stealing)\n     BOOST_REQUIRE(b2);\n }\n \n-typedef CCheckQueue_Internals::job_array<Standard_Queue> J;\n+typedef CCheckQueue_Internals::job_array<FakeJob> J;\n BOOST_AUTO_TEST_CASE(test_CheckQueue_job_array)\n {\n+    const size_t MAX_JOBS = 100000;\n     auto jobs = std::shared_ptr<J>(new J());\n+    jobs->init(MAX_JOBS, 1);\n     std::atomic<size_t> m;\n-    for (size_t i = 0; i < Standard_Queue::MAX_JOBS; ++i)\n-        jobs->reset_flag(i);\n+\n+    jobs->reset_flags_for(0, MAX_JOBS);\n+\n     m = 0;\n     std::thread t([&](std::atomic<size_t>& m) {\n-        for (size_t i = 0; i < Standard_Queue::MAX_JOBS; ++i)\n+        for (size_t i = 0; i < MAX_JOBS; ++i)\n             m += jobs->reserve(i) ? 1 : 0;\n     }, std::ref(m));\n \n \n     std::thread t2([&](std::atomic<size_t>& m) {\n-        for (size_t i = 0; i < Standard_Queue::MAX_JOBS; ++i)\n+        for (size_t i = 0; i < MAX_JOBS; ++i)\n             m += jobs->reserve(i) ? 1 : 0;\n     }, std::ref(m));\n     t.join();\n     t2.join();\n \n-    BOOST_REQUIRE(m == Standard_Queue::MAX_JOBS);\n+    BOOST_REQUIRE(m == MAX_JOBS);\n }\n \n-typedef CCheckQueue_Internals::barrier<Standard_Queue> B;\n BOOST_AUTO_TEST_CASE(test_CheckQueue_round_barrier)\n {\n     RAII_ThreadGroup threadGroup;\n-    auto b = std::shared_ptr<B>(new B());\n+    auto b = std::shared_ptr<CCheckQueue_Internals::barrier>(new CCheckQueue_Internals::barrier());\n     b->init(nScriptCheckThreads);\n     b->reset();\n \n@@ -162,11 +164,11 @@ struct FakeJobNoWork {\n     }\n     void swap(FakeJobNoWork& x){};\n };\n-typedef CCheckQueue<FakeJobNoWork, (size_t)100000, MAX_SCRIPTCHECK_THREADS, true, false> Consume_Queue;\n+typedef CCheckQueue<FakeJobNoWork, true, false> Consume_Queue;\n BOOST_AUTO_TEST_CASE(test_CheckQueue_consume)\n {\n     auto fast_queue = std::shared_ptr<Consume_Queue>(new Consume_Queue());\n-    fast_queue->init(nScriptCheckThreads);\n+    fast_queue->init(100000, nScriptCheckThreads);\n     std::atomic<int> spawned{0};\n     RAII_ThreadGroup threadGroup;\n \n@@ -179,9 +181,9 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_consume)\n \n     while (spawned != nScriptCheckThreads);\n     for (auto y = 0; y < 1000; ++y) {\n-        auto inserter = CCheckQueue_Internals::inserter<Consume_Queue>(fast_queue.get()); \n         for (auto x = 0; x< 100; ++x) \n-            new (inserter()) FakeJobNoWork{};\n+            fast_queue->emplace_back(FakeJobNoWork{});\n+        fast_queue->Flush();\n     }\n     fast_queue->TEST_set_masterJoined(true);\n \n@@ -203,23 +205,23 @@ struct FakeJobCheckCompletion {\n };\n std::atomic<size_t> FakeJobCheckCompletion::n_calls{0};\n const bool print_Correct_Queue = false;\n-typedef CCheckQueue<FakeJobCheckCompletion, (size_t)100000, MAX_SCRIPTCHECK_THREADS, true, print_Correct_Queue> Correct_Queue;\n+typedef CCheckQueue<FakeJobCheckCompletion,  true, print_Correct_Queue> Correct_Queue;\n void Correct_Queue_range(std::vector<size_t> range)\n {\n     auto small_queue = std::shared_ptr<Correct_Queue>(new Correct_Queue);\n-    small_queue->init(nScriptCheckThreads);\n+    small_queue->init(100000, nScriptCheckThreads);\n     for (auto i : range) {\n         size_t total = i;\n         FakeJobCheckCompletion::n_calls = 0;\n         {\n             CCheckQueueControl<Correct_Queue> control(small_queue.get());\n             while (total) {\n                 size_t r = GetRand(10);\n-                auto inserter = control.get_inserter();\n                 for (size_t k = 0; k < r && total; k++) {\n                     total--;\n-                    new (inserter()) FakeJobCheckCompletion{};\n+                    control.emplace_back(FakeJobCheckCompletion{});\n                 }\n+                control.Flush();\n             }\n         }\n         if (print_Correct_Queue) {\n@@ -274,28 +276,29 @@ struct FailingJob {\n         std::swap(call_state, x.call_state);\n     };\n };\n-typedef CCheckQueue<FailingJob, (size_t)1000, MAX_SCRIPTCHECK_THREADS, true, false> Failing_Queue;\n+typedef CCheckQueue<FailingJob, true, false> Failing_Queue;\n BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n {\n     auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue());\n \n-    fail_queue->init(nScriptCheckThreads);\n+    fail_queue->init(1000, nScriptCheckThreads);\n \n     for (size_t i = 0; i < 1001; ++i) {\n         CCheckQueueControl<Failing_Queue> control(fail_queue.get());\n         size_t remaining = i;\n         while (remaining) {\n             size_t r = GetRand(10);\n-            auto inserter = control.get_inserter();\n+\n             for (size_t k = 0; k < r && remaining; k++, remaining--)\n-                new (inserter()) FailingJob{remaining == 1};\n+                control.emplace_back( FailingJob{remaining == 1});\n+            control.Flush();\n         }\n         bool success = control.Wait();\n         if (success && i > 0) {\n             size_t nChecked = 0;\n-            auto jobs = fail_queue->TEST_introspect_jobs()->TEST_get_checks();\n-            for (size_t x = 0; x < i; ++x)\n-                if ((*jobs)[x].call_state)\n+            std::vector<FailingJob>* jobs = fail_queue->TEST_introspect_jobs()->TEST_get_checks();\n+            for (auto j : *jobs)\n+                if (j.call_state)\n                     nChecked++;\n             fail_queue->TEST_dump_log();\n             fail_queue->TEST_erase_log();\n@@ -311,16 +314,16 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n {\n     auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue());\n     std::array<FailingJob, 100> checks;\n-    fail_queue->init(nScriptCheckThreads);\n+    fail_queue->init(100, nScriptCheckThreads);\n \n     for (auto times = 0; times < 10; ++times) {\n         std::array<bool, 2> result;\n         for (bool end_fails : {true, false}) {\n             CCheckQueueControl<Failing_Queue> control(fail_queue.get());\n             {\n-                auto inserter = control.get_inserter();\n                 for (size_t k = 0; k < 100; ++k)\n-                    new (inserter()) FailingJob {k == 99 && end_fails};\n+                    control.emplace_back(FailingJob {k == 99 && end_fails});\n+                control.Flush();\n             }\n             result[end_fails ? 0 : 1] = control.Wait();\n             fail_queue->TEST_dump_log();\n@@ -347,21 +350,21 @@ struct UniqueJob {\n };\n std::mutex UniqueJob::m;\n std::unordered_multiset<size_t> UniqueJob::results;\n-typedef CCheckQueue<UniqueJob, (size_t)100000, MAX_SCRIPTCHECK_THREADS, true, false> Unique_Queue;\n+typedef CCheckQueue<UniqueJob,  true, false> Unique_Queue;\n BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueJob)\n {\n     auto queue = std::shared_ptr<Unique_Queue>(new Unique_Queue);\n-    queue->init(nScriptCheckThreads);\n+    queue->init(100000, nScriptCheckThreads);\n \n     size_t COUNT = 100000;\n     size_t total = COUNT;\n     {\n         CCheckQueueControl<Unique_Queue> control(queue.get());\n         while (total) {\n             size_t r = GetRand(10);\n-            auto inserter = control.get_inserter();\n             for (size_t k = 0; k < r && total; k++)\n-                new (inserter()) UniqueJob{--total};\n+                control.emplace_back( UniqueJob{--total});\n+            control.Flush();\n         }\n     }\n     bool r = true;\n@@ -386,23 +389,23 @@ struct MemoryJob {\n     };\n     void swap(MemoryJob& x) { mb_memory.swap(x.mb_memory); };\n };\n-typedef CCheckQueue<MemoryJob, (size_t)10000, MAX_SCRIPTCHECK_THREADS> Memory_Queue;\n+typedef CCheckQueue<MemoryJob> Memory_Queue;\n BOOST_AUTO_TEST_CASE(test_CheckQueue_Memory)\n {\n     auto queue = std::shared_ptr<Memory_Queue>(new Memory_Queue{});\n-    queue->init(nScriptCheckThreads);\n+    queue->init(10000, nScriptCheckThreads);\n \n     for (size_t i = 9999; i < 9999; --i) {\n         size_t total = i;\n         {\n             CCheckQueueControl<Memory_Queue> control(queue.get());\n             while (total) {\n                 size_t r = GetRand(10);\n-                auto inserter = control.get_inserter();\n                 for (size_t k = 0; k < r && total; k++) {\n                     total--;\n-                    new (inserter()) MemoryJob{total == 0};\n+                    control.emplace_back(MemoryJob{total == 0});\n                 }\n+                control.Flush();\n             }\n         }\n     }\n@@ -424,16 +427,16 @@ struct FrozenCleanupJob {\n };\n \n std::atomic<bool> FrozenCleanupJob::frozen {false};\n-typedef CCheckQueue<FrozenCleanupJob, (size_t)1000, MAX_SCRIPTCHECK_THREADS> FrozenCleanup_Queue;\n+typedef CCheckQueue<FrozenCleanupJob> FrozenCleanup_Queue;\n BOOST_AUTO_TEST_CASE(test_CheckQueue_FrozenCleanup)\n {\n     auto queue = std::shared_ptr<FrozenCleanup_Queue>(new FrozenCleanup_Queue{});\n-    queue->init(nScriptCheckThreads);\n+    queue->init(1000, nScriptCheckThreads);\n     std::thread t0([&](){\n         CCheckQueueControl<FrozenCleanup_Queue> control(queue.get());\n         {\n-            auto inserter = control.get_inserter();\n-            new (inserter()) FrozenCleanupJob{};\n+            control.emplace_back(FrozenCleanupJob{});\n+            control.Flush();\n         }\n         FrozenCleanupJob::frozen = true;\n         BOOST_REQUIRE(control.Wait());"
      }
    ]
  },
  {
    "sha": "05b14517f1eb9886224736227198d005100f1047",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNWIxNDUxN2YxZWI5ODg2MjI0NzM2MjI3MTk4ZDAwNTEwMGYxMDQ3",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-29T20:34:06Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:47Z"
      },
      "message": "Restore RAII style for emplacement",
      "tree": {
        "sha": "fe794a9c1f41eae1373ea58d892b0d6dd78187cb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fe794a9c1f41eae1373ea58d892b0d6dd78187cb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/05b14517f1eb9886224736227198d005100f1047",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/05b14517f1eb9886224736227198d005100f1047",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/05b14517f1eb9886224736227198d005100f1047",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/05b14517f1eb9886224736227198d005100f1047/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2acb1ec81c06eeb75ecec5e07dc1a766c6d60216",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2acb1ec81c06eeb75ecec5e07dc1a766c6d60216",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2acb1ec81c06eeb75ecec5e07dc1a766c6d60216"
      }
    ],
    "stats": {
      "total": 94,
      "additions": 52,
      "deletions": 42
    },
    "files": [
      {
        "sha": "f865d0b13ddba7694a7c776aea5d93f4dfc5b4f6",
        "filename": "src/bench/checkqueue.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/05b14517f1eb9886224736227198d005100f1047/src/bench/checkqueue.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/05b14517f1eb9886224736227198d005100f1047/src/bench/checkqueue.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkqueue.cpp?ref=05b14517f1eb9886224736227198d005100f1047",
        "patch": "@@ -27,9 +27,9 @@ static void CCheckQueueSpeed(benchmark::State& state)\n             for (size_t j = 0; j < 101; ++j) {\n                 size_t r = 30;\n                 total += r;\n+                auto emplacer = control.get_emplacer();\n                 for (size_t k = 0; k < r; ++k)\n-                    control.emplace_back(FakeJobNoWork{});\n-                control.Flush();\n+                    emplacer(FakeJobNoWork{});\n             }\n         }\n     }"
      },
      {
        "sha": "fcd8fb5456b5c55a83491916feeb64fe36f3cf1e",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 22,
        "deletions": 20,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/05b14517f1eb9886224736227198d005100f1047/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/05b14517f1eb9886224736227198d005100f1047/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=05b14517f1eb9886224736227198d005100f1047",
        "patch": "@@ -293,7 +293,6 @@ class CCheckQueue\n {\n public:\n     typedef T JOB_TYPE;\n-    typedef CCheckQueue<T, TFE, TLE> SELF;\n     static const bool TEST_FUNCTIONS_ENABLE = TFE;\n     static const bool TEST_LOGGING_ENABLE = TLE;\n \n@@ -427,17 +426,23 @@ class CCheckQueue\n         jobs.clear_check_memory();\n     }\n \n-    void emplace_back(JOB_TYPE&& t) {\n-        jobs.emplace_back(std::move(t));\n-    }\n-    void Flush()\n-    {\n-        const size_t n = jobs.size();\n-        nAvail.store(n);\n-        TEST_log(0, [&, this](std::ostringstream& o) {\n-            o << \"Added \" << n << \" values. nAvail was \" \n-            << nAvail.load() - n << \" now is \" << nAvail.load() << \" \\n\";\n-        });\n+\n+    struct emplacer {\n+        CCheckQueue_Internals::job_array<JOB_TYPE>& j;\n+        std::atomic<size_t>& nAvail;\n+        emplacer(CCheckQueue_Internals::job_array<JOB_TYPE>& j_, std::atomic<size_t>& nAvail_) : j(j_), nAvail(nAvail_) {}\n+        void operator()(JOB_TYPE && t)\n+        {\n+            j.emplace_back(std::move(t));\n+        }\n+        ~emplacer()\n+        {\n+            nAvail.store(j.size());\n+        }\n+\n+    };\n+    emplacer get_emplacer() {\n+        return emplacer(jobs, nAvail);\n     }\n     ~CCheckQueue()\n     {\n@@ -551,16 +556,13 @@ class CCheckQueueControl\n         return fRet;\n     }\n \n-    bool emplace_back(typename Q::JOB_TYPE && j)\n+    typename Q::emplacer get_emplacer()\n     {\n-        if (pqueue)\n-            pqueue->emplace_back(std::move(j));\n-        return !!pqueue;\n+        return pqueue->get_emplacer();\n     }\n-    void Flush()\n-    {\n-        if (pqueue)\n-            pqueue->Flush();\n+\n+    operator bool() {\n+        return (!!pqueue);\n     }\n \n     ~CCheckQueueControl()"
      },
      {
        "sha": "32787a14fa9efcf2725b40af2c8977c5b6dc0076",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 5,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/05b14517f1eb9886224736227198d005100f1047/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/05b14517f1eb9886224736227198d005100f1047/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=05b14517f1eb9886224736227198d005100f1047",
        "patch": "@@ -1969,7 +1969,7 @@ bool CheckTxInputs(const CTransaction& tx, CValidationState& state, const CCoins\n }\n }// namespace Consensus\n \n-bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheStore, std::function<bool (CScriptCheck &&)> emplacer)\n+bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheStore, std::function<void (CScriptCheck &&)> emplacer)\n {\n     if (!tx.IsCoinBase())\n     {\n@@ -1994,8 +1994,10 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                 assert(coins);\n \n                 // Verify signature\n-                if (emplacer && emplacer(CScriptCheck(*coins, tx, i, flags, cacheStore)))\n+                if (emplacer) {\n+                    emplacer(CScriptCheck(*coins, tx, i, flags, cacheStore));\n                     continue;\n+                }\n                 CScriptCheck check = CScriptCheck(*coins, tx, i, flags, cacheStore);\n                 if (!check()) {\n                     if (flags & STANDARD_NOT_MANDATORY_VERIFY_FLAGS) {\n@@ -2456,10 +2458,17 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n             nFees += view.GetValueIn(tx)-tx.GetValueOut();\n \n             bool fCacheResults = fJustCheck; /* Don't cache results if we're actually connecting blocks (still consult the cache, though) */\n-            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, [&](CScriptCheck&& c){return control.emplace_back(std::move(c)); }))\n+\n+            bool result = false;\n+            if (control) {\n+                // Must be this way to make sure destructor only gets called once.\n+                auto emplacer = control.get_emplacer();\n+                result = CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, std::ref(emplacer));\n+            } else\n+                result = CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults);\n+            if (!result)\n                 return error(\"ConnectBlock(): CheckInputs on %s failed with %s\",\n-                    tx.GetHash().ToString(), FormatStateMessage(state));\n-            control.Flush();\n+                        tx.GetHash().ToString(), FormatStateMessage(state));\n         }\n \n         CTxUndo undoDummy;"
      },
      {
        "sha": "49a5c96b00be0ad2ffff5e846ee837babd7cfbdd",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/05b14517f1eb9886224736227198d005100f1047/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/05b14517f1eb9886224736227198d005100f1047/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=05b14517f1eb9886224736227198d005100f1047",
        "patch": "@@ -349,7 +349,7 @@ int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& i\n  * instead of being performed inline.\n  */\n bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &view, bool fScriptChecks,\n-                 unsigned int flags, bool cacheStore, std::function<bool (CScriptCheck &&) > emplacer = nullptr);\n+                 unsigned int flags, bool cacheStore, std::function<void (CScriptCheck &&) > emplacer = nullptr);\n \n /** Apply the effects of this transaction on the UTXO set represented by view */\n void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, int nHeight);"
      },
      {
        "sha": "339f5ac7351243a39f6bb4580564fecb6d451986",
        "filename": "src/test/checkqueue_tests.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 14,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/05b14517f1eb9886224736227198d005100f1047/src/test/checkqueue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/05b14517f1eb9886224736227198d005100f1047/src/test/checkqueue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkqueue_tests.cpp?ref=05b14517f1eb9886224736227198d005100f1047",
        "patch": "@@ -181,9 +181,9 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_consume)\n \n     while (spawned != nScriptCheckThreads);\n     for (auto y = 0; y < 1000; ++y) {\n+        auto emplacer = fast_queue->get_emplacer();\n         for (auto x = 0; x< 100; ++x) \n-            fast_queue->emplace_back(FakeJobNoWork{});\n-        fast_queue->Flush();\n+            emplacer(FakeJobNoWork{});\n     }\n     fast_queue->TEST_set_masterJoined(true);\n \n@@ -217,11 +217,11 @@ void Correct_Queue_range(std::vector<size_t> range)\n             CCheckQueueControl<Correct_Queue> control(small_queue.get());\n             while (total) {\n                 size_t r = GetRand(10);\n+                auto emplacer = control.get_emplacer();\n                 for (size_t k = 0; k < r && total; k++) {\n                     total--;\n-                    control.emplace_back(FakeJobCheckCompletion{});\n+                    emplacer(FakeJobCheckCompletion{});\n                 }\n-                control.Flush();\n             }\n         }\n         if (print_Correct_Queue) {\n@@ -289,9 +289,9 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n         while (remaining) {\n             size_t r = GetRand(10);\n \n+            auto emplacer = control.get_emplacer();\n             for (size_t k = 0; k < r && remaining; k++, remaining--)\n-                control.emplace_back( FailingJob{remaining == 1});\n-            control.Flush();\n+                emplacer( FailingJob{remaining == 1});\n         }\n         bool success = control.Wait();\n         if (success && i > 0) {\n@@ -321,9 +321,9 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n         for (bool end_fails : {true, false}) {\n             CCheckQueueControl<Failing_Queue> control(fail_queue.get());\n             {\n+                auto emplacer = control.get_emplacer();\n                 for (size_t k = 0; k < 100; ++k)\n-                    control.emplace_back(FailingJob {k == 99 && end_fails});\n-                control.Flush();\n+                    emplacer(FailingJob {k == 99 && end_fails});\n             }\n             result[end_fails ? 0 : 1] = control.Wait();\n             fail_queue->TEST_dump_log();\n@@ -362,9 +362,9 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueJob)\n         CCheckQueueControl<Unique_Queue> control(queue.get());\n         while (total) {\n             size_t r = GetRand(10);\n+            auto emplacer = control.get_emplacer();\n             for (size_t k = 0; k < r && total; k++)\n-                control.emplace_back( UniqueJob{--total});\n-            control.Flush();\n+                emplacer( UniqueJob{--total});\n         }\n     }\n     bool r = true;\n@@ -401,11 +401,11 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Memory)\n             CCheckQueueControl<Memory_Queue> control(queue.get());\n             while (total) {\n                 size_t r = GetRand(10);\n+                auto emplacer = control.get_emplacer();\n                 for (size_t k = 0; k < r && total; k++) {\n                     total--;\n-                    control.emplace_back(MemoryJob{total == 0});\n+                    emplacer(MemoryJob{total == 0});\n                 }\n-                control.Flush();\n             }\n         }\n     }\n@@ -435,8 +435,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_FrozenCleanup)\n     std::thread t0([&](){\n         CCheckQueueControl<FrozenCleanup_Queue> control(queue.get());\n         {\n-            control.emplace_back(FrozenCleanupJob{});\n-            control.Flush();\n+            control.get_emplacer()(FrozenCleanupJob{});\n         }\n         FrozenCleanupJob::frozen = true;\n         BOOST_REQUIRE(control.Wait());"
      }
    ]
  },
  {
    "sha": "969c5244822f8db029dc61d75329c78429053ef3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NjljNTI0NDgyMmY4ZGIwMjlkYzYxZDc1MzI5Yzc4NDI5MDUzZWYz",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-29T23:04:11Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:47Z"
      },
      "message": "Fixed OSX build",
      "tree": {
        "sha": "e23871bd00f3c9b2777fbc3f29571dd13748e925",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e23871bd00f3c9b2777fbc3f29571dd13748e925"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/969c5244822f8db029dc61d75329c78429053ef3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/969c5244822f8db029dc61d75329c78429053ef3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/969c5244822f8db029dc61d75329c78429053ef3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/969c5244822f8db029dc61d75329c78429053ef3/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "05b14517f1eb9886224736227198d005100f1047",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/05b14517f1eb9886224736227198d005100f1047",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/05b14517f1eb9886224736227198d005100f1047"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "ec32be9e58a4c0dea2ec0e8173b42d47ae7e5c76",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/969c5244822f8db029dc61d75329c78429053ef3/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/969c5244822f8db029dc61d75329c78429053ef3/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=969c5244822f8db029dc61d75329c78429053ef3",
        "patch": "@@ -2231,7 +2231,7 @@ void static FlushBlockFile(bool fFinalize = false)\n \n bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos, unsigned int nAddSize);\n \n-static CCheckQueue<CScriptCheck, MAX_SCRIPTCHECKS, MAX_SCRIPTCHECK_THREADS> scriptcheckqueue;\n+static CCheckQueue<CScriptCheck> scriptcheckqueue;\n void StopCCheckQueue() {\n     LogPrintf(\"Shutting down CCheckQueue\\n\");\n     scriptcheckqueue.quit();"
      }
    ]
  },
  {
    "sha": "d0fb3b87f9471e01f2caf7045df75a4ac4a80ed6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMGZiM2I4N2Y5NDcxZTAxZjJjYWY3MDQ1ZGY3NWE0YWM0YTgwZWQ2",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-30T05:36:31Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:47Z"
      },
      "message": "Make benchmarking cross platform friendlier by: removing boost requirement, switching to chrono over sys/time",
      "tree": {
        "sha": "7f94864650e4095ed02ecf3eff687e1e0836def6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7f94864650e4095ed02ecf3eff687e1e0836def6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d0fb3b87f9471e01f2caf7045df75a4ac4a80ed6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0fb3b87f9471e01f2caf7045df75a4ac4a80ed6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d0fb3b87f9471e01f2caf7045df75a4ac4a80ed6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0fb3b87f9471e01f2caf7045df75a4ac4a80ed6/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "969c5244822f8db029dc61d75329c78429053ef3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/969c5244822f8db029dc61d75329c78429053ef3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/969c5244822f8db029dc61d75329c78429053ef3"
      }
    ],
    "stats": {
      "total": 17,
      "additions": 7,
      "deletions": 10
    },
    "files": [
      {
        "sha": "1994635238682553c537e4dcfa15abbe7bf598e4",
        "filename": "src/bench/bench.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0fb3b87f9471e01f2caf7045df75a4ac4a80ed6/src/bench/bench.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0fb3b87f9471e01f2caf7045df75a4ac4a80ed6/src/bench/bench.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.cpp?ref=d0fb3b87f9471e01f2caf7045df75a4ac4a80ed6",
        "patch": "@@ -6,16 +6,15 @@\n \n #include <iostream>\n #include <iomanip>\n-#include <sys/time.h>\n \n+#include <chrono>\n using namespace benchmark;\n \n std::map<std::string, BenchFunction> BenchRunner::benchmarks;\n \n static double gettimedouble(void) {\n-    struct timeval tv;\n-    gettimeofday(&tv, NULL);\n-    return tv.tv_usec * 0.000001 + tv.tv_sec;\n+    std::chrono::duration<double> result {std::chrono::system_clock::now().time_since_epoch()};\n+    return result.count();\n }\n \n BenchRunner::BenchRunner(std::string name, BenchFunction func)"
      },
      {
        "sha": "e6636aa6f9402f501c019c9f523577b51c4b80ab",
        "filename": "src/bench/bench.h",
        "status": "modified",
        "additions": 4,
        "deletions": 6,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0fb3b87f9471e01f2caf7045df75a4ac4a80ed6/src/bench/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0fb3b87f9471e01f2caf7045df75a4ac4a80ed6/src/bench/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.h?ref=d0fb3b87f9471e01f2caf7045df75a4ac4a80ed6",
        "patch": "@@ -7,10 +7,9 @@\n \n #include <map>\n #include <string>\n+#include <limits>\n+#include <functional>\n \n-#include <boost/function.hpp>\n-#include <boost/preprocessor/cat.hpp>\n-#include <boost/preprocessor/stringize.hpp>\n \n // Simple micro-benchmarking framework; API mostly matches a subset of the Google Benchmark\n // framework (see https://github.com/google/benchmark)\n@@ -53,7 +52,7 @@ namespace benchmark {\n         bool KeepRunning();\n     };\n \n-    typedef boost::function<void(State&)> BenchFunction;\n+    typedef std::function<void(State&)> BenchFunction;\n \n     class BenchRunner\n     {\n@@ -67,7 +66,6 @@ namespace benchmark {\n }\n \n // BENCHMARK(foo) expands to:  benchmark::BenchRunner bench_11foo(\"foo\", foo);\n-#define BENCHMARK(n) \\\n-    benchmark::BenchRunner BOOST_PP_CAT(bench_, BOOST_PP_CAT(__LINE__, n))(BOOST_PP_STRINGIZE(n), n);\n+#define BENCHMARK(n) benchmark::BenchRunner bench_ ## __LINE__ ## n(#n, n);\n \n #endif // BITCOIN_BENCH_BENCH_H"
      }
    ]
  },
  {
    "sha": "1a57ba3a2c3eeb240bdabfcf7cc85f5c016fd797",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxYTU3YmEzYTJjM2VlYjI0MGJkYWJmY2Y3Y2M4NWY1YzAxNmZkNzk3",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-30T22:25:52Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:47Z"
      },
      "message": "Ugly hack to print out tests as they are run to mitigate travis timeouts. Someone with more knowledge here should fix this",
      "tree": {
        "sha": "d306c199bcb8b5f5371c9a9031daf0b29815bfce",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d306c199bcb8b5f5371c9a9031daf0b29815bfce"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1a57ba3a2c3eeb240bdabfcf7cc85f5c016fd797",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1a57ba3a2c3eeb240bdabfcf7cc85f5c016fd797",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1a57ba3a2c3eeb240bdabfcf7cc85f5c016fd797",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1a57ba3a2c3eeb240bdabfcf7cc85f5c016fd797/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d0fb3b87f9471e01f2caf7045df75a4ac4a80ed6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0fb3b87f9471e01f2caf7045df75a4ac4a80ed6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d0fb3b87f9471e01f2caf7045df75a4ac4a80ed6"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 1,
      "deletions": 0
    },
    "files": [
      {
        "sha": "dc62e972a22379ba7287136a3987ff88e573a5a8",
        "filename": "autogen.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a57ba3a2c3eeb240bdabfcf7cc85f5c016fd797/autogen.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a57ba3a2c3eeb240bdabfcf7cc85f5c016fd797/autogen.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/autogen.sh?ref=1a57ba3a2c3eeb240bdabfcf7cc85f5c016fd797",
        "patch": "@@ -9,3 +9,4 @@ fi\n which autoreconf >/dev/null || \\\n   (echo \"configuration failed, please install autoconf first\" && exit 1)\n autoreconf --install --force --warnings=all\n+sed -i 's,\"\\$@\" >$log_file 2>\\&1,\"\\$@\" -l test_suite  2>\\&1 | tee $log_file,' build-aux/test-driver"
      }
    ]
  },
  {
    "sha": "3bedc5d7980035bacf0bd0fb34e3836ef8329f9c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozYmVkYzVkNzk4MDAzNWJhY2YwYmQwZmIzNGUzODM2ZWY4MzI5Zjlj",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-30T23:11:09Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:47Z"
      },
      "message": "remove uneccesary travis stuff and disable benching till it works",
      "tree": {
        "sha": "edc8b40c5b81cd953eb56b13c3618d38ac5790cb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/edc8b40c5b81cd953eb56b13c3618d38ac5790cb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3bedc5d7980035bacf0bd0fb34e3836ef8329f9c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3bedc5d7980035bacf0bd0fb34e3836ef8329f9c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3bedc5d7980035bacf0bd0fb34e3836ef8329f9c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3bedc5d7980035bacf0bd0fb34e3836ef8329f9c/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1a57ba3a2c3eeb240bdabfcf7cc85f5c016fd797",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1a57ba3a2c3eeb240bdabfcf7cc85f5c016fd797",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1a57ba3a2c3eeb240bdabfcf7cc85f5c016fd797"
      }
    ],
    "stats": {
      "total": 16,
      "additions": 5,
      "deletions": 11
    },
    "files": [
      {
        "sha": "89e5d044b9a7b1456e0fcabda3d53938c0b46766",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 5,
        "deletions": 11,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3bedc5d7980035bacf0bd0fb34e3836ef8329f9c/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3bedc5d7980035bacf0bd0fb34e3836ef8329f9c/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=3bedc5d7980035bacf0bd0fb34e3836ef8329f9c",
        "patch": "@@ -25,15 +25,15 @@ env:\n # ARM\n     - HOST=arm-linux-gnueabihf PACKAGES=\"g++-arm-linux-gnueabihf\" DEP_OPTS=\"NO_QT=1\" CHECK_DOC=1 GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports\"\n # Win32\n-    - HOST=i686-w64-mingw32 DPKG_ADD_ARCH=\"i386\" DEP_OPTS=\"NO_QT=1\" PACKAGES=\"python3 nsis g++-mingw-w64-i686 wine1.6 bc gdb\" RUN_BENCH=true RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-reduce-exports\"\n+    - HOST=i686-w64-mingw32 DPKG_ADD_ARCH=\"i386\" DEP_OPTS=\"NO_QT=1\" PACKAGES=\"python3 nsis g++-mingw-w64-i686 wine1.6 bc gdb\" RUN_BENCH=false RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-reduce-exports\"\n # 32-bit + dash\n-    - HOST=i686-pc-linux-gnu PACKAGES=\"g++-multilib bc python3-zmq gdb\" DEP_OPTS=\"NO_QT=1\" RUN_BENCH=true RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --enable-glibc-back-compat --enable-reduce-exports LDFLAGS=-static-libstdc++\" USE_SHELL=\"/bin/dash\"\n+    - HOST=i686-pc-linux-gnu PACKAGES=\"g++-multilib bc python3-zmq gdb\" DEP_OPTS=\"NO_QT=1\" RUN_BENCH=false RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --enable-glibc-back-compat --enable-reduce-exports LDFLAGS=-static-libstdc++\" USE_SHELL=\"/bin/dash\"\n # Win64\n-    - HOST=x86_64-w64-mingw32 DPKG_ADD_ARCH=\"i386\" DEP_OPTS=\"NO_QT=1\" PACKAGES=\"python3 nsis g++-mingw-w64-x86-64 wine1.6 bc gdb\" RUN_BENCH=true RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-reduce-exports\"\n+    - HOST=x86_64-w64-mingw32 DPKG_ADD_ARCH=\"i386\" DEP_OPTS=\"NO_QT=1\" PACKAGES=\"python3 nsis g++-mingw-w64-x86-64 wine1.6 bc gdb\" RUN_BENCH=false RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-reduce-exports\"\n # bitcoind\n-    - HOST=x86_64-unknown-linux-gnu PACKAGES=\"bc python3-zmq gdb\" DEP_OPTS=\"NO_QT=1 NO_UPNP=1 DEBUG=1\" RUN_BENCH=true RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --enable-glibc-back-compat --enable-reduce-exports CPPFLAGS=-DDEBUG_LOCKORDER\"\n+    - HOST=x86_64-unknown-linux-gnu PACKAGES=\"bc python3-zmq gdb\" DEP_OPTS=\"NO_QT=1 NO_UPNP=1 DEBUG=1\" RUN_BENCH=false RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --enable-glibc-back-compat --enable-reduce-exports CPPFLAGS=-DDEBUG_LOCKORDER\"\n # No wallet\n-    - HOST=x86_64-unknown-linux-gnu PACKAGES=\"python3 gdb\" DEP_OPTS=\"NO_WALLET=1\" RUN_BENCH=true RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports\"\n+    - HOST=x86_64-unknown-linux-gnu PACKAGES=\"python3 gdb\" DEP_OPTS=\"NO_WALLET=1\" RUN_BENCH=false RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports\"\n # Cross-Mac\n     - HOST=x86_64-apple-darwin11 PACKAGES=\"cmake imagemagick libcap-dev librsvg2-bin libz-dev libbz2-dev libtiff-tools python-dev\" BITCOIN_CONFIG=\"--enable-reduce-exports\" OSX_SDK=10.11 GOAL=\"deploy\"\n \n@@ -45,7 +45,6 @@ install:\n     - if [ -n \"$PACKAGES\" ]; then travis_retry sudo apt-get update; fi\n     - if [ -n \"$PACKAGES\" ]; then travis_retry sudo apt-get install --no-install-recommends --no-upgrade -qq $PACKAGES; fi\n before_script:\n-    - ulimit -c unlimited -S       # enable core dumps\n     - unset CC; unset CXX\n     - if [ \"$CHECK_DOC\" = 1 ]; then contrib/devtools/check-doc.py; fi\n     - mkdir -p depends/SDKs depends/sdk-sources\n@@ -69,8 +68,3 @@ script:\n after_script:\n     - echo $TRAVIS_COMMIT_RANGE\n     - echo $TRAVIS_COMMIT_LOG\n-after_failure:\n-    - COREFILE=$(sudo find /  -name \"core-*\" | head -n 1) # find core file\n-    - if [[ -f \"$COREFILE\" ]]; then gdb -c \"$COREFILE\" example -ex \"thread apply all bt\" -ex \"set pagination 0\" -batch; fi\n-    - LOGFILE=$(find ~ -name \"test-suite.log\" | head -n 1)\n-    - if [[ -f \"$LOGFILE\" ]]; then  cat $LOGFILE; fi"
      }
    ]
  },
  {
    "sha": "5210b405ce1daa8c1daed243af57ee9429c62b98",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1MjEwYjQwNWNlMWRhYThjMWRhZWQyNDNhZjU3ZWU5NDI5YzYyYjk4",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-30T23:56:56Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:47Z"
      },
      "message": "speed up prevector tests by parallelization",
      "tree": {
        "sha": "f29453defc3a65369ba31ff65333bab849eb8f4c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f29453defc3a65369ba31ff65333bab849eb8f4c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5210b405ce1daa8c1daed243af57ee9429c62b98",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5210b405ce1daa8c1daed243af57ee9429c62b98",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5210b405ce1daa8c1daed243af57ee9429c62b98",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5210b405ce1daa8c1daed243af57ee9429c62b98/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3bedc5d7980035bacf0bd0fb34e3836ef8329f9c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3bedc5d7980035bacf0bd0fb34e3836ef8329f9c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3bedc5d7980035bacf0bd0fb34e3836ef8329f9c"
      }
    ],
    "stats": {
      "total": 195,
      "additions": 115,
      "deletions": 80
    },
    "files": [
      {
        "sha": "dc076cd0252b933d10815a97cb6647d8b5c83295",
        "filename": "src/test/prevector_tests.cpp",
        "status": "modified",
        "additions": 115,
        "deletions": 80,
        "changes": 195,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5210b405ce1daa8c1daed243af57ee9429c62b98/src/test/prevector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5210b405ce1daa8c1daed243af57ee9429c62b98/src/test/prevector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/prevector_tests.cpp?ref=5210b405ce1daa8c1daed243af57ee9429c62b98",
        "patch": "@@ -12,8 +12,27 @@\n #include \"test/test_bitcoin.h\"\n \n #include <boost/test/unit_test.hpp>\n+#include <thread>\n+#include <sstream>\n+#include <mutex>\n+\n+BOOST_FIXTURE_TEST_SUITE(PrevectorTests, BasicTestingSetup)\n+\n+\n+static std::ostringstream first_failure;\n+static bool failed = false;\n+std::mutex m;\n+bool abort_if_fail() \n+{\n+    std::lock_guard<std::mutex> l(m);\n+    return failed;\n+\n+}\n+\n+#define pBOOST_CHECK(v) { if (!(v)) { std::lock_guard<std::mutex> l(m); if (!failed) {failed=true; first_failure << \"Checking: \" << #v << \" failed.\\n\";} } }\n+\n+#define pBOOST_CHECK_EQUAL(t, v) { if ((t) != (v)) { std::lock_guard<std::mutex> l(m); if (!failed) {failed=true; first_failure << \"Checking: \" << #t << \" == \"<< #v << \" failed.\\n\";} } }\n \n-BOOST_FIXTURE_TEST_SUITE(PrevectorTests, TestingSetup)\n \n template<unsigned int N, typename T>\n class prevector_tester {\n@@ -29,54 +48,54 @@ class prevector_tester {\n \n     void test() {\n         const pretype& const_pre_vector = pre_vector;\n-        BOOST_CHECK_EQUAL(real_vector.size(), pre_vector.size());\n-        BOOST_CHECK_EQUAL(real_vector.empty(), pre_vector.empty());\n+        pBOOST_CHECK_EQUAL(real_vector.size(), pre_vector.size());\n+        pBOOST_CHECK_EQUAL(real_vector.empty(), pre_vector.empty());\n         for (Size s = 0; s < real_vector.size(); s++) {\n-             BOOST_CHECK(real_vector[s] == pre_vector[s]);\n-             BOOST_CHECK(&(pre_vector[s]) == &(pre_vector.begin()[s]));\n-             BOOST_CHECK(&(pre_vector[s]) == &*(pre_vector.begin() + s));\n-             BOOST_CHECK(&(pre_vector[s]) == &*((pre_vector.end() + s) - real_vector.size()));\n+             pBOOST_CHECK(real_vector[s] == pre_vector[s]);\n+             pBOOST_CHECK(&(pre_vector[s]) == &(pre_vector.begin()[s]));\n+             pBOOST_CHECK(&(pre_vector[s]) == &*(pre_vector.begin() + s));\n+             pBOOST_CHECK(&(pre_vector[s]) == &*((pre_vector.end() + s) - real_vector.size()));\n         }\n         // BOOST_CHECK(realtype(pre_vector) == real_vector);\n-        BOOST_CHECK(pretype(real_vector.begin(), real_vector.end()) == pre_vector);\n-        BOOST_CHECK(pretype(pre_vector.begin(), pre_vector.end()) == pre_vector);\n+        pBOOST_CHECK(pretype(real_vector.begin(), real_vector.end()) == pre_vector);\n+        pBOOST_CHECK(pretype(pre_vector.begin(), pre_vector.end()) == pre_vector);\n         size_t pos = 0;\n         BOOST_FOREACH(const T& v, pre_vector) {\n-             BOOST_CHECK(v == real_vector[pos++]);\n+             pBOOST_CHECK(v == real_vector[pos++]);\n         }\n         BOOST_REVERSE_FOREACH(const T& v, pre_vector) {\n-             BOOST_CHECK(v == real_vector[--pos]);\n+             pBOOST_CHECK(v == real_vector[--pos]);\n         }\n         BOOST_FOREACH(const T& v, const_pre_vector) {\n-             BOOST_CHECK(v == real_vector[pos++]);\n+             pBOOST_CHECK(v == real_vector[pos++]);\n         }\n         BOOST_REVERSE_FOREACH(const T& v, const_pre_vector) {\n-             BOOST_CHECK(v == real_vector[--pos]);\n+             pBOOST_CHECK(v == real_vector[--pos]);\n         }\n         CDataStream ss1(SER_DISK, 0);\n         CDataStream ss2(SER_DISK, 0);\n         ss1 << real_vector;\n         ss2 << pre_vector;\n-        BOOST_CHECK_EQUAL(ss1.size(), ss2.size());\n+        pBOOST_CHECK_EQUAL(ss1.size(), ss2.size());\n         for (Size s = 0; s < ss1.size(); s++) {\n-            BOOST_CHECK_EQUAL(ss1[s], ss2[s]);\n+            pBOOST_CHECK_EQUAL(ss1[s], ss2[s]);\n         }\n     }\n \n public:\n     void resize(Size s) {\n         real_vector.resize(s);\n-        BOOST_CHECK_EQUAL(real_vector.size(), s);\n+        pBOOST_CHECK_EQUAL(real_vector.size(), s);\n         pre_vector.resize(s);\n-        BOOST_CHECK_EQUAL(pre_vector.size(), s);\n+        pBOOST_CHECK_EQUAL(pre_vector.size(), s);\n         test();\n     }\n \n     void reserve(Size s) {\n         real_vector.reserve(s);\n-        BOOST_CHECK(real_vector.capacity() >= s);\n+        pBOOST_CHECK(real_vector.capacity() >= s);\n         pre_vector.reserve(s);\n-        BOOST_CHECK(pre_vector.capacity() >= s);\n+        pBOOST_CHECK(pre_vector.capacity() >= s);\n         test();\n     }\n \n@@ -159,70 +178,86 @@ class prevector_tester {\n     }\n };\n \n-BOOST_AUTO_TEST_CASE(PrevectorTestInt)\n-{\n-    for (int j = 0; j < 64; j++) {\n-        prevector_tester<8, int> test;\n-        for (int i = 0; i < 2048; i++) {\n-            int r = insecure_rand();\n-            if ((r % 4) == 0) {\n-                test.insert(insecure_rand() % (test.size() + 1), insecure_rand());\n-            }\n-            if (test.size() > 0 && ((r >> 2) % 4) == 1) {\n-                test.erase(insecure_rand() % test.size());\n-            }\n-            if (((r >> 4) % 8) == 2) {\n-                int new_size = std::max<int>(0, std::min<int>(30, test.size() + (insecure_rand() % 5) - 2));\n-                test.resize(new_size);\n-            }\n-            if (((r >> 7) % 8) == 3) {\n-                test.insert(insecure_rand() % (test.size() + 1), 1 + (insecure_rand() % 2), insecure_rand());\n-            }\n-            if (((r >> 10) % 8) == 4) {\n-                int del = std::min<int>(test.size(), 1 + (insecure_rand() % 2));\n-                int beg = insecure_rand() % (test.size() + 1 - del);\n-                test.erase(beg, beg + del);\n-            }\n-            if (((r >> 13) % 16) == 5) {\n-                test.push_back(insecure_rand());\n-            }\n-            if (test.size() > 0 && ((r >> 17) % 16) == 6) {\n-                test.pop_back();\n-            }\n-            if (((r >> 21) % 32) == 7) {\n-                int values[4];\n-                int num = 1 + (insecure_rand() % 4);\n-                for (int k = 0; k < num; k++) {\n-                    values[k] = insecure_rand();\n-                }\n-                test.insert_range(insecure_rand() % (test.size() + 1), values, values + num);\n-            }\n-            if (((r >> 26) % 32) == 8) {\n-                int del = std::min<int>(test.size(), 1 + (insecure_rand() % 4));\n-                int beg = insecure_rand() % (test.size() + 1 - del);\n-                test.erase(beg, beg + del);\n-            }\n-            r = insecure_rand();\n-            if (r % 32 == 9) {\n-                test.reserve(insecure_rand() % 32);\n-            }\n-            if ((r >> 5) % 64 == 10) {\n-                test.shrink_to_fit();\n-            }\n-            if (test.size() > 0) {\n-                test.update(insecure_rand() % test.size(), insecure_rand());\n-            }\n-            if (((r >> 11) % 1024) == 11) {\n-                test.clear();\n-            }\n-            if (((r >> 21) % 512) == 12) {\n-                test.assign(insecure_rand() % 32, insecure_rand());\n-            }\n-            if (((r >> 15) % 64) == 3) {\n-                test.swap();\n+\n+void test_round() {\n+    prevector_tester<8, int> test;\n+    for (int i = 0; i < 2048; i++) {\n+        int r = insecure_rand();\n+        if ((r % 4) == 0) {\n+            test.insert(insecure_rand() % (test.size() + 1), insecure_rand());\n+        }\n+        if (test.size() > 0 && ((r >> 2) % 4) == 1) {\n+            test.erase(insecure_rand() % test.size());\n+        }\n+        if (((r >> 4) % 8) == 2) {\n+            int new_size = std::max<int>(0, std::min<int>(30, test.size() + (insecure_rand() % 5) - 2));\n+            test.resize(new_size);\n+        }\n+        if (((r >> 7) % 8) == 3) {\n+            test.insert(insecure_rand() % (test.size() + 1), 1 + (insecure_rand() % 2), insecure_rand());\n+        }\n+        if (((r >> 10) % 8) == 4) {\n+            int del = std::min<int>(test.size(), 1 + (insecure_rand() % 2));\n+            int beg = insecure_rand() % (test.size() + 1 - del);\n+            test.erase(beg, beg + del);\n+        }\n+        if (((r >> 13) % 16) == 5) {\n+            test.push_back(insecure_rand());\n+        }\n+        if (test.size() > 0 && ((r >> 17) % 16) == 6) {\n+            test.pop_back();\n+        }\n+        if (((r >> 21) % 32) == 7) {\n+            int values[4];\n+            int num = 1 + (insecure_rand() % 4);\n+            for (int k = 0; k < num; k++) {\n+                values[k] = insecure_rand();\n             }\n+            test.insert_range(insecure_rand() % (test.size() + 1), values, values + num);\n+        }\n+        if (((r >> 26) % 32) == 8) {\n+            int del = std::min<int>(test.size(), 1 + (insecure_rand() % 4));\n+            int beg = insecure_rand() % (test.size() + 1 - del);\n+            test.erase(beg, beg + del);\n+        }\n+        r = insecure_rand();\n+        if (r % 32 == 9) {\n+            test.reserve(insecure_rand() % 32);\n+        }\n+        if ((r >> 5) % 64 == 10) {\n+            test.shrink_to_fit();\n+        }\n+        if (test.size() > 0) {\n+            test.update(insecure_rand() % test.size(), insecure_rand());\n+        }\n+        if (((r >> 11) % 1024) == 11) {\n+            test.clear();\n+        }\n+        if (((r >> 21) % 512) == 12) {\n+            test.assign(insecure_rand() % 32, insecure_rand());\n+        }\n+        if (((r >> 15) % 64) == 3) {\n+            test.swap();\n         }\n     }\n }\n+BOOST_AUTO_TEST_CASE(PrevectorTestInt)\n+{\n+    std::vector<std::thread> threads;\n+\n+    auto testfn = [](){\n+        for (int i = 0; i < 16 && !abort_if_fail(); ++i)\n+            test_round();\n+    };\n+    for (int thread_count = 0; thread_count < 3; ++thread_count)\n+        threads.emplace_back(std::thread(testfn));\n+    testfn();\n+    for (auto& t: threads)\n+        t.join();\n+    std::lock_guard<std::mutex> l(m);\n+    auto s = first_failure.str();\n+    if (s.size() != 0)\n+        BOOST_TEST_ERROR(s);\n+}\n \n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "72e42967b02f387286e144d8b272df95424aaccc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3MmU0Mjk2N2IwMmYzODcyODZlMTQ0ZDhiMjcyZGY5NTQyNGFhY2Nj",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T00:36:50Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2016-08-31T01:18:47Z"
      },
      "message": "BOOST_CHECK_MESSAGE doesn't exist in older versions of boost, so replacing it with it's definition",
      "tree": {
        "sha": "337f94b3e0827478985f05a1cd2d9b3cf718d64b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/337f94b3e0827478985f05a1cd2d9b3cf718d64b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/72e42967b02f387286e144d8b272df95424aaccc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/72e42967b02f387286e144d8b272df95424aaccc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/72e42967b02f387286e144d8b272df95424aaccc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/72e42967b02f387286e144d8b272df95424aaccc/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5210b405ce1daa8c1daed243af57ee9429c62b98",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5210b405ce1daa8c1daed243af57ee9429c62b98",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5210b405ce1daa8c1daed243af57ee9429c62b98"
      }
    ],
    "stats": {
      "total": 3,
      "additions": 2,
      "deletions": 1
    },
    "files": [
      {
        "sha": "3571d0e4916e9501376deeb37bff20ecd46287de",
        "filename": "src/test/prevector_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/72e42967b02f387286e144d8b272df95424aaccc/src/test/prevector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/72e42967b02f387286e144d8b272df95424aaccc/src/test/prevector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/prevector_tests.cpp?ref=72e42967b02f387286e144d8b272df95424aaccc",
        "patch": "@@ -257,7 +257,8 @@ BOOST_AUTO_TEST_CASE(PrevectorTestInt)\n     std::lock_guard<std::mutex> l(m);\n     auto s = first_failure.str();\n     if (s.size() != 0)\n-        BOOST_TEST_ERROR(s);\n+        BOOST_CHECK_MESSAGE(false, s);\n+    \n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  }
]