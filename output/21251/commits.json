[
  {
    "sha": "aacb47c8c135f2cb9b7363f9d320711c8149a2a8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphYWNiNDdjOGMxMzVmMmNiOWI3MzYzZjlkMzIwNzExYzgxNDlhMmE4",
    "commit": {
      "author": {
        "name": "x00",
        "email": "32819740+x00x00@users.noreply.github.com",
        "date": "2021-02-21T06:44:28Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-02-21T06:44:28Z"
      },
      "message": "Add wp images",
      "tree": {
        "sha": "659e97f9efb01c73a72eaef0a4a2b2d4faf7c652",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/659e97f9efb01c73a72eaef0a4a2b2d4faf7c652"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/aacb47c8c135f2cb9b7363f9d320711c8149a2a8",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgMgFMCRBK7hj4Ov3rIwAAdHIIAEPRPoHINgOOe5xAJRAdhuFN\nPFfV6zOA5CAjwRS1amfKHAZsziyrGw6/J1p/kbsD5lNs7bgW9XPwDQmeTHgba5Wu\n9weQ9qsk8cjtNxn95rd1eTW6XzvDCNGBMqK98rMB3NGgogkXEu10PKh+RV0jOpxg\nPIOiLG0gcheJO364O+z53bNA26o1PU3nmN8bdMwwpYrMfgiBoJcddzlBS5uG94FD\n9sxDmfMQWp5BEhYJurpH40LNLzS8pMANTfPnGPSXG0c46FgX4Ao2NjCNUFQkMWm0\nlCpuibpG74/1jtZu2tMSMdMBPyweGhiBxosuN9MvxAu9K0EfJ31gfx3L+z8lGJE=\n=tG9p\n-----END PGP SIGNATURE-----\n",
        "payload": "tree 659e97f9efb01c73a72eaef0a4a2b2d4faf7c652\nparent 5bb64acd9d3ced6e6f95df282a1a0f8b98522cb0\nauthor x00 <32819740+x00x00@users.noreply.github.com> 1613889868 +0530\ncommitter GitHub <noreply@github.com> 1613889868 +0530\n\nAdd wp images"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aacb47c8c135f2cb9b7363f9d320711c8149a2a8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/aacb47c8c135f2cb9b7363f9d320711c8149a2a8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aacb47c8c135f2cb9b7363f9d320711c8149a2a8/comments",
    "author": {
      "login": "1337in",
      "id": 32819740,
      "node_id": "MDQ6VXNlcjMyODE5NzQw",
      "avatar_url": "https://avatars.githubusercontent.com/u/32819740?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/1337in",
      "html_url": "https://github.com/1337in",
      "followers_url": "https://api.github.com/users/1337in/followers",
      "following_url": "https://api.github.com/users/1337in/following{/other_user}",
      "gists_url": "https://api.github.com/users/1337in/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/1337in/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/1337in/subscriptions",
      "organizations_url": "https://api.github.com/users/1337in/orgs",
      "repos_url": "https://api.github.com/users/1337in/repos",
      "events_url": "https://api.github.com/users/1337in/events{/privacy}",
      "received_events_url": "https://api.github.com/users/1337in/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5bb64acd9d3ced6e6f95df282a1a0f8b98522cb0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5bb64acd9d3ced6e6f95df282a1a0f8b98522cb0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5bb64acd9d3ced6e6f95df282a1a0f8b98522cb0"
      }
    ],
    "stats": {
      "total": 0,
      "additions": 0,
      "deletions": 0
    },
    "files": [
      {
        "sha": "50653fd0675ce0a0f2ff8c972b7379307ee17263",
        "filename": "doc/whitepaper/diskspace.PNG",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aacb47c8c135f2cb9b7363f9d320711c8149a2a8/doc/whitepaper/diskspace.PNG",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aacb47c8c135f2cb9b7363f9d320711c8149a2a8/doc/whitepaper/diskspace.PNG",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/whitepaper/diskspace.PNG?ref=aacb47c8c135f2cb9b7363f9d320711c8149a2a8"
      },
      {
        "sha": "bfffe9e55ee0800145c782f0164875d146d6530e",
        "filename": "doc/whitepaper/privacy.PNG",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aacb47c8c135f2cb9b7363f9d320711c8149a2a8/doc/whitepaper/privacy.PNG",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aacb47c8c135f2cb9b7363f9d320711c8149a2a8/doc/whitepaper/privacy.PNG",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/whitepaper/privacy.PNG?ref=aacb47c8c135f2cb9b7363f9d320711c8149a2a8"
      },
      {
        "sha": "8480ccb0984bc5b03f760958f52ac56c4ff8b4e8",
        "filename": "doc/whitepaper/proofofwork.PNG",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aacb47c8c135f2cb9b7363f9d320711c8149a2a8/doc/whitepaper/proofofwork.PNG",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aacb47c8c135f2cb9b7363f9d320711c8149a2a8/doc/whitepaper/proofofwork.PNG",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/whitepaper/proofofwork.PNG?ref=aacb47c8c135f2cb9b7363f9d320711c8149a2a8"
      },
      {
        "sha": "6a34a6b212e89e6113b390c3a79f369971d37aca",
        "filename": "doc/whitepaper/split.PNG",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aacb47c8c135f2cb9b7363f9d320711c8149a2a8/doc/whitepaper/split.PNG",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aacb47c8c135f2cb9b7363f9d320711c8149a2a8/doc/whitepaper/split.PNG",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/whitepaper/split.PNG?ref=aacb47c8c135f2cb9b7363f9d320711c8149a2a8"
      },
      {
        "sha": "6b89102e19798bd353d07ebf0db1923c2ff105cf",
        "filename": "doc/whitepaper/spv.PNG",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aacb47c8c135f2cb9b7363f9d320711c8149a2a8/doc/whitepaper/spv.PNG",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aacb47c8c135f2cb9b7363f9d320711c8149a2a8/doc/whitepaper/spv.PNG",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/whitepaper/spv.PNG?ref=aacb47c8c135f2cb9b7363f9d320711c8149a2a8"
      },
      {
        "sha": "1fc9e11b2a6bb42a5adcea95a6c4f060d70e8577",
        "filename": "doc/whitepaper/timestamp-server.PNG",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aacb47c8c135f2cb9b7363f9d320711c8149a2a8/doc/whitepaper/timestamp-server.PNG",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aacb47c8c135f2cb9b7363f9d320711c8149a2a8/doc/whitepaper/timestamp-server.PNG",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/whitepaper/timestamp-server.PNG?ref=aacb47c8c135f2cb9b7363f9d320711c8149a2a8"
      },
      {
        "sha": "fb21017918cef596f1d0c53729dc4f6010b30d0a",
        "filename": "doc/whitepaper/transactions.PNG",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aacb47c8c135f2cb9b7363f9d320711c8149a2a8/doc/whitepaper/transactions.PNG",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aacb47c8c135f2cb9b7363f9d320711c8149a2a8/doc/whitepaper/transactions.PNG",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/whitepaper/transactions.PNG?ref=aacb47c8c135f2cb9b7363f9d320711c8149a2a8"
      }
    ]
  },
  {
    "sha": "5d3ce1486ee0919881173369100acec77fec49cf",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ZDNjZTE0ODZlZTA5MTk4ODExNzMzNjkxMDBhY2VjNzdmZWM0OWNm",
    "commit": {
      "author": {
        "name": "x00",
        "email": "32819740+x00x00@users.noreply.github.com",
        "date": "2021-02-21T06:51:18Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-02-21T06:51:18Z"
      },
      "message": "Add whitepaper with images",
      "tree": {
        "sha": "5e1c874ce8d4a30e9c22baf16c19a7181f830a49",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5e1c874ce8d4a30e9c22baf16c19a7181f830a49"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5d3ce1486ee0919881173369100acec77fec49cf",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgMgLmCRBK7hj4Ov3rIwAAdHIIAHBaYSiFIDjZXo49dERjhh/O\n2cUgiMXtrarhxZuYgCoDHm4v6uOhuDxT42EPOglY9TiTzL8tRQxcXH339tXRSBuO\nB/7Ars5GWSt0Jnk3yMXZ1yrn5Qp39mn/3dxVQxEPMFx3tp0y3T7hGxgHlbOlormW\nEBWzkC10aMojRZfUnGp8BQJ09ypXgRRVl6Bm+lcsBEvpLVDzxBGHgzlBwhUmkWXp\nw8qxqCssIDzbqJX0Ko4JUfIAMYf6UZMoCBnmEYPvaXjgqR7BV6sbutIONHF1H7Qc\nZVY+UTl00unsewx+iMR/J2X5uvVJl+ykDzPcwANmSco8bfmwWDn+ip8WBLOwj6U=\n=yYB/\n-----END PGP SIGNATURE-----\n",
        "payload": "tree 5e1c874ce8d4a30e9c22baf16c19a7181f830a49\nparent aacb47c8c135f2cb9b7363f9d320711c8149a2a8\nauthor x00 <32819740+x00x00@users.noreply.github.com> 1613890278 +0530\ncommitter GitHub <noreply@github.com> 1613890278 +0530\n\nAdd whitepaper with images"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5d3ce1486ee0919881173369100acec77fec49cf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5d3ce1486ee0919881173369100acec77fec49cf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5d3ce1486ee0919881173369100acec77fec49cf/comments",
    "author": {
      "login": "1337in",
      "id": 32819740,
      "node_id": "MDQ6VXNlcjMyODE5NzQw",
      "avatar_url": "https://avatars.githubusercontent.com/u/32819740?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/1337in",
      "html_url": "https://github.com/1337in",
      "followers_url": "https://api.github.com/users/1337in/followers",
      "following_url": "https://api.github.com/users/1337in/following{/other_user}",
      "gists_url": "https://api.github.com/users/1337in/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/1337in/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/1337in/subscriptions",
      "organizations_url": "https://api.github.com/users/1337in/orgs",
      "repos_url": "https://api.github.com/users/1337in/repos",
      "events_url": "https://api.github.com/users/1337in/events{/privacy}",
      "received_events_url": "https://api.github.com/users/1337in/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "aacb47c8c135f2cb9b7363f9d320711c8149a2a8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aacb47c8c135f2cb9b7363f9d320711c8149a2a8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/aacb47c8c135f2cb9b7363f9d320711c8149a2a8"
      }
    ],
    "stats": {
      "total": 364,
      "additions": 364,
      "deletions": 0
    },
    "files": [
      {
        "sha": "d0b0ffbe092f674192229bf0028114fccbf7fd3f",
        "filename": "doc/whitepaper/whitepaper.md",
        "status": "added",
        "additions": 364,
        "deletions": 0,
        "changes": 364,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d3ce1486ee0919881173369100acec77fec49cf/doc/whitepaper/whitepaper.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d3ce1486ee0919881173369100acec77fec49cf/doc/whitepaper/whitepaper.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/whitepaper/whitepaper.md?ref=5d3ce1486ee0919881173369100acec77fec49cf",
        "patch": "@@ -0,0 +1,364 @@\n+# Bitcoin: A Peer-to-Peer Electronic Cash System\n+\n+| Satoshi Nakamoto |\n+|     :---:        |\n+| satoshin@gmx.com |\n+\n+**Abstract**: A purely peer-to-peer version of electronic cash\n+would allow online payments to be sent directly from one party\n+to another without going through a financial institution.\n+Digital signatures provide part of the solution, but the main\n+benefits are lost if a trusted third party is still required\n+to prevent double-spending. We propose a solution to the\n+double-spending problem using a peer-to-peer network.\n+The network timestamps transactions by hashing them into an\n+ongoing chain of hash-based proof-of-work, forming a record\n+that cannot be changed without redoing the proof-of-work.\n+The longest chain not only serves as proof of the sequence\n+of events witnessed, but proof that it came from the largest\n+pool of CPU power.  As long as a majority of CPU power is\n+controlled by nodes that are not cooperating to attack the\n+network, they'll generate the longest chain and outpace\n+attackers. The network itself requires minimal structure.\n+Messages are broadcast on a best effort basis, and nodes\n+can leave and rejoin the network at will, accepting the\n+longest proof-of-work chain as proof of what happened while\n+they were gone.\n+\n+## 1. Introduction\n+\n+Commerce on the Internet has come to rely almost exclusively\n+on financial institutions serving as trusted third parties to\n+process electronic payments.  While the system works well\n+enough for most transactions, it still suffers from the inherent\n+weaknesses of the trust based model. Completely non-reversible\n+transactions are not really possible, since financial institutions\n+cannot avoid mediating disputes.  The cost of mediation increases\n+transaction costs, limiting the minimum practical transaction size\n+and cutting off the possibility for small casual transactions, and\n+there is a broader cost in the loss of ability to make non-reversible\n+payments for nonreversible services.  With the possibility of reversal,\n+the need for trust spreads.  Merchants must be wary of their customers,\n+hassling them for more information than they would otherwise need.\n+A certain percentage of fraud is accepted as unavoidable.  These costs\n+and payment uncertainties can be avoided in person by using physical\n+currency, but no mechanism exists to make payments over a communications\n+channel without a trusted party.\n+\n+What is needed is an electronic payment system based on cryptographic\n+proof instead of trust, allowing any two willing parties to transact\n+directly with each other without the need for a trusted third party.\n+Transactions that are computationally impractical to reverse would\n+protect sellers from fraud, and routine escrow mechanisms could easily\n+be implemented to protect buyers.  In this paper, we propose a solution\n+to the double-spending problem using a peer-to-peer distributed timestamp\n+server to generate computational proof of the chronological order of\n+transactions.  The system is secure as long as honest nodes collectively\n+control more CPU power than any cooperating group of attacker nodes.\n+\n+## 2. Transactions\n+\n+We define an electronic coin as a chain of digital signatures.  Each owner\n+transfers the coin to the next by digitally signing a hash of the previous\n+transaction and the public key of the next owner and adding these to the end\n+of the coin.  A payee can verify the signatures to verify the chain of ownership.\n+\n+![transactions](/doc/whitepaper/transactions.PNG)\n+\n+The problem of course is the payee can't verify that one of the owners did not\n+double-spend the coin.  A common solution is to introduce a trusted central authority,\n+or mint, that checks every transaction for double spending.  After each transaction,\n+the coin must be returned to the mint to issue a new coin, and only coins issued directly\n+from the mint are trusted not to be double-spent. The problem with this solution is that\n+the fate of the entire money system depends on the company running the mint, with every\n+transaction having to go through them, just like a bank.\n+\n+We need a way for the payee to know that the previous owners did not sign any earlier\n+transactions.  For our purposes, the earliest transaction is the one that counts, so\n+we don't care about later attempts to double-spend.  The only way to confirm the absence\n+of a transaction is to be aware of all transactions.  In the mint based model, the mint\n+was aware of all transactions and decided which arrived first.  To accomplish this without\n+a trusted party, transactions must be publicly announced [1], and we need a system for\n+participants to agree on a single history of the order in which they were received.\n+The payee needs proof that at the time of each transaction, the majority of nodes agreed\n+it was the first received.\n+\n+## 3. Timestamp Server\n+\n+The solution we propose begins with a timestamp server.  A timestamp server works by taking\n+a hash of a block of items to be timestamped and widely publishing the hash, such as in a\n+newspaper or Usenet post [2-5].  The timestamp proves that the data must have existed at the\n+time, obviously, in order to get into the hash.  Each timestamp includes the previous timestamp\n+in its hash, forming a chain, with each additional timestamp reinforcing the ones before it.\n+\n+![timestamp-server](/doc/whitepaper/timestamp-server.PNG\n+\n+## 4. Proof-of-Work\n+\n+To implement a distributed timestamp server on a peer-to-peer basis, we will need to use a\n+proofof-work system similar to Adam Back's Hashcash [6], rather than newspaper or Usenet posts.\n+The proof-of-work involves scanning for a value that when hashed, such as with SHA-256, the hash\n+begins with a number of zero bits.  The average work required is exponential in the number of zero\n+bits required and can be verified by executing a single hash.\n+\n+For our timestamp network, we implement the proof-of-work by incrementing a nonce in the block until\n+a value is found that gives the block's hash the required zero bits.  Once the CPU effort has been\n+expended to make it satisfy the proof-of-work, the block cannot be changed without redoing the work.\n+As later blocks are chained after it, the work to change the block would include redoing all the blocks\n+after it.\n+\n+![proof-of-work](/doc/whitepaper/proofofwork.PNG)\n+\n+The proof-of-work also solves the problem of determining representation in majority decision making.\n+If the majority were based on one-IP-address-one-vote, it could be subverted by anyone able to allocate\n+many IPs.  Proof-of-work is essentially one-CPU-one-vote.  The majority decision is represented by the\n+longest chain, which has the greatest proof-of-work effort invested in it.  If a majority of CPU power is\n+controlled by honest nodes, the honest chain will grow the fastest and outpace any competing chains.\n+To modify a past block, an attacker would have to redo the proof-of-work of the block and all blocks after\n+it and then catch up with and surpass the work of the honest nodes.  We will show later that the probability\n+of a slower attacker catching up diminishes exponentially as subsequent blocks are added.\n+\n+To compensate for increasing hardware speed and varying interest in running nodes over time, the proof-of-work\n+difficulty is determined by a moving average targeting an average number of blocks per hour.  If they're generated\n+too fast, the difficulty increases.\n+\n+## 5. Network\n+\n+The steps to run the network are as follows:\n+\n+1) New transactions are broadcast to all nodes.\n+2) Each node collects new transactions into a block.\n+3) Each node works on finding a difficult proof-of-work for its block.\n+4) When a node finds a proof-of-work, it broadcasts the block to all nodes.\n+5) Nodes accept the block only if all transactions in it are valid and not already spent.\n+6) Nodes express their acceptance of the block by working on creating the next block in the chain, using the hash\n+of the accepted block as the previous hash.\n+\n+Nodes always consider the longest chain to be the correct one and will keep working on extending it.\n+If two nodes broadcast different versions of the next block simultaneously, some nodes may receive one or the other first.\n+In that case, they work on the first one they received, but save the other branch in case it becomes longer.\n+The tie will be broken when the next proofof-work is found and one branch becomes longer; the nodes that were working on the\n+other branch will then switch to the longer one.\n+\n+New transaction broadcasts do not necessarily need to reach all nodes.  As long as they reach many nodes, they will get into\n+a block before long.  Block broadcasts are also tolerant of dropped messages.  If a node does not receive a block, it will\n+request it when it receives the next block and realizes it missed one.\n+\n+## 6. Incentive\n+\n+By convention, the first transaction in a block is a special transaction that starts a new coin owned by the creator of the block.\n+This adds an incentive for nodes to support the network, and provides a way to initially distribute coins into circulation,\n+since there is no central authority to issue them. The steady addition of a constant of amount of new coins is analogous to gold\n+miners expending resources to add gold to circulation.  In our case, it is CPU time and electricity that is expended.\n+\n+The incentive can also be funded with transaction fees.  If the output value of a transaction is less than its input value,\n+the difference is a transaction fee that is added to the incentive value of the block containing the transaction.\n+Once a predetermined number of coins have entered circulation, the incentive can transition entirely to transaction fees\n+and be completely inflation free.\n+\n+The incentive may help encourage nodes to stay honest.  If a greedy attacker is able to assemble more CPU power than all\n+the honest nodes, he would have to choose between using it to defraud people by stealing back his payments, or using it to\n+generate new coins.  He ought to find it more profitable to play by the rules, such rules that favour him with more new coins\n+than everyone else combined, than to undermine the system and the validity of his own wealth.\n+\n+## 7. Reclaiming Disk Space\n+\n+Once the latest transaction in a coin is buried under enough blocks, the spent transactions before it can be discarded to\n+save disk space.  To facilitate this without breaking the block's hash, transactions are hashed in a Merkle Tree [7][2][5],\n+with only the root included in the block's hash. Old blocks can then be compacted by stubbing off branches of the tree.\n+The interior hashes do not need to be stored.\n+\n+![disk-space](/doc/whitepaper/diskspace.PNG)\n+\n+A block header with no transactions would be about 80 bytes.  If we suppose blocks are generated every 10 minutes,\n+80 bytes * 6 * 24 * 365 = 4.2MB per year.  With computer systems typically selling with 2GB of RAM as of 2008, and Moore's Law\n+predicting current growth of 1.2GB per year, storage should not be a problem even if the block headers must be kept in memory.\n+\n+## 8. Simplified Payment Verification\n+\n+It is possible to verify payments without running a full network node.  A user only needs to keep a copy of the block headers\n+of the longest proof-of-work chain, which he can get by querying network nodes until he's convinced he has the longest chain,\n+and obtain the Merkle branch linking the transaction to the block it's timestamped in.  He can't check the transaction for himself,\n+but by linking it to a place in the chain, he can see that a network node has accepted it, and blocks added after it further confirm\n+the network has accepted it.\n+\n+![spv](/doc/whitepaper/spv.PNG)\n+\n+As such, the verification is reliable as long as honest nodes control the network, but is more vulnerable if the network is overpowered by\n+an attacker.  While network nodes can verify transactions for themselves, the simplified method can be fooled by an attacker's fabricated\n+transactions for as long as the attacker can continue to overpower the network.  One strategy to protect against this would be to accept\n+alerts from network nodes when they detect an invalid block, prompting the user's software to download the full block and alerted transactions\n+to confirm the inconsistency.  Businesses that receive frequent payments will probably still want to run their own nodes for more independent\n+security and quicker verification.\n+\n+## 9. Combining and Splitting Value\n+\n+Although it would be possible to handle coins individually, it would be unwieldy to make a separate transaction for every cent in a transfer.\n+To allow value to be split and combined, transactions contain multiple inputs and outputs.  Normally there will be either a single input from\n+a larger previous transaction or multiple inputs combining smaller amounts, and at most two outputs: one for the payment, and one returning the\n+change, if any, back to the sender.\n+\n+![split-value](/doc/whitepaper/split.PNG)\n+\n+It should be noted that fan-out, where a transaction depends on several transactions, and those transactions depend on many more, is not a problem\n+here.  There is never the need to extract a complete standalone copy of a transaction's history.\n+\n+## 10. Privacy\n+\n+The traditional banking model achieves a level of privacy by limiting access to information to the parties involved and the trusted third party.\n+The necessity to announce all transactions publicly precludes this method, but privacy can still be maintained by breaking the flow of information\n+in another place: by keeping public keys anonymous.  The public can see that someone is sending an amount to someone else, but without information\n+linking the transaction to anyone.  This is similar to the level of information released by stock exchanges, where the time and size of individual\n+trades, the \"tape\", is made public, but without telling who the parties were.\n+\n+![privacy](/doc/whitepaper/privacy.PNG)\n+\n+As an additional firewall, a new key pair should be used for each transaction to keep them from being linked to a common owner.  Some linking is\n+still unavoidable with multi-input transactions, which necessarily reveal that their inputs were owned by the same owner.  The risk is that if the\n+owner of a key is revealed, linking could reveal other transactions that belonged to the same owner.\n+\n+## 11. Calculations\n+\n+We consider the scenario of an attacker trying to generate an alternate chain faster than the honest chain.  Even if this is accomplished, it does\n+not throw the system open to arbitrary changes, such as creating value out of thin air or taking money that never belonged to the attacker.  Nodes\n+are not going to accept an invalid transaction as payment, and honest nodes will never accept a block containing them.  An attacker can only try to\n+change one of his own transactions to take back money he recently spent.\n+\n+The race between the honest chain and an attacker chain can be characterized as a Binomial Random Walk.  The success event is the honest chain being\n+extended by one block, increasing its lead by +1, and the failure event is the attacker's chain being extended by one block, reducing the gap by -1.\n+\n+The probability of an attacker catching up from a given deficit is analogous to a Gambler's Ruin problem.  Suppose a gambler with unlimited credit\n+starts at a deficit and plays potentially an infinite number of trials to try to reach breakeven.  We can calculate the probability he ever reaches\n+breakeven, or that an attacker ever catches up with the honest chain, as follows [8]:\n+\n+*p = probability an honest node finds the next block*\n+\n+*q = probability the attacker finds the next block*\n+\n+*q<sub>z</sub> = probability the attacker will ever catch up from z blocks behind*\n+\n+if p<=q, q<sub>z</sub> = 1 else (q/p)<sup>z</sup>\n+\n+Given our assumption that p > q, the probability drops exponentially as the number of blocks the attacker has to catch up with increases.  With the odds\n+against him, if he doesn't make a lucky lunge forward early on, his chances become vanishingly small as he falls further behind.\n+\n+We now consider how long the recipient of a new transaction needs to wait before being sufficiently certain the sender can't change the transaction.\n+We assume the sender is an attacker who wants to make the recipient believe he paid him for a while, then switch it to pay back to himself after some\n+time has passed.  The receiver will be alerted when that happens, but the sender hopes it will be too late.\n+\n+The receiver generates a new key pair and gives the public key to the sender shortly before signing.  This prevents the sender from preparing a chain\n+of blocks ahead of time by working on it continuously until he is lucky enough to get far enough ahead, then executing the transaction at that moment.\n+Once the transaction is sent, the dishonest sender starts working in secret on a parallel chain containing an alternate version of his transaction.\n+\n+The recipient waits until the transaction has been added to a block and z blocks have been linked after it.  He doesn't know the exact amount of progress\n+the attacker has made, but assuming the honest blocks took the average expected time per block, the attacker's potential progress will be a Poisson distribution\n+with expected value:\n+\n+\u03bb = z*(q/p)\n+\n+To get the probability the attacker could still catch up now, we multiply the Poisson density for each amount of progress he could have made by the probability\n+he could catch up from that point:\n+\n+<sub>k=0</sub>\u03a3<sup>\u221e</sup> (\u03bb<sup>k</sup>e<sup>-\u03bb</sup>)/k! * {(q/p)<sup>(z-k)</sup> if k<=z else 1}\n+\n+Rearranging to avoid summing the infinite tail of the distribution:\n+\n+1 - <sub>k=0</sub>\u03a3<sup>\u221e</sup> (\u03bb<sup>k</sup>e<sup>-\u03bb</sup>)/k! * (1- (q/p)<sup>(z-k)</sup>)\n+\n+Converting to C code:\n+\n+```\n+#include <math.h>\n+double AttackerSuccessProbability(double q, int z)\n+{\n+double p = 1.0 - q;\n+double lambda = z * (q / p);\n+double sum = 1.0;\n+int i, k;\n+for (k = 0; k <= z; k++)\n+{\n+double poisson = exp(-lambda);\n+for (i = 1; i <= k; i++)\n+poisson *= lambda / i;\n+sum -= poisson * (1 - pow(q / p, z - k));\n+}\n+return sum;\n+}\n+```\n+Running some results, we can see the probability drop off exponentially with z:\n+\n+<pre>\n+q=0.1\n+z=0    P=1.0000000\n+z=1    P=0.2045873\n+z=2    P=0.0509779\n+z=3    P=0.0131722\n+z=4    P=0.0034552\n+z=5    P=0.0009137\n+z=6    P=0.0002428\n+z=7    P=0.0000647\n+z=8    P=0.0000173\n+z=9    P=0.0000046\n+z=10   P=0.0000012\n+</pre>\n+\n+<pre>\n+q=0.3\n+z=0    P=1.0000000\n+z=5    P=0.1773523\n+z=10   P=0.0416605\n+z=15   P=0.0101008\n+z=20   P=0.0024804\n+z=25   P=0.0006132\n+z=30   P=0.0001522\n+z=35   P=0.0000379\n+z=40   P=0.0000095\n+z=45   P=0.0000024\n+z=50   P=0.0000006\n+</pre>\n+\n+Solving for P less than 0.1%:\n+\n+<pre>\n+P < 0.001\n+q=0.10   z=5\n+q=0.15   z=8\n+q=0.20   z=11\n+q=0.25   z=15\n+q=0.30   z=24\n+q=0.35   z=41\n+q=0.40   z=89\n+q=0.45   z=340\n+</pre>\n+\n+## 12. Conclusion\n+\n+We have proposed a system for electronic transactions without relying on trust.  We started with the usual framework of coins made from digital signatures,\n+which provides strong control of ownership, but is incomplete without a way to prevent double-spending.  To solve this, we proposed a peer-to-peer network\n+using proof-of-work to record a public history of transactions that quickly becomes computationally impractical for an attacker to change if honest nodes\n+control a majority of CPU power.  The network is robust in its unstructured simplicity.  Nodes work all at once with little coordination.  They do not need\n+to be identified, since messages are not routed to any particular place and only need to be delivered on a best effort basis.  Nodes can leave and rejoin the\n+network at will, accepting the proof-of-work chain as proof of what happened while they were gone.  They vote with their CPU power, expressing their acceptance\n+of valid blocks by working on extending them and rejecting invalid blocks by refusing to work on them.  Any needed rules and incentives can be enforced with\n+this consensus mechanism.\n+\n+## References\n+\n+[1] W. Dai, \"b-money,\" http://www.weidai.com/bmoney.txt, 1998.\n+\n+[2] H. Massias, X.S. Avila, and J.-J. Quisquater, \"Design of a secure timestamping service with minimal trust requirements,\" In 20th Symposium on Information\n+Theory in the Benelux, May 1999.\n+\n+[3] S. Haber, W.S. Stornetta, \"How to time-stamp a digital document,\" In Journal of Cryptology, vol 3, no 2, pages 99-111, 1991.\n+\n+[4] D. Bayer, S. Haber, W.S. Stornetta, \"Improving the efficiency and reliability of digital time-stamping,\" In Sequences II: Methods in Communication,\n+Security and Computer Science, pages 329-334, 1993.\n+\n+[5] S. Haber, W.S. Stornetta, \"Secure names for bit-strings,\" In Proceedings of the 4th ACM Conference on Computer and Communications Security, pages 28-35, April 1997.\n+\n+[6] A. Back, \"Hashcash - a denial of service counter-measure,\" http://www.hashcash.org/papers/hashcash.pdf, 2002.\n+\n+[7] R.C. Merkle, \"Protocols for public key cryptosystems,\" In Proc. 1980 Symposium on Security and Privacy, IEEE Computer Society, pages 122-133, April 1980.\n+\n+[8] W. Feller, \"An introduction to probability theory and its applications,\" 1957.\n+"
      }
    ]
  }
]