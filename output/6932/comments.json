[
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/153505158",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/6932#issuecomment-153505158",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/6932",
    "id": 153505158,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1MzUwNTE1OA==",
    "user": {
      "login": "gmaxwell",
      "id": 858454,
      "node_id": "MDQ6VXNlcjg1ODQ1NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/858454?u=63e5c438c242094837a9deeda775d77988b508bf&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gmaxwell",
      "html_url": "https://github.com/gmaxwell",
      "followers_url": "https://api.github.com/users/gmaxwell/followers",
      "following_url": "https://api.github.com/users/gmaxwell/following{/other_user}",
      "gists_url": "https://api.github.com/users/gmaxwell/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
      "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
      "repos_url": "https://api.github.com/users/gmaxwell/repos",
      "events_url": "https://api.github.com/users/gmaxwell/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-03T22:09:48Z",
    "updated_at": "2015-11-03T22:09:48Z",
    "author_association": "CONTRIBUTOR",
    "body": "ConceptACK, will review further and test.\n",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/153505158/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/155697633",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/6932#issuecomment-155697633",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/6932",
    "id": 155697633,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1NTY5NzYzMw==",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?u=7999a16349f0df0fb273fffa18e5a955c9d3f11c&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-11T07:59:01Z",
    "updated_at": "2015-11-11T07:59:01Z",
    "author_association": "MEMBER",
    "body": "Untested, code review ACK. Needs a unit test, though.\n",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/155697633/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/155701630",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/6932#issuecomment-155701630",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/6932",
    "id": 155701630,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1NTcwMTYzMA==",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?u=7999a16349f0df0fb273fffa18e5a955c9d3f11c&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-11T08:22:34Z",
    "updated_at": "2015-11-11T08:22:34Z",
    "author_association": "MEMBER",
    "body": "Together with #5967 it should be possible to also avoid the db read that's still done for coinbase transactions.\n",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/155701630/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/155978638",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/6932#issuecomment-155978638",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/6932",
    "id": 155978638,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1NTk3ODYzOA==",
    "user": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?u=b7dd63827227d69794b5fe28797b1bd107b930dd&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-12T02:34:16Z",
    "updated_at": "2015-11-12T02:34:16Z",
    "author_association": "MEMBER",
    "body": "@sipa I'm not sure if this was the kind of unit test that you had in mind?  I thought it was important to actually test UpdateCoins instead of modifyNewCoins directly because it's how it is used that matters.\n\nThis test passes on master, passes on this PR, but fails when UpdateCoins is changed to just mark coinbases as un-FRESH but still skip the lookup (assuming the assert is commented out to permit this).\n\nHowever if #5967 is merged then the test passes once again.\n",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/155978638/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/156113106",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/6932#issuecomment-156113106",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/6932",
    "id": 156113106,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1NjExMzEwNg==",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?u=7999a16349f0df0fb273fffa18e5a955c9d3f11c&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-12T14:16:29Z",
    "updated_at": "2015-11-12T14:16:29Z",
    "author_association": "MEMBER",
    "body": "@morcos Awesome test.\n",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/156113106/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/156128886",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/6932#issuecomment-156128886",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/6932",
    "id": 156128886,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1NjEyODg4Ng==",
    "user": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?u=b7dd63827227d69794b5fe28797b1bd107b930dd&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-12T14:57:54Z",
    "updated_at": "2015-11-12T14:57:54Z",
    "author_association": "MEMBER",
    "body": "ok fixed the mess with the random nValue.\n",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/156128886/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/156132015",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/6932#issuecomment-156132015",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/6932",
    "id": 156132015,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1NjEzMjAxNQ==",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?u=7999a16349f0df0fb273fffa18e5a955c9d3f11c&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-12T15:04:42Z",
    "updated_at": "2015-11-12T15:04:42Z",
    "author_association": "MEMBER",
    "body": "ACK\n",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/156132015/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/156137582",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/6932#issuecomment-156137582",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/6932",
    "id": 156137582,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1NjEzNzU4Mg==",
    "user": {
      "login": "jgarzik",
      "id": 494411,
      "node_id": "MDQ6VXNlcjQ5NDQxMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/494411?u=0b02049ec38b6bb7d55c5c66d9bbeb0d4b822129&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jgarzik",
      "html_url": "https://github.com/jgarzik",
      "followers_url": "https://api.github.com/users/jgarzik/followers",
      "following_url": "https://api.github.com/users/jgarzik/following{/other_user}",
      "gists_url": "https://api.github.com/users/jgarzik/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jgarzik/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jgarzik/subscriptions",
      "organizations_url": "https://api.github.com/users/jgarzik/orgs",
      "repos_url": "https://api.github.com/users/jgarzik/repos",
      "events_url": "https://api.github.com/users/jgarzik/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jgarzik/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-12T15:26:18Z",
    "updated_at": "2015-11-12T15:26:18Z",
    "author_association": "CONTRIBUTOR",
    "body": "lightly tested ACK\n",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/156137582/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/156426767",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/6932#issuecomment-156426767",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/6932",
    "id": 156426767,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1NjQyNjc2Nw==",
    "user": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?u=13b19d1ff2f5f914e180c41418f451a4ba6f8bd1&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-13T13:05:04Z",
    "updated_at": "2015-11-13T13:05:04Z",
    "author_association": "MEMBER",
    "body": "Code review ACK\n",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/156426767/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44777833",
    "pull_request_review_id": null,
    "id": 44777833,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc3ODMz",
    "diff_hunk": "@@ -197,4 +202,133 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n     BOOST_CHECK(missed_an_entry);\n }\n \n+// This test is similar to the previous test\n+// except the emphasis is on testing the functionality of UpdateCoins\n+// random txs are created and UpdateCoins is used to update the cache stack\n+// In particular it is tested that spending a duplicate coinbase tx\n+// has the expected effect (the other duplicate is overwitten at all cache levels)\n+BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n+{\n+    bool spent_a_duplicate_coinbase = false;\n+    // A simple map to track what we expect the cache stack to represent.\n+    std::map<uint256, CCoins> result;\n+\n+    // The cache stack.\n+    CCoinsViewTest base; // A CCoinsViewTest at the bottom.\n+    std::vector<CCoinsViewCacheTest*> stack; // A stack of CCoinsViewCaches on top.\n+    stack.push_back(new CCoinsViewCacheTest(&base)); // Start with one cache.\n+\n+    // Track the txids we've used and whether they have been spent or not\n+    std::map<uint256, CAmount> coinbaseids;\n+    std::set<uint256> alltxids;\n+    std::set<uint256> duplicateids;\n+\n+    for (unsigned int i = 0; i < NUM_SIMULATION_ITERATIONS; i++) {\n+        {\n+            CMutableTransaction tx;\n+            tx.vin.resize(1);\n+            tx.vout.resize(1);\n+            tx.vout[0].nValue = i; //Keep txs unique unless intended to duplicate\n+            unsigned int height = insecure_rand();\n+\n+            // 1/10 times create a coinbase\n+            if (insecure_rand() % 10 == 0 || coinbaseids.size() < 10) {\n+                // 1/100 times create a duplicate coinbase\n+                if (insecure_rand() % 10 == 0 && coinbaseids.size()) {\n+                    std::map<uint256, CAmount>::iterator coinbaseIt = coinbaseids.lower_bound(GetRandHash());\n+                    if (coinbaseIt == coinbaseids.end()) {\n+                        coinbaseIt = coinbaseids.begin();\n+                    }\n+                    //Use same random value to have same hash and be a true duplicate\n+                    tx.vout[0].nValue = coinbaseIt->second;\n+                    assert(tx.GetHash() == coinbaseIt->first);\n+                    duplicateids.insert(coinbaseIt->first);\n+                }\n+                else {\n+                    coinbaseids[tx.GetHash()] = tx.vout[0].nValue;\n+                }\n+                assert(CTransaction(tx).IsCoinBase());\n+            }\n+            // 9/10 times create a regular tx\n+            else {\n+                uint256 prevouthash;\n+                // equally likely to spend coinbase or non coinbase\n+                std::set<uint256>::iterator txIt = alltxids.lower_bound(GetRandHash());\n+                if (txIt == alltxids.end()) {\n+                    txIt = alltxids.begin();\n+                }\n+                prevouthash = *txIt;\n+\n+                // Construct the tx to spend the coins of prevouthash\n+                tx.vin[0].prevout.hash = prevouthash;\n+                tx.vin[0].prevout.n = 0;\n+\n+                // Update the expected result of prevouthash to know these coins are spent\n+                CCoins& oldcoins = result[prevouthash];\n+                oldcoins.Clear();\n+\n+                // It is of particular importance here that once we spend a coinbase tx hash\n+                // it is no longer available to be duplicated (or spent again)\n+                // BIP 34 in conjunction with enforcing BIP 30 (at least until BIP 34 was active)\n+                // results in the fact that no coinbases were duplicated after they were already spent\n+                alltxids.erase(prevouthash);\n+                coinbaseids.erase(prevouthash);\n+\n+                // The test is designed to ensure spending a duplicate coinbase will work properly\n+                // if that ever happens and not resurrect the previously overwritten coinbase\n+                if (duplicateids.count(prevouthash))\n+                    spent_a_duplicate_coinbase = true;\n+\n+                assert(!CTransaction(tx).IsCoinBase());\n+            }\n+            // Track this tx to possibly spend later\n+            alltxids.insert(tx.GetHash());\n+\n+            // Update the expected result to know about the new output coins\n+            CCoins &coins = result[tx.GetHash()];\n+            coins.FromTx(tx, height);\n+\n+            CValidationState dummy;\n+            UpdateCoins(tx, dummy, *(stack.back()), height);\n+        }\n+\n+        // Once every 1000 iterations and at the end, verify the full cache.\n+        if (insecure_rand() % 1000 == 1 || i == NUM_SIMULATION_ITERATIONS - 1) {\n+            for (std::map<uint256, CCoins>::iterator it = result.begin(); it != result.end(); it++) {\n+                const CCoins* coins = stack.back()->AccessCoins(it->first);\n+                if (coins) {\n+                    BOOST_CHECK(*coins == it->second);\n+                 } else {\n+                    BOOST_CHECK(it->second.IsPruned());\n+                 }\n+            }\n+        }\n+\n+        if (insecure_rand() % 100 == 0) {\n+            // Every 100 iterations, change the cache stack.",
    "path": "src/test/coins_tests.cpp",
    "position": 141,
    "original_position": 141,
    "commit_id": "1cf3dd80a614fddbafac387e446fd83d118e0c25",
    "original_commit_id": "1cf3dd80a614fddbafac387e446fd83d118e0c25",
    "user": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "If the purpose is to do this every 100 iterations, why use random?\nEither the comment or the code is wrong :)\n",
    "created_at": "2015-11-13T12:39:37Z",
    "updated_at": "2015-11-13T12:39:37Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/6932#discussion_r44777833",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/6932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44777833"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/6932#discussion_r44777833"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/6932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44777833/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 308,
    "original_line": 308,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44778108",
    "pull_request_review_id": null,
    "id": 44778108,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4MTA4",
    "diff_hunk": "@@ -197,4 +202,133 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n     BOOST_CHECK(missed_an_entry);\n }\n \n+// This test is similar to the previous test\n+// except the emphasis is on testing the functionality of UpdateCoins\n+// random txs are created and UpdateCoins is used to update the cache stack\n+// In particular it is tested that spending a duplicate coinbase tx\n+// has the expected effect (the other duplicate is overwitten at all cache levels)\n+BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n+{\n+    bool spent_a_duplicate_coinbase = false;\n+    // A simple map to track what we expect the cache stack to represent.\n+    std::map<uint256, CCoins> result;\n+\n+    // The cache stack.\n+    CCoinsViewTest base; // A CCoinsViewTest at the bottom.\n+    std::vector<CCoinsViewCacheTest*> stack; // A stack of CCoinsViewCaches on top.\n+    stack.push_back(new CCoinsViewCacheTest(&base)); // Start with one cache.\n+\n+    // Track the txids we've used and whether they have been spent or not\n+    std::map<uint256, CAmount> coinbaseids;\n+    std::set<uint256> alltxids;\n+    std::set<uint256> duplicateids;\n+\n+    for (unsigned int i = 0; i < NUM_SIMULATION_ITERATIONS; i++) {\n+        {\n+            CMutableTransaction tx;\n+            tx.vin.resize(1);\n+            tx.vout.resize(1);\n+            tx.vout[0].nValue = i; //Keep txs unique unless intended to duplicate\n+            unsigned int height = insecure_rand();\n+\n+            // 1/10 times create a coinbase\n+            if (insecure_rand() % 10 == 0 || coinbaseids.size() < 10) {\n+                // 1/100 times create a duplicate coinbase\n+                if (insecure_rand() % 10 == 0 && coinbaseids.size()) {\n+                    std::map<uint256, CAmount>::iterator coinbaseIt = coinbaseids.lower_bound(GetRandHash());\n+                    if (coinbaseIt == coinbaseids.end()) {\n+                        coinbaseIt = coinbaseids.begin();\n+                    }\n+                    //Use same random value to have same hash and be a true duplicate\n+                    tx.vout[0].nValue = coinbaseIt->second;\n+                    assert(tx.GetHash() == coinbaseIt->first);\n+                    duplicateids.insert(coinbaseIt->first);\n+                }\n+                else {\n+                    coinbaseids[tx.GetHash()] = tx.vout[0].nValue;\n+                }\n+                assert(CTransaction(tx).IsCoinBase());\n+            }\n+            // 9/10 times create a regular tx\n+            else {\n+                uint256 prevouthash;\n+                // equally likely to spend coinbase or non coinbase\n+                std::set<uint256>::iterator txIt = alltxids.lower_bound(GetRandHash());\n+                if (txIt == alltxids.end()) {\n+                    txIt = alltxids.begin();\n+                }\n+                prevouthash = *txIt;\n+\n+                // Construct the tx to spend the coins of prevouthash\n+                tx.vin[0].prevout.hash = prevouthash;\n+                tx.vin[0].prevout.n = 0;\n+\n+                // Update the expected result of prevouthash to know these coins are spent\n+                CCoins& oldcoins = result[prevouthash];\n+                oldcoins.Clear();\n+\n+                // It is of particular importance here that once we spend a coinbase tx hash\n+                // it is no longer available to be duplicated (or spent again)\n+                // BIP 34 in conjunction with enforcing BIP 30 (at least until BIP 34 was active)\n+                // results in the fact that no coinbases were duplicated after they were already spent\n+                alltxids.erase(prevouthash);\n+                coinbaseids.erase(prevouthash);\n+\n+                // The test is designed to ensure spending a duplicate coinbase will work properly\n+                // if that ever happens and not resurrect the previously overwritten coinbase\n+                if (duplicateids.count(prevouthash))\n+                    spent_a_duplicate_coinbase = true;\n+\n+                assert(!CTransaction(tx).IsCoinBase());\n+            }\n+            // Track this tx to possibly spend later\n+            alltxids.insert(tx.GetHash());\n+\n+            // Update the expected result to know about the new output coins\n+            CCoins &coins = result[tx.GetHash()];\n+            coins.FromTx(tx, height);\n+\n+            CValidationState dummy;\n+            UpdateCoins(tx, dummy, *(stack.back()), height);\n+        }\n+\n+        // Once every 1000 iterations and at the end, verify the full cache.\n+        if (insecure_rand() % 1000 == 1 || i == NUM_SIMULATION_ITERATIONS - 1) {\n+            for (std::map<uint256, CCoins>::iterator it = result.begin(); it != result.end(); it++) {\n+                const CCoins* coins = stack.back()->AccessCoins(it->first);\n+                if (coins) {\n+                    BOOST_CHECK(*coins == it->second);\n+                 } else {\n+                    BOOST_CHECK(it->second.IsPruned());\n+                 }\n+            }\n+        }\n+\n+        if (insecure_rand() % 100 == 0) {\n+            // Every 100 iterations, change the cache stack.",
    "path": "src/test/coins_tests.cpp",
    "position": 141,
    "original_position": 141,
    "commit_id": "1cf3dd80a614fddbafac387e446fd83d118e0c25",
    "original_commit_id": "1cf3dd80a614fddbafac387e446fd83d118e0c25",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "It's copied from the test above that I wrote. It's intended to be random, so the comment is wrong :)\n",
    "created_at": "2015-11-13T12:43:07Z",
    "updated_at": "2015-11-13T12:43:22Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/6932#discussion_r44778108",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/6932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44778108"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/6932#discussion_r44778108"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/6932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44778108/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 308,
    "original_line": 308,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44779703",
    "pull_request_review_id": null,
    "id": 44779703,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5NzAz",
    "diff_hunk": "@@ -197,4 +202,133 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n     BOOST_CHECK(missed_an_entry);\n }\n \n+// This test is similar to the previous test\n+// except the emphasis is on testing the functionality of UpdateCoins\n+// random txs are created and UpdateCoins is used to update the cache stack\n+// In particular it is tested that spending a duplicate coinbase tx\n+// has the expected effect (the other duplicate is overwitten at all cache levels)\n+BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n+{\n+    bool spent_a_duplicate_coinbase = false;\n+    // A simple map to track what we expect the cache stack to represent.\n+    std::map<uint256, CCoins> result;\n+\n+    // The cache stack.\n+    CCoinsViewTest base; // A CCoinsViewTest at the bottom.\n+    std::vector<CCoinsViewCacheTest*> stack; // A stack of CCoinsViewCaches on top.\n+    stack.push_back(new CCoinsViewCacheTest(&base)); // Start with one cache.\n+\n+    // Track the txids we've used and whether they have been spent or not\n+    std::map<uint256, CAmount> coinbaseids;\n+    std::set<uint256> alltxids;\n+    std::set<uint256> duplicateids;\n+\n+    for (unsigned int i = 0; i < NUM_SIMULATION_ITERATIONS; i++) {\n+        {\n+            CMutableTransaction tx;\n+            tx.vin.resize(1);\n+            tx.vout.resize(1);\n+            tx.vout[0].nValue = i; //Keep txs unique unless intended to duplicate\n+            unsigned int height = insecure_rand();\n+\n+            // 1/10 times create a coinbase\n+            if (insecure_rand() % 10 == 0 || coinbaseids.size() < 10) {\n+                // 1/100 times create a duplicate coinbase\n+                if (insecure_rand() % 10 == 0 && coinbaseids.size()) {\n+                    std::map<uint256, CAmount>::iterator coinbaseIt = coinbaseids.lower_bound(GetRandHash());\n+                    if (coinbaseIt == coinbaseids.end()) {\n+                        coinbaseIt = coinbaseids.begin();\n+                    }\n+                    //Use same random value to have same hash and be a true duplicate\n+                    tx.vout[0].nValue = coinbaseIt->second;\n+                    assert(tx.GetHash() == coinbaseIt->first);\n+                    duplicateids.insert(coinbaseIt->first);\n+                }\n+                else {\n+                    coinbaseids[tx.GetHash()] = tx.vout[0].nValue;\n+                }\n+                assert(CTransaction(tx).IsCoinBase());\n+            }\n+            // 9/10 times create a regular tx\n+            else {\n+                uint256 prevouthash;\n+                // equally likely to spend coinbase or non coinbase\n+                std::set<uint256>::iterator txIt = alltxids.lower_bound(GetRandHash());\n+                if (txIt == alltxids.end()) {\n+                    txIt = alltxids.begin();\n+                }\n+                prevouthash = *txIt;\n+\n+                // Construct the tx to spend the coins of prevouthash\n+                tx.vin[0].prevout.hash = prevouthash;\n+                tx.vin[0].prevout.n = 0;\n+\n+                // Update the expected result of prevouthash to know these coins are spent\n+                CCoins& oldcoins = result[prevouthash];\n+                oldcoins.Clear();\n+\n+                // It is of particular importance here that once we spend a coinbase tx hash\n+                // it is no longer available to be duplicated (or spent again)\n+                // BIP 34 in conjunction with enforcing BIP 30 (at least until BIP 34 was active)\n+                // results in the fact that no coinbases were duplicated after they were already spent\n+                alltxids.erase(prevouthash);\n+                coinbaseids.erase(prevouthash);\n+\n+                // The test is designed to ensure spending a duplicate coinbase will work properly\n+                // if that ever happens and not resurrect the previously overwritten coinbase\n+                if (duplicateids.count(prevouthash))\n+                    spent_a_duplicate_coinbase = true;\n+\n+                assert(!CTransaction(tx).IsCoinBase());\n+            }\n+            // Track this tx to possibly spend later\n+            alltxids.insert(tx.GetHash());\n+\n+            // Update the expected result to know about the new output coins\n+            CCoins &coins = result[tx.GetHash()];\n+            coins.FromTx(tx, height);\n+\n+            CValidationState dummy;\n+            UpdateCoins(tx, dummy, *(stack.back()), height);\n+        }\n+\n+        // Once every 1000 iterations and at the end, verify the full cache.\n+        if (insecure_rand() % 1000 == 1 || i == NUM_SIMULATION_ITERATIONS - 1) {\n+            for (std::map<uint256, CCoins>::iterator it = result.begin(); it != result.end(); it++) {\n+                const CCoins* coins = stack.back()->AccessCoins(it->first);\n+                if (coins) {\n+                    BOOST_CHECK(*coins == it->second);\n+                 } else {\n+                    BOOST_CHECK(it->second.IsPruned());\n+                 }\n+            }\n+        }\n+\n+        if (insecure_rand() % 100 == 0) {\n+            // Every 100 iterations, change the cache stack.\n+            if (stack.size() > 0 && insecure_rand() % 2 == 0) {\n+                stack.back()->Flush();\n+                delete stack.back();",
    "path": "src/test/coins_tests.cpp",
    "position": 144,
    "original_position": 144,
    "commit_id": "1cf3dd80a614fddbafac387e446fd83d118e0c25",
    "original_commit_id": "1cf3dd80a614fddbafac387e446fd83d118e0c25",
    "user": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "If this was in production code I'd prefer to use a RAII pointer type (such as boost::shared_ptr) inside stack instead of explicit delete, because of exception safety and memory leaks.\nAs it is just the tests, mehh.\n",
    "created_at": "2015-11-13T13:04:37Z",
    "updated_at": "2015-11-13T13:04:37Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/6932#discussion_r44779703",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/6932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44779703"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/6932#discussion_r44779703"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/6932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44779703/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 311,
    "original_line": 311,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44779920",
    "pull_request_review_id": null,
    "id": 44779920,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5OTIw",
    "diff_hunk": "@@ -197,4 +202,133 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n     BOOST_CHECK(missed_an_entry);\n }\n \n+// This test is similar to the previous test\n+// except the emphasis is on testing the functionality of UpdateCoins\n+// random txs are created and UpdateCoins is used to update the cache stack\n+// In particular it is tested that spending a duplicate coinbase tx\n+// has the expected effect (the other duplicate is overwitten at all cache levels)\n+BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n+{\n+    bool spent_a_duplicate_coinbase = false;\n+    // A simple map to track what we expect the cache stack to represent.\n+    std::map<uint256, CCoins> result;\n+\n+    // The cache stack.\n+    CCoinsViewTest base; // A CCoinsViewTest at the bottom.\n+    std::vector<CCoinsViewCacheTest*> stack; // A stack of CCoinsViewCaches on top.\n+    stack.push_back(new CCoinsViewCacheTest(&base)); // Start with one cache.\n+\n+    // Track the txids we've used and whether they have been spent or not\n+    std::map<uint256, CAmount> coinbaseids;\n+    std::set<uint256> alltxids;\n+    std::set<uint256> duplicateids;\n+\n+    for (unsigned int i = 0; i < NUM_SIMULATION_ITERATIONS; i++) {\n+        {\n+            CMutableTransaction tx;\n+            tx.vin.resize(1);\n+            tx.vout.resize(1);\n+            tx.vout[0].nValue = i; //Keep txs unique unless intended to duplicate\n+            unsigned int height = insecure_rand();\n+\n+            // 1/10 times create a coinbase\n+            if (insecure_rand() % 10 == 0 || coinbaseids.size() < 10) {\n+                // 1/100 times create a duplicate coinbase\n+                if (insecure_rand() % 10 == 0 && coinbaseids.size()) {\n+                    std::map<uint256, CAmount>::iterator coinbaseIt = coinbaseids.lower_bound(GetRandHash());\n+                    if (coinbaseIt == coinbaseids.end()) {\n+                        coinbaseIt = coinbaseids.begin();\n+                    }\n+                    //Use same random value to have same hash and be a true duplicate\n+                    tx.vout[0].nValue = coinbaseIt->second;\n+                    assert(tx.GetHash() == coinbaseIt->first);\n+                    duplicateids.insert(coinbaseIt->first);\n+                }\n+                else {\n+                    coinbaseids[tx.GetHash()] = tx.vout[0].nValue;\n+                }\n+                assert(CTransaction(tx).IsCoinBase());\n+            }\n+            // 9/10 times create a regular tx\n+            else {\n+                uint256 prevouthash;\n+                // equally likely to spend coinbase or non coinbase\n+                std::set<uint256>::iterator txIt = alltxids.lower_bound(GetRandHash());\n+                if (txIt == alltxids.end()) {\n+                    txIt = alltxids.begin();\n+                }\n+                prevouthash = *txIt;\n+\n+                // Construct the tx to spend the coins of prevouthash\n+                tx.vin[0].prevout.hash = prevouthash;\n+                tx.vin[0].prevout.n = 0;\n+\n+                // Update the expected result of prevouthash to know these coins are spent\n+                CCoins& oldcoins = result[prevouthash];\n+                oldcoins.Clear();\n+\n+                // It is of particular importance here that once we spend a coinbase tx hash\n+                // it is no longer available to be duplicated (or spent again)\n+                // BIP 34 in conjunction with enforcing BIP 30 (at least until BIP 34 was active)\n+                // results in the fact that no coinbases were duplicated after they were already spent\n+                alltxids.erase(prevouthash);\n+                coinbaseids.erase(prevouthash);\n+\n+                // The test is designed to ensure spending a duplicate coinbase will work properly\n+                // if that ever happens and not resurrect the previously overwritten coinbase\n+                if (duplicateids.count(prevouthash))\n+                    spent_a_duplicate_coinbase = true;\n+\n+                assert(!CTransaction(tx).IsCoinBase());\n+            }\n+            // Track this tx to possibly spend later\n+            alltxids.insert(tx.GetHash());\n+\n+            // Update the expected result to know about the new output coins\n+            CCoins &coins = result[tx.GetHash()];\n+            coins.FromTx(tx, height);\n+\n+            CValidationState dummy;\n+            UpdateCoins(tx, dummy, *(stack.back()), height);\n+        }\n+\n+        // Once every 1000 iterations and at the end, verify the full cache.\n+        if (insecure_rand() % 1000 == 1 || i == NUM_SIMULATION_ITERATIONS - 1) {\n+            for (std::map<uint256, CCoins>::iterator it = result.begin(); it != result.end(); it++) {\n+                const CCoins* coins = stack.back()->AccessCoins(it->first);\n+                if (coins) {\n+                    BOOST_CHECK(*coins == it->second);\n+                 } else {\n+                    BOOST_CHECK(it->second.IsPruned());\n+                 }\n+            }\n+        }\n+\n+        if (insecure_rand() % 100 == 0) {\n+            // Every 100 iterations, change the cache stack.\n+            if (stack.size() > 0 && insecure_rand() % 2 == 0) {\n+                stack.back()->Flush();\n+                delete stack.back();",
    "path": "src/test/coins_tests.cpp",
    "position": 144,
    "original_position": 144,
    "commit_id": "1cf3dd80a614fddbafac387e446fd83d118e0c25",
    "original_commit_id": "1cf3dd80a614fddbafac387e446fd83d118e0c25",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I believe I originally tried using boost::unique_ptr, but you can't use\nthat inside stl containers.\n",
    "created_at": "2015-11-13T13:06:47Z",
    "updated_at": "2015-11-13T13:06:47Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/6932#discussion_r44779920",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/6932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44779920"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/6932#discussion_r44779920"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/6932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44779920/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 311,
    "original_line": 311,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44780905",
    "pull_request_review_id": null,
    "id": 44780905,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwOTA1",
    "diff_hunk": "@@ -197,4 +202,133 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n     BOOST_CHECK(missed_an_entry);\n }\n \n+// This test is similar to the previous test\n+// except the emphasis is on testing the functionality of UpdateCoins\n+// random txs are created and UpdateCoins is used to update the cache stack\n+// In particular it is tested that spending a duplicate coinbase tx\n+// has the expected effect (the other duplicate is overwitten at all cache levels)\n+BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n+{\n+    bool spent_a_duplicate_coinbase = false;\n+    // A simple map to track what we expect the cache stack to represent.\n+    std::map<uint256, CCoins> result;\n+\n+    // The cache stack.\n+    CCoinsViewTest base; // A CCoinsViewTest at the bottom.\n+    std::vector<CCoinsViewCacheTest*> stack; // A stack of CCoinsViewCaches on top.\n+    stack.push_back(new CCoinsViewCacheTest(&base)); // Start with one cache.\n+\n+    // Track the txids we've used and whether they have been spent or not\n+    std::map<uint256, CAmount> coinbaseids;\n+    std::set<uint256> alltxids;\n+    std::set<uint256> duplicateids;\n+\n+    for (unsigned int i = 0; i < NUM_SIMULATION_ITERATIONS; i++) {\n+        {\n+            CMutableTransaction tx;\n+            tx.vin.resize(1);\n+            tx.vout.resize(1);\n+            tx.vout[0].nValue = i; //Keep txs unique unless intended to duplicate\n+            unsigned int height = insecure_rand();\n+\n+            // 1/10 times create a coinbase\n+            if (insecure_rand() % 10 == 0 || coinbaseids.size() < 10) {\n+                // 1/100 times create a duplicate coinbase\n+                if (insecure_rand() % 10 == 0 && coinbaseids.size()) {\n+                    std::map<uint256, CAmount>::iterator coinbaseIt = coinbaseids.lower_bound(GetRandHash());\n+                    if (coinbaseIt == coinbaseids.end()) {\n+                        coinbaseIt = coinbaseids.begin();\n+                    }\n+                    //Use same random value to have same hash and be a true duplicate\n+                    tx.vout[0].nValue = coinbaseIt->second;\n+                    assert(tx.GetHash() == coinbaseIt->first);\n+                    duplicateids.insert(coinbaseIt->first);\n+                }\n+                else {\n+                    coinbaseids[tx.GetHash()] = tx.vout[0].nValue;\n+                }\n+                assert(CTransaction(tx).IsCoinBase());\n+            }\n+            // 9/10 times create a regular tx\n+            else {\n+                uint256 prevouthash;\n+                // equally likely to spend coinbase or non coinbase\n+                std::set<uint256>::iterator txIt = alltxids.lower_bound(GetRandHash());\n+                if (txIt == alltxids.end()) {\n+                    txIt = alltxids.begin();\n+                }\n+                prevouthash = *txIt;\n+\n+                // Construct the tx to spend the coins of prevouthash\n+                tx.vin[0].prevout.hash = prevouthash;\n+                tx.vin[0].prevout.n = 0;\n+\n+                // Update the expected result of prevouthash to know these coins are spent\n+                CCoins& oldcoins = result[prevouthash];\n+                oldcoins.Clear();\n+\n+                // It is of particular importance here that once we spend a coinbase tx hash\n+                // it is no longer available to be duplicated (or spent again)\n+                // BIP 34 in conjunction with enforcing BIP 30 (at least until BIP 34 was active)\n+                // results in the fact that no coinbases were duplicated after they were already spent\n+                alltxids.erase(prevouthash);\n+                coinbaseids.erase(prevouthash);\n+\n+                // The test is designed to ensure spending a duplicate coinbase will work properly\n+                // if that ever happens and not resurrect the previously overwritten coinbase\n+                if (duplicateids.count(prevouthash))\n+                    spent_a_duplicate_coinbase = true;\n+\n+                assert(!CTransaction(tx).IsCoinBase());\n+            }\n+            // Track this tx to possibly spend later\n+            alltxids.insert(tx.GetHash());\n+\n+            // Update the expected result to know about the new output coins\n+            CCoins &coins = result[tx.GetHash()];\n+            coins.FromTx(tx, height);\n+\n+            CValidationState dummy;\n+            UpdateCoins(tx, dummy, *(stack.back()), height);\n+        }\n+\n+        // Once every 1000 iterations and at the end, verify the full cache.\n+        if (insecure_rand() % 1000 == 1 || i == NUM_SIMULATION_ITERATIONS - 1) {\n+            for (std::map<uint256, CCoins>::iterator it = result.begin(); it != result.end(); it++) {\n+                const CCoins* coins = stack.back()->AccessCoins(it->first);\n+                if (coins) {\n+                    BOOST_CHECK(*coins == it->second);\n+                 } else {\n+                    BOOST_CHECK(it->second.IsPruned());\n+                 }\n+            }\n+        }\n+\n+        if (insecure_rand() % 100 == 0) {\n+            // Every 100 iterations, change the cache stack.\n+            if (stack.size() > 0 && insecure_rand() % 2 == 0) {\n+                stack.back()->Flush();\n+                delete stack.back();",
    "path": "src/test/coins_tests.cpp",
    "position": 144,
    "original_position": 144,
    "commit_id": "1cf3dd80a614fddbafac387e446fd83d118e0c25",
    "original_commit_id": "1cf3dd80a614fddbafac387e446fd83d118e0c25",
    "user": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Right - I think shared_ptr is the only boost pointer you can use inside containers.\n\nEdit: with **c++11** unique_ptr it should be possible, though, I guess we can change it by then :)\n",
    "created_at": "2015-11-13T13:19:09Z",
    "updated_at": "2015-11-13T13:29:39Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/6932#discussion_r44780905",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/6932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44780905"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/6932#discussion_r44780905"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/6932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44780905/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 311,
    "original_line": 311,
    "side": "RIGHT"
  }
]