[
  {
    "sha": "c80de7834ad59fba93548024fc96f541f02b60f7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjODBkZTc4MzRhZDU5ZmJhOTM1NDgwMjRmYzk2ZjU0MWYwMmI2MGY3",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2020-12-16T19:00:18Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2020-12-16T19:06:04Z"
      },
      "message": "Replace m_tx_relay/nullptr checks in net_processing.cpp\n\nSemantically, whether m_tx_relay is a nullptr can mean that either the\nconnection is a block-relay-only connection, or that we're relaying\ntransactions on this connection. While there's currently a 1-1 mapping between\nthose ideas right now, separate the two concepts more clearly so that in the\nfuture it'll be easier to reason about changes, particularly if we add more\nconnection types which do not relay transactions.",
      "tree": {
        "sha": "f0ad6bb9fee40bd1af04ebfa7af28befec65cabe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f0ad6bb9fee40bd1af04ebfa7af28befec65cabe"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c80de7834ad59fba93548024fc96f541f02b60f7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c80de7834ad59fba93548024fc96f541f02b60f7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c80de7834ad59fba93548024fc96f541f02b60f7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c80de7834ad59fba93548024fc96f541f02b60f7/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5b6f970e3fda20733b3567677d9723f3cd5840c6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5b6f970e3fda20733b3567677d9723f3cd5840c6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5b6f970e3fda20733b3567677d9723f3cd5840c6"
      }
    ],
    "stats": {
      "total": 38,
      "additions": 24,
      "deletions": 14
    },
    "files": [
      {
        "sha": "fdde6247fedf42edaca95628b6716d46e7f1fc32",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c80de7834ad59fba93548024fc96f541f02b60f7/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c80de7834ad59fba93548024fc96f541f02b60f7/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=c80de7834ad59fba93548024fc96f541f02b60f7",
        "patch": "@@ -961,6 +961,16 @@ class CNode\n         return m_conn_type != ConnectionType::BLOCK_RELAY;\n     }\n \n+    /* Whether we relay transactions over this connection */\n+    bool RelayTxsWithConn() const\n+    {\n+        // This should be exactly the set of non-block-relay-only peers, but\n+        // implement by checking whether m_tx_relay is set so that we can be\n+        // sure we'll never dereference a nullptr if calling code is using this\n+        // function to check whether tx relay is in fact allowed.\n+        return m_tx_relay != nullptr;\n+    }\n+\n     bool ExpectServicesFromConn() const {\n         switch (m_conn_type) {\n             case ConnectionType::INBOUND:"
      },
      {
        "sha": "dc5d0051218f6e8c4aab33d57bbc529e20dca255",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c80de7834ad59fba93548024fc96f541f02b60f7/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c80de7834ad59fba93548024fc96f541f02b60f7/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=c80de7834ad59fba93548024fc96f541f02b60f7",
        "patch": "@@ -700,7 +700,7 @@ void PeerManager::PushNodeVersion(CNode& pnode, int64_t nTime)\n     CAddress addrMe = CAddress(CService(), nLocalNodeServices);\n \n     m_connman.PushMessage(&pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERSION, PROTOCOL_VERSION, (uint64_t)nLocalNodeServices, nTime, addrYou, addrMe,\n-            nonce, strSubVersion, nNodeStartingHeight, !m_ignore_incoming_txs && pnode.m_tx_relay != nullptr));\n+            nonce, strSubVersion, nNodeStartingHeight, !m_ignore_incoming_txs && pnode.RelayTxsWithConn()));\n \n     if (fLogIPs) {\n         LogPrint(BCLog::NET, \"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%d\\n\", PROTOCOL_VERSION, nNodeStartingHeight, addrMe.ToString(), addrYou.ToString(), nodeid);\n@@ -1564,7 +1564,7 @@ void static ProcessGetBlockData(CNode& pfrom, const CChainParams& chainparams, c\n             } else if (inv.IsMsgFilteredBlk()) {\n                 bool sendMerkleBlock = false;\n                 CMerkleBlock merkleBlock;\n-                if (pfrom.m_tx_relay != nullptr) {\n+                if (pfrom.RelayTxsWithConn()) {\n                     LOCK(pfrom.m_tx_relay->cs_filter);\n                     if (pfrom.m_tx_relay->pfilter) {\n                         sendMerkleBlock = true;\n@@ -1657,7 +1657,7 @@ void static ProcessGetData(CNode& pfrom, Peer& peer, const CChainParams& chainpa\n \n     const std::chrono::seconds now = GetTime<std::chrono::seconds>();\n     // Get last mempool request time\n-    const std::chrono::seconds mempool_req = pfrom.m_tx_relay != nullptr ? pfrom.m_tx_relay->m_last_mempool_req.load()\n+    const std::chrono::seconds mempool_req = pfrom.RelayTxsWithConn() ? pfrom.m_tx_relay->m_last_mempool_req.load()\n                                                                           : std::chrono::seconds::min();\n \n     // Process as many TX items from the front of the getdata queue as\n@@ -1671,7 +1671,7 @@ void static ProcessGetData(CNode& pfrom, Peer& peer, const CChainParams& chainpa\n \n         const CInv &inv = *it++;\n \n-        if (pfrom.m_tx_relay == nullptr) {\n+        if (!pfrom.RelayTxsWithConn()) {\n             // Ignore GETDATA requests for transactions from blocks-only peers.\n             continue;\n         }\n@@ -2368,7 +2368,7 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n         // set nodes not capable of serving the complete blockchain history as \"limited nodes\"\n         pfrom.m_limited_node = (!(nServices & NODE_NETWORK) && (nServices & NODE_NETWORK_LIMITED));\n \n-        if (pfrom.m_tx_relay != nullptr) {\n+        if (pfrom.RelayTxsWithConn()) {\n             LOCK(pfrom.m_tx_relay->cs_filter);\n             pfrom.m_tx_relay->fRelayTxes = fRelay; // set to true after we get the first filter* message\n         }\n@@ -2644,7 +2644,7 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n \n         // We won't accept tx inv's if we're in blocks-only mode, or this is a\n         // block-relay-only peer\n-        bool fBlocksOnly = m_ignore_incoming_txs || (pfrom.m_tx_relay == nullptr);\n+        bool fBlocksOnly = m_ignore_incoming_txs || !pfrom.RelayTxsWithConn();\n \n         // Allow peers with relay permission to send data other than blocks in blocks only mode\n         if (pfrom.HasPermission(PF_RELAY)) {\n@@ -2921,7 +2921,7 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n         // Stop processing the transaction early if\n         // 1) We are in blocks only mode and peer has no relay permission\n         // 2) This peer is a block-relay-only peer\n-        if ((m_ignore_incoming_txs && !pfrom.HasPermission(PF_RELAY)) || (pfrom.m_tx_relay == nullptr))\n+        if ((m_ignore_incoming_txs && !pfrom.HasPermission(PF_RELAY)) || !pfrom.RelayTxsWithConn())\n         {\n             LogPrint(BCLog::NET, \"transaction sent in violation of protocol peer=%d\\n\", pfrom.GetId());\n             pfrom.fDisconnect = true;\n@@ -3552,7 +3552,7 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n             return;\n         }\n \n-        if (pfrom.m_tx_relay != nullptr) {\n+        if (pfrom.RelayTxsWithConn()) {\n             LOCK(pfrom.m_tx_relay->cs_tx_inventory);\n             pfrom.m_tx_relay->fSendMempool = true;\n         }\n@@ -3648,7 +3648,7 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n             // There is no excuse for sending a too-large filter\n             Misbehaving(pfrom.GetId(), 100, \"too-large bloom filter\");\n         }\n-        else if (pfrom.m_tx_relay != nullptr)\n+        else if (pfrom.RelayTxsWithConn())\n         {\n             LOCK(pfrom.m_tx_relay->cs_filter);\n             pfrom.m_tx_relay->pfilter.reset(new CBloomFilter(filter));\n@@ -3670,7 +3670,7 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n         bool bad = false;\n         if (vData.size() > MAX_SCRIPT_ELEMENT_SIZE) {\n             bad = true;\n-        } else if (pfrom.m_tx_relay != nullptr) {\n+        } else if (pfrom.RelayTxsWithConn()) {\n             LOCK(pfrom.m_tx_relay->cs_filter);\n             if (pfrom.m_tx_relay->pfilter) {\n                 pfrom.m_tx_relay->pfilter->insert(vData);\n@@ -3689,7 +3689,7 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n             pfrom.fDisconnect = true;\n             return;\n         }\n-        if (pfrom.m_tx_relay == nullptr) {\n+        if (!pfrom.RelayTxsWithConn()) {\n             return;\n         }\n         LOCK(pfrom.m_tx_relay->cs_filter);\n@@ -3702,7 +3702,7 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n         CAmount newFeeFilter = 0;\n         vRecv >> newFeeFilter;\n         if (MoneyRange(newFeeFilter)) {\n-            if (pfrom.m_tx_relay != nullptr) {\n+            if (pfrom.RelayTxsWithConn()) {\n                 LOCK(pfrom.m_tx_relay->cs_feeFilter);\n                 pfrom.m_tx_relay->minFeeFilter = newFeeFilter;\n             }\n@@ -4354,7 +4354,7 @@ bool PeerManager::SendMessages(CNode* pto)\n             }\n             pto->vInventoryBlockToSend.clear();\n \n-            if (pto->m_tx_relay != nullptr) {\n+            if (pto->RelayTxsWithConn()) {\n                 LOCK(pto->m_tx_relay->cs_tx_inventory);\n                 // Check whether periodic sends should happen\n                 bool fSendTrickle = pto->HasPermission(PF_NOBAN);\n@@ -4613,7 +4613,7 @@ bool PeerManager::SendMessages(CNode* pto)\n         //\n         // Message: feefilter\n         //\n-        if (pto->m_tx_relay != nullptr && pto->GetCommonVersion() >= FEEFILTER_VERSION && gArgs.GetBoolArg(\"-feefilter\", DEFAULT_FEEFILTER) &&\n+        if (pto->RelayTxsWithConn() && pto->GetCommonVersion() >= FEEFILTER_VERSION && gArgs.GetBoolArg(\"-feefilter\", DEFAULT_FEEFILTER) &&\n             !pto->HasPermission(PF_FORCERELAY) // peers with the forcerelay permission should not filter txs to us\n         ) {\n             CAmount currentFilter = m_mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFeePerK();"
      }
    ]
  }
]