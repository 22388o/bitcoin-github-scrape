[
  {
    "sha": "fdc2f15c6b821f8ac0936cd35272a37305801723",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZGMyZjE1YzZiODIxZjhhYzA5MzZjZDM1MjcyYTM3MzA1ODAxNzIz",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "j@rubin.io",
        "date": "2020-08-07T05:03:40Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "j@rubin.io",
        "date": "2020-08-11T17:05:06Z"
      },
      "message": "Refactor BlockMap to use an unordered_set instead of an unordered_map",
      "tree": {
        "sha": "d6371eb7a406160b25173777476d227cd42cd5d9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d6371eb7a406160b25173777476d227cd42cd5d9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fdc2f15c6b821f8ac0936cd35272a37305801723",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fdc2f15c6b821f8ac0936cd35272a37305801723",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fdc2f15c6b821f8ac0936cd35272a37305801723",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fdc2f15c6b821f8ac0936cd35272a37305801723/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "82127d27c9001eee3eb28df67ce2e6eace620423",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/82127d27c9001eee3eb28df67ce2e6eace620423",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/82127d27c9001eee3eb28df67ce2e6eace620423"
      }
    ],
    "stats": {
      "total": 176,
      "additions": 93,
      "deletions": 83
    },
    "files": [
      {
        "sha": "fd37bc71eb37f4a289e29fbfbc29fd619234f94a",
        "filename": "src/bench/rpc_blockchain.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fdc2f15c6b821f8ac0936cd35272a37305801723/src/bench/rpc_blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fdc2f15c6b821f8ac0936cd35272a37305801723/src/bench/rpc_blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/rpc_blockchain.cpp?ref=fdc2f15c6b821f8ac0936cd35272a37305801723",
        "patch": "@@ -21,8 +21,7 @@ static void BlockToJsonVerbose(benchmark::Bench& bench)\n     stream >> block;\n \n     CBlockIndex blockindex;\n-    const uint256 blockHash = block.GetHash();\n-    blockindex.phashBlock = &blockHash;\n+    blockindex.m_hash_block = block.GetHash();\n     blockindex.nBits = 403014710;\n \n     bench.run([&] {"
      },
      {
        "sha": "9eda3a6160a565b29cdfb27f447de9be77afb5fd",
        "filename": "src/chain.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fdc2f15c6b821f8ac0936cd35272a37305801723/src/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fdc2f15c6b821f8ac0936cd35272a37305801723/src/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.h?ref=fdc2f15c6b821f8ac0936cd35272a37305801723",
        "patch": "@@ -137,8 +137,8 @@ enum BlockStatus: uint32_t {\n class CBlockIndex\n {\n public:\n-    //! pointer to the hash of the block, if any. Memory is owned by this CBlockIndex\n-    const uint256* phashBlock{nullptr};\n+    //! hash of the block. m_hash_block.IsNull() if there is not yet a hash\n+    uint256 m_hash_block;\n \n     //! pointer to the index of the predecessor of this block\n     CBlockIndex* pprev{nullptr};\n@@ -230,9 +230,9 @@ class CBlockIndex\n         return block;\n     }\n \n-    uint256 GetBlockHash() const\n+    const uint256& GetBlockHash() const\n     {\n-        return *phashBlock;\n+        return m_hash_block;\n     }\n \n     /**"
      },
      {
        "sha": "7c37148c8312bc121dfca32ffc67bcb9b5ccb4ce",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fdc2f15c6b821f8ac0936cd35272a37305801723/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fdc2f15c6b821f8ac0936cd35272a37305801723/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=fdc2f15c6b821f8ac0936cd35272a37305801723",
        "patch": "@@ -1347,10 +1347,10 @@ static UniValue getchaintips(const JSONRPCRequest& request)\n     std::set<const CBlockIndex*> setOrphans;\n     std::set<const CBlockIndex*> setPrevs;\n \n-    for (const std::pair<const uint256, CBlockIndex*>& item : chainman.BlockIndex()) {\n-        if (!chainman.ActiveChain().Contains(item.second)) {\n-            setOrphans.insert(item.second);\n-            setPrevs.insert(item.second->pprev);\n+    for (CBlockIndex* pindex : chainman.BlockIndex()) {\n+        if (!chainman.ActiveChain().Contains(pindex)) {\n+            setOrphans.insert(pindex);\n+            setPrevs.insert(pindex->pprev);\n         }\n     }\n \n@@ -1368,7 +1368,7 @@ static UniValue getchaintips(const JSONRPCRequest& request)\n     for (const CBlockIndex* block : setTips) {\n         UniValue obj(UniValue::VOBJ);\n         obj.pushKV(\"height\", block->nHeight);\n-        obj.pushKV(\"hash\", block->phashBlock->GetHex());\n+        obj.pushKV(\"hash\", block->m_hash_block.GetHex());\n \n         const int branchLen = block->nHeight - chainman.ActiveChain().FindFork(block)->nHeight;\n         obj.pushKV(\"branchlen\", branchLen);"
      },
      {
        "sha": "7893536737d57cd99b40f817ebb915507e4d7c2c",
        "filename": "src/test/fuzz/chain.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fdc2f15c6b821f8ac0936cd35272a37305801723/src/test/fuzz/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fdc2f15c6b821f8ac0936cd35272a37305801723/src/test/fuzz/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/chain.cpp?ref=fdc2f15c6b821f8ac0936cd35272a37305801723",
        "patch": "@@ -19,8 +19,6 @@ void test_one_input(const std::vector<uint8_t>& buffer)\n         return;\n     }\n \n-    const uint256 zero{};\n-    disk_block_index->phashBlock = &zero;\n     (void)disk_block_index->GetBlockHash();\n     (void)disk_block_index->GetBlockPos();\n     (void)disk_block_index->GetBlockTime();\n@@ -59,7 +57,6 @@ void test_one_input(const std::vector<uint8_t>& buffer)\n     }\n \n     CBlockIndex block_index{block_header};\n-    block_index.phashBlock = &zero;\n     (void)block_index.GetBlockHash();\n     (void)block_index.ToString();\n }"
      },
      {
        "sha": "9f41a6642cb3807c4cfeefc4cd3a1251ad86bcd0",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fdc2f15c6b821f8ac0936cd35272a37305801723/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fdc2f15c6b821f8ac0936cd35272a37305801723/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=fdc2f15c6b821f8ac0936cd35272a37305801723",
        "patch": "@@ -377,7 +377,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     while (::ChainActive().Tip()->nHeight < 209999) {\n         CBlockIndex* prev = ::ChainActive().Tip();\n         CBlockIndex* next = new CBlockIndex();\n-        next->phashBlock = new uint256(InsecureRand256());\n+        next->m_hash_block = uint256(InsecureRand256());\n         ::ChainstateActive().CoinsTip().SetBestBlock(next->GetBlockHash());\n         next->pprev = prev;\n         next->nHeight = prev->nHeight + 1;\n@@ -389,7 +389,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     while (::ChainActive().Tip()->nHeight < 210000) {\n         CBlockIndex* prev = ::ChainActive().Tip();\n         CBlockIndex* next = new CBlockIndex();\n-        next->phashBlock = new uint256(InsecureRand256());\n+        next->m_hash_block = uint256(InsecureRand256());\n         ::ChainstateActive().CoinsTip().SetBestBlock(next->GetBlockHash());\n         next->pprev = prev;\n         next->nHeight = prev->nHeight + 1;\n@@ -421,7 +421,6 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         CBlockIndex* del = ::ChainActive().Tip();\n         ::ChainActive().SetTip(del->pprev);\n         ::ChainstateActive().CoinsTip().SetBestBlock(del->pprev->GetBlockHash());\n-        delete del->phashBlock;\n         delete del;\n     }\n "
      },
      {
        "sha": "ad86c288e2092b3ca849026bc55e033dc7f41874",
        "filename": "src/test/skiplist_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fdc2f15c6b821f8ac0936cd35272a37305801723/src/test/skiplist_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fdc2f15c6b821f8ac0936cd35272a37305801723/src/test/skiplist_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/skiplist_tests.cpp?ref=fdc2f15c6b821f8ac0936cd35272a37305801723",
        "patch": "@@ -51,7 +51,7 @@ BOOST_AUTO_TEST_CASE(getlocator_test)\n         vHashMain[i] = ArithToUint256(i); // Set the hash equal to the height, so we can quickly check the distances.\n         vBlocksMain[i].nHeight = i;\n         vBlocksMain[i].pprev = i ? &vBlocksMain[i - 1] : nullptr;\n-        vBlocksMain[i].phashBlock = &vHashMain[i];\n+        vBlocksMain[i].m_hash_block = vHashMain[i];\n         vBlocksMain[i].BuildSkip();\n         BOOST_CHECK_EQUAL((int)UintToArith256(vBlocksMain[i].GetBlockHash()).GetLow64(), vBlocksMain[i].nHeight);\n         BOOST_CHECK(vBlocksMain[i].pprev == nullptr || vBlocksMain[i].nHeight == vBlocksMain[i].pprev->nHeight + 1);\n@@ -64,7 +64,7 @@ BOOST_AUTO_TEST_CASE(getlocator_test)\n         vHashSide[i] = ArithToUint256(i + 50000 + (arith_uint256(1) << 128)); // Add 1<<128 to the hashes, so GetLow64() still returns the height.\n         vBlocksSide[i].nHeight = i + 50000;\n         vBlocksSide[i].pprev = i ? &vBlocksSide[i - 1] : (vBlocksMain.data()+49999);\n-        vBlocksSide[i].phashBlock = &vHashSide[i];\n+        vBlocksSide[i].m_hash_block = vHashSide[i];\n         vBlocksSide[i].BuildSkip();\n         BOOST_CHECK_EQUAL((int)UintToArith256(vBlocksSide[i].GetBlockHash()).GetLow64(), vBlocksSide[i].nHeight);\n         BOOST_CHECK(vBlocksSide[i].pprev == nullptr || vBlocksSide[i].nHeight == vBlocksSide[i].pprev->nHeight + 1);\n@@ -106,7 +106,7 @@ BOOST_AUTO_TEST_CASE(findearliestatleast_test)\n         vHashMain[i] = ArithToUint256(i); // Set the hash equal to the height\n         vBlocksMain[i].nHeight = i;\n         vBlocksMain[i].pprev = i ? &vBlocksMain[i - 1] : nullptr;\n-        vBlocksMain[i].phashBlock = &vHashMain[i];\n+        vBlocksMain[i].m_hash_block = vHashMain[i];\n         vBlocksMain[i].BuildSkip();\n         if (i < 10) {\n             vBlocksMain[i].nTime = i;"
      },
      {
        "sha": "1e54492a79b5be3d4d1776f126ba3246ee79883b",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 57,
        "deletions": 56,
        "changes": 113,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fdc2f15c6b821f8ac0936cd35272a37305801723/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fdc2f15c6b821f8ac0936cd35272a37305801723/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=fdc2f15c6b821f8ac0936cd35272a37305801723",
        "patch": "@@ -173,8 +173,9 @@ namespace {\n CBlockIndex* LookupBlockIndex(const uint256& hash)\n {\n     AssertLockHeld(cs_main);\n-    BlockMap::const_iterator it = g_chainman.BlockIndex().find(hash);\n-    return it == g_chainman.BlockIndex().end() ? nullptr : it->second;\n+    auto& idx = g_chainman.BlockIndex();\n+    BlockMap::const_iterator it = idx.find(idx.hash_function()(hash));\n+    return it == idx.end() ? nullptr : *it;\n }\n \n CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator)\n@@ -1345,14 +1346,14 @@ static void CheckForkWarningConditions() EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n         if (!GetfLargeWorkForkFound() && pindexBestForkBase)\n         {\n             std::string warning = std::string(\"'Warning: Large-work fork detected, forking after block \") +\n-                pindexBestForkBase->phashBlock->ToString() + std::string(\"'\");\n+                pindexBestForkBase->m_hash_block.ToString() + std::string(\"'\");\n             AlertNotify(warning);\n         }\n         if (pindexBestForkTip && pindexBestForkBase)\n         {\n             LogPrintf(\"%s: Warning: Large valid fork found\\n  forking the chain at height %d (%s)\\n  lasting to height %d (%s).\\nChain state database corruption likely.\\n\", __func__,\n-                   pindexBestForkBase->nHeight, pindexBestForkBase->phashBlock->ToString(),\n-                   pindexBestForkTip->nHeight, pindexBestForkTip->phashBlock->ToString());\n+                   pindexBestForkBase->nHeight, pindexBestForkBase->m_hash_block.ToString(),\n+                   pindexBestForkTip->nHeight, pindexBestForkTip->m_hash_block.ToString());\n             SetfLargeWorkForkFound(true);\n         }\n         else\n@@ -1875,8 +1876,8 @@ static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consens\n     // mainnet and testnet), so for simplicity, always leave P2SH\n     // on except for the one violating block.\n     if (consensusparams.BIP16Exception.IsNull() || // no bip16 exception on this chain\n-        pindex->phashBlock == nullptr || // this is a new candidate block, eg from TestBlockValidity()\n-        *pindex->phashBlock != consensusparams.BIP16Exception) // this block isn't the historical exception\n+        pindex->m_hash_block.IsNull() || // this is a new candidate block, eg from TestBlockValidity()\n+        pindex->m_hash_block != consensusparams.BIP16Exception) // this block isn't the historical exception\n     {\n         flags |= SCRIPT_VERIFY_P2SH;\n     }\n@@ -1929,7 +1930,7 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n {\n     AssertLockHeld(cs_main);\n     assert(pindex);\n-    assert(*pindex->phashBlock == block.GetHash());\n+    assert(pindex->m_hash_block == block.GetHash());\n     int64_t nTimeStart = GetTimeMicros();\n \n     // Check it again in case a previous version let a bad block in\n@@ -1976,9 +1977,10 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n         //  relative to a piece of software is an objective fact these defaults can be easily reviewed.\n         // This setting doesn't force the selection of any particular chain but makes validating some faster by\n         //  effectively caching the result of part of the verification.\n-        BlockMap::const_iterator  it = m_blockman.m_block_index.find(hashAssumeValid);\n+        //\n+        BlockMap::const_iterator  it = m_blockman.m_block_index.find(m_blockman.m_block_index.hash_function()(hashAssumeValid));\n         if (it != m_blockman.m_block_index.end()) {\n-            if (it->second->GetAncestor(pindex->nHeight) == pindex &&\n+            if ((*it)->GetAncestor(pindex->nHeight) == pindex &&\n                 pindexBestHeader->GetAncestor(pindex->nHeight) == pindex &&\n                 pindexBestHeader->nChainWork >= nMinimumChainWork) {\n                 // This block is a member of the assumed verified chain and an ancestor of the best header.\n@@ -2214,7 +2216,7 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n         setDirtyBlockIndex.insert(pindex);\n     }\n \n-    assert(pindex->phashBlock);\n+    assert(!pindex->m_hash_block.IsNull());\n     // add this block to the view's block chain\n     view.SetBestBlock(pindex->GetBlockHash());\n \n@@ -2995,8 +2997,7 @@ bool CChainState::InvalidateBlock(BlockValidationState& state, const CChainParam\n \n     {\n         LOCK(cs_main);\n-        for (const auto& entry : m_blockman.m_block_index) {\n-            CBlockIndex *candidate = entry.second;\n+        for (CBlockIndex* candidate : m_blockman.m_block_index) {\n             // We don't need to put anything in our active chain into the\n             // multimap, because those candidates will be found and considered\n             // as we disconnect.\n@@ -3093,8 +3094,8 @@ bool CChainState::InvalidateBlock(BlockValidationState& state, const CChainParam\n         // to setBlockIndexCandidates.\n         BlockMap::iterator it = m_blockman.m_block_index.begin();\n         while (it != m_blockman.m_block_index.end()) {\n-            if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->HaveTxsDownloaded() && !setBlockIndexCandidates.value_comp()(it->second, m_chain.Tip())) {\n-                setBlockIndexCandidates.insert(it->second);\n+            if ((*it)->IsValid(BLOCK_VALID_TRANSACTIONS) && (*it)->HaveTxsDownloaded() && !setBlockIndexCandidates.value_comp()(*it, m_chain.Tip())) {\n+                setBlockIndexCandidates.insert(*it);\n             }\n             it++;\n         }\n@@ -3121,17 +3122,18 @@ void CChainState::ResetBlockFailureFlags(CBlockIndex *pindex) {\n     // Remove the invalidity flag from this block and all its descendants.\n     BlockMap::iterator it = m_blockman.m_block_index.begin();\n     while (it != m_blockman.m_block_index.end()) {\n-        if (!it->second->IsValid() && it->second->GetAncestor(nHeight) == pindex) {\n-            it->second->nStatus &= ~BLOCK_FAILED_MASK;\n-            setDirtyBlockIndex.insert(it->second);\n-            if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->HaveTxsDownloaded() && setBlockIndexCandidates.value_comp()(m_chain.Tip(), it->second)) {\n-                setBlockIndexCandidates.insert(it->second);\n+        CBlockIndex& block = **it;\n+        if (!block.IsValid() && block.GetAncestor(nHeight) == pindex) {\n+            block.nStatus &= ~BLOCK_FAILED_MASK;\n+            setDirtyBlockIndex.insert(&block);\n+            if (block.IsValid(BLOCK_VALID_TRANSACTIONS) && block.HaveTxsDownloaded() && setBlockIndexCandidates.value_comp()(m_chain.Tip(), &block)) {\n+                setBlockIndexCandidates.insert(&block);\n             }\n-            if (it->second == pindexBestInvalid) {\n+            if (&block == pindexBestInvalid) {\n                 // Reset invalid block marker if it was pointing to one of those.\n                 pindexBestInvalid = nullptr;\n             }\n-            m_blockman.m_failed_blocks.erase(it->second);\n+            m_blockman.m_failed_blocks.erase(&block);\n         }\n         it++;\n     }\n@@ -3157,22 +3159,22 @@ CBlockIndex* BlockManager::AddToBlockIndex(const CBlockHeader& block)\n \n     // Check for duplicate\n     uint256 hash = block.GetHash();\n-    BlockMap::iterator it = m_block_index.find(hash);\n+    BlockMap::iterator it = m_block_index.find(m_block_index.hash_function()(hash));\n     if (it != m_block_index.end())\n-        return it->second;\n+        return *it;\n \n     // Construct new block index object\n     CBlockIndex* pindexNew = new CBlockIndex(block);\n     // We assign the sequence id to blocks only when the full data is available,\n     // to avoid miners withholding blocks but broadcasting headers, to get a\n     // competitive advantage.\n     pindexNew->nSequenceId = 0;\n-    BlockMap::iterator mi = m_block_index.insert(std::make_pair(hash, pindexNew)).first;\n-    pindexNew->phashBlock = &((*mi).first);\n-    BlockMap::iterator miPrev = m_block_index.find(block.hashPrevBlock);\n+    pindexNew->m_hash_block = hash;\n+    m_block_index.insert(pindexNew);\n+    BlockMap::iterator miPrev = m_block_index.find(m_block_index.hash_function()(block.hashPrevBlock));\n     if (miPrev != m_block_index.end())\n     {\n-        pindexNew->pprev = (*miPrev).second;\n+        pindexNew->pprev = *miPrev;\n         pindexNew->nHeight = pindexNew->pprev->nHeight + 1;\n         pindexNew->BuildSkip();\n     }\n@@ -3614,12 +3616,12 @@ bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, BlockValidationS\n     AssertLockHeld(cs_main);\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n-    BlockMap::iterator miSelf = m_block_index.find(hash);\n+    BlockMap::iterator miSelf = m_block_index.find(m_block_index.hash_function()(hash));\n     CBlockIndex *pindex = nullptr;\n     if (hash != chainparams.GetConsensus().hashGenesisBlock) {\n         if (miSelf != m_block_index.end()) {\n             // Block header is already known.\n-            pindex = miSelf->second;\n+            pindex = *miSelf;\n             if (ppindex)\n                 *ppindex = pindex;\n             if (pindex->nStatus & BLOCK_FAILED_MASK) {\n@@ -3636,12 +3638,12 @@ bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, BlockValidationS\n \n         // Get prev block index\n         CBlockIndex* pindexPrev = nullptr;\n-        BlockMap::iterator mi = m_block_index.find(block.hashPrevBlock);\n+        BlockMap::iterator mi = m_block_index.find(m_block_index.hash_function()(block.hashPrevBlock));\n         if (mi == m_block_index.end()) {\n             LogPrintf(\"ERROR: %s: prev block not found\\n\", __func__);\n             return state.Invalid(BlockValidationResult::BLOCK_MISSING_PREV, \"prev-blk-not-found\");\n         }\n-        pindexPrev = (*mi).second;\n+        pindexPrev = *mi;\n         if (pindexPrev->nStatus & BLOCK_FAILED_MASK) {\n             LogPrintf(\"ERROR: %s: prev block invalid\\n\", __func__);\n             return state.Invalid(BlockValidationResult::BLOCK_INVALID_PREV, \"bad-prevblk\");\n@@ -3871,7 +3873,7 @@ bool TestBlockValidity(BlockValidationState& state, const CChainParams& chainpar\n     CBlockIndex indexDummy(block);\n     indexDummy.pprev = pindexPrev;\n     indexDummy.nHeight = pindexPrev->nHeight + 1;\n-    indexDummy.phashBlock = &block_hash;\n+    indexDummy.m_hash_block = block_hash;\n \n     // NOTE: CheckBlockHeader is called by CheckBlock\n     if (!ContextualCheckBlockHeader(block, state, chainparams, pindexPrev, GetAdjustedTime()))\n@@ -3908,8 +3910,7 @@ void ChainstateManager::PruneOneBlockFile(const int fileNumber)\n     AssertLockHeld(cs_main);\n     LOCK(cs_LastBlockFile);\n \n-    for (const auto& entry : m_blockman.m_block_index) {\n-        CBlockIndex* pindex = entry.second;\n+    for (CBlockIndex* pindex : m_blockman.m_block_index) {\n         if (pindex->nFile == fileNumber) {\n             pindex->nStatus &= ~BLOCK_HAVE_DATA;\n             pindex->nStatus &= ~BLOCK_HAVE_UNDO;\n@@ -4084,14 +4085,14 @@ CBlockIndex * BlockManager::InsertBlockIndex(const uint256& hash)\n         return nullptr;\n \n     // Return existing\n-    BlockMap::iterator mi = m_block_index.find(hash);\n+    BlockMap::iterator mi = m_block_index.find(m_block_index.hash_function()(hash));\n     if (mi != m_block_index.end())\n-        return (*mi).second;\n+        return *mi;\n \n     // Create new\n     CBlockIndex* pindexNew = new CBlockIndex();\n-    mi = m_block_index.insert(std::make_pair(hash, pindexNew)).first;\n-    pindexNew->phashBlock = &((*mi).first);\n+    pindexNew->m_hash_block = hash;\n+    mi = m_block_index.insert(pindexNew).first;\n \n     return pindexNew;\n }\n@@ -4107,9 +4108,8 @@ bool BlockManager::LoadBlockIndex(\n     // Calculate nChainWork\n     std::vector<std::pair<int, CBlockIndex*> > vSortedByHeight;\n     vSortedByHeight.reserve(m_block_index.size());\n-    for (const std::pair<const uint256, CBlockIndex*>& item : m_block_index)\n+    for (CBlockIndex* pindex : m_block_index)\n     {\n-        CBlockIndex* pindex = item.second;\n         vSortedByHeight.push_back(std::make_pair(pindex->nHeight, pindex));\n     }\n     sort(vSortedByHeight.begin(), vSortedByHeight.end());\n@@ -4155,8 +4155,8 @@ void BlockManager::Unload() {\n     m_failed_blocks.clear();\n     m_blocks_unlinked.clear();\n \n-    for (const BlockMap::value_type& entry : m_block_index) {\n-        delete entry.second;\n+    for (CBlockIndex* pindex : m_block_index) {\n+        delete pindex;\n     }\n \n     m_block_index.clear();\n@@ -4190,8 +4190,7 @@ bool static LoadBlockIndexDB(ChainstateManager& chainman, const CChainParams& ch\n     // Check presence of blk files\n     LogPrintf(\"Checking all blk files are present...\\n\");\n     std::set<int> setBlkDataFiles;\n-    for (const std::pair<const uint256, CBlockIndex*>& item : chainman.BlockIndex()) {\n-        CBlockIndex* pindex = item.second;\n+    for (CBlockIndex* pindex : chainman.BlockIndex()) {\n         if (pindex->nStatus & BLOCK_HAVE_DATA) {\n             setBlkDataFiles.insert(pindex->nFile);\n         }\n@@ -4392,16 +4391,18 @@ bool CChainState::ReplayBlocks(const CChainParams& params)\n     const CBlockIndex* pindexNew;            // New tip during the interrupted flush.\n     const CBlockIndex* pindexFork = nullptr; // Latest block common to both the old and the new tip.\n \n-    if (m_blockman.m_block_index.count(hashHeads[0]) == 0) {\n+    auto mi = m_blockman.m_block_index.find(m_blockman.m_block_index.hash_function()(hashHeads[0]));\n+    if (mi == m_blockman.m_block_index.end()) {\n         return error(\"ReplayBlocks(): reorganization to unknown block requested\");\n     }\n-    pindexNew = m_blockman.m_block_index[hashHeads[0]];\n+    pindexNew = *mi;\n \n     if (!hashHeads[1].IsNull()) { // The old tip is allowed to be 0, indicating it's the first flush.\n-        if (m_blockman.m_block_index.count(hashHeads[1]) == 0) {\n+        auto mi2 = m_blockman.m_block_index.find(m_blockman.m_block_index.hash_function()(hashHeads[1]));\n+        if (mi2 == m_blockman.m_block_index.end()) {\n             return error(\"ReplayBlocks(): reorganization from unknown block requested\");\n         }\n-        pindexOld = m_blockman.m_block_index[hashHeads[1]];\n+        pindexOld = *mi2;\n         pindexFork = LastCommonAncestor(pindexOld, pindexNew);\n         assert(pindexFork != nullptr);\n     }\n@@ -4486,9 +4487,9 @@ bool CChainState::RewindBlockIndex(const CChainParams& params)\n     // blocks will be dealt with below (releasing cs_main in between).\n     {\n         LOCK(cs_main);\n-        for (const auto& entry : m_blockman.m_block_index) {\n-            if (IsWitnessEnabled(entry.second->pprev, params.GetConsensus()) && !(entry.second->nStatus & BLOCK_OPT_WITNESS) && !m_chain.Contains(entry.second)) {\n-                EraseBlockData(entry.second);\n+        for (CBlockIndex* pindex : m_blockman.m_block_index) {\n+            if (IsWitnessEnabled(pindex->pprev, params.GetConsensus()) && !(pindex->nStatus & BLOCK_OPT_WITNESS) && !m_chain.Contains(pindex)) {\n+                EraseBlockData(pindex);\n             }\n         }\n     }\n@@ -4636,7 +4637,7 @@ bool CChainState::LoadGenesisBlock(const CChainParams& chainparams)\n     // m_blockman.m_block_index. Note that we can't use m_chain here, since it is\n     // set based on the coins db, not the block index db, which is the only\n     // thing loaded at this point.\n-    if (m_blockman.m_block_index.count(chainparams.GenesisBlock().GetHash()))\n+    if (m_blockman.m_block_index.count(m_blockman.m_block_index.hash_function()(chainparams.GenesisBlock().GetHash())))\n         return true;\n \n     try {\n@@ -4795,8 +4796,8 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n \n     // Build forward-pointing map of the entire block tree.\n     std::multimap<CBlockIndex*,CBlockIndex*> forward;\n-    for (const std::pair<const uint256, CBlockIndex*>& entry : m_blockman.m_block_index) {\n-        forward.insert(std::make_pair(entry.second->pprev, entry.second));\n+    for (CBlockIndex* pindex : m_blockman.m_block_index) {\n+        forward.insert(std::make_pair(pindex->pprev, pindex));\n     }\n \n     assert(forward.size() == m_blockman.m_block_index.size());\n@@ -5216,7 +5217,7 @@ class CMainCleanup\n         // block headers\n         BlockMap::iterator it1 = g_chainman.BlockIndex().begin();\n         for (; it1 != g_chainman.BlockIndex().end(); it1++)\n-            delete (*it1).second;\n+            delete *it1;\n         g_chainman.BlockIndex().clear();\n     }\n };"
      },
      {
        "sha": "9835f68e166012d761a0bef0efe497386b4d3c61",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 16,
        "deletions": 2,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fdc2f15c6b821f8ac0936cd35272a37305801723/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fdc2f15c6b821f8ac0936cd35272a37305801723/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=fdc2f15c6b821f8ac0936cd35272a37305801723",
        "patch": "@@ -101,7 +101,21 @@ struct BlockHasher\n     // this used to call `GetCheapHash()` in uint256, which was later moved; the\n     // cheap hash function simply calls ReadLE64() however, so the end result is\n     // identical\n-    size_t operator()(const uint256& hash) const { return ReadLE64(hash.begin()); }\n+    mutable CBlockIndex mock;\n+    BlockHasher() : mock() {};\n+    size_t operator()(CBlockIndex* const& ptr) const { return ReadLE64(ptr->GetBlockHash().begin()); }\n+    // Helper for querying by hash\n+    // e.g., map.find(map.hash_function()(h))\n+    CBlockIndex* operator()(const uint256& hash) {\n+        mock.m_hash_block = hash;\n+        return &mock;\n+    }\n+};\n+\n+\n+struct BlockEqual\n+{\n+    bool operator()(CBlockIndex* const& ptr, CBlockIndex* const& ptr2) const { return ptr->GetBlockHash() == ptr2->GetBlockHash(); }\n };\n \n /** Current sync state passed to tip changed callbacks. */\n@@ -114,7 +128,7 @@ enum class SynchronizationState {\n extern RecursiveMutex cs_main;\n extern CBlockPolicyEstimator feeEstimator;\n extern CTxMemPool mempool;\n-typedef std::unordered_map<uint256, CBlockIndex*, BlockHasher> BlockMap;\n+typedef std::unordered_set<CBlockIndex*, BlockHasher, BlockEqual> BlockMap;\n extern Mutex g_best_block_mutex;\n extern std::condition_variable g_best_block_cv;\n extern uint256 g_best_block;"
      },
      {
        "sha": "4fea95852f05e3a917ac5ca056851f85dba8ab3b",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fdc2f15c6b821f8ac0936cd35272a37305801723/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fdc2f15c6b821f8ac0936cd35272a37305801723/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=fdc2f15c6b821f8ac0936cd35272a37305801723",
        "patch": "@@ -347,13 +347,13 @@ static int64_t AddTx(ChainstateManager& chainman, CWallet& wallet, uint32_t lock\n     CBlockIndex* block = nullptr;\n     if (blockTime > 0) {\n         LOCK(cs_main);\n-        auto inserted = chainman.BlockIndex().emplace(GetRandHash(), new CBlockIndex);\n+        auto pblock = new CBlockIndex;\n+        pblock->m_hash_block = GetRandHash();\n+        auto inserted = chainman.BlockIndex().emplace(pblock);\n         assert(inserted.second);\n-        const uint256& hash = inserted.first->first;\n-        block = inserted.first->second;\n+        block = *inserted.first;\n         block->nTime = blockTime;\n-        block->phashBlock = &hash;\n-        confirm = {CWalletTx::Status::CONFIRMED, block->nHeight, hash, 0};\n+        confirm = {CWalletTx::Status::CONFIRMED, block->nHeight, block->GetBlockHash(), 0};\n     }\n \n     // If transaction is already in map, to avoid inconsistencies, unconfirmation"
      }
    ]
  }
]