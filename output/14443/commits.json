[
  {
    "sha": "b3e34c3af4be187f97194e3c19b08871ffc174c7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiM2UzNGMzYWY0YmUxODdmOTcxOTRlM2MxOWIwODg3MWZmYzE3NGM3",
    "commit": {
      "author": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2018-10-09T11:33:59Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2018-10-09T12:02:12Z"
      },
      "message": "Remove redundant run-time lock checking for locking requirements already checked at compile time (-Wthread-safety)",
      "tree": {
        "sha": "f43924b2a977f29d51302e67652497a4ae94a602",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f43924b2a977f29d51302e67652497a4ae94a602"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b3e34c3af4be187f97194e3c19b08871ffc174c7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b3e34c3af4be187f97194e3c19b08871ffc174c7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b3e34c3af4be187f97194e3c19b08871ffc174c7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b3e34c3af4be187f97194e3c19b08871ffc174c7/comments",
    "author": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1d1417430c829a0c21bf5a2fe4a5b2f592a9423f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1d1417430c829a0c21bf5a2fe4a5b2f592a9423f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1d1417430c829a0c21bf5a2fe4a5b2f592a9423f"
      }
    ],
    "stats": {
      "total": 75,
      "additions": 3,
      "deletions": 72
    },
    "files": [
      {
        "sha": "d36b045d0e4b21a811fbc9af3495ff6b91eaea03",
        "filename": "src/keystore.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b3e34c3af4be187f97194e3c19b08871ffc174c7/src/keystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b3e34c3af4be187f97194e3c19b08871ffc174c7/src/keystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.cpp?ref=b3e34c3af4be187f97194e3c19b08871ffc174c7",
        "patch": "@@ -9,7 +9,6 @@\n \n void CBasicKeyStore::ImplicitlyLearnRelatedKeyScripts(const CPubKey& pubkey)\n {\n-    AssertLockHeld(cs_KeyStore);\n     CKeyID key_id = pubkey.GetID();\n     // We must actually know about this key already.\n     assert(HaveKey(key_id) || mapWatchKeys.count(key_id));"
      },
      {
        "sha": "c3509361a8e61dabb5675dc91d36d63c288eaaf4",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b3e34c3af4be187f97194e3c19b08871ffc174c7/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b3e34c3af4be187f97194e3c19b08871ffc174c7/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=b3e34c3af4be187f97194e3c19b08871ffc174c7",
        "patch": "@@ -444,7 +444,6 @@ static void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) EXCLUSIV\n  */\n static void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman* connman) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    AssertLockHeld(cs_main);\n     CNodeState* nodestate = State(nodeid);\n     if (!nodestate || !nodestate->fSupportsDesiredCmpctVersion) {\n         // Never ask from peers who can't provide witnesses.\n@@ -480,7 +479,6 @@ static void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman* connma\n \n static bool TipMayBeStale(const Consensus::Params &consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    AssertLockHeld(cs_main);\n     if (g_last_tip_update == 0) {\n         g_last_tip_update = GetTime();\n     }\n@@ -833,7 +831,6 @@ void Misbehaving(NodeId pnode, int howmuch, const std::string& message) EXCLUSIV\n // we fully-validated them at some point.\n static bool BlockRequestAllowed(const CBlockIndex* pindex, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    AssertLockHeld(cs_main);\n     if (chainActive.Contains(pindex)) return true;\n     return pindex->IsValid(BLOCK_VALID_SCRIPTS) && (pindexBestHeader != nullptr) &&\n         (pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() < STALE_RELAY_AGE_LIMIT) &&\n@@ -2927,7 +2924,6 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n static bool SendRejectsAndCheckIfBanned(CNode* pnode, CConnman* connman, bool enable_bip61) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    AssertLockHeld(cs_main);\n     CNodeState &state = *State(pnode->GetId());\n \n     if (enable_bip61) {\n@@ -3081,8 +3077,6 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n \n void PeerLogicValidation::ConsiderEviction(CNode *pto, int64_t time_in_seconds)\n {\n-    AssertLockHeld(cs_main);\n-\n     CNodeState &state = *State(pto->GetId());\n     const CNetMsgMaker msgMaker(pto->GetSendVersion());\n "
      },
      {
        "sha": "07ab7b3de48dc10b213e7e11c3bca58687b46e36",
        "filename": "src/policy/rbf.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b3e34c3af4be187f97194e3c19b08871ffc174c7/src/policy/rbf.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b3e34c3af4be187f97194e3c19b08871ffc174c7/src/policy/rbf.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/rbf.cpp?ref=b3e34c3af4be187f97194e3c19b08871ffc174c7",
        "patch": "@@ -16,8 +16,6 @@ bool SignalsOptInRBF(const CTransaction &tx)\n \n RBFTransactionState IsRBFOptIn(const CTransaction &tx, CTxMemPool &pool)\n {\n-    AssertLockHeld(pool.cs);\n-\n     CTxMemPool::setEntries setAncestors;\n \n     // First check the transaction itself."
      },
      {
        "sha": "dd44de29fc49aecce76bc4d6bad98f22b4995da7",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b3e34c3af4be187f97194e3c19b08871ffc174c7/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b3e34c3af4be187f97194e3c19b08871ffc174c7/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=b3e34c3af4be187f97194e3c19b08871ffc174c7",
        "patch": "@@ -387,8 +387,6 @@ static std::string EntryDescriptionString()\n \n static void entryToJSON(UniValue &info, const CTxMemPoolEntry &e) EXCLUSIVE_LOCKS_REQUIRED(::mempool.cs)\n {\n-    AssertLockHeld(mempool.cs);\n-\n     UniValue fees(UniValue::VOBJ);\n     fees.pushKV(\"base\", ValueFromAmount(e.GetFee()));\n     fees.pushKV(\"modified\", ValueFromAmount(e.GetModifiedFee()));"
      },
      {
        "sha": "d0b2fb4691fc5e3ef13df447ba795ef45242df1f",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b3e34c3af4be187f97194e3c19b08871ffc174c7/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b3e34c3af4be187f97194e3c19b08871ffc174c7/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=b3e34c3af4be187f97194e3c19b08871ffc174c7",
        "patch": "@@ -529,7 +529,6 @@ void CTxMemPool::removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMem\n void CTxMemPool::removeConflicts(const CTransaction &tx)\n {\n     // Remove transactions which depend on inputs of tx, recursively\n-    AssertLockHeld(cs);\n     for (const CTxIn &txin : tx.vin) {\n         auto it = mapNextTx.find(txin.prevout);\n         if (it != mapNextTx.end()) {\n@@ -753,8 +752,6 @@ class DepthAndScoreComparator\n std::vector<CTxMemPool::indexed_transaction_set::const_iterator> CTxMemPool::GetSortedDepthAndScore() const\n {\n     std::vector<indexed_transaction_set::const_iterator> iters;\n-    AssertLockHeld(cs);\n-\n     iters.reserve(mapTx.size());\n \n     for (indexed_transaction_set::iterator mi = mapTx.begin(); mi != mapTx.end(); ++mi) {\n@@ -915,7 +912,6 @@ size_t CTxMemPool::DynamicMemoryUsage() const {\n }\n \n void CTxMemPool::RemoveStaged(setEntries &stage, bool updateDescendants, MemPoolRemovalReason reason) {\n-    AssertLockHeld(cs);\n     UpdateForRemoveFromMempool(stage, updateDescendants);\n     for (txiter it : stage) {\n         removeUnchecked(it, reason);\n@@ -1008,7 +1004,6 @@ CFeeRate CTxMemPool::GetMinFee(size_t sizelimit) const {\n }\n \n void CTxMemPool::trackPackageRemoved(const CFeeRate& rate) {\n-    AssertLockHeld(cs);\n     if (rate.GetFeePerK() > rollingMinimumFeeRate) {\n         rollingMinimumFeeRate = rate.GetFeePerK();\n         blockSinceLastRollingFeeBump = false;"
      },
      {
        "sha": "e6ee3a90a0e9297d7736fe4d1c1aed3dfb1ed932",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 27,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b3e34c3af4be187f97194e3c19b08871ffc174c7/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b3e34c3af4be187f97194e3c19b08871ffc174c7/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=b3e34c3af4be187f97194e3c19b08871ffc174c7",
        "patch": "@@ -313,8 +313,6 @@ static FILE* OpenUndoFile(const CDiskBlockPos &pos, bool fReadOnly = false);\n \n bool CheckFinalTx(const CTransaction &tx, int flags)\n {\n-    AssertLockHeld(cs_main);\n-\n     // By convention a negative value for flags indicates that the\n     // current network-enforced consensus rules should be used. In\n     // a future soft-fork scenario that would mean checking which\n@@ -345,7 +343,6 @@ bool CheckFinalTx(const CTransaction &tx, int flags)\n \n bool TestLockPointValidity(const LockPoints* lp)\n {\n-    AssertLockHeld(cs_main);\n     assert(lp);\n     // If there are relative lock times then the maxInputBlock will be set\n     // If there are no relative lock times, the LockPoints don't depend on the chain\n@@ -459,7 +456,6 @@ std::string FormatStateMessage(const CValidationState &state)\n \n static bool IsCurrentForFeeEstimation() EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    AssertLockHeld(cs_main);\n     if (IsInitialBlockDownload())\n         return false;\n     if (chainActive.Tip()->GetBlockTime() < (GetTime() - MAX_FEE_ESTIMATION_TIP_AGE))\n@@ -484,7 +480,6 @@ static bool IsCurrentForFeeEstimation() EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n \n static void UpdateMempoolForReorg(DisconnectedBlockTransactions &disconnectpool, bool fAddToMempool) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    AssertLockHeld(cs_main);\n     std::vector<uint256> vHashUpdate;\n     // disconnectpool's insertion_order index sorts the entries from\n     // oldest to newest, but the oldest entry will be the last tx from the\n@@ -525,8 +520,6 @@ static void UpdateMempoolForReorg(DisconnectedBlockTransactions &disconnectpool,\n // were somehow broken and returning the wrong scriptPubKeys\n static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationState& state, const CCoinsViewCache& view, const CTxMemPool& pool,\n                  unsigned int flags, bool cacheSigStore, PrecomputedTransactionData& txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n-    AssertLockHeld(cs_main);\n-\n     // pool.cs should be locked already, but go ahead and re-take the lock here\n     // to enforce that mempool doesn't change between when we check the view\n     // and when we actually call through to CheckInputs\n@@ -563,7 +556,6 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n {\n     const CTransaction& tx = *ptx;\n     const uint256 hash = tx.GetHash();\n-    AssertLockHeld(cs_main);\n     LOCK(pool.cs); // mempool \"read lock\" (held through GetMainSignals().TransactionAddedToMempool())\n     if (pfMissingInputs) {\n         *pfMissingInputs = false;\n@@ -1209,7 +1201,6 @@ static void AlertNotify(const std::string& strMessage)\n \n static void CheckForkWarningConditions() EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    AssertLockHeld(cs_main);\n     // Before we get past initial download, we cannot reliably alert about forks\n     // (we assume we don't get stuck on a fork before finishing our initial sync)\n     if (IsInitialBlockDownload())\n@@ -1250,7 +1241,6 @@ static void CheckForkWarningConditions() EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n \n static void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    AssertLockHeld(cs_main);\n     // If we are on a fork that is sufficiently large, set a warning flag\n     CBlockIndex* pfork = pindexNewForkTip;\n     CBlockIndex* plonger = chainActive.Tip();\n@@ -1367,6 +1357,9 @@ void InitScriptExecutionCache() {\n  * entry again.\n  *\n  * Non-static (and re-declared) in src/test/txvalidationcache_tests.cpp\n+ *\n+ * Calling CheckInputs requires holding cs_main. This requirement can be removed\n+ * by making CuckooCache not require external locks.\n  */\n bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n@@ -1395,7 +1388,6 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n             // round - giving us 19 + 32 + 4 = 55 bytes (+ 8 + 1 = 64)\n             static_assert(55 - sizeof(flags) - 32 >= 128/8, \"Want at least 128 bits of nonce for script execution cache\");\n             CSHA256().Write(scriptExecutionCacheNonce.begin(), 55 - sizeof(flags) - 32).Write(tx.GetWitnessHash().begin(), 32).Write((unsigned char*)&flags, sizeof(flags)).Finalize(hashCacheEntry.begin());\n-            AssertLockHeld(cs_main); //TODO: Remove this requirement by making CuckooCache not require external locks\n             if (scriptExecutionCache.contains(hashCacheEntry, !cacheFullScriptStore)) {\n                 return true;\n             }\n@@ -1735,8 +1727,6 @@ static bool IsScriptWitnessEnabled(const Consensus::Params& params)\n }\n \n static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consensus::Params& consensusparams) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n-    AssertLockHeld(cs_main);\n-\n     unsigned int flags = SCRIPT_VERIFY_NONE;\n \n     // BIP16 didn't become active until Apr 1 2012 (on mainnet, and\n@@ -1796,7 +1786,6 @@ static int64_t nBlocksTotal = 0;\n bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pindex,\n                   CCoinsViewCache& view, const CChainParams& chainparams, bool fJustCheck)\n {\n-    AssertLockHeld(cs_main);\n     assert(pindex);\n     assert(*pindex->phashBlock == block.GetHash());\n     int64_t nTimeStart = GetTimeMicros();\n@@ -2544,8 +2533,6 @@ void CChainState::PruneBlockIndexCandidates() {\n  */\n bool CChainState::ActivateBestChainStep(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace)\n {\n-    AssertLockHeld(cs_main);\n-\n     const CBlockIndex *pindexOldTip = chainActive.Tip();\n     const CBlockIndex *pindexFork = chainActive.FindFork(pindexMostWork);\n \n@@ -2793,8 +2780,6 @@ bool PreciousBlock(CValidationState& state, const CChainParams& params, CBlockIn\n \n bool CChainState::InvalidateBlock(CValidationState& state, const CChainParams& chainparams, CBlockIndex *pindex)\n {\n-    AssertLockHeld(cs_main);\n-\n     // We first disconnect backwards and then mark the blocks as invalid.\n     // This prevents a case where pruned nodes may fail to invalidateblock\n     // and be left unable to start as they have no tip candidates (as there\n@@ -2860,8 +2845,6 @@ bool InvalidateBlock(CValidationState& state, const CChainParams& chainparams, C\n }\n \n void CChainState::ResetBlockFailureFlags(CBlockIndex *pindex) {\n-    AssertLockHeld(cs_main);\n-\n     int nHeight = pindex->nHeight;\n \n     // Remove the invalidity flag from this block and all its descendants.\n@@ -2899,8 +2882,6 @@ void ResetBlockFailureFlags(CBlockIndex *pindex) {\n \n CBlockIndex* CChainState::AddToBlockIndex(const CBlockHeader& block)\n {\n-    AssertLockHeld(cs_main);\n-\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n     BlockMap::iterator it = mapBlockIndex.find(hash);\n@@ -3345,7 +3326,6 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n \n bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex)\n {\n-    AssertLockHeld(cs_main);\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n     BlockMap::iterator miSelf = mapBlockIndex.find(hash);\n@@ -3450,7 +3430,6 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CVali\n     const CBlock& block = *pblock;\n \n     if (fNewBlock) *fNewBlock = false;\n-    AssertLockHeld(cs_main);\n \n     CBlockIndex *pindexDummy = nullptr;\n     CBlockIndex *&pindex = ppindex ? *ppindex : pindexDummy;\n@@ -3559,7 +3538,6 @@ bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<cons\n \n bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams, const CBlock& block, CBlockIndex* pindexPrev, bool fCheckPOW, bool fCheckMerkleRoot)\n {\n-    AssertLockHeld(cs_main);\n     assert(pindexPrev && pindexPrev == chainActive.Tip());\n     CCoinsViewCache viewNew(pcoinsTip.get());\n     uint256 block_hash(block.GetHash());\n@@ -3796,8 +3774,6 @@ fs::path GetBlockPosFilename(const CDiskBlockPos &pos, const char *prefix)\n \n CBlockIndex * CChainState::InsertBlockIndex(const uint256& hash)\n {\n-    AssertLockHeld(cs_main);\n-\n     if (hash.IsNull())\n         return nullptr;\n "
      },
      {
        "sha": "2749678fcb6c93154d0d20a0d216a1f2093ee217",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 29,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b3e34c3af4be187f97194e3c19b08871ffc174c7/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b3e34c3af4be187f97194e3c19b08871ffc174c7/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=b3e34c3af4be187f97194e3c19b08871ffc174c7",
        "patch": "@@ -178,7 +178,6 @@ const CWalletTx* CWallet::GetWalletTx(const uint256& hash) const\n CPubKey CWallet::GenerateNewKey(WalletBatch &batch, bool internal)\n {\n     assert(!IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS));\n-    AssertLockHeld(cs_wallet); // mapKeyMetadata\n     bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets\n \n     CKey secret;\n@@ -259,8 +258,6 @@ void CWallet::DeriveNewChildKey(WalletBatch &batch, CKeyMetadata& metadata, CKey\n \n bool CWallet::AddKeyPubKeyWithDB(WalletBatch &batch, const CKey& secret, const CPubKey &pubkey)\n {\n-    AssertLockHeld(cs_wallet); // mapKeyMetadata\n-\n     // CCryptoKeyStore has no concept of wallet databases, but calls AddCryptedKey\n     // which is overridden below.  To avoid flushes, the database handle is\n     // tunneled through to it.\n@@ -319,14 +316,12 @@ bool CWallet::AddCryptedKey(const CPubKey &vchPubKey,\n \n void CWallet::LoadKeyMetadata(const CKeyID& keyID, const CKeyMetadata &meta)\n {\n-    AssertLockHeld(cs_wallet); // mapKeyMetadata\n     UpdateTimeFirstKey(meta.nCreateTime);\n     mapKeyMetadata[keyID] = meta;\n }\n \n void CWallet::LoadScriptMetadata(const CScriptID& script_id, const CKeyMetadata &meta)\n {\n-    AssertLockHeld(cs_wallet); // m_script_metadata\n     UpdateTimeFirstKey(meta.nCreateTime);\n     m_script_metadata[script_id] = meta;\n }\n@@ -342,7 +337,6 @@ bool CWallet::LoadCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigne\n  */\n void CWallet::UpdateTimeFirstKey(int64_t nCreateTime)\n {\n-    AssertLockHeld(cs_wallet);\n     if (nCreateTime <= 1) {\n         // Cannot determine birthday information, so set the wallet birthday to\n         // the beginning of time.\n@@ -392,7 +386,6 @@ bool CWallet::AddWatchOnly(const CScript& dest, int64_t nCreateTime)\n \n bool CWallet::RemoveWatchOnly(const CScript &dest)\n {\n-    AssertLockHeld(cs_wallet);\n     if (!CCryptoKeyStore::RemoveWatchOnly(dest))\n         return false;\n     if (!HaveWatchOnly())\n@@ -541,7 +534,6 @@ std::set<uint256> CWallet::GetConflicts(const uint256& txid) const\n \n bool CWallet::HasWalletSpend(const uint256& txid) const\n {\n-    AssertLockHeld(cs_wallet);\n     auto iter = mapTxSpends.lower_bound(COutPoint(txid, 0));\n     return (iter != mapTxSpends.end() && iter->first.hash == txid);\n }\n@@ -792,7 +784,6 @@ DBErrors CWallet::ReorderTransactions()\n \n int64_t CWallet::IncOrderPosNext(WalletBatch *batch)\n {\n-    AssertLockHeld(cs_wallet); // nOrderPosNext\n     int64_t nRet = nOrderPosNext++;\n     if (batch) {\n         batch->WriteOrderPosNext(nOrderPosNext);\n@@ -2150,9 +2141,6 @@ CAmount CWallet::GetAvailableBalance(const CCoinControl* coinControl) const\n \n void CWallet::AvailableCoins(std::vector<COutput> &vCoins, bool fOnlySafe, const CCoinControl *coinControl, const CAmount &nMinimumAmount, const CAmount &nMaximumAmount, const CAmount &nMinimumSumAmount, const uint64_t nMaximumCount, const int nMinDepth, const int nMaxDepth) const\n {\n-    AssertLockHeld(cs_main);\n-    AssertLockHeld(cs_wallet);\n-\n     vCoins.clear();\n     CAmount nTotal = 0;\n \n@@ -2259,9 +2247,6 @@ void CWallet::AvailableCoins(std::vector<COutput> &vCoins, bool fOnlySafe, const\n \n std::map<CTxDestination, std::vector<COutput>> CWallet::ListCoins() const\n {\n-    AssertLockHeld(cs_main);\n-    AssertLockHeld(cs_wallet);\n-\n     std::map<CTxDestination, std::vector<COutput>> result;\n     std::vector<COutput> availableCoins;\n \n@@ -2455,8 +2440,6 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n \n bool CWallet::SignTransaction(CMutableTransaction &tx)\n {\n-    AssertLockHeld(cs_wallet); // mapWallet\n-\n     // sign the new tx\n     int nIn = 0;\n     for (auto& input : tx.vin) {\n@@ -3035,7 +3018,6 @@ DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n \n DBErrors CWallet::ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256>& vHashOut)\n {\n-    AssertLockHeld(cs_wallet); // mapWallet\n     DBErrors nZapSelectTxRet = WalletBatch(*database,\"cr+\").ZapSelectTx(vHashIn, vHashOut);\n     for (uint256 hash : vHashOut) {\n         const auto& it = mapWallet.find(hash);\n@@ -3182,13 +3164,11 @@ bool CWallet::NewKeyPool()\n \n size_t CWallet::KeypoolCountExternalKeys()\n {\n-    AssertLockHeld(cs_wallet); // setExternalKeyPool\n     return setExternalKeyPool.size() + set_pre_split_keypool.size();\n }\n \n void CWallet::LoadKeyPool(int64_t nIndex, const CKeyPool &keypool)\n {\n-    AssertLockHeld(cs_wallet);\n     if (keypool.m_pre_split) {\n         set_pre_split_keypool.insert(nIndex);\n     } else if (keypool.fInternal) {\n@@ -3430,7 +3410,6 @@ std::map<CTxDestination, CAmount> CWallet::GetAddressBalances()\n \n std::set< std::set<CTxDestination> > CWallet::GetAddressGroupings()\n {\n-    AssertLockHeld(cs_wallet); // mapWallet\n     std::set< std::set<CTxDestination> > groupings;\n     std::set<CTxDestination> grouping;\n \n@@ -3570,7 +3549,6 @@ void CReserveKey::ReturnKey()\n \n void CWallet::MarkReserveKeysAsUsed(int64_t keypool_id)\n {\n-    AssertLockHeld(cs_wallet);\n     bool internal = setInternalKeyPool.count(keypool_id);\n     if (!internal) assert(setExternalKeyPool.count(keypool_id) || set_pre_split_keypool.count(keypool_id));\n     std::set<int64_t> *setKeyPool = internal ? &setInternalKeyPool : (set_pre_split_keypool.empty() ? &setExternalKeyPool : &set_pre_split_keypool);\n@@ -3605,33 +3583,28 @@ void CWallet::GetScriptForMining(std::shared_ptr<CReserveScript> &script)\n \n void CWallet::LockCoin(const COutPoint& output)\n {\n-    AssertLockHeld(cs_wallet); // setLockedCoins\n     setLockedCoins.insert(output);\n }\n \n void CWallet::UnlockCoin(const COutPoint& output)\n {\n-    AssertLockHeld(cs_wallet); // setLockedCoins\n     setLockedCoins.erase(output);\n }\n \n void CWallet::UnlockAllCoins()\n {\n-    AssertLockHeld(cs_wallet); // setLockedCoins\n     setLockedCoins.clear();\n }\n \n bool CWallet::IsLockedCoin(uint256 hash, unsigned int n) const\n {\n-    AssertLockHeld(cs_wallet); // setLockedCoins\n     COutPoint outpt(hash, n);\n \n     return (setLockedCoins.count(outpt) > 0);\n }\n \n void CWallet::ListLockedCoins(std::vector<COutPoint>& vOutpts) const\n {\n-    AssertLockHeld(cs_wallet); // setLockedCoins\n     for (std::set<COutPoint>::iterator it = setLockedCoins.begin();\n          it != setLockedCoins.end(); it++) {\n         COutPoint outpt = (*it);\n@@ -4234,8 +4207,6 @@ int CMerkleTx::GetDepthInMainChain() const\n     if (hashUnset())\n         return 0;\n \n-    AssertLockHeld(cs_main);\n-\n     // Find the block it claims to be in\n     CBlockIndex* pindex = LookupBlockIndex(hashBlock);\n     if (!pindex || !chainActive.Contains(pindex))"
      }
    ]
  }
]