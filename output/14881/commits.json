[
  {
    "sha": "088985125f72b568fce32a090715b4abe18bf810",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowODg5ODUxMjVmNzJiNTY4ZmNlMzJhMDkwNzE1YjRhYmUxOGJmODEw",
    "commit": {
      "author": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-06T01:50:43Z"
      },
      "committer": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-06T02:18:41Z"
      },
      "message": "Unit testing of procedure AddTimeData",
      "tree": {
        "sha": "8f5b8ddea02c7c40a83d6a05339ea7a285ac22cf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8f5b8ddea02c7c40a83d6a05339ea7a285ac22cf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/088985125f72b568fce32a090715b4abe18bf810",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/088985125f72b568fce32a090715b4abe18bf810",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/088985125f72b568fce32a090715b4abe18bf810",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/088985125f72b568fce32a090715b4abe18bf810/comments",
    "author": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "60b20c869f8df9a81b5080ebcbe8c9cf4e6b9d77",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/60b20c869f8df9a81b5080ebcbe8c9cf4e6b9d77",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/60b20c869f8df9a81b5080ebcbe8c9cf4e6b9d77"
      }
    ],
    "stats": {
      "total": 119,
      "additions": 118,
      "deletions": 1
    },
    "files": [
      {
        "sha": "293b0f6fe6cfa7b3b89e74177bf3dd696c2b6afc",
        "filename": "src/test/timedata_tests.cpp",
        "status": "modified",
        "additions": 103,
        "deletions": 0,
        "changes": 103,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/088985125f72b568fce32a090715b4abe18bf810/src/test/timedata_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/088985125f72b568fce32a090715b4abe18bf810/src/test/timedata_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/timedata_tests.cpp?ref=088985125f72b568fce32a090715b4abe18bf810",
        "patch": "@@ -3,6 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n //\n #include <timedata.h>\n+#include <netaddress.h>\n #include <test/test_bitcoin.h>\n \n #include <boost/test/unit_test.hpp>\n@@ -34,4 +35,106 @@ BOOST_AUTO_TEST_CASE(util_MedianFilter)\n     BOOST_CHECK_EQUAL(filter.median(), 7);\n }\n \n+BOOST_AUTO_TEST_CASE(util_MedianFilterShallNotGrowBeyondSize)\n+{\n+    CMedianFilter<int> filter(2, 15);\n+\n+    BOOST_CHECK_EQUAL(filter.size(), 1); // 15\n+\n+    filter.input(100); // 15 100\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+\n+    filter.input(10); // 100 10\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+    BOOST_CHECK_EQUAL(filter.sorted()[0], 10);\n+    BOOST_CHECK_EQUAL(filter.sorted()[1], 100);\n+}\n+\n+\n+CNetAddr utilBuildAddress(std::string address);\n+\n+void utilPreconditionIsAtLeastFiveEntriesRequired(std::string baseip, int basevalue);\n+\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataComputeOffsetWhenSampleCountIsUneven)\n+{\n+    utilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.1.\", 200); // precondition 1: at least 5 entries required to compute any offset\n+    BOOST_CHECK(CountOffsetSamples() >= 5);\n+\n+\n+    if ((CountOffsetSamples() % 2) == 1) { // precondition 2: start with an even number of samples\n+        AddTimeData(utilBuildAddress(\"1.1.1.210\"), 210);\n+    }\n+\n+    BOOST_CHECK(CountOffsetSamples() % 2 == 0);\n+\n+\n+    int64_t offset = GetTimeOffset();\n+    int samples = CountOffsetSamples();\n+    AddTimeData(utilBuildAddress(\"1.1.1.211\"), 211);\n+\n+    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples + 1); // sample was added\n+    BOOST_CHECK(GetTimeOffset() != offset);               // and new offset was computed\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataDoNotComputeOffsetWhenSampleCountIsEven)\n+{\n+    utilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.1.\", 100); // precondition 1: at least 5 entries required to compute any offset\n+\n+    BOOST_CHECK(CountOffsetSamples() >= 5);\n+\n+    if (CountOffsetSamples() % 2 == 0) { // precondition 2: start with an uneven number of samples\n+        AddTimeData(utilBuildAddress(\"1.1.1.110\"), 110);\n+    }\n+\n+    BOOST_CHECK(CountOffsetSamples() % 2 == 1);\n+\n+\n+    int64_t offset = GetTimeOffset();\n+    int samples = CountOffsetSamples();\n+    AddTimeData(utilBuildAddress(\"1.1.1.111\"), 111);\n+\n+    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples + 1); // sample was added\n+    BOOST_CHECK_EQUAL(GetTimeOffset(), offset);           //new offset was not computed\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataIgnoreSampleWithDuplicateIP)\n+{\n+    utilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.1.\", 300); // precondition 1: at least 5 entries required to compute any offset\n+    BOOST_CHECK(CountOffsetSamples() >= 5);\n+\n+\n+    AddTimeData(utilBuildAddress(\"1.1.1.310\"), 310);\n+\n+    int64_t offset = GetTimeOffset();\n+    int samples = CountOffsetSamples();\n+    AddTimeData(utilBuildAddress(\"1.1.1.310\"), 311);\n+\n+    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples); // sample was ignored\n+    BOOST_CHECK_EQUAL(GetTimeOffset(), offset);       //new offset was not computed\n+}\n+\n+\n+CNetAddr utilBuildAddress(std::string address)\n+{\n+    struct sockaddr_in sa;\n+    inet_pton(AF_INET, address.c_str(), &(sa.sin_addr));\n+    CNetAddr addr = CNetAddr(sa.sin_addr);\n+    return addr;\n+}\n+\n+\n+void utilPreconditionIsAtLeastFiveEntriesRequired(std::string baseip, int basevalue)\n+{\n+    for (int i = CountOffsetSamples(); i < 5; i++) { // precondition 1: at least 5 entries required to compute any offset\n+        int val = basevalue + i;\n+        std::stringstream stream;\n+        stream << baseip << val;\n+        std::string ip = stream.str();\n+        AddTimeData(utilBuildAddress(ip.c_str()), val);\n+    }\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "7a61c98e913c10e6e3a1f9ddb835a0a9833a519b",
        "filename": "src/timedata.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 1,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/088985125f72b568fce32a090715b4abe18bf810/src/timedata.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/088985125f72b568fce32a090715b4abe18bf810/src/timedata.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.cpp?ref=088985125f72b568fce32a090715b4abe18bf810",
        "patch": "@@ -19,6 +19,8 @@\n static CCriticalSection cs_nTimeOffset;\n static int64_t nTimeOffset GUARDED_BY(cs_nTimeOffset) = 0;\n \n+\n+\n /**\n  * \"Never go to sea with two chronometers; take one or three.\"\n  * Our three time sources are:\n@@ -42,8 +44,19 @@ static int64_t abs64(int64_t n)\n     return (n >= 0 ? n : -n);\n }\n \n+\n #define BITCOIN_TIMEDATA_MAX_SAMPLES 200\n \n+\n+static CMedianFilter<int64_t> vTimeOffsets(BITCOIN_TIMEDATA_MAX_SAMPLES, 0);\n+\n+int CountOffsetSamples()\n+{\n+    LOCK(cs_nTimeOffset);\n+    return vTimeOffsets.size();\n+}\n+\n+\n void AddTimeData(const CNetAddr& ip, int64_t nOffsetSample)\n {\n     LOCK(cs_nTimeOffset);\n@@ -55,7 +68,6 @@ void AddTimeData(const CNetAddr& ip, int64_t nOffsetSample)\n         return;\n \n     // Add data\n-    static CMedianFilter<int64_t> vTimeOffsets(BITCOIN_TIMEDATA_MAX_SAMPLES, 0);\n     vTimeOffsets.input(nOffsetSample);\n     LogPrint(BCLog::NET,\"added time data, samples %d, offset %+d (%+d minutes)\\n\", vTimeOffsets.size(), nOffsetSample, nOffsetSample/60);\n "
      },
      {
        "sha": "a7c0a33fdb55de4207e2872a3283c949f3d7a8e9",
        "filename": "src/timedata.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/088985125f72b568fce32a090715b4abe18bf810/src/timedata.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/088985125f72b568fce32a090715b4abe18bf810/src/timedata.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.h?ref=088985125f72b568fce32a090715b4abe18bf810",
        "patch": "@@ -75,4 +75,6 @@ int64_t GetTimeOffset();\n int64_t GetAdjustedTime();\n void AddTimeData(const CNetAddr& ip, int64_t nTime);\n \n+int CountOffsetSamples();\n+\n #endif // BITCOIN_TIMEDATA_H"
      }
    ]
  },
  {
    "sha": "b34dd93ff12bfcaa5fbc4cff133c65ce3e706dc3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMzRkZDkzZmYxMmJmY2FhNWZiYzRjZmYxMzNjNjVjZTNlNzA2ZGMz",
    "commit": {
      "author": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-06T03:21:34Z"
      },
      "committer": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-06T03:21:34Z"
      },
      "message": "Test AddTimeDataAlgorithm",
      "tree": {
        "sha": "4e4e740fd3aba7d291a9e1203d49d85b3464ae3a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4e4e740fd3aba7d291a9e1203d49d85b3464ae3a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b34dd93ff12bfcaa5fbc4cff133c65ce3e706dc3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b34dd93ff12bfcaa5fbc4cff133c65ce3e706dc3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b34dd93ff12bfcaa5fbc4cff133c65ce3e706dc3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b34dd93ff12bfcaa5fbc4cff133c65ce3e706dc3/comments",
    "author": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "088985125f72b568fce32a090715b4abe18bf810",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/088985125f72b568fce32a090715b4abe18bf810",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/088985125f72b568fce32a090715b4abe18bf810"
      }
    ],
    "stats": {
      "total": 164,
      "additions": 135,
      "deletions": 29
    },
    "files": [
      {
        "sha": "68a413a7b5d0200223bcc15fc3940da22325c8aa",
        "filename": "src/test/timedata_tests.cpp",
        "status": "modified",
        "additions": 104,
        "deletions": 1,
        "changes": 105,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b34dd93ff12bfcaa5fbc4cff133c65ce3e706dc3/src/test/timedata_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b34dd93ff12bfcaa5fbc4cff133c65ce3e706dc3/src/test/timedata_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/timedata_tests.cpp?ref=b34dd93ff12bfcaa5fbc4cff133c65ce3e706dc3",
        "patch": "@@ -2,9 +2,9 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n //\n-#include <timedata.h>\n #include <netaddress.h>\n #include <test/test_bitcoin.h>\n+#include <timedata.h>\n \n #include <boost/test/unit_test.hpp>\n \n@@ -117,6 +117,109 @@ BOOST_AUTO_TEST_CASE(util_AddTimeDataIgnoreSampleWithDuplicateIP)\n }\n \n \n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmMedianIsWithinBounds)\n+{\n+    int limit = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : 10 , init value: 0\n+\n+\n+    for (int sample = 1; sample < 4; sample++) { // precondition: 4 samples, all within bounds\n+        std::stringstream stream;\n+        stream << \"1.1.1.\" << sample;\n+        std::string ip = stream.str();\n+        AddTimeDataAlgorithm(utilBuildAddress(ip), sample, knownSet, offsetFilter, offset);\n+    }\n+\n+    BOOST_CHECK_EQUAL(offset, 0);\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 4);\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.200\"), 200, knownSet, offsetFilter, offset);\n+\n+    BOOST_CHECK_EQUAL(offset, offsetFilter.median());\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 5);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmMedianIsOutsideBounds)\n+{\n+    int limit = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : limit , init value: 0\n+\n+    for (int sample = 1; sample < 4; sample++) { // precondition: 4 samples, all outside bounds\n+        std::stringstream stream;\n+        stream << \"1.1.1.\" << 1 + sample;\n+        std::string ip = stream.str();\n+        AddTimeDataAlgorithm(utilBuildAddress(ip), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset);\n+    } // sorted filter: 0 x x x  -- x is outside the boundaries\n+\n+    BOOST_CHECK_EQUAL(offset, 0);\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 4);\n+\n+    // offset is computed only when number of entries is uneven\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.5\"), 1, knownSet, offsetFilter, offset); // sorted filter : 0 1 (x) x x  -- median (x)\n+    BOOST_CHECK_EQUAL(offset, 0);\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.6\"), 1, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 x x x\n+    BOOST_CHECK_EQUAL(offset, 0);\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.7\"), 1, knownSet, offsetFilter, offset);                               // sorted filter : 0 1 1 (1) x x x x -- median (1)\n+    BOOST_CHECK_EQUAL(offset, 1);                                                                                       // flip to 1\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.8\"), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 1 x x x x x\n+    BOOST_CHECK_EQUAL(offset, 1);\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.9\"), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 1 (x) x x x x x -- median (x)\n+    BOOST_CHECK_EQUAL(offset, 0);                                                                                       // flip back to zero\n+\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 9);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmAtLeastFiveSamplesToComputeOffset)\n+{\n+    int limit = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : limit , init value: 0\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.1\"), 1, knownSet, offsetFilter, offset);\n+    BOOST_CHECK_EQUAL(offset, 0);\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.2\"), 2, knownSet, offsetFilter, offset);\n+    BOOST_CHECK_EQUAL(offset, 0);\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.3\"), 3, knownSet, offsetFilter, offset);\n+    BOOST_CHECK_EQUAL(offset, 0);\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.4\"), 4, knownSet, offsetFilter, offset); // this is the fifth entry\n+    BOOST_CHECK_EQUAL(offset, 2);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmIgnoresSamplesBeyondInternalLimit)\n+{\n+    int limit = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : limit , init value: 0\n+\n+\n+    for (int sample = 1; sample < limit; sample++) { // precondition: limit samples\n+        std::stringstream stream;\n+        stream << \"1.1.1.\" << sample;\n+        std::string ip = stream.str();\n+        AddTimeDataAlgorithm(utilBuildAddress(ip), sample, knownSet, offsetFilter, offset);\n+    }\n+\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), limit);\n+\n+    int64_t pre = offset;\n+    int size = offsetFilter.size();\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.200\"), 200, knownSet, offsetFilter, offset);\n+\n+    BOOST_CHECK_EQUAL(offset, pre);\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), size);\n+}\n+\n+\n CNetAddr utilBuildAddress(std::string address)\n {\n     struct sockaddr_in sa;"
      },
      {
        "sha": "d7b719b2c19e2b92ec8e06a3ecee65e731f134d9",
        "filename": "src/timedata.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 28,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b34dd93ff12bfcaa5fbc4cff133c65ce3e706dc3/src/timedata.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b34dd93ff12bfcaa5fbc4cff133c65ce3e706dc3/src/timedata.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.cpp?ref=b34dd93ff12bfcaa5fbc4cff133c65ce3e706dc3",
        "patch": "@@ -6,21 +6,19 @@\n #include <config/bitcoin-config.h>\n #endif\n \n-#include <timedata.h>\n-\n #include <netaddress.h>\n #include <sync.h>\n+#include <timedata.h>\n #include <ui_interface.h>\n-#include <util/system.h>\n #include <util/strencodings.h>\n+#include <util/system.h>\n #include <warnings.h>\n \n \n static CCriticalSection cs_nTimeOffset;\n static int64_t nTimeOffset GUARDED_BY(cs_nTimeOffset) = 0;\n \n \n-\n /**\n  * \"Never go to sea with two chronometers; take one or three.\"\n  * Our three time sources are:\n@@ -48,6 +46,8 @@ static int64_t abs64(int64_t n)\n #define BITCOIN_TIMEDATA_MAX_SAMPLES 200\n \n \n+static std::set<CNetAddr> setKnown;\n+\n static CMedianFilter<int64_t> vTimeOffsets(BITCOIN_TIMEDATA_MAX_SAMPLES, 0);\n \n int CountOffsetSamples()\n@@ -56,20 +56,26 @@ int CountOffsetSamples()\n     return vTimeOffsets.size();\n }\n \n-\n void AddTimeData(const CNetAddr& ip, int64_t nOffsetSample)\n {\n     LOCK(cs_nTimeOffset);\n+\n+    AddTimeDataAlgorithm(ip, nOffsetSample, setKnown, vTimeOffsets, nTimeOffset);\n+}\n+\n+\n+void AddTimeDataAlgorithm(const CNetAddr& ip, const int64_t nOffsetSample, std::set<CNetAddr>& knownSet, CMedianFilter<int64_t>& offsetFilter, int64_t& offset)\n+{\n     // Ignore duplicates\n-    static std::set<CNetAddr> setKnown;\n-    if (setKnown.size() == BITCOIN_TIMEDATA_MAX_SAMPLES)\n+\n+    if (knownSet.size() == BITCOIN_TIMEDATA_MAX_SAMPLES)\n         return;\n-    if (!setKnown.insert(ip).second)\n+    if (!knownSet.insert(ip).second)\n         return;\n \n     // Add data\n-    vTimeOffsets.input(nOffsetSample);\n-    LogPrint(BCLog::NET,\"added time data, samples %d, offset %+d (%+d minutes)\\n\", vTimeOffsets.size(), nOffsetSample, nOffsetSample/60);\n+    offsetFilter.input(nOffsetSample);\n+    LogPrint(BCLog::NET, \"added time data, samples %d, offset %+d (%+d minutes)\\n\", offsetFilter.size(), nOffsetSample, nOffsetSample / 60);\n \n     // There is a known issue here (see issue #4521):\n     //\n@@ -88,31 +94,25 @@ void AddTimeData(const CNetAddr& ip, int64_t nOffsetSample)\n     // So we should hold off on fixing this and clean it up as part of\n     // a timing cleanup that strengthens it in a number of other ways.\n     //\n-    if (vTimeOffsets.size() >= 5 && vTimeOffsets.size() % 2 == 1)\n-    {\n-        int64_t nMedian = vTimeOffsets.median();\n-        std::vector<int64_t> vSorted = vTimeOffsets.sorted();\n+    if (offsetFilter.size() >= 5 && offsetFilter.size() % 2 == 1) {\n+        int64_t nMedian = offsetFilter.median();\n+        std::vector<int64_t> vSorted = offsetFilter.sorted();\n         // Only let other nodes change our time by so much\n-        if (abs64(nMedian) <= std::max<int64_t>(0, gArgs.GetArg(\"-maxtimeadjustment\", DEFAULT_MAX_TIME_ADJUSTMENT)))\n-        {\n-            nTimeOffset = nMedian;\n-        }\n-        else\n-        {\n-            nTimeOffset = 0;\n+        if (abs64(nMedian) <= std::max<int64_t>(0, gArgs.GetArg(\"-maxtimeadjustment\", DEFAULT_MAX_TIME_ADJUSTMENT))) {\n+            offset = nMedian;\n+        } else {\n+            offset = 0;\n \n-            static bool fDone;\n-            if (!fDone)\n-            {\n+            static bool gDone;\n+            if (!gDone) {\n                 // If nobody has a time different than ours but within 5 minutes of ours, give a warning\n                 bool fMatch = false;\n                 for (const int64_t nOffset : vSorted)\n                     if (nOffset != 0 && abs64(nOffset) < 5 * 60)\n                         fMatch = true;\n \n-                if (!fMatch)\n-                {\n-                    fDone = true;\n+                if (!fMatch) {\n+                    gDone = true;\n                     std::string strMessage = strprintf(_(\"Please check that your computer's date and time are correct! If your clock is wrong, %s will not work properly.\"), _(PACKAGE_NAME));\n                     SetMiscWarning(strMessage);\n                     uiInterface.ThreadSafeMessageBox(strMessage, \"\", CClientUIInterface::MSG_WARNING);\n@@ -126,7 +126,7 @@ void AddTimeData(const CNetAddr& ip, int64_t nOffsetSample)\n             }\n             LogPrint(BCLog::NET, \"|  \"); /* Continued */\n \n-            LogPrint(BCLog::NET, \"nTimeOffset = %+d  (%+d minutes)\\n\", nTimeOffset, nTimeOffset/60);\n+            LogPrint(BCLog::NET, \"nTimeOffset = %+d  (%+d minutes)\\n\", offset, offset / 60);\n         }\n     }\n }"
      },
      {
        "sha": "fe641834ef4f5b28c3794bc93de3c37850591371",
        "filename": "src/timedata.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b34dd93ff12bfcaa5fbc4cff133c65ce3e706dc3/src/timedata.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b34dd93ff12bfcaa5fbc4cff133c65ce3e706dc3/src/timedata.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.h?ref=b34dd93ff12bfcaa5fbc4cff133c65ce3e706dc3",
        "patch": "@@ -7,6 +7,7 @@\n \n #include <algorithm>\n #include <assert.h>\n+#include <set>\n #include <stdint.h>\n #include <vector>\n \n@@ -75,6 +76,8 @@ int64_t GetTimeOffset();\n int64_t GetAdjustedTime();\n void AddTimeData(const CNetAddr& ip, int64_t nTime);\n \n+/** Functions to enable testing the contract for AddTimeData */\n int CountOffsetSamples();\n+void AddTimeDataAlgorithm(const CNetAddr& ip, const int64_t nOffsetSample, std::set<CNetAddr>& knownSet, CMedianFilter<int64_t>& offsetFilter, int64_t& offset);\n \n #endif // BITCOIN_TIMEDATA_H"
      }
    ]
  },
  {
    "sha": "7a8498033e22ffdf707cbda77507cc1296e68c0e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3YTg0OTgwMzNlMjJmZmRmNzA3Y2JkYTc3NTA3Y2MxMjk2ZTY4YzBl",
    "commit": {
      "author": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-06T01:50:43Z"
      },
      "committer": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-06T03:27:28Z"
      },
      "message": "Unit testing of procedure AddTimeData\n\nPushed static variables ouf of the procedure to remove statefulness\nIntroduced procedure AddTimeDataAlgorithm to test the contract",
      "tree": {
        "sha": "4e4e740fd3aba7d291a9e1203d49d85b3464ae3a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4e4e740fd3aba7d291a9e1203d49d85b3464ae3a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7a8498033e22ffdf707cbda77507cc1296e68c0e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7a8498033e22ffdf707cbda77507cc1296e68c0e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7a8498033e22ffdf707cbda77507cc1296e68c0e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7a8498033e22ffdf707cbda77507cc1296e68c0e/comments",
    "author": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "60b20c869f8df9a81b5080ebcbe8c9cf4e6b9d77",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/60b20c869f8df9a81b5080ebcbe8c9cf4e6b9d77",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/60b20c869f8df9a81b5080ebcbe8c9cf4e6b9d77"
      }
    ],
    "stats": {
      "total": 279,
      "additions": 251,
      "deletions": 28
    },
    "files": [
      {
        "sha": "68a413a7b5d0200223bcc15fc3940da22325c8aa",
        "filename": "src/test/timedata_tests.cpp",
        "status": "modified",
        "additions": 207,
        "deletions": 1,
        "changes": 208,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a8498033e22ffdf707cbda77507cc1296e68c0e/src/test/timedata_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a8498033e22ffdf707cbda77507cc1296e68c0e/src/test/timedata_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/timedata_tests.cpp?ref=7a8498033e22ffdf707cbda77507cc1296e68c0e",
        "patch": "@@ -2,8 +2,9 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n //\n-#include <timedata.h>\n+#include <netaddress.h>\n #include <test/test_bitcoin.h>\n+#include <timedata.h>\n \n #include <boost/test/unit_test.hpp>\n \n@@ -34,4 +35,209 @@ BOOST_AUTO_TEST_CASE(util_MedianFilter)\n     BOOST_CHECK_EQUAL(filter.median(), 7);\n }\n \n+BOOST_AUTO_TEST_CASE(util_MedianFilterShallNotGrowBeyondSize)\n+{\n+    CMedianFilter<int> filter(2, 15);\n+\n+    BOOST_CHECK_EQUAL(filter.size(), 1); // 15\n+\n+    filter.input(100); // 15 100\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+\n+    filter.input(10); // 100 10\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+    BOOST_CHECK_EQUAL(filter.sorted()[0], 10);\n+    BOOST_CHECK_EQUAL(filter.sorted()[1], 100);\n+}\n+\n+\n+CNetAddr utilBuildAddress(std::string address);\n+\n+void utilPreconditionIsAtLeastFiveEntriesRequired(std::string baseip, int basevalue);\n+\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataComputeOffsetWhenSampleCountIsUneven)\n+{\n+    utilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.1.\", 200); // precondition 1: at least 5 entries required to compute any offset\n+    BOOST_CHECK(CountOffsetSamples() >= 5);\n+\n+\n+    if ((CountOffsetSamples() % 2) == 1) { // precondition 2: start with an even number of samples\n+        AddTimeData(utilBuildAddress(\"1.1.1.210\"), 210);\n+    }\n+\n+    BOOST_CHECK(CountOffsetSamples() % 2 == 0);\n+\n+\n+    int64_t offset = GetTimeOffset();\n+    int samples = CountOffsetSamples();\n+    AddTimeData(utilBuildAddress(\"1.1.1.211\"), 211);\n+\n+    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples + 1); // sample was added\n+    BOOST_CHECK(GetTimeOffset() != offset);               // and new offset was computed\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataDoNotComputeOffsetWhenSampleCountIsEven)\n+{\n+    utilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.1.\", 100); // precondition 1: at least 5 entries required to compute any offset\n+\n+    BOOST_CHECK(CountOffsetSamples() >= 5);\n+\n+    if (CountOffsetSamples() % 2 == 0) { // precondition 2: start with an uneven number of samples\n+        AddTimeData(utilBuildAddress(\"1.1.1.110\"), 110);\n+    }\n+\n+    BOOST_CHECK(CountOffsetSamples() % 2 == 1);\n+\n+\n+    int64_t offset = GetTimeOffset();\n+    int samples = CountOffsetSamples();\n+    AddTimeData(utilBuildAddress(\"1.1.1.111\"), 111);\n+\n+    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples + 1); // sample was added\n+    BOOST_CHECK_EQUAL(GetTimeOffset(), offset);           //new offset was not computed\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataIgnoreSampleWithDuplicateIP)\n+{\n+    utilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.1.\", 300); // precondition 1: at least 5 entries required to compute any offset\n+    BOOST_CHECK(CountOffsetSamples() >= 5);\n+\n+\n+    AddTimeData(utilBuildAddress(\"1.1.1.310\"), 310);\n+\n+    int64_t offset = GetTimeOffset();\n+    int samples = CountOffsetSamples();\n+    AddTimeData(utilBuildAddress(\"1.1.1.310\"), 311);\n+\n+    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples); // sample was ignored\n+    BOOST_CHECK_EQUAL(GetTimeOffset(), offset);       //new offset was not computed\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmMedianIsWithinBounds)\n+{\n+    int limit = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : 10 , init value: 0\n+\n+\n+    for (int sample = 1; sample < 4; sample++) { // precondition: 4 samples, all within bounds\n+        std::stringstream stream;\n+        stream << \"1.1.1.\" << sample;\n+        std::string ip = stream.str();\n+        AddTimeDataAlgorithm(utilBuildAddress(ip), sample, knownSet, offsetFilter, offset);\n+    }\n+\n+    BOOST_CHECK_EQUAL(offset, 0);\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 4);\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.200\"), 200, knownSet, offsetFilter, offset);\n+\n+    BOOST_CHECK_EQUAL(offset, offsetFilter.median());\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 5);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmMedianIsOutsideBounds)\n+{\n+    int limit = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : limit , init value: 0\n+\n+    for (int sample = 1; sample < 4; sample++) { // precondition: 4 samples, all outside bounds\n+        std::stringstream stream;\n+        stream << \"1.1.1.\" << 1 + sample;\n+        std::string ip = stream.str();\n+        AddTimeDataAlgorithm(utilBuildAddress(ip), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset);\n+    } // sorted filter: 0 x x x  -- x is outside the boundaries\n+\n+    BOOST_CHECK_EQUAL(offset, 0);\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 4);\n+\n+    // offset is computed only when number of entries is uneven\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.5\"), 1, knownSet, offsetFilter, offset); // sorted filter : 0 1 (x) x x  -- median (x)\n+    BOOST_CHECK_EQUAL(offset, 0);\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.6\"), 1, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 x x x\n+    BOOST_CHECK_EQUAL(offset, 0);\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.7\"), 1, knownSet, offsetFilter, offset);                               // sorted filter : 0 1 1 (1) x x x x -- median (1)\n+    BOOST_CHECK_EQUAL(offset, 1);                                                                                       // flip to 1\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.8\"), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 1 x x x x x\n+    BOOST_CHECK_EQUAL(offset, 1);\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.9\"), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 1 (x) x x x x x -- median (x)\n+    BOOST_CHECK_EQUAL(offset, 0);                                                                                       // flip back to zero\n+\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 9);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmAtLeastFiveSamplesToComputeOffset)\n+{\n+    int limit = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : limit , init value: 0\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.1\"), 1, knownSet, offsetFilter, offset);\n+    BOOST_CHECK_EQUAL(offset, 0);\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.2\"), 2, knownSet, offsetFilter, offset);\n+    BOOST_CHECK_EQUAL(offset, 0);\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.3\"), 3, knownSet, offsetFilter, offset);\n+    BOOST_CHECK_EQUAL(offset, 0);\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.4\"), 4, knownSet, offsetFilter, offset); // this is the fifth entry\n+    BOOST_CHECK_EQUAL(offset, 2);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmIgnoresSamplesBeyondInternalLimit)\n+{\n+    int limit = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : limit , init value: 0\n+\n+\n+    for (int sample = 1; sample < limit; sample++) { // precondition: limit samples\n+        std::stringstream stream;\n+        stream << \"1.1.1.\" << sample;\n+        std::string ip = stream.str();\n+        AddTimeDataAlgorithm(utilBuildAddress(ip), sample, knownSet, offsetFilter, offset);\n+    }\n+\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), limit);\n+\n+    int64_t pre = offset;\n+    int size = offsetFilter.size();\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.200\"), 200, knownSet, offsetFilter, offset);\n+\n+    BOOST_CHECK_EQUAL(offset, pre);\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), size);\n+}\n+\n+\n+CNetAddr utilBuildAddress(std::string address)\n+{\n+    struct sockaddr_in sa;\n+    inet_pton(AF_INET, address.c_str(), &(sa.sin_addr));\n+    CNetAddr addr = CNetAddr(sa.sin_addr);\n+    return addr;\n+}\n+\n+\n+void utilPreconditionIsAtLeastFiveEntriesRequired(std::string baseip, int basevalue)\n+{\n+    for (int i = CountOffsetSamples(); i < 5; i++) { // precondition 1: at least 5 entries required to compute any offset\n+        int val = basevalue + i;\n+        std::stringstream stream;\n+        stream << baseip << val;\n+        std::string ip = stream.str();\n+        AddTimeData(utilBuildAddress(ip.c_str()), val);\n+    }\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "d7b719b2c19e2b92ec8e06a3ecee65e731f134d9",
        "filename": "src/timedata.cpp",
        "status": "modified",
        "additions": 39,
        "deletions": 27,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a8498033e22ffdf707cbda77507cc1296e68c0e/src/timedata.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a8498033e22ffdf707cbda77507cc1296e68c0e/src/timedata.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.cpp?ref=7a8498033e22ffdf707cbda77507cc1296e68c0e",
        "patch": "@@ -6,19 +6,19 @@\n #include <config/bitcoin-config.h>\n #endif\n \n-#include <timedata.h>\n-\n #include <netaddress.h>\n #include <sync.h>\n+#include <timedata.h>\n #include <ui_interface.h>\n-#include <util/system.h>\n #include <util/strencodings.h>\n+#include <util/system.h>\n #include <warnings.h>\n \n \n static CCriticalSection cs_nTimeOffset;\n static int64_t nTimeOffset GUARDED_BY(cs_nTimeOffset) = 0;\n \n+\n /**\n  * \"Never go to sea with two chronometers; take one or three.\"\n  * Our three time sources are:\n@@ -42,22 +42,40 @@ static int64_t abs64(int64_t n)\n     return (n >= 0 ? n : -n);\n }\n \n+\n #define BITCOIN_TIMEDATA_MAX_SAMPLES 200\n \n+\n+static std::set<CNetAddr> setKnown;\n+\n+static CMedianFilter<int64_t> vTimeOffsets(BITCOIN_TIMEDATA_MAX_SAMPLES, 0);\n+\n+int CountOffsetSamples()\n+{\n+    LOCK(cs_nTimeOffset);\n+    return vTimeOffsets.size();\n+}\n+\n void AddTimeData(const CNetAddr& ip, int64_t nOffsetSample)\n {\n     LOCK(cs_nTimeOffset);\n+\n+    AddTimeDataAlgorithm(ip, nOffsetSample, setKnown, vTimeOffsets, nTimeOffset);\n+}\n+\n+\n+void AddTimeDataAlgorithm(const CNetAddr& ip, const int64_t nOffsetSample, std::set<CNetAddr>& knownSet, CMedianFilter<int64_t>& offsetFilter, int64_t& offset)\n+{\n     // Ignore duplicates\n-    static std::set<CNetAddr> setKnown;\n-    if (setKnown.size() == BITCOIN_TIMEDATA_MAX_SAMPLES)\n+\n+    if (knownSet.size() == BITCOIN_TIMEDATA_MAX_SAMPLES)\n         return;\n-    if (!setKnown.insert(ip).second)\n+    if (!knownSet.insert(ip).second)\n         return;\n \n     // Add data\n-    static CMedianFilter<int64_t> vTimeOffsets(BITCOIN_TIMEDATA_MAX_SAMPLES, 0);\n-    vTimeOffsets.input(nOffsetSample);\n-    LogPrint(BCLog::NET,\"added time data, samples %d, offset %+d (%+d minutes)\\n\", vTimeOffsets.size(), nOffsetSample, nOffsetSample/60);\n+    offsetFilter.input(nOffsetSample);\n+    LogPrint(BCLog::NET, \"added time data, samples %d, offset %+d (%+d minutes)\\n\", offsetFilter.size(), nOffsetSample, nOffsetSample / 60);\n \n     // There is a known issue here (see issue #4521):\n     //\n@@ -76,31 +94,25 @@ void AddTimeData(const CNetAddr& ip, int64_t nOffsetSample)\n     // So we should hold off on fixing this and clean it up as part of\n     // a timing cleanup that strengthens it in a number of other ways.\n     //\n-    if (vTimeOffsets.size() >= 5 && vTimeOffsets.size() % 2 == 1)\n-    {\n-        int64_t nMedian = vTimeOffsets.median();\n-        std::vector<int64_t> vSorted = vTimeOffsets.sorted();\n+    if (offsetFilter.size() >= 5 && offsetFilter.size() % 2 == 1) {\n+        int64_t nMedian = offsetFilter.median();\n+        std::vector<int64_t> vSorted = offsetFilter.sorted();\n         // Only let other nodes change our time by so much\n-        if (abs64(nMedian) <= std::max<int64_t>(0, gArgs.GetArg(\"-maxtimeadjustment\", DEFAULT_MAX_TIME_ADJUSTMENT)))\n-        {\n-            nTimeOffset = nMedian;\n-        }\n-        else\n-        {\n-            nTimeOffset = 0;\n+        if (abs64(nMedian) <= std::max<int64_t>(0, gArgs.GetArg(\"-maxtimeadjustment\", DEFAULT_MAX_TIME_ADJUSTMENT))) {\n+            offset = nMedian;\n+        } else {\n+            offset = 0;\n \n-            static bool fDone;\n-            if (!fDone)\n-            {\n+            static bool gDone;\n+            if (!gDone) {\n                 // If nobody has a time different than ours but within 5 minutes of ours, give a warning\n                 bool fMatch = false;\n                 for (const int64_t nOffset : vSorted)\n                     if (nOffset != 0 && abs64(nOffset) < 5 * 60)\n                         fMatch = true;\n \n-                if (!fMatch)\n-                {\n-                    fDone = true;\n+                if (!fMatch) {\n+                    gDone = true;\n                     std::string strMessage = strprintf(_(\"Please check that your computer's date and time are correct! If your clock is wrong, %s will not work properly.\"), _(PACKAGE_NAME));\n                     SetMiscWarning(strMessage);\n                     uiInterface.ThreadSafeMessageBox(strMessage, \"\", CClientUIInterface::MSG_WARNING);\n@@ -114,7 +126,7 @@ void AddTimeData(const CNetAddr& ip, int64_t nOffsetSample)\n             }\n             LogPrint(BCLog::NET, \"|  \"); /* Continued */\n \n-            LogPrint(BCLog::NET, \"nTimeOffset = %+d  (%+d minutes)\\n\", nTimeOffset, nTimeOffset/60);\n+            LogPrint(BCLog::NET, \"nTimeOffset = %+d  (%+d minutes)\\n\", offset, offset / 60);\n         }\n     }\n }"
      },
      {
        "sha": "fe641834ef4f5b28c3794bc93de3c37850591371",
        "filename": "src/timedata.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a8498033e22ffdf707cbda77507cc1296e68c0e/src/timedata.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a8498033e22ffdf707cbda77507cc1296e68c0e/src/timedata.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.h?ref=7a8498033e22ffdf707cbda77507cc1296e68c0e",
        "patch": "@@ -7,6 +7,7 @@\n \n #include <algorithm>\n #include <assert.h>\n+#include <set>\n #include <stdint.h>\n #include <vector>\n \n@@ -75,4 +76,8 @@ int64_t GetTimeOffset();\n int64_t GetAdjustedTime();\n void AddTimeData(const CNetAddr& ip, int64_t nTime);\n \n+/** Functions to enable testing the contract for AddTimeData */\n+int CountOffsetSamples();\n+void AddTimeDataAlgorithm(const CNetAddr& ip, const int64_t nOffsetSample, std::set<CNetAddr>& knownSet, CMedianFilter<int64_t>& offsetFilter, int64_t& offset);\n+\n #endif // BITCOIN_TIMEDATA_H"
      }
    ]
  },
  {
    "sha": "c4cd6dabde865558c98dc50de64dbaf6228eff09",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNGNkNmRhYmRlODY1NTU4Yzk4ZGM1MGRlNjRkYmFmNjIyOGVmZjA5",
    "commit": {
      "author": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-06T03:39:27Z"
      },
      "committer": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-06T03:39:27Z"
      },
      "message": "Merge remote-tracking branch 'origin/timedata_contract_test' into timedata_contract_test",
      "tree": {
        "sha": "4e4e740fd3aba7d291a9e1203d49d85b3464ae3a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4e4e740fd3aba7d291a9e1203d49d85b3464ae3a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c4cd6dabde865558c98dc50de64dbaf6228eff09",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c4cd6dabde865558c98dc50de64dbaf6228eff09",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c4cd6dabde865558c98dc50de64dbaf6228eff09",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c4cd6dabde865558c98dc50de64dbaf6228eff09/comments",
    "author": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7a8498033e22ffdf707cbda77507cc1296e68c0e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7a8498033e22ffdf707cbda77507cc1296e68c0e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7a8498033e22ffdf707cbda77507cc1296e68c0e"
      },
      {
        "sha": "b34dd93ff12bfcaa5fbc4cff133c65ce3e706dc3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b34dd93ff12bfcaa5fbc4cff133c65ce3e706dc3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b34dd93ff12bfcaa5fbc4cff133c65ce3e706dc3"
      }
    ],
    "stats": {
      "total": 0,
      "additions": 0,
      "deletions": 0
    },
    "files": []
  },
  {
    "sha": "305ebd25db4dfbe742ca693e4160dafaff2e8acd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozMDVlYmQyNWRiNGRmYmU3NDJjYTY5M2U0MTYwZGFmYWZmMmU4YWNk",
    "commit": {
      "author": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-06T21:09:03Z"
      },
      "committer": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-06T21:09:03Z"
      },
      "message": "function inet_pton requires inet.h on windows",
      "tree": {
        "sha": "d58d6a4374d09fde93ef5a0bc7f144d0a29a8497",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d58d6a4374d09fde93ef5a0bc7f144d0a29a8497"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/305ebd25db4dfbe742ca693e4160dafaff2e8acd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/305ebd25db4dfbe742ca693e4160dafaff2e8acd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/305ebd25db4dfbe742ca693e4160dafaff2e8acd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/305ebd25db4dfbe742ca693e4160dafaff2e8acd/comments",
    "author": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c4cd6dabde865558c98dc50de64dbaf6228eff09",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c4cd6dabde865558c98dc50de64dbaf6228eff09",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c4cd6dabde865558c98dc50de64dbaf6228eff09"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 1,
      "deletions": 0
    },
    "files": [
      {
        "sha": "a75a230454c67a52bd514b63236d3fc6fb05d21f",
        "filename": "src/test/timedata_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/305ebd25db4dfbe742ca693e4160dafaff2e8acd/src/test/timedata_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/305ebd25db4dfbe742ca693e4160dafaff2e8acd/src/test/timedata_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/timedata_tests.cpp?ref=305ebd25db4dfbe742ca693e4160dafaff2e8acd",
        "patch": "@@ -3,6 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n //\n #include <netaddress.h>\n+#include <arpa/inet.h>\n #include <test/test_bitcoin.h>\n #include <timedata.h>\n "
      }
    ]
  },
  {
    "sha": "8078dad339f44b544515d9e470840c9737c11cf4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4MDc4ZGFkMzM5ZjQ0YjU0NDUxNWQ5ZTQ3MDg0MGM5NzM3YzExY2Y0",
    "commit": {
      "author": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-10T23:11:03Z"
      },
      "committer": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-10T23:11:03Z"
      },
      "message": "enforced code conventions and added compat.h since arpa/inet.h not available on windows",
      "tree": {
        "sha": "406155e558645bca81ccaf98daaee709323be126",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/406155e558645bca81ccaf98daaee709323be126"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8078dad339f44b544515d9e470840c9737c11cf4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8078dad339f44b544515d9e470840c9737c11cf4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8078dad339f44b544515d9e470840c9737c11cf4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8078dad339f44b544515d9e470840c9737c11cf4/comments",
    "author": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "305ebd25db4dfbe742ca693e4160dafaff2e8acd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/305ebd25db4dfbe742ca693e4160dafaff2e8acd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/305ebd25db4dfbe742ca693e4160dafaff2e8acd"
      }
    ],
    "stats": {
      "total": 89,
      "additions": 42,
      "deletions": 47
    },
    "files": [
      {
        "sha": "e86a731c79c24813ff86d18dbc6714b51efec472",
        "filename": "src/test/timedata_tests.cpp",
        "status": "modified",
        "additions": 42,
        "deletions": 47,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8078dad339f44b544515d9e470840c9737c11cf4/src/test/timedata_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8078dad339f44b544515d9e470840c9737c11cf4/src/test/timedata_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/timedata_tests.cpp?ref=8078dad339f44b544515d9e470840c9737c11cf4",
        "patch": "@@ -2,8 +2,8 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n //\n+#include <compat.h>\n #include <netaddress.h>\n-#include <arpa/inet.h>\n #include <test/test_bitcoin.h>\n #include <timedata.h>\n \n@@ -52,27 +52,43 @@ BOOST_AUTO_TEST_CASE(util_MedianFilterShallNotGrowBeyondSize)\n }\n \n \n-CNetAddr utilBuildAddress(std::string address);\n+CNetAddr UtilBuildAddress(const std::string& address)\n+{\n+    struct sockaddr_in sa;\n+    inet_pton(AF_INET, address.c_str(), &(sa.sin_addr));\n+    CNetAddr addr = CNetAddr(sa.sin_addr);\n+    return addr;\n+}\n \n-void utilPreconditionIsAtLeastFiveEntriesRequired(std::string baseip, int basevalue);\n+\n+void UtilPreconditionIsAtLeastFiveEntriesRequired(const std::string& baseip, int basevalue)\n+{\n+    for (int i = CountOffsetSamples(); i < 5; i++) { // precondition 1: at least 5 entries required to compute any offset\n+        int val = basevalue + i;\n+        std::stringstream stream;\n+        stream << baseip << val;\n+        std::string ip = stream.str();\n+        AddTimeData(UtilBuildAddress(ip), val);\n+    }\n+}\n \n \n BOOST_AUTO_TEST_CASE(util_AddTimeDataComputeOffsetWhenSampleCountIsUneven)\n {\n-    utilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.1.\", 200); // precondition 1: at least 5 entries required to compute any offset\n+    UtilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.1.\", 200); // precondition 1: at least 5 entries required to compute any offset\n     BOOST_CHECK(CountOffsetSamples() >= 5);\n \n \n     if ((CountOffsetSamples() % 2) == 1) { // precondition 2: start with an even number of samples\n-        AddTimeData(utilBuildAddress(\"1.1.1.210\"), 210);\n+        AddTimeData(UtilBuildAddress(\"1.1.1.210\"), 210);\n     }\n \n     BOOST_CHECK(CountOffsetSamples() % 2 == 0);\n \n \n     int64_t offset = GetTimeOffset();\n     int samples = CountOffsetSamples();\n-    AddTimeData(utilBuildAddress(\"1.1.1.211\"), 211);\n+    AddTimeData(UtilBuildAddress(\"1.1.1.211\"), 211);\n \n     BOOST_CHECK_EQUAL(CountOffsetSamples(), samples + 1); // sample was added\n     BOOST_CHECK(GetTimeOffset() != offset);               // and new offset was computed\n@@ -81,20 +97,20 @@ BOOST_AUTO_TEST_CASE(util_AddTimeDataComputeOffsetWhenSampleCountIsUneven)\n \n BOOST_AUTO_TEST_CASE(util_AddTimeDataDoNotComputeOffsetWhenSampleCountIsEven)\n {\n-    utilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.1.\", 100); // precondition 1: at least 5 entries required to compute any offset\n+    UtilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.1.\", 100); // precondition 1: at least 5 entries required to compute any offset\n \n     BOOST_CHECK(CountOffsetSamples() >= 5);\n \n     if (CountOffsetSamples() % 2 == 0) { // precondition 2: start with an uneven number of samples\n-        AddTimeData(utilBuildAddress(\"1.1.1.110\"), 110);\n+        AddTimeData(UtilBuildAddress(\"1.1.1.110\"), 110);\n     }\n \n     BOOST_CHECK(CountOffsetSamples() % 2 == 1);\n \n \n     int64_t offset = GetTimeOffset();\n     int samples = CountOffsetSamples();\n-    AddTimeData(utilBuildAddress(\"1.1.1.111\"), 111);\n+    AddTimeData(UtilBuildAddress(\"1.1.1.111\"), 111);\n \n     BOOST_CHECK_EQUAL(CountOffsetSamples(), samples + 1); // sample was added\n     BOOST_CHECK_EQUAL(GetTimeOffset(), offset);           //new offset was not computed\n@@ -103,15 +119,15 @@ BOOST_AUTO_TEST_CASE(util_AddTimeDataDoNotComputeOffsetWhenSampleCountIsEven)\n \n BOOST_AUTO_TEST_CASE(util_AddTimeDataIgnoreSampleWithDuplicateIP)\n {\n-    utilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.1.\", 300); // precondition 1: at least 5 entries required to compute any offset\n+    UtilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.1.\", 300); // precondition 1: at least 5 entries required to compute any offset\n     BOOST_CHECK(CountOffsetSamples() >= 5);\n \n \n-    AddTimeData(utilBuildAddress(\"1.1.1.310\"), 310);\n+    AddTimeData(UtilBuildAddress(\"1.1.1.310\"), 310);\n \n     int64_t offset = GetTimeOffset();\n     int samples = CountOffsetSamples();\n-    AddTimeData(utilBuildAddress(\"1.1.1.310\"), 311);\n+    AddTimeData(UtilBuildAddress(\"1.1.1.310\"), 311);\n \n     BOOST_CHECK_EQUAL(CountOffsetSamples(), samples); // sample was ignored\n     BOOST_CHECK_EQUAL(GetTimeOffset(), offset);       //new offset was not computed\n@@ -130,13 +146,13 @@ BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmMedianIsWithinBounds)\n         std::stringstream stream;\n         stream << \"1.1.1.\" << sample;\n         std::string ip = stream.str();\n-        AddTimeDataAlgorithm(utilBuildAddress(ip), sample, knownSet, offsetFilter, offset);\n+        AddTimeDataAlgorithm(UtilBuildAddress(ip), sample, knownSet, offsetFilter, offset);\n     }\n \n     BOOST_CHECK_EQUAL(offset, 0);\n     BOOST_CHECK_EQUAL(offsetFilter.size(), 4);\n \n-    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.200\"), 200, knownSet, offsetFilter, offset);\n+    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.200\"), 200, knownSet, offsetFilter, offset);\n \n     BOOST_CHECK_EQUAL(offset, offsetFilter.median());\n     BOOST_CHECK_EQUAL(offsetFilter.size(), 5);\n@@ -153,22 +169,22 @@ BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmMedianIsOutsideBounds)\n         std::stringstream stream;\n         stream << \"1.1.1.\" << 1 + sample;\n         std::string ip = stream.str();\n-        AddTimeDataAlgorithm(utilBuildAddress(ip), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset);\n+        AddTimeDataAlgorithm(UtilBuildAddress(ip), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset);\n     } // sorted filter: 0 x x x  -- x is outside the boundaries\n \n     BOOST_CHECK_EQUAL(offset, 0);\n     BOOST_CHECK_EQUAL(offsetFilter.size(), 4);\n \n     // offset is computed only when number of entries is uneven\n-    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.5\"), 1, knownSet, offsetFilter, offset); // sorted filter : 0 1 (x) x x  -- median (x)\n+    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.5\"), 1, knownSet, offsetFilter, offset); // sorted filter : 0 1 (x) x x  -- median (x)\n     BOOST_CHECK_EQUAL(offset, 0);\n-    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.6\"), 1, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 x x x\n+    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.6\"), 1, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 x x x\n     BOOST_CHECK_EQUAL(offset, 0);\n-    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.7\"), 1, knownSet, offsetFilter, offset);                               // sorted filter : 0 1 1 (1) x x x x -- median (1)\n+    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.7\"), 1, knownSet, offsetFilter, offset);                               // sorted filter : 0 1 1 (1) x x x x -- median (1)\n     BOOST_CHECK_EQUAL(offset, 1);                                                                                       // flip to 1\n-    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.8\"), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 1 x x x x x\n+    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.8\"), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 1 x x x x x\n     BOOST_CHECK_EQUAL(offset, 1);\n-    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.9\"), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 1 (x) x x x x x -- median (x)\n+    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.9\"), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 1 (x) x x x x x -- median (x)\n     BOOST_CHECK_EQUAL(offset, 0);                                                                                       // flip back to zero\n \n     BOOST_CHECK_EQUAL(offsetFilter.size(), 9);\n@@ -181,16 +197,16 @@ BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmAtLeastFiveSamplesToComputeOffset)\n     std::set<CNetAddr> knownSet;\n     CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : limit , init value: 0\n \n-    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.1\"), 1, knownSet, offsetFilter, offset);\n+    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.1\"), 1, knownSet, offsetFilter, offset);\n     BOOST_CHECK_EQUAL(offset, 0);\n \n-    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.2\"), 2, knownSet, offsetFilter, offset);\n+    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.2\"), 2, knownSet, offsetFilter, offset);\n     BOOST_CHECK_EQUAL(offset, 0);\n \n-    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.3\"), 3, knownSet, offsetFilter, offset);\n+    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.3\"), 3, knownSet, offsetFilter, offset);\n     BOOST_CHECK_EQUAL(offset, 0);\n \n-    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.4\"), 4, knownSet, offsetFilter, offset); // this is the fifth entry\n+    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.4\"), 4, knownSet, offsetFilter, offset); // this is the fifth entry\n     BOOST_CHECK_EQUAL(offset, 2);\n }\n \n@@ -206,39 +222,18 @@ BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmIgnoresSamplesBeyondInternalLimit)\n         std::stringstream stream;\n         stream << \"1.1.1.\" << sample;\n         std::string ip = stream.str();\n-        AddTimeDataAlgorithm(utilBuildAddress(ip), sample, knownSet, offsetFilter, offset);\n+        AddTimeDataAlgorithm(UtilBuildAddress(ip), sample, knownSet, offsetFilter, offset);\n     }\n \n     BOOST_CHECK_EQUAL(offsetFilter.size(), limit);\n \n     int64_t pre = offset;\n     int size = offsetFilter.size();\n \n-    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.200\"), 200, knownSet, offsetFilter, offset);\n+    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.200\"), 200, knownSet, offsetFilter, offset);\n \n     BOOST_CHECK_EQUAL(offset, pre);\n     BOOST_CHECK_EQUAL(offsetFilter.size(), size);\n }\n \n-\n-CNetAddr utilBuildAddress(std::string address)\n-{\n-    struct sockaddr_in sa;\n-    inet_pton(AF_INET, address.c_str(), &(sa.sin_addr));\n-    CNetAddr addr = CNetAddr(sa.sin_addr);\n-    return addr;\n-}\n-\n-\n-void utilPreconditionIsAtLeastFiveEntriesRequired(std::string baseip, int basevalue)\n-{\n-    for (int i = CountOffsetSamples(); i < 5; i++) { // precondition 1: at least 5 entries required to compute any offset\n-        int val = basevalue + i;\n-        std::stringstream stream;\n-        stream << baseip << val;\n-        std::string ip = stream.str();\n-        AddTimeData(utilBuildAddress(ip.c_str()), val);\n-    }\n-}\n-\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "0c56993ffc27ce7e2a089aafea202a1f4c17fa4a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowYzU2OTkzZmZjMjdjZTdlMmEwODlhYWZlYTIwMmExZjRjMTdmYTRh",
    "commit": {
      "author": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-11T20:55:13Z"
      },
      "committer": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-11T20:55:13Z"
      },
      "message": "compat.already included in netaddress.h shall support windows vista",
      "tree": {
        "sha": "3016a8eae353c848cde53b0f26e30474c7050e30",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3016a8eae353c848cde53b0f26e30474c7050e30"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0c56993ffc27ce7e2a089aafea202a1f4c17fa4a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0c56993ffc27ce7e2a089aafea202a1f4c17fa4a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0c56993ffc27ce7e2a089aafea202a1f4c17fa4a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0c56993ffc27ce7e2a089aafea202a1f4c17fa4a/comments",
    "author": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8078dad339f44b544515d9e470840c9737c11cf4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8078dad339f44b544515d9e470840c9737c11cf4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8078dad339f44b544515d9e470840c9737c11cf4"
      }
    ],
    "stats": {
      "total": 3,
      "additions": 1,
      "deletions": 2
    },
    "files": [
      {
        "sha": "c539ce7fd80e5f703845a02140b13d4d138411fa",
        "filename": "src/compat.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0c56993ffc27ce7e2a089aafea202a1f4c17fa4a/src/compat.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0c56993ffc27ce7e2a089aafea202a1f4c17fa4a/src/compat.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat.h?ref=0c56993ffc27ce7e2a089aafea202a1f4c17fa4a",
        "patch": "@@ -14,7 +14,7 @@\n #ifdef _WIN32_WINNT\n #undef _WIN32_WINNT\n #endif\n-#define _WIN32_WINNT 0x0501\n+#define _WIN32_WINNT 0x0600\n #ifndef WIN32_LEAN_AND_MEAN\n #define WIN32_LEAN_AND_MEAN 1\n #endif"
      },
      {
        "sha": "4fab1dded4393bbfdf6ade3bf9f88c7d7c076080",
        "filename": "src/test/timedata_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0c56993ffc27ce7e2a089aafea202a1f4c17fa4a/src/test/timedata_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0c56993ffc27ce7e2a089aafea202a1f4c17fa4a/src/test/timedata_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/timedata_tests.cpp?ref=0c56993ffc27ce7e2a089aafea202a1f4c17fa4a",
        "patch": "@@ -2,7 +2,6 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n //\n-#include <compat.h>\n #include <netaddress.h>\n #include <test/test_bitcoin.h>\n #include <timedata.h>"
      }
    ]
  },
  {
    "sha": "27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyN2NkOTVlOTM2NmJlZDc0MDc4ZWE5YmEzYTc2Y2M4MWEyN2I4ZmE3",
    "commit": {
      "author": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-20T17:47:19Z"
      },
      "committer": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-20T17:47:19Z"
      },
      "message": "Merge branch 'master' into timedata_contract_test",
      "tree": {
        "sha": "e70490fca844e68377c640d74239a031df217619",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e70490fca844e68377c640d74239a031df217619"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/comments",
    "author": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0c56993ffc27ce7e2a089aafea202a1f4c17fa4a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0c56993ffc27ce7e2a089aafea202a1f4c17fa4a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0c56993ffc27ce7e2a089aafea202a1f4c17fa4a"
      },
      {
        "sha": "86e0a33f5c382513d5179e3fdf158baf952d7e2f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/86e0a33f5c382513d5179e3fdf158baf952d7e2f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/86e0a33f5c382513d5179e3fdf158baf952d7e2f"
      }
    ],
    "stats": {
      "total": 5729,
      "additions": 3127,
      "deletions": 2602
    },
    "files": [
      {
        "sha": "7bcbb3808b5089efd99f8473833c9576236b8357",
        "filename": ".python-version",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/.python-version",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/.python-version",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.python-version?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -0,0 +1 @@\n+3.4.9"
      },
      {
        "sha": "a7c6e03f2d6ae583654ee3aafaa7be6237e843e8",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -43,7 +43,7 @@ jobs:\n       env:\n       cache: false\n       language: python\n-      python: '3.6'\n+      python: '3.4' # Oldest supported version according to doc/dependencies.md\n       install:\n         - set -o errexit; source .travis/lint_04_install.sh\n       before_script:\n@@ -99,9 +99,9 @@ jobs:\n         DOCKER_NAME_TAG=ubuntu:16.04\n         PACKAGES=\"clang llvm python3-zmq qtbase5-dev qttools5-dev-tools libssl-dev libevent-dev bsdmainutils libboost-system-dev libboost-filesystem-dev libboost-chrono-dev libboost-test-dev libboost-thread-dev libdb5.3++-dev libminiupnpc-dev libzmq3-dev libprotobuf-dev protobuf-compiler libqrencode-dev\"\n         NO_DEPENDS=1\n-        RUN_FUNCTIONAL_TESTS=false # Disabled for now. TODO identify suppressions or exclude specific tests\n+        FUNCTIONAL_TESTS_CONFIG=\"--exclude feature_block.py,p2p_invalid_messages.py\"\n         GOAL=\"install\"\n-        BITCOIN_CONFIG=\"--enable-zmq --with-incompatible-bdb --with-gui=qt5 CPPFLAGS=-DDEBUG_LOCKORDER --with-sanitizers=thread --disable-hardening --disable-asm CC=clang CXX=clang++\"\n+        BITCOIN_CONFIG=\"--enable-zmq --disable-wallet --with-gui=qt5 CPPFLAGS=-DDEBUG_LOCKORDER --with-sanitizers=thread --disable-hardening --disable-asm CC=clang CXX=clang++\"\n # x86_64 Linux (no depends, only system libs, sanitizers: address/leak (ASan + LSan) + undefined (UBSan) + integer)\n     - stage: test\n       env: >-"
      },
      {
        "sha": "3f74158117654e46627d317eddb0c1fd5864f756",
        "filename": ".travis/test_04_install.sh",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/.travis/test_04_install.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/.travis/test_04_install.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis/test_04_install.sh?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -7,9 +7,10 @@\n export LC_ALL=C.UTF-8\n \n travis_retry docker pull \"$DOCKER_NAME_TAG\"\n+mkdir -p \"${TRAVIS_BUILD_DIR}/sanitizer-output/\"\n export ASAN_OPTIONS=\"\"\n export LSAN_OPTIONS=\"suppressions=${TRAVIS_BUILD_DIR}/test/sanitizer_suppressions/lsan\"\n-export TSAN_OPTIONS=\"suppressions=${TRAVIS_BUILD_DIR}/test/sanitizer_suppressions/tsan\"\n+export TSAN_OPTIONS=\"suppressions=${TRAVIS_BUILD_DIR}/test/sanitizer_suppressions/tsan:log_path=${TRAVIS_BUILD_DIR}/sanitizer-output/tsan\"\n export UBSAN_OPTIONS=\"suppressions=${TRAVIS_BUILD_DIR}/test/sanitizer_suppressions/ubsan:print_stacktrace=1:halt_on_error=1\"\n env | grep -E '^(BITCOIN_CONFIG|CCACHE_|WINEDEBUG|LC_ALL|BOOST_TEST_RANDOM|CONFIG_SHELL|(ASAN|LSAN|TSAN|UBSAN)_OPTIONS)' | tee /tmp/env\n if [[ $HOST = *-mingw32 ]]; then"
      },
      {
        "sha": "618aa2c3b6ee88705868df5231b3890e8fd2bb5e",
        "filename": ".travis/test_06_script.sh",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/.travis/test_06_script.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/.travis/test_06_script.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis/test_06_script.sh?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -40,6 +40,9 @@ BEGIN_FOLD configure\n DOCKER_EXEC ./configure --cache-file=../config.cache $BITCOIN_CONFIG_ALL $BITCOIN_CONFIG || ( cat config.log && false)\n END_FOLD\n \n+set -o errtrace\n+trap 'DOCKER_EXEC \"cat ${TRAVIS_BUILD_DIR}/sanitizer-output/* 2> /dev/null\"' ERR\n+\n BEGIN_FOLD build\n DOCKER_EXEC make $MAKEJOBS $GOAL || ( echo \"Build failure. Verbose build follows.\" && DOCKER_EXEC make $GOAL V=1 ; false )\n END_FOLD"
      },
      {
        "sha": "2d34b83047e9bbb5a9753bf8a5778f4296a0db9a",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 20,
        "deletions": 10,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -214,7 +214,7 @@ AC_ARG_ENABLE([bip70],\n   [AS_HELP_STRING([--disable-bip70],\n   [disable BIP70 (payment protocol) support in GUI (enabled by default)])],\n   [enable_bip70=$enableval],\n-  [enable_bip70=yes])\n+  [enable_bip70=auto])\n \n AC_ARG_WITH([protoc-bindir],[AS_HELP_STRING([--with-protoc-bindir=BIN_DIR],[specify protoc bin path])], [protoc_bin_path=$withval], [])\n \n@@ -1089,7 +1089,7 @@ if test x$use_pkgconfig = xyes; then\n       PKG_CHECK_MODULES([SSL], [libssl],, [AC_MSG_ERROR(openssl not found.)])\n       PKG_CHECK_MODULES([CRYPTO], [libcrypto],,[AC_MSG_ERROR(libcrypto not found.)])\n       if test x$enable_bip70 != xno; then\n-        BITCOIN_QT_CHECK([PKG_CHECK_MODULES([PROTOBUF], [protobuf], [have_protobuf=yes], [BITCOIN_QT_FAIL(libprotobuf not found)])])\n+        BITCOIN_QT_CHECK([PKG_CHECK_MODULES([PROTOBUF], [protobuf], [have_protobuf=yes], [have_protobuf=no])])\n       fi\n       if test x$use_qr != xno; then\n         BITCOIN_QT_CHECK([PKG_CHECK_MODULES([QR], [libqrencode], [have_qrencode=yes], [have_qrencode=no])])\n@@ -1151,7 +1151,7 @@ else\n   fi\n \n   if test x$enable_bip70 != xno; then\n-    BITCOIN_QT_CHECK(AC_CHECK_LIB([protobuf] ,[main],[PROTOBUF_LIBS=-lprotobuf], BITCOIN_QT_FAIL(libprotobuf not found)))\n+    BITCOIN_QT_CHECK(AC_CHECK_LIB([protobuf] ,[main],[PROTOBUF_LIBS=-lprotobuf], [have_protobuf=no]))\n   fi\n   if test x$use_qr != xno; then\n     BITCOIN_QT_CHECK([AC_CHECK_LIB([qrencode], [main],[QR_LIBS=-lqrencode], [have_qrencode=no])])\n@@ -1230,8 +1230,10 @@ AM_CONDITIONAL([EMBEDDED_UNIVALUE],[test x$need_bundled_univalue = xyes])\n AC_SUBST(UNIVALUE_CFLAGS)\n AC_SUBST(UNIVALUE_LIBS)\n \n-if test x$enable_bip70 != xno; then\n-BITCOIN_QT_PATH_PROGS([PROTOC], [protoc],$protoc_bin_path)\n+\n+if test x$have_protobuf != xno &&\n+   test x$enable_bip70 != xno; then\n+  BITCOIN_QT_PATH_PROGS([PROTOC], [protoc],$protoc_bin_path)\n fi\n \n AC_MSG_CHECKING([whether to build bitcoind])\n@@ -1352,12 +1354,20 @@ if test x$bitcoin_enable_qt != xno; then\n   fi\n \n   AC_MSG_CHECKING([whether to build BIP70 support])\n-  if test x$enable_bip70 != xno; then\n-    AC_DEFINE([ENABLE_BIP70],[1],[Define if BIP70 support should be compiled in])\n-    enable_bip70=yes\n-    AC_MSG_RESULT([yes])\n+  if test x$have_protobuf = xno; then\n+    if test x$enable_bip70 = xyes; then\n+      AC_MSG_ERROR(protobuf missing)\n+    fi\n+    enable_bip70=no\n+    AC_MSG_RESULT(no)\n   else\n-    AC_MSG_RESULT([no])\n+    if test x$enable_bip70 != xno; then\n+      AC_DEFINE([ENABLE_BIP70],[1],[Define if BIP70 support should be compiled in])\n+      enable_bip70=yes\n+      AC_MSG_RESULT([yes])\n+    else\n+      AC_MSG_RESULT([no])\n+    fi\n   fi\n fi\n "
      },
      {
        "sha": "f322b3a88049a603ad517eccc272522bfc1f0202",
        "filename": "contrib/devtools/clang-format-diff.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/contrib/devtools/clang-format-diff.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/contrib/devtools/clang-format-diff.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/clang-format-diff.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -109,7 +109,7 @@ def main():\n     match = re.search('^\\+\\+\\+\\ (.*?/){%s}(\\S*)' % args.p, line)\n     if match:\n       filename = match.group(2)\n-    if filename == None:\n+    if filename is None:\n       continue\n \n     if args.regex is not None:"
      },
      {
        "sha": "6d7a592f01f3b9eabced711881c71f03107950e6",
        "filename": "contrib/devtools/copyright_header.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/contrib/devtools/copyright_header.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/contrib/devtools/copyright_header.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/copyright_header.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -491,7 +491,7 @@ def get_git_change_year_range(filename):\n \n def file_already_has_core_copyright(file_lines):\n     index, _ = get_updatable_copyright_line(file_lines)\n-    return index != None\n+    return index is not None\n \n ################################################################################\n # insert header execution"
      },
      {
        "sha": "4f827401fbf3d274f6755a441e76aa1d68498526",
        "filename": "contrib/devtools/github-merge.py",
        "status": "modified",
        "additions": 1,
        "deletions": 5,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/contrib/devtools/github-merge.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/contrib/devtools/github-merge.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/github-merge.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -14,7 +14,6 @@\n \n # In case of a clean merge that is accepted by the user, the local branch with\n # name $BRANCH is overwritten with the merged result, and optionally pushed.\n-from __future__ import division,print_function,unicode_literals\n import os\n from sys import stdin,stdout,stderr\n import argparse\n@@ -23,10 +22,7 @@\n import sys\n import json\n import codecs\n-try:\n-    from urllib.request import Request,urlopen\n-except:\n-    from urllib2 import Request,urlopen\n+from urllib.request import Request, urlopen\n \n # External tools (can be overridden using environment)\n GIT = os.getenv('GIT','git')"
      },
      {
        "sha": "44b7f6c7cc41072f7ab08fe7bf0bf590e48db1ad",
        "filename": "contrib/devtools/security-check.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/contrib/devtools/security-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/contrib/devtools/security-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/security-check.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -86,7 +86,7 @@ def check_ELF_RELRO(executable):\n         # This does not affect security: the permission flags of the GNU_RELRO program header are ignored, the PT_LOAD header determines the effective permissions.\n         # However, the dynamic linker need to write to this area so these are RW.\n         # Glibc itself takes care of mprotecting this area R after relocations are finished.\n-        # See also http://permalink.gmane.org/gmane.comp.gnu.binutils/71347\n+        # See also https://marc.info/?l=binutils&m=1498883354122353\n         if typ == 'GNU_RELRO':\n             have_gnu_relro = True\n "
      },
      {
        "sha": "1b9d3a4c279d4b91778068591de5b0962e105876",
        "filename": "contrib/devtools/update-translations.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/contrib/devtools/update-translations.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/contrib/devtools/update-translations.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/update-translations.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -125,7 +125,7 @@ def escape_cdata(text):\n     return text\n \n def contains_bitcoin_addr(text, errors):\n-    if text != None and ADDRESS_REGEXP.search(text) != None:\n+    if text is not None and ADDRESS_REGEXP.search(text) is not None:\n         errors.append('Translation \"%s\" contains a bitcoin address. This will be removed.' % (text))\n         return True\n     return False"
      },
      {
        "sha": "e90b8af7e103b123168ec372862f963629f4dd51",
        "filename": "contrib/install_db4.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/contrib/install_db4.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/contrib/install_db4.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/install_db4.sh?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -51,7 +51,7 @@ http_get() {\n   if [ -f \"${2}\" ]; then\n     echo \"File ${2} already exists; not downloading again\"\n   elif check_exists curl; then\n-    curl --insecure \"${1}\" -o \"${2}\"\n+    curl --insecure --retry 5 \"${1}\" -o \"${2}\"\n   else\n     wget --no-check-certificate \"${1}\" -O \"${2}\"\n   fi"
      },
      {
        "sha": "56c1fbfc92167e7343b3fbbaa70597214976e397",
        "filename": "contrib/linearize/linearize-data.py",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/contrib/linearize/linearize-data.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/contrib/linearize/linearize-data.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/linearize/linearize-data.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -7,7 +7,6 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n #\n \n-from __future__ import print_function, division\n import struct\n import re\n import os"
      },
      {
        "sha": "e10b46d831c7dbe6c73e6fb2cfd7704dffe5eb43",
        "filename": "contrib/linearize/linearize-hashes.py",
        "status": "modified",
        "additions": 2,
        "deletions": 6,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/contrib/linearize/linearize-hashes.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/contrib/linearize/linearize-hashes.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/linearize/linearize-hashes.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -7,11 +7,7 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n #\n \n-from __future__ import print_function\n-try: # Python 3\n-    import http.client as httplib\n-except ImportError: # Python 2\n-    import httplib\n+from http.client import HttpConnection\n import json\n import re\n import base64\n@@ -31,7 +27,7 @@ def __init__(self, host, port, username, password):\n         authpair = \"%s:%s\" % (username, password)\n         authpair = authpair.encode('utf-8')\n         self.authhdr = b\"Basic \" + base64.b64encode(authpair)\n-        self.conn = httplib.HTTPConnection(host, port=port, timeout=30)\n+        self.conn = HttpConnection(host, port=port, timeout=30)\n \n     def execute(self, obj):\n         try:"
      },
      {
        "sha": "5f9b87d9b23fbccca183bdcd83fbc84a9ec60372",
        "filename": "contrib/qos/tc.sh",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/contrib/qos/tc.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/contrib/qos/tc.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/qos/tc.sh?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -1,3 +1,5 @@\n+#!/usr/bin/env bash\n+#\n # Copyright (c) 2017 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php."
      },
      {
        "sha": "27ca15acb434c6274b0473a5dd21734752e29199",
        "filename": "contrib/verify-commits/README.md",
        "status": "modified",
        "additions": 13,
        "deletions": 4,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/contrib/verify-commits/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/contrib/verify-commits/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verify-commits/README.md?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -3,7 +3,7 @@ Tooling for verification of PGP signed commits\n \n This is an incomplete work in progress, but currently includes a pre-push hook\n script (`pre-push-hook.sh`) for maintainers to ensure that their own commits\n-are PGP signed (nearly always merge commits), as well as a script to verify\n+are PGP signed (nearly always merge commits), as well as a Python 3 script to verify\n commits against a trusted keys list.\n \n \n@@ -17,9 +17,11 @@ be backdoored. Instead, you need to use a trusted version of verify-commits\n prior to checkout to make sure you're checking out only code signed by trusted\n keys:\n \n-    git fetch origin && \\\n-      ./contrib/verify-commits/verify-commits.py origin/master && \\\n-      git checkout origin/master\n+ ```sh\n+ git fetch origin && \\\n+ ./contrib/verify-commits/verify-commits.py origin/master && \\\n+ git checkout origin/master\n+ ```\n \n Note that the above isn't a good UI/UX yet, and needs significant improvements\n to make it more convenient and reduce the chance of errors; pull-reqs\n@@ -33,6 +35,13 @@ Configuration files\n * `trusted-keys`: This file should contain a \\n-delimited list of all PGP fingerprints of authorized commit signers (primary, not subkeys).\n * `allow-revsig-commits`: This file should contain a \\n-delimited list of git commit hashes. See next section for more info.\n \n+Import trusted keys\n+-------------------\n+In order to check the commit signatures you must add the trusted PGP keys to your machine. This can be done in Linux by running\n+```sh\n+gpg --recv-keys $(<contrib/verify-commits/trusted-keys)\n+```\n+\n Key expiry/revocation\n ---------------------\n "
      },
      {
        "sha": "a10da9d822279e363b617e64bd281bc28629de6d",
        "filename": "contrib/verify-commits/trusted-keys",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/contrib/verify-commits/trusted-keys",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/contrib/verify-commits/trusted-keys",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verify-commits/trusted-keys?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -2,3 +2,4 @@\n 133EAC179436F14A5CF1B794860FEB804E669320\n 32EE5C4C3FA15CCADB46ABE529D4BCB6416F53EC\n B8B3F1C0E58C15DB6A81D30C3648A882F4316B9B\n+CA03882CB1FC067B5D3ACFE4D300116E1C875A3D"
      },
      {
        "sha": "b3c8064ec24c77a0e2a24d005062bc4fa712ea7f",
        "filename": "contrib/verify-commits/verify-commits.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/contrib/verify-commits/verify-commits.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/contrib/verify-commits/verify-commits.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verify-commits/verify-commits.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -139,7 +139,7 @@ def main():\n         if len(parents) == 2 and check_merge and not allow_unclean:\n             current_tree = subprocess.check_output([GIT, 'show', '--format=%T', current_commit], universal_newlines=True, encoding='utf8').splitlines()[0]\n             subprocess.call([GIT, 'checkout', '--force', '--quiet', parents[0]])\n-            subprocess.call([GIT, 'merge', '--no-ff', '--quiet', parents[1]], stdout=subprocess.DEVNULL)\n+            subprocess.call([GIT, 'merge', '--no-ff', '--quiet', '--no-gpg-sign', parents[1]], stdout=subprocess.DEVNULL)\n             recreated_tree = subprocess.check_output([GIT, 'show', '--format=format:%T', 'HEAD'], universal_newlines=True, encoding='utf8').splitlines()[0]\n             if current_tree != recreated_tree:\n                 print(\"Merge commit {} is not clean\".format(current_commit), file=sys.stderr)"
      },
      {
        "sha": "8d06882cdb50e4fea29a54991860649cb5ffd086",
        "filename": "depends/packages/expat.mk",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/depends/packages/expat.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/depends/packages/expat.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/expat.mk?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -1,11 +1,11 @@\n package=expat\n-$(package)_version=2.2.5\n-$(package)_download_path=https://github.com/libexpat/libexpat/releases/download/R_2_2_5/\n+$(package)_version=2.2.6\n+$(package)_download_path=https://github.com/libexpat/libexpat/releases/download/R_2_2_6/\n $(package)_file_name=$(package)-$($(package)_version).tar.bz2\n-$(package)_sha256_hash=d9dc32efba7e74f788fcc4f212a43216fc37cf5f23f4c2339664d473353aedf6\n+$(package)_sha256_hash=17b43c2716d521369f82fc2dc70f359860e90fa440bea65b3b85f0b246ea81f2\n \n define $(package)_set_vars\n-$(package)_config_opts=--disable-static\n+$(package)_config_opts=--disable-static --without-docbook\n endef\n \n define $(package)_config_cmds"
      },
      {
        "sha": "deebf13e985f3ca2c98cf3a79ebe85b4c7393144",
        "filename": "depends/packages/qt.mk",
        "status": "modified",
        "additions": 16,
        "deletions": 4,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/depends/packages/qt.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/depends/packages/qt.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/qt.mk?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -1,20 +1,20 @@\n PACKAGE=qt\n-$(package)_version=5.9.6\n+$(package)_version=5.9.7\n $(package)_download_path=https://download.qt.io/official_releases/qt/5.9/$($(package)_version)/submodules\n $(package)_suffix=opensource-src-$($(package)_version).tar.xz\n $(package)_file_name=qtbase-$($(package)_suffix)\n-$(package)_sha256_hash=eed620cb268b199bd83b3fc6a471c51d51e1dc2dbb5374fc97a0cc75facbe36f\n+$(package)_sha256_hash=36dd9574f006eaa1e5af780e4b33d11fe39d09fd7c12f3b9d83294174bd28f00\n $(package)_dependencies=openssl zlib\n $(package)_linux_dependencies=freetype fontconfig libxcb libX11 xproto libXext\n $(package)_build_subdir=qtbase\n $(package)_qt_libs=corelib network widgets gui plugins testlib\n $(package)_patches=fix_qt_pkgconfig.patch mac-qmake.conf fix_configure_mac.patch fix_no_printer.patch fix_rcc_determinism.patch fix_riscv64_arch.patch xkb-default.patch\n \n $(package)_qttranslations_file_name=qttranslations-$($(package)_suffix)\n-$(package)_qttranslations_sha256_hash=9822084f8e2d2939ba39f4af4c0c2320e45d5996762a9423f833055607604ed8\n+$(package)_qttranslations_sha256_hash=b36da7d93c3ab6fca56b32053bb73bc619c8b192bb89b74e3bcde2705f1c2a14\n \n $(package)_qttools_file_name=qttools-$($(package)_suffix)\n-$(package)_qttools_sha256_hash=50e75417ec0c74bb8b1989d1d8e981ee83690dce7dfc0c2169f7c00f397e5117\n+$(package)_qttools_sha256_hash=d62e0f70d99645d6704dbb8976fb2222443061743689943d40970c52c49367a1\n \n $(package)_extra_sources  = $($(package)_qttranslations_file_name)\n $(package)_extra_sources += $($(package)_qttools_file_name)\n@@ -27,6 +27,7 @@ $(package)_config_opts += -c++std c++11\n $(package)_config_opts += -confirm-license\n $(package)_config_opts += -dbus-runtime\n $(package)_config_opts += -hostprefix $(build_prefix)\n+$(package)_config_opts += -no-compile-examples\n $(package)_config_opts += -no-cups\n $(package)_config_opts += -no-egl\n $(package)_config_opts += -no-eglfs\n@@ -69,9 +70,20 @@ $(package)_config_opts += -system-zlib\n $(package)_config_opts += -static\n $(package)_config_opts += -silent\n $(package)_config_opts += -v\n+$(package)_config_opts += -no-feature-dial\n+$(package)_config_opts += -no-feature-ftp\n+$(package)_config_opts += -no-feature-lcdnumber\n+$(package)_config_opts += -no-feature-pdf\n $(package)_config_opts += -no-feature-printer\n $(package)_config_opts += -no-feature-printdialog\n $(package)_config_opts += -no-feature-concurrent\n+$(package)_config_opts += -no-feature-sql\n+$(package)_config_opts += -no-feature-statemachine\n+$(package)_config_opts += -no-feature-syntaxhighlighter\n+$(package)_config_opts += -no-feature-textbrowser\n+$(package)_config_opts += -no-feature-textodfwriter\n+$(package)_config_opts += -no-feature-udpsocket\n+$(package)_config_opts += -no-feature-wizard\n $(package)_config_opts += -no-feature-xml\n \n ifneq ($(build_os),darwin)"
      },
      {
        "sha": "9641e0d3fda485e7357c3f804b3e89f0931ebd69",
        "filename": "doc/build-windows.md",
        "status": "modified",
        "additions": 9,
        "deletions": 1,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/doc/build-windows.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/doc/build-windows.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-windows.md?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -65,7 +65,11 @@ A host toolchain (`build-essential`) is necessary because some dependency\n packages (such as `protobuf`) need to build host utilities that are used in the\n build process.\n \n-See also: [dependencies.md](dependencies.md).\n+See [dependencies.md](dependencies.md) for a complete overview.\n+\n+If you want to build the windows installer with `make deploy` you need [NSIS](https://nsis.sourceforge.io/Main_Page):\n+\n+    sudo apt install nsis\n \n ## Building for 64-bit Windows\n \n@@ -139,6 +143,10 @@ way. This will install to `c:\\workspace\\bitcoin`, for example:\n \n     make install DESTDIR=/mnt/c/workspace/bitcoin\n \n+You can also create an installer using:\n+\n+    make deploy\n+\n Footnotes\n ---------\n "
      },
      {
        "sha": "50dde02fad4482bfd79b1661be1d5b3637e2018c",
        "filename": "doc/dependencies.md",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/doc/dependencies.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/doc/dependencies.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/dependencies.md?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -3,15 +3,15 @@ Dependencies\n \n These are the dependencies currently used by Bitcoin Core. You can find instructions for installing them in the `build-*.md` file for your platform.\n \n-| Dependency | Version used | Minimum required | CVEs | Shared | [Bundled Qt library](https://doc.qt.io/qt-5/configure-options.html) |\n+| Dependency | Version used | Minimum required | CVEs | Shared | [Bundled Qt library](https://doc.qt.io/qt-5/configure-options.html#third-party-libraries) |\n | --- | --- | --- | --- | --- | --- |\n-| Berkeley DB | [4.8.30](http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html) | 4.8.x | No |  |  |\n+| Berkeley DB | [4.8.30](https://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html) | 4.8.x | No |  |  |\n | Boost | [1.64.0](https://www.boost.org/users/download/) | [1.47.0](https://github.com/bitcoin/bitcoin/pull/8920) | No |  |  |\n | Clang |  | [3.3+](https://llvm.org/releases/download.html) (C++11 support) |  |  |  |\n | D-Bus | [1.10.18](https://cgit.freedesktop.org/dbus/dbus/tree/NEWS?h=dbus-1.10) |  | No | Yes |  |\n-| Expat | [2.2.5](https://libexpat.github.io/) |  | No | Yes |  |\n+| Expat | [2.2.6](https://libexpat.github.io/) |  | No | Yes |  |\n | fontconfig | [2.12.1](https://www.freedesktop.org/software/fontconfig/release/) |  | No | Yes |  |\n-| FreeType | [2.7.1](http://download.savannah.gnu.org/releases/freetype) |  | No |  |  |\n+| FreeType | [2.7.1](https://download.savannah.gnu.org/releases/freetype) |  | No |  |  |\n | GCC |  | [4.8+](https://gcc.gnu.org/) (C++11 support) |  |  |  |\n | HarfBuzz-NG |  |  |  |  |  |\n | libevent | [2.1.8-stable](https://github.com/libevent/libevent/releases) | 2.0.22 | No |  |  |\n@@ -23,7 +23,7 @@ These are the dependencies currently used by Bitcoin Core. You can find instruct\n | protobuf | [2.6.1](https://github.com/google/protobuf/releases) |  | No |  |  |\n | Python (tests) |  | [3.4](https://www.python.org/downloads) |  |  |  |\n | qrencode | [3.4.4](https://fukuchi.org/works/qrencode) |  | No |  |  |\n-| Qt | [5.9.6](https://download.qt.io/official_releases/qt/) | 5.x | No |  |  |\n+| Qt | [5.9.7](https://download.qt.io/official_releases/qt/) | [5.2](https://github.com/bitcoin/bitcoin/pull/14725) | No |  |  |\n | XCB |  |  |  |  | [Yes](https://github.com/bitcoin/bitcoin/blob/master/depends/packages/qt.mk#L87) (Linux only) |\n | xkbcommon |  |  |  |  | [Yes](https://github.com/bitcoin/bitcoin/blob/master/depends/packages/qt.mk#L86) (Linux only) |\n | ZeroMQ | [4.2.5](https://github.com/zeromq/libzmq/releases) | 4.0.0 | No |  |  |"
      },
      {
        "sha": "a6df17ddd8e8dc8d8018aad73320a22e237ff448",
        "filename": "doc/developer-notes.md",
        "status": "modified",
        "additions": 28,
        "deletions": 1,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/doc/developer-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/doc/developer-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/developer-notes.md?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -28,6 +28,8 @@ Developer Notes\n     - [Strings and formatting](#strings-and-formatting)\n     - [Variable names](#variable-names)\n     - [Threads and synchronization](#threads-and-synchronization)\n+    - [Scripts](#scripts)\n+        - [Shebang](#shebang)\n     - [Source code organization](#source-code-organization)\n     - [GUI](#gui)\n     - [Subtrees](#subtrees)\n@@ -602,6 +604,31 @@ TRY_LOCK(cs_vNodes, lockNodes);\n }\n ```\n \n+Scripts\n+--------------------------\n+\n+### Shebang\n+\n+- Use `#!/usr/bin/env bash` instead of obsolete `#!/bin/bash`.\n+\n+  - [*Rationale*](https://github.com/dylanaraps/pure-bash-bible#shebang):\n+\n+    `#!/bin/bash` assumes it is always installed to /bin/ which can cause issues;\n+\n+    `#!/usr/bin/env bash` searches the user's PATH to find the bash binary.\n+\n+  OK:\n+\n+```bash\n+#!/usr/bin/env bash\n+```\n+\n+  Wrong:\n+\n+```bash\n+#!/bin/bash\n+```\n+\n Source code organization\n --------------------------\n \n@@ -714,7 +741,7 @@ Current subtrees include:\n   - Upstream at https://github.com/bitcoin-core/ctaes ; actively maintained by Core contributors.\n \n - src/univalue\n-  - Upstream at https://github.com/jgarzik/univalue ; report important PRs to Core to avoid delay.\n+  - Upstream at https://github.com/bitcoin-core/univalue ; actively maintained by Core contributors, deviates from upstream https://github.com/jgarzik/univalue\n \n Upgrading LevelDB\n ---------------------"
      },
      {
        "sha": "85c27f3fd0bba6c967f44d162d44cc3d10b19af3",
        "filename": "doc/files.md",
        "status": "modified",
        "additions": 23,
        "deletions": 22,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/doc/files.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/doc/files.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/files.md?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -1,25 +1,26 @@\n-\n-* banlist.dat: stores the IPs/Subnets of banned nodes\n-* bitcoin.conf: contains configuration settings for bitcoind or bitcoin-qt\n-* bitcoind.pid: stores the process id of bitcoind while running\n-* blocks/blk000??.dat: block data (custom, 128 MiB per file); since 0.8.0\n-* blocks/rev000??.dat; block undo data (custom); since 0.8.0 (format changed since pre-0.8)\n-* blocks/index/*; block index (LevelDB); since 0.8.0\n-* chainstate/*; block chain state database (LevelDB); since 0.8.0\n-* database/*: BDB database environment; only used for wallet since 0.8.0; moved to wallets/ directory on new installs since 0.16.0\n-* db.log: wallet database log file; moved to wallets/ directory on new installs since 0.16.0\n-* debug.log: contains debug information and general logging generated by bitcoind or bitcoin-qt\n-* fee_estimates.dat: stores statistics used to estimate minimum transaction fees and priorities required for confirmation; since 0.10.0\n-* indexes/txindex/*: optional transaction index database (LevelDB); since 0.17.0\n-* mempool.dat: dump of the mempool's transactions; since 0.14.0.\n-* peers.dat: peer IP address database (custom format); since 0.7.0\n-* wallet.dat: personal wallet (BDB) with keys and transactions; moved to wallets/ directory on new installs since 0.16.0\n-* wallets/database/*: BDB database environment; used for wallets since 0.16.0\n-* wallets/db.log: wallet database log file; since 0.16.0\n-* wallets/wallet.dat: personal wallet (BDB) with keys and transactions; since 0.16.0\n-* .cookie: session RPC authentication cookie (written at start when cookie authentication is used, deleted on shutdown): since 0.12.0\n-* onion_private_key: cached Tor hidden service private key for `-listenonion`: since 0.12.0\n-* guisettings.ini.bak: backup of former GUI settings after `-resetguisettings` is used\n+Filename            | Description\n+--------------------|----------------------------------------------------------------------------------------------------------------------------\n+banlist.dat         | stores the IPs/Subnets of banned nodes\n+bitcoin.conf        | contains configuration settings for bitcoind or bitcoin-qt\n+bitcoind.pid        | stores the process id of bitcoind while running\n+blocks/blk000??.dat | block data (custom, 128 MiB per file); since 0.8.0\n+blocks/rev000??.dat | block undo data (custom); since 0.8.0 (format changed since pre-0.8)\n+blocks/index/*      | block index (LevelDB); since 0.8.0\n+chainstate/*        | blockchain state database (LevelDB); since 0.8.0\n+database/*          | BDB database environment; only used for wallet since 0.8.0; moved to wallets/ directory on new installs since 0.16.0\n+db.log              | wallet database log file; moved to wallets/ directory on new installs since 0.16.0\n+debug.log           | contains debug information and general logging generated by bitcoind or bitcoin-qt\n+fee_estimates.dat   | stores statistics used to estimate minimum transaction fees and priorities required for confirmation; since 0.10.0\n+indexes/txindex/*   | optional transaction index database (LevelDB); since 0.17.0\n+mempool.dat         | dump of the mempool's transactions; since 0.14.0\n+peers.dat           | peer IP address database (custom format); since 0.7.0\n+wallet.dat          | personal wallet (BDB) with keys and transactions; moved to wallets/ directory on new installs since 0.16.0\n+wallets/database/*  | BDB database environment; used for wallets since 0.16.0\n+wallets/db.log      | wallet database log file; since 0.16.0\n+wallets/wallet.dat  | personal wallet (BDB) with keys and transactions; since 0.16.0\n+.cookie             | session RPC authentication cookie (written at start when cookie authentication is used, deleted on shutdown): since 0.12.0\n+onion_private_key   | cached Tor hidden service private key for `-listenonion`: since 0.12.0\n+guisettings.ini.bak | backup of former GUI settings after `-resetguisettings` is used\n \n Only used in pre-0.8.0\n ---------------------"
      },
      {
        "sha": "7e6a93714d54377d84a3d2aff867147417fb73fe",
        "filename": "doc/psbt.md",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/doc/psbt.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/doc/psbt.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/psbt.md?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -90,7 +90,7 @@ the command line in case `bitcoin-cli` is used.\n Setup:\n - All three call `getnewaddress` to create a new address; call these addresses\n   *Aalice*, *Abob*, and *Acarol*.\n-- All three call `getaddressinfo X`, with *X* their respective address, and\n+- All three call `getaddressinfo \"X\"`, with *X* their respective address, and\n   remember the corresponding public keys. Call these public keys *Kalice*,\n   *Kbob*, and *Kcarol*.\n - All three now run `addmultisigaddress 2 [\"Kalice\",\"Kbob\",\"Kcarol\"]` to teach\n@@ -105,28 +105,28 @@ Setup:\n   output. Again, it may be necessary to explicitly specify the addresstype\n   in order to get a result that matches. This command won't enable them to\n   initiate transactions later, however.\n-- They can now give out *D* as address others can pay to.\n+- They can now give out *Amulti* as address others can pay to.\n \n Later, when *V* BTC has been received on *Amulti*, and Bob and Carol want to\n move the coins in their entirety to address *Asend*, with no change. Alice\n does not need to be involved.\n - One of them - let's assume Carol here - initiates the creation. She runs\n-  `walletcreatefundedpsbt [] {\"Asend\":V} 0 false {\"subtractFeeFromOutputs\":[0], \"includeWatching\":true}`.\n-  We call the resulting PSBT *P*. P does not contain any signatures.\n+  `walletcreatefundedpsbt [] {\"Asend\":V} 0 {\"subtractFeeFromOutputs\":[0], \"includeWatching\":true}`.\n+  We call the resulting PSBT *P*. *P* does not contain any signatures.\n - Carol needs to sign the transaction herself. In order to do so, she runs\n-  `walletprocesspsbt P`, and gives the resulting PSBT *P2* to Bob.\n+  `walletprocesspsbt \"P\"`, and gives the resulting PSBT *P2* to Bob.\n - Bob inspects the PSBT using `decodepsbt \"P2\"` to determine if the transaction\n   has indeed just the expected input, and an output to *Asend*, and the fee is\n   reasonable. If he agrees, he calls `walletprocesspsbt \"P2\"` to sign. The\n   resulting PSBT *P3* contains both Carol's and Bob's signature.\n-- Now anyone can call `finalizepsbt \"P2\"` to extract a fully signed transaction\n+- Now anyone can call `finalizepsbt \"P3\"` to extract a fully signed transaction\n   *T*.\n - Finally anyone can broadcast the transaction using `sendrawtransaction \"T\"`.\n \n In case there are more signers, it may be advantageous to let them all sign in\n parallel, rather passing the PSBT from one signer to the next one. In the\n above example this would translate to Carol handing a copy of *P* to each signer\n-separately. They can then all invoke `walletprocesspsbt P`, and end up with\n+separately. They can then all invoke `walletprocesspsbt \"P\"`, and end up with\n their individually-signed PSBT structures. They then all send those back to\n Carol (or anyone) who can combine them using `combinepsbt`. The last two steps\n (`finalizepsbt` and `sendrawtransaction`) remain unchanged."
      },
      {
        "sha": "97fedb6e2418aee39c2ee721becb373246ada924",
        "filename": "doc/release-process.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/doc/release-process.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/doc/release-process.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-process.md?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -87,7 +87,7 @@ Ensure gitian-builder is up-to-date:\n     pushd ./gitian-builder\n     mkdir -p inputs\n     wget -P inputs https://bitcoincore.org/cfields/osslsigncode-Backports-to-1.7.1.patch\n-    wget -P inputs http://downloads.sourceforge.net/project/osslsigncode/osslsigncode/osslsigncode-1.7.1.tar.gz\n+    wget -P inputs https://downloads.sourceforge.net/project/osslsigncode/osslsigncode/osslsigncode-1.7.1.tar.gz\n     popd\n \n Create the macOS SDK tarball, see the [macOS readme](README_osx.md) for details, and copy it into the inputs directory."
      },
      {
        "sha": "c46b7e9f607abb82f0ab67fdb12bd589e51ef035",
        "filename": "doc/tor.md",
        "status": "modified",
        "additions": 7,
        "deletions": 3,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/doc/tor.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/doc/tor.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/tor.md?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -109,9 +109,13 @@ preconfigured and the creation of a hidden service is automatic. If permission p\n are seen with `-debug=tor` they can be resolved by adding both the user running Tor and\n the user running bitcoind to the same group and setting permissions appropriately. On\n Debian-based systems the user running bitcoind can be added to the debian-tor group,\n-which has the appropriate permissions. An alternative authentication method is the use\n-of the `-torpassword` flag and a `hash-password` which can be enabled and specified in\n-Tor configuration.\n+which has the appropriate permissions.\n+\n+An alternative authentication method is the use\n+of the `-torpassword=password` option. The `password` is the clear text form that\n+was used when generating the hashed password for the `HashedControlPassword` option\n+in the tor configuration file. The hashed password can be obtained with the command\n+`tor --hash-password password` (read the tor manual for more details).\n \n ## 4. Privacy recommendations\n "
      },
      {
        "sha": "3cd130ce48450dd40976817964831bf59b764453",
        "filename": "share/qt/Info.plist.in",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/share/qt/Info.plist.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/share/qt/Info.plist.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/qt/Info.plist.in?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -17,7 +17,7 @@\n   <string>APPL</string>\n \n   <key>CFBundleGetInfoString</key>\n-  <string>@CLIENT_VERSION_MAJOR@.@CLIENT_VERSION_MINOR@.@CLIENT_VERSION_REVISION@, Copyright \u00a9 2009-@COPYRIGHT_YEAR@ @COPYRIGHT_HOLDERS_FINAL@</string>\n+  <string>@CLIENT_VERSION_MAJOR@.@CLIENT_VERSION_MINOR@.@CLIENT_VERSION_REVISION@.@CLIENT_VERSION_BUILD@, Copyright \u00a9 2009-@COPYRIGHT_YEAR@ @COPYRIGHT_HOLDERS_FINAL@</string>\n \n   <key>CFBundleShortVersionString</key>\n   <string>@CLIENT_VERSION_MAJOR@.@CLIENT_VERSION_MINOR@.@CLIENT_VERSION_REVISION@</string>"
      },
      {
        "sha": "8ce7562434c7ed3ecf9f881f815ccf8b04e253c2",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -132,7 +132,7 @@ test_test_bitcoin_LDADD += $(LIBBITCOIN_SERVER) $(LIBBITCOIN_CLI) $(LIBBITCOIN_C\n   $(LIBLEVELDB) $(LIBLEVELDB_SSE42) $(LIBMEMENV) $(BOOST_LIBS) $(BOOST_UNIT_TEST_FRAMEWORK_LIB) $(LIBSECP256K1) $(EVENT_LIBS) $(EVENT_PTHREADS_LIBS)\n test_test_bitcoin_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n \n-test_test_bitcoin_LDADD += $(LIBBITCOIN_CONSENSUS) $(BDB_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(RAPIDCHECK_LIBS)\n+test_test_bitcoin_LDADD += $(BDB_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(RAPIDCHECK_LIBS)\n test_test_bitcoin_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS) -static\n \n if ENABLE_ZMQ"
      },
      {
        "sha": "06c342ba73d34c0676c13920652930881917fdf6",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 20,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -11,22 +11,22 @@\n \n int CAddrInfo::GetTriedBucket(const uint256& nKey) const\n {\n-    uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetKey()).GetHash().GetCheapHash();\n-    uint64_t hash2 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup() << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP)).GetHash().GetCheapHash();\n+    uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetKey()).GetCheapHash();\n+    uint64_t hash2 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup() << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP)).GetCheapHash();\n     return hash2 % ADDRMAN_TRIED_BUCKET_COUNT;\n }\n \n int CAddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src) const\n {\n     std::vector<unsigned char> vchSourceGroupKey = src.GetGroup();\n-    uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup() << vchSourceGroupKey).GetHash().GetCheapHash();\n-    uint64_t hash2 = (CHashWriter(SER_GETHASH, 0) << nKey << vchSourceGroupKey << (hash1 % ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP)).GetHash().GetCheapHash();\n+    uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup() << vchSourceGroupKey).GetCheapHash();\n+    uint64_t hash2 = (CHashWriter(SER_GETHASH, 0) << nKey << vchSourceGroupKey << (hash1 % ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP)).GetCheapHash();\n     return hash2 % ADDRMAN_NEW_BUCKET_COUNT;\n }\n \n int CAddrInfo::GetBucketPosition(const uint256 &nKey, bool fNew, int nBucket) const\n {\n-    uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << (fNew ? 'N' : 'K') << nBucket << GetKey()).GetHash().GetCheapHash();\n+    uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << (fNew ? 'N' : 'K') << nBucket << GetKey()).GetCheapHash();\n     return hash1 % ADDRMAN_BUCKET_SIZE;\n }\n \n@@ -217,7 +217,7 @@ void CAddrMan::Good_(const CService& addr, bool test_before_evict, int64_t nTime\n         return;\n \n     // find a bucket it is in now\n-    int nRnd = RandomInt(ADDRMAN_NEW_BUCKET_COUNT);\n+    int nRnd = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n     int nUBucket = -1;\n     for (unsigned int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {\n         int nB = (n + nRnd) % ADDRMAN_NEW_BUCKET_COUNT;\n@@ -291,7 +291,7 @@ bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimeP\n         int nFactor = 1;\n         for (int n = 0; n < pinfo->nRefCount; n++)\n             nFactor *= 2;\n-        if (nFactor > 1 && (RandomInt(nFactor) != 0))\n+        if (nFactor > 1 && (insecure_rand.randrange(nFactor) != 0))\n             return false;\n     } else {\n         pinfo = Create(addr, source, &nId);\n@@ -356,37 +356,37 @@ CAddrInfo CAddrMan::Select_(bool newOnly)\n \n     // Use a 50% chance for choosing between tried and new table entries.\n     if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || RandomInt(2) == 0))) {\n+       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n         // use a tried node\n         double fChanceFactor = 1.0;\n         while (1) {\n-            int nKBucket = RandomInt(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = RandomInt(ADDRMAN_BUCKET_SIZE);\n+            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n+            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n             while (vvTried[nKBucket][nKBucketPos] == -1) {\n                 nKBucket = (nKBucket + insecure_rand.randbits(ADDRMAN_TRIED_BUCKET_COUNT_LOG2)) % ADDRMAN_TRIED_BUCKET_COUNT;\n                 nKBucketPos = (nKBucketPos + insecure_rand.randbits(ADDRMAN_BUCKET_SIZE_LOG2)) % ADDRMAN_BUCKET_SIZE;\n             }\n             int nId = vvTried[nKBucket][nKBucketPos];\n             assert(mapInfo.count(nId) == 1);\n             CAddrInfo& info = mapInfo[nId];\n-            if (RandomInt(1 << 30) < fChanceFactor * info.GetChance() * (1 << 30))\n+            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30))\n                 return info;\n             fChanceFactor *= 1.2;\n         }\n     } else {\n         // use a new node\n         double fChanceFactor = 1.0;\n         while (1) {\n-            int nUBucket = RandomInt(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = RandomInt(ADDRMAN_BUCKET_SIZE);\n+            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n+            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n             while (vvNew[nUBucket][nUBucketPos] == -1) {\n                 nUBucket = (nUBucket + insecure_rand.randbits(ADDRMAN_NEW_BUCKET_COUNT_LOG2)) % ADDRMAN_NEW_BUCKET_COUNT;\n                 nUBucketPos = (nUBucketPos + insecure_rand.randbits(ADDRMAN_BUCKET_SIZE_LOG2)) % ADDRMAN_BUCKET_SIZE;\n             }\n             int nId = vvNew[nUBucket][nUBucketPos];\n             assert(mapInfo.count(nId) == 1);\n             CAddrInfo& info = mapInfo[nId];\n-            if (RandomInt(1 << 30) < fChanceFactor * info.GetChance() * (1 << 30))\n+            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30))\n                 return info;\n             fChanceFactor *= 1.2;\n         }\n@@ -482,7 +482,7 @@ void CAddrMan::GetAddr_(std::vector<CAddress>& vAddr)\n         if (vAddr.size() >= nNodes)\n             break;\n \n-        int nRndPos = RandomInt(vRandom.size() - n) + n;\n+        int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;\n         SwapRandom(n, nRndPos);\n         assert(mapInfo.count(vRandom[n]) == 1);\n \n@@ -530,10 +530,6 @@ void CAddrMan::SetServices_(const CService& addr, ServiceFlags nServices)\n     info.nServices = nServices;\n }\n \n-int CAddrMan::RandomInt(int nMax){\n-    return GetRandInt(nMax);\n-}\n-\n void CAddrMan::ResolveCollisions_()\n {\n     for (std::set<int>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {\n@@ -593,7 +589,7 @@ CAddrInfo CAddrMan::SelectTriedCollision_()\n     std::set<int>::iterator it = m_tried_collisions.begin();\n \n     // Selects a random element from m_tried_collisions\n-    std::advance(it, GetRandInt(m_tried_collisions.size()));\n+    std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));\n     int id_new = *it;\n \n     // If id_new not found in mapInfo remove it from m_tried_collisions"
      },
      {
        "sha": "af5a1d3b238847c82811bf1b7db673ded1f87adc",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -266,9 +266,6 @@ class CAddrMan\n     //! Return a random to-be-evicted tried table address.\n     CAddrInfo SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    //! Wraps GetRandInt to allow tests to override RandomInt and make it determinismistic.\n-    virtual int RandomInt(int nMax);\n-\n #ifdef DEBUG_ADDRMAN\n     //! Perform consistency check. Returns an error code or zero.\n     int Check_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n@@ -473,7 +470,7 @@ class CAddrMan\n     {\n         LOCK(cs);\n         std::vector<int>().swap(vRandom);\n-        nKey = GetRandHash();\n+        nKey = insecure_rand.rand256();\n         for (size_t bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {\n             for (size_t entry = 0; entry < ADDRMAN_BUCKET_SIZE; entry++) {\n                 vvNew[bucket][entry] = -1;"
      },
      {
        "sha": "bd0360087d9ea0c6aabd0ce1f44e4a3d171139f0",
        "filename": "src/arith_uint256.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/arith_uint256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/arith_uint256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/arith_uint256.h?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -8,6 +8,7 @@\n \n #include <assert.h>\n #include <cstring>\n+#include <limits>\n #include <stdexcept>\n #include <stdint.h>\n #include <string>\n@@ -189,7 +190,7 @@ class base_uint\n     {\n         // prefix operator\n         int i = 0;\n-        while (i < WIDTH && --pn[i] == (uint32_t)-1)\n+        while (i < WIDTH && --pn[i] == std::numeric_limits<uint32_t>::max())\n             i++;\n         return *this;\n     }"
      },
      {
        "sha": "9cfd5d23effe120ba17ede3c51e94b5b69b4b12a",
        "filename": "src/bench/ccoins_caching.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/bench/ccoins_caching.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/bench/ccoins_caching.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/ccoins_caching.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -35,14 +35,14 @@ SetupDummyInputs(CBasicKeyStore& keystoreRet, CCoinsViewCache& coinsRet)\n     dummyTransactions[0].vout[0].scriptPubKey << ToByteVector(key[0].GetPubKey()) << OP_CHECKSIG;\n     dummyTransactions[0].vout[1].nValue = 50 * COIN;\n     dummyTransactions[0].vout[1].scriptPubKey << ToByteVector(key[1].GetPubKey()) << OP_CHECKSIG;\n-    AddCoins(coinsRet, dummyTransactions[0], 0);\n+    AddCoins(coinsRet, CTransaction(dummyTransactions[0]), 0);\n \n     dummyTransactions[1].vout.resize(2);\n     dummyTransactions[1].vout[0].nValue = 21 * COIN;\n     dummyTransactions[1].vout[0].scriptPubKey = GetScriptForDestination(key[2].GetPubKey().GetID());\n     dummyTransactions[1].vout[1].nValue = 22 * COIN;\n     dummyTransactions[1].vout[1].scriptPubKey = GetScriptForDestination(key[3].GetPubKey().GetID());\n-    AddCoins(coinsRet, dummyTransactions[1], 0);\n+    AddCoins(coinsRet, CTransaction(dummyTransactions[1]), 0);\n \n     return dummyTransactions;\n }\n@@ -76,10 +76,11 @@ static void CCoinsCaching(benchmark::State& state)\n     t1.vout[0].scriptPubKey << OP_1;\n \n     // Benchmark.\n+    const CTransaction tx_1(t1);\n     while (state.KeepRunning()) {\n-        bool success = AreInputsStandard(t1, coins);\n+        bool success = AreInputsStandard(tx_1, coins);\n         assert(success);\n-        CAmount value = coins.GetValueIn(t1);\n+        CAmount value = coins.GetValueIn(tx_1);\n         assert(value == (50 + 21 + 22) * COIN);\n     }\n }"
      },
      {
        "sha": "49ea6e88b5ea9dfd2a6403fb3e613e4fe0671a58",
        "filename": "src/bench/mempool_eviction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/bench/mempool_eviction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/bench/mempool_eviction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/mempool_eviction.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -127,7 +127,7 @@ static void MempoolEviction(benchmark::State& state)\n         AddTx(tx6_r, 1100LL, pool);\n         AddTx(tx7_r, 9000LL, pool);\n         pool.TrimToSize(pool.DynamicMemoryUsage() * 3 / 4);\n-        pool.TrimToSize(GetVirtualTransactionSize(tx1));\n+        pool.TrimToSize(GetVirtualTransactionSize(*tx1_r));\n     }\n }\n "
      },
      {
        "sha": "7cdf61ad35534c266bdf4cbae1dd4443bf285bea",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -492,9 +492,6 @@ static int CommandLineRPC(int argc, char *argv[])\n             }\n         } while (fWait);\n     }\n-    catch (const boost::thread_interrupted&) {\n-        throw;\n-    }\n     catch (const std::exception& e) {\n         strPrint = std::string(\"error: \") + e.what();\n         nRet = EXIT_FAILURE;"
      },
      {
        "sha": "2e41adc276396c4aaaf8004db30f20faf4db3654",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -820,10 +820,6 @@ static int CommandLineRawTx(int argc, char* argv[])\n \n         OutputTx(tx);\n     }\n-\n-    catch (const boost::thread_interrupted&) {\n-        throw;\n-    }\n     catch (const std::exception& e) {\n         strPrint = std::string(\"error: \") + e.what();\n         nRet = EXIT_FAILURE;"
      },
      {
        "sha": "3b786664af222a7ba02d671ad356475884d7e246",
        "filename": "src/chain.h",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.h?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -294,6 +294,15 @@ class CBlockIndex\n         return *phashBlock;\n     }\n \n+    /**\n+     * Check whether this block's and all previous blocks' transactions have been\n+     * downloaded (and stored to disk) at some point.\n+     *\n+     * Does not imply the transactions are consensus-valid (ConnectTip might fail)\n+     * Does not imply the transactions are still stored on disk. (IsBlockPruned might return true)\n+     */\n+    bool HaveTxsDownloaded() const { return nChainTx != 0; }\n+\n     int64_t GetBlockTime() const\n     {\n         return (int64_t)nTime;"
      },
      {
        "sha": "c295568a3e733038388ea7616e0b1e7783e49fd3",
        "filename": "src/hash.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.h?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -6,6 +6,7 @@\n #ifndef BITCOIN_HASH_H\n #define BITCOIN_HASH_H\n \n+#include <crypto/common.h>\n #include <crypto/ripemd160.h>\n #include <crypto/sha256.h>\n #include <prevector.h>\n@@ -138,6 +139,15 @@ class CHashWriter\n         return result;\n     }\n \n+    /**\n+     * Returns the first 64 bits from the resulting hash.\n+     */\n+    inline uint64_t GetCheapHash() {\n+        unsigned char result[CHash256::OUTPUT_SIZE];\n+        ctx.Finalize(result);\n+        return ReadLE64(result);\n+    }\n+\n     template<typename T>\n     CHashWriter& operator<<(const T& obj) {\n         // Serialize to this stream"
      },
      {
        "sha": "cb8578927a46be78145638b9eeda5c11be713c83",
        "filename": "src/httpserver.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 21,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/httpserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/httpserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -10,6 +10,7 @@\n #include <util/strencodings.h>\n #include <netbase.h>\n #include <rpc/protocol.h> // For HTTP status codes\n+#include <shutdown.h>\n #include <sync.h>\n #include <ui_interface.h>\n \n@@ -21,7 +22,6 @@\n #include <sys/types.h>\n #include <sys/stat.h>\n #include <signal.h>\n-#include <future>\n \n #include <event2/thread.h>\n #include <event2/buffer.h>\n@@ -421,17 +421,14 @@ bool UpdateHTTPServerLogging(bool enable) {\n }\n \n std::thread threadHTTP;\n-std::future<bool> threadResult;\n static std::vector<std::thread> g_thread_http_workers;\n \n void StartHTTPServer()\n {\n     LogPrint(BCLog::HTTP, \"Starting HTTP server\\n\");\n     int rpcThreads = std::max((long)gArgs.GetArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n     LogPrintf(\"HTTP: starting %d worker threads\\n\", rpcThreads);\n-    std::packaged_task<bool(event_base*)> task(ThreadHTTP);\n-    threadResult = task.get_future();\n-    threadHTTP = std::thread(std::move(task), eventBase);\n+    threadHTTP = std::thread(ThreadHTTP, eventBase);\n \n     for (int i = 0; i < rpcThreads; i++) {\n         g_thread_http_workers.emplace_back(HTTPWorkQueueRun, workQueue);\n@@ -442,10 +439,6 @@ void InterruptHTTPServer()\n {\n     LogPrint(BCLog::HTTP, \"Interrupting HTTP server\\n\");\n     if (eventHTTP) {\n-        // Unlisten sockets\n-        for (evhttp_bound_socket *socket : boundSockets) {\n-            evhttp_del_accept_socket(eventHTTP, socket);\n-        }\n         // Reject requests on current connections\n         evhttp_set_gencb(eventHTTP, http_reject_request_cb, nullptr);\n     }\n@@ -465,20 +458,14 @@ void StopHTTPServer()\n         delete workQueue;\n         workQueue = nullptr;\n     }\n+    // Unlisten sockets, these are what make the event loop running, which means\n+    // that after this and all connections are closed the event loop will quit.\n+    for (evhttp_bound_socket *socket : boundSockets) {\n+        evhttp_del_accept_socket(eventHTTP, socket);\n+    }\n+    boundSockets.clear();\n     if (eventBase) {\n         LogPrint(BCLog::HTTP, \"Waiting for HTTP event thread to exit\\n\");\n-        // Exit the event loop as soon as there are no active events.\n-        event_base_loopexit(eventBase, nullptr);\n-        // Give event loop a few seconds to exit (to send back last RPC responses), then break it\n-        // Before this was solved with event_base_loopexit, but that didn't work as expected in\n-        // at least libevent 2.0.21 and always introduced a delay. In libevent\n-        // master that appears to be solved, so in the future that solution\n-        // could be used again (if desirable).\n-        // (see discussion in https://github.com/bitcoin/bitcoin/pull/6990)\n-        if (threadResult.valid() && threadResult.wait_for(std::chrono::milliseconds(2000)) == std::future_status::timeout) {\n-            LogPrintf(\"HTTP event loop did not exit within allotted time, sending loopbreak\\n\");\n-            event_base_loopbreak(eventBase);\n-        }\n         threadHTTP.join();\n     }\n     if (eventHTTP) {\n@@ -583,6 +570,9 @@ void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\n void HTTPRequest::WriteReply(int nStatus, const std::string& strReply)\n {\n     assert(!replySent && req);\n+    if (ShutdownRequested()) {\n+        WriteHeader(\"Connection\", \"close\");\n+    }\n     // Send event to main http thread to send reply message\n     struct evbuffer* evb = evhttp_request_get_output_buffer(req);\n     assert(evb);"
      },
      {
        "sha": "8ecd79197fbe366d8c61c5ec76d1fa345bc1e267",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 2,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -403,6 +403,7 @@ void SetupServerArgs()\n     gArgs.AddArg(\"-proxyrandomize\", strprintf(\"Randomize credentials for every proxy connection. This enables Tor stream isolation (default: %u)\", DEFAULT_PROXYRANDOMIZE), false, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-seednode=<ip>\", \"Connect to a node to retrieve peer addresses, and disconnect. This option can be specified multiple times to connect to multiple nodes.\", false, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-timeout=<n>\", strprintf(\"Specify connection timeout in milliseconds (minimum: 1, default: %d)\", DEFAULT_CONNECT_TIMEOUT), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-peertimeout=<n>\", strprintf(\"Specify p2p connection timeout in seconds. This option determines the amount of time a peer may be inactive before the connection to it is dropped. (minimum: 1, default: %d)\", DEFAULT_PEER_CONNECT_TIMEOUT), true, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-torcontrol=<ip>:<port>\", strprintf(\"Tor control port to use if onion listening enabled (default: %s)\", DEFAULT_TOR_CONTROL), false, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-torpassword=<pass>\", \"Tor control port password (default: empty)\", false, OptionsCategory::CONNECTION);\n #ifdef USE_UPNP\n@@ -499,7 +500,7 @@ void SetupServerArgs()\n \n     gArgs.AddArg(\"-rest\", strprintf(\"Accept public REST requests (default: %u)\", DEFAULT_REST_ENABLE), false, OptionsCategory::RPC);\n     gArgs.AddArg(\"-rpcallowip=<ip>\", \"Allow JSON-RPC connections from specified source. Valid for <ip> are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24). This option can be specified multiple times\", false, OptionsCategory::RPC);\n-    gArgs.AddArg(\"-rpcauth=<userpw>\", \"Username and hashed password for JSON-RPC connections. The field <userpw> comes in the format: <USERNAME>:<SALT>$<HASH>. A canonical python script is included in share/rpcauth. The client then connects normally using the rpcuser=<USERNAME>/rpcpassword=<PASSWORD> pair of arguments. This option can be specified multiple times\", false, OptionsCategory::RPC);\n+    gArgs.AddArg(\"-rpcauth=<userpw>\", \"Username and HMAC-SHA-256 hashed password for JSON-RPC connections. The field <userpw> comes in the format: <USERNAME>:<SALT>$<HASH>. A canonical python script is included in share/rpcauth. The client then connects normally using the rpcuser=<USERNAME>/rpcpassword=<PASSWORD> pair of arguments. This option can be specified multiple times\", false, OptionsCategory::RPC);\n     gArgs.AddArg(\"-rpcbind=<addr>[:port]\", \"Bind to given address to listen for JSON-RPC connections. Do not expose the RPC server to untrusted networks such as the public internet! This option is ignored unless -rpcallowip is also passed. Port is optional and overrides -rpcport. Use [host]:port notation for IPv6. This option can be specified multiple times (default: 127.0.0.1 and ::1 i.e., localhost)\", false, OptionsCategory::RPC);\n     gArgs.AddArg(\"-rpccookiefile=<loc>\", \"Location of the auth cookie. Relative paths will be prefixed by a net-specific datadir location. (default: data dir)\", false, OptionsCategory::RPC);\n     gArgs.AddArg(\"-rpcpassword=<pw>\", \"Password for JSON-RPC connections\", false, OptionsCategory::RPC);\n@@ -856,6 +857,7 @@ int nMaxConnections;\n int nUserMaxConnections;\n int nFD;\n ServiceFlags nLocalServices = ServiceFlags(NODE_NETWORK | NODE_NETWORK_LIMITED);\n+int64_t peer_connect_timeout;\n \n } // namespace\n \n@@ -1054,8 +1056,14 @@ bool AppInitParameterInteraction()\n     }\n \n     nConnectTimeout = gArgs.GetArg(\"-timeout\", DEFAULT_CONNECT_TIMEOUT);\n-    if (nConnectTimeout <= 0)\n+    if (nConnectTimeout <= 0) {\n         nConnectTimeout = DEFAULT_CONNECT_TIMEOUT;\n+    }\n+\n+    peer_connect_timeout = gArgs.GetArg(\"-peertimeout\", DEFAULT_PEER_CONNECT_TIMEOUT);\n+    if (peer_connect_timeout <= 0) {\n+        return InitError(\"peertimeout cannot be configured with a negative value.\");\n+    }\n \n     if (gArgs.IsArgSet(\"-minrelaytxfee\")) {\n         CAmount n = 0;\n@@ -1693,6 +1701,7 @@ bool AppInitMain(InitInterfaces& interfaces)\n \n     connOptions.nMaxOutboundTimeframe = nMaxOutboundTimeframe;\n     connOptions.nMaxOutboundLimit = nMaxOutboundLimit;\n+    connOptions.m_peer_connect_timeout = peer_connect_timeout;\n \n     for (const std::string& strBind : gArgs.GetArgs(\"-bind\")) {\n         CService addrBind;"
      },
      {
        "sha": "e595fb0b0bc36db59a72c09338d0ed25ab5810f9",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 6,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -134,11 +134,12 @@ static std::vector<CAddress> convertSeed6(const std::vector<SeedSpec6> &vSeedsIn\n     const int64_t nOneWeek = 7*24*60*60;\n     std::vector<CAddress> vSeedsOut;\n     vSeedsOut.reserve(vSeedsIn.size());\n+    FastRandomContext rng;\n     for (const auto& seed_in : vSeedsIn) {\n         struct in6_addr ip;\n         memcpy(&ip, seed_in.addr, sizeof(ip));\n         CAddress addr(CService(ip, seed_in.port), GetDesirableServiceFlags(NODE_NONE));\n-        addr.nTime = GetTime() - GetRand(nOneWeek) - nOneWeek;\n+        addr.nTime = GetTime() - rng.randrange(nOneWeek) - nOneWeek;\n         vSeedsOut.push_back(addr);\n     }\n     return vSeedsOut;\n@@ -189,16 +190,16 @@ void AdvertiseLocal(CNode *pnode)\n         // If discovery is enabled, sometimes give our peer the address it\n         // tells us that it sees us as in case it has a better idea of our\n         // address than we do.\n+        FastRandomContext rng;\n         if (IsPeerAddrLocalGood(pnode) && (!addrLocal.IsRoutable() ||\n-             GetRand((GetnScore(addrLocal) > LOCAL_MANUAL) ? 8:2) == 0))\n+             rng.randbits((GetnScore(addrLocal) > LOCAL_MANUAL) ? 3 : 1) == 0))\n         {\n             addrLocal.SetIP(pnode->GetAddrLocal());\n         }\n         if (addrLocal.IsRoutable() || gArgs.GetBoolArg(\"-addrmantest\", false))\n         {\n             LogPrint(BCLog::NET, \"AdvertiseLocal: advertising address %s\\n\", addrLocal.ToString());\n-            FastRandomContext insecure_rand;\n-            pnode->PushAddress(addrLocal, insecure_rand);\n+            pnode->PushAddress(addrLocal, rng);\n         }\n     }\n }\n@@ -1227,11 +1228,11 @@ void CConnman::NotifyNumConnectionsChanged()\n void CConnman::InactivityCheck(CNode *pnode)\n {\n     int64_t nTime = GetSystemTimeInSeconds();\n-    if (nTime - pnode->nTimeConnected > 60)\n+    if (nTime - pnode->nTimeConnected > m_peer_connect_timeout)\n     {\n         if (pnode->nLastRecv == 0 || pnode->nLastSend == 0)\n         {\n-            LogPrint(BCLog::NET, \"socket no message in first 60 seconds, %d %d from %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0, pnode->GetId());\n+            LogPrint(BCLog::NET, \"socket no message in first %i seconds, %d %d from %d\\n\", m_peer_connect_timeout, pnode->nLastRecv != 0, pnode->nLastSend != 0, pnode->GetId());\n             pnode->fDisconnect = true;\n         }\n         else if (nTime - pnode->nLastSend > TIMEOUT_INTERVAL)"
      },
      {
        "sha": "775d0c8099e8a3ee5294191ef28d2c8ccfbd078a",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -78,6 +78,8 @@ static const uint64_t DEFAULT_MAX_UPLOAD_TARGET = 0;\n static const uint64_t MAX_UPLOAD_TIMEFRAME = 60 * 60 * 24;\n /** Default for blocks only*/\n static const bool DEFAULT_BLOCKSONLY = false;\n+/** -peertimeout default */\n+static const int64_t DEFAULT_PEER_CONNECT_TIMEOUT = 60;\n \n static const bool DEFAULT_FORCEDNSSEED = false;\n static const size_t DEFAULT_MAXRECEIVEBUFFER = 5 * 1000;\n@@ -138,6 +140,7 @@ class CConnman\n         unsigned int nReceiveFloodSize = 0;\n         uint64_t nMaxOutboundTimeframe = 0;\n         uint64_t nMaxOutboundLimit = 0;\n+        int64_t m_peer_connect_timeout = DEFAULT_PEER_CONNECT_TIMEOUT;\n         std::vector<std::string> vSeedNodes;\n         std::vector<CSubNet> vWhitelistedRange;\n         std::vector<CService> vBinds, vWhiteBinds;\n@@ -158,6 +161,7 @@ class CConnman\n         m_msgproc = connOptions.m_msgproc;\n         nSendBufferMaxSize = connOptions.nSendBufferMaxSize;\n         nReceiveFloodSize = connOptions.nReceiveFloodSize;\n+        m_peer_connect_timeout = connOptions.m_peer_connect_timeout;\n         {\n             LOCK(cs_totalBytesSent);\n             nMaxOutboundTimeframe = connOptions.nMaxOutboundTimeframe;\n@@ -391,6 +395,9 @@ class CConnman\n     uint64_t nMaxOutboundLimit GUARDED_BY(cs_totalBytesSent);\n     uint64_t nMaxOutboundTimeframe GUARDED_BY(cs_totalBytesSent);\n \n+    // P2P timeout in seconds\n+    int64_t m_peer_connect_timeout;\n+\n     // Whitelisted ranges. Any node connecting from these is automatically\n     // whitelisted (as well as those connecting to whitelisted binds).\n     std::vector<CSubNet> vWhitelistedRange;"
      },
      {
        "sha": "0e222bdfa4775ad12036ed147e312c8f08fa9064",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -566,7 +566,7 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n                 return;\n             }\n             if (pindex->nStatus & BLOCK_HAVE_DATA || chainActive.Contains(pindex)) {\n-                if (pindex->nChainTx)\n+                if (pindex->HaveTxsDownloaded())\n                     state->pindexLastCommonBlock = pindex;\n             } else if (mapBlocksInFlight.count(pindex->GetBlockHash()) == 0) {\n                 // The block is not already downloaded, and not yet in flight.\n@@ -779,10 +779,11 @@ unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)\n         nNextSweep = nMinExpTime + ORPHAN_TX_EXPIRE_INTERVAL;\n         if (nErased > 0) LogPrint(BCLog::MEMPOOL, \"Erased %d orphan tx due to expiration\\n\", nErased);\n     }\n+    FastRandomContext rng;\n     while (mapOrphanTransactions.size() > nMaxOrphans)\n     {\n         // Evict a random orphan:\n-        uint256 randomhash = GetRandHash();\n+        uint256 randomhash = rng.rand256();\n         std::map<uint256, COrphanTx>::iterator it = mapOrphanTransactions.lower_bound(randomhash);\n         if (it == mapOrphanTransactions.end())\n             it = mapOrphanTransactions.begin();\n@@ -1124,7 +1125,7 @@ void static ProcessGetBlockData(CNode* pfrom, const CChainParams& chainparams, c\n         LOCK(cs_main);\n         const CBlockIndex* pindex = LookupBlockIndex(inv.hash);\n         if (pindex) {\n-            if (pindex->nChainTx && !pindex->IsValid(BLOCK_VALID_SCRIPTS) &&\n+            if (pindex->HaveTxsDownloaded() && !pindex->IsValid(BLOCK_VALID_SCRIPTS) &&\n                     pindex->IsValid(BLOCK_VALID_TREE)) {\n                 // If we have the block and all of its parents, but have not yet validated it,\n                 // we might be in the middle of connecting it (ie in the unlock of cs_main"
      },
      {
        "sha": "c88d5b1ad3e27db1af5e022b9399dd7c7d23c254",
        "filename": "src/primitives/transaction.h",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/primitives/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/primitives/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.h?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -21,7 +21,9 @@ class COutPoint\n     uint256 hash;\n     uint32_t n;\n \n-    COutPoint(): n((uint32_t) -1) { }\n+    static constexpr uint32_t NULL_INDEX = std::numeric_limits<uint32_t>::max();\n+\n+    COutPoint(): n(NULL_INDEX) { }\n     COutPoint(const uint256& hashIn, uint32_t nIn): hash(hashIn), n(nIn) { }\n \n     ADD_SERIALIZE_METHODS;\n@@ -32,8 +34,8 @@ class COutPoint\n         READWRITE(n);\n     }\n \n-    void SetNull() { hash.SetNull(); n = (uint32_t) -1; }\n-    bool IsNull() const { return (hash.IsNull() && n == (uint32_t) -1); }\n+    void SetNull() { hash.SetNull(); n = NULL_INDEX; }\n+    bool IsNull() const { return (hash.IsNull() && n == NULL_INDEX); }\n \n     friend bool operator<(const COutPoint& a, const COutPoint& b)\n     {"
      },
      {
        "sha": "eaeb93a652e1e04a13af50a650aaa3988ac473ef",
        "filename": "src/qt/bitcoin.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 13,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -71,11 +71,6 @@ Q_DECLARE_METATYPE(bool*)\n Q_DECLARE_METATYPE(CAmount)\n Q_DECLARE_METATYPE(uint256)\n \n-static void InitMessage(const std::string& message)\n-{\n-    noui_InitMessage(message);\n-}\n-\n /** Translate string to current locale using Qt. */\n const std::function<std::string(const char*)> G_TRANSLATION_FUN = [](const char* psz) {\n     return QCoreApplication::translate(\"bitcoin-core\", psz).toStdString();\n@@ -217,7 +212,7 @@ public Q_SLOTS:\n     void requestedInitialize();\n     void requestedShutdown();\n     void stopThread();\n-    void splashFinished(QWidget *window);\n+    void splashFinished();\n \n private:\n     QThread *coreThread;\n@@ -357,9 +352,9 @@ void BitcoinApplication::createSplashScreen(const NetworkStyle *networkStyle)\n {\n     SplashScreen *splash = new SplashScreen(m_node, 0, networkStyle);\n     // We don't hold a direct pointer to the splash screen after creation, but the splash\n-    // screen will take care of deleting itself when slotFinish happens.\n+    // screen will take care of deleting itself when finish() happens.\n     splash->show();\n-    connect(this, &BitcoinApplication::splashFinished, splash, &SplashScreen::slotFinish);\n+    connect(this, &BitcoinApplication::splashFinished, splash, &SplashScreen::finish);\n     connect(this, &BitcoinApplication::requestedShutdown, splash, &QWidget::close);\n }\n \n@@ -500,7 +495,7 @@ void BitcoinApplication::initializeResult(bool success)\n         {\n             window->show();\n         }\n-        Q_EMIT splashFinished(window);\n+        Q_EMIT splashFinished();\n \n #ifdef ENABLE_WALLET\n         // Now that initialization/startup is done, process any command-line\n@@ -514,7 +509,7 @@ void BitcoinApplication::initializeResult(bool success)\n #endif\n         pollShutdownTimer->start(200);\n     } else {\n-        Q_EMIT splashFinished(window); // Make sure splash screen doesn't stick around during shutdown\n+        Q_EMIT splashFinished(); // Make sure splash screen doesn't stick around during shutdown\n         quit(); // Exit first main loop invocation\n     }\n }\n@@ -563,6 +558,11 @@ int main(int argc, char *argv[])\n \n     std::unique_ptr<interfaces::Node> node = interfaces::MakeNode();\n \n+    // Subscribe to global signals from core\n+    std::unique_ptr<interfaces::Handler> handler_message_box = node->handleMessageBox(noui_ThreadSafeMessageBox);\n+    std::unique_ptr<interfaces::Handler> handler_question = node->handleQuestion(noui_ThreadSafeQuestion);\n+    std::unique_ptr<interfaces::Handler> handler_init_message = node->handleInitMessage(noui_InitMessage);\n+\n     // Do not refer to data directory yet, this can be overridden by Intro::pickDataDirectory\n \n     /// 1. Basic Qt initialization (not dependent on parameters or configuration)\n@@ -696,9 +696,6 @@ int main(int argc, char *argv[])\n     // Load GUI settings from QSettings\n     app.createOptionsModel(gArgs.GetBoolArg(\"-resetguisettings\", false));\n \n-    // Subscribe to global signals from core\n-    std::unique_ptr<interfaces::Handler> handler = node->handleInitMessage(InitMessage);\n-\n     if (gArgs.GetBoolArg(\"-splash\", DEFAULT_SPLASHSCREEN) && !gArgs.GetBoolArg(\"-min\", false))\n         app.createSplashScreen(networkStyle.data());\n "
      },
      {
        "sha": "d7056ddd89f3e5e9e95dd156b3ce58c1d35d1bd5",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 64,
        "deletions": 17,
        "changes": 81,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -31,7 +31,6 @@\n #include <chainparams.h>\n #include <interfaces/handler.h>\n #include <interfaces/node.h>\n-#include <noui.h>\n #include <ui_interface.h>\n #include <util/system.h>\n \n@@ -57,6 +56,7 @@\n #include <QToolBar>\n #include <QUrlQuery>\n #include <QVBoxLayout>\n+#include <QWindow>\n \n #include <boost/bind.hpp>\n \n@@ -325,9 +325,9 @@ void BitcoinGUI::createActions()\n     // initially disable the debug window menu item\n     openRPCConsoleAction->setEnabled(false);\n \n-    usedSendingAddressesAction = new QAction(platformStyle->TextColorIcon(\":/icons/address-book\"), tr(\"&Sending addresses...\"), this);\n+    usedSendingAddressesAction = new QAction(platformStyle->TextColorIcon(\":/icons/address-book\"), tr(\"&Sending addresses\"), this);\n     usedSendingAddressesAction->setStatusTip(tr(\"Show the list of used sending addresses and labels\"));\n-    usedReceivingAddressesAction = new QAction(platformStyle->TextColorIcon(\":/icons/address-book\"), tr(\"&Receiving addresses...\"), this);\n+    usedReceivingAddressesAction = new QAction(platformStyle->TextColorIcon(\":/icons/address-book\"), tr(\"&Receiving addresses\"), this);\n     usedReceivingAddressesAction->setStatusTip(tr(\"Show the list of used receiving addresses and labels\"));\n \n     openAction = new QAction(platformStyle->TextColorIcon(\":/icons/open\"), tr(\"Open &URI...\"), this);\n@@ -386,9 +386,6 @@ void BitcoinGUI::createMenuBar()\n         file->addAction(signMessageAction);\n         file->addAction(verifyMessageAction);\n         file->addSeparator();\n-        file->addAction(usedSendingAddressesAction);\n-        file->addAction(usedReceivingAddressesAction);\n-        file->addSeparator();\n     }\n     file->addAction(quitAction);\n \n@@ -401,11 +398,64 @@ void BitcoinGUI::createMenuBar()\n     }\n     settings->addAction(optionsAction);\n \n-    QMenu *help = appMenuBar->addMenu(tr(\"&Help\"));\n-    if(walletFrame)\n-    {\n-        help->addAction(openRPCConsoleAction);\n+    QMenu* window_menu = appMenuBar->addMenu(tr(\"&Window\"));\n+\n+    QAction* minimize_action = window_menu->addAction(tr(\"Minimize\"));\n+    minimize_action->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_M));\n+    connect(minimize_action, &QAction::triggered, [] {\n+        qApp->focusWindow()->showMinimized();\n+    });\n+    connect(qApp, &QApplication::focusWindowChanged, [minimize_action] (QWindow* window) {\n+        minimize_action->setEnabled(window != nullptr && (window->flags() & Qt::Dialog) != Qt::Dialog && window->windowState() != Qt::WindowMinimized);\n+    });\n+\n+#ifdef Q_OS_MAC\n+    QAction* zoom_action = window_menu->addAction(tr(\"Zoom\"));\n+    connect(zoom_action, &QAction::triggered, [] {\n+        QWindow* window = qApp->focusWindow();\n+        if (window->windowState() != Qt::WindowMaximized) {\n+            window->showMaximized();\n+        } else {\n+            window->showNormal();\n+        }\n+    });\n+\n+    connect(qApp, &QApplication::focusWindowChanged, [zoom_action] (QWindow* window) {\n+        zoom_action->setEnabled(window != nullptr);\n+    });\n+#else\n+    QAction* restore_action = window_menu->addAction(tr(\"Restore\"));\n+    connect(restore_action, &QAction::triggered, [] {\n+        qApp->focusWindow()->showNormal();\n+    });\n+\n+    connect(qApp, &QApplication::focusWindowChanged, [restore_action] (QWindow* window) {\n+        restore_action->setEnabled(window != nullptr);\n+    });\n+#endif\n+\n+    if (walletFrame) {\n+        window_menu->addSeparator();\n+        QAction* main_window_action = window_menu->addAction(tr(\"Main Window\"));\n+        connect(main_window_action, &QAction::triggered, [this] {\n+            GUIUtil::bringToFront(this);\n+        });\n+\n+        window_menu->addSeparator();\n+        window_menu->addAction(usedSendingAddressesAction);\n+        window_menu->addAction(usedReceivingAddressesAction);\n+    }\n+\n+    window_menu->addSeparator();\n+    for (RPCConsole::TabTypes tab_type : rpcConsole->tabs()) {\n+        QAction* tab_action = window_menu->addAction(rpcConsole->tabTitle(tab_type));\n+        connect(tab_action, &QAction::triggered, [this, tab_type] {\n+            rpcConsole->setTabFocus(tab_type);\n+            showDebugWindow();\n+        });\n     }\n+\n+    QMenu *help = appMenuBar->addMenu(tr(\"&Help\"));\n     help->addAction(showHelpMessageAction);\n     help->addSeparator();\n     help->addAction(aboutAction);\n@@ -1089,10 +1139,10 @@ bool BitcoinGUI::handlePaymentRequest(const SendCoinsRecipient& recipient)\n     return false;\n }\n \n-void BitcoinGUI::setHDStatus(int hdEnabled)\n+void BitcoinGUI::setHDStatus(bool privkeyDisabled, int hdEnabled)\n {\n-    labelWalletHDStatusIcon->setPixmap(platformStyle->SingleColorIcon(hdEnabled ? \":/icons/hd_enabled\" : \":/icons/hd_disabled\").pixmap(STATUSBAR_ICONSIZE,STATUSBAR_ICONSIZE));\n-    labelWalletHDStatusIcon->setToolTip(hdEnabled ? tr(\"HD key generation is <b>enabled</b>\") : tr(\"HD key generation is <b>disabled</b>\"));\n+    labelWalletHDStatusIcon->setPixmap(platformStyle->SingleColorIcon(privkeyDisabled ? \":/icons/eye\" : hdEnabled ? \":/icons/hd_enabled\" : \":/icons/hd_disabled\").pixmap(STATUSBAR_ICONSIZE,STATUSBAR_ICONSIZE));\n+    labelWalletHDStatusIcon->setToolTip(privkeyDisabled ? tr(\"Private key <b>disabled</b>\") : hdEnabled ? tr(\"HD key generation is <b>enabled</b>\") : tr(\"HD key generation is <b>disabled</b>\"));\n \n     // eventually disable the QLabel to set its opacity to 50%\n     labelWalletHDStatusIcon->setEnabled(hdEnabled);\n@@ -1138,7 +1188,7 @@ void BitcoinGUI::updateWalletStatus()\n     }\n     WalletModel * const walletModel = walletView->getWalletModel();\n     setEncryptionStatus(walletModel->getEncryptionStatus());\n-    setHDStatus(walletModel->wallet().hdEnabled());\n+    setHDStatus(walletModel->privateKeysDisabled(), walletModel->wallet().hdEnabled());\n }\n #endif // ENABLE_WALLET\n \n@@ -1226,9 +1276,6 @@ void BitcoinGUI::showModalOverlay()\n \n static bool ThreadSafeMessageBox(BitcoinGUI* gui, const std::string& message, const std::string& caption, unsigned int style)\n {\n-    // Redundantly log and print message in non-gui fashion\n-    noui_ThreadSafeMessageBox(message, caption, style);\n-\n     bool modal = (style & CClientUIInterface::MODAL);\n     // The SECURE flag has no effect in the Qt GUI.\n     // bool secure = (style & CClientUIInterface::SECURE);"
      },
      {
        "sha": "aeff5dae30455c4aa5daecfb1da730f1e5c82fca",
        "filename": "src/qt/bitcoingui.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/bitcoingui.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/bitcoingui.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.h?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -223,7 +223,7 @@ public Q_SLOTS:\n      @param[in] hdEnabled         current hd enabled status\n      @see WalletModel::EncryptionStatus\n      */\n-    void setHDStatus(int hdEnabled);\n+    void setHDStatus(bool privkeyDisabled, int hdEnabled);\n \n public Q_SLOTS:\n     bool handlePaymentRequest(const SendCoinsRecipient& recipient);"
      },
      {
        "sha": "77f8bcf9016afc869c7cad5033d39e0b6707daac",
        "filename": "src/qt/coincontroldialog.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 11,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/coincontroldialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/coincontroldialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroldialog.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -129,8 +129,6 @@ CoinControlDialog::CoinControlDialog(const PlatformStyle *_platformStyle, QWidge\n     ui->treeWidget->setColumnWidth(COLUMN_ADDRESS, 320);\n     ui->treeWidget->setColumnWidth(COLUMN_DATE, 130);\n     ui->treeWidget->setColumnWidth(COLUMN_CONFIRMATIONS, 110);\n-    ui->treeWidget->setColumnHidden(COLUMN_TXHASH, true);         // store transaction hash in this column, but don't show it\n-    ui->treeWidget->setColumnHidden(COLUMN_VOUT_INDEX, true);     // store vout index in this column, but don't show it\n \n     // default view is sorted by amount desc\n     sortView(COLUMN_AMOUNT, Qt::DescendingOrder);\n@@ -203,10 +201,10 @@ void CoinControlDialog::showMenu(const QPoint &point)\n         contextMenuItem = item;\n \n         // disable some items (like Copy Transaction ID, lock, unlock) for tree roots in context menu\n-        if (item->text(COLUMN_TXHASH).length() == 64) // transaction hash is 64 characters (this means it is a child node, so it is not a parent node in tree mode)\n+        if (item->data(COLUMN_ADDRESS, TxHashRole).toString().length() == 64) // transaction hash is 64 characters (this means it is a child node, so it is not a parent node in tree mode)\n         {\n             copyTransactionHashAction->setEnabled(true);\n-            if (model->wallet().isLockedCoin(COutPoint(uint256S(item->text(COLUMN_TXHASH).toStdString()), item->text(COLUMN_VOUT_INDEX).toUInt())))\n+            if (model->wallet().isLockedCoin(COutPoint(uint256S(item->data(COLUMN_ADDRESS, TxHashRole).toString().toStdString()), item->data(COLUMN_ADDRESS, VOutRole).toUInt())))\n             {\n                 lockAction->setEnabled(false);\n                 unlockAction->setEnabled(true);\n@@ -256,7 +254,7 @@ void CoinControlDialog::copyAddress()\n // context menu action: copy transaction id\n void CoinControlDialog::copyTransactionHash()\n {\n-    GUIUtil::setClipboard(contextMenuItem->text(COLUMN_TXHASH));\n+    GUIUtil::setClipboard(contextMenuItem->data(COLUMN_ADDRESS, TxHashRole).toString());\n }\n \n // context menu action: lock coin\n@@ -265,7 +263,7 @@ void CoinControlDialog::lockCoin()\n     if (contextMenuItem->checkState(COLUMN_CHECKBOX) == Qt::Checked)\n         contextMenuItem->setCheckState(COLUMN_CHECKBOX, Qt::Unchecked);\n \n-    COutPoint outpt(uint256S(contextMenuItem->text(COLUMN_TXHASH).toStdString()), contextMenuItem->text(COLUMN_VOUT_INDEX).toUInt());\n+    COutPoint outpt(uint256S(contextMenuItem->data(COLUMN_ADDRESS, TxHashRole).toString().toStdString()), contextMenuItem->data(COLUMN_ADDRESS, VOutRole).toUInt());\n     model->wallet().lockCoin(outpt);\n     contextMenuItem->setDisabled(true);\n     contextMenuItem->setIcon(COLUMN_CHECKBOX, platformStyle->SingleColorIcon(\":/icons/lock_closed\"));\n@@ -275,7 +273,7 @@ void CoinControlDialog::lockCoin()\n // context menu action: unlock coin\n void CoinControlDialog::unlockCoin()\n {\n-    COutPoint outpt(uint256S(contextMenuItem->text(COLUMN_TXHASH).toStdString()), contextMenuItem->text(COLUMN_VOUT_INDEX).toUInt());\n+    COutPoint outpt(uint256S(contextMenuItem->data(COLUMN_ADDRESS, TxHashRole).toString().toStdString()), contextMenuItem->data(COLUMN_ADDRESS, VOutRole).toUInt());\n     model->wallet().unlockCoin(outpt);\n     contextMenuItem->setDisabled(false);\n     contextMenuItem->setIcon(COLUMN_CHECKBOX, QIcon());\n@@ -371,9 +369,9 @@ void CoinControlDialog::radioListMode(bool checked)\n // checkbox clicked by user\n void CoinControlDialog::viewItemChanged(QTreeWidgetItem* item, int column)\n {\n-    if (column == COLUMN_CHECKBOX && item->text(COLUMN_TXHASH).length() == 64) // transaction hash is 64 characters (this means it is a child node, so it is not a parent node in tree mode)\n+    if (column == COLUMN_CHECKBOX && item->data(COLUMN_ADDRESS, TxHashRole).toString().length() == 64) // transaction hash is 64 characters (this means it is a child node, so it is not a parent node in tree mode)\n     {\n-        COutPoint outpt(uint256S(item->text(COLUMN_TXHASH).toStdString()), item->text(COLUMN_VOUT_INDEX).toUInt());\n+        COutPoint outpt(uint256S(item->data(COLUMN_ADDRESS, TxHashRole).toString().toStdString()), item->data(COLUMN_ADDRESS, VOutRole).toUInt());\n \n         if (item->checkState(COLUMN_CHECKBOX) == Qt::Unchecked)\n             coinControl()->UnSelect(outpt);\n@@ -693,10 +691,10 @@ void CoinControlDialog::updateView()\n             itemOutput->setData(COLUMN_CONFIRMATIONS, Qt::UserRole, QVariant((qlonglong)out.depth_in_main_chain));\n \n             // transaction hash\n-            itemOutput->setText(COLUMN_TXHASH, QString::fromStdString(output.hash.GetHex()));\n+            itemOutput->setData(COLUMN_ADDRESS, TxHashRole, QString::fromStdString(output.hash.GetHex()));\n \n             // vout index\n-            itemOutput->setText(COLUMN_VOUT_INDEX, QString::number(output.n));\n+            itemOutput->setData(COLUMN_ADDRESS, VOutRole, output.n);\n \n              // disable locked coins\n             if (model->wallet().isLockedCoin(output))"
      },
      {
        "sha": "8f15ae4b20496ac403d63b672c0d0b202f3ffd7e",
        "filename": "src/qt/coincontroldialog.h",
        "status": "modified",
        "additions": 7,
        "deletions": 2,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/coincontroldialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/coincontroldialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroldialog.h?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -80,9 +80,14 @@ class CoinControlDialog : public QDialog\n         COLUMN_ADDRESS,\n         COLUMN_DATE,\n         COLUMN_CONFIRMATIONS,\n-        COLUMN_TXHASH,\n-        COLUMN_VOUT_INDEX,\n     };\n+\n+    enum\n+    {\n+        TxHashRole = Qt::UserRole,\n+        VOutRole\n+    };\n+\n     friend class CCoinControlWidgetItem;\n \n private Q_SLOTS:"
      },
      {
        "sha": "bd7f3c5f56b864baeb407dca479f5ace50b914ec",
        "filename": "src/qt/forms/coincontroldialog.ui",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/forms/coincontroldialog.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/forms/coincontroldialog.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/coincontroldialog.ui?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -402,7 +402,7 @@\n       <bool>false</bool>\n      </property>\n      <property name=\"columnCount\">\n-      <number>10</number>\n+      <number>6</number>\n      </property>\n      <attribute name=\"headerShowSortIndicator\" stdset=\"0\">\n       <bool>true</bool>"
      },
      {
        "sha": "2fc166b0c554b73fa0fe212ef9c816ca25e19b87",
        "filename": "src/qt/guiutil.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/guiutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/guiutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -339,7 +339,7 @@ bool checkPoint(const QPoint &p, const QWidget *w)\n {\n     QWidget *atW = QApplication::widgetAt(w->mapToGlobal(p));\n     if (!atW) return false;\n-    return atW->topLevelWidget() == w;\n+    return atW->window() == w;\n }\n \n bool isObscured(QWidget *w)"
      },
      {
        "sha": "a07079eece9dd9c6907f39da30ce304b5496b585",
        "filename": "src/qt/macnotificationhandler.mm",
        "status": "modified",
        "additions": 4,
        "deletions": 19,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/macnotificationhandler.mm",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/macnotificationhandler.mm",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/macnotificationhandler.mm?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -24,25 +24,10 @@ - (NSString *)__bundleIdentifier\n {\n     // check if users OS has support for NSUserNotification\n     if(this->hasUserNotificationCenterSupport()) {\n-        // okay, seems like 10.8+\n-        QByteArray utf8 = title.toUtf8();\n-        char* cString = (char *)utf8.constData();\n-        NSString *titleMac = [[NSString alloc] initWithUTF8String:cString];\n-\n-        utf8 = text.toUtf8();\n-        cString = (char *)utf8.constData();\n-        NSString *textMac = [[NSString alloc] initWithUTF8String:cString];\n-\n-        // do everything weak linked (because we will keep <10.8 compatibility)\n-        id userNotification = [[NSClassFromString(@\"NSUserNotification\") alloc] init];\n-        [userNotification performSelector:@selector(setTitle:) withObject:titleMac];\n-        [userNotification performSelector:@selector(setInformativeText:) withObject:textMac];\n-\n-        id notificationCenterInstance = [NSClassFromString(@\"NSUserNotificationCenter\") performSelector:@selector(defaultUserNotificationCenter)];\n-        [notificationCenterInstance performSelector:@selector(deliverNotification:) withObject:userNotification];\n-\n-        [titleMac release];\n-        [textMac release];\n+        NSUserNotification* userNotification = [[NSUserNotification alloc] init];\n+        userNotification.title = title.toNSString();\n+        userNotification.informativeText = text.toNSString();\n+        [[NSUserNotificationCenter defaultUserNotificationCenter] deliverNotification: userNotification];\n         [userNotification release];\n     }\n }"
      },
      {
        "sha": "bec79335e787b49fadc8fa733e4d6ef7de102501",
        "filename": "src/qt/overviewpage.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 12,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/overviewpage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/overviewpage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/overviewpage.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -161,15 +161,21 @@ void OverviewPage::setBalance(const interfaces::WalletBalances& balances)\n {\n     int unit = walletModel->getOptionsModel()->getDisplayUnit();\n     m_balances = balances;\n-    ui->labelBalance->setText(BitcoinUnits::formatWithUnit(unit, balances.balance, false, BitcoinUnits::separatorAlways));\n-    ui->labelUnconfirmed->setText(BitcoinUnits::formatWithUnit(unit, balances.unconfirmed_balance, false, BitcoinUnits::separatorAlways));\n-    ui->labelImmature->setText(BitcoinUnits::formatWithUnit(unit, balances.immature_balance, false, BitcoinUnits::separatorAlways));\n-    ui->labelTotal->setText(BitcoinUnits::formatWithUnit(unit, balances.balance + balances.unconfirmed_balance + balances.immature_balance, false, BitcoinUnits::separatorAlways));\n-    ui->labelWatchAvailable->setText(BitcoinUnits::formatWithUnit(unit, balances.watch_only_balance, false, BitcoinUnits::separatorAlways));\n-    ui->labelWatchPending->setText(BitcoinUnits::formatWithUnit(unit, balances.unconfirmed_watch_only_balance, false, BitcoinUnits::separatorAlways));\n-    ui->labelWatchImmature->setText(BitcoinUnits::formatWithUnit(unit, balances.immature_watch_only_balance, false, BitcoinUnits::separatorAlways));\n-    ui->labelWatchTotal->setText(BitcoinUnits::formatWithUnit(unit, balances.watch_only_balance + balances.unconfirmed_watch_only_balance + balances.immature_watch_only_balance, false, BitcoinUnits::separatorAlways));\n-\n+    if (walletModel->privateKeysDisabled()) {\n+        ui->labelBalance->setText(BitcoinUnits::formatWithUnit(unit, balances.watch_only_balance, false, BitcoinUnits::separatorAlways));\n+        ui->labelUnconfirmed->setText(BitcoinUnits::formatWithUnit(unit, balances.unconfirmed_watch_only_balance, false, BitcoinUnits::separatorAlways));\n+        ui->labelImmature->setText(BitcoinUnits::formatWithUnit(unit, balances.immature_watch_only_balance, false, BitcoinUnits::separatorAlways));\n+        ui->labelTotal->setText(BitcoinUnits::formatWithUnit(unit, balances.watch_only_balance + balances.unconfirmed_watch_only_balance + balances.immature_watch_only_balance, false, BitcoinUnits::separatorAlways));\n+    } else {\n+        ui->labelBalance->setText(BitcoinUnits::formatWithUnit(unit, balances.balance, false, BitcoinUnits::separatorAlways));\n+        ui->labelUnconfirmed->setText(BitcoinUnits::formatWithUnit(unit, balances.unconfirmed_balance, false, BitcoinUnits::separatorAlways));\n+        ui->labelImmature->setText(BitcoinUnits::formatWithUnit(unit, balances.immature_balance, false, BitcoinUnits::separatorAlways));\n+        ui->labelTotal->setText(BitcoinUnits::formatWithUnit(unit, balances.balance + balances.unconfirmed_balance + balances.immature_balance, false, BitcoinUnits::separatorAlways));\n+        ui->labelWatchAvailable->setText(BitcoinUnits::formatWithUnit(unit, balances.watch_only_balance, false, BitcoinUnits::separatorAlways));\n+        ui->labelWatchPending->setText(BitcoinUnits::formatWithUnit(unit, balances.unconfirmed_watch_only_balance, false, BitcoinUnits::separatorAlways));\n+        ui->labelWatchImmature->setText(BitcoinUnits::formatWithUnit(unit, balances.immature_watch_only_balance, false, BitcoinUnits::separatorAlways));\n+        ui->labelWatchTotal->setText(BitcoinUnits::formatWithUnit(unit, balances.watch_only_balance + balances.unconfirmed_watch_only_balance + balances.immature_watch_only_balance, false, BitcoinUnits::separatorAlways));\n+    }\n     // only show immature (newly mined) balance if it's non-zero, so as not to complicate things\n     // for the non-mining users\n     bool showImmature = balances.immature_balance != 0;\n@@ -178,7 +184,7 @@ void OverviewPage::setBalance(const interfaces::WalletBalances& balances)\n     // for symmetry reasons also show immature label when the watch-only one is shown\n     ui->labelImmature->setVisible(showImmature || showWatchOnlyImmature);\n     ui->labelImmatureText->setVisible(showImmature || showWatchOnlyImmature);\n-    ui->labelWatchImmature->setVisible(showWatchOnlyImmature); // show watch-only immature balance\n+    ui->labelWatchImmature->setVisible(!walletModel->privateKeysDisabled() && showWatchOnlyImmature); // show watch-only immature balance\n }\n \n // show/hide watch-only labels\n@@ -231,8 +237,10 @@ void OverviewPage::setWalletModel(WalletModel *model)\n \n         connect(model->getOptionsModel(), &OptionsModel::displayUnitChanged, this, &OverviewPage::updateDisplayUnit);\n \n-        updateWatchOnlyLabels(wallet.haveWatchOnly());\n-        connect(model, &WalletModel::notifyWatchonlyChanged, this, &OverviewPage::updateWatchOnlyLabels);\n+        updateWatchOnlyLabels(wallet.haveWatchOnly() && !model->privateKeysDisabled());\n+        connect(model, &WalletModel::notifyWatchonlyChanged, [this](bool showWatchOnly) {\n+            updateWatchOnlyLabels(showWatchOnly && !walletModel->privateKeysDisabled());\n+        });\n     }\n \n     // update the display unit, to not use the default (\"BTC\")"
      },
      {
        "sha": "f47c66e02c0eb4dad2ae271a3563c3d4efd1edf1",
        "filename": "src/qt/res/movies/makespinner.sh",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/res/movies/makespinner.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/res/movies/makespinner.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/res/movies/makespinner.sh?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -1,3 +1,5 @@\n+#!/usr/bin/env bash\n+#\n # Copyright (c) 2014-2015 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php."
      },
      {
        "sha": "774a0d78e7f2c796d0a832007d8a0cb4e22fba56",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -1275,7 +1275,17 @@ void RPCConsole::showOrHideBanTableIfRequired()\n     ui->banHeading->setVisible(visible);\n }\n \n+RPCConsole::TabTypes RPCConsole::tabFocus() const\n+{\n+    return (TabTypes) ui->tabWidget->currentIndex();\n+}\n+\n void RPCConsole::setTabFocus(enum TabTypes tabType)\n {\n     ui->tabWidget->setCurrentIndex(tabType);\n }\n+\n+QString RPCConsole::tabTitle(TabTypes tab_type) const\n+{\n+    return ui->tabWidget->tabText(tab_type);\n+}"
      },
      {
        "sha": "20dbf5ec95e4c39f83f4312c55823f1acd4fd2d1",
        "filename": "src/qt/rpcconsole.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/rpcconsole.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/rpcconsole.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.h?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -65,6 +65,11 @@ class RPCConsole: public QWidget\n         TAB_PEERS = 3\n     };\n \n+    std::vector<TabTypes> tabs() const { return {TAB_INFO, TAB_CONSOLE, TAB_GRAPH, TAB_PEERS}; }\n+\n+    TabTypes tabFocus() const;\n+    QString tabTitle(TabTypes tab_type) const;\n+\n protected:\n     virtual bool eventFilter(QObject* obj, QEvent *event);\n     void keyPressEvent(QKeyEvent *);"
      },
      {
        "sha": "7b952f9fd72b30b4251b7bb8f37ff2bcb0c415d7",
        "filename": "src/qt/splashscreen.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/splashscreen.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/splashscreen.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/splashscreen.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -145,10 +145,8 @@ bool SplashScreen::eventFilter(QObject * obj, QEvent * ev) {\n     return QObject::eventFilter(obj, ev);\n }\n \n-void SplashScreen::slotFinish(QWidget *mainWin)\n+void SplashScreen::finish()\n {\n-    Q_UNUSED(mainWin);\n-\n     /* If the window is minimized, hide() will be ignored. */\n     /* Make sure we de-minimize the splashscreen window before hiding */\n     if (isMinimized())"
      },
      {
        "sha": "f99dd0c701c5a3b259ea1801bee43b81d16f7fe6",
        "filename": "src/qt/splashscreen.h",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/splashscreen.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/splashscreen.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/splashscreen.h?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -5,8 +5,7 @@\n #ifndef BITCOIN_QT_SPLASHSCREEN_H\n #define BITCOIN_QT_SPLASHSCREEN_H\n \n-#include <functional>\n-#include <QSplashScreen>\n+#include <QWidget>\n \n #include <memory>\n \n@@ -37,8 +36,8 @@ class SplashScreen : public QWidget\n     void closeEvent(QCloseEvent *event);\n \n public Q_SLOTS:\n-    /** Slot to call finish() method as it's not defined as slot */\n-    void slotFinish(QWidget *mainWin);\n+    /** Hide the splash screen window and schedule the splash screen object for deletion */\n+    void finish();\n \n     /** Show message and progress */\n     void showMessage(const QString &message, int alignment, const QColor &color);"
      },
      {
        "sha": "610d83acb6fb967a8d57eca8b52e1582bf23d0e4",
        "filename": "src/qt/test/wallettests.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/test/wallettests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/qt/test/wallettests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/wallettests.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -146,7 +146,13 @@ void TestGUI()\n         auto locked_chain = wallet->chain().lock();\n         WalletRescanReserver reserver(wallet.get());\n         reserver.reserve();\n-        wallet->ScanForWalletTransactions(chainActive.Genesis(), nullptr, reserver, true);\n+        const CBlockIndex* const null_block = nullptr;\n+        const CBlockIndex *stop_block, *failed_block;\n+        QCOMPARE(\n+            wallet->ScanForWalletTransactions(chainActive.Genesis(), nullptr, reserver, failed_block, stop_block, true /* fUpdate */),\n+            CWallet::ScanResult::SUCCESS);\n+        QCOMPARE(stop_block, chainActive.Tip());\n+        QCOMPARE(failed_block, null_block);\n     }\n     wallet->SetBroadcastTransactions(true);\n "
      },
      {
        "sha": "f8ffda136d85a5929f5d212d30b0979e7bdcbcf6",
        "filename": "src/random.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/random.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/random.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -398,6 +398,7 @@ uint256 FastRandomContext::rand256()\n \n std::vector<unsigned char> FastRandomContext::randbytes(size_t len)\n {\n+    if (requires_seed) RandomSeed();\n     std::vector<unsigned char> ret(len);\n     if (len > 0) {\n         rng.Output(&ret[0], len);\n@@ -463,6 +464,20 @@ FastRandomContext::FastRandomContext(bool fDeterministic) : requires_seed(!fDete\n     rng.SetKey(seed.begin(), 32);\n }\n \n+FastRandomContext& FastRandomContext::operator=(FastRandomContext&& from) noexcept\n+{\n+    requires_seed = from.requires_seed;\n+    rng = from.rng;\n+    std::copy(std::begin(from.bytebuf), std::end(from.bytebuf), std::begin(bytebuf));\n+    bytebuf_size = from.bytebuf_size;\n+    bitbuf = from.bitbuf;\n+    bitbuf_size = from.bitbuf_size;\n+    from.requires_seed = true;\n+    from.bytebuf_size = 0;\n+    from.bitbuf_size = 0;\n+    return *this;\n+}\n+\n void RandomInit()\n {\n     RDRandInit();"
      },
      {
        "sha": "00e90abbc5f7b7786b8f3da1e0ba47dcf02dfddb",
        "filename": "src/random.h",
        "status": "modified",
        "additions": 31,
        "deletions": 0,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/random.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/random.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.h?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -76,6 +76,14 @@ class FastRandomContext {\n     /** Initialize with explicit seed (only for testing) */\n     explicit FastRandomContext(const uint256& seed);\n \n+    // Do not permit copying a FastRandomContext (move it, or create a new one to get reseeded).\n+    FastRandomContext(const FastRandomContext&) = delete;\n+    FastRandomContext(FastRandomContext&&) = delete;\n+    FastRandomContext& operator=(const FastRandomContext&) = delete;\n+\n+    /** Move a FastRandomContext. If the original one is used again, it will be reseeded. */\n+    FastRandomContext& operator=(FastRandomContext&& from) noexcept;\n+\n     /** Generate a random 64-bit integer. */\n     uint64_t rand64()\n     {\n@@ -130,6 +138,29 @@ class FastRandomContext {\n     inline uint64_t operator()() { return rand64(); }\n };\n \n+/** More efficient than using std::shuffle on a FastRandomContext.\n+ *\n+ * This is more efficient as std::shuffle will consume entropy in groups of\n+ * 64 bits at the time and throw away most.\n+ *\n+ * This also works around a bug in libstdc++ std::shuffle that may cause\n+ * type::operator=(type&&) to be invoked on itself, which the library's\n+ * debug mode detects and panics on. This is a known issue, see\n+ * https://stackoverflow.com/questions/22915325/avoiding-self-assignment-in-stdshuffle\n+ */\n+template<typename I, typename R>\n+void Shuffle(I first, I last, R&& rng)\n+{\n+    while (first != last) {\n+        size_t j = rng.randrange(last - first);\n+        if (j) {\n+            using std::swap;\n+            swap(*first, *(first + j));\n+        }\n+        ++first;\n+    }\n+}\n+\n /* Number of random bytes returned by GetOSRand.\n  * When changing this constant make sure to change all call sites, and make\n  * sure that the underlying OS APIs for all platforms support the number."
      },
      {
        "sha": "ec87f42c93199557a8fb1b58a6d0e7fc017e90af",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 48,
        "deletions": 110,
        "changes": 158,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -212,11 +212,9 @@ static UniValue waitfornewblock(const JSONRPCRequest& request)\n                 \"\\nWaits for a specific new block and returns useful info about it.\\n\"\n                 \"\\nReturns the current block on timeout or exit.\\n\",\n                 {\n-                    {\"timeout\", RPCArg::Type::NUM, true},\n+                    {\"timeout\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"0\", \"Time in milliseconds to wait for a response. 0 indicates no timeout.\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. timeout (int, optional, default=0) Time in milliseconds to wait for a response. 0 indicates no timeout.\\n\"\n             \"\\nResult:\\n\"\n             \"{                           (json object)\\n\"\n             \"  \\\"hash\\\" : {       (string) The blockhash\\n\"\n@@ -254,13 +252,10 @@ static UniValue waitforblock(const JSONRPCRequest& request)\n                 \"\\nWaits for a specific new block and returns useful info about it.\\n\"\n                 \"\\nReturns the current block on timeout or exit.\\n\",\n                 {\n-                    {\"blockhash\", RPCArg::Type::STR, false},\n-                    {\"timeout\", RPCArg::Type::NUM, true},\n+                    {\"blockhash\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"Block hash to wait for.\"},\n+                    {\"timeout\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"0\", \"Time in milliseconds to wait for a response. 0 indicates no timeout.\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"blockhash\\\" (required, string) Block hash to wait for.\\n\"\n-            \"2. timeout       (int, optional, default=0) Time in milliseconds to wait for a response. 0 indicates no timeout.\\n\"\n             \"\\nResult:\\n\"\n             \"{                           (json object)\\n\"\n             \"  \\\"hash\\\" : {       (string) The blockhash\\n\"\n@@ -302,13 +297,10 @@ static UniValue waitforblockheight(const JSONRPCRequest& request)\n                 \"of the current tip.\\n\"\n                 \"\\nReturns the current block on timeout or exit.\\n\",\n                 {\n-                    {\"height\", RPCArg::Type::NUM, false},\n-                    {\"timeout\", RPCArg::Type::NUM, true},\n+                    {\"height\", RPCArg::Type::NUM, /* opt */ false, /* default_val */ \"\", \"Block height to wait for.\"},\n+                    {\"timeout\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"0\", \"Time in milliseconds to wait for a response. 0 indicates no timeout.\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. height  (int, required) Block height to wait for.\\n\"\n-            \"2. timeout (int, optional, default=0) Time in milliseconds to wait for a response. 0 indicates no timeout.\\n\"\n             \"\\nResult:\\n\"\n             \"{                           (json object)\\n\"\n             \"  \\\"hash\\\" : {       (string) The blockhash\\n\"\n@@ -496,14 +488,12 @@ static UniValue getrawmempool(const JSONRPCRequest& request)\n     if (request.fHelp || request.params.size() > 1)\n         throw std::runtime_error(\n             RPCHelpMan{\"getrawmempool\",\n-                \"\\nReturns all transaction ids in memory pool as a json array of string transaction ids.\\n\",\n+                \"\\nReturns all transaction ids in memory pool as a json array of string transaction ids.\\n\"\n+                \"\\nHint: use getmempoolentry to fetch a specific transaction from the mempool.\\n\",\n                 {\n-                    {\"verbose\", RPCArg::Type::BOOL, true},\n+                    {\"verbose\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"True for a json object, false for array of transaction ids\"},\n                 }}\n                 .ToString() +\n-            \"\\nHint: use getmempoolentry to fetch a specific transaction from the mempool.\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. verbose (boolean, optional, default=false) True for a json object, false for array of transaction ids\\n\"\n             \"\\nResult: (for verbose = false):\\n\"\n             \"[                     (json array of string)\\n\"\n             \"  \\\"transactionid\\\"     (string) The transaction id\\n\"\n@@ -534,13 +524,10 @@ static UniValue getmempoolancestors(const JSONRPCRequest& request)\n             RPCHelpMan{\"getmempoolancestors\",\n                 \"\\nIf txid is in the mempool, returns all in-mempool ancestors.\\n\",\n                 {\n-                    {\"txid\", RPCArg::Type::STR_HEX, false},\n-                    {\"verbose\", RPCArg::Type::BOOL, true},\n+                    {\"txid\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"The transaction id (must be in mempool)\"},\n+                    {\"verbose\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"True for a json object, false for array of transaction ids\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"txid\\\"                 (string, required) The transaction id (must be in mempool)\\n\"\n-            \"2. verbose                  (boolean, optional, default=false) True for a json object, false for array of transaction ids\\n\"\n             \"\\nResult (for verbose = false):\\n\"\n             \"[                       (json array of strings)\\n\"\n             \"  \\\"transactionid\\\"           (string) The transaction id of an in-mempool ancestor transaction\\n\"\n@@ -603,13 +590,10 @@ static UniValue getmempooldescendants(const JSONRPCRequest& request)\n             RPCHelpMan{\"getmempooldescendants\",\n                 \"\\nIf txid is in the mempool, returns all in-mempool descendants.\\n\",\n                 {\n-                    {\"txid\", RPCArg::Type::STR_HEX, false},\n-                    {\"verbose\", RPCArg::Type::BOOL, true},\n+                    {\"txid\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"The transaction id (must be in mempool)\"},\n+                    {\"verbose\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"True for a json object, false for array of transaction ids\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"txid\\\"                 (string, required) The transaction id (must be in mempool)\\n\"\n-            \"2. verbose                  (boolean, optional, default=false) True for a json object, false for array of transaction ids\\n\"\n             \"\\nResult (for verbose = false):\\n\"\n             \"[                       (json array of strings)\\n\"\n             \"  \\\"transactionid\\\"           (string) The transaction id of an in-mempool descendant transaction\\n\"\n@@ -672,11 +656,9 @@ static UniValue getmempoolentry(const JSONRPCRequest& request)\n             RPCHelpMan{\"getmempoolentry\",\n                 \"\\nReturns mempool data for given transaction\\n\",\n                 {\n-                    {\"txid\", RPCArg::Type::STR_HEX, false},\n+                    {\"txid\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"The transaction id (must be in mempool)\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"txid\\\"                   (string, required) The transaction id (must be in mempool)\\n\"\n             \"\\nResult:\\n\"\n             \"{                           (json object)\\n\"\n             + EntryDescriptionString()\n@@ -709,11 +691,9 @@ static UniValue getblockhash(const JSONRPCRequest& request)\n             RPCHelpMan{\"getblockhash\",\n                 \"\\nReturns hash of block in best-block-chain at height provided.\\n\",\n                 {\n-                    {\"height\", RPCArg::Type::NUM, false},\n+                    {\"height\", RPCArg::Type::NUM, /* opt */ false, /* default_val */ \"\", \"The height index\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. height         (numeric, required) The height index\\n\"\n             \"\\nResult:\\n\"\n             \"\\\"hash\\\"         (string) The block hash\\n\"\n             \"\\nExamples:\\n\"\n@@ -739,13 +719,10 @@ static UniValue getblockheader(const JSONRPCRequest& request)\n                 \"\\nIf verbose is false, returns a string that is serialized, hex-encoded data for blockheader 'hash'.\\n\"\n                 \"If verbose is true, returns an Object with information about blockheader <hash>.\\n\",\n                 {\n-                    {\"blockhash\", RPCArg::Type::STR_HEX, false},\n-                    {\"verbose\", RPCArg::Type::BOOL, true},\n+                    {\"blockhash\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"The block hash\"},\n+                    {\"verbose\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"true\", \"true for a json object, false for the hex-encoded data\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"blockhash\\\"     (string, required) The block hash\\n\"\n-            \"2. verbose           (boolean, optional, default=true) true for a json object, false for the hex-encoded data\\n\"\n             \"\\nResult (for verbose = true):\\n\"\n             \"{\\n\"\n             \"  \\\"hash\\\" : \\\"hash\\\",     (string) the block hash (same as provided)\\n\"\n@@ -823,13 +800,10 @@ static UniValue getblock(const JSONRPCRequest& request)\n                 \"If verbosity is 1, returns an Object with information about block <hash>.\\n\"\n                 \"If verbosity is 2, returns an Object with information about block <hash> and information about each transaction. \\n\",\n                 {\n-                    {\"blockhash\", RPCArg::Type::STR_HEX, false},\n-                    {\"verbosity\", RPCArg::Type::NUM, true},\n+                    {\"blockhash\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"The block hash\"},\n+                    {\"verbosity\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"1\", \"0 for hex-encoded data, 1 for a json object, and 2 for json object with transaction data\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"blockhash\\\"          (string, required) The block hash\\n\"\n-            \"2. verbosity              (numeric, optional, default=1) 0 for hex-encoded data, 1 for a json object, and 2 for json object with transaction data\\n\"\n             \"\\nResult (for verbosity = 0):\\n\"\n             \"\\\"data\\\"             (string) A string that is serialized, hex-encoded data for block 'hash'.\\n\"\n             \"\\nResult (for verbosity = 1):\\n\"\n@@ -977,12 +951,10 @@ static UniValue pruneblockchain(const JSONRPCRequest& request)\n         throw std::runtime_error(\n             RPCHelpMan{\"pruneblockchain\", \"\",\n                 {\n-                    {\"height\", RPCArg::Type::NUM, false},\n+                    {\"height\", RPCArg::Type::NUM, /* opt */ false, /* default_val */ \"\", \"The block height to prune up to. May be set to a discrete height, or a unix timestamp\\n\"\n+            \"                  to prune blocks whose block time is at least 2 hours older than the provided timestamp.\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"height\\\"       (numeric, required) The block height to prune up to. May be set to a discrete height, or a unix timestamp\\n\"\n-            \"                  to prune blocks whose block time is at least 2 hours older than the provided timestamp.\\n\"\n             \"\\nResult:\\n\"\n             \"n    (numeric) Height of the last block pruned.\\n\"\n             \"\\nExamples:\\n\"\n@@ -1075,16 +1047,11 @@ UniValue gettxout(const JSONRPCRequest& request)\n             RPCHelpMan{\"gettxout\",\n                 \"\\nReturns details about an unspent transaction output.\\n\",\n                 {\n-                    {\"txid\", RPCArg::Type::STR, false},\n-                    {\"n\", RPCArg::Type::NUM, false},\n-                    {\"include_mempool\", RPCArg::Type::BOOL, true},\n+                    {\"txid\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The transaction id\"},\n+                    {\"n\", RPCArg::Type::NUM, /* opt */ false, /* default_val */ \"\", \"vout number\"},\n+                    {\"include_mempool\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"true\", \"Whether to include the mempool. Note that an unspent output that is spent in the mempool won't appear.\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"txid\\\"             (string, required) The transaction id\\n\"\n-            \"2. \\\"n\\\"                (numeric, required) vout number\\n\"\n-            \"3. \\\"include_mempool\\\"  (boolean, optional) Whether to include the mempool. Default: true.\"\n-            \"     Note that an unspent output that is spent in the mempool won't appear.\\n\"\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"bestblock\\\":  \\\"hash\\\",    (string) The hash of the block at the tip of the chain\\n\"\n@@ -1161,13 +1128,10 @@ static UniValue verifychain(const JSONRPCRequest& request)\n             RPCHelpMan{\"verifychain\",\n                 \"\\nVerifies blockchain database.\\n\",\n                 {\n-                    {\"checklevel\", RPCArg::Type::NUM, true},\n-                    {\"nblocks\", RPCArg::Type::NUM, true},\n+                    {\"checklevel\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ strprintf(\"%d, range=0-4\", nCheckLevel), \"How thorough the block verification is.\"},\n+                    {\"nblocks\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ strprintf(\"%d, 0=all\", nCheckDepth), \"The number of blocks to check.\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. checklevel   (numeric, optional, 0-4, default=\" + strprintf(\"%d\", nCheckLevel) + \") How thorough the block verification is.\\n\"\n-            \"2. nblocks      (numeric, optional, default=\" + strprintf(\"%d\", nCheckDepth) + \", 0=all) The number of blocks to check.\\n\"\n             \"\\nResult:\\n\"\n             \"true|false       (boolean) Verified or not\\n\"\n             \"\\nExamples:\\n\"\n@@ -1458,7 +1422,7 @@ static UniValue getchaintips(const JSONRPCRequest& request)\n         } else if (block->nStatus & BLOCK_FAILED_MASK) {\n             // This block or one of its ancestors is invalid.\n             status = \"invalid\";\n-        } else if (block->nChainTx == 0) {\n+        } else if (!block->HaveTxsDownloaded()) {\n             // This block cannot be connected because full block data for it or one of its parents is missing.\n             status = \"headers-only\";\n         } else if (block->IsValid(BLOCK_VALID_SCRIPTS)) {\n@@ -1526,11 +1490,9 @@ static UniValue preciousblock(const JSONRPCRequest& request)\n                 \"\\nA later preciousblock call can override the effect of an earlier one.\\n\"\n                 \"\\nThe effects of preciousblock are not retained across restarts.\\n\",\n                 {\n-                    {\"blockhash\", RPCArg::Type::STR_HEX, false},\n+                    {\"blockhash\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"the hash of the block to mark as precious\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"blockhash\\\"   (string, required) the hash of the block to mark as precious\\n\"\n             \"\\nResult:\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"preciousblock\", \"\\\"blockhash\\\"\")\n@@ -1565,11 +1527,9 @@ static UniValue invalidateblock(const JSONRPCRequest& request)\n             RPCHelpMan{\"invalidateblock\",\n                 \"\\nPermanently marks a block as invalid, as if it violated a consensus rule.\\n\",\n                 {\n-                    {\"blockhash\", RPCArg::Type::STR_HEX, false},\n+                    {\"blockhash\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"the hash of the block to mark as invalid\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"blockhash\\\"   (string, required) the hash of the block to mark as invalid\\n\"\n             \"\\nResult:\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"invalidateblock\", \"\\\"blockhash\\\"\")\n@@ -1608,11 +1568,9 @@ static UniValue reconsiderblock(const JSONRPCRequest& request)\n                 \"\\nRemoves invalidity status of a block and its descendants, reconsider them for activation.\\n\"\n                 \"This can be used to undo the effects of invalidateblock.\\n\",\n                 {\n-                    {\"blockhash\", RPCArg::Type::STR_HEX, false},\n+                    {\"blockhash\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"the hash of the block to reconsider\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"blockhash\\\"   (string, required) the hash of the block to reconsider\\n\"\n             \"\\nResult:\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"reconsiderblock\", \"\\\"blockhash\\\"\")\n@@ -1648,13 +1606,10 @@ static UniValue getchaintxstats(const JSONRPCRequest& request)\n             RPCHelpMan{\"getchaintxstats\",\n                 \"\\nCompute statistics about the total number and rate of transactions in the chain.\\n\",\n                 {\n-                    {\"nblocks\", RPCArg::Type::NUM, true},\n-                    {\"blockhash\", RPCArg::Type::STR_HEX, true},\n+                    {\"nblocks\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"one month\", \"Size of the window in number of blocks\"},\n+                    {\"blockhash\", RPCArg::Type::STR_HEX, /* opt */ true, /* default_val */ \"chain tip\", \"The hash of the block that ends the window.\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. nblocks      (numeric, optional) Size of the window in number of blocks (default: one month).\\n\"\n-            \"2. \\\"blockhash\\\"  (string, optional) The hash of the block that ends the window.\\n\"\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"time\\\": xxxxx,                         (numeric) The timestamp for the final block in the window in UNIX format.\\n\"\n@@ -1785,23 +1740,15 @@ static UniValue getblockstats(const JSONRPCRequest& request)\n                 \"It won't work for some heights with pruning.\\n\"\n                 \"It won't work without -txindex for utxo_size_inc, *fee or *feerate stats.\\n\",\n                 {\n-                    {\"hash_or_height\", RPCArg::Type::NUM, false},\n-                    {\"stats\", RPCArg::Type::ARR,\n+                    {\"hash_or_height\", RPCArg::Type::NUM, /* opt */ false, /* default_val */ \"\", \"The block hash or height of the target block\", \"\", {\"\", \"string or numeric\"}},\n+                    {\"stats\", RPCArg::Type::ARR, /* opt */ true, /* default_val */ \"all values\", \"Values to plot (see result below)\",\n                         {\n-                            {\"height\", RPCArg::Type::STR, true},\n-                            {\"time\", RPCArg::Type::STR, true},\n+                            {\"height\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"\", \"Selected statistic\"},\n+                            {\"time\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"\", \"Selected statistic\"},\n                         },\n-                        true, \"stats\"},\n+                        \"stats\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"hash_or_height\\\"     (string or numeric, required) The block hash or height of the target block\\n\"\n-            \"2. \\\"stats\\\"              (array,  optional) Values to plot, by default all values (see result below)\\n\"\n-            \"    [\\n\"\n-            \"      \\\"height\\\",         (string, optional) Selected statistic\\n\"\n-            \"      \\\"time\\\",           (string, optional) Selected statistic\\n\"\n-            \"      ,...\\n\"\n-            \"    ]\\n\"\n             \"\\nResult:\\n\"\n             \"{                           (json object)\\n\"\n             \"  \\\"avgfee\\\": xxxxx,          (numeric) Average fee in the block\\n\"\n@@ -2153,33 +2100,24 @@ UniValue scantxoutset(const JSONRPCRequest& request)\n                 \"In the latter case, a range needs to be specified by below if different from 1000.\\n\"\n                 \"For more information on output descriptors, see the documentation in the doc/descriptors.md file.\\n\",\n                 {\n-                    {\"action\", RPCArg::Type::STR, false},\n-                    {\"scanobjects\", RPCArg::Type::ARR,\n+                    {\"action\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\"},\n+                    {\"scanobjects\", RPCArg::Type::ARR, /* opt */ false, /* default_val */ \"\", \"Array of scan objects\\n\"\n+            \"                                  Every scan object is either a string descriptor or an object:\",\n                         {\n-                            {\"descriptor\", RPCArg::Type::OBJ,\n+                            {\"descriptor\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"\", \"An output descriptor\"},\n+                            {\"\", RPCArg::Type::OBJ, /* opt */ true, /* default_val */ \"\", \"An object with output descriptor and metadata\",\n                                 {\n-                                    {\"desc\", RPCArg::Type::STR, false},\n-                                    {\"range\", RPCArg::Type::NUM, true},\n+                                    {\"desc\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"An output descriptor\"},\n+                                    {\"range\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"1000\", \"Up to what child index HD chains should be explored\"},\n                                 },\n-                                false, \"scanobjects\"},\n+                            },\n                         },\n-                        false},\n+                        \"[scanobjects,...]\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n-            \"                                      \\\"start\\\" for starting a scan\\n\"\n-            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n-            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n-            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects\\n\"\n-            \"    [                             Every scan object is either a string descriptor or an object:\\n\"\n-            \"        \\\"descriptor\\\",             (string, optional) An output descriptor\\n\"\n-            \"        {                         (object, optional) An object with output descriptor and metadata\\n\"\n-            \"          \\\"desc\\\": \\\"descriptor\\\",   (string, required) An output descriptor\\n\"\n-            \"          \\\"range\\\": n,             (numeric, optional) Up to what child index HD chains should be explored (default: 1000)\\n\"\n-            \"        },\\n\"\n-            \"        ...\\n\"\n-            \"    ]\\n\"\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"unspents\\\": [\\n\""
      },
      {
        "sha": "6f1bfb03d15f089dc5eee79aa8798b65622e8611",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -162,6 +162,7 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"rescanblockchain\", 1, \"stop_height\"},\n     { \"createwallet\", 1, \"disable_private_keys\"},\n     { \"getnodeaddresses\", 0, \"count\"},\n+    { \"stop\", 0, \"wait\" },\n };\n // clang-format on\n "
      },
      {
        "sha": "29684d0e6cfbceb7e5dfc6c3916a22df1bb48720",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 70,
        "changes": 103,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -92,13 +92,10 @@ static UniValue getnetworkhashps(const JSONRPCRequest& request)\n                 \"Pass in [blocks] to override # of blocks, -1 specifies since last difficulty change.\\n\"\n                 \"Pass in [height] to estimate the network speed at the time when a certain block was found.\\n\",\n                 {\n-                    {\"nblocks\", RPCArg::Type::NUM, true},\n-                    {\"height\", RPCArg::Type::NUM, true},\n+                    {\"nblocks\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"120\", \"The number of blocks, or -1 for blocks since last difficulty change.\"},\n+                    {\"height\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"-1\", \"To estimate at the time of the given height.\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. nblocks     (numeric, optional, default=120) The number of blocks, or -1 for blocks since last difficulty change.\\n\"\n-            \"2. height      (numeric, optional, default=-1) To estimate at the time of the given height.\\n\"\n             \"\\nResult:\\n\"\n             \"x             (numeric) Hashes per second estimated\\n\"\n             \"\\nExamples:\\n\"\n@@ -165,15 +162,11 @@ static UniValue generatetoaddress(const JSONRPCRequest& request)\n             RPCHelpMan{\"generatetoaddress\",\n                 \"\\nMine blocks immediately to a specified address (before the RPC call returns)\\n\",\n                 {\n-                    {\"nblocks\", RPCArg::Type::NUM, false},\n-                    {\"address\", RPCArg::Type::STR, false},\n-                    {\"maxtries\", RPCArg::Type::NUM, true},\n+                    {\"nblocks\", RPCArg::Type::NUM, /* opt */ false, /* default_val */ \"\", \"How many blocks are generated immediately.\"},\n+                    {\"address\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The address to send the newly generated bitcoin to.\"},\n+                    {\"maxtries\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"1000000\", \"How many iterations to try.\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. nblocks      (numeric, required) How many blocks are generated immediately.\\n\"\n-            \"2. address      (string, required) The address to send the newly generated bitcoin to.\\n\"\n-            \"3. maxtries     (numeric, optional) How many iterations to try (default = 1000000).\\n\"\n             \"\\nResult:\\n\"\n             \"[ blockhashes ]     (array) hashes of blocks generated\\n\"\n             \"\\nExamples:\\n\"\n@@ -247,19 +240,15 @@ static UniValue prioritisetransaction(const JSONRPCRequest& request)\n             RPCHelpMan{\"prioritisetransaction\",\n                 \"Accepts the transaction into mined blocks at a higher (or lower) priority\\n\",\n                 {\n-                    {\"txid\", RPCArg::Type::STR, false},\n-                    {\"dummy\", RPCArg::Type::NUM, false},\n-                    {\"fee_delta\", RPCArg::Type::NUM, false},\n-                }}\n-                .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"txid\\\"       (string, required) The transaction id.\\n\"\n-            \"2. dummy          (numeric, optional) API-Compatibility for previous API. Must be zero or null.\\n\"\n-            \"                  DEPRECATED. For forward compatibility use named arguments and omit this parameter.\\n\"\n-            \"3. fee_delta      (numeric, required) The fee value (in satoshis) to add (or subtract, if negative).\\n\"\n+                    {\"txid\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"The transaction id.\"},\n+                    {\"dummy\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"null\", \"API-Compatibility for previous API. Must be zero or null.\\n\"\n+            \"                  DEPRECATED. For forward compatibility use named arguments and omit this parameter.\"},\n+                    {\"fee_delta\", RPCArg::Type::NUM, /* opt */ false, /* default_val */ \"\", \"The fee value (in satoshis) to add (or subtract, if negative).\\n\"\n             \"                  Note, that this value is not a fee rate. It is a value to modify absolute fee of the TX.\\n\"\n             \"                  The fee is not actually paid, only the algorithm for selecting transactions into a block\\n\"\n-            \"                  considers the transaction as it would have paid a higher (or lower) fee.\\n\"\n+            \"                  considers the transaction as it would have paid a higher (or lower) fee.\"},\n+                }}\n+                .ToString() +\n             \"\\nResult:\\n\"\n             \"true              (boolean) Returns true\\n\"\n             \"\\nExamples:\\n\"\n@@ -322,38 +311,23 @@ static UniValue getblocktemplate(const JSONRPCRequest& request)\n                 \"    https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki#getblocktemplate_changes\\n\"\n                 \"    https://github.com/bitcoin/bips/blob/master/bip-0145.mediawiki\\n\",\n                 {\n-                    {\"template_request\", RPCArg::Type::OBJ,\n+                    {\"template_request\", RPCArg::Type::OBJ, /* opt */ true, /* default_val */ \"\", \"A json object in the following spec\",\n                         {\n-                            {\"mode\", RPCArg::Type::STR, true},\n-                            {\"capabilities\", RPCArg::Type::ARR,\n+                            {\"mode\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"\", \"This must be set to \\\"template\\\", \\\"proposal\\\" (see BIP 23), or omitted\"},\n+                            {\"capabilities\", RPCArg::Type::ARR, /* opt */ true, /* default_val */ \"\", \"A list of strings\",\n                                 {\n-                                    {\"support\", RPCArg::Type::STR, true},\n+                                    {\"support\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"\", \"client side supported feature, 'longpoll', 'coinbasetxn', 'coinbasevalue', 'proposal', 'serverlist', 'workid'\"},\n                                 },\n-                                true},\n-                            {\"rules\", RPCArg::Type::ARR,\n+                                },\n+                            {\"rules\", RPCArg::Type::ARR, /* opt */ true, /* default_val */ \"\", \"A list of strings\",\n                                 {\n-                                    {\"support\", RPCArg::Type::STR, true},\n+                                    {\"support\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"\", \"client side supported softfork deployment\"},\n+                                },\n                                 },\n-                                true},\n                         },\n-                        true, \"\\\"template_request\\\"\"},\n+                        \"\\\"template_request\\\"\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. template_request         (json object, optional) A json object in the following spec\\n\"\n-            \"     {\\n\"\n-            \"       \\\"mode\\\":\\\"template\\\"    (string, optional) This must be set to \\\"template\\\", \\\"proposal\\\" (see BIP 23), or omitted\\n\"\n-            \"       \\\"capabilities\\\":[     (array, optional) A list of strings\\n\"\n-            \"           \\\"support\\\"          (string) client side supported feature, 'longpoll', 'coinbasetxn', 'coinbasevalue', 'proposal', 'serverlist', 'workid'\\n\"\n-            \"           ,...\\n\"\n-            \"       ],\\n\"\n-            \"       \\\"rules\\\":[            (array, optional) A list of strings\\n\"\n-            \"           \\\"support\\\"          (string) client side supported softfork deployment\\n\"\n-            \"           ,...\\n\"\n-            \"       ]\\n\"\n-            \"     }\\n\"\n-            \"\\n\"\n-\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"version\\\" : n,                    (numeric) The preferred block version\\n\"\n@@ -742,13 +716,10 @@ static UniValue submitblock(const JSONRPCRequest& request)\n                 \"\\nAttempts to submit new block to network.\\n\"\n                 \"See https://en.bitcoin.it/wiki/BIP_0022 for full specification.\\n\",\n                 {\n-                    {\"hexdata\", RPCArg::Type::STR_HEX, false},\n-                    {\"dummy\", RPCArg::Type::STR, true},\n+                    {\"hexdata\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"the hex-encoded block data to submit\"},\n+                    {\"dummy\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"ignored\", \"dummy value, for compatibility with BIP22. This value is ignored.\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments\\n\"\n-            \"1. \\\"hexdata\\\"        (string, required) the hex-encoded block data to submit\\n\"\n-            \"2. \\\"dummy\\\"          (optional) dummy value, for compatibility with BIP22. This value is ignored.\\n\"\n             \"\\nResult:\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"submitblock\", \"\\\"mydata\\\"\")\n@@ -810,11 +781,9 @@ static UniValue submitheader(const JSONRPCRequest& request)\n                 \"\\nDecode the given hexdata as a header and submit it as a candidate chain tip if valid.\"\n                 \"\\nThrows when the header is invalid.\\n\",\n                 {\n-                    {\"hexdata\", RPCArg::Type::STR_HEX, false},\n+                    {\"hexdata\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"the hex-encoded block header data\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments\\n\"\n-            \"1. \\\"hexdata\\\"        (string, required) the hex-encoded block header data\\n\"\n             \"\\nResult:\\n\"\n             \"None\"\n             \"\\nExamples:\\n\" +\n@@ -852,21 +821,18 @@ static UniValue estimatesmartfee(const JSONRPCRequest& request)\n                 \"for which the estimate is valid. Uses virtual transaction size as defined\\n\"\n                 \"in BIP 141 (witness data is discounted).\\n\",\n                 {\n-                    {\"conf_target\", RPCArg::Type::NUM, false},\n-                    {\"estimate_mode\", RPCArg::Type::STR, true},\n-                }}\n-                .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. conf_target     (numeric) Confirmation target in blocks (1 - 1008)\\n\"\n-            \"2. \\\"estimate_mode\\\" (string, optional, default=CONSERVATIVE) The fee estimate mode.\\n\"\n+                    {\"conf_target\", RPCArg::Type::NUM, /* opt */ false, /* default_val */ \"\", \"Confirmation target in blocks (1 - 1008)\"},\n+                    {\"estimate_mode\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"CONSERVATIVE\", \"The fee estimate mode.\\n\"\n             \"                   Whether to return a more conservative estimate which also satisfies\\n\"\n             \"                   a longer history. A conservative estimate potentially returns a\\n\"\n             \"                   higher feerate and is more likely to be sufficient for the desired\\n\"\n             \"                   target, but is not as responsive to short term drops in the\\n\"\n             \"                   prevailing fee market.  Must be one of:\\n\"\n             \"       \\\"UNSET\\\"\\n\"\n             \"       \\\"ECONOMICAL\\\"\\n\"\n-            \"       \\\"CONSERVATIVE\\\"\\n\"\n+            \"       \\\"CONSERVATIVE\\\"\"},\n+                }}\n+                .ToString() +\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"feerate\\\" : x.x,     (numeric, optional) estimate fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n@@ -921,15 +887,12 @@ static UniValue estimaterawfee(const JSONRPCRequest& request)\n                 \"confirmation within conf_target blocks if possible. Uses virtual transaction size as\\n\"\n                 \"defined in BIP 141 (witness data is discounted).\\n\",\n                 {\n-                    {\"conf_target\", RPCArg::Type::NUM, false},\n-                    {\"threshold\", RPCArg::Type::NUM, true},\n+                    {\"conf_target\", RPCArg::Type::NUM, /* opt */ false, /* default_val */ \"\", \"Confirmation target in blocks (1 - 1008)\"},\n+                    {\"threshold\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"0.95\", \"The proportion of transactions in a given feerate range that must have been\\n\"\n+            \"               confirmed within conf_target in order to consider those feerates as high enough and proceed to check\\n\"\n+            \"               lower buckets.\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. conf_target (numeric) Confirmation target in blocks (1 - 1008)\\n\"\n-            \"2. threshold   (numeric, optional) The proportion of transactions in a given feerate range that must have been\\n\"\n-            \"               confirmed within conf_target in order to consider those feerates as high enough and proceed to check\\n\"\n-            \"               lower buckets.  Default: 0.95\\n\"\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"short\\\" : {            (json object, optional) estimate for short time horizon\\n\""
      },
      {
        "sha": "18c867bff32a6bded21e65f2e93315f65564cc64",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 50,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -39,11 +39,9 @@ static UniValue validateaddress(const JSONRPCRequest& request)\n                 \"fields have moved to getaddressinfo and will only be shown here with -deprecatedrpc=validateaddress: ismine, iswatchonly,\\n\"\n                 \"script, hex, pubkeys, sigsrequired, pubkey, addresses, embedded, iscompressed, account, timestamp, hdkeypath, kdmasterkeyid.\\n\",\n                 {\n-                    {\"address\", RPCArg::Type::STR, false},\n+                    {\"address\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The bitcoin address to validate\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"address\\\"                    (string, required) The bitcoin address to validate\\n\"\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"isvalid\\\" : true|false,       (boolean) If the address is valid or not. If not, this is the only property returned.\\n\"\n@@ -82,18 +80,19 @@ static UniValue createmultisig(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n     {\n-        std::string msg = \"createmultisig nrequired [\\\"key\\\",...] ( \\\"address_type\\\" )\\n\"\n-            \"\\nCreates a multi-signature address with n signature of m keys required.\\n\"\n-            \"It returns a json object with the address and redeemScript.\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. nrequired                    (numeric, required) The number of required signatures out of the n keys.\\n\"\n-            \"2. \\\"keys\\\"                       (string, required) A json array of hex-encoded public keys\\n\"\n-            \"     [\\n\"\n-            \"       \\\"key\\\"                    (string) The hex-encoded public key\\n\"\n-            \"       ,...\\n\"\n-            \"     ]\\n\"\n-            \"3. \\\"address_type\\\"               (string, optional) The address type to use. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\". Default is legacy.\\n\"\n-\n+        std::string msg =\n+            RPCHelpMan{\"createmultisig\",\n+                \"\\nCreates a multi-signature address with n signature of m keys required.\\n\"\n+                \"It returns a json object with the address and redeemScript.\\n\",\n+                {\n+                    {\"nrequired\", RPCArg::Type::NUM, /* opt */ false, /* default_val */ \"\", \"The number of required signatures out of the n keys.\"},\n+                    {\"keys\", RPCArg::Type::ARR, /* opt */ false, /* default_val */ \"\", \"A json array of hex-encoded public keys.\",\n+                        {\n+                            {\"key\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"The hex-encoded public key\"},\n+                        }},\n+                    {\"address_type\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"legacy\", \"The address type to use. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n+                }}\n+                .ToString() +\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"address\\\":\\\"multisigaddress\\\",  (string) The value of the new multisig address.\\n\"\n@@ -149,15 +148,11 @@ static UniValue verifymessage(const JSONRPCRequest& request)\n             RPCHelpMan{\"verifymessage\",\n                 \"\\nVerify a signed message\\n\",\n                 {\n-                    {\"address\", RPCArg::Type::STR, false},\n-                    {\"signature\", RPCArg::Type::STR, false},\n-                    {\"message\", RPCArg::Type::STR, false},\n+                    {\"address\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The bitcoin address to use for the signature.\"},\n+                    {\"signature\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The signature provided by the signer in base 64 encoding (see signmessage).\"},\n+                    {\"message\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The message that was signed.\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"address\\\"         (string, required) The bitcoin address to use for the signature.\\n\"\n-            \"2. \\\"signature\\\"       (string, required) The signature provided by the signer in base 64 encoding (see signmessage).\\n\"\n-            \"3. \\\"message\\\"         (string, required) The message that was signed.\\n\"\n             \"\\nResult:\\n\"\n             \"true|false   (boolean) If the signature is verified or not.\\n\"\n             \"\\nExamples:\\n\"\n@@ -211,13 +206,10 @@ static UniValue signmessagewithprivkey(const JSONRPCRequest& request)\n             RPCHelpMan{\"signmessagewithprivkey\",\n                 \"\\nSign a message with the private key of an address\\n\",\n                 {\n-                    {\"privkey\", RPCArg::Type::STR, false},\n-                    {\"message\", RPCArg::Type::STR, false},\n+                    {\"privkey\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The private key to sign the message with.\"},\n+                    {\"message\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The message to create a signature of.\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"privkey\\\"         (string, required) The private key to sign the message with.\\n\"\n-            \"2. \\\"message\\\"         (string, required) The message to create a signature of.\\n\"\n             \"\\nResult:\\n\"\n             \"\\\"signature\\\"          (string) The signature of the message encoded in base 64\\n\"\n             \"\\nExamples:\\n\"\n@@ -255,12 +247,10 @@ static UniValue setmocktime(const JSONRPCRequest& request)\n             RPCHelpMan{\"setmocktime\",\n                 \"\\nSet the local time to given timestamp (-regtest only)\\n\",\n                 {\n-                    {\"timestamp\", RPCArg::Type::NUM, false},\n+                    {\"timestamp\", RPCArg::Type::NUM, /* opt */ false, /* default_val */ \"\", \"Unix seconds-since-epoch timestamp\\n\"\n+            \"   Pass 0 to go back to using the system time.\"},\n                 }}\n-                .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. timestamp  (integer, required) Unix seconds-since-epoch timestamp\\n\"\n-            \"   Pass 0 to go back to using the system time.\"\n+                .ToString()\n         );\n \n     if (!Params().MineBlocksOnDemand())\n@@ -321,13 +311,11 @@ static UniValue getmemoryinfo(const JSONRPCRequest& request)\n             RPCHelpMan{\"getmemoryinfo\",\n                 \"Returns an object containing information about memory usage.\\n\",\n                 {\n-                    {\"mode\", RPCArg::Type::STR, true},\n+                    {\"mode\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"\\\"stats\\\"\", \"determines what kind of information is returned.\\n\"\n+            \"  - \\\"stats\\\" returns general statistics about memory usage in the daemon.\\n\"\n+            \"  - \\\"mallocinfo\\\" returns an XML string describing low-level heap state (only available if compiled with glibc 2.10+).\"},\n                 }}\n                 .ToString() +\n-            \"Arguments:\\n\"\n-            \"1. \\\"mode\\\" determines what kind of information is returned. This argument is optional, the default mode is \\\"stats\\\".\\n\"\n-            \"  - \\\"stats\\\" returns general statistics about memory usage in the daemon.\\n\"\n-            \"  - \\\"mallocinfo\\\" returns an XML string describing low-level heap state (only available if compiled with glibc 2.10+).\\n\"\n             \"\\nResult (mode \\\"stats\\\"):\\n\"\n             \"{\\n\"\n             \"  \\\"locked\\\": {               (json object) Information about locked memory manager\\n\"\n@@ -396,21 +384,16 @@ UniValue logging(const JSONRPCRequest& request)\n             \"  - \\\"none\\\", \\\"0\\\" : even if other logging categories are specified, ignore all of them.\\n\"\n             ,\n                 {\n-                    {\"include\", RPCArg::Type::STR, true},\n-                    {\"exclude\", RPCArg::Type::STR, true},\n+                    {\"include\", RPCArg::Type::ARR, /* opt */ true, /* default_val */ \"null\", \"A json array of categories to add debug logging\",\n+                        {\n+                            {\"include_category\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"the valid logging category\"},\n+                        }},\n+                    {\"exclude\", RPCArg::Type::ARR, /* opt */ true, /* default_val */ \"null\", \"A json array of categories to remove debug logging\",\n+                        {\n+                            {\"exclude_category\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"the valid logging category\"},\n+                        }},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"include\\\"        (array of strings, optional) A json array of categories to add debug logging\\n\"\n-            \"     [\\n\"\n-            \"       \\\"category\\\"   (string) the valid logging category\\n\"\n-            \"       ,...\\n\"\n-            \"     ]\\n\"\n-            \"2. \\\"exclude\\\"        (array of strings, optional) A json array of categories to remove debug logging\\n\"\n-            \"     [\\n\"\n-            \"       \\\"category\\\"   (string) the valid logging category\\n\"\n-            \"       ,...\\n\"\n-            \"     ]\\n\"\n             \"\\nResult:\\n\"\n             \"{                   (json object where keys are the logging categories, and values indicates its status\\n\"\n             \"  \\\"category\\\": 0|1,  (numeric) if being debug logged or not. 0:inactive, 1:active\\n\""
      },
      {
        "sha": "4d6b260cc76e6d054ecbfca2dca12c081735f586",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 30,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -211,13 +211,10 @@ static UniValue addnode(const JSONRPCRequest& request)\n                 \"Nodes added using addnode (or -connect) are protected from DoS disconnection and are not required to be\\n\"\n                 \"full nodes/support SegWit as other outbound peers are (though such peers will not be synced from).\\n\",\n                 {\n-                    {\"node\", RPCArg::Type::STR, false},\n-                    {\"command\", RPCArg::Type::STR, false},\n+                    {\"node\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The node (see getpeerinfo for nodes)\"},\n+                    {\"command\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"'add' to add a node to the list, 'remove' to remove a node from the list, 'onetry' to try a connection to the node once\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"node\\\"     (string, required) The node (see getpeerinfo for nodes)\\n\"\n-            \"2. \\\"command\\\"  (string, required) 'add' to add a node to the list, 'remove' to remove a node from the list, 'onetry' to try a connection to the node once\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"addnode\", \"\\\"192.168.0.6:8333\\\" \\\"onetry\\\"\")\n             + HelpExampleRpc(\"addnode\", \"\\\"192.168.0.6:8333\\\", \\\"onetry\\\"\")\n@@ -258,13 +255,10 @@ static UniValue disconnectnode(const JSONRPCRequest& request)\n                 \"\\nStrictly one out of 'address' and 'nodeid' can be provided to identify the node.\\n\"\n                 \"\\nTo disconnect by nodeid, either set 'address' to the empty string, or call using the named 'nodeid' argument only.\\n\",\n                 {\n-                    {\"address\", RPCArg::Type::STR, true},\n-                    {\"nodeid\", RPCArg::Type::NUM, true},\n+                    {\"address\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"fallback to nodeid\", \"The IP address/port of the node\"},\n+                    {\"nodeid\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"fallback to address\", \"The node ID (see getpeerinfo for node IDs)\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"address\\\"     (string, optional) The IP address/port of the node\\n\"\n-            \"2. nodeid        (number, optional) The node ID (see getpeerinfo for node IDs)\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"disconnectnode\", \"\\\"192.168.0.6:8333\\\"\")\n             + HelpExampleCli(\"disconnectnode\", \"\\\"\\\" 1\")\n@@ -305,11 +299,9 @@ static UniValue getaddednodeinfo(const JSONRPCRequest& request)\n                 \"\\nReturns information about the given added node, or all added nodes\\n\"\n                 \"(note that onetry addnodes are not listed here)\\n\",\n                 {\n-                    {\"node\", RPCArg::Type::STR, true},\n+                    {\"node\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"all nodes\", \"If provided, return information about this specific node, otherwise all nodes are returned.\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"node\\\"   (string, optional) If provided, return information about this specific node, otherwise all nodes are returned.\\n\"\n             \"\\nResult:\\n\"\n             \"[\\n\"\n             \"  {\\n\"\n@@ -524,17 +516,12 @@ static UniValue setban(const JSONRPCRequest& request)\n             RPCHelpMan{\"setban\",\n                 \"\\nAttempts to add or remove an IP/Subnet from the banned list.\\n\",\n                 {\n-                    {\"subnet\", RPCArg::Type::STR, false},\n-                    {\"command\", RPCArg::Type::STR, false},\n-                    {\"bantime\", RPCArg::Type::NUM, true},\n-                    {\"absolute\", RPCArg::Type::NUM, true},\n+                    {\"subnet\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The IP/Subnet (see getpeerinfo for nodes IP) with an optional netmask (default is /32 = single IP)\"},\n+                    {\"command\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"'add' to add an IP/Subnet to the list, 'remove' to remove an IP/Subnet from the list\"},\n+                    {\"bantime\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"0\", \"time in seconds how long (or until when if [absolute] is set) the IP is banned (0 or empty means using the default time of 24h which can also be overwritten by the -bantime startup argument)\"},\n+                    {\"absolute\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"If set, the bantime must be an absolute timestamp in seconds since epoch (Jan 1 1970 GMT)\"},\n                 }}\n                 .ToString() +\n-                            \"\\nArguments:\\n\"\n-                            \"1. \\\"subnet\\\"       (string, required) The IP/Subnet (see getpeerinfo for nodes IP) with an optional netmask (default is /32 = single IP)\\n\"\n-                            \"2. \\\"command\\\"      (string, required) 'add' to add an IP/Subnet to the list, 'remove' to remove an IP/Subnet from the list\\n\"\n-                            \"3. \\\"bantime\\\"      (numeric, optional) time in seconds how long (or until when if [absolute] is set) the IP is banned (0 or empty means using the default time of 24h which can also be overwritten by the -bantime startup argument)\\n\"\n-                            \"4. \\\"absolute\\\"     (boolean, optional) If set, the bantime must be an absolute timestamp in seconds since epoch (Jan 1 1970 GMT)\\n\"\n                             \"\\nExamples:\\n\"\n                             + HelpExampleCli(\"setban\", \"\\\"192.168.0.6\\\" \\\"add\\\" 86400\")\n                             + HelpExampleCli(\"setban\", \"\\\"192.168.0.0/24\\\" \\\"add\\\"\")\n@@ -644,11 +631,9 @@ static UniValue setnetworkactive(const JSONRPCRequest& request)\n             RPCHelpMan{\"setnetworkactive\",\n                 \"\\nDisable/enable all p2p network activity.\\n\",\n                 {\n-                    {\"state\", RPCArg::Type::BOOL, false},\n+                    {\"state\", RPCArg::Type::BOOL, /* opt */ false, /* default_val */ \"\", \"true to enable networking, false to disable\"},\n                 }}\n-                .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"state\\\"        (boolean, required) true to enable networking, false to disable\\n\"\n+                .ToString()\n         );\n     }\n \n@@ -668,12 +653,9 @@ static UniValue getnodeaddresses(const JSONRPCRequest& request)\n             RPCHelpMan{\"getnodeaddresses\",\n                 \"\\nReturn known addresses which can potentially be used to find new nodes in the network\\n\",\n                 {\n-                    {\"count\", RPCArg::Type::NUM, true},\n+                    {\"count\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"1\", \"How many addresses to return. Limited to the smaller of \" + std::to_string(ADDRMAN_GETADDR_MAX) + \" or \" + std::to_string(ADDRMAN_GETADDR_MAX_PCT) + \"% of all known addresses.\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"count\\\"    (numeric, optional) How many addresses to return. Limited to the smaller of \" + std::to_string(ADDRMAN_GETADDR_MAX) +\n-                \" or \" + std::to_string(ADDRMAN_GETADDR_MAX_PCT) + \"% of all known addresses. (default = 1)\\n\"\n             \"\\nResult:\\n\"\n             \"[\\n\"\n             \"  {\\n\""
      },
      {
        "sha": "370ae8e4d7cf0ab047f5d9a8b7047234659869b7",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 137,
        "deletions": 205,
        "changes": 342,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -71,24 +71,19 @@ static UniValue getrawtransaction(const JSONRPCRequest& request)\n                 \"enabled, it also works for blockchain transactions. If the block which contains the transaction\\n\"\n                 \"is known, its hash can be provided even for nodes without -txindex. Note that if a blockhash is\\n\"\n                 \"provided, only that block will be searched and if the transaction is in the mempool or other\\n\"\n-                \"blocks, or if this node does not have the given block available, the transaction will not be found.\\n\",\n-                {\n-                    {\"txid\", RPCArg::Type::STR_HEX, false},\n-                    {\"verbose\", RPCArg::Type::BOOL, true},\n-                    {\"blockhash\", RPCArg::Type::STR_HEX, true},\n-                }}\n-                .ToString() +\n+                \"blocks, or if this node does not have the given block available, the transaction will not be found.\\n\"\n             \"DEPRECATED: for now, it also works for transactions with unspent outputs.\\n\"\n \n             \"\\nReturn the raw transaction data.\\n\"\n             \"\\nIf verbose is 'true', returns an Object with information about 'txid'.\\n\"\n             \"If verbose is 'false' or omitted, returns a string that is serialized, hex-encoded data for 'txid'.\\n\"\n-\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"txid\\\"      (string, required) The transaction id\\n\"\n-            \"2. verbose     (bool, optional, default=false) If false, return a string, otherwise return a json object\\n\"\n-            \"3. \\\"blockhash\\\" (string, optional) The block in which to look for the transaction\\n\"\n-\n+                ,\n+                {\n+                    {\"txid\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"The transaction id\"},\n+                    {\"verbose\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"If false, return a string, otherwise return a json object\"},\n+                    {\"blockhash\", RPCArg::Type::STR_HEX, /* opt */ true, /* default_val */ \"null\", \"The block in which to look for the transaction\"},\n+                }}\n+                .ToString() +\n             \"\\nResult (if verbose is not set or set to false):\\n\"\n             \"\\\"data\\\"      (string) The serialized, hex-encoded data for 'txid'\\n\"\n \n@@ -218,21 +213,14 @@ static UniValue gettxoutproof(const JSONRPCRequest& request)\n                 \"you need to maintain a transaction index, using the -txindex command line option or\\n\"\n                 \"specify the block in which the transaction is included manually (by blockhash).\\n\",\n                 {\n-                    {\"txids\", RPCArg::Type::ARR,\n+                    {\"txids\", RPCArg::Type::ARR, /* opt */ false, /* default_val */ \"\", \"A json array of txids to filter\",\n                         {\n-                            {\"txid\", RPCArg::Type::STR_HEX, false},\n+                            {\"txid\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"A transaction hash\"},\n+                        },\n                         },\n-                        false},\n-                    {\"blockhash\", RPCArg::Type::STR_HEX, true},\n+                    {\"blockhash\", RPCArg::Type::STR_HEX, /* opt */ true, /* default_val */ \"null\", \"If specified, looks for txid in the block with this hash\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"txids\\\"       (string) A json array of txids to filter\\n\"\n-            \"    [\\n\"\n-            \"      \\\"txid\\\"     (string) A transaction hash\\n\"\n-            \"      ,...\\n\"\n-            \"    ]\\n\"\n-            \"2. \\\"blockhash\\\"   (string, optional) If specified, looks for txid in the block with this hash\\n\"\n             \"\\nResult:\\n\"\n             \"\\\"data\\\"           (string) A string that is a serialized, hex-encoded data for the proof.\\n\"\n         );\n@@ -316,11 +304,9 @@ static UniValue verifytxoutproof(const JSONRPCRequest& request)\n                 \"\\nVerifies that a proof points to a transaction in a block, returning the transaction it commits to\\n\"\n                 \"and throwing an RPC error if the block is not in our best chain\\n\",\n                 {\n-                    {\"proof\", RPCArg::Type::STR, false},\n+                    {\"proof\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"The hex-encoded proof generated by gettxoutproof\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"proof\\\"    (string, required) The hex-encoded proof generated by gettxoutproof\\n\"\n             \"\\nResult:\\n\"\n             \"[\\\"txid\\\"]      (array, strings) The txid(s) which the proof commits to, or empty array if the proof can not be validated.\\n\"\n         );\n@@ -411,7 +397,6 @@ CMutableTransaction ConstructTransaction(const UniValue& inputs_in, const UniVal\n         rawTx.vin.push_back(in);\n     }\n \n-    std::set<CTxDestination> destinations;\n     if (!outputs_is_obj) {\n         // Translate array of key-value pairs into dict\n         UniValue outputs_dict = UniValue(UniValue::VOBJ);\n@@ -427,8 +412,17 @@ CMutableTransaction ConstructTransaction(const UniValue& inputs_in, const UniVal\n         }\n         outputs = std::move(outputs_dict);\n     }\n+\n+    // Duplicate checking\n+    std::set<CTxDestination> destinations;\n+    bool has_data{false};\n+\n     for (const std::string& name_ : outputs.getKeys()) {\n         if (name_ == \"data\") {\n+            if (has_data) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, duplicate key: data\");\n+            }\n+            has_data = true;\n             std::vector<unsigned char> data = ParseHexV(outputs[name_].getValStr(), \"Data\");\n \n             CTxOut out(0, CScript() << OP_RETURN << data);\n@@ -462,38 +456,46 @@ static UniValue createrawtransaction(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 4) {\n         throw std::runtime_error(\n-            // clang-format off\n-            \"createrawtransaction [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n-            \"\\nCreate a transaction spending the given inputs and creating new outputs.\\n\"\n-            \"Outputs can be addresses or data.\\n\"\n-            \"Returns hex-encoded raw transaction.\\n\"\n-            \"Note that the transaction's inputs are not signed, and\\n\"\n-            \"it is not stored in the wallet or transmitted to the network.\\n\"\n-\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n-            \"     [\\n\"\n-            \"       {\\n\"\n-            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n-            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n-            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n-            \"       } \\n\"\n-            \"       ,...\\n\"\n-            \"     ]\\n\"\n-            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n-            \"   [\\n\"\n-            \"    {\\n\"\n-            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n-            \"    },\\n\"\n-            \"    {\\n\"\n-            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex-encoded data\\n\"\n-            \"    }\\n\"\n-            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n-            \"                             accepted as second parameter.\\n\"\n-            \"   ]\\n\"\n-            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n-            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125-replaceable.\\n\"\n-            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n+            RPCHelpMan{\"createrawtransaction\",\n+                \"\\nCreate a transaction spending the given inputs and creating new outputs.\\n\"\n+                \"Outputs can be addresses or data.\\n\"\n+                \"Returns hex-encoded raw transaction.\\n\"\n+                \"Note that the transaction's inputs are not signed, and\\n\"\n+                \"it is not stored in the wallet or transmitted to the network.\\n\",\n+                {\n+                    {\"inputs\", RPCArg::Type::ARR, /* opt */ false, /* default_val */ \"\", \"A json array of json objects\",\n+                        {\n+                            {\"\", RPCArg::Type::OBJ, /* opt */ true, /* default_val */ \"\", \"\",\n+                                {\n+                                    {\"txid\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"The transaction id\"},\n+                                    {\"vout\", RPCArg::Type::NUM, /* opt */ false, /* default_val */ \"\", \"The output number\"},\n+                                    {\"sequence\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"depends on the value of the 'replaceable' and 'locktime' arguments\", \"The sequence number\"},\n+                                },\n+                                },\n+                        },\n+                        },\n+                    {\"outputs\", RPCArg::Type::ARR, /* opt */ false, /* default_val */ \"\", \"a json array with outputs (key-value pairs), where none of the keys are duplicated.\\n\"\n+                            \"That is, each address can only appear once and there can only be one 'data' object.\\n\"\n+                            \"For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+                            \"                             accepted as second parameter.\",\n+                        {\n+                            {\"\", RPCArg::Type::OBJ, /* opt */ true, /* default_val */ \"\", \"\",\n+                                {\n+                                    {\"address\", RPCArg::Type::AMOUNT, /* opt */ false, /* default_val */ \"\", \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT},\n+                                },\n+                                },\n+                            {\"\", RPCArg::Type::OBJ, /* opt */ true, /* default_val */ \"\", \"\",\n+                                {\n+                                    {\"data\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"A key-value pair. The key must be \\\"data\\\", the value is hex-encoded data\"},\n+                                },\n+                                },\n+                        },\n+                        },\n+                    {\"locktime\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"0\", \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                    {\"replaceable\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"Marks this transaction as BIP125-replaceable.\\n\"\n+            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\"},\n+                }}\n+                .ToString() +\n             \"\\nResult:\\n\"\n             \"\\\"transaction\\\"              (string) hex string of the transaction\\n\"\n \n@@ -502,7 +504,6 @@ static UniValue createrawtransaction(const JSONRPCRequest& request)\n             + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n             + HelpExampleRpc(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\", \\\"[{\\\\\\\"address\\\\\\\":0.01}]\\\"\")\n             + HelpExampleRpc(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\", \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n-            // clang-format on\n         );\n     }\n \n@@ -526,15 +527,11 @@ static UniValue decoderawtransaction(const JSONRPCRequest& request)\n             RPCHelpMan{\"decoderawtransaction\",\n                 \"\\nReturn a JSON object representing the serialized, hex-encoded transaction.\\n\",\n                 {\n-                    {\"hexstring\", RPCArg::Type::STR_HEX, false},\n-                    {\"iswitness\", RPCArg::Type::BOOL, true},\n+                    {\"hexstring\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"The transaction hex string\"},\n+                    {\"iswitness\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"depends on heuristic tests\", \"Whether the transaction hex is a serialized witness transaction\\n\"\n+            \"                         If iswitness is not present, heuristic tests will be used in decoding\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"hexstring\\\"      (string, required) The transaction hex string\\n\"\n-            \"2. iswitness          (boolean, optional) Whether the transaction hex is a serialized witness transaction\\n\"\n-            \"                         If iswitness is not present, heuristic tests will be used in decoding\\n\"\n-\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"txid\\\" : \\\"id\\\",        (string) The transaction id\\n\"\n@@ -605,11 +602,9 @@ static UniValue decodescript(const JSONRPCRequest& request)\n             RPCHelpMan{\"decodescript\",\n                 \"\\nDecode a hex-encoded script.\\n\",\n                 {\n-                    {\"hexstring\", RPCArg::Type::STR_HEX, false},\n+                    {\"hexstring\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"the hex-encoded script\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"hexstring\\\"     (string) the hex-encoded script\\n\"\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"asm\\\":\\\"asm\\\",   (string) Script public key\\n\"\n@@ -706,20 +701,13 @@ static UniValue combinerawtransaction(const JSONRPCRequest& request)\n                 \"The combined transaction may be another partially signed transaction or a \\n\"\n                 \"fully signed transaction.\",\n                 {\n-                    {\"txs\", RPCArg::Type::ARR,\n+                    {\"txs\", RPCArg::Type::ARR, /* opt */ false, /* default_val */ \"\", \"A json array of hex strings of partially signed transactions\",\n                         {\n-                            {\"hexstring\", RPCArg::Type::STR_HEX, false},\n+                            {\"hexstring\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"A transaction hash\"},\n+                        },\n                         },\n-                        false},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"txs\\\"         (string) A json array of hex strings of partially signed transactions\\n\"\n-            \"    [\\n\"\n-            \"      \\\"hexstring\\\"     (string) A transaction hash\\n\"\n-            \"      ,...\\n\"\n-            \"    ]\\n\"\n-\n             \"\\nResult:\\n\"\n             \"\\\"hex\\\"            (string) The hex-encoded raw transaction with signature(s)\\n\"\n \n@@ -938,54 +926,35 @@ static UniValue signrawtransactionwithkey(const JSONRPCRequest& request)\n                 \"The third optional argument (may be null) is an array of previous transaction outputs that\\n\"\n                 \"this transaction depends on but may not yet be in the block chain.\\n\",\n                 {\n-                    {\"hexstring\", RPCArg::Type::STR, false},\n-                    {\"privkeys\", RPCArg::Type::ARR,\n+                    {\"hexstring\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The transaction hex string\"},\n+                    {\"privkeys\", RPCArg::Type::ARR, /* opt */ false, /* default_val */ \"\", \"A json array of base58-encoded private keys for signing\",\n                         {\n-                            {\"privatekey\", RPCArg::Type::STR_HEX, false},\n+                            {\"privatekey\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"private key in base58-encoding\"},\n                         },\n-                        false},\n-                    {\"prevtxs\", RPCArg::Type::ARR,\n+                        },\n+                    {\"prevtxs\", RPCArg::Type::ARR, /* opt */ true, /* default_val */ \"null\", \"A json array of previous dependent transaction outputs\",\n                         {\n-                            {\"\", RPCArg::Type::OBJ,\n+                            {\"\", RPCArg::Type::OBJ, /* opt */ true, /* default_val */ \"\", \"\",\n                                 {\n-                                    {\"txid\", RPCArg::Type::STR_HEX, false},\n-                                    {\"vout\", RPCArg::Type::NUM, false},\n-                                    {\"scriptPubKey\", RPCArg::Type::STR_HEX, false},\n-                                    {\"redeemScript\", RPCArg::Type::STR_HEX, false},\n-                                    {\"amount\", RPCArg::Type::AMOUNT, false},\n+                                    {\"txid\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"The transaction id\"},\n+                                    {\"vout\", RPCArg::Type::NUM, /* opt */ false, /* default_val */ \"\", \"The output number\"},\n+                                    {\"scriptPubKey\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"script key\"},\n+                                    {\"redeemScript\", RPCArg::Type::STR_HEX, /* opt */ true, /* default_val */ \"omitted\", \"(required for P2SH or P2WSH) redeem script\"},\n+                                    {\"amount\", RPCArg::Type::AMOUNT, /* opt */ false, /* default_val */ \"\", \"The amount spent\"},\n+                                },\n                                 },\n-                                true},\n                         },\n-                        true},\n-                    {\"sighashtype\", RPCArg::Type::STR, true},\n-                }}\n-                .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"hexstring\\\"                      (string, required) The transaction hex string\\n\"\n-            \"2. \\\"privkeys\\\"                       (string, required) A json array of base58-encoded private keys for signing\\n\"\n-            \"    [                               (json array of strings)\\n\"\n-            \"      \\\"privatekey\\\"                  (string) private key in base58-encoding\\n\"\n-            \"      ,...\\n\"\n-            \"    ]\\n\"\n-            \"3. \\\"prevtxs\\\"                        (string, optional) An json array of previous dependent transaction outputs\\n\"\n-            \"     [                              (json array of json objects, or 'null' if none provided)\\n\"\n-            \"       {\\n\"\n-            \"         \\\"txid\\\":\\\"id\\\",               (string, required) The transaction id\\n\"\n-            \"         \\\"vout\\\":n,                  (numeric, required) The output number\\n\"\n-            \"         \\\"scriptPubKey\\\": \\\"hex\\\",     (string, required) script key\\n\"\n-            \"         \\\"redeemScript\\\": \\\"hex\\\",     (string, required for P2SH or P2WSH) redeem script\\n\"\n-            \"         \\\"amount\\\": value            (numeric, required) The amount spent\\n\"\n-            \"       }\\n\"\n-            \"       ,...\\n\"\n-            \"    ]\\n\"\n-            \"4. \\\"sighashtype\\\"                    (string, optional, default=ALL) The signature hash type. Must be one of:\\n\"\n+                        },\n+                    {\"sighashtype\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"ALL\", \"The signature hash type. Must be one of:\\n\"\n             \"       \\\"ALL\\\"\\n\"\n             \"       \\\"NONE\\\"\\n\"\n             \"       \\\"SINGLE\\\"\\n\"\n             \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n             \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n             \"       \\\"SINGLE|ANYONECANPAY\\\"\\n\"\n-\n+                    },\n+                }}\n+                .ToString() +\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"hex\\\" : \\\"value\\\",                  (string) The hex-encoded raw transaction with signature(s)\\n\"\n@@ -1044,13 +1013,10 @@ static UniValue sendrawtransaction(const JSONRPCRequest& request)\n                 \"\\nSubmits raw transaction (serialized, hex-encoded) to local node and network.\\n\"\n                 \"\\nAlso see createrawtransaction and signrawtransactionwithkey calls.\\n\",\n                 {\n-                    {\"hexstring\", RPCArg::Type::STR_HEX, false},\n-                    {\"allowhighfees\", RPCArg::Type::BOOL, true},\n+                    {\"hexstring\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"The hex string of the raw transaction\"},\n+                    {\"allowhighfees\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"Allow high fees\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"hexstring\\\"    (string, required) The hex string of the raw transaction)\\n\"\n-            \"2. allowhighfees    (boolean, optional, default=false) Allow high fees\\n\"\n             \"\\nResult:\\n\"\n             \"\\\"hex\\\"             (string) The transaction hash in hex\\n\"\n             \"\\nExamples:\\n\"\n@@ -1140,15 +1106,20 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2) {\n         throw std::runtime_error(\n-            // clang-format off\n-            \"testmempoolaccept [\\\"rawtxs\\\"] ( allowhighfees )\\n\"\n-            \"\\nReturns result of mempool acceptance tests indicating if raw transaction (serialized, hex-encoded) would be accepted by mempool.\\n\"\n-            \"\\nThis checks if the transaction violates the consensus or policy rules.\\n\"\n-            \"\\nSee sendrawtransaction call.\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. [\\\"rawtxs\\\"]       (array, required) An array of hex strings of raw transactions.\\n\"\n-            \"                                        Length must be one for now.\\n\"\n-            \"2. allowhighfees    (boolean, optional, default=false) Allow high fees\\n\"\n+            RPCHelpMan{\"testmempoolaccept\",\n+                \"\\nReturns result of mempool acceptance tests indicating if raw transaction (serialized, hex-encoded) would be accepted by mempool.\\n\"\n+                \"\\nThis checks if the transaction violates the consensus or policy rules.\\n\"\n+                \"\\nSee sendrawtransaction call.\\n\",\n+                {\n+                    {\"rawtxs\", RPCArg::Type::ARR, /* opt */ false, /* default_val */ \"\", \"An array of hex strings of raw transactions.\\n\"\n+            \"                                        Length must be one for now.\",\n+                        {\n+                            {\"rawtx\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"\"},\n+                        },\n+                        },\n+                    {\"allowhighfees\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"Allow high fees\"},\n+                }}\n+                .ToString() +\n             \"\\nResult:\\n\"\n             \"[                   (array) The result of the mempool acceptance test for each raw transaction in the input array.\\n\"\n             \"                            Length is exactly one for now.\\n\"\n@@ -1167,7 +1138,6 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n             + HelpExampleCli(\"testmempoolaccept\", \"\\\"signedhex\\\"\") +\n             \"\\nAs a JSON-RPC call\\n\"\n             + HelpExampleRpc(\"testmempoolaccept\", \"[\\\"signedhex\\\"]\")\n-            // clang-format on\n             );\n     }\n \n@@ -1241,12 +1211,9 @@ UniValue decodepsbt(const JSONRPCRequest& request)\n             RPCHelpMan{\"decodepsbt\",\n                 \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\",\n                 {\n-                    {\"psbt\", RPCArg::Type::STR, false},\n+                    {\"psbt\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The PSBT base64 string\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n-\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n@@ -1520,20 +1487,13 @@ UniValue combinepsbt(const JSONRPCRequest& request)\n                 \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n                 \"Implements the Combiner role.\\n\",\n                 {\n-                    {\"txs\", RPCArg::Type::ARR,\n+                    {\"txs\", RPCArg::Type::ARR, /* opt */ false, /* default_val */ \"\", \"A json array of base64 strings of partially signed transactions\",\n                         {\n-                            {\"psbt\", RPCArg::Type::STR_HEX, false},\n+                            {\"psbt\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"A base64 string of a PSBT\"},\n+                        },\n                         },\n-                        false},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n-            \"    [\\n\"\n-            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n-            \"      ,...\\n\"\n-            \"    ]\\n\"\n-\n             \"\\nResult:\\n\"\n             \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n             \"\\nExamples:\\n\"\n@@ -1583,15 +1543,11 @@ UniValue finalizepsbt(const JSONRPCRequest& request)\n                 \"created which has the final_scriptSig and final_scriptWitness fields filled for inputs that are complete.\\n\"\n                 \"Implements the Finalizer and Extractor roles.\\n\",\n                 {\n-                    {\"psbt\", RPCArg::Type::STR, false},\n-                    {\"extract\", RPCArg::Type::BOOL, true},\n+                    {\"psbt\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"A base64 string of a PSBT\"},\n+                    {\"extract\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"true\", \"If true and the transaction is complete,\\n\"\n+            \"                             extract and return the complete transaction in normal network serialization instead of the PSBT.\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n-            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n-            \"                             extract and return the complete transaction in normal network serialization instead of the PSBT.\\n\"\n-\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction if not extracted\\n\"\n@@ -1650,59 +1606,39 @@ UniValue createpsbt(const JSONRPCRequest& request)\n                 \"\\nCreates a transaction in the Partially Signed Transaction format.\\n\"\n                 \"Implements the Creator role.\\n\",\n                 {\n-                    {\"inputs\", RPCArg::Type::ARR,\n+                    {\"inputs\", RPCArg::Type::ARR, /* opt */ false, /* default_val */ \"\", \"A json array of json objects\",\n                         {\n-                            {\"\", RPCArg::Type::OBJ,\n+                            {\"\", RPCArg::Type::OBJ, /* opt */ false, /* default_val */ \"\", \"\",\n                                 {\n-                                    {\"txid\", RPCArg::Type::STR_HEX, false},\n-                                    {\"vout\", RPCArg::Type::NUM, false},\n-                                    {\"sequence\", RPCArg::Type::NUM, true},\n+                                    {\"txid\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"The transaction id\"},\n+                                    {\"vout\", RPCArg::Type::NUM, /* opt */ false, /* default_val */ \"\", \"The output number\"},\n+                                    {\"sequence\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"depends on the value of the 'replaceable' and 'locktime' arguments\", \"The sequence number\"},\n+                                },\n                                 },\n-                                false},\n                         },\n-                        false},\n-                    {\"outputs\", RPCArg::Type::ARR,\n+                        },\n+                    {\"outputs\", RPCArg::Type::ARR, /* opt */ false, /* default_val */ \"\", \"a json array with outputs (key-value pairs), where none of the keys are duplicated.\\n\"\n+                            \"That is, each address can only appear once and there can only be one 'data' object.\\n\"\n+                            \"For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+                            \"                             accepted as second parameter.\",\n                         {\n-                            {\"\", RPCArg::Type::OBJ,\n+                            {\"\", RPCArg::Type::OBJ, /* opt */ true, /* default_val */ \"\", \"\",\n                                 {\n-                                    {\"address\", RPCArg::Type::AMOUNT, false},\n+                                    {\"address\", RPCArg::Type::AMOUNT, /* opt */ false, /* default_val */ \"\", \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT},\n+                                },\n                                 },\n-                                true},\n-                            {\"\", RPCArg::Type::OBJ,\n+                            {\"\", RPCArg::Type::OBJ, /* opt */ true, /* default_val */ \"\", \"\",\n                                 {\n-                                    {\"data\", RPCArg::Type::STR_HEX, false},\n+                                    {\"data\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"A key-value pair. The key must be \\\"data\\\", the value is hex-encoded data\"},\n                                 },\n-                                true},\n+                                },\n+                        },\n                         },\n-                        false},\n-                    {\"locktime\", RPCArg::Type::NUM, true},\n-                    {\"replaceable\", RPCArg::Type::BOOL, true},\n+                    {\"locktime\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"0\", \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                    {\"replaceable\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\"},\n                 }}\n                 .ToString() +\n-                            \"\\nArguments:\\n\"\n-                            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n-                            \"     [\\n\"\n-                            \"       {\\n\"\n-                            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n-                            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n-                            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n-                            \"       } \\n\"\n-                            \"       ,...\\n\"\n-                            \"     ]\\n\"\n-                            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n-                            \"   [\\n\"\n-                            \"    {\\n\"\n-                            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n-                            \"    },\\n\"\n-                            \"    {\\n\"\n-                            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex-encoded data\\n\"\n-                            \"    }\\n\"\n-                            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n-                            \"                             accepted as second parameter.\\n\"\n-                            \"   ]\\n\"\n-                            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n-                            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n-                            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n                             \"\\nResult:\\n\"\n                             \"  \\\"psbt\\\"        (string)  The resulting raw transaction (base64-encoded string)\\n\"\n                             \"\\nExamples:\\n\"\n@@ -1745,19 +1681,15 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n                 \"\\nConverts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction\\n\"\n                 \"createpsbt and walletcreatefundedpsbt should be used for new applications.\\n\",\n                 {\n-                    {\"hexstring\", RPCArg::Type::STR_HEX, false},\n-                    {\"permitsigdata\", RPCArg::Type::BOOL, true},\n-                    {\"iswitness\", RPCArg::Type::BOOL, true},\n-                }}\n-                .ToString() +\n-                            \"\\nArguments:\\n\"\n-                            \"1. \\\"hexstring\\\"              (string, required) The hex string of a raw transaction\\n\"\n-                            \"2. permitsigdata           (boolean, optional, default=false) If true, any signatures in the input will be discarded and conversion.\\n\"\n-                            \"                              will continue. If false, RPC will fail if any signatures are present.\\n\"\n-                            \"3. iswitness               (boolean, optional) Whether the transaction hex is a serialized witness transaction.\\n\"\n+                    {\"hexstring\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"The hex string of a raw transaction\"},\n+                    {\"permitsigdata\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"If true, any signatures in the input will be discarded and conversion.\\n\"\n+                            \"                              will continue. If false, RPC will fail if any signatures are present.\"},\n+                    {\"iswitness\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"depends on heuristic tests\", \"Whether the transaction hex is a serialized witness transaction.\\n\"\n                             \"                              If iswitness is not present, heuristic tests will be used in decoding. If true, only witness deserializaion\\n\"\n                             \"                              will be tried. If false, only non-witness deserialization will be tried. Only has an effect if\\n\"\n-                            \"                              permitsigdata is true.\\n\"\n+                            \"                              permitsigdata is true.\"},\n+                }}\n+                .ToString() +\n                             \"\\nResult:\\n\"\n                             \"  \\\"psbt\\\"        (string)  The resulting raw transaction (base64-encoded string)\\n\"\n                             \"\\nExamples:\\n\""
      },
      {
        "sha": "03e1c8113296946dba2b51524728c34734d9a469",
        "filename": "src/rpc/server.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 15,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/rpc/server.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/rpc/server.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -24,7 +24,7 @@\n #include <unordered_map>\n \n static CCriticalSection cs_rpcWarmup;\n-static bool fRPCRunning = false;\n+static std::atomic<bool> g_rpc_running{false};\n static bool fRPCInWarmup GUARDED_BY(cs_rpcWarmup) = true;\n static std::string rpcWarmupStatus GUARDED_BY(cs_rpcWarmup) = \"RPC server started\";\n /* Timer-creating functions */\n@@ -142,10 +142,6 @@ std::vector<unsigned char> ParseHexO(const UniValue& o, std::string strKey)\n     return ParseHexV(find_value(o, strKey), strKey);\n }\n \n-/**\n- * Note: This interface may still be subject to change.\n- */\n-\n std::string CRPCTable::help(const std::string& strCommand, const JSONRPCRequest& helpreq) const\n {\n     std::string strRet;\n@@ -207,11 +203,9 @@ UniValue help(const JSONRPCRequest& jsonRequest)\n             RPCHelpMan{\"help\",\n                 \"\\nList all commands, or get help for a specified command.\\n\",\n                 {\n-                    {\"command\", RPCArg::Type::STR, true},\n+                    {\"command\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"all commands\", \"The command to get help on\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"command\\\"     (string, optional) The command to get help on\\n\"\n             \"\\nResult:\\n\"\n             \"\\\"text\\\"     (string) The help text\\n\"\n         );\n@@ -227,6 +221,9 @@ UniValue help(const JSONRPCRequest& jsonRequest)\n UniValue stop(const JSONRPCRequest& jsonRequest)\n {\n     // Accept the deprecated and ignored 'detach' boolean argument\n+    // Also accept the hidden 'wait' integer argument (milliseconds)\n+    // For instance, 'stop 1000' makes the call wait 1 second before returning\n+    // to the client (intended for testing)\n     if (jsonRequest.fHelp || jsonRequest.params.size() > 1)\n         throw std::runtime_error(\n             RPCHelpMan{\"stop\",\n@@ -235,6 +232,9 @@ UniValue stop(const JSONRPCRequest& jsonRequest)\n     // Event loop will exit after current HTTP requests have been handled, so\n     // this reply will get back to the client.\n     StartShutdown();\n+    if (jsonRequest.params[0].isNum()) {\n+        MilliSleep(jsonRequest.params[0].get_int());\n+    }\n     return \"Bitcoin server stopping\";\n }\n \n@@ -256,15 +256,12 @@ static UniValue uptime(const JSONRPCRequest& jsonRequest)\n }\n \n // clang-format off\n-/**\n- * Call Table\n- */\n static const CRPCCommand vRPCCommands[] =\n { //  category              name                      actor (function)         argNames\n   //  --------------------- ------------------------  -----------------------  ----------\n     /* Overall control/query calls */\n     { \"control\",            \"help\",                   &help,                   {\"command\"}  },\n-    { \"control\",            \"stop\",                   &stop,                   {}  },\n+    { \"control\",            \"stop\",                   &stop,                   {\"wait\"}  },\n     { \"control\",            \"uptime\",                 &uptime,                 {}  },\n };\n // clang-format on\n@@ -306,15 +303,15 @@ bool CRPCTable::appendCommand(const std::string& name, const CRPCCommand* pcmd)\n void StartRPC()\n {\n     LogPrint(BCLog::RPC, \"Starting RPC\\n\");\n-    fRPCRunning = true;\n+    g_rpc_running = true;\n     g_rpcSignals.Started();\n }\n \n void InterruptRPC()\n {\n     LogPrint(BCLog::RPC, \"Interrupting RPC\\n\");\n     // Interrupt e.g. running longpolls\n-    fRPCRunning = false;\n+    g_rpc_running = false;\n }\n \n void StopRPC()\n@@ -327,7 +324,7 @@ void StopRPC()\n \n bool IsRPCRunning()\n {\n-    return fRPCRunning;\n+    return g_rpc_running;\n }\n \n void SetRPCWarmupStatus(const std::string& newStatus)"
      },
      {
        "sha": "b91baee4ac3d1285c6020fc994430b9223395a5b",
        "filename": "src/rpc/util.cpp",
        "status": "modified",
        "additions": 220,
        "deletions": 15,
        "changes": 235,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/rpc/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/rpc/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -129,35 +129,240 @@ UniValue DescribeAddress(const CTxDestination& dest)\n     return boost::apply_visitor(DescribeAddressVisitor(), dest);\n }\n \n+struct Section {\n+    Section(const std::string& left, const std::string& right)\n+        : m_left{left}, m_right{right} {}\n+    const std::string m_left;\n+    const std::string m_right;\n+};\n+\n+struct Sections {\n+    std::vector<Section> m_sections;\n+    size_t m_max_pad{0};\n+\n+    void PushSection(const Section& s)\n+    {\n+        m_max_pad = std::max(m_max_pad, s.m_left.size());\n+        m_sections.push_back(s);\n+    }\n+\n+    enum class OuterType {\n+        ARR,\n+        OBJ,\n+        NAMED_ARG, // Only set on first recursion\n+    };\n+\n+    void Push(const RPCArg& arg, const size_t current_indent = 5, const OuterType outer_type = OuterType::NAMED_ARG)\n+    {\n+        const auto indent = std::string(current_indent, ' ');\n+        const auto indent_next = std::string(current_indent + 2, ' ');\n+        switch (arg.m_type) {\n+        case RPCArg::Type::STR_HEX:\n+        case RPCArg::Type::STR:\n+        case RPCArg::Type::NUM:\n+        case RPCArg::Type::AMOUNT:\n+        case RPCArg::Type::BOOL: {\n+            if (outer_type == OuterType::NAMED_ARG) return; // Nothing more to do for non-recursive types on first recursion\n+            auto left = indent;\n+            if (arg.m_type_str.size() != 0 && outer_type == OuterType::OBJ) {\n+                left += \"\\\"\" + arg.m_name + \"\\\": \" + arg.m_type_str.at(0);\n+            } else {\n+                left += outer_type == OuterType::OBJ ? arg.ToStringObj(/* oneline */ false) : arg.ToString(/* oneline */ false);\n+            }\n+            left += \",\";\n+            PushSection({left, arg.ToDescriptionString(/* implicitly_required */ outer_type == OuterType::ARR)});\n+            break;\n+        }\n+        case RPCArg::Type::OBJ:\n+        case RPCArg::Type::OBJ_USER_KEYS: {\n+            const auto right = outer_type == OuterType::NAMED_ARG ? \"\" : arg.ToDescriptionString(/* implicitly_required */ outer_type == OuterType::ARR);\n+            PushSection({indent + \"{\", right});\n+            for (const auto& arg_inner : arg.m_inner) {\n+                Push(arg_inner, current_indent + 2, OuterType::OBJ);\n+            }\n+            if (arg.m_type != RPCArg::Type::OBJ) {\n+                PushSection({indent_next + \"...\", \"\"});\n+            }\n+            PushSection({indent + \"}\" + (outer_type != OuterType::NAMED_ARG ? \",\" : \"\"), \"\"});\n+            break;\n+        }\n+        case RPCArg::Type::ARR: {\n+            auto left = indent;\n+            left += outer_type == OuterType::OBJ ? \"\\\"\" + arg.m_name + \"\\\": \" : \"\";\n+            left += \"[\";\n+            const auto right = outer_type == OuterType::NAMED_ARG ? \"\" : arg.ToDescriptionString(/* implicitly_required */ outer_type == OuterType::ARR);\n+            PushSection({left, right});\n+            for (const auto& arg_inner : arg.m_inner) {\n+                Push(arg_inner, current_indent + 2, OuterType::ARR);\n+            }\n+            PushSection({indent_next + \"...\", \"\"});\n+            PushSection({indent + \"]\" + (outer_type != OuterType::NAMED_ARG ? \",\" : \"\"), \"\"});\n+            break;\n+        }\n+\n+            // no default case, so the compiler can warn about missing cases\n+        }\n+    }\n+\n+    std::string ToString() const\n+    {\n+        std::string ret;\n+        const size_t pad = m_max_pad + 4;\n+        for (const auto& s : m_sections) {\n+            if (s.m_right.empty()) {\n+                ret += s.m_left;\n+                ret += \"\\n\";\n+                continue;\n+            }\n+\n+            std::string left = s.m_left;\n+            left.resize(pad, ' ');\n+            ret += left;\n+\n+            // Properly pad after newlines\n+            std::string right;\n+            size_t begin = 0;\n+            size_t new_line_pos = s.m_right.find_first_of('\\n');\n+            while (true) {\n+                right += s.m_right.substr(begin, new_line_pos - begin);\n+                if (new_line_pos == std::string::npos) {\n+                    break; //No new line\n+                }\n+                right += \"\\n\" + std::string(pad, ' ');\n+                begin = s.m_right.find_first_not_of(' ', new_line_pos + 1);\n+                if (begin == std::string::npos) {\n+                    break; // Empty line\n+                }\n+                new_line_pos = s.m_right.find_first_of('\\n', begin + 1);\n+            }\n+            ret += right;\n+            ret += \"\\n\";\n+        }\n+        return ret;\n+    }\n+};\n+\n+RPCHelpMan::RPCHelpMan(const std::string& name, const std::string& description, const std::vector<RPCArg>& args)\n+    : m_name{name}, m_description{description}, m_args{args}\n+{\n+    std::set<std::string> named_args;\n+    for (const auto& arg : m_args) {\n+        // Should have unique named arguments\n+        assert(named_args.insert(arg.m_name).second);\n+    }\n+}\n+\n std::string RPCHelpMan::ToString() const\n {\n     std::string ret;\n \n+    // Oneline summary\n     ret += m_name;\n-    bool is_optional{false};\n+    bool was_optional{false};\n     for (const auto& arg : m_args) {\n         ret += \" \";\n         if (arg.m_optional) {\n-            if (!is_optional) ret += \"( \";\n-            is_optional = true;\n+            if (!was_optional) ret += \"( \";\n+            was_optional = true;\n         } else {\n-            // Currently we still support unnamed arguments, so any argument following an optional argument must also be optional\n-            // If support for positional arguments is deprecated in the future, remove this line\n-            assert(!is_optional);\n+            if (was_optional) ret += \") \";\n+            was_optional = false;\n         }\n-        ret += arg.ToString();\n+        ret += arg.ToString(/* oneline */ true);\n     }\n-    if (is_optional) ret += \" )\";\n+    if (was_optional) ret += \" )\";\n     ret += \"\\n\";\n \n+    // Description\n     ret += m_description;\n \n+    // Arguments\n+    Sections sections;\n+    for (size_t i{0}; i < m_args.size(); ++i) {\n+        const auto& arg = m_args.at(i);\n+\n+        if (i == 0) ret += \"\\nArguments:\\n\";\n+\n+        // Push named argument name and description\n+        sections.m_sections.emplace_back(std::to_string(i + 1) + \". \" + arg.m_name, arg.ToDescriptionString());\n+        sections.m_max_pad = std::max(sections.m_max_pad, sections.m_sections.back().m_left.size());\n+\n+        // Recursively push nested args\n+        sections.Push(arg);\n+    }\n+    ret += sections.ToString();\n+\n     return ret;\n }\n \n-std::string RPCArg::ToStringObj() const\n+std::string RPCArg::ToDescriptionString(const bool implicitly_required) const\n {\n-    std::string res = \"\\\"\" + m_name + \"\\\":\";\n+    std::string ret;\n+    ret += \"(\";\n+    if (m_type_str.size() != 0) {\n+        ret += m_type_str.at(1);\n+    } else {\n+        switch (m_type) {\n+        case Type::STR_HEX:\n+        case Type::STR: {\n+            ret += \"string\";\n+            break;\n+        }\n+        case Type::NUM: {\n+            ret += \"numeric\";\n+            break;\n+        }\n+        case Type::AMOUNT: {\n+            ret += \"numeric or string\";\n+            break;\n+        }\n+        case Type::BOOL: {\n+            ret += \"boolean\";\n+            break;\n+        }\n+        case Type::OBJ:\n+        case Type::OBJ_USER_KEYS: {\n+            ret += \"json object\";\n+            break;\n+        }\n+        case Type::ARR: {\n+            ret += \"json array\";\n+            break;\n+        }\n+\n+            // no default case, so the compiler can warn about missing cases\n+        }\n+    }\n+    if (!implicitly_required) {\n+        ret += \", \";\n+        if (m_optional) {\n+            ret += \"optional\";\n+            if (!m_default_value.empty()) {\n+                ret += \", default=\" + m_default_value;\n+            } else {\n+                // TODO enable this assert, when all optional parameters have their default value documented\n+                //assert(false);\n+            }\n+        } else {\n+            ret += \"required\";\n+            assert(m_default_value.empty()); // Default value is ignored, and must not be present\n+        }\n+    }\n+    ret += \")\";\n+    ret += m_description.empty() ? \"\" : \" \" + m_description;\n+    return ret;\n+}\n+\n+std::string RPCArg::ToStringObj(const bool oneline) const\n+{\n+    std::string res;\n+    res += \"\\\"\";\n+    res += m_name;\n+    if (oneline) {\n+        res += \"\\\":\";\n+    } else {\n+        res += \"\\\": \";\n+    }\n     switch (m_type) {\n     case Type::STR:\n         return res + \"\\\"str\\\"\";\n@@ -172,7 +377,7 @@ std::string RPCArg::ToStringObj() const\n     case Type::ARR:\n         res += \"[\";\n         for (const auto& i : m_inner) {\n-            res += i.ToString() + \",\";\n+            res += i.ToString(oneline) + \",\";\n         }\n         return res + \"...]\";\n     case Type::OBJ:\n@@ -185,9 +390,9 @@ std::string RPCArg::ToStringObj() const\n     assert(false);\n }\n \n-std::string RPCArg::ToString() const\n+std::string RPCArg::ToString(const bool oneline) const\n {\n-    if (!m_oneline_description.empty()) return m_oneline_description;\n+    if (oneline && !m_oneline_description.empty()) return m_oneline_description;\n \n     switch (m_type) {\n     case Type::STR_HEX:\n@@ -203,7 +408,7 @@ std::string RPCArg::ToString() const\n     case Type::OBJ_USER_KEYS: {\n         std::string res;\n         for (size_t i = 0; i < m_inner.size();) {\n-            res += m_inner[i].ToStringObj();\n+            res += m_inner[i].ToStringObj(oneline);\n             if (++i < m_inner.size()) res += \",\";\n         }\n         if (m_type == Type::OBJ) {\n@@ -215,7 +420,7 @@ std::string RPCArg::ToString() const\n     case Type::ARR: {\n         std::string res;\n         for (const auto& i : m_inner) {\n-            res += i.ToString() + \",\";\n+            res += i.ToString(oneline) + \",\";\n         }\n         return \"[\" + res + \"...]\";\n     }"
      },
      {
        "sha": "9e97b3ae0bd60408f6d449fe35a4c4034ae48399",
        "filename": "src/rpc/util.h",
        "status": "modified",
        "additions": 53,
        "deletions": 13,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/rpc/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/rpc/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.h?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -43,33 +43,73 @@ struct RPCArg {\n     const Type m_type;\n     const std::vector<RPCArg> m_inner; //!< Only used for arrays or dicts\n     const bool m_optional;\n+    const std::string m_default_value; //!< Only used for optional args\n+    const std::string m_description;\n     const std::string m_oneline_description; //!< Should be empty unless it is supposed to override the auto-generated summary line\n-\n-    RPCArg(const std::string& name, const Type& type, const bool optional, const std::string& oneline_description = \"\")\n-        : m_name{name}, m_type{type}, m_optional{optional}, m_oneline_description{oneline_description}\n+    const std::vector<std::string> m_type_str; //!< Should be empty unless it is supposed to override the auto-generated type strings. Vector length is either 0 or 2, m_type_str.at(0) will override the type of the value in a key-value pair, m_type_str.at(1) will override the type in the argument description.\n+\n+    RPCArg(\n+        const std::string& name,\n+        const Type& type,\n+        const bool opt,\n+        const std::string& default_val,\n+        const std::string& description,\n+        const std::string& oneline_description = \"\",\n+        const std::vector<std::string>& type_str = {})\n+        : m_name{name},\n+          m_type{type},\n+          m_optional{opt},\n+          m_default_value{default_val},\n+          m_description{description},\n+          m_oneline_description{oneline_description},\n+          m_type_str{type_str}\n     {\n         assert(type != Type::ARR && type != Type::OBJ);\n     }\n \n-    RPCArg(const std::string& name, const Type& type, const std::vector<RPCArg>& inner, const bool optional, const std::string& oneline_description = \"\")\n-        : m_name{name}, m_type{type}, m_inner{inner}, m_optional{optional}, m_oneline_description{oneline_description}\n+    RPCArg(\n+        const std::string& name,\n+        const Type& type,\n+        const bool opt,\n+        const std::string& default_val,\n+        const std::string& description,\n+        const std::vector<RPCArg>& inner,\n+        const std::string& oneline_description = \"\",\n+        const std::vector<std::string>& type_str = {})\n+        : m_name{name},\n+          m_type{type},\n+          m_inner{inner},\n+          m_optional{opt},\n+          m_default_value{default_val},\n+          m_description{description},\n+          m_oneline_description{oneline_description},\n+          m_type_str{type_str}\n     {\n         assert(type == Type::ARR || type == Type::OBJ);\n     }\n \n-    std::string ToString() const;\n-\n-private:\n-    std::string ToStringObj() const;\n+    /**\n+     * Return the type string of the argument.\n+     * Set oneline to allow it to be overridden by a custom oneline type string (m_oneline_description).\n+     */\n+    std::string ToString(bool oneline) const;\n+    /**\n+     * Return the type string of the argument when it is in an object (dict).\n+     * Set oneline to get the oneline representation (less whitespace)\n+     */\n+    std::string ToStringObj(bool oneline) const;\n+    /**\n+     * Return the description string, including the argument type and whether\n+     * the argument is required.\n+     * implicitly_required is set for arguments in an array, which are neither optional nor required.\n+     */\n+    std::string ToDescriptionString(bool implicitly_required = false) const;\n };\n \n class RPCHelpMan\n {\n public:\n-    RPCHelpMan(const std::string& name, const std::string& description, const std::vector<RPCArg>& args)\n-        : m_name{name}, m_description{description}, m_args{args}\n-    {\n-    }\n+    RPCHelpMan(const std::string& name, const std::string& description, const std::vector<RPCArg>& args);\n \n     std::string ToString() const;\n "
      },
      {
        "sha": "a702be5b780e69e82701197963f4e3f6fff0a7aa",
        "filename": "src/script/descriptor.cpp",
        "status": "modified",
        "additions": 244,
        "deletions": 200,
        "changes": 444,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/script/descriptor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/script/descriptor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -40,8 +40,8 @@ struct PubkeyProvider\n {\n     virtual ~PubkeyProvider() = default;\n \n-    /** Derive a public key. */\n-    virtual bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& key, KeyOriginInfo& info) const = 0;\n+    /** Derive a public key. If key==nullptr, only info is desired. */\n+    virtual bool GetPubKey(int pos, const SigningProvider& arg, CPubKey* key, KeyOriginInfo& info) const = 0;\n \n     /** Whether this represent multiple public keys at different positions. */\n     virtual bool IsRange() const = 0;\n@@ -68,7 +68,7 @@ class OriginPubkeyProvider final : public PubkeyProvider\n \n public:\n     OriginPubkeyProvider(KeyOriginInfo info, std::unique_ptr<PubkeyProvider> provider) : m_origin(std::move(info)), m_provider(std::move(provider)) {}\n-    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& key, KeyOriginInfo& info) const override\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey* key, KeyOriginInfo& info) const override\n     {\n         if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n         std::copy(std::begin(m_origin.fingerprint), std::end(m_origin.fingerprint), info.fingerprint);\n@@ -94,9 +94,9 @@ class ConstPubkeyProvider final : public PubkeyProvider\n \n public:\n     ConstPubkeyProvider(const CPubKey& pubkey) : m_pubkey(pubkey) {}\n-    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& key, KeyOriginInfo& info) const override\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey* key, KeyOriginInfo& info) const override\n     {\n-        key = m_pubkey;\n+        if (key) *key = m_pubkey;\n         info.path.clear();\n         CKeyID keyid = m_pubkey.GetID();\n         std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n@@ -152,26 +152,28 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     BIP32PubkeyProvider(const CExtPubKey& extkey, KeyPath path, DeriveType derive) : m_extkey(extkey), m_path(std::move(path)), m_derive(derive) {}\n     bool IsRange() const override { return m_derive != DeriveType::NO; }\n     size_t GetSize() const override { return 33; }\n-    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& key, KeyOriginInfo& info) const override\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey* key, KeyOriginInfo& info) const override\n     {\n-        if (IsHardened()) {\n-            CExtKey extkey;\n-            if (!GetExtKey(arg, extkey)) return false;\n-            for (auto entry : m_path) {\n-                extkey.Derive(extkey, entry);\n+        if (key) {\n+            if (IsHardened()) {\n+                CExtKey extkey;\n+                if (!GetExtKey(arg, extkey)) return false;\n+                for (auto entry : m_path) {\n+                    extkey.Derive(extkey, entry);\n+                }\n+                if (m_derive == DeriveType::UNHARDENED) extkey.Derive(extkey, pos);\n+                if (m_derive == DeriveType::HARDENED) extkey.Derive(extkey, pos | 0x80000000UL);\n+                *key = extkey.Neuter().pubkey;\n+            } else {\n+                // TODO: optimize by caching\n+                CExtPubKey extkey = m_extkey;\n+                for (auto entry : m_path) {\n+                    extkey.Derive(extkey, entry);\n+                }\n+                if (m_derive == DeriveType::UNHARDENED) extkey.Derive(extkey, pos);\n+                assert(m_derive != DeriveType::HARDENED);\n+                *key = extkey.pubkey;\n             }\n-            if (m_derive == DeriveType::UNHARDENED) extkey.Derive(extkey, pos);\n-            if (m_derive == DeriveType::HARDENED) extkey.Derive(extkey, pos | 0x80000000UL);\n-            key = extkey.Neuter().pubkey;\n-        } else {\n-            // TODO: optimize by caching\n-            CExtPubKey extkey = m_extkey;\n-            for (auto entry : m_path) {\n-                extkey.Derive(extkey, entry);\n-            }\n-            if (m_derive == DeriveType::UNHARDENED) extkey.Derive(extkey, pos);\n-            assert(m_derive != DeriveType::HARDENED);\n-            key = extkey.pubkey;\n         }\n         CKeyID keyid = m_extkey.pubkey.GetID();\n         std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n@@ -202,219 +204,261 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n-{\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    bool IsSolvable() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n-\n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n-\n-public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n-\n-    bool IsRange() const override { return false; }\n-    bool IsSolvable() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n+    //! Public key arguments for this descriptor (size 1 for PK, PKH, WPKH; any size of Multisig).\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkey_args;\n+    //! The sub-descriptor argument (nullptr for everything but SH and WSH).\n+    const std::unique_ptr<DescriptorImpl> m_script_arg;\n+    //! The string name of the descriptor function.\n+    const std::string m_name;\n+\n+protected:\n+    //! Return a serialization of anything except pubkey and script arguments, to be prepended to those.\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+\n+    /** A helper function to construct the scripts for this descriptor.\n+     *\n+     *  This function is invoked once for every CScript produced by evaluating\n+     *  m_script_arg, or just once in case m_script_arg is nullptr.\n+\n+     *  @param pubkeys The evaluations of the m_pubkey_args field.\n+     *  @param script The evaluation of m_script_arg (or nullptr when m_script_arg is nullptr).\n+     *  @param out A FlatSigningProvider to put scripts or public keys in that are necessary to the solver.\n+     *             The script and pubkeys argument to this function are automatically added.\n+     *  @return A vector with scriptPubKeys for this descriptor.\n+     */\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, const CScript* script, FlatSigningProvider& out) const = 0;\n \n public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkey_args(std::move(pubkeys)), m_script_arg(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    bool IsSolvable() const override { return true; }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsSolvable() const override\n     {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n+        if (m_script_arg) {\n+            if (!m_script_arg->IsSolvable()) return false;\n+        }\n         return true;\n     }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n \n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n+    bool IsRange() const final\n     {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkey_args) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script_arg) {\n+            if (m_script_arg->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    bool IsSolvable() const override { return true; }\n-\n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0 ? 1 : 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkey_args) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n         }\n-        return std::move(ret) + \")\";\n-    }\n-\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        if (m_script_arg) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_script_arg->ToStringHelper(arg, tmp, priv)) return false;\n+            ret += std::move(tmp);\n         }\n         out = std::move(ret) + \")\";\n         return true;\n     }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    std::string ToString() const final\n+    {\n+        std::string ret;\n+        ToStringHelper(nullptr, ret, false);\n+        return ret;\n+    }\n+\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final { return ToStringHelper(&arg, out, true); }\n+\n+    bool ExpandHelper(int pos, const SigningProvider& arg, Span<const unsigned char>* cache_read, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache_write) const\n     {\n         std::vector<std::pair<CPubKey, KeyOriginInfo>> entries;\n-        entries.reserve(m_providers.size());\n-        // Construct temporary data in `entries`, to avoid producing output in case of failure.\n-        for (const auto& p : m_providers) {\n+        entries.reserve(m_pubkey_args.size());\n+\n+        // Construct temporary data in `entries` and `subscripts`, to avoid producing output in case of failure.\n+        for (const auto& p : m_pubkey_args) {\n             entries.emplace_back();\n-            if (!p->GetPubKey(pos, arg, entries.back().first, entries.back().second)) return false;\n+            if (!p->GetPubKey(pos, arg, cache_read ? nullptr : &entries.back().first, entries.back().second)) return false;\n+            if (cache_read) {\n+                // Cached expanded public key exists, use it.\n+                if (cache_read->size() == 0) return false;\n+                bool compressed = ((*cache_read)[0] == 0x02 || (*cache_read)[0] == 0x03) && cache_read->size() >= 33;\n+                bool uncompressed = ((*cache_read)[0] == 0x04) && cache_read->size() >= 65;\n+                if (!(compressed || uncompressed)) return false;\n+                CPubKey pubkey(cache_read->begin(), cache_read->begin() + (compressed ? 33 : 65));\n+                entries.back().first = pubkey;\n+                *cache_read = cache_read->subspan(compressed ? 33 : 65);\n+            }\n+            if (cache_write) {\n+                cache_write->insert(cache_write->end(), entries.back().first.begin(), entries.back().first.end());\n+            }\n         }\n+        std::vector<CScript> subscripts;\n+        if (m_script_arg) {\n+            FlatSigningProvider subprovider;\n+            if (!m_script_arg->ExpandHelper(pos, arg, cache_read, subscripts, subprovider, cache_write)) return false;\n+            out = Merge(out, subprovider);\n+        }\n+\n         std::vector<CPubKey> pubkeys;\n         pubkeys.reserve(entries.size());\n         for (auto& entry : entries) {\n             pubkeys.push_back(entry.first);\n             out.origins.emplace(entry.first.GetID(), std::move(entry.second));\n             out.pubkeys.emplace(entry.first.GetID(), entry.first);\n         }\n-        output_scripts = std::vector<CScript>{GetScriptForMultisig(m_threshold, pubkeys)};\n+        if (m_script_arg) {\n+            for (const auto& subscript : subscripts) {\n+                out.scripts.emplace(CScriptID(subscript), subscript);\n+                std::vector<CScript> addscripts = MakeScripts(pubkeys, &subscript, out);\n+                for (auto& addscript : addscripts) {\n+                    output_scripts.push_back(std::move(addscript));\n+                }\n+            }\n+        } else {\n+            output_scripts = MakeScripts(pubkeys, nullptr, out);\n+        }\n         return true;\n     }\n+\n+    bool Expand(int pos, const SigningProvider& provider, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache = nullptr) const final\n+    {\n+        return ExpandHelper(pos, provider, nullptr, output_scripts, out, cache);\n+    }\n+\n+    bool ExpandFromCache(int pos, const std::vector<unsigned char>& cache, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const final\n+    {\n+        Span<const unsigned char> span = MakeSpan(cache);\n+        return ExpandHelper(pos, DUMMY_SIGNING_PROVIDER, &span, output_scripts, out, nullptr) && span.size() == 0;\n+    }\n };\n \n-/** A parsed sh(S) or wsh(S) descriptor. */\n-class ConvertorDescriptor : public Descriptor\n+/** Construct a vector with one element, which is moved into it. */\n+template<typename T>\n+std::vector<T> Singleton(T elem)\n {\n-    const std::function<CScript(const CScript&)> m_convert_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<Descriptor> m_descriptor;\n+    std::vector<T> ret;\n+    ret.emplace_back(std::move(elem));\n+    return ret;\n+}\n \n+/** A parsed addr(A) descriptor. */\n+class AddressDescriptor final : public DescriptorImpl\n+{\n+    const CTxDestination m_destination;\n+protected:\n+    std::string ToStringExtra() const override { return EncodeDestination(m_destination); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, const CScript*, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(m_destination)); }\n public:\n-    ConvertorDescriptor(std::unique_ptr<Descriptor> descriptor, const std::function<CScript(const CScript&)>& fn, const std::string& name) : m_convert_fn(fn), m_fn_name(name), m_descriptor(std::move(descriptor)) {}\n+    AddressDescriptor(CTxDestination destination) : DescriptorImpl({}, {}, \"addr\"), m_destination(std::move(destination)) {}\n+    bool IsSolvable() const final { return false; }\n+};\n \n-    bool IsRange() const override { return m_descriptor->IsRange(); }\n-    bool IsSolvable() const override { return m_descriptor->IsSolvable(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_descriptor->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_descriptor->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        std::vector<CScript> sub;\n-        if (!m_descriptor->Expand(pos, arg, sub, out)) return false;\n-        output_scripts.clear();\n-        for (const auto& script : sub) {\n-            CScriptID id(script);\n-            out.scripts.emplace(CScriptID(script), script);\n-            output_scripts.push_back(m_convert_fn(script));\n-        }\n-        return true;\n-    }\n+/** A parsed raw(H) descriptor. */\n+class RawDescriptor final : public DescriptorImpl\n+{\n+    const CScript m_script;\n+protected:\n+    std::string ToStringExtra() const override { return HexStr(m_script.begin(), m_script.end()); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, const CScript*, FlatSigningProvider&) const override { return Singleton(m_script); }\n+public:\n+    RawDescriptor(CScript script) : DescriptorImpl({}, {}, \"raw\"), m_script(std::move(script)) {}\n+    bool IsSolvable() const final { return false; }\n };\n \n-CScript ConvertP2SH(const CScript& script) { return GetScriptForDestination(CScriptID(script)); }\n-CScript ConvertP2WSH(const CScript& script) { return GetScriptForDestination(WitnessV0ScriptHash(script)); }\n+/** A parsed pk(P) descriptor. */\n+class PKDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, const CScript*, FlatSigningProvider&) const override { return Singleton(GetScriptForRawPubKey(keys[0])); }\n+public:\n+    PKDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"pk\") {}\n+};\n \n-/** A parsed combo(P) descriptor. */\n-class ComboDescriptor final : public Descriptor\n+/** A parsed pkh(P) descriptor. */\n+class PKHDescriptor final : public DescriptorImpl\n {\n-    std::unique_ptr<PubkeyProvider> m_provider;\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, const CScript*, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(keys[0].GetID())); }\n+public:\n+    PKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"pkh\") {}\n+};\n \n+/** A parsed wpkh(P) descriptor. */\n+class WPKHDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, const CScript*, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(WitnessV0KeyHash(keys[0].GetID()))); }\n public:\n-    ComboDescriptor(std::unique_ptr<PubkeyProvider> provider) : m_provider(std::move(provider)) {}\n+    WPKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"wpkh\") {}\n+};\n \n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    bool IsSolvable() const override { return true; }\n-    std::string ToString() const override { return \"combo(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = \"combo(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+/** A parsed combo(P) descriptor. */\n+class ComboDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, const CScript*, FlatSigningProvider& out) const override\n     {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        CKeyID keyid = key.GetID();\n-        {\n-            CScript p2pk = GetScriptForRawPubKey(key);\n-            CScript p2pkh = GetScriptForDestination(keyid);\n-            output_scripts = std::vector<CScript>{std::move(p2pk), std::move(p2pkh)};\n-            out.pubkeys.emplace(keyid, key);\n-            out.origins.emplace(keyid, std::move(info));\n-        }\n-        if (key.IsCompressed()) {\n-            CScript p2wpkh = GetScriptForDestination(WitnessV0KeyHash(keyid));\n-            CScriptID p2wpkh_id(p2wpkh);\n-            CScript p2sh_p2wpkh = GetScriptForDestination(p2wpkh_id);\n-            out.scripts.emplace(p2wpkh_id, p2wpkh);\n-            output_scripts.push_back(std::move(p2wpkh));\n-            output_scripts.push_back(std::move(p2sh_p2wpkh));\n+        std::vector<CScript> ret;\n+        CKeyID id = keys[0].GetID();\n+        ret.emplace_back(GetScriptForRawPubKey(keys[0])); // P2PK\n+        ret.emplace_back(GetScriptForDestination(id)); // P2PKH\n+        if (keys[0].IsCompressed()) {\n+            CScript p2wpkh = GetScriptForDestination(WitnessV0KeyHash(id));\n+            out.scripts.emplace(CScriptID(p2wpkh), p2wpkh);\n+            ret.emplace_back(p2wpkh);\n+            ret.emplace_back(GetScriptForDestination(CScriptID(p2wpkh))); // P2SH-P2WPKH\n         }\n-        return true;\n+        return ret;\n     }\n+public:\n+    ComboDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"combo\") {}\n+};\n+\n+/** A parsed multi(...) descriptor. */\n+class MultisigDescriptor final : public DescriptorImpl\n+{\n+    const int m_threshold;\n+protected:\n+    std::string ToStringExtra() const override { return strprintf(\"%i\", m_threshold); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, const CScript*, FlatSigningProvider&) const override { return Singleton(GetScriptForMultisig(m_threshold, keys)); }\n+public:\n+    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : DescriptorImpl(std::move(providers), {}, \"multi\"), m_threshold(threshold) {}\n+};\n+\n+/** A parsed sh(...) descriptor. */\n+class SHDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, const CScript* script, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(CScriptID(*script))); }\n+public:\n+    SHDescriptor(std::unique_ptr<DescriptorImpl> desc) : DescriptorImpl({}, std::move(desc), \"sh\") {}\n+};\n+\n+/** A parsed wsh(...) descriptor. */\n+class WSHDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, const CScript* script, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(WitnessV0ScriptHash(*script))); }\n+public:\n+    WSHDescriptor(std::unique_ptr<DescriptorImpl> desc) : DescriptorImpl({}, std::move(desc), \"wsh\") {}\n };\n \n ////////////////////////////////////////////////////////////////////////////\n@@ -562,18 +606,18 @@ std::unique_ptr<PubkeyProvider> ParsePubkey(const Span<const char>& sp, bool per\n }\n \n /** Parse a script in a particular context. */\n-std::unique_ptr<Descriptor> ParseScript(Span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out)\n+std::unique_ptr<DescriptorImpl> ParseScript(Span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out)\n {\n     auto expr = Expr(sp);\n     if (Func(\"pk\", expr)) {\n         auto pubkey = ParsePubkey(expr, ctx != ParseScriptContext::P2WSH, out);\n         if (!pubkey) return nullptr;\n-        return MakeUnique<SingleKeyDescriptor>(std::move(pubkey), P2PKGetScript, \"pk\");\n+        return MakeUnique<PKDescriptor>(std::move(pubkey));\n     }\n     if (Func(\"pkh\", expr)) {\n         auto pubkey = ParsePubkey(expr, ctx != ParseScriptContext::P2WSH, out);\n         if (!pubkey) return nullptr;\n-        return MakeUnique<SingleKeyDescriptor>(std::move(pubkey), P2PKHGetScript, \"pkh\");\n+        return MakeUnique<PKHDescriptor>(std::move(pubkey));\n     }\n     if (ctx == ParseScriptContext::TOP && Func(\"combo\", expr)) {\n         auto pubkey = ParsePubkey(expr, true, out);\n@@ -606,17 +650,17 @@ std::unique_ptr<Descriptor> ParseScript(Span<const char>& sp, ParseScriptContext\n     if (ctx != ParseScriptContext::P2WSH && Func(\"wpkh\", expr)) {\n         auto pubkey = ParsePubkey(expr, false, out);\n         if (!pubkey) return nullptr;\n-        return MakeUnique<SingleKeyDescriptor>(std::move(pubkey), P2WPKHGetScript, \"wpkh\");\n+        return MakeUnique<WPKHDescriptor>(std::move(pubkey));\n     }\n     if (ctx == ParseScriptContext::TOP && Func(\"sh\", expr)) {\n         auto desc = ParseScript(expr, ParseScriptContext::P2SH, out);\n         if (!desc || expr.size()) return nullptr;\n-        return MakeUnique<ConvertorDescriptor>(std::move(desc), ConvertP2SH, \"sh\");\n+        return MakeUnique<SHDescriptor>(std::move(desc));\n     }\n     if (ctx != ParseScriptContext::P2WSH && Func(\"wsh\", expr)) {\n         auto desc = ParseScript(expr, ParseScriptContext::P2WSH, out);\n         if (!desc || expr.size()) return nullptr;\n-        return MakeUnique<ConvertorDescriptor>(std::move(desc), ConvertP2WSH, \"wsh\");\n+        return MakeUnique<WSHDescriptor>(std::move(desc));\n     }\n     if (ctx == ParseScriptContext::TOP && Func(\"addr\", expr)) {\n         CTxDestination dest = DecodeDestination(std::string(expr.begin(), expr.end()));\n@@ -642,31 +686,31 @@ std::unique_ptr<PubkeyProvider> InferPubkey(const CPubKey& pubkey, ParseScriptCo\n     return key_provider;\n }\n \n-std::unique_ptr<Descriptor> InferScript(const CScript& script, ParseScriptContext ctx, const SigningProvider& provider)\n+std::unique_ptr<DescriptorImpl> InferScript(const CScript& script, ParseScriptContext ctx, const SigningProvider& provider)\n {\n     std::vector<std::vector<unsigned char>> data;\n     txnouttype txntype = Solver(script, data);\n \n     if (txntype == TX_PUBKEY) {\n         CPubKey pubkey(data[0].begin(), data[0].end());\n         if (pubkey.IsValid()) {\n-            return MakeUnique<SingleKeyDescriptor>(InferPubkey(pubkey, ctx, provider), P2PKGetScript, \"pk\");\n+            return MakeUnique<PKDescriptor>(InferPubkey(pubkey, ctx, provider));\n         }\n     }\n     if (txntype == TX_PUBKEYHASH) {\n         uint160 hash(data[0]);\n         CKeyID keyid(hash);\n         CPubKey pubkey;\n         if (provider.GetPubKey(keyid, pubkey)) {\n-            return MakeUnique<SingleKeyDescriptor>(InferPubkey(pubkey, ctx, provider), P2PKHGetScript, \"pkh\");\n+            return MakeUnique<PKHDescriptor>(InferPubkey(pubkey, ctx, provider));\n         }\n     }\n     if (txntype == TX_WITNESS_V0_KEYHASH && ctx != ParseScriptContext::P2WSH) {\n         uint160 hash(data[0]);\n         CKeyID keyid(hash);\n         CPubKey pubkey;\n         if (provider.GetPubKey(keyid, pubkey)) {\n-            return MakeUnique<SingleKeyDescriptor>(InferPubkey(pubkey, ctx, provider), P2WPKHGetScript, \"wpkh\");\n+            return MakeUnique<WPKHDescriptor>(InferPubkey(pubkey, ctx, provider));\n         }\n     }\n     if (txntype == TX_MULTISIG) {\n@@ -683,7 +727,7 @@ std::unique_ptr<Descriptor> InferScript(const CScript& script, ParseScriptContex\n         CScript subscript;\n         if (provider.GetCScript(scriptid, subscript)) {\n             auto sub = InferScript(subscript, ParseScriptContext::P2SH, provider);\n-            if (sub) return MakeUnique<ConvertorDescriptor>(std::move(sub), ConvertP2SH, \"sh\");\n+            if (sub) return MakeUnique<SHDescriptor>(std::move(sub));\n         }\n     }\n     if (txntype == TX_WITNESS_V0_SCRIPTHASH && ctx != ParseScriptContext::P2WSH) {\n@@ -692,7 +736,7 @@ std::unique_ptr<Descriptor> InferScript(const CScript& script, ParseScriptContex\n         CScript subscript;\n         if (provider.GetCScript(scriptid, subscript)) {\n             auto sub = InferScript(subscript, ParseScriptContext::P2WSH, provider);\n-            if (sub) return MakeUnique<ConvertorDescriptor>(std::move(sub), ConvertP2WSH, \"wsh\");\n+            if (sub) return MakeUnique<WSHDescriptor>(std::move(sub));\n         }\n     }\n \n@@ -712,7 +756,7 @@ std::unique_ptr<Descriptor> Parse(const std::string& descriptor, FlatSigningProv\n {\n     Span<const char> sp(descriptor.data(), descriptor.size());\n     auto ret = ParseScript(sp, ParseScriptContext::TOP, out);\n-    if (sp.size() == 0 && ret) return ret;\n+    if (sp.size() == 0 && ret) return std::unique_ptr<Descriptor>(std::move(ret));\n     return nullptr;\n }\n "
      },
      {
        "sha": "44f0efca03e9091b8a5ec1046901a90633977ee2",
        "filename": "src/script/descriptor.h",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/script/descriptor.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/script/descriptor.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.h?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -48,8 +48,18 @@ struct Descriptor {\n      * provider: the provider to query for private keys in case of hardened derivation.\n      * output_script: the expanded scriptPubKeys will be put here.\n      * out: scripts and public keys necessary for solving the expanded scriptPubKeys will be put here (may be equal to provider).\n+     * cache: vector which will be overwritten with cache data necessary to-evaluate the descriptor at this point without access to private keys.\n      */\n-    virtual bool Expand(int pos, const SigningProvider& provider, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const = 0;\n+    virtual bool Expand(int pos, const SigningProvider& provider, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache = nullptr) const = 0;\n+\n+    /** Expand a descriptor at a specified position using cached expansion data.\n+     *\n+     * pos: the position at which to expand the descriptor. If IsRange() is false, this is ignored.\n+     * cache: vector from which cached expansion data will be read.\n+     * output_script: the expanded scriptPubKeys will be put here.\n+     * out: scripts and public keys necessary for solving the expanded scriptPubKeys will be put here (may be equal to provider).\n+     */\n+    virtual bool ExpandFromCache(int pos, const std::vector<unsigned char>& cache, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const = 0;\n };\n \n /** Parse a descriptor string. Included private keys are put in out. Returns nullptr if parsing fails. */"
      },
      {
        "sha": "635e4fa3d27df0fe476a1eff0b6fedbfadb67a19",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -705,5 +705,7 @@ FlatSigningProvider Merge(const FlatSigningProvider& a, const FlatSigningProvide\n     ret.pubkeys.insert(b.pubkeys.begin(), b.pubkeys.end());\n     ret.keys = a.keys;\n     ret.keys.insert(b.keys.begin(), b.keys.end());\n+    ret.origins = a.origins;\n+    ret.origins.insert(b.origins.begin(), b.origins.end());\n     return ret;\n }"
      },
      {
        "sha": "d5565fe61ff248c932de1eb56936da119db7ee10",
        "filename": "src/streams.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/streams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/streams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/streams.h?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -761,7 +761,7 @@ class CBufferedFile\n \n public:\n     CBufferedFile(FILE *fileIn, uint64_t nBufSize, uint64_t nRewindIn, int nTypeIn, int nVersionIn) :\n-        nType(nTypeIn), nVersion(nVersionIn), nSrcPos(0), nReadPos(0), nReadLimit((uint64_t)(-1)), nRewind(nRewindIn), vchBuf(nBufSize, 0)\n+        nType(nTypeIn), nVersion(nVersionIn), nSrcPos(0), nReadPos(0), nReadLimit(std::numeric_limits<uint64_t>::max()), nRewind(nRewindIn), vchBuf(nBufSize, 0)\n     {\n         src = fileIn;\n     }\n@@ -846,7 +846,7 @@ class CBufferedFile\n \n     // prevent reading beyond a certain position\n     // no argument removes the limit\n-    bool SetLimit(uint64_t nPos = (uint64_t)(-1)) {\n+    bool SetLimit(uint64_t nPos = std::numeric_limits<uint64_t>::max()) {\n         if (nPos < nReadPos)\n             return false;\n         nReadLimit = nPos;"
      },
      {
        "sha": "234da5ae4d12ba18caf6ca34d63f9f36fb3d684a",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 39,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -32,12 +32,6 @@ class CAddrManTest : public CAddrMan\n         insecure_rand = FastRandomContext(true);\n     }\n \n-    int RandomInt(int nMax) override\n-    {\n-        state = (CHashWriter(SER_GETHASH, 0) << state).GetHash().GetCheapHash();\n-        return (unsigned int)(state % nMax);\n-    }\n-\n     CAddrInfo* Find(const CNetAddr& addr, int* pnId = nullptr)\n     {\n         LOCK(cs);\n@@ -154,11 +148,11 @@ BOOST_AUTO_TEST_CASE(addrman_ports)\n \n     // Test 7; Addr with same IP but diff port does not replace existing addr.\n     CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n-    addrman.Add(CAddress(addr1, NODE_NONE), source);\n+    BOOST_CHECK(addrman.Add(CAddress(addr1, NODE_NONE), source));\n     BOOST_CHECK_EQUAL(addrman.size(), 1U);\n \n     CService addr1_port = ResolveService(\"250.1.1.1\", 8334);\n-    addrman.Add(CAddress(addr1_port, NODE_NONE), source);\n+    BOOST_CHECK(!addrman.Add(CAddress(addr1_port, NODE_NONE), source));\n     BOOST_CHECK_EQUAL(addrman.size(), 1U);\n     CAddrInfo addr_ret2 = addrman.Select();\n     BOOST_CHECK_EQUAL(addr_ret2.ToString(), \"250.1.1.1:8333\");\n@@ -181,7 +175,7 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n \n     // Test: Select from new with 1 addr in new.\n     CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n-    addrman.Add(CAddress(addr1, NODE_NONE), source);\n+    BOOST_CHECK(addrman.Add(CAddress(addr1, NODE_NONE), source));\n     BOOST_CHECK_EQUAL(addrman.size(), 1U);\n \n     bool newOnly = true;\n@@ -205,20 +199,20 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     CService addr3 = ResolveService(\"250.3.2.2\", 9999);\n     CService addr4 = ResolveService(\"250.3.3.3\", 9999);\n \n-    addrman.Add(CAddress(addr2, NODE_NONE), ResolveService(\"250.3.1.1\", 8333));\n-    addrman.Add(CAddress(addr3, NODE_NONE), ResolveService(\"250.3.1.1\", 8333));\n-    addrman.Add(CAddress(addr4, NODE_NONE), ResolveService(\"250.4.1.1\", 8333));\n+    BOOST_CHECK(addrman.Add(CAddress(addr2, NODE_NONE), ResolveService(\"250.3.1.1\", 8333)));\n+    BOOST_CHECK(addrman.Add(CAddress(addr3, NODE_NONE), ResolveService(\"250.3.1.1\", 8333)));\n+    BOOST_CHECK(addrman.Add(CAddress(addr4, NODE_NONE), ResolveService(\"250.4.1.1\", 8333)));\n \n     // Add three addresses to tried table.\n     CService addr5 = ResolveService(\"250.4.4.4\", 8333);\n     CService addr6 = ResolveService(\"250.4.5.5\", 7777);\n     CService addr7 = ResolveService(\"250.4.6.6\", 8333);\n \n-    addrman.Add(CAddress(addr5, NODE_NONE), ResolveService(\"250.3.1.1\", 8333));\n+    BOOST_CHECK(addrman.Add(CAddress(addr5, NODE_NONE), ResolveService(\"250.3.1.1\", 8333)));\n     addrman.Good(CAddress(addr5, NODE_NONE));\n-    addrman.Add(CAddress(addr6, NODE_NONE), ResolveService(\"250.3.1.1\", 8333));\n+    BOOST_CHECK(addrman.Add(CAddress(addr6, NODE_NONE), ResolveService(\"250.3.1.1\", 8333)));\n     addrman.Good(CAddress(addr6, NODE_NONE));\n-    addrman.Add(CAddress(addr7, NODE_NONE), ResolveService(\"250.1.1.3\", 8333));\n+    BOOST_CHECK(addrman.Add(CAddress(addr7, NODE_NONE), ResolveService(\"250.1.1.3\", 8333)));\n     addrman.Good(CAddress(addr7, NODE_NONE));\n \n     // Test: 6 addrs + 1 addr from last test = 7.\n@@ -242,19 +236,19 @@ BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n \n     for (unsigned int i = 1; i < 18; i++) {\n         CService addr = ResolveService(\"250.1.1.\" + std::to_string(i));\n-        addrman.Add(CAddress(addr, NODE_NONE), source);\n+        BOOST_CHECK(addrman.Add(CAddress(addr, NODE_NONE), source));\n \n         //Test: No collision in new table yet.\n         BOOST_CHECK_EQUAL(addrman.size(), i);\n     }\n \n     //Test: new table collision!\n     CService addr1 = ResolveService(\"250.1.1.18\");\n-    addrman.Add(CAddress(addr1, NODE_NONE), source);\n+    BOOST_CHECK(addrman.Add(CAddress(addr1, NODE_NONE), source));\n     BOOST_CHECK_EQUAL(addrman.size(), 17U);\n \n     CService addr2 = ResolveService(\"250.1.1.19\");\n-    addrman.Add(CAddress(addr2, NODE_NONE), source);\n+    BOOST_CHECK(addrman.Add(CAddress(addr2, NODE_NONE), source));\n     BOOST_CHECK_EQUAL(addrman.size(), 18U);\n }\n \n@@ -268,7 +262,7 @@ BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n \n     for (unsigned int i = 1; i < 80; i++) {\n         CService addr = ResolveService(\"250.1.1.\" + std::to_string(i));\n-        addrman.Add(CAddress(addr, NODE_NONE), source);\n+        BOOST_CHECK(addrman.Add(CAddress(addr, NODE_NONE), source));\n         addrman.Good(CAddress(addr, NODE_NONE));\n \n         //Test: No collision in tried table yet.\n@@ -277,11 +271,11 @@ BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n \n     //Test: tried table collision!\n     CService addr1 = ResolveService(\"250.1.1.80\");\n-    addrman.Add(CAddress(addr1, NODE_NONE), source);\n+    BOOST_CHECK(addrman.Add(CAddress(addr1, NODE_NONE), source));\n     BOOST_CHECK_EQUAL(addrman.size(), 79U);\n \n     CService addr2 = ResolveService(\"250.1.1.81\");\n-    addrman.Add(CAddress(addr2, NODE_NONE), source);\n+    BOOST_CHECK(addrman.Add(CAddress(addr2, NODE_NONE), source));\n     BOOST_CHECK_EQUAL(addrman.size(), 80U);\n }\n \n@@ -298,9 +292,9 @@ BOOST_AUTO_TEST_CASE(addrman_find)\n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n     CNetAddr source2 = ResolveIP(\"250.1.2.2\");\n \n-    addrman.Add(addr1, source1);\n-    addrman.Add(addr2, source2);\n-    addrman.Add(addr3, source1);\n+    BOOST_CHECK(addrman.Add(addr1, source1));\n+    BOOST_CHECK(!addrman.Add(addr2, source2));\n+    BOOST_CHECK(addrman.Add(addr3, source1));\n \n     // Test: ensure Find returns an IP matching what we searched on.\n     CAddrInfo* info1 = addrman.Find(addr1);\n@@ -382,11 +376,11 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n     CNetAddr source2 = ResolveIP(\"250.2.3.3\");\n \n     // Test: Ensure GetAddr works with new addresses.\n-    addrman.Add(addr1, source1);\n-    addrman.Add(addr2, source2);\n-    addrman.Add(addr3, source1);\n-    addrman.Add(addr4, source2);\n-    addrman.Add(addr5, source1);\n+    BOOST_CHECK(addrman.Add(addr1, source1));\n+    BOOST_CHECK(addrman.Add(addr2, source2));\n+    BOOST_CHECK(addrman.Add(addr3, source1));\n+    BOOST_CHECK(addrman.Add(addr4, source2));\n+    BOOST_CHECK(addrman.Add(addr5, source1));\n \n     // GetAddr returns 23% of addresses, 23% of 5 is 1 rounded down.\n     BOOST_CHECK_EQUAL(addrman.GetAddr().size(), 1U);\n@@ -555,7 +549,7 @@ BOOST_AUTO_TEST_CASE(addrman_selecttriedcollision)\n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n     for (unsigned int i = 1; i < 23; i++) {\n         CService addr = ResolveService(\"250.1.1.\"+std::to_string(i));\n-        addrman.Add(CAddress(addr, NODE_NONE), source);\n+        BOOST_CHECK(addrman.Add(CAddress(addr, NODE_NONE), source));\n         addrman.Good(addr);\n \n         // No collisions yet.\n@@ -585,7 +579,7 @@ BOOST_AUTO_TEST_CASE(addrman_noevict)\n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n     for (unsigned int i = 1; i < 23; i++) {\n         CService addr = ResolveService(\"250.1.1.\"+std::to_string(i));\n-        addrman.Add(CAddress(addr, NODE_NONE), source);\n+        BOOST_CHECK(addrman.Add(CAddress(addr, NODE_NONE), source));\n         addrman.Good(addr);\n \n         // No collision yet.\n@@ -595,7 +589,7 @@ BOOST_AUTO_TEST_CASE(addrman_noevict)\n \n     // Collision between 23 and 19.\n     CService addr23 = ResolveService(\"250.1.1.23\");\n-    addrman.Add(CAddress(addr23, NODE_NONE), source);\n+    BOOST_CHECK(addrman.Add(CAddress(addr23, NODE_NONE), source));\n     addrman.Good(addr23);\n \n     BOOST_CHECK(addrman.size() == 23);\n@@ -608,7 +602,7 @@ BOOST_AUTO_TEST_CASE(addrman_noevict)\n     // Lets create two collisions.\n     for (unsigned int i = 24; i < 33; i++) {\n         CService addr = ResolveService(\"250.1.1.\"+std::to_string(i));\n-        addrman.Add(CAddress(addr, NODE_NONE), source);\n+        BOOST_CHECK(addrman.Add(CAddress(addr, NODE_NONE), source));\n         addrman.Good(addr);\n \n         BOOST_CHECK(addrman.size() == i);\n@@ -617,14 +611,14 @@ BOOST_AUTO_TEST_CASE(addrman_noevict)\n \n     // Cause a collision.\n     CService addr33 = ResolveService(\"250.1.1.33\");\n-    addrman.Add(CAddress(addr33, NODE_NONE), source);\n+    BOOST_CHECK(addrman.Add(CAddress(addr33, NODE_NONE), source));\n     addrman.Good(addr33);\n     BOOST_CHECK(addrman.size() == 33);\n \n     BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"250.1.1.27:0\");\n \n     // Cause a second collision.\n-    addrman.Add(CAddress(addr23, NODE_NONE), source);\n+    BOOST_CHECK(!addrman.Add(CAddress(addr23, NODE_NONE), source));\n     addrman.Good(addr23);\n     BOOST_CHECK(addrman.size() == 33);\n \n@@ -649,7 +643,7 @@ BOOST_AUTO_TEST_CASE(addrman_evictionworks)\n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n     for (unsigned int i = 1; i < 23; i++) {\n         CService addr = ResolveService(\"250.1.1.\"+std::to_string(i));\n-        addrman.Add(CAddress(addr, NODE_NONE), source);\n+        BOOST_CHECK(addrman.Add(CAddress(addr, NODE_NONE), source));\n         addrman.Good(addr);\n \n         // No collision yet.\n@@ -659,7 +653,7 @@ BOOST_AUTO_TEST_CASE(addrman_evictionworks)\n \n     // Collision between 23 and 19.\n     CService addr = ResolveService(\"250.1.1.23\");\n-    addrman.Add(CAddress(addr, NODE_NONE), source);\n+    BOOST_CHECK(addrman.Add(CAddress(addr, NODE_NONE), source));\n     addrman.Good(addr);\n \n     BOOST_CHECK(addrman.size() == 23);\n@@ -674,14 +668,14 @@ BOOST_AUTO_TEST_CASE(addrman_evictionworks)\n     BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n \n     // If 23 was swapped for 19, then this should cause no collisions.\n-    addrman.Add(CAddress(addr, NODE_NONE), source);\n+    BOOST_CHECK(!addrman.Add(CAddress(addr, NODE_NONE), source));\n     addrman.Good(addr);\n \n     BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n \n     // If we insert 19 is should collide with 23.\n     CService addr19 = ResolveService(\"250.1.1.19\");\n-    addrman.Add(CAddress(addr19, NODE_NONE), source);\n+    BOOST_CHECK(!addrman.Add(CAddress(addr19, NODE_NONE), source));\n     addrman.Good(addr19);\n \n     BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"250.1.1.23:0\");"
      },
      {
        "sha": "3469c6dfba98d0e164152459cb15df8db0b8a02f",
        "filename": "src/test/checkqueue_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/checkqueue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/checkqueue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkqueue_tests.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -355,7 +355,8 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_FrozenCleanup)\n         // would get called twice).\n         vChecks[0].should_freeze = true;\n         control.Add(vChecks);\n-        control.Wait(); // Hangs here\n+        bool waitResult = control.Wait(); // Hangs here\n+        assert(waitResult);\n     });\n     {\n         std::unique_lock<std::mutex> l(FrozenCleanupCheck::m);"
      },
      {
        "sha": "aa2e88477d810a58a5e777289bffaa20ef587ae8",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -176,7 +176,7 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n             } else {\n                 removed_an_entry = true;\n                 coin.Clear();\n-                stack.back()->SpendCoin(COutPoint(txid, 0));\n+                BOOST_CHECK(stack.back()->SpendCoin(COutPoint(txid, 0)));\n             }\n         }\n \n@@ -211,14 +211,14 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n             // Every 100 iterations, flush an intermediate cache\n             if (stack.size() > 1 && InsecureRandBool() == 0) {\n                 unsigned int flushIndex = InsecureRandRange(stack.size() - 1);\n-                stack[flushIndex]->Flush();\n+                BOOST_CHECK(stack[flushIndex]->Flush());\n             }\n         }\n         if (InsecureRandRange(100) == 0) {\n             // Every 100 iterations, change the cache stack.\n             if (stack.size() > 0 && InsecureRandBool() == 0) {\n                 //Remove the top cache\n-                stack.back()->Flush();\n+                BOOST_CHECK(stack.back()->Flush());\n                 delete stack.back();\n                 stack.pop_back();\n             }\n@@ -377,7 +377,7 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n \n             // Call UpdateCoins on the top cache\n             CTxUndo undo;\n-            UpdateCoins(tx, *(stack.back()), undo, height);\n+            UpdateCoins(CTransaction(tx), *(stack.back()), undo, height);\n \n             // Update the utxo set for future spends\n             utxoset.insert(outpoint);\n@@ -403,7 +403,7 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n             // Disconnect the tx from the current UTXO\n             // See code in DisconnectBlock\n             // remove outputs\n-            stack.back()->SpendCoin(utxod->first);\n+            BOOST_CHECK(stack.back()->SpendCoin(utxod->first));\n             // restore inputs\n             if (!tx.IsCoinBase()) {\n                 const COutPoint &out = tx.vin[0].prevout;\n@@ -444,13 +444,13 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n             // Every 100 iterations, flush an intermediate cache\n             if (stack.size() > 1 && InsecureRandBool() == 0) {\n                 unsigned int flushIndex = InsecureRandRange(stack.size() - 1);\n-                stack[flushIndex]->Flush();\n+                BOOST_CHECK(stack[flushIndex]->Flush());\n             }\n         }\n         if (InsecureRandRange(100) == 0) {\n             // Every 100 iterations, change the cache stack.\n             if (stack.size() > 0 && InsecureRandBool() == 0) {\n-                stack.back()->Flush();\n+                BOOST_CHECK(stack.back()->Flush());\n                 delete stack.back();\n                 stack.pop_back();\n             }\n@@ -589,7 +589,7 @@ void WriteCoinsViewEntry(CCoinsView& view, CAmount value, char flags)\n {\n     CCoinsMap map;\n     InsertCoinsMapEntry(map, value, flags);\n-    view.BatchWrite(map, {});\n+    BOOST_CHECK(view.BatchWrite(map, {}));\n }\n \n class SingleEntryCacheTest"
      },
      {
        "sha": "d8286520ec75d259d6078eb6a1d801d09735bb19",
        "filename": "src/test/cuckoocache_tests.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 31,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/cuckoocache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/cuckoocache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/cuckoocache_tests.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -21,40 +21,23 @@\n  *  using BOOST_CHECK_CLOSE to fail.\n  *\n  */\n-FastRandomContext local_rand_ctx(true);\n-\n BOOST_AUTO_TEST_SUITE(cuckoocache_tests);\n \n-\n-/** insecure_GetRandHash fills in a uint256 from local_rand_ctx\n- */\n-static void insecure_GetRandHash(uint256& t)\n-{\n-    uint32_t* ptr = (uint32_t*)t.begin();\n-    for (uint8_t j = 0; j < 8; ++j)\n-        *(ptr++) = local_rand_ctx.rand32();\n-}\n-\n-\n-\n /* Test that no values not inserted into the cache are read out of it.\n  *\n  * There are no repeats in the first 200000 insecure_GetRandHash calls\n  */\n BOOST_AUTO_TEST_CASE(test_cuckoocache_no_fakes)\n {\n-    local_rand_ctx = FastRandomContext(true);\n+    SeedInsecureRand(true);\n     CuckooCache::cache<uint256, SignatureCacheHasher> cc{};\n     size_t megabytes = 4;\n     cc.setup_bytes(megabytes << 20);\n-    uint256 v;\n     for (int x = 0; x < 100000; ++x) {\n-        insecure_GetRandHash(v);\n-        cc.insert(v);\n+        cc.insert(InsecureRand256());\n     }\n     for (int x = 0; x < 100000; ++x) {\n-        insecure_GetRandHash(v);\n-        BOOST_CHECK(!cc.contains(v, false));\n+        BOOST_CHECK(!cc.contains(InsecureRand256(), false));\n     }\n };\n \n@@ -64,7 +47,7 @@ BOOST_AUTO_TEST_CASE(test_cuckoocache_no_fakes)\n template <typename Cache>\n static double test_cache(size_t megabytes, double load)\n {\n-    local_rand_ctx = FastRandomContext(true);\n+    SeedInsecureRand(true);\n     std::vector<uint256> hashes;\n     Cache set{};\n     size_t bytes = megabytes * (1 << 20);\n@@ -74,7 +57,7 @@ static double test_cache(size_t megabytes, double load)\n     for (uint32_t i = 0; i < n_insert; ++i) {\n         uint32_t* ptr = (uint32_t*)hashes[i].begin();\n         for (uint8_t j = 0; j < 8; ++j)\n-            *(ptr++) = local_rand_ctx.rand32();\n+            *(ptr++) = InsecureRand32();\n     }\n     /** We make a copy of the hashes because future optimizations of the\n      * cuckoocache may overwrite the inserted element, so the test is\n@@ -135,7 +118,7 @@ template <typename Cache>\n static void test_cache_erase(size_t megabytes)\n {\n     double load = 1;\n-    local_rand_ctx = FastRandomContext(true);\n+    SeedInsecureRand(true);\n     std::vector<uint256> hashes;\n     Cache set{};\n     size_t bytes = megabytes * (1 << 20);\n@@ -145,7 +128,7 @@ static void test_cache_erase(size_t megabytes)\n     for (uint32_t i = 0; i < n_insert; ++i) {\n         uint32_t* ptr = (uint32_t*)hashes[i].begin();\n         for (uint8_t j = 0; j < 8; ++j)\n-            *(ptr++) = local_rand_ctx.rand32();\n+            *(ptr++) = InsecureRand32();\n     }\n     /** We make a copy of the hashes because future optimizations of the\n      * cuckoocache may overwrite the inserted element, so the test is\n@@ -158,7 +141,7 @@ static void test_cache_erase(size_t megabytes)\n         set.insert(hashes_insert_copy[i]);\n     /** Erase the first quarter */\n     for (uint32_t i = 0; i < (n_insert / 4); ++i)\n-        set.contains(hashes[i], true);\n+        BOOST_CHECK(set.contains(hashes[i], true));\n     /** Insert the second half */\n     for (uint32_t i = (n_insert / 2); i < n_insert; ++i)\n         set.insert(hashes_insert_copy[i]);\n@@ -198,7 +181,7 @@ template <typename Cache>\n static void test_cache_erase_parallel(size_t megabytes)\n {\n     double load = 1;\n-    local_rand_ctx = FastRandomContext(true);\n+    SeedInsecureRand(true);\n     std::vector<uint256> hashes;\n     Cache set{};\n     size_t bytes = megabytes * (1 << 20);\n@@ -208,7 +191,7 @@ static void test_cache_erase_parallel(size_t megabytes)\n     for (uint32_t i = 0; i < n_insert; ++i) {\n         uint32_t* ptr = (uint32_t*)hashes[i].begin();\n         for (uint8_t j = 0; j < 8; ++j)\n-            *(ptr++) = local_rand_ctx.rand32();\n+            *(ptr++) = InsecureRand32();\n     }\n     /** We make a copy of the hashes because future optimizations of the\n      * cuckoocache may overwrite the inserted element, so the test is\n@@ -237,8 +220,10 @@ static void test_cache_erase_parallel(size_t megabytes)\n             size_t ntodo = (n_insert/4)/3;\n             size_t start = ntodo*x;\n             size_t end = ntodo*(x+1);\n-            for (uint32_t i = start; i < end; ++i)\n-                set.contains(hashes[i], true);\n+            for (uint32_t i = start; i < end; ++i) {\n+                bool contains = set.contains(hashes[i], true);\n+                assert(contains);\n+            }\n         });\n \n     /** Wait for all threads to finish\n@@ -300,7 +285,7 @@ static void test_cache_generations()\n     // iterations with non-deterministic values, so it isn't \"overfit\" to the\n     // specific entropy in FastRandomContext(true) and implementation of the\n     // cache.\n-    local_rand_ctx = FastRandomContext(true);\n+    SeedInsecureRand(true);\n \n     // block_activity models a chunk of network activity. n_insert elements are\n     // added to the cache. The first and last n/4 are stored for removal later\n@@ -317,7 +302,7 @@ static void test_cache_generations()\n             for (uint32_t i = 0; i < n_insert; ++i) {\n                 uint32_t* ptr = (uint32_t*)inserts[i].begin();\n                 for (uint8_t j = 0; j < 8; ++j)\n-                    *(ptr++) = local_rand_ctx.rand32();\n+                    *(ptr++) = InsecureRand32();\n             }\n             for (uint32_t i = 0; i < n_insert / 4; ++i)\n                 reads.push_back(inserts[i]);"
      },
      {
        "sha": "94e8c95345214e716f442d41b26b6f5188400d11",
        "filename": "src/test/dbwrapper_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/dbwrapper_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/dbwrapper_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/dbwrapper_tests.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -67,7 +67,7 @@ BOOST_AUTO_TEST_CASE(dbwrapper_batch)\n         // Remove key3 before it's even been written\n         batch.Erase(key3);\n \n-        dbw.WriteBatch(batch);\n+        BOOST_CHECK(dbw.WriteBatch(batch));\n \n         BOOST_CHECK(dbw.Read(key, res));\n         BOOST_CHECK_EQUAL(res.ToString(), in.ToString());"
      },
      {
        "sha": "8cf614bc8dc094627401a14d0762e565e2dcdbf3",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -77,7 +77,7 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n     // Test starts here\n     {\n         LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n-        peerLogic->SendMessages(&dummyNode1); // should result in getheaders\n+        BOOST_CHECK(peerLogic->SendMessages(&dummyNode1)); // should result in getheaders\n     }\n     {\n         LOCK2(cs_main, dummyNode1.cs_vSend);\n@@ -90,7 +90,7 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n     SetMockTime(nStartTime+21*60);\n     {\n         LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n-        peerLogic->SendMessages(&dummyNode1); // should result in getheaders\n+        BOOST_CHECK(peerLogic->SendMessages(&dummyNode1)); // should result in getheaders\n     }\n     {\n         LOCK2(cs_main, dummyNode1.cs_vSend);\n@@ -100,7 +100,7 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n     SetMockTime(nStartTime+24*60);\n     {\n         LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n-        peerLogic->SendMessages(&dummyNode1); // should result in disconnect\n+        BOOST_CHECK(peerLogic->SendMessages(&dummyNode1)); // should result in disconnect\n     }\n     BOOST_CHECK(dummyNode1.fDisconnect == true);\n     SetMockTime(0);\n@@ -111,7 +111,7 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n \n static void AddRandomOutboundPeer(std::vector<CNode *> &vNodes, PeerLogicValidation &peerLogic)\n {\n-    CAddress addr(ip(GetRandInt(0xffffffff)), NODE_NONE);\n+    CAddress addr(ip(g_insecure_rand_ctx.randbits(32)), NODE_NONE);\n     vNodes.emplace_back(new CNode(id++, ServiceFlags(NODE_NETWORK|NODE_WITNESS), 0, INVALID_SOCKET, addr, 0, 0, CAddress(), \"\", /*fInboundIn=*/ false));\n     CNode &node = *vNodes.back();\n     node.SetSendVersion(PROTOCOL_VERSION);\n@@ -208,7 +208,7 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     }\n     {\n         LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n-        peerLogic->SendMessages(&dummyNode1);\n+        BOOST_CHECK(peerLogic->SendMessages(&dummyNode1));\n     }\n     BOOST_CHECK(connman->IsBanned(addr1));\n     BOOST_CHECK(!connman->IsBanned(ip(0xa0b0c001|0x0000ff00))); // Different IP, not banned\n@@ -225,7 +225,7 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     }\n     {\n         LOCK2(cs_main, dummyNode2.cs_sendProcessing);\n-        peerLogic->SendMessages(&dummyNode2);\n+        BOOST_CHECK(peerLogic->SendMessages(&dummyNode2));\n     }\n     BOOST_CHECK(!connman->IsBanned(addr2)); // 2 not banned yet...\n     BOOST_CHECK(connman->IsBanned(addr1));  // ... but 1 still should be\n@@ -235,7 +235,7 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     }\n     {\n         LOCK2(cs_main, dummyNode2.cs_sendProcessing);\n-        peerLogic->SendMessages(&dummyNode2);\n+        BOOST_CHECK(peerLogic->SendMessages(&dummyNode2));\n     }\n     BOOST_CHECK(connman->IsBanned(addr2));\n \n@@ -261,7 +261,7 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n     }\n     {\n         LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n-        peerLogic->SendMessages(&dummyNode1);\n+        BOOST_CHECK(peerLogic->SendMessages(&dummyNode1));\n     }\n     BOOST_CHECK(!connman->IsBanned(addr1));\n     {\n@@ -270,7 +270,7 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n     }\n     {\n         LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n-        peerLogic->SendMessages(&dummyNode1);\n+        BOOST_CHECK(peerLogic->SendMessages(&dummyNode1));\n     }\n     BOOST_CHECK(!connman->IsBanned(addr1));\n     {\n@@ -279,7 +279,7 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n     }\n     {\n         LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n-        peerLogic->SendMessages(&dummyNode1);\n+        BOOST_CHECK(peerLogic->SendMessages(&dummyNode1));\n     }\n     BOOST_CHECK(connman->IsBanned(addr1));\n     gArgs.ForceSetArg(\"-banscore\", std::to_string(DEFAULT_BANSCORE_THRESHOLD));\n@@ -308,7 +308,7 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     }\n     {\n         LOCK2(cs_main, dummyNode.cs_sendProcessing);\n-        peerLogic->SendMessages(&dummyNode);\n+        BOOST_CHECK(peerLogic->SendMessages(&dummyNode));\n     }\n     BOOST_CHECK(connman->IsBanned(addr));\n \n@@ -337,7 +337,7 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     CKey key;\n     key.MakeNewKey(true);\n     CBasicKeyStore keystore;\n-    keystore.AddKey(key);\n+    BOOST_CHECK(keystore.AddKey(key));\n \n     // 50 orphan transactions:\n     for (int i = 0; i < 50; i++)\n@@ -366,7 +366,7 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n         tx.vout.resize(1);\n         tx.vout[0].nValue = 1*CENT;\n         tx.vout[0].scriptPubKey = GetScriptForDestination(key.GetPubKey().GetID());\n-        SignSignature(keystore, *txPrev, tx, 0, SIGHASH_ALL);\n+        BOOST_CHECK(SignSignature(keystore, *txPrev, tx, 0, SIGHASH_ALL));\n \n         AddOrphanTx(MakeTransactionRef(tx), i);\n     }\n@@ -386,7 +386,7 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n             tx.vin[j].prevout.n = j;\n             tx.vin[j].prevout.hash = txPrev->GetHash();\n         }\n-        SignSignature(keystore, *txPrev, tx, 0, SIGHASH_ALL);\n+        BOOST_CHECK(SignSignature(keystore, *txPrev, tx, 0, SIGHASH_ALL));\n         // Re-use same signature for other inputs\n         // (they don't have to be valid for this test)\n         for (unsigned int j = 1; j < tx.vin.size(); j++)"
      },
      {
        "sha": "8da8cfc00c4f22dcdd69aeee4fa1816143dcaf56",
        "filename": "src/test/descriptor_tests.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 6,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/descriptor_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/descriptor_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/descriptor_tests.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -79,19 +79,42 @@ void Check(const std::string& prv, const std::string& pub, int flags, const std:\n     BOOST_CHECK_EQUAL(parse_pub->IsRange(), (flags & RANGE) != 0);\n     BOOST_CHECK_EQUAL(parse_priv->IsRange(), (flags & RANGE) != 0);\n \n-\n-    // Is not ranged descriptor, only a single result is expected.\n+    // * For ranged descriptors,  the `scripts` parameter is a list of expected result outputs, for subsequent\n+    //   positions to evaluate the descriptors on (so the first element of `scripts` is for evaluating the\n+    //   descriptor at 0; the second at 1; and so on). To verify this, we evaluate the descriptors once for\n+    //   each element in `scripts`.\n+    // * For non-ranged descriptors, we evaluate the descriptors at positions 0, 1, and 2, but expect the\n+    //   same result in each case, namely the first element of `scripts`. Because of that, the size of\n+    //   `scripts` must be one in that case.\n     if (!(flags & RANGE)) assert(scripts.size() == 1);\n-\n     size_t max = (flags & RANGE) ? scripts.size() : 3;\n+\n+    // Iterate over the position we'll evaluate the descriptors in.\n     for (size_t i = 0; i < max; ++i) {\n+        // Call the expected result scripts `ref`.\n         const auto& ref = scripts[(flags & RANGE) ? i : 0];\n+        // When t=0, evaluate the `prv` descriptor; when t=1, evaluate the `pub` descriptor.\n         for (int t = 0; t < 2; ++t) {\n+            // When the descriptor is hardened, evaluate with access to the private keys inside.\n             const FlatSigningProvider& key_provider = (flags & HARDENED) ? keys_priv : keys_pub;\n-            FlatSigningProvider script_provider;\n-            std::vector<CScript> spks;\n-            BOOST_CHECK((t ? parse_priv : parse_pub)->Expand(i, key_provider, spks, script_provider));\n+\n+            // Evaluate the descriptor selected by `t` in poisition `i`.\n+            FlatSigningProvider script_provider, script_provider_cached;\n+            std::vector<CScript> spks, spks_cached;\n+            std::vector<unsigned char> cache;\n+            BOOST_CHECK((t ? parse_priv : parse_pub)->Expand(i, key_provider, spks, script_provider, &cache));\n+\n+            // Compare the output with the expected result.\n             BOOST_CHECK_EQUAL(spks.size(), ref.size());\n+\n+            // Try to expand again using cached data, and compare.\n+            BOOST_CHECK(parse_pub->ExpandFromCache(i, cache, spks_cached, script_provider_cached));\n+            BOOST_CHECK(spks == spks_cached);\n+            BOOST_CHECK(script_provider.pubkeys == script_provider_cached.pubkeys);\n+            BOOST_CHECK(script_provider.scripts == script_provider_cached.scripts);\n+            BOOST_CHECK(script_provider.origins == script_provider_cached.origins);\n+\n+            // For each of the produced scripts, verify solvability, and when possible, try to sign a transaction spending it.\n             for (size_t n = 0; n < spks.size(); ++n) {\n                 BOOST_CHECK_EQUAL(ref[n], HexStr(spks[n].begin(), spks[n].end()));\n                 BOOST_CHECK_EQUAL(IsSolvable(Merge(key_provider, script_provider), spks[n]), (flags & UNSOLVABLE) == 0);\n@@ -123,6 +146,7 @@ void Check(const std::string& prv, const std::string& pub, int flags, const std:\n             }\n         }\n     }\n+\n     // Verify no expected paths remain that were not observed.\n     BOOST_CHECK_MESSAGE(left_paths.empty(), \"Not all expected key paths found: \" + prv);\n }"
      },
      {
        "sha": "1abaabd658c22eb7249647f776c0f71212568228",
        "filename": "src/test/key_io_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/key_io_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/key_io_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/key_io_tests.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -107,7 +107,7 @@ BOOST_AUTO_TEST_CASE(key_io_valid_gen)\n         } else {\n             CTxDestination dest;\n             CScript exp_script(exp_payload.begin(), exp_payload.end());\n-            ExtractDestination(exp_script, dest);\n+            BOOST_CHECK(ExtractDestination(exp_script, dest));\n             std::string address = EncodeDestination(dest);\n \n             BOOST_CHECK_EQUAL(address, exp_base58string);"
      },
      {
        "sha": "a768b4bcbd9289421a11293c6e8c5450d7eb55e9",
        "filename": "src/test/key_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/key_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/key_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/key_tests.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -163,7 +163,7 @@ BOOST_AUTO_TEST_CASE(key_signature_tests)\n \n     for (int i = 1; i <=20; ++i) {\n         sig.clear();\n-        key.Sign(msg_hash, sig, false, i);\n+        BOOST_CHECK(key.Sign(msg_hash, sig, false, i));\n         found = sig[3] == 0x21 && sig[4] == 0x00;\n         if (found) {\n             break;\n@@ -179,7 +179,7 @@ BOOST_AUTO_TEST_CASE(key_signature_tests)\n         sig.clear();\n         std::string msg = \"A message to be signed\" + std::to_string(i);\n         msg_hash = Hash(msg.begin(), msg.end());\n-        key.Sign(msg_hash, sig);\n+        BOOST_CHECK(key.Sign(msg_hash, sig));\n         found = sig[3] == 0x20;\n         BOOST_CHECK(sig.size() <= 70);\n         found_small |= sig.size() < 70;"
      },
      {
        "sha": "2396aba0f1db3f789f141832fbb974536a6549e9",
        "filename": "src/test/mempool_tests.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/mempool_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/mempool_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/mempool_tests.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -59,13 +59,13 @@ BOOST_AUTO_TEST_CASE(MempoolRemoveTest)\n \n     // Nothing in pool, remove should do nothing:\n     unsigned int poolSize = testPool.size();\n-    testPool.removeRecursive(txParent);\n+    testPool.removeRecursive(CTransaction(txParent));\n     BOOST_CHECK_EQUAL(testPool.size(), poolSize);\n \n     // Just the parent:\n     testPool.addUnchecked(entry.FromTx(txParent));\n     poolSize = testPool.size();\n-    testPool.removeRecursive(txParent);\n+    testPool.removeRecursive(CTransaction(txParent));\n     BOOST_CHECK_EQUAL(testPool.size(), poolSize - 1);\n \n     // Parent, children, grandchildren:\n@@ -77,18 +77,18 @@ BOOST_AUTO_TEST_CASE(MempoolRemoveTest)\n     }\n     // Remove Child[0], GrandChild[0] should be removed:\n     poolSize = testPool.size();\n-    testPool.removeRecursive(txChild[0]);\n+    testPool.removeRecursive(CTransaction(txChild[0]));\n     BOOST_CHECK_EQUAL(testPool.size(), poolSize - 2);\n     // ... make sure grandchild and child are gone:\n     poolSize = testPool.size();\n-    testPool.removeRecursive(txGrandChild[0]);\n+    testPool.removeRecursive(CTransaction(txGrandChild[0]));\n     BOOST_CHECK_EQUAL(testPool.size(), poolSize);\n     poolSize = testPool.size();\n-    testPool.removeRecursive(txChild[0]);\n+    testPool.removeRecursive(CTransaction(txChild[0]));\n     BOOST_CHECK_EQUAL(testPool.size(), poolSize);\n     // Remove parent, all children/grandchildren should go:\n     poolSize = testPool.size();\n-    testPool.removeRecursive(txParent);\n+    testPool.removeRecursive(CTransaction(txParent));\n     BOOST_CHECK_EQUAL(testPool.size(), poolSize - 5);\n     BOOST_CHECK_EQUAL(testPool.size(), 0U);\n \n@@ -101,7 +101,7 @@ BOOST_AUTO_TEST_CASE(MempoolRemoveTest)\n     // Now remove the parent, as might happen if a block-re-org occurs but the parent cannot be\n     // put into the mempool (maybe because it is non-standard):\n     poolSize = testPool.size();\n-    testPool.removeRecursive(txParent);\n+    testPool.removeRecursive(CTransaction(txParent));\n     BOOST_CHECK_EQUAL(testPool.size(), poolSize - 6);\n     BOOST_CHECK_EQUAL(testPool.size(), 0U);\n }\n@@ -309,7 +309,7 @@ BOOST_AUTO_TEST_CASE(MempoolAncestorIndexingTest)\n     tx2.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx2.vout[0].nValue = 2 * COIN;\n     pool.addUnchecked(entry.Fee(20000LL).FromTx(tx2));\n-    uint64_t tx2Size = GetVirtualTransactionSize(tx2);\n+    uint64_t tx2Size = GetVirtualTransactionSize(CTransaction(tx2));\n \n     /* lowest fee */\n     CMutableTransaction tx3 = CMutableTransaction();\n@@ -357,7 +357,7 @@ BOOST_AUTO_TEST_CASE(MempoolAncestorIndexingTest)\n     tx6.vout.resize(1);\n     tx6.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx6.vout[0].nValue = 20 * COIN;\n-    uint64_t tx6Size = GetVirtualTransactionSize(tx6);\n+    uint64_t tx6Size = GetVirtualTransactionSize(CTransaction(tx6));\n \n     pool.addUnchecked(entry.Fee(0LL).FromTx(tx6));\n     BOOST_CHECK_EQUAL(pool.size(), 6U);\n@@ -376,7 +376,7 @@ BOOST_AUTO_TEST_CASE(MempoolAncestorIndexingTest)\n     tx7.vout.resize(1);\n     tx7.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx7.vout[0].nValue = 10 * COIN;\n-    uint64_t tx7Size = GetVirtualTransactionSize(tx7);\n+    uint64_t tx7Size = GetVirtualTransactionSize(CTransaction(tx7));\n \n     /* set the fee to just below tx2's feerate when including ancestor */\n     CAmount fee = (20000/tx2Size)*(tx7Size + tx6Size) - 1;\n@@ -464,12 +464,12 @@ BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)\n     BOOST_CHECK(pool.exists(tx2.GetHash()));\n     BOOST_CHECK(pool.exists(tx3.GetHash()));\n \n-    pool.TrimToSize(GetVirtualTransactionSize(tx1)); // mempool is limited to tx1's size in memory usage, so nothing fits\n+    pool.TrimToSize(GetVirtualTransactionSize(CTransaction(tx1))); // mempool is limited to tx1's size in memory usage, so nothing fits\n     BOOST_CHECK(!pool.exists(tx1.GetHash()));\n     BOOST_CHECK(!pool.exists(tx2.GetHash()));\n     BOOST_CHECK(!pool.exists(tx3.GetHash()));\n \n-    CFeeRate maxFeeRateRemoved(25000, GetVirtualTransactionSize(tx3) + GetVirtualTransactionSize(tx2));\n+    CFeeRate maxFeeRateRemoved(25000, GetVirtualTransactionSize(CTransaction(tx3)) + GetVirtualTransactionSize(CTransaction(tx2)));\n     BOOST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), maxFeeRateRemoved.GetFeePerK() + 1000);\n \n     CMutableTransaction tx4 = CMutableTransaction();"
      },
      {
        "sha": "f3648e2eeec8b073b1816b92df990696ec5a8a39",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 18,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -159,7 +159,7 @@ static void TestPackageSelection(const CChainParams& chainparams, const CScript&\n     // Test that packages above the min relay fee do get included, even if one\n     // of the transactions is below the min relay fee\n     // Remove the low fee transaction and replace with a higher fee transaction\n-    mempool.removeRecursive(tx);\n+    mempool.removeRecursive(CTransaction(tx));\n     tx.vout[0].nValue -= 2; // Now we should be just over the min relay fee\n     hashLowFeeTx = tx.GetHash();\n     mempool.addUnchecked(entry.Fee(feeToUse+2).FromTx(tx));\n@@ -441,22 +441,22 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.nLockTime = 0;\n     hash = tx.GetHash();\n     mempool.addUnchecked(entry.Fee(HIGHFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n-    BOOST_CHECK(CheckFinalTx(tx, flags)); // Locktime passes\n-    BOOST_CHECK(!TestSequenceLocks(tx, flags)); // Sequence locks fail\n-    BOOST_CHECK(SequenceLocks(tx, flags, &prevheights, CreateBlockIndex(chainActive.Tip()->nHeight + 2))); // Sequence locks pass on 2nd block\n+    BOOST_CHECK(CheckFinalTx(CTransaction(tx), flags)); // Locktime passes\n+    BOOST_CHECK(!TestSequenceLocks(CTransaction(tx), flags)); // Sequence locks fail\n+    BOOST_CHECK(SequenceLocks(CTransaction(tx), flags, &prevheights, CreateBlockIndex(chainActive.Tip()->nHeight + 2))); // Sequence locks pass on 2nd block\n \n     // relative time locked\n     tx.vin[0].prevout.hash = txFirst[1]->GetHash();\n     tx.vin[0].nSequence = CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG | (((chainActive.Tip()->GetMedianTimePast()+1-chainActive[1]->GetMedianTimePast()) >> CTxIn::SEQUENCE_LOCKTIME_GRANULARITY) + 1); // txFirst[1] is the 3rd block\n     prevheights[0] = baseheight + 2;\n     hash = tx.GetHash();\n     mempool.addUnchecked(entry.Time(GetTime()).FromTx(tx));\n-    BOOST_CHECK(CheckFinalTx(tx, flags)); // Locktime passes\n-    BOOST_CHECK(!TestSequenceLocks(tx, flags)); // Sequence locks fail\n+    BOOST_CHECK(CheckFinalTx(CTransaction(tx), flags)); // Locktime passes\n+    BOOST_CHECK(!TestSequenceLocks(CTransaction(tx), flags)); // Sequence locks fail\n \n     for (int i = 0; i < CBlockIndex::nMedianTimeSpan; i++)\n         chainActive.Tip()->GetAncestor(chainActive.Tip()->nHeight - i)->nTime += 512; //Trick the MedianTimePast\n-    BOOST_CHECK(SequenceLocks(tx, flags, &prevheights, CreateBlockIndex(chainActive.Tip()->nHeight + 1))); // Sequence locks pass 512 seconds later\n+    BOOST_CHECK(SequenceLocks(CTransaction(tx), flags, &prevheights, CreateBlockIndex(chainActive.Tip()->nHeight + 1))); // Sequence locks pass 512 seconds later\n     for (int i = 0; i < CBlockIndex::nMedianTimeSpan; i++)\n         chainActive.Tip()->GetAncestor(chainActive.Tip()->nHeight - i)->nTime -= 512; //undo tricked MTP\n \n@@ -467,9 +467,9 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.nLockTime = chainActive.Tip()->nHeight + 1;\n     hash = tx.GetHash();\n     mempool.addUnchecked(entry.Time(GetTime()).FromTx(tx));\n-    BOOST_CHECK(!CheckFinalTx(tx, flags)); // Locktime fails\n-    BOOST_CHECK(TestSequenceLocks(tx, flags)); // Sequence locks pass\n-    BOOST_CHECK(IsFinalTx(tx, chainActive.Tip()->nHeight + 2, chainActive.Tip()->GetMedianTimePast())); // Locktime passes on 2nd block\n+    BOOST_CHECK(!CheckFinalTx(CTransaction(tx), flags)); // Locktime fails\n+    BOOST_CHECK(TestSequenceLocks(CTransaction(tx), flags)); // Sequence locks pass\n+    BOOST_CHECK(IsFinalTx(CTransaction(tx), chainActive.Tip()->nHeight + 2, chainActive.Tip()->GetMedianTimePast())); // Locktime passes on 2nd block\n \n     // absolute time locked\n     tx.vin[0].prevout.hash = txFirst[3]->GetHash();\n@@ -478,23 +478,23 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     prevheights[0] = baseheight + 4;\n     hash = tx.GetHash();\n     mempool.addUnchecked(entry.Time(GetTime()).FromTx(tx));\n-    BOOST_CHECK(!CheckFinalTx(tx, flags)); // Locktime fails\n-    BOOST_CHECK(TestSequenceLocks(tx, flags)); // Sequence locks pass\n-    BOOST_CHECK(IsFinalTx(tx, chainActive.Tip()->nHeight + 2, chainActive.Tip()->GetMedianTimePast() + 1)); // Locktime passes 1 second later\n+    BOOST_CHECK(!CheckFinalTx(CTransaction(tx), flags)); // Locktime fails\n+    BOOST_CHECK(TestSequenceLocks(CTransaction(tx), flags)); // Sequence locks pass\n+    BOOST_CHECK(IsFinalTx(CTransaction(tx), chainActive.Tip()->nHeight + 2, chainActive.Tip()->GetMedianTimePast() + 1)); // Locktime passes 1 second later\n \n     // mempool-dependent transactions (not added)\n     tx.vin[0].prevout.hash = hash;\n     prevheights[0] = chainActive.Tip()->nHeight + 1;\n     tx.nLockTime = 0;\n     tx.vin[0].nSequence = 0;\n-    BOOST_CHECK(CheckFinalTx(tx, flags)); // Locktime passes\n-    BOOST_CHECK(TestSequenceLocks(tx, flags)); // Sequence locks pass\n+    BOOST_CHECK(CheckFinalTx(CTransaction(tx), flags)); // Locktime passes\n+    BOOST_CHECK(TestSequenceLocks(CTransaction(tx), flags)); // Sequence locks pass\n     tx.vin[0].nSequence = 1;\n-    BOOST_CHECK(!TestSequenceLocks(tx, flags)); // Sequence locks fail\n+    BOOST_CHECK(!TestSequenceLocks(CTransaction(tx), flags)); // Sequence locks fail\n     tx.vin[0].nSequence = CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG;\n-    BOOST_CHECK(TestSequenceLocks(tx, flags)); // Sequence locks pass\n+    BOOST_CHECK(TestSequenceLocks(CTransaction(tx), flags)); // Sequence locks pass\n     tx.vin[0].nSequence = CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG | 1;\n-    BOOST_CHECK(!TestSequenceLocks(tx, flags)); // Sequence locks fail\n+    BOOST_CHECK(!TestSequenceLocks(CTransaction(tx), flags)); // Sequence locks fail\n \n     BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n "
      },
      {
        "sha": "8afe4b8a5996f649ce679dbe70e2c6329b235860",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -76,20 +76,20 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n     // Test a AND b:\n     keys.assign(1,key[0]);\n     keys.push_back(key[1]);\n-    s = sign_multisig(a_and_b, keys, txTo[0], 0);\n+    s = sign_multisig(a_and_b, keys, CTransaction(txTo[0]), 0);\n     BOOST_CHECK(VerifyScript(s, a_and_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     for (int i = 0; i < 4; i++)\n     {\n         keys.assign(1,key[i]);\n-        s = sign_multisig(a_and_b, keys, txTo[0], 0);\n+        s = sign_multisig(a_and_b, keys, CTransaction(txTo[0]), 0);\n         BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount), &err), strprintf(\"a&b 1: %d\", i));\n         BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_INVALID_STACK_OPERATION, ScriptErrorString(err));\n \n         keys.assign(1,key[1]);\n         keys.push_back(key[i]);\n-        s = sign_multisig(a_and_b, keys, txTo[0], 0);\n+        s = sign_multisig(a_and_b, keys, CTransaction(txTo[0]), 0);\n         BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount), &err), strprintf(\"a&b 2: %d\", i));\n         BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n     }\n@@ -98,7 +98,7 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n     for (int i = 0; i < 4; i++)\n     {\n         keys.assign(1,key[i]);\n-        s = sign_multisig(a_or_b, keys, txTo[1], 0);\n+        s = sign_multisig(a_or_b, keys, CTransaction(txTo[1]), 0);\n         if (i == 0 || i == 1)\n         {\n             BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[1], 0, amount), &err), strprintf(\"a|b: %d\", i));\n@@ -121,7 +121,7 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n         {\n             keys.assign(1,key[i]);\n             keys.push_back(key[j]);\n-            s = sign_multisig(escrow, keys, txTo[2], 0);\n+            s = sign_multisig(escrow, keys, CTransaction(txTo[2]), 0);\n             if (i < j && i < 3 && j < 3)\n             {\n                 BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, nullptr, flags, MutableTransactionSignatureChecker(&txTo[2], 0, amount), &err), strprintf(\"escrow 1: %d %d\", i, j));\n@@ -179,7 +179,7 @@ BOOST_AUTO_TEST_CASE(multisig_Sign)\n     for (int i = 0; i < 4; i++)\n     {\n         key[i].MakeNewKey(true);\n-        keystore.AddKey(key[i]);\n+        BOOST_CHECK(keystore.AddKey(key[i]));\n     }\n \n     CScript a_and_b;\n@@ -209,7 +209,7 @@ BOOST_AUTO_TEST_CASE(multisig_Sign)\n \n     for (int i = 0; i < 3; i++)\n     {\n-        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0, SIGHASH_ALL), strprintf(\"SignSignature %d\", i));\n+        BOOST_CHECK_MESSAGE(SignSignature(keystore, CTransaction(txFrom), txTo[i], 0, SIGHASH_ALL), strprintf(\"SignSignature %d\", i));\n     }\n }\n "
      },
      {
        "sha": "e7a3c963436684594df16b0920099aa407baa6d4",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -54,10 +54,10 @@ class CAddrManCorrupted : public CAddrManSerializationMock\n         s << nUBuckets;\n \n         CService serv;\n-        Lookup(\"252.1.1.1\", serv, 7777, false);\n+        BOOST_CHECK(Lookup(\"252.1.1.1\", serv, 7777, false));\n         CAddress addr = CAddress(serv, NODE_NONE);\n         CNetAddr resolved;\n-        LookupHost(\"252.2.2.2\", resolved, false);\n+        BOOST_CHECK(LookupHost(\"252.2.2.2\", resolved, false));\n         CAddrInfo info = CAddrInfo(addr, resolved);\n         s << info;\n     }\n@@ -82,7 +82,7 @@ BOOST_AUTO_TEST_CASE(cnode_listen_port)\n     BOOST_CHECK(port == Params().GetDefaultPort());\n     // test set port\n     unsigned short altPort = 12345;\n-    gArgs.SoftSetArg(\"-port\", std::to_string(altPort));\n+    BOOST_CHECK(gArgs.SoftSetArg(\"-port\", std::to_string(altPort)));\n     port = GetListenPort();\n     BOOST_CHECK(port == altPort);\n }\n@@ -94,16 +94,16 @@ BOOST_AUTO_TEST_CASE(caddrdb_read)\n     addrmanUncorrupted.MakeDeterministic();\n \n     CService addr1, addr2, addr3;\n-    Lookup(\"250.7.1.1\", addr1, 8333, false);\n-    Lookup(\"250.7.2.2\", addr2, 9999, false);\n-    Lookup(\"250.7.3.3\", addr3, 9999, false);\n+    BOOST_CHECK(Lookup(\"250.7.1.1\", addr1, 8333, false));\n+    BOOST_CHECK(Lookup(\"250.7.2.2\", addr2, 9999, false));\n+    BOOST_CHECK(Lookup(\"250.7.3.3\", addr3, 9999, false));\n \n     // Add three addresses to new table.\n     CService source;\n-    Lookup(\"252.5.1.1\", source, 8333, false);\n-    addrmanUncorrupted.Add(CAddress(addr1, NODE_NONE), source);\n-    addrmanUncorrupted.Add(CAddress(addr2, NODE_NONE), source);\n-    addrmanUncorrupted.Add(CAddress(addr3, NODE_NONE), source);\n+    BOOST_CHECK(Lookup(\"252.5.1.1\", source, 8333, false));\n+    BOOST_CHECK(addrmanUncorrupted.Add(CAddress(addr1, NODE_NONE), source));\n+    BOOST_CHECK(addrmanUncorrupted.Add(CAddress(addr2, NODE_NONE), source));\n+    BOOST_CHECK(addrmanUncorrupted.Add(CAddress(addr3, NODE_NONE), source));\n \n     // Test that the de-serialization does not throw an exception.\n     CDataStream ssPeers1 = AddrmanToStream(addrmanUncorrupted);\n@@ -128,7 +128,7 @@ BOOST_AUTO_TEST_CASE(caddrdb_read)\n     CAddrMan addrman2;\n     CAddrDB adb;\n     BOOST_CHECK(addrman2.size() == 0);\n-    adb.Read(addrman2, ssPeers2);\n+    BOOST_CHECK(adb.Read(addrman2, ssPeers2));\n     BOOST_CHECK(addrman2.size() == 3);\n }\n \n@@ -161,7 +161,7 @@ BOOST_AUTO_TEST_CASE(caddrdb_read_corrupted)\n     CAddrMan addrman2;\n     CAddrDB adb;\n     BOOST_CHECK(addrman2.size() == 0);\n-    adb.Read(addrman2, ssPeers2);\n+    BOOST_CHECK(!adb.Read(addrman2, ssPeers2));\n     BOOST_CHECK(addrman2.size() == 0);\n }\n "
      },
      {
        "sha": "431b16cfc282f8d69a5cf7a7bf33f54c09f43000",
        "filename": "src/test/policyestimator_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/policyestimator_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/policyestimator_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/policyestimator_tests.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -44,7 +44,7 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n     tx.vin[0].scriptSig = garbage;\n     tx.vout.resize(1);\n     tx.vout[0].nValue=0LL;\n-    CFeeRate baseRate(basefee, GetVirtualTransactionSize(tx));\n+    CFeeRate baseRate(basefee, GetVirtualTransactionSize(CTransaction(tx)));\n \n     // Create a fake block\n     std::vector<CTransactionRef> block;"
      },
      {
        "sha": "7341389208ece75b36aed9120ed30ca5e2f8349a",
        "filename": "src/test/prevector_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/prevector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/prevector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/prevector_tests.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -189,8 +189,8 @@ class prevector_tester {\n \n     prevector_tester() {\n         SeedInsecureRand();\n-        rand_seed = insecure_rand_seed;\n-        rand_cache = insecure_rand_ctx;\n+        rand_seed = InsecureRand256();\n+        rand_cache = FastRandomContext(rand_seed);\n     }\n };\n "
      },
      {
        "sha": "1057d09471631c4b6c64ac2f9706435536817f61",
        "filename": "src/test/random_tests.cpp",
        "status": "modified",
        "additions": 46,
        "deletions": 5,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/random_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/random_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/random_tests.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -38,11 +38,18 @@ BOOST_AUTO_TEST_CASE(fastrandom_tests)\n     BOOST_CHECK(ctx1.randbytes(50) == ctx2.randbytes(50));\n \n     // Check that a nondeterministic ones are not\n-    FastRandomContext ctx3;\n-    FastRandomContext ctx4;\n-    BOOST_CHECK(ctx3.rand64() != ctx4.rand64()); // extremely unlikely to be equal\n-    BOOST_CHECK(ctx3.rand256() != ctx4.rand256());\n-    BOOST_CHECK(ctx3.randbytes(7) != ctx4.randbytes(7));\n+    {\n+        FastRandomContext ctx3, ctx4;\n+        BOOST_CHECK(ctx3.rand64() != ctx4.rand64()); // extremely unlikely to be equal\n+    }\n+    {\n+        FastRandomContext ctx3, ctx4;\n+        BOOST_CHECK(ctx3.rand256() != ctx4.rand256());\n+    }\n+    {\n+        FastRandomContext ctx3, ctx4;\n+        BOOST_CHECK(ctx3.randbytes(7) != ctx4.randbytes(7));\n+    }\n }\n \n BOOST_AUTO_TEST_CASE(fastrandom_randbits)\n@@ -75,8 +82,42 @@ BOOST_AUTO_TEST_CASE(stdrandom_test)\n         for (int j = 1; j <= 10; ++j) {\n             BOOST_CHECK(std::find(test.begin(), test.end(), j) != test.end());\n         }\n+        Shuffle(test.begin(), test.end(), ctx);\n+        for (int j = 1; j <= 10; ++j) {\n+            BOOST_CHECK(std::find(test.begin(), test.end(), j) != test.end());\n+        }\n     }\n \n }\n \n+/** Test that Shuffle reaches every permutation with equal probability. */\n+BOOST_AUTO_TEST_CASE(shuffle_stat_test)\n+{\n+    FastRandomContext ctx(true);\n+    uint32_t counts[5 * 5 * 5 * 5 * 5] = {0};\n+    for (int i = 0; i < 12000; ++i) {\n+        int data[5] = {0, 1, 2, 3, 4};\n+        Shuffle(std::begin(data), std::end(data), ctx);\n+        int pos = data[0] + data[1] * 5 + data[2] * 25 + data[3] * 125 + data[4] * 625;\n+        ++counts[pos];\n+    }\n+    unsigned int sum = 0;\n+    double chi_score = 0.0;\n+    for (int i = 0; i < 5 * 5 * 5 * 5 * 5; ++i) {\n+        int i1 = i % 5, i2 = (i / 5) % 5, i3 = (i / 25) % 5, i4 = (i / 125) % 5, i5 = i / 625;\n+        uint32_t count = counts[i];\n+        if (i1 == i2 || i1 == i3 || i1 == i4 || i1 == i5 || i2 == i3 || i2 == i4 || i2 == i5 || i3 == i4 || i3 == i5 || i4 == i5) {\n+            BOOST_CHECK(count == 0);\n+        } else {\n+            chi_score += ((count - 100.0) * (count - 100.0)) / 100.0;\n+            BOOST_CHECK(count > 50);\n+            BOOST_CHECK(count < 150);\n+            sum += count;\n+        }\n+    }\n+    BOOST_CHECK(chi_score > 58.1411); // 99.9999% confidence interval\n+    BOOST_CHECK(chi_score < 210.275);\n+    BOOST_CHECK_EQUAL(sum, 12000);\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "ff4839892585bfaf831c07b810a0347ed9bdb561",
        "filename": "src/test/rpc_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/rpc_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/rpc_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/rpc_tests.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -129,9 +129,6 @@ BOOST_AUTO_TEST_CASE(rpc_createraw_op_return)\n {\n     BOOST_CHECK_NO_THROW(CallRPC(\"createrawtransaction [{\\\"txid\\\":\\\"a3b807410df0b60fcb9736768df5823938b2f838694939ba45f3c0a1bff150ed\\\",\\\"vout\\\":0}] {\\\"data\\\":\\\"68656c6c6f776f726c64\\\"}\"));\n \n-    // Allow more than one data transaction output\n-    BOOST_CHECK_NO_THROW(CallRPC(\"createrawtransaction [{\\\"txid\\\":\\\"a3b807410df0b60fcb9736768df5823938b2f838694939ba45f3c0a1bff150ed\\\",\\\"vout\\\":0}] {\\\"data\\\":\\\"68656c6c6f776f726c64\\\",\\\"data\\\":\\\"68656c6c6f776f726c64\\\"}\"));\n-\n     // Key not \"data\" (bad address)\n     BOOST_CHECK_THROW(CallRPC(\"createrawtransaction [{\\\"txid\\\":\\\"a3b807410df0b60fcb9736768df5823938b2f838694939ba45f3c0a1bff150ed\\\",\\\"vout\\\":0}] {\\\"somedata\\\":\\\"68656c6c6f776f726c64\\\"}\"), std::runtime_error);\n "
      },
      {
        "sha": "1556b2f667872ac7d5f6564aecf07e7e05fc6c26",
        "filename": "src/test/script_p2sh_tests.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 26,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/script_p2sh_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/script_p2sh_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_p2sh_tests.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -61,7 +61,7 @@ BOOST_AUTO_TEST_CASE(sign)\n     for (int i = 0; i < 4; i++)\n     {\n         key[i].MakeNewKey(true);\n-        keystore.AddKey(key[i]);\n+        BOOST_CHECK(keystore.AddKey(key[i]));\n     }\n \n     // 8 Scripts: checking all combinations of\n@@ -74,7 +74,7 @@ BOOST_AUTO_TEST_CASE(sign)\n     CScript evalScripts[4];\n     for (int i = 0; i < 4; i++)\n     {\n-        keystore.AddCScript(standardScripts[i]);\n+        BOOST_CHECK(keystore.AddCScript(standardScripts[i]));\n         evalScripts[i] = GetScriptForDestination(CScriptID(standardScripts[i]));\n     }\n \n@@ -88,7 +88,7 @@ BOOST_AUTO_TEST_CASE(sign)\n         txFrom.vout[i+4].scriptPubKey = standardScripts[i];\n         txFrom.vout[i+4].nValue = COIN;\n     }\n-    BOOST_CHECK(IsStandardTx(txFrom, reason));\n+    BOOST_CHECK(IsStandardTx(CTransaction(txFrom), reason));\n \n     CMutableTransaction txTo[8]; // Spending transactions\n     for (int i = 0; i < 8; i++)\n@@ -102,7 +102,7 @@ BOOST_AUTO_TEST_CASE(sign)\n     }\n     for (int i = 0; i < 8; i++)\n     {\n-        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0, SIGHASH_ALL), strprintf(\"SignSignature %d\", i));\n+        BOOST_CHECK_MESSAGE(SignSignature(keystore, CTransaction(txFrom), txTo[i], 0, SIGHASH_ALL), strprintf(\"SignSignature %d\", i));\n     }\n     // All of the above should be OK, and the txTos have valid signatures\n     // Check to make sure signature verification fails if we use the wrong ScriptSig:\n@@ -112,7 +112,7 @@ BOOST_AUTO_TEST_CASE(sign)\n         {\n             CScript sigSave = txTo[i].vin[0].scriptSig;\n             txTo[i].vin[0].scriptSig = txTo[j].vin[0].scriptSig;\n-            bool sigOK = CScriptCheck(txFrom.vout[txTo[i].vin[0].prevout.n], txTo[i], 0, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC, false, &txdata)();\n+            bool sigOK = CScriptCheck(txFrom.vout[txTo[i].vin[0].prevout.n], CTransaction(txTo[i]), 0, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC, false, &txdata)();\n             if (i == j)\n                 BOOST_CHECK_MESSAGE(sigOK, strprintf(\"VerifySignature %d %d\", i, j));\n             else\n@@ -159,7 +159,7 @@ BOOST_AUTO_TEST_CASE(set)\n     for (int i = 0; i < 4; i++)\n     {\n         key[i].MakeNewKey(true);\n-        keystore.AddKey(key[i]);\n+        BOOST_CHECK(keystore.AddKey(key[i]));\n         keys.push_back(key[i].GetPubKey());\n     }\n \n@@ -173,7 +173,7 @@ BOOST_AUTO_TEST_CASE(set)\n     for (int i = 0; i < 4; i++)\n     {\n         outer[i] = GetScriptForDestination(CScriptID(inner[i]));\n-        keystore.AddCScript(inner[i]);\n+        BOOST_CHECK(keystore.AddCScript(inner[i]));\n     }\n \n     CMutableTransaction txFrom;  // Funding transaction:\n@@ -184,7 +184,7 @@ BOOST_AUTO_TEST_CASE(set)\n         txFrom.vout[i].scriptPubKey = outer[i];\n         txFrom.vout[i].nValue = CENT;\n     }\n-    BOOST_CHECK(IsStandardTx(txFrom, reason));\n+    BOOST_CHECK(IsStandardTx(CTransaction(txFrom), reason));\n \n     CMutableTransaction txTo[4]; // Spending transactions\n     for (int i = 0; i < 4; i++)\n@@ -199,8 +199,8 @@ BOOST_AUTO_TEST_CASE(set)\n     }\n     for (int i = 0; i < 4; i++)\n     {\n-        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0, SIGHASH_ALL), strprintf(\"SignSignature %d\", i));\n-        BOOST_CHECK_MESSAGE(IsStandardTx(txTo[i], reason), strprintf(\"txTo[%d].IsStandard\", i));\n+        BOOST_CHECK_MESSAGE(SignSignature(keystore, CTransaction(txFrom), txTo[i], 0, SIGHASH_ALL), strprintf(\"SignSignature %d\", i));\n+        BOOST_CHECK_MESSAGE(IsStandardTx(CTransaction(txTo[i]), reason), strprintf(\"txTo[%d].IsStandard\", i));\n     }\n }\n \n@@ -266,7 +266,7 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     for (int i = 0; i < 6; i++)\n     {\n         key[i].MakeNewKey(true);\n-        keystore.AddKey(key[i]);\n+        BOOST_CHECK(keystore.AddKey(key[i]));\n     }\n     for (int i = 0; i < 3; i++)\n         keys.push_back(key[i].GetPubKey());\n@@ -276,7 +276,7 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n \n     // First three are standard:\n     CScript pay1 = GetScriptForDestination(key[0].GetPubKey().GetID());\n-    keystore.AddCScript(pay1);\n+    BOOST_CHECK(keystore.AddCScript(pay1));\n     CScript pay1of3 = GetScriptForMultisig(1, keys);\n \n     txFrom.vout[0].scriptPubKey = GetScriptForDestination(CScriptID(pay1)); // P2SH (OP_CHECKSIG)\n@@ -293,7 +293,7 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     oneAndTwo << OP_3 << OP_CHECKMULTISIGVERIFY;\n     oneAndTwo << OP_2 << ToByteVector(key[3].GetPubKey()) << ToByteVector(key[4].GetPubKey()) << ToByteVector(key[5].GetPubKey());\n     oneAndTwo << OP_3 << OP_CHECKMULTISIG;\n-    keystore.AddCScript(oneAndTwo);\n+    BOOST_CHECK(keystore.AddCScript(oneAndTwo));\n     txFrom.vout[3].scriptPubKey = GetScriptForDestination(CScriptID(oneAndTwo));\n     txFrom.vout[3].nValue = 4000;\n \n@@ -302,21 +302,21 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     for (unsigned i = 0; i < MAX_P2SH_SIGOPS; i++)\n         fifteenSigops << ToByteVector(key[i%3].GetPubKey());\n     fifteenSigops << OP_15 << OP_CHECKMULTISIG;\n-    keystore.AddCScript(fifteenSigops);\n+    BOOST_CHECK(keystore.AddCScript(fifteenSigops));\n     txFrom.vout[4].scriptPubKey = GetScriptForDestination(CScriptID(fifteenSigops));\n     txFrom.vout[4].nValue = 5000;\n \n     // vout[5/6] are non-standard because they exceed MAX_P2SH_SIGOPS\n     CScript sixteenSigops; sixteenSigops << OP_16 << OP_CHECKMULTISIG;\n-    keystore.AddCScript(sixteenSigops);\n+    BOOST_CHECK(keystore.AddCScript(sixteenSigops));\n     txFrom.vout[5].scriptPubKey = GetScriptForDestination(CScriptID(sixteenSigops));\n     txFrom.vout[5].nValue = 5000;\n     CScript twentySigops; twentySigops << OP_CHECKMULTISIG;\n-    keystore.AddCScript(twentySigops);\n+    BOOST_CHECK(keystore.AddCScript(twentySigops));\n     txFrom.vout[6].scriptPubKey = GetScriptForDestination(CScriptID(twentySigops));\n     txFrom.vout[6].nValue = 6000;\n \n-    AddCoins(coins, txFrom, 0);\n+    AddCoins(coins, CTransaction(txFrom), 0);\n \n     CMutableTransaction txTo;\n     txTo.vout.resize(1);\n@@ -328,18 +328,18 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n         txTo.vin[i].prevout.n = i;\n         txTo.vin[i].prevout.hash = txFrom.GetHash();\n     }\n-    BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL));\n-    BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 1, SIGHASH_ALL));\n-    BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 2, SIGHASH_ALL));\n+    BOOST_CHECK(SignSignature(keystore, CTransaction(txFrom), txTo, 0, SIGHASH_ALL));\n+    BOOST_CHECK(SignSignature(keystore, CTransaction(txFrom), txTo, 1, SIGHASH_ALL));\n+    BOOST_CHECK(SignSignature(keystore, CTransaction(txFrom), txTo, 2, SIGHASH_ALL));\n     // SignSignature doesn't know how to sign these. We're\n     // not testing validating signatures, so just create\n     // dummy signatures that DO include the correct P2SH scripts:\n     txTo.vin[3].scriptSig << OP_11 << OP_11 << std::vector<unsigned char>(oneAndTwo.begin(), oneAndTwo.end());\n     txTo.vin[4].scriptSig << std::vector<unsigned char>(fifteenSigops.begin(), fifteenSigops.end());\n \n-    BOOST_CHECK(::AreInputsStandard(txTo, coins));\n+    BOOST_CHECK(::AreInputsStandard(CTransaction(txTo), coins));\n     // 22 P2SH sigops for all inputs (1 for vin[0], 6 for vin[3], 15 for vin[4]\n-    BOOST_CHECK_EQUAL(GetP2SHSigOpCount(txTo, coins), 22U);\n+    BOOST_CHECK_EQUAL(GetP2SHSigOpCount(CTransaction(txTo), coins), 22U);\n \n     CMutableTransaction txToNonStd1;\n     txToNonStd1.vout.resize(1);\n@@ -350,8 +350,8 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     txToNonStd1.vin[0].prevout.hash = txFrom.GetHash();\n     txToNonStd1.vin[0].scriptSig << std::vector<unsigned char>(sixteenSigops.begin(), sixteenSigops.end());\n \n-    BOOST_CHECK(!::AreInputsStandard(txToNonStd1, coins));\n-    BOOST_CHECK_EQUAL(GetP2SHSigOpCount(txToNonStd1, coins), 16U);\n+    BOOST_CHECK(!::AreInputsStandard(CTransaction(txToNonStd1), coins));\n+    BOOST_CHECK_EQUAL(GetP2SHSigOpCount(CTransaction(txToNonStd1), coins), 16U);\n \n     CMutableTransaction txToNonStd2;\n     txToNonStd2.vout.resize(1);\n@@ -362,8 +362,8 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     txToNonStd2.vin[0].prevout.hash = txFrom.GetHash();\n     txToNonStd2.vin[0].scriptSig << std::vector<unsigned char>(twentySigops.begin(), twentySigops.end());\n \n-    BOOST_CHECK(!::AreInputsStandard(txToNonStd2, coins));\n-    BOOST_CHECK_EQUAL(GetP2SHSigOpCount(txToNonStd2, coins), 20U);\n+    BOOST_CHECK(!::AreInputsStandard(CTransaction(txToNonStd2), coins));\n+    BOOST_CHECK_EQUAL(GetP2SHSigOpCount(CTransaction(txToNonStd2), coins), 20U);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "bde82018c7b23b2d5387373f8448b9033987038c",
        "filename": "src/test/script_standard_tests.cpp",
        "status": "modified",
        "additions": 47,
        "deletions": 47,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/script_standard_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/script_standard_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_standard_tests.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -398,7 +398,7 @@ BOOST_AUTO_TEST_CASE(script_standard_IsMine)\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has key\n-        keystore.AddKey(keys[0]);\n+        BOOST_CHECK(keystore.AddKey(keys[0]));\n         result = IsMine(keystore, scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n     }\n@@ -413,7 +413,7 @@ BOOST_AUTO_TEST_CASE(script_standard_IsMine)\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has key\n-        keystore.AddKey(uncompressedKey);\n+        BOOST_CHECK(keystore.AddKey(uncompressedKey));\n         result = IsMine(keystore, scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n     }\n@@ -428,7 +428,7 @@ BOOST_AUTO_TEST_CASE(script_standard_IsMine)\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has key\n-        keystore.AddKey(keys[0]);\n+        BOOST_CHECK(keystore.AddKey(keys[0]));\n         result = IsMine(keystore, scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n     }\n@@ -443,7 +443,7 @@ BOOST_AUTO_TEST_CASE(script_standard_IsMine)\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has key\n-        keystore.AddKey(uncompressedKey);\n+        BOOST_CHECK(keystore.AddKey(uncompressedKey));\n         result = IsMine(keystore, scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n     }\n@@ -460,12 +460,12 @@ BOOST_AUTO_TEST_CASE(script_standard_IsMine)\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has redeemScript but no key\n-        keystore.AddCScript(redeemScript);\n+        BOOST_CHECK(keystore.AddCScript(redeemScript));\n         result = IsMine(keystore, scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has redeemScript and key\n-        keystore.AddKey(keys[0]);\n+        BOOST_CHECK(keystore.AddKey(keys[0]));\n         result = IsMine(keystore, scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n     }\n@@ -478,10 +478,10 @@ BOOST_AUTO_TEST_CASE(script_standard_IsMine)\n         CScript redeemscript = GetScriptForDestination(CScriptID(redeemscript_inner));\n         scriptPubKey = GetScriptForDestination(CScriptID(redeemscript));\n \n-        keystore.AddCScript(redeemscript);\n-        keystore.AddCScript(redeemscript_inner);\n-        keystore.AddCScript(scriptPubKey);\n-        keystore.AddKey(keys[0]);\n+        BOOST_CHECK(keystore.AddCScript(redeemscript));\n+        BOOST_CHECK(keystore.AddCScript(redeemscript_inner));\n+        BOOST_CHECK(keystore.AddCScript(scriptPubKey));\n+        BOOST_CHECK(keystore.AddKey(keys[0]));\n         result = IsMine(keystore, scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n     }\n@@ -494,10 +494,10 @@ BOOST_AUTO_TEST_CASE(script_standard_IsMine)\n         CScript witnessscript = GetScriptForDestination(CScriptID(redeemscript));\n         scriptPubKey = GetScriptForDestination(WitnessV0ScriptHash(witnessscript));\n \n-        keystore.AddCScript(witnessscript);\n-        keystore.AddCScript(redeemscript);\n-        keystore.AddCScript(scriptPubKey);\n-        keystore.AddKey(keys[0]);\n+        BOOST_CHECK(keystore.AddCScript(witnessscript));\n+        BOOST_CHECK(keystore.AddCScript(redeemscript));\n+        BOOST_CHECK(keystore.AddCScript(scriptPubKey));\n+        BOOST_CHECK(keystore.AddKey(keys[0]));\n         result = IsMine(keystore, scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n     }\n@@ -509,9 +509,9 @@ BOOST_AUTO_TEST_CASE(script_standard_IsMine)\n         CScript witnessscript = GetScriptForDestination(WitnessV0KeyHash(pubkeys[0].GetID()));\n         scriptPubKey = GetScriptForDestination(WitnessV0ScriptHash(witnessscript));\n \n-        keystore.AddCScript(witnessscript);\n-        keystore.AddCScript(scriptPubKey);\n-        keystore.AddKey(keys[0]);\n+        BOOST_CHECK(keystore.AddCScript(witnessscript));\n+        BOOST_CHECK(keystore.AddCScript(scriptPubKey));\n+        BOOST_CHECK(keystore.AddKey(keys[0]));\n         result = IsMine(keystore, scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n     }\n@@ -524,31 +524,31 @@ BOOST_AUTO_TEST_CASE(script_standard_IsMine)\n         CScript witnessscript = GetScriptForDestination(WitnessV0ScriptHash(witnessscript_inner));\n         scriptPubKey = GetScriptForDestination(WitnessV0ScriptHash(witnessscript));\n \n-        keystore.AddCScript(witnessscript_inner);\n-        keystore.AddCScript(witnessscript);\n-        keystore.AddCScript(scriptPubKey);\n-        keystore.AddKey(keys[0]);\n+        BOOST_CHECK(keystore.AddCScript(witnessscript_inner));\n+        BOOST_CHECK(keystore.AddCScript(witnessscript));\n+        BOOST_CHECK(keystore.AddCScript(scriptPubKey));\n+        BOOST_CHECK(keystore.AddKey(keys[0]));\n         result = IsMine(keystore, scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n     }\n \n     // P2WPKH compressed\n     {\n         CBasicKeyStore keystore;\n-        keystore.AddKey(keys[0]);\n+        BOOST_CHECK(keystore.AddKey(keys[0]));\n \n         scriptPubKey = GetScriptForDestination(WitnessV0KeyHash(pubkeys[0].GetID()));\n \n         // Keystore implicitly has key and P2SH redeemScript\n-        keystore.AddCScript(scriptPubKey);\n+        BOOST_CHECK(keystore.AddCScript(scriptPubKey));\n         result = IsMine(keystore, scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n     }\n \n     // P2WPKH uncompressed\n     {\n         CBasicKeyStore keystore;\n-        keystore.AddKey(uncompressedKey);\n+        BOOST_CHECK(keystore.AddKey(uncompressedKey));\n \n         scriptPubKey = GetScriptForDestination(WitnessV0KeyHash(uncompressedPubkey.GetID()));\n \n@@ -557,7 +557,7 @@ BOOST_AUTO_TEST_CASE(script_standard_IsMine)\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has key and P2SH redeemScript\n-        keystore.AddCScript(scriptPubKey);\n+        BOOST_CHECK(keystore.AddCScript(scriptPubKey));\n         result = IsMine(keystore, scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n     }\n@@ -573,19 +573,19 @@ BOOST_AUTO_TEST_CASE(script_standard_IsMine)\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has 1/2 keys\n-        keystore.AddKey(uncompressedKey);\n+        BOOST_CHECK(keystore.AddKey(uncompressedKey));\n \n         result = IsMine(keystore, scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has 2/2 keys\n-        keystore.AddKey(keys[1]);\n+        BOOST_CHECK(keystore.AddKey(keys[1]));\n \n         result = IsMine(keystore, scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has 2/2 keys and the script\n-        keystore.AddCScript(scriptPubKey);\n+        BOOST_CHECK(keystore.AddCScript(scriptPubKey));\n \n         result = IsMine(keystore, scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n@@ -594,8 +594,8 @@ BOOST_AUTO_TEST_CASE(script_standard_IsMine)\n     // P2SH multisig\n     {\n         CBasicKeyStore keystore;\n-        keystore.AddKey(uncompressedKey);\n-        keystore.AddKey(keys[1]);\n+        BOOST_CHECK(keystore.AddKey(uncompressedKey));\n+        BOOST_CHECK(keystore.AddKey(keys[1]));\n \n         CScript redeemScript = GetScriptForMultisig(2, {uncompressedPubkey, pubkeys[1]});\n         scriptPubKey = GetScriptForDestination(CScriptID(redeemScript));\n@@ -605,16 +605,16 @@ BOOST_AUTO_TEST_CASE(script_standard_IsMine)\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has redeemScript\n-        keystore.AddCScript(redeemScript);\n+        BOOST_CHECK(keystore.AddCScript(redeemScript));\n         result = IsMine(keystore, scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n     }\n \n     // P2WSH multisig with compressed keys\n     {\n         CBasicKeyStore keystore;\n-        keystore.AddKey(keys[0]);\n-        keystore.AddKey(keys[1]);\n+        BOOST_CHECK(keystore.AddKey(keys[0]));\n+        BOOST_CHECK(keystore.AddKey(keys[1]));\n \n         CScript witnessScript = GetScriptForMultisig(2, {pubkeys[0], pubkeys[1]});\n         scriptPubKey = GetScriptForDestination(WitnessV0ScriptHash(witnessScript));\n@@ -624,21 +624,21 @@ BOOST_AUTO_TEST_CASE(script_standard_IsMine)\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has keys and witnessScript, but no P2SH redeemScript\n-        keystore.AddCScript(witnessScript);\n+        BOOST_CHECK(keystore.AddCScript(witnessScript));\n         result = IsMine(keystore, scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has keys, witnessScript, P2SH redeemScript\n-        keystore.AddCScript(scriptPubKey);\n+        BOOST_CHECK(keystore.AddCScript(scriptPubKey));\n         result = IsMine(keystore, scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n     }\n \n     // P2WSH multisig with uncompressed key\n     {\n         CBasicKeyStore keystore;\n-        keystore.AddKey(uncompressedKey);\n-        keystore.AddKey(keys[1]);\n+        BOOST_CHECK(keystore.AddKey(uncompressedKey));\n+        BOOST_CHECK(keystore.AddKey(keys[1]));\n \n         CScript witnessScript = GetScriptForMultisig(2, {uncompressedPubkey, pubkeys[1]});\n         scriptPubKey = GetScriptForDestination(WitnessV0ScriptHash(witnessScript));\n@@ -648,12 +648,12 @@ BOOST_AUTO_TEST_CASE(script_standard_IsMine)\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has keys and witnessScript, but no P2SH redeemScript\n-        keystore.AddCScript(witnessScript);\n+        BOOST_CHECK(keystore.AddCScript(witnessScript));\n         result = IsMine(keystore, scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has keys, witnessScript, P2SH redeemScript\n-        keystore.AddCScript(scriptPubKey);\n+        BOOST_CHECK(keystore.AddCScript(scriptPubKey));\n         result = IsMine(keystore, scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n     }\n@@ -671,22 +671,22 @@ BOOST_AUTO_TEST_CASE(script_standard_IsMine)\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has witnessScript and P2SH redeemScript, but no keys\n-        keystore.AddCScript(redeemScript);\n-        keystore.AddCScript(witnessScript);\n+        BOOST_CHECK(keystore.AddCScript(redeemScript));\n+        BOOST_CHECK(keystore.AddCScript(witnessScript));\n         result = IsMine(keystore, scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has keys, witnessScript, P2SH redeemScript\n-        keystore.AddKey(keys[0]);\n-        keystore.AddKey(keys[1]);\n+        BOOST_CHECK(keystore.AddKey(keys[0]));\n+        BOOST_CHECK(keystore.AddKey(keys[1]));\n         result = IsMine(keystore, scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n     }\n \n     // OP_RETURN\n     {\n         CBasicKeyStore keystore;\n-        keystore.AddKey(keys[0]);\n+        BOOST_CHECK(keystore.AddKey(keys[0]));\n \n         scriptPubKey.clear();\n         scriptPubKey << OP_RETURN << ToByteVector(pubkeys[0]);\n@@ -698,7 +698,7 @@ BOOST_AUTO_TEST_CASE(script_standard_IsMine)\n     // witness unspendable\n     {\n         CBasicKeyStore keystore;\n-        keystore.AddKey(keys[0]);\n+        BOOST_CHECK(keystore.AddKey(keys[0]));\n \n         scriptPubKey.clear();\n         scriptPubKey << OP_0 << ToByteVector(ParseHex(\"aabb\"));\n@@ -710,7 +710,7 @@ BOOST_AUTO_TEST_CASE(script_standard_IsMine)\n     // witness unknown\n     {\n         CBasicKeyStore keystore;\n-        keystore.AddKey(keys[0]);\n+        BOOST_CHECK(keystore.AddKey(keys[0]));\n \n         scriptPubKey.clear();\n         scriptPubKey << OP_16 << ToByteVector(ParseHex(\"aabb\"));\n@@ -722,7 +722,7 @@ BOOST_AUTO_TEST_CASE(script_standard_IsMine)\n     // Nonstandard\n     {\n         CBasicKeyStore keystore;\n-        keystore.AddKey(keys[0]);\n+        BOOST_CHECK(keystore.AddKey(keys[0]));\n \n         scriptPubKey.clear();\n         scriptPubKey << OP_9 << OP_ADD << OP_11 << OP_EQUAL;"
      },
      {
        "sha": "1b394753efbabd59a93fcaed528f2d2591d8b2d8",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 43,
        "deletions": 21,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -1030,6 +1030,28 @@ BOOST_AUTO_TEST_CASE(script_PushData)\n     BOOST_CHECK(EvalScript(pushdata4Stack, CScript(pushdata4, pushdata4 + sizeof(pushdata4)), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n     BOOST_CHECK(pushdata4Stack == directStack);\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n+\n+    const std::vector<unsigned char> pushdata1_trunc{OP_PUSHDATA1, 1};\n+    const std::vector<unsigned char> pushdata2_trunc{OP_PUSHDATA2, 1, 0};\n+    const std::vector<unsigned char> pushdata4_trunc{OP_PUSHDATA4, 1, 0, 0, 0};\n+\n+    std::vector<std::vector<unsigned char>> stack_ignore;\n+    BOOST_CHECK(!EvalScript(stack_ignore, CScript(pushdata1_trunc.begin(), pushdata1_trunc.end()), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n+    BOOST_CHECK_EQUAL(err, SCRIPT_ERR_BAD_OPCODE);\n+    BOOST_CHECK(!EvalScript(stack_ignore, CScript(pushdata2_trunc.begin(), pushdata2_trunc.end()), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n+    BOOST_CHECK_EQUAL(err, SCRIPT_ERR_BAD_OPCODE);\n+    BOOST_CHECK(!EvalScript(stack_ignore, CScript(pushdata4_trunc.begin(), pushdata4_trunc.end()), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n+    BOOST_CHECK_EQUAL(err, SCRIPT_ERR_BAD_OPCODE);\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_cltv_truncated)\n+{\n+    const auto script_cltv_trunc = CScript() << OP_CHECKLOCKTIMEVERIFY;\n+\n+    std::vector<std::vector<unsigned char>> stack_ignore;\n+    ScriptError err;\n+    BOOST_CHECK(!EvalScript(stack_ignore, script_cltv_trunc, SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, BaseSignatureChecker(), SigVersion::BASE, &err));\n+    BOOST_CHECK_EQUAL(err, SCRIPT_ERR_INVALID_STACK_OPERATION);\n }\n \n static CScript\n@@ -1078,18 +1100,18 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG12)\n     const CTransaction txFrom12{BuildCreditingTransaction(scriptPubKey12)};\n     CMutableTransaction txTo12 = BuildSpendingTransaction(CScript(), CScriptWitness(), txFrom12);\n \n-    CScript goodsig1 = sign_multisig(scriptPubKey12, key1, txTo12);\n+    CScript goodsig1 = sign_multisig(scriptPubKey12, key1, CTransaction(txTo12));\n     BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey12, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n     txTo12.vout[0].nValue = 2;\n     BOOST_CHECK(!VerifyScript(goodsig1, scriptPubKey12, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n-    CScript goodsig2 = sign_multisig(scriptPubKey12, key2, txTo12);\n+    CScript goodsig2 = sign_multisig(scriptPubKey12, key2, CTransaction(txTo12));\n     BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey12, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n-    CScript badsig1 = sign_multisig(scriptPubKey12, key3, txTo12);\n+    CScript badsig1 = sign_multisig(scriptPubKey12, key3, CTransaction(txTo12));\n     BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey12, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n }\n@@ -1111,54 +1133,54 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n \n     std::vector<CKey> keys;\n     keys.push_back(key1); keys.push_back(key2);\n-    CScript goodsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n+    CScript goodsig1 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n     BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key1); keys.push_back(key3);\n-    CScript goodsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n+    CScript goodsig2 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n     BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key3);\n-    CScript goodsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n+    CScript goodsig3 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n     BOOST_CHECK(VerifyScript(goodsig3, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key2); // Can't re-use sig\n-    CScript badsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n+    CScript badsig1 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n     BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key1); // sigs must be in correct order\n-    CScript badsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n+    CScript badsig2 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n     BOOST_CHECK(!VerifyScript(badsig2, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key3); keys.push_back(key2); // sigs must be in correct order\n-    CScript badsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n+    CScript badsig3 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n     BOOST_CHECK(!VerifyScript(badsig3, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key4); keys.push_back(key2); // sigs must match pubkeys\n-    CScript badsig4 = sign_multisig(scriptPubKey23, keys, txTo23);\n+    CScript badsig4 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n     BOOST_CHECK(!VerifyScript(badsig4, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key1); keys.push_back(key4); // sigs must match pubkeys\n-    CScript badsig5 = sign_multisig(scriptPubKey23, keys, txTo23);\n+    CScript badsig5 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n     BOOST_CHECK(!VerifyScript(badsig5, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear(); // Must have signatures\n-    CScript badsig6 = sign_multisig(scriptPubKey23, keys, txTo23);\n+    CScript badsig6 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n     BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_INVALID_STACK_OPERATION, ScriptErrorString(err));\n }\n@@ -1185,11 +1207,11 @@ BOOST_AUTO_TEST_CASE(script_combineSigs)\n         key.MakeNewKey(i%2 == 1);\n         keys.push_back(key);\n         pubkeys.push_back(key.GetPubKey());\n-        keystore.AddKey(key);\n+        BOOST_CHECK(keystore.AddKey(key));\n     }\n \n     CMutableTransaction txFrom = BuildCreditingTransaction(GetScriptForDestination(keys[0].GetPubKey().GetID()));\n-    CMutableTransaction txTo = BuildSpendingTransaction(CScript(), CScriptWitness(), txFrom);\n+    CMutableTransaction txTo = BuildSpendingTransaction(CScript(), CScriptWitness(), CTransaction(txFrom));\n     CScript& scriptPubKey = txFrom.vout[0].scriptPubKey;\n     SignatureData scriptSig;\n \n@@ -1198,39 +1220,39 @@ BOOST_AUTO_TEST_CASE(script_combineSigs)\n     BOOST_CHECK(combined.scriptSig.empty());\n \n     // Single signature case:\n-    SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL); // changes scriptSig\n+    BOOST_CHECK(SignSignature(keystore, CTransaction(txFrom), txTo, 0, SIGHASH_ALL)); // changes scriptSig\n     scriptSig = DataFromTransaction(txTo, 0, txFrom.vout[0]);\n     combined = CombineSignatures(txFrom.vout[0], txTo, scriptSig, empty);\n     BOOST_CHECK(combined.scriptSig == scriptSig.scriptSig);\n     combined = CombineSignatures(txFrom.vout[0], txTo, empty, scriptSig);\n     BOOST_CHECK(combined.scriptSig == scriptSig.scriptSig);\n     SignatureData scriptSigCopy = scriptSig;\n     // Signing again will give a different, valid signature:\n-    SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL);\n+    BOOST_CHECK(SignSignature(keystore, CTransaction(txFrom), txTo, 0, SIGHASH_ALL));\n     scriptSig = DataFromTransaction(txTo, 0, txFrom.vout[0]);\n     combined = CombineSignatures(txFrom.vout[0], txTo, scriptSigCopy, scriptSig);\n     BOOST_CHECK(combined.scriptSig == scriptSigCopy.scriptSig || combined.scriptSig == scriptSig.scriptSig);\n \n     // P2SH, single-signature case:\n     CScript pkSingle; pkSingle << ToByteVector(keys[0].GetPubKey()) << OP_CHECKSIG;\n-    keystore.AddCScript(pkSingle);\n+    BOOST_CHECK(keystore.AddCScript(pkSingle));\n     scriptPubKey = GetScriptForDestination(CScriptID(pkSingle));\n-    SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL);\n+    BOOST_CHECK(SignSignature(keystore, CTransaction(txFrom), txTo, 0, SIGHASH_ALL));\n     scriptSig = DataFromTransaction(txTo, 0, txFrom.vout[0]);\n     combined = CombineSignatures(txFrom.vout[0], txTo, scriptSig, empty);\n     BOOST_CHECK(combined.scriptSig == scriptSig.scriptSig);\n     combined = CombineSignatures(txFrom.vout[0], txTo, empty, scriptSig);\n     BOOST_CHECK(combined.scriptSig == scriptSig.scriptSig);\n     scriptSigCopy = scriptSig;\n-    SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL);\n+    BOOST_CHECK(SignSignature(keystore, CTransaction(txFrom), txTo, 0, SIGHASH_ALL));\n     scriptSig = DataFromTransaction(txTo, 0, txFrom.vout[0]);\n     combined = CombineSignatures(txFrom.vout[0], txTo, scriptSigCopy, scriptSig);\n     BOOST_CHECK(combined.scriptSig == scriptSigCopy.scriptSig || combined.scriptSig == scriptSig.scriptSig);\n \n     // Hardest case:  Multisig 2-of-3\n     scriptPubKey = GetScriptForMultisig(2, pubkeys);\n-    keystore.AddCScript(scriptPubKey);\n-    SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL);\n+    BOOST_CHECK(keystore.AddCScript(scriptPubKey));\n+    BOOST_CHECK(SignSignature(keystore, CTransaction(txFrom), txTo, 0, SIGHASH_ALL));\n     scriptSig = DataFromTransaction(txTo, 0, txFrom.vout[0]);\n     combined = CombineSignatures(txFrom.vout[0], txTo, scriptSig, empty);\n     BOOST_CHECK(combined.scriptSig == scriptSig.scriptSig);"
      },
      {
        "sha": "002f61f6a28e89f703ccb5141e60692ca1c31338",
        "filename": "src/test/serialize_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/serialize_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/serialize_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/serialize_tests.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -200,7 +200,7 @@ BOOST_AUTO_TEST_CASE(varints)\n     }\n \n     for (uint64_t i = 0;  i < 100000000000ULL; i += 999999937) {\n-        uint64_t j = -1;\n+        uint64_t j = std::numeric_limits<uint64_t>::max();\n         ss >> VARINT(j);\n         BOOST_CHECK_MESSAGE(i == j, \"decoded:\" << j << \" expected:\" << i);\n     }"
      },
      {
        "sha": "04d5462acb20a06a6e06b583a617094df13a2916",
        "filename": "src/test/sighash_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/sighash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/sighash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sighash_tests.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -105,7 +105,7 @@ void static RandomTransaction(CMutableTransaction &tx, bool fSingle) {\n         txin.prevout.hash = InsecureRand256();\n         txin.prevout.n = InsecureRandBits(2);\n         RandomScript(txin.scriptSig);\n-        txin.nSequence = (InsecureRandBool()) ? InsecureRand32() : (unsigned int)-1;\n+        txin.nSequence = (InsecureRandBool()) ? InsecureRand32() : std::numeric_limits<uint32_t>::max();\n     }\n     for (int out = 0; out < outs; out++) {\n         tx.vout.push_back(CTxOut());\n@@ -137,7 +137,7 @@ BOOST_AUTO_TEST_CASE(sighash_test)\n         int nIn = InsecureRandRange(txTo.vin.size());\n \n         uint256 sh, sho;\n-        sho = SignatureHashOld(scriptCode, txTo, nIn, nHashType);\n+        sho = SignatureHashOld(scriptCode, CTransaction(txTo), nIn, nHashType);\n         sh = SignatureHash(scriptCode, txTo, nIn, nHashType, 0, SigVersion::BASE);\n         #if defined(PRINT_SIGHASH_JSON)\n         CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);"
      },
      {
        "sha": "6a0349cd4e433708945d2a6a2537428b1bcc3700",
        "filename": "src/test/sigopcount_tests.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/sigopcount_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/sigopcount_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sigopcount_tests.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -102,7 +102,7 @@ static void BuildTxs(CMutableTransaction& spendingTx, CCoinsViewCache& coins, CM\n     spendingTx.vout[0].nValue = 1;\n     spendingTx.vout[0].scriptPubKey = CScript();\n \n-    AddCoins(coins, creationTx, 0);\n+    AddCoins(coins, CTransaction(creationTx), 0);\n }\n \n BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n@@ -138,7 +138,7 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n         // is not accurate.\n         assert(GetTransactionSigOpCost(CTransaction(creationTx), coins, flags) == MAX_PUBKEYS_PER_MULTISIG * WITNESS_SCALE_FACTOR);\n         // Sanity check: script verification fails because of an invalid signature.\n-        assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n+        assert(VerifyWithFlag(CTransaction(creationTx), spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n     }\n \n     // Multisig nested in P2SH\n@@ -149,7 +149,7 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n \n         BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, CScriptWitness());\n         assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 2 * WITNESS_SCALE_FACTOR);\n-        assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n+        assert(VerifyWithFlag(CTransaction(creationTx), spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n     }\n \n     // P2WPKH witness program\n@@ -166,7 +166,7 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n         assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 1);\n         // No signature operations if we don't verify the witness.\n         assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags & ~SCRIPT_VERIFY_WITNESS) == 0);\n-        assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_EQUALVERIFY);\n+        assert(VerifyWithFlag(CTransaction(creationTx), spendingTx, flags) == SCRIPT_ERR_EQUALVERIFY);\n \n         // The sig op cost for witness version != 0 is zero.\n         assert(scriptPubKey[0] == 0x00);\n@@ -193,7 +193,7 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n \n         BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, scriptWitness);\n         assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 1);\n-        assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_EQUALVERIFY);\n+        assert(VerifyWithFlag(CTransaction(creationTx), spendingTx, flags) == SCRIPT_ERR_EQUALVERIFY);\n     }\n \n     // P2WSH witness program\n@@ -209,7 +209,7 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n         BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, scriptWitness);\n         assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 2);\n         assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags & ~SCRIPT_VERIFY_WITNESS) == 0);\n-        assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n+        assert(VerifyWithFlag(CTransaction(creationTx), spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n     }\n \n     // P2WSH nested in P2SH\n@@ -225,7 +225,7 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n \n         BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, scriptWitness);\n         assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 2);\n-        assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n+        assert(VerifyWithFlag(CTransaction(creationTx), spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n     }\n }\n "
      },
      {
        "sha": "a3201de385c30257b041ccc698fb237cd46b1e52",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 16,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -11,6 +11,7 @@\n #include <crypto/sha256.h>\n #include <miner.h>\n #include <net_processing.h>\n+#include <noui.h>\n #include <pow.h>\n #include <rpc/register.h>\n #include <rpc/server.h>\n@@ -21,6 +22,8 @@\n \n const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n \n+FastRandomContext g_insecure_rand_ctx;\n+\n void CConnmanTest::AddNode(CNode& node)\n {\n     LOCK(g_connman->cs_vNodes);\n@@ -36,12 +39,6 @@ void CConnmanTest::ClearNodes()\n     g_connman->vNodes.clear();\n }\n \n-uint256 insecure_rand_seed = GetRandHash();\n-FastRandomContext insecure_rand_ctx(insecure_rand_seed);\n-\n-extern bool fPrintToConsole;\n-extern void noui_connect();\n-\n std::ostream& operator<<(std::ostream& os, const uint256& num)\n {\n     os << num.ToString();\n@@ -118,16 +115,16 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n \n TestingSetup::~TestingSetup()\n {\n-        threadGroup.interrupt_all();\n-        threadGroup.join_all();\n-        GetMainSignals().FlushBackgroundCallbacks();\n-        GetMainSignals().UnregisterBackgroundSignalScheduler();\n-        g_connman.reset();\n-        peerLogic.reset();\n-        UnloadBlockIndex();\n-        pcoinsTip.reset();\n-        pcoinsdbview.reset();\n-        pblocktree.reset();\n+    threadGroup.interrupt_all();\n+    threadGroup.join_all();\n+    GetMainSignals().FlushBackgroundCallbacks();\n+    GetMainSignals().UnregisterBackgroundSignalScheduler();\n+    g_connman.reset();\n+    peerLogic.reset();\n+    UnloadBlockIndex();\n+    pcoinsTip.reset();\n+    pcoinsdbview.reset();\n+    pblocktree.reset();\n }\n \n TestChain100Setup::TestChain100Setup() : TestingSetup(CBaseChainParams::REGTEST)"
      },
      {
        "sha": "31d90c0151b48e233fb3b47664e000f956c18271",
        "filename": "src/test/test_bitcoin.h",
        "status": "modified",
        "additions": 24,
        "deletions": 15,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/test_bitcoin.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/test_bitcoin.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.h?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -15,27 +15,36 @@\n #include <txmempool.h>\n \n #include <memory>\n+#include <type_traits>\n \n #include <boost/thread.hpp>\n \n-extern uint256 insecure_rand_seed;\n-extern FastRandomContext insecure_rand_ctx;\n+// Enable BOOST_CHECK_EQUAL for enum class types\n+template <typename T>\n+std::ostream& operator<<(typename std::enable_if<std::is_enum<T>::value, std::ostream>::type& stream, const T& e)\n+{\n+    return stream << static_cast<typename std::underlying_type<T>::type>(e);\n+}\n+\n+/**\n+ * This global and the helpers that use it are not thread-safe.\n+ *\n+ * If thread-safety is needed, the global could be made thread_local (given\n+ * that thread_local is supported on all architectures we support) or a\n+ * per-thread instance could be used in the multi-threaded test.\n+ */\n+extern FastRandomContext g_insecure_rand_ctx;\n \n-static inline void SeedInsecureRand(bool fDeterministic = false)\n+static inline void SeedInsecureRand(bool deterministic = false)\n {\n-    if (fDeterministic) {\n-        insecure_rand_seed = uint256();\n-    } else {\n-        insecure_rand_seed = GetRandHash();\n-    }\n-    insecure_rand_ctx = FastRandomContext(insecure_rand_seed);\n+    g_insecure_rand_ctx = FastRandomContext(deterministic);\n }\n \n-static inline uint32_t InsecureRand32() { return insecure_rand_ctx.rand32(); }\n-static inline uint256 InsecureRand256() { return insecure_rand_ctx.rand256(); }\n-static inline uint64_t InsecureRandBits(int bits) { return insecure_rand_ctx.randbits(bits); }\n-static inline uint64_t InsecureRandRange(uint64_t range) { return insecure_rand_ctx.randrange(range); }\n-static inline bool InsecureRandBool() { return insecure_rand_ctx.randbool(); }\n+static inline uint32_t InsecureRand32() { return g_insecure_rand_ctx.rand32(); }\n+static inline uint256 InsecureRand256() { return g_insecure_rand_ctx.rand256(); }\n+static inline uint64_t InsecureRandBits(int bits) { return g_insecure_rand_ctx.randbits(bits); }\n+static inline uint64_t InsecureRandRange(uint64_t range) { return g_insecure_rand_ctx.randrange(range); }\n+static inline bool InsecureRandBool() { return g_insecure_rand_ctx.randbool(); }\n \n static constexpr CAmount CENT{1000000};\n \n@@ -65,7 +74,7 @@ struct CConnmanTest {\n };\n \n class PeerLogicValidation;\n-struct TestingSetup: public BasicTestingSetup {\n+struct TestingSetup : public BasicTestingSetup {\n     boost::thread_group threadGroup;\n     CConnman* connman;\n     CScheduler scheduler;"
      },
      {
        "sha": "c68b6bbb4de970cc75a4c3e44aece14cb4467e1a",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 41,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -273,11 +273,11 @@ BOOST_AUTO_TEST_CASE(basic_transaction_tests)\n     CMutableTransaction tx;\n     stream >> tx;\n     CValidationState state;\n-    BOOST_CHECK_MESSAGE(CheckTransaction(tx, state) && state.IsValid(), \"Simple deserialized transaction should be valid.\");\n+    BOOST_CHECK_MESSAGE(CheckTransaction(CTransaction(tx), state) && state.IsValid(), \"Simple deserialized transaction should be valid.\");\n \n     // Check that duplicate txins fail\n     tx.vin.push_back(tx.vin[0]);\n-    BOOST_CHECK_MESSAGE(!CheckTransaction(tx, state) || !state.IsValid(), \"Transaction with duplicate txins should be invalid.\");\n+    BOOST_CHECK_MESSAGE(!CheckTransaction(CTransaction(tx), state) || !state.IsValid(), \"Transaction with duplicate txins should be invalid.\");\n }\n \n //\n@@ -306,14 +306,14 @@ SetupDummyInputs(CBasicKeyStore& keystoreRet, CCoinsViewCache& coinsRet)\n     dummyTransactions[0].vout[0].scriptPubKey << ToByteVector(key[0].GetPubKey()) << OP_CHECKSIG;\n     dummyTransactions[0].vout[1].nValue = 50*CENT;\n     dummyTransactions[0].vout[1].scriptPubKey << ToByteVector(key[1].GetPubKey()) << OP_CHECKSIG;\n-    AddCoins(coinsRet, dummyTransactions[0], 0);\n+    AddCoins(coinsRet, CTransaction(dummyTransactions[0]), 0);\n \n     dummyTransactions[1].vout.resize(2);\n     dummyTransactions[1].vout[0].nValue = 21*CENT;\n     dummyTransactions[1].vout[0].scriptPubKey = GetScriptForDestination(key[2].GetPubKey().GetID());\n     dummyTransactions[1].vout[1].nValue = 22*CENT;\n     dummyTransactions[1].vout[1].scriptPubKey = GetScriptForDestination(key[3].GetPubKey().GetID());\n-    AddCoins(coinsRet, dummyTransactions[1], 0);\n+    AddCoins(coinsRet, CTransaction(dummyTransactions[1]), 0);\n \n     return dummyTransactions;\n }\n@@ -340,8 +340,8 @@ BOOST_AUTO_TEST_CASE(test_Get)\n     t1.vout[0].nValue = 90*CENT;\n     t1.vout[0].scriptPubKey << OP_1;\n \n-    BOOST_CHECK(AreInputsStandard(t1, coins));\n-    BOOST_CHECK_EQUAL(coins.GetValueIn(t1), (50+21+22)*CENT);\n+    BOOST_CHECK(AreInputsStandard(CTransaction(t1), coins));\n+    BOOST_CHECK_EQUAL(coins.GetValueIn(CTransaction(t1)), (50+21+22)*CENT);\n }\n \n static void CreateCreditAndSpend(const CKeyStore& keystore, const CScript& outscript, CTransactionRef& output, CMutableTransaction& input, bool success = true)\n@@ -421,7 +421,7 @@ BOOST_AUTO_TEST_CASE(test_big_witness_transaction) {\n     CKey key;\n     key.MakeNewKey(true); // Need to use compressed keys in segwit or the signing will fail\n     CBasicKeyStore keystore;\n-    keystore.AddKeyPubKey(key, key.GetPubKey());\n+    BOOST_CHECK(keystore.AddKeyPubKey(key, key.GetPubKey()));\n     CKeyID hash = key.GetPubKey().GetID();\n     CScript scriptPubKey = CScript() << OP_0 << std::vector<unsigned char>(hash.begin(), hash.end());\n \n@@ -518,10 +518,10 @@ BOOST_AUTO_TEST_CASE(test_witness)\n     pubkey3 = key3.GetPubKey();\n     pubkey1L = key1L.GetPubKey();\n     pubkey2L = key2L.GetPubKey();\n-    keystore.AddKeyPubKey(key1, pubkey1);\n-    keystore.AddKeyPubKey(key2, pubkey2);\n-    keystore.AddKeyPubKey(key1L, pubkey1L);\n-    keystore.AddKeyPubKey(key2L, pubkey2L);\n+    BOOST_CHECK(keystore.AddKeyPubKey(key1, pubkey1));\n+    BOOST_CHECK(keystore.AddKeyPubKey(key2, pubkey2));\n+    BOOST_CHECK(keystore.AddKeyPubKey(key1L, pubkey1L));\n+    BOOST_CHECK(keystore.AddKeyPubKey(key2L, pubkey2L));\n     CScript scriptPubkey1, scriptPubkey2, scriptPubkey1L, scriptPubkey2L, scriptMulti;\n     scriptPubkey1 << ToByteVector(pubkey1) << OP_CHECKSIG;\n     scriptPubkey2 << ToByteVector(pubkey2) << OP_CHECKSIG;\n@@ -531,19 +531,19 @@ BOOST_AUTO_TEST_CASE(test_witness)\n     oneandthree.push_back(pubkey1);\n     oneandthree.push_back(pubkey3);\n     scriptMulti = GetScriptForMultisig(2, oneandthree);\n-    keystore.AddCScript(scriptPubkey1);\n-    keystore.AddCScript(scriptPubkey2);\n-    keystore.AddCScript(scriptPubkey1L);\n-    keystore.AddCScript(scriptPubkey2L);\n-    keystore.AddCScript(scriptMulti);\n-    keystore.AddCScript(GetScriptForWitness(scriptPubkey1));\n-    keystore.AddCScript(GetScriptForWitness(scriptPubkey2));\n-    keystore.AddCScript(GetScriptForWitness(scriptPubkey1L));\n-    keystore.AddCScript(GetScriptForWitness(scriptPubkey2L));\n-    keystore.AddCScript(GetScriptForWitness(scriptMulti));\n-    keystore2.AddCScript(scriptMulti);\n-    keystore2.AddCScript(GetScriptForWitness(scriptMulti));\n-    keystore2.AddKeyPubKey(key3, pubkey3);\n+    BOOST_CHECK(keystore.AddCScript(scriptPubkey1));\n+    BOOST_CHECK(keystore.AddCScript(scriptPubkey2));\n+    BOOST_CHECK(keystore.AddCScript(scriptPubkey1L));\n+    BOOST_CHECK(keystore.AddCScript(scriptPubkey2L));\n+    BOOST_CHECK(keystore.AddCScript(scriptMulti));\n+    BOOST_CHECK(keystore.AddCScript(GetScriptForWitness(scriptPubkey1)));\n+    BOOST_CHECK(keystore.AddCScript(GetScriptForWitness(scriptPubkey2)));\n+    BOOST_CHECK(keystore.AddCScript(GetScriptForWitness(scriptPubkey1L)));\n+    BOOST_CHECK(keystore.AddCScript(GetScriptForWitness(scriptPubkey2L)));\n+    BOOST_CHECK(keystore.AddCScript(GetScriptForWitness(scriptMulti)));\n+    BOOST_CHECK(keystore2.AddCScript(scriptMulti));\n+    BOOST_CHECK(keystore2.AddCScript(GetScriptForWitness(scriptMulti)));\n+    BOOST_CHECK(keystore2.AddKeyPubKey(key3, pubkey3));\n \n     CTransactionRef output1, output2;\n     CMutableTransaction input1, input2;\n@@ -697,75 +697,75 @@ BOOST_AUTO_TEST_CASE(test_IsStandard)\n     t.vout[0].scriptPubKey = GetScriptForDestination(key.GetPubKey().GetID());\n \n     std::string reason;\n-    BOOST_CHECK(IsStandardTx(t, reason));\n+    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n \n     // Check dust with default relay fee:\n     CAmount nDustThreshold = 182 * dustRelayFee.GetFeePerK()/1000;\n     BOOST_CHECK_EQUAL(nDustThreshold, 546);\n     // dust:\n     t.vout[0].nValue = nDustThreshold - 1;\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n+    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n     // not dust:\n     t.vout[0].nValue = nDustThreshold;\n-    BOOST_CHECK(IsStandardTx(t, reason));\n+    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n \n     // Check dust with odd relay fee to verify rounding:\n     // nDustThreshold = 182 * 3702 / 1000\n     dustRelayFee = CFeeRate(3702);\n     // dust:\n     t.vout[0].nValue = 673 - 1;\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n+    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n     // not dust:\n     t.vout[0].nValue = 673;\n-    BOOST_CHECK(IsStandardTx(t, reason));\n+    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n     dustRelayFee = CFeeRate(DUST_RELAY_TX_FEE);\n \n     t.vout[0].scriptPubKey = CScript() << OP_1;\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n+    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n \n     // MAX_OP_RETURN_RELAY-byte TX_NULL_DATA (standard)\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef3804678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38\");\n     BOOST_CHECK_EQUAL(MAX_OP_RETURN_RELAY, t.vout[0].scriptPubKey.size());\n-    BOOST_CHECK(IsStandardTx(t, reason));\n+    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n \n     // MAX_OP_RETURN_RELAY+1-byte TX_NULL_DATA (non-standard)\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef3804678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef3800\");\n     BOOST_CHECK_EQUAL(MAX_OP_RETURN_RELAY + 1, t.vout[0].scriptPubKey.size());\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n+    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n \n     // Data payload can be encoded in any way...\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"\");\n-    BOOST_CHECK(IsStandardTx(t, reason));\n+    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"00\") << ParseHex(\"01\");\n-    BOOST_CHECK(IsStandardTx(t, reason));\n+    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n     // OP_RESERVED *is* considered to be a PUSHDATA type opcode by IsPushOnly()!\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << OP_RESERVED << -1 << 0 << ParseHex(\"01\") << 2 << 3 << 4 << 5 << 6 << 7 << 8 << 9 << 10 << 11 << 12 << 13 << 14 << 15 << 16;\n-    BOOST_CHECK(IsStandardTx(t, reason));\n+    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << 0 << ParseHex(\"01\") << 2 << ParseHex(\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n-    BOOST_CHECK(IsStandardTx(t, reason));\n+    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n \n     // ...so long as it only contains PUSHDATA's\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << OP_RETURN;\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n+    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n \n     // TX_NULL_DATA w/o PUSHDATA\n     t.vout.resize(1);\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN;\n-    BOOST_CHECK(IsStandardTx(t, reason));\n+    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n \n     // Only one TX_NULL_DATA permitted in all cases\n     t.vout.resize(2);\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38\");\n     t.vout[1].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38\");\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n+    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n \n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38\");\n     t.vout[1].scriptPubKey = CScript() << OP_RETURN;\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n+    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n \n     t.vout[0].scriptPubKey = CScript() << OP_RETURN;\n     t.vout[1].scriptPubKey = CScript() << OP_RETURN;\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n+    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "c467f2783613802824ae1f1782a4e7095315d75c",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 17,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -156,8 +156,8 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n     CScript p2wpkh_scriptPubKey = GetScriptForWitness(p2pkh_scriptPubKey);\n \n     CBasicKeyStore keystore;\n-    keystore.AddKey(coinbaseKey);\n-    keystore.AddCScript(p2pk_scriptPubKey);\n+    BOOST_CHECK(keystore.AddKey(coinbaseKey));\n+    BOOST_CHECK(keystore.AddCScript(p2pk_scriptPubKey));\n \n     // flags to test: SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, SCRIPT_VERIFY_CHECKSEQUENCE_VERIFY, SCRIPT_VERIFY_NULLDUMMY, uncompressed pubkey thing\n \n@@ -198,20 +198,20 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         CValidationState state;\n         PrecomputedTransactionData ptd_spend_tx(spend_tx);\n \n-        BOOST_CHECK(!CheckInputs(spend_tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, nullptr));\n+        BOOST_CHECK(!CheckInputs(CTransaction(spend_tx), state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, nullptr));\n \n         // If we call again asking for scriptchecks (as happens in\n         // ConnectBlock), we should add a script check object for this -- we're\n         // not caching invalidity (if that changes, delete this test case).\n         std::vector<CScriptCheck> scriptchecks;\n-        BOOST_CHECK(CheckInputs(spend_tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, &scriptchecks));\n+        BOOST_CHECK(CheckInputs(CTransaction(spend_tx), state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, &scriptchecks));\n         BOOST_CHECK_EQUAL(scriptchecks.size(), 1U);\n \n         // Test that CheckInputs returns true iff DERSIG-enforcing flags are\n         // not present.  Don't add these checks to the cache, so that we can\n         // test later that block validation works fine in the absence of cached\n         // successes.\n-        ValidateCheckInputsForAllFlags(spend_tx, SCRIPT_VERIFY_DERSIG | SCRIPT_VERIFY_LOW_S | SCRIPT_VERIFY_STRICTENC, false);\n+        ValidateCheckInputsForAllFlags(CTransaction(spend_tx), SCRIPT_VERIFY_DERSIG | SCRIPT_VERIFY_LOW_S | SCRIPT_VERIFY_STRICTENC, false);\n     }\n \n     // And if we produce a block with this tx, it should be valid (DERSIG not\n@@ -238,7 +238,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         std::vector<unsigned char> vchSig2(p2pk_scriptPubKey.begin(), p2pk_scriptPubKey.end());\n         invalid_under_p2sh_tx.vin[0].scriptSig << vchSig2;\n \n-        ValidateCheckInputsForAllFlags(invalid_under_p2sh_tx, SCRIPT_VERIFY_P2SH, true);\n+        ValidateCheckInputsForAllFlags(CTransaction(invalid_under_p2sh_tx), SCRIPT_VERIFY_P2SH, true);\n     }\n \n     // Test CHECKLOCKTIMEVERIFY\n@@ -261,13 +261,13 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         vchSig.push_back((unsigned char)SIGHASH_ALL);\n         invalid_with_cltv_tx.vin[0].scriptSig = CScript() << vchSig << 101;\n \n-        ValidateCheckInputsForAllFlags(invalid_with_cltv_tx, SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true);\n+        ValidateCheckInputsForAllFlags(CTransaction(invalid_with_cltv_tx), SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true);\n \n         // Make it valid, and check again\n         invalid_with_cltv_tx.vin[0].scriptSig = CScript() << vchSig << 100;\n         CValidationState state;\n         PrecomputedTransactionData txdata(invalid_with_cltv_tx);\n-        BOOST_CHECK(CheckInputs(invalid_with_cltv_tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true, true, txdata, nullptr));\n+        BOOST_CHECK(CheckInputs(CTransaction(invalid_with_cltv_tx), state, pcoinsTip.get(), true, SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true, true, txdata, nullptr));\n     }\n \n     // TEST CHECKSEQUENCEVERIFY\n@@ -289,13 +289,13 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         vchSig.push_back((unsigned char)SIGHASH_ALL);\n         invalid_with_csv_tx.vin[0].scriptSig = CScript() << vchSig << 101;\n \n-        ValidateCheckInputsForAllFlags(invalid_with_csv_tx, SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true);\n+        ValidateCheckInputsForAllFlags(CTransaction(invalid_with_csv_tx), SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true);\n \n         // Make it valid, and check again\n         invalid_with_csv_tx.vin[0].scriptSig = CScript() << vchSig << 100;\n         CValidationState state;\n         PrecomputedTransactionData txdata(invalid_with_csv_tx);\n-        BOOST_CHECK(CheckInputs(invalid_with_csv_tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true, true, txdata, nullptr));\n+        BOOST_CHECK(CheckInputs(CTransaction(invalid_with_csv_tx), state, pcoinsTip.get(), true, SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true, true, txdata, nullptr));\n     }\n \n     // TODO: add tests for remaining script flags\n@@ -314,15 +314,15 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n \n         // Sign\n         SignatureData sigdata;\n-        ProduceSignature(keystore, MutableTransactionSignatureCreator(&valid_with_witness_tx, 0, 11*CENT, SIGHASH_ALL), spend_tx.vout[1].scriptPubKey, sigdata);\n+        BOOST_CHECK(ProduceSignature(keystore, MutableTransactionSignatureCreator(&valid_with_witness_tx, 0, 11*CENT, SIGHASH_ALL), spend_tx.vout[1].scriptPubKey, sigdata));\n         UpdateInput(valid_with_witness_tx.vin[0], sigdata);\n \n         // This should be valid under all script flags.\n-        ValidateCheckInputsForAllFlags(valid_with_witness_tx, 0, true);\n+        ValidateCheckInputsForAllFlags(CTransaction(valid_with_witness_tx), 0, true);\n \n         // Remove the witness, and check that it is now invalid.\n         valid_with_witness_tx.vin[0].scriptWitness.SetNull();\n-        ValidateCheckInputsForAllFlags(valid_with_witness_tx, SCRIPT_VERIFY_WITNESS, true);\n+        ValidateCheckInputsForAllFlags(CTransaction(valid_with_witness_tx), SCRIPT_VERIFY_WITNESS, true);\n     }\n \n     {\n@@ -342,12 +342,12 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         // Sign\n         for (int i=0; i<2; ++i) {\n             SignatureData sigdata;\n-            ProduceSignature(keystore, MutableTransactionSignatureCreator(&tx, i, 11*CENT, SIGHASH_ALL), spend_tx.vout[i].scriptPubKey, sigdata);\n+            BOOST_CHECK(ProduceSignature(keystore, MutableTransactionSignatureCreator(&tx, i, 11*CENT, SIGHASH_ALL), spend_tx.vout[i].scriptPubKey, sigdata));\n             UpdateInput(tx.vin[i], sigdata);\n         }\n \n         // This should be valid under all script flags\n-        ValidateCheckInputsForAllFlags(tx, 0, true);\n+        ValidateCheckInputsForAllFlags(CTransaction(tx), 0, true);\n \n         // Check that if the second input is invalid, but the first input is\n         // valid, the transaction is not cached.\n@@ -357,12 +357,12 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         CValidationState state;\n         PrecomputedTransactionData txdata(tx);\n         // This transaction is now invalid under segwit, because of the second input.\n-        BOOST_CHECK(!CheckInputs(tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, nullptr));\n+        BOOST_CHECK(!CheckInputs(CTransaction(tx), state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, nullptr));\n \n         std::vector<CScriptCheck> scriptchecks;\n         // Make sure this transaction was not cached (ie because the first\n         // input was valid)\n-        BOOST_CHECK(CheckInputs(tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, &scriptchecks));\n+        BOOST_CHECK(CheckInputs(CTransaction(tx), state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, &scriptchecks));\n         // Should get 2 script checks back -- caching is on a whole-transaction basis.\n         BOOST_CHECK_EQUAL(scriptchecks.size(), 2U);\n     }"
      },
      {
        "sha": "62dfed6c41fed0113b75ebeb1b2a367a95857b9f",
        "filename": "src/test/validation_block_tests.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 7,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/validation_block_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/test/validation_block_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_block_tests.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -104,8 +104,8 @@ void BuildChain(const uint256& root, int height, const unsigned int invalid_rate\n {\n     if (height <= 0 || blocks.size() >= max_size) return;\n \n-    bool gen_invalid = GetRand(100) < invalid_rate;\n-    bool gen_fork = GetRand(100) < branch_rate;\n+    bool gen_invalid = InsecureRandRange(100) < invalid_rate;\n+    bool gen_fork = InsecureRandRange(100) < branch_rate;\n \n     const std::shared_ptr<const CBlock> pblock = gen_invalid ? BadBlock(root) : GoodBlock(root);\n     blocks.push_back(pblock);\n@@ -137,7 +137,7 @@ BOOST_AUTO_TEST_CASE(processnewblock_signals_ordering)\n     BOOST_CHECK(ProcessNewBlockHeaders(headers, state, Params()));\n \n     // Connect the genesis block and drain any outstanding events\n-    ProcessNewBlock(Params(), std::make_shared<CBlock>(Params().GenesisBlock()), true, &ignored);\n+    BOOST_CHECK(ProcessNewBlock(Params(), std::make_shared<CBlock>(Params().GenesisBlock()), true, &ignored));\n     SyncWithValidationInterfaceQueue();\n \n     // subscribe to events (this subscriber will validate event ordering)\n@@ -152,12 +152,13 @@ BOOST_AUTO_TEST_CASE(processnewblock_signals_ordering)\n     // create a bunch of threads that repeatedly process a block generated above at random\n     // this will create parallelism and randomness inside validation - the ValidationInterface\n     // will subscribe to events generated during block validation and assert on ordering invariance\n-    boost::thread_group threads;\n+    std::vector<std::thread> threads;\n     for (int i = 0; i < 10; i++) {\n-        threads.create_thread([&blocks]() {\n+        threads.emplace_back([&blocks]() {\n             bool ignored;\n+            FastRandomContext insecure;\n             for (int i = 0; i < 1000; i++) {\n-                auto block = blocks[GetRand(blocks.size() - 1)];\n+                auto block = blocks[insecure.randrange(blocks.size() - 1)];\n                 ProcessNewBlock(Params(), block, true, &ignored);\n             }\n \n@@ -171,7 +172,9 @@ BOOST_AUTO_TEST_CASE(processnewblock_signals_ordering)\n         });\n     }\n \n-    threads.join_all();\n+    for (auto& t : threads) {\n+        t.join();\n+    }\n     while (GetMainSignals().CallbacksPending() > 0) {\n         MilliSleep(100);\n     }"
      },
      {
        "sha": "97e0cfa015fc2249bde549d0d5bba238233268e3",
        "filename": "src/uint256.h",
        "status": "modified",
        "additions": 0,
        "deletions": 11,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/uint256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/uint256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/uint256.h?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -12,7 +12,6 @@\n #include <stdint.h>\n #include <string>\n #include <vector>\n-#include <crypto/common.h>\n \n /** Template base class for fixed-sized opaque blobs. */\n template<unsigned int BITS>\n@@ -123,16 +122,6 @@ class uint256 : public base_blob<256> {\n public:\n     uint256() {}\n     explicit uint256(const std::vector<unsigned char>& vch) : base_blob<256>(vch) {}\n-\n-    /** A cheap hash function that just returns 64 bits from the result, it can be\n-     * used when the contents are considered uniformly random. It is not appropriate\n-     * when the value can easily be influenced from outside as e.g. a network adversary could\n-     * provide values to trigger worst-case behavior.\n-     */\n-    uint64_t GetCheapHash() const\n-    {\n-        return ReadLE64(data);\n-    }\n };\n \n /* uint256 from const char *."
      },
      {
        "sha": "5696684ed642c02feefebd18ce044ce3c07bbc56",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 17,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -2487,7 +2487,7 @@ CBlockIndex* CChainState::FindMostWorkChain() {\n         CBlockIndex *pindexTest = pindexNew;\n         bool fInvalidAncestor = false;\n         while (pindexTest && !chainActive.Contains(pindexTest)) {\n-            assert(pindexTest->nChainTx || pindexTest->nHeight == 0);\n+            assert(pindexTest->HaveTxsDownloaded() || pindexTest->nHeight == 0);\n \n             // Pruned nodes may have entries in setBlockIndexCandidates for\n             // which block files have been deleted.  Remove those as candidates\n@@ -2777,7 +2777,7 @@ bool CChainState::PreciousBlock(CValidationState& state, const CChainParams& par\n             // call preciousblock 2**31-1 times on the same set of tips...\n             nBlockReverseSequenceId--;\n         }\n-        if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) && pindex->nChainTx) {\n+        if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) && pindex->HaveTxsDownloaded()) {\n             setBlockIndexCandidates.insert(pindex);\n             PruneBlockIndexCandidates();\n         }\n@@ -2838,7 +2838,7 @@ bool CChainState::InvalidateBlock(CValidationState& state, const CChainParams& c\n     // add it again.\n     BlockMap::iterator it = mapBlockIndex.begin();\n     while (it != mapBlockIndex.end()) {\n-        if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->nChainTx && !setBlockIndexCandidates.value_comp()(it->second, chainActive.Tip())) {\n+        if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->HaveTxsDownloaded() && !setBlockIndexCandidates.value_comp()(it->second, chainActive.Tip())) {\n             setBlockIndexCandidates.insert(it->second);\n         }\n         it++;\n@@ -2868,7 +2868,7 @@ void CChainState::ResetBlockFailureFlags(CBlockIndex *pindex) {\n         if (!it->second->IsValid() && it->second->GetAncestor(nHeight) == pindex) {\n             it->second->nStatus &= ~BLOCK_FAILED_MASK;\n             setDirtyBlockIndex.insert(it->second);\n-            if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->nChainTx && setBlockIndexCandidates.value_comp()(chainActive.Tip(), it->second)) {\n+            if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->HaveTxsDownloaded() && setBlockIndexCandidates.value_comp()(chainActive.Tip(), it->second)) {\n                 setBlockIndexCandidates.insert(it->second);\n             }\n             if (it->second == pindexBestInvalid) {\n@@ -2946,7 +2946,7 @@ void CChainState::ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pi\n     pindexNew->RaiseValidity(BLOCK_VALID_TRANSACTIONS);\n     setDirtyBlockIndex.insert(pindexNew);\n \n-    if (pindexNew->pprev == nullptr || pindexNew->pprev->nChainTx) {\n+    if (pindexNew->pprev == nullptr || pindexNew->pprev->HaveTxsDownloaded()) {\n         // If pindexNew is the genesis block or all parents are BLOCK_VALID_TRANSACTIONS.\n         std::deque<CBlockIndex*> queue;\n         queue.push_back(pindexNew);\n@@ -3267,6 +3267,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     // Start enforcing BIP113 (Median Time Past) using versionbits logic.\n     int nLockTimeFlags = 0;\n     if (VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_CSV, versionbitscache) == ThresholdState::ACTIVE) {\n+        assert(pindexPrev != nullptr);\n         nLockTimeFlags |= LOCKTIME_MEDIAN_TIME_PAST;\n     }\n \n@@ -3530,12 +3531,14 @@ bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<cons\n         CBlockIndex *pindex = nullptr;\n         if (fNewBlock) *fNewBlock = false;\n         CValidationState state;\n-        // Ensure that CheckBlock() passes before calling AcceptBlock, as\n-        // belt-and-suspenders.\n-        bool ret = CheckBlock(*pblock, state, chainparams.GetConsensus());\n \n+        // CheckBlock() does not support multi-threaded block validation because CBlock::fChecked can cause data race.\n+        // Therefore, the following critical section must include the CheckBlock() call as well.\n         LOCK(cs_main);\n \n+        // Ensure that CheckBlock() passes before calling AcceptBlock, as\n+        // belt-and-suspenders.\n+        bool ret = CheckBlock(*pblock, state, chainparams.GetConsensus());\n         if (ret) {\n             // Store to disk\n             ret = g_chainstate.AcceptBlock(pblock, state, chainparams, &pindex, fForceProcessing, nullptr, fNewBlock);\n@@ -3817,8 +3820,6 @@ bool CChainState::LoadBlockIndex(const Consensus::Params& consensus_params, CBlo\n     if (!blocktree.LoadBlockIndexGuts(consensus_params, [this](const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main) { return this->InsertBlockIndex(hash); }))\n         return false;\n \n-    boost::this_thread::interruption_point();\n-\n     // Calculate nChainWork\n     std::vector<std::pair<int, CBlockIndex*> > vSortedByHeight;\n     vSortedByHeight.reserve(mapBlockIndex.size());\n@@ -3837,7 +3838,7 @@ bool CChainState::LoadBlockIndex(const Consensus::Params& consensus_params, CBlo\n         // Pruned nodes may have deleted the block.\n         if (pindex->nTx > 0) {\n             if (pindex->pprev) {\n-                if (pindex->pprev->nChainTx) {\n+                if (pindex->pprev->HaveTxsDownloaded()) {\n                     pindex->nChainTx = pindex->pprev->nChainTx + pindex->nTx;\n                 } else {\n                     pindex->nChainTx = 0;\n@@ -3851,7 +3852,7 @@ bool CChainState::LoadBlockIndex(const Consensus::Params& consensus_params, CBlo\n             pindex->nStatus |= BLOCK_FAILED_CHILD;\n             setDirtyBlockIndex.insert(pindex);\n         }\n-        if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) && (pindex->nChainTx || pindex->pprev == nullptr))\n+        if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) && (pindex->HaveTxsDownloaded() || pindex->pprev == nullptr))\n             setBlockIndexCandidates.insert(pindex);\n         if (pindex->nStatus & BLOCK_FAILED_MASK && (!pindexBestInvalid || pindex->nChainWork > pindexBestInvalid->nChainWork))\n             pindexBestInvalid = pindex;\n@@ -4220,7 +4221,7 @@ bool CChainState::RewindBlockIndex(const CChainParams& params)\n                     ++ret.first;\n                 }\n             }\n-        } else if (pindexIter->IsValid(BLOCK_VALID_TRANSACTIONS) && pindexIter->nChainTx) {\n+        } else if (pindexIter->IsValid(BLOCK_VALID_TRANSACTIONS) && pindexIter->HaveTxsDownloaded()) {\n             setBlockIndexCandidates.insert(pindexIter);\n         }\n     }\n@@ -4521,7 +4522,7 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n             assert(pindex->GetBlockHash() == consensusParams.hashGenesisBlock); // Genesis block's hash must match.\n             assert(pindex == chainActive.Genesis()); // The current active chain's genesis block must be this block.\n         }\n-        if (pindex->nChainTx == 0) assert(pindex->nSequenceId <= 0);  // nSequenceId can't be set positive for blocks that aren't linked (negative is used for preciousblock)\n+        if (!pindex->HaveTxsDownloaded()) assert(pindex->nSequenceId <= 0); // nSequenceId can't be set positive for blocks that aren't linked (negative is used for preciousblock)\n         // VALID_TRANSACTIONS is equivalent to nTx > 0 for all nodes (whether or not pruning has occurred).\n         // HAVE_DATA is only equivalent to nTx > 0 (or VALID_TRANSACTIONS) if no pruning has occurred.\n         if (!fHavePruned) {\n@@ -4534,9 +4535,9 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n         }\n         if (pindex->nStatus & BLOCK_HAVE_UNDO) assert(pindex->nStatus & BLOCK_HAVE_DATA);\n         assert(((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_TRANSACTIONS) == (pindex->nTx > 0)); // This is pruning-independent.\n-        // All parents having had data (at some point) is equivalent to all parents being VALID_TRANSACTIONS, which is equivalent to nChainTx being set.\n-        assert((pindexFirstNeverProcessed != nullptr) == (pindex->nChainTx == 0)); // nChainTx != 0 is used to signal that all parent blocks have been processed (but may have been pruned).\n-        assert((pindexFirstNotTransactionsValid != nullptr) == (pindex->nChainTx == 0));\n+        // All parents having had data (at some point) is equivalent to all parents being VALID_TRANSACTIONS, which is equivalent to HaveTxsDownloaded().\n+        assert((pindexFirstNeverProcessed == nullptr) == pindex->HaveTxsDownloaded());\n+        assert((pindexFirstNotTransactionsValid == nullptr) == pindex->HaveTxsDownloaded());\n         assert(pindex->nHeight == nHeight); // nHeight must be consistent.\n         assert(pindex->pprev == nullptr || pindex->nChainWork >= pindex->pprev->nChainWork); // For every block except the genesis block, the chainwork must be larger than the parent's.\n         assert(nHeight < 2 || (pindex->pskip && (pindex->pskip->nHeight < nHeight))); // The pskip pointer must point back for all but the first 2 blocks."
      },
      {
        "sha": "b5548a9293440045721ca850b5b4f2daab5dbef9",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -12,6 +12,7 @@\n \n #include <amount.h>\n #include <coins.h>\n+#include <crypto/common.h> // for ReadLE64\n #include <fs.h>\n #include <protocol.h> // For CMessageHeader::MessageStartChars\n #include <policy/feerate.h>\n@@ -138,7 +139,10 @@ static const int DEFAULT_STOPATHEIGHT = 0;\n \n struct BlockHasher\n {\n-    size_t operator()(const uint256& hash) const { return hash.GetCheapHash(); }\n+    // this used to call `GetCheapHash()` in uint256, which was later moved; the\n+    // cheap hash function simply calls ReadLE64() however, so the end result is\n+    // identical\n+    size_t operator()(const uint256& hash) const { return ReadLE64(hash.begin()); }\n };\n \n extern CScript COINBASE_FLAGS;"
      },
      {
        "sha": "8a37f374a1e54d8f09fcfd21ee82fdcd481b42c8",
        "filename": "src/wallet/coinselection.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/wallet/coinselection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/wallet/coinselection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -223,7 +223,7 @@ bool KnapsackSolver(const CAmount& nTargetValue, std::vector<OutputGroup>& group\n     std::vector<OutputGroup> applicable_groups;\n     CAmount nTotalLower = 0;\n \n-    random_shuffle(groups.begin(), groups.end(), GetRandInt);\n+    Shuffle(groups.begin(), groups.end(), FastRandomContext());\n \n     for (const OutputGroup& group : groups) {\n         if (group.m_value == nTargetValue) {"
      },
      {
        "sha": "98e2abbd18677bed67ebd937b98ec2585c930250",
        "filename": "src/wallet/db.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/wallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/wallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -709,7 +709,7 @@ void BerkeleyEnvironment::Flush(bool fShutdown)\n {\n     int64_t nStart = GetTimeMillis();\n     // Flush log data to the actual data file on all files that are not in use\n-    LogPrint(BCLog::DB, \"BerkeleyEnvironment::Flush: Flush(%s)%s\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" database not started\");\n+    LogPrint(BCLog::DB, \"BerkeleyEnvironment::Flush: [%s] Flush(%s)%s\\n\", strPath, fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" database not started\");\n     if (!fDbEnvInit)\n         return;\n     {"
      },
      {
        "sha": "647af3eb8660a31f0eeba2d728a64ecc76e93e90",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 84,
        "changes": 136,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -110,18 +110,14 @@ UniValue importprivkey(const JSONRPCRequest& request)\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n         throw std::runtime_error(\n             RPCHelpMan{\"importprivkey\",\n-                \"\\nAdds a private key (as returned by dumpprivkey) to your wallet. Requires a new wallet backup.\\n\",\n+                \"\\nAdds a private key (as returned by dumpprivkey) to your wallet. Requires a new wallet backup.\\n\"\n+                \"Hint: use importmulti to import more than one private key.\\n\",\n                 {\n-                    {\"privkey\", RPCArg::Type::STR, false},\n-                    {\"label\", RPCArg::Type::STR, true},\n-                    {\"rescan\", RPCArg::Type::BOOL, true},\n+                    {\"privkey\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The private key (see dumpprivkey)\"},\n+                    {\"label\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"current label if address exists, otherwise \\\"\\\"\", \"An optional label\"},\n+                    {\"rescan\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"true\", \"Rescan the wallet for transactions\"},\n                 }}\n                 .ToString() +\n-            \"Hint: use importmulti to import more than one private key.\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"privkey\\\"          (string, required) The private key (see dumpprivkey)\\n\"\n-            \"2. \\\"label\\\"            (string, optional, default=current label if address exists, otherwise \\\"\\\") An optional label\\n\"\n-            \"3. rescan               (boolean, optional, default=true) Rescan the wallet for transactions\\n\"\n             \"\\nNote: This call can take over an hour to complete if rescan is true, during that time, other rpc calls\\n\"\n             \"may report that the imported key exists but related transactions are still missing, leading to temporarily incorrect/bogus balances and unspent outputs until rescan completes.\\n\"\n             \"\\nExamples:\\n\"\n@@ -278,17 +274,12 @@ UniValue importaddress(const JSONRPCRequest& request)\n             RPCHelpMan{\"importaddress\",\n                 \"\\nAdds an address or script (in hex) that can be watched as if it were in your wallet but cannot be used to spend. Requires a new wallet backup.\\n\",\n                 {\n-                    {\"address\", RPCArg::Type::STR, false},\n-                    {\"label\", RPCArg::Type::STR, true},\n-                    {\"rescan\", RPCArg::Type::BOOL, true},\n-                    {\"p2sh\", RPCArg::Type::BOOL, true},\n+                    {\"address\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The Bitcoin address (or hex-encoded script)\"},\n+                    {\"label\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"\\\"\\\"\", \"An optional label\"},\n+                    {\"rescan\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"true\", \"Rescan the wallet for transactions\"},\n+                    {\"p2sh\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"Add the P2SH version of the script as well\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"address\\\"          (string, required) The Bitcoin address (or hex-encoded script)\\n\"\n-            \"2. \\\"label\\\"            (string, optional, default=\\\"\\\") An optional label\\n\"\n-            \"3. rescan               (boolean, optional, default=true) Rescan the wallet for transactions\\n\"\n-            \"4. p2sh                 (boolean, optional, default=false) Add the P2SH version of the script as well\\n\"\n             \"\\nNote: This call can take over an hour to complete if rescan is true, during that time, other rpc calls\\n\"\n             \"may report that the imported address exists but related transactions are still missing, leading to temporarily incorrect/bogus balances and unspent outputs until rescan completes.\\n\"\n             \"If you have the full public key, you should call importpubkey instead of this.\\n\"\n@@ -365,13 +356,10 @@ UniValue importprunedfunds(const JSONRPCRequest& request)\n             RPCHelpMan{\"importprunedfunds\",\n                 \"\\nImports funds without rescan. Corresponding address or script must previously be included in wallet. Aimed towards pruned wallets. The end-user is responsible to import additional transactions that subsequently spend the imported outputs or rescan after the point in the blockchain the transaction is included.\\n\",\n                 {\n-                    {\"rawtransaction\", RPCArg::Type::STR_HEX, false},\n-                    {\"txoutproof\", RPCArg::Type::STR_HEX, false},\n+                    {\"rawtransaction\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"A raw transaction in hex funding an already-existing address in wallet\"},\n+                    {\"txoutproof\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"The hex output from gettxoutproof that contains the transaction\"},\n                 }}\n-                .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"rawtransaction\\\" (string, required) A raw transaction in hex funding an already-existing address in wallet\\n\"\n-            \"2. \\\"txoutproof\\\"     (string, required) The hex output from gettxoutproof that contains the transaction\\n\"\n+                .ToString()\n         );\n \n     CMutableTransaction tx;\n@@ -434,11 +422,9 @@ UniValue removeprunedfunds(const JSONRPCRequest& request)\n             RPCHelpMan{\"removeprunedfunds\",\n                 \"\\nDeletes the specified transaction from the wallet. Meant for use with pruned wallets and as a companion to importprunedfunds. This will affect wallet balances.\\n\",\n                 {\n-                    {\"txid\", RPCArg::Type::STR_HEX, false},\n+                    {\"txid\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"The hex-encoded id of the transaction you are deleting\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"txid\\\"           (string, required) The hex-encoded id of the transaction you are deleting\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"removeprunedfunds\", \"\\\"a8d0c0184dde994a09ec054286f1ce581bebf46446a512166eae7628734ea0a5\\\"\") +\n             \"\\nAs a JSON-RPC call\\n\"\n@@ -477,15 +463,11 @@ UniValue importpubkey(const JSONRPCRequest& request)\n             RPCHelpMan{\"importpubkey\",\n                 \"\\nAdds a public key (in hex) that can be watched as if it were in your wallet but cannot be used to spend. Requires a new wallet backup.\\n\",\n                 {\n-                    {\"pubkey\", RPCArg::Type::STR, false},\n-                    {\"label\", RPCArg::Type::STR, true},\n-                    {\"rescan\", RPCArg::Type::BOOL, true},\n+                    {\"pubkey\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The hex-encoded public key\"},\n+                    {\"label\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"\\\"\\\"\", \"An optional label\"},\n+                    {\"rescan\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"true\", \"Rescan the wallet for transactions\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"pubkey\\\"           (string, required) The hex-encoded public key\\n\"\n-            \"2. \\\"label\\\"            (string, optional, default=\\\"\\\") An optional label\\n\"\n-            \"3. rescan               (boolean, optional, default=true) Rescan the wallet for transactions\\n\"\n             \"\\nNote: This call can take over an hour to complete if rescan is true, during that time, other rpc calls\\n\"\n             \"may report that the imported pubkey exists but related transactions are still missing, leading to temporarily incorrect/bogus balances and unspent outputs until rescan completes.\\n\"\n             \"\\nExamples:\\n\"\n@@ -555,11 +537,9 @@ UniValue importwallet(const JSONRPCRequest& request)\n             RPCHelpMan{\"importwallet\",\n                 \"\\nImports keys from a wallet dump file (see dumpwallet). Requires a new wallet backup to include imported keys.\\n\",\n                 {\n-                    {\"filename\", RPCArg::Type::STR, false},\n+                    {\"filename\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The wallet file\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"filename\\\"    (string, required) The wallet file\\n\"\n             \"\\nExamples:\\n\"\n             \"\\nDump the wallet\\n\"\n             + HelpExampleCli(\"dumpwallet\", \"\\\"test\\\"\") +\n@@ -690,11 +670,9 @@ UniValue dumpprivkey(const JSONRPCRequest& request)\n                 \"\\nReveals the private key corresponding to 'address'.\\n\"\n                 \"Then the importprivkey can be used with this output\\n\",\n                 {\n-                    {\"address\", RPCArg::Type::STR, false},\n+                    {\"address\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The bitcoin address for the private key\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"address\\\"   (string, required) The bitcoin address for the private key\\n\"\n             \"\\nResult:\\n\"\n             \"\\\"key\\\"                (string) The private key\\n\"\n             \"\\nExamples:\\n\"\n@@ -741,11 +719,9 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n                 \"Note that if your wallet contains keys which are not derived from your HD seed (e.g. imported keys), these are not covered by\\n\"\n                 \"only backing up the seed itself, and must be backed up too (e.g. ensure you back up the whole dumpfile).\\n\",\n                 {\n-                    {\"filename\", RPCArg::Type::STR, false},\n+                    {\"filename\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The filename with path (either absolute or relative to bitcoind)\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"filename\\\"    (string, required) The filename with path (either absolute or relative to bitcoind)\\n\"\n             \"\\nResult:\\n\"\n             \"{                           (json object)\\n\"\n             \"  \\\"filename\\\" : {        (string) The filename with full absolute path\\n\"\n@@ -1127,57 +1103,49 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n     if (mainRequest.fHelp || mainRequest.params.size() < 1 || mainRequest.params.size() > 2)\n         throw std::runtime_error(\n             RPCHelpMan{\"importmulti\",\n-                \"\\nImport addresses/scripts (with private or public keys, redeem script (P2SH)), rescanning all addresses in one-shot-only (rescan can be disabled via options). Requires a new wallet backup.\\n\\n\",\n+                \"\\nImport addresses/scripts (with private or public keys, redeem script (P2SH)), rescanning all addresses in one-shot-only (rescan can be disabled via options). Requires a new wallet backup.\\n\",\n                 {\n-                    {\"requests\", RPCArg::Type::ARR,\n+                    {\"requests\", RPCArg::Type::ARR, /* opt */ false, /* default_val */ \"\", \"Data to be imported\",\n                         {\n-                            {\"\", RPCArg::Type::OBJ,\n+                            {\"\", RPCArg::Type::OBJ, /* opt */ false, /* default_val */ \"\", \"\",\n                                 {\n-                                    {\n-                                        {\"scriptPubKey\", RPCArg::Type::STR, false},\n-                                        {\"timestamp\", RPCArg::Type::NUM, false},\n-                                        {\"redeemscript\", RPCArg::Type::STR, true},\n-                                        {\"witnessscript\", RPCArg::Type::STR, true},\n-                                        {\"internal\", RPCArg::Type::BOOL, true},\n-                                        {\"watchonly\", RPCArg::Type::BOOL, true},\n-                                        {\"label\", RPCArg::Type::STR, true},\n+                                    {\"scriptPubKey\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"Type of scriptPubKey (string for script, json for address)\",\n+                                        /* oneline_description */ \"\", {\"\\\"<script>\\\" | { \\\"address\\\":\\\"<address>\\\" }\", \"string / json\"}\n+                                    },\n+                                    {\"timestamp\", RPCArg::Type::NUM, /* opt */ false, /* default_val */ \"\", \"Creation time of the key in seconds since epoch (Jan 1 1970 GMT),\\n\"\n+        \"                                                              or the string \\\"now\\\" to substitute the current synced blockchain time. The timestamp of the oldest\\n\"\n+        \"                                                              key will determine how far back blockchain rescans need to begin for missing wallet transactions.\\n\"\n+        \"                                                              \\\"now\\\" can be specified to bypass scanning, for keys which are known to never have been used, and\\n\"\n+        \"                                                              0 can be specified to scan the entire blockchain. Blocks up to 2 hours before the earliest key\\n\"\n+        \"                                                              creation time of all keys being imported by the importmulti call will be scanned.\",\n+                                        /* oneline_description */ \"\", {\"timestamp | \\\"now\\\"\", \"integer / string\"}\n+                                    },\n+                                    {\"redeemscript\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"omitted\", \"Allowed only if the scriptPubKey is a P2SH or P2SH-P2WSH address/scriptPubKey\"},\n+                                    {\"witnessscript\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"omitted\", \"Allowed only if the scriptPubKey is a P2SH-P2WSH or P2WSH address/scriptPubKey\"},\n+                                    {\"pubkeys\", RPCArg::Type::ARR, /* opt */ true, /* default_val */ \"empty array\", \"Array of strings giving pubkeys that must occur in the output or redeemscript\",\n+                                        {\n+                                            {\"pubKey\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"\"},\n+                                        }\n+                                    },\n+                                    {\"keys\", RPCArg::Type::ARR, /* opt */ true, /* default_val */ \"empty array\", \"Array of strings giving private keys whose corresponding public keys must occur in the output or redeemscript\",\n+                                        {\n+                                            {\"key\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"\"},\n+                                        }\n                                     },\n+                                    {\"internal\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"Stating whether matching outputs should be treated as not incoming payments aka change\"},\n+                                    {\"watchonly\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"Stating whether matching outputs should be considered watched even when they're not spendable, only allowed if keys are empty\"},\n+                                    {\"label\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"''\", \"Label to assign to the address, only allowed with internal=false\"},\n                                 },\n-                                false},\n+                            },\n                         },\n-                        false, \"\\\"requests\\\"\"},\n-                    {\"options\", RPCArg::Type::OBJ,\n+                        \"\\\"requests\\\"\"},\n+                    {\"options\", RPCArg::Type::OBJ, /* opt */ true, /* default_val */ \"null\", \"\",\n                         {\n-                            {\"rescan\", RPCArg::Type::BOOL, true},\n+                            {\"rescan\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"true\", \"Stating if should rescan the blockchain after all imports\"},\n                         },\n-                        true, \"\\\"options\\\"\"},\n+                        \"\\\"options\\\"\"},\n                 }}\n                 .ToString() +\n-            \"Arguments:\\n\"\n-            \"1. requests     (array, required) Data to be imported\\n\"\n-            \"  [     (array of json objects)\\n\"\n-            \"    {\\n\"\n-            \"      \\\"scriptPubKey\\\": \\\"<script>\\\" | { \\\"address\\\":\\\"<address>\\\" }, (string / json, required) Type of scriptPubKey (string for script, json for address)\\n\"\n-            \"      \\\"timestamp\\\": timestamp | \\\"now\\\"                        , (integer / string, required) Creation time of the key in seconds since epoch (Jan 1 1970 GMT),\\n\"\n-            \"                                                              or the string \\\"now\\\" to substitute the current synced blockchain time. The timestamp of the oldest\\n\"\n-            \"                                                              key will determine how far back blockchain rescans need to begin for missing wallet transactions.\\n\"\n-            \"                                                              \\\"now\\\" can be specified to bypass scanning, for keys which are known to never have been used, and\\n\"\n-            \"                                                              0 can be specified to scan the entire blockchain. Blocks up to 2 hours before the earliest key\\n\"\n-            \"                                                              creation time of all keys being imported by the importmulti call will be scanned.\\n\"\n-            \"      \\\"redeemscript\\\": \\\"<script>\\\"                            , (string, optional) Allowed only if the scriptPubKey is a P2SH or P2SH-P2WSH address/scriptPubKey\\n\"\n-            \"      \\\"witnessscript\\\": \\\"<script>\\\"                           , (string, optional) Allowed only if the scriptPubKey is a P2SH-P2WSH or P2WSH address/scriptPubKey\\n\"\n-            \"      \\\"pubkeys\\\": [\\\"<pubKey>\\\", ... ]                         , (array, optional) Array of strings giving pubkeys that must occur in the output or redeemscript\\n\"\n-            \"      \\\"keys\\\": [\\\"<key>\\\", ... ]                               , (array, optional) Array of strings giving private keys whose corresponding public keys must occur in the output or redeemscript\\n\"\n-            \"      \\\"internal\\\": <true>                                    , (boolean, optional, default: false) Stating whether matching outputs should be treated as not incoming payments aka change\\n\"\n-            \"      \\\"watchonly\\\": <true>                                   , (boolean, optional, default: false) Stating whether matching outputs should be considered watched even when they're not spendable, only allowed if keys are empty\\n\"\n-            \"      \\\"label\\\": <label>                                      , (string, optional, default: '') Label to assign to the address, only allowed with internal=false\\n\"\n-            \"    }\\n\"\n-            \"  ,...\\n\"\n-            \"  ]\\n\"\n-            \"2. options                 (json, optional)\\n\"\n-            \"  {\\n\"\n-            \"     \\\"rescan\\\": <false>,         (boolean, optional, default: true) Stating if should rescan the blockchain after all imports\\n\"\n-            \"  }\\n\"\n             \"\\nNote: This call can take over an hour to complete if rescan is true, during that time, other rpc calls\\n\"\n             \"may report that the imported keys, addresses or scripts exists but related transactions are still missing.\\n\"\n             \"\\nExamples:\\n\" +"
      },
      {
        "sha": "c1cdd0b2eef892ef7e6cc93476718cb712375fb8",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 280,
        "deletions": 485,
        "changes": 765,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -155,13 +155,10 @@ static UniValue getnewaddress(const JSONRPCRequest& request)\n                 \"If 'label' is specified, it is added to the address book \\n\"\n                 \"so payments received with the address will be associated with 'label'.\\n\",\n                 {\n-                    {\"label\", RPCArg::Type::STR, true},\n-                    {\"address_type\", RPCArg::Type::STR, true},\n+                    {\"label\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"null\", \"The label name for the address to be linked to. If not provided, the default label \\\"\\\" is used. It can also be set to the empty string \\\"\\\" to represent the default label. The label does not need to exist, it will be created if there is no label by the given name.\"},\n+                    {\"address_type\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"set by -addresstype\", \"The address type to use. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"label\\\"          (string, optional) The label name for the address to be linked to. If not provided, the default label \\\"\\\" is used. It can also be set to the empty string \\\"\\\" to represent the default label. The label does not need to exist, it will be created if there is no label by the given name.\\n\"\n-            \"2. \\\"address_type\\\"   (string, optional) The address type to use. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\". Default is set by -addresstype.\\n\"\n             \"\\nResult:\\n\"\n             \"\\\"address\\\"    (string) The new bitcoin address\\n\"\n             \"\\nExamples:\\n\"\n@@ -219,11 +216,9 @@ static UniValue getrawchangeaddress(const JSONRPCRequest& request)\n                 \"\\nReturns a new Bitcoin address, for receiving change.\\n\"\n                 \"This is for use with raw transactions, NOT normal use.\\n\",\n                 {\n-                    {\"address_type\", RPCArg::Type::STR, true},\n+                    {\"address_type\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"set by -changetype\", \"The address type to use. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"address_type\\\"           (string, optional) The address type to use. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\". Default is set by -changetype.\\n\"\n             \"\\nResult:\\n\"\n             \"\\\"address\\\"    (string) The address\\n\"\n             \"\\nExamples:\\n\"\n@@ -276,13 +271,10 @@ static UniValue setlabel(const JSONRPCRequest& request)\n             RPCHelpMan{\"setlabel\",\n                 \"\\nSets the label associated with the given address.\\n\",\n                 {\n-                    {\"address\", RPCArg::Type::STR, false},\n-                    {\"label\", RPCArg::Type::STR, false},\n+                    {\"address\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The bitcoin address to be associated with a label.\"},\n+                    {\"label\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The label to assign to the address.\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"address\\\"         (string, required) The bitcoin address to be associated with a label.\\n\"\n-            \"2. \\\"label\\\"           (string, required) The label to assign to the address.\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"setlabel\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\\\" \\\"tabby\\\"\")\n             + HelpExampleRpc(\"setlabel\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\\\", \\\"tabby\\\"\")\n@@ -359,35 +351,26 @@ static UniValue sendtoaddress(const JSONRPCRequest& request)\n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 8)\n         throw std::runtime_error(\n             RPCHelpMan{\"sendtoaddress\",\n-                \"\\nSend an amount to a given address.\\n\",\n+                \"\\nSend an amount to a given address.\" +\n+                    HelpRequiringPassphrase(pwallet) + \"\\n\",\n                 {\n-                    {\"address\", RPCArg::Type::STR, false},\n-                    {\"amount\", RPCArg::Type::AMOUNT, false},\n-                    {\"comment\", RPCArg::Type::STR, true},\n-                    {\"comment_to\", RPCArg::Type::STR, true},\n-                    {\"subtractfeefromamount\", RPCArg::Type::BOOL, true},\n-                    {\"replaceable\", RPCArg::Type::BOOL, true},\n-                    {\"conf_target\", RPCArg::Type::NUM, true},\n-                    {\"estimate_mode\", RPCArg::Type::STR, true},\n-                }}\n-                .ToString() +\n-            HelpRequiringPassphrase(pwallet) +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"address\\\"            (string, required) The bitcoin address to send to.\\n\"\n-            \"2. \\\"amount\\\"             (numeric or string, required) The amount in \" + CURRENCY_UNIT + \" to send. eg 0.1\\n\"\n-            \"3. \\\"comment\\\"            (string, optional) A comment used to store what the transaction is for. \\n\"\n-            \"                             This is not part of the transaction, just kept in your wallet.\\n\"\n-            \"4. \\\"comment_to\\\"         (string, optional) A comment to store the name of the person or organization \\n\"\n+                    {\"address\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The bitcoin address to send to.\"},\n+                    {\"amount\", RPCArg::Type::AMOUNT, /* opt */ false, /* default_val */ \"\", \"The amount in \" + CURRENCY_UNIT + \" to send. eg 0.1\"},\n+                    {\"comment\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"null\", \"A comment used to store what the transaction is for.\\n\"\n+            \"                             This is not part of the transaction, just kept in your wallet.\"},\n+                    {\"comment_to\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"null\", \"A comment to store the name of the person or organization\\n\"\n             \"                             to which you're sending the transaction. This is not part of the \\n\"\n-            \"                             transaction, just kept in your wallet.\\n\"\n-            \"5. subtractfeefromamount  (boolean, optional, default=false) The fee will be deducted from the amount being sent.\\n\"\n-            \"                             The recipient will receive less bitcoins than you enter in the amount field.\\n\"\n-            \"6. replaceable            (boolean, optional) Allow this transaction to be replaced by a transaction with higher fees via BIP 125\\n\"\n-            \"7. conf_target            (numeric, optional) Confirmation target (in blocks)\\n\"\n-            \"8. \\\"estimate_mode\\\"      (string, optional, default=UNSET) The fee estimate mode, must be one of:\\n\"\n+            \"                             transaction, just kept in your wallet.\"},\n+                    {\"subtractfeefromamount\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"The fee will be deducted from the amount being sent.\\n\"\n+            \"                             The recipient will receive less bitcoins than you enter in the amount field.\"},\n+                    {\"replaceable\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"fallback to wallet's default\", \"Allow this transaction to be replaced by a transaction with higher fees via BIP 125\"},\n+                    {\"conf_target\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"fallback to wallet's default\", \"Confirmation target (in blocks)\"},\n+                    {\"estimate_mode\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"UNSET\", \"The fee estimate mode, must be one of:\\n\"\n             \"       \\\"UNSET\\\"\\n\"\n             \"       \\\"ECONOMICAL\\\"\\n\"\n-            \"       \\\"CONSERVATIVE\\\"\\n\"\n+            \"       \\\"CONSERVATIVE\\\"\"},\n+                }}\n+                .ToString() +\n             \"\\nResult:\\n\"\n             \"\\\"txid\\\"                  (string) The transaction id.\\n\"\n             \"\\nExamples:\\n\"\n@@ -522,16 +505,13 @@ static UniValue signmessage(const JSONRPCRequest& request)\n     if (request.fHelp || request.params.size() != 2)\n         throw std::runtime_error(\n             RPCHelpMan{\"signmessage\",\n-                \"\\nSign a message with the private key of an address\",\n+                \"\\nSign a message with the private key of an address\" +\n+                    HelpRequiringPassphrase(pwallet) + \"\\n\",\n                 {\n-                    {\"address\", RPCArg::Type::STR, false},\n-                    {\"message\", RPCArg::Type::STR, false},\n+                    {\"address\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The bitcoin address to use for the private key.\"},\n+                    {\"message\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The message to create a signature of.\"},\n                 }}\n                 .ToString() +\n-            HelpRequiringPassphrase(pwallet) + \"\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"address\\\"         (string, required) The bitcoin address to use for the private key.\\n\"\n-            \"2. \\\"message\\\"         (string, required) The message to create a signature of.\\n\"\n             \"\\nResult:\\n\"\n             \"\\\"signature\\\"          (string) The signature of the message encoded in base 64\\n\"\n             \"\\nExamples:\\n\"\n@@ -593,13 +573,10 @@ static UniValue getreceivedbyaddress(const JSONRPCRequest& request)\n             RPCHelpMan{\"getreceivedbyaddress\",\n                 \"\\nReturns the total amount received by the given address in transactions with at least minconf confirmations.\\n\",\n                 {\n-                    {\"address\", RPCArg::Type::STR, false},\n-                    {\"minconf\", RPCArg::Type::NUM, true},\n+                    {\"address\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The bitcoin address for transactions.\"},\n+                    {\"minconf\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"1\", \"Only include transactions confirmed at least this many times.\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"address\\\"         (string, required) The bitcoin address for transactions.\\n\"\n-            \"2. minconf             (numeric, optional, default=1) Only include transactions confirmed at least this many times.\\n\"\n             \"\\nResult:\\n\"\n             \"amount   (numeric) The total amount in \" + CURRENCY_UNIT + \" received at this address.\\n\"\n             \"\\nExamples:\\n\"\n@@ -667,13 +644,10 @@ static UniValue getreceivedbylabel(const JSONRPCRequest& request)\n             RPCHelpMan{\"getreceivedbylabel\",\n                 \"\\nReturns the total amount received by addresses with <label> in transactions with at least [minconf] confirmations.\\n\",\n                 {\n-                    {\"label\", RPCArg::Type::STR, false},\n-                    {\"minconf\", RPCArg::Type::NUM, true},\n+                    {\"label\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The selected label, may be the default label using \\\"\\\".\"},\n+                    {\"minconf\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"1\", \"Only include transactions confirmed at least this many times.\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"label\\\"        (string, required) The selected label, may be the default label using \\\"\\\".\\n\"\n-            \"2. minconf          (numeric, optional, default=1) Only include transactions confirmed at least this many times.\\n\"\n             \"\\nResult:\\n\"\n             \"amount              (numeric) The total amount in \" + CURRENCY_UNIT + \" received for this label.\\n\"\n             \"\\nExamples:\\n\"\n@@ -741,15 +715,11 @@ static UniValue getbalance(const JSONRPCRequest& request)\n                 \"The available balance is what the wallet considers currently spendable, and is\\n\"\n                 \"thus affected by options which limit spendability such as -spendzeroconfchange.\\n\",\n                 {\n-                    {\"dummy\", RPCArg::Type::STR, true},\n-                    {\"minconf\", RPCArg::Type::NUM, true},\n-                    {\"include_watchonly\", RPCArg::Type::NUM, true},\n+                    {\"dummy\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"null\", \"Remains for backward compatibility. Must be excluded or set to \\\"*\\\".\"},\n+                    {\"minconf\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"0\", \"Only include transactions confirmed at least this many times.\"},\n+                    {\"include_watchonly\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"Also include balance in watch-only addresses (see 'importaddress')\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. (dummy)           (string, optional) Remains for backward compatibility. Must be excluded or set to \\\"*\\\".\\n\"\n-            \"2. minconf           (numeric, optional, default=0) Only include transactions confirmed at least this many times.\\n\"\n-            \"3. include_watchonly (bool, optional, default=false) Also include balance in watch-only addresses (see 'importaddress')\\n\"\n             \"\\nResult:\\n\"\n             \"amount              (numeric) The total amount in \" + CURRENCY_UNIT + \" received for this wallet.\\n\"\n             \"\\nExamples:\\n\"\n@@ -824,50 +794,33 @@ static UniValue sendmany(const JSONRPCRequest& request)\n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 8)\n         throw std::runtime_error(\n             RPCHelpMan{\"sendmany\",\n-                \"\\nSend multiple times. Amounts are double-precision floating point numbers.\\n\",\n+                \"\\nSend multiple times. Amounts are double-precision floating point numbers.\" +\n+                    HelpRequiringPassphrase(pwallet) + \"\\n\",\n                 {\n-                    {\"dummy\", RPCArg::Type::STR, false, \"\\\"\\\"\"},\n-                    {\"amounts\", RPCArg::Type::OBJ,\n-                        {\n-                            {\"address\", RPCArg::Type::AMOUNT, false},\n-                        },\n-                        false},\n-                    {\"minconf\", RPCArg::Type::NUM, true},\n-                    {\"comment\", RPCArg::Type::STR, true},\n-                    {\"subtractfeefrom\", RPCArg::Type::ARR,\n+                    {\"dummy\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"Must be set to \\\"\\\" for backwards compatibility.\", \"\\\"\\\"\"},\n+                    {\"amounts\", RPCArg::Type::OBJ, /* opt */ false, /* default_val */ \"\", \"A json object with addresses and amounts\",\n                         {\n-                            {\"address\", RPCArg::Type::STR, true},\n+                            {\"address\", RPCArg::Type::AMOUNT, /* opt */ false, /* default_val */ \"\", \"The bitcoin address is the key, the numeric amount (can be string) in \" + CURRENCY_UNIT + \" is the value\"},\n                         },\n-                        true},\n-                    {\"replaceable\", RPCArg::Type::BOOL, true},\n-                    {\"conf_target\", RPCArg::Type::NUM, true},\n-                    {\"estimate_mode\", RPCArg::Type::STR, true},\n-                }}\n-                .ToString() +\n-            HelpRequiringPassphrase(pwallet) + \"\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"dummy\\\"               (string, required) Must be set to \\\"\\\" for backwards compatibility.\\n\"\n-            \"2. \\\"amounts\\\"             (string, required) A json object with addresses and amounts\\n\"\n-            \"    {\\n\"\n-            \"      \\\"address\\\":amount   (numeric or string) The bitcoin address is the key, the numeric amount (can be string) in \" + CURRENCY_UNIT + \" is the value\\n\"\n-            \"      ,...\\n\"\n-            \"    }\\n\"\n-            \"3. minconf                 (numeric, optional, default=1) Only use the balance confirmed at least this many times.\\n\"\n-            \"4. \\\"comment\\\"             (string, optional) A comment\\n\"\n-            \"5. subtractfeefrom         (array, optional) A json array with addresses.\\n\"\n+                    },\n+                    {\"minconf\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"1\", \"Only use the balance confirmed at least this many times.\"},\n+                    {\"comment\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"null\", \"A comment\"},\n+                    {\"subtractfeefrom\", RPCArg::Type::ARR, /* opt */ true, /* default_val */ \"null\", \"A json array with addresses.\\n\"\n             \"                           The fee will be equally deducted from the amount of each selected address.\\n\"\n             \"                           Those recipients will receive less bitcoins than you enter in their corresponding amount field.\\n\"\n-            \"                           If no addresses are specified here, the sender pays the fee.\\n\"\n-            \"    [\\n\"\n-            \"      \\\"address\\\"          (string) Subtract fee from this address\\n\"\n-            \"      ,...\\n\"\n-            \"    ]\\n\"\n-            \"6. replaceable            (boolean, optional) Allow this transaction to be replaced by a transaction with higher fees via BIP 125\\n\"\n-            \"7. conf_target            (numeric, optional) Confirmation target (in blocks)\\n\"\n-            \"8. \\\"estimate_mode\\\"      (string, optional, default=UNSET) The fee estimate mode, must be one of:\\n\"\n+            \"                           If no addresses are specified here, the sender pays the fee.\",\n+                        {\n+                            {\"address\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"\", \"Subtract fee from this address\"},\n+                        },\n+                    },\n+                    {\"replaceable\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"fallback to wallet's default\", \"Allow this transaction to be replaced by a transaction with higher fees via BIP 125\"},\n+                    {\"conf_target\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"fallback to wallet's default\", \"Confirmation target (in blocks)\"},\n+                    {\"estimate_mode\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"UNSET\", \"The fee estimate mode, must be one of:\\n\"\n             \"       \\\"UNSET\\\"\\n\"\n             \"       \\\"ECONOMICAL\\\"\\n\"\n-            \"       \\\"CONSERVATIVE\\\"\\n\"\n+            \"       \\\"CONSERVATIVE\\\"\"},\n+                }}\n+                .ToString() +\n              \"\\nResult:\\n\"\n             \"\\\"txid\\\"                   (string) The transaction id for the send. Only 1 transaction is created regardless of \\n\"\n             \"                                    the number of addresses.\\n\"\n@@ -995,23 +948,24 @@ static UniValue addmultisigaddress(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 4) {\n-        std::string msg = \"addmultisigaddress nrequired [\\\"key\\\",...] ( \\\"label\\\" \\\"address_type\\\" )\\n\"\n-            \"\\nAdd a nrequired-to-sign multisignature address to the wallet. Requires a new wallet backup.\\n\"\n-            \"Each key is a Bitcoin address or hex-encoded public key.\\n\"\n-            \"This functionality is only intended for use with non-watchonly addresses.\\n\"\n-            \"See `importaddress` for watchonly p2sh address support.\\n\"\n-            \"If 'label' is specified, assign address to that label.\\n\"\n-\n-            \"\\nArguments:\\n\"\n-            \"1. nrequired                      (numeric, required) The number of required signatures out of the n keys or addresses.\\n\"\n-            \"2. \\\"keys\\\"                         (string, required) A json array of bitcoin addresses or hex-encoded public keys\\n\"\n-            \"     [\\n\"\n-            \"       \\\"address\\\"                  (string) bitcoin address or hex-encoded public key\\n\"\n-            \"       ...,\\n\"\n-            \"     ]\\n\"\n-            \"3. \\\"label\\\"                        (string, optional) A label to assign the addresses to.\\n\"\n-            \"4. \\\"address_type\\\"                 (string, optional) The address type to use. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\". Default is set by -addresstype.\\n\"\n-\n+        std::string msg =\n+            RPCHelpMan{\"addmultisigaddress\",\n+                \"\\nAdd a nrequired-to-sign multisignature address to the wallet. Requires a new wallet backup.\\n\"\n+                \"Each key is a Bitcoin address or hex-encoded public key.\\n\"\n+                \"This functionality is only intended for use with non-watchonly addresses.\\n\"\n+                \"See `importaddress` for watchonly p2sh address support.\\n\"\n+                \"If 'label' is specified, assign address to that label.\\n\",\n+                {\n+                    {\"nrequired\", RPCArg::Type::NUM, /* opt */ false, /* default_val */ \"\", \"The number of required signatures out of the n keys or addresses.\"},\n+                    {\"keys\", RPCArg::Type::ARR, /* opt */ false, /* default_val */ \"\", \"A json array of bitcoin addresses or hex-encoded public keys\",\n+                        {\n+                            {\"key\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"bitcoin address or hex-encoded public key\"},\n+                        },\n+                        },\n+                    {\"label\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"null\", \"A label to assign the addresses to.\"},\n+                    {\"address_type\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"set by -addresstype\", \"The address type to use. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n+                }}\n+                .ToString() +\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"address\\\":\\\"multisigaddress\\\",    (string) The value of the new multisig address.\\n\"\n@@ -1238,17 +1192,12 @@ static UniValue listreceivedbyaddress(const JSONRPCRequest& request)\n             RPCHelpMan{\"listreceivedbyaddress\",\n                 \"\\nList balances by receiving address.\\n\",\n                 {\n-                    {\"minconf\", RPCArg::Type::NUM, true},\n-                    {\"include_empty\", RPCArg::Type::BOOL, true},\n-                    {\"include_watchonly\", RPCArg::Type::BOOL, true},\n-                    {\"address_filter\", RPCArg::Type::STR, true},\n+                    {\"minconf\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"1\", \"The minimum number of confirmations before payments are included.\"},\n+                    {\"include_empty\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"Whether to include addresses that haven't received any payments.\"},\n+                    {\"include_watchonly\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"Whether to include watch-only addresses (see 'importaddress').\"},\n+                    {\"address_filter\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"null\", \"If present, only return information on this address.\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. minconf           (numeric, optional, default=1) The minimum number of confirmations before payments are included.\\n\"\n-            \"2. include_empty     (bool, optional, default=false) Whether to include addresses that haven't received any payments.\\n\"\n-            \"3. include_watchonly (bool, optional, default=false) Whether to include watch-only addresses (see 'importaddress').\\n\"\n-            \"4. address_filter    (string, optional) If present, only return information on this address.\\n\"\n             \"\\nResult:\\n\"\n             \"[\\n\"\n             \"  {\\n\"\n@@ -1296,16 +1245,11 @@ static UniValue listreceivedbylabel(const JSONRPCRequest& request)\n             RPCHelpMan{\"listreceivedbylabel\",\n                 \"\\nList received transactions by label.\\n\",\n                 {\n-                    {\"minconf\", RPCArg::Type::NUM, true},\n-                    {\"include_empty\", RPCArg::Type::BOOL, true},\n-                    {\"include_watchonly\", RPCArg::Type::BOOL, true},\n+                    {\"minconf\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"1\", \"The minimum number of confirmations before payments are included.\"},\n+                    {\"include_empty\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"Whether to include labels that haven't received any payments.\"},\n+                    {\"include_watchonly\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"Whether to include watch-only addresses (see 'importaddress').\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. minconf           (numeric, optional, default=1) The minimum number of confirmations before payments are included.\\n\"\n-            \"2. include_empty     (bool, optional, default=false) Whether to include labels that haven't received any payments.\\n\"\n-            \"3. include_watchonly (bool, optional, default=false) Whether to include watch-only addresses (see 'importaddress').\\n\"\n-\n             \"\\nResult:\\n\"\n             \"[\\n\"\n             \"  {\\n\"\n@@ -1442,25 +1386,25 @@ UniValue listtransactions(const JSONRPCRequest& request)\n                 \"\\nIf a label name is provided, this will return only incoming transactions paying to addresses with the specified label.\\n\"\n                 \"\\nReturns up to 'count' most recent transactions skipping the first 'from' transactions.\\n\",\n                 {\n-                    {\"label\", RPCArg::Type::STR, true},\n-                    {\"count\", RPCArg::Type::NUM, true},\n-                    {\"skip\", RPCArg::Type::NUM, true},\n-                    {\"include_watchonly\", RPCArg::Type::BOOL, true},\n+                    {\"label\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"null\", \"If set, should be a valid label name to return only incoming transactions\\n\"\n+            \"              with the specified label, or \\\"*\\\" to disable filtering and return all transactions.\"},\n+                    {\"count\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"10\", \"The number of transactions to return\"},\n+                    {\"skip\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"0\", \"The number of transactions to skip\"},\n+                    {\"include_watchonly\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"Include transactions to watch-only addresses (see 'importaddress')\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"label\\\"    (string, optional) If set, should be a valid label name to return only incoming transactions\\n\"\n-            \"              with the specified label, or \\\"*\\\" to disable filtering and return all transactions.\\n\"\n-            \"2. count          (numeric, optional, default=10) The number of transactions to return\\n\"\n-            \"3. skip           (numeric, optional, default=0) The number of transactions to skip\\n\"\n-            \"4. include_watchonly (bool, optional, default=false) Include transactions to watch-only addresses (see 'importaddress')\\n\"\n             \"\\nResult:\\n\"\n             \"[\\n\"\n             \"  {\\n\"\n             \"    \\\"address\\\":\\\"address\\\",    (string) The bitcoin address of the transaction.\\n\"\n-            \"    \\\"category\\\":\\\"send|receive\\\", (string) The transaction category.\\n\"\n+            \"    \\\"category\\\":               (string) The transaction category.\\n\"\n+            \"                \\\"send\\\"                  Transactions sent.\\n\"\n+            \"                \\\"receive\\\"               Non-coinbase transactions received.\\n\"\n+            \"                \\\"generate\\\"              Coinbase transactions received with more than 100 confirmations.\\n\"\n+            \"                \\\"immature\\\"              Coinbase transactions received with 100 or fewer confirmations.\\n\"\n+            \"                \\\"orphan\\\"                Orphaned coinbase transactions received.\\n\"\n             \"    \\\"amount\\\": x.xxx,          (numeric) The amount in \" + CURRENCY_UNIT + \". This is negative for the 'send' category, and is positive\\n\"\n-            \"                                        for the 'receive' category,\\n\"\n+            \"                                        for all other categories\\n\"\n             \"    \\\"label\\\": \\\"label\\\",       (string) A comment for the address/transaction, if any\\n\"\n             \"    \\\"vout\\\": n,                (numeric) the vout value\\n\"\n             \"    \\\"fee\\\": x.xxx,             (numeric) The amount of the fee in \" + CURRENCY_UNIT + \". This is negative and only available for the \\n\"\n@@ -1577,35 +1521,35 @@ static UniValue listsinceblock(const JSONRPCRequest& request)\n                 \"If \\\"blockhash\\\" is no longer a part of the main chain, transactions from the fork point onward are included.\\n\"\n                 \"Additionally, if include_removed is set, transactions affecting the wallet which were removed are returned in the \\\"removed\\\" array.\\n\",\n                 {\n-                    {\"blockhash\", RPCArg::Type::STR, true},\n-                    {\"target_confirmations\", RPCArg::Type::NUM, true},\n-                    {\"include_watchonly\", RPCArg::Type::BOOL, true},\n-                    {\"include_removed\", RPCArg::Type::BOOL, true},\n+                    {\"blockhash\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"null\", \"If set, the block hash to list transactions since, otherwise list all transactions.\"},\n+                    {\"target_confirmations\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"1\", \"Return the nth block hash from the main chain. e.g. 1 would mean the best block hash. Note: this is not used as a filter, but only affects [lastblock] in the return value\"},\n+                    {\"include_watchonly\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"Include transactions to watch-only addresses (see 'importaddress')\"},\n+                    {\"include_removed\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"true\", \"Show transactions that were removed due to a reorg in the \\\"removed\\\" array\\n\"\n+            \"                                                           (not guaranteed to work on pruned nodes)\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"blockhash\\\"            (string, optional) The block hash to list transactions since\\n\"\n-            \"2. target_confirmations:    (numeric, optional, default=1) Return the nth block hash from the main chain. e.g. 1 would mean the best block hash. Note: this is not used as a filter, but only affects [lastblock] in the return value\\n\"\n-            \"3. include_watchonly:       (bool, optional, default=false) Include transactions to watch-only addresses (see 'importaddress')\\n\"\n-            \"4. include_removed:         (bool, optional, default=true) Show transactions that were removed due to a reorg in the \\\"removed\\\" array\\n\"\n-            \"                                                           (not guaranteed to work on pruned nodes)\\n\"\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"transactions\\\": [\\n\"\n-            \"    \\\"address\\\":\\\"address\\\",    (string) The bitcoin address of the transaction. Not present for move transactions (category = move).\\n\"\n-            \"    \\\"category\\\":\\\"send|receive\\\",     (string) The transaction category. 'send' has negative amounts, 'receive' has positive amounts.\\n\"\n-            \"    \\\"amount\\\": x.xxx,          (numeric) The amount in \" + CURRENCY_UNIT + \". This is negative for the 'send' category, and for the 'move' category for moves \\n\"\n-            \"                                          outbound. It is positive for the 'receive' category, and for the 'move' category for inbound funds.\\n\"\n+            \"    \\\"address\\\":\\\"address\\\",    (string) The bitcoin address of the transaction.\\n\"\n+            \"    \\\"category\\\":               (string) The transaction category.\\n\"\n+            \"                \\\"send\\\"                  Transactions sent.\\n\"\n+            \"                \\\"receive\\\"               Non-coinbase transactions received.\\n\"\n+            \"                \\\"generate\\\"              Coinbase transactions received with more than 100 confirmations.\\n\"\n+            \"                \\\"immature\\\"              Coinbase transactions received with 100 or fewer confirmations.\\n\"\n+            \"                \\\"orphan\\\"                Orphaned coinbase transactions received.\\n\"\n+            \"    \\\"amount\\\": x.xxx,          (numeric) The amount in \" + CURRENCY_UNIT + \". This is negative for the 'send' category, and is positive\\n\"\n+            \"                                         for all other categories\\n\"\n             \"    \\\"vout\\\" : n,               (numeric) the vout value\\n\"\n             \"    \\\"fee\\\": x.xxx,             (numeric) The amount of the fee in \" + CURRENCY_UNIT + \". This is negative and only available for the 'send' category of transactions.\\n\"\n-            \"    \\\"confirmations\\\": n,       (numeric) The number of confirmations for the transaction. Available for 'send' and 'receive' category of transactions.\\n\"\n+            \"    \\\"confirmations\\\": n,       (numeric) The number of confirmations for the transaction.\\n\"\n             \"                                          When it's < 0, it means the transaction conflicted that many blocks ago.\\n\"\n-            \"    \\\"blockhash\\\": \\\"hashvalue\\\",     (string) The block hash containing the transaction. Available for 'send' and 'receive' category of transactions.\\n\"\n-            \"    \\\"blockindex\\\": n,          (numeric) The index of the transaction in the block that includes it. Available for 'send' and 'receive' category of transactions.\\n\"\n+            \"    \\\"blockhash\\\": \\\"hashvalue\\\",     (string) The block hash containing the transaction.\\n\"\n+            \"    \\\"blockindex\\\": n,          (numeric) The index of the transaction in the block that includes it.\\n\"\n             \"    \\\"blocktime\\\": xxx,         (numeric) The block time in seconds since epoch (1 Jan 1970 GMT).\\n\"\n-            \"    \\\"txid\\\": \\\"transactionid\\\",  (string) The transaction id. Available for 'send' and 'receive' category of transactions.\\n\"\n+            \"    \\\"txid\\\": \\\"transactionid\\\",  (string) The transaction id.\\n\"\n             \"    \\\"time\\\": xxx,              (numeric) The transaction time in seconds since epoch (Jan 1 1970 GMT).\\n\"\n-            \"    \\\"timereceived\\\": xxx,      (numeric) The time received in seconds since epoch (Jan 1 1970 GMT). Available for 'send' and 'receive' category of transactions.\\n\"\n+            \"    \\\"timereceived\\\": xxx,      (numeric) The time received in seconds since epoch (Jan 1 1970 GMT).\\n\"\n             \"    \\\"bip125-replaceable\\\": \\\"yes|no|unknown\\\",  (string) Whether this transaction could be replaced due to BIP125 (replace-by-fee);\\n\"\n             \"                                                   may be unknown for unconfirmed transactions not in the mempool\\n\"\n             \"    \\\"abandoned\\\": xxx,         (bool) 'true' if the transaction has been abandoned (inputs are respendable). Only available for the 'send' category of transactions.\\n\"\n@@ -1722,13 +1666,10 @@ static UniValue gettransaction(const JSONRPCRequest& request)\n             RPCHelpMan{\"gettransaction\",\n                 \"\\nGet detailed information about in-wallet transaction <txid>\\n\",\n                 {\n-                    {\"txid\", RPCArg::Type::STR, false},\n-                    {\"include_watchonly\", RPCArg::Type::BOOL, true},\n+                    {\"txid\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The transaction id\"},\n+                    {\"include_watchonly\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"Whether to include watch-only addresses in balance calculation and details[]\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"txid\\\"                  (string, required) The transaction id\\n\"\n-            \"2. \\\"include_watchonly\\\"     (bool, optional, default=false) Whether to include watch-only addresses in balance calculation and details[]\\n\"\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"amount\\\" : x.xxx,        (numeric) The transaction amount in \" + CURRENCY_UNIT + \"\\n\"\n@@ -1746,7 +1687,12 @@ static UniValue gettransaction(const JSONRPCRequest& request)\n             \"  \\\"details\\\" : [\\n\"\n             \"    {\\n\"\n             \"      \\\"address\\\" : \\\"address\\\",          (string) The bitcoin address involved in the transaction\\n\"\n-            \"      \\\"category\\\" : \\\"send|receive\\\",    (string) The category, either 'send' or 'receive'\\n\"\n+            \"      \\\"category\\\" :                      (string) The transaction category.\\n\"\n+            \"                   \\\"send\\\"                  Transactions sent.\\n\"\n+            \"                   \\\"receive\\\"               Non-coinbase transactions received.\\n\"\n+            \"                   \\\"generate\\\"              Coinbase transactions received with more than 100 confirmations.\\n\"\n+            \"                   \\\"immature\\\"              Coinbase transactions received with 100 or fewer confirmations.\\n\"\n+            \"                   \\\"orphan\\\"                Orphaned coinbase transactions received.\\n\"\n             \"      \\\"amount\\\" : x.xxx,                 (numeric) The amount in \" + CURRENCY_UNIT + \"\\n\"\n             \"      \\\"label\\\" : \\\"label\\\",              (string) A comment for the address/transaction, if any\\n\"\n             \"      \\\"vout\\\" : n,                       (numeric) the vout value\\n\"\n@@ -1826,11 +1772,9 @@ static UniValue abandontransaction(const JSONRPCRequest& request)\n                 \"It only works on transactions which are not included in a block and are not currently in the mempool.\\n\"\n                 \"It has no effect on transactions which are already abandoned.\\n\",\n                 {\n-                    {\"txid\", RPCArg::Type::STR_HEX, false},\n+                    {\"txid\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"The transaction id\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"txid\\\"    (string, required) The transaction id\\n\"\n             \"\\nResult:\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"abandontransaction\", \"\\\"1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d\\\"\")\n@@ -1872,11 +1816,9 @@ static UniValue backupwallet(const JSONRPCRequest& request)\n             RPCHelpMan{\"backupwallet\",\n                 \"\\nSafely copies current wallet file to destination, which can be a directory or a path with filename.\\n\",\n                 {\n-                    {\"destination\", RPCArg::Type::STR, false},\n+                    {\"destination\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The destination directory or file\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"destination\\\"   (string) The destination directory or file\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"backupwallet\", \"\\\"backup.dat\\\"\")\n             + HelpExampleRpc(\"backupwallet\", \"\\\"backup.dat\\\"\")\n@@ -1910,14 +1852,12 @@ static UniValue keypoolrefill(const JSONRPCRequest& request)\n     if (request.fHelp || request.params.size() > 1)\n         throw std::runtime_error(\n             RPCHelpMan{\"keypoolrefill\",\n-                \"\\nFills the keypool.\",\n+                \"\\nFills the keypool.\"+\n+                    HelpRequiringPassphrase(pwallet) + \"\\n\",\n                 {\n-                    {\"newsize\", RPCArg::Type::NUM, true},\n+                    {\"newsize\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"100\", \"The new keypool size\"},\n                 }}\n                 .ToString() +\n-            HelpRequiringPassphrase(pwallet) + \"\\n\"\n-            \"\\nArguments\\n\"\n-            \"1. newsize     (numeric, optional, default=100) The new keypool size\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"keypoolrefill\", \"\")\n             + HelpExampleRpc(\"keypoolrefill\", \"\")\n@@ -1964,13 +1904,10 @@ static UniValue walletpassphrase(const JSONRPCRequest& request)\n                 \"\\nStores the wallet decryption key in memory for 'timeout' seconds.\\n\"\n                 \"This is needed prior to performing transactions related to private keys such as sending bitcoins\\n\",\n                 {\n-                    {\"passphrase\", RPCArg::Type::STR, false},\n-                    {\"timeout\", RPCArg::Type::NUM, false},\n+                    {\"passphrase\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The wallet passphrase\"},\n+                    {\"timeout\", RPCArg::Type::NUM, /* opt */ false, /* default_val */ \"\", \"The time to keep the decryption key in seconds; capped at 100000000 (~3 years).\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"passphrase\\\"     (string, required) The wallet passphrase\\n\"\n-            \"2. timeout            (numeric, required) The time to keep the decryption key in seconds; capped at 100000000 (~3 years).\\n\"\n             \"\\nNote:\\n\"\n             \"Issuing the walletpassphrase command while the wallet is already unlocked will set a new unlock\\n\"\n             \"time that overrides the old one.\\n\"\n@@ -2052,13 +1989,10 @@ static UniValue walletpassphrasechange(const JSONRPCRequest& request)\n             RPCHelpMan{\"walletpassphrasechange\",\n                 \"\\nChanges the wallet passphrase from 'oldpassphrase' to 'newpassphrase'.\\n\",\n                 {\n-                    {\"oldpassphrase\", RPCArg::Type::STR, false},\n-                    {\"newpassphrase\", RPCArg::Type::STR, false},\n+                    {\"oldpassphrase\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The current passphrase\"},\n+                    {\"newpassphrase\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The new passphrase\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"oldpassphrase\\\"      (string) The current passphrase\\n\"\n-            \"2. \\\"newpassphrase\\\"      (string) The new passphrase\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"walletpassphrasechange\", \"\\\"old one\\\" \\\"new one\\\"\")\n             + HelpExampleRpc(\"walletpassphrasechange\", \"\\\"old one\\\", \\\"new one\\\"\")\n@@ -2155,11 +2089,9 @@ static UniValue encryptwallet(const JSONRPCRequest& request)\n                 \"Use the walletpassphrase call for this, and then walletlock call.\\n\"\n                 \"If the wallet is already encrypted, use the walletpassphrasechange call.\\n\",\n                 {\n-                    {\"passphrase\", RPCArg::Type::STR, false},\n+                    {\"passphrase\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The pass phrase to encrypt the wallet with. It must be at least 1 character, but should be long.\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"passphrase\\\"    (string) The pass phrase to encrypt the wallet with. It must be at least 1 character, but should be long.\\n\"\n             \"\\nExamples:\\n\"\n             \"\\nEncrypt your wallet\\n\"\n             + HelpExampleCli(\"encryptwallet\", \"\\\"my pass phrase\\\"\") +\n@@ -2218,30 +2150,19 @@ static UniValue lockunspent(const JSONRPCRequest& request)\n                 \"is always cleared (by virtue of process exit) when a node stops or fails.\\n\"\n                 \"Also see the listunspent call\\n\",\n                 {\n-                    {\"unlock\", RPCArg::Type::BOOL, false},\n-                    {\"transactions\", RPCArg::Type::ARR,\n+                    {\"unlock\", RPCArg::Type::BOOL, /* opt */ false, /* default_val */ \"\", \"Whether to unlock (true) or lock (false) the specified transactions\"},\n+                    {\"transactions\", RPCArg::Type::ARR, /* opt */ true, /* default_val */ \"empty array\", \"A json array of objects. Each object the txid (string) vout (numeric).\",\n                         {\n-                            {\"\", RPCArg::Type::OBJ,\n+                            {\"\", RPCArg::Type::OBJ, /* opt */ true, /* default_val */ \"\", \"\",\n                                 {\n-                                    {\"txid\", RPCArg::Type::STR_HEX, false},\n-                                    {\"vout\", RPCArg::Type::NUM, false},\n+                                    {\"txid\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"The transaction id\"},\n+                                    {\"vout\", RPCArg::Type::NUM, /* opt */ false, /* default_val */ \"\", \"The output number\"},\n                                 },\n-                                true},\n+                            },\n                         },\n-                        true},\n+                    },\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. unlock            (boolean, required) Whether to unlock (true) or lock (false) the specified transactions\\n\"\n-            \"2. \\\"transactions\\\"  (string, optional) A json array of objects. Each object the txid (string) vout (numeric)\\n\"\n-            \"     [           (json array of json objects)\\n\"\n-            \"       {\\n\"\n-            \"         \\\"txid\\\":\\\"id\\\",    (string) The transaction id\\n\"\n-            \"         \\\"vout\\\": n         (numeric) The output number\\n\"\n-            \"       }\\n\"\n-            \"       ,...\\n\"\n-            \"     ]\\n\"\n-\n             \"\\nResult:\\n\"\n             \"true|false    (boolean) Whether the command was successful or not\\n\"\n \n@@ -2408,11 +2329,9 @@ static UniValue settxfee(const JSONRPCRequest& request)\n             RPCHelpMan{\"settxfee\",\n                 \"\\nSet the transaction fee per kB for this wallet. Overrides the global -paytxfee command line parameter.\\n\",\n                 {\n-                    {\"amount\", RPCArg::Type::NUM, false},\n+                    {\"amount\", RPCArg::Type::AMOUNT, /* opt */ false, /* default_val */ \"\", \"The transaction fee in \" + CURRENCY_UNIT + \"/kB\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. amount         (numeric or string, required) The transaction fee in \" + CURRENCY_UNIT + \"/kB\\n\"\n             \"\\nResult\\n\"\n             \"true|false        (boolean) Returns true if successful\\n\"\n             \"\\nExamples:\\n\"\n@@ -2584,11 +2503,9 @@ static UniValue loadwallet(const JSONRPCRequest& request)\n                 \"\\nNote that all wallet command-line options used when starting bitcoind will be\"\n                 \"\\napplied to the new wallet (eg -zapwallettxes, upgradewallet, rescan, etc).\\n\",\n                 {\n-                    {\"filename\", RPCArg::Type::STR, false},\n+                    {\"filename\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The wallet directory or .dat file.\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"filename\\\"    (string, required) The wallet directory or .dat file.\\n\"\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"name\\\" :    <wallet_name>,        (string) The wallet name if loaded successfully.\\n\"\n@@ -2639,13 +2556,10 @@ static UniValue createwallet(const JSONRPCRequest& request)\n             RPCHelpMan{\"createwallet\",\n                 \"\\nCreates and loads a new wallet.\\n\",\n                 {\n-                    {\"wallet_name\", RPCArg::Type::STR, false},\n-                    {\"disable_private_keys\", RPCArg::Type::BOOL, true},\n+                    {\"wallet_name\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The name for the new wallet. If this is a path, the wallet will be created at the path location.\"},\n+                    {\"disable_private_keys\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"Disable the possibility of private keys (only watchonlys are possible in this mode).\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"wallet_name\\\"          (string, required) The name for the new wallet. If this is a path, the wallet will be created at the path location.\\n\"\n-            \"2. disable_private_keys   (boolean, optional, default: false) Disable the possibility of private keys (only watchonlys are possible in this mode).\\n\"\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"name\\\" :    <wallet_name>,        (string) The wallet name if created successfully. If the wallet was created using a full path, the wallet_name will be the full path.\\n\"\n@@ -2697,11 +2611,9 @@ static UniValue unloadwallet(const JSONRPCRequest& request)\n                 \"Unloads the wallet referenced by the request endpoint otherwise unloads the wallet specified in the argument.\\n\"\n                 \"Specifying the wallet name on a wallet endpoint is invalid.\",\n                 {\n-                    {\"wallet_name\", RPCArg::Type::STR, true},\n+                    {\"wallet_name\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"the wallet name from the RPC request\", \"The name of the wallet to unload.\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"wallet_name\\\"    (string, optional) The name of the wallet to unload.\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"unloadwallet\", \"wallet_name\")\n             + HelpExampleRpc(\"unloadwallet\", \"wallet_name\")\n@@ -2798,41 +2710,25 @@ static UniValue listunspent(const JSONRPCRequest& request)\n                 \"with between minconf and maxconf (inclusive) confirmations.\\n\"\n                 \"Optionally filter to only include txouts paid to specified addresses.\\n\",\n                 {\n-                    {\"minconf\", RPCArg::Type::NUM, true},\n-                    {\"maxconf\", RPCArg::Type::NUM, true},\n-                    {\"addresses\", RPCArg::Type::ARR,\n+                    {\"minconf\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"1\", \"The minimum confirmations to filter\"},\n+                    {\"maxconf\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"9999999\", \"The maximum confirmations to filter\"},\n+                    {\"addresses\", RPCArg::Type::ARR, /* opt */ true, /* default_val */ \"empty array\", \"A json array of bitcoin addresses to filter\",\n                         {\n-                            {\"address\", RPCArg::Type::STR, true},\n+                            {\"address\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"\", \"bitcoin address\"},\n                         },\n-                        true},\n-                    {\"include_unsafe\", RPCArg::Type::BOOL, true},\n-                    {\"query_options\", RPCArg::Type::OBJ,\n+                    },\n+                    {\"include_unsafe\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"true\", \"Include outputs that are not safe to spend\\n\"\n+            \"                  See description of \\\"safe\\\" attribute below.\"},\n+                    {\"query_options\", RPCArg::Type::OBJ, /* opt */ true, /* default_val */ \"null\", \"JSON with query options\",\n                         {\n-                            {\"minimumAmount\", RPCArg::Type::AMOUNT, true},\n-                            {\"maximumAmount\", RPCArg::Type::AMOUNT, true},\n-                            {\"maximumCount\", RPCArg::Type::NUM, true},\n-                            {\"minimumSumAmount\", RPCArg::Type::AMOUNT, true},\n+                            {\"minimumAmount\", RPCArg::Type::AMOUNT, /* opt */ true, /* default_val */ \"0\", \"Minimum value of each UTXO in \" + CURRENCY_UNIT + \"\"},\n+                            {\"maximumAmount\", RPCArg::Type::AMOUNT, /* opt */ true, /* default_val */ \"unlimited\", \"Maximum value of each UTXO in \" + CURRENCY_UNIT + \"\"},\n+                            {\"maximumCount\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"unlimited\", \"Maximum number of UTXOs\"},\n+                            {\"minimumSumAmount\", RPCArg::Type::AMOUNT, /* opt */ true, /* default_val */ \"unlimited\", \"Minimum sum value of all UTXOs in \" + CURRENCY_UNIT + \"\"},\n                         },\n-                        true, \"query_options\"},\n+                        \"query_options\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. minconf          (numeric, optional, default=1) The minimum confirmations to filter\\n\"\n-            \"2. maxconf          (numeric, optional, default=9999999) The maximum confirmations to filter\\n\"\n-            \"3. \\\"addresses\\\"      (string) A json array of bitcoin addresses to filter\\n\"\n-            \"    [\\n\"\n-            \"      \\\"address\\\"     (string) bitcoin address\\n\"\n-            \"      ,...\\n\"\n-            \"    ]\\n\"\n-            \"4. include_unsafe (bool, optional, default=true) Include outputs that are not safe to spend\\n\"\n-            \"                  See description of \\\"safe\\\" attribute below.\\n\"\n-            \"5. query_options    (json, optional) JSON with query options\\n\"\n-            \"    {\\n\"\n-            \"      \\\"minimumAmount\\\"    (numeric or string, default=0) Minimum value of each UTXO in \" + CURRENCY_UNIT + \"\\n\"\n-            \"      \\\"maximumAmount\\\"    (numeric or string, default=unlimited) Maximum value of each UTXO in \" + CURRENCY_UNIT + \"\\n\"\n-            \"      \\\"maximumCount\\\"     (numeric or string, default=unlimited) Maximum number of UTXOs\\n\"\n-            \"      \\\"minimumSumAmount\\\" (numeric or string, default=unlimited) Minimum sum value of all UTXOs in \" + CURRENCY_UNIT + \"\\n\"\n-            \"    }\\n\"\n             \"\\nResult\\n\"\n             \"[                   (array of json object)\\n\"\n             \"  {\\n\"\n@@ -3115,56 +3011,36 @@ static UniValue fundrawtransaction(const JSONRPCRequest& request)\n                 \"You can see whether this is the case by checking the \\\"solvable\\\" field in the listunspent output.\\n\"\n                 \"Only pay-to-pubkey, multisig, and P2SH versions thereof are currently supported for watch-only\\n\",\n                 {\n-                    {\"hexstring\", RPCArg::Type::STR_HEX, false},\n-                    {\"options\", RPCArg::Type::OBJ,\n+                    {\"hexstring\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"The hex string of the raw transaction\"},\n+                    {\"options\", RPCArg::Type::OBJ, /* opt */ true, /* default_val */ \"null\", \"for backward compatibility: passing in a true instead of an object will result in {\\\"includeWatching\\\":true}\",\n                         {\n-                            {\"changeAddress\", RPCArg::Type::STR, true},\n-                            {\"changePosition\", RPCArg::Type::NUM, true},\n-                            {\"change_type\", RPCArg::Type::STR, true},\n-                            {\"includeWatching\", RPCArg::Type::BOOL, true},\n-                            {\"lockUnspents\", RPCArg::Type::BOOL, true},\n-                            {\"feeRate\", RPCArg::Type::AMOUNT, true},\n-                            {\"subtractFeeFromOutputs\", RPCArg::Type::ARR,\n+                            {\"changeAddress\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"pool address\", \"The bitcoin address to receive the change\"},\n+                            {\"changePosition\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"random\", \"The index of the change output\"},\n+                            {\"change_type\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"set by -changetype\", \"The output type to use. Only valid if changeAddress is not specified. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n+                            {\"includeWatching\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"Also select inputs which are watch only\"},\n+                            {\"lockUnspents\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"Lock selected unspent outputs\"},\n+                            {\"feeRate\", RPCArg::Type::AMOUNT, /* opt */ true, /* default_val */ \"not set: makes wallet determine the fee\", \"Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\"},\n+                            {\"subtractFeeFromOutputs\", RPCArg::Type::ARR, /* opt */ true, /* default_val */ \"empty array\", \"A json array of integers.\\n\"\n+                            \"                              The fee will be equally deducted from the amount of each specified output.\\n\"\n+                            \"                              Those recipients will receive less bitcoins than you enter in their corresponding amount field.\\n\"\n+                            \"                              If no outputs are specified here, the sender pays the fee.\",\n                                 {\n-                                    {\"vout_index\", RPCArg::Type::NUM, true},\n+                                    {\"vout_index\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"\", \"The zero-based output index, before a change output is added.\"},\n                                 },\n-                                true},\n-                            {\"replaceable\", RPCArg::Type::BOOL, true},\n-                            {\"conf_target\", RPCArg::Type::NUM, true},\n-                            {\"estimate_mode\", RPCArg::Type::STR, true},\n+                            },\n+                            {\"replaceable\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"fallback to wallet's default\", \"Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                              Allows this transaction to be replaced by a transaction with higher fees\"},\n+                            {\"conf_target\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"fallback to wallet's default\", \"Confirmation target (in blocks)\"},\n+                            {\"estimate_mode\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"UNSET\", \"The fee estimate mode, must be one of:\\n\"\n+                            \"         \\\"UNSET\\\"\\n\"\n+                            \"         \\\"ECONOMICAL\\\"\\n\"\n+                            \"         \\\"CONSERVATIVE\\\"\"},\n                         },\n-                        true, \"options\"},\n-                    {\"iswitness\", RPCArg::Type::BOOL, true},\n+                        \"options\"},\n+                    {\"iswitness\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"depends on heuristic tests\", \"Whether the transaction hex is a serialized witness transaction \\n\"\n+                            \"                              If iswitness is not present, heuristic tests will be used in decoding\"},\n                 }}\n                 .ToString() +\n-                            \"\\nArguments:\\n\"\n-                            \"1. \\\"hexstring\\\"           (string, required) The hex string of the raw transaction\\n\"\n-                            \"2. options                 (object, optional)\\n\"\n-                            \"   {\\n\"\n-                            \"     \\\"changeAddress\\\"          (string, optional, default pool address) The bitcoin address to receive the change\\n\"\n-                            \"     \\\"changePosition\\\"         (numeric, optional, default random) The index of the change output\\n\"\n-                            \"     \\\"change_type\\\"            (string, optional) The output type to use. Only valid if changeAddress is not specified. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\". Default is set by -changetype.\\n\"\n-                            \"     \\\"includeWatching\\\"        (boolean, optional, default false) Also select inputs which are watch only\\n\"\n-                            \"     \\\"lockUnspents\\\"           (boolean, optional, default false) Lock selected unspent outputs\\n\"\n-                            \"     \\\"feeRate\\\"                (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n-                            \"     \\\"subtractFeeFromOutputs\\\" (array, optional) A json array of integers.\\n\"\n-                            \"                              The fee will be equally deducted from the amount of each specified output.\\n\"\n-                            \"                              The outputs are specified by their zero-based index, before any change output is added.\\n\"\n-                            \"                              Those recipients will receive less bitcoins than you enter in their corresponding amount field.\\n\"\n-                            \"                              If no outputs are specified here, the sender pays the fee.\\n\"\n-                            \"                                  [vout_index,...]\\n\"\n-                            \"     \\\"replaceable\\\"            (boolean, optional) Marks this transaction as BIP125 replaceable.\\n\"\n-                            \"                              Allows this transaction to be replaced by a transaction with higher fees\\n\"\n-                            \"     \\\"conf_target\\\"            (numeric, optional) Confirmation target (in blocks)\\n\"\n-                            \"     \\\"estimate_mode\\\"          (string, optional, default=UNSET) The fee estimate mode, must be one of:\\n\"\n-                            \"         \\\"UNSET\\\"\\n\"\n-                            \"         \\\"ECONOMICAL\\\"\\n\"\n-                            \"         \\\"CONSERVATIVE\\\"\\n\"\n-                            \"   }\\n\"\n-                            \"                         for backward compatibility: passing in a true instead of an object will result in {\\\"includeWatching\\\":true}\\n\"\n-                            \"3. iswitness               (boolean, optional) Whether the transaction hex is a serialized witness transaction \\n\"\n-                            \"                              If iswitness is not present, heuristic tests will be used in decoding\\n\"\n-\n                             \"\\nResult:\\n\"\n                             \"{\\n\"\n                             \"  \\\"hex\\\":       \\\"value\\\", (string)  The resulting raw transaction (hex-encoded string)\\n\"\n@@ -3218,48 +3094,32 @@ UniValue signrawtransactionwithwallet(const JSONRPCRequest& request)\n             RPCHelpMan{\"signrawtransactionwithwallet\",\n                 \"\\nSign inputs for raw transaction (serialized, hex-encoded).\\n\"\n                 \"The second optional argument (may be null) is an array of previous transaction outputs that\\n\"\n-                \"this transaction depends on but may not yet be in the block chain.\\n\",\n+                \"this transaction depends on but may not yet be in the block chain.\" +\n+                    HelpRequiringPassphrase(pwallet) + \"\\n\",\n                 {\n-                    {\"hexstring\", RPCArg::Type::STR, false},\n-                    {\"prevtxs\", RPCArg::Type::ARR,\n+                    {\"hexstring\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The transaction hex string\"},\n+                    {\"prevtxs\", RPCArg::Type::ARR, /* opt */ true, /* default_val */ \"null\", \"A json array of previous dependent transaction outputs\",\n                         {\n-                            {\"\", RPCArg::Type::OBJ,\n+                            {\"\", RPCArg::Type::OBJ, /* opt */ false, /* default_val */ \"\", \"\",\n                                 {\n-                                    {\"txid\", RPCArg::Type::STR_HEX, false},\n-                                    {\"vout\", RPCArg::Type::NUM, false},\n-                                    {\"scriptPubKey\", RPCArg::Type::STR_HEX, false},\n-                                    {\"redeemScript\", RPCArg::Type::STR_HEX, false},\n-                                    {\"amount\", RPCArg::Type::AMOUNT, false},\n+                                    {\"txid\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"The transaction id\"},\n+                                    {\"vout\", RPCArg::Type::NUM, /* opt */ false, /* default_val */ \"\", \"The output number\"},\n+                                    {\"scriptPubKey\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"script key\"},\n+                                    {\"redeemScript\", RPCArg::Type::STR_HEX, /* opt */ true, /* default_val */ \"omitted\", \"(required for P2SH or P2WSH)\"},\n+                                    {\"amount\", RPCArg::Type::AMOUNT, /* opt */ false, /* default_val */ \"\", \"The amount spent\"},\n                                 },\n-                                false},\n+                            },\n                         },\n-                        true},\n-                    {\"sighashtype\", RPCArg::Type::STR, true},\n-                }}\n-                .ToString() +\n-            HelpRequiringPassphrase(pwallet) + \"\\n\"\n-\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"hexstring\\\"                      (string, required) The transaction hex string\\n\"\n-            \"2. \\\"prevtxs\\\"                        (string, optional) An json array of previous dependent transaction outputs\\n\"\n-            \"     [                              (json array of json objects, or 'null' if none provided)\\n\"\n-            \"       {\\n\"\n-            \"         \\\"txid\\\":\\\"id\\\",               (string, required) The transaction id\\n\"\n-            \"         \\\"vout\\\":n,                  (numeric, required) The output number\\n\"\n-            \"         \\\"scriptPubKey\\\": \\\"hex\\\",     (string, required) script key\\n\"\n-            \"         \\\"redeemScript\\\": \\\"hex\\\",     (string, required for P2SH or P2WSH) redeem script\\n\"\n-            \"         \\\"amount\\\": value            (numeric, required) The amount spent\\n\"\n-            \"       }\\n\"\n-            \"       ,...\\n\"\n-            \"    ]\\n\"\n-            \"3. \\\"sighashtype\\\"                    (string, optional, default=ALL) The signature hash type. Must be one of\\n\"\n+                    },\n+                    {\"sighashtype\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"ALL\", \"The signature hash type. Must be one of\\n\"\n             \"       \\\"ALL\\\"\\n\"\n             \"       \\\"NONE\\\"\\n\"\n             \"       \\\"SINGLE\\\"\\n\"\n             \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n             \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n-            \"       \\\"SINGLE|ANYONECANPAY\\\"\\n\"\n-\n+            \"       \\\"SINGLE|ANYONECANPAY\\\"\"},\n+                }}\n+                .ToString() +\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"hex\\\" : \\\"value\\\",                  (string) The hex-encoded raw transaction with signature(s)\\n\"\n@@ -3320,38 +3180,29 @@ static UniValue bumpfee(const JSONRPCRequest& request)\n                 \"At a minimum, the new fee rate must be high enough to pay an additional new relay fee (incrementalfee\\n\"\n                 \"returned by getnetworkinfo) to enter the node's mempool.\\n\",\n                 {\n-                    {\"txid\", RPCArg::Type::STR_HEX, false},\n-                    {\"options\", RPCArg::Type::OBJ,\n+                    {\"txid\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"The txid to be bumped\"},\n+                    {\"options\", RPCArg::Type::OBJ, /* opt */ true, /* default_val */ \"null\", \"\",\n                         {\n-                            {\"confTarget\", RPCArg::Type::NUM, true},\n-                            {\"totalFee\", RPCArg::Type::AMOUNT, true},\n-                            {\"replaceable\", RPCArg::Type::BOOL, true},\n-                            {\"estimate_mode\", RPCArg::Type::STR, true},\n-                        },\n-                        true, \"options\"},\n-                }}\n-                .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. txid                  (string, required) The txid to be bumped\\n\"\n-            \"2. options               (object, optional)\\n\"\n-            \"   {\\n\"\n-            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n-            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis.\\n\"\n+                            {\"confTarget\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"fallback to wallet's default\", \"Confirmation target (in blocks)\"},\n+                            {\"totalFee\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"fallback to 'confTarget'\", \"Total fee (NOT feerate) to pay, in satoshis.\\n\"\n             \"                         In rare cases, the actual fee paid might be slightly higher than the specified\\n\"\n             \"                         totalFee if the tx change output has to be removed because it is too close to\\n\"\n-            \"                         the dust threshold.\\n\"\n-            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         the dust threshold.\"},\n+                            {\"replaceable\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"true\", \"Whether the new transaction should still be\\n\"\n             \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n             \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n             \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n             \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n             \"                         still be replaceable in practice, for example if it has unconfirmed ancestors which\\n\"\n-            \"                         are replaceable).\\n\"\n-            \"     \\\"estimate_mode\\\"     (string, optional, default=UNSET) The fee estimate mode, must be one of:\\n\"\n+            \"                         are replaceable).\"},\n+                            {\"estimate_mode\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"UNSET\", \"The fee estimate mode, must be one of:\\n\"\n             \"         \\\"UNSET\\\"\\n\"\n             \"         \\\"ECONOMICAL\\\"\\n\"\n-            \"         \\\"CONSERVATIVE\\\"\\n\"\n-            \"   }\\n\"\n+            \"         \\\"CONSERVATIVE\\\"\"},\n+                        },\n+                        \"options\"},\n+                }}\n+                .ToString() +\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n@@ -3474,13 +3325,10 @@ UniValue generate(const JSONRPCRequest& request)\n             RPCHelpMan{\"generate\",\n                 \"\\nMine up to nblocks blocks immediately (before the RPC call returns) to an address in the wallet.\\n\",\n                 {\n-                    {\"nblocks\", RPCArg::Type::NUM, false},\n-                    {\"maxtries\", RPCArg::Type::NUM, true},\n+                    {\"nblocks\", RPCArg::Type::NUM, /* opt */ false, /* default_val */ \"\", \"How many blocks are generated immediately.\"},\n+                    {\"maxtries\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"1000000\", \"How many iterations to try.\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. nblocks      (numeric, required) How many blocks are generated immediately.\\n\"\n-            \"2. maxtries     (numeric, optional) How many iterations to try (default = 1000000).\\n\"\n             \"\\nResult:\\n\"\n             \"[ blockhashes ]     (array) hashes of blocks generated\\n\"\n             \"\\nExamples:\\n\"\n@@ -3531,13 +3379,10 @@ UniValue rescanblockchain(const JSONRPCRequest& request)\n             RPCHelpMan{\"rescanblockchain\",\n                 \"\\nRescan the local blockchain for wallet related transactions.\\n\",\n                 {\n-                    {\"start_height\", RPCArg::Type::NUM, true},\n-                    {\"stop_height\", RPCArg::Type::NUM, true},\n+                    {\"start_height\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"0\", \"block height where the rescan should start\"},\n+                    {\"stop_height\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"tip height\", \"the last block height that should be scanned\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"start_height\\\"    (numeric, optional) block height where the rescan should start\\n\"\n-            \"2. \\\"stop_height\\\"     (numeric, optional) the last block height that should be scanned\\n\"\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"start_height\\\"     (numeric) The block height where the rescan has started. If omitted, rescan started from the genesis block.\\n\"\n@@ -3592,16 +3437,17 @@ UniValue rescanblockchain(const JSONRPCRequest& request)\n         }\n     }\n \n-    CBlockIndex *stopBlock = pwallet->ScanForWalletTransactions(pindexStart, pindexStop, reserver, true);\n-    if (!stopBlock) {\n-        if (pwallet->IsAbortingRescan()) {\n-            throw JSONRPCError(RPC_MISC_ERROR, \"Rescan aborted.\");\n-        }\n-        // if we got a nullptr returned, ScanForWalletTransactions did rescan up to the requested stopindex\n-        stopBlock = pindexStop ? pindexStop : pChainTip;\n-    }\n-    else {\n+    const CBlockIndex *failed_block, *stopBlock;\n+    CWallet::ScanResult result =\n+        pwallet->ScanForWalletTransactions(pindexStart, pindexStop, reserver, failed_block, stopBlock, true);\n+    switch (result) {\n+    case CWallet::ScanResult::SUCCESS:\n+        break; // stopBlock set by ScanForWalletTransactions\n+    case CWallet::ScanResult::FAILURE:\n         throw JSONRPCError(RPC_MISC_ERROR, \"Rescan failed. Potentially corrupted data files.\");\n+    case CWallet::ScanResult::USER_ABORT:\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Rescan aborted.\");\n+        // no default case, so the compiler can warn about missing cases\n     }\n     UniValue response(UniValue::VOBJ);\n     response.pushKV(\"start_height\", pindexStart->nHeight);\n@@ -3743,11 +3589,9 @@ UniValue getaddressinfo(const JSONRPCRequest& request)\n                 \"\\nReturn information about the given bitcoin address. Some information requires the address\\n\"\n                 \"to be in the wallet.\\n\",\n                 {\n-                    {\"address\", RPCArg::Type::STR, false},\n+                    {\"address\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The bitcoin address to get the information of.\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"address\\\"                    (string, required) The bitcoin address to get the information of.\\n\"\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"address\\\" : \\\"address\\\",        (string) The bitcoin address validated\\n\"\n@@ -3873,11 +3717,9 @@ static UniValue getaddressesbylabel(const JSONRPCRequest& request)\n             RPCHelpMan{\"getaddressesbylabel\",\n                 \"\\nReturns the list of addresses assigned the specified label.\\n\",\n                 {\n-                    {\"label\", RPCArg::Type::STR, false},\n+                    {\"label\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The label.\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"label\\\"  (string, required) The label.\\n\"\n             \"\\nResult:\\n\"\n             \"{ (json object with addresses as keys)\\n\"\n             \"  \\\"address\\\": { (json object with information about address)\\n\"\n@@ -3922,11 +3764,9 @@ static UniValue listlabels(const JSONRPCRequest& request)\n             RPCHelpMan{\"listlabels\",\n                 \"\\nReturns the list of all labels, or labels that are assigned to addresses with a specific purpose.\\n\",\n                 {\n-                    {\"purpose\", RPCArg::Type::STR, true},\n+                    {\"purpose\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"null\", \"Address purpose to list labels for ('send','receive'). An empty string is the same as not providing this argument.\"},\n                 }}\n                 .ToString() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"purpose\\\"    (string, optional) Address purpose to list labels for ('send','receive'). An empty string is the same as not providing this argument.\\n\"\n             \"\\nResult:\\n\"\n             \"[               (json array of string)\\n\"\n             \"  \\\"label\\\",      (string) Label name\\n\"\n@@ -3980,20 +3820,17 @@ UniValue sethdseed(const JSONRPCRequest& request)\n             RPCHelpMan{\"sethdseed\",\n                 \"\\nSet or generate a new HD wallet seed. Non-HD wallets will not be upgraded to being a HD wallet. Wallets that are already\\n\"\n                 \"HD will have a new HD seed set so that new keys added to the keypool will be derived from this new seed.\\n\"\n-                \"\\nNote that you will need to MAKE A NEW BACKUP of your wallet after setting the HD wallet seed.\\n\",\n+                \"\\nNote that you will need to MAKE A NEW BACKUP of your wallet after setting the HD wallet seed.\" +\n+                    HelpRequiringPassphrase(pwallet) + \"\\n\",\n                 {\n-                    {\"newkeypool\", RPCArg::Type::BOOL, true},\n-                    {\"seed\", RPCArg::Type::STR, true},\n-                }}\n-                .ToString()\n-            + HelpRequiringPassphrase(pwallet) +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"newkeypool\\\"         (boolean, optional, default=true) Whether to flush old unused addresses, including change addresses, from the keypool and regenerate it.\\n\"\n+                    {\"newkeypool\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"true\", \"Whether to flush old unused addresses, including change addresses, from the keypool and regenerate it.\\n\"\n             \"                             If true, the next address from getnewaddress and change address from getrawchangeaddress will be from this new seed.\\n\"\n             \"                             If false, addresses (including change addresses if the wallet already had HD Chain Split enabled) from the existing\\n\"\n-            \"                             keypool will be used until it has been depleted.\\n\"\n-            \"2. \\\"seed\\\"               (string, optional) The WIF private key to use as the new HD seed; if not provided a random seed will be used.\\n\"\n-            \"                             The seed value can be retrieved using the dumpwallet command. It is the private key marked hdseed=1\\n\"\n+            \"                             keypool will be used until it has been depleted.\"},\n+                    {\"seed\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"random seed\", \"The WIF private key to use as the new HD seed.\\n\"\n+            \"                             The seed value can be retrieved using the dumpwallet command. It is the private key marked hdseed=1\"},\n+                }}\n+                .ToString() +\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"sethdseed\", \"\")\n             + HelpExampleCli(\"sethdseed\", \"false\")\n@@ -4123,28 +3960,21 @@ UniValue walletprocesspsbt(const JSONRPCRequest& request)\n         throw std::runtime_error(\n             RPCHelpMan{\"walletprocesspsbt\",\n                 \"\\nUpdate a PSBT with input information from our wallet and then sign inputs\\n\"\n-                \"that we can sign for.\\n\",\n+                \"that we can sign for.\" +\n+                    HelpRequiringPassphrase(pwallet) + \"\\n\",\n                 {\n-                    {\"psbt\", RPCArg::Type::STR, false},\n-                    {\"sign\", RPCArg::Type::BOOL, true},\n-                    {\"sighashtype\", RPCArg::Type::STR, true},\n-                    {\"bip32derivs\", RPCArg::Type::BOOL, true},\n-                }}\n-                .ToString() +\n-            HelpRequiringPassphrase(pwallet) + \"\\n\"\n-\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"psbt\\\"                      (string, required) The transaction base64 string\\n\"\n-            \"2. sign                          (boolean, optional, default=true) Also sign the transaction when updating\\n\"\n-            \"3. \\\"sighashtype\\\"            (string, optional, default=ALL) The signature hash type to sign with if not specified by the PSBT. Must be one of\\n\"\n+                    {\"psbt\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The transaction base64 string\"},\n+                    {\"sign\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"true\", \"Also sign the transaction when updating\"},\n+                    {\"sighashtype\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"ALL\", \"The signature hash type to sign with if not specified by the PSBT. Must be one of\\n\"\n             \"       \\\"ALL\\\"\\n\"\n             \"       \\\"NONE\\\"\\n\"\n             \"       \\\"SINGLE\\\"\\n\"\n             \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n             \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n-            \"       \\\"SINGLE|ANYONECANPAY\\\"\\n\"\n-            \"4. bip32derivs                    (boolean, optional, default=false) If true, includes the BIP 32 derivation paths for public keys if we know them\\n\"\n-\n+            \"       \\\"SINGLE|ANYONECANPAY\\\"\"},\n+                    {\"bip32derivs\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"If true, includes the BIP 32 derivation paths for public keys if we know them\"},\n+                }}\n+                .ToString() +\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n@@ -4197,99 +4027,64 @@ UniValue walletcreatefundedpsbt(const JSONRPCRequest& request)\n                 \"\\nCreates and funds a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n                 \"Implements the Creator and Updater roles.\\n\",\n                 {\n-                    {\"inputs\", RPCArg::Type::ARR,\n+                    {\"inputs\", RPCArg::Type::ARR, /* opt */ false, /* default_val */ \"\", \"A json array of json objects\",\n                         {\n-                            {\"\", RPCArg::Type::OBJ,\n+                            {\"\", RPCArg::Type::OBJ, /* opt */ false, /* default_val */ \"\", \"\",\n                                 {\n-                                    {\"txid\", RPCArg::Type::STR_HEX, false},\n-                                    {\"vout\", RPCArg::Type::NUM, false},\n-                                    {\"sequence\", RPCArg::Type::NUM, false},\n+                                    {\"txid\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"The transaction id\"},\n+                                    {\"vout\", RPCArg::Type::NUM, /* opt */ false, /* default_val */ \"\", \"The output number\"},\n+                                    {\"sequence\", RPCArg::Type::NUM, /* opt */ false, /* default_val */ \"\", \"The sequence number\"},\n                                 },\n-                                false},\n+                            },\n+                        },\n                         },\n-                        false},\n-                    {\"outputs\", RPCArg::Type::ARR,\n+                    {\"outputs\", RPCArg::Type::ARR, /* opt */ false, /* default_val */ \"\", \"a json array with outputs (key-value pairs), where none of the keys are duplicated.\\n\"\n+                            \"That is, each address can only appear once and there can only be one 'data' object.\\n\"\n+                            \"For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+                            \"                             accepted as second parameter.\",\n                         {\n-                            {\"\", RPCArg::Type::OBJ,\n+                            {\"\", RPCArg::Type::OBJ, /* opt */ true, /* default_val */ \"\", \"\",\n                                 {\n-                                    {\"address\", RPCArg::Type::AMOUNT, true},\n+                                    {\"address\", RPCArg::Type::AMOUNT, /* opt */ false, /* default_val */ \"\", \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n                                 },\n-                                true},\n-                            {\"\", RPCArg::Type::OBJ,\n+                                },\n+                            {\"\", RPCArg::Type::OBJ, /* opt */ true, /* default_val */ \"\", \"\",\n                                 {\n-                                    {\"data\", RPCArg::Type::STR_HEX, true},\n+                                    {\"data\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"A key-value pair. The key must be \\\"data\\\", the value is hex-encoded data\"},\n                                 },\n-                                true},\n+                            },\n                         },\n-                        false},\n-                    {\"locktime\", RPCArg::Type::NUM, true},\n-                    {\"options\", RPCArg::Type::OBJ,\n+                    },\n+                    {\"locktime\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"0\", \"Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n+                            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\"},\n+                    {\"options\", RPCArg::Type::OBJ, /* opt */ true, /* default_val */ \"null\", \"\",\n                         {\n-                            {\"changeAddress\", RPCArg::Type::STR_HEX, true},\n-                            {\"changePosition\", RPCArg::Type::NUM, true},\n-                            {\"change_type\", RPCArg::Type::STR, true},\n-                            {\"includeWatching\", RPCArg::Type::BOOL, true},\n-                            {\"lockUnspents\", RPCArg::Type::BOOL, true},\n-                            {\"feeRate\", RPCArg::Type::AMOUNT, true},\n-                            {\"subtractFeeFromOutputs\", RPCArg::Type::ARR,\n+                            {\"changeAddress\", RPCArg::Type::STR_HEX, /* opt */ true, /* default_val */ \"pool address\", \"The bitcoin address to receive the change\"},\n+                            {\"changePosition\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"random\", \"The index of the change output\"},\n+                            {\"change_type\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"set by -changetype\", \"The output type to use. Only valid if changeAddress is not specified. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n+                            {\"includeWatching\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"Also select inputs which are watch only\"},\n+                            {\"lockUnspents\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"Lock selected unspent outputs\"},\n+                            {\"feeRate\", RPCArg::Type::AMOUNT, /* opt */ true, /* default_val */ \"not set: makes wallet determine the fee\", \"Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\"},\n+                            {\"subtractFeeFromOutputs\", RPCArg::Type::ARR, /* opt */ true, /* default_val */ \"empty array\", \"A json array of integers.\\n\"\n+                            \"                              The fee will be equally deducted from the amount of each specified output.\\n\"\n+                            \"                              Those recipients will receive less bitcoins than you enter in their corresponding amount field.\\n\"\n+                            \"                              If no outputs are specified here, the sender pays the fee.\",\n                                 {\n-                                    {\"int\", RPCArg::Type::NUM, true},\n+                                    {\"vout_index\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"\", \"The zero-based output index, before a change output is added.\"},\n                                 },\n-                                true},\n-                            {\"replaceable\", RPCArg::Type::BOOL, true},\n-                            {\"conf_target\", RPCArg::Type::NUM, true},\n-                            {\"estimate_mode\", RPCArg::Type::STR, true},\n+                            },\n+                            {\"replaceable\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                              Allows this transaction to be replaced by a transaction with higher fees\"},\n+                            {\"conf_target\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"Fallback to wallet's confirmation target\", \"Confirmation target (in blocks)\"},\n+                            {\"estimate_mode\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"UNSET\", \"The fee estimate mode, must be one of:\\n\"\n+                            \"         \\\"UNSET\\\"\\n\"\n+                            \"         \\\"ECONOMICAL\\\"\\n\"\n+                            \"         \\\"CONSERVATIVE\\\"\"},\n                         },\n-                        true, \"options\"},\n-                    {\"bip32derivs\", RPCArg::Type::BOOL, true},\n+                        \"options\"},\n+                    {\"bip32derivs\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"If true, includes the BIP 32 derivation paths for public keys if we know them\"},\n                 }}\n                 .ToString() +\n-                            \"\\nArguments:\\n\"\n-                            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n-                            \"     [\\n\"\n-                            \"       {\\n\"\n-                            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n-                            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n-                            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n-                            \"       } \\n\"\n-                            \"       ,...\\n\"\n-                            \"     ]\\n\"\n-                            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n-                            \"   [\\n\"\n-                            \"    {\\n\"\n-                            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n-                            \"    },\\n\"\n-                            \"    {\\n\"\n-                            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex-encoded data\\n\"\n-                            \"    }\\n\"\n-                            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n-                            \"                             accepted as second parameter.\\n\"\n-                            \"   ]\\n\"\n-                            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n-                            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n-                            \"4. options                 (object, optional)\\n\"\n-                            \"   {\\n\"\n-                            \"     \\\"changeAddress\\\"          (string, optional, default pool address) The bitcoin address to receive the change\\n\"\n-                            \"     \\\"changePosition\\\"         (numeric, optional, default random) The index of the change output\\n\"\n-                            \"     \\\"change_type\\\"            (string, optional) The output type to use. Only valid if changeAddress is not specified. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\". Default is set by -changetype.\\n\"\n-                            \"     \\\"includeWatching\\\"        (boolean, optional, default false) Also select inputs which are watch only\\n\"\n-                            \"     \\\"lockUnspents\\\"           (boolean, optional, default false) Lock selected unspent outputs\\n\"\n-                            \"     \\\"feeRate\\\"                (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n-                            \"     \\\"subtractFeeFromOutputs\\\" (array, optional) A json array of integers.\\n\"\n-                            \"                              The fee will be equally deducted from the amount of each specified output.\\n\"\n-                            \"                              The outputs are specified by their zero-based index, before any change output is added.\\n\"\n-                            \"                              Those recipients will receive less bitcoins than you enter in their corresponding amount field.\\n\"\n-                            \"                              If no outputs are specified here, the sender pays the fee.\\n\"\n-                            \"                                  [vout_index,...]\\n\"\n-                            \"     \\\"replaceable\\\"            (boolean, optional) Marks this transaction as BIP125 replaceable.\\n\"\n-                            \"                              Allows this transaction to be replaced by a transaction with higher fees\\n\"\n-                            \"     \\\"conf_target\\\"            (numeric, optional) Confirmation target (in blocks)\\n\"\n-                            \"     \\\"estimate_mode\\\"          (string, optional, default=UNSET) The fee estimate mode, must be one of:\\n\"\n-                            \"         \\\"UNSET\\\"\\n\"\n-                            \"         \\\"ECONOMICAL\\\"\\n\"\n-                            \"         \\\"CONSERVATIVE\\\"\\n\"\n-                            \"   }\\n\"\n-                            \"5. bip32derivs                    (boolean, optional, default=false) If true, includes the BIP 32 derivation paths for public keys if we know them\\n\"\n                             \"\\nResult:\\n\"\n                             \"{\\n\"\n                             \"  \\\"psbt\\\": \\\"value\\\",        (string)  The resulting raw transaction (base64-encoded string)\\n\""
      },
      {
        "sha": "1ed1926af2471118cb2f9c26c3eaaa79bb24080d",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 106,
        "deletions": 5,
        "changes": 111,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -17,6 +17,7 @@\n #include <validation.h>\n #include <wallet/coincontrol.h>\n #include <wallet/test/wallet_test_fixture.h>\n+#include <policy/policy.h>\n \n #include <boost/test/unit_test.hpp>\n #include <univalue.h>\n@@ -33,27 +34,43 @@ static void AddKey(CWallet& wallet, const CKey& key)\n     wallet.AddKeyPubKey(key, key.GetPubKey());\n }\n \n-BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n+BOOST_FIXTURE_TEST_CASE(scan_for_wallet_transactions, TestChain100Setup)\n {\n     auto chain = interfaces::MakeChain();\n \n     // Cap last block file size, and mine new block in a new block file.\n-    CBlockIndex* const nullBlock = nullptr;\n+    const CBlockIndex* const null_block = nullptr;\n     CBlockIndex* oldTip = chainActive.Tip();\n     GetBlockFileInfo(oldTip->GetBlockPos().nFile)->nSize = MAX_BLOCKFILE_SIZE;\n     CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey()));\n     CBlockIndex* newTip = chainActive.Tip();\n \n     auto locked_chain = chain->lock();\n \n+    // Verify ScanForWalletTransactions accomodates a null start block.\n+    {\n+        CWallet wallet(*chain, WalletLocation(), WalletDatabase::CreateDummy());\n+        AddKey(wallet, coinbaseKey);\n+        WalletRescanReserver reserver(&wallet);\n+        reserver.reserve();\n+        const CBlockIndex *stop_block = null_block + 1, *failed_block = null_block + 1;\n+        BOOST_CHECK_EQUAL(wallet.ScanForWalletTransactions(nullptr, nullptr, reserver, failed_block, stop_block), CWallet::ScanResult::SUCCESS);\n+        BOOST_CHECK_EQUAL(failed_block, null_block);\n+        BOOST_CHECK_EQUAL(stop_block, null_block);\n+        BOOST_CHECK_EQUAL(wallet.GetImmatureBalance(), 0);\n+    }\n+\n     // Verify ScanForWalletTransactions picks up transactions in both the old\n     // and new block files.\n     {\n         CWallet wallet(*chain, WalletLocation(), WalletDatabase::CreateDummy());\n         AddKey(wallet, coinbaseKey);\n         WalletRescanReserver reserver(&wallet);\n         reserver.reserve();\n-        BOOST_CHECK_EQUAL(nullBlock, wallet.ScanForWalletTransactions(oldTip, nullptr, reserver));\n+        const CBlockIndex *stop_block = null_block + 1, *failed_block = null_block + 1;\n+        BOOST_CHECK_EQUAL(wallet.ScanForWalletTransactions(oldTip, nullptr, reserver, failed_block, stop_block), CWallet::ScanResult::SUCCESS);\n+        BOOST_CHECK_EQUAL(failed_block, null_block);\n+        BOOST_CHECK_EQUAL(stop_block, newTip);\n         BOOST_CHECK_EQUAL(wallet.GetImmatureBalance(), 100 * COIN);\n     }\n \n@@ -68,10 +85,47 @@ BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n         AddKey(wallet, coinbaseKey);\n         WalletRescanReserver reserver(&wallet);\n         reserver.reserve();\n-        BOOST_CHECK_EQUAL(oldTip, wallet.ScanForWalletTransactions(oldTip, nullptr, reserver));\n+        const CBlockIndex *stop_block = null_block + 1, *failed_block = null_block + 1;\n+        BOOST_CHECK_EQUAL(wallet.ScanForWalletTransactions(oldTip, nullptr, reserver, failed_block, stop_block), CWallet::ScanResult::FAILURE);\n+        BOOST_CHECK_EQUAL(failed_block, oldTip);\n+        BOOST_CHECK_EQUAL(stop_block, newTip);\n         BOOST_CHECK_EQUAL(wallet.GetImmatureBalance(), 50 * COIN);\n     }\n \n+    // Prune the remaining block file.\n+    PruneOneBlockFile(newTip->GetBlockPos().nFile);\n+    UnlinkPrunedFiles({newTip->GetBlockPos().nFile});\n+\n+    // Verify ScanForWalletTransactions scans no blocks.\n+    {\n+        CWallet wallet(*chain, WalletLocation(), WalletDatabase::CreateDummy());\n+        AddKey(wallet, coinbaseKey);\n+        WalletRescanReserver reserver(&wallet);\n+        reserver.reserve();\n+        const CBlockIndex *stop_block = null_block + 1, *failed_block = null_block + 1;\n+        BOOST_CHECK_EQUAL(wallet.ScanForWalletTransactions(oldTip, nullptr, reserver, failed_block, stop_block), CWallet::ScanResult::FAILURE);\n+        BOOST_CHECK_EQUAL(failed_block, newTip);\n+        BOOST_CHECK_EQUAL(stop_block, null_block);\n+        BOOST_CHECK_EQUAL(wallet.GetImmatureBalance(), 0);\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(importmulti_rescan, TestChain100Setup)\n+{\n+    auto chain = interfaces::MakeChain();\n+\n+    // Cap last block file size, and mine new block in a new block file.\n+    CBlockIndex* oldTip = chainActive.Tip();\n+    GetBlockFileInfo(oldTip->GetBlockPos().nFile)->nSize = MAX_BLOCKFILE_SIZE;\n+    CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey()));\n+    CBlockIndex* newTip = chainActive.Tip();\n+\n+    auto locked_chain = chain->lock();\n+\n+    // Prune the older block file.\n+    PruneOneBlockFile(oldTip->GetBlockPos().nFile);\n+    UnlinkPrunedFiles({oldTip->GetBlockPos().nFile});\n+\n     // Verify importmulti RPC returns failure for a key whose creation time is\n     // before the missing block, and success for a key whose creation time is\n     // after.\n@@ -286,7 +340,11 @@ class ListCoinsTestingSetup : public TestChain100Setup\n         AddKey(*wallet, coinbaseKey);\n         WalletRescanReserver reserver(wallet.get());\n         reserver.reserve();\n-        wallet->ScanForWalletTransactions(chainActive.Genesis(), nullptr, reserver);\n+        const CBlockIndex* const null_block = nullptr;\n+        const CBlockIndex *stop_block = null_block + 1, *failed_block = null_block + 1;\n+        BOOST_CHECK_EQUAL(wallet->ScanForWalletTransactions(chainActive.Genesis(), nullptr, reserver, failed_block, stop_block), CWallet::ScanResult::SUCCESS);\n+        BOOST_CHECK_EQUAL(stop_block, chainActive.Tip());\n+        BOOST_CHECK_EQUAL(failed_block, null_block);\n     }\n \n     ~ListCoinsTestingSetup()\n@@ -394,4 +452,47 @@ BOOST_FIXTURE_TEST_CASE(wallet_disableprivkeys, TestChain100Setup)\n     BOOST_CHECK(!wallet->GetKeyFromPool(pubkey, false));\n }\n \n+// Explicit calculation which is used to test the wallet constant\n+// We get the same virtual size due to rounding(weight/4) for both use_max_sig values\n+static size_t CalculateNestedKeyhashInputSize(bool use_max_sig)\n+{\n+    // Generate ephemeral valid pubkey\n+    CKey key;\n+    key.MakeNewKey(true);\n+    CPubKey pubkey = key.GetPubKey();\n+\n+    // Generate pubkey hash\n+    uint160 key_hash(Hash160(pubkey.begin(), pubkey.end()));\n+\n+    // Create inner-script to enter into keystore. Key hash can't be 0...\n+    CScript inner_script = CScript() << OP_0 << std::vector<unsigned char>(key_hash.begin(), key_hash.end());\n+\n+    // Create outer P2SH script for the output\n+    uint160 script_id(Hash160(inner_script.begin(), inner_script.end()));\n+    CScript script_pubkey = CScript() << OP_HASH160 << std::vector<unsigned char>(script_id.begin(), script_id.end()) << OP_EQUAL;\n+\n+    // Add inner-script to key store and key to watchonly\n+    CBasicKeyStore keystore;\n+    keystore.AddCScript(inner_script);\n+    keystore.AddKeyPubKey(key, pubkey);\n+\n+    // Fill in dummy signatures for fee calculation.\n+    SignatureData sig_data;\n+\n+    if (!ProduceSignature(keystore, use_max_sig ? DUMMY_MAXIMUM_SIGNATURE_CREATOR : DUMMY_SIGNATURE_CREATOR, script_pubkey, sig_data)) {\n+        // We're hand-feeding it correct arguments; shouldn't happen\n+        assert(false);\n+    }\n+\n+    CTxIn tx_in;\n+    UpdateInput(tx_in, sig_data);\n+    return (size_t)GetVirtualTransactionInputSize(tx_in);\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(dummy_input_size_test, TestChain100Setup)\n+{\n+    BOOST_CHECK_EQUAL(CalculateNestedKeyhashInputSize(false), DUMMY_NESTED_P2WPKH_INPUT_SIZE);\n+    BOOST_CHECK_EQUAL(CalculateNestedKeyhashInputSize(true), DUMMY_NESTED_P2WPKH_INPUT_SIZE);\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "109f8e6da0e176d76b69660f7e578dfc8a80f277",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 56,
        "deletions": 91,
        "changes": 147,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -22,6 +22,7 @@\n #include <policy/rbf.h>\n #include <primitives/block.h>\n #include <primitives/transaction.h>\n+#include <script/descriptor.h>\n #include <script/script.h>\n #include <shutdown.h>\n #include <timedata.h>\n@@ -104,67 +105,17 @@ std::string COutput::ToString() const\n     return strprintf(\"COutput(%s, %d, %d) [%s]\", tx->GetHash().ToString(), i, nDepth, FormatMoney(tx->tx->vout[i].nValue));\n }\n \n-/** A class to identify which pubkeys a script and a keystore have in common. */\n-class CAffectedKeysVisitor : public boost::static_visitor<void> {\n-private:\n-    const CKeyStore &keystore;\n-    std::vector<CKeyID> &vKeys;\n-\n-public:\n-    /**\n-     * @param[in] keystoreIn The CKeyStore that is queried for the presence of a pubkey.\n-     * @param[out] vKeysIn A vector to which a script's pubkey identifiers are appended if they are in the keystore.\n-     */\n-    CAffectedKeysVisitor(const CKeyStore &keystoreIn, std::vector<CKeyID> &vKeysIn) : keystore(keystoreIn), vKeys(vKeysIn) {}\n-\n-    /**\n-     * Apply the visitor to each destination in a script, recursively to the redeemscript\n-     * in the case of p2sh destinations.\n-     * @param[in] script The CScript from which destinations are extracted.\n-     * @post Any CKeyIDs that script and keystore have in common are appended to the visitor's vKeys.\n-     */\n-    void Process(const CScript &script) {\n-        txnouttype type;\n-        std::vector<CTxDestination> vDest;\n-        int nRequired;\n-        if (ExtractDestinations(script, type, vDest, nRequired)) {\n-            for (const CTxDestination &dest : vDest)\n-                boost::apply_visitor(*this, dest);\n-        }\n-    }\n-\n-    void operator()(const CKeyID &keyId) {\n-        if (keystore.HaveKey(keyId))\n-            vKeys.push_back(keyId);\n-    }\n-\n-    void operator()(const CScriptID &scriptId) {\n-        CScript script;\n-        if (keystore.GetCScript(scriptId, script))\n-            Process(script);\n-    }\n-\n-    void operator()(const WitnessV0ScriptHash& scriptID)\n-    {\n-        CScriptID id;\n-        CRIPEMD160().Write(scriptID.begin(), 32).Finalize(id.begin());\n-        CScript script;\n-        if (keystore.GetCScript(id, script)) {\n-            Process(script);\n-        }\n-    }\n-\n-    void operator()(const WitnessV0KeyHash& keyid)\n-    {\n-        CKeyID id(keyid);\n-        if (keystore.HaveKey(id)) {\n-            vKeys.push_back(id);\n-        }\n+std::vector<CKeyID> GetAffectedKeys(const CScript& spk, const SigningProvider& provider)\n+{\n+    std::vector<CScript> dummy;\n+    FlatSigningProvider out;\n+    InferDescriptor(spk, provider)->Expand(0, DUMMY_SIGNING_PROVIDER, dummy, out);\n+    std::vector<CKeyID> ret;\n+    for (const auto& entry : out.pubkeys) {\n+        ret.push_back(entry.first);\n     }\n-\n-    template<typename X>\n-    void operator()(const X &none) {}\n-};\n+    return ret;\n+}\n \n const CWalletTx* CWallet::GetWalletTx(const uint256& hash) const\n {\n@@ -977,9 +928,7 @@ bool CWallet::AddToWalletIfInvolvingMe(const CTransactionRef& ptx, const CBlockI\n             // loop though all outputs\n             for (const CTxOut& txout: tx.vout) {\n                 // extract addresses and check if they match with an unused keypool key\n-                std::vector<CKeyID> vAffected;\n-                CAffectedKeysVisitor(*this, vAffected).Process(txout.scriptPubKey);\n-                for (const CKeyID &keyid : vAffected) {\n+                for (const auto& keyid : GetAffectedKeys(txout.scriptPubKey, *this)) {\n                     std::map<CKeyID, int64_t>::const_iterator mi = m_pool_key_to_index.find(keyid);\n                     if (mi != m_pool_key_to_index.end()) {\n                         WalletLogPrintf(\"%s: Detected a used keypool key, mark all keypool key up to this key as used\\n\", __func__);\n@@ -1530,8 +1479,6 @@ int CalculateMaximumSignedInputSize(const CTxOut& txout, const CWallet* wallet,\n     CMutableTransaction txn;\n     txn.vin.push_back(CTxIn(COutPoint()));\n     if (!wallet->DummySignInput(txn.vin[0], txout, use_max_sig)) {\n-        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n-        // implies that we can sign for every input.\n         return -1;\n     }\n     return GetVirtualTransactionInputSize(txn.vin[0]);\n@@ -1613,8 +1560,9 @@ int64_t CWallet::RescanFromTime(int64_t startTime, const WalletRescanReserver& r\n     }\n \n     if (startBlock) {\n-        const CBlockIndex* const failedBlock = ScanForWalletTransactions(startBlock, nullptr, reserver, update);\n-        if (failedBlock) {\n+        const CBlockIndex *failedBlock, *stop_block;\n+        // TODO: this should take into account failure by ScanResult::USER_ABORT\n+        if (ScanResult::FAILURE == ScanForWalletTransactions(startBlock, nullptr, reserver, failedBlock, stop_block, update)) {\n             return failedBlock->GetBlockTimeMax() + TIMESTAMP_WINDOW + 1;\n         }\n     }\n@@ -1626,18 +1574,22 @@ int64_t CWallet::RescanFromTime(int64_t startTime, const WalletRescanReserver& r\n  * from or to us. If fUpdate is true, found transactions that already\n  * exist in the wallet will be updated.\n  *\n- * Returns null if scan was successful. Otherwise, if a complete rescan was not\n- * possible (due to pruning or corruption), returns pointer to the most recent\n- * block that could not be scanned.\n+ * @param[in] pindexStop if not a nullptr, the scan will stop at this block-index\n+ * @param[out] failed_block if FAILURE is returned, the most recent block\n+ *     that could not be scanned, otherwise nullptr\n+ * @param[out] stop_block the most recent block that could be scanned,\n+ *     otherwise nullptr if no block could be scanned\n  *\n- * If pindexStop is not a nullptr, the scan will stop at the block-index\n- * defined by pindexStop\n+ * @return ScanResult indicating success or failure of the scan. SUCCESS if\n+ * scan was successful. FAILURE if a complete rescan was not possible (due to\n+ * pruning or corruption). USER_ABORT if the rescan was aborted before it\n+ * could complete.\n  *\n- * Caller needs to make sure pindexStop (and the optional pindexStart) are on\n+ * @pre Caller needs to make sure pindexStop (and the optional pindexStart) are on\n  * the main chain after to the addition of any new keys you want to detect\n  * transactions for.\n  */\n-CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, CBlockIndex* pindexStop, const WalletRescanReserver &reserver, bool fUpdate)\n+CWallet::ScanResult CWallet::ScanForWalletTransactions(const CBlockIndex* const pindexStart, const CBlockIndex* const pindexStop, const WalletRescanReserver& reserver, const CBlockIndex*& failed_block, const CBlockIndex*& stop_block, bool fUpdate)\n {\n     int64_t nNow = GetTime();\n     const CChainParams& chainParams = Params();\n@@ -1647,8 +1599,9 @@ CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, CBlock\n         assert(pindexStop->nHeight >= pindexStart->nHeight);\n     }\n \n-    CBlockIndex* pindex = pindexStart;\n-    CBlockIndex* ret = nullptr;\n+    const CBlockIndex* pindex = pindexStart;\n+    failed_block = nullptr;\n+    stop_block = nullptr;\n \n     if (pindex) WalletLogPrintf(\"Rescan started from block %d...\\n\", pindex->nHeight);\n \n@@ -1669,8 +1622,7 @@ CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, CBlock\n             }\n         }\n         double progress_current = progress_begin;\n-        while (pindex && !fAbortRescan && !ShutdownRequested())\n-        {\n+        while (pindex && !fAbortRescan && !ShutdownRequested()) {\n             if (pindex->nHeight % 100 == 0 && progress_end - progress_begin > 0.0) {\n                 ShowProgress(strprintf(\"%s \" + _(\"Rescanning...\"), GetDisplayName()), std::max(1, std::min(99, (int)((progress_current - progress_begin) / (progress_end - progress_begin) * 100))));\n             }\n@@ -1686,14 +1638,17 @@ CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, CBlock\n                 if (pindex && !chainActive.Contains(pindex)) {\n                     // Abort scan if current block is no longer active, to prevent\n                     // marking transactions as coming from the wrong block.\n-                    ret = pindex;\n+                    failed_block = pindex;\n                     break;\n                 }\n                 for (size_t posInBlock = 0; posInBlock < block.vtx.size(); ++posInBlock) {\n                     SyncTransaction(block.vtx[posInBlock], pindex, posInBlock, fUpdate);\n                 }\n+                // scan succeeded, record block as most recent successfully scanned\n+                stop_block = pindex;\n             } else {\n-                ret = pindex;\n+                // could not scan block, keep scanning but record this block as the most recent failure\n+                failed_block = pindex;\n             }\n             if (pindex == pindexStop) {\n                 break;\n@@ -1709,14 +1664,20 @@ CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, CBlock\n                 }\n             }\n         }\n+        ShowProgress(strprintf(\"%s \" + _(\"Rescanning...\"), GetDisplayName()), 100); // hide progress dialog in GUI\n         if (pindex && fAbortRescan) {\n             WalletLogPrintf(\"Rescan aborted at block %d. Progress=%f\\n\", pindex->nHeight, progress_current);\n+            return ScanResult::USER_ABORT;\n         } else if (pindex && ShutdownRequested()) {\n             WalletLogPrintf(\"Rescan interrupted by shutdown request at block %d. Progress=%f\\n\", pindex->nHeight, progress_current);\n+            return ScanResult::USER_ABORT;\n         }\n-        ShowProgress(strprintf(\"%s \" + _(\"Rescanning...\"), GetDisplayName()), 100); // hide progress dialog in GUI\n     }\n-    return ret;\n+    if (failed_block) {\n+        return ScanResult::FAILURE;\n+    } else {\n+        return ScanResult::SUCCESS;\n+    }\n }\n \n void CWallet::ReacceptWalletTransactions()\n@@ -2451,7 +2412,7 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n         // Cases where we have 11+ outputs all pointing to the same destination may result in\n         // privacy leaks as they will potentially be deterministically sorted. We solve that by\n         // explicitly shuffling the outputs before processing\n-        std::shuffle(vCoins.begin(), vCoins.end(), FastRandomContext());\n+        Shuffle(vCoins.begin(), vCoins.end(), FastRandomContext());\n     }\n     std::vector<OutputGroup> groups = GroupOutputs(vCoins, !coin_control.m_avoid_partial_spends);\n \n@@ -2755,7 +2716,14 @@ bool CWallet::CreateTransaction(interfaces::Chain::Lock& locked_chain, const std\n                 if (pick_new_inputs) {\n                     nValueIn = 0;\n                     setCoins.clear();\n-                    coin_selection_params.change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n+                    int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n+                    // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n+                    // as lower-bound to allow BnB to do it's thing\n+                    if (change_spend_size == -1) {\n+                        coin_selection_params.change_spend_size = DUMMY_NESTED_P2WPKH_INPUT_SIZE;\n+                    } else {\n+                        coin_selection_params.change_spend_size = (size_t)change_spend_size;\n+                    }\n                     coin_selection_params.effective_fee = nFeeRateNeeded;\n                     if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coin_control, coin_selection_params, bnb_used))\n                     {\n@@ -2904,7 +2872,7 @@ bool CWallet::CreateTransaction(interfaces::Chain::Lock& locked_chain, const std\n         // Shuffle selected coins and fill in final vin\n         txNew.vin.clear();\n         std::vector<CInputCoin> selected_coins(setCoins.begin(), setCoins.end());\n-        std::shuffle(selected_coins.begin(), selected_coins.end(), FastRandomContext());\n+        Shuffle(selected_coins.begin(), selected_coins.end(), FastRandomContext());\n \n         // Note how the sequence number is set to non-maxint so that\n         // the nLockTime set above actually works.\n@@ -3693,7 +3661,6 @@ void CWallet::GetKeyBirthTimes(interfaces::Chain::Lock& locked_chain, std::map<C\n         return;\n \n     // find first block that affects those keys, if there are any left\n-    std::vector<CKeyID> vAffected;\n     for (const auto& entry : mapWallet) {\n         // iterate over all wallet transactions...\n         const CWalletTx &wtx = entry.second;\n@@ -3703,14 +3670,12 @@ void CWallet::GetKeyBirthTimes(interfaces::Chain::Lock& locked_chain, std::map<C\n             int nHeight = pindex->nHeight;\n             for (const CTxOut &txout : wtx.tx->vout) {\n                 // iterate over all their outputs\n-                CAffectedKeysVisitor(*this, vAffected).Process(txout.scriptPubKey);\n-                for (const CKeyID &keyid : vAffected) {\n+                for (const auto &keyid : GetAffectedKeys(txout.scriptPubKey, *this)) {\n                     // ... and all their affected keys\n                     std::map<CKeyID, CBlockIndex*>::iterator rit = mapKeyFirstBlock.find(keyid);\n                     if (rit != mapKeyFirstBlock.end() && nHeight < rit->second->nHeight)\n                         rit->second = pindex;\n                 }\n-                vAffected.clear();\n             }\n         }\n     }\n@@ -4164,11 +4129,11 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n         nStart = GetTimeMillis();\n         {\n             WalletRescanReserver reserver(walletInstance.get());\n-            if (!reserver.reserve()) {\n+            const CBlockIndex *stop_block, *failed_block;\n+            if (!reserver.reserve() || (ScanResult::SUCCESS != walletInstance->ScanForWalletTransactions(pindexRescan, nullptr, reserver, failed_block, stop_block, true))) {\n                 InitError(_(\"Failed to rescan the wallet during initialization\"));\n                 return nullptr;\n             }\n-            walletInstance->ScanForWalletTransactions(pindexRescan, nullptr, reserver, true);\n         }\n         walletInstance->WalletLogPrintf(\"Rescan completed in %15dms\\n\", GetTimeMillis() - nStart);\n         walletInstance->ChainStateFlushed(chainActive.GetLocator());"
      },
      {
        "sha": "95a2c833f85806cde87025ec3958a4247a8b9211",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 10,
        "deletions": 1,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -85,6 +85,9 @@ static const bool DEFAULT_WALLET_RBF = false;\n static const bool DEFAULT_WALLETBROADCAST = true;\n static const bool DEFAULT_DISABLE_WALLET = false;\n \n+//! Pre-calculated constants for input size estimation in *virtual size*\n+static constexpr size_t DUMMY_NESTED_P2WPKH_INPUT_SIZE = 91;\n+\n class CBlockIndex;\n class CCoinControl;\n class COutput;\n@@ -896,7 +899,13 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex *pindex, const std::vector<CTransactionRef>& vtxConflicted) override;\n     void BlockDisconnected(const std::shared_ptr<const CBlock>& pblock) override;\n     int64_t RescanFromTime(int64_t startTime, const WalletRescanReserver& reserver, bool update);\n-    CBlockIndex* ScanForWalletTransactions(CBlockIndex* pindexStart, CBlockIndex* pindexStop, const WalletRescanReserver& reserver, bool fUpdate = false);\n+\n+    enum class ScanResult {\n+        SUCCESS,\n+        FAILURE,\n+        USER_ABORT\n+    };\n+    ScanResult ScanForWalletTransactions(const CBlockIndex* const pindexStart, const CBlockIndex* const pindexStop, const WalletRescanReserver& reserver, const CBlockIndex*& failed_block, const CBlockIndex*& stop_block, bool fUpdate = false);\n     void TransactionRemovedFromMempool(const CTransactionRef &ptx) override;\n     void ReacceptWalletTransactions();\n     void ResendWalletTransactions(int64_t nBestBlockTime, CConnman* connman) override EXCLUSIVE_LOCKS_REQUIRED(cs_main);"
      },
      {
        "sha": "5bb3b5c094ddf5ba51ce2cde871ff31f975c84ca",
        "filename": "test/functional/combine_logs.py",
        "status": "modified",
        "additions": 48,
        "deletions": 8,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/combine_logs.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/combine_logs.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/combine_logs.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -2,7 +2,9 @@\n \"\"\"Combine logs from multiple bitcoin nodes as well as the test_framework log.\n \n This streams the combined log output to stdout. Use combine_logs.py > outputfile\n-to write to an outputfile.\"\"\"\n+to write to an outputfile.\n+\n+If no argument is provided, the most recent test directory will be used.\"\"\"\n \n import argparse\n from collections import defaultdict, namedtuple\n@@ -11,6 +13,13 @@\n import os\n import re\n import sys\n+import tempfile\n+\n+# N.B.: don't import any local modules here - this script must remain executable\n+# without the parent module installed.\n+\n+# Should match same symbol in `test_framework.test_framework`.\n+TMPDIR_PREFIX = \"bitcoin_func_test_\"\n \n # Matches on the date format at the start of the log event\n TIMESTAMP_PATTERN = re.compile(r\"^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d{6})?Z\")\n@@ -19,22 +28,30 @@\n \n def main():\n     \"\"\"Main function. Parses args, reads the log files and renders them as text or html.\"\"\"\n-\n-    parser = argparse.ArgumentParser(usage='%(prog)s [options] <test temporary directory>', description=__doc__)\n+    parser = argparse.ArgumentParser(\n+        description=__doc__, formatter_class=argparse.RawTextHelpFormatter)\n+    parser.add_argument(\n+        'testdir', nargs='?', default='',\n+        help=('temporary test directory to combine logs from. '\n+              'Defaults to the most recent'))\n     parser.add_argument('-c', '--color', dest='color', action='store_true', help='outputs the combined log with events colored by source (requires posix terminal colors. Use less -r for viewing)')\n     parser.add_argument('--html', dest='html', action='store_true', help='outputs the combined log as html. Requires jinja2. pip install jinja2')\n-    args, unknown_args = parser.parse_known_args()\n+    args = parser.parse_args()\n \n     if args.html and args.color:\n         print(\"Only one out of --color or --html should be specified\")\n         sys.exit(1)\n \n-    # There should only be one unknown argument - the path of the temporary test directory\n-    if len(unknown_args) != 1:\n-        print(\"Unexpected arguments\" + str(unknown_args))\n+    testdir = args.testdir or find_latest_test_dir()\n+\n+    if not testdir:\n+        print(\"No test directories found\")\n         sys.exit(1)\n \n-    log_events = read_logs(unknown_args[0])\n+    if not args.testdir:\n+        print(\"Opening latest test directory: {}\".format(testdir), file=sys.stderr)\n+\n+    log_events = read_logs(testdir)\n \n     print_logs(log_events, color=args.color, html=args.html)\n \n@@ -53,6 +70,29 @@ def read_logs(tmp_dir):\n \n     return heapq.merge(*[get_log_events(source, f) for source, f in files])\n \n+\n+def find_latest_test_dir():\n+    \"\"\"Returns the latest tmpfile test directory prefix.\"\"\"\n+    tmpdir = tempfile.gettempdir()\n+\n+    def join_tmp(basename):\n+        return os.path.join(tmpdir, basename)\n+\n+    def is_valid_test_tmpdir(basename):\n+        fullpath = join_tmp(basename)\n+        return (\n+            os.path.isdir(fullpath)\n+            and basename.startswith(TMPDIR_PREFIX)\n+            and os.access(fullpath, os.R_OK)\n+        )\n+\n+    testdir_paths = [\n+        join_tmp(name) for name in os.listdir(tmpdir) if is_valid_test_tmpdir(name)\n+    ]\n+\n+    return max(testdir_paths, key=os.path.getmtime) if testdir_paths else None\n+\n+\n def get_log_events(source, logfile):\n     \"\"\"Generator function that returns individual log events.\n "
      },
      {
        "sha": "b633fabb1fac7a8e2898094946d008362519d2e0",
        "filename": "test/functional/feature_shutdown.py",
        "status": "added",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/feature_shutdown.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/feature_shutdown.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_shutdown.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -0,0 +1,28 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test bitcoind shutdown.\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal, get_rpc_proxy\n+from threading import Thread\n+\n+def test_long_call(node):\n+    block = node.waitfornewblock()\n+    assert_equal(block['height'], 0)\n+\n+class ShutdownTest(BitcoinTestFramework):\n+\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+\n+    def run_test(self):\n+        node = get_rpc_proxy(self.nodes[0].url, 1, timeout=600, coveragedir=self.nodes[0].coverage_dir)\n+        Thread(target=test_long_call, args=(node,)).start()\n+        # wait 1 second to ensure event loop waits for current connections to close\n+        self.stop_node(0, wait=1000)\n+\n+if __name__ == '__main__':\n+    ShutdownTest().main()"
      },
      {
        "sha": "20889366e5ea33de03bbad200dc984de024f7609",
        "filename": "test/functional/interface_http.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/interface_http.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/interface_http.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_http.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -31,13 +31,13 @@ def run_test(self):\n         conn.request('POST', '/', '{\"method\": \"getbestblockhash\"}', headers)\n         out1 = conn.getresponse().read()\n         assert(b'\"error\":null' in out1)\n-        assert(conn.sock!=None) #according to http/1.1 connection must still be open!\n+        assert(conn.sock is not None) #according to http/1.1 connection must still be open!\n \n         #send 2nd request without closing connection\n         conn.request('POST', '/', '{\"method\": \"getchaintips\"}', headers)\n         out1 = conn.getresponse().read()\n         assert(b'\"error\":null' in out1) #must also response with a correct json-rpc message\n-        assert(conn.sock!=None) #according to http/1.1 connection must still be open!\n+        assert(conn.sock is not None) #according to http/1.1 connection must still be open!\n         conn.close()\n \n         #same should be if we add keep-alive because this should be the std. behaviour\n@@ -48,13 +48,13 @@ def run_test(self):\n         conn.request('POST', '/', '{\"method\": \"getbestblockhash\"}', headers)\n         out1 = conn.getresponse().read()\n         assert(b'\"error\":null' in out1)\n-        assert(conn.sock!=None) #according to http/1.1 connection must still be open!\n+        assert(conn.sock is not None) #according to http/1.1 connection must still be open!\n \n         #send 2nd request without closing connection\n         conn.request('POST', '/', '{\"method\": \"getchaintips\"}', headers)\n         out1 = conn.getresponse().read()\n         assert(b'\"error\":null' in out1) #must also response with a correct json-rpc message\n-        assert(conn.sock!=None) #according to http/1.1 connection must still be open!\n+        assert(conn.sock is not None) #according to http/1.1 connection must still be open!\n         conn.close()\n \n         #now do the same with \"Connection: close\"\n@@ -65,7 +65,7 @@ def run_test(self):\n         conn.request('POST', '/', '{\"method\": \"getbestblockhash\"}', headers)\n         out1 = conn.getresponse().read()\n         assert(b'\"error\":null' in out1)\n-        assert(conn.sock==None) #now the connection must be closed after the response\n+        assert(conn.sock is None) #now the connection must be closed after the response\n \n         #node1 (2nd node) is running with disabled keep-alive option\n         urlNode1 = urllib.parse.urlparse(self.nodes[1].url)\n@@ -88,7 +88,7 @@ def run_test(self):\n         conn.request('POST', '/', '{\"method\": \"getbestblockhash\"}', headers)\n         out1 = conn.getresponse().read()\n         assert(b'\"error\":null' in out1)\n-        assert(conn.sock!=None) #connection must be closed because bitcoind should use keep-alive by default\n+        assert(conn.sock is not None) #connection must be closed because bitcoind should use keep-alive by default\n \n         # Check excessive request size\n         conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)"
      },
      {
        "sha": "02f1cc43913d5b26513c65ec0a12a284aebc0def",
        "filename": "test/functional/mempool_accept.py",
        "status": "modified",
        "additions": 21,
        "deletions": 2,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/mempool_accept.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/mempool_accept.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_accept.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -6,6 +6,7 @@\n \n from io import BytesIO\n import math\n+\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.messages import (\n     BIP125_SEQUENCE_NUMBER,\n@@ -57,20 +58,22 @@ def run_test(self):\n         self.mempool_size = 0\n         wait_until(lambda: node.getblockcount() == 200)\n         assert_equal(node.getmempoolinfo()['size'], self.mempool_size)\n+        coins = node.listunspent()\n \n         self.log.info('Should not accept garbage to testmempoolaccept')\n         assert_raises_rpc_error(-3, 'Expected type array, got string', lambda: node.testmempoolaccept(rawtxs='ff00baar'))\n         assert_raises_rpc_error(-8, 'Array must contain exactly one raw transaction for now', lambda: node.testmempoolaccept(rawtxs=['ff00baar', 'ff22']))\n         assert_raises_rpc_error(-22, 'TX decode failed', lambda: node.testmempoolaccept(rawtxs=['ff00baar']))\n \n         self.log.info('A transaction already in the blockchain')\n-        coin = node.listunspent()[0]  # Pick a random coin(base) to spend\n+        coin = coins.pop()  # Pick a random coin(base) to spend\n         raw_tx_in_block = node.signrawtransactionwithwallet(node.createrawtransaction(\n             inputs=[{'txid': coin['txid'], 'vout': coin['vout']}],\n             outputs=[{node.getnewaddress(): 0.3}, {node.getnewaddress(): 49}],\n         ))['hex']\n         txid_in_block = node.sendrawtransaction(hexstring=raw_tx_in_block, allowhighfees=True)\n         node.generate(1)\n+        self.mempool_size = 0\n         self.check_mempool_result(\n             result_expected=[{'txid': txid_in_block, 'allowed': False, 'reject-reason': '18: txn-already-known'}],\n             rawtxs=[raw_tx_in_block],\n@@ -90,9 +93,25 @@ def run_test(self):\n             rawtxs=[raw_tx_0],\n         )\n \n+        self.log.info('A final transaction not in the mempool')\n+        coin = coins.pop()  # Pick a random coin(base) to spend\n+        raw_tx_final = node.signrawtransactionwithwallet(node.createrawtransaction(\n+            inputs=[{'txid': coin['txid'], 'vout': coin['vout'], \"sequence\": 0xffffffff}],  # SEQUENCE_FINAL\n+            outputs=[{node.getnewaddress(): 0.025}],\n+            locktime=node.getblockcount() + 2000,  # Can be anything\n+        ))['hex']\n+        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_final)))\n+        self.check_mempool_result(\n+            result_expected=[{'txid': tx.rehash(), 'allowed': True}],\n+            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+            allowhighfees=True,\n+        )\n+        node.sendrawtransaction(hexstring=raw_tx_final, allowhighfees=True)\n+        self.mempool_size += 1\n+\n         self.log.info('A transaction in the mempool')\n         node.sendrawtransaction(hexstring=raw_tx_0)\n-        self.mempool_size = 1\n+        self.mempool_size += 1\n         self.check_mempool_result(\n             result_expected=[{'txid': txid_0, 'allowed': False, 'reject-reason': '18: txn-already-in-mempool'}],\n             rawtxs=[raw_tx_0],"
      },
      {
        "sha": "d74d4eaaf1a77de3f0ffb7723017b53d821caf47",
        "filename": "test/functional/mempool_persist.py",
        "status": "modified",
        "additions": 13,
        "deletions": 1,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/mempool_persist.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/mempool_persist.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_persist.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -42,6 +42,7 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal, assert_raises_rpc_error, wait_until\n \n+\n class MempoolPersistTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 3\n@@ -60,14 +61,21 @@ def run_test(self):\n \n         self.log.debug(\"Send 5 transactions from node2 (to its own address)\")\n         for i in range(5):\n-            self.nodes[2].sendtoaddress(self.nodes[2].getnewaddress(), Decimal(\"10\"))\n+            last_txid = self.nodes[2].sendtoaddress(self.nodes[2].getnewaddress(), Decimal(\"10\"))\n         node2_balance = self.nodes[2].getbalance()\n         self.sync_all()\n \n         self.log.debug(\"Verify that node0 and node1 have 5 transactions in their mempools\")\n         assert_equal(len(self.nodes[0].getrawmempool()), 5)\n         assert_equal(len(self.nodes[1].getrawmempool()), 5)\n \n+        self.log.debug(\"Prioritize a transaction on node0\")\n+        fees = self.nodes[0].getmempoolentry(txid=last_txid)['fees']\n+        assert_equal(fees['base'], fees['modified'])\n+        self.nodes[0].prioritisetransaction(txid=last_txid, fee_delta=1000)\n+        fees = self.nodes[0].getmempoolentry(txid=last_txid)['fees']\n+        assert_equal(fees['base'] + Decimal('0.00001000'), fees['modified'])\n+\n         self.log.debug(\"Stop-start the nodes. Verify that node0 has the transactions in its mempool and node1 does not. Verify that node2 calculates its balance correctly after loading wallet transactions.\")\n         self.stop_nodes()\n         # Give this node a head-start, so we can be \"extra-sure\" that it didn't load anything later\n@@ -81,6 +89,10 @@ def run_test(self):\n         # The others have loaded their mempool. If node_1 loaded anything, we'd probably notice by now:\n         assert_equal(len(self.nodes[1].getrawmempool()), 0)\n \n+        self.log.debug('Verify prioritization is loaded correctly')\n+        fees = self.nodes[0].getmempoolentry(txid=last_txid)['fees']\n+        assert_equal(fees['base'] + Decimal('0.00001000'), fees['modified'])\n+\n         # Verify accounting of mempool transactions after restart is correct\n         self.nodes[2].syncwithvalidationinterfacequeue()  # Flush mempool to wallet\n         assert_equal(node2_balance, self.nodes[2].getbalance())"
      },
      {
        "sha": "6e74731349b6be41de3ab5e4e18fcfb09b2e24a0",
        "filename": "test/functional/mining_basic.py",
        "status": "modified",
        "additions": 10,
        "deletions": 2,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/mining_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/mining_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mining_basic.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -25,7 +25,7 @@\n     assert_raises_rpc_error,\n     bytes_to_hex_str as b2x,\n )\n-\n+from test_framework.script import CScriptNum\n \n def assert_template(node, block, expect, rehash=True):\n     if rehash:\n@@ -65,11 +65,19 @@ def assert_submitblock(block, result_str_1, result_str_2=None):\n         assert 'proposal' in tmpl['capabilities']\n         assert 'coinbasetxn' not in tmpl\n \n-        coinbase_tx = create_coinbase(height=int(tmpl[\"height\"]) + 1)\n+        next_height = int(tmpl[\"height\"])\n+        coinbase_tx = create_coinbase(height=next_height)\n         # sequence numbers must not be max for nLockTime to have effect\n         coinbase_tx.vin[0].nSequence = 2 ** 32 - 2\n         coinbase_tx.rehash()\n \n+        # round-trip the encoded bip34 block height commitment\n+        assert_equal(CScriptNum.decode(coinbase_tx.vin[0].scriptSig), next_height)\n+        # round-trip negative and multi-byte CScriptNums to catch python regression\n+        assert_equal(CScriptNum.decode(CScriptNum.encode(CScriptNum(1500))), 1500)\n+        assert_equal(CScriptNum.decode(CScriptNum.encode(CScriptNum(-1500))), -1500)\n+        assert_equal(CScriptNum.decode(CScriptNum.encode(CScriptNum(-1))), -1)\n+\n         block = CBlock()\n         block.nVersion = tmpl[\"version\"]\n         block.hashPrevBlock = int(tmpl[\"previousblockhash\"], 16)"
      },
      {
        "sha": "da16bfbbfbef05665382e020145a58222ebcf520",
        "filename": "test/functional/mining_prioritisetransaction.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/mining_prioritisetransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/mining_prioritisetransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mining_prioritisetransaction.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -84,7 +84,7 @@ def run_test(self):\n                 high_fee_tx = x\n \n         # Something high-fee should have been mined!\n-        assert(high_fee_tx != None)\n+        assert(high_fee_tx is not None)\n \n         # Add a prioritisation before a tx is in the mempool (de-prioritising a\n         # high-fee transaction so that it's now low fee)."
      },
      {
        "sha": "ffed853033dee21aa5bee1a767650e427a92e8bb",
        "filename": "test/functional/p2p_timeouts.py",
        "status": "modified",
        "additions": 17,
        "deletions": 9,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/p2p_timeouts.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/p2p_timeouts.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_timeouts.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -14,11 +14,11 @@\n - Wait 1 second\n - Assert that we're connected\n - Send a ping to no_verack_node and no_version_node\n-- Wait 30 seconds\n+- Wait 1 second\n - Assert that we're still connected\n - Send a ping to no_verack_node and no_version_node\n-- Wait 31 seconds\n-- Assert that we're no longer connected (timeout to receive version/verack is 60 seconds)\n+- Wait 2 seconds\n+- Assert that we're no longer connected (timeout to receive version/verack is 3 seconds)\n \"\"\"\n \n from time import sleep\n@@ -36,6 +36,8 @@ class TimeoutsTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.setup_clean_chain = True\n         self.num_nodes = 1\n+        # set timeout to receive version/verack to 3 seconds\n+        self.extra_args = [[\"-peertimeout=3\"]]\n \n     def run_test(self):\n         # Setup the p2p connections\n@@ -52,7 +54,7 @@ def run_test(self):\n         no_verack_node.send_message(msg_ping())\n         no_version_node.send_message(msg_ping())\n \n-        sleep(30)\n+        sleep(1)\n \n         assert \"version\" in no_verack_node.last_message\n \n@@ -63,11 +65,17 @@ def run_test(self):\n         no_verack_node.send_message(msg_ping())\n         no_version_node.send_message(msg_ping())\n \n-        sleep(31)\n-\n-        assert not no_verack_node.is_connected\n-        assert not no_version_node.is_connected\n-        assert not no_send_node.is_connected\n+        expected_timeout_logs = [\n+            \"version handshake timeout from 0\",\n+            \"socket no message in first 3 seconds, 1 0 from 1\",\n+            \"socket no message in first 3 seconds, 0 0 from 2\",\n+        ]\n+\n+        with self.nodes[0].assert_debug_log(expected_msgs=expected_timeout_logs):\n+            sleep(2)\n+            assert not no_verack_node.is_connected\n+            assert not no_version_node.is_connected\n+            assert not no_send_node.is_connected\n \n if __name__ == '__main__':\n     TimeoutsTest().main()"
      },
      {
        "sha": "c23aa13685e92905044572deaeaecd4a1286e437",
        "filename": "test/functional/rpc_bind.py",
        "status": "modified",
        "additions": 7,
        "deletions": 4,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/rpc_bind.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/rpc_bind.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_bind.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -48,9 +48,12 @@ def run_allowip_test(self, allow_ips, rpchost, rpcport):\n         at a non-localhost IP.\n         '''\n         self.log.info(\"Allow IP test for %s:%d\" % (rpchost, rpcport))\n-        base_args = ['-disablewallet', '-nolisten'] + ['-rpcallowip='+x for x in allow_ips]\n+        node_args = \\\n+            ['-disablewallet', '-nolisten'] + \\\n+            ['-rpcallowip='+x for x in allow_ips] + \\\n+            ['-rpcbind='+addr for addr in ['127.0.0.1', \"%s:%d\" % (rpchost, rpcport)]] # Bind to localhost as well so start_nodes doesn't hang\n         self.nodes[0].rpchost = None\n-        self.start_nodes([base_args])\n+        self.start_nodes([node_args])\n         # connect to node through non-loopback interface\n         node = get_rpc_proxy(rpc_url(self.nodes[0].datadir, 0, \"%s:%d\" % (rpchost, rpcport)), 0, coveragedir=self.options.coveragedir)\n         node.getnetworkinfo()\n@@ -101,9 +104,9 @@ def _run_loopback_tests(self):\n             # check default without rpcallowip (IPv4 and IPv6 localhost)\n             self.run_bind_test(None, '127.0.0.1', [],\n                 [('127.0.0.1', self.defaultport), ('::1', self.defaultport)])\n-            # check default with rpcallowip (IPv6 any)\n+            # check default with rpcallowip (IPv4 and IPv6 localhost)\n             self.run_bind_test(['127.0.0.1'], '127.0.0.1', [],\n-                [('::0', self.defaultport)])\n+                [('127.0.0.1', self.defaultport), ('::1', self.defaultport)])\n             # check only IPv6 localhost (explicit)\n             self.run_bind_test(['[::1]'], '[::1]', ['[::1]'],\n                 [('::1', self.defaultport)])"
      },
      {
        "sha": "272ebe65cbc233c8fefeefc0daef092236e84ae6",
        "filename": "test/functional/rpc_psbt.py",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/rpc_psbt.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/rpc_psbt.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_psbt.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -210,6 +210,10 @@ def run_test(self):\n             assert tx_in[\"sequence\"] > MAX_BIP125_RBF_SEQUENCE\n         assert_equal(decoded_psbt[\"tx\"][\"locktime\"], 0)\n \n+        # Make sure change address wallet does not have P2SH innerscript access to results in success\n+        # when attempting BnB coin selection\n+        self.nodes[0].walletcreatefundedpsbt([], [{self.nodes[2].getnewaddress():unspent[\"amount\"]+1}], block_height+2, {\"changeAddress\":self.nodes[1].getnewaddress()}, False)\n+\n         # Regression test for 14473 (mishandling of already-signed witness transaction):\n         psbtx_info = self.nodes[0].walletcreatefundedpsbt([{\"txid\":unspent[\"txid\"], \"vout\":unspent[\"vout\"]}], [{self.nodes[2].getnewaddress():unspent[\"amount\"]+1}])\n         complete_psbt = self.nodes[0].walletprocesspsbt(psbtx_info[\"psbt\"])"
      },
      {
        "sha": "fc012e6e3a352720531fae060a5c1b1da5ba62ec",
        "filename": "test/functional/rpc_rawtransaction.py",
        "status": "modified",
        "additions": 4,
        "deletions": 9,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/rpc_rawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/rpc_rawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_rawtransaction.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -100,6 +100,8 @@ def run_test(self):\n         assert_raises_rpc_error(-3, \"Amount out of range\", self.nodes[0].createrawtransaction, [], {address: -1})\n         assert_raises_rpc_error(-8, \"Invalid parameter, duplicated address: %s\" % address, self.nodes[0].createrawtransaction, [], multidict([(address, 1), (address, 1)]))\n         assert_raises_rpc_error(-8, \"Invalid parameter, duplicated address: %s\" % address, self.nodes[0].createrawtransaction, [], [{address: 1}, {address: 1}])\n+        assert_raises_rpc_error(-8, \"Invalid parameter, duplicate key: data\", self.nodes[0].createrawtransaction, [], [{\"data\": 'aa'}, {\"data\": \"bb\"}])\n+        assert_raises_rpc_error(-8, \"Invalid parameter, duplicate key: data\", self.nodes[0].createrawtransaction, [], multidict([(\"data\", 'aa'), (\"data\", \"bb\")]))\n         assert_raises_rpc_error(-8, \"Invalid parameter, key-value pair must contain exactly one key\", self.nodes[0].createrawtransaction, [], [{'a': 1, 'b': 2}])\n         assert_raises_rpc_error(-8, \"Invalid parameter, key-value pair not an object as expected\", self.nodes[0].createrawtransaction, [], [['key-value pair1'], ['2']])\n \n@@ -127,19 +129,12 @@ def run_test(self):\n             bytes_to_hex_str(tx.serialize()),\n             self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs=[{address: 99}, {address2: 99}]),\n         )\n-        # Two data outputs\n-        tx.deserialize(BytesIO(hex_str_to_bytes(self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs=multidict([('data', '99'), ('data', '99')])))))\n-        assert_equal(len(tx.vout), 2)\n-        assert_equal(\n-            bytes_to_hex_str(tx.serialize()),\n-            self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs=[{'data': '99'}, {'data': '99'}]),\n-        )\n         # Multiple mixed outputs\n-        tx.deserialize(BytesIO(hex_str_to_bytes(self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs=multidict([(address, 99), ('data', '99'), ('data', '99')])))))\n+        tx.deserialize(BytesIO(hex_str_to_bytes(self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs=multidict([(address, 99), (address2, 99), ('data', '99')])))))\n         assert_equal(len(tx.vout), 3)\n         assert_equal(\n             bytes_to_hex_str(tx.serialize()),\n-            self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs=[{address: 99}, {'data': '99'}, {'data': '99'}]),\n+            self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs=[{address: 99}, {address2: 99}, {'data': '99'}]),\n         )\n \n         for type in [\"bech32\", \"p2sh-segwit\", \"legacy\"]:"
      },
      {
        "sha": "356a45d6d028e308ed66208aaec8dfc0dcfa435b",
        "filename": "test/functional/test_framework/messages.py",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/test_framework/messages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/test_framework/messages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/messages.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -450,6 +450,8 @@ def deserialize(self, f):\n         if flags != 0:\n             self.wit.vtxinwit = [CTxInWitness() for i in range(len(self.vin))]\n             self.wit.deserialize(f)\n+        else:\n+            self.wit = CTxWitness()\n         self.nLockTime = struct.unpack(\"<I\", f.read(4))[0]\n         self.sha256 = None\n         self.hash = None\n@@ -764,7 +766,7 @@ def __init__(self, p2pheaders_and_shortids = None):\n         self.prefilled_txn = []\n         self.use_witness = False\n \n-        if p2pheaders_and_shortids != None:\n+        if p2pheaders_and_shortids is not None:\n             self.header = p2pheaders_and_shortids.header\n             self.nonce = p2pheaders_and_shortids.nonce\n             self.shortids = p2pheaders_and_shortids.shortids\n@@ -822,7 +824,7 @@ class BlockTransactionsRequest:\n \n     def __init__(self, blockhash=0, indexes = None):\n         self.blockhash = blockhash\n-        self.indexes = indexes if indexes != None else []\n+        self.indexes = indexes if indexes is not None else []\n \n     def deserialize(self, f):\n         self.blockhash = deser_uint256(f)\n@@ -863,7 +865,7 @@ class BlockTransactions:\n \n     def __init__(self, blockhash=0, transactions = None):\n         self.blockhash = blockhash\n-        self.transactions = transactions if transactions != None else []\n+        self.transactions = transactions if transactions is not None else []\n \n     def deserialize(self, f):\n         self.blockhash = deser_uint256(f)\n@@ -1052,7 +1054,7 @@ class msg_getdata:\n     command = b\"getdata\"\n \n     def __init__(self, inv=None):\n-        self.inv = inv if inv != None else []\n+        self.inv = inv if inv is not None else []\n \n     def deserialize(self, f):\n         self.inv = deser_vector(f, CInv)"
      },
      {
        "sha": "012c80a1be555fbd1aad9cd655f50fa8e650736a",
        "filename": "test/functional/test_framework/script.py",
        "status": "modified",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/test_framework/script.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/test_framework/script.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/script.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -385,6 +385,22 @@ def encode(obj):\n             r[-1] |= 0x80\n         return bytes([len(r)]) + r\n \n+    @staticmethod\n+    def decode(vch):\n+        result = 0\n+        # We assume valid push_size and minimal encoding\n+        value = vch[1:]\n+        if len(value) == 0:\n+            return result\n+        for i, byte in enumerate(value):\n+            result |= int(byte) << 8*i\n+        if value[-1] >= 0x80:\n+            # Mask for all but the highest result bit\n+            num_mask = (2**(len(value)*8) - 1) >> 1\n+            result &= num_mask\n+            result *= -1\n+        return result\n+\n \n class CScript(bytes):\n     \"\"\"Serialized script\n@@ -434,6 +450,10 @@ def join(self, iterable):\n         # join makes no sense for a CScript()\n         raise NotImplementedError\n \n+    # Python 3.4 compatibility\n+    def hex(self):\n+        return hexlify(self).decode('ascii')\n+\n     def __new__(cls, value=b''):\n         if isinstance(value, bytes) or isinstance(value, bytearray):\n             return super(CScript, cls).__new__(cls, value)"
      },
      {
        "sha": "21bf35597edae0bbd9af3a1ec6a03e48ad089590",
        "filename": "test/functional/test_framework/test_framework.py",
        "status": "modified",
        "additions": 24,
        "deletions": 7,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/test_framework/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/test_framework/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_framework.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -43,6 +43,8 @@ class TestStatus(Enum):\n TEST_EXIT_FAILED = 1\n TEST_EXIT_SKIPPED = 77\n \n+TMPDIR_PREFIX = \"bitcoin_func_test_\"\n+\n \n class SkipTest(Exception):\n     \"\"\"This exception is raised to skip a test\"\"\"\n@@ -151,7 +153,7 @@ def main(self):\n             self.options.tmpdir = os.path.abspath(self.options.tmpdir)\n             os.makedirs(self.options.tmpdir, exist_ok=False)\n         else:\n-            self.options.tmpdir = tempfile.mkdtemp(prefix=\"test\")\n+            self.options.tmpdir = tempfile.mkdtemp(prefix=TMPDIR_PREFIX)\n         self._start_logging()\n \n         self.log.debug('Setting up network thread')\n@@ -279,7 +281,10 @@ def run_test(self):\n     # Public helper methods. These can be accessed by the subclass test scripts.\n \n     def add_nodes(self, num_nodes, extra_args=None, *, rpchost=None, binary=None):\n-        \"\"\"Instantiate TestNode objects\"\"\"\n+        \"\"\"Instantiate TestNode objects.\n+\n+        Should only be called once after the nodes have been specified in\n+        set_test_params().\"\"\"\n         if self.bind_to_localhost_only:\n             extra_confs = [[\"bind=127.0.0.1\"]] * num_nodes\n         else:\n@@ -292,7 +297,19 @@ def add_nodes(self, num_nodes, extra_args=None, *, rpchost=None, binary=None):\n         assert_equal(len(extra_args), num_nodes)\n         assert_equal(len(binary), num_nodes)\n         for i in range(num_nodes):\n-            self.nodes.append(TestNode(i, get_datadir_path(self.options.tmpdir, i), rpchost=rpchost, timewait=self.rpc_timewait, bitcoind=binary[i], bitcoin_cli=self.options.bitcoincli, mocktime=self.mocktime, coverage_dir=self.options.coveragedir, extra_conf=extra_confs[i], extra_args=extra_args[i], use_cli=self.options.usecli))\n+            self.nodes.append(TestNode(\n+                i,\n+                get_datadir_path(self.options.tmpdir, i),\n+                rpchost=rpchost,\n+                timewait=self.rpc_timewait,\n+                bitcoind=binary[i],\n+                bitcoin_cli=self.options.bitcoincli,\n+                mocktime=self.mocktime,\n+                coverage_dir=self.options.coveragedir,\n+                extra_conf=extra_confs[i],\n+                extra_args=extra_args[i],\n+                use_cli=self.options.usecli,\n+            ))\n \n     def start_node(self, i, *args, **kwargs):\n         \"\"\"Start a bitcoind\"\"\"\n@@ -325,16 +342,16 @@ def start_nodes(self, extra_args=None, *args, **kwargs):\n             for node in self.nodes:\n                 coverage.write_all_rpc_commands(self.options.coveragedir, node.rpc)\n \n-    def stop_node(self, i, expected_stderr=''):\n+    def stop_node(self, i, expected_stderr='', wait=0):\n         \"\"\"Stop a bitcoind test node\"\"\"\n-        self.nodes[i].stop_node(expected_stderr)\n+        self.nodes[i].stop_node(expected_stderr, wait=wait)\n         self.nodes[i].wait_until_stopped()\n \n-    def stop_nodes(self):\n+    def stop_nodes(self, wait=0):\n         \"\"\"Stop multiple bitcoind test nodes\"\"\"\n         for node in self.nodes:\n             # Issue RPC to stop nodes\n-            node.stop_node()\n+            node.stop_node(wait=wait)\n \n         for node in self.nodes:\n             # Wait for nodes to stop"
      },
      {
        "sha": "031a8824b175cadde5c09789c9fc076701bf5d3a",
        "filename": "test/functional/test_framework/test_node.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/test_framework/test_node.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/test_framework/test_node.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_node.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -68,7 +68,7 @@ def __init__(self, i, datadir, *, rpchost, timewait, bitcoind, bitcoin_cli, mock\n         self.rpc_timeout = timewait\n         self.binary = bitcoind\n         self.coverage_dir = coverage_dir\n-        if extra_conf != None:\n+        if extra_conf is not None:\n             append_config(datadir, extra_conf)\n         # Most callers will just need to add extra args to the standard list below.\n         # For those callers that need more flexibility, they can just set the args property directly.\n@@ -228,13 +228,13 @@ def get_wallet_rpc(self, wallet_name):\n             wallet_path = \"wallet/{}\".format(urllib.parse.quote(wallet_name))\n             return self.rpc / wallet_path\n \n-    def stop_node(self, expected_stderr=''):\n+    def stop_node(self, expected_stderr='', wait=0):\n         \"\"\"Stop the node.\"\"\"\n         if not self.running:\n             return\n         self.log.debug(\"Stopping node\")\n         try:\n-            self.stop()\n+            self.stop(wait=wait)\n         except http.client.CannotSendRequest:\n             self.log.exception(\"Unable to stop node.\")\n "
      },
      {
        "sha": "d0a78d8dfd3f1cf60a81a8d479a4735389cb61bb",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -326,7 +326,7 @@ def get_auth_cookie(datadir):\n                 if line.startswith(\"rpcpassword=\"):\n                     assert password is None  # Ensure that there is only one rpcpassword line\n                     password = line.split(\"=\")[1].strip(\"\\n\")\n-    if os.path.isfile(os.path.join(datadir, \"regtest\", \".cookie\")):\n+    if os.path.isfile(os.path.join(datadir, \"regtest\", \".cookie\")) and os.access(os.path.join(datadir, \"regtest\", \".cookie\"), os.R_OK):\n         with open(os.path.join(datadir, \"regtest\", \".cookie\"), 'r', encoding=\"ascii\") as f:\n             userpass = f.read()\n             split_userpass = userpass.split(':')"
      },
      {
        "sha": "a094433942fa8be1d1eef89e6fc05dfd2e7f7ce9",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -153,6 +153,7 @@\n     'wallet_importprunedfunds.py',\n     'p2p_leak_tx.py',\n     'rpc_signmessage.py',\n+    'wallet_balance.py',\n     'feature_nulldummy.py',\n     'mempool_accept.py',\n     'wallet_import_rescan.py',\n@@ -175,6 +176,7 @@\n     'rpc_getblockstats.py',\n     'p2p_fingerprint.py',\n     'feature_uacomment.py',\n+    'wallet_coinbase_category.py',\n     'feature_filelock.py',\n     'p2p_unrequested_blocks.py',\n     'feature_includeconf.py',\n@@ -185,6 +187,7 @@\n     'feature_config_args.py',\n     'rpc_help.py',\n     'feature_help.py',\n+    'feature_shutdown.py',\n     # Don't append tests at the end to avoid merge conflicts\n     # Put them in a random line within the section that fits their approximate run-time\n ]\n@@ -272,7 +275,7 @@ def main():\n     if tests:\n         # Individual tests have been specified. Run specified tests that exist\n         # in the ALL_SCRIPTS list. Accept the name with or without .py extension.\n-        tests = [re.sub(\"\\.py$\", \"\", test) + \".py\" for test in tests]\n+        tests = [test + \".py\" if \".py\" not in test else test for test in tests]\n         for test in tests:\n             if test in ALL_SCRIPTS:\n                 test_list.append(test)"
      },
      {
        "sha": "05c97e03405bb56e5e6b091f3d7f6cc21c7e62c2",
        "filename": "test/functional/wallet_balance.py",
        "status": "added",
        "additions": 133,
        "deletions": 0,
        "changes": 133,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/wallet_balance.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/wallet_balance.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_balance.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -0,0 +1,133 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the wallet balance RPC methods.\"\"\"\n+from decimal import Decimal\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+RANDOM_COINBASE_ADDRESS = 'mneYUmWYsuk7kySiURxCi3AGxrAqZxLgPZ'\n+\n+def create_transactions(node, address, amt, fees):\n+    # Create and sign raw transactions from node to address for amt.\n+    # Creates a transaction for each fee and returns an array\n+    # of the raw transactions.\n+    utxos = node.listunspent(0)\n+\n+    # Create transactions\n+    inputs = []\n+    ins_total = 0\n+    for utxo in utxos:\n+        inputs.append({\"txid\": utxo[\"txid\"], \"vout\": utxo[\"vout\"]})\n+        ins_total += utxo['amount']\n+        if ins_total > amt:\n+            break\n+\n+    txs = []\n+    for fee in fees:\n+        outputs = {address: amt, node.getrawchangeaddress(): ins_total - amt - fee}\n+        raw_tx = node.createrawtransaction(inputs, outputs, 0, True)\n+        raw_tx = node.signrawtransactionwithwallet(raw_tx)\n+        txs.append(raw_tx)\n+\n+    return txs\n+\n+class WalletTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.setup_clean_chain = True\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        # Check that nodes don't own any UTXOs\n+        assert_equal(len(self.nodes[0].listunspent()), 0)\n+        assert_equal(len(self.nodes[1].listunspent()), 0)\n+\n+        self.log.info(\"Mining one block for each node\")\n+\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+        self.nodes[1].generate(1)\n+        self.nodes[1].generatetoaddress(100, RANDOM_COINBASE_ADDRESS)\n+        self.sync_all()\n+\n+        assert_equal(self.nodes[0].getbalance(), 50)\n+        assert_equal(self.nodes[1].getbalance(), 50)\n+\n+        self.log.info(\"Test getbalance with different arguments\")\n+        assert_equal(self.nodes[0].getbalance(\"*\"), 50)\n+        assert_equal(self.nodes[0].getbalance(\"*\", 1), 50)\n+        assert_equal(self.nodes[0].getbalance(\"*\", 1, True), 50)\n+        assert_equal(self.nodes[0].getbalance(minconf=1), 50)\n+\n+        # Send 40 BTC from 0 to 1 and 60 BTC from 1 to 0.\n+        txs = create_transactions(self.nodes[0], self.nodes[1].getnewaddress(), 40, [Decimal('0.01')])\n+        self.nodes[0].sendrawtransaction(txs[0]['hex'])\n+        self.nodes[1].sendrawtransaction(txs[0]['hex'])  # sending on both nodes is faster than waiting for propagation\n+\n+        self.sync_all()\n+        txs = create_transactions(self.nodes[1], self.nodes[0].getnewaddress(), 60, [Decimal('0.01'), Decimal('0.02')])\n+        self.nodes[1].sendrawtransaction(txs[0]['hex'])\n+        self.nodes[0].sendrawtransaction(txs[0]['hex'])  # sending on both nodes is faster than waiting for propagation\n+        self.sync_all()\n+\n+        # First argument of getbalance must be set to \"*\"\n+        assert_raises_rpc_error(-32, \"dummy first argument must be excluded or set to \\\"*\\\"\", self.nodes[1].getbalance, \"\")\n+\n+        self.log.info(\"Test getbalance and getunconfirmedbalance with unconfirmed inputs\")\n+\n+        # getbalance without any arguments includes unconfirmed transactions, but not untrusted transactions\n+        assert_equal(self.nodes[0].getbalance(), Decimal('9.99'))  # change from node 0's send\n+        assert_equal(self.nodes[1].getbalance(), Decimal('29.99'))  # change from node 1's send\n+        # Same with minconf=0\n+        assert_equal(self.nodes[0].getbalance(minconf=0), Decimal('9.99'))\n+        assert_equal(self.nodes[1].getbalance(minconf=0), Decimal('29.99'))\n+        # getbalance with a minconf incorrectly excludes coins that have been spent more recently than the minconf blocks ago\n+        # TODO: fix getbalance tracking of coin spentness depth\n+        assert_equal(self.nodes[0].getbalance(minconf=1), Decimal('0'))\n+        assert_equal(self.nodes[1].getbalance(minconf=1), Decimal('0'))\n+        # getunconfirmedbalance\n+        assert_equal(self.nodes[0].getunconfirmedbalance(), Decimal('60'))  # output of node 1's spend\n+        assert_equal(self.nodes[1].getunconfirmedbalance(), Decimal('0'))  # Doesn't include output of node 0's send since it was spent\n+\n+        # Node 1 bumps the transaction fee and resends\n+        self.nodes[1].sendrawtransaction(txs[1]['hex'])\n+        self.sync_all()\n+\n+        self.log.info(\"Test getbalance and getunconfirmedbalance with conflicted unconfirmed inputs\")\n+\n+        assert_equal(self.nodes[0].getwalletinfo()[\"unconfirmed_balance\"], Decimal('60'))  # output of node 1's send\n+        assert_equal(self.nodes[0].getunconfirmedbalance(), Decimal('60'))\n+        assert_equal(self.nodes[1].getwalletinfo()[\"unconfirmed_balance\"], Decimal('0'))  # Doesn't include output of node 0's send since it was spent\n+        assert_equal(self.nodes[1].getunconfirmedbalance(), Decimal('0'))\n+\n+        self.nodes[1].generatetoaddress(1, RANDOM_COINBASE_ADDRESS)\n+        self.sync_all()\n+\n+        # balances are correct after the transactions are confirmed\n+        assert_equal(self.nodes[0].getbalance(), Decimal('69.99'))  # node 1's send plus change from node 0's send\n+        assert_equal(self.nodes[1].getbalance(), Decimal('29.98'))  # change from node 0's send\n+\n+        # Send total balance away from node 1\n+        txs = create_transactions(self.nodes[1], self.nodes[0].getnewaddress(), Decimal('29.97'), [Decimal('0.01')])\n+        self.nodes[1].sendrawtransaction(txs[0]['hex'])\n+        self.nodes[1].generatetoaddress(2, RANDOM_COINBASE_ADDRESS)\n+        self.sync_all()\n+\n+        # getbalance with a minconf incorrectly excludes coins that have been spent more recently than the minconf blocks ago\n+        # TODO: fix getbalance tracking of coin spentness depth\n+        # getbalance with minconf=3 should still show the old balance\n+        assert_equal(self.nodes[1].getbalance(minconf=3), Decimal('0'))\n+\n+        # getbalance with minconf=2 will show the new balance.\n+        assert_equal(self.nodes[1].getbalance(minconf=2), Decimal('0'))\n+\n+if __name__ == '__main__':\n+    WalletTest().main()"
      },
      {
        "sha": "7184bb8cb687dcf8ca2dedb4c0119015161efb13",
        "filename": "test/functional/wallet_basic.py",
        "status": "modified",
        "additions": 0,
        "deletions": 13,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/wallet_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/wallet_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_basic.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -67,15 +67,6 @@ def run_test(self):\n         assert_equal(self.nodes[1].getbalance(), 50)\n         assert_equal(self.nodes[2].getbalance(), 0)\n \n-        # Check getbalance with different arguments\n-        assert_equal(self.nodes[0].getbalance(\"*\"), 50)\n-        assert_equal(self.nodes[0].getbalance(\"*\", 1), 50)\n-        assert_equal(self.nodes[0].getbalance(\"*\", 1, True), 50)\n-        assert_equal(self.nodes[0].getbalance(minconf=1), 50)\n-\n-        # first argument of getbalance must be excluded or set to \"*\"\n-        assert_raises_rpc_error(-32, \"dummy first argument must be excluded or set to \\\"*\\\"\", self.nodes[0].getbalance, \"\")\n-\n         # Check that only first and second nodes have UTXOs\n         utxos = self.nodes[0].listunspent()\n         assert_equal(len(utxos), 1)\n@@ -248,10 +239,6 @@ def run_test(self):\n \n         assert(txid1 in self.nodes[3].getrawmempool())\n \n-        # Exercise balance rpcs\n-        assert_equal(self.nodes[0].getwalletinfo()[\"unconfirmed_balance\"], 1)\n-        assert_equal(self.nodes[0].getunconfirmedbalance(), 1)\n-\n         # check if we can list zero value tx as available coins\n         # 1. create raw_tx\n         # 2. hex-changed one output to 0.0"
      },
      {
        "sha": "7aa8b44ebd5d5c20502528485628f28684b0d26d",
        "filename": "test/functional/wallet_coinbase_category.py",
        "status": "added",
        "additions": 59,
        "deletions": 0,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/wallet_coinbase_category.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/wallet_coinbase_category.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_coinbase_category.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -0,0 +1,59 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2014-2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test coinbase transactions return the correct categories.\n+\n+Tests listtransactions, listsinceblock, and gettransaction.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_array_result\n+)\n+\n+class CoinbaseCategoryTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def assert_category(self, category, address, txid, skip):\n+        assert_array_result(self.nodes[0].listtransactions(skip=skip),\n+                            {\"address\": address},\n+                            {\"category\": category})\n+        assert_array_result(self.nodes[0].listsinceblock()[\"transactions\"],\n+                            {\"address\": address},\n+                            {\"category\": category})\n+        assert_array_result(self.nodes[0].gettransaction(txid)[\"details\"],\n+                            {\"address\": address},\n+                            {\"category\": category})\n+\n+    def run_test(self):\n+        # Generate one block to an address\n+        address = self.nodes[0].getnewaddress()\n+        self.nodes[0].generatetoaddress(1, address)\n+        hash = self.nodes[0].getbestblockhash()\n+        txid = self.nodes[0].getblock(hash)[\"tx\"][0]\n+\n+        # Coinbase transaction is immature after 1 confirmation\n+        self.assert_category(\"immature\", address, txid, 0)\n+\n+        # Mine another 99 blocks on top\n+        self.nodes[0].generate(99)\n+        # Coinbase transaction is still immature after 100 confirmations\n+        self.assert_category(\"immature\", address, txid, 99)\n+\n+        # Mine one more block\n+        self.nodes[0].generate(1)\n+        # Coinbase transaction is now matured, so category is \"generate\"\n+        self.assert_category(\"generate\", address, txid, 100)\n+\n+        # Orphan block that paid to address\n+        self.nodes[0].invalidateblock(hash)\n+        # Coinbase transaction is now orphaned\n+        self.assert_category(\"orphan\", address, txid, 100)\n+\n+if __name__ == '__main__':\n+    CoinbaseCategoryTest().main()"
      },
      {
        "sha": "a163f7018c2f215d545164cdefad546402b41402",
        "filename": "test/functional/wallet_importmulti.py",
        "status": "modified",
        "additions": 440,
        "deletions": 462,
        "changes": 902,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/wallet_importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/wallet_importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importmulti.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -2,9 +2,43 @@\n # Copyright (c) 2014-2018 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Test the importmulti RPC.\"\"\"\n-\n-from test_framework import script\n+\"\"\"Test the importmulti RPC.\n+\n+Test importmulti by generating keys on node0, importing the scriptPubKeys and\n+addresses on node1 and then testing the address info for the different address\n+variants.\n+\n+- `get_key()` and `get_multisig()` are called to generate keys on node0 and\n+  return the privkeys, pubkeys and all variants of scriptPubKey and address.\n+- `test_importmulti()` is called to send an importmulti call to node1, test\n+  success, and (if unsuccessful) test the error code and error message returned.\n+- `test_address()` is called to call getaddressinfo for an address on node1\n+  and test the values returned.\"\"\"\n+from collections import namedtuple\n+\n+from test_framework.address import (\n+    key_to_p2pkh,\n+    key_to_p2sh_p2wpkh,\n+    key_to_p2wpkh,\n+    script_to_p2sh,\n+    script_to_p2sh_p2wsh,\n+    script_to_p2wsh,\n+)\n+from test_framework.script import (\n+    CScript,\n+    OP_0,\n+    OP_2,\n+    OP_3,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKSIG,\n+    OP_DUP,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_NOP,\n+    hash160,\n+    sha256,\n+)\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n@@ -13,12 +47,26 @@\n     bytes_to_hex_str,\n     hex_str_to_bytes\n )\n-from test_framework.script import (\n-    CScript,\n-    OP_0,\n-    hash160\n-)\n-from test_framework.messages import sha256\n+\n+Key = namedtuple('Key', ['privkey',\n+                         'pubkey',\n+                         'p2pkh_script',\n+                         'p2pkh_addr',\n+                         'p2wpkh_script',\n+                         'p2wpkh_addr',\n+                         'p2sh_p2wpkh_script',\n+                         'p2sh_p2wpkh_redeem_script',\n+                         'p2sh_p2wpkh_addr'])\n+\n+Multisig = namedtuple('Multisig', ['privkeys',\n+                                   'pubkeys',\n+                                   'p2sh_script',\n+                                   'p2sh_addr',\n+                                   'redeem_script',\n+                                   'p2wsh_script',\n+                                   'p2wsh_addr',\n+                                   'p2sh_p2wsh_script',\n+                                   'p2sh_p2wsh_addr'])\n \n class ImportMultiTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -32,595 +80,525 @@ def skip_test_if_missing_module(self):\n     def setup_network(self):\n         self.setup_nodes()\n \n-    def run_test (self):\n+    def get_key(self):\n+        \"\"\"Generate a fresh key on node0\n+\n+        Returns a named tuple of privkey, pubkey and all address and scripts.\"\"\"\n+        addr = self.nodes[0].getnewaddress()\n+        pubkey = self.nodes[0].getaddressinfo(addr)['pubkey']\n+        pkh = hash160(hex_str_to_bytes(pubkey))\n+        return Key(self.nodes[0].dumpprivkey(addr),\n+                   pubkey,\n+                   CScript([OP_DUP, OP_HASH160, pkh, OP_EQUALVERIFY, OP_CHECKSIG]).hex(),  # p2pkh\n+                   key_to_p2pkh(pubkey),  # p2pkh addr\n+                   CScript([OP_0, pkh]).hex(),  # p2wpkh\n+                   key_to_p2wpkh(pubkey),  # p2wpkh addr\n+                   CScript([OP_HASH160, hash160(CScript([OP_0, pkh])), OP_EQUAL]).hex(),  # p2sh-p2wpkh\n+                   CScript([OP_0, pkh]).hex(),  # p2sh-p2wpkh redeem script\n+                   key_to_p2sh_p2wpkh(pubkey))  # p2sh-p2wpkh addr\n+\n+    def get_multisig(self):\n+        \"\"\"Generate a fresh multisig on node0\n+\n+        Returns a named tuple of privkeys, pubkeys and all address and scripts.\"\"\"\n+        addrs = []\n+        pubkeys = []\n+        for _ in range(3):\n+            addr = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+            addrs.append(addr['address'])\n+            pubkeys.append(addr['pubkey'])\n+        script_code = CScript([OP_2] + [hex_str_to_bytes(pubkey) for pubkey in pubkeys] + [OP_3, OP_CHECKMULTISIG])\n+        witness_script = CScript([OP_0, sha256(script_code)])\n+        return Multisig([self.nodes[0].dumpprivkey(addr) for addr in addrs],\n+                        pubkeys,\n+                        CScript([OP_HASH160, hash160(script_code), OP_EQUAL]).hex(),  # p2sh\n+                        script_to_p2sh(script_code),  # p2sh addr\n+                        script_code.hex(),  # redeem script\n+                        witness_script.hex(),  # p2wsh\n+                        script_to_p2wsh(script_code),  # p2wsh addr\n+                        CScript([OP_HASH160, witness_script, OP_EQUAL]).hex(),  # p2sh-p2wsh\n+                        script_to_p2sh_p2wsh(script_code))  # p2sh-p2wsh addr\n+\n+    def test_importmulti(self, req, success, error_code=None, error_message=None):\n+        \"\"\"Run importmulti and assert success\"\"\"\n+        result = self.nodes[1].importmulti([req])\n+        assert_equal(result[0]['success'], success)\n+        if error_code is not None:\n+            assert_equal(result[0]['error']['code'], error_code)\n+            assert_equal(result[0]['error']['message'], error_message)\n+\n+    def test_address(self, address, **kwargs):\n+        \"\"\"Get address info for `address` and test whether the returned values are as expected.\"\"\"\n+        addr_info = self.nodes[1].getaddressinfo(address)\n+        for key, value in kwargs.items():\n+            if value is None:\n+                if key in addr_info.keys():\n+                    raise AssertionError(\"key {} unexpectedly returned in getaddressinfo.\".format(key))\n+            elif addr_info[key] != value:\n+                raise AssertionError(\"key {} value {} did not match expected value {}\".format(key, addr_info[key], value))\n+\n+    def run_test(self):\n         self.log.info(\"Mining blocks...\")\n         self.nodes[0].generate(1)\n         self.nodes[1].generate(1)\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n \n         node0_address1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n \n-        #Check only one address\n+        # Check only one address\n         assert_equal(node0_address1['ismine'], True)\n \n-        #Node 1 sync test\n-        assert_equal(self.nodes[1].getblockcount(),1)\n+        # Node 1 sync test\n+        assert_equal(self.nodes[1].getblockcount(), 1)\n \n-        #Address Test - before import\n+        # Address Test - before import\n         address_info = self.nodes[1].getaddressinfo(node0_address1['address'])\n         assert_equal(address_info['iswatchonly'], False)\n         assert_equal(address_info['ismine'], False)\n \n-\n         # RPC importmulti -----------------------------------------------\n \n         # Bitcoin Address (implicit non-internal)\n         self.log.info(\"Should import an address\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": address['address']\n-            },\n-            \"timestamp\": \"now\",\n-        }])\n-        assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n-        assert_equal(address_assert['iswatchonly'], True)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal(address_assert['timestamp'], timestamp)\n-        assert_equal(address_assert['ischange'], False)\n-        watchonly_address = address['address']\n+        key = self.get_key()\n+        address = key.p2pkh_addr\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+                               \"timestamp\": \"now\"},\n+                              True)\n+        self.test_address(address,\n+                          iswatchonly=True,\n+                          ismine=False,\n+                          timestamp=timestamp,\n+                          ischange=False)\n+        watchonly_address = address\n         watchonly_timestamp = timestamp\n \n         self.log.info(\"Should not import an invalid address\")\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": \"not valid address\",\n-            },\n-            \"timestamp\": \"now\",\n-        }])\n-        assert_equal(result[0]['success'], False)\n-        assert_equal(result[0]['error']['code'], -5)\n-        assert_equal(result[0]['error']['message'], 'Invalid address')\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": \"not valid address\"},\n+                               \"timestamp\": \"now\"},\n+                              False,\n+                              error_code=-5,\n+                              error_message='Invalid address')\n \n         # ScriptPubKey + internal\n         self.log.info(\"Should import a scriptPubKey with internal flag\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": address['scriptPubKey'],\n-            \"timestamp\": \"now\",\n-            \"internal\": True\n-        }])\n-        assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n-        assert_equal(address_assert['iswatchonly'], True)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal(address_assert['timestamp'], timestamp)\n-        assert_equal(address_assert['ischange'], True)\n+        key = self.get_key()\n+        self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n+                               \"timestamp\": \"now\",\n+                               \"internal\": True},\n+                              True)\n+        self.test_address(key.p2pkh_addr,\n+                          iswatchonly=True,\n+                          ismine=False,\n+                          timestamp=timestamp,\n+                          ischange=True)\n \n         # ScriptPubKey + internal + label\n         self.log.info(\"Should not allow a label to be specified when internal is true\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": address['scriptPubKey'],\n-            \"timestamp\": \"now\",\n-            \"internal\": True,\n-            \"label\": \"Example label\"\n-        }])\n-        assert_equal(result[0]['success'], False)\n-        assert_equal(result[0]['error']['code'], -8)\n-        assert_equal(result[0]['error']['message'], 'Internal addresses should not have a label')\n+        key = self.get_key()\n+        self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n+                               \"timestamp\": \"now\",\n+                               \"internal\": True,\n+                               \"label\": \"Example label\"},\n+                              False,\n+                              error_code=-8,\n+                              error_message='Internal addresses should not have a label')\n \n         # Nonstandard scriptPubKey + !internal\n         self.log.info(\"Should not import a nonstandard scriptPubKey without internal flag\")\n-        nonstandardScriptPubKey = address['scriptPubKey'] + bytes_to_hex_str(script.CScript([script.OP_NOP]))\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": nonstandardScriptPubKey,\n-            \"timestamp\": \"now\",\n-        }])\n-        assert_equal(result[0]['success'], False)\n-        assert_equal(result[0]['error']['code'], -8)\n-        assert_equal(result[0]['error']['message'], 'Internal must be set to true for nonstandard scriptPubKey imports.')\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n-        assert_equal(address_assert['iswatchonly'], False)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal('timestamp' in address_assert, False)\n-\n+        nonstandardScriptPubKey = key.p2pkh_script + bytes_to_hex_str(CScript([OP_NOP]))\n+        key = self.get_key()\n+        address = key.p2pkh_addr\n+        self.test_importmulti({\"scriptPubKey\": nonstandardScriptPubKey,\n+                               \"timestamp\": \"now\"},\n+                              False,\n+                              error_code=-8,\n+                              error_message='Internal must be set to true for nonstandard scriptPubKey imports.')\n+        self.test_address(address,\n+                          iswatchonly=False,\n+                          ismine=False,\n+                          timestamp=None)\n \n         # Address + Public key + !Internal(explicit)\n         self.log.info(\"Should import an address with public key\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": address['address']\n-            },\n-            \"timestamp\": \"now\",\n-            \"pubkeys\": [ address['pubkey'] ],\n-            \"internal\": False\n-        }])\n-        assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n-        assert_equal(address_assert['iswatchonly'], True)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal(address_assert['timestamp'], timestamp)\n-\n+        key = self.get_key()\n+        address = key.p2pkh_addr\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+                               \"timestamp\": \"now\",\n+                               \"pubkeys\": [key.pubkey],\n+                               \"internal\": False},\n+                              True)\n+        self.test_address(address,\n+                          iswatchonly=True,\n+                          ismine=False,\n+                          timestamp=timestamp)\n \n         # ScriptPubKey + Public key + internal\n         self.log.info(\"Should import a scriptPubKey with internal and with public key\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        request = [{\n-            \"scriptPubKey\": address['scriptPubKey'],\n-            \"timestamp\": \"now\",\n-            \"pubkeys\": [ address['pubkey'] ],\n-            \"internal\": True\n-        }]\n-        result = self.nodes[1].importmulti(requests=request)\n-        assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n-        assert_equal(address_assert['iswatchonly'], True)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal(address_assert['timestamp'], timestamp)\n+        key = self.get_key()\n+        address = key.p2pkh_addr\n+        self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n+                               \"timestamp\": \"now\",\n+                               \"pubkeys\": [key.pubkey],\n+                               \"internal\": True},\n+                              True)\n+        self.test_address(address,\n+                          iswatchonly=True,\n+                          ismine=False,\n+                          timestamp=timestamp)\n \n         # Nonstandard scriptPubKey + Public key + !internal\n         self.log.info(\"Should not import a nonstandard scriptPubKey without internal and with public key\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        request = [{\n-            \"scriptPubKey\": nonstandardScriptPubKey,\n-            \"timestamp\": \"now\",\n-            \"pubkeys\": [ address['pubkey'] ]\n-        }]\n-        result = self.nodes[1].importmulti(requests=request)\n-        assert_equal(result[0]['success'], False)\n-        assert_equal(result[0]['error']['code'], -8)\n-        assert_equal(result[0]['error']['message'], 'Internal must be set to true for nonstandard scriptPubKey imports.')\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n-        assert_equal(address_assert['iswatchonly'], False)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal('timestamp' in address_assert, False)\n+        key = self.get_key()\n+        address = key.p2pkh_addr\n+        self.test_importmulti({\"scriptPubKey\": nonstandardScriptPubKey,\n+                               \"timestamp\": \"now\",\n+                               \"pubkeys\": [key.pubkey]},\n+                              False,\n+                              error_code=-8,\n+                              error_message='Internal must be set to true for nonstandard scriptPubKey imports.')\n+        self.test_address(address,\n+                          iswatchonly=False,\n+                          ismine=False,\n+                          timestamp=None)\n \n         # Address + Private key + !watchonly\n         self.log.info(\"Should import an address with private key\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": address['address']\n-            },\n-            \"timestamp\": \"now\",\n-            \"keys\": [ self.nodes[0].dumpprivkey(address['address']) ]\n-        }])\n-        assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n-        assert_equal(address_assert['iswatchonly'], False)\n-        assert_equal(address_assert['ismine'], True)\n-        assert_equal(address_assert['timestamp'], timestamp)\n+        key = self.get_key()\n+        address = key.p2pkh_addr\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+                               \"timestamp\": \"now\",\n+                               \"keys\": [key.privkey]},\n+                              True)\n+        self.test_address(address,\n+                          iswatchonly=False,\n+                          ismine=True,\n+                          timestamp=timestamp)\n \n         self.log.info(\"Should not import an address with private key if is already imported\")\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": address['address']\n-            },\n-            \"timestamp\": \"now\",\n-            \"keys\": [ self.nodes[0].dumpprivkey(address['address']) ]\n-        }])\n-        assert_equal(result[0]['success'], False)\n-        assert_equal(result[0]['error']['code'], -4)\n-        assert_equal(result[0]['error']['message'], 'The wallet already contains the private key for this address or script')\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+                               \"timestamp\": \"now\",\n+                               \"keys\": [key.privkey]},\n+                              False,\n+                              error_code=-4,\n+                              error_message='The wallet already contains the private key for this address or script')\n \n         # Address + Private key + watchonly\n         self.log.info(\"Should not import an address with private key and with watchonly\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": address['address']\n-            },\n-            \"timestamp\": \"now\",\n-            \"keys\": [ self.nodes[0].dumpprivkey(address['address']) ],\n-            \"watchonly\": True\n-        }])\n-        assert_equal(result[0]['success'], False)\n-        assert_equal(result[0]['error']['code'], -8)\n-        assert_equal(result[0]['error']['message'], 'Watch-only addresses should not include private keys')\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n-        assert_equal(address_assert['iswatchonly'], False)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal('timestamp' in address_assert, False)\n+        key = self.get_key()\n+        address = key.p2pkh_addr\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+                               \"timestamp\": \"now\",\n+                               \"keys\": [key.privkey],\n+                               \"watchonly\": True},\n+                              False,\n+                              error_code=-8,\n+                              error_message='Watch-only addresses should not include private keys')\n+        self.test_address(address,\n+                          iswatchonly=False,\n+                          ismine=False,\n+                          timestamp=None)\n \n         # ScriptPubKey + Private key + internal\n         self.log.info(\"Should import a scriptPubKey with internal and with private key\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": address['scriptPubKey'],\n-            \"timestamp\": \"now\",\n-            \"keys\": [ self.nodes[0].dumpprivkey(address['address']) ],\n-            \"internal\": True\n-        }])\n-        assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n-        assert_equal(address_assert['iswatchonly'], False)\n-        assert_equal(address_assert['ismine'], True)\n-        assert_equal(address_assert['timestamp'], timestamp)\n+        key = self.get_key()\n+        address = key.p2pkh_addr\n+        self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n+                               \"timestamp\": \"now\",\n+                               \"keys\": [key.privkey],\n+                               \"internal\": True},\n+                              True)\n+        self.test_address(address,\n+                          iswatchonly=False,\n+                          ismine=True,\n+                          timestamp=timestamp)\n \n         # Nonstandard scriptPubKey + Private key + !internal\n         self.log.info(\"Should not import a nonstandard scriptPubKey without internal and with private key\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": nonstandardScriptPubKey,\n-            \"timestamp\": \"now\",\n-            \"keys\": [ self.nodes[0].dumpprivkey(address['address']) ]\n-        }])\n-        assert_equal(result[0]['success'], False)\n-        assert_equal(result[0]['error']['code'], -8)\n-        assert_equal(result[0]['error']['message'], 'Internal must be set to true for nonstandard scriptPubKey imports.')\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n-        assert_equal(address_assert['iswatchonly'], False)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal('timestamp' in address_assert, False)\n-\n+        key = self.get_key()\n+        address = key.p2pkh_addr\n+        self.test_importmulti({\"scriptPubKey\": nonstandardScriptPubKey,\n+                               \"timestamp\": \"now\",\n+                               \"keys\": [key.privkey]},\n+                              False,\n+                              error_code=-8,\n+                              error_message='Internal must be set to true for nonstandard scriptPubKey imports.')\n+        self.test_address(address,\n+                          iswatchonly=False,\n+                          ismine=False,\n+                          timestamp=None)\n \n         # P2SH address\n-        sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        sig_address_2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        sig_address_3 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        multi_sig_script = self.nodes[0].createmultisig(2, [sig_address_1['pubkey'], sig_address_2['pubkey'], sig_address_3['pubkey']])\n+        multisig = self.get_multisig()\n         self.nodes[1].generate(100)\n-        self.nodes[1].sendtoaddress(multi_sig_script['address'], 10.00)\n+        self.nodes[1].sendtoaddress(multisig.p2sh_addr, 10.00)\n         self.nodes[1].generate(1)\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n \n         self.log.info(\"Should import a p2sh\")\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": multi_sig_script['address']\n-            },\n-            \"timestamp\": \"now\",\n-        }])\n-        assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(multi_sig_script['address'])\n-        assert_equal(address_assert['isscript'], True)\n-        assert_equal(address_assert['iswatchonly'], True)\n-        assert_equal(address_assert['timestamp'], timestamp)\n-        p2shunspent = self.nodes[1].listunspent(0,999999, [multi_sig_script['address']])[0]\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2sh_addr},\n+                               \"timestamp\": \"now\"},\n+                              True)\n+        self.test_address(multisig.p2sh_addr,\n+                          isscript=True,\n+                          iswatchonly=True,\n+                          timestamp=timestamp)\n+        p2shunspent = self.nodes[1].listunspent(0, 999999, [multisig.p2sh_addr])[0]\n         assert_equal(p2shunspent['spendable'], False)\n         assert_equal(p2shunspent['solvable'], False)\n \n-\n         # P2SH + Redeem script\n-        sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        sig_address_2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        sig_address_3 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        multi_sig_script = self.nodes[0].createmultisig(2, [sig_address_1['pubkey'], sig_address_2['pubkey'], sig_address_3['pubkey']])\n+        multisig = self.get_multisig()\n         self.nodes[1].generate(100)\n-        self.nodes[1].sendtoaddress(multi_sig_script['address'], 10.00)\n+        self.nodes[1].sendtoaddress(multisig.p2sh_addr, 10.00)\n         self.nodes[1].generate(1)\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n \n         self.log.info(\"Should import a p2sh with respective redeem script\")\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": multi_sig_script['address']\n-            },\n-            \"timestamp\": \"now\",\n-            \"redeemscript\": multi_sig_script['redeemScript']\n-        }])\n-        assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(multi_sig_script['address'])\n-        assert_equal(address_assert['timestamp'], timestamp)\n-\n-        p2shunspent = self.nodes[1].listunspent(0,999999, [multi_sig_script['address']])[0]\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2sh_addr},\n+                               \"timestamp\": \"now\",\n+                               \"redeemscript\": multisig.redeem_script},\n+                              True)\n+        self.test_address(multisig.p2sh_addr, timestamp=timestamp)\n+\n+        p2shunspent = self.nodes[1].listunspent(0, 999999, [multisig.p2sh_addr])[0]\n         assert_equal(p2shunspent['spendable'], False)\n         assert_equal(p2shunspent['solvable'], True)\n \n-\n         # P2SH + Redeem script + Private Keys + !Watchonly\n-        sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        sig_address_2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        sig_address_3 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        multi_sig_script = self.nodes[0].createmultisig(2, [sig_address_1['pubkey'], sig_address_2['pubkey'], sig_address_3['pubkey']])\n+        multisig = self.get_multisig()\n         self.nodes[1].generate(100)\n-        self.nodes[1].sendtoaddress(multi_sig_script['address'], 10.00)\n+        self.nodes[1].sendtoaddress(multisig.p2sh_addr, 10.00)\n         self.nodes[1].generate(1)\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n \n         self.log.info(\"Should import a p2sh with respective redeem script and private keys\")\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": multi_sig_script['address']\n-            },\n-            \"timestamp\": \"now\",\n-            \"redeemscript\": multi_sig_script['redeemScript'],\n-            \"keys\": [ self.nodes[0].dumpprivkey(sig_address_1['address']), self.nodes[0].dumpprivkey(sig_address_2['address'])]\n-        }])\n-        assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(multi_sig_script['address'])\n-        assert_equal(address_assert['timestamp'], timestamp)\n-\n-        p2shunspent = self.nodes[1].listunspent(0,999999, [multi_sig_script['address']])[0]\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2sh_addr},\n+                               \"timestamp\": \"now\",\n+                               \"redeemscript\": multisig.redeem_script,\n+                               \"keys\": multisig.privkeys[0:2]},\n+                              True)\n+        self.test_address(multisig.p2sh_addr,\n+                          timestamp=timestamp)\n+\n+        p2shunspent = self.nodes[1].listunspent(0, 999999, [multisig.p2sh_addr])[0]\n         assert_equal(p2shunspent['spendable'], False)\n         assert_equal(p2shunspent['solvable'], True)\n \n         # P2SH + Redeem script + Private Keys + Watchonly\n-        sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        sig_address_2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        sig_address_3 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        multi_sig_script = self.nodes[0].createmultisig(2, [sig_address_1['pubkey'], sig_address_2['pubkey'], sig_address_3['pubkey']])\n+        multisig = self.get_multisig()\n         self.nodes[1].generate(100)\n-        self.nodes[1].sendtoaddress(multi_sig_script['address'], 10.00)\n+        self.nodes[1].sendtoaddress(multisig.p2sh_addr, 10.00)\n         self.nodes[1].generate(1)\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n \n         self.log.info(\"Should import a p2sh with respective redeem script and private keys\")\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": multi_sig_script['address']\n-            },\n-            \"timestamp\": \"now\",\n-            \"redeemscript\": multi_sig_script['redeemScript'],\n-            \"keys\": [ self.nodes[0].dumpprivkey(sig_address_1['address']), self.nodes[0].dumpprivkey(sig_address_2['address'])],\n-            \"watchonly\": True\n-        }])\n-        assert_equal(result[0]['success'], False)\n-        assert_equal(result[0]['error']['code'], -8)\n-        assert_equal(result[0]['error']['message'], 'Watch-only addresses should not include private keys')\n-\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2sh_addr},\n+                               \"timestamp\": \"now\",\n+                               \"redeemscript\": multisig.redeem_script,\n+                               \"keys\": multisig.privkeys[0:2],\n+                               \"watchonly\": True},\n+                              False,\n+                              error_code=-8,\n+                              error_message='Watch-only addresses should not include private keys')\n \n         # Address + Public key + !Internal + Wrong pubkey\n         self.log.info(\"Should not import an address with a wrong public key\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        address2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": address['address']\n-            },\n-            \"timestamp\": \"now\",\n-            \"pubkeys\": [ address2['pubkey'] ]\n-        }])\n-        assert_equal(result[0]['success'], False)\n-        assert_equal(result[0]['error']['code'], -5)\n-        assert_equal(result[0]['error']['message'], 'Key does not match address destination')\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n-        assert_equal(address_assert['iswatchonly'], False)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal('timestamp' in address_assert, False)\n-\n+        key = self.get_key()\n+        address = key.p2pkh_addr\n+        wrong_key = self.get_key().pubkey\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+                               \"timestamp\": \"now\",\n+                               \"pubkeys\": [wrong_key]},\n+                              False,\n+                              error_code=-5,\n+                              error_message='Key does not match address destination')\n+        self.test_address(address,\n+                          iswatchonly=False,\n+                          ismine=False,\n+                          timestamp=None)\n \n         # ScriptPubKey + Public key + internal + Wrong pubkey\n         self.log.info(\"Should not import a scriptPubKey with internal and with a wrong public key\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        address2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        request = [{\n-            \"scriptPubKey\": address['scriptPubKey'],\n-            \"timestamp\": \"now\",\n-            \"pubkeys\": [ address2['pubkey'] ],\n-            \"internal\": True\n-        }]\n-        result = self.nodes[1].importmulti(request)\n-        assert_equal(result[0]['success'], False)\n-        assert_equal(result[0]['error']['code'], -5)\n-        assert_equal(result[0]['error']['message'], 'Key does not match address destination')\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n-        assert_equal(address_assert['iswatchonly'], False)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal('timestamp' in address_assert, False)\n-\n+        key = self.get_key()\n+        address = key.p2pkh_addr\n+        wrong_key = self.get_key().pubkey\n+        self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n+                               \"timestamp\": \"now\",\n+                               \"pubkeys\": [wrong_key],\n+                               \"internal\": True},\n+                              False,\n+                              error_code=-5,\n+                              error_message='Key does not match address destination')\n+        self.test_address(address,\n+                          iswatchonly=False,\n+                          ismine=False,\n+                          timestamp=None)\n \n         # Address + Private key + !watchonly + Wrong private key\n         self.log.info(\"Should not import an address with a wrong private key\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        address2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": address['address']\n-            },\n-            \"timestamp\": \"now\",\n-            \"keys\": [ self.nodes[0].dumpprivkey(address2['address']) ]\n-        }])\n-        assert_equal(result[0]['success'], False)\n-        assert_equal(result[0]['error']['code'], -5)\n-        assert_equal(result[0]['error']['message'], 'Key does not match address destination')\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n-        assert_equal(address_assert['iswatchonly'], False)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal('timestamp' in address_assert, False)\n-\n+        key = self.get_key()\n+        address = key.p2pkh_addr\n+        wrong_privkey = self.get_key().privkey\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+                               \"timestamp\": \"now\",\n+                               \"keys\": [wrong_privkey]},\n+                              False,\n+                              error_code=-5,\n+                              error_message='Key does not match address destination')\n+        self.test_address(address,\n+                          iswatchonly=False,\n+                          ismine=False,\n+                          timestamp=None)\n \n         # ScriptPubKey + Private key + internal + Wrong private key\n         self.log.info(\"Should not import a scriptPubKey with internal and with a wrong private key\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        address2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": address['scriptPubKey'],\n-            \"timestamp\": \"now\",\n-            \"keys\": [ self.nodes[0].dumpprivkey(address2['address']) ],\n-            \"internal\": True\n-        }])\n-        assert_equal(result[0]['success'], False)\n-        assert_equal(result[0]['error']['code'], -5)\n-        assert_equal(result[0]['error']['message'], 'Key does not match address destination')\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n-        assert_equal(address_assert['iswatchonly'], False)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal('timestamp' in address_assert, False)\n-\n+        key = self.get_key()\n+        address = key.p2pkh_addr\n+        wrong_privkey = self.get_key().privkey\n+        self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n+                               \"timestamp\": \"now\",\n+                               \"keys\": [wrong_privkey],\n+                               \"internal\": True},\n+                              False,\n+                              error_code=-5,\n+                              error_message='Key does not match address destination')\n+        self.test_address(address,\n+                          iswatchonly=False,\n+                          ismine=False,\n+                          timestamp=None)\n \n         # Importing existing watch only address with new timestamp should replace saved timestamp.\n         assert_greater_than(timestamp, watchonly_timestamp)\n         self.log.info(\"Should replace previously saved watch only timestamp.\")\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": watchonly_address,\n-            },\n-            \"timestamp\": \"now\",\n-        }])\n-        assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(watchonly_address)\n-        assert_equal(address_assert['iswatchonly'], True)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal(address_assert['timestamp'], timestamp)\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": watchonly_address},\n+                               \"timestamp\": \"now\"},\n+                              True)\n+        self.test_address(watchonly_address,\n+                          iswatchonly=True,\n+                          ismine=False,\n+                          timestamp=timestamp)\n         watchonly_timestamp = timestamp\n \n-\n         # restart nodes to check for proper serialization/deserialization of watch only address\n         self.stop_nodes()\n         self.start_nodes()\n-        address_assert = self.nodes[1].getaddressinfo(watchonly_address)\n-        assert_equal(address_assert['iswatchonly'], True)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal(address_assert['timestamp'], watchonly_timestamp)\n+        self.test_address(watchonly_address,\n+                          iswatchonly=True,\n+                          ismine=False,\n+                          timestamp=watchonly_timestamp)\n \n         # Bad or missing timestamps\n         self.log.info(\"Should throw on invalid or missing timestamp values\")\n         assert_raises_rpc_error(-3, 'Missing required timestamp field for key',\n-            self.nodes[1].importmulti, [{\n-                \"scriptPubKey\": address['scriptPubKey'],\n-            }])\n+                                self.nodes[1].importmulti, [{\"scriptPubKey\": key.p2pkh_script}])\n         assert_raises_rpc_error(-3, 'Expected number or \"now\" timestamp value for key. got type string',\n-            self.nodes[1].importmulti, [{\n-                \"scriptPubKey\": address['scriptPubKey'],\n-                \"timestamp\": \"\",\n-            }])\n+                                self.nodes[1].importmulti, [{\n+                                    \"scriptPubKey\": key.p2pkh_script,\n+                                    \"timestamp\": \"\"\n+                                }])\n \n         # Import P2WPKH address as watch only\n         self.log.info(\"Should import a P2WPKH address as watch only\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress(address_type=\"bech32\"))\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": address['address']\n-            },\n-            \"timestamp\": \"now\",\n-        }])\n-        assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n-        assert_equal(address_assert['iswatchonly'], True)\n-        assert_equal(address_assert['solvable'], False)\n+        key = self.get_key()\n+        address = key.p2wpkh_addr\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+                               \"timestamp\": \"now\"},\n+                              True)\n+        self.test_address(address,\n+                          iswatchonly=True,\n+                          solvable=False)\n \n         # Import P2WPKH address with public key but no private key\n         self.log.info(\"Should import a P2WPKH address and public key as solvable but not spendable\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress(address_type=\"bech32\"))\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": address['address']\n-            },\n-            \"timestamp\": \"now\",\n-            \"pubkeys\": [ address['pubkey'] ]\n-        }])\n-        assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal(address_assert['solvable'], True)\n+        key = self.get_key()\n+        address = key.p2wpkh_addr\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+                               \"timestamp\": \"now\",\n+                               \"pubkeys\": [key.pubkey]},\n+                              True)\n+        self.test_address(address,\n+                          ismine=False,\n+                          solvable=True)\n \n         # Import P2WPKH address with key and check it is spendable\n         self.log.info(\"Should import a P2WPKH address with key\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress(address_type=\"bech32\"))\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": address['address']\n-            },\n-            \"timestamp\": \"now\",\n-            \"keys\": [self.nodes[0].dumpprivkey(address['address'])]\n-        }])\n-        assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n-        assert_equal(address_assert['iswatchonly'], False)\n-        assert_equal(address_assert['ismine'], True)\n+        key = self.get_key()\n+        address = key.p2wpkh_addr\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+                               \"timestamp\": \"now\",\n+                               \"keys\": [key.privkey]},\n+                              True)\n+        self.test_address(address,\n+                          iswatchonly=False,\n+                          ismine=True)\n \n         # P2WSH multisig address without scripts or keys\n-        sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        sig_address_2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        multi_sig_script = self.nodes[0].addmultisigaddress(2, [sig_address_1['pubkey'], sig_address_2['pubkey']], \"\", \"bech32\")\n+        multisig = self.get_multisig()\n         self.log.info(\"Should import a p2wsh multisig as watch only without respective redeem script and private keys\")\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": multi_sig_script['address']\n-            },\n-            \"timestamp\": \"now\"\n-        }])\n-        assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(multi_sig_script['address'])\n-        assert_equal(address_assert['solvable'], False)\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2wsh_addr},\n+                               \"timestamp\": \"now\"},\n+                              True)\n+        self.test_address(multisig.p2sh_addr,\n+                          solvable=False)\n \n         # Same P2WSH multisig address as above, but now with witnessscript + private keys\n-        self.log.info(\"Should import a p2wsh with respective redeem script and private keys\")\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": multi_sig_script['address']\n-            },\n-            \"timestamp\": \"now\",\n-            \"witnessscript\": multi_sig_script['redeemScript'],\n-            \"keys\": [ self.nodes[0].dumpprivkey(sig_address_1['address']), self.nodes[0].dumpprivkey(sig_address_2['address']) ]\n-        }])\n-        assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(multi_sig_script['address'])\n-        assert_equal(address_assert['solvable'], True)\n-        assert_equal(address_assert['ismine'], True)\n-        assert_equal(address_assert['sigsrequired'], 2)\n+        self.log.info(\"Should import a p2wsh with respective witness script and private keys\")\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2wsh_addr},\n+                               \"timestamp\": \"now\",\n+                               \"witnessscript\": multisig.redeem_script,\n+                               \"keys\": multisig.privkeys},\n+                              True)\n+        self.test_address(multisig.p2sh_addr,\n+                          solvable=True,\n+                          ismine=True,\n+                          sigsrequired=2)\n \n         # P2SH-P2WPKH address with no redeemscript or public or private key\n-        sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress(address_type=\"p2sh-segwit\"))\n-        pubkeyhash = hash160(hex_str_to_bytes(sig_address_1['pubkey']))\n-        pkscript = CScript([OP_0, pubkeyhash])\n+        key = self.get_key()\n+        address = key.p2sh_p2wpkh_addr\n         self.log.info(\"Should import a p2sh-p2wpkh without redeem script or keys\")\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": sig_address_1['address']\n-            },\n-            \"timestamp\": \"now\"\n-        }])\n-        assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(sig_address_1['address'])\n-        assert_equal(address_assert['solvable'], False)\n-        assert_equal(address_assert['ismine'], False)\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+                               \"timestamp\": \"now\"},\n+                              True)\n+        self.test_address(address,\n+                          solvable=False,\n+                          ismine=False)\n \n         # P2SH-P2WPKH address + redeemscript + public key with no private key\n         self.log.info(\"Should import a p2sh-p2wpkh with respective redeem script and pubkey as solvable\")\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": sig_address_1['address']\n-            },\n-            \"timestamp\": \"now\",\n-            \"redeemscript\": bytes_to_hex_str(pkscript),\n-            \"pubkeys\": [ sig_address_1['pubkey'] ]\n-        }])\n-        assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(sig_address_1['address'])\n-        assert_equal(address_assert['solvable'], True)\n-        assert_equal(address_assert['ismine'], False)\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+                               \"timestamp\": \"now\",\n+                               \"redeemscript\": key.p2sh_p2wpkh_redeem_script,\n+                               \"pubkeys\": [key.pubkey]},\n+                              True)\n+        self.test_address(address,\n+                          solvable=True,\n+                          ismine=False)\n \n         # P2SH-P2WPKH address + redeemscript + private key\n-        sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress(address_type=\"p2sh-segwit\"))\n-        pubkeyhash = hash160(hex_str_to_bytes(sig_address_1['pubkey']))\n-        pkscript = CScript([OP_0, pubkeyhash])\n+        key = self.get_key()\n+        address = key.p2sh_p2wpkh_addr\n         self.log.info(\"Should import a p2sh-p2wpkh with respective redeem script and private keys\")\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": sig_address_1['address']\n-            },\n-            \"timestamp\": \"now\",\n-            \"redeemscript\": bytes_to_hex_str(pkscript),\n-            \"keys\": [ self.nodes[0].dumpprivkey(sig_address_1['address'])]\n-        }])\n-        assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(sig_address_1['address'])\n-        assert_equal(address_assert['solvable'], True)\n-        assert_equal(address_assert['ismine'], True)\n-\n-        # P2SH-P2WSH 1-of-1 multisig + redeemscript with no private key\n-        sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        multi_sig_script = self.nodes[0].addmultisigaddress(1, [sig_address_1['pubkey']], \"\", \"p2sh-segwit\")\n-        scripthash = sha256(hex_str_to_bytes(multi_sig_script['redeemScript']))\n-        redeem_script = CScript([OP_0, scripthash])\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+                               \"timestamp\": \"now\",\n+                               \"redeemscript\": key.p2sh_p2wpkh_redeem_script,\n+                               \"keys\": [key.privkey]},\n+                              True)\n+        self.test_address(address,\n+                          solvable=True,\n+                          ismine=True)\n+\n+        # P2SH-P2WSH multisig + redeemscript with no private key\n+        multisig = self.get_multisig()\n         self.log.info(\"Should import a p2sh-p2wsh with respective redeem script but no private key\")\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": multi_sig_script['address']\n-            },\n-            \"timestamp\": \"now\",\n-            \"redeemscript\": bytes_to_hex_str(redeem_script),\n-            \"witnessscript\": multi_sig_script['redeemScript']\n-        }])\n-        assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(multi_sig_script['address'])\n-        assert_equal(address_assert['solvable'], True)\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2sh_p2wsh_addr},\n+                               \"timestamp\": \"now\",\n+                               \"redeemscript\": multisig.p2wsh_script,\n+                               \"witnessscript\": multisig.redeem_script},\n+                              True)\n+        self.test_address(address,\n+                          solvable=True)\n \n if __name__ == '__main__':\n-    ImportMultiTest ().main ()\n+    ImportMultiTest().main()"
      },
      {
        "sha": "b7c8d3098d2b5e6eae899e33c7994848ea6b3632",
        "filename": "test/functional/wallet_keypool_topup.py",
        "status": "modified",
        "additions": 39,
        "deletions": 24,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/wallet_keypool_topup.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/functional/wallet_keypool_topup.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_keypool_topup.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -24,8 +24,8 @@\n class KeypoolRestoreTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.setup_clean_chain = True\n-        self.num_nodes = 2\n-        self.extra_args = [[], ['-keypool=100']]\n+        self.num_nodes = 4\n+        self.extra_args = [[], ['-keypool=100'], ['-keypool=100'], ['-keypool=100']]\n \n     def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()\n@@ -40,32 +40,47 @@ def run_test(self):\n         shutil.copyfile(wallet_path, wallet_backup_path)\n         self.start_node(1, self.extra_args[1])\n         connect_nodes_bi(self.nodes, 0, 1)\n+        connect_nodes_bi(self.nodes, 0, 2)\n+        connect_nodes_bi(self.nodes, 0, 3)\n \n-        self.log.info(\"Generate keys for wallet\")\n-        for _ in range(90):\n-            addr_oldpool = self.nodes[1].getnewaddress()\n-        for _ in range(20):\n-            addr_extpool = self.nodes[1].getnewaddress()\n+        for i, output_type in enumerate([\"legacy\", \"p2sh-segwit\", \"bech32\"]):\n \n-        self.log.info(\"Send funds to wallet\")\n-        self.nodes[0].sendtoaddress(addr_oldpool, 10)\n-        self.nodes[0].generate(1)\n-        self.nodes[0].sendtoaddress(addr_extpool, 5)\n-        self.nodes[0].generate(1)\n-        sync_blocks(self.nodes)\n+            self.log.info(\"Generate keys for wallet with address type: {}\".format(output_type))\n+            idx = i+1\n+            for _ in range(90):\n+                addr_oldpool = self.nodes[idx].getnewaddress(address_type=output_type)\n+            for _ in range(20):\n+                addr_extpool = self.nodes[idx].getnewaddress(address_type=output_type)\n \n-        self.log.info(\"Restart node with wallet backup\")\n-        self.stop_node(1)\n-        shutil.copyfile(wallet_backup_path, wallet_path)\n-        self.start_node(1, self.extra_args[1])\n-        connect_nodes_bi(self.nodes, 0, 1)\n-        self.sync_all()\n+            # Make sure we're creating the outputs we expect\n+            address_details = self.nodes[idx].validateaddress(addr_extpool)\n+            if i == 0:\n+                assert(not address_details[\"isscript\"] and not address_details[\"iswitness\"])\n+            elif i == 1:\n+                assert(address_details[\"isscript\"] and not address_details[\"iswitness\"])\n+            else:\n+                assert(not address_details[\"isscript\"] and address_details[\"iswitness\"])\n+\n+\n+            self.log.info(\"Send funds to wallet\")\n+            self.nodes[0].sendtoaddress(addr_oldpool, 10)\n+            self.nodes[0].generate(1)\n+            self.nodes[0].sendtoaddress(addr_extpool, 5)\n+            self.nodes[0].generate(1)\n+            sync_blocks(self.nodes)\n+\n+            self.log.info(\"Restart node with wallet backup\")\n+            self.stop_node(idx)\n+            shutil.copyfile(wallet_backup_path, wallet_path)\n+            self.start_node(idx, self.extra_args[idx])\n+            connect_nodes_bi(self.nodes, 0, idx)\n+            self.sync_all()\n \n-        self.log.info(\"Verify keypool is restored and balance is correct\")\n-        assert_equal(self.nodes[1].getbalance(), 15)\n-        assert_equal(self.nodes[1].listtransactions()[0]['category'], \"receive\")\n-        # Check that we have marked all keys up to the used keypool key as used\n-        assert_equal(self.nodes[1].getaddressinfo(self.nodes[1].getnewaddress())['hdkeypath'], \"m/0'/0'/110'\")\n+            self.log.info(\"Verify keypool is restored and balance is correct\")\n+            assert_equal(self.nodes[idx].getbalance(), 15)\n+            assert_equal(self.nodes[idx].listtransactions()[0]['category'], \"receive\")\n+            # Check that we have marked all keys up to the used keypool key as used\n+            assert_equal(self.nodes[idx].getaddressinfo(self.nodes[idx].getnewaddress())['hdkeypath'], \"m/0'/0'/110'\")\n \n \n if __name__ == '__main__':"
      },
      {
        "sha": "4facd6c33472882f5cbb75ae151d49848f68ee59",
        "filename": "test/lint/check-doc.py",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/lint/check-doc.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/lint/check-doc.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/check-doc.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -26,8 +26,12 @@\n \n \n def main():\n-    used = check_output(CMD_GREP_ARGS, shell=True, universal_newlines=True, encoding='utf8')\n-    docd = check_output(CMD_GREP_DOCS, shell=True, universal_newlines=True, encoding='utf8')\n+    if sys.version_info >= (3, 6):\n+        used = check_output(CMD_GREP_ARGS, shell=True, universal_newlines=True, encoding='utf8')\n+        docd = check_output(CMD_GREP_DOCS, shell=True, universal_newlines=True, encoding='utf8')\n+    else:\n+        used = check_output(CMD_GREP_ARGS, shell=True, universal_newlines=True) # encoding='utf8'\n+        docd = check_output(CMD_GREP_DOCS, shell=True, universal_newlines=True) # encoding='utf8'\n \n     args_used = set(re.findall(re.compile(REGEX_ARG), used))\n     args_docd = set(re.findall(re.compile(REGEX_DOC), docd)).union(SET_DOC_OPTIONAL)"
      },
      {
        "sha": "4267f9fa0d8272055f6aa04197575d0baf14d2dc",
        "filename": "test/lint/commit-script-check.sh",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/lint/commit-script-check.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/lint/commit-script-check.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/commit-script-check.sh?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -20,23 +20,23 @@ fi\n RET=0\n PREV_BRANCH=`git name-rev --name-only HEAD`\n PREV_HEAD=`git rev-parse HEAD`\n-for i in `git rev-list --reverse $1`; do\n-    if git rev-list -n 1 --pretty=\"%s\" $i | grep -q \"^scripted-diff:\"; then\n-        git checkout --quiet $i^ || exit\n-        SCRIPT=\"`git rev-list --format=%b -n1 $i | sed '/^-BEGIN VERIFY SCRIPT-$/,/^-END VERIFY SCRIPT-$/{//!b};d'`\"\n+for commit in `git rev-list --reverse $1`; do\n+    if git rev-list -n 1 --pretty=\"%s\" $commit | grep -q \"^scripted-diff:\"; then\n+        git checkout --quiet $commit^ || exit\n+        SCRIPT=\"`git rev-list --format=%b -n1 $commit | sed '/^-BEGIN VERIFY SCRIPT-$/,/^-END VERIFY SCRIPT-$/{//!b};d'`\"\n         if test \"x$SCRIPT\" = \"x\"; then\n-            echo \"Error: missing script for: $i\"\n+            echo \"Error: missing script for: $commit\"\n             echo \"Failed\"\n             RET=1\n         else\n-            echo \"Running script for: $i\"\n+            echo \"Running script for: $commit\"\n             echo \"$SCRIPT\"\n-            eval \"$SCRIPT\"\n-            git --no-pager diff --exit-code $i && echo \"OK\" || (echo \"Failed\"; false) || RET=1\n+            (eval \"$SCRIPT\")\n+            git --no-pager diff --exit-code $commit && echo \"OK\" || (echo \"Failed\"; false) || RET=1\n         fi\n         git reset --quiet --hard HEAD\n      else\n-        if git rev-list \"--format=%b\" -n1 $i | grep -q '^-\\(BEGIN\\|END\\)[ a-zA-Z]*-$'; then\n+        if git rev-list \"--format=%b\" -n1 $commit | grep -q '^-\\(BEGIN\\|END\\)[ a-zA-Z]*-$'; then\n             echo \"Error: script block marker but no scripted-diff in title\"\n             echo \"Failed\"\n             RET=1"
      },
      {
        "sha": "4561b0db307e7f756f6770a7c89425cb065e05e8",
        "filename": "test/lint/lint-python-dead-code.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/lint/lint-python-dead-code.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/lint/lint-python-dead-code.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-python-dead-code.sh?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n #\n # Copyright (c) 2018 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying"
      },
      {
        "sha": "3dbb9fff28e8b43f3164725c5cf260cb3fba732b",
        "filename": "test/lint/lint-python.sh",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/lint/lint-python.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/lint/lint-python.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-python.sh?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -36,6 +36,7 @@ export LC_ALL=C\n # E701 multiple statements on one line (colon)\n # E702 multiple statements on one line (semicolon)\n # E703 statement ends with a semicolon\n+# E711 comparison to None should be 'if cond is None:'\n # E714 test for object identity should be \"is not\"\n # E721 do not compare types, use \"isinstance()\"\n # E741 do not use variables named \"l\", \"O\", or \"I\"\n@@ -87,4 +88,4 @@ elif PYTHONWARNINGS=\"ignore\" flake8 --version | grep -q \"Python 2\"; then\n     exit 0\n fi\n \n-PYTHONWARNINGS=\"ignore\" flake8 --ignore=B,C,E,F,I,N,W --select=E101,E112,E113,E115,E116,E125,E129,E131,E133,E223,E224,E242,E266,E271,E272,E273,E274,E275,E304,E306,E401,E402,E502,E701,E702,E703,E714,E721,E741,E742,E743,E901,E902,F401,F402,F403,F404,F405,F406,F407,F601,F602,F621,F622,F631,F701,F702,F703,F704,F705,F706,F707,F811,F812,F821,F822,F823,F831,F841,W191,W291,W292,W293,W504,W601,W602,W603,W604,W605,W606 \"${@:-.}\"\n+PYTHONWARNINGS=\"ignore\" flake8 --ignore=B,C,E,F,I,N,W --select=E101,E112,E113,E115,E116,E125,E129,E131,E133,E223,E224,E242,E266,E271,E272,E273,E274,E275,E304,E306,E401,E402,E502,E701,E702,E703,E711,E714,E721,E741,E742,E743,E901,E902,F401,F402,F403,F404,F405,F406,F407,F601,F602,F621,F622,F631,F701,F702,F703,F704,F705,F706,F707,F811,F812,F821,F822,F823,F831,F841,W191,W291,W292,W293,W504,W601,W602,W603,W604,W605,W606 \"${@:-.}\""
      },
      {
        "sha": "fda22592d30ff2e8fa52fb3b4d2ba2efccc5a1aa",
        "filename": "test/lint/lint-shebang.sh",
        "status": "renamed",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/lint/lint-shebang.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/lint/lint-shebang.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-shebang.sh?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env bash\n-# Shebang must use python3 (not python or python2)\n+# Assert expected shebang lines\n \n export LC_ALL=C\n EXIT_CODE=0\n@@ -10,4 +10,11 @@ for PYTHON_FILE in $(git ls-files -- \"*.py\"); do\n         EXIT_CODE=1\n     fi\n done\n+for SHELL_FILE in $(git ls-files -- \"*.sh\"); do\n+    if [[ $(head -n 1 \"${SHELL_FILE}\") != \"#!/usr/bin/env bash\" &&\n+          $(head -n 1 \"${SHELL_FILE}\") != \"#!/bin/sh\" ]]; then\n+        echo \"Missing expected shebang \\\"#!/usr/bin/env bash\\\" or \\\"#!/bin/sh\\\" in ${SHELL_FILE}\"\n+        EXIT_CODE=1\n+    fi\n+done\n exit ${EXIT_CODE}",
        "previous_filename": "test/lint/lint-python-shebang.sh"
      },
      {
        "sha": "70eea343633aedfa0a7eb6e415cd38279e929f8f",
        "filename": "test/sanitizer_suppressions/tsan",
        "status": "modified",
        "additions": 3,
        "deletions": 11,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/sanitizer_suppressions/tsan",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/sanitizer_suppressions/tsan",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/sanitizer_suppressions/tsan?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -1,9 +1,6 @@\n # ThreadSanitizer suppressions\n # ============================\n \n-# fChecked is theoretically racy, practically only in unit tests\n-race:CheckBlock\n-\n # WalletBatch (unidentified deadlock)\n deadlock:WalletBatch\n \n@@ -14,11 +11,6 @@ deadlock:TestPotentialDeadLockDetected\n race:src/qt/test/*\n deadlock:src/qt/test/*\n \n-# WIP: Unidentified suppressions to run the functional tests\n-#race:zmqpublishnotifier.cpp\n-#\n-#deadlock:CreateWalletFromFile\n-#deadlock:importprivkey\n-#deadlock:walletdb.h\n-#deadlock:walletdb.cpp\n-#deadlock:wallet/db.cpp\n+# External libraries\n+deadlock:libdb\n+race:libzmq"
      },
      {
        "sha": "7b1cc2b0315fb1d45e1a83a7769f425cc8325dda",
        "filename": "test/util/bitcoin-util-test.py",
        "status": "modified",
        "additions": 1,
        "deletions": 6,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/util/bitcoin-util-test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7/test/util/bitcoin-util-test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/bitcoin-util-test.py?ref=27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "patch": "@@ -9,14 +9,9 @@\n \n Can also be run manually.\"\"\"\n \n-from __future__ import division,print_function,unicode_literals\n-\n import argparse\n import binascii\n-try:\n-    import configparser\n-except ImportError:\n-    import ConfigParser as configparser\n+import configparser\n import difflib\n import json\n import logging"
      }
    ]
  },
  {
    "sha": "89dd88b9643e6cd826ce95c2425453fd2e6ab651",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4OWRkODhiOTY0M2U2Y2Q4MjZjZTk1YzI0MjU0NTNmZDJlNmFiNjUx",
    "commit": {
      "author": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-23T22:14:05Z"
      },
      "committer": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-23T22:14:05Z"
      },
      "message": "Tests for ComputeTimeSmart falsely assumed that time offset is zero",
      "tree": {
        "sha": "116ad40ccd63c4a8756ebdf6a02e89527917ac35",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/116ad40ccd63c4a8756ebdf6a02e89527917ac35"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/89dd88b9643e6cd826ce95c2425453fd2e6ab651",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/89dd88b9643e6cd826ce95c2425453fd2e6ab651",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/89dd88b9643e6cd826ce95c2425453fd2e6ab651",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/89dd88b9643e6cd826ce95c2425453fd2e6ab651/comments",
    "author": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/27cd95e9366bed74078ea9ba3a76cc81a27b8fa7"
      }
    ],
    "stats": {
      "total": 49,
      "additions": 37,
      "deletions": 12
    },
    "files": [
      {
        "sha": "31a89cfef1d52fdfe120502de28813d6a856835b",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 12,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/89dd88b9643e6cd826ce95c2425453fd2e6ab651/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/89dd88b9643e6cd826ce95c2425453fd2e6ab651/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=89dd88b9643e6cd826ce95c2425453fd2e6ab651",
        "patch": "@@ -12,12 +12,13 @@\n \n #include <consensus/validation.h>\n #include <interfaces/chain.h>\n+#include <policy/policy.h>\n #include <rpc/server.h>\n #include <test/test_bitcoin.h>\n+#include <timedata.h>\n #include <validation.h>\n #include <wallet/coincontrol.h>\n #include <wallet/test/wallet_test_fixture.h>\n-#include <policy/policy.h>\n \n #include <boost/test/unit_test.hpp>\n #include <univalue.h>\n@@ -161,7 +162,7 @@ BOOST_FIXTURE_TEST_CASE(importmulti_rescan, TestChain100Setup)\n                       \"by pruning or data corruption (see bitcoind log for details) and could be dealt with by \"\n                       \"downloading and rescanning the relevant blocks (see -reindex and -rescan \"\n                       \"options).\\\"}},{\\\"success\\\":true}]\",\n-                              0, oldTip->GetBlockTimeMax(), TIMESTAMP_WINDOW));\n+                0, oldTip->GetBlockTimeMax(), TIMESTAMP_WINDOW));\n         RemoveWallet(wallet);\n     }\n }\n@@ -255,14 +256,13 @@ BOOST_FIXTURE_TEST_CASE(coin_mark_dirty_immature_credit, TestChain100Setup)\n     // credit amount is calculated.\n     wtx.MarkDirty();\n     wallet.AddKeyPubKey(coinbaseKey, coinbaseKey.GetPubKey());\n-    BOOST_CHECK_EQUAL(wtx.GetImmatureCredit(*locked_chain), 50*COIN);\n+    BOOST_CHECK_EQUAL(wtx.GetImmatureCredit(*locked_chain), 50 * COIN);\n }\n \n-static int64_t AddTx(CWallet& wallet, uint32_t lockTime, int64_t mockTime, int64_t blockTime)\n+static int64_t AddTx(CWallet& wallet, uint32_t lockTime, int64_t blockTime)\n {\n     CMutableTransaction tx;\n     tx.nLockTime = lockTime;\n-    SetMockTime(mockTime);\n     CBlockIndex* block = nullptr;\n     if (blockTime > 0) {\n         auto locked_chain = wallet.chain().lock();\n@@ -286,34 +286,59 @@ static int64_t AddTx(CWallet& wallet, uint32_t lockTime, int64_t mockTime, int64\n     return wallet.mapWallet.at(wtx.GetHash()).nTimeSmart;\n }\n \n+\n // Simple test to verify assignment of CWalletTx::nSmartTime value. Could be\n // expanded to cover more corner cases of smart time logic.\n BOOST_AUTO_TEST_CASE(ComputeTimeSmart)\n {\n+    // The ComputeTimeSmart funciton within the wallet retrieves the time using the GetAdjustedTime function in timedata.\n+    // This function computes the time based on the system time (which can be mocked) and the time offset, which is not necessarily zero.\n+    // Tests have to be executed in order, because the individual cases are stateful\n+\n     // New transaction should use clock time if lower than block time.\n-    BOOST_CHECK_EQUAL(AddTx(m_wallet, 1, 100, 120), 100);\n+    SetMockTime(10);\n+    int64_t clockTime = GetAdjustedTime(); // includes time offset\n+    int64_t blockTime = clockTime + 5;\n+\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 1, blockTime), clockTime); // clocktime used\n \n     // Test that updating existing transaction does not change smart time.\n-    BOOST_CHECK_EQUAL(AddTx(m_wallet, 1, 200, 220), 100);\n+    SetMockTime(20);\n+    int64_t newBlockTime = GetAdjustedTime() + 10;\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 1, newBlockTime), clockTime); // time has not been changed\n+\n \n     // New transaction should use clock time if there's no block time.\n-    BOOST_CHECK_EQUAL(AddTx(m_wallet, 2, 300, 0), 300);\n+    SetMockTime(30);\n+    clockTime = GetAdjustedTime();\n+    blockTime = 0;                                               // block time is not set\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 2, blockTime), clockTime); // clocktime used, because blocktime is unset (zero)\n \n     // New transaction should use block time if lower than clock time.\n-    BOOST_CHECK_EQUAL(AddTx(m_wallet, 3, 420, 400), 400);\n+    SetMockTime(40);\n+    clockTime = GetAdjustedTime();\n+    blockTime = clockTime - 2;\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 3, blockTime), blockTime); // blocktime used\n \n     // New transaction should use latest entry time if higher than\n     // min(block time, clock time).\n-    BOOST_CHECK_EQUAL(AddTx(m_wallet, 4, 500, 390), 400);\n+    SetMockTime(5);\n+    newBlockTime = blockTime - 5;\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 4, newBlockTime), blockTime); // using the blocktime of the previous transaction\n+\n \n     // If there are future entries, new transaction should use time of the\n     // newest entry that is no more than 300 seconds ahead of the clock time.\n-    BOOST_CHECK_EQUAL(AddTx(m_wallet, 5, 50, 600), 300);\n+    SetMockTime(1);\n+    clockTime = GetAdjustedTime();\n+    newBlockTime = clockTime + 1000;                                // this is way too far in the future\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 5, newBlockTime), blockTime); // the newest entry was the last one\n \n     // Reset mock time for other tests.\n     SetMockTime(0);\n }\n \n+\n BOOST_AUTO_TEST_CASE(LoadReceiveRequests)\n {\n     CTxDestination dest = CKeyID();\n@@ -377,7 +402,7 @@ class ListCoinsTestingSetup : public TestChain100Setup\n     }\n \n     std::unique_ptr<interfaces::Chain> m_chain = interfaces::MakeChain();\n-    std::unique_ptr<interfaces::Chain::Lock> m_locked_chain = m_chain->assumeLocked();  // Temporary. Removed in upcoming lock cleanup\n+    std::unique_ptr<interfaces::Chain::Lock> m_locked_chain = m_chain->assumeLocked(); // Temporary. Removed in upcoming lock cleanup\n     std::unique_ptr<CWallet> wallet;\n };\n "
      }
    ]
  },
  {
    "sha": "bf41e77dbb7fd7919a4a670591194f11be7bcd28",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiZjQxZTc3ZGJiN2ZkNzkxOWE0YTY3MDU5MTE5NGYxMWJlN2JjZDI4",
    "commit": {
      "author": {
        "name": "mmachicao",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-25T16:07:54Z"
      },
      "committer": {
        "name": "mmachicao",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-25T16:07:54Z"
      },
      "message": "Initialize sockaddr_in with zero before use. Use sizeof in comparison operators for CNetAddr",
      "tree": {
        "sha": "f064ca0c4a693b4a7b2f8b764454d2a2a3ca3548",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f064ca0c4a693b4a7b2f8b764454d2a2a3ca3548"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bf41e77dbb7fd7919a4a670591194f11be7bcd28",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bf41e77dbb7fd7919a4a670591194f11be7bcd28",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bf41e77dbb7fd7919a4a670591194f11be7bcd28",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bf41e77dbb7fd7919a4a670591194f11be7bcd28/comments",
    "author": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "89dd88b9643e6cd826ce95c2425453fd2e6ab651",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/89dd88b9643e6cd826ce95c2425453fd2e6ab651",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/89dd88b9643e6cd826ce95c2425453fd2e6ab651"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 3,
      "deletions": 2
    },
    "files": [
      {
        "sha": "d14c58adf6f7147267b3a3abd673321eebece5f3",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bf41e77dbb7fd7919a4a670591194f11be7bcd28/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bf41e77dbb7fd7919a4a670591194f11be7bcd28/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=bf41e77dbb7fd7919a4a670591194f11be7bcd28",
        "patch": "@@ -291,12 +291,12 @@ std::string CNetAddr::ToString() const\n \n bool operator==(const CNetAddr& a, const CNetAddr& b)\n {\n-    return (memcmp(a.ip, b.ip, 16) == 0);\n+    return (memcmp(a.ip, b.ip, sizeof(a.ip)) == 0);\n }\n \n bool operator<(const CNetAddr& a, const CNetAddr& b)\n {\n-    return (memcmp(a.ip, b.ip, 16) < 0);\n+    return (memcmp(a.ip, b.ip, sizeof(a.ip)) < 0);\n }\n \n bool CNetAddr::GetInAddr(struct in_addr* pipv4Addr) const"
      },
      {
        "sha": "7b6ad70e6d20881461c6746497be4a39ee04e766",
        "filename": "src/test/timedata_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bf41e77dbb7fd7919a4a670591194f11be7bcd28/src/test/timedata_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bf41e77dbb7fd7919a4a670591194f11be7bcd28/src/test/timedata_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/timedata_tests.cpp?ref=bf41e77dbb7fd7919a4a670591194f11be7bcd28",
        "patch": "@@ -54,6 +54,7 @@ BOOST_AUTO_TEST_CASE(util_MedianFilterShallNotGrowBeyondSize)\n CNetAddr UtilBuildAddress(const std::string& address)\n {\n     struct sockaddr_in sa;\n+    memset(&sa, 0, sizeof(sockaddr_in));\n     inet_pton(AF_INET, address.c_str(), &(sa.sin_addr));\n     CNetAddr addr = CNetAddr(sa.sin_addr);\n     return addr;"
      }
    ]
  },
  {
    "sha": "b6f8f5ae7b166313d089e5d62a387c807e78ec92",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNmY4ZjVhZTdiMTY2MzEzZDA4OWU1ZDYyYTM4N2M4MDdlNzhlYzky",
    "commit": {
      "author": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-25T17:07:40Z"
      },
      "committer": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-25T17:07:40Z"
      },
      "message": "util_AddTimeDataIgnoreSampleWithDuplicateIP is using ip out of range",
      "tree": {
        "sha": "7e8b826abee6920df8746da364c4e1875dd5c35d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7e8b826abee6920df8746da364c4e1875dd5c35d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b6f8f5ae7b166313d089e5d62a387c807e78ec92",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b6f8f5ae7b166313d089e5d62a387c807e78ec92",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b6f8f5ae7b166313d089e5d62a387c807e78ec92",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b6f8f5ae7b166313d089e5d62a387c807e78ec92/comments",
    "author": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bf41e77dbb7fd7919a4a670591194f11be7bcd28",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bf41e77dbb7fd7919a4a670591194f11be7bcd28",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bf41e77dbb7fd7919a4a670591194f11be7bcd28"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 3,
      "deletions": 3
    },
    "files": [
      {
        "sha": "acc3ded589a187135fb1e926f108fd61f6752d31",
        "filename": "src/test/timedata_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6f8f5ae7b166313d089e5d62a387c807e78ec92/src/test/timedata_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6f8f5ae7b166313d089e5d62a387c807e78ec92/src/test/timedata_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/timedata_tests.cpp?ref=b6f8f5ae7b166313d089e5d62a387c807e78ec92",
        "patch": "@@ -119,15 +119,15 @@ BOOST_AUTO_TEST_CASE(util_AddTimeDataDoNotComputeOffsetWhenSampleCountIsEven)\n \n BOOST_AUTO_TEST_CASE(util_AddTimeDataIgnoreSampleWithDuplicateIP)\n {\n-    UtilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.1.\", 300); // precondition 1: at least 5 entries required to compute any offset\n+    UtilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.3.\", 50); // precondition 1: at least 5 entries required to compute any offset\n     BOOST_CHECK(CountOffsetSamples() >= 5);\n \n \n-    AddTimeData(UtilBuildAddress(\"1.1.1.310\"), 310);\n+    AddTimeData(UtilBuildAddress(\"1.1.3.60\"), 60);\n \n     int64_t offset = GetTimeOffset();\n     int samples = CountOffsetSamples();\n-    AddTimeData(UtilBuildAddress(\"1.1.1.310\"), 311);\n+    AddTimeData(UtilBuildAddress(\"1.1.3.60\"), 61);\n \n     BOOST_CHECK_EQUAL(CountOffsetSamples(), samples); // sample was ignored\n     BOOST_CHECK_EQUAL(GetTimeOffset(), offset);       //new offset was not computed"
      }
    ]
  },
  {
    "sha": "51a65850eb7470db7f78d6c73345b14acd32f6e0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1MWE2NTg1MGViNzQ3MGRiN2Y3OGQ2YzczMzQ1YjE0YWNkMzJmNmUw",
    "commit": {
      "author": {
        "name": "mmachicao",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-26T07:51:11Z"
      },
      "committer": {
        "name": "mmachicao",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-26T07:51:11Z"
      },
      "message": "Using memcpy to build sockaddr_in because\n compat.h does not support inet_pton with current #define _WIN32_WINNT 0x0501 and\n #define _WIN32_WINNT 0x0600 has other integration issues",
      "tree": {
        "sha": "de205e73e4f00b6d1df79cbdfcf80b83ede10478",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/de205e73e4f00b6d1df79cbdfcf80b83ede10478"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/51a65850eb7470db7f78d6c73345b14acd32f6e0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/51a65850eb7470db7f78d6c73345b14acd32f6e0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/51a65850eb7470db7f78d6c73345b14acd32f6e0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/51a65850eb7470db7f78d6c73345b14acd32f6e0/comments",
    "author": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b6f8f5ae7b166313d089e5d62a387c807e78ec92",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b6f8f5ae7b166313d089e5d62a387c807e78ec92",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b6f8f5ae7b166313d089e5d62a387c807e78ec92"
      }
    ],
    "stats": {
      "total": 176,
      "additions": 117,
      "deletions": 59
    },
    "files": [
      {
        "sha": "049579c36539fd26baa47a65d6f602d73808ea7e",
        "filename": "src/compat.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/51a65850eb7470db7f78d6c73345b14acd32f6e0/src/compat.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/51a65850eb7470db7f78d6c73345b14acd32f6e0/src/compat.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat.h?ref=51a65850eb7470db7f78d6c73345b14acd32f6e0",
        "patch": "@@ -14,7 +14,7 @@\n #ifdef _WIN32_WINNT\n #undef _WIN32_WINNT\n #endif\n-#define _WIN32_WINNT 0x0600\n+#define _WIN32_WINNT 0x0501\n #ifndef WIN32_LEAN_AND_MEAN\n #define WIN32_LEAN_AND_MEAN 1\n #endif"
      },
      {
        "sha": "8aaad5298cbb983734a383c405925d05bb96f003",
        "filename": "src/test/timedata_tests.cpp",
        "status": "modified",
        "additions": 116,
        "deletions": 58,
        "changes": 174,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/51a65850eb7470db7f78d6c73345b14acd32f6e0/src/test/timedata_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/51a65850eb7470db7f78d6c73345b14acd32f6e0/src/test/timedata_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/timedata_tests.cpp?ref=51a65850eb7470db7f78d6c73345b14acd32f6e0",
        "patch": "@@ -50,45 +50,70 @@ BOOST_AUTO_TEST_CASE(util_MedianFilterShallNotGrowBeyondSize)\n     BOOST_CHECK_EQUAL(filter.sorted()[1], 100);\n }\n \n+/* Utility function to build a CNetAddr object.\n \n-CNetAddr UtilBuildAddress(const std::string& address)\n+   Using memcpy to build sockaddr_in because compat.h does not support inet_pton with current #define _WIN32_WINNT 0x0501\n+*/\n+CNetAddr UtilBuildAddress(unsigned char ip1, unsigned char ip2, unsigned char ip3, unsigned char ip4)\n {\n+    unsigned char ip[] = {ip1, ip2, ip3, ip4};\n+\n     struct sockaddr_in sa;\n-    memset(&sa, 0, sizeof(sockaddr_in));\n-    inet_pton(AF_INET, address.c_str(), &(sa.sin_addr));\n+    memset(&sa, 0, sizeof(sockaddr_in)); // initialize the memory block\n+    memcpy(&(sa.sin_addr), &ip, sizeof(ip));\n     CNetAddr addr = CNetAddr(sa.sin_addr);\n     return addr;\n }\n \n-\n-void UtilPreconditionIsAtLeastFiveEntriesRequired(const std::string& baseip, int basevalue)\n+/* Utility procedure to match the precondition that the AddTimeData procedure requires at least five time samples to compute a new offset */\n+void UtilPreconditionIsAtLeastFiveEntriesRequired(const unsigned char ip1, const unsigned char ip2, const unsigned char ip3, unsigned int baseip4)\n {\n-    for (int i = CountOffsetSamples(); i < 5; i++) { // precondition 1: at least 5 entries required to compute any offset\n-        int val = basevalue + i;\n-        std::stringstream stream;\n-        stream << baseip << val;\n-        std::string ip = stream.str();\n-        AddTimeData(UtilBuildAddress(ip), val);\n+    for (unsigned int i = CountOffsetSamples(); i < 5; i++) { // precondition 1: at least 5 entries required to compute any offset\n+        unsigned int val = baseip4 + i;\n+        assert(val < 257); // we are talking ip addresses here\n+        AddTimeData(UtilBuildAddress(ip1, ip2, ip3, val), val);\n     }\n }\n \n \n+BOOST_AUTO_TEST_CASE(util_UtilBuildAddress)\n+{\n+    CNetAddr cn1 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D2); // 1.1.1.210\n+\n+    CNetAddr cn2 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D2); // 1.1.1.210\n+\n+    bool eq = (cn1 == cn2);\n+\n+    BOOST_CHECK(eq);\n+\n+    CNetAddr cn3 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D3); // 1.1.1.211\n+\n+    bool neq = !(cn1 == cn3);\n+\n+    BOOST_CHECK(neq);\n+\n+    neq = !(cn2 == cn3);\n+\n+    BOOST_CHECK(neq);\n+}\n+\n+\n BOOST_AUTO_TEST_CASE(util_AddTimeDataComputeOffsetWhenSampleCountIsUneven)\n {\n-    UtilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.1.\", 200); // precondition 1: at least 5 entries required to compute any offset\n+    UtilPreconditionIsAtLeastFiveEntriesRequired(0x001, 0x001, 0x001, 200); // precondition 1: at least 5 entries required to compute any offset. start at 1.1.1.200\n     BOOST_CHECK(CountOffsetSamples() >= 5);\n \n \n-    if ((CountOffsetSamples() % 2) == 1) { // precondition 2: start with an even number of samples\n-        AddTimeData(UtilBuildAddress(\"1.1.1.210\"), 210);\n+    if ((CountOffsetSamples() % 2) == 1) {                              // precondition 2: start with an even number of samples\n+        AddTimeData(UtilBuildAddress(0x001, 0x001, 0x001, 0x0D2), 110); // 1.1.1.210 , offsetSample = 110\n     }\n \n     BOOST_CHECK(CountOffsetSamples() % 2 == 0);\n \n \n     int64_t offset = GetTimeOffset();\n     int samples = CountOffsetSamples();\n-    AddTimeData(UtilBuildAddress(\"1.1.1.211\"), 211);\n+    AddTimeData(UtilBuildAddress(0x001, 0x001, 0x001, 0x0D3), 111); // 1.1.1.211 , offsetSample = 111\n \n     BOOST_CHECK_EQUAL(CountOffsetSamples(), samples + 1); // sample was added\n     BOOST_CHECK(GetTimeOffset() != offset);               // and new offset was computed\n@@ -97,20 +122,20 @@ BOOST_AUTO_TEST_CASE(util_AddTimeDataComputeOffsetWhenSampleCountIsUneven)\n \n BOOST_AUTO_TEST_CASE(util_AddTimeDataDoNotComputeOffsetWhenSampleCountIsEven)\n {\n-    UtilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.1.\", 100); // precondition 1: at least 5 entries required to compute any offset\n+    UtilPreconditionIsAtLeastFiveEntriesRequired(0x001, 0x001, 0x001, 100); // precondition 1: at least 5 entries required to compute any offset. start at 1.1.1.100\n \n     BOOST_CHECK(CountOffsetSamples() >= 5);\n \n-    if (CountOffsetSamples() % 2 == 0) { // precondition 2: start with an uneven number of samples\n-        AddTimeData(UtilBuildAddress(\"1.1.1.110\"), 110);\n+    if (CountOffsetSamples() % 2 == 0) {                                // precondition 2: start with an uneven number of samples\n+        AddTimeData(UtilBuildAddress(0x001, 0x001, 0x001, 0x06E), 113); // 1.1.1.110 , offsetSample = 113\n     }\n \n     BOOST_CHECK(CountOffsetSamples() % 2 == 1);\n \n \n     int64_t offset = GetTimeOffset();\n     int samples = CountOffsetSamples();\n-    AddTimeData(UtilBuildAddress(\"1.1.1.111\"), 111);\n+    AddTimeData(UtilBuildAddress(0x001, 0x001, 0x001, 0x06F), 114); // 1.1.1.111 , offsetSample = 114\n \n     BOOST_CHECK_EQUAL(CountOffsetSamples(), samples + 1); // sample was added\n     BOOST_CHECK_EQUAL(GetTimeOffset(), offset);           //new offset was not computed\n@@ -119,18 +144,39 @@ BOOST_AUTO_TEST_CASE(util_AddTimeDataDoNotComputeOffsetWhenSampleCountIsEven)\n \n BOOST_AUTO_TEST_CASE(util_AddTimeDataIgnoreSampleWithDuplicateIP)\n {\n-    UtilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.3.\", 50); // precondition 1: at least 5 entries required to compute any offset\n+    UtilPreconditionIsAtLeastFiveEntriesRequired(0x001, 0x001, 0x001, 50); // precondition 1: at least 5 entries required to compute any offset. start at 1.1.3.50\n     BOOST_CHECK(CountOffsetSamples() >= 5);\n \n+\tif ((CountOffsetSamples() % 2) == 1) {                              // precondition 2: start with an even number of samples\n+        AddTimeData(UtilBuildAddress(0x001, 0x001, 0x001, 0x03A), 58); // 1.1.1.58 , offsetSample = 110\n+    }\n \n-    AddTimeData(UtilBuildAddress(\"1.1.3.60\"), 60);\n-\n-    int64_t offset = GetTimeOffset();\n+\tint64_t offset = GetTimeOffset();\n     int samples = CountOffsetSamples();\n-    AddTimeData(UtilBuildAddress(\"1.1.3.60\"), 61);\n \n-    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples); // sample was ignored\n-    BOOST_CHECK_EQUAL(GetTimeOffset(), offset);       //new offset was not computed\n+\t// add a sample with a given ip\n+    AddTimeData(UtilBuildAddress(0x001, 0x001, 0x001, 0x03C), 60); // 1.1.1.60 , offsetSample = 60\n+    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples + 1); // sample was added\n+\tBOOST_CHECK(GetTimeOffset() != offset); // a new offset was computed\n+\n+\toffset = GetTimeOffset();\n+    samples = CountOffsetSamples();\n+\n+\t// add a new sample to start with an even number of samples because of precondition 2\n+\tAddTimeData(UtilBuildAddress(0x001, 0x001, 0x001, 0x03B), 59); // 1.1.1.59 , offsetSample = 111\n+    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples + 1);          // sample was added\n+    BOOST_CHECK_EQUAL(GetTimeOffset(),offset); // ...but offset was not computed\n+    BOOST_CHECK((CountOffsetSamples() % 2) == 0);                  // need an even number of samples again...\n+\t\n+\n+\toffset = GetTimeOffset();\n+    samples = CountOffsetSamples();\n+    \n+\t// add a sample with a duplicate ip. this shall be ignored completely\n+    AddTimeData(UtilBuildAddress(0x001, 0x001, 0x001, 0x03C), 61); // 1.1.1.60 , offsetSample = 61\n+\n+    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples); // sample was completely ignored\n+    BOOST_CHECK_EQUAL(GetTimeOffset(), offset);       // ...and offset was not computed\n }\n \n \n@@ -142,17 +188,15 @@ BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmMedianIsWithinBounds)\n     CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : 10 , init value: 0\n \n \n-    for (int sample = 1; sample < 4; sample++) { // precondition: 4 samples, all within bounds\n-        std::stringstream stream;\n-        stream << \"1.1.1.\" << sample;\n-        std::string ip = stream.str();\n-        AddTimeDataAlgorithm(UtilBuildAddress(ip), sample, knownSet, offsetFilter, offset);\n+    for (unsigned int sample = 1; sample < 4; sample++) { // precondition: 4 samples, all within bounds\n+        CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, sample);\n+        AddTimeDataAlgorithm(addr, sample, knownSet, offsetFilter, offset); // 1.1.1.[1,2,3],  offsetSample = [1,2,3]\n     }\n \n     BOOST_CHECK_EQUAL(offset, 0);\n     BOOST_CHECK_EQUAL(offsetFilter.size(), 4);\n \n-    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.200\"), 200, knownSet, offsetFilter, offset);\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x0C8), 200, knownSet, offsetFilter, offset); // 1.1.1.200 , offsetSample = 200\n \n     BOOST_CHECK_EQUAL(offset, offsetFilter.median());\n     BOOST_CHECK_EQUAL(offsetFilter.size(), 5);\n@@ -165,27 +209,26 @@ BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmMedianIsOutsideBounds)\n     std::set<CNetAddr> knownSet;\n     CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : limit , init value: 0\n \n-    for (int sample = 1; sample < 4; sample++) { // precondition: 4 samples, all outside bounds\n-        std::stringstream stream;\n-        stream << \"1.1.1.\" << 1 + sample;\n-        std::string ip = stream.str();\n-        AddTimeDataAlgorithm(UtilBuildAddress(ip), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset);\n+    for (int sample = 1; sample < 4; sample++) {                                                     // precondition: 4 samples, all outside bounds\n+        CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, sample);                               // 1.1.1.[1,2,3]\n+        AddTimeDataAlgorithm(addr, 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // offsetSample  = 2 * DEFAULT_MAX_TIME_ADJUSTMENT (out of bounds)\n+\n     } // sorted filter: 0 x x x  -- x is outside the boundaries\n \n     BOOST_CHECK_EQUAL(offset, 0);\n     BOOST_CHECK_EQUAL(offsetFilter.size(), 4);\n \n     // offset is computed only when number of entries is uneven\n-    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.5\"), 1, knownSet, offsetFilter, offset); // sorted filter : 0 1 (x) x x  -- median (x)\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x005), 1, knownSet, offsetFilter, offset); // sorted filter : 0 1 (x) x x  -- median (x)\n     BOOST_CHECK_EQUAL(offset, 0);\n-    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.6\"), 1, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 x x x\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x006), 1, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 x x x\n     BOOST_CHECK_EQUAL(offset, 0);\n-    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.7\"), 1, knownSet, offsetFilter, offset);                               // sorted filter : 0 1 1 (1) x x x x -- median (1)\n-    BOOST_CHECK_EQUAL(offset, 1);                                                                                       // flip to 1\n-    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.8\"), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 1 x x x x x\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x007), 1, knownSet, offsetFilter, offset);                               // sorted filter : 0 1 1 (1) x x x x -- median (1)\n+    BOOST_CHECK_EQUAL(offset, 1);                                                                                                        // flip to 1\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x008), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 1 x x x x x\n     BOOST_CHECK_EQUAL(offset, 1);\n-    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.9\"), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 1 (x) x x x x x -- median (x)\n-    BOOST_CHECK_EQUAL(offset, 0);                                                                                       // flip back to zero\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x009), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 1 (x) x x x x x -- median (x)\n+    BOOST_CHECK_EQUAL(offset, 0);                                                                                                        // flip back to zero\n \n     BOOST_CHECK_EQUAL(offsetFilter.size(), 9);\n }\n@@ -197,43 +240,58 @@ BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmAtLeastFiveSamplesToComputeOffset)\n     std::set<CNetAddr> knownSet;\n     CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : limit , init value: 0\n \n-    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.1\"), 1, knownSet, offsetFilter, offset);\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x001), 1, knownSet, offsetFilter, offset);\n     BOOST_CHECK_EQUAL(offset, 0);\n \n-    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.2\"), 2, knownSet, offsetFilter, offset);\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x002), 2, knownSet, offsetFilter, offset);\n     BOOST_CHECK_EQUAL(offset, 0);\n \n-    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.3\"), 3, knownSet, offsetFilter, offset);\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x003), 3, knownSet, offsetFilter, offset);\n     BOOST_CHECK_EQUAL(offset, 0);\n \n-    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.4\"), 4, knownSet, offsetFilter, offset); // this is the fifth entry\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x004), 4, knownSet, offsetFilter, offset); // this is the fifth entry\n     BOOST_CHECK_EQUAL(offset, 2);\n }\n \n-BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmIgnoresSamplesBeyondInternalLimit)\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmIgnoreSamplesBeyondInternalCapacity)\n {\n-    int limit = 10;\n+    int capacity = 10; // internal capacity\n     int64_t offset = 0;\n     std::set<CNetAddr> knownSet;\n-    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : limit , init value: 0\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : capacity , initial offset: 0\n \n \n-    for (int sample = 1; sample < limit; sample++) { // precondition: limit samples\n-        std::stringstream stream;\n-        stream << \"1.1.1.\" << sample;\n-        std::string ip = stream.str();\n-        AddTimeDataAlgorithm(UtilBuildAddress(ip), sample, knownSet, offsetFilter, offset);\n+    for (int sample = 1; sample < capacity; sample++) { // precondition: fill filter up to the capacity\n+        CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, sample);\n+        AddTimeDataAlgorithm(addr, sample, knownSet, offsetFilter, offset);\n     }\n \n-    BOOST_CHECK_EQUAL(offsetFilter.size(), limit);\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), capacity);\n \n     int64_t pre = offset;\n     int size = offsetFilter.size();\n \n-    AddTimeDataAlgorithm(UtilBuildAddress(\"1.1.1.200\"), 200, knownSet, offsetFilter, offset);\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x0C8), 200, knownSet, offsetFilter, offset); // 1.1.1.200, offsetSample = 200\n \n     BOOST_CHECK_EQUAL(offset, pre);\n     BOOST_CHECK_EQUAL(offsetFilter.size(), size);\n }\n \n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmIgnoreSampleWithDuplicateIp)\n+{\n+    int capacity = 10; // internal capacity\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : capacity , initial offset: 0\n+\n+\tint samples = offsetFilter.size();\n+\n+\tAddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x0C8), 200, knownSet, offsetFilter, offset); // 1.1.1.200, offsetSample = 200\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), samples + 1); // new sample was accepted\n+\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x0C8), 201, knownSet, offsetFilter, offset); // 1.1.1.200, offsetSample = 201\n+\tBOOST_CHECK_EQUAL(offsetFilter.size(), samples + 1); // sample with duplicate ip was ignored\n+}\n+\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "09d9b92274fb1a4fb7cb354bfecffd4a49f56abb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowOWQ5YjkyMjc0ZmIxYTRmYjdjYjM1NGJmZWNmZmQ0YTQ5ZjU2YWJi",
    "commit": {
      "author": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-26T08:11:03Z"
      },
      "committer": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-26T08:11:03Z"
      },
      "message": "applied clang formatter",
      "tree": {
        "sha": "602e47d8c2326fa19f04691332a1a1a12b8a5f4e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/602e47d8c2326fa19f04691332a1a1a12b8a5f4e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/09d9b92274fb1a4fb7cb354bfecffd4a49f56abb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/09d9b92274fb1a4fb7cb354bfecffd4a49f56abb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/09d9b92274fb1a4fb7cb354bfecffd4a49f56abb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/09d9b92274fb1a4fb7cb354bfecffd4a49f56abb/comments",
    "author": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "51a65850eb7470db7f78d6c73345b14acd32f6e0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/51a65850eb7470db7f78d6c73345b14acd32f6e0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/51a65850eb7470db7f78d6c73345b14acd32f6e0"
      }
    ],
    "stats": {
      "total": 85,
      "additions": 43,
      "deletions": 42
    },
    "files": [
      {
        "sha": "bade71e9d73c89e8243c7b2fc0d8fcc6a4b8079e",
        "filename": "src/compat.h",
        "status": "modified",
        "additions": 26,
        "deletions": 25,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/09d9b92274fb1a4fb7cb354bfecffd4a49f56abb/src/compat.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/09d9b92274fb1a4fb7cb354bfecffd4a49f56abb/src/compat.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat.h?ref=09d9b92274fb1a4fb7cb354bfecffd4a49f56abb",
        "patch": "@@ -26,51 +26,51 @@\n #endif\n #define FD_SETSIZE 1024 // max number of fds in fd_set\n \n-#include <winsock2.h>     // Must be included before mswsock.h and windows.h\n+#include <winsock2.h> // Must be included before mswsock.h and windows.h\n \n #include <mswsock.h>\n+#include <stdint.h>\n #include <windows.h>\n #include <ws2tcpip.h>\n-#include <stdint.h>\n #else\n+#include <arpa/inet.h>\n #include <fcntl.h>\n+#include <ifaddrs.h>\n+#include <limits.h>\n+#include <net/if.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\n #include <sys/mman.h>\n #include <sys/select.h>\n #include <sys/socket.h>\n #include <sys/types.h>\n-#include <net/if.h>\n-#include <netinet/in.h>\n-#include <netinet/tcp.h>\n-#include <arpa/inet.h>\n-#include <ifaddrs.h>\n-#include <limits.h>\n-#include <netdb.h>\n #include <unistd.h>\n #endif\n \n #ifndef WIN32\n typedef unsigned int SOCKET;\n #include <errno.h>\n-#define WSAGetLastError()   errno\n-#define WSAEINVAL           EINVAL\n-#define WSAEALREADY         EALREADY\n-#define WSAEWOULDBLOCK      EWOULDBLOCK\n-#define WSAEMSGSIZE         EMSGSIZE\n-#define WSAEINTR            EINTR\n-#define WSAEINPROGRESS      EINPROGRESS\n-#define WSAEADDRINUSE       EADDRINUSE\n-#define WSAENOTSOCK         EBADF\n-#define INVALID_SOCKET      (SOCKET)(~0)\n-#define SOCKET_ERROR        -1\n+#define WSAGetLastError() errno\n+#define WSAEINVAL EINVAL\n+#define WSAEALREADY EALREADY\n+#define WSAEWOULDBLOCK EWOULDBLOCK\n+#define WSAEMSGSIZE EMSGSIZE\n+#define WSAEINTR EINTR\n+#define WSAEINPROGRESS EINPROGRESS\n+#define WSAEADDRINUSE EADDRINUSE\n+#define WSAENOTSOCK EBADF\n+#define INVALID_SOCKET (SOCKET)(~0)\n+#define SOCKET_ERROR -1\n #endif\n \n #ifdef WIN32\n #ifndef S_IRUSR\n-#define S_IRUSR             0400\n-#define S_IWUSR             0200\n+#define S_IRUSR 0400\n+#define S_IWUSR 0200\n #endif\n #else\n-#define MAX_PATH            1024\n+#define MAX_PATH 1024\n #endif\n #ifdef _MSC_VER\n #if !defined(ssize_t)\n@@ -83,7 +83,7 @@ typedef int32_t ssize_t;\n #endif\n \n #if HAVE_DECL_STRNLEN == 0\n-size_t strnlen( const char *start, size_t max_len);\n+size_t strnlen(const char* start, size_t max_len);\n #endif // HAVE_DECL_STRNLEN\n \n #ifndef WIN32\n@@ -92,7 +92,8 @@ typedef void* sockopt_arg_type;\n typedef char* sockopt_arg_type;\n #endif\n \n-bool static inline IsSelectableSocket(const SOCKET& s) {\n+bool static inline IsSelectableSocket(const SOCKET& s)\n+{\n #ifdef WIN32\n     return true;\n #else"
      },
      {
        "sha": "80b93000dbd3e30a1591c53998612ab62c4b474b",
        "filename": "src/test/timedata_tests.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 17,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/09d9b92274fb1a4fb7cb354bfecffd4a49f56abb/src/test/timedata_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/09d9b92274fb1a4fb7cb354bfecffd4a49f56abb/src/test/timedata_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/timedata_tests.cpp?ref=09d9b92274fb1a4fb7cb354bfecffd4a49f56abb",
        "patch": "@@ -147,32 +147,32 @@ BOOST_AUTO_TEST_CASE(util_AddTimeDataIgnoreSampleWithDuplicateIP)\n     UtilPreconditionIsAtLeastFiveEntriesRequired(0x001, 0x001, 0x001, 50); // precondition 1: at least 5 entries required to compute any offset. start at 1.1.3.50\n     BOOST_CHECK(CountOffsetSamples() >= 5);\n \n-\tif ((CountOffsetSamples() % 2) == 1) {                              // precondition 2: start with an even number of samples\n+    if ((CountOffsetSamples() % 2) == 1) {                             // precondition 2: start with an even number of samples\n         AddTimeData(UtilBuildAddress(0x001, 0x001, 0x001, 0x03A), 58); // 1.1.1.58 , offsetSample = 110\n     }\n \n-\tint64_t offset = GetTimeOffset();\n+    int64_t offset = GetTimeOffset();\n     int samples = CountOffsetSamples();\n \n-\t// add a sample with a given ip\n+    // add a sample with a given ip\n     AddTimeData(UtilBuildAddress(0x001, 0x001, 0x001, 0x03C), 60); // 1.1.1.60 , offsetSample = 60\n-    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples + 1); // sample was added\n-\tBOOST_CHECK(GetTimeOffset() != offset); // a new offset was computed\n+    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples + 1);          // sample was added\n+    BOOST_CHECK(GetTimeOffset() != offset);                        // a new offset was computed\n \n-\toffset = GetTimeOffset();\n+    offset = GetTimeOffset();\n     samples = CountOffsetSamples();\n \n-\t// add a new sample to start with an even number of samples because of precondition 2\n-\tAddTimeData(UtilBuildAddress(0x001, 0x001, 0x001, 0x03B), 59); // 1.1.1.59 , offsetSample = 111\n+    // add a new sample to start with an even number of samples because of precondition 2\n+    AddTimeData(UtilBuildAddress(0x001, 0x001, 0x001, 0x03B), 59); // 1.1.1.59 , offsetSample = 111\n     BOOST_CHECK_EQUAL(CountOffsetSamples(), samples + 1);          // sample was added\n-    BOOST_CHECK_EQUAL(GetTimeOffset(),offset); // ...but offset was not computed\n+    BOOST_CHECK_EQUAL(GetTimeOffset(), offset);                    // ...but offset was not computed\n     BOOST_CHECK((CountOffsetSamples() % 2) == 0);                  // need an even number of samples again...\n-\t\n \n-\toffset = GetTimeOffset();\n+\n+    offset = GetTimeOffset();\n     samples = CountOffsetSamples();\n-    \n-\t// add a sample with a duplicate ip. this shall be ignored completely\n+\n+    // add a sample with a duplicate ip. this shall be ignored completely\n     AddTimeData(UtilBuildAddress(0x001, 0x001, 0x001, 0x03C), 61); // 1.1.1.60 , offsetSample = 61\n \n     BOOST_CHECK_EQUAL(CountOffsetSamples(), samples); // sample was completely ignored\n@@ -284,13 +284,13 @@ BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmIgnoreSampleWithDuplicateIp)\n     std::set<CNetAddr> knownSet;\n     CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : capacity , initial offset: 0\n \n-\tint samples = offsetFilter.size();\n+    int samples = offsetFilter.size();\n \n-\tAddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x0C8), 200, knownSet, offsetFilter, offset); // 1.1.1.200, offsetSample = 200\n-    BOOST_CHECK_EQUAL(offsetFilter.size(), samples + 1); // new sample was accepted\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x0C8), 200, knownSet, offsetFilter, offset); // 1.1.1.200, offsetSample = 200\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), samples + 1);                                                     // new sample was accepted\n \n     AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x0C8), 201, knownSet, offsetFilter, offset); // 1.1.1.200, offsetSample = 201\n-\tBOOST_CHECK_EQUAL(offsetFilter.size(), samples + 1); // sample with duplicate ip was ignored\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), samples + 1);                                                     // sample with duplicate ip was ignored\n }\n \n "
      }
    ]
  },
  {
    "sha": "176215f354cb6310f5c209d43cb18e093b748f53",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxNzYyMTVmMzU0Y2I2MzEwZjVjMjA5ZDQzY2IxOGUwOTNiNzQ4ZjUz",
    "commit": {
      "author": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-26T10:12:14Z"
      },
      "committer": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-26T10:12:14Z"
      },
      "message": "Moved statefull tests for AddTimeData to stateless AddTimeDataAlgorithm",
      "tree": {
        "sha": "101c3defd98afef013aaebf2a4f62b9b6dec56c3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/101c3defd98afef013aaebf2a4f62b9b6dec56c3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/176215f354cb6310f5c209d43cb18e093b748f53",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/176215f354cb6310f5c209d43cb18e093b748f53",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/176215f354cb6310f5c209d43cb18e093b748f53",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/176215f354cb6310f5c209d43cb18e093b748f53/comments",
    "author": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "09d9b92274fb1a4fb7cb354bfecffd4a49f56abb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/09d9b92274fb1a4fb7cb354bfecffd4a49f56abb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/09d9b92274fb1a4fb7cb354bfecffd4a49f56abb"
      }
    ],
    "stats": {
      "total": 104,
      "additions": 33,
      "deletions": 71
    },
    "files": [
      {
        "sha": "ed6268d27f8a7b2513ff11ebb1cdd078e7c1394c",
        "filename": "src/test/timedata_tests.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 71,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/176215f354cb6310f5c209d43cb18e093b748f53/src/test/timedata_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/176215f354cb6310f5c209d43cb18e093b748f53/src/test/timedata_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/timedata_tests.cpp?ref=176215f354cb6310f5c209d43cb18e093b748f53",
        "patch": "@@ -65,17 +65,6 @@ CNetAddr UtilBuildAddress(unsigned char ip1, unsigned char ip2, unsigned char ip\n     return addr;\n }\n \n-/* Utility procedure to match the precondition that the AddTimeData procedure requires at least five time samples to compute a new offset */\n-void UtilPreconditionIsAtLeastFiveEntriesRequired(const unsigned char ip1, const unsigned char ip2, const unsigned char ip3, unsigned int baseip4)\n-{\n-    for (unsigned int i = CountOffsetSamples(); i < 5; i++) { // precondition 1: at least 5 entries required to compute any offset\n-        unsigned int val = baseip4 + i;\n-        assert(val < 257); // we are talking ip addresses here\n-        AddTimeData(UtilBuildAddress(ip1, ip2, ip3, val), val);\n-    }\n-}\n-\n-\n BOOST_AUTO_TEST_CASE(util_UtilBuildAddress)\n {\n     CNetAddr cn1 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D2); // 1.1.1.210\n@@ -97,86 +86,59 @@ BOOST_AUTO_TEST_CASE(util_UtilBuildAddress)\n     BOOST_CHECK(neq);\n }\n \n-\n-BOOST_AUTO_TEST_CASE(util_AddTimeDataComputeOffsetWhenSampleCountIsUneven)\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmComputeOffsetWhenNewSampleCountIsGreaterEqualFiveAndUneven)\n {\n-    UtilPreconditionIsAtLeastFiveEntriesRequired(0x001, 0x001, 0x001, 200); // precondition 1: at least 5 entries required to compute any offset. start at 1.1.1.200\n-    BOOST_CHECK(CountOffsetSamples() >= 5);\n+    int limit = 20; //  can store up to 20 samples\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : 20 , init sample: 0\n \n \n-    if ((CountOffsetSamples() % 2) == 1) {                              // precondition 2: start with an even number of samples\n-        AddTimeData(UtilBuildAddress(0x001, 0x001, 0x001, 0x0D2), 110); // 1.1.1.210 , offsetSample = 110\n+    for (unsigned int sample = 1; sample < 10; sample++) { // precondition: at least 4 samples, all within bounds (including the init sample : 0\n+        CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, sample);\n+        AddTimeDataAlgorithm(addr, sample, knownSet, offsetFilter, offset); // 1.1.1.[1,2,3],  offsetSample = [1,2,3]\n     }\n \n-    BOOST_CHECK(CountOffsetSamples() % 2 == 0);\n-\n-\n-    int64_t offset = GetTimeOffset();\n-    int samples = CountOffsetSamples();\n-    AddTimeData(UtilBuildAddress(0x001, 0x001, 0x001, 0x0D3), 111); // 1.1.1.211 , offsetSample = 111\n-\n-    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples + 1); // sample was added\n-    BOOST_CHECK(GetTimeOffset() != offset);               // and new offset was computed\n-}\n-\n+    BOOST_CHECK(offset != 0); // offset has changed from the initial value\n \n-BOOST_AUTO_TEST_CASE(util_AddTimeDataDoNotComputeOffsetWhenSampleCountIsEven)\n-{\n-    UtilPreconditionIsAtLeastFiveEntriesRequired(0x001, 0x001, 0x001, 100); // precondition 1: at least 5 entries required to compute any offset. start at 1.1.1.100\n-\n-    BOOST_CHECK(CountOffsetSamples() >= 5);\n-\n-    if (CountOffsetSamples() % 2 == 0) {                                // precondition 2: start with an uneven number of samples\n-        AddTimeData(UtilBuildAddress(0x001, 0x001, 0x001, 0x06E), 113); // 1.1.1.110 , offsetSample = 113\n-    }\n+    assert(offsetFilter.size() == 10); // next sample will be the 11th (uneven) and will trigger a new computation of the offset\n \n-    BOOST_CHECK(CountOffsetSamples() % 2 == 1);\n \n+    int samples = offsetFilter.size();\n+    int64_t oldOffset = offset;\n+    CNetAddr addr2 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0010);\n+    AddTimeDataAlgorithm(addr2, 111, knownSet, offsetFilter, offset); // 1.1.1.16 , offsetSample = 111\n \n-    int64_t offset = GetTimeOffset();\n-    int samples = CountOffsetSamples();\n-    AddTimeData(UtilBuildAddress(0x001, 0x001, 0x001, 0x06F), 114); // 1.1.1.111 , offsetSample = 114\n-\n-    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples + 1); // sample was added\n-    BOOST_CHECK_EQUAL(GetTimeOffset(), offset);           //new offset was not computed\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), samples + 1); // sample was added...\n+    BOOST_CHECK(oldOffset != offset);                    // ...and new offset was computed\n }\n \n \n-BOOST_AUTO_TEST_CASE(util_AddTimeDataIgnoreSampleWithDuplicateIP)\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmDoNotComputeOffsetWhenNewSampleCountIsGreaterEqualFiveButEven)\n {\n-    UtilPreconditionIsAtLeastFiveEntriesRequired(0x001, 0x001, 0x001, 50); // precondition 1: at least 5 entries required to compute any offset. start at 1.1.3.50\n-    BOOST_CHECK(CountOffsetSamples() >= 5);\n-\n-    if ((CountOffsetSamples() % 2) == 1) {                             // precondition 2: start with an even number of samples\n-        AddTimeData(UtilBuildAddress(0x001, 0x001, 0x001, 0x03A), 58); // 1.1.1.58 , offsetSample = 110\n-    }\n-\n-    int64_t offset = GetTimeOffset();\n-    int samples = CountOffsetSamples();\n+    int limit = 20; //  can store up to 20 samples\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : 20 , init sample: 0\n \n-    // add a sample with a given ip\n-    AddTimeData(UtilBuildAddress(0x001, 0x001, 0x001, 0x03C), 60); // 1.1.1.60 , offsetSample = 60\n-    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples + 1);          // sample was added\n-    BOOST_CHECK(GetTimeOffset() != offset);                        // a new offset was computed\n \n-    offset = GetTimeOffset();\n-    samples = CountOffsetSamples();\n+    for (unsigned int sample = 1; sample < 9; sample++) { // precondition: at least 4 samples, all within bounds (including the init sample : 0\n+        CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, sample);\n+        AddTimeDataAlgorithm(addr, sample, knownSet, offsetFilter, offset); // 1.1.1.[1,2,3],  offsetSample = [1,2,3]\n+    }\n \n-    // add a new sample to start with an even number of samples because of precondition 2\n-    AddTimeData(UtilBuildAddress(0x001, 0x001, 0x001, 0x03B), 59); // 1.1.1.59 , offsetSample = 111\n-    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples + 1);          // sample was added\n-    BOOST_CHECK_EQUAL(GetTimeOffset(), offset);                    // ...but offset was not computed\n-    BOOST_CHECK((CountOffsetSamples() % 2) == 0);                  // need an even number of samples again...\n+    BOOST_CHECK(offset != 0); // offset has changed from the initial value\n \n+    assert(offsetFilter.size() == 9); // next sample will be the 10th (even) and will *not* trigger a new computation of the offset\n \n-    offset = GetTimeOffset();\n-    samples = CountOffsetSamples();\n \n-    // add a sample with a duplicate ip. this shall be ignored completely\n-    AddTimeData(UtilBuildAddress(0x001, 0x001, 0x001, 0x03C), 61); // 1.1.1.60 , offsetSample = 61\n+    int samples = offsetFilter.size();\n+    int64_t oldOffset = offset;\n+    CNetAddr addr2 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0010);\n+    AddTimeDataAlgorithm(addr2, 111, knownSet, offsetFilter, offset); // 1.1.1.16 , offsetSample = 111\n \n-    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples); // sample was completely ignored\n-    BOOST_CHECK_EQUAL(GetTimeOffset(), offset);       // ...and offset was not computed\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), samples + 1); // sample was added...\n+    BOOST_CHECK(oldOffset == offset);                    // ...but new offset was not computed\n }\n \n "
      }
    ]
  },
  {
    "sha": "407e25564670b6c216f3c088965c930642ec85f0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MDdlMjU1NjQ2NzBiNmMyMTZmM2MwODg5NjVjOTMwNjQyZWM4NWYw",
    "commit": {
      "author": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-26T14:24:02Z"
      },
      "committer": {
        "name": "marcaiaf",
        "email": "mmachicao@m19r.de",
        "date": "2018-12-26T14:24:02Z"
      },
      "message": "improve test descriptions",
      "tree": {
        "sha": "2ea9428f5d5cc1ab94c095d336354e61bfc01c29",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2ea9428f5d5cc1ab94c095d336354e61bfc01c29"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/407e25564670b6c216f3c088965c930642ec85f0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/407e25564670b6c216f3c088965c930642ec85f0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/407e25564670b6c216f3c088965c930642ec85f0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/407e25564670b6c216f3c088965c930642ec85f0/comments",
    "author": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mmachicao",
      "id": 1525975,
      "node_id": "MDQ6VXNlcjE1MjU5NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1525975?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mmachicao",
      "html_url": "https://github.com/mmachicao",
      "followers_url": "https://api.github.com/users/mmachicao/followers",
      "following_url": "https://api.github.com/users/mmachicao/following{/other_user}",
      "gists_url": "https://api.github.com/users/mmachicao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mmachicao/subscriptions",
      "organizations_url": "https://api.github.com/users/mmachicao/orgs",
      "repos_url": "https://api.github.com/users/mmachicao/repos",
      "events_url": "https://api.github.com/users/mmachicao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mmachicao/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "176215f354cb6310f5c209d43cb18e093b748f53",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/176215f354cb6310f5c209d43cb18e093b748f53",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/176215f354cb6310f5c209d43cb18e093b748f53"
      }
    ],
    "stats": {
      "total": 30,
      "additions": 15,
      "deletions": 15
    },
    "files": [
      {
        "sha": "6357cd267bdda6e3f14d234a27cad842a4bb4691",
        "filename": "src/test/timedata_tests.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 15,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/407e25564670b6c216f3c088965c930642ec85f0/src/test/timedata_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/407e25564670b6c216f3c088965c930642ec85f0/src/test/timedata_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/timedata_tests.cpp?ref=407e25564670b6c216f3c088965c930642ec85f0",
        "patch": "@@ -88,13 +88,13 @@ BOOST_AUTO_TEST_CASE(util_UtilBuildAddress)\n \n BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmComputeOffsetWhenNewSampleCountIsGreaterEqualFiveAndUneven)\n {\n-    int limit = 20; //  can store up to 20 samples\n+    int capacity = 20; //  can store up to 20 samples\n     int64_t offset = 0;\n     std::set<CNetAddr> knownSet;\n-    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : 20 , init sample: 0\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : 20 , init sample: 0\n \n \n-    for (unsigned int sample = 1; sample < 10; sample++) { // precondition: at least 4 samples, all within bounds (including the init sample : 0\n+    for (unsigned int sample = 1; sample < 10; sample++) { // precondition: at least 4 samples. (including the init sample : 0)\n         CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, sample);\n         AddTimeDataAlgorithm(addr, sample, knownSet, offsetFilter, offset); // 1.1.1.[1,2,3],  offsetSample = [1,2,3]\n     }\n@@ -116,13 +116,13 @@ BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmComputeOffsetWhenNewSampleCountIsG\n \n BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmDoNotComputeOffsetWhenNewSampleCountIsGreaterEqualFiveButEven)\n {\n-    int limit = 20; //  can store up to 20 samples\n+    int capacity = 20; //  can store up to 20 samples\n     int64_t offset = 0;\n     std::set<CNetAddr> knownSet;\n-    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : 20 , init sample: 0\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : 20 , init sample: 0\n \n \n-    for (unsigned int sample = 1; sample < 9; sample++) { // precondition: at least 4 samples, all within bounds (including the init sample : 0\n+    for (unsigned int sample = 1; sample < 9; sample++) { // precondition: at least 7 samples. (including the init sample : 0\n         CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, sample);\n         AddTimeDataAlgorithm(addr, sample, knownSet, offsetFilter, offset); // 1.1.1.[1,2,3],  offsetSample = [1,2,3]\n     }\n@@ -142,15 +142,15 @@ BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmDoNotComputeOffsetWhenNewSampleCou\n }\n \n \n-BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmMedianIsWithinBounds)\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmComputeOffsetWithMedianWithinBounds)\n {\n-    int limit = 10;\n+    int capacity = 10;\n     int64_t offset = 0;\n     std::set<CNetAddr> knownSet;\n-    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : 10 , init value: 0\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : 10 , init samplee: 0\n \n \n-    for (unsigned int sample = 1; sample < 4; sample++) { // precondition: 4 samples, all within bounds\n+    for (unsigned int sample = 1; sample < 4; sample++) { // precondition: 4 samples. (including the init sample : 0)\n         CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, sample);\n         AddTimeDataAlgorithm(addr, sample, knownSet, offsetFilter, offset); // 1.1.1.[1,2,3],  offsetSample = [1,2,3]\n     }\n@@ -164,12 +164,12 @@ BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmMedianIsWithinBounds)\n     BOOST_CHECK_EQUAL(offsetFilter.size(), 5);\n }\n \n-BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmMedianIsOutsideBounds)\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmOffsetFlipsToZeroIfMedianIsOutsideBounds)\n {\n-    int limit = 10;\n+    int capacity = 10;\n     int64_t offset = 0;\n     std::set<CNetAddr> knownSet;\n-    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : limit , init value: 0\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : 10 , init sample: 0\n \n     for (int sample = 1; sample < 4; sample++) {                                                     // precondition: 4 samples, all outside bounds\n         CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, sample);                               // 1.1.1.[1,2,3]\n@@ -197,10 +197,10 @@ BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmMedianIsOutsideBounds)\n \n BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmAtLeastFiveSamplesToComputeOffset)\n {\n-    int limit = 10;\n+    int capacity = 10;\n     int64_t offset = 0;\n     std::set<CNetAddr> knownSet;\n-    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : limit , init value: 0\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : 10 , init sample: 0\n \n     AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x001), 1, knownSet, offsetFilter, offset);\n     BOOST_CHECK_EQUAL(offset, 0);"
      }
    ]
  }
]