[
  {
    "sha": "9805f4af7ecb6becf8a146bd845fb131ffa625c9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ODA1ZjRhZjdlY2I2YmVjZjhhMTQ2YmQ4NDVmYjEzMWZmYTYyNWM5",
    "commit": {
      "author": {
        "name": "Kaz Wesley",
        "email": "keziahw@gmail.com",
        "date": "2016-05-01T04:45:26Z"
      },
      "committer": {
        "name": "Kaz Wesley",
        "email": "keziahw@gmail.com",
        "date": "2016-06-02T19:31:51Z"
      },
      "message": "mapNextTx: use pointer as key, simplify value\n\nSaves about 10% of application memory usage once the mempool warms up. Since the\nmempool is DynamicUsage-regulated, this will translate to a larger mempool in\nthe same amount of space.\n\nMap value type: eliminate the vin index; no users of the map need to know which\ninput of the transaction is spending the prevout.\n\nMap key type: replace the COutPoint with a pointer to a COutPoint. A COutPoint\nis 36 bytes, but each COutPoint is accessible from the same map entry's value.\nA trivial DereferencingComparator functor allows indirect map keys, but the\nresulting syntax is misleading: `map.find(&outpoint)`. Implement an indirectmap\nthat acts as a wrapper to a map that uses a DereferencingComparator, supporting\na syntax that accurately reflect the container's semantics: inserts and\niterators use pointers since they store pointers and need them to remain\nconstant and dereferenceable, but lookup functions take const references.",
      "tree": {
        "sha": "4be823065e49b4bd5bbe50e19b7c1d7a1b4bf929",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4be823065e49b4bd5bbe50e19b7c1d7a1b4bf929"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9805f4af7ecb6becf8a146bd845fb131ffa625c9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9805f4af7ecb6becf8a146bd845fb131ffa625c9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9805f4af7ecb6becf8a146bd845fb131ffa625c9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9805f4af7ecb6becf8a146bd845fb131ffa625c9/comments",
    "author": {
      "login": "kazcw",
      "id": 1047859,
      "node_id": "MDQ6VXNlcjEwNDc4NTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1047859?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kazcw",
      "html_url": "https://github.com/kazcw",
      "followers_url": "https://api.github.com/users/kazcw/followers",
      "following_url": "https://api.github.com/users/kazcw/following{/other_user}",
      "gists_url": "https://api.github.com/users/kazcw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kazcw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kazcw/subscriptions",
      "organizations_url": "https://api.github.com/users/kazcw/orgs",
      "repos_url": "https://api.github.com/users/kazcw/repos",
      "events_url": "https://api.github.com/users/kazcw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kazcw/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kazcw",
      "id": 1047859,
      "node_id": "MDQ6VXNlcjEwNDc4NTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1047859?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kazcw",
      "html_url": "https://github.com/kazcw",
      "followers_url": "https://api.github.com/users/kazcw/followers",
      "following_url": "https://api.github.com/users/kazcw/following{/other_user}",
      "gists_url": "https://api.github.com/users/kazcw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kazcw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kazcw/subscriptions",
      "organizations_url": "https://api.github.com/users/kazcw/orgs",
      "repos_url": "https://api.github.com/users/kazcw/repos",
      "events_url": "https://api.github.com/users/kazcw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kazcw/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "03cf6e86750218f633498210923544f4a6c3c020",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/03cf6e86750218f633498210923544f4a6c3c020",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/03cf6e86750218f633498210923544f4a6c3c020"
      }
    ],
    "stats": {
      "total": 137,
      "additions": 96,
      "deletions": 41
    },
    "files": [
      {
        "sha": "ad61e4f108db4a00214591ed464d65b81b867336",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9805f4af7ecb6becf8a146bd845fb131ffa625c9/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9805f4af7ecb6becf8a146bd845fb131ffa625c9/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=9805f4af7ecb6becf8a146bd845fb131ffa625c9",
        "patch": "@@ -94,6 +94,7 @@ BITCOIN_CORE_H = \\\n   core_memusage.h \\\n   httprpc.h \\\n   httpserver.h \\\n+  indirectmap.h \\\n   init.h \\\n   key.h \\\n   keystore.h \\"
      },
      {
        "sha": "28e1e8deddbde938aa3c73d6bbdaeedf710a95fd",
        "filename": "src/indirectmap.h",
        "status": "added",
        "additions": 52,
        "deletions": 0,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9805f4af7ecb6becf8a146bd845fb131ffa625c9/src/indirectmap.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9805f4af7ecb6becf8a146bd845fb131ffa625c9/src/indirectmap.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/indirectmap.h?ref=9805f4af7ecb6becf8a146bd845fb131ffa625c9",
        "patch": "@@ -0,0 +1,52 @@\n+#ifndef BITCOIN_INDIRECTMAP_H\n+#define BITCOIN_INDIRECTMAP_H\n+\n+template <class T>\n+struct DereferencingComparator { bool operator()(const T a, const T b) const { return *a < *b; } };\n+\n+/* Map whose keys are pointers, but are compared by their dereferenced values.\n+ *\n+ * Differs from a plain std::map<const K*, T, DereferencingComparator<K*> > in\n+ * that methods that take a key for comparison take a K rather than taking a K*\n+ * (taking a K* would be confusing, since it's the value rather than the address\n+ * of the object for comparison that matters due to the dereferencing comparator).\n+ *\n+ * Objects pointed to by keys must not be modified in any way that changes the\n+ * result of DereferencingComparator.\n+ */\n+template <class K, class T>\n+class indirectmap {\n+private:\n+    typedef std::map<const K*, T, DereferencingComparator<const K*> > base;\n+    base m;\n+public:\n+    typedef typename base::iterator iterator;\n+    typedef typename base::const_iterator const_iterator;\n+    typedef typename base::size_type size_type;\n+    typedef typename base::value_type value_type;\n+\n+    // passthrough (pointer interface)\n+    std::pair<iterator, bool> insert(const value_type& value) { return m.insert(value); }\n+\n+    // pass address (value interface)\n+    iterator find(const K& key)                     { return m.find(&key); }\n+    const_iterator find(const K& key) const         { return m.find(&key); }\n+    iterator lower_bound(const K& key)              { return m.lower_bound(&key); }\n+    const_iterator lower_bound(const K& key) const  { return m.lower_bound(&key); }\n+    size_type erase(const K& key)                   { return m.erase(&key); }\n+    size_type count(const K& key) const             { return m.count(&key); }\n+\n+    // passthrough\n+    bool empty() const              { return m.empty(); }\n+    size_type size() const          { return m.size(); }\n+    size_type max_size() const      { return m.max_size(); }\n+    void clear()                    { m.clear(); }\n+    iterator begin()                { return m.begin(); }\n+    iterator end()                  { return m.end(); }\n+    const_iterator begin() const    { return m.begin(); }\n+    const_iterator end() const      { return m.end(); }\n+    const_iterator cbegin() const   { return m.cbegin(); }\n+    const_iterator cend() const     { return m.cend(); }\n+};\n+\n+#endif // BITCOIN_INDIRECTMAP_H"
      },
      {
        "sha": "13da2137e5295bae1c37cb45d87b43a9ab71c08a",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9805f4af7ecb6becf8a146bd845fb131ffa625c9/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9805f4af7ecb6becf8a146bd845fb131ffa625c9/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=9805f4af7ecb6becf8a146bd845fb131ffa625c9",
        "patch": "@@ -1049,9 +1049,10 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n     LOCK(pool.cs); // protect pool.mapNextTx\n     BOOST_FOREACH(const CTxIn &txin, tx.vin)\n     {\n-        if (pool.mapNextTx.count(txin.prevout))\n+        auto itConflicting = pool.mapNextTx.find(txin.prevout);\n+        if (itConflicting != pool.mapNextTx.end())\n         {\n-            const CTransaction *ptxConflicting = pool.mapNextTx[txin.prevout].ptx;\n+            const CTransaction *ptxConflicting = itConflicting->second;\n             if (!setConflicts.count(ptxConflicting->GetHash()))\n             {\n                 // Allow opt-out of transaction replacement by setting"
      },
      {
        "sha": "9c98e5c2cf22eaf029bdf8c336f2312097f5ca72",
        "filename": "src/memusage.h",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9805f4af7ecb6becf8a146bd845fb131ffa625c9/src/memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9805f4af7ecb6becf8a146bd845fb131ffa625c9/src/memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/memusage.h?ref=9805f4af7ecb6becf8a146bd845fb131ffa625c9",
        "patch": "@@ -5,6 +5,8 @@\n #ifndef BITCOIN_MEMUSAGE_H\n #define BITCOIN_MEMUSAGE_H\n \n+#include \"indirectmap.h\"\n+\n #include <stdlib.h>\n \n #include <map>\n@@ -106,6 +108,20 @@ static inline size_t IncrementalDynamicUsage(const std::map<X, Y, Z>& m)\n     return MallocUsage(sizeof(stl_tree_node<std::pair<const X, Y> >));\n }\n \n+// indirectmap has underlying map with pointer as key\n+\n+template<typename X, typename Y>\n+static inline size_t DynamicUsage(const indirectmap<X, Y>& m)\n+{\n+    return MallocUsage(sizeof(stl_tree_node<std::pair<const X*, Y> >)) * m.size();\n+}\n+\n+template<typename X, typename Y>\n+static inline size_t IncrementalDynamicUsage(const indirectmap<X, Y>& m)\n+{\n+    return MallocUsage(sizeof(stl_tree_node<std::pair<const X*, Y> >));\n+}\n+\n // Boost data structures\n \n template<typename X>"
      },
      {
        "sha": "d7fb77661bd47d97f03e0ff112fbae70a818fd3e",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 24,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9805f4af7ecb6becf8a146bd845fb131ffa625c9/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9805f4af7ecb6becf8a146bd845fb131ffa625c9/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=9805f4af7ecb6becf8a146bd845fb131ffa625c9",
        "patch": "@@ -147,11 +147,11 @@ void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<uint256> &vHashes\n         if (it == mapTx.end()) {\n             continue;\n         }\n-        std::map<COutPoint, CInPoint>::iterator iter = mapNextTx.lower_bound(COutPoint(hash, 0));\n+        auto iter = mapNextTx.lower_bound(COutPoint(hash, 0));\n         // First calculate the children, and update setMemPoolChildren to\n         // include them, and update their setMemPoolParents to include this tx.\n-        for (; iter != mapNextTx.end() && iter->first.hash == hash; ++iter) {\n-            const uint256 &childHash = iter->second.ptx->GetHash();\n+        for (; iter != mapNextTx.end() && iter->first->hash == hash; ++iter) {\n+            const uint256 &childHash = iter->second->GetHash();\n             txiter childIter = mapTx.find(childHash);\n             assert(childIter != mapTx.end());\n             // We can skip updating entries we've encountered before or that\n@@ -365,11 +365,11 @@ void CTxMemPool::pruneSpent(const uint256 &hashTx, CCoins &coins)\n {\n     LOCK(cs);\n \n-    std::map<COutPoint, CInPoint>::iterator it = mapNextTx.lower_bound(COutPoint(hashTx, 0));\n+    auto it = mapNextTx.lower_bound(COutPoint(hashTx, 0));\n \n     // iterate over all COutPoints in mapNextTx whose hash equals the provided hashTx\n-    while (it != mapNextTx.end() && it->first.hash == hashTx) {\n-        coins.Spend(it->first.n); // and remove those outputs from coins\n+    while (it != mapNextTx.end() && it->first->hash == hashTx) {\n+        coins.Spend(it->first->n); // and remove those outputs from coins\n         it++;\n     }\n }\n@@ -414,7 +414,7 @@ bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry,\n     const CTransaction& tx = newit->GetTx();\n     std::set<uint256> setParentTransactions;\n     for (unsigned int i = 0; i < tx.vin.size(); i++) {\n-        mapNextTx[tx.vin[i].prevout] = CInPoint(&tx, i);\n+        mapNextTx.insert(std::make_pair(&tx.vin[i].prevout, &tx));\n         setParentTransactions.insert(tx.vin[i].prevout.hash);\n     }\n     // Don't bother worrying about child transactions of this one.\n@@ -500,10 +500,10 @@ void CTxMemPool::removeRecursive(const CTransaction &origTx, std::list<CTransact\n             // happen during chain re-orgs if origTx isn't re-accepted into\n             // the mempool for any reason.\n             for (unsigned int i = 0; i < origTx.vout.size(); i++) {\n-                std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(COutPoint(origTx.GetHash(), i));\n+                auto it = mapNextTx.find(COutPoint(origTx.GetHash(), i));\n                 if (it == mapNextTx.end())\n                     continue;\n-                txiter nextit = mapTx.find(it->second.ptx->GetHash());\n+                txiter nextit = mapTx.find(it->second->GetHash());\n                 assert(nextit != mapTx.end());\n                 txToRemove.insert(nextit);\n             }\n@@ -561,9 +561,9 @@ void CTxMemPool::removeConflicts(const CTransaction &tx, std::list<CTransaction>\n     list<CTransaction> result;\n     LOCK(cs);\n     BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n-        std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(txin.prevout);\n+        auto it = mapNextTx.find(txin.prevout);\n         if (it != mapNextTx.end()) {\n-            const CTransaction &txConflict = *it->second.ptx;\n+            const CTransaction &txConflict = *it->second;\n             if (txConflict != tx)\n             {\n                 removeRecursive(txConflict, removed);\n@@ -671,10 +671,10 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n                 assert(coins && coins->IsAvailable(txin.prevout.n));\n             }\n             // Check whether its inputs are marked in mapNextTx.\n-            std::map<COutPoint, CInPoint>::const_iterator it3 = mapNextTx.find(txin.prevout);\n+            auto it3 = mapNextTx.find(txin.prevout);\n             assert(it3 != mapNextTx.end());\n-            assert(it3->second.ptx == &tx);\n-            assert(it3->second.n == i);\n+            assert(it3->first == &txin.prevout);\n+            assert(it3->second == &tx);\n             i++;\n         }\n         assert(setParentCheck == GetMemPoolParents(it));\n@@ -701,10 +701,10 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n \n         // Check children against mapNextTx\n         CTxMemPool::setEntries setChildrenCheck;\n-        std::map<COutPoint, CInPoint>::const_iterator iter = mapNextTx.lower_bound(COutPoint(it->GetTx().GetHash(), 0));\n+        auto iter = mapNextTx.lower_bound(COutPoint(it->GetTx().GetHash(), 0));\n         int64_t childSizes = 0;\n-        for (; iter != mapNextTx.end() && iter->first.hash == it->GetTx().GetHash(); ++iter) {\n-            txiter childit = mapTx.find(iter->second.ptx->GetHash());\n+        for (; iter != mapNextTx.end() && iter->first->hash == it->GetTx().GetHash(); ++iter) {\n+            txiter childit = mapTx.find(iter->second->GetHash());\n             assert(childit != mapTx.end()); // mapNextTx points to in-mempool transactions\n             if (setChildrenCheck.insert(childit).second) {\n                 childSizes += childit->GetTxSize();\n@@ -738,14 +738,12 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n             stepsSinceLastRemove = 0;\n         }\n     }\n-    for (std::map<COutPoint, CInPoint>::const_iterator it = mapNextTx.begin(); it != mapNextTx.end(); it++) {\n-        uint256 hash = it->second.ptx->GetHash();\n+    for (auto it = mapNextTx.cbegin(); it != mapNextTx.cend(); it++) {\n+        uint256 hash = it->second->GetHash();\n         indexed_transaction_set::const_iterator it2 = mapTx.find(hash);\n         const CTransaction& tx = it2->GetTx();\n         assert(it2 != mapTx.end());\n-        assert(&tx == it->second.ptx);\n-        assert(tx.vin.size() > it->second.n);\n-        assert(it->first == it->second.ptx->vin[it->second.n].prevout);\n+        assert(&tx == it->second);\n     }\n \n     assert(totalTxSize == checkTotal);\n@@ -1044,8 +1042,8 @@ void CTxMemPool::TrimToSize(size_t sizelimit, std::vector<uint256>* pvNoSpendsRe\n                 BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n                     if (exists(txin.prevout.hash))\n                         continue;\n-                    std::map<COutPoint, CInPoint>::iterator it = mapNextTx.lower_bound(COutPoint(txin.prevout.hash, 0));\n-                    if (it == mapNextTx.end() || it->first.hash != txin.prevout.hash)\n+                    auto it = mapNextTx.lower_bound(COutPoint(txin.prevout.hash, 0));\n+                    if (it == mapNextTx.end() || it->first->hash != txin.prevout.hash)\n                         pvNoSpendsRemaining->push_back(txin.prevout.hash);\n                 }\n             }"
      },
      {
        "sha": "7ad5579a066a9e7898cfbbb468341d0389b928c3",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 2,
        "deletions": 15,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9805f4af7ecb6becf8a146bd845fb131ffa625c9/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9805f4af7ecb6becf8a146bd845fb131ffa625c9/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=9805f4af7ecb6becf8a146bd845fb131ffa625c9",
        "patch": "@@ -11,6 +11,7 @@\n \n #include \"amount.h\"\n #include \"coins.h\"\n+#include \"indirectmap.h\"\n #include \"primitives/transaction.h\"\n #include \"sync.h\"\n \n@@ -305,20 +306,6 @@ struct ancestor_score {};\n \n class CBlockPolicyEstimator;\n \n-/** An inpoint - a combination of a transaction and an index n into its vin */\n-class CInPoint\n-{\n-public:\n-    const CTransaction* ptx;\n-    uint32_t n;\n-\n-    CInPoint() { SetNull(); }\n-    CInPoint(const CTransaction* ptxIn, uint32_t nIn) { ptx = ptxIn; n = nIn; }\n-    void SetNull() { ptx = NULL; n = (uint32_t) -1; }\n-    bool IsNull() const { return (ptx == NULL && n == (uint32_t) -1); }\n-    size_t DynamicMemoryUsage() const { return 0; }\n-};\n-\n /**\n  * CTxMemPool stores valid-according-to-the-current-best-chain\n  * transactions that may be included in the next block.\n@@ -477,7 +464,7 @@ class CTxMemPool\n     void UpdateChild(txiter entry, txiter child, bool add);\n \n public:\n-    std::map<COutPoint, CInPoint> mapNextTx;\n+    indirectmap<COutPoint, const CTransaction*> mapNextTx;\n     std::map<uint256, std::pair<double, CAmount> > mapDeltas;\n \n     /** Create a new CTxMemPool."
      }
    ]
  }
]