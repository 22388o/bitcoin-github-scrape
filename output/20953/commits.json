[
  {
    "sha": "4efb6c2d3b41c6badb4d8d5d9370387a91bf7066",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ZWZiNmMyZDNiNDFjNmJhZGI0ZDhkNWQ5MzcwMzg3YTkxYmY3MDY2",
    "commit": {
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2021-01-17T01:44:45Z"
      },
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2021-01-17T11:58:46Z"
      },
      "message": "zmq test: deduplicate test setup code (node restart, topics subscription)",
      "tree": {
        "sha": "6c275b4e3d607b93e0dcc9030ca16f293ccd55b3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6c275b4e3d607b93e0dcc9030ca16f293ccd55b3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4efb6c2d3b41c6badb4d8d5d9370387a91bf7066",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4efb6c2d3b41c6badb4d8d5d9370387a91bf7066",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4efb6c2d3b41c6badb4d8d5d9370387a91bf7066",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4efb6c2d3b41c6badb4d8d5d9370387a91bf7066/comments",
    "author": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "30e664dcce1a9adb9ba9a29e4f0cf809767870dd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/30e664dcce1a9adb9ba9a29e4f0cf809767870dd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/30e664dcce1a9adb9ba9a29e4f0cf809767870dd"
      }
    ],
    "stats": {
      "total": 106,
      "additions": 37,
      "deletions": 69
    },
    "files": [
      {
        "sha": "946bfa51d4d3696aa4c7dc38f38cc8dfd517de99",
        "filename": "test/functional/interface_zmq.py",
        "status": "modified",
        "additions": 37,
        "deletions": 69,
        "changes": 106,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4efb6c2d3b41c6badb4d8d5d9370387a91bf7066/test/functional/interface_zmq.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4efb6c2d3b41c6badb4d8d5d9370387a91bf7066/test/functional/interface_zmq.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_zmq.py?ref=4efb6c2d3b41c6badb4d8d5d9370387a91bf7066",
        "patch": "@@ -80,34 +80,43 @@ def run_test(self):\n             self.log.debug(\"Destroying ZMQ context\")\n             self.ctx.destroy(linger=None)\n \n+    # Restart node with the specified zmq notifications enabled, subscribe to\n+    # all of them and return the corresponding ZMQSubscriber objects.\n+    def setup_zmq_test(self, services, recv_timeout=60, connect_nodes=False):\n+        subscribers = []\n+        for topic, address in services:\n+            socket = self.ctx.socket(zmq.SUB)\n+            socket.set(zmq.RCVTIMEO, recv_timeout*1000)\n+            subscribers.append(ZMQSubscriber(socket, topic.encode()))\n+\n+        self.restart_node(0, [\"-zmqpub%s=%s\" % (topic, address) for topic, address in services])\n+\n+        if connect_nodes:\n+            self.connect_nodes(0, 1)\n+\n+        for i, sub in enumerate(subscribers):\n+            sub.socket.connect(services[i][1])\n+\n+        # Relax so that the subscribers are ready before publishing zmq messages\n+        sleep(0.2)\n+\n+        return subscribers\n+\n     def test_basic(self):\n \n         # Invalid zmq arguments don't take down the node, see #17185.\n         self.restart_node(0, [\"-zmqpubrawtx=foo\", \"-zmqpubhashtx=bar\"])\n \n         address = 'tcp://127.0.0.1:28332'\n-        sockets = []\n-        subs = []\n-        services = [b\"hashblock\", b\"hashtx\", b\"rawblock\", b\"rawtx\"]\n-        for service in services:\n-            sockets.append(self.ctx.socket(zmq.SUB))\n-            sockets[-1].set(zmq.RCVTIMEO, 60000)\n-            subs.append(ZMQSubscriber(sockets[-1], service))\n-\n-        # Subscribe to all available topics.\n+        subs = self.setup_zmq_test(\n+            [(topic, address) for topic in [\"hashblock\", \"hashtx\", \"rawblock\", \"rawtx\"]],\n+            connect_nodes=True)\n+\n         hashblock = subs[0]\n         hashtx = subs[1]\n         rawblock = subs[2]\n         rawtx = subs[3]\n \n-        self.restart_node(0, [\"-zmqpub%s=%s\" % (sub.topic.decode(), address) for sub in [hashblock, hashtx, rawblock, rawtx]])\n-        self.connect_nodes(0, 1)\n-        for socket in sockets:\n-            socket.connect(address)\n-\n-        # Relax so that the subscriber is ready before publishing zmq messages\n-        sleep(0.2)\n-\n         num_blocks = 5\n         self.log.info(\"Generate %(n)d blocks (and %(n)d coinbase txes)\" % {\"n\": num_blocks})\n         genhashes = self.nodes[0].generatetoaddress(num_blocks, ADDRESS_BCRT1_UNSPENDABLE)\n@@ -174,25 +183,10 @@ def test_reorg(self):\n \n         address = 'tcp://127.0.0.1:28333'\n \n-        services = [b\"hashblock\", b\"hashtx\"]\n-        sockets = []\n-        subs = []\n-        for service in services:\n-            sockets.append(self.ctx.socket(zmq.SUB))\n-            # 2 second timeout to check end of notifications\n-            sockets[-1].set(zmq.RCVTIMEO, 2000)\n-            subs.append(ZMQSubscriber(sockets[-1], service))\n-\n-        # Subscribe to all available topics.\n-        hashblock = subs[0]\n-        hashtx = subs[1]\n-\n         # Should only notify the tip if a reorg occurs\n-        self.restart_node(0, [\"-zmqpub%s=%s\" % (sub.topic.decode(), address) for sub in [hashblock, hashtx]])\n-        for socket in sockets:\n-            socket.connect(address)\n-        # Relax so that the subscriber is ready before publishing zmq messages\n-        sleep(0.2)\n+        hashblock, hashtx = self.setup_zmq_test(\n+            [(topic, address) for topic in [\"hashblock\", \"hashtx\"]],\n+            recv_timeout=2)  # 2 second timeout to check end of notifications\n \n         # Generate 1 block in nodes[0] with 1 mempool tx and receive all notifications\n         payment_txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n@@ -240,15 +234,7 @@ def test_sequence(self):\n         <32-byte hash>A<8-byte LE uint> : Transactionhash added mempool\n         \"\"\"\n         self.log.info(\"Testing 'sequence' publisher\")\n-        address = 'tcp://127.0.0.1:28333'\n-        socket = self.ctx.socket(zmq.SUB)\n-        socket.set(zmq.RCVTIMEO, 60000)\n-        seq = ZMQSubscriber(socket, b'sequence')\n-\n-        self.restart_node(0, ['-zmqpub%s=%s' % (seq.topic.decode(), address)])\n-        socket.connect(address)\n-        # Relax so that the subscriber is ready before publishing zmq messages\n-        sleep(0.2)\n+        [seq] = self.setup_zmq_test([(\"sequence\", \"tcp://127.0.0.1:28333\")])\n \n         # Mempool sequence number starts at 1\n         seq_num = 1\n@@ -399,16 +385,7 @@ def test_mempool_sync(self):\n             return\n \n         self.log.info(\"Testing 'mempool sync' usage of sequence notifier\")\n-        address = 'tcp://127.0.0.1:28333'\n-        socket = self.ctx.socket(zmq.SUB)\n-        socket.set(zmq.RCVTIMEO, 60000)\n-        seq = ZMQSubscriber(socket, b'sequence')\n-\n-        self.restart_node(0, ['-zmqpub%s=%s' % (seq.topic.decode(), address)])\n-        self.connect_nodes(0, 1)\n-        socket.connect(address)\n-        # Relax so that the subscriber is ready before publishing zmq messages\n-        sleep(0.2)\n+        [seq] = self.setup_zmq_test([(\"sequence\", \"tcp://127.0.0.1:28333\")], connect_nodes=True)\n \n         # In-memory counter, should always start at 1\n         next_mempool_seq = self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"]\n@@ -508,26 +485,17 @@ def test_mempool_sync(self):\n \n     def test_multiple_interfaces(self):\n         # Set up two subscribers with different addresses\n-        subscribers = []\n-        for i in range(2):\n-            address = 'tcp://127.0.0.1:%d' % (28334 + i)\n-            socket = self.ctx.socket(zmq.SUB)\n-            socket.set(zmq.RCVTIMEO, 60000)\n-            hashblock = ZMQSubscriber(socket, b\"hashblock\")\n-            socket.connect(address)\n-            subscribers.append({'address': address, 'hashblock': hashblock})\n-\n-        self.restart_node(0, ['-zmqpub%s=%s' % (subscriber['hashblock'].topic.decode(), subscriber['address']) for subscriber in subscribers])\n-\n-        # Relax so that the subscriber is ready before publishing zmq messages\n-        sleep(0.2)\n+        subscribers = self.setup_zmq_test([\n+            (\"hashblock\", \"tcp://127.0.0.1:28334\"),\n+            (\"hashblock\", \"tcp://127.0.0.1:28335\"),\n+        ])\n \n         # Generate 1 block in nodes[0] and receive all notifications\n         self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)\n \n         # Should receive the same block hash on both subscribers\n-        assert_equal(self.nodes[0].getbestblockhash(), subscribers[0]['hashblock'].receive().hex())\n-        assert_equal(self.nodes[0].getbestblockhash(), subscribers[1]['hashblock'].receive().hex())\n+        assert_equal(self.nodes[0].getbestblockhash(), subscribers[0].receive().hex())\n+        assert_equal(self.nodes[0].getbestblockhash(), subscribers[1].receive().hex())\n \n if __name__ == '__main__':\n     ZMQTest().main()"
      }
    ]
  }
]