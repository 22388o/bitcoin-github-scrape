[
  {
    "sha": "1b389b0e7e57534a2a4b18a2fead70c24dd69ced",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxYjM4OWIwZTdlNTc1MzRhMmE0YjE4YTJmZWFkNzBjMjRkZDY5Y2Vk",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2017-03-31T19:51:48Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2017-09-05T20:38:56Z"
      },
      "message": "Separate Contextual checks and handling in net_processing.cpp.",
      "tree": {
        "sha": "7b9eaf3e957d8e4f3f59b94243434772ec257cf5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7b9eaf3e957d8e4f3f59b94243434772ec257cf5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1b389b0e7e57534a2a4b18a2fead70c24dd69ced",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1b389b0e7e57534a2a4b18a2fead70c24dd69ced",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1b389b0e7e57534a2a4b18a2fead70c24dd69ced",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1b389b0e7e57534a2a4b18a2fead70c24dd69ced/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ba05971bf4e7b9647002aa39ceb384339995195e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ba05971bf4e7b9647002aa39ceb384339995195e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ba05971bf4e7b9647002aa39ceb384339995195e"
      }
    ],
    "stats": {
      "total": 363,
      "additions": 261,
      "deletions": 102
    },
    "files": [
      {
        "sha": "c8352592c0aa713ccbad02177cfc6843bb3fa0bd",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 261,
        "deletions": 102,
        "changes": 363,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b389b0e7e57534a2a4b18a2fead70c24dd69ced/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b389b0e7e57534a2a4b18a2fead70c24dd69ced/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=1b389b0e7e57534a2a4b18a2fead70c24dd69ced",
        "patch": "@@ -1172,31 +1172,13 @@ inline void static SendBlockTransactions(const CBlock& block, const BlockTransac\n     connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n }\n \n-bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n-{\n-    LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->GetId());\n-    if (gArgs.IsArgSet(\"-dropmessagestest\") && GetRand(gArgs.GetArg(\"-dropmessagestest\", 0)) == 0)\n-    {\n-        LogPrintf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n-        return true;\n-    }\n-\n-\n-    if (!(pfrom->GetLocalServices() & NODE_BLOOM) &&\n-              (strCommand == NetMsgType::FILTERLOAD ||\n-               strCommand == NetMsgType::FILTERADD))\n-    {\n-        if (pfrom->nVersion >= NO_BLOOM_VERSION) {\n-            LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 100);\n-            return false;\n-        } else {\n-            pfrom->fDisconnect = true;\n-            return false;\n-        }\n-    }\n+static bool ContextualProcessMessage(CNode* pfrom, const std::string&\n+        strCommand, CDataStream& vRecv, int64_t nTimeReceived, const\n+        CChainParams& chainparams, CConnman& connman, const std::atomic<bool>&\n+        interruptMsgProc);\n+namespace ProcessMessageHandler {\n \n-    if (strCommand == NetMsgType::REJECT)\n+    static bool ProcessRejectMessage(CNode* pfrom, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n     {\n         if (LogAcceptCategory(BCLog::NET)) {\n             try {\n@@ -1218,19 +1200,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 LogPrint(BCLog::NET, \"Unparseable reject message received\\n\");\n             }\n         }\n+        return true;\n     }\n \n-    else if (strCommand == NetMsgType::VERSION)\n+static bool ProcessVersionMessage(CNode* pfrom, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n     {\n-        // Each connection can only send one version message\n-        if (pfrom->nVersion != 0)\n-        {\n-            connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, std::string(\"Duplicate version message\")));\n-            LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 1);\n-            return false;\n-        }\n-\n+        const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n         int64_t nTime;\n         CAddress addrMe;\n         CAddress addrFrom;\n@@ -1254,7 +1229,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (pfrom->nServicesExpected & ~nServices)\n         {\n             LogPrint(BCLog::NET, \"peer=%d does not offer the expected services (%08x offered, %08x expected); disconnecting\\n\", pfrom->GetId(), nServices, pfrom->nServicesExpected);\n-            connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_NONSTANDARD,\n+            connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, std::string(NetMsgType::VERSION), REJECT_NONSTANDARD,\n                                strprintf(\"Expected to offer services %08x\", pfrom->nServicesExpected)));\n             pfrom->fDisconnect = true;\n             return false;\n@@ -1275,7 +1250,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         {\n             // disconnect from peers older than this proto version\n             LogPrintf(\"peer=%d using obsolete version %i; disconnecting\\n\", pfrom->GetId(), nVersion);\n-            connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_OBSOLETE,\n+            connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, std::string(NetMsgType::VERSION), REJECT_OBSOLETE,\n                                strprintf(\"Version must be %d or greater\", MIN_PEER_PROTO_VERSION)));\n             pfrom->fDisconnect = true;\n             return false;\n@@ -1397,20 +1372,9 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         return true;\n     }\n \n-\n-    else if (pfrom->nVersion == 0)\n-    {\n-        // Must have a version message before anything else\n-        LOCK(cs_main);\n-        Misbehaving(pfrom->GetId(), 1);\n-        return false;\n-    }\n-\n-    // At this point, the outgoing message serialization version can't change.\n-    const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n-\n-    if (strCommand == NetMsgType::VERACK)\n+    static bool ProcessVerackMessage(CNode* pfrom, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n     {\n+        const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n         pfrom->SetRecvVersion(std::min(pfrom->nVersion.load(), PROTOCOL_VERSION));\n \n         if (!pfrom->fInbound) {\n@@ -1440,17 +1404,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n         }\n         pfrom->fSuccessfullyConnected = true;\n+        return true;\n     }\n \n-    else if (!pfrom->fSuccessfullyConnected)\n-    {\n-        // Must have a verack message before anything else\n-        LOCK(cs_main);\n-        Misbehaving(pfrom->GetId(), 1);\n-        return false;\n-    }\n-\n-    else if (strCommand == NetMsgType::ADDR)\n+static bool ProcessAddrMessage(CNode* pfrom, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n     {\n         std::vector<CAddress> vAddr;\n         vRecv >> vAddr;\n@@ -1495,15 +1452,17 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             pfrom->fGetAddr = false;\n         if (pfrom->fOneShot)\n             pfrom->fDisconnect = true;\n+        return true;\n     }\n \n-    else if (strCommand == NetMsgType::SENDHEADERS)\n+    static bool ProcessSendHeadersMessage(CNode* pfrom, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n     {\n         LOCK(cs_main);\n         State(pfrom->GetId())->fPreferHeaders = true;\n+        return true;\n     }\n \n-    else if (strCommand == NetMsgType::SENDCMPCT)\n+    static bool ProcessSendCompactMessage(CNode* pfrom, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n     {\n         bool fAnnounceUsingCMPCTBLOCK = false;\n         uint64_t nCMPCTBLOCKVersion = 0;\n@@ -1524,11 +1483,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     State(pfrom->GetId())->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 1);\n             }\n         }\n+        return true;\n     }\n \n-\n-    else if (strCommand == NetMsgType::INV)\n+    static bool ProcessInvMessage(CNode* pfrom, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n     {\n+        const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n         std::vector<CInv> vInv;\n         vRecv >> vInv;\n         if (vInv.size() > MAX_INV_SZ)\n@@ -1585,10 +1545,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // Track requests for our stuff\n             GetMainSignals().Inventory(inv.hash);\n         }\n+        return true;\n     }\n \n-\n-    else if (strCommand == NetMsgType::GETDATA)\n+    static bool ProcessGetDataMessage(CNode* pfrom, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n     {\n         std::vector<CInv> vInv;\n         vRecv >> vInv;\n@@ -1607,10 +1567,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         pfrom->vRecvGetData.insert(pfrom->vRecvGetData.end(), vInv.begin(), vInv.end());\n         ProcessGetData(pfrom, chainparams.GetConsensus(), connman, interruptMsgProc);\n+        return true;\n     }\n \n-\n-    else if (strCommand == NetMsgType::GETBLOCKS)\n+    static bool ProcessGetBlocksMessage(CNode* pfrom, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n     {\n         CBlockLocator locator;\n         uint256 hashStop;\n@@ -1668,10 +1628,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 break;\n             }\n         }\n+        return true;\n     }\n \n-\n-    else if (strCommand == NetMsgType::GETBLOCKTXN)\n+    static bool ProcessGetBlockTxnMessage(CNode* pfrom, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n     {\n         BlockTransactionsRequest req;\n         vRecv >> req;\n@@ -1718,11 +1678,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         assert(ret);\n \n         SendBlockTransactions(block, req, pfrom, connman);\n+        return true;\n     }\n \n-\n-    else if (strCommand == NetMsgType::GETHEADERS)\n+    static bool ProcessGetHeadersMessage(CNode* pfrom, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n     {\n+        const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n         CBlockLocator locator;\n         uint256 hashStop;\n         vRecv >> locator >> hashStop;\n@@ -1775,11 +1736,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // in the SendMessages logic.\n         nodestate->pindexBestHeaderSent = pindex ? pindex : chainActive.Tip();\n         connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n+        return true;\n     }\n \n-\n-    else if (strCommand == NetMsgType::TX)\n+    static bool ProcessTxMessage(CNode* pfrom, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n     {\n+        const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n         // Stop processing the transaction early if\n         // We are in blocks only mode and peer is either not whitelisted or whitelistrelay is off\n         if (!fRelayTxes && (!pfrom->fWhitelisted || !gArgs.GetBoolArg(\"-whitelistrelay\", DEFAULT_WHITELISTRELAY)))\n@@ -1955,17 +1917,18 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 pfrom->GetId(),\n                 FormatStateMessage(state));\n             if (state.GetRejectCode() > 0 && state.GetRejectCode() < REJECT_INTERNAL) // Never send AcceptToMemoryPool's internal codes over P2P\n-                connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n+                connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::REJECT, std::string(NetMsgType::TX), (unsigned char)state.GetRejectCode(),\n                                    state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), inv.hash));\n             if (nDoS > 0) {\n                 Misbehaving(pfrom->GetId(), nDoS);\n             }\n         }\n+        return true;\n     }\n \n-\n-    else if (strCommand == NetMsgType::CMPCTBLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n+static bool ProcessCompactBlockMessage(CNode* pfrom, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n     {\n+        const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n         CBlockHeaderAndShortTxIDs cmpctblock;\n         vRecv >> cmpctblock;\n \n@@ -2131,10 +2094,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         } // cs_main\n \n         if (fProcessBLOCKTXN)\n-            return ProcessMessage(pfrom, NetMsgType::BLOCKTXN, blockTxnMsg, nTimeReceived, chainparams, connman, interruptMsgProc);\n+            return ContextualProcessMessage(pfrom, NetMsgType::BLOCKTXN, blockTxnMsg, nTimeReceived, chainparams, connman, interruptMsgProc);\n \n         if (fRevertToHeaderProcessing)\n-            return ProcessMessage(pfrom, NetMsgType::HEADERS, vHeadersMsg, nTimeReceived, chainparams, connman, interruptMsgProc);\n+            return ContextualProcessMessage(pfrom, NetMsgType::HEADERS, vHeadersMsg, nTimeReceived, chainparams, connman, interruptMsgProc);\n \n         if (fBlockReconstructed) {\n             // If we got here, we were able to optimistically reconstruct a\n@@ -2160,11 +2123,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 MarkBlockAsReceived(pblock->GetHash());\n             }\n         }\n-\n+        return true;\n     }\n \n-    else if (strCommand == NetMsgType::BLOCKTXN && !fImporting && !fReindex) // Ignore blocks received while importing\n+    static bool ProcessBlockTxnMessage(CNode* pfrom, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n     {\n+        const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n         BlockTransactions resp;\n         vRecv >> resp;\n \n@@ -2232,11 +2196,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 mapBlockSource.erase(pblock->GetHash());\n             }\n         }\n+        return true;\n     }\n \n-\n-    else if (strCommand == NetMsgType::HEADERS && !fImporting && !fReindex) // Ignore headers received while importing\n+    static bool ProcessHeadersMessage(CNode* pfrom, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n     {\n+        const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n         std::vector<CBlockHeader> headers;\n \n         // Bypass the normal CBlock deserialization, as we don't want to risk deserializing 2000 full blocks.\n@@ -2382,9 +2347,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             }\n         }\n         }\n+        return true;\n     }\n \n-    else if (strCommand == NetMsgType::BLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n+    static bool ProcessBlockMessage(CNode* pfrom, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n     {\n         std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();\n         vRecv >> *pblock;\n@@ -2414,10 +2380,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             LOCK(cs_main);\n             mapBlockSource.erase(pblock->GetHash());\n         }\n+        return true;\n     }\n \n-\n-    else if (strCommand == NetMsgType::GETADDR)\n+    static bool ProcessGetAddrMessage(CNode* pfrom, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n     {\n         // This asymmetric behavior for inbound and outbound connections was introduced\n         // to prevent a fingerprinting attack: an attacker can send specific fake addresses\n@@ -2442,10 +2408,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         FastRandomContext insecure_rand;\n         for (const CAddress &addr : vAddr)\n             pfrom->PushAddress(addr, insecure_rand);\n+        return true;\n     }\n \n-\n-    else if (strCommand == NetMsgType::MEMPOOL)\n+    static bool ProcessMempoolMessage(CNode* pfrom, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n     {\n         if (!(pfrom->GetLocalServices() & NODE_BLOOM) && !pfrom->fWhitelisted)\n         {\n@@ -2463,11 +2429,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         LOCK(pfrom->cs_inventory);\n         pfrom->fSendMempool = true;\n+        return true;\n     }\n \n-\n-    else if (strCommand == NetMsgType::PING)\n+    static bool ProcessPingMessage(CNode* pfrom, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n     {\n+        const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n         if (pfrom->nVersion > BIP0031_VERSION)\n         {\n             uint64_t nonce = 0;\n@@ -2485,10 +2452,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // return very quickly.\n             connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::PONG, nonce));\n         }\n+        return true;\n     }\n \n-\n-    else if (strCommand == NetMsgType::PONG)\n+    static bool ProcessPongMessage(CNode* pfrom, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n     {\n         int64_t pingUsecEnd = nTimeReceived;\n         uint64_t nonce = 0;\n@@ -2542,10 +2509,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (bPingFinished) {\n             pfrom->nPingNonceSent = 0;\n         }\n+        return true;\n     }\n \n-\n-    else if (strCommand == NetMsgType::FILTERLOAD)\n+    static bool ProcessFilterLoadMessage(CNode* pfrom, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n     {\n         CBloomFilter filter;\n         vRecv >> filter;\n@@ -2564,10 +2531,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             pfrom->pfilter->UpdateEmptyFull();\n             pfrom->fRelayTxes = true;\n         }\n+        return true;\n     }\n \n-\n-    else if (strCommand == NetMsgType::FILTERADD)\n+    static bool ProcessFilterAddMessage(CNode* pfrom, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n     {\n         std::vector<unsigned char> vData;\n         vRecv >> vData;\n@@ -2589,20 +2556,22 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 100);\n         }\n+        return true;\n     }\n \n-\n-    else if (strCommand == NetMsgType::FILTERCLEAR)\n+    static bool ProcessFilterClearMessage(CNode* pfrom, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n     {\n         LOCK(pfrom->cs_filter);\n         if (pfrom->GetLocalServices() & NODE_BLOOM) {\n             delete pfrom->pfilter;\n             pfrom->pfilter = new CBloomFilter();\n         }\n         pfrom->fRelayTxes = true;\n+        return true;\n     }\n \n-    else if (strCommand == NetMsgType::FEEFILTER) {\n+    static bool ProcessFeeFilterMessage(CNode* pfrom, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n+    {\n         CAmount newFeeFilter = 0;\n         vRecv >> newFeeFilter;\n         if (MoneyRange(newFeeFilter)) {\n@@ -2612,20 +2581,210 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             }\n             LogPrint(BCLog::NET, \"received: feefilter of %s from peer=%d\\n\", CFeeRate(newFeeFilter).ToString(), pfrom->GetId());\n         }\n+        return true;\n     }\n \n-    else if (strCommand == NetMsgType::NOTFOUND) {\n+    static bool ProcessNotFoundMessage(CNode* pfrom, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n+    {\n         // We do not care about the NOTFOUND message, but logging an Unknown Command\n         // message would be undesirable as we transmit it ourselves.\n+        return true;\n     }\n \n-    else {\n-        // Ignore unknown commands for extensibility\n-        LogPrint(BCLog::NET, \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(strCommand), pfrom->GetId());\n+    // Message Indexes do not have to be in order\n+    // For whitelist size correctness INDEX_COUNT must come last\n+    enum whitelist_index : uint64_t {\n+        // Message Tags\n+        VERSION,\n+        VERACK,\n+        ADDR,\n+        INV,\n+        GETDATA,\n+        MERKLEBLOCK,\n+        GETBLOCKS,\n+        GETHEADERS,\n+        TX,\n+        HEADERS,\n+        BLOCK,\n+        GETADDR,\n+        MEMPOOL,\n+        PING,\n+        PONG,\n+        NOTFOUND,\n+        FILTERLOAD,\n+        FILTERADD,\n+        FILTERCLEAR,\n+        REJECT,\n+        SENDHEADERS,\n+        FEEFILTER,\n+        SENDCMPCT,\n+        CMPCTBLOCK,\n+        GETBLOCKTXN,\n+        BLOCKTXN,\n+        // Unknown Index\n+        MSG_TYPE_UNKNOWN,\n+        // Size\n+        INDEX_COUNT,\n+    };\n+\n+    typedef std::function<bool(CNode* pfrom, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)> handler_t;\n+\n+\n+    static const std::map<std::string, std::pair<handler_t, whitelist_index>> handler_registry =\n+    { { NetMsgType::VERSION,     { ProcessVersionMessage,      VERSION     } },\n+    {   NetMsgType::VERACK,      { ProcessVerackMessage,       VERACK      } },\n+    {   NetMsgType::ADDR,        { ProcessAddrMessage,         ADDR        } },\n+    {   NetMsgType::INV,         { ProcessInvMessage,          INV         } },\n+    {   NetMsgType::GETDATA,     { ProcessGetDataMessage,      GETDATA     } },\n+    {   NetMsgType::MERKLEBLOCK, { nullptr,                    MERKLEBLOCK } },\n+    {   NetMsgType::GETBLOCKS,   { ProcessGetBlocksMessage,    GETBLOCKS   } },\n+    {   NetMsgType::GETHEADERS,  { ProcessGetHeadersMessage,   GETHEADERS  } },\n+    {   NetMsgType::TX,          { ProcessTxMessage,           TX          } },\n+    {   NetMsgType::HEADERS,     { ProcessHeadersMessage,      HEADERS     } },\n+    {   NetMsgType::BLOCK,       { ProcessBlockMessage,        BLOCK       } },\n+    {   NetMsgType::GETADDR,     { ProcessGetAddrMessage,      GETADDR     } },\n+    {   NetMsgType::MEMPOOL,     { ProcessMempoolMessage,      MEMPOOL     } },\n+    {   NetMsgType::PING,        { ProcessPingMessage,         PING        } },\n+    {   NetMsgType::PONG,        { ProcessPongMessage,         PONG        } },\n+    {   NetMsgType::NOTFOUND,    { ProcessNotFoundMessage,     NOTFOUND    } },\n+    {   NetMsgType::FILTERLOAD,  { ProcessFilterLoadMessage,   FILTERLOAD  } },\n+    {   NetMsgType::FILTERADD,   { ProcessFilterAddMessage,    FILTERADD   } },\n+    {   NetMsgType::FILTERCLEAR, { ProcessFilterClearMessage,  FILTERCLEAR } },\n+    {   NetMsgType::REJECT,      { ProcessRejectMessage,       REJECT      } },\n+    {   NetMsgType::SENDHEADERS, { ProcessSendHeadersMessage,  SENDHEADERS } },\n+    {   NetMsgType::FEEFILTER,   { ProcessFeeFilterMessage,    FEEFILTER   } },\n+    {   NetMsgType::SENDCMPCT,   { ProcessSendCompactMessage,  SENDCMPCT   } },\n+    {   NetMsgType::CMPCTBLOCK,  { ProcessCompactBlockMessage, CMPCTBLOCK  } },\n+    {   NetMsgType::GETBLOCKTXN, { ProcessGetBlockTxnMessage,  GETBLOCKTXN } },\n+    {   NetMsgType::BLOCKTXN,    { ProcessBlockTxnMessage,     BLOCKTXN    } } };\n+\n+    static const std::pair<handler_t, whitelist_index> failed_lookup {nullptr, MSG_TYPE_UNKNOWN};\n+    const std::pair<handler_t, whitelist_index>& lookup(const std::string& strCommand) {\n+        auto it = handler_registry.find(strCommand);\n+        if (it == handler_registry.end())\n+            return failed_lookup;\n+        return it->second;\n     }\n \n \n \n+    //! Message Processing Whitelists (default init 0)\n+    //! Not const for initialization\n+    static std::array<bool, INDEX_COUNT> KNOWN_MESSAGES {};\n+    static std::array<bool, INDEX_COUNT> WHILE_IMPORT {};\n+    static std::array<bool, INDEX_COUNT> BEFORE_VERACK {};\n+    static std::array<bool, INDEX_COUNT> BEFORE_VERSION {};\n+    static std::array<bool, INDEX_COUNT> AFTER_VERACK {};\n+    static std::array<bool, INDEX_COUNT> NO_REQUIRE_BLOOM {};\n+\n+    bool init_whitelists() {\n+        for (auto x : { VERSION, VERACK, ADDR, INV, GETDATA, MERKLEBLOCK,\n+                        GETBLOCKS, GETHEADERS, TX, HEADERS, BLOCK, GETADDR,\n+                        MEMPOOL, PING, PONG, NOTFOUND, FILTERLOAD, FILTERADD,\n+                        FILTERCLEAR, REJECT, SENDHEADERS, FEEFILTER, SENDCMPCT,\n+                        CMPCTBLOCK, GETBLOCKTXN, BLOCKTXN }) {\n+            KNOWN_MESSAGES[x] = true;\n+        }\n+\n+        for (auto x : { VERSION, REJECT }) {\n+            BEFORE_VERSION[x] = true;\n+        }\n+\n+        WHILE_IMPORT = KNOWN_MESSAGES;\n+        for (auto x : { HEADERS, BLOCK, CMPCTBLOCK, BLOCKTXN }) {\n+            WHILE_IMPORT[x] = false;\n+        }\n+\n+        for (auto x : { VERSION, VERACK, REJECT }) {\n+            BEFORE_VERACK[x] = true;\n+        }\n+\n+        AFTER_VERACK = KNOWN_MESSAGES;\n+        AFTER_VERACK[VERSION] = false;\n+\n+        NO_REQUIRE_BLOOM = KNOWN_MESSAGES;\n+        for (auto x : { FILTERLOAD, FILTERADD }) { // FILTERCLEAR is overloaded to be enabled\n+            NO_REQUIRE_BLOOM[x] = false;\n+        }\n+\n+        return true;\n+    };\n+    static const bool properly_initialized = init_whitelists();\n+\n+};\n+static bool ContextualProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n+{\n+    // Here just to stop unused import warnings\n+    assert(ProcessMessageHandler::properly_initialized);\n+    LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->GetId());\n+    if (gArgs.IsArgSet(\"-dropmessagestest\") && GetRand(gArgs.GetArg(\"-dropmessagestest\", 0)) == 0)\n+    {\n+        LogPrintf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n+        return true;\n+    }\n+    auto handler = ProcessMessageHandler::lookup(strCommand);\n+    uint64_t msg_type = handler.second;\n+\n+    // Global Context\n+    bool importing = fImporting || fReindex;\n+    bool bloom_enabled = (pfrom->GetLocalServices() & NODE_BLOOM);\n+\n+    // Generate whitelists given Global Context\n+\n+    // Not importing, or allowed during import\n+    bool while_import_safe = !importing  || ProcessMessageHandler::WHILE_IMPORT[msg_type];\n+    // Bloom is enabled or message is not a bloom type\n+    bool bloom_disabled_safe =  bloom_enabled || ProcessMessageHandler::NO_REQUIRE_BLOOM[msg_type];\n+\n+\n+    // Connection Specific Context\n+    bool got_verack = pfrom->fSuccessfullyConnected;\n+    bool have_version = pfrom->nVersion != 0;\n+\n+    // Generate whitelists given Connection Specific Context\n+\n+    // Must be a known message\n+    bool message_type_known = ProcessMessageHandler::KNOWN_MESSAGES[msg_type];\n+    // Must get a version or reject before others\n+    bool before_version_ok = have_version || ProcessMessageHandler::BEFORE_VERSION[msg_type];\n+    // We get only one version message\n+    bool only_one_version = !have_version || msg_type != ProcessMessageHandler::VERSION;\n+    // Gotten verack, or allowed before verack\n+    bool before_verack_ok = got_verack || ProcessMessageHandler::BEFORE_VERACK[msg_type];\n+    // Not veracked, or allowed after verack\n+    bool after_verack_ok  = !got_verack  || ProcessMessageHandler::AFTER_VERACK[msg_type];\n+    // Handler was provided\n+    bool handler_provided = !!handler.first;\n+\n+    bool whitelisted =  while_import_safe && bloom_disabled_safe && message_type_known\n+                     && before_verack_ok && after_verack_ok && before_version_ok\n+                     && only_one_version && handler_provided;\n+    // If all whitelist checks pass, safe to call ProcessMessageHandler\n+    if (whitelisted) {\n+        return handler.first(pfrom, vRecv, nTimeReceived, chainparams, connman, interruptMsgProc);\n+    }\n+\n+    // This control flow is a bit messy, because it has identical behavior with\n+    // a prior version. If it doesn't break compatibility, it is safe to refactor\n+    if (!bloom_disabled_safe && pfrom->nVersion < NO_BLOOM_VERSION)\n+    {\n+        pfrom->fDisconnect = true;\n+        return false;\n+    }\n+    if (!only_one_version) {\n+        connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, std::string(\"Duplicate version message\")));\n+    }\n+    bool misbehaving = !before_verack_ok || !before_version_ok || !only_one_version || !bloom_disabled_safe;\n+    if (misbehaving) {\n+        // Must have a verack message before anything else\n+        LOCK(cs_main);\n+        Misbehaving(pfrom->GetId(), 1);\n+        return false;\n+    }\n+    if (!message_type_known) {\n+        // Ignore unknown commands for extensibility\n+        LogPrint(BCLog::NET, \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(strCommand), pfrom->GetId());\n+    }\n     return true;\n }\n \n@@ -2734,7 +2893,7 @@ bool ProcessMessages(CNode* pfrom, CConnman& connman, const std::atomic<bool>& i\n     bool fRet = false;\n     try\n     {\n-        fRet = ProcessMessage(pfrom, strCommand, vRecv, msg.nTime, chainparams, connman, interruptMsgProc);\n+        fRet = ContextualProcessMessage(pfrom, strCommand, vRecv, msg.nTime, chainparams, connman, interruptMsgProc);\n         if (interruptMsgProc)\n             return false;\n         if (!pfrom->vRecvGetData.empty())"
      }
    ]
  }
]