gmaxwell,2017-04-03T22:23:32Z,"I don't get the bitfield stuff here. Why?  It adds a lot of code with indirect effects, and means that we cannot use a perfect hash to set the enum value (e.g. stuck with a map of strings at best, though this code doesn't do that). ",https://github.com/bitcoin/bitcoin/pull/10145#issuecomment-291291673,291291673,
theuni,2017-04-03T22:39:25Z,"@gmaxwell I agree. I asked @JeremyRubin to check my logic in https://github.com/theuni/bitcoin/commit/f1e4e281e3f1eb884f8010ac941c82752174bdbe, and after reviewing, he wanted to take a stab at a more direct mapping for the initial filter.\n\nThis is an interesting approach, but I think this is much less clear than f1e4e281e3f1eb884f8010ac941c82752174bdbe, and it tangles the rules up with the enu",https://github.com/bitcoin/bitcoin/pull/10145#issuecomment-291294719,291294719,
JeremyRubin,2017-04-03T22:41:12Z,"It's actually trivial to make this work very well with a perfect hash and\nthis implementation doesn't add any network dependency on the order. If you\nhave a perfect hash available I could demonstrate :)\n\nThe bitwise stuff is the set of current policies. It's much more explicit\nabout which operations are allowed in which contexts compared to a list of\nconditionals. There might be a bett",https://github.com/bitcoin/bitcoin/pull/10145#issuecomment-291295072,291295072,
gmaxwell,2017-04-03T23:16:55Z,"> If you have a perfect hash available \n\ngperf works in a pinch\n\ncat protocol.cpp | grep '^const char *' | cut -d'""' -f2 | sort | gperf -lCcE\n\n> . It's much more explicit about which operations are allowed in which contexts compared to a list of conditionals.\n\n/Generally/ moving function preconditions far away from their code results in defects. When its something that applies basi",https://github.com/bitcoin/bitcoin/pull/10145#issuecomment-291309935,291309935,
JeremyRubin,2017-04-04T02:12:05Z,"> cat protocol.cpp | grep '^const char *' | cut -d'""' -f2 | sort | gperf -lCcE\n\nAs promised, perfect hashing patch in https://github.com/JeremyRubin/bitcoin/tree/perfect_hashing (a little bit less clean than it could be, because I didn't want to modify protocol.h, but you get the idea). \n\nIt's like 8 lines of code. At initialize you just fill up a translation table to map the perfect hashe",https://github.com/bitcoin/bitcoin/pull/10145#issuecomment-291374007,291374007,
laanwj,2017-04-04T06:27:52Z,"A serious drawback of perfect hashing is that it makes it hard to add message types, especially in PRs or third-party patches. It reduces flexibility.\n\nUnless it can be clearly shown from performance results that matching a small string in e.g. a sorted table or run-time constructed hash is really a performance sink, and given the small number of small messages I would be really surprised (12 ",https://github.com/bitcoin/bitcoin/pull/10145#issuecomment-291405594,291405594,
sipa,2017-04-04T07:07:29Z,I think using a perfect hash is unnecessary overkill here.,https://github.com/bitcoin/bitcoin/pull/10145#issuecomment-291413416,291413416,
JeremyRubin,2017-04-04T21:09:50Z,"Ultimately if we want to check preconditions, it can't hurt to check some general preconditions in ContextualProcessMessage which apply to either the ProcessMessage state machine (e.g., that only one version may be received) or affect more than one handler. Individual handlers that rely on global preconditions should also re-check these global preconditions to harden them against a failure in Cont",https://github.com/bitcoin/bitcoin/pull/10145#issuecomment-291632820,291632820,
jtimon,2017-04-05T16:44:17Z,"I only looked fast at the changes and read the rest of the comments, but this does way more than #9608 , even if #9608 would rebase on top of https://github.com/theuni/bitcoin/commit/f1e4e281e3f1eb884f8010ac941c82752174bdbe (which at a glance look like something good to do before #9608, but I haven't reviewed it deeply because I'm not that familiar with the network code).\n\n#9608 is very easy t",https://github.com/bitcoin/bitcoin/pull/10145#issuecomment-291922420,291922420,
JeremyRubin,2017-09-05T23:34:27Z,rebased to 1b389b0,https://github.com/bitcoin/bitcoin/pull/10145#issuecomment-327332283,327332283,
theuni,2017-09-22T22:25:05Z,"I've thought about this a good bit lately, sorry for the delayed response.\n\nAfter rewriting this about a dozen different ways now, I'm now convinced that the approach in #9608 is the way to go.\n\nA dispatcher with registered functions and a state checker (like you've done here, and like I attempted as well) seems like the obviously correct approach, but once implemented, it's far less strai",https://github.com/bitcoin/bitcoin/pull/10145#issuecomment-331574431,331574431,
JeremyRubin,2017-09-23T00:16:17Z,"> A dumb if/then/else parser seems icky, but I think it's the least likely to cause us issues in the future :(\n\nCan you clarify the kinds of future issues you're worried about? I think something like #9608 is more likely to cause issues. I think verifying correctness of changes to the processing logic is more complicated under #9608. I'd love to understand what other future considerations you'",https://github.com/bitcoin/bitcoin/pull/10145#issuecomment-331587174,331587174,
theuni,2017-09-25T20:26:18Z,"> Can you clarify the kinds of future issues you're worried about? I think something like #9608 is more likely to cause issues. I think verifying correctness of changes to the processing logic is more complicated under #9608. I'd love to understand what other future considerations you're making though.\n\nBecause of all of the pesky interactions with our own state, we can only go so far in layin",https://github.com/bitcoin/bitcoin/pull/10145#issuecomment-332001769,332001769,
MarcoFalke,2018-08-25T16:31:22Z,Closing for now. Let me know when you want to continue working on this,https://github.com/bitcoin/bitcoin/pull/10145#issuecomment-415980891,415980891,
JeremyRubin,2018-09-16T18:43:41Z,"@MarcoFalke my read was that there was not consensus that this approach was welcome.\n\nIf it's worth refreshing, I'd be happy to.",https://github.com/bitcoin/bitcoin/pull/10145#issuecomment-421811184,421811184,
ryanofsky,2017-09-06T17:24:02Z,"Maybe leave this as ProcessMessage instead of renaming to ContextualProcessMessage. ""Contextual"" doesn't seem that elucidating, and the PR could be a little smaller without this change.",https://github.com/bitcoin/bitcoin/pull/10145#discussion_r137334628,137334628,src/net_processing.cpp
ryanofsky,2017-09-06T17:28:06Z,"Style guide probably changed since this PR was written, but currently says to use a snake_case name for a namespace, put the brace on the next line, and not indent the contents. Could maybe name this ""handlers"" instead of ""handler"" too since it is a collection of handlers.",https://github.com/bitcoin/bitcoin/pull/10145#discussion_r137335652,137335652,src/net_processing.cpp
ryanofsky,2017-09-06T17:47:11Z,"You might be able to cut down on the size of the PR by making these handlers classes instead of functions. E.g. you wouldn't need to repeat these pfrom, vRecv, nTimeReceived declarations because they could be members initialized by an inherited constructor. strCommand variables could be static members, so PushMessage calls wouldn't need to change. And you could replace handler_registry table with ",https://github.com/bitcoin/bitcoin/pull/10145#discussion_r137340640,137340640,src/net_processing.cpp
ryanofsky,2017-09-06T17:57:43Z,Maybe add a comment here that this must be last.,https://github.com/bitcoin/bitcoin/pull/10145#discussion_r137343501,137343501,src/net_processing.cpp
ryanofsky,2017-09-06T18:05:10Z,"No good reason not to make these constant, I think. You can assign them values at initialization by returning from a function or lambda.",https://github.com/bitcoin/bitcoin/pull/10145#discussion_r137345472,137345472,src/net_processing.cpp
ryanofsky,2017-09-06T18:36:46Z,Could you initialize this from the registry table instead of listing all the messages again?,https://github.com/bitcoin/bitcoin/pull/10145#discussion_r137354361,137354361,src/net_processing.cpp
ryanofsky,2017-09-06T18:39:26Z,"Would be good to have comments describing what each whitelist does, and maybe the types of messages make sense to have in the whitelist. For example, it's not immediately obvious which messages should go in KNOWN_MESSAGES (all the message types, or only the messages types with handlers).\n\nAlternately could add an overall comment here pointing to the ContextualProcessMessage function for specif",https://github.com/bitcoin/bitcoin/pull/10145#discussion_r137355038,137355038,src/net_processing.cpp
