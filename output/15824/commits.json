[
  {
    "sha": "c7f6ce74d3a5cf2a0c5bac20eab1efd997175a72",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjN2Y2Y2U3NGQzYTVjZjJhMGM1YmFjMjBlYWIxZWZkOTk3MTc1YTcy",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "accounts@carldong.me",
        "date": "2019-04-15T20:10:04Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2019-07-15T18:46:15Z"
      },
      "message": "docs: Improve netbase comments\n\n- Improve and add various Lookup* docs\n- Improve InterruptibleRecv docs\n- Improve Socks5 docs\n- Add CreateSocket docs\n- Add ConnectSocketDirectly docs\n- Add SetNameProxy docs\n- Add ConnectThroughProxy docs\n- Add LookupSubNet docs",
      "tree": {
        "sha": "478ad4776a240ff8e4c1e6ec692690ca453b5381",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/478ad4776a240ff8e4c1e6ec692690ca453b5381"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c7f6ce74d3a5cf2a0c5bac20eab1efd997175a72",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEECc3SW1JEo3Z49u6oDMUhUxl5kaUFAl0syfcACgkQDMUhUxl5\nkaXObg//cuR8sMyJgnYd4RJbyVZnzpv7fKAh2eXoi5mrxnmhdWRFlJEkzdYElYQd\nObZl0GRJQZDbyrJbiHsl51gMd1GkPfWpY5X9brZ2ZAuCkBoXGJy5BcpauuV960J9\neekCWbUCeVNuDddhytO9xJkfmU0WueCYs5czGEHj+osP0gyXKwNwgAvGR2+y6wU8\n1reUXQCLKTAWc4tLjhQcvLfnLHSZ1wu8RCDZtxE/OBU/WLsQgaKxiOHC3vUNhQU8\nOgEfE0zCThvCWkp7p2X0PFurOqWTbDT9TI/LeGRzk9nhVWoAwCYpdcZugxoF38pS\nNjkw+sG2JIpTnjtBlERF82Yq6lcJpfoAWhJh/TF58CfL0mJD1/1WiY/XGWMYqpnj\nROVot06u+fdLDFbrhlY/5ZMWr3lwhFQASPC04ri9aemT3EAj6+7DHDez4c3OgACh\nh+iKlNF85lTra9+yEuF9bXhpjZKxCV7/iRk4s5zeZKg4RfNBK50tAMBcv66UuZMj\nT/a6arfulWiYYL2MMCX6fJiUD/O0BCEOZulfUYJtoq06gCKSawO++Q50kTiuARDC\n85INPS51ZKRfbLVO2Nhf9zn1hr4DgkJDMJoEB3KZidmszix3BBvbGaU1TEAOSioQ\nT9uxVZshrHSBp0DfmwMg4rom7KhyLCOu0qXXTFkyJuXcLrPqmaY=\n=8CJ1\n-----END PGP SIGNATURE-----",
        "payload": "tree 478ad4776a240ff8e4c1e6ec692690ca453b5381\nparent 0822b44d8a68a3f29b12719523f6cb5253eb679c\nauthor Carl Dong <accounts@carldong.me> 1555359004 -0400\ncommitter Carl Dong <contact@carldong.me> 1563216375 -0400\n\ndocs: Improve netbase comments\n\n- Improve and add various Lookup* docs\n- Improve InterruptibleRecv docs\n- Improve Socks5 docs\n- Add CreateSocket docs\n- Add ConnectSocketDirectly docs\n- Add SetNameProxy docs\n- Add ConnectThroughProxy docs\n- Add LookupSubNet docs\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c7f6ce74d3a5cf2a0c5bac20eab1efd997175a72",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c7f6ce74d3a5cf2a0c5bac20eab1efd997175a72",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c7f6ce74d3a5cf2a0c5bac20eab1efd997175a72/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0822b44d8a68a3f29b12719523f6cb5253eb679c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0822b44d8a68a3f29b12719523f6cb5253eb679c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0822b44d8a68a3f29b12719523f6cb5253eb679c"
      }
    ],
    "stats": {
      "total": 222,
      "additions": 202,
      "deletions": 20
    },
    "files": [
      {
        "sha": "53e5985a0f120abdedadf641645db7ccdc303f71",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 202,
        "deletions": 20,
        "changes": 222,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c7f6ce74d3a5cf2a0c5bac20eab1efd997175a72/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c7f6ce74d3a5cf2a0c5bac20eab1efd997175a72/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=c7f6ce74d3a5cf2a0c5bac20eab1efd997175a72",
        "patch": "@@ -65,6 +65,12 @@ bool static LookupIntern(const char *pszName, std::vector<CNetAddr>& vIP, unsign\n \n     {\n         CNetAddr addr;\n+        // From our perspective, onion addresses are not hostnames but rather\n+        // direct encodings of CNetAddr much like IPv4 dotted-decimal notation\n+        // or IPv6 colon-separated hextet notation. Since we can't use\n+        // getaddrinfo to decode them and it wouldn't make sense to resolve\n+        // them, we return a network address representing it instead. See\n+        // CNetAddr::SetSpecial(const std::string&) for more details.\n         if (addr.SetSpecial(std::string(pszName))) {\n             vIP.push_back(addr);\n             return true;\n@@ -74,15 +80,25 @@ bool static LookupIntern(const char *pszName, std::vector<CNetAddr>& vIP, unsign\n     struct addrinfo aiHint;\n     memset(&aiHint, 0, sizeof(struct addrinfo));\n \n+    // We want a TCP port, which is a streaming socket type\n     aiHint.ai_socktype = SOCK_STREAM;\n     aiHint.ai_protocol = IPPROTO_TCP;\n+    // We don't care which address family (IPv4 or IPv6) is returned\n     aiHint.ai_family = AF_UNSPEC;\n+    // If we allow lookups of hostnames, use the AI_ADDRCONFIG flag to only\n+    // return addresses whose family we have an address configured for.\n+    //\n+    // If we don't allow lookups, then use the AI_NUMERICHOST flag for\n+    // getaddrinfo to only decode numerical network addresses and suppress\n+    // hostname lookups.\n     aiHint.ai_flags = fAllowLookup ? AI_ADDRCONFIG : AI_NUMERICHOST;\n     struct addrinfo *aiRes = nullptr;\n     int nErr = getaddrinfo(pszName, nullptr, &aiHint, &aiRes);\n     if (nErr)\n         return false;\n \n+    // Traverse the linked list starting with aiTrav, add all non-internal\n+    // IPv4,v6 addresses to vIP while respecting nMaxSolutions.\n     struct addrinfo *aiTrav = aiRes;\n     while (aiTrav != nullptr && (nMaxSolutions == 0 || vIP.size() < nMaxSolutions))\n     {\n@@ -112,6 +128,21 @@ bool static LookupIntern(const char *pszName, std::vector<CNetAddr>& vIP, unsign\n     return (vIP.size() > 0);\n }\n \n+/**\n+ * Resolve a host string to its corresponding network addresses.\n+ *\n+ * @param pszName The string representing a host. Could be a name or a numerical\n+ *                IP address (IPv6 addresses in their bracketed form are\n+ *                allowed).\n+ * @param[out] vIP The resulting network addresses to which the specified host\n+ *                 string resolved.\n+ *\n+ * @returns Whether or not the specified host string successfully resolved to\n+ *          any resulting network addresses.\n+ *\n+ * @see Lookup(const char *, std::vector<CService>&, int, bool, unsigned int)\n+ *      for additional parameter descriptions.\n+ */\n bool LookupHost(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n {\n     std::string strHost(pszName);\n@@ -124,6 +155,12 @@ bool LookupHost(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nM\n     return LookupIntern(strHost.c_str(), vIP, nMaxSolutions, fAllowLookup);\n }\n \n+ /**\n+ * Resolve a host string to its first corresponding network address.\n+ *\n+ * @see LookupHost(const char *, std::vector<CNetAddr>&, unsigned int, bool) for\n+ *      additional parameter descriptions.\n+ */\n bool LookupHost(const char *pszName, CNetAddr& addr, bool fAllowLookup)\n {\n     std::vector<CNetAddr> vIP;\n@@ -134,6 +171,26 @@ bool LookupHost(const char *pszName, CNetAddr& addr, bool fAllowLookup)\n     return true;\n }\n \n+/**\n+ * Resolve a service string to its corresponding service.\n+ *\n+ * @param pszName The string representing a service. Could be a name or a\n+ *                numerical IP address (IPv6 addresses should be in their\n+ *                disambiguated bracketed form), optionally followed by a port\n+ *                number. (e.g. example.com:8333 or\n+ *                [2001:db8:85a3:8d3:1319:8a2e:370:7348]:420)\n+ * @param[out] vAddr The resulting services to which the specified service string\n+ *                   resolved.\n+ * @param portDefault The default port for resulting services if not specified\n+ *                    by the service string.\n+ * @param fAllowLookup Whether or not hostname lookups are permitted. If yes,\n+ *                     external queries may be performed.\n+ * @param nMaxSolutions The maximum number of results we want, specifying 0\n+ *                      means \"as many solutions as we get.\"\n+ *\n+ * @returns Whether or not the service string successfully resolved to any\n+ *          resulting services.\n+ */\n bool Lookup(const char *pszName, std::vector<CService>& vAddr, int portDefault, bool fAllowLookup, unsigned int nMaxSolutions)\n {\n     if (pszName[0] == 0)\n@@ -152,6 +209,12 @@ bool Lookup(const char *pszName, std::vector<CService>& vAddr, int portDefault,\n     return true;\n }\n \n+/**\n+ * Resolve a service string to its first corresponding service.\n+ *\n+ * @see Lookup(const char *, std::vector<CService>&, int, bool, unsigned int)\n+ *      for additional parameter descriptions.\n+ */\n bool Lookup(const char *pszName, CService& addr, int portDefault, bool fAllowLookup)\n {\n     std::vector<CService> vService;\n@@ -162,6 +225,16 @@ bool Lookup(const char *pszName, CService& addr, int portDefault, bool fAllowLoo\n     return true;\n }\n \n+/**\n+ * Resolve a service string with a numeric IP to its first corresponding\n+ * service.\n+ *\n+ * @returns The resulting CService if the resolution was successful, [::]:0\n+ *          otherwise.\n+ *\n+ * @see Lookup(const char *, CService&, int, bool) for additional parameter\n+ *      descriptions.\n+ */\n CService LookupNumeric(const char *pszName, int portDefault)\n {\n     CService addr;\n@@ -231,22 +304,29 @@ enum class IntrRecvError {\n };\n \n /**\n- * Read bytes from socket. This will either read the full number of bytes requested\n- * or return False on error or timeout.\n- * This function can be interrupted by calling InterruptSocks5()\n+ * Try to read a specified number of bytes from a socket. Please read the \"see\n+ * also\" section for more detail.\n  *\n- * @param data Buffer to receive into\n- * @param len  Length of data to receive\n- * @param timeout  Timeout in milliseconds for receive operation\n+ * @param data The buffer where the read bytes should be stored.\n+ * @param len The number of bytes to read into the specified buffer.\n+ * @param timeout The total timeout in milliseconds for this read.\n+ * @param hSocket The socket (has to be in non-blocking mode) from which to read\n+ *                bytes.\n  *\n- * @note This function requires that hSocket is in non-blocking mode.\n+ * @returns An IntrRecvError indicating the resulting status of this read.\n+ *          IntrRecvError::OK only if all of the specified number of bytes were\n+ *          read.\n+ *\n+ * @see This function can be interrupted by calling InterruptSocks5(bool).\n+ *      Sockets can be made non-blocking with SetSocketNonBlocking(const\n+ *      SOCKET&, bool).\n  */\n static IntrRecvError InterruptibleRecv(uint8_t* data, size_t len, int timeout, const SOCKET& hSocket)\n {\n     int64_t curTime = GetTimeMillis();\n     int64_t endTime = curTime + timeout;\n-    // Maximum time to wait in one select call. It will take up until this time (in millis)\n-    // to break off in case of an interruption.\n+    // Maximum time to wait for I/O readiness. It will take up until this time\n+    // (in millis) to break off in case of an interruption.\n     const int64_t maxWait = 1000;\n     while (len > 0 && curTime < endTime) {\n         ssize_t ret = recv(hSocket, (char*)data, len, 0); // Optimistically try the recv first\n@@ -261,6 +341,8 @@ static IntrRecvError InterruptibleRecv(uint8_t* data, size_t len, int timeout, c\n                 if (!IsSelectableSocket(hSocket)) {\n                     return IntrRecvError::NetworkError;\n                 }\n+                // Only wait at most maxWait milliseconds at a time, unless\n+                // we're approaching the end of the specified total timeout\n                 int timeout_ms = std::min(endTime - curTime, maxWait);\n #ifdef USE_POLL\n                 struct pollfd pollfd = {};\n@@ -320,23 +402,40 @@ static std::string Socks5ErrorString(uint8_t err)\n     }\n }\n \n-/** Connect using SOCKS5 (as described in RFC1928) */\n+/**\n+ * Connect to a specified destination service through an already connected\n+ * SOCKS5 proxy.\n+ *\n+ * @param strDest The destination fully-qualified domain name.\n+ * @param port The destination port.\n+ * @param auth The credentials with which to authenticate with the specified\n+ *             SOCKS5 proxy.\n+ * @param hSocket The SOCKS5 proxy socket.\n+ *\n+ * @returns Whether or not the operation succeeded.\n+ *\n+ * @note The specified SOCKS5 proxy socket must already be connected to the\n+ *       SOCKS5 proxy.\n+ *\n+ * @see <a href=\"https://www.ietf.org/rfc/rfc1928.txt\">RFC1928: SOCKS Protocol\n+ *      Version 5</a>\n+ */\n static bool Socks5(const std::string& strDest, int port, const ProxyCredentials *auth, const SOCKET& hSocket)\n {\n     IntrRecvError recvr;\n     LogPrint(BCLog::NET, \"SOCKS5 connecting %s\\n\", strDest);\n     if (strDest.size() > 255) {\n         return error(\"Hostname too long\");\n     }\n-    // Accepted authentication methods\n+    // Construct the version identifier/method selection message\n     std::vector<uint8_t> vSocks5Init;\n-    vSocks5Init.push_back(SOCKSVersion::SOCKS5);\n+    vSocks5Init.push_back(SOCKSVersion::SOCKS5); // We want the SOCK5 protocol\n     if (auth) {\n-        vSocks5Init.push_back(0x02); // Number of methods\n+        vSocks5Init.push_back(0x02); // 2 method identifiers follow...\n         vSocks5Init.push_back(SOCKS5Method::NOAUTH);\n         vSocks5Init.push_back(SOCKS5Method::USER_PASS);\n     } else {\n-        vSocks5Init.push_back(0x01); // Number of methods\n+        vSocks5Init.push_back(0x01); // 1 method identifier follows...\n         vSocks5Init.push_back(SOCKS5Method::NOAUTH);\n     }\n     ssize_t ret = send(hSocket, (const char*)vSocks5Init.data(), vSocks5Init.size(), MSG_NOSIGNAL);\n@@ -440,19 +539,30 @@ static bool Socks5(const std::string& strDest, int port, const ProxyCredentials\n     return true;\n }\n \n+/**\n+ * Try to create a socket file descriptor with specific properties in the\n+ * communications domain (address family) of the specified service.\n+ *\n+ * For details on the desired properties, see the inline comments in the source\n+ * code.\n+ */\n SOCKET CreateSocket(const CService &addrConnect)\n {\n+    // Create a sockaddr from the specified service.\n     struct sockaddr_storage sockaddr;\n     socklen_t len = sizeof(sockaddr);\n     if (!addrConnect.GetSockAddr((struct sockaddr*)&sockaddr, &len)) {\n         LogPrintf(\"Cannot create socket for %s: unsupported network\\n\", addrConnect.ToString());\n         return INVALID_SOCKET;\n     }\n \n+    // Create a TCP socket in the address family of the specified service.\n     SOCKET hSocket = socket(((struct sockaddr*)&sockaddr)->sa_family, SOCK_STREAM, IPPROTO_TCP);\n     if (hSocket == INVALID_SOCKET)\n         return INVALID_SOCKET;\n \n+    // Ensure that waiting for I/O on this socket won't result in undefined\n+    // behavior.\n     if (!IsSelectableSocket(hSocket)) {\n         CloseSocket(hSocket);\n         LogPrintf(\"Cannot create connection: non-selectable socket created (fd >= FD_SETSIZE ?)\\n\");\n@@ -461,17 +571,18 @@ SOCKET CreateSocket(const CService &addrConnect)\n \n #ifdef SO_NOSIGPIPE\n     int set = 1;\n-    // Different way of disabling SIGPIPE on BSD\n+    // Set the no-sigpipe option on the socket for BSD systems, other UNIXes\n+    // should use the MSG_NOSIGNAL flag for every send.\n     setsockopt(hSocket, SOL_SOCKET, SO_NOSIGPIPE, (void*)&set, sizeof(int));\n #endif\n \n-    //Disable Nagle's algorithm\n+    // Set the no-delay option (disable Nagle's algorithm) on the TCP socket.\n     SetSocketNoDelay(hSocket);\n \n-    // Set to non-blocking\n+    // Set the non-blocking option on the socket.\n     if (!SetSocketNonBlocking(hSocket, true)) {\n         CloseSocket(hSocket);\n-        LogPrintf(\"ConnectSocketDirectly: Setting socket to non-blocking failed, error %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        LogPrintf(\"CreateSocket: Setting socket to non-blocking failed, error %s\\n\", NetworkErrorString(WSAGetLastError()));\n     }\n     return hSocket;\n }\n@@ -486,8 +597,21 @@ static void LogConnectFailure(bool manual_connection, const char* fmt, const Arg\n     }\n }\n \n+/**\n+ * Try to connect to the specified service on the specified socket.\n+ *\n+ * @param addrConnect The service to which to connect.\n+ * @param hSocket The socket on which to connect.\n+ * @param nTimeout Wait this many milliseconds for the connection to be\n+ *                 established.\n+ * @param manual_connection Whether or not the connection was manually requested\n+ *                          (e.g. thru the addnode RPC)\n+ *\n+ * @returns Whether or not a connection was successfully made.\n+ */\n bool ConnectSocketDirectly(const CService &addrConnect, const SOCKET& hSocket, int nTimeout, bool manual_connection)\n {\n+    // Create a sockaddr from the specified service.\n     struct sockaddr_storage sockaddr;\n     socklen_t len = sizeof(sockaddr);\n     if (hSocket == INVALID_SOCKET) {\n@@ -498,12 +622,17 @@ bool ConnectSocketDirectly(const CService &addrConnect, const SOCKET& hSocket, i\n         LogPrintf(\"Cannot connect to %s: unsupported network\\n\", addrConnect.ToString());\n         return false;\n     }\n+\n+    // Connect to the addrConnect service on the hSocket socket.\n     if (connect(hSocket, (struct sockaddr*)&sockaddr, len) == SOCKET_ERROR)\n     {\n         int nErr = WSAGetLastError();\n         // WSAEINVAL is here because some legacy version of winsock uses it\n         if (nErr == WSAEINPROGRESS || nErr == WSAEWOULDBLOCK || nErr == WSAEINVAL)\n         {\n+            // Connection didn't actually fail, but is being established\n+            // asynchronously. Thus, use async I/O api (select/poll)\n+            // synchronously to check for successful connection with a timeout.\n #ifdef USE_POLL\n             struct pollfd pollfd = {};\n             pollfd.fd = hSocket;\n@@ -516,6 +645,10 @@ bool ConnectSocketDirectly(const CService &addrConnect, const SOCKET& hSocket, i\n             FD_SET(hSocket, &fdset);\n             int nRet = select(hSocket + 1, nullptr, &fdset, nullptr, &timeout);\n #endif\n+            // Upon successful completion, both select and poll return the total\n+            // number of file descriptors that have been selected. A value of 0\n+            // indicates that the call timed out and no file descriptors have\n+            // been selected.\n             if (nRet == 0)\n             {\n                 LogPrint(BCLog::NET, \"connection to %s timeout\\n\", addrConnect.ToString());\n@@ -526,6 +659,11 @@ bool ConnectSocketDirectly(const CService &addrConnect, const SOCKET& hSocket, i\n                 LogPrintf(\"select() for %s failed: %s\\n\", addrConnect.ToString(), NetworkErrorString(WSAGetLastError()));\n                 return false;\n             }\n+\n+            // Even if the select/poll was successful, the connect might not\n+            // have been successful. The reason for this failure is hidden away\n+            // in the SO_ERROR for the socket in modern systems. We read it into\n+            // nRet here.\n             socklen_t nRetSize = sizeof(nRet);\n             if (getsockopt(hSocket, SOL_SOCKET, SO_ERROR, (sockopt_arg_type)&nRet, &nRetSize) == SOCKET_ERROR)\n             {\n@@ -569,6 +707,22 @@ bool GetProxy(enum Network net, proxyType &proxyInfoOut) {\n     return true;\n }\n \n+/**\n+ * Set the name proxy to use for all connections to nodes specified by a\n+ * hostname. After setting this proxy, connecting to a node sepcified by a\n+ * hostname won't result in a local lookup of said hostname, rather, connect to\n+ * the node by asking the name proxy for a proxy connection to the hostname,\n+ * effectively delegating the hostname lookup to the specified proxy.\n+ *\n+ * This delegation increases privacy for those who set the name proxy as they no\n+ * longer leak their external hostname queries to their DNS servers.\n+ *\n+ * @returns Whether or not the operation succeeded.\n+ *\n+ * @note SOCKS5's support for UDP-over-SOCKS5 has been considered, but no SOCK5\n+ *       server in common use (most notably Tor) actually implements UDP\n+ *       support, and a DNS resolver is beyond the scope of this project.\n+ */\n bool SetNameProxy(const proxyType &addrProxy) {\n     if (!addrProxy.IsValid())\n         return false;\n@@ -599,6 +753,21 @@ bool IsProxy(const CNetAddr &addr) {\n     return false;\n }\n \n+/**\n+ * Connect to a specified destination service through a SOCKS5 proxy by first\n+ * connecting to the SOCKS5 proxy.\n+ *\n+ * @param proxy The SOCKS5 proxy.\n+ * @param strDest The destination service to which to connect.\n+ * @param port The destination port.\n+ * @param hSocket The socket on which to connect to the SOCKS5 proxy.\n+ * @param nTimeout Wait this many milliseconds for the connection to the SOCKS5\n+ *                 proxy to be established.\n+ * @param outProxyConnectionFailed[out] Whether or not the connection to the\n+ *                                      SOCKS5 proxy failed.\n+ *\n+ * @returns Whether or not the operation succeeded.\n+ */\n bool ConnectThroughProxy(const proxyType &proxy, const std::string& strDest, int port, const SOCKET& hSocket, int nTimeout, bool *outProxyConnectionFailed)\n {\n     // first connect to proxy server\n@@ -623,22 +792,35 @@ bool ConnectThroughProxy(const proxyType &proxy, const std::string& strDest, int\n     return true;\n }\n \n+/**\n+ * Parse and resolve a specified subnet string into the appropriate internal\n+ * representation.\n+ *\n+ * @param pszName A string representation of a subnet of the form `network\n+ *                address [ \"/\", ( CIDR-style suffix | netmask ) ]`(e.g.\n+ *                `2001:db8::/32`, `192.0.2.0/255.255.255.0`, or `8.8.8.8`).\n+ * @param ret The resulting internal representation of a subnet.\n+ *\n+ * @returns Whether the operation succeeded or not.\n+ */\n bool LookupSubNet(const char* pszName, CSubNet& ret)\n {\n     std::string strSubnet(pszName);\n     size_t slash = strSubnet.find_last_of('/');\n     std::vector<CNetAddr> vIP;\n \n     std::string strAddress = strSubnet.substr(0, slash);\n+    // TODO: Use LookupHost(const char *, CNetAddr&, bool) instead to just get\n+    //       one CNetAddr.\n     if (LookupHost(strAddress.c_str(), vIP, 1, false))\n     {\n         CNetAddr network = vIP[0];\n         if (slash != strSubnet.npos)\n         {\n             std::string strNetmask = strSubnet.substr(slash + 1);\n             int32_t n;\n-            // IPv4 addresses start at offset 12, and first 12 bytes must match, so just offset n\n-            if (ParseInt32(strNetmask, &n)) { // If valid number, assume /24 syntax\n+            if (ParseInt32(strNetmask, &n)) {\n+                // If valid number, assume CIDR variable-length subnet masking\n                 ret = CSubNet(network, n);\n                 return ret.IsValid();\n             }"
      }
    ]
  }
]