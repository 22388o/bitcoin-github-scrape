[
  {
    "sha": "f7c7f8ecf3a2fbfdf1b24bbcacd23f9d21737d40",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmN2M3ZjhlY2YzYTJmYmZkZjFiMjRiYmNhY2QyM2Y5ZDIxNzM3ZDQw",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-06-13T15:56:20Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-06-29T19:32:52Z"
      },
      "message": "[tests] p2p_segwit: Fix flake8 warnings.",
      "tree": {
        "sha": "31a33a1e4cae3cea4d298972a8a0b5f585ff5575",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/31a33a1e4cae3cea4d298972a8a0b5f585ff5575"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f7c7f8ecf3a2fbfdf1b24bbcacd23f9d21737d40",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f7c7f8ecf3a2fbfdf1b24bbcacd23f9d21737d40",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f7c7f8ecf3a2fbfdf1b24bbcacd23f9d21737d40",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f7c7f8ecf3a2fbfdf1b24bbcacd23f9d21737d40/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a6ed99a1e6facd38913711106bce6fb65bd14862",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a6ed99a1e6facd38913711106bce6fb65bd14862",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a6ed99a1e6facd38913711106bce6fb65bd14862"
      }
    ],
    "stats": {
      "total": 518,
      "additions": 283,
      "deletions": 235
    },
    "files": [
      {
        "sha": "4ac0f44a6b2d5b39ff29be75ff2e893ec9024341",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 283,
        "deletions": 235,
        "changes": 518,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f7c7f8ecf3a2fbfdf1b24bbcacd23f9d21737d40/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f7c7f8ecf3a2fbfdf1b24bbcacd23f9d21737d40/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=f7c7f8ecf3a2fbfdf1b24bbcacd23f9d21737d40",
        "patch": "@@ -3,17 +3,84 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test segwit transactions and blocks on P2P network.\"\"\"\n+from binascii import hexlify\n+import math\n+import random\n+import struct\n+import time\n \n-from test_framework.mininode import *\n-from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import *\n-from test_framework.script import *\n from test_framework.blocktools import create_block, create_coinbase, add_witness_commitment, get_witness_script, WITNESS_COMMITMENT_HEADER\n from test_framework.key import CECKey, CPubKey\n-import math\n-import time\n-import random\n-from binascii import hexlify\n+from test_framework.messages import (\n+    BIP125_SEQUENCE_NUMBER,\n+    CBlock,\n+    CBlockHeader,\n+    CInv,\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    CTxWitness,\n+    MAX_BLOCK_BASE_SIZE,\n+    MSG_WITNESS_FLAG,\n+    NODE_NETWORK,\n+    NODE_WITNESS,\n+    msg_block,\n+    msg_getdata,\n+    msg_headers,\n+    msg_inv,\n+    msg_tx,\n+    msg_witness_block,\n+    msg_witness_tx,\n+    ser_uint256,\n+    ser_vector,\n+    sha256,\n+    uint256_from_str,\n+)\n+from test_framework.mininode import (\n+    P2PInterface,\n+    mininode_lock,\n+    network_thread_start,\n+)\n+from test_framework.script import (\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    OP_0,\n+    OP_1,\n+    OP_16,\n+    OP_2DROP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKSIG,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_RETURN,\n+    OP_TRUE,\n+    SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SegwitVersion1SignatureHash,\n+    SignatureHash,\n+    hash160,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    bytes_to_hex_str,\n+    connect_nodes,\n+    get_bip9_status,\n+    hex_str_to_bytes,\n+    sync_blocks,\n+    sync_mempools,\n+)\n \n # The versionbit bit used to signal activation of SegWit\n VB_WITNESS_BIT = 1\n@@ -29,7 +96,7 @@ def get_virtual_size(witness_block):\n     base_size = len(witness_block.serialize(with_witness=False))\n     total_size = len(witness_block.serialize(with_witness=True))\n     # the \"+3\" is so we round up\n-    vsize = int((3*base_size + total_size + 3)/4)\n+    vsize = int((3 * base_size + total_size + 3) / 4)\n     return vsize\n \n def test_transaction_acceptance(rpc, p2p, tx, with_witness, accepted, reason=None):\n@@ -43,7 +110,7 @@ def test_transaction_acceptance(rpc, p2p, tx, with_witness, accepted, reason=Non\n     p2p.send_message(tx_message)\n     p2p.sync_with_ping()\n     assert_equal(tx.hash in rpc.getrawmempool(), accepted)\n-    if (reason != None and not accepted):\n+    if (reason is not None and not accepted):\n         # Check the rejection reason as well.\n         with mininode_lock:\n             assert_equal(p2p.last_message[\"reject\"].reason, reason)\n@@ -59,7 +126,7 @@ def test_witness_block(rpc, p2p, block, accepted, with_witness=True, reason=None\n         p2p.send_message(msg_block(block))\n     p2p.sync_with_ping()\n     assert_equal(rpc.getbestblockhash() == block.hash, accepted)\n-    if (reason != None and not accepted):\n+    if (reason is not None and not accepted):\n         # Check the rejection reason as well.\n         with mininode_lock:\n             assert_equal(p2p.last_message[\"reject\"].reason, reason)\n@@ -88,7 +155,7 @@ def announce_block_and_wait_for_getdata(self, block, use_header, timeout=60):\n             self.last_message.pop(\"getdata\", None)\n             self.last_message.pop(\"getheaders\", None)\n         msg = msg_headers()\n-        msg.headers = [ CBlockHeader(block) ]\n+        msg.headers = [CBlockHeader(block)]\n         if use_header:\n             self.send_message(msg)\n         else:\n@@ -106,21 +173,21 @@ def request_block(self, blockhash, inv_type, timeout=60):\n \n # Used to keep track of anyone-can-spend outputs that we can use in the tests\n class UTXO():\n-    def __init__(self, sha256, n, nValue):\n+    def __init__(self, sha256, n, value):\n         self.sha256 = sha256\n         self.n = n\n-        self.nValue = nValue\n+        self.nValue = value\n \n # Helper for getting the script associated with a P2PKH\n-def GetP2PKHScript(pubkeyhash):\n+def get_p2pkh_script(pubkeyhash):\n     return CScript([CScriptOp(OP_DUP), CScriptOp(OP_HASH160), pubkeyhash, CScriptOp(OP_EQUALVERIFY), CScriptOp(OP_CHECKSIG)])\n \n # Add signature for a P2PK witness program.\n-def sign_P2PK_witness_input(script, txTo, inIdx, hashtype, value, key):\n-    tx_hash = SegwitVersion1SignatureHash(script, txTo, inIdx, hashtype, value)\n+def sign_p2pk_witness_input(script, tx_to, in_idx, hashtype, value, key):\n+    tx_hash = SegwitVersion1SignatureHash(script, tx_to, in_idx, hashtype, value)\n     signature = key.sign(tx_hash) + chr(hashtype).encode('latin-1')\n-    txTo.wit.vtxinwit[inIdx].scriptWitness.stack = [signature, script]\n-    txTo.rehash()\n+    tx_to.wit.vtxinwit[in_idx].scriptWitness.stack = [signature, script]\n+    tx_to.rehash()\n \n \n class SegWitTest(BitcoinTestFramework):\n@@ -138,12 +205,12 @@ def setup_network(self):\n \n     ''' Helpers '''\n     # Build a block on top of node0's tip.\n-    def build_next_block(self, nVersion=4):\n+    def build_next_block(self, version=4):\n         tip = self.nodes[0].getbestblockhash()\n         height = self.nodes[0].getblockcount() + 1\n         block_time = self.nodes[0].getblockheader(tip)[\"mediantime\"] + 1\n         block = create_block(int(tip, 16), create_coinbase(height), block_time)\n-        block.nVersion = nVersion\n+        block.version = version\n         block.rehash()\n         return block\n \n@@ -159,20 +226,19 @@ def test_witness_services(self):\n         self.log.info(\"Verifying NODE_WITNESS service bit\")\n         assert((self.test_node.nServices & NODE_WITNESS) != 0)\n \n-\n     # See if sending a regular transaction works, and create a utxo\n     # to use in later tests.\n     def test_non_witness_transaction(self):\n         # Mine a block with an anyone-can-spend coinbase,\n         # let it mature, then try to spend it.\n         self.log.info(\"Testing non-witness transaction\")\n-        block = self.build_next_block(nVersion=1)\n+        block = self.build_next_block(version=1)\n         block.solve()\n         self.test_node.send_message(msg_block(block))\n-        self.test_node.sync_with_ping() # make sure the block was processed\n+        self.test_node.sync_with_ping()  # make sure the block was processed\n         txid = block.vtx[0].sha256\n \n-        self.nodes[0].generate(99) # let the block mature\n+        self.nodes[0].generate(99)  # let the block mature\n \n         # Create a transaction that spends the coinbase\n         tx = CTransaction()\n@@ -185,13 +251,12 @@ def test_non_witness_transaction(self):\n         assert_equal(msg_tx(tx).serialize(), msg_witness_tx(tx).serialize())\n \n         self.test_node.send_message(msg_witness_tx(tx))\n-        self.test_node.sync_with_ping() # make sure the tx was processed\n+        self.test_node.sync_with_ping()  # make sure the tx was processed\n         assert(tx.hash in self.nodes[0].getrawmempool())\n         # Save this transaction for later\n-        self.utxo.append(UTXO(tx.sha256, 0, 49*100000000))\n+        self.utxo.append(UTXO(tx.sha256, 0, 49 * 100000000))\n         self.nodes[0].generate(1)\n \n-\n     # Verify that blocks with witnesses are rejected before activation.\n     def test_unnecessary_witness_before_segwit_activation(self):\n         self.log.info(\"Testing behavior of unnecessary witnesses\")\n@@ -202,7 +267,7 @@ def test_unnecessary_witness_before_segwit_activation(self):\n \n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n-        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, CScript([OP_TRUE])))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue - 1000, CScript([OP_TRUE])))\n         tx.wit.vtxinwit.append(CTxInWitness())\n         tx.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)])]\n \n@@ -212,15 +277,15 @@ def test_unnecessary_witness_before_segwit_activation(self):\n         assert(tx.sha256 != tx.calc_sha256(with_witness=True))\n \n         # Construct a segwit-signaling block that includes the transaction.\n-        block = self.build_next_block(nVersion=(VB_TOP_BITS|(1 << VB_WITNESS_BIT)))\n+        block = self.build_next_block(version=(VB_TOP_BITS | (1 << VB_WITNESS_BIT)))\n         self.update_witness_block_with_transactions(block, [tx])\n         # Sending witness data before activation is not allowed (anti-spam\n         # rule).\n         test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n         # TODO: fix synchronization so we can test reject reason\n         # Right now, bitcoind delays sending reject messages for blocks\n         # until the future, making synchronization here difficult.\n-        #assert_equal(self.test_node.last_message[\"reject\"].reason, \"unexpected-witness\")\n+        # assert_equal(self.test_node.last_message[\"reject\"].reason, \"unexpected-witness\")\n \n         # But it should not be permanently marked bad...\n         # Resend without witness information.\n@@ -249,16 +314,16 @@ def test_v0_outputs_arent_spendable(self):\n         # Create two outputs, a p2wsh and p2sh-p2wsh\n         witness_program = CScript([OP_TRUE])\n         witness_hash = sha256(witness_program)\n-        scriptPubKey = CScript([OP_0, witness_hash])\n+        script_pubkey = CScript([OP_0, witness_hash])\n \n-        p2sh_pubkey = hash160(scriptPubKey)\n-        p2sh_scriptPubKey = CScript([OP_HASH160, p2sh_pubkey, OP_EQUAL])\n+        p2sh_pubkey = hash160(script_pubkey)\n+        p2sh_script_pubkey = CScript([OP_HASH160, p2sh_pubkey, OP_EQUAL])\n \n         value = self.utxo[0].nValue // 3\n \n         tx = CTransaction()\n         tx.vin = [CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b'')]\n-        tx.vout = [CTxOut(value, scriptPubKey), CTxOut(value, p2sh_scriptPubKey)]\n+        tx.vout = [CTxOut(value, script_pubkey), CTxOut(value, p2sh_script_pubkey)]\n         tx.vout.append(CTxOut(value, CScript([OP_TRUE])))\n         tx.rehash()\n         txid = tx.sha256\n@@ -268,7 +333,7 @@ def test_v0_outputs_arent_spendable(self):\n         self.update_witness_block_with_transactions(block, [tx])\n         # Verify that segwit isn't activated. A block serialized with witness\n         # should be rejected prior to activation.\n-        test_witness_block(self.nodes[0], self.test_node, block, accepted=False, with_witness=True, reason = b'unexpected-witness')\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False, with_witness=True, reason=b'unexpected-witness')\n         # Now send the block without witness. It should be accepted\n         test_witness_block(self.nodes[0], self.test_node, block, accepted=True, with_witness=False)\n \n@@ -281,7 +346,7 @@ def test_v0_outputs_arent_spendable(self):\n         p2wsh_tx.rehash()\n \n         p2sh_p2wsh_tx = CTransaction()\n-        p2sh_p2wsh_tx.vin = [CTxIn(COutPoint(txid, 1), CScript([scriptPubKey]))]\n+        p2sh_p2wsh_tx.vin = [CTxIn(COutPoint(txid, 1), CScript([script_pubkey]))]\n         p2sh_p2wsh_tx.vout = [CTxOut(value, CScript([OP_TRUE]))]\n         p2sh_p2wsh_tx.wit.vtxinwit.append(CTxInWitness())\n         p2sh_p2wsh_tx.wit.vtxinwit[0].scriptWitness.stack = [CScript([OP_TRUE])]\n@@ -317,7 +382,7 @@ def advance_to_segwit_started(self):\n         # Genesis block is 'defined'.\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'defined')\n         # Advance to end of period, status should now be 'started'\n-        self.nodes[0].generate(VB_PERIOD-height-1)\n+        self.nodes[0].generate(VB_PERIOD - height - 1)\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'started')\n \n     # Mine enough blocks to lock in segwit, but don't activate.\n@@ -327,26 +392,24 @@ def advance_to_segwit_lockin(self):\n         height = self.nodes[0].getblockcount()\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'started')\n         # Advance to end of period, and verify lock-in happens at the end\n-        self.nodes[0].generate(VB_PERIOD-1)\n+        self.nodes[0].generate(VB_PERIOD - 1)\n         height = self.nodes[0].getblockcount()\n         assert((height % VB_PERIOD) == VB_PERIOD - 2)\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'started')\n         self.nodes[0].generate(1)\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'locked_in')\n \n-\n     # Mine enough blocks to activate segwit.\n     # TODO: we could verify that activation only happens at the right threshold\n     # of signalling blocks, rather than just at the right period boundary.\n     def advance_to_segwit_active(self):\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'locked_in')\n         height = self.nodes[0].getblockcount()\n-        self.nodes[0].generate(VB_PERIOD - (height%VB_PERIOD) - 2)\n+        self.nodes[0].generate(VB_PERIOD - (height % VB_PERIOD) - 2)\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'locked_in')\n         self.nodes[0].generate(1)\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'active')\n \n-\n     # This test can only be run after segwit has activated\n     def test_witness_commitments(self):\n         self.log.info(\"Testing witness commitments\")\n@@ -381,14 +444,14 @@ def test_witness_commitments(self):\n         # Let's construct a witness program\n         witness_program = CScript([OP_TRUE])\n         witness_hash = sha256(witness_program)\n-        scriptPubKey = CScript([OP_0, witness_hash])\n-        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, scriptPubKey))\n+        script_pubkey = CScript([OP_0, witness_hash])\n+        tx.vout.append(CTxOut(self.utxo[0].nValue - 1000, script_pubkey))\n         tx.rehash()\n \n         # tx2 will spend tx1, and send back to a regular anyone-can-spend address\n         tx2 = CTransaction()\n         tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n-        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, witness_program))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue - 1000, witness_program))\n         tx2.wit.vtxinwit.append(CTxInWitness())\n         tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n         tx2.rehash()\n@@ -416,7 +479,7 @@ def test_witness_commitments(self):\n         block_3.vtx[0].rehash()\n         block_3.hashMerkleRoot = block_3.calc_merkle_root()\n         block_3.rehash()\n-        assert(len(block_3.vtx[0].vout) == 4) # 3 OP_returns\n+        assert(len(block_3.vtx[0].vout) == 4)  # 3 OP_returns\n         block_3.solve()\n         test_witness_block(self.nodes[0].rpc, self.test_node, block_3, accepted=True)\n \n@@ -425,7 +488,7 @@ def test_witness_commitments(self):\n         block_4 = self.build_next_block()\n         tx3 = CTransaction()\n         tx3.vin.append(CTxIn(COutPoint(tx2.sha256, 0), b\"\"))\n-        tx3.vout.append(CTxOut(tx.vout[0].nValue-1000, witness_program))\n+        tx3.vout.append(CTxOut(tx.vout[0].nValue - 1000, witness_program))\n         tx3.rehash()\n         block_4.vtx.append(tx3)\n         block_4.hashMerkleRoot = block_4.calc_merkle_root()\n@@ -436,7 +499,6 @@ def test_witness_commitments(self):\n         self.utxo.pop(0)\n         self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n \n-\n     def test_block_malleability(self):\n         self.log.info(\"Testing witness block malleability\")\n \n@@ -447,7 +509,7 @@ def test_block_malleability(self):\n         add_witness_commitment(block)\n         block.solve()\n \n-        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack.append(b'a'*5000000)\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack.append(b'a' * 5000000)\n         assert(get_virtual_size(block) > MAX_BLOCK_BASE_SIZE)\n \n         # We can't send over the p2p network, because this is too big to relay\n@@ -470,14 +532,13 @@ def test_block_malleability(self):\n \n         # Change the nonce -- should not cause the block to be permanently\n         # failed\n-        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack = [ ser_uint256(1) ]\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack = [ser_uint256(1)]\n         test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n \n         # Changing the witness reserved value doesn't change the block hash\n-        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack = [ ser_uint256(0) ]\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack = [ser_uint256(0)]\n         test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n \n-\n     def test_witness_block_size(self):\n         self.log.info(\"Testing witness block size limit\")\n         # TODO: Test that non-witness carrying blocks can't exceed 1MB\n@@ -492,21 +553,21 @@ def test_witness_block_size(self):\n         # The witness program will be a bunch of OP_2DROP's, followed by OP_TRUE.\n         # This should give us plenty of room to tweak the spending tx's\n         # virtual size.\n-        NUM_DROPS = 200 # 201 max ops per script!\n+        NUM_DROPS = 200  # 201 max ops per script!\n         NUM_OUTPUTS = 50\n \n-        witness_program = CScript([OP_2DROP]*NUM_DROPS + [OP_TRUE])\n+        witness_program = CScript([OP_2DROP] * NUM_DROPS + [OP_TRUE])\n         witness_hash = uint256_from_str(sha256(witness_program))\n-        scriptPubKey = CScript([OP_0, ser_uint256(witness_hash)])\n+        script_pubkey = CScript([OP_0, ser_uint256(witness_hash)])\n \n         prevout = COutPoint(self.utxo[0].sha256, self.utxo[0].n)\n         value = self.utxo[0].nValue\n \n         parent_tx = CTransaction()\n         parent_tx.vin.append(CTxIn(prevout, b\"\"))\n-        child_value = int(value/NUM_OUTPUTS)\n+        child_value = int(value / NUM_OUTPUTS)\n         for i in range(NUM_OUTPUTS):\n-            parent_tx.vout.append(CTxOut(child_value, scriptPubKey))\n+            parent_tx.vout.append(CTxOut(child_value, script_pubkey))\n         parent_tx.vout[0].nValue -= 50000\n         assert(parent_tx.vout[0].nValue > 0)\n         parent_tx.rehash()\n@@ -517,17 +578,17 @@ def test_witness_block_size(self):\n         child_tx.vout = [CTxOut(value - 100000, CScript([OP_TRUE]))]\n         for i in range(NUM_OUTPUTS):\n             child_tx.wit.vtxinwit.append(CTxInWitness())\n-            child_tx.wit.vtxinwit[-1].scriptWitness.stack = [b'a'*195]*(2*NUM_DROPS) + [witness_program]\n+            child_tx.wit.vtxinwit[-1].scriptWitness.stack = [b'a' * 195] * (2 * NUM_DROPS) + [witness_program]\n         child_tx.rehash()\n         self.update_witness_block_with_transactions(block, [parent_tx, child_tx])\n \n         vsize = get_virtual_size(block)\n-        additional_bytes = (MAX_BLOCK_BASE_SIZE - vsize)*4\n+        additional_bytes = (MAX_BLOCK_BASE_SIZE - vsize) * 4\n         i = 0\n         while additional_bytes > 0:\n             # Add some more bytes to each input until we hit MAX_BLOCK_BASE_SIZE+1\n-            extra_bytes = min(additional_bytes+1, 55)\n-            block.vtx[-1].wit.vtxinwit[int(i/(2*NUM_DROPS))].scriptWitness.stack[i%(2*NUM_DROPS)] = b'a'*(195+extra_bytes)\n+            extra_bytes = min(additional_bytes + 1, 55)\n+            block.vtx[-1].wit.vtxinwit[int(i / (2 * NUM_DROPS))].scriptWitness.stack[i % (2 * NUM_DROPS)] = b'a' * (195 + extra_bytes)\n             additional_bytes -= extra_bytes\n             i += 1\n \n@@ -538,13 +599,13 @@ def test_witness_block_size(self):\n         assert_equal(vsize, MAX_BLOCK_BASE_SIZE + 1)\n         # Make sure that our test case would exceed the old max-network-message\n         # limit\n-        assert(len(block.serialize(True)) > 2*1024*1024)\n+        assert(len(block.serialize(True)) > 2 * 1024 * 1024)\n \n         test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n \n         # Now resize the second transaction to make the block fit.\n         cur_length = len(block.vtx[-1].wit.vtxinwit[0].scriptWitness.stack[0])\n-        block.vtx[-1].wit.vtxinwit[0].scriptWitness.stack[0] = b'a'*(cur_length-1)\n+        block.vtx[-1].wit.vtxinwit[0].scriptWitness.stack[0] = b'a' * (cur_length - 1)\n         block.vtx[0].vout.pop()\n         add_witness_commitment(block)\n         block.solve()\n@@ -556,7 +617,6 @@ def test_witness_block_size(self):\n         self.utxo.pop(0)\n         self.utxo.append(UTXO(block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue))\n \n-\n     # submitblock will try to add the nonce automatically, so that mining\n     # software doesn't need to worry about doing so itself.\n     def test_submit_block(self):\n@@ -565,7 +625,7 @@ def test_submit_block(self):\n         # Try using a custom nonce and then don't supply it.\n         # This shouldn't possibly work.\n         add_witness_commitment(block, nonce=1)\n-        block.vtx[0].wit = CTxWitness() # drop the nonce\n+        block.vtx[0].wit = CTxWitness()  # drop the nonce\n         block.solve()\n         self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n         assert(self.nodes[0].getbestblockhash() != block.hash)\n@@ -593,7 +653,6 @@ def test_submit_block(self):\n         # Tip should not advance!\n         assert(self.nodes[0].getbestblockhash() != block_2.hash)\n \n-\n     # Consensus tests of extra witness data in a transaction.\n     def test_extra_witness_data(self):\n         self.log.info(\"Testing extra witness data in tx\")\n@@ -604,13 +663,13 @@ def test_extra_witness_data(self):\n \n         witness_program = CScript([OP_DROP, OP_TRUE])\n         witness_hash = sha256(witness_program)\n-        scriptPubKey = CScript([OP_0, witness_hash])\n+        script_pubkey = CScript([OP_0, witness_hash])\n \n         # First try extra witness data on a tx that doesn't require a witness\n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n-        tx.vout.append(CTxOut(self.utxo[0].nValue-2000, scriptPubKey))\n-        tx.vout.append(CTxOut(1000, CScript([OP_TRUE]))) # non-witness output\n+        tx.vout.append(CTxOut(self.utxo[0].nValue - 2000, script_pubkey))\n+        tx.vout.append(CTxOut(1000, CScript([OP_TRUE])))  # non-witness output\n         tx.wit.vtxinwit.append(CTxInWitness())\n         tx.wit.vtxinwit[0].scriptWitness.stack = [CScript([])]\n         tx.rehash()\n@@ -631,12 +690,12 @@ def test_extra_witness_data(self):\n         # Now try extra witness/signature data on an input that DOES require a\n         # witness\n         tx2 = CTransaction()\n-        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\")) # witness output\n-        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 1), b\"\")) # non-witness\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))  # witness output\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 1), b\"\"))  # non-witness\n         tx2.vout.append(CTxOut(tx.vout[0].nValue, CScript([OP_TRUE])))\n         tx2.wit.vtxinwit.extend([CTxInWitness(), CTxInWitness()])\n-        tx2.wit.vtxinwit[0].scriptWitness.stack = [ CScript([CScriptNum(1)]), CScript([CScriptNum(1)]), witness_program ]\n-        tx2.wit.vtxinwit[1].scriptWitness.stack = [ CScript([OP_TRUE]) ]\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)]), CScript([CScriptNum(1)]), witness_program]\n+        tx2.wit.vtxinwit[1].scriptWitness.stack = [CScript([OP_TRUE])]\n \n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx2])\n@@ -669,7 +728,6 @@ def test_extra_witness_data(self):\n         self.utxo.pop(0)\n         self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n \n-\n     def test_max_witness_push_length(self):\n         ''' Should only allow up to 520 byte pushes in witness stack '''\n         self.log.info(\"Testing maximum witness push size\")\n@@ -680,26 +738,26 @@ def test_max_witness_push_length(self):\n \n         witness_program = CScript([OP_DROP, OP_TRUE])\n         witness_hash = sha256(witness_program)\n-        scriptPubKey = CScript([OP_0, witness_hash])\n+        script_pubkey = CScript([OP_0, witness_hash])\n \n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n-        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, scriptPubKey))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue - 1000, script_pubkey))\n         tx.rehash()\n \n         tx2 = CTransaction()\n         tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n-        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, CScript([OP_TRUE])))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue - 1000, CScript([OP_TRUE])))\n         tx2.wit.vtxinwit.append(CTxInWitness())\n         # First try a 521-byte stack element\n-        tx2.wit.vtxinwit[0].scriptWitness.stack = [ b'a'*(MAX_SCRIPT_ELEMENT_SIZE+1), witness_program ]\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a' * (MAX_SCRIPT_ELEMENT_SIZE + 1), witness_program]\n         tx2.rehash()\n \n         self.update_witness_block_with_transactions(block, [tx, tx2])\n         test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n \n         # Now reduce the length of the stack element\n-        tx2.wit.vtxinwit[0].scriptWitness.stack[0] = b'a'*(MAX_SCRIPT_ELEMENT_SIZE)\n+        tx2.wit.vtxinwit[0].scriptWitness.stack[0] = b'a' * (MAX_SCRIPT_ELEMENT_SIZE)\n \n         add_witness_commitment(block)\n         block.solve()\n@@ -717,39 +775,39 @@ def test_max_witness_program_length(self):\n         MAX_PROGRAM_LENGTH = 10000\n \n         # This program is 19 max pushes (9937 bytes), then 64 more opcode-bytes.\n-        long_witness_program = CScript([b'a'*520]*19 + [OP_DROP]*63 + [OP_TRUE])\n-        assert(len(long_witness_program) == MAX_PROGRAM_LENGTH+1)\n+        long_witness_program = CScript([b'a' * 520] * 19 + [OP_DROP] * 63 + [OP_TRUE])\n+        assert(len(long_witness_program) == MAX_PROGRAM_LENGTH + 1)\n         long_witness_hash = sha256(long_witness_program)\n-        long_scriptPubKey = CScript([OP_0, long_witness_hash])\n+        long_script_pubkey = CScript([OP_0, long_witness_hash])\n \n         block = self.build_next_block()\n \n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n-        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, long_scriptPubKey))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue - 1000, long_script_pubkey))\n         tx.rehash()\n \n         tx2 = CTransaction()\n         tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n-        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, CScript([OP_TRUE])))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue - 1000, CScript([OP_TRUE])))\n         tx2.wit.vtxinwit.append(CTxInWitness())\n-        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a']*44 + [long_witness_program]\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a'] * 44 + [long_witness_program]\n         tx2.rehash()\n \n         self.update_witness_block_with_transactions(block, [tx, tx2])\n \n         test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n \n         # Try again with one less byte in the witness program\n-        witness_program = CScript([b'a'*520]*19 + [OP_DROP]*62 + [OP_TRUE])\n+        witness_program = CScript([b'a' * 520] * 19 + [OP_DROP] * 62 + [OP_TRUE])\n         assert(len(witness_program) == MAX_PROGRAM_LENGTH)\n         witness_hash = sha256(witness_program)\n-        scriptPubKey = CScript([OP_0, witness_hash])\n+        script_pubkey = CScript([OP_0, witness_hash])\n \n-        tx.vout[0] = CTxOut(tx.vout[0].nValue, scriptPubKey)\n+        tx.vout[0] = CTxOut(tx.vout[0].nValue, script_pubkey)\n         tx.rehash()\n         tx2.vin[0].prevout.hash = tx.sha256\n-        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a']*43 + [witness_program]\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a'] * 43 + [witness_program]\n         tx2.rehash()\n         block.vtx = [block.vtx[0]]\n         self.update_witness_block_with_transactions(block, [tx, tx2])\n@@ -758,22 +816,21 @@ def test_max_witness_program_length(self):\n         self.utxo.pop()\n         self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n \n-\n     def test_witness_input_length(self):\n         ''' Ensure that vin length must match vtxinwit length '''\n         self.log.info(\"Testing witness input length\")\n         assert(len(self.utxo))\n \n         witness_program = CScript([OP_DROP, OP_TRUE])\n         witness_hash = sha256(witness_program)\n-        scriptPubKey = CScript([OP_0, witness_hash])\n+        script_pubkey = CScript([OP_0, witness_hash])\n \n         # Create a transaction that splits our utxo into many outputs\n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n-        nValue = self.utxo[0].nValue\n+        value = self.utxo[0].nValue\n         for i in range(10):\n-            tx.vout.append(CTxOut(int(nValue/10), scriptPubKey))\n+            tx.vout.append(CTxOut(int(value / 10), script_pubkey))\n         tx.vout[0].nValue -= 1000\n         assert(tx.vout[0].nValue >= 0)\n \n@@ -805,7 +862,7 @@ def serialize_with_witness(self):\n         tx2 = BrokenCTransaction()\n         for i in range(10):\n             tx2.vin.append(CTxIn(COutPoint(tx.sha256, i), b\"\"))\n-        tx2.vout.append(CTxOut(nValue-3000, CScript([OP_TRUE])))\n+        tx2.vout.append(CTxOut(value - 3000, CScript([OP_TRUE])))\n \n         # First try using a too long vtxinwit\n         for i in range(11):\n@@ -827,7 +884,7 @@ def serialize_with_witness(self):\n         # Now make one of the intermediate witnesses be incorrect\n         tx2.wit.vtxinwit.append(CTxInWitness())\n         tx2.wit.vtxinwit[-1].scriptWitness.stack = [b'a', witness_program]\n-        tx2.wit.vtxinwit[5].scriptWitness.stack = [ witness_program ]\n+        tx2.wit.vtxinwit[5].scriptWitness.stack = [witness_program]\n \n         block.vtx = [block.vtx[0]]\n         self.update_witness_block_with_transactions(block, [tx2])\n@@ -842,7 +899,6 @@ def serialize_with_witness(self):\n         self.utxo.pop()\n         self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n \n-\n     def test_witness_tx_relay_before_segwit_activation(self):\n         self.log.info(\"Testing relay of witness transactions\")\n         # Generate a transaction that doesn't require a witness, but send it\n@@ -853,7 +909,7 @@ def test_witness_tx_relay_before_segwit_activation(self):\n         tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n         tx.vout.append(CTxOut(self.utxo[0].nValue - 1000, CScript([OP_TRUE, OP_DROP] * 15 + [OP_TRUE])))\n         tx.wit.vtxinwit.append(CTxInWitness())\n-        tx.wit.vtxinwit[0].scriptWitness.stack = [ b'a' ]\n+        tx.wit.vtxinwit[0].scriptWitness.stack = [b'a']\n         tx.rehash()\n \n         tx_hash = tx.sha256\n@@ -880,12 +936,11 @@ def test_witness_tx_relay_before_segwit_activation(self):\n \n         # Cleanup: mine the first transaction and update utxo\n         self.nodes[0].generate(1)\n-        assert_equal(len(self.nodes[0].getrawmempool()),  0)\n+        assert_equal(len(self.nodes[0].getrawmempool()), 0)\n \n         self.utxo.pop(0)\n         self.utxo.append(UTXO(tx_hash, 0, tx_value))\n \n-\n     # After segwit activates, verify that mempool:\n     # - rejects transactions with unnecessary/extra witnesses\n     # - accepts transactions with valid witnesses\n@@ -900,7 +955,7 @@ def test_tx_relay_after_segwit_activation(self):\n         tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n         tx.vout.append(CTxOut(self.utxo[0].nValue - 1000, CScript([OP_TRUE, OP_DROP] * 15 + [OP_TRUE])))\n         tx.wit.vtxinwit.append(CTxInWitness())\n-        tx.wit.vtxinwit[0].scriptWitness.stack = [ b'a' ]\n+        tx.wit.vtxinwit[0].scriptWitness.stack = [b'a']\n         tx.rehash()\n \n         tx_hash = tx.sha256\n@@ -917,10 +972,10 @@ def test_tx_relay_after_segwit_activation(self):\n         # Now try to add extra witness data to a valid witness tx.\n         witness_program = CScript([OP_TRUE])\n         witness_hash = sha256(witness_program)\n-        scriptPubKey = CScript([OP_0, witness_hash])\n+        script_pubkey = CScript([OP_0, witness_hash])\n         tx2 = CTransaction()\n         tx2.vin.append(CTxIn(COutPoint(tx_hash, 0), b\"\"))\n-        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, scriptPubKey))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue - 1000, script_pubkey))\n         tx2.rehash()\n \n         tx3 = CTransaction()\n@@ -930,8 +985,8 @@ def test_tx_relay_after_segwit_activation(self):\n         # Add too-large for IsStandard witness and check that it does not enter reject filter\n         p2sh_program = CScript([OP_TRUE])\n         p2sh_pubkey = hash160(p2sh_program)\n-        witness_program2 = CScript([b'a'*400000])\n-        tx3.vout.append(CTxOut(tx2.vout[0].nValue-1000, CScript([OP_HASH160, p2sh_pubkey, OP_EQUAL])))\n+        witness_program2 = CScript([b'a' * 400000])\n+        tx3.vout.append(CTxOut(tx2.vout[0].nValue - 1000, CScript([OP_HASH160, p2sh_pubkey, OP_EQUAL])))\n         tx3.wit.vtxinwit[0].scriptWitness.stack = [witness_program2]\n         tx3.rehash()\n \n@@ -943,17 +998,17 @@ def test_tx_relay_after_segwit_activation(self):\n \n         # Remove witness stuffing, instead add extra witness push on stack\n         tx3.vout[0] = CTxOut(tx2.vout[0].nValue - 1000, CScript([OP_TRUE, OP_DROP] * 15 + [OP_TRUE]))\n-        tx3.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)]), witness_program ]\n+        tx3.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)]), witness_program]\n         tx3.rehash()\n \n         test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx2, with_witness=True, accepted=True)\n         test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx3, with_witness=True, accepted=False)\n \n         # Get rid of the extra witness, and verify acceptance.\n-        tx3.wit.vtxinwit[0].scriptWitness.stack = [ witness_program ]\n+        tx3.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n         # Also check that old_node gets a tx announcement, even though this is\n         # a witness transaction.\n-        self.old_node.wait_for_inv([CInv(1, tx2.sha256)]) # wait until tx2 was inv'ed\n+        self.old_node.wait_for_inv([CInv(1, tx2.sha256)])  # wait until tx2 was inv'ed\n         test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx3, with_witness=True, accepted=True)\n         self.old_node.wait_for_inv([CInv(1, tx3.sha256)])\n \n@@ -962,7 +1017,7 @@ def test_tx_relay_after_segwit_activation(self):\n         raw_tx = self.nodes[0].getrawtransaction(tx3.hash, 1)\n         assert_equal(int(raw_tx[\"hash\"], 16), tx3.calc_sha256(True))\n         assert_equal(raw_tx[\"size\"], len(tx3.serialize_with_witness()))\n-        weight = len(tx3.serialize_with_witness()) + 3*len(tx3.serialize_without_witness())\n+        weight = len(tx3.serialize_with_witness()) + 3 * len(tx3.serialize_without_witness())\n         vsize = math.ceil(weight / 4)\n         assert_equal(raw_tx[\"vsize\"], vsize)\n         assert_equal(raw_tx[\"weight\"], weight)\n@@ -972,19 +1027,18 @@ def test_tx_relay_after_segwit_activation(self):\n \n         # Cleanup: mine the transactions and update utxo for next test\n         self.nodes[0].generate(1)\n-        assert_equal(len(self.nodes[0].getrawmempool()),  0)\n+        assert_equal(len(self.nodes[0].getrawmempool()), 0)\n \n         self.utxo.pop(0)\n         self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n \n-\n     # Test that block requests to NODE_WITNESS peer are with MSG_WITNESS_FLAG\n     # This is true regardless of segwit activation.\n     # Also test that we don't ask for blocks from unupgraded peers\n     def test_block_relay(self, segwit_activated):\n         self.log.info(\"Testing block relay\")\n \n-        blocktype = 2|MSG_WITNESS_FLAG\n+        blocktype = 2 | MSG_WITNESS_FLAG\n \n         # test_node has set NODE_WITNESS, so all getdata requests should be for\n         # witness blocks.\n@@ -997,36 +1051,36 @@ def test_block_relay(self, segwit_activated):\n         assert(self.test_node.last_message[\"getdata\"].inv[0].type == blocktype)\n         test_witness_block(self.nodes[0].rpc, self.test_node, block1, True)\n \n-        block2 = self.build_next_block(nVersion=4)\n+        block2 = self.build_next_block(version=4)\n         block2.solve()\n \n         self.test_node.announce_block_and_wait_for_getdata(block2, use_header=True)\n         assert(self.test_node.last_message[\"getdata\"].inv[0].type == blocktype)\n         test_witness_block(self.nodes[0].rpc, self.test_node, block2, True)\n \n-        block3 = self.build_next_block(nVersion=(VB_TOP_BITS | (1<<15)))\n+        block3 = self.build_next_block(version=(VB_TOP_BITS | (1 << 15)))\n         block3.solve()\n         self.test_node.announce_block_and_wait_for_getdata(block3, use_header=True)\n         assert(self.test_node.last_message[\"getdata\"].inv[0].type == blocktype)\n         test_witness_block(self.nodes[0].rpc, self.test_node, block3, True)\n \n         # Check that we can getdata for witness blocks or regular blocks,\n         # and the right thing happens.\n-        if segwit_activated == False:\n+        if not segwit_activated:\n             # Before activation, we should be able to request old blocks with\n             # or without witness, and they should be the same.\n             chain_height = self.nodes[0].getblockcount()\n             # Pick 10 random blocks on main chain, and verify that getdata's\n             # for MSG_BLOCK, MSG_WITNESS_BLOCK, and rpc getblock() are equal.\n-            all_heights = list(range(chain_height+1))\n+            all_heights = list(range(chain_height + 1))\n             random.shuffle(all_heights)\n             all_heights = all_heights[0:10]\n             for height in all_heights:\n                 block_hash = self.nodes[0].getblockhash(height)\n                 rpc_block = self.nodes[0].getblock(block_hash, False)\n                 block_hash = int(block_hash, 16)\n                 block = self.test_node.request_block(block_hash, 2)\n-                wit_block = self.test_node.request_block(block_hash, 2|MSG_WITNESS_FLAG)\n+                wit_block = self.test_node.request_block(block_hash, 2 | MSG_WITNESS_FLAG)\n                 assert_equal(block.serialize(True), wit_block.serialize(True))\n                 assert_equal(block.serialize(), hex_str_to_bytes(rpc_block))\n         else:\n@@ -1042,7 +1096,7 @@ def test_block_relay(self, segwit_activated):\n             # Now try to retrieve it...\n             rpc_block = self.nodes[0].getblock(block.hash, False)\n             non_wit_block = self.test_node.request_block(block.sha256, 2)\n-            wit_block = self.test_node.request_block(block.sha256, 2|MSG_WITNESS_FLAG)\n+            wit_block = self.test_node.request_block(block.sha256, 2 | MSG_WITNESS_FLAG)\n             assert_equal(wit_block.serialize(True), hex_str_to_bytes(rpc_block))\n             assert_equal(wit_block.serialize(False), non_wit_block.serialize())\n             assert_equal(wit_block.serialize(True), block.serialize(True))\n@@ -1051,11 +1105,11 @@ def test_block_relay(self, segwit_activated):\n             rpc_details = self.nodes[0].getblock(block.hash, True)\n             assert_equal(rpc_details[\"size\"], len(block.serialize(True)))\n             assert_equal(rpc_details[\"strippedsize\"], len(block.serialize(False)))\n-            weight = 3*len(block.serialize(False)) + len(block.serialize(True))\n+            weight = 3 * len(block.serialize(False)) + len(block.serialize(True))\n             assert_equal(rpc_details[\"weight\"], weight)\n \n             # Upgraded node should not ask for blocks from unupgraded\n-            block4 = self.build_next_block(nVersion=4)\n+            block4 = self.build_next_block(version=4)\n             block4.solve()\n             self.old_node.getdataset = set()\n \n@@ -1068,7 +1122,7 @@ def test_block_relay(self, segwit_activated):\n             # Since 0.14, inv's will only be responded to with a getheaders, so send a header\n             # to announce this block.\n             msg = msg_headers()\n-            msg.headers = [ CBlockHeader(block4) ]\n+            msg.headers = [CBlockHeader(block4)]\n             self.old_node.send_message(msg)\n             self.old_node.announce_tx_and_wait_for_getdata(block4.vtx[0])\n             assert(block4.sha256 not in self.old_node.getdataset)\n@@ -1080,15 +1134,15 @@ def test_standardness_v0(self, segwit_activated):\n \n         witness_program = CScript([OP_TRUE])\n         witness_hash = sha256(witness_program)\n-        scriptPubKey = CScript([OP_0, witness_hash])\n+        script_pubkey = CScript([OP_0, witness_hash])\n \n         p2sh_pubkey = hash160(witness_program)\n-        p2sh_scriptPubKey = CScript([OP_HASH160, p2sh_pubkey, OP_EQUAL])\n+        p2sh_script_pubkey = CScript([OP_HASH160, p2sh_pubkey, OP_EQUAL])\n \n         # First prepare a p2sh output (so that spending it will pass standardness)\n         p2sh_tx = CTransaction()\n         p2sh_tx.vin = [CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\")]\n-        p2sh_tx.vout = [CTxOut(self.utxo[0].nValue-1000, p2sh_scriptPubKey)]\n+        p2sh_tx.vout = [CTxOut(self.utxo[0].nValue - 1000, p2sh_script_pubkey)]\n         p2sh_tx.rehash()\n \n         # Mine it on test_node to create the confirmed output.\n@@ -1100,8 +1154,8 @@ def test_standardness_v0(self, segwit_activated):\n         # Start by creating a transaction with two outputs.\n         tx = CTransaction()\n         tx.vin = [CTxIn(COutPoint(p2sh_tx.sha256, 0), CScript([witness_program]))]\n-        tx.vout = [CTxOut(p2sh_tx.vout[0].nValue-10000, scriptPubKey)]\n-        tx.vout.append(CTxOut(8000, scriptPubKey)) # Might burn this later\n+        tx.vout = [CTxOut(p2sh_tx.vout[0].nValue - 10000, script_pubkey)]\n+        tx.vout.append(CTxOut(8000, script_pubkey))  # Might burn this later\n         tx.vin[0].nSequence = BIP125_SEQUENCE_NUMBER  # Just to have the option to bump this tx from the mempool\n         tx.rehash()\n \n@@ -1110,11 +1164,11 @@ def test_standardness_v0(self, segwit_activated):\n         test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx, with_witness=True, accepted=True)\n \n         # Now create something that looks like a P2PKH output. This won't be spendable.\n-        scriptPubKey = CScript([OP_0, hash160(witness_hash)])\n+        script_pubkey = CScript([OP_0, hash160(witness_hash)])\n         tx2 = CTransaction()\n         # tx was accepted, so we spend the second output.\n         tx2.vin = [CTxIn(COutPoint(tx.sha256, 1), b\"\")]\n-        tx2.vout = [CTxOut(7000, scriptPubKey)]\n+        tx2.vout = [CTxOut(7000, script_pubkey)]\n         tx2.wit.vtxinwit.append(CTxInWitness())\n         tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n         tx2.rehash()\n@@ -1149,25 +1203,24 @@ def test_standardness_v0(self, segwit_activated):\n         self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n         assert_equal(len(self.nodes[1].getrawmempool()), 0)\n \n-\n     # Verify that future segwit upgraded transactions are non-standard,\n     # but valid in blocks. Can run this before and after segwit activation.\n     def test_segwit_versions(self):\n         self.log.info(\"Testing standardness/consensus for segwit versions (0-16)\")\n         assert(len(self.utxo))\n-        NUM_TESTS = 17 # will test OP_0, OP1, ..., OP_16\n-        if (len(self.utxo) < NUM_TESTS):\n+        num_tests = 17  # will test OP_0, OP1, ..., OP_16\n+        if (len(self.utxo) < num_tests):\n             tx = CTransaction()\n             tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n-            split_value = (self.utxo[0].nValue - 4000) // NUM_TESTS\n-            for i in range(NUM_TESTS):\n+            split_value = (self.utxo[0].nValue - 4000) // num_tests\n+            for i in range(num_tests):\n                 tx.vout.append(CTxOut(split_value, CScript([OP_TRUE])))\n             tx.rehash()\n             block = self.build_next_block()\n             self.update_witness_block_with_transactions(block, [tx])\n             test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n             self.utxo.pop(0)\n-            for i in range(NUM_TESTS):\n+            for i in range(num_tests):\n                 self.utxo.append(UTXO(tx.sha256, i, split_value))\n \n         sync_blocks(self.nodes)\n@@ -1177,36 +1230,36 @@ def test_segwit_versions(self):\n         witness_program = CScript([OP_TRUE])\n         witness_hash = sha256(witness_program)\n         assert_equal(len(self.nodes[1].getrawmempool()), 0)\n-        for version in list(range(OP_1, OP_16+1)) + [OP_0]:\n+        for version in list(range(OP_1, OP_16 + 1)) + [OP_0]:\n             count += 1\n-            # First try to spend to a future version segwit scriptPubKey.\n-            scriptPubKey = CScript([CScriptOp(version), witness_hash])\n+            # First try to spend to a future version segwit script_pubkey.\n+            script_pubkey = CScript([CScriptOp(version), witness_hash])\n             tx.vin = [CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\")]\n-            tx.vout = [CTxOut(self.utxo[0].nValue-1000, scriptPubKey)]\n+            tx.vout = [CTxOut(self.utxo[0].nValue - 1000, script_pubkey)]\n             tx.rehash()\n             test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx, with_witness=True, accepted=False)\n             test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, with_witness=True, accepted=True)\n             self.utxo.pop(0)\n             temp_utxo.append(UTXO(tx.sha256, 0, tx.vout[0].nValue))\n \n-        self.nodes[0].generate(1) # Mine all the transactions\n+        self.nodes[0].generate(1)  # Mine all the transactions\n         sync_blocks(self.nodes)\n         assert(len(self.nodes[0].getrawmempool()) == 0)\n \n         # Finally, verify that version 0 -> version 1 transactions\n         # are non-standard\n-        scriptPubKey = CScript([CScriptOp(OP_1), witness_hash])\n+        script_pubkey = CScript([CScriptOp(OP_1), witness_hash])\n         tx2 = CTransaction()\n         tx2.vin = [CTxIn(COutPoint(tx.sha256, 0), b\"\")]\n-        tx2.vout = [CTxOut(tx.vout[0].nValue-1000, scriptPubKey)]\n+        tx2.vout = [CTxOut(tx.vout[0].nValue - 1000, script_pubkey)]\n         tx2.wit.vtxinwit.append(CTxInWitness())\n-        tx2.wit.vtxinwit[0].scriptWitness.stack = [ witness_program ]\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n         tx2.rehash()\n         # Gets accepted to test_node, because standardness of outputs isn't\n         # checked with fRequireStandard\n         test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx2, with_witness=True, accepted=True)\n         test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx2, with_witness=True, accepted=False)\n-        temp_utxo.pop() # last entry in temp_utxo was the output we just spent\n+        temp_utxo.pop()  # last entry in temp_utxo was the output we just spent\n         temp_utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n \n         # Spend everything in temp_utxo back to an OP_TRUE output.\n@@ -1235,15 +1288,14 @@ def test_segwit_versions(self):\n         # Add utxo to our list\n         self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n \n-\n     def test_premature_coinbase_witness_spend(self):\n         self.log.info(\"Testing premature coinbase witness spend\")\n         block = self.build_next_block()\n         # Change the output of the block to be a witness output.\n         witness_program = CScript([OP_TRUE])\n         witness_hash = sha256(witness_program)\n-        scriptPubKey = CScript([OP_0, witness_hash])\n-        block.vtx[0].vout[0].scriptPubKey = scriptPubKey\n+        script_pubkey = CScript([OP_0, witness_hash])\n+        block.vtx[0].vout[0].scriptPubKey = script_pubkey\n         # This next line will rehash the coinbase and update the merkle\n         # root, and solve.\n         self.update_witness_block_with_transactions(block, [])\n@@ -1253,7 +1305,7 @@ def test_premature_coinbase_witness_spend(self):\n         spend_tx.vin = [CTxIn(COutPoint(block.vtx[0].sha256, 0), b\"\")]\n         spend_tx.vout = [CTxOut(block.vtx[0].vout[0].nValue, witness_program)]\n         spend_tx.wit.vtxinwit.append(CTxInWitness())\n-        spend_tx.wit.vtxinwit[0].scriptWitness.stack = [ witness_program ]\n+        spend_tx.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n         spend_tx.rehash()\n \n         # Now test a premature spend.\n@@ -1270,7 +1322,6 @@ def test_premature_coinbase_witness_spend(self):\n         test_witness_block(self.nodes[0].rpc, self.test_node, block2, accepted=True)\n         sync_blocks(self.nodes)\n \n-\n     def test_signature_version_1(self):\n         self.log.info(\"Testing segwit signature hash version 1\")\n         key = CECKey()\n@@ -1279,13 +1330,13 @@ def test_signature_version_1(self):\n \n         witness_program = CScript([pubkey, CScriptOp(OP_CHECKSIG)])\n         witness_hash = sha256(witness_program)\n-        scriptPubKey = CScript([OP_0, witness_hash])\n+        script_pubkey = CScript([OP_0, witness_hash])\n \n         # First create a witness output for use in the tests.\n         assert(len(self.utxo))\n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n-        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, scriptPubKey))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue - 1000, script_pubkey))\n         tx.rehash()\n \n         test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, with_witness=True, accepted=True)\n@@ -1298,27 +1349,27 @@ def test_signature_version_1(self):\n \n         # Test each hashtype\n         prev_utxo = UTXO(tx.sha256, 0, tx.vout[0].nValue)\n-        for sigflag in [ 0, SIGHASH_ANYONECANPAY ]:\n+        for sigflag in [0, SIGHASH_ANYONECANPAY]:\n             for hashtype in [SIGHASH_ALL, SIGHASH_NONE, SIGHASH_SINGLE]:\n                 hashtype |= sigflag\n                 block = self.build_next_block()\n                 tx = CTransaction()\n                 tx.vin.append(CTxIn(COutPoint(prev_utxo.sha256, prev_utxo.n), b\"\"))\n-                tx.vout.append(CTxOut(prev_utxo.nValue - 1000, scriptPubKey))\n+                tx.vout.append(CTxOut(prev_utxo.nValue - 1000, script_pubkey))\n                 tx.wit.vtxinwit.append(CTxInWitness())\n                 # Too-large input value\n-                sign_P2PK_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue+1, key)\n+                sign_p2pk_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue + 1, key)\n                 self.update_witness_block_with_transactions(block, [tx])\n                 test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n \n                 # Too-small input value\n-                sign_P2PK_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue-1, key)\n-                block.vtx.pop() # remove last tx\n+                sign_p2pk_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue - 1, key)\n+                block.vtx.pop()  # remove last tx\n                 self.update_witness_block_with_transactions(block, [tx])\n                 test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n \n                 # Now try correct value\n-                sign_P2PK_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue, key)\n+                sign_p2pk_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue, key)\n                 block.vtx.pop()\n                 self.update_witness_block_with_transactions(block, [tx])\n                 test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n@@ -1328,19 +1379,19 @@ def test_signature_version_1(self):\n         # Test combinations of signature hashes.\n         # Split the utxo into a lot of outputs.\n         # Randomly choose up to 10 to spend, sign with different hashtypes, and\n-        # output to a random number of outputs.  Repeat NUM_TESTS times.\n+        # output to a random number of outputs.  Repeat num_tests times.\n         # Ensure that we've tested a situation where we use SIGHASH_SINGLE with\n         # an input index > number of outputs.\n-        NUM_TESTS = 500\n+        num_tests = 500\n         temp_utxos = []\n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(prev_utxo.sha256, prev_utxo.n), b\"\"))\n-        split_value = prev_utxo.nValue // NUM_TESTS\n-        for i in range(NUM_TESTS):\n-            tx.vout.append(CTxOut(split_value, scriptPubKey))\n+        split_value = prev_utxo.nValue // num_tests\n+        for i in range(num_tests):\n+            tx.vout.append(CTxOut(split_value, script_pubkey))\n         tx.wit.vtxinwit.append(CTxInWitness())\n-        sign_P2PK_witness_input(witness_program, tx, 0, SIGHASH_ALL, prev_utxo.nValue, key)\n-        for i in range(NUM_TESTS):\n+        sign_p2pk_witness_input(witness_program, tx, 0, SIGHASH_ALL, prev_utxo.nValue, key)\n+        for i in range(num_tests):\n             temp_utxos.append(UTXO(tx.sha256, i, split_value))\n \n         block = self.build_next_block()\n@@ -1349,7 +1400,7 @@ def test_signature_version_1(self):\n \n         block = self.build_next_block()\n         used_sighash_single_out_of_bounds = False\n-        for i in range(NUM_TESTS):\n+        for i in range(num_tests):\n             # Ping regularly to keep the connection alive\n             if (not i % 100):\n                 self.test_node.sync_with_ping()\n@@ -1367,14 +1418,14 @@ def test_signature_version_1(self):\n                 total_value += temp_utxos[i].nValue\n             split_value = total_value // num_outputs\n             for i in range(num_outputs):\n-                tx.vout.append(CTxOut(split_value, scriptPubKey))\n+                tx.vout.append(CTxOut(split_value, script_pubkey))\n             for i in range(num_inputs):\n                 # Now try to sign each input, using a random hashtype.\n                 anyonecanpay = 0\n                 if random.randint(0, 1):\n                     anyonecanpay = SIGHASH_ANYONECANPAY\n                 hashtype = random.randint(1, 3) | anyonecanpay\n-                sign_P2PK_witness_input(witness_program, tx, i, hashtype, temp_utxos[i].nValue, key)\n+                sign_p2pk_witness_input(witness_program, tx, i, hashtype, temp_utxos[i].nValue, key)\n                 if (hashtype == SIGHASH_SINGLE and i >= num_outputs):\n                     used_sighash_single_out_of_bounds = True\n             tx.rehash()\n@@ -1399,19 +1450,19 @@ def test_signature_version_1(self):\n \n         # Now test witness version 0 P2PKH transactions\n         pubkeyhash = hash160(pubkey)\n-        scriptPKH = CScript([OP_0, pubkeyhash])\n+        script_pkh = CScript([OP_0, pubkeyhash])\n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(temp_utxos[0].sha256, temp_utxos[0].n), b\"\"))\n-        tx.vout.append(CTxOut(temp_utxos[0].nValue, scriptPKH))\n+        tx.vout.append(CTxOut(temp_utxos[0].nValue, script_pkh))\n         tx.wit.vtxinwit.append(CTxInWitness())\n-        sign_P2PK_witness_input(witness_program, tx, 0, SIGHASH_ALL, temp_utxos[0].nValue, key)\n+        sign_p2pk_witness_input(witness_program, tx, 0, SIGHASH_ALL, temp_utxos[0].nValue, key)\n         tx2 = CTransaction()\n         tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n         tx2.vout.append(CTxOut(tx.vout[0].nValue, CScript([OP_TRUE])))\n \n-        script = GetP2PKHScript(pubkeyhash)\n+        script = get_p2pkh_script(pubkeyhash)\n         sig_hash = SegwitVersion1SignatureHash(script, tx2, 0, SIGHASH_ALL, tx.vout[0].nValue)\n-        signature = key.sign(sig_hash) + b'\\x01' # 0x1 is SIGHASH_ALL\n+        signature = key.sign(sig_hash) + b'\\x01'  # 0x1 is SIGHASH_ALL\n \n         # Check that we can't have a scriptSig\n         tx2.vin[0].scriptSig = CScript([signature, pubkey])\n@@ -1444,7 +1495,7 @@ def test_signature_version_1(self):\n             # the signatures as we go.\n             tx.vin.append(CTxIn(COutPoint(i.sha256, i.n), b\"\"))\n             tx.wit.vtxinwit.append(CTxInWitness())\n-            sign_P2PK_witness_input(witness_program, tx, index, SIGHASH_ALL|SIGHASH_ANYONECANPAY, i.nValue, key)\n+            sign_p2pk_witness_input(witness_program, tx, index, SIGHASH_ALL | SIGHASH_ANYONECANPAY, i.nValue, key)\n             index += 1\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx])\n@@ -1453,7 +1504,6 @@ def test_signature_version_1(self):\n         for i in range(len(tx.vout)):\n             self.utxo.append(UTXO(tx.sha256, i, tx.vout[i].nValue))\n \n-\n     # Test P2SH wrapped witness programs.\n     def test_p2sh_witness(self, segwit_activated):\n         self.log.info(\"Testing P2SH witness transactions\")\n@@ -1465,13 +1515,13 @@ def test_p2sh_witness(self, segwit_activated):\n         witness_hash = sha256(witness_program)\n         p2wsh_pubkey = CScript([OP_0, witness_hash])\n         p2sh_witness_hash = hash160(p2wsh_pubkey)\n-        scriptPubKey = CScript([OP_HASH160, p2sh_witness_hash, OP_EQUAL])\n-        scriptSig = CScript([p2wsh_pubkey]) # a push of the redeem script\n+        script_pubkey = CScript([OP_HASH160, p2sh_witness_hash, OP_EQUAL])\n+        script_sig = CScript([p2wsh_pubkey])  # a push of the redeem script\n \n         # Fund the P2SH output\n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n-        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, scriptPubKey))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue - 1000, script_pubkey))\n         tx.rehash()\n \n         # Verify mempool acceptance and block validity\n@@ -1483,8 +1533,8 @@ def test_p2sh_witness(self, segwit_activated):\n \n         # Now test attempts to spend the output.\n         spend_tx = CTransaction()\n-        spend_tx.vin.append(CTxIn(COutPoint(tx.sha256, 0), scriptSig))\n-        spend_tx.vout.append(CTxOut(tx.vout[0].nValue-1000, CScript([OP_TRUE])))\n+        spend_tx.vin.append(CTxIn(COutPoint(tx.sha256, 0), script_sig))\n+        spend_tx.vout.append(CTxOut(tx.vout[0].nValue - 1000, CScript([OP_TRUE])))\n         spend_tx.rehash()\n \n         # This transaction should not be accepted into the mempool pre- or\n@@ -1494,17 +1544,17 @@ def test_p2sh_witness(self, segwit_activated):\n         # segwit-aware would also reject this for failing CLEANSTACK.\n         test_transaction_acceptance(self.nodes[0].rpc, self.test_node, spend_tx, with_witness=False, accepted=False)\n \n-        # Try to put the witness script in the scriptSig, should also fail.\n-        spend_tx.vin[0].scriptSig = CScript([p2wsh_pubkey, b'a'])\n+        # Try to put the witness script in the script_sig, should also fail.\n+        spend_tx.vin[0].script_sig = CScript([p2wsh_pubkey, b'a'])\n         spend_tx.rehash()\n         test_transaction_acceptance(self.nodes[0].rpc, self.test_node, spend_tx, with_witness=False, accepted=False)\n \n         # Now put the witness script in the witness, should succeed after\n         # segwit activates.\n-        spend_tx.vin[0].scriptSig = scriptSig\n+        spend_tx.vin[0].scriptSig = script_sig\n         spend_tx.rehash()\n         spend_tx.wit.vtxinwit.append(CTxInWitness())\n-        spend_tx.wit.vtxinwit[0].scriptWitness.stack = [ b'a', witness_program ]\n+        spend_tx.wit.vtxinwit[0].scriptWitness.stack = [b'a', witness_program]\n \n         # Verify mempool acceptance\n         test_transaction_acceptance(self.nodes[0].rpc, self.test_node, spend_tx, with_witness=True, accepted=segwit_activated)\n@@ -1532,7 +1582,7 @@ def test_p2sh_witness(self, segwit_activated):\n     def test_upgrade_after_activation(self, node_id):\n         self.log.info(\"Testing software upgrade after softfork activation\")\n \n-        assert(node_id != 0) # node0 is assumed to be a segwit-active bitcoind\n+        assert(node_id != 0)  # node0 is assumed to be a segwit-active bitcoind\n \n         # Make sure the nodes are all up\n         sync_blocks(self.nodes)\n@@ -1555,49 +1605,48 @@ def test_upgrade_after_activation(self, node_id):\n             assert_equal(self.nodes[0].getblock(block_hash), self.nodes[node_id].getblock(block_hash))\n             height -= 1\n \n-\n     def test_witness_sigops(self):\n         '''Ensure sigop counting is correct inside witnesses.'''\n         self.log.info(\"Testing sigops limit\")\n \n         assert(len(self.utxo))\n \n         # Keep this under MAX_OPS_PER_SCRIPT (201)\n-        witness_program = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKMULTISIG]*5 + [OP_CHECKSIG]*193 + [OP_ENDIF])\n+        witness_program = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKMULTISIG] * 5 + [OP_CHECKSIG] * 193 + [OP_ENDIF])\n         witness_hash = sha256(witness_program)\n-        scriptPubKey = CScript([OP_0, witness_hash])\n+        script_pubkey = CScript([OP_0, witness_hash])\n \n-        sigops_per_script = 20*5 + 193*1\n+        sigops_per_script = 20 * 5 + 193 * 1\n         # We'll produce 2 extra outputs, one with a program that would take us\n         # over max sig ops, and one with a program that would exactly reach max\n         # sig ops\n         outputs = (MAX_SIGOP_COST // sigops_per_script) + 2\n         extra_sigops_available = MAX_SIGOP_COST % sigops_per_script\n \n         # We chose the number of checkmultisigs/checksigs to make this work:\n-        assert(extra_sigops_available < 100) # steer clear of MAX_OPS_PER_SCRIPT\n+        assert(extra_sigops_available < 100)  # steer clear of MAX_OPS_PER_SCRIPT\n \n         # This script, when spent with the first\n         # N(=MAX_SIGOP_COST//sigops_per_script) outputs of our transaction,\n         # would push us just over the block sigop limit.\n-        witness_program_toomany = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKSIG]*(extra_sigops_available + 1) + [OP_ENDIF])\n+        witness_program_toomany = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKSIG] * (extra_sigops_available + 1) + [OP_ENDIF])\n         witness_hash_toomany = sha256(witness_program_toomany)\n-        scriptPubKey_toomany = CScript([OP_0, witness_hash_toomany])\n+        script_pubkey_toomany = CScript([OP_0, witness_hash_toomany])\n \n         # If we spend this script instead, we would exactly reach our sigop\n         # limit (for witness sigops).\n-        witness_program_justright = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKSIG]*(extra_sigops_available) + [OP_ENDIF])\n+        witness_program_justright = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKSIG] * (extra_sigops_available) + [OP_ENDIF])\n         witness_hash_justright = sha256(witness_program_justright)\n-        scriptPubKey_justright = CScript([OP_0, witness_hash_justright])\n+        script_pubkey_justright = CScript([OP_0, witness_hash_justright])\n \n         # First split our available utxo into a bunch of outputs\n         split_value = self.utxo[0].nValue // outputs\n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n         for i in range(outputs):\n-            tx.vout.append(CTxOut(split_value, scriptPubKey))\n-        tx.vout[-2].scriptPubKey = scriptPubKey_toomany\n-        tx.vout[-1].scriptPubKey = scriptPubKey_justright\n+            tx.vout.append(CTxOut(split_value, script_pubkey))\n+        tx.vout[-2].scriptPubKey = script_pubkey_toomany\n+        tx.vout[-1].scriptPubKey = script_pubkey_justright\n         tx.rehash()\n \n         block_1 = self.build_next_block()\n@@ -1608,12 +1657,12 @@ def test_witness_sigops(self):\n         # If we try to spend the first n-1 outputs from tx, that should be\n         # too many sigops.\n         total_value = 0\n-        for i in range(outputs-1):\n+        for i in range(outputs - 1):\n             tx2.vin.append(CTxIn(COutPoint(tx.sha256, i), b\"\"))\n             tx2.wit.vtxinwit.append(CTxInWitness())\n-            tx2.wit.vtxinwit[-1].scriptWitness.stack = [ witness_program ]\n+            tx2.wit.vtxinwit[-1].scriptWitness.stack = [witness_program]\n             total_value += tx.vout[i].nValue\n-        tx2.wit.vtxinwit[-1].scriptWitness.stack = [ witness_program_toomany ]\n+        tx2.wit.vtxinwit[-1].scriptWitness.stack = [witness_program_toomany]\n         tx2.vout.append(CTxOut(total_value, CScript([OP_TRUE])))\n         tx2.rehash()\n \n@@ -1624,8 +1673,8 @@ def test_witness_sigops(self):\n         # Try dropping the last input in tx2, and add an output that has\n         # too many sigops (contributing to legacy sigop count).\n         checksig_count = (extra_sigops_available // 4) + 1\n-        scriptPubKey_checksigs = CScript([OP_CHECKSIG]*checksig_count)\n-        tx2.vout.append(CTxOut(0, scriptPubKey_checksigs))\n+        script_pubkey_checksigs = CScript([OP_CHECKSIG] * checksig_count)\n+        tx2.vout.append(CTxOut(0, script_pubkey_checksigs))\n         tx2.vin.pop()\n         tx2.wit.vtxinwit.pop()\n         tx2.vout[0].nValue -= tx.vout[-2].nValue\n@@ -1636,7 +1685,7 @@ def test_witness_sigops(self):\n \n         # If we drop the last checksig in this output, the tx should succeed.\n         block_4 = self.build_next_block()\n-        tx2.vout[-1].scriptPubKey = CScript([OP_CHECKSIG]*(checksig_count-1))\n+        tx2.vout[-1].scriptPubKey = CScript([OP_CHECKSIG] * (checksig_count - 1))\n         tx2.rehash()\n         self.update_witness_block_with_transactions(block_4, [tx2])\n         test_witness_block(self.nodes[0].rpc, self.test_node, block_4, accepted=True)\n@@ -1650,9 +1699,9 @@ def test_witness_sigops(self):\n         # output of tx\n         block_5 = self.build_next_block()\n         tx2.vout.pop()\n-        tx2.vin.append(CTxIn(COutPoint(tx.sha256, outputs-1), b\"\"))\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, outputs - 1), b\"\"))\n         tx2.wit.vtxinwit.append(CTxInWitness())\n-        tx2.wit.vtxinwit[-1].scriptWitness.stack = [ witness_program_justright ]\n+        tx2.wit.vtxinwit[-1].scriptWitness.stack = [witness_program_justright]\n         tx2.rehash()\n         self.update_witness_block_with_transactions(block_5, [tx2])\n         test_witness_block(self.nodes[0].rpc, self.test_node, block_5, accepted=True)\n@@ -1678,11 +1727,11 @@ def test_getblocktemplate_before_lockin(self):\n         txid = int(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1), 16)\n         # Using mocktime lets us avoid sleep()\n         sync_mempools(self.nodes)\n-        self.nodes[0].setmocktime(int(time.time())+10)\n-        self.nodes[2].setmocktime(int(time.time())+10)\n+        self.nodes[0].setmocktime(int(time.time()) + 10)\n+        self.nodes[2].setmocktime(int(time.time()) + 10)\n \n         for node in [self.nodes[0], self.nodes[2]]:\n-            gbt_results = node.getblocktemplate({\"rules\" : [\"segwit\"]})\n+            gbt_results = node.getblocktemplate({\"rules\": [\"segwit\"]})\n             block_version = gbt_results['version']\n             if node == self.nodes[2]:\n                 # If this is a non-segwit node, we should still not get a witness\n@@ -1716,18 +1765,18 @@ def test_uncompressed_pubkey(self):\n         key.set_secretbytes(b\"9\")\n         key.set_compressed(False)\n         pubkey = CPubKey(key.get_pubkey())\n-        assert_equal(len(pubkey), 65) # This should be an uncompressed pubkey\n+        assert_equal(len(pubkey), 65)  # This should be an uncompressed pubkey\n \n         assert(len(self.utxo) > 0)\n         utxo = self.utxo.pop(0)\n \n         # Test 1: P2WPKH\n         # First create a P2WPKH output that uses an uncompressed pubkey\n         pubkeyhash = hash160(pubkey)\n-        scriptPKH = CScript([OP_0, pubkeyhash])\n+        script_pkh = CScript([OP_0, pubkeyhash])\n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(utxo.sha256, utxo.n), b\"\"))\n-        tx.vout.append(CTxOut(utxo.nValue-1000, scriptPKH))\n+        tx.vout.append(CTxOut(utxo.nValue - 1000, script_pkh))\n         tx.rehash()\n \n         # Confirm it in a block.\n@@ -1739,16 +1788,16 @@ def test_uncompressed_pubkey(self):\n         # use in the next test.\n         witness_program = CScript([pubkey, CScriptOp(OP_CHECKSIG)])\n         witness_hash = sha256(witness_program)\n-        scriptWSH = CScript([OP_0, witness_hash])\n+        script_wsh = CScript([OP_0, witness_hash])\n \n         tx2 = CTransaction()\n         tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n-        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, scriptWSH))\n-        script = GetP2PKHScript(pubkeyhash)\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue - 1000, script_wsh))\n+        script = get_p2pkh_script(pubkeyhash)\n         sig_hash = SegwitVersion1SignatureHash(script, tx2, 0, SIGHASH_ALL, tx.vout[0].nValue)\n-        signature = key.sign(sig_hash) + b'\\x01' # 0x1 is SIGHASH_ALL\n+        signature = key.sign(sig_hash) + b'\\x01'  # 0x1 is SIGHASH_ALL\n         tx2.wit.vtxinwit.append(CTxInWitness())\n-        tx2.wit.vtxinwit[0].scriptWitness.stack = [ signature, pubkey ]\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [signature, pubkey]\n         tx2.rehash()\n \n         # Should fail policy test.\n@@ -1761,15 +1810,15 @@ def test_uncompressed_pubkey(self):\n         # Test 2: P2WSH\n         # Try to spend the P2WSH output created in last test.\n         # Send it to a P2SH(P2WSH) output, which we'll use in the next test.\n-        p2sh_witness_hash = hash160(scriptWSH)\n-        scriptP2SH = CScript([OP_HASH160, p2sh_witness_hash, OP_EQUAL])\n-        scriptSig = CScript([scriptWSH])\n+        p2sh_witness_hash = hash160(script_wsh)\n+        script_p2sh = CScript([OP_HASH160, p2sh_witness_hash, OP_EQUAL])\n+        script_sig = CScript([script_wsh])\n \n         tx3 = CTransaction()\n         tx3.vin.append(CTxIn(COutPoint(tx2.sha256, 0), b\"\"))\n-        tx3.vout.append(CTxOut(tx2.vout[0].nValue-1000, scriptP2SH))\n+        tx3.vout.append(CTxOut(tx2.vout[0].nValue - 1000, script_p2sh))\n         tx3.wit.vtxinwit.append(CTxInWitness())\n-        sign_P2PK_witness_input(witness_program, tx3, 0, SIGHASH_ALL, tx2.vout[0].nValue, key)\n+        sign_p2pk_witness_input(witness_program, tx3, 0, SIGHASH_ALL, tx2.vout[0].nValue, key)\n \n         # Should fail policy test.\n         test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx3, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n@@ -1781,12 +1830,12 @@ def test_uncompressed_pubkey(self):\n         # Test 3: P2SH(P2WSH)\n         # Try to spend the P2SH output created in the last test.\n         # Send it to a P2PKH output, which we'll use in the next test.\n-        scriptPubKey = GetP2PKHScript(pubkeyhash)\n+        script_pubkey = get_p2pkh_script(pubkeyhash)\n         tx4 = CTransaction()\n-        tx4.vin.append(CTxIn(COutPoint(tx3.sha256, 0), scriptSig))\n-        tx4.vout.append(CTxOut(tx3.vout[0].nValue-1000, scriptPubKey))\n+        tx4.vin.append(CTxIn(COutPoint(tx3.sha256, 0), script_sig))\n+        tx4.vout.append(CTxOut(tx3.vout[0].nValue - 1000, script_pubkey))\n         tx4.wit.vtxinwit.append(CTxInWitness())\n-        sign_P2PK_witness_input(witness_program, tx4, 0, SIGHASH_ALL, tx3.vout[0].nValue, key)\n+        sign_p2pk_witness_input(witness_program, tx4, 0, SIGHASH_ALL, tx3.vout[0].nValue, key)\n \n         # Should fail policy test.\n         test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx4, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n@@ -1798,9 +1847,9 @@ def test_uncompressed_pubkey(self):\n         # transactions.\n         tx5 = CTransaction()\n         tx5.vin.append(CTxIn(COutPoint(tx4.sha256, 0), b\"\"))\n-        tx5.vout.append(CTxOut(tx4.vout[0].nValue-1000, CScript([OP_TRUE])))\n-        (sig_hash, err) = SignatureHash(scriptPubKey, tx5, 0, SIGHASH_ALL)\n-        signature = key.sign(sig_hash) + b'\\x01' # 0x1 is SIGHASH_ALL\n+        tx5.vout.append(CTxOut(tx4.vout[0].nValue - 1000, CScript([OP_TRUE])))\n+        (sig_hash, err) = SignatureHash(script_pubkey, tx5, 0, SIGHASH_ALL)\n+        signature = key.sign(sig_hash) + b'\\x01'  # 0x1 is SIGHASH_ALL\n         tx5.vin[0].scriptSig = CScript([signature, pubkey])\n         tx5.rehash()\n         # Should pass policy and consensus.\n@@ -1819,13 +1868,13 @@ def test_non_standard_witness_blinding(self):\n         # in P2SH).\n         p2sh_program = CScript([OP_TRUE])\n         p2sh_pubkey = hash160(p2sh_program)\n-        scriptPubKey = CScript([OP_HASH160, p2sh_pubkey, OP_EQUAL])\n+        script_pubkey = CScript([OP_HASH160, p2sh_pubkey, OP_EQUAL])\n \n         # Now check that unnecessary witnesses can't be used to blind a node\n         # to a transaction, eg by violating standardness checks.\n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n-        tx.vout.append(CTxOut(self.utxo[0].nValue - 1000, scriptPubKey))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue - 1000, script_pubkey))\n         tx.rehash()\n         test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, False, True)\n         self.nodes[0].generate(1)\n@@ -1838,7 +1887,7 @@ def test_non_standard_witness_blinding(self):\n         # to the rejection cache.\n         tx2 = CTransaction()\n         tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), CScript([p2sh_program])))\n-        tx2.vout.append(CTxOut(tx.vout[0].nValue - 1000, scriptPubKey))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue - 1000, script_pubkey))\n         tx2.wit.vtxinwit.append(CTxInWitness())\n         tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a' * 400]\n         tx2.rehash()\n@@ -1901,13 +1950,13 @@ def test_non_standard_witness(self):\n         p2sh_txs = []\n         for i in range(len(scripts)):\n             p2wsh_tx = CTransaction()\n-            p2wsh_tx.vin.append(CTxIn(COutPoint(txid,i*2)))\n+            p2wsh_tx.vin.append(CTxIn(COutPoint(txid, i * 2)))\n             p2wsh_tx.vout.append(CTxOut(outputvalue - 5000, CScript([OP_0, hash160(hex_str_to_bytes(\"\"))])))\n             p2wsh_tx.wit.vtxinwit.append(CTxInWitness())\n             p2wsh_tx.rehash()\n             p2wsh_txs.append(p2wsh_tx)\n             p2sh_tx = CTransaction()\n-            p2sh_tx.vin.append(CTxIn(COutPoint(txid,i*2+1), CScript([p2wsh_scripts[i]])))\n+            p2sh_tx.vin.append(CTxIn(COutPoint(txid, i * 2 + 1), CScript([p2wsh_scripts[i]])))\n             p2sh_tx.vout.append(CTxOut(outputvalue - 5000, CScript([OP_0, hash160(hex_str_to_bytes(\"\"))])))\n             p2sh_tx.wit.vtxinwit.append(CTxInWitness())\n             p2sh_tx.rehash()\n@@ -1967,11 +2016,11 @@ def test_non_standard_witness(self):\n     def run_test(self):\n         # Setup the p2p connections\n         # self.test_node sets NODE_WITNESS|NODE_NETWORK\n-        self.test_node = self.nodes[0].add_p2p_connection(TestP2PConn(), services=NODE_NETWORK|NODE_WITNESS)\n+        self.test_node = self.nodes[0].add_p2p_connection(TestP2PConn(), services=NODE_NETWORK | NODE_WITNESS)\n         # self.old_node sets only NODE_NETWORK\n         self.old_node = self.nodes[0].add_p2p_connection(TestP2PConn(), services=NODE_NETWORK)\n         # self.std_node is for testing node1 (fRequireStandard=true)\n-        self.std_node = self.nodes[1].add_p2p_connection(TestP2PConn(), services=NODE_NETWORK|NODE_WITNESS)\n+        self.std_node = self.nodes[1].add_p2p_connection(TestP2PConn(), services=NODE_NETWORK | NODE_WITNESS)\n \n         # Keep a place to store utxo's that can be used in later tests\n         self.utxo = []\n@@ -1981,8 +2030,8 @@ def run_test(self):\n \n         self.log.info(\"Starting tests before segwit lock in:\")\n \n-        self.test_witness_services() # Verifies NODE_WITNESS\n-        self.test_non_witness_transaction() # non-witness tx's are accepted\n+        self.test_witness_services()  # Verifies NODE_WITNESS\n+        self.test_non_witness_transaction()  # non-witness tx's are accepted\n         self.test_unnecessary_witness_before_segwit_activation()\n         self.test_v0_outputs_arent_spendable()\n         self.test_block_relay(segwit_activated=False)\n@@ -2035,6 +2084,5 @@ def run_test(self):\n         self.test_upgrade_after_activation(node_id=2)\n         self.test_witness_sigops()\n \n-\n if __name__ == '__main__':\n     SegWitTest().main()"
      }
    ]
  },
  {
    "sha": "94a0134a40aebac146e8ebe9a3094321d8b1c7da",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NGEwMTM0YTQwYWViYWMxNDZlOGViZTlhMzA5NDMyMWQ4YjFjN2Rh",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-06-13T18:16:28Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-06-29T19:32:52Z"
      },
      "message": "[tests] p2p_segwit: standardise comments/docstrings.",
      "tree": {
        "sha": "595d98eb867dc3fc80da22a324e2b460c21d2837",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/595d98eb867dc3fc80da22a324e2b460c21d2837"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/94a0134a40aebac146e8ebe9a3094321d8b1c7da",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/94a0134a40aebac146e8ebe9a3094321d8b1c7da",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/94a0134a40aebac146e8ebe9a3094321d8b1c7da",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/94a0134a40aebac146e8ebe9a3094321d8b1c7da/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f7c7f8ecf3a2fbfdf1b24bbcacd23f9d21737d40",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f7c7f8ecf3a2fbfdf1b24bbcacd23f9d21737d40",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f7c7f8ecf3a2fbfdf1b24bbcacd23f9d21737d40"
      }
    ],
    "stats": {
      "total": 125,
      "additions": 71,
      "deletions": 54
    },
    "files": [
      {
        "sha": "6b19adde76e6a488e6ff97e12edb4baabdeeaa68",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 71,
        "deletions": 54,
        "changes": 125,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/94a0134a40aebac146e8ebe9a3094321d8b1c7da/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/94a0134a40aebac146e8ebe9a3094321d8b1c7da/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=94a0134a40aebac146e8ebe9a3094321d8b1c7da",
        "patch": "@@ -90,9 +90,10 @@\n MAX_SIGOP_COST = 80000\n \n \n-# Calculate the virtual size of a witness block:\n-# (base + witness/4)\n def get_virtual_size(witness_block):\n+    \"\"\"Calculate the virtual size of a witness block.\n+\n+    Virtual size is base + witness/4.\"\"\"\n     base_size = len(witness_block.serialize(with_witness=False))\n     total_size = len(witness_block.serialize(with_witness=True))\n     # the \"+3\" is so we round up\n@@ -171,25 +172,24 @@ def request_block(self, blockhash, inv_type, timeout=60):\n         self.wait_for_block(blockhash, timeout)\n         return self.last_message[\"block\"].block\n \n-# Used to keep track of anyone-can-spend outputs that we can use in the tests\n class UTXO():\n+    \"\"\"Used to keep track of anyone-can-spend outputs that we can use in the tests.\"\"\"\n     def __init__(self, sha256, n, value):\n         self.sha256 = sha256\n         self.n = n\n         self.nValue = value\n \n-# Helper for getting the script associated with a P2PKH\n def get_p2pkh_script(pubkeyhash):\n+    \"\"\"Get the script associated with a P2PKH.\"\"\"\n     return CScript([CScriptOp(OP_DUP), CScriptOp(OP_HASH160), pubkeyhash, CScriptOp(OP_EQUALVERIFY), CScriptOp(OP_CHECKSIG)])\n \n-# Add signature for a P2PK witness program.\n def sign_p2pk_witness_input(script, tx_to, in_idx, hashtype, value, key):\n+    \"\"\"Add signature for a P2PK witness program.\"\"\"\n     tx_hash = SegwitVersion1SignatureHash(script, tx_to, in_idx, hashtype, value)\n     signature = key.sign(tx_hash) + chr(hashtype).encode('latin-1')\n     tx_to.wit.vtxinwit[in_idx].scriptWitness.stack = [signature, script]\n     tx_to.rehash()\n \n-\n class SegWitTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.setup_clean_chain = True\n@@ -203,9 +203,10 @@ def setup_network(self):\n         connect_nodes(self.nodes[0], 2)\n         self.sync_all()\n \n-    ''' Helpers '''\n-    # Build a block on top of node0's tip.\n+    # Helper functions\n+\n     def build_next_block(self, version=4):\n+        \"\"\"Build a block on top of node0's tip.\"\"\"\n         tip = self.nodes[0].getbestblockhash()\n         height = self.nodes[0].getblockcount() + 1\n         block_time = self.nodes[0].getblockheader(tip)[\"mediantime\"] + 1\n@@ -214,21 +215,21 @@ def build_next_block(self, version=4):\n         block.rehash()\n         return block\n \n-    # Adds list of transactions to block, adds witness commitment, then solves.\n     def update_witness_block_with_transactions(self, block, tx_list, nonce=0):\n+        \"\"\"Add list of transactions to block, adds witness commitment, then solves.\"\"\"\n         block.vtx.extend(tx_list)\n         add_witness_commitment(block, nonce)\n         block.solve()\n         return\n \n-    ''' Individual tests '''\n+    # Individual tests\n+\n     def test_witness_services(self):\n         self.log.info(\"Verifying NODE_WITNESS service bit\")\n         assert((self.test_node.nServices & NODE_WITNESS) != 0)\n \n-    # See if sending a regular transaction works, and create a utxo\n-    # to use in later tests.\n     def test_non_witness_transaction(self):\n+        \"\"\"See if sending a regular transaction works, and create a utxo to use in later tests.\"\"\"\n         # Mine a block with an anyone-can-spend coinbase,\n         # let it mature, then try to spend it.\n         self.log.info(\"Testing non-witness transaction\")\n@@ -257,8 +258,8 @@ def test_non_witness_transaction(self):\n         self.utxo.append(UTXO(tx.sha256, 0, 49 * 100000000))\n         self.nodes[0].generate(1)\n \n-    # Verify that blocks with witnesses are rejected before activation.\n     def test_unnecessary_witness_before_segwit_activation(self):\n+        \"\"\"Verify that blocks with witnesses are rejected before activation.\"\"\"\n         self.log.info(\"Testing behavior of unnecessary witnesses\")\n         # For now, rely on earlier tests to have created at least one utxo for\n         # us to use\n@@ -299,14 +300,17 @@ def test_unnecessary_witness_before_segwit_activation(self):\n         self.utxo.pop(0)\n         self.utxo.append(UTXO(tx.sha256, 0, tx.vout[0].nValue))\n \n-    # ~6 months after segwit activation, the SCRIPT_VERIFY_WITNESS flag was\n-    # backdated so that it applies to all blocks, going back to the genesis\n-    # block.\n-    #\n-    # Consequently, version 0 witness outputs are never spendable without\n-    # witness, and so can't be spent before segwit activation (the point at which\n-    # blocks are permitted to contain witnesses).\n     def test_v0_outputs_arent_spendable(self):\n+        \"\"\"Test that v0 outputs aren't spendable before segwit activation.\n+\n+        ~6 months after segwit activation, the SCRIPT_VERIFY_WITNESS flag was\n+        backdated so that it applies to all blocks, going back to the genesis\n+        block.\n+\n+        Consequently, version 0 witness outputs are never spendable without\n+        witness, and so can't be spent before segwit activation (the point at which\n+        blocks are permitted to contain witnesses).\"\"\"\n+\n         self.log.info(\"Testing that v0 witness program outputs aren't spendable before activation\")\n \n         assert len(self.utxo), \"self.utxo is empty\"\n@@ -374,8 +378,8 @@ def test_v0_outputs_arent_spendable(self):\n         self.utxo.pop(0)\n         self.utxo.append(UTXO(txid, 2, value))\n \n-    # Mine enough blocks for segwit's vb state to be 'started'.\n     def advance_to_segwit_started(self):\n+        \"\"\"Mine enough blocks for segwit's vb state to be 'started'.\"\"\"\n         height = self.nodes[0].getblockcount()\n         # Will need to rewrite the tests here if we are past the first period\n         assert(height < VB_PERIOD - 1)\n@@ -385,10 +389,11 @@ def advance_to_segwit_started(self):\n         self.nodes[0].generate(VB_PERIOD - height - 1)\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'started')\n \n-    # Mine enough blocks to lock in segwit, but don't activate.\n-    # TODO: we could verify that lockin only happens at the right threshold of\n-    # signalling blocks, rather than just at the right period boundary.\n     def advance_to_segwit_lockin(self):\n+        \"\"\"Mine enough blocks to lock in segwit, but don't activate.\"\"\"\n+        # TODO: we could verify that lockin only happens at the right threshold of\n+        # signalling blocks, rather than just at the right period boundary.\n+\n         height = self.nodes[0].getblockcount()\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'started')\n         # Advance to end of period, and verify lock-in happens at the end\n@@ -399,19 +404,23 @@ def advance_to_segwit_lockin(self):\n         self.nodes[0].generate(1)\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'locked_in')\n \n-    # Mine enough blocks to activate segwit.\n-    # TODO: we could verify that activation only happens at the right threshold\n-    # of signalling blocks, rather than just at the right period boundary.\n     def advance_to_segwit_active(self):\n+        \"\"\"Mine enough blocks to activate segwit.\"\"\"\n+        # TODO: we could verify that activation only happens at the right threshold\n+        # of signalling blocks, rather than just at the right period boundary.\n+\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'locked_in')\n         height = self.nodes[0].getblockcount()\n         self.nodes[0].generate(VB_PERIOD - (height % VB_PERIOD) - 2)\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'locked_in')\n         self.nodes[0].generate(1)\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'active')\n \n-    # This test can only be run after segwit has activated\n     def test_witness_commitments(self):\n+        \"\"\"Test witness commitments.\n+\n+        This test can only be run after segwit has activated.\"\"\"\n+\n         self.log.info(\"Testing witness commitments\")\n \n         # First try a correct witness commitment.\n@@ -617,9 +626,8 @@ def test_witness_block_size(self):\n         self.utxo.pop(0)\n         self.utxo.append(UTXO(block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue))\n \n-    # submitblock will try to add the nonce automatically, so that mining\n-    # software doesn't need to worry about doing so itself.\n     def test_submit_block(self):\n+        \"\"\"Test that submitblock adds the nonce automatically when possible.\"\"\"\n         block = self.build_next_block()\n \n         # Try using a custom nonce and then don't supply it.\n@@ -653,8 +661,8 @@ def test_submit_block(self):\n         # Tip should not advance!\n         assert(self.nodes[0].getbestblockhash() != block_2.hash)\n \n-    # Consensus tests of extra witness data in a transaction.\n     def test_extra_witness_data(self):\n+        \"\"\"Test extra witness data in a transaction.\"\"\"\n         self.log.info(\"Testing extra witness data in tx\")\n \n         assert(len(self.utxo) > 0)\n@@ -729,7 +737,7 @@ def test_extra_witness_data(self):\n         self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n \n     def test_max_witness_push_length(self):\n-        ''' Should only allow up to 520 byte pushes in witness stack '''\n+        \"\"\"Test that witness stack can only allow up to 520 byte pushes.\"\"\"\n         self.log.info(\"Testing maximum witness push size\")\n         MAX_SCRIPT_ELEMENT_SIZE = 520\n         assert(len(self.utxo))\n@@ -768,8 +776,7 @@ def test_max_witness_push_length(self):\n         self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n \n     def test_max_witness_program_length(self):\n-        # Can create witness outputs that are long, but can't be greater than\n-        # 10k bytes to successfully spend\n+        \"\"\"Test that witness outputs greater than 10kB can't be spent.\"\"\"\n         self.log.info(\"Testing maximum witness program length\")\n         assert(len(self.utxo))\n         MAX_PROGRAM_LENGTH = 10000\n@@ -817,7 +824,7 @@ def test_max_witness_program_length(self):\n         self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n \n     def test_witness_input_length(self):\n-        ''' Ensure that vin length must match vtxinwit length '''\n+        \"\"\"Test that vin length must match vtxinwit length.\"\"\"\n         self.log.info(\"Testing witness input length\")\n         assert(len(self.utxo))\n \n@@ -941,11 +948,14 @@ def test_witness_tx_relay_before_segwit_activation(self):\n         self.utxo.pop(0)\n         self.utxo.append(UTXO(tx_hash, 0, tx_value))\n \n-    # After segwit activates, verify that mempool:\n-    # - rejects transactions with unnecessary/extra witnesses\n-    # - accepts transactions with valid witnesses\n-    # and that witness transactions are relayed to non-upgraded peers.\n     def test_tx_relay_after_segwit_activation(self):\n+        \"\"\"Test transaction relay after segwit activation.\n+\n+        After segwit activates, verify that mempool:\n+        - rejects transactions with unnecessary/extra witnesses\n+        - accepts transactions with valid witnesses\n+        and that witness transactions are relayed to non-upgraded peers.\"\"\"\n+\n         self.log.info(\"Testing relay of witness transactions\")\n         # Generate a transaction that doesn't require a witness, but send it\n         # with a witness.  Should be rejected because we can't use a witness\n@@ -1032,10 +1042,11 @@ def test_tx_relay_after_segwit_activation(self):\n         self.utxo.pop(0)\n         self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n \n-    # Test that block requests to NODE_WITNESS peer are with MSG_WITNESS_FLAG\n-    # This is true regardless of segwit activation.\n-    # Also test that we don't ask for blocks from unupgraded peers\n     def test_block_relay(self, segwit_activated):\n+        \"\"\"Test that block requests to NODE_WITNESS peer are with MSG_WITNESS_FLAG.\n+\n+        This is true regardless of segwit activation.\n+        Also test that we don't ask for blocks from unupgraded peers.\"\"\"\n         self.log.info(\"Testing block relay\")\n \n         blocktype = 2 | MSG_WITNESS_FLAG\n@@ -1127,8 +1138,12 @@ def test_block_relay(self, segwit_activated):\n             self.old_node.announce_tx_and_wait_for_getdata(block4.vtx[0])\n             assert(block4.sha256 not in self.old_node.getdataset)\n \n-    # V0 segwit outputs and inputs are always standard. V0 segwit inputs may only be mined after activation, but not before.\n     def test_standardness_v0(self, segwit_activated):\n+        \"\"\"Test V0 txout standardness.\n+        \n+        V0 segwit outputs and inputs are always standard.\n+        V0 segwit inputs may only be mined after activation, but not before.\"\"\"\n+\n         self.log.info(\"Testing standardness of v0 outputs (%s activation)\" % (\"after\" if segwit_activated else \"before\"))\n         assert(len(self.utxo))\n \n@@ -1203,9 +1218,12 @@ def test_standardness_v0(self, segwit_activated):\n         self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n         assert_equal(len(self.nodes[1].getrawmempool()), 0)\n \n-    # Verify that future segwit upgraded transactions are non-standard,\n-    # but valid in blocks. Can run this before and after segwit activation.\n     def test_segwit_versions(self):\n+        \"\"\"Test validity of future segwit version transactions.\n+        \n+        Future segwit version transactions are non-standard, but valid in blocks.\n+        Can run this before and after segwit activation.\"\"\"\n+\n         self.log.info(\"Testing standardness/consensus for segwit versions (0-16)\")\n         assert(len(self.utxo))\n         num_tests = 17  # will test OP_0, OP1, ..., OP_16\n@@ -1504,8 +1522,8 @@ def test_signature_version_1(self):\n         for i in range(len(tx.vout)):\n             self.utxo.append(UTXO(tx.sha256, i, tx.vout[i].nValue))\n \n-    # Test P2SH wrapped witness programs.\n     def test_p2sh_witness(self, segwit_activated):\n+        \"\"\"Test P2SH wrapped witness programs.\"\"\"\n         self.log.info(\"Testing P2SH witness transactions\")\n \n         assert(len(self.utxo))\n@@ -1574,12 +1592,8 @@ def test_p2sh_witness(self, segwit_activated):\n         self.utxo.pop(0)\n         self.utxo.append(UTXO(spend_tx.sha256, 0, spend_tx.vout[0].nValue))\n \n-    # Test the behavior of starting up a segwit-aware node after the softfork\n-    # has activated.  As segwit requires different block data than pre-segwit\n-    # nodes would have stored, this requires special handling.\n-    # To enable this test, pass --oldbinary=<path-to-pre-segwit-bitcoind> to\n-    # the test.\n     def test_upgrade_after_activation(self, node_id):\n+        \"\"\"Test the behavior of starting up a segwit-aware node after the softfork has activated.\"\"\"\n         self.log.info(\"Testing software upgrade after softfork activation\")\n \n         assert(node_id != 0)  # node0 is assumed to be a segwit-active bitcoind\n@@ -1606,7 +1620,7 @@ def test_upgrade_after_activation(self, node_id):\n             height -= 1\n \n     def test_witness_sigops(self):\n-        '''Ensure sigop counting is correct inside witnesses.'''\n+        \"\"\"Test sigop counting is correct inside witnesses.\"\"\"\n         self.log.info(\"Testing sigops limit\")\n \n         assert(len(self.utxo))\n@@ -1755,9 +1769,12 @@ def test_getblocktemplate_before_lockin(self):\n         self.nodes[0].setmocktime(0)\n         self.nodes[2].setmocktime(0)\n \n-    # Uncompressed pubkeys are no longer supported in default relay policy,\n-    # but (for now) are still valid in blocks.\n     def test_uncompressed_pubkey(self):\n+        \"\"\"Test uncompressed pubkey validity in segwit transactions.\n+\n+        Uncompressed pubkeys are no longer supported in default relay policy,\n+        but (for now) are still valid in blocks.\"\"\"\n+\n         self.log.info(\"Testing uncompressed pubkeys\")\n         # Segwit transactions using uncompressed pubkeys are not accepted\n         # under default policy, but should still pass consensus."
      }
    ]
  },
  {
    "sha": "2af4e398dc7cd7529a43d8832621dfb40b467eb9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyYWY0ZTM5OGRjN2NkNzUyOWE0M2Q4ODMyNjIxZGZiNDBiNDY3ZWI5",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-06-13T18:26:25Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-06-29T19:34:22Z"
      },
      "message": "[tests] p2p_segwit: re-order function definitions.\n\nThis re-orders the defintions in p2p_segwit so subtests are\ndefined in the order that they're called.",
      "tree": {
        "sha": "8293701ca1f6a6484e1b48ea4fce5df686b5dfa5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8293701ca1f6a6484e1b48ea4fce5df686b5dfa5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2af4e398dc7cd7529a43d8832621dfb40b467eb9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2af4e398dc7cd7529a43d8832621dfb40b467eb9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2af4e398dc7cd7529a43d8832621dfb40b467eb9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2af4e398dc7cd7529a43d8832621dfb40b467eb9/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "94a0134a40aebac146e8ebe9a3094321d8b1c7da",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/94a0134a40aebac146e8ebe9a3094321d8b1c7da",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/94a0134a40aebac146e8ebe9a3094321d8b1c7da"
      }
    ],
    "stats": {
      "total": 1469,
      "additions": 733,
      "deletions": 736
    },
    "files": [
      {
        "sha": "d61fafaec31e68fa9944d49defb1e976c0171b8d",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 733,
        "deletions": 736,
        "changes": 1469,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2af4e398dc7cd7529a43d8832621dfb40b467eb9/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2af4e398dc7cd7529a43d8832621dfb40b467eb9/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=2af4e398dc7cd7529a43d8832621dfb40b467eb9",
        "patch": "@@ -41,7 +41,6 @@\n from test_framework.mininode import (\n     P2PInterface,\n     mininode_lock,\n-    network_thread_start,\n )\n from test_framework.script import (\n     CScript,\n@@ -89,6 +88,23 @@\n \n MAX_SIGOP_COST = 80000\n \n+class UTXO():\n+    \"\"\"Used to keep track of anyone-can-spend outputs that we can use in the tests.\"\"\"\n+    def __init__(self, sha256, n, value):\n+        self.sha256 = sha256\n+        self.n = n\n+        self.nValue = value\n+\n+def get_p2pkh_script(pubkeyhash):\n+    \"\"\"Get the script associated with a P2PKH.\"\"\"\n+    return CScript([CScriptOp(OP_DUP), CScriptOp(OP_HASH160), pubkeyhash, CScriptOp(OP_EQUALVERIFY), CScriptOp(OP_CHECKSIG)])\n+\n+def sign_p2pk_witness_input(script, tx_to, in_idx, hashtype, value, key):\n+    \"\"\"Add signature for a P2PK witness program.\"\"\"\n+    tx_hash = SegwitVersion1SignatureHash(script, tx_to, in_idx, hashtype, value)\n+    signature = key.sign(tx_hash) + chr(hashtype).encode('latin-1')\n+    tx_to.wit.vtxinwit[in_idx].scriptWitness.stack = [signature, script]\n+    tx_to.rehash()\n \n def get_virtual_size(witness_block):\n     \"\"\"Calculate the virtual size of a witness block.\n@@ -172,24 +188,6 @@ def request_block(self, blockhash, inv_type, timeout=60):\n         self.wait_for_block(blockhash, timeout)\n         return self.last_message[\"block\"].block\n \n-class UTXO():\n-    \"\"\"Used to keep track of anyone-can-spend outputs that we can use in the tests.\"\"\"\n-    def __init__(self, sha256, n, value):\n-        self.sha256 = sha256\n-        self.n = n\n-        self.nValue = value\n-\n-def get_p2pkh_script(pubkeyhash):\n-    \"\"\"Get the script associated with a P2PKH.\"\"\"\n-    return CScript([CScriptOp(OP_DUP), CScriptOp(OP_HASH160), pubkeyhash, CScriptOp(OP_EQUALVERIFY), CScriptOp(OP_CHECKSIG)])\n-\n-def sign_p2pk_witness_input(script, tx_to, in_idx, hashtype, value, key):\n-    \"\"\"Add signature for a P2PK witness program.\"\"\"\n-    tx_hash = SegwitVersion1SignatureHash(script, tx_to, in_idx, hashtype, value)\n-    signature = key.sign(tx_hash) + chr(hashtype).encode('latin-1')\n-    tx_to.wit.vtxinwit[in_idx].scriptWitness.stack = [signature, script]\n-    tx_to.rehash()\n-\n class SegWitTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.setup_clean_chain = True\n@@ -220,7 +218,77 @@ def update_witness_block_with_transactions(self, block, tx_list, nonce=0):\n         block.vtx.extend(tx_list)\n         add_witness_commitment(block, nonce)\n         block.solve()\n-        return\n+\n+    def run_test(self):\n+        # Setup the p2p connections and start up the network thread.\n+        # self.test_node sets NODE_WITNESS|NODE_NETWORK\n+        self.test_node = self.nodes[0].add_p2p_connection(TestP2PConn(), services=NODE_NETWORK | NODE_WITNESS)\n+        # self.old_node sets only NODE_NETWORK\n+        self.old_node = self.nodes[0].add_p2p_connection(TestP2PConn(), services=NODE_NETWORK)\n+        # self.std_node is for testing node1 (fRequireStandard=true)\n+        self.std_node = self.nodes[1].add_p2p_connection(TestP2PConn(), services=NODE_NETWORK | NODE_WITNESS)\n+\n+        # Keep a place to store utxo's that can be used in later tests\n+        self.utxo = []\n+\n+        # Test logic begins here\n+        self.test_node.wait_for_verack()\n+\n+        self.log.info(\"Starting tests before segwit lock in:\")\n+\n+        self.test_witness_services()  # Verifies NODE_WITNESS\n+        self.test_non_witness_transaction()  # non-witness tx's are accepted\n+        self.test_unnecessary_witness_before_segwit_activation()\n+        self.test_v0_outputs_arent_spendable()\n+        self.test_block_relay(segwit_activated=False)\n+\n+        # Advance to segwit being 'started'\n+        self.advance_to_segwit_started()\n+        sync_blocks(self.nodes)\n+        self.test_getblocktemplate_before_lockin()\n+\n+        sync_blocks(self.nodes)\n+\n+        # At lockin, nothing should change.\n+        self.log.info(\"Testing behavior post lockin, pre-activation\")\n+        self.advance_to_segwit_lockin()\n+\n+        # Retest unnecessary witnesses\n+        self.test_unnecessary_witness_before_segwit_activation()\n+        self.test_witness_tx_relay_before_segwit_activation()\n+        self.test_block_relay(segwit_activated=False)\n+        self.test_standardness_v0(segwit_activated=False)\n+\n+        sync_blocks(self.nodes)\n+\n+        # Now activate segwit\n+        self.log.info(\"Testing behavior after segwit activation\")\n+        self.advance_to_segwit_active()\n+\n+        sync_blocks(self.nodes)\n+\n+        # Test P2SH witness handling again\n+        self.test_p2sh_witness(segwit_activated=True)\n+        self.test_witness_commitments()\n+        self.test_block_malleability()\n+        self.test_witness_block_size()\n+        self.test_submit_block()\n+        self.test_extra_witness_data()\n+        self.test_max_witness_push_length()\n+        self.test_max_witness_program_length()\n+        self.test_witness_input_length()\n+        self.test_block_relay(segwit_activated=True)\n+        self.test_tx_relay_after_segwit_activation()\n+        self.test_standardness_v0(segwit_activated=True)\n+        self.test_segwit_versions()\n+        self.test_premature_coinbase_witness_spend()\n+        self.test_uncompressed_pubkey()\n+        self.test_signature_version_1()\n+        self.test_non_standard_witness_blinding()\n+        self.test_non_standard_witness()\n+        sync_blocks(self.nodes)\n+        self.test_upgrade_after_activation(node_id=2)\n+        self.test_witness_sigops()\n \n     # Individual tests\n \n@@ -300,6 +368,102 @@ def test_unnecessary_witness_before_segwit_activation(self):\n         self.utxo.pop(0)\n         self.utxo.append(UTXO(tx.sha256, 0, tx.vout[0].nValue))\n \n+    def test_block_relay(self, segwit_activated):\n+        \"\"\"Test that block requests to NODE_WITNESS peer are with MSG_WITNESS_FLAG.\n+\n+        This is true regardless of segwit activation.\n+        Also test that we don't ask for blocks from unupgraded peers.\"\"\"\n+        self.log.info(\"Testing block relay\")\n+\n+        blocktype = 2 | MSG_WITNESS_FLAG\n+\n+        # test_node has set NODE_WITNESS, so all getdata requests should be for\n+        # witness blocks.\n+        # Test announcing a block via inv results in a getdata, and that\n+        # announcing a version 4 or random VB block with a header results in a getdata\n+        block1 = self.build_next_block()\n+        block1.solve()\n+\n+        self.test_node.announce_block_and_wait_for_getdata(block1, use_header=False)\n+        assert(self.test_node.last_message[\"getdata\"].inv[0].type == blocktype)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block1, True)\n+\n+        block2 = self.build_next_block(version=4)\n+        block2.solve()\n+\n+        self.test_node.announce_block_and_wait_for_getdata(block2, use_header=True)\n+        assert(self.test_node.last_message[\"getdata\"].inv[0].type == blocktype)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block2, True)\n+\n+        block3 = self.build_next_block(version=(VB_TOP_BITS | (1 << 15)))\n+        block3.solve()\n+        self.test_node.announce_block_and_wait_for_getdata(block3, use_header=True)\n+        assert(self.test_node.last_message[\"getdata\"].inv[0].type == blocktype)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block3, True)\n+\n+        # Check that we can getdata for witness blocks or regular blocks,\n+        # and the right thing happens.\n+        if not segwit_activated:\n+            # Before activation, we should be able to request old blocks with\n+            # or without witness, and they should be the same.\n+            chain_height = self.nodes[0].getblockcount()\n+            # Pick 10 random blocks on main chain, and verify that getdata's\n+            # for MSG_BLOCK, MSG_WITNESS_BLOCK, and rpc getblock() are equal.\n+            all_heights = list(range(chain_height + 1))\n+            random.shuffle(all_heights)\n+            all_heights = all_heights[0:10]\n+            for height in all_heights:\n+                block_hash = self.nodes[0].getblockhash(height)\n+                rpc_block = self.nodes[0].getblock(block_hash, False)\n+                block_hash = int(block_hash, 16)\n+                block = self.test_node.request_block(block_hash, 2)\n+                wit_block = self.test_node.request_block(block_hash, 2 | MSG_WITNESS_FLAG)\n+                assert_equal(block.serialize(True), wit_block.serialize(True))\n+                assert_equal(block.serialize(), hex_str_to_bytes(rpc_block))\n+        else:\n+            # After activation, witness blocks and non-witness blocks should\n+            # be different.  Verify rpc getblock() returns witness blocks, while\n+            # getdata respects the requested type.\n+            block = self.build_next_block()\n+            self.update_witness_block_with_transactions(block, [])\n+            # This gives us a witness commitment.\n+            assert(len(block.vtx[0].wit.vtxinwit) == 1)\n+            assert(len(block.vtx[0].wit.vtxinwit[0].scriptWitness.stack) == 1)\n+            test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+            # Now try to retrieve it...\n+            rpc_block = self.nodes[0].getblock(block.hash, False)\n+            non_wit_block = self.test_node.request_block(block.sha256, 2)\n+            wit_block = self.test_node.request_block(block.sha256, 2 | MSG_WITNESS_FLAG)\n+            assert_equal(wit_block.serialize(True), hex_str_to_bytes(rpc_block))\n+            assert_equal(wit_block.serialize(False), non_wit_block.serialize())\n+            assert_equal(wit_block.serialize(True), block.serialize(True))\n+\n+            # Test size, vsize, weight\n+            rpc_details = self.nodes[0].getblock(block.hash, True)\n+            assert_equal(rpc_details[\"size\"], len(block.serialize(True)))\n+            assert_equal(rpc_details[\"strippedsize\"], len(block.serialize(False)))\n+            weight = 3 * len(block.serialize(False)) + len(block.serialize(True))\n+            assert_equal(rpc_details[\"weight\"], weight)\n+\n+            # Upgraded node should not ask for blocks from unupgraded\n+            block4 = self.build_next_block(version=4)\n+            block4.solve()\n+            self.old_node.getdataset = set()\n+\n+            # Blocks can be requested via direct-fetch (immediately upon processing the announcement)\n+            # or via parallel download (with an indeterminate delay from processing the announcement)\n+            # so to test that a block is NOT requested, we could guess a time period to sleep for,\n+            # and then check. We can avoid the sleep() by taking advantage of transaction getdata's\n+            # being processed after block getdata's, and announce a transaction as well,\n+            # and then check to see if that particular getdata has been received.\n+            # Since 0.14, inv's will only be responded to with a getheaders, so send a header\n+            # to announce this block.\n+            msg = msg_headers()\n+            msg.headers = [CBlockHeader(block4)]\n+            self.old_node.send_message(msg)\n+            self.old_node.announce_tx_and_wait_for_getdata(block4.vtx[0])\n+            assert(block4.sha256 not in self.old_node.getdataset)\n+\n     def test_v0_outputs_arent_spendable(self):\n         \"\"\"Test that v0 outputs aren't spendable before segwit activation.\n \n@@ -389,6 +553,53 @@ def advance_to_segwit_started(self):\n         self.nodes[0].generate(VB_PERIOD - height - 1)\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'started')\n \n+    def test_getblocktemplate_before_lockin(self):\n+        self.log.info(\"Testing getblocktemplate setting of segwit versionbit (before lockin)\")\n+        # Node0 is segwit aware, node2 is not.\n+        for node in [self.nodes[0], self.nodes[2]]:\n+            gbt_results = node.getblocktemplate()\n+            block_version = gbt_results['version']\n+            # If we're not indicating segwit support, we will still be\n+            # signalling for segwit activation.\n+            assert_equal((block_version & (1 << VB_WITNESS_BIT) != 0), node == self.nodes[0])\n+            # If we don't specify the segwit rule, then we won't get a default\n+            # commitment.\n+            assert('default_witness_commitment' not in gbt_results)\n+\n+        # Workaround:\n+        # Can either change the tip, or change the mempool and wait 5 seconds\n+        # to trigger a recomputation of getblocktemplate.\n+        txid = int(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1), 16)\n+        # Using mocktime lets us avoid sleep()\n+        sync_mempools(self.nodes)\n+        self.nodes[0].setmocktime(int(time.time()) + 10)\n+        self.nodes[2].setmocktime(int(time.time()) + 10)\n+\n+        for node in [self.nodes[0], self.nodes[2]]:\n+            gbt_results = node.getblocktemplate({\"rules\": [\"segwit\"]})\n+            block_version = gbt_results['version']\n+            if node == self.nodes[2]:\n+                # If this is a non-segwit node, we should still not get a witness\n+                # commitment, nor a version bit signalling segwit.\n+                assert_equal(block_version & (1 << VB_WITNESS_BIT), 0)\n+                assert('default_witness_commitment' not in gbt_results)\n+            else:\n+                # For segwit-aware nodes, check the version bit and the witness\n+                # commitment are correct.\n+                assert(block_version & (1 << VB_WITNESS_BIT) != 0)\n+                assert('default_witness_commitment' in gbt_results)\n+                witness_commitment = gbt_results['default_witness_commitment']\n+\n+                # Check that default_witness_commitment is present.\n+                witness_root = CBlock.get_merkle_root([ser_uint256(0),\n+                                                       ser_uint256(txid)])\n+                script = get_witness_script(witness_root, 0)\n+                assert_equal(witness_commitment, bytes_to_hex_str(script))\n+\n+        # undo mocktime\n+        self.nodes[0].setmocktime(0)\n+        self.nodes[2].setmocktime(0)\n+\n     def advance_to_segwit_lockin(self):\n         \"\"\"Mine enough blocks to lock in segwit, but don't activate.\"\"\"\n         # TODO: we could verify that lockin only happens at the right threshold of\n@@ -404,18 +615,210 @@ def advance_to_segwit_lockin(self):\n         self.nodes[0].generate(1)\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'locked_in')\n \n-    def advance_to_segwit_active(self):\n-        \"\"\"Mine enough blocks to activate segwit.\"\"\"\n-        # TODO: we could verify that activation only happens at the right threshold\n-        # of signalling blocks, rather than just at the right period boundary.\n-\n-        assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'locked_in')\n-        height = self.nodes[0].getblockcount()\n-        self.nodes[0].generate(VB_PERIOD - (height % VB_PERIOD) - 2)\n+    def test_witness_tx_relay_before_segwit_activation(self):\n+        self.log.info(\"Testing relay of witness transactions\")\n+        # Generate a transaction that doesn't require a witness, but send it\n+        # with a witness.  Should be rejected for premature-witness, but should\n+        # not be added to recently rejected list.\n+        assert(len(self.utxo))\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue - 1000, CScript([OP_TRUE, OP_DROP] * 15 + [OP_TRUE])))\n+        tx.wit.vtxinwit.append(CTxInWitness())\n+        tx.wit.vtxinwit[0].scriptWitness.stack = [b'a']\n+        tx.rehash()\n+\n+        tx_hash = tx.sha256\n+        tx_value = tx.vout[0].nValue\n+\n+        # Verify that if a peer doesn't set nServices to include NODE_WITNESS,\n+        # the getdata is just for the non-witness portion.\n+        self.old_node.announce_tx_and_wait_for_getdata(tx)\n+        assert(self.old_node.last_message[\"getdata\"].inv[0].type == 1)\n+\n+        # Since we haven't delivered the tx yet, inv'ing the same tx from\n+        # a witness transaction ought not result in a getdata.\n+        self.test_node.announce_tx_and_wait_for_getdata(tx, timeout=2, success=False)\n+\n+        # Delivering this transaction with witness should fail (no matter who\n+        # its from)\n+        assert_equal(len(self.nodes[0].getrawmempool()), 0)\n+        assert_equal(len(self.nodes[1].getrawmempool()), 0)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.old_node, tx, with_witness=True, accepted=False)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, with_witness=True, accepted=False)\n+\n+        # But eliminating the witness should fix it\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, with_witness=False, accepted=True)\n+\n+        # Cleanup: mine the first transaction and update utxo\n+        self.nodes[0].generate(1)\n+        assert_equal(len(self.nodes[0].getrawmempool()), 0)\n+\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx_hash, 0, tx_value))\n+\n+    def test_standardness_v0(self, segwit_activated):\n+        \"\"\"Test V0 txout standardness.\n+\n+        V0 segwit outputs and inputs are always standard.\n+        V0 segwit inputs may only be mined after activation, but not before.\"\"\"\n+\n+        self.log.info(\"Testing standardness of v0 outputs (%s activation)\" % (\"after\" if segwit_activated else \"before\"))\n+        assert(len(self.utxo))\n+\n+        witness_program = CScript([OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        script_pubkey = CScript([OP_0, witness_hash])\n+\n+        p2sh_pubkey = hash160(witness_program)\n+        p2sh_script_pubkey = CScript([OP_HASH160, p2sh_pubkey, OP_EQUAL])\n+\n+        # First prepare a p2sh output (so that spending it will pass standardness)\n+        p2sh_tx = CTransaction()\n+        p2sh_tx.vin = [CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\")]\n+        p2sh_tx.vout = [CTxOut(self.utxo[0].nValue - 1000, p2sh_script_pubkey)]\n+        p2sh_tx.rehash()\n+\n+        # Mine it on test_node to create the confirmed output.\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, p2sh_tx, with_witness=True, accepted=True)\n+        self.nodes[0].generate(1)\n+        sync_blocks(self.nodes)\n+\n+        # Now test standardness of v0 P2WSH outputs.\n+        # Start by creating a transaction with two outputs.\n+        tx = CTransaction()\n+        tx.vin = [CTxIn(COutPoint(p2sh_tx.sha256, 0), CScript([witness_program]))]\n+        tx.vout = [CTxOut(p2sh_tx.vout[0].nValue - 10000, script_pubkey)]\n+        tx.vout.append(CTxOut(8000, script_pubkey))  # Might burn this later\n+        tx.vin[0].nSequence = BIP125_SEQUENCE_NUMBER  # Just to have the option to bump this tx from the mempool\n+        tx.rehash()\n+\n+        # This is always accepted, since the mempool policy is to consider segwit as always active\n+        # and thus allow segwit outputs\n+        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx, with_witness=True, accepted=True)\n+\n+        # Now create something that looks like a P2PKH output. This won't be spendable.\n+        script_pubkey = CScript([OP_0, hash160(witness_hash)])\n+        tx2 = CTransaction()\n+        # tx was accepted, so we spend the second output.\n+        tx2.vin = [CTxIn(COutPoint(tx.sha256, 1), b\"\")]\n+        tx2.vout = [CTxOut(7000, script_pubkey)]\n+        tx2.wit.vtxinwit.append(CTxInWitness())\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n+        tx2.rehash()\n+\n+        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx2, with_witness=True, accepted=True)\n+\n+        # Now update self.utxo for later tests.\n+        tx3 = CTransaction()\n+        # tx and tx2 were both accepted.  Don't bother trying to reclaim the\n+        # P2PKH output; just send tx's first output back to an anyone-can-spend.\n+        sync_mempools([self.nodes[0], self.nodes[1]])\n+        tx3.vin = [CTxIn(COutPoint(tx.sha256, 0), b\"\")]\n+        tx3.vout = [CTxOut(tx.vout[0].nValue - 1000, CScript([OP_TRUE, OP_DROP] * 15 + [OP_TRUE]))]\n+        tx3.wit.vtxinwit.append(CTxInWitness())\n+        tx3.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n+        tx3.rehash()\n+        if not segwit_activated:\n+            # Just check mempool acceptance, but don't add the transaction to the mempool, since witness is disallowed\n+            # in blocks and the tx is impossible to mine right now.\n+            assert_equal(self.nodes[0].testmempoolaccept([bytes_to_hex_str(tx3.serialize_with_witness())]), [{'txid': tx3.hash, 'allowed': True}])\n+            # Create the same output as tx3, but by replacing tx\n+            tx3_out = tx3.vout[0]\n+            tx3 = tx\n+            tx3.vout = [tx3_out]\n+            tx3.rehash()\n+            assert_equal(self.nodes[0].testmempoolaccept([bytes_to_hex_str(tx3.serialize_with_witness())]), [{'txid': tx3.hash, 'allowed': True}])\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx3, with_witness=True, accepted=True)\n+\n+        self.nodes[0].generate(1)\n+        sync_blocks(self.nodes)\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n+        assert_equal(len(self.nodes[1].getrawmempool()), 0)\n+\n+    def advance_to_segwit_active(self):\n+        \"\"\"Mine enough blocks to activate segwit.\"\"\"\n+        # TODO: we could verify that activation only happens at the right threshold\n+        # of signalling blocks, rather than just at the right period boundary.\n+\n+        assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'locked_in')\n+        height = self.nodes[0].getblockcount()\n+        self.nodes[0].generate(VB_PERIOD - (height % VB_PERIOD) - 2)\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'locked_in')\n         self.nodes[0].generate(1)\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'active')\n \n+    def test_p2sh_witness(self, segwit_activated):\n+        \"\"\"Test P2SH wrapped witness programs.\"\"\"\n+        self.log.info(\"Testing P2SH witness transactions\")\n+\n+        assert(len(self.utxo))\n+\n+        # Prepare the p2sh-wrapped witness output\n+        witness_program = CScript([OP_DROP, OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        p2wsh_pubkey = CScript([OP_0, witness_hash])\n+        p2sh_witness_hash = hash160(p2wsh_pubkey)\n+        script_pubkey = CScript([OP_HASH160, p2sh_witness_hash, OP_EQUAL])\n+        script_sig = CScript([p2wsh_pubkey])  # a push of the redeem script\n+\n+        # Fund the P2SH output\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue - 1000, script_pubkey))\n+        tx.rehash()\n+\n+        # Verify mempool acceptance and block validity\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, with_witness=False, accepted=True)\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx])\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True, with_witness=segwit_activated)\n+        sync_blocks(self.nodes)\n+\n+        # Now test attempts to spend the output.\n+        spend_tx = CTransaction()\n+        spend_tx.vin.append(CTxIn(COutPoint(tx.sha256, 0), script_sig))\n+        spend_tx.vout.append(CTxOut(tx.vout[0].nValue - 1000, CScript([OP_TRUE])))\n+        spend_tx.rehash()\n+\n+        # This transaction should not be accepted into the mempool pre- or\n+        # post-segwit.  Mempool acceptance will use SCRIPT_VERIFY_WITNESS which\n+        # will require a witness to spend a witness program regardless of\n+        # segwit activation.  Note that older bitcoind's that are not\n+        # segwit-aware would also reject this for failing CLEANSTACK.\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, spend_tx, with_witness=False, accepted=False)\n+\n+        # Try to put the witness script in the script_sig, should also fail.\n+        spend_tx.vin[0].script_sig = CScript([p2wsh_pubkey, b'a'])\n+        spend_tx.rehash()\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, spend_tx, with_witness=False, accepted=False)\n+\n+        # Now put the witness script in the witness, should succeed after\n+        # segwit activates.\n+        spend_tx.vin[0].scriptSig = script_sig\n+        spend_tx.rehash()\n+        spend_tx.wit.vtxinwit.append(CTxInWitness())\n+        spend_tx.wit.vtxinwit[0].scriptWitness.stack = [b'a', witness_program]\n+\n+        # Verify mempool acceptance\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, spend_tx, with_witness=True, accepted=segwit_activated)\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [spend_tx])\n+\n+        # If we're after activation, then sending this with witnesses should be valid.\n+        # This no longer works before activation, because SCRIPT_VERIFY_WITNESS\n+        # is always set.\n+        # TODO: rewrite this test to make clear that it only works after activation.\n+        if segwit_activated:\n+            test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+        else:\n+            test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True, with_witness=False)\n+\n+        # Update self.utxo\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(spend_tx.sha256, 0, spend_tx.vout[0].nValue))\n+\n     def test_witness_commitments(self):\n         \"\"\"Test witness commitments.\n \n@@ -906,48 +1309,6 @@ def serialize_with_witness(self):\n         self.utxo.pop()\n         self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n \n-    def test_witness_tx_relay_before_segwit_activation(self):\n-        self.log.info(\"Testing relay of witness transactions\")\n-        # Generate a transaction that doesn't require a witness, but send it\n-        # with a witness.  Should be rejected for premature-witness, but should\n-        # not be added to recently rejected list.\n-        assert(len(self.utxo))\n-        tx = CTransaction()\n-        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n-        tx.vout.append(CTxOut(self.utxo[0].nValue - 1000, CScript([OP_TRUE, OP_DROP] * 15 + [OP_TRUE])))\n-        tx.wit.vtxinwit.append(CTxInWitness())\n-        tx.wit.vtxinwit[0].scriptWitness.stack = [b'a']\n-        tx.rehash()\n-\n-        tx_hash = tx.sha256\n-        tx_value = tx.vout[0].nValue\n-\n-        # Verify that if a peer doesn't set nServices to include NODE_WITNESS,\n-        # the getdata is just for the non-witness portion.\n-        self.old_node.announce_tx_and_wait_for_getdata(tx)\n-        assert(self.old_node.last_message[\"getdata\"].inv[0].type == 1)\n-\n-        # Since we haven't delivered the tx yet, inv'ing the same tx from\n-        # a witness transaction ought not result in a getdata.\n-        self.test_node.announce_tx_and_wait_for_getdata(tx, timeout=2, success=False)\n-\n-        # Delivering this transaction with witness should fail (no matter who\n-        # its from)\n-        assert_equal(len(self.nodes[0].getrawmempool()), 0)\n-        assert_equal(len(self.nodes[1].getrawmempool()), 0)\n-        test_transaction_acceptance(self.nodes[0].rpc, self.old_node, tx, with_witness=True, accepted=False)\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, with_witness=True, accepted=False)\n-\n-        # But eliminating the witness should fix it\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, with_witness=False, accepted=True)\n-\n-        # Cleanup: mine the first transaction and update utxo\n-        self.nodes[0].generate(1)\n-        assert_equal(len(self.nodes[0].getrawmempool()), 0)\n-\n-        self.utxo.pop(0)\n-        self.utxo.append(UTXO(tx_hash, 0, tx_value))\n-\n     def test_tx_relay_after_segwit_activation(self):\n         \"\"\"Test transaction relay after segwit activation.\n \n@@ -1042,187 +1403,11 @@ def test_tx_relay_after_segwit_activation(self):\n         self.utxo.pop(0)\n         self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n \n-    def test_block_relay(self, segwit_activated):\n-        \"\"\"Test that block requests to NODE_WITNESS peer are with MSG_WITNESS_FLAG.\n-\n-        This is true regardless of segwit activation.\n-        Also test that we don't ask for blocks from unupgraded peers.\"\"\"\n-        self.log.info(\"Testing block relay\")\n+    def test_segwit_versions(self):\n+        \"\"\"Test validity of future segwit version transactions.\n \n-        blocktype = 2 | MSG_WITNESS_FLAG\n-\n-        # test_node has set NODE_WITNESS, so all getdata requests should be for\n-        # witness blocks.\n-        # Test announcing a block via inv results in a getdata, and that\n-        # announcing a version 4 or random VB block with a header results in a getdata\n-        block1 = self.build_next_block()\n-        block1.solve()\n-\n-        self.test_node.announce_block_and_wait_for_getdata(block1, use_header=False)\n-        assert(self.test_node.last_message[\"getdata\"].inv[0].type == blocktype)\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block1, True)\n-\n-        block2 = self.build_next_block(version=4)\n-        block2.solve()\n-\n-        self.test_node.announce_block_and_wait_for_getdata(block2, use_header=True)\n-        assert(self.test_node.last_message[\"getdata\"].inv[0].type == blocktype)\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block2, True)\n-\n-        block3 = self.build_next_block(version=(VB_TOP_BITS | (1 << 15)))\n-        block3.solve()\n-        self.test_node.announce_block_and_wait_for_getdata(block3, use_header=True)\n-        assert(self.test_node.last_message[\"getdata\"].inv[0].type == blocktype)\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block3, True)\n-\n-        # Check that we can getdata for witness blocks or regular blocks,\n-        # and the right thing happens.\n-        if not segwit_activated:\n-            # Before activation, we should be able to request old blocks with\n-            # or without witness, and they should be the same.\n-            chain_height = self.nodes[0].getblockcount()\n-            # Pick 10 random blocks on main chain, and verify that getdata's\n-            # for MSG_BLOCK, MSG_WITNESS_BLOCK, and rpc getblock() are equal.\n-            all_heights = list(range(chain_height + 1))\n-            random.shuffle(all_heights)\n-            all_heights = all_heights[0:10]\n-            for height in all_heights:\n-                block_hash = self.nodes[0].getblockhash(height)\n-                rpc_block = self.nodes[0].getblock(block_hash, False)\n-                block_hash = int(block_hash, 16)\n-                block = self.test_node.request_block(block_hash, 2)\n-                wit_block = self.test_node.request_block(block_hash, 2 | MSG_WITNESS_FLAG)\n-                assert_equal(block.serialize(True), wit_block.serialize(True))\n-                assert_equal(block.serialize(), hex_str_to_bytes(rpc_block))\n-        else:\n-            # After activation, witness blocks and non-witness blocks should\n-            # be different.  Verify rpc getblock() returns witness blocks, while\n-            # getdata respects the requested type.\n-            block = self.build_next_block()\n-            self.update_witness_block_with_transactions(block, [])\n-            # This gives us a witness commitment.\n-            assert(len(block.vtx[0].wit.vtxinwit) == 1)\n-            assert(len(block.vtx[0].wit.vtxinwit[0].scriptWitness.stack) == 1)\n-            test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n-            # Now try to retrieve it...\n-            rpc_block = self.nodes[0].getblock(block.hash, False)\n-            non_wit_block = self.test_node.request_block(block.sha256, 2)\n-            wit_block = self.test_node.request_block(block.sha256, 2 | MSG_WITNESS_FLAG)\n-            assert_equal(wit_block.serialize(True), hex_str_to_bytes(rpc_block))\n-            assert_equal(wit_block.serialize(False), non_wit_block.serialize())\n-            assert_equal(wit_block.serialize(True), block.serialize(True))\n-\n-            # Test size, vsize, weight\n-            rpc_details = self.nodes[0].getblock(block.hash, True)\n-            assert_equal(rpc_details[\"size\"], len(block.serialize(True)))\n-            assert_equal(rpc_details[\"strippedsize\"], len(block.serialize(False)))\n-            weight = 3 * len(block.serialize(False)) + len(block.serialize(True))\n-            assert_equal(rpc_details[\"weight\"], weight)\n-\n-            # Upgraded node should not ask for blocks from unupgraded\n-            block4 = self.build_next_block(version=4)\n-            block4.solve()\n-            self.old_node.getdataset = set()\n-\n-            # Blocks can be requested via direct-fetch (immediately upon processing the announcement)\n-            # or via parallel download (with an indeterminate delay from processing the announcement)\n-            # so to test that a block is NOT requested, we could guess a time period to sleep for,\n-            # and then check. We can avoid the sleep() by taking advantage of transaction getdata's\n-            # being processed after block getdata's, and announce a transaction as well,\n-            # and then check to see if that particular getdata has been received.\n-            # Since 0.14, inv's will only be responded to with a getheaders, so send a header\n-            # to announce this block.\n-            msg = msg_headers()\n-            msg.headers = [CBlockHeader(block4)]\n-            self.old_node.send_message(msg)\n-            self.old_node.announce_tx_and_wait_for_getdata(block4.vtx[0])\n-            assert(block4.sha256 not in self.old_node.getdataset)\n-\n-    def test_standardness_v0(self, segwit_activated):\n-        \"\"\"Test V0 txout standardness.\n-        \n-        V0 segwit outputs and inputs are always standard.\n-        V0 segwit inputs may only be mined after activation, but not before.\"\"\"\n-\n-        self.log.info(\"Testing standardness of v0 outputs (%s activation)\" % (\"after\" if segwit_activated else \"before\"))\n-        assert(len(self.utxo))\n-\n-        witness_program = CScript([OP_TRUE])\n-        witness_hash = sha256(witness_program)\n-        script_pubkey = CScript([OP_0, witness_hash])\n-\n-        p2sh_pubkey = hash160(witness_program)\n-        p2sh_script_pubkey = CScript([OP_HASH160, p2sh_pubkey, OP_EQUAL])\n-\n-        # First prepare a p2sh output (so that spending it will pass standardness)\n-        p2sh_tx = CTransaction()\n-        p2sh_tx.vin = [CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\")]\n-        p2sh_tx.vout = [CTxOut(self.utxo[0].nValue - 1000, p2sh_script_pubkey)]\n-        p2sh_tx.rehash()\n-\n-        # Mine it on test_node to create the confirmed output.\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, p2sh_tx, with_witness=True, accepted=True)\n-        self.nodes[0].generate(1)\n-        sync_blocks(self.nodes)\n-\n-        # Now test standardness of v0 P2WSH outputs.\n-        # Start by creating a transaction with two outputs.\n-        tx = CTransaction()\n-        tx.vin = [CTxIn(COutPoint(p2sh_tx.sha256, 0), CScript([witness_program]))]\n-        tx.vout = [CTxOut(p2sh_tx.vout[0].nValue - 10000, script_pubkey)]\n-        tx.vout.append(CTxOut(8000, script_pubkey))  # Might burn this later\n-        tx.vin[0].nSequence = BIP125_SEQUENCE_NUMBER  # Just to have the option to bump this tx from the mempool\n-        tx.rehash()\n-\n-        # This is always accepted, since the mempool policy is to consider segwit as always active\n-        # and thus allow segwit outputs\n-        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx, with_witness=True, accepted=True)\n-\n-        # Now create something that looks like a P2PKH output. This won't be spendable.\n-        script_pubkey = CScript([OP_0, hash160(witness_hash)])\n-        tx2 = CTransaction()\n-        # tx was accepted, so we spend the second output.\n-        tx2.vin = [CTxIn(COutPoint(tx.sha256, 1), b\"\")]\n-        tx2.vout = [CTxOut(7000, script_pubkey)]\n-        tx2.wit.vtxinwit.append(CTxInWitness())\n-        tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n-        tx2.rehash()\n-\n-        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx2, with_witness=True, accepted=True)\n-\n-        # Now update self.utxo for later tests.\n-        tx3 = CTransaction()\n-        # tx and tx2 were both accepted.  Don't bother trying to reclaim the\n-        # P2PKH output; just send tx's first output back to an anyone-can-spend.\n-        sync_mempools([self.nodes[0], self.nodes[1]])\n-        tx3.vin = [CTxIn(COutPoint(tx.sha256, 0), b\"\")]\n-        tx3.vout = [CTxOut(tx.vout[0].nValue - 1000, CScript([OP_TRUE, OP_DROP] * 15 + [OP_TRUE]))]\n-        tx3.wit.vtxinwit.append(CTxInWitness())\n-        tx3.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n-        tx3.rehash()\n-        if not segwit_activated:\n-            # Just check mempool acceptance, but don't add the transaction to the mempool, since witness is disallowed\n-            # in blocks and the tx is impossible to mine right now.\n-            assert_equal(self.nodes[0].testmempoolaccept([bytes_to_hex_str(tx3.serialize_with_witness())]), [{'txid': tx3.hash, 'allowed': True}])\n-            # Create the same output as tx3, but by replacing tx\n-            tx3_out = tx3.vout[0]\n-            tx3 = tx\n-            tx3.vout = [tx3_out]\n-            tx3.rehash()\n-            assert_equal(self.nodes[0].testmempoolaccept([bytes_to_hex_str(tx3.serialize_with_witness())]), [{'txid': tx3.hash, 'allowed': True}])\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx3, with_witness=True, accepted=True)\n-\n-        self.nodes[0].generate(1)\n-        sync_blocks(self.nodes)\n-        self.utxo.pop(0)\n-        self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n-        assert_equal(len(self.nodes[1].getrawmempool()), 0)\n-\n-    def test_segwit_versions(self):\n-        \"\"\"Test validity of future segwit version transactions.\n-        \n-        Future segwit version transactions are non-standard, but valid in blocks.\n-        Can run this before and after segwit activation.\"\"\"\n+        Future segwit version transactions are non-standard, but valid in blocks.\n+        Can run this before and after segwit activation.\"\"\"\n \n         self.log.info(\"Testing standardness/consensus for segwit versions (0-16)\")\n         assert(len(self.utxo))\n@@ -1340,64 +1525,171 @@ def test_premature_coinbase_witness_spend(self):\n         test_witness_block(self.nodes[0].rpc, self.test_node, block2, accepted=True)\n         sync_blocks(self.nodes)\n \n-    def test_signature_version_1(self):\n-        self.log.info(\"Testing segwit signature hash version 1\")\n+    def test_uncompressed_pubkey(self):\n+        \"\"\"Test uncompressed pubkey validity in segwit transactions.\n+\n+        Uncompressed pubkeys are no longer supported in default relay policy,\n+        but (for now) are still valid in blocks.\"\"\"\n+\n+        self.log.info(\"Testing uncompressed pubkeys\")\n+        # Segwit transactions using uncompressed pubkeys are not accepted\n+        # under default policy, but should still pass consensus.\n         key = CECKey()\n         key.set_secretbytes(b\"9\")\n+        key.set_compressed(False)\n         pubkey = CPubKey(key.get_pubkey())\n+        assert_equal(len(pubkey), 65)  # This should be an uncompressed pubkey\n \n-        witness_program = CScript([pubkey, CScriptOp(OP_CHECKSIG)])\n-        witness_hash = sha256(witness_program)\n-        script_pubkey = CScript([OP_0, witness_hash])\n+        assert(len(self.utxo) > 0)\n+        utxo = self.utxo.pop(0)\n \n-        # First create a witness output for use in the tests.\n-        assert(len(self.utxo))\n+        # Test 1: P2WPKH\n+        # First create a P2WPKH output that uses an uncompressed pubkey\n+        pubkeyhash = hash160(pubkey)\n+        script_pkh = CScript([OP_0, pubkeyhash])\n         tx = CTransaction()\n-        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n-        tx.vout.append(CTxOut(self.utxo[0].nValue - 1000, script_pubkey))\n+        tx.vin.append(CTxIn(COutPoint(utxo.sha256, utxo.n), b\"\"))\n+        tx.vout.append(CTxOut(utxo.nValue - 1000, script_pkh))\n         tx.rehash()\n \n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, with_witness=True, accepted=True)\n-        # Mine this transaction in preparation for following tests.\n+        # Confirm it in a block.\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx])\n         test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n-        sync_blocks(self.nodes)\n-        self.utxo.pop(0)\n \n-        # Test each hashtype\n-        prev_utxo = UTXO(tx.sha256, 0, tx.vout[0].nValue)\n-        for sigflag in [0, SIGHASH_ANYONECANPAY]:\n-            for hashtype in [SIGHASH_ALL, SIGHASH_NONE, SIGHASH_SINGLE]:\n-                hashtype |= sigflag\n-                block = self.build_next_block()\n-                tx = CTransaction()\n-                tx.vin.append(CTxIn(COutPoint(prev_utxo.sha256, prev_utxo.n), b\"\"))\n-                tx.vout.append(CTxOut(prev_utxo.nValue - 1000, script_pubkey))\n-                tx.wit.vtxinwit.append(CTxInWitness())\n-                # Too-large input value\n-                sign_p2pk_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue + 1, key)\n-                self.update_witness_block_with_transactions(block, [tx])\n-                test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n+        # Now try to spend it. Send it to a P2WSH output, which we'll\n+        # use in the next test.\n+        witness_program = CScript([pubkey, CScriptOp(OP_CHECKSIG)])\n+        witness_hash = sha256(witness_program)\n+        script_wsh = CScript([OP_0, witness_hash])\n \n-                # Too-small input value\n-                sign_p2pk_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue - 1, key)\n-                block.vtx.pop()  # remove last tx\n-                self.update_witness_block_with_transactions(block, [tx])\n-                test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue - 1000, script_wsh))\n+        script = get_p2pkh_script(pubkeyhash)\n+        sig_hash = SegwitVersion1SignatureHash(script, tx2, 0, SIGHASH_ALL, tx.vout[0].nValue)\n+        signature = key.sign(sig_hash) + b'\\x01'  # 0x1 is SIGHASH_ALL\n+        tx2.wit.vtxinwit.append(CTxInWitness())\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [signature, pubkey]\n+        tx2.rehash()\n \n-                # Now try correct value\n-                sign_p2pk_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue, key)\n-                block.vtx.pop()\n-                self.update_witness_block_with_transactions(block, [tx])\n-                test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+        # Should fail policy test.\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx2, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n+        # But passes consensus.\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n \n-                prev_utxo = UTXO(tx.sha256, 0, tx.vout[0].nValue)\n+        # Test 2: P2WSH\n+        # Try to spend the P2WSH output created in last test.\n+        # Send it to a P2SH(P2WSH) output, which we'll use in the next test.\n+        p2sh_witness_hash = hash160(script_wsh)\n+        script_p2sh = CScript([OP_HASH160, p2sh_witness_hash, OP_EQUAL])\n+        script_sig = CScript([script_wsh])\n \n-        # Test combinations of signature hashes.\n-        # Split the utxo into a lot of outputs.\n-        # Randomly choose up to 10 to spend, sign with different hashtypes, and\n-        # output to a random number of outputs.  Repeat num_tests times.\n+        tx3 = CTransaction()\n+        tx3.vin.append(CTxIn(COutPoint(tx2.sha256, 0), b\"\"))\n+        tx3.vout.append(CTxOut(tx2.vout[0].nValue - 1000, script_p2sh))\n+        tx3.wit.vtxinwit.append(CTxInWitness())\n+        sign_p2pk_witness_input(witness_program, tx3, 0, SIGHASH_ALL, tx2.vout[0].nValue, key)\n+\n+        # Should fail policy test.\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx3, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n+        # But passes consensus.\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx3])\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+\n+        # Test 3: P2SH(P2WSH)\n+        # Try to spend the P2SH output created in the last test.\n+        # Send it to a P2PKH output, which we'll use in the next test.\n+        script_pubkey = get_p2pkh_script(pubkeyhash)\n+        tx4 = CTransaction()\n+        tx4.vin.append(CTxIn(COutPoint(tx3.sha256, 0), script_sig))\n+        tx4.vout.append(CTxOut(tx3.vout[0].nValue - 1000, script_pubkey))\n+        tx4.wit.vtxinwit.append(CTxInWitness())\n+        sign_p2pk_witness_input(witness_program, tx4, 0, SIGHASH_ALL, tx3.vout[0].nValue, key)\n+\n+        # Should fail policy test.\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx4, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx4])\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+\n+        # Test 4: Uncompressed pubkeys should still be valid in non-segwit\n+        # transactions.\n+        tx5 = CTransaction()\n+        tx5.vin.append(CTxIn(COutPoint(tx4.sha256, 0), b\"\"))\n+        tx5.vout.append(CTxOut(tx4.vout[0].nValue - 1000, CScript([OP_TRUE])))\n+        (sig_hash, err) = SignatureHash(script_pubkey, tx5, 0, SIGHASH_ALL)\n+        signature = key.sign(sig_hash) + b'\\x01'  # 0x1 is SIGHASH_ALL\n+        tx5.vin[0].scriptSig = CScript([signature, pubkey])\n+        tx5.rehash()\n+        # Should pass policy and consensus.\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx5, True, True)\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx5])\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+        self.utxo.append(UTXO(tx5.sha256, 0, tx5.vout[0].nValue))\n+\n+    def test_signature_version_1(self):\n+        self.log.info(\"Testing segwit signature hash version 1\")\n+        key = CECKey()\n+        key.set_secretbytes(b\"9\")\n+        pubkey = CPubKey(key.get_pubkey())\n+\n+        witness_program = CScript([pubkey, CScriptOp(OP_CHECKSIG)])\n+        witness_hash = sha256(witness_program)\n+        script_pubkey = CScript([OP_0, witness_hash])\n+\n+        # First create a witness output for use in the tests.\n+        assert(len(self.utxo))\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue - 1000, script_pubkey))\n+        tx.rehash()\n+\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, with_witness=True, accepted=True)\n+        # Mine this transaction in preparation for following tests.\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx])\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+        sync_blocks(self.nodes)\n+        self.utxo.pop(0)\n+\n+        # Test each hashtype\n+        prev_utxo = UTXO(tx.sha256, 0, tx.vout[0].nValue)\n+        for sigflag in [0, SIGHASH_ANYONECANPAY]:\n+            for hashtype in [SIGHASH_ALL, SIGHASH_NONE, SIGHASH_SINGLE]:\n+                hashtype |= sigflag\n+                block = self.build_next_block()\n+                tx = CTransaction()\n+                tx.vin.append(CTxIn(COutPoint(prev_utxo.sha256, prev_utxo.n), b\"\"))\n+                tx.vout.append(CTxOut(prev_utxo.nValue - 1000, script_pubkey))\n+                tx.wit.vtxinwit.append(CTxInWitness())\n+                # Too-large input value\n+                sign_p2pk_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue + 1, key)\n+                self.update_witness_block_with_transactions(block, [tx])\n+                test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n+\n+                # Too-small input value\n+                sign_p2pk_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue - 1, key)\n+                block.vtx.pop()  # remove last tx\n+                self.update_witness_block_with_transactions(block, [tx])\n+                test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n+\n+                # Now try correct value\n+                sign_p2pk_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue, key)\n+                block.vtx.pop()\n+                self.update_witness_block_with_transactions(block, [tx])\n+                test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+\n+                prev_utxo = UTXO(tx.sha256, 0, tx.vout[0].nValue)\n+\n+        # Test combinations of signature hashes.\n+        # Split the utxo into a lot of outputs.\n+        # Randomly choose up to 10 to spend, sign with different hashtypes, and\n+        # output to a random number of outputs.  Repeat num_tests times.\n         # Ensure that we've tested a situation where we use SIGHASH_SINGLE with\n         # an input index > number of outputs.\n         num_tests = 500\n@@ -1471,410 +1763,56 @@ def test_signature_version_1(self):\n         script_pkh = CScript([OP_0, pubkeyhash])\n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(temp_utxos[0].sha256, temp_utxos[0].n), b\"\"))\n-        tx.vout.append(CTxOut(temp_utxos[0].nValue, script_pkh))\n-        tx.wit.vtxinwit.append(CTxInWitness())\n-        sign_p2pk_witness_input(witness_program, tx, 0, SIGHASH_ALL, temp_utxos[0].nValue, key)\n-        tx2 = CTransaction()\n-        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n-        tx2.vout.append(CTxOut(tx.vout[0].nValue, CScript([OP_TRUE])))\n-\n-        script = get_p2pkh_script(pubkeyhash)\n-        sig_hash = SegwitVersion1SignatureHash(script, tx2, 0, SIGHASH_ALL, tx.vout[0].nValue)\n-        signature = key.sign(sig_hash) + b'\\x01'  # 0x1 is SIGHASH_ALL\n-\n-        # Check that we can't have a scriptSig\n-        tx2.vin[0].scriptSig = CScript([signature, pubkey])\n-        block = self.build_next_block()\n-        self.update_witness_block_with_transactions(block, [tx, tx2])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n-\n-        # Move the signature to the witness.\n-        block.vtx.pop()\n-        tx2.wit.vtxinwit.append(CTxInWitness())\n-        tx2.wit.vtxinwit[0].scriptWitness.stack = [signature, pubkey]\n-        tx2.vin[0].scriptSig = b\"\"\n-        tx2.rehash()\n-\n-        self.update_witness_block_with_transactions(block, [tx2])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n-\n-        temp_utxos.pop(0)\n-\n-        # Update self.utxos for later tests by creating two outputs\n-        # that consolidate all the coins in temp_utxos.\n-        output_value = sum(i.nValue for i in temp_utxos) // 2\n-\n-        tx = CTransaction()\n-        index = 0\n-        # Just spend to our usual anyone-can-spend output\n-        tx.vout = [CTxOut(output_value, CScript([OP_TRUE]))] * 2\n-        for i in temp_utxos:\n-            # Use SIGHASH_ALL|SIGHASH_ANYONECANPAY so we can build up\n-            # the signatures as we go.\n-            tx.vin.append(CTxIn(COutPoint(i.sha256, i.n), b\"\"))\n-            tx.wit.vtxinwit.append(CTxInWitness())\n-            sign_p2pk_witness_input(witness_program, tx, index, SIGHASH_ALL | SIGHASH_ANYONECANPAY, i.nValue, key)\n-            index += 1\n-        block = self.build_next_block()\n-        self.update_witness_block_with_transactions(block, [tx])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n-\n-        for i in range(len(tx.vout)):\n-            self.utxo.append(UTXO(tx.sha256, i, tx.vout[i].nValue))\n-\n-    def test_p2sh_witness(self, segwit_activated):\n-        \"\"\"Test P2SH wrapped witness programs.\"\"\"\n-        self.log.info(\"Testing P2SH witness transactions\")\n-\n-        assert(len(self.utxo))\n-\n-        # Prepare the p2sh-wrapped witness output\n-        witness_program = CScript([OP_DROP, OP_TRUE])\n-        witness_hash = sha256(witness_program)\n-        p2wsh_pubkey = CScript([OP_0, witness_hash])\n-        p2sh_witness_hash = hash160(p2wsh_pubkey)\n-        script_pubkey = CScript([OP_HASH160, p2sh_witness_hash, OP_EQUAL])\n-        script_sig = CScript([p2wsh_pubkey])  # a push of the redeem script\n-\n-        # Fund the P2SH output\n-        tx = CTransaction()\n-        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n-        tx.vout.append(CTxOut(self.utxo[0].nValue - 1000, script_pubkey))\n-        tx.rehash()\n-\n-        # Verify mempool acceptance and block validity\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, with_witness=False, accepted=True)\n-        block = self.build_next_block()\n-        self.update_witness_block_with_transactions(block, [tx])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True, with_witness=segwit_activated)\n-        sync_blocks(self.nodes)\n-\n-        # Now test attempts to spend the output.\n-        spend_tx = CTransaction()\n-        spend_tx.vin.append(CTxIn(COutPoint(tx.sha256, 0), script_sig))\n-        spend_tx.vout.append(CTxOut(tx.vout[0].nValue - 1000, CScript([OP_TRUE])))\n-        spend_tx.rehash()\n-\n-        # This transaction should not be accepted into the mempool pre- or\n-        # post-segwit.  Mempool acceptance will use SCRIPT_VERIFY_WITNESS which\n-        # will require a witness to spend a witness program regardless of\n-        # segwit activation.  Note that older bitcoind's that are not\n-        # segwit-aware would also reject this for failing CLEANSTACK.\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, spend_tx, with_witness=False, accepted=False)\n-\n-        # Try to put the witness script in the script_sig, should also fail.\n-        spend_tx.vin[0].script_sig = CScript([p2wsh_pubkey, b'a'])\n-        spend_tx.rehash()\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, spend_tx, with_witness=False, accepted=False)\n-\n-        # Now put the witness script in the witness, should succeed after\n-        # segwit activates.\n-        spend_tx.vin[0].scriptSig = script_sig\n-        spend_tx.rehash()\n-        spend_tx.wit.vtxinwit.append(CTxInWitness())\n-        spend_tx.wit.vtxinwit[0].scriptWitness.stack = [b'a', witness_program]\n-\n-        # Verify mempool acceptance\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, spend_tx, with_witness=True, accepted=segwit_activated)\n-        block = self.build_next_block()\n-        self.update_witness_block_with_transactions(block, [spend_tx])\n-\n-        # If we're after activation, then sending this with witnesses should be valid.\n-        # This no longer works before activation, because SCRIPT_VERIFY_WITNESS\n-        # is always set.\n-        # TODO: rewrite this test to make clear that it only works after activation.\n-        if segwit_activated:\n-            test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n-        else:\n-            test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True, with_witness=False)\n-\n-        # Update self.utxo\n-        self.utxo.pop(0)\n-        self.utxo.append(UTXO(spend_tx.sha256, 0, spend_tx.vout[0].nValue))\n-\n-    def test_upgrade_after_activation(self, node_id):\n-        \"\"\"Test the behavior of starting up a segwit-aware node after the softfork has activated.\"\"\"\n-        self.log.info(\"Testing software upgrade after softfork activation\")\n-\n-        assert(node_id != 0)  # node0 is assumed to be a segwit-active bitcoind\n-\n-        # Make sure the nodes are all up\n-        sync_blocks(self.nodes)\n-\n-        # Restart with the new binary\n-        self.stop_node(node_id)\n-        self.start_node(node_id, extra_args=[\"-vbparams=segwit:0:999999999999\"])\n-        connect_nodes(self.nodes[0], node_id)\n-\n-        sync_blocks(self.nodes)\n-\n-        # Make sure that this peer thinks segwit has activated.\n-        assert(get_bip9_status(self.nodes[node_id], 'segwit')['status'] == \"active\")\n-\n-        # Make sure this peer's blocks match those of node0.\n-        height = self.nodes[node_id].getblockcount()\n-        while height >= 0:\n-            block_hash = self.nodes[node_id].getblockhash(height)\n-            assert_equal(block_hash, self.nodes[0].getblockhash(height))\n-            assert_equal(self.nodes[0].getblock(block_hash), self.nodes[node_id].getblock(block_hash))\n-            height -= 1\n-\n-    def test_witness_sigops(self):\n-        \"\"\"Test sigop counting is correct inside witnesses.\"\"\"\n-        self.log.info(\"Testing sigops limit\")\n-\n-        assert(len(self.utxo))\n-\n-        # Keep this under MAX_OPS_PER_SCRIPT (201)\n-        witness_program = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKMULTISIG] * 5 + [OP_CHECKSIG] * 193 + [OP_ENDIF])\n-        witness_hash = sha256(witness_program)\n-        script_pubkey = CScript([OP_0, witness_hash])\n-\n-        sigops_per_script = 20 * 5 + 193 * 1\n-        # We'll produce 2 extra outputs, one with a program that would take us\n-        # over max sig ops, and one with a program that would exactly reach max\n-        # sig ops\n-        outputs = (MAX_SIGOP_COST // sigops_per_script) + 2\n-        extra_sigops_available = MAX_SIGOP_COST % sigops_per_script\n-\n-        # We chose the number of checkmultisigs/checksigs to make this work:\n-        assert(extra_sigops_available < 100)  # steer clear of MAX_OPS_PER_SCRIPT\n-\n-        # This script, when spent with the first\n-        # N(=MAX_SIGOP_COST//sigops_per_script) outputs of our transaction,\n-        # would push us just over the block sigop limit.\n-        witness_program_toomany = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKSIG] * (extra_sigops_available + 1) + [OP_ENDIF])\n-        witness_hash_toomany = sha256(witness_program_toomany)\n-        script_pubkey_toomany = CScript([OP_0, witness_hash_toomany])\n-\n-        # If we spend this script instead, we would exactly reach our sigop\n-        # limit (for witness sigops).\n-        witness_program_justright = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKSIG] * (extra_sigops_available) + [OP_ENDIF])\n-        witness_hash_justright = sha256(witness_program_justright)\n-        script_pubkey_justright = CScript([OP_0, witness_hash_justright])\n-\n-        # First split our available utxo into a bunch of outputs\n-        split_value = self.utxo[0].nValue // outputs\n-        tx = CTransaction()\n-        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n-        for i in range(outputs):\n-            tx.vout.append(CTxOut(split_value, script_pubkey))\n-        tx.vout[-2].scriptPubKey = script_pubkey_toomany\n-        tx.vout[-1].scriptPubKey = script_pubkey_justright\n-        tx.rehash()\n-\n-        block_1 = self.build_next_block()\n-        self.update_witness_block_with_transactions(block_1, [tx])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block_1, accepted=True)\n-\n-        tx2 = CTransaction()\n-        # If we try to spend the first n-1 outputs from tx, that should be\n-        # too many sigops.\n-        total_value = 0\n-        for i in range(outputs - 1):\n-            tx2.vin.append(CTxIn(COutPoint(tx.sha256, i), b\"\"))\n-            tx2.wit.vtxinwit.append(CTxInWitness())\n-            tx2.wit.vtxinwit[-1].scriptWitness.stack = [witness_program]\n-            total_value += tx.vout[i].nValue\n-        tx2.wit.vtxinwit[-1].scriptWitness.stack = [witness_program_toomany]\n-        tx2.vout.append(CTxOut(total_value, CScript([OP_TRUE])))\n-        tx2.rehash()\n-\n-        block_2 = self.build_next_block()\n-        self.update_witness_block_with_transactions(block_2, [tx2])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block_2, accepted=False)\n-\n-        # Try dropping the last input in tx2, and add an output that has\n-        # too many sigops (contributing to legacy sigop count).\n-        checksig_count = (extra_sigops_available // 4) + 1\n-        script_pubkey_checksigs = CScript([OP_CHECKSIG] * checksig_count)\n-        tx2.vout.append(CTxOut(0, script_pubkey_checksigs))\n-        tx2.vin.pop()\n-        tx2.wit.vtxinwit.pop()\n-        tx2.vout[0].nValue -= tx.vout[-2].nValue\n-        tx2.rehash()\n-        block_3 = self.build_next_block()\n-        self.update_witness_block_with_transactions(block_3, [tx2])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block_3, accepted=False)\n-\n-        # If we drop the last checksig in this output, the tx should succeed.\n-        block_4 = self.build_next_block()\n-        tx2.vout[-1].scriptPubKey = CScript([OP_CHECKSIG] * (checksig_count - 1))\n-        tx2.rehash()\n-        self.update_witness_block_with_transactions(block_4, [tx2])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block_4, accepted=True)\n-\n-        # Reset the tip back down for the next test\n-        sync_blocks(self.nodes)\n-        for x in self.nodes:\n-            x.invalidateblock(block_4.hash)\n-\n-        # Try replacing the last input of tx2 to be spending the last\n-        # output of tx\n-        block_5 = self.build_next_block()\n-        tx2.vout.pop()\n-        tx2.vin.append(CTxIn(COutPoint(tx.sha256, outputs - 1), b\"\"))\n-        tx2.wit.vtxinwit.append(CTxInWitness())\n-        tx2.wit.vtxinwit[-1].scriptWitness.stack = [witness_program_justright]\n-        tx2.rehash()\n-        self.update_witness_block_with_transactions(block_5, [tx2])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block_5, accepted=True)\n-\n-        # TODO: test p2sh sigop counting\n-\n-    def test_getblocktemplate_before_lockin(self):\n-        self.log.info(\"Testing getblocktemplate setting of segwit versionbit (before lockin)\")\n-        # Node0 is segwit aware, node2 is not.\n-        for node in [self.nodes[0], self.nodes[2]]:\n-            gbt_results = node.getblocktemplate()\n-            block_version = gbt_results['version']\n-            # If we're not indicating segwit support, we will still be\n-            # signalling for segwit activation.\n-            assert_equal((block_version & (1 << VB_WITNESS_BIT) != 0), node == self.nodes[0])\n-            # If we don't specify the segwit rule, then we won't get a default\n-            # commitment.\n-            assert('default_witness_commitment' not in gbt_results)\n-\n-        # Workaround:\n-        # Can either change the tip, or change the mempool and wait 5 seconds\n-        # to trigger a recomputation of getblocktemplate.\n-        txid = int(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1), 16)\n-        # Using mocktime lets us avoid sleep()\n-        sync_mempools(self.nodes)\n-        self.nodes[0].setmocktime(int(time.time()) + 10)\n-        self.nodes[2].setmocktime(int(time.time()) + 10)\n-\n-        for node in [self.nodes[0], self.nodes[2]]:\n-            gbt_results = node.getblocktemplate({\"rules\": [\"segwit\"]})\n-            block_version = gbt_results['version']\n-            if node == self.nodes[2]:\n-                # If this is a non-segwit node, we should still not get a witness\n-                # commitment, nor a version bit signalling segwit.\n-                assert_equal(block_version & (1 << VB_WITNESS_BIT), 0)\n-                assert('default_witness_commitment' not in gbt_results)\n-            else:\n-                # For segwit-aware nodes, check the version bit and the witness\n-                # commitment are correct.\n-                assert(block_version & (1 << VB_WITNESS_BIT) != 0)\n-                assert('default_witness_commitment' in gbt_results)\n-                witness_commitment = gbt_results['default_witness_commitment']\n-\n-                # Check that default_witness_commitment is present.\n-                witness_root = CBlock.get_merkle_root([ser_uint256(0),\n-                                                       ser_uint256(txid)])\n-                script = get_witness_script(witness_root, 0)\n-                assert_equal(witness_commitment, bytes_to_hex_str(script))\n-\n-        # undo mocktime\n-        self.nodes[0].setmocktime(0)\n-        self.nodes[2].setmocktime(0)\n-\n-    def test_uncompressed_pubkey(self):\n-        \"\"\"Test uncompressed pubkey validity in segwit transactions.\n-\n-        Uncompressed pubkeys are no longer supported in default relay policy,\n-        but (for now) are still valid in blocks.\"\"\"\n-\n-        self.log.info(\"Testing uncompressed pubkeys\")\n-        # Segwit transactions using uncompressed pubkeys are not accepted\n-        # under default policy, but should still pass consensus.\n-        key = CECKey()\n-        key.set_secretbytes(b\"9\")\n-        key.set_compressed(False)\n-        pubkey = CPubKey(key.get_pubkey())\n-        assert_equal(len(pubkey), 65)  # This should be an uncompressed pubkey\n-\n-        assert(len(self.utxo) > 0)\n-        utxo = self.utxo.pop(0)\n-\n-        # Test 1: P2WPKH\n-        # First create a P2WPKH output that uses an uncompressed pubkey\n-        pubkeyhash = hash160(pubkey)\n-        script_pkh = CScript([OP_0, pubkeyhash])\n-        tx = CTransaction()\n-        tx.vin.append(CTxIn(COutPoint(utxo.sha256, utxo.n), b\"\"))\n-        tx.vout.append(CTxOut(utxo.nValue - 1000, script_pkh))\n-        tx.rehash()\n-\n-        # Confirm it in a block.\n-        block = self.build_next_block()\n-        self.update_witness_block_with_transactions(block, [tx])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n-\n-        # Now try to spend it. Send it to a P2WSH output, which we'll\n-        # use in the next test.\n-        witness_program = CScript([pubkey, CScriptOp(OP_CHECKSIG)])\n-        witness_hash = sha256(witness_program)\n-        script_wsh = CScript([OP_0, witness_hash])\n-\n+        tx.vout.append(CTxOut(temp_utxos[0].nValue, script_pkh))\n+        tx.wit.vtxinwit.append(CTxInWitness())\n+        sign_p2pk_witness_input(witness_program, tx, 0, SIGHASH_ALL, temp_utxos[0].nValue, key)\n         tx2 = CTransaction()\n         tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n-        tx2.vout.append(CTxOut(tx.vout[0].nValue - 1000, script_wsh))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue, CScript([OP_TRUE])))\n+\n         script = get_p2pkh_script(pubkeyhash)\n         sig_hash = SegwitVersion1SignatureHash(script, tx2, 0, SIGHASH_ALL, tx.vout[0].nValue)\n         signature = key.sign(sig_hash) + b'\\x01'  # 0x1 is SIGHASH_ALL\n+\n+        # Check that we can't have a scriptSig\n+        tx2.vin[0].scriptSig = CScript([signature, pubkey])\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx, tx2])\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n+\n+        # Move the signature to the witness.\n+        block.vtx.pop()\n         tx2.wit.vtxinwit.append(CTxInWitness())\n         tx2.wit.vtxinwit[0].scriptWitness.stack = [signature, pubkey]\n+        tx2.vin[0].scriptSig = b\"\"\n         tx2.rehash()\n \n-        # Should fail policy test.\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx2, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n-        # But passes consensus.\n-        block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx2])\n         test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n \n-        # Test 2: P2WSH\n-        # Try to spend the P2WSH output created in last test.\n-        # Send it to a P2SH(P2WSH) output, which we'll use in the next test.\n-        p2sh_witness_hash = hash160(script_wsh)\n-        script_p2sh = CScript([OP_HASH160, p2sh_witness_hash, OP_EQUAL])\n-        script_sig = CScript([script_wsh])\n-\n-        tx3 = CTransaction()\n-        tx3.vin.append(CTxIn(COutPoint(tx2.sha256, 0), b\"\"))\n-        tx3.vout.append(CTxOut(tx2.vout[0].nValue - 1000, script_p2sh))\n-        tx3.wit.vtxinwit.append(CTxInWitness())\n-        sign_p2pk_witness_input(witness_program, tx3, 0, SIGHASH_ALL, tx2.vout[0].nValue, key)\n-\n-        # Should fail policy test.\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx3, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n-        # But passes consensus.\n-        block = self.build_next_block()\n-        self.update_witness_block_with_transactions(block, [tx3])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n+        temp_utxos.pop(0)\n \n-        # Test 3: P2SH(P2WSH)\n-        # Try to spend the P2SH output created in the last test.\n-        # Send it to a P2PKH output, which we'll use in the next test.\n-        script_pubkey = get_p2pkh_script(pubkeyhash)\n-        tx4 = CTransaction()\n-        tx4.vin.append(CTxIn(COutPoint(tx3.sha256, 0), script_sig))\n-        tx4.vout.append(CTxOut(tx3.vout[0].nValue - 1000, script_pubkey))\n-        tx4.wit.vtxinwit.append(CTxInWitness())\n-        sign_p2pk_witness_input(witness_program, tx4, 0, SIGHASH_ALL, tx3.vout[0].nValue, key)\n+        # Update self.utxos for later tests by creating two outputs\n+        # that consolidate all the coins in temp_utxos.\n+        output_value = sum(i.nValue for i in temp_utxos) // 2\n \n-        # Should fail policy test.\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx4, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n+        tx = CTransaction()\n+        index = 0\n+        # Just spend to our usual anyone-can-spend output\n+        tx.vout = [CTxOut(output_value, CScript([OP_TRUE]))] * 2\n+        for i in temp_utxos:\n+            # Use SIGHASH_ALL|SIGHASH_ANYONECANPAY so we can build up\n+            # the signatures as we go.\n+            tx.vin.append(CTxIn(COutPoint(i.sha256, i.n), b\"\"))\n+            tx.wit.vtxinwit.append(CTxInWitness())\n+            sign_p2pk_witness_input(witness_program, tx, index, SIGHASH_ALL | SIGHASH_ANYONECANPAY, i.nValue, key)\n+            index += 1\n         block = self.build_next_block()\n-        self.update_witness_block_with_transactions(block, [tx4])\n+        self.update_witness_block_with_transactions(block, [tx])\n         test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n \n-        # Test 4: Uncompressed pubkeys should still be valid in non-segwit\n-        # transactions.\n-        tx5 = CTransaction()\n-        tx5.vin.append(CTxIn(COutPoint(tx4.sha256, 0), b\"\"))\n-        tx5.vout.append(CTxOut(tx4.vout[0].nValue - 1000, CScript([OP_TRUE])))\n-        (sig_hash, err) = SignatureHash(script_pubkey, tx5, 0, SIGHASH_ALL)\n-        signature = key.sign(sig_hash) + b'\\x01'  # 0x1 is SIGHASH_ALL\n-        tx5.vin[0].scriptSig = CScript([signature, pubkey])\n-        tx5.rehash()\n-        # Should pass policy and consensus.\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx5, True, True)\n-        block = self.build_next_block()\n-        self.update_witness_block_with_transactions(block, [tx5])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n-        self.utxo.append(UTXO(tx5.sha256, 0, tx5.vout[0].nValue))\n+        for i in range(len(tx.vout)):\n+            self.utxo.append(UTXO(tx.sha256, i, tx.vout[i].nValue))\n \n     def test_non_standard_witness_blinding(self):\n         self.log.info(\"Testing behavior of unnecessary witnesses in transactions does not blind the node for the transaction\")\n@@ -2030,76 +1968,135 @@ def test_non_standard_witness(self):\n \n         self.utxo.pop(0)\n \n-    def run_test(self):\n-        # Setup the p2p connections\n-        # self.test_node sets NODE_WITNESS|NODE_NETWORK\n-        self.test_node = self.nodes[0].add_p2p_connection(TestP2PConn(), services=NODE_NETWORK | NODE_WITNESS)\n-        # self.old_node sets only NODE_NETWORK\n-        self.old_node = self.nodes[0].add_p2p_connection(TestP2PConn(), services=NODE_NETWORK)\n-        # self.std_node is for testing node1 (fRequireStandard=true)\n-        self.std_node = self.nodes[1].add_p2p_connection(TestP2PConn(), services=NODE_NETWORK | NODE_WITNESS)\n-\n-        # Keep a place to store utxo's that can be used in later tests\n-        self.utxo = []\n+    def test_upgrade_after_activation(self, node_id):\n+        \"\"\"Test the behavior of starting up a segwit-aware node after the softfork has activated.\"\"\"\n+        self.log.info(\"Testing software upgrade after softfork activation\")\n \n-        # Test logic begins here\n-        self.test_node.wait_for_verack()\n+        assert(node_id != 0)  # node0 is assumed to be a segwit-active bitcoind\n \n-        self.log.info(\"Starting tests before segwit lock in:\")\n+        # Make sure the nodes are all up\n+        sync_blocks(self.nodes)\n \n-        self.test_witness_services()  # Verifies NODE_WITNESS\n-        self.test_non_witness_transaction()  # non-witness tx's are accepted\n-        self.test_unnecessary_witness_before_segwit_activation()\n-        self.test_v0_outputs_arent_spendable()\n-        self.test_block_relay(segwit_activated=False)\n+        # Restart with the new binary\n+        self.stop_node(node_id)\n+        self.start_node(node_id, extra_args=[\"-vbparams=segwit:0:999999999999\"])\n+        connect_nodes(self.nodes[0], node_id)\n \n-        # Advance to segwit being 'started'\n-        self.advance_to_segwit_started()\n         sync_blocks(self.nodes)\n-        self.test_getblocktemplate_before_lockin()\n \n-        sync_blocks(self.nodes)\n+        # Make sure that this peer thinks segwit has activated.\n+        assert(get_bip9_status(self.nodes[node_id], 'segwit')['status'] == \"active\")\n \n-        # At lockin, nothing should change.\n-        self.log.info(\"Testing behavior post lockin, pre-activation\")\n-        self.advance_to_segwit_lockin()\n+        # Make sure this peer's blocks match those of node0.\n+        height = self.nodes[node_id].getblockcount()\n+        while height >= 0:\n+            block_hash = self.nodes[node_id].getblockhash(height)\n+            assert_equal(block_hash, self.nodes[0].getblockhash(height))\n+            assert_equal(self.nodes[0].getblock(block_hash), self.nodes[node_id].getblock(block_hash))\n+            height -= 1\n \n-        # Retest unnecessary witnesses\n-        self.test_unnecessary_witness_before_segwit_activation()\n-        self.test_witness_tx_relay_before_segwit_activation()\n-        self.test_block_relay(segwit_activated=False)\n-        self.test_standardness_v0(segwit_activated=False)\n+    def test_witness_sigops(self):\n+        \"\"\"Test sigop counting is correct inside witnesses.\"\"\"\n+        self.log.info(\"Testing sigops limit\")\n \n-        sync_blocks(self.nodes)\n+        assert(len(self.utxo))\n \n-        # Now activate segwit\n-        self.log.info(\"Testing behavior after segwit activation\")\n-        self.advance_to_segwit_active()\n+        # Keep this under MAX_OPS_PER_SCRIPT (201)\n+        witness_program = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKMULTISIG] * 5 + [OP_CHECKSIG] * 193 + [OP_ENDIF])\n+        witness_hash = sha256(witness_program)\n+        script_pubkey = CScript([OP_0, witness_hash])\n \n-        sync_blocks(self.nodes)\n+        sigops_per_script = 20 * 5 + 193 * 1\n+        # We'll produce 2 extra outputs, one with a program that would take us\n+        # over max sig ops, and one with a program that would exactly reach max\n+        # sig ops\n+        outputs = (MAX_SIGOP_COST // sigops_per_script) + 2\n+        extra_sigops_available = MAX_SIGOP_COST % sigops_per_script\n \n-        # Test P2SH witness handling again\n-        self.test_p2sh_witness(segwit_activated=True)\n-        self.test_witness_commitments()\n-        self.test_block_malleability()\n-        self.test_witness_block_size()\n-        self.test_submit_block()\n-        self.test_extra_witness_data()\n-        self.test_max_witness_push_length()\n-        self.test_max_witness_program_length()\n-        self.test_witness_input_length()\n-        self.test_block_relay(segwit_activated=True)\n-        self.test_tx_relay_after_segwit_activation()\n-        self.test_standardness_v0(segwit_activated=True)\n-        self.test_segwit_versions()\n-        self.test_premature_coinbase_witness_spend()\n-        self.test_uncompressed_pubkey()\n-        self.test_signature_version_1()\n-        self.test_non_standard_witness_blinding()\n-        self.test_non_standard_witness()\n+        # We chose the number of checkmultisigs/checksigs to make this work:\n+        assert(extra_sigops_available < 100)  # steer clear of MAX_OPS_PER_SCRIPT\n+\n+        # This script, when spent with the first\n+        # N(=MAX_SIGOP_COST//sigops_per_script) outputs of our transaction,\n+        # would push us just over the block sigop limit.\n+        witness_program_toomany = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKSIG] * (extra_sigops_available + 1) + [OP_ENDIF])\n+        witness_hash_toomany = sha256(witness_program_toomany)\n+        script_pubkey_toomany = CScript([OP_0, witness_hash_toomany])\n+\n+        # If we spend this script instead, we would exactly reach our sigop\n+        # limit (for witness sigops).\n+        witness_program_justright = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKSIG] * (extra_sigops_available) + [OP_ENDIF])\n+        witness_hash_justright = sha256(witness_program_justright)\n+        script_pubkey_justright = CScript([OP_0, witness_hash_justright])\n+\n+        # First split our available utxo into a bunch of outputs\n+        split_value = self.utxo[0].nValue // outputs\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        for i in range(outputs):\n+            tx.vout.append(CTxOut(split_value, script_pubkey))\n+        tx.vout[-2].scriptPubKey = script_pubkey_toomany\n+        tx.vout[-1].scriptPubKey = script_pubkey_justright\n+        tx.rehash()\n+\n+        block_1 = self.build_next_block()\n+        self.update_witness_block_with_transactions(block_1, [tx])\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block_1, accepted=True)\n+\n+        tx2 = CTransaction()\n+        # If we try to spend the first n-1 outputs from tx, that should be\n+        # too many sigops.\n+        total_value = 0\n+        for i in range(outputs - 1):\n+            tx2.vin.append(CTxIn(COutPoint(tx.sha256, i), b\"\"))\n+            tx2.wit.vtxinwit.append(CTxInWitness())\n+            tx2.wit.vtxinwit[-1].scriptWitness.stack = [witness_program]\n+            total_value += tx.vout[i].nValue\n+        tx2.wit.vtxinwit[-1].scriptWitness.stack = [witness_program_toomany]\n+        tx2.vout.append(CTxOut(total_value, CScript([OP_TRUE])))\n+        tx2.rehash()\n+\n+        block_2 = self.build_next_block()\n+        self.update_witness_block_with_transactions(block_2, [tx2])\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block_2, accepted=False)\n+\n+        # Try dropping the last input in tx2, and add an output that has\n+        # too many sigops (contributing to legacy sigop count).\n+        checksig_count = (extra_sigops_available // 4) + 1\n+        script_pubkey_checksigs = CScript([OP_CHECKSIG] * checksig_count)\n+        tx2.vout.append(CTxOut(0, script_pubkey_checksigs))\n+        tx2.vin.pop()\n+        tx2.wit.vtxinwit.pop()\n+        tx2.vout[0].nValue -= tx.vout[-2].nValue\n+        tx2.rehash()\n+        block_3 = self.build_next_block()\n+        self.update_witness_block_with_transactions(block_3, [tx2])\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block_3, accepted=False)\n+\n+        # If we drop the last checksig in this output, the tx should succeed.\n+        block_4 = self.build_next_block()\n+        tx2.vout[-1].scriptPubKey = CScript([OP_CHECKSIG] * (checksig_count - 1))\n+        tx2.rehash()\n+        self.update_witness_block_with_transactions(block_4, [tx2])\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block_4, accepted=True)\n+\n+        # Reset the tip back down for the next test\n         sync_blocks(self.nodes)\n-        self.test_upgrade_after_activation(node_id=2)\n-        self.test_witness_sigops()\n+        for x in self.nodes:\n+            x.invalidateblock(block_4.hash)\n+\n+        # Try replacing the last input of tx2 to be spending the last\n+        # output of tx\n+        block_5 = self.build_next_block()\n+        tx2.vout.pop()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, outputs - 1), b\"\"))\n+        tx2.wit.vtxinwit.append(CTxInWitness())\n+        tx2.wit.vtxinwit[-1].scriptWitness.stack = [witness_program_justright]\n+        tx2.rehash()\n+        self.update_witness_block_with_transactions(block_5, [tx2])\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block_5, accepted=True)\n+\n+        # TODO: test p2sh sigop counting\n \n if __name__ == '__main__':\n     SegWitTest().main()"
      }
    ]
  },
  {
    "sha": "bfe32734dedbb90ae04fc0e82a87ae760b647d39",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiZmUzMjczNGRlZGJiOTBhZTA0ZmMwZTgyYTg3YWU3NjBiNjQ3ZDM5",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-06-13T19:58:59Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-06-29T19:34:22Z"
      },
      "message": "[tests] p2p_segwit: wrap subtests with subtest wrapper.\n\nThe subtest wrapper logs the name of the subtest.",
      "tree": {
        "sha": "14bb2261aa4b416dc3987d2cba68d53cfe08275e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/14bb2261aa4b416dc3987d2cba68d53cfe08275e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bfe32734dedbb90ae04fc0e82a87ae760b647d39",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bfe32734dedbb90ae04fc0e82a87ae760b647d39",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bfe32734dedbb90ae04fc0e82a87ae760b647d39",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bfe32734dedbb90ae04fc0e82a87ae760b647d39/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2af4e398dc7cd7529a43d8832621dfb40b467eb9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2af4e398dc7cd7529a43d8832621dfb40b467eb9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2af4e398dc7cd7529a43d8832621dfb40b467eb9"
      }
    ],
    "stats": {
      "total": 72,
      "additions": 46,
      "deletions": 26
    },
    "files": [
      {
        "sha": "76be5fe215f5023ca90189e9ffe5960f59b66c27",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 46,
        "deletions": 26,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bfe32734dedbb90ae04fc0e82a87ae760b647d39/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bfe32734dedbb90ae04fc0e82a87ae760b647d39/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=bfe32734dedbb90ae04fc0e82a87ae760b647d39",
        "patch": "@@ -292,15 +292,24 @@ def run_test(self):\n \n     # Individual tests\n \n+    def subtest(func):  # noqa: N805\n+        \"\"\"Wraps the subtests for logging and state assertions.\"\"\"\n+        def func_wrapper(self, *args, **kwargs):\n+            self.log.info(\"Subtest: {}\".format(func.__name__))\n+            func(self, *args, **kwargs)\n+\n+        return func_wrapper\n+\n     def test_witness_services(self):\n         self.log.info(\"Verifying NODE_WITNESS service bit\")\n         assert((self.test_node.nServices & NODE_WITNESS) != 0)\n \n+    @subtest\n     def test_non_witness_transaction(self):\n         \"\"\"See if sending a regular transaction works, and create a utxo to use in later tests.\"\"\"\n         # Mine a block with an anyone-can-spend coinbase,\n         # let it mature, then try to spend it.\n-        self.log.info(\"Testing non-witness transaction\")\n+\n         block = self.build_next_block(version=1)\n         block.solve()\n         self.test_node.send_message(msg_block(block))\n@@ -326,9 +335,10 @@ def test_non_witness_transaction(self):\n         self.utxo.append(UTXO(tx.sha256, 0, 49 * 100000000))\n         self.nodes[0].generate(1)\n \n+    @subtest\n     def test_unnecessary_witness_before_segwit_activation(self):\n         \"\"\"Verify that blocks with witnesses are rejected before activation.\"\"\"\n-        self.log.info(\"Testing behavior of unnecessary witnesses\")\n+\n         # For now, rely on earlier tests to have created at least one utxo for\n         # us to use\n         assert(len(self.utxo) > 0)\n@@ -368,12 +378,12 @@ def test_unnecessary_witness_before_segwit_activation(self):\n         self.utxo.pop(0)\n         self.utxo.append(UTXO(tx.sha256, 0, tx.vout[0].nValue))\n \n+    @subtest\n     def test_block_relay(self, segwit_activated):\n         \"\"\"Test that block requests to NODE_WITNESS peer are with MSG_WITNESS_FLAG.\n \n         This is true regardless of segwit activation.\n         Also test that we don't ask for blocks from unupgraded peers.\"\"\"\n-        self.log.info(\"Testing block relay\")\n \n         blocktype = 2 | MSG_WITNESS_FLAG\n \n@@ -464,6 +474,7 @@ def test_block_relay(self, segwit_activated):\n             self.old_node.announce_tx_and_wait_for_getdata(block4.vtx[0])\n             assert(block4.sha256 not in self.old_node.getdataset)\n \n+    @subtest\n     def test_v0_outputs_arent_spendable(self):\n         \"\"\"Test that v0 outputs aren't spendable before segwit activation.\n \n@@ -475,8 +486,6 @@ def test_v0_outputs_arent_spendable(self):\n         witness, and so can't be spent before segwit activation (the point at which\n         blocks are permitted to contain witnesses).\"\"\"\n \n-        self.log.info(\"Testing that v0 witness program outputs aren't spendable before activation\")\n-\n         assert len(self.utxo), \"self.utxo is empty\"\n \n         # Create two outputs, a p2wsh and p2sh-p2wsh\n@@ -542,6 +551,7 @@ def test_v0_outputs_arent_spendable(self):\n         self.utxo.pop(0)\n         self.utxo.append(UTXO(txid, 2, value))\n \n+    @subtest\n     def advance_to_segwit_started(self):\n         \"\"\"Mine enough blocks for segwit's vb state to be 'started'.\"\"\"\n         height = self.nodes[0].getblockcount()\n@@ -553,8 +563,8 @@ def advance_to_segwit_started(self):\n         self.nodes[0].generate(VB_PERIOD - height - 1)\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'started')\n \n+    @subtest\n     def test_getblocktemplate_before_lockin(self):\n-        self.log.info(\"Testing getblocktemplate setting of segwit versionbit (before lockin)\")\n         # Node0 is segwit aware, node2 is not.\n         for node in [self.nodes[0], self.nodes[2]]:\n             gbt_results = node.getblocktemplate()\n@@ -600,6 +610,7 @@ def test_getblocktemplate_before_lockin(self):\n         self.nodes[0].setmocktime(0)\n         self.nodes[2].setmocktime(0)\n \n+    @subtest\n     def advance_to_segwit_lockin(self):\n         \"\"\"Mine enough blocks to lock in segwit, but don't activate.\"\"\"\n         # TODO: we could verify that lockin only happens at the right threshold of\n@@ -615,8 +626,9 @@ def advance_to_segwit_lockin(self):\n         self.nodes[0].generate(1)\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'locked_in')\n \n+    @subtest\n     def test_witness_tx_relay_before_segwit_activation(self):\n-        self.log.info(\"Testing relay of witness transactions\")\n+\n         # Generate a transaction that doesn't require a witness, but send it\n         # with a witness.  Should be rejected for premature-witness, but should\n         # not be added to recently rejected list.\n@@ -657,13 +669,13 @@ def test_witness_tx_relay_before_segwit_activation(self):\n         self.utxo.pop(0)\n         self.utxo.append(UTXO(tx_hash, 0, tx_value))\n \n+    @subtest\n     def test_standardness_v0(self, segwit_activated):\n         \"\"\"Test V0 txout standardness.\n \n         V0 segwit outputs and inputs are always standard.\n         V0 segwit inputs may only be mined after activation, but not before.\"\"\"\n \n-        self.log.info(\"Testing standardness of v0 outputs (%s activation)\" % (\"after\" if segwit_activated else \"before\"))\n         assert(len(self.utxo))\n \n         witness_program = CScript([OP_TRUE])\n@@ -737,6 +749,7 @@ def test_standardness_v0(self, segwit_activated):\n         self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n         assert_equal(len(self.nodes[1].getrawmempool()), 0)\n \n+    @subtest\n     def advance_to_segwit_active(self):\n         \"\"\"Mine enough blocks to activate segwit.\"\"\"\n         # TODO: we could verify that activation only happens at the right threshold\n@@ -749,9 +762,9 @@ def advance_to_segwit_active(self):\n         self.nodes[0].generate(1)\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'active')\n \n+    @subtest\n     def test_p2sh_witness(self, segwit_activated):\n         \"\"\"Test P2SH wrapped witness programs.\"\"\"\n-        self.log.info(\"Testing P2SH witness transactions\")\n \n         assert(len(self.utxo))\n \n@@ -819,13 +832,12 @@ def test_p2sh_witness(self, segwit_activated):\n         self.utxo.pop(0)\n         self.utxo.append(UTXO(spend_tx.sha256, 0, spend_tx.vout[0].nValue))\n \n+    @subtest\n     def test_witness_commitments(self):\n         \"\"\"Test witness commitments.\n \n         This test can only be run after segwit has activated.\"\"\"\n \n-        self.log.info(\"Testing witness commitments\")\n-\n         # First try a correct witness commitment.\n         block = self.build_next_block()\n         add_witness_commitment(block)\n@@ -911,8 +923,8 @@ def test_witness_commitments(self):\n         self.utxo.pop(0)\n         self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n \n+    @subtest\n     def test_block_malleability(self):\n-        self.log.info(\"Testing witness block malleability\")\n \n         # Make sure that a block that has too big a virtual size\n         # because of a too-large coinbase witness is not permanently\n@@ -951,8 +963,8 @@ def test_block_malleability(self):\n         block.vtx[0].wit.vtxinwit[0].scriptWitness.stack = [ser_uint256(0)]\n         test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n \n+    @subtest\n     def test_witness_block_size(self):\n-        self.log.info(\"Testing witness block size limit\")\n         # TODO: Test that non-witness carrying blocks can't exceed 1MB\n         # Skipping this test for now; this is covered in p2p-fullblocktest.py\n \n@@ -1029,6 +1041,7 @@ def test_witness_block_size(self):\n         self.utxo.pop(0)\n         self.utxo.append(UTXO(block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue))\n \n+    @subtest\n     def test_submit_block(self):\n         \"\"\"Test that submitblock adds the nonce automatically when possible.\"\"\"\n         block = self.build_next_block()\n@@ -1064,9 +1077,9 @@ def test_submit_block(self):\n         # Tip should not advance!\n         assert(self.nodes[0].getbestblockhash() != block_2.hash)\n \n+    @subtest\n     def test_extra_witness_data(self):\n         \"\"\"Test extra witness data in a transaction.\"\"\"\n-        self.log.info(\"Testing extra witness data in tx\")\n \n         assert(len(self.utxo) > 0)\n \n@@ -1139,9 +1152,10 @@ def test_extra_witness_data(self):\n         self.utxo.pop(0)\n         self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n \n+    @subtest\n     def test_max_witness_push_length(self):\n         \"\"\"Test that witness stack can only allow up to 520 byte pushes.\"\"\"\n-        self.log.info(\"Testing maximum witness push size\")\n+\n         MAX_SCRIPT_ELEMENT_SIZE = 520\n         assert(len(self.utxo))\n \n@@ -1178,9 +1192,10 @@ def test_max_witness_push_length(self):\n         self.utxo.pop()\n         self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n \n+    @subtest\n     def test_max_witness_program_length(self):\n         \"\"\"Test that witness outputs greater than 10kB can't be spent.\"\"\"\n-        self.log.info(\"Testing maximum witness program length\")\n+\n         assert(len(self.utxo))\n         MAX_PROGRAM_LENGTH = 10000\n \n@@ -1226,9 +1241,10 @@ def test_max_witness_program_length(self):\n         self.utxo.pop()\n         self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n \n+    @subtest\n     def test_witness_input_length(self):\n         \"\"\"Test that vin length must match vtxinwit length.\"\"\"\n-        self.log.info(\"Testing witness input length\")\n+\n         assert(len(self.utxo))\n \n         witness_program = CScript([OP_DROP, OP_TRUE])\n@@ -1309,6 +1325,7 @@ def serialize_with_witness(self):\n         self.utxo.pop()\n         self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n \n+    @subtest\n     def test_tx_relay_after_segwit_activation(self):\n         \"\"\"Test transaction relay after segwit activation.\n \n@@ -1317,7 +1334,6 @@ def test_tx_relay_after_segwit_activation(self):\n         - accepts transactions with valid witnesses\n         and that witness transactions are relayed to non-upgraded peers.\"\"\"\n \n-        self.log.info(\"Testing relay of witness transactions\")\n         # Generate a transaction that doesn't require a witness, but send it\n         # with a witness.  Should be rejected because we can't use a witness\n         # when spending a non-witness output.\n@@ -1403,13 +1419,13 @@ def test_tx_relay_after_segwit_activation(self):\n         self.utxo.pop(0)\n         self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n \n+    @subtest\n     def test_segwit_versions(self):\n         \"\"\"Test validity of future segwit version transactions.\n \n         Future segwit version transactions are non-standard, but valid in blocks.\n         Can run this before and after segwit activation.\"\"\"\n \n-        self.log.info(\"Testing standardness/consensus for segwit versions (0-16)\")\n         assert(len(self.utxo))\n         num_tests = 17  # will test OP_0, OP1, ..., OP_16\n         if (len(self.utxo) < num_tests):\n@@ -1491,8 +1507,9 @@ def test_segwit_versions(self):\n         # Add utxo to our list\n         self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n \n+    @subtest\n     def test_premature_coinbase_witness_spend(self):\n-        self.log.info(\"Testing premature coinbase witness spend\")\n+\n         block = self.build_next_block()\n         # Change the output of the block to be a witness output.\n         witness_program = CScript([OP_TRUE])\n@@ -1525,13 +1542,13 @@ def test_premature_coinbase_witness_spend(self):\n         test_witness_block(self.nodes[0].rpc, self.test_node, block2, accepted=True)\n         sync_blocks(self.nodes)\n \n+    @subtest\n     def test_uncompressed_pubkey(self):\n         \"\"\"Test uncompressed pubkey validity in segwit transactions.\n \n         Uncompressed pubkeys are no longer supported in default relay policy,\n         but (for now) are still valid in blocks.\"\"\"\n \n-        self.log.info(\"Testing uncompressed pubkeys\")\n         # Segwit transactions using uncompressed pubkeys are not accepted\n         # under default policy, but should still pass consensus.\n         key = CECKey()\n@@ -1632,8 +1649,9 @@ def test_uncompressed_pubkey(self):\n         test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n         self.utxo.append(UTXO(tx5.sha256, 0, tx5.vout[0].nValue))\n \n+    @subtest\n     def test_signature_version_1(self):\n-        self.log.info(\"Testing segwit signature hash version 1\")\n+\n         key = CECKey()\n         key.set_secretbytes(b\"9\")\n         pubkey = CPubKey(key.get_pubkey())\n@@ -1814,8 +1832,9 @@ def test_signature_version_1(self):\n         for i in range(len(tx.vout)):\n             self.utxo.append(UTXO(tx.sha256, i, tx.vout[i].nValue))\n \n+    @subtest\n     def test_non_standard_witness_blinding(self):\n-        self.log.info(\"Testing behavior of unnecessary witnesses in transactions does not blind the node for the transaction\")\n+        \"\"\"Test behavior of unnecessary witnesses in transactions does not blind the node for the transaction\"\"\"\n         assert (len(self.utxo) > 0)\n \n         # Create a p2sh output -- this is so we can pass the standardness\n@@ -1868,8 +1887,9 @@ def test_non_standard_witness_blinding(self):\n         self.utxo.pop(0)\n         self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n \n+    @subtest\n     def test_non_standard_witness(self):\n-        self.log.info(\"Testing detection of non-standard P2WSH witness\")\n+        \"\"\"Test detection of non-standard P2WSH witness\"\"\"\n         pad = chr(1).encode('latin-1')\n \n         # Create scripts for tests\n@@ -1968,9 +1988,9 @@ def test_non_standard_witness(self):\n \n         self.utxo.pop(0)\n \n+    @subtest\n     def test_upgrade_after_activation(self, node_id):\n         \"\"\"Test the behavior of starting up a segwit-aware node after the softfork has activated.\"\"\"\n-        self.log.info(\"Testing software upgrade after softfork activation\")\n \n         assert(node_id != 0)  # node0 is assumed to be a segwit-active bitcoind\n \n@@ -1995,9 +2015,9 @@ def test_upgrade_after_activation(self, node_id):\n             assert_equal(self.nodes[0].getblock(block_hash), self.nodes[node_id].getblock(block_hash))\n             height -= 1\n \n+    @subtest\n     def test_witness_sigops(self):\n         \"\"\"Test sigop counting is correct inside witnesses.\"\"\"\n-        self.log.info(\"Testing sigops limit\")\n \n         assert(len(self.utxo))\n "
      }
    ]
  },
  {
    "sha": "6839863d5365772d5fe7babe9dcdff6c97dd78c2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ODM5ODYzZDUzNjU3NzJkNWZlN2JhYmU5ZGNkZmY2Yzk3ZGQ3OGMy",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-06-13T20:37:10Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-06-29T19:35:07Z"
      },
      "message": "[tests] p2p_segwit: Make sure each subtest leaves utxos for the next.",
      "tree": {
        "sha": "04bafbaaedd1b10c1dcfcaa8a6756856524fb1ad",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/04bafbaaedd1b10c1dcfcaa8a6756856524fb1ad"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6839863d5365772d5fe7babe9dcdff6c97dd78c2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6839863d5365772d5fe7babe9dcdff6c97dd78c2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6839863d5365772d5fe7babe9dcdff6c97dd78c2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6839863d5365772d5fe7babe9dcdff6c97dd78c2/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bfe32734dedbb90ae04fc0e82a87ae760b647d39",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bfe32734dedbb90ae04fc0e82a87ae760b647d39",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bfe32734dedbb90ae04fc0e82a87ae760b647d39"
      }
    ],
    "stats": {
      "total": 42,
      "additions": 8,
      "deletions": 34
    },
    "files": [
      {
        "sha": "08e41de02ce84b72f4f10a5f6df58940d23d16b8",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 8,
        "deletions": 34,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6839863d5365772d5fe7babe9dcdff6c97dd78c2/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6839863d5365772d5fe7babe9dcdff6c97dd78c2/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=6839863d5365772d5fe7babe9dcdff6c97dd78c2",
        "patch": "@@ -228,16 +228,17 @@ def run_test(self):\n         # self.std_node is for testing node1 (fRequireStandard=true)\n         self.std_node = self.nodes[1].add_p2p_connection(TestP2PConn(), services=NODE_NETWORK | NODE_WITNESS)\n \n+        for conn in (self.test_node, self.old_node, self.std_node):\n+            conn.wait_for_verack()\n+\n+        assert self.test_node.nServices & NODE_WITNESS != 0\n+\n         # Keep a place to store utxo's that can be used in later tests\n         self.utxo = []\n \n-        # Test logic begins here\n-        self.test_node.wait_for_verack()\n-\n         self.log.info(\"Starting tests before segwit lock in:\")\n \n-        self.test_witness_services()  # Verifies NODE_WITNESS\n-        self.test_non_witness_transaction()  # non-witness tx's are accepted\n+        self.test_non_witness_transaction()\n         self.test_unnecessary_witness_before_segwit_activation()\n         self.test_v0_outputs_arent_spendable()\n         self.test_block_relay(segwit_activated=False)\n@@ -297,13 +298,11 @@ def subtest(func):  # noqa: N805\n         def func_wrapper(self, *args, **kwargs):\n             self.log.info(\"Subtest: {}\".format(func.__name__))\n             func(self, *args, **kwargs)\n+            # Each subtest should leave some utxos for the next subtest\n+            assert self.utxo\n \n         return func_wrapper\n \n-    def test_witness_services(self):\n-        self.log.info(\"Verifying NODE_WITNESS service bit\")\n-        assert((self.test_node.nServices & NODE_WITNESS) != 0)\n-\n     @subtest\n     def test_non_witness_transaction(self):\n         \"\"\"See if sending a regular transaction works, and create a utxo to use in later tests.\"\"\"\n@@ -339,9 +338,6 @@ def test_non_witness_transaction(self):\n     def test_unnecessary_witness_before_segwit_activation(self):\n         \"\"\"Verify that blocks with witnesses are rejected before activation.\"\"\"\n \n-        # For now, rely on earlier tests to have created at least one utxo for\n-        # us to use\n-        assert(len(self.utxo) > 0)\n         assert(get_bip9_status(self.nodes[0], 'segwit')['status'] != 'active')\n \n         tx = CTransaction()\n@@ -486,8 +482,6 @@ def test_v0_outputs_arent_spendable(self):\n         witness, and so can't be spent before segwit activation (the point at which\n         blocks are permitted to contain witnesses).\"\"\"\n \n-        assert len(self.utxo), \"self.utxo is empty\"\n-\n         # Create two outputs, a p2wsh and p2sh-p2wsh\n         witness_program = CScript([OP_TRUE])\n         witness_hash = sha256(witness_program)\n@@ -632,7 +626,6 @@ def test_witness_tx_relay_before_segwit_activation(self):\n         # Generate a transaction that doesn't require a witness, but send it\n         # with a witness.  Should be rejected for premature-witness, but should\n         # not be added to recently rejected list.\n-        assert(len(self.utxo))\n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n         tx.vout.append(CTxOut(self.utxo[0].nValue - 1000, CScript([OP_TRUE, OP_DROP] * 15 + [OP_TRUE])))\n@@ -676,8 +669,6 @@ def test_standardness_v0(self, segwit_activated):\n         V0 segwit outputs and inputs are always standard.\n         V0 segwit inputs may only be mined after activation, but not before.\"\"\"\n \n-        assert(len(self.utxo))\n-\n         witness_program = CScript([OP_TRUE])\n         witness_hash = sha256(witness_program)\n         script_pubkey = CScript([OP_0, witness_hash])\n@@ -766,8 +757,6 @@ def advance_to_segwit_active(self):\n     def test_p2sh_witness(self, segwit_activated):\n         \"\"\"Test P2SH wrapped witness programs.\"\"\"\n \n-        assert(len(self.utxo))\n-\n         # Prepare the p2sh-wrapped witness output\n         witness_program = CScript([OP_DROP, OP_TRUE])\n         witness_hash = sha256(witness_program)\n@@ -861,7 +850,6 @@ def test_witness_commitments(self):\n         test_witness_block(self.nodes[0].rpc, self.test_node, block_2, accepted=True)\n \n         # Now test commitments with actual transactions\n-        assert (len(self.utxo) > 0)\n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n \n@@ -1081,8 +1069,6 @@ def test_submit_block(self):\n     def test_extra_witness_data(self):\n         \"\"\"Test extra witness data in a transaction.\"\"\"\n \n-        assert(len(self.utxo) > 0)\n-\n         block = self.build_next_block()\n \n         witness_program = CScript([OP_DROP, OP_TRUE])\n@@ -1157,7 +1143,6 @@ def test_max_witness_push_length(self):\n         \"\"\"Test that witness stack can only allow up to 520 byte pushes.\"\"\"\n \n         MAX_SCRIPT_ELEMENT_SIZE = 520\n-        assert(len(self.utxo))\n \n         block = self.build_next_block()\n \n@@ -1196,7 +1181,6 @@ def test_max_witness_push_length(self):\n     def test_max_witness_program_length(self):\n         \"\"\"Test that witness outputs greater than 10kB can't be spent.\"\"\"\n \n-        assert(len(self.utxo))\n         MAX_PROGRAM_LENGTH = 10000\n \n         # This program is 19 max pushes (9937 bytes), then 64 more opcode-bytes.\n@@ -1245,8 +1229,6 @@ def test_max_witness_program_length(self):\n     def test_witness_input_length(self):\n         \"\"\"Test that vin length must match vtxinwit length.\"\"\"\n \n-        assert(len(self.utxo))\n-\n         witness_program = CScript([OP_DROP, OP_TRUE])\n         witness_hash = sha256(witness_program)\n         script_pubkey = CScript([OP_0, witness_hash])\n@@ -1337,7 +1319,6 @@ def test_tx_relay_after_segwit_activation(self):\n         # Generate a transaction that doesn't require a witness, but send it\n         # with a witness.  Should be rejected because we can't use a witness\n         # when spending a non-witness output.\n-        assert(len(self.utxo))\n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n         tx.vout.append(CTxOut(self.utxo[0].nValue - 1000, CScript([OP_TRUE, OP_DROP] * 15 + [OP_TRUE])))\n@@ -1426,7 +1407,6 @@ def test_segwit_versions(self):\n         Future segwit version transactions are non-standard, but valid in blocks.\n         Can run this before and after segwit activation.\"\"\"\n \n-        assert(len(self.utxo))\n         num_tests = 17  # will test OP_0, OP1, ..., OP_16\n         if (len(self.utxo) < num_tests):\n             tx = CTransaction()\n@@ -1557,7 +1537,6 @@ def test_uncompressed_pubkey(self):\n         pubkey = CPubKey(key.get_pubkey())\n         assert_equal(len(pubkey), 65)  # This should be an uncompressed pubkey\n \n-        assert(len(self.utxo) > 0)\n         utxo = self.utxo.pop(0)\n \n         # Test 1: P2WPKH\n@@ -1661,7 +1640,6 @@ def test_signature_version_1(self):\n         script_pubkey = CScript([OP_0, witness_hash])\n \n         # First create a witness output for use in the tests.\n-        assert(len(self.utxo))\n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n         tx.vout.append(CTxOut(self.utxo[0].nValue - 1000, script_pubkey))\n@@ -1835,7 +1813,6 @@ def test_signature_version_1(self):\n     @subtest\n     def test_non_standard_witness_blinding(self):\n         \"\"\"Test behavior of unnecessary witnesses in transactions does not blind the node for the transaction\"\"\"\n-        assert (len(self.utxo) > 0)\n \n         # Create a p2sh output -- this is so we can pass the standardness\n         # rules (an anyone-can-spend OP_TRUE would be rejected, if not wrapped\n@@ -1901,7 +1878,6 @@ def test_non_standard_witness(self):\n \n         p2wsh_scripts = []\n \n-        assert(len(self.utxo))\n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n \n@@ -2019,8 +1995,6 @@ def test_upgrade_after_activation(self, node_id):\n     def test_witness_sigops(self):\n         \"\"\"Test sigop counting is correct inside witnesses.\"\"\"\n \n-        assert(len(self.utxo))\n-\n         # Keep this under MAX_OPS_PER_SCRIPT (201)\n         witness_program = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKMULTISIG] * 5 + [OP_CHECKSIG] * 193 + [OP_ENDIF])\n         witness_hash = sha256(witness_program)"
      }
    ]
  },
  {
    "sha": "25711c2696f9b887304883c5f4bd8e9b713a3cca",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNTcxMWMyNjk2ZjliODg3MzA0ODgzYzVmNGJkOGU5YjcxM2EzY2Nh",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-06-13T20:48:04Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-06-29T19:35:07Z"
      },
      "message": "[tests] p2p_segwit: log and assert segwit status in subtest wrapper.",
      "tree": {
        "sha": "a1bb03736aef20fae587ad7a5fb3ad7ba2fdebee",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a1bb03736aef20fae587ad7a5fb3ad7ba2fdebee"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/25711c2696f9b887304883c5f4bd8e9b713a3cca",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/25711c2696f9b887304883c5f4bd8e9b713a3cca",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/25711c2696f9b887304883c5f4bd8e9b713a3cca",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/25711c2696f9b887304883c5f4bd8e9b713a3cca/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6839863d5365772d5fe7babe9dcdff6c97dd78c2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6839863d5365772d5fe7babe9dcdff6c97dd78c2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6839863d5365772d5fe7babe9dcdff6c97dd78c2"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 9,
      "deletions": 10
    },
    "files": [
      {
        "sha": "3467fce0f25abe9d25c230dbbaaaffbaccc30184",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 9,
        "deletions": 10,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/25711c2696f9b887304883c5f4bd8e9b713a3cca/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/25711c2696f9b887304883c5f4bd8e9b713a3cca/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=25711c2696f9b887304883c5f4bd8e9b713a3cca",
        "patch": "@@ -236,7 +236,7 @@ def run_test(self):\n         # Keep a place to store utxo's that can be used in later tests\n         self.utxo = []\n \n-        self.log.info(\"Starting tests before segwit lock in:\")\n+        self.segwit_status = 'defined'\n \n         self.test_non_witness_transaction()\n         self.test_unnecessary_witness_before_segwit_activation()\n@@ -251,7 +251,6 @@ def run_test(self):\n         sync_blocks(self.nodes)\n \n         # At lockin, nothing should change.\n-        self.log.info(\"Testing behavior post lockin, pre-activation\")\n         self.advance_to_segwit_lockin()\n \n         # Retest unnecessary witnesses\n@@ -263,7 +262,6 @@ def run_test(self):\n         sync_blocks(self.nodes)\n \n         # Now activate segwit\n-        self.log.info(\"Testing behavior after segwit activation\")\n         self.advance_to_segwit_active()\n \n         sync_blocks(self.nodes)\n@@ -296,10 +294,14 @@ def run_test(self):\n     def subtest(func):  # noqa: N805\n         \"\"\"Wraps the subtests for logging and state assertions.\"\"\"\n         def func_wrapper(self, *args, **kwargs):\n-            self.log.info(\"Subtest: {}\".format(func.__name__))\n+            self.log.info(\"Subtest: {} (Segwit status = {})\".format(func.__name__, self.segwit_status))\n+            # Assert segwit status is as expected\n+            assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], self.segwit_status)\n             func(self, *args, **kwargs)\n             # Each subtest should leave some utxos for the next subtest\n             assert self.utxo\n+            # Assert segwit status is as expected at end of subtest\n+            assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], self.segwit_status)\n \n         return func_wrapper\n \n@@ -338,8 +340,6 @@ def test_non_witness_transaction(self):\n     def test_unnecessary_witness_before_segwit_activation(self):\n         \"\"\"Verify that blocks with witnesses are rejected before activation.\"\"\"\n \n-        assert(get_bip9_status(self.nodes[0], 'segwit')['status'] != 'active')\n-\n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n         tx.vout.append(CTxOut(self.utxo[0].nValue - 1000, CScript([OP_TRUE])))\n@@ -551,11 +551,10 @@ def advance_to_segwit_started(self):\n         height = self.nodes[0].getblockcount()\n         # Will need to rewrite the tests here if we are past the first period\n         assert(height < VB_PERIOD - 1)\n-        # Genesis block is 'defined'.\n-        assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'defined')\n         # Advance to end of period, status should now be 'started'\n         self.nodes[0].generate(VB_PERIOD - height - 1)\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'started')\n+        self.segwit_status = 'started'\n \n     @subtest\n     def test_getblocktemplate_before_lockin(self):\n@@ -611,14 +610,14 @@ def advance_to_segwit_lockin(self):\n         # signalling blocks, rather than just at the right period boundary.\n \n         height = self.nodes[0].getblockcount()\n-        assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'started')\n         # Advance to end of period, and verify lock-in happens at the end\n         self.nodes[0].generate(VB_PERIOD - 1)\n         height = self.nodes[0].getblockcount()\n         assert((height % VB_PERIOD) == VB_PERIOD - 2)\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'started')\n         self.nodes[0].generate(1)\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'locked_in')\n+        self.segwit_status = 'locked_in'\n \n     @subtest\n     def test_witness_tx_relay_before_segwit_activation(self):\n@@ -746,12 +745,12 @@ def advance_to_segwit_active(self):\n         # TODO: we could verify that activation only happens at the right threshold\n         # of signalling blocks, rather than just at the right period boundary.\n \n-        assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'locked_in')\n         height = self.nodes[0].getblockcount()\n         self.nodes[0].generate(VB_PERIOD - (height % VB_PERIOD) - 2)\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'locked_in')\n         self.nodes[0].generate(1)\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'active')\n+        self.segwit_status = 'active'\n \n     @subtest\n     def test_p2sh_witness(self, segwit_activated):"
      }
    ]
  },
  {
    "sha": "55e8050853981a0e74396a04c5b53fce5f21ff41",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NWU4MDUwODUzOTgxYTBlNzQzOTZhMDRjNWI1M2ZjZTVmMjFmZjQx",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-06-13T21:03:40Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-06-29T19:35:07Z"
      },
      "message": "[tests] p2p_segwit: remove unnecessary arguments from subtests.",
      "tree": {
        "sha": "2616dbaf22a6889bcb4ae24e0561006c2213b9c6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2616dbaf22a6889bcb4ae24e0561006c2213b9c6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/55e8050853981a0e74396a04c5b53fce5f21ff41",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/55e8050853981a0e74396a04c5b53fce5f21ff41",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/55e8050853981a0e74396a04c5b53fce5f21ff41",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/55e8050853981a0e74396a04c5b53fce5f21ff41/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "25711c2696f9b887304883c5f4bd8e9b713a3cca",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/25711c2696f9b887304883c5f4bd8e9b713a3cca",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/25711c2696f9b887304883c5f4bd8e9b713a3cca"
      }
    ],
    "stats": {
      "total": 51,
      "additions": 23,
      "deletions": 28
    },
    "files": [
      {
        "sha": "d01da7b28191c132c6088de895f02af2e7240c8a",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 23,
        "deletions": 28,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/55e8050853981a0e74396a04c5b53fce5f21ff41/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/55e8050853981a0e74396a04c5b53fce5f21ff41/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=55e8050853981a0e74396a04c5b53fce5f21ff41",
        "patch": "@@ -241,7 +241,7 @@ def run_test(self):\n         self.test_non_witness_transaction()\n         self.test_unnecessary_witness_before_segwit_activation()\n         self.test_v0_outputs_arent_spendable()\n-        self.test_block_relay(segwit_activated=False)\n+        self.test_block_relay()\n \n         # Advance to segwit being 'started'\n         self.advance_to_segwit_started()\n@@ -256,8 +256,8 @@ def run_test(self):\n         # Retest unnecessary witnesses\n         self.test_unnecessary_witness_before_segwit_activation()\n         self.test_witness_tx_relay_before_segwit_activation()\n-        self.test_block_relay(segwit_activated=False)\n-        self.test_standardness_v0(segwit_activated=False)\n+        self.test_block_relay()\n+        self.test_standardness_v0()\n \n         sync_blocks(self.nodes)\n \n@@ -267,7 +267,7 @@ def run_test(self):\n         sync_blocks(self.nodes)\n \n         # Test P2SH witness handling again\n-        self.test_p2sh_witness(segwit_activated=True)\n+        self.test_p2sh_witness()\n         self.test_witness_commitments()\n         self.test_block_malleability()\n         self.test_witness_block_size()\n@@ -276,17 +276,17 @@ def run_test(self):\n         self.test_max_witness_push_length()\n         self.test_max_witness_program_length()\n         self.test_witness_input_length()\n-        self.test_block_relay(segwit_activated=True)\n+        self.test_block_relay()\n         self.test_tx_relay_after_segwit_activation()\n-        self.test_standardness_v0(segwit_activated=True)\n+        self.test_standardness_v0()\n         self.test_segwit_versions()\n         self.test_premature_coinbase_witness_spend()\n         self.test_uncompressed_pubkey()\n         self.test_signature_version_1()\n         self.test_non_standard_witness_blinding()\n         self.test_non_standard_witness()\n         sync_blocks(self.nodes)\n-        self.test_upgrade_after_activation(node_id=2)\n+        self.test_upgrade_after_activation()\n         self.test_witness_sigops()\n \n     # Individual tests\n@@ -375,7 +375,7 @@ def test_unnecessary_witness_before_segwit_activation(self):\n         self.utxo.append(UTXO(tx.sha256, 0, tx.vout[0].nValue))\n \n     @subtest\n-    def test_block_relay(self, segwit_activated):\n+    def test_block_relay(self):\n         \"\"\"Test that block requests to NODE_WITNESS peer are with MSG_WITNESS_FLAG.\n \n         This is true regardless of segwit activation.\n@@ -409,7 +409,7 @@ def test_block_relay(self, segwit_activated):\n \n         # Check that we can getdata for witness blocks or regular blocks,\n         # and the right thing happens.\n-        if not segwit_activated:\n+        if self.segwit_status != 'active':\n             # Before activation, we should be able to request old blocks with\n             # or without witness, and they should be the same.\n             chain_height = self.nodes[0].getblockcount()\n@@ -662,7 +662,7 @@ def test_witness_tx_relay_before_segwit_activation(self):\n         self.utxo.append(UTXO(tx_hash, 0, tx_value))\n \n     @subtest\n-    def test_standardness_v0(self, segwit_activated):\n+    def test_standardness_v0(self):\n         \"\"\"Test V0 txout standardness.\n \n         V0 segwit outputs and inputs are always standard.\n@@ -721,7 +721,7 @@ def test_standardness_v0(self, segwit_activated):\n         tx3.wit.vtxinwit.append(CTxInWitness())\n         tx3.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n         tx3.rehash()\n-        if not segwit_activated:\n+        if self.segwit_status != 'active':\n             # Just check mempool acceptance, but don't add the transaction to the mempool, since witness is disallowed\n             # in blocks and the tx is impossible to mine right now.\n             assert_equal(self.nodes[0].testmempoolaccept([bytes_to_hex_str(tx3.serialize_with_witness())]), [{'txid': tx3.hash, 'allowed': True}])\n@@ -753,7 +753,7 @@ def advance_to_segwit_active(self):\n         self.segwit_status = 'active'\n \n     @subtest\n-    def test_p2sh_witness(self, segwit_activated):\n+    def test_p2sh_witness(self):\n         \"\"\"Test P2SH wrapped witness programs.\"\"\"\n \n         # Prepare the p2sh-wrapped witness output\n@@ -774,7 +774,7 @@ def test_p2sh_witness(self, segwit_activated):\n         test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, with_witness=False, accepted=True)\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx])\n-        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True, with_witness=segwit_activated)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True, with_witness=True)\n         sync_blocks(self.nodes)\n \n         # Now test attempts to spend the output.\n@@ -803,18 +803,15 @@ def test_p2sh_witness(self, segwit_activated):\n         spend_tx.wit.vtxinwit[0].scriptWitness.stack = [b'a', witness_program]\n \n         # Verify mempool acceptance\n-        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, spend_tx, with_witness=True, accepted=segwit_activated)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, spend_tx, with_witness=True, accepted=True)\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [spend_tx])\n \n         # If we're after activation, then sending this with witnesses should be valid.\n         # This no longer works before activation, because SCRIPT_VERIFY_WITNESS\n         # is always set.\n         # TODO: rewrite this test to make clear that it only works after activation.\n-        if segwit_activated:\n-            test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n-        else:\n-            test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True, with_witness=False)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n \n         # Update self.utxo\n         self.utxo.pop(0)\n@@ -1964,30 +1961,28 @@ def test_non_standard_witness(self):\n         self.utxo.pop(0)\n \n     @subtest\n-    def test_upgrade_after_activation(self, node_id):\n+    def test_upgrade_after_activation(self):\n         \"\"\"Test the behavior of starting up a segwit-aware node after the softfork has activated.\"\"\"\n \n-        assert(node_id != 0)  # node0 is assumed to be a segwit-active bitcoind\n-\n         # Make sure the nodes are all up\n         sync_blocks(self.nodes)\n \n         # Restart with the new binary\n-        self.stop_node(node_id)\n-        self.start_node(node_id, extra_args=[\"-vbparams=segwit:0:999999999999\"])\n-        connect_nodes(self.nodes[0], node_id)\n+        self.stop_node(2)\n+        self.start_node(2, extra_args=[\"-vbparams=segwit:0:999999999999\"])\n+        connect_nodes(self.nodes[0], 2)\n \n         sync_blocks(self.nodes)\n \n         # Make sure that this peer thinks segwit has activated.\n-        assert(get_bip9_status(self.nodes[node_id], 'segwit')['status'] == \"active\")\n+        assert(get_bip9_status(self.nodes[2], 'segwit')['status'] == \"active\")\n \n         # Make sure this peer's blocks match those of node0.\n-        height = self.nodes[node_id].getblockcount()\n+        height = self.nodes[2].getblockcount()\n         while height >= 0:\n-            block_hash = self.nodes[node_id].getblockhash(height)\n+            block_hash = self.nodes[2].getblockhash(height)\n             assert_equal(block_hash, self.nodes[0].getblockhash(height))\n-            assert_equal(self.nodes[0].getblock(block_hash), self.nodes[node_id].getblock(block_hash))\n+            assert_equal(self.nodes[0].getblock(block_hash), self.nodes[2].getblock(block_hash))\n             height -= 1\n \n     @subtest"
      }
    ]
  },
  {
    "sha": "e3aab295e7c91d08bd577f9fb05f6bb8e585870a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplM2FhYjI5NWU3YzkxZDA4YmQ1NzdmOWZiMDVmNmJiOGU1ODU4NzBh",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-06-13T21:47:43Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-06-29T19:35:07Z"
      },
      "message": "[tests] p2p_segwit: sync_blocks in subtest wrapper.",
      "tree": {
        "sha": "d0e64159d7c9afc10b538897eded888a7097d2de",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d0e64159d7c9afc10b538897eded888a7097d2de"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e3aab295e7c91d08bd577f9fb05f6bb8e585870a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3aab295e7c91d08bd577f9fb05f6bb8e585870a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e3aab295e7c91d08bd577f9fb05f6bb8e585870a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3aab295e7c91d08bd577f9fb05f6bb8e585870a/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "55e8050853981a0e74396a04c5b53fce5f21ff41",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/55e8050853981a0e74396a04c5b53fce5f21ff41",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/55e8050853981a0e74396a04c5b53fce5f21ff41"
      }
    ],
    "stats": {
      "total": 34,
      "additions": 15,
      "deletions": 19
    },
    "files": [
      {
        "sha": "727f2d1c6ee008516025f04562be7d760818d971",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 15,
        "deletions": 19,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3aab295e7c91d08bd577f9fb05f6bb8e585870a/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3aab295e7c91d08bd577f9fb05f6bb8e585870a/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=e3aab295e7c91d08bd577f9fb05f6bb8e585870a",
        "patch": "@@ -75,6 +75,7 @@\n     assert_equal,\n     bytes_to_hex_str,\n     connect_nodes,\n+    disconnect_nodes,\n     get_bip9_status,\n     hex_str_to_bytes,\n     sync_blocks,\n@@ -236,37 +237,30 @@ def run_test(self):\n         # Keep a place to store utxo's that can be used in later tests\n         self.utxo = []\n \n+        # Segwit status 'defined'\n         self.segwit_status = 'defined'\n \n         self.test_non_witness_transaction()\n         self.test_unnecessary_witness_before_segwit_activation()\n         self.test_v0_outputs_arent_spendable()\n         self.test_block_relay()\n-\n-        # Advance to segwit being 'started'\n         self.advance_to_segwit_started()\n-        sync_blocks(self.nodes)\n-        self.test_getblocktemplate_before_lockin()\n \n-        sync_blocks(self.nodes)\n+        # Segwit status 'started'\n \n-        # At lockin, nothing should change.\n+        self.test_getblocktemplate_before_lockin()\n         self.advance_to_segwit_lockin()\n \n-        # Retest unnecessary witnesses\n+        # Segwit status 'locked_in'\n+\n         self.test_unnecessary_witness_before_segwit_activation()\n         self.test_witness_tx_relay_before_segwit_activation()\n         self.test_block_relay()\n         self.test_standardness_v0()\n-\n-        sync_blocks(self.nodes)\n-\n-        # Now activate segwit\n         self.advance_to_segwit_active()\n \n-        sync_blocks(self.nodes)\n+        # Segwit status 'active'\n \n-        # Test P2SH witness handling again\n         self.test_p2sh_witness()\n         self.test_witness_commitments()\n         self.test_block_malleability()\n@@ -285,7 +279,6 @@ def run_test(self):\n         self.test_signature_version_1()\n         self.test_non_standard_witness_blinding()\n         self.test_non_standard_witness()\n-        sync_blocks(self.nodes)\n         self.test_upgrade_after_activation()\n         self.test_witness_sigops()\n \n@@ -300,6 +293,7 @@ def func_wrapper(self, *args, **kwargs):\n             func(self, *args, **kwargs)\n             # Each subtest should leave some utxos for the next subtest\n             assert self.utxo\n+            sync_blocks(self.nodes)\n             # Assert segwit status is as expected at end of subtest\n             assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], self.segwit_status)\n \n@@ -368,8 +362,6 @@ def test_unnecessary_witness_before_segwit_activation(self):\n         self.test_node.sync_with_ping()\n         assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n \n-        sync_blocks(self.nodes)\n-\n         # Update our utxo list; we spent the first entry.\n         self.utxo.pop(0)\n         self.utxo.append(UTXO(tx.sha256, 0, tx.vout[0].nValue))\n@@ -482,6 +474,11 @@ def test_v0_outputs_arent_spendable(self):\n         witness, and so can't be spent before segwit activation (the point at which\n         blocks are permitted to contain witnesses).\"\"\"\n \n+        # node2 doesn't need to be connected for this test.\n+        # (If it's connected, node0 may propogate an invalid block to it over\n+        # compact blocks and the nodes would have inconsistent tips.)\n+        disconnect_nodes(self.nodes[0], 2)\n+\n         # Create two outputs, a p2wsh and p2sh-p2wsh\n         witness_program = CScript([OP_TRUE])\n         witness_hash = sha256(witness_program)\n@@ -542,6 +539,8 @@ def test_v0_outputs_arent_spendable(self):\n             # TODO: support multiple acceptable reject reasons.\n             test_witness_block(self.nodes[0], self.test_node, block, accepted=False, with_witness=False)\n \n+        connect_nodes(self.nodes[0], 2)\n+\n         self.utxo.pop(0)\n         self.utxo.append(UTXO(txid, 2, value))\n \n@@ -1964,9 +1963,6 @@ def test_non_standard_witness(self):\n     def test_upgrade_after_activation(self):\n         \"\"\"Test the behavior of starting up a segwit-aware node after the softfork has activated.\"\"\"\n \n-        # Make sure the nodes are all up\n-        sync_blocks(self.nodes)\n-\n         # Restart with the new binary\n         self.stop_node(2)\n         self.start_node(2, extra_args=[\"-vbparams=segwit:0:999999999999\"])"
      }
    ]
  }
]