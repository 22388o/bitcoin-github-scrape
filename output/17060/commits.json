[
  {
    "sha": "1fb877c38b02ac259f7f665b12472f7085929bff",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxZmI4NzdjMzhiMDJhYzI1OWY3ZjY2NWIxMjQ3MmY3MDg1OTI5YmZm",
    "commit": {
      "author": {
        "name": "Martin Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2019-09-25T18:38:32Z"
      },
      "committer": {
        "name": "Martin Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2019-11-08T15:57:48Z"
      },
      "message": "more tightly pack Coin\n\nThis change reduces CCoinMap's value_type from 96 bytes to 80 bytes by\nmore tightly packing it's data. This is achieved by these changes:\n\n* Refactored prevector so it uses a single byte to determine its size\n  when in direct mode\n* Reduce CScriptBase from 28 to 27 indirect bytes\n* Introduced PackableCAmount to be able to align CTxOut to 4 bytes to\n  prevent padding when used as a member in Coin\n\nThis tighter packing means more data can be stored in the coinsCache\nbefore it is full and has to be flushed to disk. In my benchmark,\n-reindex-chainstate was 6% faster and used 6% less memory. The cache\ncould fit 14% more txo's before it had to resize.",
      "tree": {
        "sha": "741f649dffa0a28b76285a35362ecbeb63de1231",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/741f649dffa0a28b76285a35362ecbeb63de1231"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1fb877c38b02ac259f7f665b12472f7085929bff",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1fb877c38b02ac259f7f665b12472f7085929bff",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1fb877c38b02ac259f7f665b12472f7085929bff",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1fb877c38b02ac259f7f665b12472f7085929bff/comments",
    "author": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8021392b825c74312173f15eb937ba6d4aec3841",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8021392b825c74312173f15eb937ba6d4aec3841",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8021392b825c74312173f15eb937ba6d4aec3841"
      }
    ],
    "stats": {
      "total": 139,
      "additions": 107,
      "deletions": 32
    },
    "files": [
      {
        "sha": "a0349dc0f5695dfa3e7edf4c8b92b8998b62f6a4",
        "filename": "src/node/coinstats.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1fb877c38b02ac259f7f665b12472f7085929bff/src/node/coinstats.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1fb877c38b02ac259f7f665b12472f7085929bff/src/node/coinstats.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/coinstats.cpp?ref=1fb877c38b02ac259f7f665b12472f7085929bff",
        "patch": "@@ -23,7 +23,7 @@ static void ApplyStats(CCoinsStats &stats, CHashWriter& ss, const uint256& hash,\n     for (const auto& output : outputs) {\n         ss << VARINT(output.first + 1);\n         ss << output.second.out.scriptPubKey;\n-        ss << VARINT(output.second.out.nValue, VarIntMode::NONNEGATIVE_SIGNED);\n+        ss << VARINT((CAmount)output.second.out.nValue, VarIntMode::NONNEGATIVE_SIGNED);\n         stats.nTransactionOutputs++;\n         stats.nTotalAmount += output.second.out.nValue;\n         stats.nBogoSize += 32 /* txid */ + 4 /* vout index */ + 4 /* height + coinbase */ + 8 /* amount */ +"
      },
      {
        "sha": "99f5e4c6488cafc85629358da06b8f93bcbbaafe",
        "filename": "src/prevector.h",
        "status": "modified",
        "additions": 39,
        "deletions": 26,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1fb877c38b02ac259f7f665b12472f7085929bff/src/prevector.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1fb877c38b02ac259f7f665b12472f7085929bff/src/prevector.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/prevector.h?ref=1fb877c38b02ac259f7f665b12472f7085929bff",
        "patch": "@@ -21,20 +21,23 @@\n  *\n  *  Storage layout is either:\n  *  - Direct allocation:\n- *    - Size _size: the number of used elements (between 0 and N)\n  *    - T direct[N]: an array of N elements of type T\n- *      (only the first _size are initialized).\n+ *    - unsigned char _size_direct: the number of used elements\n+ *      between 0 and N. 0xFF means indirect allocation.\n+ *      (only the first _size_direct are initialized).\n  *  - Indirect allocation:\n- *    - Size _size: the number of used elements plus N + 1\n- *    - Size capacity: the number of allocated elements\n- *    - T* indirect: a pointer to an array of capacity elements of type T\n+ *    - size_type _size: the number of used elements\n+ *    - size_type capacity: the number of allocated elements\n+ *    - char* indirect: a pointer to an array of capacity elements of type T\n  *      (only the first _size are initialized).\n  *\n  *  The data type T must be movable by memmove/realloc(). Once we switch to C++,\n  *  move constructors can be used instead.\n  */\n template<unsigned int N, typename T, typename Size = uint32_t, typename Diff = int32_t>\n class prevector {\n+    static_assert(N < 0xff, \"can't directly allocate more than 254 elements\");\n+\n public:\n     typedef Size size_type;\n     typedef Diff difference_type;\n@@ -146,30 +149,31 @@ class prevector {\n     };\n \n private:\n-    size_type _size = 0;\n     union direct_or_indirect {\n         char direct[sizeof(T) * N];\n         struct {\n+            size_type size;\n             size_type capacity;\n             char* indirect;\n         };\n     } _union = {};\n+    unsigned char _size_direct = 0;\n \n     T* direct_ptr(difference_type pos) { return reinterpret_cast<T*>(_union.direct) + pos; }\n     const T* direct_ptr(difference_type pos) const { return reinterpret_cast<const T*>(_union.direct) + pos; }\n     T* indirect_ptr(difference_type pos) { return reinterpret_cast<T*>(_union.indirect) + pos; }\n     const T* indirect_ptr(difference_type pos) const { return reinterpret_cast<const T*>(_union.indirect) + pos; }\n-    bool is_direct() const { return _size <= N; }\n+    bool is_direct() const { return _size_direct != 0xFF; }\n \n     void change_capacity(size_type new_capacity) {\n         if (new_capacity <= N) {\n             if (!is_direct()) {\n+                _size_direct = static_cast<unsigned char>(_union.size);\n                 T* indirect = indirect_ptr(0);\n                 T* src = indirect;\n                 T* dst = direct_ptr(0);\n-                memcpy(dst, src, size() * sizeof(T));\n+                memcpy(dst, src, _size_direct * sizeof(T));\n                 free(indirect);\n-                _size -= N + 1;\n             }\n         } else {\n             if (!is_direct()) {\n@@ -187,7 +191,8 @@ class prevector {\n                 memcpy(dst, src, size() * sizeof(T));\n                 _union.indirect = new_indirect;\n                 _union.capacity = new_capacity;\n-                _size += N + 1;\n+                _union.size = _size_direct;\n+                _size_direct = 0xff;\n             }\n         }\n     }\n@@ -208,13 +213,21 @@ class prevector {\n         }\n     }\n \n+    void change_size_by(Diff diff) {\n+        if (is_direct()) {\n+            _size_direct += diff;\n+        } else {\n+            _union.size += diff;\n+        }\n+    }\n+\n public:\n     void assign(size_type n, const T& val) {\n         clear();\n         if (capacity() < n) {\n             change_capacity(n);\n         }\n-        _size += n;\n+        change_size_by(n);\n         fill(item_ptr(0), n, val);\n     }\n \n@@ -225,7 +238,7 @@ class prevector {\n         if (capacity() < n) {\n             change_capacity(n);\n         }\n-        _size += n;\n+        change_size_by(n);\n         fill(item_ptr(0), first, last);\n     }\n \n@@ -237,22 +250,22 @@ class prevector {\n \n     explicit prevector(size_type n, const T& val) {\n         change_capacity(n);\n-        _size += n;\n+        change_size_by(n);\n         fill(item_ptr(0), n, val);\n     }\n \n     template<typename InputIterator>\n     prevector(InputIterator first, InputIterator last) {\n         size_type n = last - first;\n         change_capacity(n);\n-        _size += n;\n+        change_size_by(n);\n         fill(item_ptr(0), first, last);\n     }\n \n     prevector(const prevector<N, T, Size, Diff>& other) {\n         size_type n = other.size();\n         change_capacity(n);\n-        _size += n;\n+        change_size_by(n);\n         fill(item_ptr(0), other.begin(),  other.end());\n     }\n \n@@ -274,7 +287,7 @@ class prevector {\n     }\n \n     size_type size() const {\n-        return is_direct() ? _size : _size - N - 1;\n+        return is_direct() ? _size_direct : _union.size;\n     }\n \n     bool empty() const {\n@@ -321,7 +334,7 @@ class prevector {\n         }\n         ptrdiff_t increase = new_size - cur_size;\n         fill(item_ptr(cur_size), increase);\n-        _size += increase;\n+        change_size_by(increase);\n     }\n \n     void reserve(size_type new_capacity) {\n@@ -346,7 +359,7 @@ class prevector {\n         }\n         T* ptr = item_ptr(p);\n         memmove(ptr + 1, ptr, (size() - p) * sizeof(T));\n-        _size++;\n+        change_size_by(1);\n         new(static_cast<void*>(ptr)) T(value);\n         return iterator(ptr);\n     }\n@@ -359,7 +372,7 @@ class prevector {\n         }\n         T* ptr = item_ptr(p);\n         memmove(ptr + count, ptr, (size() - p) * sizeof(T));\n-        _size += count;\n+        change_size_by(count);\n         fill(item_ptr(p), count, value);\n     }\n \n@@ -373,7 +386,7 @@ class prevector {\n         }\n         T* ptr = item_ptr(p);\n         memmove(ptr + count, ptr, (size() - p) * sizeof(T));\n-        _size += count;\n+        change_size_by(count);\n         fill(ptr, first, last);\n     }\n \n@@ -382,13 +395,13 @@ class prevector {\n         // If size < new_size, the added elements must be initialized explicitly.\n         if (capacity() < new_size) {\n             change_capacity(new_size);\n-            _size += new_size - size();\n+            change_size_by(new_size - size());\n             return;\n         }\n         if (new_size < size()) {\n             erase(item_ptr(new_size), end());\n         } else {\n-            _size += new_size - size();\n+            change_size_by(new_size - size());\n         }\n     }\n \n@@ -408,11 +421,11 @@ class prevector {\n         if (!std::is_trivially_destructible<T>::value) {\n             while (p != last) {\n                 (*p).~T();\n-                _size--;\n+                change_size_by(-1);\n                 ++p;\n             }\n         } else {\n-            _size -= last - p;\n+            change_size_by(-(last - p));\n         }\n         memmove(&(*first), &(*last), endp - ((char*)(&(*last))));\n         return first;\n@@ -424,7 +437,7 @@ class prevector {\n             change_capacity(new_size + (new_size >> 1));\n         }\n         new(item_ptr(size())) T(value);\n-        _size++;\n+        change_size_by(1);\n     }\n \n     void pop_back() {\n@@ -449,7 +462,7 @@ class prevector {\n \n     void swap(prevector<N, T, Size, Diff>& other) {\n         std::swap(_union, other._union);\n-        std::swap(_size, other._size);\n+        std::swap(_size_direct, other._size_direct);\n     }\n \n     ~prevector() {"
      },
      {
        "sha": "79a63f5b6d5ae84c2e950d5c04350a2ff12cd073",
        "filename": "src/primitives/transaction.h",
        "status": "modified",
        "additions": 60,
        "deletions": 1,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1fb877c38b02ac259f7f665b12472f7085929bff/src/primitives/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1fb877c38b02ac259f7f665b12472f7085929bff/src/primitives/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.h?ref=1fb877c38b02ac259f7f665b12472f7085929bff",
        "patch": "@@ -127,13 +127,72 @@ class CTxIn\n     std::string ToString() const;\n };\n \n+\n+/**\n+ * CAmount is an int64_t, which requires alignment of 8. This wrapper stores the data\n+ * in a memory array and packs/unpacks it whenever needed, regarldess of alignment.\n+ *\n+ * Since CAmount's size is know, the compiler should be able to optimize the std::memcpy away\n+ * in most cases.\n+ */\n+class PackableCAmount\n+{\n+    uint8_t m_data[sizeof(CAmount)];\n+\n+public:\n+    PackableCAmount(CAmount val) noexcept\n+    {\n+        std::memcpy(m_data, &val, sizeof(CAmount));\n+    }\n+\n+    PackableCAmount() noexcept\n+        : PackableCAmount(0) {}\n+\n+    operator CAmount() const noexcept\n+    {\n+        CAmount ret;\n+        std::memcpy(&ret, m_data, sizeof(CAmount));\n+        return ret;\n+    }\n+\n+    PackableCAmount& operator-=(CAmount other) noexcept\n+    {\n+        *this = ((CAmount) * this) - other;\n+        return *this;\n+    }\n+\n+    PackableCAmount& operator+=(CAmount other) noexcept\n+    {\n+        *this = ((CAmount) * this) + other;\n+        return *this;\n+    }\n+\n+    template <typename Stream>\n+    void Unserialize(Stream& s)\n+    {\n+        CAmount val;\n+        ::Unserialize(s, val);\n+        *this = val;\n+    }\n+\n+    template <typename Stream>\n+    void Serialize(Stream& s) const\n+    {\n+        ::Serialize(s, (CAmount) * this);\n+    }\n+};\n+\n /** An output of a transaction.  It contains the public key that the next input\n  * must be able to sign with to claim it.\n+ *\n+ * We align the struct to 4 bytes: that way, CTxOut will have 36 bytes: 8 for\n+ * CAmount, and 28 for CScript. As a member of Coin, this leaves 4 bytes for\n+ * Coin's nHeight without the need for any padding.\n  */\n class CTxOut\n {\n public:\n-    CAmount nValue;\n+    PackableCAmount nValue;\n     CScript scriptPubKey;\n \n     CTxOut()"
      },
      {
        "sha": "429e284e317b5d20e166524bd5b21cc9c2ba9c85",
        "filename": "src/script/script.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1fb877c38b02ac259f7f665b12472f7085929bff/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1fb877c38b02ac259f7f665b12472f7085929bff/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=1fb877c38b02ac259f7f665b12472f7085929bff",
        "patch": "@@ -381,8 +381,11 @@ class CScriptNum\n  *  of vectors in cases where they normally contain a small number of small elements.\n  * Tests in October 2015 showed use of this reduced dbcache memory usage by 23%\n  *  and made an initial sync 13% faster.\n+ *\n+ * Most scripts seem to have <= 25 bytes. So with 27 entries + 1 byte for size(),\n+ * the prevector will have a size of 28 bytes.\n  */\n-typedef prevector<28, unsigned char> CScriptBase;\n+typedef prevector<27, unsigned char> CScriptBase;\n \n bool GetScriptOp(CScriptBase::const_iterator& pc, CScriptBase::const_iterator end, opcodetype& opcodeRet, std::vector<unsigned char>* pvchRet);\n "
      },
      {
        "sha": "36b63f32d4bf5402750c4e5890daa2dbda858e07",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1fb877c38b02ac259f7f665b12472f7085929bff/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1fb877c38b02ac259f7f665b12472f7085929bff/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=1fb877c38b02ac259f7f665b12472f7085929bff",
        "patch": "@@ -1175,7 +1175,7 @@ CAmount CWallet::GetCredit(const CTxOut& txout, const isminefilter& filter) cons\n {\n     if (!MoneyRange(txout.nValue))\n         throw std::runtime_error(std::string(__func__) + \": value out of range\");\n-    return ((IsMine(txout) & filter) ? txout.nValue : 0);\n+    return ((IsMine(txout) & filter) ? (CAmount)txout.nValue : 0);\n }\n \n bool CWallet::IsChange(const CTxOut& txout) const\n@@ -1209,7 +1209,7 @@ CAmount CWallet::GetChange(const CTxOut& txout) const\n {\n     if (!MoneyRange(txout.nValue))\n         throw std::runtime_error(std::string(__func__) + \": value out of range\");\n-    return (IsChange(txout) ? txout.nValue : 0);\n+    return (IsChange(txout) ? (CAmount)txout.nValue : 0);\n }\n \n bool CWallet::IsMine(const CTransaction& tx) const\n@@ -3146,7 +3146,7 @@ std::map<CTxDestination, CAmount> CWallet::GetAddressBalances(interfaces::Chain:\n                 if(!ExtractDestination(wtx.tx->vout[i].scriptPubKey, addr))\n                     continue;\n \n-                CAmount n = IsSpent(walletEntry.first, i) ? 0 : wtx.tx->vout[i].nValue;\n+                CAmount n = IsSpent(walletEntry.first, i) ? 0 : (CAmount)wtx.tx->vout[i].nValue;\n \n                 if (!balances.count(addr))\n                     balances[addr] = 0;"
      }
    ]
  },
  {
    "sha": "43328c458e169c4ba7fc07ffcbd9f2ca252bed31",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MzMyOGM0NThlMTY5YzRiYTdmYzA3ZmZjYmQ5ZjJjYTI1MmJlZDMx",
    "commit": {
      "author": {
        "name": "Martin Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2019-10-01T04:36:48Z"
      },
      "committer": {
        "name": "Martin Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2019-11-08T15:57:51Z"
      },
      "message": "packed CCoinsCacheEntry flags into Coin\n\nRemoved CCoinsCacheEntry's 1 byte for the flags and put it directly into\nCoin. That way we can get rid of unnecessary padding, which reduces the\nmemory requirement for the coinsCache. We steal 2 bits from Coin's\nnHeight, so now there are only 29 bits left. Still, we are save until\nblock 2^29-1 = 536870911.",
      "tree": {
        "sha": "e4ee72f6a79f1dddc9a28d75383111deab7b2eef",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e4ee72f6a79f1dddc9a28d75383111deab7b2eef"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/43328c458e169c4ba7fc07ffcbd9f2ca252bed31",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/43328c458e169c4ba7fc07ffcbd9f2ca252bed31",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/43328c458e169c4ba7fc07ffcbd9f2ca252bed31",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/43328c458e169c4ba7fc07ffcbd9f2ca252bed31/comments",
    "author": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1fb877c38b02ac259f7f665b12472f7085929bff",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1fb877c38b02ac259f7f665b12472f7085929bff",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1fb877c38b02ac259f7f665b12472f7085929bff"
      }
    ],
    "stats": {
      "total": 117,
      "additions": 88,
      "deletions": 29
    },
    "files": [
      {
        "sha": "a602e8e95489c337472f966ca999ef26471ce66a",
        "filename": "src/coins.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 15,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43328c458e169c4ba7fc07ffcbd9f2ca252bed31/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43328c458e169c4ba7fc07ffcbd9f2ca252bed31/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=43328c458e169c4ba7fc07ffcbd9f2ca252bed31",
        "patch": "@@ -50,7 +50,7 @@ CCoinsMap::iterator CCoinsViewCache::FetchCoin(const COutPoint &outpoint) const\n     if (ret->second.coin.IsSpent()) {\n         // The parent only has an empty entry for this outpoint; we can consider our\n         // version as fresh.\n-        ret->second.flags = CCoinsCacheEntry::FRESH;\n+        ret->second.coin.fresh = true;\n     }\n     cachedCoinsUsage += ret->second.coin.DynamicMemoryUsage();\n     return ret;\n@@ -59,7 +59,11 @@ CCoinsMap::iterator CCoinsViewCache::FetchCoin(const COutPoint &outpoint) const\n bool CCoinsViewCache::GetCoin(const COutPoint &outpoint, Coin &coin) const {\n     CCoinsMap::const_iterator it = FetchCoin(outpoint);\n     if (it != cacheCoins.end()) {\n+        auto oldDirty = coin.dirty;\n+        auto oldFresh = coin.fresh;\n         coin = it->second.coin;\n+        coin.dirty = oldDirty;\n+        coin.fresh = oldFresh;\n         return !coin.IsSpent();\n     }\n     return false;\n@@ -79,10 +83,12 @@ void CCoinsViewCache::AddCoin(const COutPoint &outpoint, Coin&& coin, bool possi\n         if (!it->second.coin.IsSpent()) {\n             throw std::logic_error(\"Adding new coin that replaces non-pruned entry\");\n         }\n-        fresh = !(it->second.flags & CCoinsCacheEntry::DIRTY);\n+        fresh = !it->second.coin.dirty;\n     }\n+    auto oldFresh = it->second.coin.fresh;\n     it->second.coin = std::move(coin);\n-    it->second.flags |= CCoinsCacheEntry::DIRTY | (fresh ? CCoinsCacheEntry::FRESH : 0);\n+    it->second.coin.fresh = oldFresh || fresh;\n+    it->second.coin.dirty = true;\n     cachedCoinsUsage += it->second.coin.DynamicMemoryUsage();\n }\n \n@@ -102,12 +108,16 @@ bool CCoinsViewCache::SpendCoin(const COutPoint &outpoint, Coin* moveout) {\n     if (it == cacheCoins.end()) return false;\n     cachedCoinsUsage -= it->second.coin.DynamicMemoryUsage();\n     if (moveout) {\n+        auto oldDirty = moveout->dirty;\n+        auto oldFresh = moveout->fresh;\n         *moveout = std::move(it->second.coin);\n+        moveout->dirty = oldDirty;\n+        moveout->fresh = oldFresh;\n     }\n-    if (it->second.flags & CCoinsCacheEntry::FRESH) {\n+    if (it->second.coin.fresh) {\n         cacheCoins.erase(it);\n     } else {\n-        it->second.flags |= CCoinsCacheEntry::DIRTY;\n+        it->second.coin.dirty = true;\n         it->second.coin.Clear();\n     }\n     return true;\n@@ -147,38 +157,35 @@ void CCoinsViewCache::SetBestBlock(const uint256 &hashBlockIn) {\n bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn) {\n     for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end(); it = mapCoins.erase(it)) {\n         // Ignore non-dirty entries (optimization).\n-        if (!(it->second.flags & CCoinsCacheEntry::DIRTY)) {\n+        if (!it->second.coin.dirty) {\n             continue;\n         }\n         CCoinsMap::iterator itUs = cacheCoins.find(it->first);\n         if (itUs == cacheCoins.end()) {\n             // The parent cache does not have an entry, while the child does\n             // We can ignore it if it's both FRESH and pruned in the child\n-            if (!(it->second.flags & CCoinsCacheEntry::FRESH && it->second.coin.IsSpent())) {\n+            if (!(it->second.coin.fresh && it->second.coin.IsSpent())) {\n                 // Otherwise we will need to create it in the parent\n                 // and move the data up and mark it as dirty\n                 CCoinsCacheEntry& entry = cacheCoins[it->first];\n                 entry.coin = std::move(it->second.coin);\n                 cachedCoinsUsage += entry.coin.DynamicMemoryUsage();\n-                entry.flags = CCoinsCacheEntry::DIRTY;\n+                entry.coin.dirty = true;\n                 // We can mark it FRESH in the parent if it was FRESH in the child\n                 // Otherwise it might have just been flushed from the parent's cache\n                 // and already exist in the grandparent\n-                if (it->second.flags & CCoinsCacheEntry::FRESH) {\n-                    entry.flags |= CCoinsCacheEntry::FRESH;\n-                }\n             }\n         } else {\n             // Assert that the child cache entry was not marked FRESH if the\n             // parent cache entry has unspent outputs. If this ever happens,\n             // it means the FRESH flag was misapplied and there is a logic\n             // error in the calling code.\n-            if ((it->second.flags & CCoinsCacheEntry::FRESH) && !itUs->second.coin.IsSpent()) {\n+            if (it->second.coin.fresh && !itUs->second.coin.IsSpent()) {\n                 throw std::logic_error(\"FRESH flag misapplied to cache entry for base transaction with spendable outputs\");\n             }\n \n             // Found the entry in the parent cache\n-            if ((itUs->second.flags & CCoinsCacheEntry::FRESH) && it->second.coin.IsSpent()) {\n+            if (itUs->second.coin.fresh && it->second.coin.IsSpent()) {\n                 // The grandparent does not have an entry, and the child is\n                 // modified and being pruned. This means we can just delete\n                 // it from the parent.\n@@ -187,14 +194,16 @@ bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn\n             } else {\n                 // A normal modification.\n                 cachedCoinsUsage -= itUs->second.coin.DynamicMemoryUsage();\n+                auto oldFresh = itUs->second.coin.fresh;\n                 itUs->second.coin = std::move(it->second.coin);\n                 cachedCoinsUsage += itUs->second.coin.DynamicMemoryUsage();\n-                itUs->second.flags |= CCoinsCacheEntry::DIRTY;\n+                itUs->second.coin.dirty = true;\n                 // NOTE: It is possible the child has a FRESH flag here in\n                 // the event the entry we found in the parent is pruned. But\n                 // we must not copy that FRESH flag to the parent as that\n                 // pruned state likely still needs to be communicated to the\n                 // grandparent.\n+                itUs->second.coin.fresh = oldFresh;\n             }\n         }\n     }\n@@ -212,7 +221,7 @@ bool CCoinsViewCache::Flush() {\n void CCoinsViewCache::Uncache(const COutPoint& hash)\n {\n     CCoinsMap::iterator it = cacheCoins.find(hash);\n-    if (it != cacheCoins.end() && it->second.flags == 0) {\n+    if (it != cacheCoins.end() && !it->second.coin.fresh && !it->second.coin.dirty) {\n         cachedCoinsUsage -= it->second.coin.DynamicMemoryUsage();\n         cacheCoins.erase(it);\n     }"
      },
      {
        "sha": "ce66ba4df18cd1872c09d53abc03b84826a7b041",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 17,
        "deletions": 7,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43328c458e169c4ba7fc07ffcbd9f2ca252bed31/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43328c458e169c4ba7fc07ffcbd9f2ca252bed31/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=43328c458e169c4ba7fc07ffcbd9f2ca252bed31",
        "patch": "@@ -20,6 +20,8 @@\n #include <functional>\n #include <unordered_map>\n \n+static constexpr uint32_t COIN_NHEIGHT_BITS = 29;\n+\n /**\n  * A UTXO entry.\n  *\n@@ -36,12 +38,18 @@ class Coin\n     //! whether containing transaction was a coinbase\n     unsigned int fCoinBase : 1;\n \n+    //! Cache entry: This cache entry is potentially different from the version in the parent view.\n+    unsigned int dirty : 1;\n+\n+    //! Cache entry: The parent view does not have this entry (or it is pruned).\n+    unsigned int fresh : 1;\n+\n     //! at which height this containing transaction was included in the active block chain\n-    uint32_t nHeight : 31;\n+    uint32_t nHeight : COIN_NHEIGHT_BITS;\n \n     //! construct a Coin from a CTxOut and height/coinbase information.\n-    Coin(CTxOut&& outIn, int nHeightIn, bool fCoinBaseIn) : out(std::move(outIn)), fCoinBase(fCoinBaseIn), nHeight(nHeightIn) {}\n-    Coin(const CTxOut& outIn, int nHeightIn, bool fCoinBaseIn) : out(outIn), fCoinBase(fCoinBaseIn),nHeight(nHeightIn) {}\n+    Coin(CTxOut&& outIn, int nHeightIn, bool fCoinBaseIn) : out(std::move(outIn)), fCoinBase(fCoinBaseIn), dirty(false), fresh(false), nHeight(nHeightIn) {}\n+    Coin(const CTxOut& outIn, int nHeightIn, bool fCoinBaseIn) : out(outIn), fCoinBase(fCoinBaseIn), dirty(false), fresh(false), nHeight(nHeightIn) {}\n \n     void Clear() {\n         out.SetNull();\n@@ -50,7 +58,7 @@ class Coin\n     }\n \n     //! empty constructor\n-    Coin() : fCoinBase(false), nHeight(0) { }\n+    Coin() : fCoinBase(false), dirty(false), fresh(false), nHeight(0) { }\n \n     bool IsCoinBase() const {\n         return fCoinBase;\n@@ -112,7 +120,6 @@ class SaltedOutpointHasher\n struct CCoinsCacheEntry\n {\n     Coin coin; // The actual cached data.\n-    unsigned char flags;\n \n     enum Flags {\n         DIRTY = (1 << 0), // This cache entry is potentially different from the version in the parent view.\n@@ -124,8 +131,11 @@ struct CCoinsCacheEntry\n          */\n     };\n \n-    CCoinsCacheEntry() : flags(0) {}\n-    explicit CCoinsCacheEntry(Coin&& coin_) : coin(std::move(coin_)), flags(0) {}\n+    CCoinsCacheEntry() {}\n+    explicit CCoinsCacheEntry(Coin&& coin_) : coin(std::move(coin_)) {\n+        coin.dirty = false;\n+        coin.fresh = false;\n+    }\n };\n \n typedef std::unordered_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher> CCoinsMap;"
      },
      {
        "sha": "8521a37f06a3462827dd4ff62adb640231b1187f",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 5,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43328c458e169c4ba7fc07ffcbd9f2ca252bed31/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43328c458e169c4ba7fc07ffcbd9f2ca252bed31/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=43328c458e169c4ba7fc07ffcbd9f2ca252bed31",
        "patch": "@@ -43,7 +43,11 @@ class CCoinsViewTest : public CCoinsView\n         if (it == map_.end()) {\n             return false;\n         }\n+        auto oldDirty = coin.dirty;\n+        auto oldFresh = coin.fresh;\n         coin = it->second;\n+        coin.dirty = oldDirty;\n+        coin.fresh = oldFresh;\n         if (coin.IsSpent() && InsecureRandBool() == 0) {\n             // Randomly return false in case of an empty entry.\n             return false;\n@@ -56,9 +60,14 @@ class CCoinsViewTest : public CCoinsView\n     bool BatchWrite(CCoinsMap& mapCoins, const uint256& hashBlock) override\n     {\n         for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end(); ) {\n-            if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n+            if (it->second.coin.dirty) {\n                 // Same optimization used in CCoinsViewDB is to only write dirty entries.\n-                map_[it->first] = it->second.coin;\n+                auto& c = map_[it->first];\n+                auto oldDirty = c.dirty;\n+                auto oldFresh = c.fresh;\n+                c = it->second.coin;\n+                c.dirty = oldDirty;\n+                c.fresh = oldFresh;\n                 if (it->second.coin.IsSpent() && InsecureRandRange(3) == 0) {\n                     // Randomly delete empty entries on write.\n                     map_.erase(it->first);\n@@ -170,7 +179,11 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n                 } else {\n                     newcoin.out.scriptPubKey.assign(InsecureRandBits(6), 0); // Random sizes so we can test memory usage accounting\n                     (coin.IsSpent() ? added_an_entry : updated_an_entry) = true;\n+                    auto oldDirty = coin.dirty;\n+                    auto oldFresh = coin.fresh;\n                     coin = newcoin;\n+                    coin.dirty = oldDirty;\n+                    coin.fresh = oldFresh;\n                 }\n                 stack.back()->AddCoin(COutPoint(txid, 0), std::move(newcoin), !coin.IsSpent() || InsecureRand32() & 1);\n             } else {\n@@ -360,7 +373,11 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n                     assert(!CTransaction(tx).IsCoinBase());\n                 }\n                 // In this simple test coins only have two states, spent or unspent, save the unspent state to restore\n+                auto oldDirty = old_coin.dirty;\n+                auto oldFresh = old_coin.fresh;\n                 old_coin = result[prevout];\n+                old_coin.dirty = oldDirty;\n+                old_coin.fresh = oldFresh;\n                 // Update the expected result of prevouthash to know these coins are spent\n                 result[prevout].Clear();\n \n@@ -376,7 +393,12 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n             // Update the expected result to know about the new output coins\n             assert(tx.vout.size() == 1);\n             const COutPoint outpoint(tx.GetHash(), 0);\n+\n+            auto oldDirty = result[outpoint].dirty;\n+            auto oldFresh = result[outpoint].fresh;\n             result[outpoint] = Coin(tx.vout[0], height, CTransaction(tx).IsCoinBase());\n+            result[outpoint].dirty = oldDirty;\n+            result[outpoint].fresh = oldFresh;\n \n             // Call UpdateCoins on the top cache\n             CTxUndo undo;\n@@ -400,7 +422,12 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n             result[utxod->first].Clear();\n             // If not coinbase restore prevout\n             if (!tx.IsCoinBase()) {\n-                result[tx.vin[0].prevout] = orig_coin;\n+                auto& c = result[tx.vin[0].prevout];\n+                auto oldDirty = c.dirty;\n+                auto oldFresh = c.fresh;\n+                c = orig_coin;\n+                c.dirty = oldDirty;\n+                c.fresh = oldFresh;\n             }\n \n             // Disconnect the tx from the current UTXO\n@@ -411,6 +438,8 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n             if (!tx.IsCoinBase()) {\n                 const COutPoint &out = tx.vin[0].prevout;\n                 Coin coin = undo.vprevout[0];\n+                coin.dirty = false;\n+                coin.fresh = false;\n                 ApplyTxInUndo(std::move(coin), *(stack.back()), out);\n             }\n             // Store as a candidate for reconnection\n@@ -566,7 +595,8 @@ static size_t InsertCoinsMapEntry(CCoinsMap& map, CAmount value, char flags)\n     }\n     assert(flags != NO_ENTRY);\n     CCoinsCacheEntry entry;\n-    entry.flags = flags;\n+    entry.coin.dirty = (flags & CCoinsCacheEntry::DIRTY) ? true : false;\n+    entry.coin.fresh = (flags & CCoinsCacheEntry::FRESH) ? true : false;\n     SetCoinsValue(value, entry.coin);\n     auto inserted = map.emplace(OUTPOINT, std::move(entry));\n     assert(inserted.second);\n@@ -585,7 +615,7 @@ void GetCoinsMapEntry(const CCoinsMap& map, CAmount& value, char& flags)\n         } else {\n             value = it->second.coin.out.nValue;\n         }\n-        flags = it->second.flags;\n+        flags = (it->second.coin.dirty ? CCoinsCacheEntry::DIRTY : 0) | (it->second.coin.fresh ? CCoinsCacheEntry::FRESH : 0);\n         assert(flags != NO_ENTRY);\n     }\n }\n@@ -861,4 +891,14 @@ BOOST_AUTO_TEST_CASE(ccoins_write)\n                     CheckWriteCoins(parent_value, child_value, parent_value, parent_flags, child_flags, parent_flags);\n }\n \n+BOOST_AUTO_TEST_CASE(ccoins_no_padding)\n+{\n+    // we could use static_assert but we get better error messages this way\n+    BOOST_CHECK_EQUAL(sizeof(CCoinsMap::value_type), sizeof(COutPoint) + sizeof(CCoinsCacheEntry));\n+    BOOST_CHECK_EQUAL(sizeof(COutPoint), sizeof(uint256) + sizeof(uint32_t));\n+    BOOST_CHECK_EQUAL(sizeof(CCoinsCacheEntry), sizeof(Coin));\n+    BOOST_CHECK_EQUAL(sizeof(Coin), sizeof(CTxOut) + sizeof(uint32_t));\n+    BOOST_CHECK_EQUAL(sizeof(CTxOut), sizeof(PackableCAmount) + sizeof(CScript));\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "a0ddbc00fbc08128308c3301cc90aaf0b2feae5c",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43328c458e169c4ba7fc07ffcbd9f2ca252bed31/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43328c458e169c4ba7fc07ffcbd9f2ca252bed31/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=43328c458e169c4ba7fc07ffcbd9f2ca252bed31",
        "patch": "@@ -106,7 +106,7 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n     batch.Write(DB_HEAD_BLOCKS, Vector(hashBlock, old_tip));\n \n     for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end();) {\n-        if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n+        if (it->second.coin.dirty) {\n             CoinEntry entry(&it->first);\n             if (it->second.coin.IsSpent())\n                 batch.Erase(entry);"
      },
      {
        "sha": "6cfb4eb1a43469187ea6313b3ad88db99f011d25",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43328c458e169c4ba7fc07ffcbd9f2ca252bed31/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43328c458e169c4ba7fc07ffcbd9f2ca252bed31/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=43328c458e169c4ba7fc07ffcbd9f2ca252bed31",
        "patch": "@@ -33,7 +33,7 @@ class CBlockIndex;\n extern CCriticalSection cs_main;\n \n /** Fake height value used in Coin to signify they are only in the memory pool (since 0.8) */\n-static const uint32_t MEMPOOL_HEIGHT = 0x7FFFFFFF;\n+static const uint32_t MEMPOOL_HEIGHT = (1 << COIN_NHEIGHT_BITS) - 1;\n \n struct LockPoints\n {"
      }
    ]
  },
  {
    "sha": "22d1d944d76bbb3612064d2f2647111c9db151f0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMmQxZDk0NGQ3NmJiYjM2MTIwNjRkMmYyNjQ3MTExYzlkYjE1MWYw",
    "commit": {
      "author": {
        "name": "Martin Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2019-10-09T14:44:42Z"
      },
      "committer": {
        "name": "Martin Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2019-11-08T15:57:51Z"
      },
      "message": "make PackableCAmount's ctor explicit\n\nThis requires the operator=(CAmount) which I've implemented here as well. Using static_cast for nicer formatting.\n\nNote that it would be cleaner to make the user defined conversion`operator CAmount()` explicit too, but that would mean that practically everywhere it is used we need to add an explicit cast.\nSee \"C.164: Avoid implicit conversion operators\" http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c164-avoid-implicit-conversion-operators",
      "tree": {
        "sha": "99464f948e81cf4c4627be4c5ab01d54f93570f4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/99464f948e81cf4c4627be4c5ab01d54f93570f4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/22d1d944d76bbb3612064d2f2647111c9db151f0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/22d1d944d76bbb3612064d2f2647111c9db151f0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/22d1d944d76bbb3612064d2f2647111c9db151f0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/22d1d944d76bbb3612064d2f2647111c9db151f0/comments",
    "author": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "43328c458e169c4ba7fc07ffcbd9f2ca252bed31",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/43328c458e169c4ba7fc07ffcbd9f2ca252bed31",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/43328c458e169c4ba7fc07ffcbd9f2ca252bed31"
      }
    ],
    "stats": {
      "total": 20,
      "additions": 12,
      "deletions": 8
    },
    "files": [
      {
        "sha": "0f685237a884f9569d116d2e4590c4260ff89fd2",
        "filename": "src/primitives/transaction.h",
        "status": "modified",
        "additions": 12,
        "deletions": 8,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/22d1d944d76bbb3612064d2f2647111c9db151f0/src/primitives/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/22d1d944d76bbb3612064d2f2647111c9db151f0/src/primitives/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.h?ref=22d1d944d76bbb3612064d2f2647111c9db151f0",
        "patch": "@@ -130,19 +130,19 @@ class CTxIn\n \n /**\n  * CAmount is an int64_t, which requires alignment of 8. This wrapper stores the data\n- * in a memory array and packs/unpacks it whenever needed, regarldess of alignment.\n+ * in a memory array and packs/unpacks it whenever needed, regardless of alignment.\n  *\n- * Since CAmount's size is know, the compiler should be able to optimize the std::memcpy away\n+ * Since CAmount's size is known, the compiler should be able to optimize the std::memcpy away\n  * in most cases.\n  */\n class PackableCAmount\n {\n     uint8_t m_data[sizeof(CAmount)];\n \n public:\n-    PackableCAmount(CAmount val) noexcept\n+    explicit PackableCAmount(CAmount val) noexcept\n     {\n-        std::memcpy(m_data, &val, sizeof(CAmount));\n+        *this = val;\n     }\n \n     PackableCAmount() noexcept\n@@ -157,13 +157,17 @@ class PackableCAmount\n \n     PackableCAmount& operator-=(CAmount other) noexcept\n     {\n-        *this = ((CAmount) * this) - other;\n-        return *this;\n+        return *this = static_cast<CAmount>(*this) - other;\n     }\n \n     PackableCAmount& operator+=(CAmount other) noexcept\n     {\n-        *this = ((CAmount) * this) + other;\n+        return *this = static_cast<CAmount>(*this) + other;\n+    }\n+\n+    PackableCAmount& operator=(CAmount other) noexcept\n+    {\n+        std::memcpy(m_data, &other, sizeof(CAmount));\n         return *this;\n     }\n \n@@ -178,7 +182,7 @@ class PackableCAmount\n     template <typename Stream>\n     void Serialize(Stream& s) const\n     {\n-        ::Serialize(s, (CAmount) * this);\n+        ::Serialize(s, static_cast<CAmount>(*this));\n     }\n };\n "
      }
    ]
  }
]