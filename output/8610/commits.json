[
  {
    "sha": "ba3cecf5c436bf38efad045d46e0aa26210d2234",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiYTNjZWNmNWM0MzZiZjM4ZWZhZDA0NWQ0NmUwYWEyNjIxMGQyMjM0",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-12-22T03:15:13Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-12-22T23:04:05Z"
      },
      "message": "Share unused mempool memory with coincache\n\nIf the mempool is not completely full, treat the difference between\nthe maximum size and the actual usage as available for the coin cache.\n\nThis also changes the early flush trigger from (usage > 0.9 * space)\nto (usage > 0.9 * space && usage > space - 100MB). This means we're not\npermanently leaving 10% of the space unused when the space is large.",
      "tree": {
        "sha": "316c6db06dc1c8a1b502663fb5d742c72c0692c8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/316c6db06dc1c8a1b502663fb5d742c72c0692c8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ba3cecf5c436bf38efad045d46e0aa26210d2234",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ba3cecf5c436bf38efad045d46e0aa26210d2234",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ba3cecf5c436bf38efad045d46e0aa26210d2234",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ba3cecf5c436bf38efad045d46e0aa26210d2234/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e8cfe1ee2d01c493b758a67ad14707dca15792ea",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e8cfe1ee2d01c493b758a67ad14707dca15792ea",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e8cfe1ee2d01c493b758a67ad14707dca15792ea"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 9,
      "deletions": 5
    },
    "files": [
      {
        "sha": "0eb206ba8b738927516b1a1862f00cb35cdabe6d",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ba3cecf5c436bf38efad045d46e0aa26210d2234/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ba3cecf5c436bf38efad045d46e0aa26210d2234/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=ba3cecf5c436bf38efad045d46e0aa26210d2234",
        "patch": "@@ -1330,10 +1330,11 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     nCoinDBCache = std::min(nCoinDBCache, nMaxCoinsDBCache << 20); // cap total coins db cache\n     nTotalCache -= nCoinDBCache;\n     nCoinCacheUsage = nTotalCache; // the rest goes to in-memory cache\n+    int64_t nMempoolSizeMax = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n     LogPrintf(\"Cache configuration:\\n\");\n     LogPrintf(\"* Using %.1fMiB for block index database\\n\", nBlockTreeDBCache * (1.0 / 1024 / 1024));\n     LogPrintf(\"* Using %.1fMiB for chain state database\\n\", nCoinDBCache * (1.0 / 1024 / 1024));\n-    LogPrintf(\"* Using %.1fMiB for in-memory UTXO set\\n\", nCoinCacheUsage * (1.0 / 1024 / 1024));\n+    LogPrintf(\"* Using %.1fMiB for in-memory UTXO set (plus up to %.1fMiB of unused mempool space)\\n\", nCoinCacheUsage * (1.0 / 1024 / 1024), nMempoolSizeMax * (1.0 / 1024 / 1024));\n \n     bool fLoaded = false;\n     while (!fLoaded) {"
      },
      {
        "sha": "0a935b6911acb8311950da727e08c4ee9662a577",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 4,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ba3cecf5c436bf38efad045d46e0aa26210d2234/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ba3cecf5c436bf38efad045d46e0aa26210d2234/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=ba3cecf5c436bf38efad045d46e0aa26210d2234",
        "patch": "@@ -1916,6 +1916,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n  * or always and in all cases if we're in prune mode and are deleting files.\n  */\n bool static FlushStateToDisk(CValidationState &state, FlushStateMode mode) {\n+    int64_t nMempoolUsage = mempool.DynamicMemoryUsage();\n     const CChainParams& chainparams = Params();\n     LOCK2(cs_main, cs_LastBlockFile);\n     static int64_t nLastWrite = 0;\n@@ -1946,11 +1947,13 @@ bool static FlushStateToDisk(CValidationState &state, FlushStateMode mode) {\n     if (nLastSetChain == 0) {\n         nLastSetChain = nNow;\n     }\n-    size_t cacheSize = pcoinsTip->DynamicMemoryUsage();\n-    // The cache is large and close to the limit, but we have time now (not in the middle of a block processing).\n-    bool fCacheLarge = mode == FLUSH_STATE_PERIODIC && cacheSize * (10.0/9) > nCoinCacheUsage;\n+    int64_t nMempoolSizeMax = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n+    int64_t cacheSize = pcoinsTip->DynamicMemoryUsage();\n+    int64_t nTotalSpace = nCoinCacheUsage + std::max<int64_t>(nMempoolSizeMax - nMempoolUsage, 0);\n+    // The cache is large and we're within 10% and 100 MiB of the limit, but we have time now (not in the middle of a block processing).\n+    bool fCacheLarge = mode == FLUSH_STATE_PERIODIC && cacheSize > std::max((9 * nTotalSpace) / 10, nTotalSpace - 100 * 1024 * 1024);\n     // The cache is over the limit, we have to write now.\n-    bool fCacheCritical = mode == FLUSH_STATE_IF_NEEDED && cacheSize > nCoinCacheUsage;\n+    bool fCacheCritical = mode == FLUSH_STATE_IF_NEEDED && cacheSize > nTotalSpace;\n     // It's been a while since we wrote the block index to disk. Do this frequently, so we don't need to redownload after a crash.\n     bool fPeriodicWrite = mode == FLUSH_STATE_PERIODIC && nNow > nLastWrite + (int64_t)DATABASE_WRITE_INTERVAL * 1000000;\n     // It's been very long since we flushed the cache. Do this infrequently, to optimize cache usage."
      }
    ]
  }
]