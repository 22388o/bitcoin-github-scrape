[
  {
    "sha": "7f1455eb98fa944d4025c0081f41c56cf590b742",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZjE0NTVlYjk4ZmE5NDRkNDAyNWMwMDgxZjQxYzU2Y2Y1OTBiNzQy",
    "commit": {
      "author": {
        "name": "Pavel Jan\u00edk",
        "email": "Pavel@Janik.cz",
        "date": "2015-01-08T10:44:25Z"
      },
      "committer": {
        "name": "Pavel Jan\u00edk",
        "email": "Pavel@Janik.cz",
        "date": "2015-01-08T10:44:25Z"
      },
      "message": "Remove whitespaces before double colon in errors and logs",
      "tree": {
        "sha": "e3161ef872dde68fbfece6c5b0cc369368869c17",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e3161ef872dde68fbfece6c5b0cc369368869c17"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7f1455eb98fa944d4025c0081f41c56cf590b742",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7f1455eb98fa944d4025c0081f41c56cf590b742",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7f1455eb98fa944d4025c0081f41c56cf590b742",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7f1455eb98fa944d4025c0081f41c56cf590b742/comments",
    "author": {
      "login": "paveljanik",
      "id": 6848764,
      "node_id": "MDQ6VXNlcjY4NDg3NjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6848764?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/paveljanik",
      "html_url": "https://github.com/paveljanik",
      "followers_url": "https://api.github.com/users/paveljanik/followers",
      "following_url": "https://api.github.com/users/paveljanik/following{/other_user}",
      "gists_url": "https://api.github.com/users/paveljanik/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/paveljanik/subscriptions",
      "organizations_url": "https://api.github.com/users/paveljanik/orgs",
      "repos_url": "https://api.github.com/users/paveljanik/repos",
      "events_url": "https://api.github.com/users/paveljanik/events{/privacy}",
      "received_events_url": "https://api.github.com/users/paveljanik/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "paveljanik",
      "id": 6848764,
      "node_id": "MDQ6VXNlcjY4NDg3NjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6848764?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/paveljanik",
      "html_url": "https://github.com/paveljanik",
      "followers_url": "https://api.github.com/users/paveljanik/followers",
      "following_url": "https://api.github.com/users/paveljanik/following{/other_user}",
      "gists_url": "https://api.github.com/users/paveljanik/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/paveljanik/subscriptions",
      "organizations_url": "https://api.github.com/users/paveljanik/orgs",
      "repos_url": "https://api.github.com/users/paveljanik/repos",
      "events_url": "https://api.github.com/users/paveljanik/events{/privacy}",
      "received_events_url": "https://api.github.com/users/paveljanik/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2eda47bc37bee37e409346e4c396d59925c06250",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2eda47bc37bee37e409346e4c396d59925c06250",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2eda47bc37bee37e409346e4c396d59925c06250"
      }
    ],
    "stats": {
      "total": 436,
      "additions": 218,
      "deletions": 218
    },
    "files": [
      {
        "sha": "323939913b7389b1ec823ec14940c9c6f9d3a5a0",
        "filename": "src/alert.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/alert.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/alert.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/alert.cpp?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -149,7 +149,7 @@ bool CAlert::CheckSignature() const\n {\n     CPubKey key(Params().AlertKey());\n     if (!key.Verify(Hash(vchMsg.begin(), vchMsg.end()), vchSig))\n-        return error(\"CAlert::CheckSignature() : verify signature failed\");\n+        return error(\"CAlert::CheckSignature(): verify signature failed\");\n \n     // Now unserialize the data\n     CDataStream sMsg(vchMsg, SER_NETWORK, PROTOCOL_VERSION);"
      },
      {
        "sha": "98bb1eb46debd8078d91e9690c6e6ae9d1ee9e49",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 20,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -43,7 +43,7 @@ void CDBEnv::EnvShutdown()\n     fDbEnvInit = false;\n     int ret = dbenv.close(0);\n     if (ret != 0)\n-        LogPrintf(\"CDBEnv::EnvShutdown : Error %d shutting down database environment: %s\\n\", ret, DbEnv::strerror(ret));\n+        LogPrintf(\"CDBEnv::EnvShutdown: Error %d shutting down database environment: %s\\n\", ret, DbEnv::strerror(ret));\n     if (!fMockDb)\n         DbEnv(0).remove(path.string().c_str(), 0);\n }\n@@ -75,7 +75,7 @@ bool CDBEnv::Open(const boost::filesystem::path& pathIn)\n     boost::filesystem::path pathLogDir = path / \"database\";\n     TryCreateDirectory(pathLogDir);\n     boost::filesystem::path pathErrorFile = path / \"db.log\";\n-    LogPrintf(\"CDBEnv::Open : LogDir=%s ErrorFile=%s\\n\", pathLogDir.string(), pathErrorFile.string());\n+    LogPrintf(\"CDBEnv::Open: LogDir=%s ErrorFile=%s\\n\", pathLogDir.string(), pathErrorFile.string());\n \n     unsigned int nEnvFlags = 0;\n     if (GetBoolArg(\"-privdb\", true))\n@@ -102,7 +102,7 @@ bool CDBEnv::Open(const boost::filesystem::path& pathIn)\n                              nEnvFlags,\n                          S_IRUSR | S_IWUSR);\n     if (ret != 0)\n-        return error(\"CDBEnv::Open : Error %d opening database environment: %s\\n\", ret, DbEnv::strerror(ret));\n+        return error(\"CDBEnv::Open: Error %d opening database environment: %s\\n\", ret, DbEnv::strerror(ret));\n \n     fDbEnvInit = true;\n     fMockDb = false;\n@@ -112,7 +112,7 @@ bool CDBEnv::Open(const boost::filesystem::path& pathIn)\n void CDBEnv::MakeMock()\n {\n     if (fDbEnvInit)\n-        throw runtime_error(\"CDBEnv::MakeMock : Already initialized\");\n+        throw runtime_error(\"CDBEnv::MakeMock: Already initialized\");\n \n     boost::this_thread::interruption_point();\n \n@@ -135,7 +135,7 @@ void CDBEnv::MakeMock()\n                              DB_PRIVATE,\n                          S_IRUSR | S_IWUSR);\n     if (ret > 0)\n-        throw runtime_error(strprintf(\"CDBEnv::MakeMock : Error %d opening database environment.\", ret));\n+        throw runtime_error(strprintf(\"CDBEnv::MakeMock: Error %d opening database environment.\", ret));\n \n     fDbEnvInit = true;\n     fMockDb = true;\n@@ -172,14 +172,14 @@ bool CDBEnv::Salvage(std::string strFile, bool fAggressive, std::vector<CDBEnv::\n     Db db(&dbenv, 0);\n     int result = db.verify(strFile.c_str(), NULL, &strDump, flags);\n     if (result == DB_VERIFY_BAD) {\n-        LogPrintf(\"CDBEnv::Salvage : Database salvage found errors, all data may not be recoverable.\\n\");\n+        LogPrintf(\"CDBEnv::Salvage: Database salvage found errors, all data may not be recoverable.\\n\");\n         if (!fAggressive) {\n-            LogPrintf(\"CDBEnv::Salvage : Rerun with aggressive mode to ignore errors and continue.\\n\");\n+            LogPrintf(\"CDBEnv::Salvage: Rerun with aggressive mode to ignore errors and continue.\\n\");\n             return false;\n         }\n     }\n     if (result != 0 && result != DB_VERIFY_BAD) {\n-        LogPrintf(\"CDBEnv::Salvage : Database salvage failed with result %d.\\n\", result);\n+        LogPrintf(\"CDBEnv::Salvage: Database salvage failed with result %d.\\n\", result);\n         return false;\n     }\n \n@@ -232,7 +232,7 @@ CDB::CDB(const std::string& strFilename, const char* pszMode) : pdb(NULL), activ\n     {\n         LOCK(bitdb.cs_db);\n         if (!bitdb.Open(GetDataDir()))\n-            throw runtime_error(\"CDB : Failed to open database environment.\");\n+            throw runtime_error(\"CDB: Failed to open database environment.\");\n \n         strFile = strFilename;\n         ++bitdb.mapFileUseCount[strFile];\n@@ -245,7 +245,7 @@ CDB::CDB(const std::string& strFilename, const char* pszMode) : pdb(NULL), activ\n                 DbMpoolFile* mpf = pdb->get_mpf();\n                 ret = mpf->set_flags(DB_MPOOL_NOFILE, 1);\n                 if (ret != 0)\n-                    throw runtime_error(strprintf(\"CDB : Failed to configure for no temp file backing for database %s\", strFile));\n+                    throw runtime_error(strprintf(\"CDB: Failed to configure for no temp file backing for database %s\", strFile));\n             }\n \n             ret = pdb->open(NULL,                               // Txn pointer\n@@ -260,7 +260,7 @@ CDB::CDB(const std::string& strFilename, const char* pszMode) : pdb(NULL), activ\n                 pdb = NULL;\n                 --bitdb.mapFileUseCount[strFile];\n                 strFile = \"\";\n-                throw runtime_error(strprintf(\"CDB : Error %d, can't open database %s\", ret, strFile));\n+                throw runtime_error(strprintf(\"CDB: Error %d, can't open database %s\", ret, strFile));\n             }\n \n             if (fCreate && !Exists(string(\"version\"))) {\n@@ -340,7 +340,7 @@ bool CDB::Rewrite(const string& strFile, const char* pszSkip)\n                 bitdb.mapFileUseCount.erase(strFile);\n \n                 bool fSuccess = true;\n-                LogPrintf(\"CDB::Rewrite : Rewriting %s...\\n\", strFile);\n+                LogPrintf(\"CDB::Rewrite: Rewriting %s...\\n\", strFile);\n                 string strFileRes = strFile + \".rewrite\";\n                 { // surround usage of db with extra {}\n                     CDB db(strFile.c_str(), \"r\");\n@@ -353,7 +353,7 @@ bool CDB::Rewrite(const string& strFile, const char* pszSkip)\n                                             DB_CREATE,          // Flags\n                                             0);\n                     if (ret > 0) {\n-                        LogPrintf(\"CDB::Rewrite : Can't create database file %s\\n\", strFileRes);\n+                        LogPrintf(\"CDB::Rewrite: Can't create database file %s\\n\", strFileRes);\n                         fSuccess = false;\n                     }\n \n@@ -402,7 +402,7 @@ bool CDB::Rewrite(const string& strFile, const char* pszSkip)\n                         fSuccess = false;\n                 }\n                 if (!fSuccess)\n-                    LogPrintf(\"CDB::Rewrite : Failed to rewrite database file %s\\n\", strFileRes);\n+                    LogPrintf(\"CDB::Rewrite: Failed to rewrite database file %s\\n\", strFileRes);\n                 return fSuccess;\n             }\n         }\n@@ -416,7 +416,7 @@ void CDBEnv::Flush(bool fShutdown)\n {\n     int64_t nStart = GetTimeMillis();\n     // Flush log data to the actual data file on all files that are not in use\n-    LogPrint(\"db\", \"CDBEnv::Flush : Flush(%s)%s\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" database not started\");\n+    LogPrint(\"db\", \"CDBEnv::Flush: Flush(%s)%s\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" database not started\");\n     if (!fDbEnvInit)\n         return;\n     {\n@@ -425,21 +425,21 @@ void CDBEnv::Flush(bool fShutdown)\n         while (mi != mapFileUseCount.end()) {\n             string strFile = (*mi).first;\n             int nRefCount = (*mi).second;\n-            LogPrint(\"db\", \"CDBEnv::Flush : Flushing %s (refcount = %d)...\\n\", strFile, nRefCount);\n+            LogPrint(\"db\", \"CDBEnv::Flush: Flushing %s (refcount = %d)...\\n\", strFile, nRefCount);\n             if (nRefCount == 0) {\n                 // Move log data to the dat file\n                 CloseDb(strFile);\n-                LogPrint(\"db\", \"CDBEnv::Flush : %s checkpoint\\n\", strFile);\n+                LogPrint(\"db\", \"CDBEnv::Flush: %s checkpoint\\n\", strFile);\n                 dbenv.txn_checkpoint(0, 0, 0);\n-                LogPrint(\"db\", \"CDBEnv::Flush : %s detach\\n\", strFile);\n+                LogPrint(\"db\", \"CDBEnv::Flush: %s detach\\n\", strFile);\n                 if (!fMockDb)\n                     dbenv.lsn_reset(strFile.c_str(), 0);\n-                LogPrint(\"db\", \"CDBEnv::Flush : %s closed\\n\", strFile);\n+                LogPrint(\"db\", \"CDBEnv::Flush: %s closed\\n\", strFile);\n                 mapFileUseCount.erase(mi++);\n             } else\n                 mi++;\n         }\n-        LogPrint(\"db\", \"CDBEnv::Flush : Flush(%s)%s took %15dms\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" database not started\", GetTimeMillis() - nStart);\n+        LogPrint(\"db\", \"CDBEnv::Flush: Flush(%s)%s took %15dms\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" database not started\", GetTimeMillis() - nStart);\n         if (fShutdown) {\n             char** listp;\n             if (mapFileUseCount.empty()) {"
      },
      {
        "sha": "7686c1f260ad0d4e79377f7172ad3d2ddef0a7bf",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -953,7 +953,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n             } catch (const boost::filesystem::filesystem_error& e) {\n                 // Note: hardlink creation failing is not a disaster, it just means\n                 // blocks will get re-downloaded from peers.\n-                LogPrintf(\"Error hardlinking blk%04u.dat : %s\\n\", i, e.what());\n+                LogPrintf(\"Error hardlinking blk%04u.dat: %s\\n\", i, e.what());\n                 break;\n             }\n         }"
      },
      {
        "sha": "22cd08f30c8cfdd9628a4481f4c0ae5bc3a6911b",
        "filename": "src/keystore.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/keystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/keystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.cpp?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -36,7 +36,7 @@ bool CBasicKeyStore::AddKeyPubKey(const CKey& key, const CPubKey &pubkey)\n bool CBasicKeyStore::AddCScript(const CScript& redeemScript)\n {\n     if (redeemScript.size() > MAX_SCRIPT_ELEMENT_SIZE)\n-        return error(\"CBasicKeyStore::AddCScript() : redeemScripts > %i bytes are invalid\", MAX_SCRIPT_ELEMENT_SIZE);\n+        return error(\"CBasicKeyStore::AddCScript(): redeemScripts > %i bytes are invalid\", MAX_SCRIPT_ELEMENT_SIZE);\n \n     LOCK(cs_KeyStore);\n     mapScripts[CScriptID(redeemScript)] = redeemScript;"
      },
      {
        "sha": "a4862f23533c618c3b43eeb9e8f1cbc8f13c02ae",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 95,
        "deletions": 95,
        "changes": 190,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -813,29 +813,29 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state)\n {\n     // Basic checks that don't depend on any context\n     if (tx.vin.empty())\n-        return state.DoS(10, error(\"CheckTransaction() : vin empty\"),\n+        return state.DoS(10, error(\"CheckTransaction(): vin empty\"),\n                          REJECT_INVALID, \"bad-txns-vin-empty\");\n     if (tx.vout.empty())\n-        return state.DoS(10, error(\"CheckTransaction() : vout empty\"),\n+        return state.DoS(10, error(\"CheckTransaction(): vout empty\"),\n                          REJECT_INVALID, \"bad-txns-vout-empty\");\n     // Size limits\n     if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n-        return state.DoS(100, error(\"CheckTransaction() : size limits failed\"),\n+        return state.DoS(100, error(\"CheckTransaction(): size limits failed\"),\n                          REJECT_INVALID, \"bad-txns-oversize\");\n \n     // Check for negative or overflow output values\n     CAmount nValueOut = 0;\n     BOOST_FOREACH(const CTxOut& txout, tx.vout)\n     {\n         if (txout.nValue < 0)\n-            return state.DoS(100, error(\"CheckTransaction() : txout.nValue negative\"),\n+            return state.DoS(100, error(\"CheckTransaction(): txout.nValue negative\"),\n                              REJECT_INVALID, \"bad-txns-vout-negative\");\n         if (txout.nValue > MAX_MONEY)\n-            return state.DoS(100, error(\"CheckTransaction() : txout.nValue too high\"),\n+            return state.DoS(100, error(\"CheckTransaction(): txout.nValue too high\"),\n                              REJECT_INVALID, \"bad-txns-vout-toolarge\");\n         nValueOut += txout.nValue;\n         if (!MoneyRange(nValueOut))\n-            return state.DoS(100, error(\"CheckTransaction() : txout total out of range\"),\n+            return state.DoS(100, error(\"CheckTransaction(): txout total out of range\"),\n                              REJECT_INVALID, \"bad-txns-txouttotal-toolarge\");\n     }\n \n@@ -844,22 +844,22 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state)\n     BOOST_FOREACH(const CTxIn& txin, tx.vin)\n     {\n         if (vInOutPoints.count(txin.prevout))\n-            return state.DoS(100, error(\"CheckTransaction() : duplicate inputs\"),\n+            return state.DoS(100, error(\"CheckTransaction(): duplicate inputs\"),\n                              REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n         vInOutPoints.insert(txin.prevout);\n     }\n \n     if (tx.IsCoinBase())\n     {\n         if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 100)\n-            return state.DoS(100, error(\"CheckTransaction() : coinbase script size\"),\n+            return state.DoS(100, error(\"CheckTransaction(): coinbase script size\"),\n                              REJECT_INVALID, \"bad-cb-length\");\n     }\n     else\n     {\n         BOOST_FOREACH(const CTxIn& txin, tx.vin)\n             if (txin.prevout.IsNull())\n-                return state.DoS(10, error(\"CheckTransaction() : prevout is null\"),\n+                return state.DoS(10, error(\"CheckTransaction(): prevout is null\"),\n                                  REJECT_INVALID, \"bad-txns-prevout-null\");\n     }\n \n@@ -915,7 +915,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n     string reason;\n     if (Params().RequireStandard() && !IsStandardTx(tx, reason))\n         return state.DoS(0,\n-                         error(\"AcceptToMemoryPool : nonstandard transaction: %s\", reason),\n+                         error(\"AcceptToMemoryPool: nonstandard transaction: %s\", reason),\n                          REJECT_NONSTANDARD, reason);\n \n     // Only accept nLockTime-using transactions that can be mined in the next\n@@ -935,7 +935,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n     // timestamp applications where it matters.\n     if (!IsFinalTx(tx, chainActive.Height() + 1))\n         return state.DoS(0,\n-                         error(\"AcceptToMemoryPool : non-final\"),\n+                         error(\"AcceptToMemoryPool: non-final\"),\n                          REJECT_NONSTANDARD, \"non-final\");\n \n     // is it already in the memory pool?\n@@ -984,7 +984,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n \n         // are the actual inputs available?\n         if (!view.HaveInputs(tx))\n-            return state.Invalid(error(\"AcceptToMemoryPool : inputs already spent\"),\n+            return state.Invalid(error(\"AcceptToMemoryPool: inputs already spent\"),\n                                  REJECT_DUPLICATE, \"bad-txns-inputs-spent\");\n \n         // Bring the best block into scope\n@@ -1009,7 +1009,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         nSigOps += GetP2SHSigOpCount(tx, view);\n         if (nSigOps > MAX_TX_SIGOPS)\n             return state.DoS(0,\n-                             error(\"AcceptToMemoryPool : too many sigops %s, %d > %d\",\n+                             error(\"AcceptToMemoryPool: too many sigops %s, %d > %d\",\n                                    hash.ToString(), nSigOps, MAX_TX_SIGOPS),\n                              REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\");\n \n@@ -1023,7 +1023,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         // Don't accept it if it can't get into a block\n         CAmount txMinFee = GetMinRelayFee(tx, nSize, true);\n         if (fLimitFree && nFees < txMinFee)\n-            return state.DoS(0, error(\"AcceptToMemoryPool : not enough fees %s, %d < %d\",\n+            return state.DoS(0, error(\"AcceptToMemoryPool: not enough fees %s, %d < %d\",\n                                       hash.ToString(), nFees, txMinFee),\n                              REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n \n@@ -1050,7 +1050,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n             // -limitfreerelay unit is thousand-bytes-per-minute\n             // At default rate it would take over a month to fill 1GB\n             if (dFreeCount >= GetArg(\"-limitfreerelay\", 15)*10*1000)\n-                return state.DoS(0, error(\"AcceptToMemoryPool : free transaction rejected by rate limiter\"),\n+                return state.DoS(0, error(\"AcceptToMemoryPool: free transaction rejected by rate limiter\"),\n                                  REJECT_INSUFFICIENTFEE, \"rate limited free transaction\");\n             LogPrint(\"mempool\", \"Rate limit dFreeCount: %g => %g\\n\", dFreeCount, dFreeCount+nSize);\n             dFreeCount += nSize;\n@@ -1116,11 +1116,11 @@ bool GetTransaction(const uint256 &hash, CTransaction &txOut, uint256 &hashBlock\n                     fseek(file.Get(), postx.nTxOffset, SEEK_CUR);\n                     file >> txOut;\n                 } catch (const std::exception& e) {\n-                    return error(\"%s : Deserialize or I/O error - %s\", __func__, e.what());\n+                    return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n                 }\n                 hashBlock = header.GetHash();\n                 if (txOut.GetHash() != hash)\n-                    return error(\"%s : txid mismatch\", __func__);\n+                    return error(\"%s: txid mismatch\", __func__);\n                 return true;\n             }\n         }\n@@ -1169,7 +1169,7 @@ bool WriteBlockToDisk(CBlock& block, CDiskBlockPos& pos)\n     // Open history file to append\n     CAutoFile fileout(OpenBlockFile(pos), SER_DISK, CLIENT_VERSION);\n     if (fileout.IsNull())\n-        return error(\"WriteBlockToDisk : OpenBlockFile failed\");\n+        return error(\"WriteBlockToDisk: OpenBlockFile failed\");\n \n     // Write index header\n     unsigned int nSize = fileout.GetSerializeSize(block);\n@@ -1178,7 +1178,7 @@ bool WriteBlockToDisk(CBlock& block, CDiskBlockPos& pos)\n     // Write block\n     long fileOutPos = ftell(fileout.Get());\n     if (fileOutPos < 0)\n-        return error(\"WriteBlockToDisk : ftell failed\");\n+        return error(\"WriteBlockToDisk: ftell failed\");\n     pos.nPos = (unsigned int)fileOutPos;\n     fileout << block;\n \n@@ -1192,19 +1192,19 @@ bool ReadBlockFromDisk(CBlock& block, const CDiskBlockPos& pos)\n     // Open history file to read\n     CAutoFile filein(OpenBlockFile(pos, true), SER_DISK, CLIENT_VERSION);\n     if (filein.IsNull())\n-        return error(\"ReadBlockFromDisk : OpenBlockFile failed\");\n+        return error(\"ReadBlockFromDisk: OpenBlockFile failed\");\n \n     // Read block\n     try {\n         filein >> block;\n     }\n     catch (const std::exception& e) {\n-        return error(\"%s : Deserialize or I/O error - %s\", __func__, e.what());\n+        return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n     }\n \n     // Check the header\n     if (!CheckProofOfWork(block.GetHash(), block.nBits))\n-        return error(\"ReadBlockFromDisk : Errors in block header\");\n+        return error(\"ReadBlockFromDisk: Errors in block header\");\n \n     return true;\n }\n@@ -1214,7 +1214,7 @@ bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex)\n     if (!ReadBlockFromDisk(block, pindex->GetBlockPos()))\n         return false;\n     if (block.GetHash() != pindex->GetBlockHash())\n-        return error(\"ReadBlockFromDisk(CBlock&, CBlockIndex*) : GetHash() doesn't match index\");\n+        return error(\"ReadBlockFromDisk(CBlock&, CBlockIndex*): GetHash() doesn't match index\");\n     return true;\n }\n \n@@ -1416,7 +1416,7 @@ void UpdateCoins(const CTransaction& tx, CValidationState &state, CCoinsViewCach\n bool CScriptCheck::operator()() {\n     const CScript &scriptSig = ptxTo->vin[nIn].scriptSig;\n     if (!VerifyScript(scriptSig, scriptPubKey, nFlags, CachingSignatureChecker(*ptxTo, nIn, cacheStore), &error)) {\n-        return ::error(\"CScriptCheck() : %s:%d VerifySignature failed: %s\", ptxTo->GetHash().ToString(), nIn, ScriptErrorString(error));\n+        return ::error(\"CScriptCheck(): %s:%d VerifySignature failed: %s\", ptxTo->GetHash().ToString(), nIn, ScriptErrorString(error));\n     }\n     return true;\n }\n@@ -1431,7 +1431,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n         // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n         // for an attacker to attempt to split the network.\n         if (!inputs.HaveInputs(tx))\n-            return state.Invalid(error(\"CheckInputs() : %s inputs unavailable\", tx.GetHash().ToString()));\n+            return state.Invalid(error(\"CheckInputs(): %s inputs unavailable\", tx.GetHash().ToString()));\n \n         // While checking, GetBestBlock() refers to the parent block.\n         // This is also true for mempool checks.\n@@ -1449,31 +1449,31 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n             if (coins->IsCoinBase()) {\n                 if (nSpendHeight - coins->nHeight < COINBASE_MATURITY)\n                     return state.Invalid(\n-                        error(\"CheckInputs() : tried to spend coinbase at depth %d\", nSpendHeight - coins->nHeight),\n+                        error(\"CheckInputs(): tried to spend coinbase at depth %d\", nSpendHeight - coins->nHeight),\n                         REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\");\n             }\n \n             // Check for negative or overflow input values\n             nValueIn += coins->vout[prevout.n].nValue;\n             if (!MoneyRange(coins->vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n-                return state.DoS(100, error(\"CheckInputs() : txin values out of range\"),\n+                return state.DoS(100, error(\"CheckInputs(): txin values out of range\"),\n                                  REJECT_INVALID, \"bad-txns-inputvalues-outofrange\");\n \n         }\n \n         if (nValueIn < tx.GetValueOut())\n-            return state.DoS(100, error(\"CheckInputs() : %s value in (%s) < value out (%s)\",\n+            return state.DoS(100, error(\"CheckInputs(): %s value in (%s) < value out (%s)\",\n                                         tx.GetHash().ToString(), FormatMoney(nValueIn), FormatMoney(tx.GetValueOut())),\n                              REJECT_INVALID, \"bad-txns-in-belowout\");\n \n         // Tally transaction fees\n         CAmount nTxFee = nValueIn - tx.GetValueOut();\n         if (nTxFee < 0)\n-            return state.DoS(100, error(\"CheckInputs() : %s nTxFee < 0\", tx.GetHash().ToString()),\n+            return state.DoS(100, error(\"CheckInputs(): %s nTxFee < 0\", tx.GetHash().ToString()),\n                              REJECT_INVALID, \"bad-txns-fee-negative\");\n         nFees += nTxFee;\n         if (!MoneyRange(nFees))\n-            return state.DoS(100, error(\"CheckInputs() : nFees out of range\"),\n+            return state.DoS(100, error(\"CheckInputs(): nFees out of range\"),\n                              REJECT_INVALID, \"bad-txns-fee-outofrange\");\n \n         // The first loop above does all the inexpensive checks.\n@@ -1530,7 +1530,7 @@ bool UndoWriteToDisk(const CBlockUndo& blockundo, CDiskBlockPos& pos, const uint\n     // Open history file to append\n     CAutoFile fileout(OpenUndoFile(pos), SER_DISK, CLIENT_VERSION);\n     if (fileout.IsNull())\n-        return error(\"%s : OpenUndoFile failed\", __func__);\n+        return error(\"%s: OpenUndoFile failed\", __func__);\n \n     // Write index header\n     unsigned int nSize = fileout.GetSerializeSize(blockundo);\n@@ -1539,7 +1539,7 @@ bool UndoWriteToDisk(const CBlockUndo& blockundo, CDiskBlockPos& pos, const uint\n     // Write undo data\n     long fileOutPos = ftell(fileout.Get());\n     if (fileOutPos < 0)\n-        return error(\"%s : ftell failed\", __func__);\n+        return error(\"%s: ftell failed\", __func__);\n     pos.nPos = (unsigned int)fileOutPos;\n     fileout << blockundo;\n \n@@ -1557,7 +1557,7 @@ bool UndoReadFromDisk(CBlockUndo& blockundo, const CDiskBlockPos& pos, const uin\n     // Open history file to read\n     CAutoFile filein(OpenUndoFile(pos, true), SER_DISK, CLIENT_VERSION);\n     if (filein.IsNull())\n-        return error(\"%s : OpenBlockFile failed\", __func__);\n+        return error(\"%s: OpenBlockFile failed\", __func__);\n \n     // Read block\n     uint256 hashChecksum;\n@@ -1566,15 +1566,15 @@ bool UndoReadFromDisk(CBlockUndo& blockundo, const CDiskBlockPos& pos, const uin\n         filein >> hashChecksum;\n     }\n     catch (const std::exception& e) {\n-        return error(\"%s : Deserialize or I/O error - %s\", __func__, e.what());\n+        return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n     }\n \n     // Verify checksum\n     CHashWriter hasher(SER_GETHASH, PROTOCOL_VERSION);\n     hasher << hashBlock;\n     hasher << blockundo;\n     if (hashChecksum != hasher.GetHash())\n-        return error(\"%s : Checksum mismatch\", __func__);\n+        return error(\"%s: Checksum mismatch\", __func__);\n \n     return true;\n }\n@@ -1593,12 +1593,12 @@ bool DisconnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex\n     CBlockUndo blockUndo;\n     CDiskBlockPos pos = pindex->GetUndoPos();\n     if (pos.IsNull())\n-        return error(\"DisconnectBlock() : no undo data available\");\n+        return error(\"DisconnectBlock(): no undo data available\");\n     if (!UndoReadFromDisk(blockUndo, pos, pindex->pprev->GetBlockHash()))\n-        return error(\"DisconnectBlock() : failure reading undo data\");\n+        return error(\"DisconnectBlock(): failure reading undo data\");\n \n     if (blockUndo.vtxundo.size() + 1 != block.vtx.size())\n-        return error(\"DisconnectBlock() : block and undo data inconsistent\");\n+        return error(\"DisconnectBlock(): block and undo data inconsistent\");\n \n     // undo transactions in reverse order\n     for (int i = block.vtx.size() - 1; i >= 0; i--) {\n@@ -1621,7 +1621,7 @@ bool DisconnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex\n         if (outsBlock.nVersion < 0)\n             outs->nVersion = outsBlock.nVersion;\n         if (*outs != outsBlock)\n-            fClean = fClean && error(\"DisconnectBlock() : added transaction mismatch? database corrupted\");\n+            fClean = fClean && error(\"DisconnectBlock(): added transaction mismatch? database corrupted\");\n \n         // remove outputs\n         outs->Clear();\n@@ -1631,25 +1631,25 @@ bool DisconnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex\n         if (i > 0) { // not coinbases\n             const CTxUndo &txundo = blockUndo.vtxundo[i-1];\n             if (txundo.vprevout.size() != tx.vin.size())\n-                return error(\"DisconnectBlock() : transaction and undo data inconsistent\");\n+                return error(\"DisconnectBlock(): transaction and undo data inconsistent\");\n             for (unsigned int j = tx.vin.size(); j-- > 0;) {\n                 const COutPoint &out = tx.vin[j].prevout;\n                 const CTxInUndo &undo = txundo.vprevout[j];\n                 CCoinsModifier coins = view.ModifyCoins(out.hash);\n                 if (undo.nHeight != 0) {\n                     // undo data contains height: this is the last output of the prevout tx being spent\n                     if (!coins->IsPruned())\n-                        fClean = fClean && error(\"DisconnectBlock() : undo data overwriting existing transaction\");\n+                        fClean = fClean && error(\"DisconnectBlock(): undo data overwriting existing transaction\");\n                     coins->Clear();\n                     coins->fCoinBase = undo.fCoinBase;\n                     coins->nHeight = undo.nHeight;\n                     coins->nVersion = undo.nVersion;\n                 } else {\n                     if (coins->IsPruned())\n-                        fClean = fClean && error(\"DisconnectBlock() : undo data adding output to missing transaction\");\n+                        fClean = fClean && error(\"DisconnectBlock(): undo data adding output to missing transaction\");\n                 }\n                 if (coins->IsAvailable(out.n))\n-                    fClean = fClean && error(\"DisconnectBlock() : undo data overwriting existing output\");\n+                    fClean = fClean && error(\"DisconnectBlock(): undo data overwriting existing output\");\n                 if (coins->vout.size() < out.n+1)\n                     coins->vout.resize(out.n+1);\n                 coins->vout[out.n] = undo.txout;\n@@ -1746,7 +1746,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n         BOOST_FOREACH(const CTransaction& tx, block.vtx) {\n             const CCoins* coins = view.AccessCoins(tx.GetHash());\n             if (coins && !coins->IsPruned())\n-                return state.DoS(100, error(\"ConnectBlock() : tried to overwrite transaction\"),\n+                return state.DoS(100, error(\"ConnectBlock(): tried to overwrite transaction\"),\n                                  REJECT_INVALID, \"bad-txns-BIP30\");\n         }\n     }\n@@ -1776,13 +1776,13 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n         nInputs += tx.vin.size();\n         nSigOps += GetLegacySigOpCount(tx);\n         if (nSigOps > MAX_BLOCK_SIGOPS)\n-            return state.DoS(100, error(\"ConnectBlock() : too many sigops\"),\n+            return state.DoS(100, error(\"ConnectBlock(): too many sigops\"),\n                              REJECT_INVALID, \"bad-blk-sigops\");\n \n         if (!tx.IsCoinBase())\n         {\n             if (!view.HaveInputs(tx))\n-                return state.DoS(100, error(\"ConnectBlock() : inputs missing/spent\"),\n+                return state.DoS(100, error(\"ConnectBlock(): inputs missing/spent\"),\n                                  REJECT_INVALID, \"bad-txns-inputs-missingorspent\");\n \n             if (fStrictPayToScriptHash)\n@@ -1792,7 +1792,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n                 // an incredibly-expensive-to-validate block.\n                 nSigOps += GetP2SHSigOpCount(tx, view);\n                 if (nSigOps > MAX_BLOCK_SIGOPS)\n-                    return state.DoS(100, error(\"ConnectBlock() : too many sigops\"),\n+                    return state.DoS(100, error(\"ConnectBlock(): too many sigops\"),\n                                      REJECT_INVALID, \"bad-blk-sigops\");\n             }\n \n@@ -1818,7 +1818,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n \n     if (block.vtx[0].GetValueOut() > GetBlockValue(pindex->nHeight, nFees))\n         return state.DoS(100,\n-                         error(\"ConnectBlock() : coinbase pays too much (actual=%d vs limit=%d)\",\n+                         error(\"ConnectBlock(): coinbase pays too much (actual=%d vs limit=%d)\",\n                                block.vtx[0].GetValueOut(), GetBlockValue(pindex->nHeight, nFees)),\n                                REJECT_INVALID, \"bad-cb-amount\");\n \n@@ -1836,7 +1836,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n         if (pindex->GetUndoPos().IsNull()) {\n             CDiskBlockPos pos;\n             if (!FindUndoPos(state, pindex->nFile, pos, ::GetSerializeSize(blockundo, SER_DISK, CLIENT_VERSION) + 40))\n-                return error(\"ConnectBlock() : FindUndoPos failed\");\n+                return error(\"ConnectBlock(): FindUndoPos failed\");\n             if (!UndoWriteToDisk(blockundo, pos, pindex->pprev->GetBlockHash()))\n                 return state.Abort(\"Failed to write undo data\");\n \n@@ -1988,7 +1988,7 @@ bool static DisconnectTip(CValidationState &state) {\n     {\n         CCoinsViewCache view(pcoinsTip);\n         if (!DisconnectBlock(block, state, pindexDelete, view))\n-            return error(\"DisconnectTip() : DisconnectBlock %s failed\", pindexDelete->GetBlockHash().ToString());\n+            return error(\"DisconnectTip(): DisconnectBlock %s failed\", pindexDelete->GetBlockHash().ToString());\n         assert(view.Flush());\n     }\n     LogPrint(\"bench\", \"- Disconnect block: %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);\n@@ -2048,7 +2048,7 @@ bool static ConnectTip(CValidationState &state, CBlockIndex *pindexNew, CBlock *\n         if (!rv) {\n             if (state.IsInvalid())\n                 InvalidBlockFound(pindexNew, state);\n-            return error(\"ConnectTip() : ConnectBlock %s failed\", pindexNew->GetBlockHash().ToString());\n+            return error(\"ConnectTip(): ConnectBlock %s failed\", pindexNew->GetBlockHash().ToString());\n         }\n         mapBlockSource.erase(inv.hash);\n         nTime3 = GetTimeMicros(); nTimeConnectTotal += nTime3 - nTime2;\n@@ -2485,12 +2485,12 @@ bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, bool f\n {\n     // Check proof of work matches claimed amount\n     if (fCheckPOW && !CheckProofOfWork(block.GetHash(), block.nBits))\n-        return state.DoS(50, error(\"CheckBlockHeader() : proof of work failed\"),\n+        return state.DoS(50, error(\"CheckBlockHeader(): proof of work failed\"),\n                          REJECT_INVALID, \"high-hash\");\n \n     // Check timestamp\n     if (block.GetBlockTime() > GetAdjustedTime() + 2 * 60 * 60)\n-        return state.Invalid(error(\"CheckBlockHeader() : block timestamp too far in the future\"),\n+        return state.Invalid(error(\"CheckBlockHeader(): block timestamp too far in the future\"),\n                              REJECT_INVALID, \"time-too-new\");\n \n     return true;\n@@ -2510,14 +2510,14 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bo\n         bool mutated;\n         uint256 hashMerkleRoot2 = block.BuildMerkleTree(&mutated);\n         if (block.hashMerkleRoot != hashMerkleRoot2)\n-            return state.DoS(100, error(\"CheckBlock() : hashMerkleRoot mismatch\"),\n+            return state.DoS(100, error(\"CheckBlock(): hashMerkleRoot mismatch\"),\n                              REJECT_INVALID, \"bad-txnmrklroot\", true);\n \n         // Check for merkle tree malleability (CVE-2012-2459): repeating sequences\n         // of transactions in a block without affecting the merkle root of a block,\n         // while still invalidating it.\n         if (mutated)\n-            return state.DoS(100, error(\"CheckBlock() : duplicate transaction\"),\n+            return state.DoS(100, error(\"CheckBlock(): duplicate transaction\"),\n                              REJECT_INVALID, \"bad-txns-duplicate\", true);\n     }\n \n@@ -2527,30 +2527,30 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bo\n \n     // Size limits\n     if (block.vtx.empty() || block.vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n-        return state.DoS(100, error(\"CheckBlock() : size limits failed\"),\n+        return state.DoS(100, error(\"CheckBlock(): size limits failed\"),\n                          REJECT_INVALID, \"bad-blk-length\");\n \n     // First transaction must be coinbase, the rest must not be\n     if (block.vtx.empty() || !block.vtx[0].IsCoinBase())\n-        return state.DoS(100, error(\"CheckBlock() : first tx is not coinbase\"),\n+        return state.DoS(100, error(\"CheckBlock(): first tx is not coinbase\"),\n                          REJECT_INVALID, \"bad-cb-missing\");\n     for (unsigned int i = 1; i < block.vtx.size(); i++)\n         if (block.vtx[i].IsCoinBase())\n-            return state.DoS(100, error(\"CheckBlock() : more than one coinbase\"),\n+            return state.DoS(100, error(\"CheckBlock(): more than one coinbase\"),\n                              REJECT_INVALID, \"bad-cb-multiple\");\n \n     // Check transactions\n     BOOST_FOREACH(const CTransaction& tx, block.vtx)\n         if (!CheckTransaction(tx, state))\n-            return error(\"CheckBlock() : CheckTransaction failed\");\n+            return error(\"CheckBlock(): CheckTransaction failed\");\n \n     unsigned int nSigOps = 0;\n     BOOST_FOREACH(const CTransaction& tx, block.vtx)\n     {\n         nSigOps += GetLegacySigOpCount(tx);\n     }\n     if (nSigOps > MAX_BLOCK_SIGOPS)\n-        return state.DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"),\n+        return state.DoS(100, error(\"CheckBlock(): out-of-bounds SigOpCount\"),\n                          REJECT_INVALID, \"bad-blk-sigops\", true);\n \n     return true;\n@@ -2569,28 +2569,28 @@ bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& sta\n     // Check proof of work\n     if ((!Params().SkipProofOfWorkCheck()) &&\n        (block.nBits != GetNextWorkRequired(pindexPrev, &block)))\n-        return state.DoS(100, error(\"%s : incorrect proof of work\", __func__),\n+        return state.DoS(100, error(\"%s: incorrect proof of work\", __func__),\n                          REJECT_INVALID, \"bad-diffbits\");\n \n     // Check timestamp against prev\n     if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n-        return state.Invalid(error(\"%s : block's timestamp is too early\", __func__),\n+        return state.Invalid(error(\"%s: block's timestamp is too early\", __func__),\n                              REJECT_INVALID, \"time-too-old\");\n \n     // Check that the block chain matches the known block chain up to a checkpoint\n     if (!Checkpoints::CheckBlock(nHeight, hash))\n-        return state.DoS(100, error(\"%s : rejected by checkpoint lock-in at %d\", __func__, nHeight),\n+        return state.DoS(100, error(\"%s: rejected by checkpoint lock-in at %d\", __func__, nHeight),\n                          REJECT_CHECKPOINT, \"checkpoint mismatch\");\n \n     // Don't accept any forks from the main chain prior to last checkpoint\n     CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint();\n     if (pcheckpoint && nHeight < pcheckpoint->nHeight)\n-        return state.DoS(100, error(\"%s : forked chain older than last checkpoint (height %d)\", __func__, nHeight));\n+        return state.DoS(100, error(\"%s: forked chain older than last checkpoint (height %d)\", __func__, nHeight));\n \n     // Reject block.nVersion=1 blocks when 95% (75% on testnet) of the network has upgraded:\n     if (block.nVersion < 2 && IsSuperMajority(2, pindexPrev, Params().RejectBlockOutdatedMajority()))\n     {\n-        return state.Invalid(error(\"%s : rejected nVersion=1 block\", __func__),\n+        return state.Invalid(error(\"%s: rejected nVersion=1 block\", __func__),\n                              REJECT_OBSOLETE, \"bad-version\");\n     }\n \n@@ -2604,7 +2604,7 @@ bool ContextualCheckBlock(const CBlock& block, CValidationState& state, CBlockIn\n     // Check that all transactions are finalized\n     BOOST_FOREACH(const CTransaction& tx, block.vtx)\n         if (!IsFinalTx(tx, nHeight, block.GetBlockTime())) {\n-            return state.DoS(10, error(\"%s : contains a non-final transaction\", __func__), REJECT_INVALID, \"bad-txns-nonfinal\");\n+            return state.DoS(10, error(\"%s: contains a non-final transaction\", __func__), REJECT_INVALID, \"bad-txns-nonfinal\");\n         }\n \n     // Enforce block.nVersion=2 rule that the coinbase starts with serialized block height\n@@ -2614,7 +2614,7 @@ bool ContextualCheckBlock(const CBlock& block, CValidationState& state, CBlockIn\n         CScript expect = CScript() << nHeight;\n         if (block.vtx[0].vin[0].scriptSig.size() < expect.size() ||\n             !std::equal(expect.begin(), expect.end(), block.vtx[0].vin[0].scriptSig.begin())) {\n-            return state.DoS(100, error(\"%s : block height mismatch in coinbase\", __func__), REJECT_INVALID, \"bad-cb-height\");\n+            return state.DoS(100, error(\"%s: block height mismatch in coinbase\", __func__), REJECT_INVALID, \"bad-cb-height\");\n         }\n     }\n \n@@ -2634,7 +2634,7 @@ bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, CBloc\n         if (ppindex)\n             *ppindex = pindex;\n         if (pindex->nStatus & BLOCK_FAILED_MASK)\n-            return state.Invalid(error(\"%s : block is marked invalid\", __func__), 0, \"duplicate\");\n+            return state.Invalid(error(\"%s: block is marked invalid\", __func__), 0, \"duplicate\");\n         return true;\n     }\n \n@@ -2646,10 +2646,10 @@ bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, CBloc\n     if (hash != Params().HashGenesisBlock()) {\n         BlockMap::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n         if (mi == mapBlockIndex.end())\n-            return state.DoS(10, error(\"%s : prev block not found\", __func__), 0, \"bad-prevblk\");\n+            return state.DoS(10, error(\"%s: prev block not found\", __func__), 0, \"bad-prevblk\");\n         pindexPrev = (*mi).second;\n         if (pindexPrev->nStatus & BLOCK_FAILED_MASK)\n-            return state.DoS(100, error(\"%s : prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n+            return state.DoS(100, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n     }\n \n     if (!ContextualCheckBlockHeader(block, state, pindexPrev))\n@@ -2675,7 +2675,7 @@ bool AcceptBlock(CBlock& block, CValidationState& state, CBlockIndex** ppindex,\n \n     if (pindex->nStatus & BLOCK_HAVE_DATA) {\n         // TODO: deal better with duplicate blocks.\n-        // return state.DoS(20, error(\"AcceptBlock() : already have block %d %s\", pindex->nHeight, pindex->GetBlockHash().ToString()), REJECT_DUPLICATE, \"duplicate\");\n+        // return state.DoS(20, error(\"AcceptBlock(): already have block %d %s\", pindex->nHeight, pindex->GetBlockHash().ToString()), REJECT_DUPLICATE, \"duplicate\");\n         return true;\n     }\n \n@@ -2696,12 +2696,12 @@ bool AcceptBlock(CBlock& block, CValidationState& state, CBlockIndex** ppindex,\n         if (dbp != NULL)\n             blockPos = *dbp;\n         if (!FindBlockPos(state, blockPos, nBlockSize+8, nHeight, block.GetBlockTime(), dbp != NULL))\n-            return error(\"AcceptBlock() : FindBlockPos failed\");\n+            return error(\"AcceptBlock(): FindBlockPos failed\");\n         if (dbp == NULL)\n             if (!WriteBlockToDisk(block, blockPos))\n                 return state.Abort(\"Failed to write block\");\n         if (!ReceivedBlockTransactions(block, state, pindex, blockPos))\n-            return error(\"AcceptBlock() : ReceivedBlockTransactions failed\");\n+            return error(\"AcceptBlock(): ReceivedBlockTransactions failed\");\n     } catch (const std::runtime_error& e) {\n         return state.Abort(std::string(\"System error: \") + e.what());\n     }\n@@ -2732,7 +2732,7 @@ bool ProcessNewBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDis\n         LOCK(cs_main);\n         MarkBlockAsReceived(pblock->GetHash());\n         if (!checked) {\n-            return error(\"%s : CheckBlock FAILED\", __func__);\n+            return error(\"%s: CheckBlock FAILED\", __func__);\n         }\n \n         // Store to disk\n@@ -2742,11 +2742,11 @@ bool ProcessNewBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDis\n             mapBlockSource[pindex->GetBlockHash()] = pfrom->GetId();\n         }\n         if (!ret)\n-            return error(\"%s : AcceptBlock FAILED\", __func__);\n+            return error(\"%s: AcceptBlock FAILED\", __func__);\n     }\n \n     if (!ActivateBestChain(state, pblock))\n-        return error(\"%s : ActivateBestChain failed\", __func__);\n+        return error(\"%s: ActivateBestChain failed\", __func__);\n \n     return true;\n }\n@@ -2852,7 +2852,7 @@ CBlockIndex * InsertBlockIndex(uint256 hash)\n     // Create new\n     CBlockIndex* pindexNew = new CBlockIndex();\n     if (!pindexNew)\n-        throw runtime_error(\"LoadBlockIndex() : new CBlockIndex failed\");\n+        throw runtime_error(\"LoadBlockIndex(): new CBlockIndex failed\");\n     mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n     pindexNew->phashBlock = &((*mi).first);\n \n@@ -2998,24 +2998,24 @@ bool CVerifyDB::VerifyDB(CCoinsView *coinsview, int nCheckLevel, int nCheckDepth\n         CBlock block;\n         // check level 0: read from disk\n         if (!ReadBlockFromDisk(block, pindex))\n-            return error(\"VerifyDB() : *** ReadBlockFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n+            return error(\"VerifyDB(): *** ReadBlockFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n         // check level 1: verify block validity\n         if (nCheckLevel >= 1 && !CheckBlock(block, state))\n-            return error(\"VerifyDB() : *** found bad block at %d, hash=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());\n+            return error(\"VerifyDB(): *** found bad block at %d, hash=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());\n         // check level 2: verify undo validity\n         if (nCheckLevel >= 2 && pindex) {\n             CBlockUndo undo;\n             CDiskBlockPos pos = pindex->GetUndoPos();\n             if (!pos.IsNull()) {\n                 if (!UndoReadFromDisk(undo, pos, pindex->pprev->GetBlockHash()))\n-                    return error(\"VerifyDB() : *** found bad undo data at %d, hash=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());\n+                    return error(\"VerifyDB(): *** found bad undo data at %d, hash=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());\n             }\n         }\n         // check level 3: check for inconsistencies during memory-only disconnect of tip blocks\n         if (nCheckLevel >= 3 && pindex == pindexState && (coins.GetCacheSize() + pcoinsTip->GetCacheSize()) <= nCoinCacheSize) {\n             bool fClean = true;\n             if (!DisconnectBlock(block, state, pindex, coins, &fClean))\n-                return error(\"VerifyDB() : *** irrecoverable inconsistency in block data at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n+                return error(\"VerifyDB(): *** irrecoverable inconsistency in block data at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n             pindexState = pindex->pprev;\n             if (!fClean) {\n                 nGoodTransactions = 0;\n@@ -3027,7 +3027,7 @@ bool CVerifyDB::VerifyDB(CCoinsView *coinsview, int nCheckLevel, int nCheckDepth\n             return true;\n     }\n     if (pindexFailure)\n-        return error(\"VerifyDB() : *** coin database inconsistencies found (last %i blocks, %i good transactions before that)\\n\", chainActive.Height() - pindexFailure->nHeight + 1, nGoodTransactions);\n+        return error(\"VerifyDB(): *** coin database inconsistencies found (last %i blocks, %i good transactions before that)\\n\", chainActive.Height() - pindexFailure->nHeight + 1, nGoodTransactions);\n \n     // check level 4: try reconnecting blocks\n     if (nCheckLevel >= 4) {\n@@ -3038,9 +3038,9 @@ bool CVerifyDB::VerifyDB(CCoinsView *coinsview, int nCheckLevel, int nCheckDepth\n             pindex = chainActive.Next(pindex);\n             CBlock block;\n             if (!ReadBlockFromDisk(block, pindex))\n-                return error(\"VerifyDB() : *** ReadBlockFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n+                return error(\"VerifyDB(): *** ReadBlockFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n             if (!ConnectBlock(block, state, pindex, coins))\n-                return error(\"VerifyDB() : *** found unconnectable block at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n+                return error(\"VerifyDB(): *** found unconnectable block at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n         }\n     }\n \n@@ -3086,18 +3086,18 @@ bool InitBlockIndex() {\n             CDiskBlockPos blockPos;\n             CValidationState state;\n             if (!FindBlockPos(state, blockPos, nBlockSize+8, 0, block.GetBlockTime()))\n-                return error(\"LoadBlockIndex() : FindBlockPos failed\");\n+                return error(\"LoadBlockIndex(): FindBlockPos failed\");\n             if (!WriteBlockToDisk(block, blockPos))\n-                return error(\"LoadBlockIndex() : writing genesis block to disk failed\");\n+                return error(\"LoadBlockIndex(): writing genesis block to disk failed\");\n             CBlockIndex *pindex = AddToBlockIndex(block);\n             if (!ReceivedBlockTransactions(block, state, pindex, blockPos))\n-                return error(\"LoadBlockIndex() : genesis block not accepted\");\n+                return error(\"LoadBlockIndex(): genesis block not accepted\");\n             if (!ActivateBestChain(state, &block))\n-                return error(\"LoadBlockIndex() : genesis block cannot be activated\");\n+                return error(\"LoadBlockIndex(): genesis block cannot be activated\");\n             // Force a chainstate write so that when we VerifyDB in a moment, it doesn't check stale data\n             return FlushStateToDisk(state, FLUSH_STATE_ALWAYS);\n         } catch (const std::runtime_error& e) {\n-            return error(\"LoadBlockIndex() : failed to initialize block database: %s\", e.what());\n+            return error(\"LoadBlockIndex(): failed to initialize block database: %s\", e.what());\n         }\n     }\n \n@@ -3197,7 +3197,7 @@ bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n                     }\n                 }\n             } catch (const std::exception& e) {\n-                LogPrintf(\"%s : Deserialize or I/O error - %s\", __func__, e.what());\n+                LogPrintf(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n             }\n         }\n     } catch (const std::runtime_error& e) {\n@@ -3261,7 +3261,7 @@ string GetWarnings(string strFor)\n         return strStatusBar;\n     else if (strFor == \"rpc\")\n         return strRPC;\n-    assert(!\"GetWarnings() : invalid parameter\");\n+    assert(!\"GetWarnings(): invalid parameter\");\n     return \"error\";\n }\n \n@@ -3828,7 +3828,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             vWorkQueue.push_back(inv.hash);\n             vEraseQueue.push_back(inv.hash);\n \n-            LogPrint(\"mempool\", \"AcceptToMemoryPool: peer=%d %s : accepted %s (poolsz %u)\\n\",\n+            LogPrint(\"mempool\", \"AcceptToMemoryPool: peer=%d %s: accepted %s (poolsz %u)\\n\",\n                 pfrom->id, pfrom->cleanSubVer,\n                 tx.GetHash().ToString(),\n                 mempool.mapTx.size());\n@@ -4290,7 +4290,7 @@ bool ProcessMessages(CNode* pfrom)\n         memcpy(&nChecksum, &hash, sizeof(nChecksum));\n         if (nChecksum != hdr.nChecksum)\n         {\n-            LogPrintf(\"ProcessMessages(%s, %u bytes) : CHECKSUM ERROR nChecksum=%08x hdr.nChecksum=%08x\\n\",\n+            LogPrintf(\"ProcessMessages(%s, %u bytes): CHECKSUM ERROR nChecksum=%08x hdr.nChecksum=%08x\\n\",\n                strCommand, nMessageSize, nChecksum, hdr.nChecksum);\n             continue;\n         }\n@@ -4308,12 +4308,12 @@ bool ProcessMessages(CNode* pfrom)\n             if (strstr(e.what(), \"end of data\"))\n             {\n                 // Allow exceptions from under-length message on vRecv\n-                LogPrintf(\"ProcessMessages(%s, %u bytes) : Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", strCommand, nMessageSize, e.what());\n+                LogPrintf(\"ProcessMessages(%s, %u bytes): Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", strCommand, nMessageSize, e.what());\n             }\n             else if (strstr(e.what(), \"size too large\"))\n             {\n                 // Allow exceptions from over-long size\n-                LogPrintf(\"ProcessMessages(%s, %u bytes) : Exception '%s' caught\\n\", strCommand, nMessageSize, e.what());\n+                LogPrintf(\"ProcessMessages(%s, %u bytes): Exception '%s' caught\\n\", strCommand, nMessageSize, e.what());\n             }\n             else\n             {"
      },
      {
        "sha": "31db0626c4dd8efc3fab4646fd75afb1911cc37a",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -333,7 +333,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n \n         CValidationState state;\n         if (!TestBlockValidity(state, *pblock, pindexPrev, false, false))\n-            throw std::runtime_error(\"CreateNewBlock() : TestBlockValidity failed\");\n+            throw std::runtime_error(\"CreateNewBlock(): TestBlockValidity failed\");\n     }\n \n     return pblocktemplate.release();\n@@ -420,7 +420,7 @@ static bool ProcessBlockFound(CBlock* pblock, CWallet& wallet, CReserveKey& rese\n     {\n         LOCK(cs_main);\n         if (pblock->hashPrevBlock != chainActive.Tip()->GetBlockHash())\n-            return error(\"BitcoinMiner : generated block is stale\");\n+            return error(\"BitcoinMiner: generated block is stale\");\n     }\n \n     // Remove key from key pool\n@@ -435,7 +435,7 @@ static bool ProcessBlockFound(CBlock* pblock, CWallet& wallet, CReserveKey& rese\n     // Process this block the same as if we had received it from another node\n     CValidationState state;\n     if (!ProcessNewBlock(state, NULL, pblock))\n-        return error(\"BitcoinMiner : ProcessNewBlock, block not accepted\");\n+        return error(\"BitcoinMiner: ProcessNewBlock, block not accepted\");\n \n     return true;\n }"
      },
      {
        "sha": "31e5711f39de5242f44b9f60b53fe258b9308701",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -1070,7 +1070,7 @@ void ThreadMapPort()\n         catch (const boost::thread_interrupted&)\n         {\n             r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n-            LogPrintf(\"UPNP_DeletePortMapping() returned : %d\\n\", r);\n+            LogPrintf(\"UPNP_DeletePortMapping() returned: %d\\n\", r);\n             freeUPNPDevlist(devlist); devlist = 0;\n             FreeUPNPUrls(&urls);\n             throw;\n@@ -1847,21 +1847,21 @@ bool CAddrDB::Write(const CAddrMan& addr)\n     FILE *file = fopen(pathTmp.string().c_str(), \"wb\");\n     CAutoFile fileout(file, SER_DISK, CLIENT_VERSION);\n     if (fileout.IsNull())\n-        return error(\"%s : Failed to open file %s\", __func__, pathTmp.string());\n+        return error(\"%s: Failed to open file %s\", __func__, pathTmp.string());\n \n     // Write and commit header, data\n     try {\n         fileout << ssPeers;\n     }\n     catch (const std::exception& e) {\n-        return error(\"%s : Serialize or I/O error - %s\", __func__, e.what());\n+        return error(\"%s: Serialize or I/O error - %s\", __func__, e.what());\n     }\n     FileCommit(fileout.Get());\n     fileout.fclose();\n \n     // replace existing peers.dat, if any, with new peers.dat.XXXX\n     if (!RenameOver(pathTmp, pathAddr))\n-        return error(\"%s : Rename-into-place failed\", __func__);\n+        return error(\"%s: Rename-into-place failed\", __func__);\n \n     return true;\n }\n@@ -1872,7 +1872,7 @@ bool CAddrDB::Read(CAddrMan& addr)\n     FILE *file = fopen(pathAddr.string().c_str(), \"rb\");\n     CAutoFile filein(file, SER_DISK, CLIENT_VERSION);\n     if (filein.IsNull())\n-        return error(\"%s : Failed to open file %s\", __func__, pathAddr.string());\n+        return error(\"%s: Failed to open file %s\", __func__, pathAddr.string());\n \n     // use file size to size memory buffer\n     int fileSize = boost::filesystem::file_size(pathAddr);\n@@ -1890,7 +1890,7 @@ bool CAddrDB::Read(CAddrMan& addr)\n         filein >> hashIn;\n     }\n     catch (const std::exception& e) {\n-        return error(\"%s : Deserialize or I/O error - %s\", __func__, e.what());\n+        return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n     }\n     filein.fclose();\n \n@@ -1899,7 +1899,7 @@ bool CAddrDB::Read(CAddrMan& addr)\n     // verify stored checksum matches input data\n     uint256 hashTmp = Hash(ssPeers.begin(), ssPeers.end());\n     if (hashIn != hashTmp)\n-        return error(\"%s : Checksum mismatch, data corrupted\", __func__);\n+        return error(\"%s: Checksum mismatch, data corrupted\", __func__);\n \n     unsigned char pchMsgTmp[4];\n     try {\n@@ -1908,13 +1908,13 @@ bool CAddrDB::Read(CAddrMan& addr)\n \n         // ... verify the network matches ours\n         if (memcmp(pchMsgTmp, Params().MessageStart(), sizeof(pchMsgTmp)))\n-            return error(\"%s : Invalid network magic number\", __func__);\n+            return error(\"%s: Invalid network magic number\", __func__);\n \n         // de-serialize address data into one CAddrMan object\n         ssPeers >> addr;\n     }\n     catch (const std::exception& e) {\n-        return error(\"%s : Deserialize or I/O error - %s\", __func__, e.what());\n+        return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n     }\n \n     return true;"
      },
      {
        "sha": "e49f0d104c26600c78ef5f392925c6c8f9c63280",
        "filename": "src/pow.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/pow.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/pow.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow.cpp?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -89,11 +89,11 @@ bool CheckProofOfWork(uint256 hash, unsigned int nBits)\n \n     // Check range\n     if (fNegative || bnTarget == 0 || fOverflow || bnTarget > Params().ProofOfWorkLimit())\n-        return error(\"CheckProofOfWork() : nBits below minimum work\");\n+        return error(\"CheckProofOfWork(): nBits below minimum work\");\n \n     // Check proof of work matches claimed amount\n     if (UintToArith256(hash) > bnTarget)\n-        return error(\"CheckProofOfWork() : hash doesn't match nBits\");\n+        return error(\"CheckProofOfWork(): hash doesn't match nBits\");\n \n     return true;\n }"
      },
      {
        "sha": "606dbea79857d2f4cc79b0136ad46486f3c187d9",
        "filename": "src/primitives/transaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/primitives/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/primitives/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.cpp?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -94,7 +94,7 @@ CAmount CTransaction::GetValueOut() const\n     {\n         nValueOut += it->nValue;\n         if (!MoneyRange(it->nValue) || !MoneyRange(nValueOut))\n-            throw std::runtime_error(\"CTransaction::GetValueOut() : value out of range\");\n+            throw std::runtime_error(\"CTransaction::GetValueOut(): value out of range\");\n     }\n     return nValueOut;\n }"
      },
      {
        "sha": "74ac706d60c6f14fc060e047068ee716128cb09b",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -66,7 +66,7 @@ bool CMessageHeader::IsValid() const\n     // Message size\n     if (nMessageSize > MAX_SIZE)\n     {\n-        LogPrintf(\"CMessageHeader::IsValid() : (%s, %u bytes) nMessageSize > MAX_SIZE\\n\", GetCommand(), nMessageSize);\n+        LogPrintf(\"CMessageHeader::IsValid(): (%s, %u bytes) nMessageSize > MAX_SIZE\\n\", GetCommand(), nMessageSize);\n         return false;\n     }\n \n@@ -117,7 +117,7 @@ CInv::CInv(const std::string& strType, const uint256& hashIn)\n         }\n     }\n     if (i == ARRAYLEN(ppszTypeName))\n-        throw std::out_of_range(strprintf(\"CInv::CInv(string, uint256) : unknown type '%s'\", strType));\n+        throw std::out_of_range(strprintf(\"CInv::CInv(string, uint256): unknown type '%s'\", strType));\n     hash = hashIn;\n }\n \n@@ -134,7 +134,7 @@ bool CInv::IsKnownType() const\n const char* CInv::GetCommand() const\n {\n     if (!IsKnownType())\n-        throw std::out_of_range(strprintf(\"CInv::GetCommand() : type=%d unknown type\", type));\n+        throw std::out_of_range(strprintf(\"CInv::GetCommand(): type=%d unknown type\", type));\n     return ppszTypeName[type];\n }\n "
      },
      {
        "sha": "162ecdba4ef4c84d4288e504db4e337664eb6282",
        "filename": "src/qt/addresstablemodel.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/qt/addresstablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/qt/addresstablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addresstablemodel.cpp?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -114,7 +114,7 @@ class AddressTablePriv\n         case CT_NEW:\n             if(inModel)\n             {\n-                qWarning() << \"AddressTablePriv::updateEntry : Warning: Got CT_NEW, but entry is already in model\";\n+                qWarning() << \"AddressTablePriv::updateEntry: Warning: Got CT_NEW, but entry is already in model\";\n                 break;\n             }\n             parent->beginInsertRows(QModelIndex(), lowerIndex, lowerIndex);\n@@ -124,7 +124,7 @@ class AddressTablePriv\n         case CT_UPDATED:\n             if(!inModel)\n             {\n-                qWarning() << \"AddressTablePriv::updateEntry : Warning: Got CT_UPDATED, but entry is not in model\";\n+                qWarning() << \"AddressTablePriv::updateEntry: Warning: Got CT_UPDATED, but entry is not in model\";\n                 break;\n             }\n             lower->type = newEntryType;\n@@ -134,7 +134,7 @@ class AddressTablePriv\n         case CT_DELETED:\n             if(!inModel)\n             {\n-                qWarning() << \"AddressTablePriv::updateEntry : Warning: Got CT_DELETED, but entry is not in model\";\n+                qWarning() << \"AddressTablePriv::updateEntry: Warning: Got CT_DELETED, but entry is not in model\";\n                 break;\n             }\n             parent->beginRemoveRows(QModelIndex(), lowerIndex, upperIndex-1);"
      },
      {
        "sha": "03d94f2e13f127dcb875d733eef691506df7a5a1",
        "filename": "src/qt/clientmodel.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/qt/clientmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/qt/clientmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.cpp?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -212,14 +212,14 @@ static void ShowProgress(ClientModel *clientmodel, const std::string &title, int\n \n static void NotifyNumConnectionsChanged(ClientModel *clientmodel, int newNumConnections)\n {\n-    // Too noisy: qDebug() << \"NotifyNumConnectionsChanged : \" + QString::number(newNumConnections);\n+    // Too noisy: qDebug() << \"NotifyNumConnectionsChanged: \" + QString::number(newNumConnections);\n     QMetaObject::invokeMethod(clientmodel, \"updateNumConnections\", Qt::QueuedConnection,\n                               Q_ARG(int, newNumConnections));\n }\n \n static void NotifyAlertChanged(ClientModel *clientmodel, const uint256 &hash, ChangeType status)\n {\n-    qDebug() << \"NotifyAlertChanged : \" + QString::fromStdString(hash.GetHex()) + \" status=\" + QString::number(status);\n+    qDebug() << \"NotifyAlertChanged: \" + QString::fromStdString(hash.GetHex()) + \" status=\" + QString::number(status);\n     QMetaObject::invokeMethod(clientmodel, \"updateAlert\", Qt::QueuedConnection,\n                               Q_ARG(QString, QString::fromStdString(hash.GetHex())),\n                               Q_ARG(int, status));"
      },
      {
        "sha": "6847f8cc2f7d6fd6ac902c1c76fe3dfce15af3cd",
        "filename": "src/qt/coincontroltreewidget.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/qt/coincontroltreewidget.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/qt/coincontroltreewidget.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroltreewidget.cpp?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -29,4 +29,4 @@ void CoinControlTreeWidget::keyPressEvent(QKeyEvent *event)\n     {\n         this->QTreeWidget::keyPressEvent(event);\n     }\n-}\n\\ No newline at end of file\n+}"
      },
      {
        "sha": "bab52a58aaf7303d275531804fde889ed16a8308",
        "filename": "src/qt/paymentrequestplus.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/qt/paymentrequestplus.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/qt/paymentrequestplus.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentrequestplus.cpp?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -30,18 +30,18 @@ bool PaymentRequestPlus::parse(const QByteArray& data)\n {\n     bool parseOK = paymentRequest.ParseFromArray(data.data(), data.size());\n     if (!parseOK) {\n-        qWarning() << \"PaymentRequestPlus::parse : Error parsing payment request\";\n+        qWarning() << \"PaymentRequestPlus::parse: Error parsing payment request\";\n         return false;\n     }\n     if (paymentRequest.payment_details_version() > 1) {\n-        qWarning() << \"PaymentRequestPlus::parse : Received up-version payment details, version=\" << paymentRequest.payment_details_version();\n+        qWarning() << \"PaymentRequestPlus::parse: Received up-version payment details, version=\" << paymentRequest.payment_details_version();\n         return false;\n     }\n \n     parseOK = details.ParseFromString(paymentRequest.serialized_payment_details());\n     if (!parseOK)\n     {\n-        qWarning() << \"PaymentRequestPlus::parse : Error parsing payment details\";\n+        qWarning() << \"PaymentRequestPlus::parse: Error parsing payment details\";\n         paymentRequest.Clear();\n         return false;\n     }\n@@ -81,17 +81,17 @@ bool PaymentRequestPlus::getMerchant(X509_STORE* certStore, QString& merchant) c\n         digestAlgorithm = EVP_sha1();\n     }\n     else if (paymentRequest.pki_type() == \"none\") {\n-        qWarning() << \"PaymentRequestPlus::getMerchant : Payment request: pki_type == none\";\n+        qWarning() << \"PaymentRequestPlus::getMerchant: Payment request: pki_type == none\";\n         return false;\n     }\n     else {\n-        qWarning() << \"PaymentRequestPlus::getMerchant : Payment request: unknown pki_type \" << QString::fromStdString(paymentRequest.pki_type());\n+        qWarning() << \"PaymentRequestPlus::getMerchant: Payment request: unknown pki_type \" << QString::fromStdString(paymentRequest.pki_type());\n         return false;\n     }\n \n     payments::X509Certificates certChain;\n     if (!certChain.ParseFromString(paymentRequest.pki_data())) {\n-        qWarning() << \"PaymentRequestPlus::getMerchant : Payment request: error parsing pki_data\";\n+        qWarning() << \"PaymentRequestPlus::getMerchant: Payment request: error parsing pki_data\";\n         return false;\n     }\n \n@@ -101,12 +101,12 @@ bool PaymentRequestPlus::getMerchant(X509_STORE* certStore, QString& merchant) c\n         QByteArray certData(certChain.certificate(i).data(), certChain.certificate(i).size());\n         QSslCertificate qCert(certData, QSsl::Der);\n         if (currentTime < qCert.effectiveDate() || currentTime > qCert.expiryDate()) {\n-            qWarning() << \"PaymentRequestPlus::getMerchant : Payment request: certificate expired or not yet active: \" << qCert;\n+            qWarning() << \"PaymentRequestPlus::getMerchant: Payment request: certificate expired or not yet active: \" << qCert;\n             return false;\n         }\n #if QT_VERSION >= 0x050000\n         if (qCert.isBlacklisted()) {\n-            qWarning() << \"PaymentRequestPlus::getMerchant : Payment request: certificate blacklisted: \" << qCert;\n+            qWarning() << \"PaymentRequestPlus::getMerchant: Payment request: certificate blacklisted: \" << qCert;\n             return false;\n         }\n #endif\n@@ -116,7 +116,7 @@ bool PaymentRequestPlus::getMerchant(X509_STORE* certStore, QString& merchant) c\n             certs.push_back(cert);\n     }\n     if (certs.empty()) {\n-        qWarning() << \"PaymentRequestPlus::getMerchant : Payment request: empty certificate chain\";\n+        qWarning() << \"PaymentRequestPlus::getMerchant: Payment request: empty certificate chain\";\n         return false;\n     }\n \n@@ -132,7 +132,7 @@ bool PaymentRequestPlus::getMerchant(X509_STORE* certStore, QString& merchant) c\n     // load the signing cert into it and verify.\n     X509_STORE_CTX *store_ctx = X509_STORE_CTX_new();\n     if (!store_ctx) {\n-        qWarning() << \"PaymentRequestPlus::getMerchant : Payment request: error creating X509_STORE_CTX\";\n+        qWarning() << \"PaymentRequestPlus::getMerchant: Payment request: error creating X509_STORE_CTX\";\n         return false;\n     }\n \n@@ -183,7 +183,7 @@ bool PaymentRequestPlus::getMerchant(X509_STORE* certStore, QString& merchant) c\n     }\n     catch (const SSLVerifyError& err) {\n         fResult = false;\n-        qWarning() << \"PaymentRequestPlus::getMerchant : SSL error: \" << err.what();\n+        qWarning() << \"PaymentRequestPlus::getMerchant: SSL error: \" << err.what();\n     }\n \n     if (website)"
      },
      {
        "sha": "8d6a97d2180e8e4e62dab1448db245d18cb4465f",
        "filename": "src/qt/paymentserver.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/qt/paymentserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/qt/paymentserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentserver.cpp?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -97,7 +97,7 @@ static QList<QString> savedPaymentRequests;\n \n static void ReportInvalidCertificate(const QSslCertificate& cert)\n {\n-    qDebug() << \"ReportInvalidCertificate : Payment server found an invalid certificate: \" << cert.subjectInfo(QSslCertificate::CommonName);\n+    qDebug() << \"ReportInvalidCertificate: Payment server found an invalid certificate: \" << cert.subjectInfo(QSslCertificate::CommonName);\n }\n \n //\n@@ -168,7 +168,7 @@ void PaymentServer::LoadRootCAs(X509_STORE* _store)\n             continue;\n         }\n     }\n-    qWarning() << \"PaymentServer::LoadRootCAs : Loaded \" << nRootCerts << \" root certificates\";\n+    qWarning() << \"PaymentServer::LoadRootCAs: Loaded \" << nRootCerts << \" root certificates\";\n \n     // Project for another day:\n     // Fetch certificate revocation lists, and add them to certStore.\n@@ -241,7 +241,7 @@ void PaymentServer::ipcParseCommandLine(int argc, char* argv[])\n         {\n             // Printing to debug.log is about the best we can do here, the\n             // GUI hasn't started yet so we can't pop up a message box.\n-            qWarning() << \"PaymentServer::ipcSendCommandLine : Payment request file does not exist: \" << arg;\n+            qWarning() << \"PaymentServer::ipcSendCommandLine: Payment request file does not exist: \" << arg;\n         }\n     }\n }\n@@ -365,10 +365,10 @@ void PaymentServer::initNetManager()\n     if (optionsModel->getProxySettings(proxy)) {\n         netManager->setProxy(proxy);\n \n-        qDebug() << \"PaymentServer::initNetManager : Using SOCKS5 proxy\" << proxy.hostName() << \":\" << proxy.port();\n+        qDebug() << \"PaymentServer::initNetManager: Using SOCKS5 proxy\" << proxy.hostName() << \":\" << proxy.port();\n     }\n     else\n-        qDebug() << \"PaymentServer::initNetManager : No active proxy server found.\";\n+        qDebug() << \"PaymentServer::initNetManager: No active proxy server found.\";\n \n     connect(netManager, SIGNAL(finished(QNetworkReply*)),\n             this, SLOT(netRequestFinished(QNetworkReply*)));\n@@ -412,12 +412,12 @@ void PaymentServer::handleURIOrFile(const QString& s)\n \n             if (fetchUrl.isValid())\n             {\n-                qDebug() << \"PaymentServer::handleURIOrFile : fetchRequest(\" << fetchUrl << \")\";\n+                qDebug() << \"PaymentServer::handleURIOrFile: fetchRequest(\" << fetchUrl << \")\";\n                 fetchRequest(fetchUrl);\n             }\n             else\n             {\n-                qWarning() << \"PaymentServer::handleURIOrFile : Invalid URL: \" << fetchUrl;\n+                qWarning() << \"PaymentServer::handleURIOrFile: Invalid URL: \" << fetchUrl;\n                 emit message(tr(\"URI handling\"),\n                     tr(\"Payment request fetch URL is invalid: %1\").arg(fetchUrl.toString()),\n                     CClientUIInterface::ICON_WARNING);\n@@ -586,10 +586,10 @@ bool PaymentServer::processPaymentRequest(PaymentRequestPlus& request, SendCoins\n     recipient.address = addresses.join(\"<br />\");\n \n     if (!recipient.authenticatedMerchant.isEmpty()) {\n-        qDebug() << \"PaymentServer::processPaymentRequest : Secure payment request from \" << recipient.authenticatedMerchant;\n+        qDebug() << \"PaymentServer::processPaymentRequest: Secure payment request from \" << recipient.authenticatedMerchant;\n     }\n     else {\n-        qDebug() << \"PaymentServer::processPaymentRequest : Insecure payment request to \" << addresses.join(\", \");\n+        qDebug() << \"PaymentServer::processPaymentRequest: Insecure payment request to \" << addresses.join(\", \");\n     }\n \n     return true;\n@@ -644,7 +644,7 @@ void PaymentServer::fetchPaymentACK(CWallet* wallet, SendCoinsRecipient recipien\n         else {\n             // This should never happen, because sending coins should have\n             // just unlocked the wallet and refilled the keypool.\n-            qWarning() << \"PaymentServer::fetchPaymentACK : Error getting refund key, refund_to not set\";\n+            qWarning() << \"PaymentServer::fetchPaymentACK: Error getting refund key, refund_to not set\";\n         }\n     }\n \n@@ -656,7 +656,7 @@ void PaymentServer::fetchPaymentACK(CWallet* wallet, SendCoinsRecipient recipien\n     }\n     else {\n         // This should never happen, either.\n-        qWarning() << \"PaymentServer::fetchPaymentACK : Error serializing payment message\";\n+        qWarning() << \"PaymentServer::fetchPaymentACK: Error serializing payment message\";\n     }\n }\n \n@@ -695,7 +695,7 @@ void PaymentServer::netRequestFinished(QNetworkReply* reply)\n         SendCoinsRecipient recipient;\n         if (!request.parse(data))\n         {\n-            qWarning() << \"PaymentServer::netRequestFinished : Error parsing payment request\";\n+            qWarning() << \"PaymentServer::netRequestFinished: Error parsing payment request\";\n             emit message(tr(\"Payment request error\"),\n                 tr(\"Payment request cannot be parsed!\"),\n                 CClientUIInterface::MSG_ERROR);\n@@ -713,7 +713,7 @@ void PaymentServer::netRequestFinished(QNetworkReply* reply)\n             QString msg = tr(\"Bad response from server %1\")\n                 .arg(reply->request().url().toString());\n \n-            qWarning() << \"PaymentServer::netRequestFinished : \" << msg;\n+            qWarning() << \"PaymentServer::netRequestFinished: \" << msg;\n             emit message(tr(\"Payment request error\"), msg, CClientUIInterface::MSG_ERROR);\n         }\n         else\n@@ -729,7 +729,7 @@ void PaymentServer::reportSslErrors(QNetworkReply* reply, const QList<QSslError>\n \n     QString errString;\n     foreach (const QSslError& err, errs) {\n-        qWarning() << \"PaymentServer::reportSslErrors : \" << err;\n+        qWarning() << \"PaymentServer::reportSslErrors: \" << err;\n         errString += err.errorString() + \"\\n\";\n     }\n     emit message(tr(\"Network request error\"), errString, CClientUIInterface::MSG_ERROR);"
      },
      {
        "sha": "df1afbfaaae31266db335a94423581896697a65c",
        "filename": "src/qt/transactiontablemodel.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/qt/transactiontablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/qt/transactiontablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiontablemodel.cpp?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -94,7 +94,7 @@ class TransactionTablePriv\n      */\n     void updateWallet(const uint256 &hash, int status, bool showTransaction)\n     {\n-        qDebug() << \"TransactionTablePriv::updateWallet : \" + QString::fromStdString(hash.ToString()) + \" \" + QString::number(status);\n+        qDebug() << \"TransactionTablePriv::updateWallet: \" + QString::fromStdString(hash.ToString()) + \" \" + QString::number(status);\n \n         // Find bounds of this transaction in model\n         QList<TransactionRecord>::iterator lower = qLowerBound(\n@@ -122,7 +122,7 @@ class TransactionTablePriv\n         case CT_NEW:\n             if(inModel)\n             {\n-                qWarning() << \"TransactionTablePriv::updateWallet : Warning: Got CT_NEW, but transaction is already in model\";\n+                qWarning() << \"TransactionTablePriv::updateWallet: Warning: Got CT_NEW, but transaction is already in model\";\n                 break;\n             }\n             if(showTransaction)\n@@ -132,7 +132,7 @@ class TransactionTablePriv\n                 std::map<uint256, CWalletTx>::iterator mi = wallet->mapWallet.find(hash);\n                 if(mi == wallet->mapWallet.end())\n                 {\n-                    qWarning() << \"TransactionTablePriv::updateWallet : Warning: Got CT_NEW, but transaction is not in wallet\";\n+                    qWarning() << \"TransactionTablePriv::updateWallet: Warning: Got CT_NEW, but transaction is not in wallet\";\n                     break;\n                 }\n                 // Added -- insert at the right position\n@@ -154,7 +154,7 @@ class TransactionTablePriv\n         case CT_DELETED:\n             if(!inModel)\n             {\n-                qWarning() << \"TransactionTablePriv::updateWallet : Warning: Got CT_DELETED, but transaction is not in model\";\n+                qWarning() << \"TransactionTablePriv::updateWallet: Warning: Got CT_DELETED, but transaction is not in model\";\n                 break;\n             }\n             // Removed -- remove entire transaction from table\n@@ -664,7 +664,7 @@ struct TransactionNotification\n     void invoke(QObject *ttm)\n     {\n         QString strHash = QString::fromStdString(hash.GetHex());\n-        qDebug() << \"NotifyTransactionChanged : \" + strHash + \" status= \" + QString::number(status);\n+        qDebug() << \"NotifyTransactionChanged: \" + strHash + \" status= \" + QString::number(status);\n         QMetaObject::invokeMethod(ttm, \"updateTransaction\", Qt::QueuedConnection,\n                                   Q_ARG(QString, strHash),\n                                   Q_ARG(int, status),"
      },
      {
        "sha": "c5523b137e8e92143269e03f6fccaca7c327078b",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -446,7 +446,7 @@ static void NotifyAddressBookChanged(WalletModel *walletmodel, CWallet *wallet,\n     QString strLabel = QString::fromStdString(label);\n     QString strPurpose = QString::fromStdString(purpose);\n \n-    qDebug() << \"NotifyAddressBookChanged : \" + strAddress + \" \" + strLabel + \" isMine=\" + QString::number(isMine) + \" purpose=\" + strPurpose + \" status=\" + QString::number(status);\n+    qDebug() << \"NotifyAddressBookChanged: \" + strAddress + \" \" + strLabel + \" isMine=\" + QString::number(isMine) + \" purpose=\" + strPurpose + \" status=\" + QString::number(status);\n     QMetaObject::invokeMethod(walletmodel, \"updateAddressBook\", Qt::QueuedConnection,\n                               Q_ARG(QString, strAddress),\n                               Q_ARG(QString, strLabel),"
      },
      {
        "sha": "44e5b9d51f2b162f979548db431907311739c899",
        "filename": "src/rpcwallet.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcwallet.cpp?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -321,7 +321,7 @@ void SendMoney(const CTxDestination &address, CAmount nValue, CWalletTx& wtxNew)\n     if (pwalletMain->IsLocked())\n     {\n         strError = \"Error: Wallet locked, unable to create transaction!\";\n-        LogPrintf(\"SendMoney() : %s\", strError);\n+        LogPrintf(\"SendMoney(): %s\", strError);\n         throw JSONRPCError(RPC_WALLET_ERROR, strError);\n     }\n \n@@ -335,7 +335,7 @@ void SendMoney(const CTxDestination &address, CAmount nValue, CWalletTx& wtxNew)\n     {\n         if (nValue + nFeeRequired > pwalletMain->GetBalance())\n             strError = strprintf(\"Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds!\", FormatMoney(nFeeRequired));\n-        LogPrintf(\"SendMoney() : %s\\n\", strError);\n+        LogPrintf(\"SendMoney(): %s\\n\", strError);\n         throw JSONRPCError(RPC_WALLET_ERROR, strError);\n     }\n     if (!pwalletMain->CommitTransaction(wtxNew, reservekey))"
      },
      {
        "sha": "e117fd9f957c34d899365daf739df8571d2454f3",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -60,7 +60,7 @@ bool CastToBool(const valtype& vch)\n static inline void popstack(vector<valtype>& stack)\n {\n     if (stack.empty())\n-        throw runtime_error(\"popstack() : stack empty\");\n+        throw runtime_error(\"popstack(): stack empty\");\n     stack.pop_back();\n }\n "
      },
      {
        "sha": "8b36aa2f5061fcbb204d73737bbf1c734aacb9ec",
        "filename": "src/script/script.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -391,7 +391,7 @@ class CScript : public std::vector<unsigned char>\n     CScript& operator<<(opcodetype opcode)\n     {\n         if (opcode < 0 || opcode > 0xff)\n-            throw std::runtime_error(\"CScript::operator<<() : invalid opcode\");\n+            throw std::runtime_error(\"CScript::operator<<(): invalid opcode\");\n         insert(end(), (unsigned char)opcode);\n         return *this;\n     }"
      },
      {
        "sha": "a62760a7938dec3f0111cc5f600345e8c48b14c0",
        "filename": "src/serialize.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/serialize.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/serialize.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/serialize.h?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -249,7 +249,7 @@ uint64_t ReadCompactSize(Stream& is)\n             throw std::ios_base::failure(\"non-canonical ReadCompactSize()\");\n     }\n     if (nSizeRet > (uint64_t)MAX_SIZE)\n-        throw std::ios_base::failure(\"ReadCompactSize() : size too large\");\n+        throw std::ios_base::failure(\"ReadCompactSize(): size too large\");\n     return nSizeRet;\n }\n "
      },
      {
        "sha": "bd8568b1af35093c4db4b85b2ddcfff2431a019c",
        "filename": "src/streams.h",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/streams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/streams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/streams.h?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -224,7 +224,7 @@ class CDataStream\n         {\n             if (nReadPosNext > vch.size())\n             {\n-                throw std::ios_base::failure(\"CDataStream::read() : end of data\");\n+                throw std::ios_base::failure(\"CDataStream::read(): end of data\");\n             }\n             memcpy(pch, &vch[nReadPos], nSize);\n             nReadPos = 0;\n@@ -244,7 +244,7 @@ class CDataStream\n         if (nReadPosNext >= vch.size())\n         {\n             if (nReadPosNext > vch.size())\n-                throw std::ios_base::failure(\"CDataStream::ignore() : end of data\");\n+                throw std::ios_base::failure(\"CDataStream::ignore(): end of data\");\n             nReadPos = 0;\n             vch.clear();\n             return (*this);\n@@ -374,18 +374,18 @@ class CAutoFile\n     CAutoFile& read(char* pch, size_t nSize)\n     {\n         if (!file)\n-            throw std::ios_base::failure(\"CAutoFile::read : file handle is NULL\");\n+            throw std::ios_base::failure(\"CAutoFile::read: file handle is NULL\");\n         if (fread(pch, 1, nSize, file) != nSize)\n-            throw std::ios_base::failure(feof(file) ? \"CAutoFile::read : end of file\" : \"CAutoFile::read : fread failed\");\n+            throw std::ios_base::failure(feof(file) ? \"CAutoFile::read: end of file\" : \"CAutoFile::read: fread failed\");\n         return (*this);\n     }\n \n     CAutoFile& write(const char* pch, size_t nSize)\n     {\n         if (!file)\n-            throw std::ios_base::failure(\"CAutoFile::write : file handle is NULL\");\n+            throw std::ios_base::failure(\"CAutoFile::write: file handle is NULL\");\n         if (fwrite(pch, 1, nSize, file) != nSize)\n-            throw std::ios_base::failure(\"CAutoFile::write : write failed\");\n+            throw std::ios_base::failure(\"CAutoFile::write: write failed\");\n         return (*this);\n     }\n \n@@ -401,7 +401,7 @@ class CAutoFile\n     {\n         // Serialize to this stream\n         if (!file)\n-            throw std::ios_base::failure(\"CAutoFile::operator<< : file handle is NULL\");\n+            throw std::ios_base::failure(\"CAutoFile::operator<<: file handle is NULL\");\n         ::Serialize(*this, obj, nType, nVersion);\n         return (*this);\n     }\n@@ -411,7 +411,7 @@ class CAutoFile\n     {\n         // Unserialize from this stream\n         if (!file)\n-            throw std::ios_base::failure(\"CAutoFile::operator>> : file handle is NULL\");\n+            throw std::ios_base::failure(\"CAutoFile::operator>>: file handle is NULL\");\n         ::Unserialize(*this, obj, nType, nVersion);\n         return (*this);\n     }\n@@ -452,7 +452,7 @@ class CBufferedFile\n             return false;\n         size_t read = fread((void*)&vchBuf[pos], 1, readNow, src);\n         if (read == 0) {\n-            throw std::ios_base::failure(feof(src) ? \"CBufferedFile::Fill : end of file\" : \"CBufferedFile::Fill : fread failed\");\n+            throw std::ios_base::failure(feof(src) ? \"CBufferedFile::Fill: end of file\" : \"CBufferedFile::Fill: fread failed\");\n         } else {\n             nSrcPos += read;\n             return true;"
      },
      {
        "sha": "e7aeee9db606c870315542a50dca96b9eb7e2ff7",
        "filename": "src/test/bignum.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/test/bignum.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/test/bignum.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bignum.h?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -37,14 +37,14 @@ class CBigNum : public BIGNUM\n         if (!BN_copy(this, &b))\n         {\n             BN_clear_free(this);\n-            throw bignum_error(\"CBigNum::CBigNum(const CBigNum&) : BN_copy failed\");\n+            throw bignum_error(\"CBigNum::CBigNum(const CBigNum&): BN_copy failed\");\n         }\n     }\n \n     CBigNum& operator=(const CBigNum& b)\n     {\n         if (!BN_copy(this, &b))\n-            throw bignum_error(\"CBigNum::operator= : BN_copy failed\");\n+            throw bignum_error(\"CBigNum::operator=: BN_copy failed\");\n         return (*this);\n     }\n \n@@ -151,15 +151,15 @@ inline const CBigNum operator+(const CBigNum& a, const CBigNum& b)\n {\n     CBigNum r;\n     if (!BN_add(&r, &a, &b))\n-        throw bignum_error(\"CBigNum::operator+ : BN_add failed\");\n+        throw bignum_error(\"CBigNum::operator+: BN_add failed\");\n     return r;\n }\n \n inline const CBigNum operator-(const CBigNum& a, const CBigNum& b)\n {\n     CBigNum r;\n     if (!BN_sub(&r, &a, &b))\n-        throw bignum_error(\"CBigNum::operator- : BN_sub failed\");\n+        throw bignum_error(\"CBigNum::operator-: BN_sub failed\");\n     return r;\n }\n "
      },
      {
        "sha": "ea41dbcde23435912f8b6ac0a7e09a3df8717d05",
        "filename": "src/test/sighash_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/test/sighash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/test/sighash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sighash_tests.cpp?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -27,7 +27,7 @@ uint256 static SignatureHashOld(CScript scriptCode, const CTransaction& txTo, un\n     static const uint256 one(uint256S(\"0000000000000000000000000000000000000000000000000000000000000001\"));\n     if (nIn >= txTo.vin.size())\n     {\n-        printf(\"ERROR: SignatureHash() : nIn=%d out of range\\n\", nIn);\n+        printf(\"ERROR: SignatureHash(): nIn=%d out of range\\n\", nIn);\n         return one;\n     }\n     CMutableTransaction txTmp(txTo);\n@@ -58,7 +58,7 @@ uint256 static SignatureHashOld(CScript scriptCode, const CTransaction& txTo, un\n         unsigned int nOut = nIn;\n         if (nOut >= txTmp.vout.size())\n         {\n-            printf(\"ERROR: SignatureHash() : nOut=%d out of range\\n\", nOut);\n+            printf(\"ERROR: SignatureHash(): nOut=%d out of range\\n\", nOut);\n             return one;\n         }\n         txTmp.vout.resize(nOut+1);"
      },
      {
        "sha": "b28d469de8e2787d73ba5e375625571f89889bae",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -130,7 +130,7 @@ bool CCoinsViewDB::GetStats(CCoinsStats &stats) const {\n             }\n             pcursor->Next();\n         } catch (const std::exception& e) {\n-            return error(\"%s : Deserialize or I/O error - %s\", __func__, e.what());\n+            return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n         }\n     }\n     stats.nHeight = mapBlockIndex.find(GetBestBlock())->second->nHeight;\n@@ -212,14 +212,14 @@ bool CBlockTreeDB::LoadBlockIndexGuts()\n                 pindexNew->nTx            = diskindex.nTx;\n \n                 if (!CheckProofOfWork(pindexNew->GetBlockHash(), pindexNew->nBits))\n-                    return error(\"LoadBlockIndex() : CheckProofOfWork failed: %s\", pindexNew->ToString());\n+                    return error(\"LoadBlockIndex(): CheckProofOfWork failed: %s\", pindexNew->ToString());\n \n                 pcursor->Next();\n             } else {\n                 break; // if shutdown requested or finished loading block index\n             }\n         } catch (const std::exception& e) {\n-            return error(\"%s : Deserialize or I/O error - %s\", __func__, e.what());\n+            return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n         }\n     }\n "
      },
      {
        "sha": "6e0f7e9c5a6bd5a2afedba96c1dd7e1b2d1c3305",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -192,7 +192,7 @@ class CMinerPolicyEstimator\n             // Neither or both fee and priority sufficient to get confirmed:\n             // don't know why they got confirmed.\n         }\n-        LogPrint(\"estimatefee\", \"Seen TX confirm: %s : %s fee/%g priority, took %d blocks\\n\",\n+        LogPrint(\"estimatefee\", \"Seen TX confirm: %s: %s fee/%g priority, took %d blocks\\n\",\n                  assignedTo, feeRate.ToString(), dPriority, nBlocksAgo);\n     }\n \n@@ -658,7 +658,7 @@ CTxMemPool::WriteFeeEstimates(CAutoFile& fileout) const\n         minerPolicyEstimator->Write(fileout);\n     }\n     catch (const std::exception&) {\n-        LogPrintf(\"CTxMemPool::WriteFeeEstimates() : unable to write policy estimator data (non-fatal)\");\n+        LogPrintf(\"CTxMemPool::WriteFeeEstimates(): unable to write policy estimator data (non-fatal)\");\n         return false;\n     }\n     return true;\n@@ -671,13 +671,13 @@ CTxMemPool::ReadFeeEstimates(CAutoFile& filein)\n         int nVersionRequired, nVersionThatWrote;\n         filein >> nVersionRequired >> nVersionThatWrote;\n         if (nVersionRequired > CLIENT_VERSION)\n-            return error(\"CTxMemPool::ReadFeeEstimates() : up-version (%d) fee estimate file\", nVersionRequired);\n+            return error(\"CTxMemPool::ReadFeeEstimates(): up-version (%d) fee estimate file\", nVersionRequired);\n \n         LOCK(cs);\n         minerPolicyEstimator->Read(filein, minRelayFee);\n     }\n     catch (const std::exception&) {\n-        LogPrintf(\"CTxMemPool::ReadFeeEstimates() : unable to read policy estimator data (non-fatal)\");\n+        LogPrintf(\"CTxMemPool::ReadFeeEstimates(): unable to read policy estimator data (non-fatal)\");\n         return false;\n     }\n     return true;"
      },
      {
        "sha": "77d0209c0b1531b75f879b8fe5262fc3cc3b3a9a",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -88,7 +88,7 @@ CPubKey CWallet::GenerateNewKey()\n         nTimeFirstKey = nCreationTime;\n \n     if (!AddKeyPubKey(secret, pubkey))\n-        throw std::runtime_error(\"CWallet::GenerateNewKey() : AddKey failed\");\n+        throw std::runtime_error(\"CWallet::GenerateNewKey(): AddKey failed\");\n     return pubkey;\n }\n \n@@ -619,7 +619,7 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn, bool fFromLoadWallet)\n                     wtx.nTimeSmart = std::max(latestEntry, std::min(blocktime, latestNow));\n                 }\n                 else\n-                    LogPrintf(\"AddToWallet() : found %s in block %s not in index\\n\",\n+                    LogPrintf(\"AddToWallet(): found %s in block %s not in index\\n\",\n                              wtxIn.GetHash().ToString(),\n                              wtxIn.hashBlock.ToString());\n             }\n@@ -1610,7 +1610,7 @@ bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n         if (!wtxNew.AcceptToMemoryPool(false))\n         {\n             // This must not fail. The transaction has already been signed and recorded.\n-            LogPrintf(\"CommitTransaction() : Error: Transaction not valid\");\n+            LogPrintf(\"CommitTransaction(): Error: Transaction not valid\");\n             return false;\n         }\n         wtxNew.RelayWalletTransaction();\n@@ -1803,7 +1803,7 @@ bool CWallet::TopUpKeyPool(unsigned int kpSize)\n             if (!setKeyPool.empty())\n                 nEnd = *(--setKeyPool.end()) + 1;\n             if (!walletdb.WritePool(nEnd, CKeyPool(GenerateNewKey())))\n-                throw runtime_error(\"TopUpKeyPool() : writing generated key failed\");\n+                throw runtime_error(\"TopUpKeyPool(): writing generated key failed\");\n             setKeyPool.insert(nEnd);\n             LogPrintf(\"keypool added key %d, size=%u\\n\", nEnd, setKeyPool.size());\n         }\n@@ -1830,9 +1830,9 @@ void CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool)\n         nIndex = *(setKeyPool.begin());\n         setKeyPool.erase(setKeyPool.begin());\n         if (!walletdb.ReadPool(nIndex, keypool))\n-            throw runtime_error(\"ReserveKeyFromKeyPool() : read failed\");\n+            throw runtime_error(\"ReserveKeyFromKeyPool(): read failed\");\n         if (!HaveKey(keypool.vchPubKey.GetID()))\n-            throw runtime_error(\"ReserveKeyFromKeyPool() : unknown key in key pool\");\n+            throw runtime_error(\"ReserveKeyFromKeyPool(): unknown key in key pool\");\n         assert(keypool.vchPubKey.IsValid());\n         LogPrintf(\"keypool reserve %d\\n\", nIndex);\n     }\n@@ -2080,11 +2080,11 @@ void CWallet::GetAllReserveKeys(set<CKeyID>& setAddress) const\n     {\n         CKeyPool keypool;\n         if (!walletdb.ReadPool(id, keypool))\n-            throw runtime_error(\"GetAllReserveKeyHashes() : read failed\");\n+            throw runtime_error(\"GetAllReserveKeyHashes(): read failed\");\n         assert(keypool.vchPubKey.IsValid());\n         CKeyID keyID = keypool.vchPubKey.GetID();\n         if (!HaveKey(keyID))\n-            throw runtime_error(\"GetAllReserveKeyHashes() : unknown key in key pool\");\n+            throw runtime_error(\"GetAllReserveKeyHashes(): unknown key in key pool\");\n         setAddress.insert(keyID);\n     }\n }\n@@ -2297,7 +2297,7 @@ int CMerkleTx::SetMerkleBranch(const CBlock& block)\n     {\n         vMerkleBranch.clear();\n         nIndex = -1;\n-        LogPrintf(\"ERROR: SetMerkleBranch() : couldn't find tx in block\\n\");\n+        LogPrintf(\"ERROR: SetMerkleBranch(): couldn't find tx in block\\n\");\n         return 0;\n     }\n "
      },
      {
        "sha": "609e37980d7694118311e09a2857c1445fe0b085",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -320,14 +320,14 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     CAmount GetCredit(const CTxOut& txout, const isminefilter& filter) const\n     {\n         if (!MoneyRange(txout.nValue))\n-            throw std::runtime_error(\"CWallet::GetCredit() : value out of range\");\n+            throw std::runtime_error(\"CWallet::GetCredit(): value out of range\");\n         return ((IsMine(txout) & filter) ? txout.nValue : 0);\n     }\n     bool IsChange(const CTxOut& txout) const;\n     CAmount GetChange(const CTxOut& txout) const\n     {\n         if (!MoneyRange(txout.nValue))\n-            throw std::runtime_error(\"CWallet::GetChange() : value out of range\");\n+            throw std::runtime_error(\"CWallet::GetChange(): value out of range\");\n         return (IsChange(txout) ? txout.nValue : 0);\n     }\n     bool IsMine(const CTransaction& tx) const\n@@ -349,7 +349,7 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n         {\n             nDebit += GetDebit(txin, filter);\n             if (!MoneyRange(nDebit))\n-                throw std::runtime_error(\"CWallet::GetDebit() : value out of range\");\n+                throw std::runtime_error(\"CWallet::GetDebit(): value out of range\");\n         }\n         return nDebit;\n     }\n@@ -360,7 +360,7 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n         {\n             nCredit += GetCredit(txout, filter);\n             if (!MoneyRange(nCredit))\n-                throw std::runtime_error(\"CWallet::GetCredit() : value out of range\");\n+                throw std::runtime_error(\"CWallet::GetCredit(): value out of range\");\n         }\n         return nCredit;\n     }\n@@ -371,7 +371,7 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n         {\n             nChange += GetChange(txout);\n             if (!MoneyRange(nChange))\n-                throw std::runtime_error(\"CWallet::GetChange() : value out of range\");\n+                throw std::runtime_error(\"CWallet::GetChange(): value out of range\");\n         }\n         return nChange;\n     }\n@@ -804,7 +804,7 @@ class CWalletTx : public CMerkleTx\n                 const CTxOut &txout = vout[i];\n                 nCredit += pwallet->GetCredit(txout, ISMINE_SPENDABLE);\n                 if (!MoneyRange(nCredit))\n-                    throw std::runtime_error(\"CWalletTx::GetAvailableCredit() : value out of range\");\n+                    throw std::runtime_error(\"CWalletTx::GetAvailableCredit(): value out of range\");\n             }\n         }\n \n@@ -847,7 +847,7 @@ class CWalletTx : public CMerkleTx\n                 const CTxOut &txout = vout[i];\n                 nCredit += pwallet->GetCredit(txout, ISMINE_WATCH_ONLY);\n                 if (!MoneyRange(nCredit))\n-                    throw std::runtime_error(\"CWalletTx::GetAvailableCredit() : value out of range\");\n+                    throw std::runtime_error(\"CWalletTx::GetAvailableCredit(): value out of range\");\n             }\n         }\n "
      },
      {
        "sha": "87a03a02d02d53f170cefa8d7bb0c5113591e3a1",
        "filename": "src/walletdb.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f1455eb98fa944d4025c0081f41c56cf590b742/src/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f1455eb98fa944d4025c0081f41c56cf590b742/src/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletdb.cpp?ref=7f1455eb98fa944d4025c0081f41c56cf590b742",
        "patch": "@@ -210,7 +210,7 @@ void CWalletDB::ListAccountCreditDebit(const string& strAccount, list<CAccountin\n \n     Dbc* pcursor = GetCursor();\n     if (!pcursor)\n-        throw runtime_error(\"CWalletDB::ListAccountCreditDebit() : cannot create DB cursor\");\n+        throw runtime_error(\"CWalletDB::ListAccountCreditDebit(): cannot create DB cursor\");\n     unsigned int fFlags = DB_SET_RANGE;\n     while (true)\n     {\n@@ -226,7 +226,7 @@ void CWalletDB::ListAccountCreditDebit(const string& strAccount, list<CAccountin\n         else if (ret != 0)\n         {\n             pcursor->close();\n-            throw runtime_error(\"CWalletDB::ListAccountCreditDebit() : error scanning DB\");\n+            throw runtime_error(\"CWalletDB::ListAccountCreditDebit(): error scanning DB\");\n         }\n \n         // Unserialize"
      }
    ]
  }
]