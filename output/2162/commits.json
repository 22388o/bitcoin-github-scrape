[
  {
    "sha": "dba91a9a6783057d7f308eeabb0ef4a6772c9562",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkYmE5MWE5YTY3ODMwNTdkN2YzMDhlZWFiYjBlZjRhNjc3MmM5NTYy",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2013-01-05T01:05:56Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2013-01-25T01:04:18Z"
      },
      "message": "spendfrom.py sends coins from a particular address or addresses\n\nShould be both useful and also a pretty good demonstration of\nusing the raw transactions API.",
      "tree": {
        "sha": "e3a8401593fa1d845f48f33fa53e0f7943b89a39",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e3a8401593fa1d845f48f33fa53e0f7943b89a39"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dba91a9a6783057d7f308eeabb0ef4a6772c9562",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dba91a9a6783057d7f308eeabb0ef4a6772c9562",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dba91a9a6783057d7f308eeabb0ef4a6772c9562",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dba91a9a6783057d7f308eeabb0ef4a6772c9562/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ea9788517bfa3e53e192c5af9e64e73625f9db74",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ea9788517bfa3e53e192c5af9e64e73625f9db74",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ea9788517bfa3e53e192c5af9e64e73625f9db74"
      }
    ],
    "stats": {
      "total": 308,
      "additions": 308,
      "deletions": 0
    },
    "files": [
      {
        "sha": "8a087a0c1e597d90bc135d43805307781fe8fcce",
        "filename": "contrib/spendfrom/README",
        "status": "added",
        "additions": 32,
        "deletions": 0,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dba91a9a6783057d7f308eeabb0ef4a6772c9562/contrib/spendfrom/README",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dba91a9a6783057d7f308eeabb0ef4a6772c9562/contrib/spendfrom/README",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/spendfrom/README?ref=dba91a9a6783057d7f308eeabb0ef4a6772c9562",
        "patch": "@@ -0,0 +1,32 @@\n+Use the raw transactions API to send coins received on a particular\n+address (or addresses).\n+\n+Depends on jsonrpc\n+\n+Usage:\n+\n+spendfrom.py --from=FROMADDRESS1[,FROMADDRESS2] --to=TOADDRESS --amount=amount \\\n+             --fee=fee --datadir=/path/to/.bitcoin --testnet --dry_run\n+\n+With no arguments, outputs a list of amounts associated with addresses.\n+\n+With arguments, sends coins received by the FROMADDRESS addresses to the TOADDRESS.\n+\n+You may explictly specify how much fee to pay (a fee more than 1% of the amount\n+will fail,  though, to prevent bitcoin-losing accidents). Spendfrom may fail if\n+it thinks the transaction would never be confirmed (if the amount being sent is\n+too small, or if the transaction is too many bytes for the fee).\n+\n+If a change output needs to be created, the change will be sent to the last\n+FROMADDRESS (if you specify just one FROMADDRESS, change will go back to it).\n+\n+If --datadir is not specified, the default datadir is used.\n+\n+The --dry_run option will just create and sign the the transaction and print\n+the transaction data (as hexadecimal), instead of broadcasting it.\n+\n+If the transaction is created and broadcast successfully, a transaction id\n+is printed.\n+\n+If this was a tool for end-users and not programmers, it would have much friendlier\n+error-handling."
      },
      {
        "sha": "01b9768a5b06a459808af61efca624239b301f1d",
        "filename": "contrib/spendfrom/setup.py",
        "status": "added",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dba91a9a6783057d7f308eeabb0ef4a6772c9562/contrib/spendfrom/setup.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dba91a9a6783057d7f308eeabb0ef4a6772c9562/contrib/spendfrom/setup.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/spendfrom/setup.py?ref=dba91a9a6783057d7f308eeabb0ef4a6772c9562",
        "patch": "@@ -0,0 +1,9 @@\n+from distutils.core import setup\n+setup(name='btcspendfrom',\n+      version='1.0',\n+      description='Command-line utility for bitcoin \"coin control\"',\n+      author='Gavin Andresen',\n+      author_email='gavin@bitcoinfoundation.org',\n+      requires=['jsonrpc'],\n+      scripts=['spendfrom.py'],\n+      )"
      },
      {
        "sha": "72ee0425eb2363ab39f85ba9d239891aa0279dcd",
        "filename": "contrib/spendfrom/spendfrom.py",
        "status": "added",
        "additions": 267,
        "deletions": 0,
        "changes": 267,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dba91a9a6783057d7f308eeabb0ef4a6772c9562/contrib/spendfrom/spendfrom.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dba91a9a6783057d7f308eeabb0ef4a6772c9562/contrib/spendfrom/spendfrom.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/spendfrom/spendfrom.py?ref=dba91a9a6783057d7f308eeabb0ef4a6772c9562",
        "patch": "@@ -0,0 +1,267 @@\n+#!/usr/bin/env python\n+#\n+# Use the raw transactions API to spend bitcoins received on particular addresses,\n+# and send any change back to that same address.\n+#\n+# Example usage:\n+#  spendfrom.py  # Lists available funds\n+#  spendfrom.py --from=ADDRESS --to=ADDRESS --amount=11.00\n+#\n+# Assumes it will talk to a bitcoind or Bitcoin-Qt running\n+# on localhost.\n+#\n+# Depends on jsonrpc\n+#\n+\n+from decimal import *\n+import getpass\n+import math\n+import os\n+import os.path\n+import platform\n+import sys\n+import time\n+from jsonrpc import ServiceProxy, json\n+\n+BASE_FEE=Decimal(\"0.001\")\n+\n+def check_json_precision():\n+    \"\"\"Make sure json library being used does not lose precision converting BTC values\"\"\"\n+    n = Decimal(\"20000000.00000003\")\n+    satoshis = int(json.loads(json.dumps(float(n)))*1.0e8)\n+    if satoshis != 2000000000000003:\n+        raise RuntimeError(\"JSON encode/decode loses precision\")\n+\n+def determine_db_dir():\n+    \"\"\"Return the default location of the bitcoin data directory\"\"\"\n+    if platform.system() == \"Darwin\":\n+        return os.path.expanduser(\"~/Library/Application Support/Bitcoin/\")\n+    elif platform.system() == \"Windows\":\n+        return os.path.join(os.environ['APPDATA'], \"Bitcoin\")\n+    return os.path.expanduser(\"~/.bitcoin\")\n+\n+def read_bitcoin_config(dbdir):\n+    \"\"\"Read the bitcoin.conf file from dbdir, returns dictionary of settings\"\"\"\n+    from ConfigParser import SafeConfigParser\n+\n+    class FakeSecHead(object):\n+        def __init__(self, fp):\n+            self.fp = fp\n+            self.sechead = '[all]\\n'\n+        def readline(self):\n+            if self.sechead:\n+                try: return self.sechead\n+                finally: self.sechead = None\n+            else:\n+                s = self.fp.readline()\n+                if s.find('#') != -1:\n+                    s = s[0:s.find('#')].strip() +\"\\n\"\n+                return s\n+\n+    config_parser = SafeConfigParser()\n+    config_parser.readfp(FakeSecHead(open(os.path.join(dbdir, \"bitcoin.conf\"))))\n+    return dict(config_parser.items(\"all\"))\n+\n+def connect_JSON(config):\n+    \"\"\"Connect to a bitcoin JSON-RPC server\"\"\"\n+    testnet = config.get('testnet', '0')\n+    testnet = (int(testnet) > 0)  # 0/1 in config file, convert to True/False\n+    if not 'rpcport' in config:\n+        config['rpcport'] = 18332 if testnet else 8332\n+    connect = \"http://%s:%s@127.0.0.1:%s\"%(config['rpcuser'], config['rpcpassword'], config['rpcport'])\n+    try:\n+        result = ServiceProxy(connect)\n+        # ServiceProxy is lazy-connect, so send an RPC command mostly to catch connection errors,\n+        # but also make sure the bitcoind we're talking to is/isn't testnet:\n+        if result.getmininginfo()['testnet'] != testnet:\n+            sys.stderr.write(\"RPC server at \"+connect+\" testnet setting mismatch\\n\")\n+            sys.exit(1)\n+        return result\n+    except:\n+        sys.stderr.write(\"Error connecting to RPC server at \"+connect+\"\\n\")\n+        sys.exit(1)\n+\n+def unlock_wallet(bitcoind):\n+    info = bitcoind.getinfo()\n+    if 'unlocked_until' not in info:\n+        return True # wallet is not encrypted\n+    t = int(info['unlocked_until'])\n+    if t <= time.time():\n+        try:\n+            passphrase = getpass.getpass(\"Wallet is locked; enter passphrase: \")\n+            bitcoind.walletpassphrase(passphrase, 5)\n+        except:\n+            sys.stderr.write(\"Wrong passphrase\\n\")\n+\n+    info = bitcoind.getinfo()\n+    return int(info['unlocked_until']) > time.time()\n+\n+def list_available(bitcoind):\n+    address_summary = dict()\n+\n+    address_to_account = dict()\n+    for info in bitcoind.listreceivedbyaddress(0):\n+        address_to_account[info[\"address\"]] = info[\"account\"]\n+\n+    unspent = bitcoind.listunspent(0)\n+    for output in unspent:\n+        # listunspent doesn't give addresses, so:\n+        rawtx = bitcoind.getrawtransaction(output['txid'], 1)\n+        vout = rawtx[\"vout\"][output['vout']]\n+        pk = vout[\"scriptPubKey\"]\n+\n+        # This code only deals with ordinary pay-to-bitcoin-address\n+        # or pay-to-script-hash outputs right now; anything exotic is ignored.\n+        if pk[\"type\"] != \"pubkeyhash\" and pk[\"type\"] != \"scripthash\":\n+            continue\n+        \n+        address = pk[\"addresses\"][0]\n+        if address in address_summary:\n+            address_summary[address][\"total\"] += vout[\"value\"]\n+            address_summary[address][\"outputs\"].append(output)\n+        else:\n+            address_summary[address] = {\n+                \"total\" : vout[\"value\"],\n+                \"outputs\" : [output],\n+                \"account\" : address_to_account.get(address, \"\")\n+                }\n+\n+    return address_summary\n+\n+def select_coins(needed, inputs):\n+    # Feel free to improve this, this is good enough for my simple needs:\n+    outputs = []\n+    have = Decimal(\"0.0\")\n+    n = 0\n+    while have < needed and n < len(inputs):\n+        outputs.append({ \"txid\":inputs[n][\"txid\"], \"vout\":inputs[n][\"vout\"]})\n+        have += inputs[n][\"amount\"]\n+        n += 1\n+    return (outputs, have-needed)\n+\n+def create_tx(bitcoind, fromaddresses, toaddress, amount, fee):\n+    all_coins = list_available(bitcoind)\n+\n+    total_available = Decimal(\"0.0\")\n+    needed = amount+fee\n+    potential_inputs = []\n+    for addr in fromaddresses:\n+        if addr not in all_coins:\n+            continue\n+        potential_inputs.extend(all_coins[addr][\"outputs\"])\n+        total_available += all_coins[addr][\"total\"]\n+\n+    if total_available < needed:\n+        sys.stderr.write(\"Error, only %f BTC available, need %f\\n\"%(total_available, needed));\n+        sys.exit(1)\n+\n+    #\n+    # Note:\n+    # Python's json/jsonrpc modules have inconsistent support for Decimal numbers.\n+    # Instead of wrestling with getting json.dumps() (used by jsonrpc) to encode\n+    # Decimals, I'm casting amounts to float before sending them to bitcoind.\n+    #  \n+    outputs = { toaddress : float(amount) }\n+    (inputs, change_amount) = select_coins(needed, potential_inputs)\n+    if change_amount > BASE_FEE:  # don't bother with zero or tiny change\n+        change_address = fromaddresses[-1]\n+        if change_address in outputs:\n+            outputs[change_address] += float(change_amount)\n+        else:\n+            outputs[change_address] = float(change_amount)\n+\n+    rawtx = bitcoind.createrawtransaction(inputs, outputs)\n+    signed_rawtx = bitcoind.signrawtransaction(rawtx)\n+    if not signed_rawtx[\"complete\"]:\n+        sys.stderr.write(\"signrawtransaction failed\\n\")\n+        sys.exit(1)\n+    txdata = signed_rawtx[\"hex\"]\n+\n+    return txdata\n+\n+def compute_amount_in(bitcoind, txinfo):\n+    result = Decimal(\"0.0\")\n+    for vin in txinfo['vin']:\n+        in_info = bitcoind.getrawtransaction(vin['txid'], 1)\n+        vout = in_info['vout'][vin['vout']]\n+        result = result + vout['value']\n+    return result\n+\n+def compute_amount_out(txinfo):\n+    result = Decimal(\"0.0\")\n+    for vout in txinfo['vout']:\n+        result = result + vout['value']\n+    return result\n+\n+def sanity_test_fee(bitcoind, txdata_hex, max_fee):\n+    class FeeError(RuntimeError):\n+        pass\n+    try:\n+        txinfo = bitcoind.decoderawtransaction(txdata_hex)\n+        total_in = compute_amount_in(bitcoind, txinfo)\n+        total_out = compute_amount_out(txinfo)\n+        if total_in-total_out > max_fee:\n+            raise FeeError(\"Rejecting transaction, unreasonable fee of \"+str(total_in-total_out))\n+\n+        tx_size = len(txdata_hex)/2\n+        kb = tx_size/1000  # integer division rounds down\n+        if kb > 1 and fee < BASE_FEE:\n+            raise FeeError(\"Rejecting no-fee transaction, larger than 1000 bytes\")\n+        if total_in < 0.01 and fee < BASE_FEE:\n+            raise FeeError(\"Rejecting no-fee, tiny-amount transaction\")\n+        # Exercise for the reader: compute transaction priority, and\n+        # warn if this is a very-low-priority transaction\n+\n+    except FeeError as err:\n+        sys.stderr.write((str(err)+\"\\n\"))\n+        sys.exit(1)\n+\n+def main():\n+    import optparse\n+\n+    parser = optparse.OptionParser(usage=\"%prog [options]\")\n+    parser.add_option(\"--from\", dest=\"fromaddresses\", default=None,\n+                      help=\"addresses to get bitcoins from\")\n+    parser.add_option(\"--to\", dest=\"to\", default=None,\n+                      help=\"address to get send bitcoins to\")\n+    parser.add_option(\"--amount\", dest=\"amount\", default=None,\n+                      help=\"amount to send\")\n+    parser.add_option(\"--fee\", dest=\"fee\", default=\"0.0\",\n+                      help=\"fee to include\")\n+    parser.add_option(\"--datadir\", dest=\"datadir\", default=determine_db_dir(),\n+                      help=\"location of bitcoin.conf file with RPC username/password (default: %default)\")\n+    parser.add_option(\"--testnet\", dest=\"testnet\", default=False, action=\"store_true\",\n+                      help=\"Use the test network\")\n+    parser.add_option(\"--dry_run\", dest=\"dry_run\", default=False, action=\"store_true\",\n+                      help=\"Don't broadcast the transaction, just create and print the transaction data\")\n+\n+    (options, args) = parser.parse_args()\n+\n+    check_json_precision()\n+    config = read_bitcoin_config(options.datadir)\n+    if options.testnet: config['testnet'] = True\n+    bitcoind = connect_JSON(config)\n+\n+    if options.amount is None:\n+        address_summary = list_available(bitcoind)\n+        for address,info in address_summary.iteritems():\n+            n_transactions = len(info['outputs'])\n+            if n_transactions > 1:\n+                print(\"%s %.8f %s (%d transactions)\"%(address, info['total'], info['account'], n_transactions))\n+            else:\n+                print(\"%s %.8f %s\"%(address, info['total'], info['account']))\n+    else:\n+        fee = Decimal(options.fee)\n+        amount = Decimal(options.amount)\n+        while unlock_wallet(bitcoind) == False:\n+            pass # Keep asking for passphrase until they get it right\n+        txdata = create_tx(bitcoind, options.fromaddresses.split(\",\"), options.to, amount, fee)\n+        sanity_test_fee(bitcoind, txdata, amount*Decimal(\"0.01\"))\n+        if options.dry_run:\n+            print(txdata)\n+        else:\n+            txid = bitcoind.sendrawtransaction(txdata)\n+            print(txid)\n+\n+if __name__ == '__main__':\n+    main()"
      }
    ]
  }
]