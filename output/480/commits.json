[
  {
    "sha": "b0243da77c6ee8d8ca59b4423f333a179bff02cf",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMDI0M2RhNzdjNmVlOGQ4Y2E1OWI0NDIzZjMzM2ExNzliZmYwMmNm",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-08-29T21:03:08Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-08-31T16:53:57Z"
      },
      "message": "Highlight mis-matching locks",
      "tree": {
        "sha": "20b48c40f423ef2a25eb3e8e33c8270e491fca05",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/20b48c40f423ef2a25eb3e8e33c8270e491fca05"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b0243da77c6ee8d8ca59b4423f333a179bff02cf",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b0243da77c6ee8d8ca59b4423f333a179bff02cf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b0243da77c6ee8d8ca59b4423f333a179bff02cf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b0243da77c6ee8d8ca59b4423f333a179bff02cf/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "21189a42a735ff66166c17c53eb44998346059d6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/21189a42a735ff66166c17c53eb44998346059d6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/21189a42a735ff66166c17c53eb44998346059d6"
      }
    ],
    "stats": {
      "total": 8,
      "additions": 6,
      "deletions": 2
    },
    "files": [
      {
        "sha": "390b3a340bbd1474777e10a449a575f392cf33e2",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0243da77c6ee8d8ca59b4423f333a179bff02cf/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0243da77c6ee8d8ca59b4423f333a179bff02cf/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=b0243da77c6ee8d8ca59b4423f333a179bff02cf",
        "patch": "@@ -942,17 +942,21 @@ static std::map<std::pair<CCriticalSection*, CCriticalSection*>, LockStack> lock\n static boost::thread_specific_ptr<LockStack> lockstack;\n \n \n-static void potential_deadlock_detected(const LockStack& s1, const LockStack& s2)\n+static void potential_deadlock_detected(const std::pair<CCriticalSection*, CCriticalSection*>& mismatch, const LockStack& s1, const LockStack& s2)\n {\n     printf(\"POTENTIAL DEADLOCK DETECTED\\n\");\n     printf(\"Previous lock order was:\\n\");\n     BOOST_FOREACH(const PAIRTYPE(CCriticalSection*, CLockLocation)& i, s2)\n     {\n+        if (i.first == mismatch.first) printf(\" (1)\");\n+        if (i.first == mismatch.second) printf(\" (2)\");\n         printf(\" %s  %s:%d\\n\", i.second.mutexName.c_str(), i.second.sourceFile.c_str(), i.second.sourceLine);\n     }\n     printf(\"Current lock order is:\\n\");\n     BOOST_FOREACH(const PAIRTYPE(CCriticalSection*, CLockLocation)& i, s1)\n     {\n+        if (i.first == mismatch.first) printf(\" (1)\");\n+        if (i.first == mismatch.second) printf(\" (2)\");\n         printf(\" %s  %s:%d\\n\", i.second.mutexName.c_str(), i.second.sourceFile.c_str(), i.second.sourceLine);\n     }\n }\n@@ -979,7 +983,7 @@ static void push_lock(CCriticalSection* c, const CLockLocation& locklocation)\n         std::pair<CCriticalSection*, CCriticalSection*> p2 = std::make_pair(c, i.first);\n         if (lockorders.count(p2))\n         {\n-            potential_deadlock_detected(lockorders[p2], lockorders[p1]);\n+            potential_deadlock_detected(p1, lockorders[p2], lockorders[p1]);\n             break;\n         }\n     }"
      }
    ]
  },
  {
    "sha": "6cc4a62c0e696dcb9d90ba0504f688e4f644a10f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2Y2M0YTYyYzBlNjk2ZGNiOWQ5MGJhMDUwNGY2ODhlNGY2NDRhMTBm",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-08-26T18:37:23Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-08-31T16:55:16Z"
      },
      "message": "Fix rpc-hanging deadlocks\n\nCollapsed multiple wallet mutexes to a single cs_wallet, to avoid deadlocks with wallet methods that acquired locks in different order.\nAlso change master RPC call handler to acquire cs_main and cs_wallet locks before executing RPC calls; requiring each RPC call to acquire the right set of locks in the right order was too error-prone.",
      "tree": {
        "sha": "5b365769be7c8be7caf6c31c4bdb1b4798be9ef4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5b365769be7c8be7caf6c31c4bdb1b4798be9ef4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6cc4a62c0e696dcb9d90ba0504f688e4f644a10f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6cc4a62c0e696dcb9d90ba0504f688e4f644a10f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6cc4a62c0e696dcb9d90ba0504f688e4f644a10f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6cc4a62c0e696dcb9d90ba0504f688e4f644a10f/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b0243da77c6ee8d8ca59b4423f333a179bff02cf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b0243da77c6ee8d8ca59b4423f333a179bff02cf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b0243da77c6ee8d8ca59b4423f333a179bff02cf"
      }
    ],
    "stats": {
      "total": 1033,
      "additions": 472,
      "deletions": 561
    },
    "files": [
      {
        "sha": "a22b17e34c20fefb2aa1413934266ca501b48acb",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6cc4a62c0e696dcb9d90ba0504f688e4f644a10f/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6cc4a62c0e696dcb9d90ba0504f688e4f644a10f/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=6cc4a62c0e696dcb9d90ba0504f688e4f644a10f",
        "patch": "@@ -683,8 +683,7 @@ int CWalletDB::LoadWallet(CWallet* pwallet)\n #endif\n \n     //// todo: shouldn't we catch exceptions and try to recover and continue?\n-    CRITICAL_BLOCK(pwallet->cs_mapWallet)\n-    CRITICAL_BLOCK(pwallet->cs_KeyStore)\n+    CRITICAL_BLOCK(pwallet->cs_wallet)\n     {\n         // Get cursor\n         Dbc* pcursor = GetCursor();"
      },
      {
        "sha": "5bf919cb8002252923bdd5a89b6a2d8993a32f1f",
        "filename": "src/keystore.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6cc4a62c0e696dcb9d90ba0504f688e4f644a10f/src/keystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6cc4a62c0e696dcb9d90ba0504f688e4f644a10f/src/keystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.cpp?ref=6cc4a62c0e696dcb9d90ba0504f688e4f644a10f",
        "patch": "@@ -45,7 +45,7 @@ std::vector<unsigned char> CCryptoKeyStore::GenerateNewKey()\n \n bool CCryptoKeyStore::Unlock(const CKeyingMaterial& vMasterKeyIn)\n {\n-    CRITICAL_BLOCK(cs_vMasterKey)\n+    CRITICAL_BLOCK(cs_KeyStore)\n     {\n         if (!SetCrypted())\n             return false;\n@@ -72,7 +72,6 @@ bool CCryptoKeyStore::Unlock(const CKeyingMaterial& vMasterKeyIn)\n bool CCryptoKeyStore::AddKey(const CKey& key)\n {\n     CRITICAL_BLOCK(cs_KeyStore)\n-    CRITICAL_BLOCK(cs_vMasterKey)\n     {\n         if (!IsCrypted())\n             return CBasicKeyStore::AddKey(key);\n@@ -106,7 +105,7 @@ bool CCryptoKeyStore::AddCryptedKey(const std::vector<unsigned char> &vchPubKey,\n \n bool CCryptoKeyStore::GetKey(const CBitcoinAddress &address, CKey& keyOut) const\n {\n-    CRITICAL_BLOCK(cs_vMasterKey)\n+    CRITICAL_BLOCK(cs_KeyStore)\n     {\n         if (!IsCrypted())\n             return CBasicKeyStore::GetKey(address, keyOut);\n@@ -128,7 +127,7 @@ bool CCryptoKeyStore::GetKey(const CBitcoinAddress &address, CKey& keyOut) const\n \n bool CCryptoKeyStore::GetPubKey(const CBitcoinAddress &address, std::vector<unsigned char>& vchPubKeyOut) const\n {\n-    CRITICAL_BLOCK(cs_vMasterKey)\n+    CRITICAL_BLOCK(cs_KeyStore)\n     {\n         if (!IsCrypted())\n             return CKeyStore::GetPubKey(address, vchPubKeyOut);\n@@ -146,7 +145,6 @@ bool CCryptoKeyStore::GetPubKey(const CBitcoinAddress &address, std::vector<unsi\n bool CCryptoKeyStore::EncryptKeys(CKeyingMaterial& vMasterKeyIn)\n {\n     CRITICAL_BLOCK(cs_KeyStore)\n-    CRITICAL_BLOCK(cs_vMasterKey)\n     {\n         if (!mapCryptedKeys.empty() || IsCrypted())\n             return false;"
      },
      {
        "sha": "d1e4985d5d7f515334f3a57d1fa3f7ee2ee49d5f",
        "filename": "src/keystore.h",
        "status": "modified",
        "additions": 27,
        "deletions": 17,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6cc4a62c0e696dcb9d90ba0504f688e4f644a10f/src/keystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6cc4a62c0e696dcb9d90ba0504f688e4f644a10f/src/keystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.h?ref=6cc4a62c0e696dcb9d90ba0504f688e4f644a10f",
        "patch": "@@ -9,9 +9,10 @@\n \n class CKeyStore\n {\n-public:\n+protected:\n     mutable CCriticalSection cs_KeyStore;\n \n+public:\n     virtual bool AddKey(const CKey& key) =0;\n     virtual bool HaveKey(const CBitcoinAddress &address) const =0;\n     virtual bool GetKey(const CBitcoinAddress &address, CKey& keyOut) const =0;\n@@ -30,15 +31,21 @@ class CBasicKeyStore : public CKeyStore\n     bool AddKey(const CKey& key);\n     bool HaveKey(const CBitcoinAddress &address) const\n     {\n-        return (mapKeys.count(address) > 0);\n+        bool result;\n+        CRITICAL_BLOCK(cs_KeyStore)\n+            result = (mapKeys.count(address) > 0);\n+        return result;\n     }\n     bool GetKey(const CBitcoinAddress &address, CKey& keyOut) const\n     {\n-        KeyMap::const_iterator mi = mapKeys.find(address);\n-        if (mi != mapKeys.end())\n+        CRITICAL_BLOCK(cs_KeyStore)\n         {\n-            keyOut.SetSecret((*mi).second);\n-            return true;\n+            KeyMap::const_iterator mi = mapKeys.find(address);\n+            if (mi != mapKeys.end())\n+            {\n+                keyOut.SetSecret((*mi).second);\n+                return true;\n+            }\n         }\n         return false;\n     }\n@@ -74,8 +81,6 @@ class CCryptoKeyStore : public CBasicKeyStore\n     bool Unlock(const CKeyingMaterial& vMasterKeyIn);\n \n public:\n-    mutable CCriticalSection cs_vMasterKey; //No guarantees master key wont get locked before you can use it, so lock this first\n-\n     CCryptoKeyStore() : fUseCrypto(false)\n     {\n     }\n@@ -89,18 +94,20 @@ class CCryptoKeyStore : public CBasicKeyStore\n     {\n         if (!IsCrypted())\n             return false;\n-        return vMasterKey.empty();\n+        bool result;\n+        CRITICAL_BLOCK(cs_KeyStore)\n+            result = vMasterKey.empty();\n+        return result;\n     }\n \n     bool Lock()\n     {\n-        CRITICAL_BLOCK(cs_vMasterKey)\n-        {\n-            if (!SetCrypted())\n-                return false;\n+        if (!SetCrypted())\n+            return false;\n \n+        CRITICAL_BLOCK(cs_KeyStore)\n             vMasterKey.clear();\n-        }\n+\n         return true;\n     }\n \n@@ -109,9 +116,12 @@ class CCryptoKeyStore : public CBasicKeyStore\n     bool AddKey(const CKey& key);\n     bool HaveKey(const CBitcoinAddress &address) const\n     {\n-        if (!IsCrypted())\n-            return CBasicKeyStore::HaveKey(address);\n-        return mapCryptedKeys.count(address) > 0;\n+        CRITICAL_BLOCK(cs_KeyStore)\n+        {\n+            if (!IsCrypted())\n+                return CBasicKeyStore::HaveKey(address);\n+            return mapCryptedKeys.count(address) > 0;\n+        }\n     }\n     bool GetKey(const CBitcoinAddress &address, CKey& keyOut) const;\n     bool GetPubKey(const CBitcoinAddress &address, std::vector<unsigned char>& vchPubKeyOut) const;"
      },
      {
        "sha": "390632aaf5c5832b7b7da36f5339003b3bcefc10",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6cc4a62c0e696dcb9d90ba0504f688e4f644a10f/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6cc4a62c0e696dcb9d90ba0504f688e4f644a10f/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=6cc4a62c0e696dcb9d90ba0504f688e4f644a10f",
        "patch": "@@ -2879,7 +2879,7 @@ bool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey)\n         reservekey.KeepKey();\n \n         // Track how many getdata requests this block gets\n-        CRITICAL_BLOCK(wallet.cs_mapRequestCount)\n+        CRITICAL_BLOCK(wallet.cs_wallet)\n             wallet.mapRequestCount[pblock->GetHash()] = 0;\n \n         // Process this block the same as if we had received it from another node"
      },
      {
        "sha": "5eb5669acb7421dfb521664cf6d341498c3cddfa",
        "filename": "src/rpc.cpp",
        "status": "modified",
        "additions": 280,
        "deletions": 353,
        "changes": 633,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6cc4a62c0e696dcb9d90ba0504f688e4f644a10f/src/rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6cc4a62c0e696dcb9d90ba0504f688e4f644a10f/src/rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc.cpp?ref=6cc4a62c0e696dcb9d90ba0504f688e4f644a10f",
        "patch": "@@ -346,55 +346,50 @@ Value getnewaddress(const Array& params, bool fHelp)\n     CBitcoinAddress address(pwalletMain->GetOrReuseKeyFromPool());\n \n     // This could be done in the same main CS as GetKeyFromKeyPool.\n-    CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n-       pwalletMain->SetAddressBookName(address, strAccount);\n+    pwalletMain->SetAddressBookName(address, strAccount);\n \n     return address.ToString();\n }\n \n \n-// requires cs_main, cs_mapWallet, cs_mapAddressBook locks\n CBitcoinAddress GetAccountAddress(string strAccount, bool bForceNew=false)\n {\n     CWalletDB walletdb(pwalletMain->strWalletFile);\n \n     CAccount account;\n-    CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n-    {\n-        walletdb.ReadAccount(strAccount, account);\n+    walletdb.ReadAccount(strAccount, account);\n \n-        bool bKeyUsed = false;\n+    bool bKeyUsed = false;\n \n-        // Check if the current key has been used\n-        if (!account.vchPubKey.empty())\n+    // Check if the current key has been used\n+    if (!account.vchPubKey.empty())\n+    {\n+        CScript scriptPubKey;\n+        scriptPubKey.SetBitcoinAddress(account.vchPubKey);\n+        for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin();\n+             it != pwalletMain->mapWallet.end() && !account.vchPubKey.empty();\n+             ++it)\n         {\n-            CScript scriptPubKey;\n-            scriptPubKey.SetBitcoinAddress(account.vchPubKey);\n-            for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin();\n-                 it != pwalletMain->mapWallet.end() && !account.vchPubKey.empty();\n-                 ++it)\n-            {\n-                const CWalletTx& wtx = (*it).second;\n-                BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n-                    if (txout.scriptPubKey == scriptPubKey)\n-                        bKeyUsed = true;\n-            }\n+            const CWalletTx& wtx = (*it).second;\n+            BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n+                if (txout.scriptPubKey == scriptPubKey)\n+                    bKeyUsed = true;\n         }\n+    }\n \n-        // Generate a new key\n-        if (account.vchPubKey.empty() || bForceNew || bKeyUsed)\n+    // Generate a new key\n+    if (account.vchPubKey.empty() || bForceNew || bKeyUsed)\n+    {\n+        if (pwalletMain->GetKeyPoolSize() < 1)\n         {\n-            if (pwalletMain->GetKeyPoolSize() < 1)\n-            {\n-                if (bKeyUsed || bForceNew)\n-                    throw JSONRPCError(-12, \"Error: Keypool ran out, please call topupkeypool first\");\n-            }\n-            else\n-            {\n-                account.vchPubKey = pwalletMain->GetOrReuseKeyFromPool();\n-                pwalletMain->SetAddressBookName(CBitcoinAddress(account.vchPubKey), strAccount);\n-                walletdb.WriteAccount(strAccount, account);\n-            }\n+            if (bKeyUsed || bForceNew)\n+                throw JSONRPCError(-12, \"Error: Keypool ran out, please call topupkeypool first\");\n+        }\n+        else\n+        {\n+            account.vchPubKey = pwalletMain->GetOrReuseKeyFromPool();\n+            pwalletMain->SetAddressBookName(CBitcoinAddress(account.vchPubKey), strAccount);\n+            walletdb.WriteAccount(strAccount, account);\n         }\n     }\n \n@@ -413,12 +408,7 @@ Value getaccountaddress(const Array& params, bool fHelp)\n \n     Value ret;\n \n-    CRITICAL_BLOCK(cs_main)\n-    CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n-    CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n-    {\n-        ret = GetAccountAddress(strAccount).ToString();\n-    }\n+    ret = GetAccountAddress(strAccount).ToString();\n \n     return ret;\n }\n@@ -442,20 +432,15 @@ Value setaccount(const Array& params, bool fHelp)\n         strAccount = AccountFromValue(params[1]);\n \n     // Detect when changing the account of an address that is the 'unused current key' of another account:\n-    CRITICAL_BLOCK(cs_main)\n-    CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n-    CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n+    if (pwalletMain->mapAddressBook.count(address))\n     {\n-        if (pwalletMain->mapAddressBook.count(address))\n-        {\n-            string strOldAccount = pwalletMain->mapAddressBook[address];\n-            if (address == GetAccountAddress(strOldAccount))\n-                GetAccountAddress(strOldAccount, true);\n-        }\n-\n-        pwalletMain->SetAddressBookName(address, strAccount);\n+        string strOldAccount = pwalletMain->mapAddressBook[address];\n+        if (address == GetAccountAddress(strOldAccount))\n+            GetAccountAddress(strOldAccount, true);\n     }\n \n+    pwalletMain->SetAddressBookName(address, strAccount);\n+\n     return Value::null;\n }\n \n@@ -472,12 +457,9 @@ Value getaccount(const Array& params, bool fHelp)\n         throw JSONRPCError(-5, \"Invalid bitcoin address\");\n \n     string strAccount;\n-    CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n-    {\n-        map<CBitcoinAddress, string>::iterator mi = pwalletMain->mapAddressBook.find(address);\n-        if (mi != pwalletMain->mapAddressBook.end() && !(*mi).second.empty())\n-            strAccount = (*mi).second;\n-    }\n+    map<CBitcoinAddress, string>::iterator mi = pwalletMain->mapAddressBook.find(address);\n+    if (mi != pwalletMain->mapAddressBook.end() && !(*mi).second.empty())\n+        strAccount = (*mi).second;\n     return strAccount;\n }\n \n@@ -493,15 +475,12 @@ Value getaddressesbyaccount(const Array& params, bool fHelp)\n \n     // Find all addresses that have the given account\n     Array ret;\n-    CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n+    BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, string)& item, pwalletMain->mapAddressBook)\n     {\n-        BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, string)& item, pwalletMain->mapAddressBook)\n-        {\n-            const CBitcoinAddress& address = item.first;\n-            const string& strName = item.second;\n-            if (strName == strAccount)\n-                ret.push_back(address.ToString());\n-        }\n+        const CBitcoinAddress& address = item.first;\n+        const string& strName = item.second;\n+        if (strName == strAccount)\n+            ret.push_back(address.ToString());\n     }\n     return ret;\n }\n@@ -548,16 +527,12 @@ Value sendtoaddress(const Array& params, bool fHelp)\n     if (params.size() > 3 && params[3].type() != null_type && !params[3].get_str().empty())\n         wtx.mapValue[\"to\"]      = params[3].get_str();\n \n-    CRITICAL_BLOCK(cs_main)\n-    CRITICAL_BLOCK(pwalletMain->cs_vMasterKey)\n-    {\n-        if(pwalletMain->IsLocked())\n-            throw JSONRPCError(-13, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n+    if (pwalletMain->IsLocked())\n+        throw JSONRPCError(-13, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n \n-        string strError = pwalletMain->SendMoneyToBitcoinAddress(address, nAmount, wtx);\n-        if (strError != \"\")\n-            throw JSONRPCError(-4, strError);\n-    }\n+    string strError = pwalletMain->SendMoneyToBitcoinAddress(address, nAmount, wtx);\n+    if (strError != \"\")\n+        throw JSONRPCError(-4, strError);\n \n     return wtx.GetHash().GetHex();\n }\n@@ -586,19 +561,16 @@ Value getreceivedbyaddress(const Array& params, bool fHelp)\n \n     // Tally\n     int64 nAmount = 0;\n-    CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n+    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n     {\n-        for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n-        {\n-            const CWalletTx& wtx = (*it).second;\n-            if (wtx.IsCoinBase() || !wtx.IsFinal())\n-                continue;\n+        const CWalletTx& wtx = (*it).second;\n+        if (wtx.IsCoinBase() || !wtx.IsFinal())\n+            continue;\n \n-            BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n-                if (txout.scriptPubKey == scriptPubKey)\n-                    if (wtx.GetDepthInMainChain() >= nMinDepth)\n-                        nAmount += txout.nValue;\n-        }\n+        BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n+            if (txout.scriptPubKey == scriptPubKey)\n+                if (wtx.GetDepthInMainChain() >= nMinDepth)\n+                    nAmount += txout.nValue;\n     }\n \n     return  ValueFromAmount(nAmount);\n@@ -607,15 +579,12 @@ Value getreceivedbyaddress(const Array& params, bool fHelp)\n \n void GetAccountAddresses(string strAccount, set<CBitcoinAddress>& setAddress)\n {\n-    CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n+    BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, string)& item, pwalletMain->mapAddressBook)\n     {\n-        BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, string)& item, pwalletMain->mapAddressBook)\n-        {\n-            const CBitcoinAddress& address = item.first;\n-            const string& strName = item.second;\n-            if (strName == strAccount)\n-                setAddress.insert(address);\n-        }\n+        const CBitcoinAddress& address = item.first;\n+        const string& strName = item.second;\n+        if (strName == strAccount)\n+            setAddress.insert(address);\n     }\n }\n \n@@ -639,21 +608,18 @@ Value getreceivedbyaccount(const Array& params, bool fHelp)\n \n     // Tally\n     int64 nAmount = 0;\n-    CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n+    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n     {\n-        for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n-        {\n-            const CWalletTx& wtx = (*it).second;\n-            if (wtx.IsCoinBase() || !wtx.IsFinal())\n-                continue;\n+        const CWalletTx& wtx = (*it).second;\n+        if (wtx.IsCoinBase() || !wtx.IsFinal())\n+            continue;\n \n-            BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n-            {\n-                CBitcoinAddress address;\n-                if (ExtractAddress(txout.scriptPubKey, pwalletMain, address) && setAddress.count(address))\n-                    if (wtx.GetDepthInMainChain() >= nMinDepth)\n-                        nAmount += txout.nValue;\n-            }\n+        BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n+        {\n+            CBitcoinAddress address;\n+            if (ExtractAddress(txout.scriptPubKey, pwalletMain, address) && setAddress.count(address))\n+                if (wtx.GetDepthInMainChain() >= nMinDepth)\n+                    nAmount += txout.nValue;\n         }\n     }\n \n@@ -664,27 +630,25 @@ Value getreceivedbyaccount(const Array& params, bool fHelp)\n int64 GetAccountBalance(CWalletDB& walletdb, const string& strAccount, int nMinDepth)\n {\n     int64 nBalance = 0;\n-    CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n-    {\n-        // Tally wallet transactions\n-        for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n-        {\n-            const CWalletTx& wtx = (*it).second;\n-            if (!wtx.IsFinal())\n-                continue;\n \n-            int64 nGenerated, nReceived, nSent, nFee;\n-            wtx.GetAccountAmounts(strAccount, nGenerated, nReceived, nSent, nFee);\n+    // Tally wallet transactions\n+    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n+    {\n+        const CWalletTx& wtx = (*it).second;\n+        if (!wtx.IsFinal())\n+            continue;\n \n-            if (nReceived != 0 && wtx.GetDepthInMainChain() >= nMinDepth)\n-                nBalance += nReceived;\n-            nBalance += nGenerated - nSent - nFee;\n-        }\n+        int64 nGenerated, nReceived, nSent, nFee;\n+        wtx.GetAccountAmounts(strAccount, nGenerated, nReceived, nSent, nFee);\n \n-        // Tally internal accounting entries\n-        nBalance += walletdb.GetAccountCreditDebit(strAccount);\n+        if (nReceived != 0 && wtx.GetDepthInMainChain() >= nMinDepth)\n+            nBalance += nReceived;\n+        nBalance += nGenerated - nSent - nFee;\n     }\n \n+    // Tally internal accounting entries\n+    nBalance += walletdb.GetAccountCreditDebit(strAccount);\n+\n     return nBalance;\n }\n \n@@ -763,33 +727,31 @@ Value movecmd(const Array& params, bool fHelp)\n     if (params.size() > 4)\n         strComment = params[4].get_str();\n \n-    CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n-    {\n-        CWalletDB walletdb(pwalletMain->strWalletFile);\n-        walletdb.TxnBegin();\n-\n-        int64 nNow = GetAdjustedTime();\n-\n-        // Debit\n-        CAccountingEntry debit;\n-        debit.strAccount = strFrom;\n-        debit.nCreditDebit = -nAmount;\n-        debit.nTime = nNow;\n-        debit.strOtherAccount = strTo;\n-        debit.strComment = strComment;\n-        walletdb.WriteAccountingEntry(debit);\n-\n-        // Credit\n-        CAccountingEntry credit;\n-        credit.strAccount = strTo;\n-        credit.nCreditDebit = nAmount;\n-        credit.nTime = nNow;\n-        credit.strOtherAccount = strFrom;\n-        credit.strComment = strComment;\n-        walletdb.WriteAccountingEntry(credit);\n-\n-        walletdb.TxnCommit();\n-    }\n+    CWalletDB walletdb(pwalletMain->strWalletFile);\n+    walletdb.TxnBegin();\n+\n+    int64 nNow = GetAdjustedTime();\n+\n+    // Debit\n+    CAccountingEntry debit;\n+    debit.strAccount = strFrom;\n+    debit.nCreditDebit = -nAmount;\n+    debit.nTime = nNow;\n+    debit.strOtherAccount = strTo;\n+    debit.strComment = strComment;\n+    walletdb.WriteAccountingEntry(debit);\n+\n+    // Credit\n+    CAccountingEntry credit;\n+    credit.strAccount = strTo;\n+    credit.nCreditDebit = nAmount;\n+    credit.nTime = nNow;\n+    credit.strOtherAccount = strFrom;\n+    credit.strComment = strComment;\n+    walletdb.WriteAccountingEntry(credit);\n+\n+    walletdb.TxnCommit();\n+\n     return true;\n }\n \n@@ -822,23 +784,18 @@ Value sendfrom(const Array& params, bool fHelp)\n     if (params.size() > 5 && params[5].type() != null_type && !params[5].get_str().empty())\n         wtx.mapValue[\"to\"]      = params[5].get_str();\n \n-    CRITICAL_BLOCK(cs_main)\n-    CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n-    CRITICAL_BLOCK(pwalletMain->cs_vMasterKey)\n-    {\n-        if(pwalletMain->IsLocked())\n-            throw JSONRPCError(-13, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n-\n-        // Check funds\n-        int64 nBalance = GetAccountBalance(strAccount, nMinDepth);\n-        if (nAmount > nBalance)\n-            throw JSONRPCError(-6, \"Account has insufficient funds\");\n-\n-        // Send\n-        string strError = pwalletMain->SendMoneyToBitcoinAddress(address, nAmount, wtx);\n-        if (strError != \"\")\n-            throw JSONRPCError(-4, strError);\n-    }\n+    if (pwalletMain->IsLocked())\n+        throw JSONRPCError(-13, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n+\n+    // Check funds\n+    int64 nBalance = GetAccountBalance(strAccount, nMinDepth);\n+    if (nAmount > nBalance)\n+        throw JSONRPCError(-6, \"Account has insufficient funds\");\n+\n+    // Send\n+    string strError = pwalletMain->SendMoneyToBitcoinAddress(address, nAmount, wtx);\n+    if (strError != \"\")\n+        throw JSONRPCError(-4, strError);\n \n     return wtx.GetHash().GetHex();\n }\n@@ -889,31 +846,26 @@ Value sendmany(const Array& params, bool fHelp)\n         vecSend.push_back(make_pair(scriptPubKey, nAmount));\n     }\n \n-    CRITICAL_BLOCK(cs_main)\n-    CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n-    CRITICAL_BLOCK(pwalletMain->cs_vMasterKey)\n+    if (pwalletMain->IsLocked())\n+        throw JSONRPCError(-13, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n+\n+    // Check funds\n+    int64 nBalance = GetAccountBalance(strAccount, nMinDepth);\n+    if (totalAmount > nBalance)\n+        throw JSONRPCError(-6, \"Account has insufficient funds\");\n+\n+    // Send\n+    CReserveKey keyChange(pwalletMain);\n+    int64 nFeeRequired = 0;\n+    bool fCreated = pwalletMain->CreateTransaction(vecSend, wtx, keyChange, nFeeRequired);\n+    if (!fCreated)\n     {\n-        if(pwalletMain->IsLocked())\n-            throw JSONRPCError(-13, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n-\n-        // Check funds\n-        int64 nBalance = GetAccountBalance(strAccount, nMinDepth);\n-        if (totalAmount > nBalance)\n-            throw JSONRPCError(-6, \"Account has insufficient funds\");\n-\n-        // Send\n-        CReserveKey keyChange(pwalletMain);\n-        int64 nFeeRequired = 0;\n-        bool fCreated = pwalletMain->CreateTransaction(vecSend, wtx, keyChange, nFeeRequired);\n-        if (!fCreated)\n-        {\n-            if (totalAmount + nFeeRequired > pwalletMain->GetBalance())\n-                throw JSONRPCError(-6, \"Insufficient funds\");\n-            throw JSONRPCError(-4, \"Transaction creation failed\");\n-        }\n-        if (!pwalletMain->CommitTransaction(wtx, keyChange))\n-            throw JSONRPCError(-4, \"Transaction commit failed\");\n+        if (totalAmount + nFeeRequired > pwalletMain->GetBalance())\n+            throw JSONRPCError(-6, \"Insufficient funds\");\n+        throw JSONRPCError(-4, \"Transaction creation failed\");\n     }\n+    if (!pwalletMain->CommitTransaction(wtx, keyChange))\n+        throw JSONRPCError(-4, \"Transaction commit failed\");\n \n     return wtx.GetHash().GetHex();\n }\n@@ -944,68 +896,62 @@ Value ListReceived(const Array& params, bool fByAccounts)\n \n     // Tally\n     map<CBitcoinAddress, tallyitem> mapTally;\n-    CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n+    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n     {\n-        for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n-        {\n-            const CWalletTx& wtx = (*it).second;\n-            if (wtx.IsCoinBase() || !wtx.IsFinal())\n-                continue;\n+        const CWalletTx& wtx = (*it).second;\n+        if (wtx.IsCoinBase() || !wtx.IsFinal())\n+            continue;\n \n-            int nDepth = wtx.GetDepthInMainChain();\n-            if (nDepth < nMinDepth)\n-                continue;\n+        int nDepth = wtx.GetDepthInMainChain();\n+        if (nDepth < nMinDepth)\n+            continue;\n \n-            BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n-            {\n-                CBitcoinAddress address;\n-                if (!ExtractAddress(txout.scriptPubKey, pwalletMain, address) || !address.IsValid())\n-                    continue;\n+        BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n+        {\n+            CBitcoinAddress address;\n+            if (!ExtractAddress(txout.scriptPubKey, pwalletMain, address) || !address.IsValid())\n+                continue;\n \n-                tallyitem& item = mapTally[address];\n-                item.nAmount += txout.nValue;\n-                item.nConf = min(item.nConf, nDepth);\n-            }\n+            tallyitem& item = mapTally[address];\n+            item.nAmount += txout.nValue;\n+            item.nConf = min(item.nConf, nDepth);\n         }\n     }\n \n     // Reply\n     Array ret;\n     map<string, tallyitem> mapAccountTally;\n-    CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n+    BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, string)& item, pwalletMain->mapAddressBook)\n     {\n-        BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, string)& item, pwalletMain->mapAddressBook)\n-        {\n-            const CBitcoinAddress& address = item.first;\n-            const string& strAccount = item.second;\n-            map<CBitcoinAddress, tallyitem>::iterator it = mapTally.find(address);\n-            if (it == mapTally.end() && !fIncludeEmpty)\n-                continue;\n+        const CBitcoinAddress& address = item.first;\n+        const string& strAccount = item.second;\n+        map<CBitcoinAddress, tallyitem>::iterator it = mapTally.find(address);\n+        if (it == mapTally.end() && !fIncludeEmpty)\n+            continue;\n \n-            int64 nAmount = 0;\n-            int nConf = INT_MAX;\n-            if (it != mapTally.end())\n-            {\n-                nAmount = (*it).second.nAmount;\n-                nConf = (*it).second.nConf;\n-            }\n+        int64 nAmount = 0;\n+        int nConf = INT_MAX;\n+        if (it != mapTally.end())\n+        {\n+            nAmount = (*it).second.nAmount;\n+            nConf = (*it).second.nConf;\n+        }\n \n-            if (fByAccounts)\n-            {\n-                tallyitem& item = mapAccountTally[strAccount];\n-                item.nAmount += nAmount;\n-                item.nConf = min(item.nConf, nConf);\n-            }\n-            else\n-            {\n-                Object obj;\n-                obj.push_back(Pair(\"address\",       address.ToString()));\n-                obj.push_back(Pair(\"account\",       strAccount));\n-                obj.push_back(Pair(\"label\",         strAccount)); // deprecated\n-                obj.push_back(Pair(\"amount\",        ValueFromAmount(nAmount)));\n-                obj.push_back(Pair(\"confirmations\", (nConf == INT_MAX ? 0 : nConf)));\n-                ret.push_back(obj);\n-            }\n+        if (fByAccounts)\n+        {\n+            tallyitem& item = mapAccountTally[strAccount];\n+            item.nAmount += nAmount;\n+            item.nConf = min(item.nConf, nConf);\n+        }\n+        else\n+        {\n+            Object obj;\n+            obj.push_back(Pair(\"address\",       address.ToString()));\n+            obj.push_back(Pair(\"account\",       strAccount));\n+            obj.push_back(Pair(\"label\",         strAccount)); // deprecated\n+            obj.push_back(Pair(\"amount\",        ValueFromAmount(nAmount)));\n+            obj.push_back(Pair(\"confirmations\", (nConf == INT_MAX ? 0 : nConf)));\n+            ret.push_back(obj);\n         }\n     }\n \n@@ -1107,27 +1053,23 @@ void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDe\n \n     // Received\n     if (listReceived.size() > 0 && wtx.GetDepthInMainChain() >= nMinDepth)\n-        CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n+        BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, int64)& r, listReceived)\n         {\n-            BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, int64)& r, listReceived)\n+            string account;\n+            if (pwalletMain->mapAddressBook.count(r.first))\n+                account = pwalletMain->mapAddressBook[r.first];\n+            if (fAllAccounts || (account == strAccount))\n             {\n-                string account;\n-                if (pwalletMain->mapAddressBook.count(r.first))\n-                    account = pwalletMain->mapAddressBook[r.first];\n-                if (fAllAccounts || (account == strAccount))\n-                {\n-                    Object entry;\n-                    entry.push_back(Pair(\"account\", account));\n-                    entry.push_back(Pair(\"address\", r.first.ToString()));\n-                    entry.push_back(Pair(\"category\", \"receive\"));\n-                    entry.push_back(Pair(\"amount\", ValueFromAmount(r.second)));\n-                    if (fLong)\n-                        WalletTxToJSON(wtx, entry);\n-                    ret.push_back(entry);\n-                }\n+                Object entry;\n+                entry.push_back(Pair(\"account\", account));\n+                entry.push_back(Pair(\"address\", r.first.ToString()));\n+                entry.push_back(Pair(\"category\", \"receive\"));\n+                entry.push_back(Pair(\"amount\", ValueFromAmount(r.second)));\n+                if (fLong)\n+                    WalletTxToJSON(wtx, entry);\n+                ret.push_back(entry);\n             }\n         }\n-\n }\n \n void AcentryToJSON(const CAccountingEntry& acentry, const string& strAccount, Array& ret)\n@@ -1167,41 +1109,38 @@ Value listtransactions(const Array& params, bool fHelp)\n     Array ret;\n     CWalletDB walletdb(pwalletMain->strWalletFile);\n \n-    CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n-    {\n-        // Firs: get all CWalletTx and CAccountingEntry into a sorted-by-time multimap:\n-        typedef pair<CWalletTx*, CAccountingEntry*> TxPair;\n-        typedef multimap<int64, TxPair > TxItems;\n-        TxItems txByTime;\n+    // Firs: get all CWalletTx and CAccountingEntry into a sorted-by-time multimap:\n+    typedef pair<CWalletTx*, CAccountingEntry*> TxPair;\n+    typedef multimap<int64, TxPair > TxItems;\n+    TxItems txByTime;\n \n-        for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n-        {\n-            CWalletTx* wtx = &((*it).second);\n-            txByTime.insert(make_pair(wtx->GetTxTime(), TxPair(wtx, (CAccountingEntry*)0)));\n-        }\n-        list<CAccountingEntry> acentries;\n-        walletdb.ListAccountCreditDebit(strAccount, acentries);\n-        BOOST_FOREACH(CAccountingEntry& entry, acentries)\n-        {\n-            txByTime.insert(make_pair(entry.nTime, TxPair((CWalletTx*)0, &entry)));\n-        }\n+    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n+    {\n+        CWalletTx* wtx = &((*it).second);\n+        txByTime.insert(make_pair(wtx->GetTxTime(), TxPair(wtx, (CAccountingEntry*)0)));\n+    }\n+    list<CAccountingEntry> acentries;\n+    walletdb.ListAccountCreditDebit(strAccount, acentries);\n+    BOOST_FOREACH(CAccountingEntry& entry, acentries)\n+    {\n+        txByTime.insert(make_pair(entry.nTime, TxPair((CWalletTx*)0, &entry)));\n+    }\n \n-        // Now: iterate backwards until we have nCount items to return:\n-        TxItems::reverse_iterator it = txByTime.rbegin();\n-        if (txByTime.size() > nFrom) std::advance(it, nFrom);\n-        for (; it != txByTime.rend(); ++it)\n-        {\n-            CWalletTx *const pwtx = (*it).second.first;\n-            if (pwtx != 0)\n-                ListTransactions(*pwtx, strAccount, 0, true, ret);\n-            CAccountingEntry *const pacentry = (*it).second.second;\n-            if (pacentry != 0)\n-                AcentryToJSON(*pacentry, strAccount, ret);\n-\n-            if (ret.size() >= nCount) break;\n-        }\n-        // ret is now newest to oldest\n+    // Now: iterate backwards until we have nCount items to return:\n+    TxItems::reverse_iterator it = txByTime.rbegin();\n+    if (txByTime.size() > nFrom) std::advance(it, nFrom);\n+    for (; it != txByTime.rend(); ++it)\n+    {\n+        CWalletTx *const pwtx = (*it).second.first;\n+        if (pwtx != 0)\n+            ListTransactions(*pwtx, strAccount, 0, true, ret);\n+        CAccountingEntry *const pacentry = (*it).second.second;\n+        if (pacentry != 0)\n+            AcentryToJSON(*pacentry, strAccount, ret);\n+\n+        if (ret.size() >= nCount) break;\n     }\n+    // ret is now newest to oldest\n     \n     // Make sure we return only last nCount items (sends-to-self might give us an extra):\n     if (ret.size() > nCount)\n@@ -1227,34 +1166,30 @@ Value listaccounts(const Array& params, bool fHelp)\n         nMinDepth = params[0].get_int();\n \n     map<string, int64> mapAccountBalances;\n-    CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n-    CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n-    {\n-        BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, string)& entry, pwalletMain->mapAddressBook) {\n-            if (pwalletMain->HaveKey(entry.first)) // This address belongs to me\n-                mapAccountBalances[entry.second] = 0;\n-        }\n+    BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, string)& entry, pwalletMain->mapAddressBook) {\n+        if (pwalletMain->HaveKey(entry.first)) // This address belongs to me\n+            mapAccountBalances[entry.second] = 0;\n+    }\n \n-        for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n+    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n+    {\n+        const CWalletTx& wtx = (*it).second;\n+        int64 nGeneratedImmature, nGeneratedMature, nFee;\n+        string strSentAccount;\n+        list<pair<CBitcoinAddress, int64> > listReceived;\n+        list<pair<CBitcoinAddress, int64> > listSent;\n+        wtx.GetAmounts(nGeneratedImmature, nGeneratedMature, listReceived, listSent, nFee, strSentAccount);\n+        mapAccountBalances[strSentAccount] -= nFee;\n+        BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, int64)& s, listSent)\n+            mapAccountBalances[strSentAccount] -= s.second;\n+        if (wtx.GetDepthInMainChain() >= nMinDepth)\n         {\n-            const CWalletTx& wtx = (*it).second;\n-            int64 nGeneratedImmature, nGeneratedMature, nFee;\n-            string strSentAccount;\n-            list<pair<CBitcoinAddress, int64> > listReceived;\n-            list<pair<CBitcoinAddress, int64> > listSent;\n-            wtx.GetAmounts(nGeneratedImmature, nGeneratedMature, listReceived, listSent, nFee, strSentAccount);\n-            mapAccountBalances[strSentAccount] -= nFee;\n-            BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, int64)& s, listSent)\n-                mapAccountBalances[strSentAccount] -= s.second;\n-            if (wtx.GetDepthInMainChain() >= nMinDepth)\n-            {\n-                mapAccountBalances[\"\"] += nGeneratedMature;\n-                BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, int64)& r, listReceived)\n-                    if (pwalletMain->mapAddressBook.count(r.first))\n-                        mapAccountBalances[pwalletMain->mapAddressBook[r.first]] += r.second;\n-                    else\n-                        mapAccountBalances[\"\"] += r.second;\n-            }\n+            mapAccountBalances[\"\"] += nGeneratedMature;\n+            BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, int64)& r, listReceived)\n+                if (pwalletMain->mapAddressBook.count(r.first))\n+                    mapAccountBalances[pwalletMain->mapAddressBook[r.first]] += r.second;\n+                else\n+                    mapAccountBalances[\"\"] += r.second;\n         }\n     }\n \n@@ -1281,27 +1216,25 @@ Value gettransaction(const Array& params, bool fHelp)\n     hash.SetHex(params[0].get_str());\n \n     Object entry;\n-    CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n-    {\n-        if (!pwalletMain->mapWallet.count(hash))\n-            throw JSONRPCError(-5, \"Invalid or non-wallet transaction id\");\n-        const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n \n-        int64 nCredit = wtx.GetCredit();\n-        int64 nDebit = wtx.GetDebit();\n-        int64 nNet = nCredit - nDebit;\n-        int64 nFee = (wtx.IsFromMe() ? wtx.GetValueOut() - nDebit : 0);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(-5, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n \n-        entry.push_back(Pair(\"amount\", ValueFromAmount(nNet - nFee)));\n-        if (wtx.IsFromMe())\n-            entry.push_back(Pair(\"fee\", ValueFromAmount(nFee)));\n+    int64 nCredit = wtx.GetCredit();\n+    int64 nDebit = wtx.GetDebit();\n+    int64 nNet = nCredit - nDebit;\n+    int64 nFee = (wtx.IsFromMe() ? wtx.GetValueOut() - nDebit : 0);\n \n-        WalletTxToJSON(pwalletMain->mapWallet[hash], entry);\n+    entry.push_back(Pair(\"amount\", ValueFromAmount(nNet - nFee)));\n+    if (wtx.IsFromMe())\n+        entry.push_back(Pair(\"fee\", ValueFromAmount(nFee)));\n \n-        Array details;\n-        ListTransactions(pwalletMain->mapWallet[hash], \"*\", 0, false, details);\n-        entry.push_back(Pair(\"details\", details));\n-    }\n+    WalletTxToJSON(pwalletMain->mapWallet[hash], entry);\n+\n+    Array details;\n+    ListTransactions(pwalletMain->mapWallet[hash], \"*\", 0, false, details);\n+    entry.push_back(Pair(\"details\", details));\n \n     return entry;\n }\n@@ -1332,13 +1265,10 @@ Value keypoolrefill(const Array& params, bool fHelp)\n             \"keypoolrefill\\n\"\n             \"Fills the keypool.\");\n \n-    CRITICAL_BLOCK(pwalletMain->cs_vMasterKey)\n-    {\n-        if (pwalletMain->IsLocked())\n-            throw JSONRPCError(-13, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n+    if (pwalletMain->IsLocked())\n+        throw JSONRPCError(-13, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n \n-        pwalletMain->TopUpKeyPool();\n-    }\n+    pwalletMain->TopUpKeyPool();\n \n     if (pwalletMain->GetKeyPoolSize() < GetArg(\"-keypool\", 100))\n         throw JSONRPCError(-4, \"Error refreshing keypool.\");\n@@ -1407,24 +1337,21 @@ Value walletpassphrase(const Array& params, bool fHelp)\n     mlock(&strWalletPass[0], strWalletPass.capacity());\n     strWalletPass = params[0].get_str();\n \n-    CRITICAL_BLOCK(pwalletMain->cs_vMasterKey)\n+    if (strWalletPass.length() > 0)\n     {\n-        if (strWalletPass.length() > 0)\n+        if (!pwalletMain->Unlock(strWalletPass))\n         {\n-            if (!pwalletMain->Unlock(strWalletPass))\n-            {\n-                fill(strWalletPass.begin(), strWalletPass.end(), '\\0');\n-                munlock(&strWalletPass[0], strWalletPass.capacity());\n-                throw JSONRPCError(-14, \"Error: The wallet passphrase entered was incorrect.\");\n-            }\n             fill(strWalletPass.begin(), strWalletPass.end(), '\\0');\n             munlock(&strWalletPass[0], strWalletPass.capacity());\n+            throw JSONRPCError(-14, \"Error: The wallet passphrase entered was incorrect.\");\n         }\n-        else\n-            throw runtime_error(\n-                \"walletpassphrase <passphrase> <timeout>\\n\"\n-                \"Stores the wallet decryption key in memory for <timeout> seconds.\");\n+        fill(strWalletPass.begin(), strWalletPass.end(), '\\0');\n+        munlock(&strWalletPass[0], strWalletPass.capacity());\n     }\n+    else\n+        throw runtime_error(\n+            \"walletpassphrase <passphrase> <timeout>\\n\"\n+            \"Stores the wallet decryption key in memory for <timeout> seconds.\");\n \n     CreateThread(ThreadTopUpKeyPool, NULL);\n     int* pnSleepTime = new int(params[1].get_int());\n@@ -1553,11 +1480,8 @@ Value validateaddress(const Array& params, bool fHelp)\n         string currentAddress = address.ToString();\n         ret.push_back(Pair(\"address\", currentAddress));\n         ret.push_back(Pair(\"ismine\", (pwalletMain->HaveKey(address) > 0)));\n-        CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n-        {\n-            if (pwalletMain->mapAddressBook.count(address))\n-                ret.push_back(Pair(\"account\", pwalletMain->mapAddressBook[address]));\n-        }\n+        if (pwalletMain->mapAddressBook.count(address))\n+            ret.push_back(Pair(\"account\", pwalletMain->mapAddressBook[address]));\n     }\n     return ret;\n }\n@@ -2233,7 +2157,10 @@ void ThreadRPCServer2(void* parg)\n             try\n             {\n                 // Execute\n-                Value result = (*(*mi).second)(params, false);\n+                Value result;\n+                CRITICAL_BLOCK(cs_main)\n+                CRITICAL_BLOCK(pwalletMain->cs_wallet)\n+                    result = (*(*mi).second)(params, false);\n \n                 // Send reply\n                 string strReply = JSONRPCReply(result, Value::null, id);"
      },
      {
        "sha": "6e7bcb5e14c20abe50edca0492755045745f426e",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 47,
        "deletions": 55,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6cc4a62c0e696dcb9d90ba0504f688e4f644a10f/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6cc4a62c0e696dcb9d90ba0504f688e4f644a10f/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=6cc4a62c0e696dcb9d90ba0504f688e4f644a10f",
        "patch": "@@ -1033,48 +1033,45 @@ bool Solver(const CKeyStore& keystore, const CScript& scriptPubKey, uint256 hash\n         return false;\n \n     // Compile solution\n-    CRITICAL_BLOCK(keystore.cs_KeyStore)\n+    BOOST_FOREACH(PAIRTYPE(opcodetype, valtype)& item, vSolution)\n     {\n-        BOOST_FOREACH(PAIRTYPE(opcodetype, valtype)& item, vSolution)\n+        if (item.first == OP_PUBKEY)\n         {\n-            if (item.first == OP_PUBKEY)\n+            // Sign\n+            const valtype& vchPubKey = item.second;\n+            CKey key;\n+            if (!keystore.GetKey(Hash160(vchPubKey), key))\n+                return false;\n+            if (key.GetPubKey() != vchPubKey)\n+                return false;\n+            if (hash != 0)\n             {\n-                // Sign\n-                const valtype& vchPubKey = item.second;\n-                CKey key;\n-                if (!keystore.GetKey(Hash160(vchPubKey), key))\n-                    return false;\n-                if (key.GetPubKey() != vchPubKey)\n+                vector<unsigned char> vchSig;\n+                if (!key.Sign(hash, vchSig))\n                     return false;\n-                if (hash != 0)\n-                {\n-                    vector<unsigned char> vchSig;\n-                    if (!key.Sign(hash, vchSig))\n-                        return false;\n-                    vchSig.push_back((unsigned char)nHashType);\n-                    scriptSigRet << vchSig;\n-                }\n+                vchSig.push_back((unsigned char)nHashType);\n+                scriptSigRet << vchSig;\n             }\n-            else if (item.first == OP_PUBKEYHASH)\n+        }\n+        else if (item.first == OP_PUBKEYHASH)\n+        {\n+            // Sign and give pubkey\n+            CKey key;\n+            if (!keystore.GetKey(uint160(item.second), key))\n+                return false;\n+            if (hash != 0)\n             {\n-                // Sign and give pubkey\n-                CKey key;\n-                if (!keystore.GetKey(uint160(item.second), key))\n+                vector<unsigned char> vchSig;\n+                if (!key.Sign(hash, vchSig))\n                     return false;\n-                if (hash != 0)\n-                {\n-                    vector<unsigned char> vchSig;\n-                    if (!key.Sign(hash, vchSig))\n-                        return false;\n-                    vchSig.push_back((unsigned char)nHashType);\n-                    scriptSigRet << vchSig << key.GetPubKey();\n-                }\n-            }\n-            else\n-            {\n-                return false;\n+                vchSig.push_back((unsigned char)nHashType);\n+                scriptSigRet << vchSig << key.GetPubKey();\n             }\n         }\n+        else\n+        {\n+            return false;\n+        }\n     }\n \n     return true;\n@@ -1095,35 +1092,31 @@ bool IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n         return false;\n \n     // Compile solution\n-    CRITICAL_BLOCK(keystore.cs_KeyStore)\n+    BOOST_FOREACH(PAIRTYPE(opcodetype, valtype)& item, vSolution)\n     {\n-        BOOST_FOREACH(PAIRTYPE(opcodetype, valtype)& item, vSolution)\n+        if (item.first == OP_PUBKEY)\n         {\n-            if (item.first == OP_PUBKEY)\n-            {\n-                const valtype& vchPubKey = item.second;\n-                vector<unsigned char> vchPubKeyFound;\n-                if (!keystore.GetPubKey(Hash160(vchPubKey), vchPubKeyFound))\n-                    return false;\n-                if (vchPubKeyFound != vchPubKey)\n-                    return false;\n-            }\n-            else if (item.first == OP_PUBKEYHASH)\n-            {\n-                if (!keystore.HaveKey(uint160(item.second)))\n-                    return false;\n-            }\n-            else\n-            {\n+            const valtype& vchPubKey = item.second;\n+            vector<unsigned char> vchPubKeyFound;\n+            if (!keystore.GetPubKey(Hash160(vchPubKey), vchPubKeyFound))\n                 return false;\n-            }\n+            if (vchPubKeyFound != vchPubKey)\n+                return false;\n+        }\n+        else if (item.first == OP_PUBKEYHASH)\n+        {\n+            if (!keystore.HaveKey(uint160(item.second)))\n+                return false;\n+        }\n+        else\n+        {\n+            return false;\n         }\n     }\n \n     return true;\n }\n \n-// requires either keystore==0, or a lock on keystore->cs_KeyStore\n bool static ExtractAddressInner(const CScript& scriptPubKey, const CKeyStore* keystore, CBitcoinAddress& addressRet)\n {\n     vector<pair<opcodetype, valtype> > vSolution;\n@@ -1146,8 +1139,7 @@ bool static ExtractAddressInner(const CScript& scriptPubKey, const CKeyStore* ke\n bool ExtractAddress(const CScript& scriptPubKey, const CKeyStore* keystore, CBitcoinAddress& addressRet)\n {\n     if (keystore)\n-        CRITICAL_BLOCK(keystore->cs_KeyStore)\n-            return ExtractAddressInner(scriptPubKey, keystore, addressRet);\n+        return ExtractAddressInner(scriptPubKey, keystore, addressRet);\n     else\n         return ExtractAddressInner(scriptPubKey, NULL, addressRet);\n     return false;"
      },
      {
        "sha": "867c9c0a0dd460152f9d5daa14ff12f579ced35d",
        "filename": "src/ui.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 9,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6cc4a62c0e696dcb9d90ba0504f688e4f644a10f/src/ui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6cc4a62c0e696dcb9d90ba0504f688e4f644a10f/src/ui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ui.cpp?ref=6cc4a62c0e696dcb9d90ba0504f688e4f644a10f",
        "patch": "@@ -862,7 +862,7 @@ void CMainFrame::OnIdle(wxIdleEvent& event)\n         // Collect list of wallet transactions and sort newest first\n         bool fEntered = false;\n         vector<pair<unsigned int, uint256> > vSorted;\n-        TRY_CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n+        TRY_CRITICAL_BLOCK(pwalletMain->cs_wallet)\n         {\n             printf(\"RefreshListCtrl starting\\n\");\n             fEntered = true;\n@@ -890,7 +890,7 @@ void CMainFrame::OnIdle(wxIdleEvent& event)\n             if (fShutdown)\n                 return;\n             bool fEntered = false;\n-            TRY_CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n+            TRY_CRITICAL_BLOCK(pwalletMain->cs_wallet)\n             {\n                 fEntered = true;\n                 uint256& hash = vSorted[i++].second;\n@@ -913,7 +913,7 @@ void CMainFrame::OnIdle(wxIdleEvent& event)\n         static int64 nLastTime;\n         if (GetTime() > nLastTime + 30)\n         {\n-            TRY_CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n+            TRY_CRITICAL_BLOCK(pwalletMain->cs_wallet)\n             {\n                 nLastTime = GetTime();\n                 for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n@@ -937,7 +937,7 @@ void CMainFrame::RefreshStatusColumn()\n     if (nTop == nLastTop && pindexLastBest == pindexBest)\n         return;\n \n-    TRY_CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n+    TRY_CRITICAL_BLOCK(pwalletMain->cs_wallet)\n     {\n         int nStart = nTop;\n         int nEnd = min(nStart + 100, m_listCtrl->GetItemCount());\n@@ -1057,7 +1057,7 @@ void CMainFrame::OnPaintListCtrl(wxPaintEvent& event)\n         // Update listctrl contents\n         if (!pwalletMain->vWalletUpdated.empty())\n         {\n-            TRY_CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n+            TRY_CRITICAL_BLOCK(pwalletMain->cs_wallet)\n             {\n                 string strTop;\n                 if (m_listCtrl->GetItemCount())\n@@ -1075,7 +1075,7 @@ void CMainFrame::OnPaintListCtrl(wxPaintEvent& event)\n         }\n \n         // Balance total\n-        TRY_CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n+        TRY_CRITICAL_BLOCK(pwalletMain->cs_wallet)\n         {\n             fPaintedBalance = true;\n             m_staticTextBalance->SetLabel(FormatMoney(pwalletMain->GetBalance()) + \"  \");\n@@ -1420,7 +1420,7 @@ void CMainFrame::OnListItemActivated(wxListEvent& event)\n {\n     uint256 hash((string)GetItemText(m_listCtrl, event.GetIndex(), 1));\n     CWalletTx wtx;\n-    CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n+    CRITICAL_BLOCK(pwalletMain->cs_wallet)\n     {\n         map<uint256, CWalletTx>::iterator mi = pwalletMain->mapWallet.find(hash);\n         if (mi == pwalletMain->mapWallet.end())\n@@ -1662,7 +1662,7 @@ CTxDetailsDialog::CTxDetailsDialog(wxWindow* parent, CWalletTx wtx) : CTxDetails\n             strHTML += HtmlEscape(wtx.ToString(), true);\n \n             strHTML += \"<br><b>Inputs:</b><br>\";\n-            CRITICAL_BLOCK(pwalletMain->cs_mapWallet)\n+            CRITICAL_BLOCK(pwalletMain->cs_wallet)\n             {\n                 BOOST_FOREACH(const CTxIn& txin, wtx.vin)\n                 {\n@@ -2621,7 +2621,6 @@ CAddressBookDialog::CAddressBookDialog(wxWindow* parent, const wxString& strInit\n     m_listCtrlReceiving->SetFocus();\n \n     // Fill listctrl with address book data\n-    CRITICAL_BLOCK(pwalletMain->cs_KeyStore)\n     CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n     {\n         string strDefaultReceiving = (string)pframeMain->m_textCtrlAddress->GetValue();"
      },
      {
        "sha": "745fbefdb14b1350fa2451f56dc1d6cb737b73a5",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 100,
        "deletions": 109,
        "changes": 209,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6cc4a62c0e696dcb9d90ba0504f688e4f644a10f/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6cc4a62c0e696dcb9d90ba0504f688e4f644a10f/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=6cc4a62c0e696dcb9d90ba0504f688e4f644a10f",
        "patch": "@@ -33,7 +33,7 @@ bool CWallet::AddCryptedKey(const vector<unsigned char> &vchPubKey, const vector\n         return false;\n     if (!fFileBacked)\n         return true;\n-    CRITICAL_BLOCK(cs_pwalletdbEncryption)\n+    CRITICAL_BLOCK(cs_wallet)\n     {\n         if (pwalletdbEncryption)\n             return pwalletdbEncryption->WriteCryptedKey(vchPubKey, vchCryptedSecret);\n@@ -44,14 +44,13 @@ bool CWallet::AddCryptedKey(const vector<unsigned char> &vchPubKey, const vector\n \n bool CWallet::Unlock(const string& strWalletPassphrase)\n {\n-    CRITICAL_BLOCK(cs_vMasterKey)\n-    {\n-        if (!IsLocked())\n-            return false;\n+    if (!IsLocked())\n+        return false;\n \n-        CCrypter crypter;\n-        CKeyingMaterial vMasterKey;\n+    CCrypter crypter;\n+    CKeyingMaterial vMasterKey;\n \n+    CRITICAL_BLOCK(cs_wallet)\n         BOOST_FOREACH(const MasterKeyMap::value_type& pMasterKey, mapMasterKeys)\n         {\n             if(!crypter.SetKeyFromPassphrase(strWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n@@ -61,16 +60,15 @@ bool CWallet::Unlock(const string& strWalletPassphrase)\n             if (CCryptoKeyStore::Unlock(vMasterKey))\n                 return true;\n         }\n-    }\n     return false;\n }\n \n bool CWallet::ChangeWalletPassphrase(const string& strOldWalletPassphrase, const string& strNewWalletPassphrase)\n {\n-    CRITICAL_BLOCK(cs_vMasterKey)\n-    {\n-        bool fWasLocked = IsLocked();\n+    bool fWasLocked = IsLocked();\n \n+    CRITICAL_BLOCK(cs_wallet)\n+    {\n         Lock();\n \n         CCrypter crypter;\n@@ -79,7 +77,7 @@ bool CWallet::ChangeWalletPassphrase(const string& strOldWalletPassphrase, const\n         {\n             if(!crypter.SetKeyFromPassphrase(strOldWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n                 return false;\n-            if(!crypter.Decrypt(pMasterKey.second.vchCryptedKey, vMasterKey))\n+            if (!crypter.Decrypt(pMasterKey.second.vchCryptedKey, vMasterKey))\n                 return false;\n             if (CCryptoKeyStore::Unlock(vMasterKey))\n             {\n@@ -107,6 +105,7 @@ bool CWallet::ChangeWalletPassphrase(const string& strOldWalletPassphrase, const\n             }\n         }\n     }\n+\n     return false;\n }\n \n@@ -125,44 +124,42 @@ class CCorruptAddress\n \n bool CWallet::EncryptWallet(const string& strWalletPassphrase)\n {\n-    CRITICAL_BLOCK(cs_KeyStore)\n-    CRITICAL_BLOCK(cs_vMasterKey)\n-    CRITICAL_BLOCK(cs_pwalletdbEncryption)\n-    {\n-        if (IsCrypted())\n-            return false;\n+    if (IsCrypted())\n+        return false;\n \n-        CKeyingMaterial vMasterKey;\n-        RandAddSeedPerfmon();\n+    CKeyingMaterial vMasterKey;\n+    RandAddSeedPerfmon();\n \n-        vMasterKey.resize(WALLET_CRYPTO_KEY_SIZE);\n-        RAND_bytes(&vMasterKey[0], WALLET_CRYPTO_KEY_SIZE);\n+    vMasterKey.resize(WALLET_CRYPTO_KEY_SIZE);\n+    RAND_bytes(&vMasterKey[0], WALLET_CRYPTO_KEY_SIZE);\n \n-        CMasterKey kMasterKey;\n+    CMasterKey kMasterKey;\n \n-        RandAddSeedPerfmon();\n-        kMasterKey.vchSalt.resize(WALLET_CRYPTO_SALT_SIZE);\n-        RAND_bytes(&kMasterKey.vchSalt[0], WALLET_CRYPTO_SALT_SIZE);\n+    RandAddSeedPerfmon();\n+    kMasterKey.vchSalt.resize(WALLET_CRYPTO_SALT_SIZE);\n+    RAND_bytes(&kMasterKey.vchSalt[0], WALLET_CRYPTO_SALT_SIZE);\n \n-        CCrypter crypter;\n-        int64 nStartTime = GetTimeMillis();\n-        crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, 25000, kMasterKey.nDerivationMethod);\n-        kMasterKey.nDeriveIterations = 2500000 / ((double)(GetTimeMillis() - nStartTime));\n+    CCrypter crypter;\n+    int64 nStartTime = GetTimeMillis();\n+    crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, 25000, kMasterKey.nDerivationMethod);\n+    kMasterKey.nDeriveIterations = 2500000 / ((double)(GetTimeMillis() - nStartTime));\n \n-        nStartTime = GetTimeMillis();\n-        crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, kMasterKey.nDeriveIterations, kMasterKey.nDerivationMethod);\n-        kMasterKey.nDeriveIterations = (kMasterKey.nDeriveIterations + kMasterKey.nDeriveIterations * 100 / ((double)(GetTimeMillis() - nStartTime))) / 2;\n+    nStartTime = GetTimeMillis();\n+    crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, kMasterKey.nDeriveIterations, kMasterKey.nDerivationMethod);\n+    kMasterKey.nDeriveIterations = (kMasterKey.nDeriveIterations + kMasterKey.nDeriveIterations * 100 / ((double)(GetTimeMillis() - nStartTime))) / 2;\n \n-        if (kMasterKey.nDeriveIterations < 25000)\n-            kMasterKey.nDeriveIterations = 25000;\n+    if (kMasterKey.nDeriveIterations < 25000)\n+        kMasterKey.nDeriveIterations = 25000;\n \n-        printf(\"Encrypting Wallet with an nDeriveIterations of %i\\n\", kMasterKey.nDeriveIterations);\n+    printf(\"Encrypting Wallet with an nDeriveIterations of %i\\n\", kMasterKey.nDeriveIterations);\n \n-        if (!crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, kMasterKey.nDeriveIterations, kMasterKey.nDerivationMethod))\n-            return false;\n-        if (!crypter.Encrypt(vMasterKey, kMasterKey.vchCryptedKey))\n-            return false;\n+    if (!crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, kMasterKey.nDeriveIterations, kMasterKey.nDerivationMethod))\n+        return false;\n+    if (!crypter.Encrypt(vMasterKey, kMasterKey.vchCryptedKey))\n+        return false;\n \n+    CRITICAL_BLOCK(cs_wallet)\n+    {\n         mapMasterKeys[++nMasterKeyMaxID] = kMasterKey;\n         if (fFileBacked)\n         {\n@@ -191,6 +188,7 @@ bool CWallet::EncryptWallet(const string& strWalletPassphrase)\n \n         Lock();\n     }\n+\n     return true;\n }\n \n@@ -199,7 +197,7 @@ void CWallet::WalletUpdateSpent(const CTransaction &tx)\n     // Anytime a signature is successfully verified, it's proof the outpoint is spent.\n     // Update the wallet spent flag if it doesn't know due to wallet.dat being\n     // restored from backup or the user making copies of wallet.dat.\n-    CRITICAL_BLOCK(cs_mapWallet)\n+    CRITICAL_BLOCK(cs_wallet)\n     {\n         BOOST_FOREACH(const CTxIn& txin, tx.vin)\n         {\n@@ -222,7 +220,7 @@ void CWallet::WalletUpdateSpent(const CTransaction &tx)\n bool CWallet::AddToWallet(const CWalletTx& wtxIn)\n {\n     uint256 hash = wtxIn.GetHash();\n-    CRITICAL_BLOCK(cs_mapWallet)\n+    CRITICAL_BLOCK(cs_wallet)\n     {\n         // Inserts only if not already there, returns tx inserted or tx found\n         pair<map<uint256, CWalletTx>::iterator, bool> ret = mapWallet.insert(make_pair(hash, wtxIn));\n@@ -290,26 +288,29 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn)\n bool CWallet::AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pblock, bool fUpdate)\n {\n     uint256 hash = tx.GetHash();\n-    bool fExisted = mapWallet.count(hash);\n-    if (fExisted && !fUpdate) return false;\n-    if (fExisted || IsMine(tx) || IsFromMe(tx))\n+    CRITICAL_BLOCK(cs_wallet)\n     {\n-        CWalletTx wtx(this,tx);\n-        // Get merkle branch if transaction was found in a block\n-        if (pblock)\n-            wtx.SetMerkleBranch(pblock);\n-        return AddToWallet(wtx);\n+        bool fExisted = mapWallet.count(hash);\n+        if (fExisted && !fUpdate) return false;\n+        if (fExisted || IsMine(tx) || IsFromMe(tx))\n+        {\n+            CWalletTx wtx(this,tx);\n+            // Get merkle branch if transaction was found in a block\n+            if (pblock)\n+                wtx.SetMerkleBranch(pblock);\n+            return AddToWallet(wtx);\n+        }\n+        else\n+            WalletUpdateSpent(tx);\n     }\n-    else\n-        WalletUpdateSpent(tx);\n     return false;\n }\n \n bool CWallet::EraseFromWallet(uint256 hash)\n {\n     if (!fFileBacked)\n         return false;\n-    CRITICAL_BLOCK(cs_mapWallet)\n+    CRITICAL_BLOCK(cs_wallet)\n     {\n         if (mapWallet.erase(hash))\n             CWalletDB(strWalletFile).EraseTx(hash);\n@@ -320,7 +321,7 @@ bool CWallet::EraseFromWallet(uint256 hash)\n \n bool CWallet::IsMine(const CTxIn &txin) const\n {\n-    CRITICAL_BLOCK(cs_mapWallet)\n+    CRITICAL_BLOCK(cs_wallet)\n     {\n         map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n         if (mi != mapWallet.end())\n@@ -336,7 +337,7 @@ bool CWallet::IsMine(const CTxIn &txin) const\n \n int64 CWallet::GetDebit(const CTxIn &txin) const\n {\n-    CRITICAL_BLOCK(cs_mapWallet)\n+    CRITICAL_BLOCK(cs_wallet)\n     {\n         map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n         if (mi != mapWallet.end())\n@@ -352,17 +353,20 @@ int64 CWallet::GetDebit(const CTxIn &txin) const\n \n int64 CWalletTx::GetTxTime() const\n {\n-    if (!fTimeReceivedIsTxTime && hashBlock != 0)\n+    CRITICAL_BLOCK(cs_main)\n     {\n-        // If we did not receive the transaction directly, we rely on the block's\n-        // time to figure out when it happened.  We use the median over a range\n-        // of blocks to try to filter out inaccurate block times.\n-        map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n-        if (mi != mapBlockIndex.end())\n+        if (!fTimeReceivedIsTxTime && hashBlock != 0)\n         {\n-            CBlockIndex* pindex = (*mi).second;\n-            if (pindex)\n-                return pindex->GetMedianTime();\n+            // If we did not receive the transaction directly, we rely on the block's\n+            // time to figure out when it happened.  We use the median over a range\n+            // of blocks to try to filter out inaccurate block times.\n+            map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n+            if (mi != mapBlockIndex.end())\n+            {\n+                CBlockIndex* pindex = (*mi).second;\n+                if (pindex)\n+                    return pindex->GetMedianTime();\n+            }\n         }\n     }\n     return nTimeReceived;\n@@ -372,7 +376,7 @@ int CWalletTx::GetRequestCount() const\n {\n     // Returns -1 if it wasn't being tracked\n     int nRequests = -1;\n-    CRITICAL_BLOCK(pwallet->cs_mapRequestCount)\n+    CRITICAL_BLOCK(pwallet->cs_wallet)\n     {\n         if (IsCoinBase())\n         {\n@@ -478,7 +482,7 @@ void CWalletTx::GetAccountAmounts(const string& strAccount, int64& nGenerated, i\n             nSent += s.second;\n         nFee = allFee;\n     }\n-    CRITICAL_BLOCK(pwallet->cs_mapAddressBook)\n+    CRITICAL_BLOCK(pwallet->cs_wallet)\n     {\n         BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress,int64)& r, listReceived)\n         {\n@@ -508,7 +512,7 @@ void CWalletTx::AddSupportingTransactions(CTxDB& txdb)\n             vWorkQueue.push_back(txin.prevout.hash);\n \n         // This critsect is OK because txdb is already open\n-        CRITICAL_BLOCK(pwallet->cs_mapWallet)\n+        CRITICAL_BLOCK(pwallet->cs_wallet)\n         {\n             map<uint256, const CMerkleTx*> mapWalletPrev;\n             set<uint256> setAlreadyDone;\n@@ -564,7 +568,7 @@ int CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n     int ret = 0;\n \n     CBlockIndex* pindex = pindexStart;\n-    CRITICAL_BLOCK(cs_mapWallet)\n+    CRITICAL_BLOCK(cs_wallet)\n     {\n         while (pindex)\n         {\n@@ -585,7 +589,7 @@ void CWallet::ReacceptWalletTransactions()\n {\n     CTxDB txdb(\"r\");\n     bool fRepeat = true;\n-    while (fRepeat) CRITICAL_BLOCK(cs_mapWallet)\n+    while (fRepeat) CRITICAL_BLOCK(cs_wallet)\n     {\n         fRepeat = false;\n         vector<CDiskTxPos> vMissingTx;\n@@ -688,7 +692,7 @@ void CWallet::ResendWalletTransactions()\n     // Rebroadcast any of our txes that aren't in a block yet\n     printf(\"ResendWalletTransactions()\\n\");\n     CTxDB txdb(\"r\");\n-    CRITICAL_BLOCK(cs_mapWallet)\n+    CRITICAL_BLOCK(cs_wallet)\n     {\n         // Sort them in chronological order\n         multimap<unsigned int, CWalletTx*> mapSorted;\n@@ -722,7 +726,7 @@ void CWallet::ResendWalletTransactions()\n int64 CWallet::GetBalance() const\n {\n     int64 nTotal = 0;\n-    CRITICAL_BLOCK(cs_mapWallet)\n+    CRITICAL_BLOCK(cs_wallet)\n     {\n         for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n@@ -749,7 +753,7 @@ bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfThe\n     vector<pair<int64, pair<const CWalletTx*,unsigned int> > > vValue;\n     int64 nTotalLower = 0;\n \n-    CRITICAL_BLOCK(cs_mapWallet)\n+    CRITICAL_BLOCK(cs_wallet)\n     {\n        vector<const CWalletTx*> vCoins;\n        vCoins.reserve(mapWallet.size());\n@@ -907,10 +911,10 @@ bool CWallet::CreateTransaction(const vector<pair<CScript, int64> >& vecSend, CW\n     wtxNew.pwallet = this;\n \n     CRITICAL_BLOCK(cs_main)\n+    CRITICAL_BLOCK(cs_wallet)\n     {\n         // txdb must be opened before the mapWallet lock\n         CTxDB txdb(\"r\");\n-        CRITICAL_BLOCK(cs_mapWallet)\n         {\n             nFeeRet = nTransactionFee;\n             loop\n@@ -1021,9 +1025,9 @@ bool CWallet::CreateTransaction(CScript scriptPubKey, int64 nValue, CWalletTx& w\n bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n {\n     CRITICAL_BLOCK(cs_main)\n+    CRITICAL_BLOCK(cs_wallet)\n     {\n         printf(\"CommitTransaction:\\n%s\", wtxNew.ToString().c_str());\n-        CRITICAL_BLOCK(cs_mapWallet)\n         {\n             // This is only to keep the database open to defeat the auto-flush for the\n             // duration of this scope.  This is the only place where this optimization\n@@ -1053,8 +1057,7 @@ bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n         }\n \n         // Track how many getdata requests our transaction gets\n-        CRITICAL_BLOCK(cs_mapRequestCount)\n-            mapRequestCount[wtxNew.GetHash()] = 0;\n+        mapRequestCount[wtxNew.GetHash()] = 0;\n \n         // Broadcast\n         if (!wtxNew.AcceptToMemoryPool())\n@@ -1072,29 +1075,26 @@ bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n \n \n \n-// requires cs_main lock\n string CWallet::SendMoney(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, bool fAskFee)\n {\n     CReserveKey reservekey(this);\n     int64 nFeeRequired;\n-    CRITICAL_BLOCK(cs_vMasterKey)\n+\n+    if (IsLocked())\n     {\n-        if (IsLocked())\n-        {\n-            string strError = _(\"Error: Wallet locked, unable to create transaction  \");\n-            printf(\"SendMoney() : %s\", strError.c_str());\n-            return strError;\n-        }\n-        if (!CreateTransaction(scriptPubKey, nValue, wtxNew, reservekey, nFeeRequired))\n-        {\n-            string strError;\n-            if (nValue + nFeeRequired > GetBalance())\n-                strError = strprintf(_(\"Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds  \"), FormatMoney(nFeeRequired).c_str());\n-            else\n-                strError = _(\"Error: Transaction creation failed  \");\n-            printf(\"SendMoney() : %s\", strError.c_str());\n-            return strError;\n-        }\n+        string strError = _(\"Error: Wallet locked, unable to create transaction  \");\n+        printf(\"SendMoney() : %s\", strError.c_str());\n+        return strError;\n+    }\n+    if (!CreateTransaction(scriptPubKey, nValue, wtxNew, reservekey, nFeeRequired))\n+    {\n+        string strError;\n+        if (nValue + nFeeRequired > GetBalance())\n+            strError = strprintf(_(\"Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds  \"), FormatMoney(nFeeRequired).c_str());\n+        else\n+            strError = _(\"Error: Transaction creation failed  \");\n+        printf(\"SendMoney() : %s\", strError.c_str());\n+        return strError;\n     }\n \n     if (fAskFee && !ThreadSafeAskFee(nFeeRequired, _(\"Sending...\"), NULL))\n@@ -1109,7 +1109,6 @@ string CWallet::SendMoney(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew,\n \n \n \n-// requires cs_main lock\n string CWallet::SendMoneyToBitcoinAddress(const CBitcoinAddress& address, int64 nValue, CWalletTx& wtxNew, bool fAskFee)\n {\n     // Check amount\n@@ -1172,7 +1171,7 @@ bool CWallet::DelAddressBookName(const CBitcoinAddress& address)\n \n void CWallet::PrintWallet(const CBlock& block)\n {\n-    CRITICAL_BLOCK(cs_mapWallet)\n+    CRITICAL_BLOCK(cs_wallet)\n     {\n         if (mapWallet.count(block.vtx[0].GetHash()))\n         {\n@@ -1185,7 +1184,7 @@ void CWallet::PrintWallet(const CBlock& block)\n \n bool CWallet::GetTransaction(const uint256 &hashTx, CWalletTx& wtx)\n {\n-    CRITICAL_BLOCK(cs_mapWallet)\n+    CRITICAL_BLOCK(cs_wallet)\n     {\n         map<uint256, CWalletTx>::iterator mi = mapWallet.find(hashTx);\n         if (mi != mapWallet.end())\n@@ -1218,10 +1217,7 @@ bool GetWalletFile(CWallet* pwallet, string &strWalletFileOut)\n \n bool CWallet::TopUpKeyPool()\n {\n-    CRITICAL_BLOCK(cs_main)\n-    CRITICAL_BLOCK(cs_mapWallet)\n-    CRITICAL_BLOCK(cs_setKeyPool)\n-    CRITICAL_BLOCK(cs_vMasterKey)\n+    CRITICAL_BLOCK(cs_wallet)\n     {\n         if (IsLocked())\n             return false;\n@@ -1248,9 +1244,7 @@ void CWallet::ReserveKeyFromKeyPool(int64& nIndex, CKeyPool& keypool)\n {\n     nIndex = -1;\n     keypool.vchPubKey.clear();\n-    CRITICAL_BLOCK(cs_main)\n-    CRITICAL_BLOCK(cs_mapWallet)\n-    CRITICAL_BLOCK(cs_setKeyPool)\n+    CRITICAL_BLOCK(cs_wallet)\n     {\n         if (!IsLocked())\n             TopUpKeyPool();\n@@ -1278,18 +1272,15 @@ void CWallet::KeepKey(int64 nIndex)\n     if (fFileBacked)\n     {\n         CWalletDB walletdb(strWalletFile);\n-        CRITICAL_BLOCK(cs_main)\n-        {\n-            walletdb.ErasePool(nIndex);\n-        }\n+        walletdb.ErasePool(nIndex);\n     }\n     printf(\"keypool keep %\"PRI64d\"\\n\", nIndex);\n }\n \n void CWallet::ReturnKey(int64 nIndex)\n {\n     // Return to key pool\n-    CRITICAL_BLOCK(cs_setKeyPool)\n+    CRITICAL_BLOCK(cs_wallet)\n         setKeyPool.insert(nIndex);\n     printf(\"keypool return %\"PRI64d\"\\n\", nIndex);\n }"
      },
      {
        "sha": "032284dd3a7aee9541b7f6a8dc9d39a344cdf632",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 5,
        "deletions": 10,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6cc4a62c0e696dcb9d90ba0504f688e4f644a10f/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6cc4a62c0e696dcb9d90ba0504f688e4f644a10f/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=6cc4a62c0e696dcb9d90ba0504f688e4f644a10f",
        "patch": "@@ -20,14 +20,14 @@ class CWallet : public CCryptoKeyStore\n     bool SelectCoins(int64 nTargetValue, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const;\n \n     CWalletDB *pwalletdbEncryption;\n-    CCriticalSection cs_pwalletdbEncryption;\n \n public:\n+    mutable CCriticalSection cs_wallet;\n+\n     bool fFileBacked;\n     std::string strWalletFile;\n \n     std::set<int64> setKeyPool;\n-    CCriticalSection cs_setKeyPool;\n \n     typedef std::map<unsigned int, CMasterKey> MasterKeyMap;\n     MasterKeyMap mapMasterKeys;\n@@ -47,15 +47,12 @@ class CWallet : public CCryptoKeyStore\n         pwalletdbEncryption = NULL;\n     }\n \n-    mutable CCriticalSection cs_mapWallet;\n     std::map<uint256, CWalletTx> mapWallet;\n     std::vector<uint256> vWalletUpdated;\n \n     std::map<uint256, int> mapRequestCount;\n-    mutable CCriticalSection cs_mapRequestCount;\n \n     std::map<CBitcoinAddress, std::string> mapAddressBook;\n-    mutable CCriticalSection cs_mapAddressBook;\n \n     std::vector<unsigned char> vchDefaultKey;\n \n@@ -107,7 +104,7 @@ class CWallet : public CCryptoKeyStore\n     {\n         CBitcoinAddress address;\n         if (ExtractAddress(txout.scriptPubKey, this, address))\n-            CRITICAL_BLOCK(cs_mapAddressBook)\n+            CRITICAL_BLOCK(cs_wallet)\n                 if (!mapAddressBook.count(address))\n                     return true;\n         return false;\n@@ -171,23 +168,21 @@ class CWallet : public CCryptoKeyStore\n     int LoadWallet(bool& fFirstRunRet);\n //    bool BackupWallet(const std::string& strDest);\n \n-    // requires cs_mapAddressBook lock\n     bool SetAddressBookName(const CBitcoinAddress& address, const std::string& strName);\n \n-    // requires cs_mapAddressBook lock\n     bool DelAddressBookName(const CBitcoinAddress& address);\n \n     void UpdatedTransaction(const uint256 &hashTx)\n     {\n-        CRITICAL_BLOCK(cs_mapWallet)\n+        CRITICAL_BLOCK(cs_wallet)\n             vWalletUpdated.push_back(hashTx);\n     }\n \n     void PrintWallet(const CBlock& block);\n \n     void Inventory(const uint256 &hash)\n     {\n-        CRITICAL_BLOCK(cs_mapRequestCount)\n+        CRITICAL_BLOCK(cs_wallet)\n         {\n             std::map<uint256, int>::iterator mi = mapRequestCount.find(hash);\n             if (mi != mapRequestCount.end())"
      }
    ]
  },
  {
    "sha": "471426fb3b2c2fa37640c03819c4f7be69ba8301",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NzE0MjZmYjNiMmMyZmEzNzY0MGMwMzgxOWM0ZjdiZTY5YmE4MzAx",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-08-31T16:27:19Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-08-31T16:55:16Z"
      },
      "message": "Fixed potential deadlocks in GUI code.\nAlso changed semantics of CWalletTx::GetTxTime(); now always returns the time the transaction was received by this node, not the average block time.\nAnd added information about -DDEBUG_LOCKORDER to coding.txt.",
      "tree": {
        "sha": "cc9de8e932d07cf2549a625e6c614a2677ec1b0e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cc9de8e932d07cf2549a625e6c614a2677ec1b0e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/471426fb3b2c2fa37640c03819c4f7be69ba8301",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/471426fb3b2c2fa37640c03819c4f7be69ba8301",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/471426fb3b2c2fa37640c03819c4f7be69ba8301",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/471426fb3b2c2fa37640c03819c4f7be69ba8301/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6cc4a62c0e696dcb9d90ba0504f688e4f644a10f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6cc4a62c0e696dcb9d90ba0504f688e4f644a10f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6cc4a62c0e696dcb9d90ba0504f688e4f644a10f"
      }
    ],
    "stats": {
      "total": 418,
      "additions": 223,
      "deletions": 195
    },
    "files": [
      {
        "sha": "ec31ccded228ee8a3ccad1ecdebcf67e7976d202",
        "filename": "doc/coding.txt",
        "status": "modified",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/471426fb3b2c2fa37640c03819c4f7be69ba8301/doc/coding.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/471426fb3b2c2fa37640c03819c4f7be69ba8301/doc/coding.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/coding.txt?ref=471426fb3b2c2fa37640c03819c4f7be69ba8301",
        "patch": "@@ -39,3 +39,47 @@ v       vector or similar list objects\n map     map or multimap\r\n set     set or multiset\r\n bn      CBigNum\r\n+\r\n+-------------------------\r\n+Locking/mutex usage notes\r\n+\r\n+The code is multi-threaded, and uses mutexes and the CRITICAL_BLOCK/TRY_CRITICAL_BLOCK macros to protect data structures.\r\n+\r\n+Deadlocks due to inconsistent lock ordering (thread 1 locks cs_main and then cs_wallet, while thread 2 locks them in the opposite order: result, deadlock as each waits for the other to release its lock) are a problem. Compile with -DDEBUG_LOCKORDER to get lock order inconsistencies reported in the debug.log file.\r\n+\r\n+Re-architecting the core code so there are better-defined interfaces between the various components is a goal, with any necessary locking done by the components (e.g. see the self-contained CKeyStore class and its cs_KeyStore lock for example).\r\n+\r\n+-------\r\n+Threads\r\n+\r\n+StartNode : Starts other threads.\r\n+\r\n+ThreadGetMyExternalIP : Determines outside-the-firewall IP address, sends addr message to connected peers when it determines it.\r\n+\r\n+ThreadIRCSeed : Joins IRC bootstrapping channel, watching for new peers and advertising this node's IP address.\r\n+\r\n+ThreadSocketHandler : Sends/Receives data from peers on port 8333.\r\n+\r\n+ThreadMessageHandler : Higher-level message handling (sending and receiving).\r\n+\r\n+ThreadOpenConnections : Initiates new connections to peers.\r\n+\r\n+ThreadTopUpKeyPool : replenishes the keystore's keypool.\r\n+\r\n+ThreadCleanWalletPassphrase : re-locks an encrypted wallet after user has unlocked it for a period of time.\r\n+\r\n+SendingDialogStartTransfer : used by pay-via-ip-address code (obsolete)\r\n+\r\n+ThreadDelayedRepaint : repaint the gui \r\n+\r\n+ThreadFlushWalletDB : Close the wallet.dat file if it hasn't been used in 500ms.\r\n+\r\n+ThreadRPCServer : Remote procedure call handler, listens on port 8332 for connections and services them.\r\n+\r\n+ThreadBitcoinMiner : Generates bitcoins\r\n+\r\n+ThreadMapPort : Universal plug-and-play startup/shutdown\r\n+\r\n+Shutdown : Does an orderly shutdown of everything\r\n+\r\n+ExitTimeout : Windows-only, sleeps 5 seconds then exits application\r"
      },
      {
        "sha": "5ca666192a5a6bfe9566990210b372034d4a86ac",
        "filename": "src/ui.cpp",
        "status": "modified",
        "additions": 179,
        "deletions": 179,
        "changes": 358,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/471426fb3b2c2fa37640c03819c4f7be69ba8301/src/ui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/471426fb3b2c2fa37640c03819c4f7be69ba8301/src/ui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ui.cpp?ref=471426fb3b2c2fa37640c03819c4f7be69ba8301",
        "patch": "@@ -708,7 +708,7 @@ bool CMainFrame::InsertTransaction(const CWalletTx& wtx, bool fNew, int nIndex)\n                     CBitcoinAddress address;\n                     if (ExtractAddress(txout.scriptPubKey, pwalletMain, address))\n                     {\n-                        CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n+                        CRITICAL_BLOCK(pwalletMain->cs_wallet)\n                         {\n                             //strDescription += _(\"Received payment to \");\n                             //strDescription += _(\"Received with address \");\n@@ -792,7 +792,7 @@ bool CMainFrame::InsertTransaction(const CWalletTx& wtx, bool fNew, int nIndex)\n                 }\n \n                 string strDescription = _(\"To: \");\n-                CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n+                CRITICAL_BLOCK(pwalletMain->cs_wallet)\n                     if (pwalletMain->mapAddressBook.count(address) && !pwalletMain->mapAddressBook[address].empty())\n                         strDescription += pwalletMain->mapAddressBook[address] + \" \";\n                 strDescription += strAddress;\n@@ -1032,6 +1032,7 @@ void MainFrameRepaint()\n         printf(\"MainFrameRepaint\\n\");\n         wxPaintEvent event;\n         pframeMain->fRefresh = true;\n+        pframeMain->fRefreshListCtrl = true;\n         pframeMain->GetEventHandler()->AddPendingEvent(event);\n     }\n }\n@@ -1247,83 +1248,80 @@ void CMainFrame::OnMenuOptionsChangeWalletPassphrase(wxCommandEvent& event)\n     strOldWalletPass = wxGetPasswordFromUser(_(\"Enter the current passphrase to the wallet.\"),\n                                              _(\"Passphrase\")).ToStdString();\n \n-    CRITICAL_BLOCK(pwalletMain->cs_vMasterKey)\n-    {\n-        bool fWasLocked = pwalletMain->IsLocked();\n-        pwalletMain->Lock();\n+    bool fWasLocked = pwalletMain->IsLocked();\n+    pwalletMain->Lock();\n \n-        if (!strOldWalletPass.size() || !pwalletMain->Unlock(strOldWalletPass))\n-        {\n-            fill(strOldWalletPass.begin(), strOldWalletPass.end(), '\\0');\n-            munlock(&strOldWalletPass[0], strOldWalletPass.capacity());\n-            wxMessageBox(_(\"The passphrase entered for the wallet decryption was incorrect.\"), \"Bitcoin\", wxOK | wxICON_ERROR);\n-            return;\n-        }\n+    if (!strOldWalletPass.size() || !pwalletMain->Unlock(strOldWalletPass))\n+    {\n+        fill(strOldWalletPass.begin(), strOldWalletPass.end(), '\\0');\n+        munlock(&strOldWalletPass[0], strOldWalletPass.capacity());\n+        wxMessageBox(_(\"The passphrase entered for the wallet decryption was incorrect.\"), \"Bitcoin\", wxOK | wxICON_ERROR);\n+        return;\n+    }\n \n-        if (fWasLocked)\n-            pwalletMain->Lock();\n+    if (fWasLocked)\n+        pwalletMain->Lock();\n \n-        string strNewWalletPass;\n-        strNewWalletPass.reserve(100);\n-        mlock(&strNewWalletPass[0], strNewWalletPass.capacity());\n+    string strNewWalletPass;\n+    strNewWalletPass.reserve(100);\n+    mlock(&strNewWalletPass[0], strNewWalletPass.capacity());\n \n-        // obtain new wallet encrypt/decrypt key, from passphrase\n-        // Note that the passphrase is not mlock()d during this entry and could potentially\n-        // be obtained from disk long after bitcoin has run.\n-        strNewWalletPass = wxGetPasswordFromUser(_(\"Enter the new passphrase for the wallet.\"),\n-                                                 _(\"Passphrase\")).ToStdString();\n+    // obtain new wallet encrypt/decrypt key, from passphrase\n+    // Note that the passphrase is not mlock()d during this entry and could potentially\n+    // be obtained from disk long after bitcoin has run.\n+    strNewWalletPass = wxGetPasswordFromUser(_(\"Enter the new passphrase for the wallet.\"),\n+                                             _(\"Passphrase\")).ToStdString();\n \n-        if (!strNewWalletPass.size())\n-        {\n-            fill(strOldWalletPass.begin(), strOldWalletPass.end(), '\\0');\n-            fill(strNewWalletPass.begin(), strNewWalletPass.end(), '\\0');\n-            munlock(&strOldWalletPass[0], strOldWalletPass.capacity());\n-            munlock(&strNewWalletPass[0], strNewWalletPass.capacity());\n-            wxMessageBox(_(\"Error: The supplied passphrase was too short.\"), \"Bitcoin\", wxOK | wxICON_ERROR);\n-            return;\n-        }\n+    if (!strNewWalletPass.size())\n+    {\n+        fill(strOldWalletPass.begin(), strOldWalletPass.end(), '\\0');\n+        fill(strNewWalletPass.begin(), strNewWalletPass.end(), '\\0');\n+        munlock(&strOldWalletPass[0], strOldWalletPass.capacity());\n+        munlock(&strNewWalletPass[0], strNewWalletPass.capacity());\n+        wxMessageBox(_(\"Error: The supplied passphrase was too short.\"), \"Bitcoin\", wxOK | wxICON_ERROR);\n+        return;\n+    }\n \n-        string strNewWalletPassTest;\n-        strNewWalletPassTest.reserve(100);\n-        mlock(&strNewWalletPassTest[0], strNewWalletPassTest.capacity());\n+    string strNewWalletPassTest;\n+    strNewWalletPassTest.reserve(100);\n+    mlock(&strNewWalletPassTest[0], strNewWalletPassTest.capacity());\n \n-        // obtain new wallet encrypt/decrypt key, from passphrase\n-        // Note that the passphrase is not mlock()d during this entry and could potentially\n-        // be obtained from disk long after bitcoin has run.\n-        strNewWalletPassTest = wxGetPasswordFromUser(_(\"Re-enter the new passphrase for the wallet.\"),\n-                                                     _(\"Passphrase\")).ToStdString();\n+    // obtain new wallet encrypt/decrypt key, from passphrase\n+    // Note that the passphrase is not mlock()d during this entry and could potentially\n+    // be obtained from disk long after bitcoin has run.\n+    strNewWalletPassTest = wxGetPasswordFromUser(_(\"Re-enter the new passphrase for the wallet.\"),\n+                                                 _(\"Passphrase\")).ToStdString();\n \n-        if (strNewWalletPassTest != strNewWalletPass)\n-        {\n-            fill(strOldWalletPass.begin(), strOldWalletPass.end(), '\\0');\n-            fill(strNewWalletPass.begin(), strNewWalletPass.end(), '\\0');\n-            fill(strNewWalletPassTest.begin(), strNewWalletPassTest.end(), '\\0');\n-            munlock(&strOldWalletPass[0], strOldWalletPass.capacity());\n-            munlock(&strNewWalletPass[0], strNewWalletPass.capacity());\n-            munlock(&strNewWalletPassTest[0], strNewWalletPassTest.capacity());\n-            wxMessageBox(_(\"Error: the supplied passphrases didn't match.\"), \"Bitcoin\", wxOK | wxICON_ERROR);\n-            return;\n-        }\n+    if (strNewWalletPassTest != strNewWalletPass)\n+    {\n+        fill(strOldWalletPass.begin(), strOldWalletPass.end(), '\\0');\n+        fill(strNewWalletPass.begin(), strNewWalletPass.end(), '\\0');\n+        fill(strNewWalletPassTest.begin(), strNewWalletPassTest.end(), '\\0');\n+        munlock(&strOldWalletPass[0], strOldWalletPass.capacity());\n+        munlock(&strNewWalletPass[0], strNewWalletPass.capacity());\n+        munlock(&strNewWalletPassTest[0], strNewWalletPassTest.capacity());\n+        wxMessageBox(_(\"Error: the supplied passphrases didn't match.\"), \"Bitcoin\", wxOK | wxICON_ERROR);\n+        return;\n+    }\n \n-        if (!pwalletMain->ChangeWalletPassphrase(strOldWalletPass, strNewWalletPass))\n-        {\n-            fill(strOldWalletPass.begin(), strOldWalletPass.end(), '\\0');\n-            fill(strNewWalletPass.begin(), strNewWalletPass.end(), '\\0');\n-            fill(strNewWalletPassTest.begin(), strNewWalletPassTest.end(), '\\0');\n-            munlock(&strOldWalletPass[0], strOldWalletPass.capacity());\n-            munlock(&strNewWalletPass[0], strNewWalletPass.capacity());\n-            munlock(&strNewWalletPassTest[0], strNewWalletPassTest.capacity());\n-            wxMessageBox(_(\"The passphrase entered for the wallet decryption was incorrect.\"), \"Bitcoin\", wxOK | wxICON_ERROR);\n-            return;\n-        }\n+    if (!pwalletMain->ChangeWalletPassphrase(strOldWalletPass, strNewWalletPass))\n+    {\n         fill(strOldWalletPass.begin(), strOldWalletPass.end(), '\\0');\n         fill(strNewWalletPass.begin(), strNewWalletPass.end(), '\\0');\n         fill(strNewWalletPassTest.begin(), strNewWalletPassTest.end(), '\\0');\n         munlock(&strOldWalletPass[0], strOldWalletPass.capacity());\n         munlock(&strNewWalletPass[0], strNewWalletPass.capacity());\n         munlock(&strNewWalletPassTest[0], strNewWalletPassTest.capacity());\n-        wxMessageBox(_(\"Wallet Passphrase Changed.\"), \"Bitcoin\");\n+        wxMessageBox(_(\"The passphrase entered for the wallet decryption was incorrect.\"), \"Bitcoin\", wxOK | wxICON_ERROR);\n+        return;\n     }\n+    fill(strOldWalletPass.begin(), strOldWalletPass.end(), '\\0');\n+    fill(strNewWalletPass.begin(), strNewWalletPass.end(), '\\0');\n+    fill(strNewWalletPassTest.begin(), strNewWalletPassTest.end(), '\\0');\n+    munlock(&strOldWalletPass[0], strOldWalletPass.capacity());\n+    munlock(&strNewWalletPass[0], strNewWalletPass.capacity());\n+    munlock(&strNewWalletPassTest[0], strNewWalletPassTest.capacity());\n+    wxMessageBox(_(\"Wallet Passphrase Changed.\"), \"Bitcoin\");\n }\n \n void CMainFrame::OnMenuOptionsOptions(wxCommandEvent& event)\n@@ -1387,21 +1385,19 @@ void CMainFrame::OnButtonNew(wxCommandEvent& event)\n     string strName = dialog.GetValue();\n \n     string strAddress;\n-    CRITICAL_BLOCK(pwalletMain->cs_vMasterKey)\n-    {\n-        bool fWasLocked = pwalletMain->IsLocked();\n-        if (!GetWalletPassphrase())\n-            return;\n \n-        // Generate new key\n-        strAddress = CBitcoinAddress(pwalletMain->GetOrReuseKeyFromPool()).ToString();\n+    bool fWasLocked = pwalletMain->IsLocked();\n+    if (!GetWalletPassphrase())\n+        return;\n \n-        if (fWasLocked)\n-            pwalletMain->Lock();\n-    }\n+    // Generate new key\n+    strAddress = CBitcoinAddress(pwalletMain->GetOrReuseKeyFromPool()).ToString();\n+\n+    if (fWasLocked)\n+        pwalletMain->Lock();\n \n     // Save\n-    CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n+    CRITICAL_BLOCK(pwalletMain->cs_wallet)\n         pwalletMain->SetAddressBookName(strAddress, strName);\n     SetDefaultReceivingAddress(strAddress);\n }\n@@ -1451,7 +1447,7 @@ CTxDetailsDialog::CTxDetailsDialog(wxWindow* parent, CWalletTx wtx) : CTxDetails\n #ifdef __WXMSW__\n     SetSize(nScaleX * GetSize().GetWidth(), nScaleY * GetSize().GetHeight());\n #endif\n-    CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n+    CRITICAL_BLOCK(pwalletMain->cs_wallet)\n     {\n         string strHTML;\n         strHTML.reserve(4000);\n@@ -2160,38 +2156,39 @@ void CSendDialog::OnButtonSend(wxCommandEvent& event)\n \n         if (fBitcoinAddress)\n         {\n+            bool fWasLocked = pwalletMain->IsLocked();\n+            if (!GetWalletPassphrase())\n+                return;\n+\n+            string strError;\n \t    CRITICAL_BLOCK(cs_main)\n-            CRITICAL_BLOCK(pwalletMain->cs_vMasterKey)\n+            CRITICAL_BLOCK(pwalletMain->cs_wallet)\n \t    {\n-                bool fWasLocked = pwalletMain->IsLocked();\n-                if (!GetWalletPassphrase())\n-                    return;\n-\n                 // Send to bitcoin address\n                 CScript scriptPubKey;\n                 scriptPubKey.SetBitcoinAddress(address);\n \n-                string strError = pwalletMain->SendMoney(scriptPubKey, nValue, wtx, true);\n-                if (strError == \"\")\n-                    wxMessageBox(_(\"Payment sent  \"), _(\"Sending...\"));\n-                else if (strError == \"ABORTED\")\n-                {\n-                    if (fWasLocked)\n-                        pwalletMain->Lock();\n-                    return; // leave send dialog open\n-                }\n-                else\n-                {\n-                    wxMessageBox(strError + \"  \", _(\"Sending...\"));\n-                    EndModal(false);\n-                    if (fWasLocked)\n-                        pwalletMain->Lock();\n-                    return;\n-                }\n-\n+                strError = pwalletMain->SendMoney(scriptPubKey, nValue, wtx, true);\n+            }\n+            if (strError == \"\")\n+                wxMessageBox(_(\"Payment sent  \"), _(\"Sending...\"));\n+            else if (strError == \"ABORTED\")\n+            {\n                 if (fWasLocked)\n                     pwalletMain->Lock();\n-\t    }\n+                return; // leave send dialog open\n+            }\n+            else\n+            {\n+                wxMessageBox(strError + \"  \", _(\"Sending...\"));\n+                EndModal(false);\n+                if (fWasLocked)\n+                    pwalletMain->Lock();\n+                return;\n+            }\n+\n+            if (fWasLocked)\n+                pwalletMain->Lock();\n         }\n         else\n         {\n@@ -2212,7 +2209,7 @@ void CSendDialog::OnButtonSend(wxCommandEvent& event)\n                 return;\n         }\n \n-        CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n+        CRITICAL_BLOCK(pwalletMain->cs_wallet)\n             if (!pwalletMain->mapAddressBook.count(address))\n                 pwalletMain->SetAddressBookName(strAddress, \"\");\n \n@@ -2464,83 +2461,89 @@ void CSendingDialog::OnReply2(CDataStream& vRecv)\n             return;\n     }\n \n-    CRITICAL_BLOCK(cs_main)\n+    // Pay\n+    if (!Status(_(\"Creating transaction...\")))\n+        return;\n+    if (nPrice + nTransactionFee > pwalletMain->GetBalance())\n     {\n-        // Pay\n-        if (!Status(_(\"Creating transaction...\")))\n-            return;\n-        if (nPrice + nTransactionFee > pwalletMain->GetBalance())\n-        {\n-            Error(_(\"Insufficient funds\"));\n-            return;\n-        }\n+        Error(_(\"Insufficient funds\"));\n+        return;\n+    }\n \n-        CReserveKey reservekey(pwalletMain);\n-        int64 nFeeRequired;\n-        CRITICAL_BLOCK(pwalletMain->cs_vMasterKey)\n-        {\n-            bool fWasLocked = pwalletMain->IsLocked();\n-            if (!GetWalletPassphrase())\n-                return;\n+    CReserveKey reservekey(pwalletMain);\n+    int64 nFeeRequired;\n+    bool fWasLocked = pwalletMain->IsLocked();\n+    if (!GetWalletPassphrase())\n+        return;\n \n-            if (!pwalletMain->CreateTransaction(scriptPubKey, nPrice, wtx, reservekey, nFeeRequired))\n-            {\n-                if (nPrice + nFeeRequired > pwalletMain->GetBalance())\n-                    Error(strprintf(_(\"This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds\"), FormatMoney(nFeeRequired).c_str()));\n-                else\n-                    Error(_(\"Transaction creation failed\"));\n-                return;\n-            }\n+    bool fTxCreated = false;\n+    CRITICAL_BLOCK(cs_main)\n+    CRITICAL_BLOCK(pwalletMain->cs_wallet)\n+    {\n+        fTxCreated = pwalletMain->CreateTransaction(scriptPubKey, nPrice, wtx, reservekey, nFeeRequired);\n+    }\n+    if (!fTxCreated)\n+    {\n+        if (nPrice + nFeeRequired > pwalletMain->GetBalance())\n+            Error(strprintf(_(\"This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds\"), FormatMoney(nFeeRequired).c_str()));\n+        else\n+            Error(_(\"Transaction creation failed\"));\n+        return;\n+    }\n \n-            if (fWasLocked)\n-                pwalletMain->Lock();\n-       }\n+    if (fWasLocked)\n+        pwalletMain->Lock();\n \n-        // Transaction fee\n-        if (!ThreadSafeAskFee(nFeeRequired, _(\"Sending...\"), this))\n-        {\n-            Error(_(\"Transaction aborted\"));\n-            return;\n-        }\n+    // Transaction fee\n+    if (!ThreadSafeAskFee(nFeeRequired, _(\"Sending...\"), this))\n+    {\n+        Error(_(\"Transaction aborted\"));\n+        return;\n+    }\n \n-        // Make sure we're still connected\n-        CNode* pnode = ConnectNode(addr, 2 * 60 * 60);\n-        if (!pnode)\n-        {\n-            Error(_(\"Lost connection, transaction cancelled\"));\n-            return;\n-        }\n+    // Make sure we're still connected\n+    CNode* pnode = ConnectNode(addr, 2 * 60 * 60);\n+    if (!pnode)\n+    {\n+        Error(_(\"Lost connection, transaction cancelled\"));\n+        return;\n+    }\n \n-        // Last chance to cancel\n-        Sleep(50);\n+    // Last chance to cancel\n+    Sleep(50);\n+    if (!Status())\n+        return;\n+    fCanCancel = false;\n+    if (fAbort)\n+    {\n+        fCanCancel = true;\n         if (!Status())\n             return;\n         fCanCancel = false;\n-        if (fAbort)\n-        {\n-            fCanCancel = true;\n-            if (!Status())\n-                return;\n-            fCanCancel = false;\n-        }\n-        if (!Status(_(\"Sending payment...\")))\n-            return;\n+    }\n+    if (!Status(_(\"Sending payment...\")))\n+        return;\n \n-        // Commit\n-        if (!pwalletMain->CommitTransaction(wtx, reservekey))\n-        {\n-            Error(_(\"The transaction was rejected.  This might happen if some of the coins in your wallet were already spent, such as if you used a copy of wallet.dat and coins were spent in the copy but not marked as spent here.\"));\n-            return;\n-        }\n+    // Commit\n+    bool fTxCommitted = false;\n+    CRITICAL_BLOCK(cs_main)\n+    CRITICAL_BLOCK(pwalletMain->cs_wallet)\n+    {\n+        fTxCommitted = pwalletMain->CommitTransaction(wtx, reservekey);\n+    }\n+    if (!fTxCommitted)\n+    {\n+        Error(_(\"The transaction was rejected.  This might happen if some of the coins in your wallet were already spent, such as if you used a copy of wallet.dat and coins were spent in the copy but not marked as spent here.\"));\n+        return;\n+    }\n \n-        // Send payment tx to seller, with response going to OnReply3 via event handler\n-        CWalletTx wtxSend = wtx;\n-        wtxSend.fFromMe = false;\n-        pnode->PushRequest(\"submitorder\", wtxSend, SendingDialogOnReply3, this);\n+    // Send payment tx to seller, with response going to OnReply3 via event handler\n+    CWalletTx wtxSend = wtx;\n+    wtxSend.fFromMe = false;\n+    pnode->PushRequest(\"submitorder\", wtxSend, SendingDialogOnReply3, this);\n \n-        Status(_(\"Waiting for confirmation...\"));\n-        MainFrameRepaint();\n-    }\n+    Status(_(\"Waiting for confirmation...\"));\n+    MainFrameRepaint();\n }\n \n void SendingDialogOnReply3(void* parg, CDataStream& vRecv)\n@@ -2621,7 +2624,7 @@ CAddressBookDialog::CAddressBookDialog(wxWindow* parent, const wxString& strInit\n     m_listCtrlReceiving->SetFocus();\n \n     // Fill listctrl with address book data\n-    CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n+    CRITICAL_BLOCK(pwalletMain->cs_wallet)\n     {\n         string strDefaultReceiving = (string)pframeMain->m_textCtrlAddress->GetValue();\n         BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, string)& item, pwalletMain->mapAddressBook)\n@@ -2682,7 +2685,7 @@ void CAddressBookDialog::OnListEndLabelEdit(wxListEvent& event)\n     if (event.IsEditCancelled())\n         return;\n     string strAddress = (string)GetItemText(m_listCtrl, event.GetIndex(), 1);\n-    CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n+    CRITICAL_BLOCK(pwalletMain->cs_wallet)\n         pwalletMain->SetAddressBookName(strAddress, string(event.GetText()));\n     pframeMain->RefreshListCtrl();\n }\n@@ -2718,7 +2721,7 @@ void CAddressBookDialog::OnButtonDelete(wxCommandEvent& event)\n         if (m_listCtrl->GetItemState(nIndex, wxLIST_STATE_SELECTED))\n         {\n             string strAddress = (string)GetItemText(m_listCtrl, nIndex, 1);\n-            CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n+            CRITICAL_BLOCK(pwalletMain->cs_wallet)\n                 pwalletMain->DelAddressBookName(strAddress);\n             m_listCtrl->DeleteItem(nIndex);\n         }\n@@ -2778,7 +2781,7 @@ void CAddressBookDialog::OnButtonEdit(wxCommandEvent& event)\n     }\n \n     // Write back\n-    CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n+    CRITICAL_BLOCK(pwalletMain->cs_wallet)\n     {\n         if (strAddress != strAddressOrg)\n             pwalletMain->DelAddressBookName(strAddressOrg);\n@@ -2818,22 +2821,19 @@ void CAddressBookDialog::OnButtonNew(wxCommandEvent& event)\n             return;\n         strName = dialog.GetValue();\n \n-        CRITICAL_BLOCK(pwalletMain->cs_vMasterKey)\n-        {\n-            bool fWasLocked = pwalletMain->IsLocked();\n-            if (!GetWalletPassphrase())\n-                return;\n+        bool fWasLocked = pwalletMain->IsLocked();\n+        if (!GetWalletPassphrase())\n+            return;\n \n-            // Generate new key\n-            strAddress = CBitcoinAddress(pwalletMain->GetOrReuseKeyFromPool()).ToString();\n+        // Generate new key\n+        strAddress = CBitcoinAddress(pwalletMain->GetOrReuseKeyFromPool()).ToString();\n \n-            if (fWasLocked)\n-                pwalletMain->Lock();\n-        }\n+        if (fWasLocked)\n+            pwalletMain->Lock();\n     }\n \n     // Add to list and select it\n-    CRITICAL_BLOCK(pwalletMain->cs_mapAddressBook)\n+    CRITICAL_BLOCK(pwalletMain->cs_wallet)\n         pwalletMain->SetAddressBookName(strAddress, strName);\n     int nIndex = InsertLine(m_listCtrl, strName, strAddress);\n     SetSelection(m_listCtrl, nIndex);"
      },
      {
        "sha": "1daec98d3453348d83122992db301f2b604d2809",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 16,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/471426fb3b2c2fa37640c03819c4f7be69ba8301/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/471426fb3b2c2fa37640c03819c4f7be69ba8301/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=471426fb3b2c2fa37640c03819c4f7be69ba8301",
        "patch": "@@ -353,22 +353,6 @@ int64 CWallet::GetDebit(const CTxIn &txin) const\n \n int64 CWalletTx::GetTxTime() const\n {\n-    CRITICAL_BLOCK(cs_main)\n-    {\n-        if (!fTimeReceivedIsTxTime && hashBlock != 0)\n-        {\n-            // If we did not receive the transaction directly, we rely on the block's\n-            // time to figure out when it happened.  We use the median over a range\n-            // of blocks to try to filter out inaccurate block times.\n-            map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n-            if (mi != mapBlockIndex.end())\n-            {\n-                CBlockIndex* pindex = (*mi).second;\n-                if (pindex)\n-                    return pindex->GetMedianTime();\n-            }\n-        }\n-    }\n     return nTimeReceived;\n }\n "
      }
    ]
  }
]