[
  {
    "sha": "978b25528c5f336e0aade73bd1b320500f257f70",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NzhiMjU1MjhjNWYzMzZlMGFhZGU3M2JkMWIzMjA1MDBmMjU3Zjcw",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@protonmail.com",
        "date": "2019-12-06T08:52:52Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@protonmail.com",
        "date": "2019-12-06T09:02:08Z"
      },
      "message": "util: Update tinyformat to upstream\n\nLast update was in 2017.\nUpdates tinyformat to upstream commit 705e3f4e1de922069bf715746d35bd2364b1f98f.\nRe-apply bitcoin core specific changes.\n\nNo changes that affect our use, as far as I can see, but this gets rid\nof the gcc `-Wimplicit-fallthrough` warnings, at least.",
      "tree": {
        "sha": "094cc600ad2d96930b87b27f75470d09257a8942",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/094cc600ad2d96930b87b27f75470d09257a8942"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/978b25528c5f336e0aade73bd1b320500f257f70",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/978b25528c5f336e0aade73bd1b320500f257f70",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/978b25528c5f336e0aade73bd1b320500f257f70",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/978b25528c5f336e0aade73bd1b320500f257f70/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cb11324a63ef10475bfc4d8e45148d5ae6f3e71e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cb11324a63ef10475bfc4d8e45148d5ae6f3e71e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cb11324a63ef10475bfc4d8e45148d5ae6f3e71e"
      }
    ],
    "stats": {
      "total": 459,
      "additions": 278,
      "deletions": 181
    },
    "files": [
      {
        "sha": "be63f2d5d8205a91a564c93fe39aa91dc4d58a3c",
        "filename": "src/tinyformat.h",
        "status": "modified",
        "additions": 278,
        "deletions": 181,
        "changes": 459,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/978b25528c5f336e0aade73bd1b320500f257f70/src/tinyformat.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/978b25528c5f336e0aade73bd1b320500f257f70/src/tinyformat.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tinyformat.h?ref=978b25528c5f336e0aade73bd1b320500f257f70",
        "patch": "@@ -33,6 +33,7 @@\n //\n // * Type safety and extensibility for user defined types.\n // * C99 printf() compatibility, to the extent possible using std::ostream\n+// * POSIX extension for positional arguments\n // * Simplicity and minimalism.  A single header file to include and distribute\n //   with your projects.\n // * Augment rather than replace the standard stream formatting mechanism\n@@ -42,7 +43,7 @@\n // Main interface example usage\n // ----------------------------\n //\n-// To print a date to std::cout:\n+// To print a date to std::cout for American usage:\n //\n //   std::string weekday = \"Wednesday\";\n //   const char* month = \"July\";\n@@ -52,6 +53,14 @@\n //\n //   tfm::printf(\"%s, %s %d, %.2d:%.2d\\n\", weekday, month, day, hour, min);\n //\n+// POSIX extension for positional arguments is available.\n+// The ability to rearrange formatting arguments is an important feature\n+// for localization because the word order may vary in different languages.\n+//\n+// Previous example for German usage. Arguments are reordered:\n+//\n+//   tfm::printf(\"%1$s, %3$d. %2$s, %4$d:%5$.2d\\n\", weekday, month, day, hour, min);\n+//\n // The strange types here emphasize the type safety of the interface; it is\n // possible to print a std::string using the \"%s\" conversion, and a\n // size_t using the \"%d\" conversion.  A similar result could be achieved\n@@ -133,12 +142,17 @@ namespace tfm = tinyformat;\n //------------------------------------------------------------------------------\n // Implementation details.\n #include <algorithm>\n-#include <cassert>\n #include <iostream>\n #include <sstream>\n-#include <stdexcept>\n+#include <stdexcept> // Added for Bitcoin Core\n+\n+#ifndef TINYFORMAT_ASSERT\n+#   include <cassert>\n+#   define TINYFORMAT_ASSERT(cond) assert(cond)\n+#endif\n \n #ifndef TINYFORMAT_ERROR\n+#   include <cassert>\n #   define TINYFORMAT_ERROR(reason) assert(0 && reason)\n #endif\n \n@@ -149,13 +163,13 @@ namespace tfm = tinyformat;\n #endif\n \n #if defined(__GLIBCXX__) && __GLIBCXX__ < 20080201\n-//  std::showpos is broken on old libstdc++ as provided with OSX.  See\n+//  std::showpos is broken on old libstdc++ as provided with macOS.  See\n //  http://gcc.gnu.org/ml/libstdc++/2007-11/msg00075.html\n #   define TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND\n #endif\n \n #ifdef __APPLE__\n-// Workaround OSX linker warning: Xcode uses different default symbol\n+// Workaround macOS linker warning: Xcode uses different default symbol\n // visibilities for static libs vs executables (see issue #25)\n #   define TINYFORMAT_HIDDEN __attribute__((visibility(\"hidden\")))\n #else\n@@ -164,6 +178,7 @@ namespace tfm = tinyformat;\n \n namespace tinyformat {\n \n+// Added for Bitcoin Core\n class format_error: public std::runtime_error\n {\n public:\n@@ -218,7 +233,7 @@ template<int n> struct is_wchar<wchar_t[n]> {};\n template<typename T, typename fmtT, bool convertible = is_convertible<T, fmtT>::value>\n struct formatValueAsType\n {\n-    static void invoke(std::ostream& /*out*/, const T& /*value*/) { assert(0); }\n+    static void invoke(std::ostream& /*out*/, const T& /*value*/) { TINYFORMAT_ASSERT(0); }\n };\n // Specialized version for types that can actually be converted to fmtT, as\n // indicated by the \"convertible\" template parameter.\n@@ -240,8 +255,7 @@ struct formatZeroIntegerWorkaround<T,true>\n {\n     static bool invoke(std::ostream& out, const T& value)\n     {\n-        if (static_cast<int>(value) == 0 && out.flags() & std::ios::showpos)\n-        {\n+        if (static_cast<int>(value) == 0 && out.flags() & std::ios::showpos) {\n             out << \"+0\";\n             return true;\n         }\n@@ -282,7 +296,7 @@ inline void formatTruncated(std::ostream& out, const T& value, int ntrunc)\n inline void formatTruncated(std::ostream& out, type* value, int ntrunc) \\\n {                                                           \\\n     std::streamsize len = 0;                                \\\n-    while(len < ntrunc && value[len] != 0)                  \\\n+    while (len < ntrunc && value[len] != 0)                 \\\n         ++len;                                              \\\n     out.write(value, len);                                  \\\n }\n@@ -328,15 +342,14 @@ inline void formatValue(std::ostream& out, const char* /*fmtBegin*/,\n     // could otherwise lead to a crash when printing a dangling (const char*).\n     const bool canConvertToChar = detail::is_convertible<T,char>::value;\n     const bool canConvertToVoidPtr = detail::is_convertible<T, const void*>::value;\n-    if(canConvertToChar && *(fmtEnd-1) == 'c')\n+    if (canConvertToChar && *(fmtEnd-1) == 'c')\n         detail::formatValueAsType<T, char>::invoke(out, value);\n-    else if(canConvertToVoidPtr && *(fmtEnd-1) == 'p')\n+    else if (canConvertToVoidPtr && *(fmtEnd-1) == 'p')\n         detail::formatValueAsType<T, const void*>::invoke(out, value);\n #ifdef TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND\n-    else if(detail::formatZeroIntegerWorkaround<T>::invoke(out, value)) /**/;\n+    else if (detail::formatZeroIntegerWorkaround<T>::invoke(out, value)) /**/;\n #endif\n-    else if(ntrunc >= 0)\n-    {\n+    else if (ntrunc >= 0) {\n         // Take care not to overread C strings in truncating conversions like\n         // \"%.4s\" where at most 4 characters may be read.\n         detail::formatTruncated(out, value, ntrunc);\n@@ -351,8 +364,7 @@ inline void formatValue(std::ostream& out, const char* /*fmtBegin*/,\n inline void formatValue(std::ostream& out, const char* /*fmtBegin*/,  \\\n                         const char* fmtEnd, int /**/, charType value) \\\n {                                                                     \\\n-    switch(*(fmtEnd-1))                                               \\\n-    {                                                                 \\\n+    switch (*(fmtEnd-1)) {                                            \\\n         case 'u': case 'd': case 'i': case 'o': case 'X': case 'x':   \\\n             out << static_cast<int>(value); break;                    \\\n         default:                                                      \\\n@@ -490,19 +502,19 @@ namespace detail {\n \n // Type-opaque holder for an argument to format(), with associated actions on\n // the type held as explicit function pointers.  This allows FormatArg's for\n-// each argument to be allocated as a homogenous array inside FormatList\n+// each argument to be allocated as a homogeneous array inside FormatList\n // whereas a naive implementation based on inheritance does not.\n class FormatArg\n {\n     public:\n         FormatArg()\n-             : m_value(nullptr),\n-             m_formatImpl(nullptr),\n-             m_toIntImpl(nullptr)\n-         { }\n+            : m_value(NULL),\n+            m_formatImpl(NULL),\n+            m_toIntImpl(NULL)\n+        { }\n \n         template<typename T>\n-        explicit FormatArg(const T& value)\n+        FormatArg(const T& value)\n             : m_value(static_cast<const void*>(&value)),\n             m_formatImpl(&formatImpl<T>),\n             m_toIntImpl(&toIntImpl<T>)\n@@ -511,15 +523,15 @@ class FormatArg\n         void format(std::ostream& out, const char* fmtBegin,\n                     const char* fmtEnd, int ntrunc) const\n         {\n-            assert(m_value);\n-            assert(m_formatImpl);\n+            TINYFORMAT_ASSERT(m_value);\n+            TINYFORMAT_ASSERT(m_formatImpl);\n             m_formatImpl(out, fmtBegin, fmtEnd, ntrunc, m_value);\n         }\n \n         int toInt() const\n         {\n-            assert(m_value);\n-            assert(m_toIntImpl);\n+            TINYFORMAT_ASSERT(m_value);\n+            TINYFORMAT_ASSERT(m_toIntImpl);\n             return m_toIntImpl(m_value);\n         }\n \n@@ -549,36 +561,68 @@ class FormatArg\n inline int parseIntAndAdvance(const char*& c)\n {\n     int i = 0;\n-    for(;*c >= '0' && *c <= '9'; ++c)\n+    for (;*c >= '0' && *c <= '9'; ++c)\n         i = 10*i + (*c - '0');\n     return i;\n }\n \n-// Print literal part of format string and return next format spec\n-// position.\n+// Parse width or precision `n` from format string pointer `c`, and advance it\n+// to the next character. If an indirection is requested with `*`, the argument\n+// is read from `args[argIndex]` and `argIndex` is incremented (or read\n+// from `args[n]` in positional mode). Returns true if one or more\n+// characters were read.\n+inline bool parseWidthOrPrecision(int& n, const char*& c, bool positionalMode,\n+                                  const detail::FormatArg* args,\n+                                  int& argIndex, int numArgs)\n+{\n+    if (*c >= '0' && *c <= '9') {\n+        n = parseIntAndAdvance(c);\n+    }\n+    else if (*c == '*') {\n+        ++c;\n+        n = 0;\n+        if (positionalMode) {\n+            int pos = parseIntAndAdvance(c) - 1;\n+            if (*c != '$')\n+                TINYFORMAT_ERROR(\"tinyformat: Non-positional argument used after a positional one\");\n+            if (pos >= 0 && pos < numArgs)\n+                n = args[pos].toInt();\n+            else\n+                TINYFORMAT_ERROR(\"tinyformat: Positional argument out of range\");\n+            ++c;\n+        }\n+        else {\n+            if (argIndex < numArgs)\n+                n = args[argIndex++].toInt();\n+            else\n+                TINYFORMAT_ERROR(\"tinyformat: Not enough arguments to read variable width or precision\");\n+        }\n+    }\n+    else {\n+        return false;\n+    }\n+    return true;\n+}\n+\n+// Print literal part of format string and return next format spec position.\n //\n-// Skips over any occurrences of '%%', printing a literal '%' to the\n-// output.  The position of the first % character of the next\n-// nontrivial format spec is returned, or the end of string.\n+// Skips over any occurrences of '%%', printing a literal '%' to the output.\n+// The position of the first % character of the next nontrivial format spec is\n+// returned, or the end of string.\n inline const char* printFormatStringLiteral(std::ostream& out, const char* fmt)\n {\n     const char* c = fmt;\n-    for(;; ++c)\n-    {\n-        switch(*c)\n-        {\n-            case '\\0':\n-                out.write(fmt, c - fmt);\n+    for (;; ++c) {\n+        if (*c == '\\0') {\n+            out.write(fmt, c - fmt);\n+            return c;\n+        }\n+        else if (*c == '%') {\n+            out.write(fmt, c - fmt);\n+            if (*(c+1) != '%')\n                 return c;\n-            case '%':\n-                out.write(fmt, c - fmt);\n-                if(*(c+1) != '%')\n-                    return c;\n-                // for \"%%\", tack trailing % onto next literal section.\n-                fmt = ++c;\n-                break;\n-            default:\n-                break;\n+            // for \"%%\", tack trailing % onto next literal section.\n+            fmt = ++c;\n         }\n     }\n }\n@@ -587,23 +631,43 @@ inline const char* printFormatStringLiteral(std::ostream& out, const char* fmt)\n // Parse a format string and set the stream state accordingly.\n //\n // The format mini-language recognized here is meant to be the one from C99,\n-// with the form \"%[flags][width][.precision][length]type\".\n+// with the form \"%[flags][width][.precision][length]type\" with POSIX\n+// positional arguments extension.\n+//\n+// POSIX positional arguments extension:\n+// Conversions can be applied to the nth argument after the format in\n+// the argument list, rather than to the next unused argument. In this case,\n+// the conversion specifier character % (see below) is replaced by the sequence\n+// \"%n$\", where n is a decimal integer in the range [1,{NL_ARGMAX}],\n+// giving the position of the argument in the argument list. This feature\n+// provides for the definition of format strings that select arguments\n+// in an order appropriate to specific languages.\n+//\n+// The format can contain either numbered argument conversion specifications\n+// (that is, \"%n$\" and \"*m$\"), or unnumbered argument conversion specifications\n+// (that is, % and * ), but not both. The only exception to this is that %%\n+// can be mixed with the \"%n$\" form. The results of mixing numbered and\n+// unnumbered argument specifications in a format string are undefined.\n+// When numbered argument specifications are used, specifying the Nth argument\n+// requires that all the leading arguments, from the first to the (N-1)th,\n+// are specified in the format string.\n+//\n+// In format strings containing the \"%n$\" form of conversion specification,\n+// numbered arguments in the argument list can be referenced from the format\n+// string as many times as required.\n //\n // Formatting options which can't be natively represented using the ostream\n // state are returned in spacePadPositive (for space padded positive numbers)\n // and ntrunc (for truncating conversions).  argIndex is incremented if\n // necessary to pull out variable width and precision.  The function returns a\n // pointer to the character after the end of the current format spec.\n-inline const char* streamStateFromFormat(std::ostream& out, bool& spacePadPositive,\n+inline const char* streamStateFromFormat(std::ostream& out, bool& positionalMode,\n+                                         bool& spacePadPositive,\n                                          int& ntrunc, const char* fmtStart,\n-                                         const detail::FormatArg* formatters,\n-                                         int& argIndex, int numFormatters)\n+                                         const detail::FormatArg* args,\n+                                         int& argIndex, int numArgs)\n {\n-    if(*fmtStart != '%')\n-    {\n-        TINYFORMAT_ERROR(\"tinyformat: Not enough conversion specifiers in format string\");\n-        return fmtStart;\n-    }\n+    TINYFORMAT_ASSERT(*fmtStart == '%');\n     // Reset stream state to defaults.\n     out.width(0);\n     out.precision(6);\n@@ -616,100 +680,113 @@ inline const char* streamStateFromFormat(std::ostream& out, bool& spacePadPositi\n     bool widthSet = false;\n     int widthExtra = 0;\n     const char* c = fmtStart + 1;\n-    // 1) Parse flags\n-    for(;; ++c)\n-    {\n-        switch(*c)\n-        {\n-            case '#':\n-                out.setf(std::ios::showpoint | std::ios::showbase);\n-                continue;\n-            case '0':\n-                // overridden by left alignment ('-' flag)\n-                if(!(out.flags() & std::ios::left))\n-                {\n-                    // Use internal padding so that numeric values are\n-                    // formatted correctly, eg -00010 rather than 000-10\n-                    out.fill('0');\n-                    out.setf(std::ios::internal, std::ios::adjustfield);\n-                }\n-                continue;\n-            case '-':\n-                out.fill(' ');\n-                out.setf(std::ios::left, std::ios::adjustfield);\n-                continue;\n-            case ' ':\n-                // overridden by show positive sign, '+' flag.\n-                if(!(out.flags() & std::ios::showpos))\n-                    spacePadPositive = true;\n-                continue;\n-            case '+':\n-                out.setf(std::ios::showpos);\n-                spacePadPositive = false;\n-                widthExtra = 1;\n-                continue;\n-            default:\n-                break;\n+\n+    // 1) Parse an argument index (if followed by '$') or a width possibly\n+    // preceded with '0' flag.\n+    if (*c >= '0' && *c <= '9') {\n+        const char tmpc = *c;\n+        int value = parseIntAndAdvance(c);\n+        if (*c == '$') {\n+            // value is an argument index\n+            if (value > 0 && value <= numArgs)\n+                argIndex = value - 1;\n+            else\n+                TINYFORMAT_ERROR(\"tinyformat: Positional argument out of range\");\n+            ++c;\n+            positionalMode = true;\n+        }\n+        else if (positionalMode) {\n+            TINYFORMAT_ERROR(\"tinyformat: Non-positional argument used after a positional one\");\n+        }\n+        else {\n+            if (tmpc == '0') {\n+                // Use internal padding so that numeric values are\n+                // formatted correctly, eg -00010 rather than 000-10\n+                out.fill('0');\n+                out.setf(std::ios::internal, std::ios::adjustfield);\n+            }\n+            if (value != 0) {\n+                // Nonzero value means that we parsed width.\n+                widthSet = true;\n+                out.width(value);\n+            }\n         }\n-        break;\n     }\n-    // 2) Parse width\n-    if(*c >= '0' && *c <= '9')\n-    {\n-        widthSet = true;\n-        out.width(parseIntAndAdvance(c));\n+    else if (positionalMode) {\n+        TINYFORMAT_ERROR(\"tinyformat: Non-positional argument used after a positional one\");\n     }\n-    if(*c == '*')\n-    {\n-        widthSet = true;\n+    // 2) Parse flags and width if we did not do it in previous step.\n+    if (!widthSet) {\n+        // Parse flags\n+        for (;; ++c) {\n+            switch (*c) {\n+                case '#':\n+                    out.setf(std::ios::showpoint | std::ios::showbase);\n+                    continue;\n+                case '0':\n+                    // overridden by left alignment ('-' flag)\n+                    if (!(out.flags() & std::ios::left)) {\n+                        // Use internal padding so that numeric values are\n+                        // formatted correctly, eg -00010 rather than 000-10\n+                        out.fill('0');\n+                        out.setf(std::ios::internal, std::ios::adjustfield);\n+                    }\n+                    continue;\n+                case '-':\n+                    out.fill(' ');\n+                    out.setf(std::ios::left, std::ios::adjustfield);\n+                    continue;\n+                case ' ':\n+                    // overridden by show positive sign, '+' flag.\n+                    if (!(out.flags() & std::ios::showpos))\n+                        spacePadPositive = true;\n+                    continue;\n+                case '+':\n+                    out.setf(std::ios::showpos);\n+                    spacePadPositive = false;\n+                    widthExtra = 1;\n+                    continue;\n+                default:\n+                    break;\n+            }\n+            break;\n+        }\n+        // Parse width\n         int width = 0;\n-        if(argIndex < numFormatters)\n-            width = formatters[argIndex++].toInt();\n-        else\n-            TINYFORMAT_ERROR(\"tinyformat: Not enough arguments to read variable width\");\n-        if(width < 0)\n-        {\n-            // negative widths correspond to '-' flag set\n-            out.fill(' ');\n-            out.setf(std::ios::left, std::ios::adjustfield);\n-            width = -width;\n+        widthSet = parseWidthOrPrecision(width, c, positionalMode,\n+                                         args, argIndex, numArgs);\n+        if (widthSet) {\n+            if (width < 0) {\n+                // negative widths correspond to '-' flag set\n+                out.fill(' ');\n+                out.setf(std::ios::left, std::ios::adjustfield);\n+                width = -width;\n+            }\n+            out.width(width);\n         }\n-        out.width(width);\n-        ++c;\n     }\n     // 3) Parse precision\n-    if(*c == '.')\n-    {\n+    if (*c == '.') {\n         ++c;\n         int precision = 0;\n-        if(*c == '*')\n-        {\n-            ++c;\n-            if(argIndex < numFormatters)\n-                precision = formatters[argIndex++].toInt();\n-            else\n-                TINYFORMAT_ERROR(\"tinyformat: Not enough arguments to read variable precision\");\n-        }\n-        else\n-        {\n-            if(*c >= '0' && *c <= '9')\n-                precision = parseIntAndAdvance(c);\n-            else if(*c == '-') // negative precisions ignored, treated as zero.\n-                parseIntAndAdvance(++c);\n-        }\n-        out.precision(precision);\n-        precisionSet = true;\n+        parseWidthOrPrecision(precision, c, positionalMode,\n+                              args, argIndex, numArgs);\n+        // Presence of `.` indicates precision set, unless the inferred value\n+        // was negative in which case the default is used.\n+        precisionSet = precision >= 0;\n+        if (precisionSet)\n+            out.precision(precision);\n     }\n     // 4) Ignore any C99 length modifier\n-    while(*c == 'l' || *c == 'h' || *c == 'L' ||\n-          *c == 'j' || *c == 'z' || *c == 't')\n+    while (*c == 'l' || *c == 'h' || *c == 'L' ||\n+           *c == 'j' || *c == 'z' || *c == 't') {\n         ++c;\n+    }\n     // 5) We're up to the conversion specifier character.\n     // Set stream flags based on conversion specifier (thanks to the\n     // boost::format class for forging the way here).\n     bool intConversion = false;\n-    switch(*c)\n-    {\n+    switch (*c) {\n         case 'u': case 'd': case 'i':\n             out.setf(std::ios::dec, std::ios::basefield);\n             intConversion = true;\n@@ -738,6 +815,18 @@ inline const char* streamStateFromFormat(std::ostream& out, bool& spacePadPositi\n         case 'f':\n             out.setf(std::ios::fixed, std::ios::floatfield);\n             break;\n+        case 'A':\n+            out.setf(std::ios::uppercase);\n+            // Falls through\n+        case 'a':\n+#           ifdef _MSC_VER\n+            // Workaround https://developercommunity.visualstudio.com/content/problem/520472/hexfloat-stream-output-does-not-ignore-precision-a.html\n+            // by always setting maximum precision on MSVC to avoid precision\n+            // loss for doubles.\n+            out.precision(13);\n+#           endif\n+            out.setf(std::ios::fixed | std::ios::scientific, std::ios::floatfield);\n+            break;\n         case 'G':\n             out.setf(std::ios::uppercase);\n             // Falls through\n@@ -746,17 +835,13 @@ inline const char* streamStateFromFormat(std::ostream& out, bool& spacePadPositi\n             // As in boost::format, let stream decide float format.\n             out.flags(out.flags() & ~std::ios::floatfield);\n             break;\n-        case 'a': case 'A':\n-            TINYFORMAT_ERROR(\"tinyformat: the %a and %A conversion specs \"\n-                             \"are not supported\");\n-            break;\n         case 'c':\n             // Handled as special case inside formatValue()\n             break;\n         case 's':\n-            if(precisionSet)\n+            if (precisionSet)\n                 ntrunc = static_cast<int>(out.precision());\n-            // Make %s print booleans as \"true\" and \"false\"\n+            // Make %s print Booleans as \"true\" and \"false\"\n             out.setf(std::ios::boolalpha);\n             break;\n         case 'n':\n@@ -770,8 +855,7 @@ inline const char* streamStateFromFormat(std::ostream& out, bool& spacePadPositi\n         default:\n             break;\n     }\n-    if(intConversion && precisionSet && !widthSet)\n-    {\n+    if (intConversion && precisionSet && !widthSet) {\n         // \"precision\" for integers gives the minimum number of digits (to be\n         // padded with zeros on the left).  This isn't really supported by the\n         // iostreams, but we can approximately simulate it with the width if\n@@ -786,35 +870,43 @@ inline const char* streamStateFromFormat(std::ostream& out, bool& spacePadPositi\n \n //------------------------------------------------------------------------------\n inline void formatImpl(std::ostream& out, const char* fmt,\n-                       const detail::FormatArg* formatters,\n-                       int numFormatters)\n+                       const detail::FormatArg* args,\n+                       int numArgs)\n {\n     // Saved stream state\n     std::streamsize origWidth = out.width();\n     std::streamsize origPrecision = out.precision();\n     std::ios::fmtflags origFlags = out.flags();\n     char origFill = out.fill();\n \n-    for (int argIndex = 0; argIndex < numFormatters; ++argIndex)\n-    {\n-        // Parse the format string\n+    // \"Positional mode\" means all format specs should be of the form \"%n$...\"\n+    // with `n` an integer. We detect this in `streamStateFromFormat`.\n+    bool positionalMode = false;\n+    int argIndex = 0;\n+    while (true) {\n         fmt = printFormatStringLiteral(out, fmt);\n+        if (*fmt == '\\0') {\n+            if (!positionalMode && argIndex < numArgs) {\n+                TINYFORMAT_ERROR(\"tinyformat: Not enough conversion specifiers in format string\");\n+            }\n+            break;\n+        }\n         bool spacePadPositive = false;\n         int ntrunc = -1;\n-        const char* fmtEnd = streamStateFromFormat(out, spacePadPositive, ntrunc, fmt,\n-                                                   formatters, argIndex, numFormatters);\n-        if (argIndex >= numFormatters)\n-        {\n-            // Check args remain after reading any variable width/precision\n-            TINYFORMAT_ERROR(\"tinyformat: Not enough format arguments\");\n+        const char* fmtEnd = streamStateFromFormat(out, positionalMode, spacePadPositive, ntrunc, fmt,\n+                                                   args, argIndex, numArgs);\n+        // NB: argIndex may be incremented by reading variable width/precision\n+        // in `streamStateFromFormat`, so do the bounds check here.\n+        if (argIndex >= numArgs) {\n+            TINYFORMAT_ERROR(\"tinyformat: Too many conversion specifiers in format string\");\n             return;\n         }\n-        const FormatArg& arg = formatters[argIndex];\n+        const FormatArg& arg = args[argIndex];\n         // Format the arg into the stream.\n-        if(!spacePadPositive)\n+        if (!spacePadPositive) {\n             arg.format(out, fmt, fmtEnd, ntrunc);\n-        else\n-        {\n+        }\n+        else {\n             // The following is a special case with no direct correspondence\n             // between stream formatting and the printf() behaviour.  Simulate\n             // it crudely by formatting into a temporary string stream and\n@@ -824,18 +916,17 @@ inline void formatImpl(std::ostream& out, const char* fmt,\n             tmpStream.setf(std::ios::showpos);\n             arg.format(tmpStream, fmt, fmtEnd, ntrunc);\n             std::string result = tmpStream.str(); // allocates... yuck.\n-            for(size_t i = 0, iend = result.size(); i < iend; ++i)\n-                if(result[i] == '+') result[i] = ' ';\n+            for (size_t i = 0, iend = result.size(); i < iend; ++i) {\n+                if (result[i] == '+')\n+                    result[i] = ' ';\n+            }\n             out << result;\n         }\n+        if (!positionalMode)\n+            ++argIndex;\n         fmt = fmtEnd;\n     }\n \n-    // Print remaining part of format string.\n-    fmt = printFormatStringLiteral(out, fmt);\n-    if(*fmt != '\\0')\n-        TINYFORMAT_ERROR(\"tinyformat: Too many conversion specifiers in format string\");\n-\n     // Restore stream state\n     out.width(origWidth);\n     out.precision(origPrecision);\n@@ -855,14 +946,14 @@ inline void formatImpl(std::ostream& out, const char* fmt,\n class FormatList\n {\n     public:\n-        FormatList(detail::FormatArg* formatters, int N)\n-            : m_formatters(formatters), m_N(N) { }\n+        FormatList(detail::FormatArg* args, int N)\n+            : m_args(args), m_N(N) { }\n \n         friend void vformat(std::ostream& out, const char* fmt,\n                             const FormatList& list);\n \n     private:\n-        const detail::FormatArg* m_formatters;\n+        const detail::FormatArg* m_args;\n         int m_N;\n };\n \n@@ -879,29 +970,33 @@ class FormatListN : public FormatList\n     public:\n #ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES\n         template<typename... Args>\n-        explicit FormatListN(const Args&... args)\n+        FormatListN(const Args&... args)\n             : FormatList(&m_formatterStore[0], N),\n             m_formatterStore { FormatArg(args)... }\n         { static_assert(sizeof...(args) == N, \"Number of args must be N\"); }\n #else // C++98 version\n         void init(int) {}\n-#       define TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR(n)       \\\n-                                                               \\\n-        template<TINYFORMAT_ARGTYPES(n)>                       \\\n-        explicit FormatListN(TINYFORMAT_VARARGS(n))            \\\n-            : FormatList(&m_formatterStore[0], n)              \\\n-        { assert(n == N); init(0, TINYFORMAT_PASSARGS(n)); }   \\\n-                                                               \\\n-        template<TINYFORMAT_ARGTYPES(n)>                       \\\n-        void init(int i, TINYFORMAT_VARARGS(n))                \\\n-        {                                                      \\\n-            m_formatterStore[i] = FormatArg(v1);               \\\n-            init(i+1 TINYFORMAT_PASSARGS_TAIL(n));             \\\n+#       define TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR(n)                \\\n+                                                                        \\\n+        template<TINYFORMAT_ARGTYPES(n)>                                \\\n+        FormatListN(TINYFORMAT_VARARGS(n))                              \\\n+            : FormatList(&m_formatterStore[0], n)                       \\\n+        { TINYFORMAT_ASSERT(n == N); init(0, TINYFORMAT_PASSARGS(n)); } \\\n+                                                                        \\\n+        template<TINYFORMAT_ARGTYPES(n)>                                \\\n+        void init(int i, TINYFORMAT_VARARGS(n))                         \\\n+        {                                                               \\\n+            m_formatterStore[i] = FormatArg(v1);                        \\\n+            init(i+1 TINYFORMAT_PASSARGS_TAIL(n));                      \\\n         }\n \n         TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR)\n #       undef TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR\n #endif\n+        FormatListN(const FormatListN& other)\n+            : FormatList(&m_formatterStore[0], N)\n+        { std::copy(&other.m_formatterStore[0], &other.m_formatterStore[N],\n+                    &m_formatterStore[0]); }\n \n     private:\n         FormatArg m_formatterStore[N];\n@@ -956,7 +1051,7 @@ TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_MAKEFORMATLIST)\n /// list of format arguments is held in a single function argument.\n inline void vformat(std::ostream& out, const char* fmt, FormatListRef list)\n {\n-    detail::formatImpl(out, fmt, list.m_formatters, list.m_N);\n+    detail::formatImpl(out, fmt, list.m_args, list.m_N);\n }\n \n \n@@ -993,6 +1088,7 @@ void printfln(const char* fmt, const Args&... args)\n     std::cout << '\\n';\n }\n \n+\n #else // C++98 version\n \n inline void format(std::ostream& out, const char* fmt)\n@@ -1063,6 +1159,7 @@ std::string format(const std::string &fmt, const Args&... args)\n \n } // namespace tinyformat\n \n+// Added for Bitcoin Core:\n /** Format arguments and return the string or write to given std::ostream (see tinyformat::format doc for details) */\n #define strprintf tfm::format\n "
      }
    ]
  }
]