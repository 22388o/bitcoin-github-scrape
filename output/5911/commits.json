[
  {
    "sha": "67a79493976a3d5f5dac6ec64993fc3f415cac43",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2N2E3OTQ5Mzk3NmEzZDVmNWRhYzZlYzY0OTkzZmMzZjQxNWNhYzQz",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-03-16T15:30:49Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-04-17T11:26:47Z"
      },
      "message": "privacy: Stream isolation for Tor\n\nAccording to Tor's extensions to the SOCKS protocol\n(https://gitweb.torproject.org/torspec.git/tree/socks-extensions.txt)\nit is possible to perform stream isolation by providing authentication\nto the proxy. Each set of credentials will create a new circuit,\nwhich makes it harder to correlate connections.\n\nThis patch adds an option, `-proxyrandomize` (on by default) that randomizes\ncredentials for every outgoing connection, thus creating a new circuit.\n\n    2015-03-16 15:29:59 SOCKS5 Sending proxy authentication 3842137544:3256031132",
      "tree": {
        "sha": "347b15fb2f4b0020160bf45a3ee91da9b4d12689",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/347b15fb2f4b0020160bf45a3ee91da9b4d12689"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/67a79493976a3d5f5dac6ec64993fc3f415cac43",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/67a79493976a3d5f5dac6ec64993fc3f415cac43",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/67a79493976a3d5f5dac6ec64993fc3f415cac43",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/67a79493976a3d5f5dac6ec64993fc3f415cac43/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8f955b9661224adc950e302b42d2f7bcb5e90bef",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8f955b9661224adc950e302b42d2f7bcb5e90bef",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8f955b9661224adc950e302b42d2f7bcb5e90bef"
      }
    ],
    "stats": {
      "total": 208,
      "additions": 129,
      "deletions": 79
    },
    "files": [
      {
        "sha": "8f52d254f4dff738f81c9527620f89f5f8863b7e",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 6,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67a79493976a3d5f5dac6ec64993fc3f415cac43/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67a79493976a3d5f5dac6ec64993fc3f415cac43/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=67a79493976a3d5f5dac6ec64993fc3f415cac43",
        "patch": "@@ -301,6 +301,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-permitbaremultisig\", strprintf(_(\"Relay non-P2SH multisig (default: %u)\"), 1));\n     strUsage += HelpMessageOpt(\"-port=<port>\", strprintf(_(\"Listen for connections on <port> (default: %u or testnet: %u)\"), 8333, 18333));\n     strUsage += HelpMessageOpt(\"-proxy=<ip:port>\", _(\"Connect through SOCKS5 proxy\"));\n+    strUsage += HelpMessageOpt(\"-proxyrandomize\", strprintf(_(\"Randomize credentials for every proxy connection. This enables Tor stream isolation (default: %u)\"), 1));\n     strUsage += HelpMessageOpt(\"-seednode=<ip>\", _(\"Connect to a node to retrieve peer addresses, and disconnect\"));\n     strUsage += HelpMessageOpt(\"-timeout=<n>\", strprintf(_(\"Specify connection timeout in milliseconds (minimum: 1, default: %d)\"), DEFAULT_CONNECT_TIMEOUT));\n #ifdef USE_UPNP\n@@ -351,7 +352,7 @@ std::string HelpMessage(HelpMessageMode mode)\n         strUsage += HelpMessageOpt(\"-flushwallet\", strprintf(_(\"Run a thread to flush wallet periodically (default: %u)\"), 1));\n         strUsage += HelpMessageOpt(\"-stopafterblockimport\", strprintf(_(\"Stop running after importing blocks from disk (default: %u)\"), 0));\n     }\n-    string debugCategories = \"addrman, alert, bench, coindb, db, lock, rand, rpc, selectcoins, mempool, net\"; // Don't translate these and qt below\n+    string debugCategories = \"addrman, alert, bench, coindb, db, lock, rand, rpc, selectcoins, mempool, net, proxy\"; // Don't translate these and qt below\n     if (mode == HMM_BITCOIN_QT)\n         debugCategories += \", qt\";\n     strUsage += HelpMessageOpt(\"-debug=<category>\", strprintf(_(\"Output debugging information (default: %u, supplying <category> is optional)\"), 0) + \". \" +\n@@ -891,10 +892,10 @@ bool AppInit2(boost::thread_group& threadGroup)\n         }\n     }\n \n-    CService addrProxy;\n+    proxyType addrProxy;\n     bool fProxy = false;\n     if (mapArgs.count(\"-proxy\")) {\n-        addrProxy = CService(mapArgs[\"-proxy\"], 9050);\n+        addrProxy = proxyType(CService(mapArgs[\"-proxy\"], 9050), GetArg(\"-proxyrandomize\", true));\n         if (!addrProxy.IsValid())\n             return InitError(strprintf(_(\"Invalid -proxy address: '%s'\"), mapArgs[\"-proxy\"]));\n \n@@ -904,14 +905,14 @@ bool AppInit2(boost::thread_group& threadGroup)\n         fProxy = true;\n     }\n \n-    // -onion can override normal proxy, -noonion disables tor entirely\n+    // -onion can override normal proxy, -noonion disables connecting to .onion entirely\n     if (!(mapArgs.count(\"-onion\") && mapArgs[\"-onion\"] == \"0\") &&\n         (fProxy || mapArgs.count(\"-onion\"))) {\n-        CService addrOnion;\n+        proxyType addrOnion;\n         if (!mapArgs.count(\"-onion\"))\n             addrOnion = addrProxy;\n         else\n-            addrOnion = CService(mapArgs[\"-onion\"], 9050);\n+            addrOnion = proxyType(CService(mapArgs[\"-onion\"], 9050), GetArg(\"-proxyrandomize\", true));\n         if (!addrOnion.IsValid())\n             return InitError(strprintf(_(\"Invalid -onion address: '%s'\"), mapArgs[\"-onion\"]));\n         SetProxy(NET_TOR, addrOnion);"
      },
      {
        "sha": "1837cfa9c3f2bc49ad55daf6cdb8bf40300dc264",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 104,
        "deletions": 66,
        "changes": 170,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67a79493976a3d5f5dac6ec64993fc3f415cac43/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67a79493976a3d5f5dac6ec64993fc3f415cac43/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=67a79493976a3d5f5dac6ec64993fc3f415cac43",
        "patch": "@@ -12,6 +12,7 @@\n #include \"hash.h\"\n #include \"sync.h\"\n #include \"uint256.h\"\n+#include \"random.h\"\n #include \"util.h\"\n #include \"utilstrencodings.h\"\n \n@@ -38,7 +39,7 @@ using namespace std;\n \n // Settings\n static proxyType proxyInfo[NET_MAX];\n-static CService nameProxy;\n+static proxyType nameProxy;\n static CCriticalSection cs_proxyInfos;\n int nConnectTimeout = DEFAULT_CONNECT_TIMEOUT;\n bool fNameLookup = false;\n@@ -285,59 +286,100 @@ bool static InterruptibleRecv(char* data, size_t len, int timeout, SOCKET& hSock\n     return len == 0;\n }\n \n-bool static Socks5(string strDest, int port, SOCKET& hSocket)\n+struct ProxyCredentials\n+{\n+    std::string username;\n+    std::string password;\n+};\n+\n+/** Connect using SOCKS5 (as described in RFC1928) */\n+bool static Socks5(string strDest, int port, const ProxyCredentials *auth, SOCKET& hSocket)\n {\n     LogPrintf(\"SOCKS5 connecting %s\\n\", strDest);\n-    if (strDest.size() > 255)\n-    {\n+    if (strDest.size() > 255) {\n         CloseSocket(hSocket);\n         return error(\"Hostname too long\");\n     }\n-    char pszSocks5Init[] = \"\\5\\1\\0\";\n-    ssize_t nSize = sizeof(pszSocks5Init) - 1;\n-\n-    ssize_t ret = send(hSocket, pszSocks5Init, nSize, MSG_NOSIGNAL);\n-    if (ret != nSize)\n-    {\n+    // Accepted authentication methods\n+    std::vector<uint8_t> vSocks5Init;\n+    vSocks5Init.push_back(0x05);\n+    if (auth) {\n+        vSocks5Init.push_back(0x02); // # METHODS\n+        vSocks5Init.push_back(0x00); // X'00' NO AUTHENTICATION REQUIRED\n+        vSocks5Init.push_back(0x02); // X'02' USERNAME/PASSWORD (RFC1929)\n+    } else {\n+        vSocks5Init.push_back(0x01); // # METHODS\n+        vSocks5Init.push_back(0x00); // X'00' NO AUTHENTICATION REQUIRED\n+    }\n+    ssize_t ret = send(hSocket, (const char*)begin_ptr(vSocks5Init), vSocks5Init.size(), MSG_NOSIGNAL);\n+    if (ret != (ssize_t)vSocks5Init.size()) {\n         CloseSocket(hSocket);\n         return error(\"Error sending to proxy\");\n     }\n     char pchRet1[2];\n-    if (!InterruptibleRecv(pchRet1, 2, SOCKS5_RECV_TIMEOUT, hSocket))\n-    {\n+    if (!InterruptibleRecv(pchRet1, 2, SOCKS5_RECV_TIMEOUT, hSocket)) {\n         CloseSocket(hSocket);\n         return error(\"Error reading proxy response\");\n     }\n-    if (pchRet1[0] != 0x05 || pchRet1[1] != 0x00)\n-    {\n+    if (pchRet1[0] != 0x05) {\n         CloseSocket(hSocket);\n         return error(\"Proxy failed to initialize\");\n     }\n-    string strSocks5(\"\\5\\1\");\n-    strSocks5 += '\\000'; strSocks5 += '\\003';\n-    strSocks5 += static_cast<char>(std::min((int)strDest.size(), 255));\n-    strSocks5 += strDest;\n-    strSocks5 += static_cast<char>((port >> 8) & 0xFF);\n-    strSocks5 += static_cast<char>((port >> 0) & 0xFF);\n-    ret = send(hSocket, strSocks5.data(), strSocks5.size(), MSG_NOSIGNAL);\n-    if (ret != (ssize_t)strSocks5.size())\n-    {\n+    if (pchRet1[1] == 0x02 && auth) {\n+        // Perform username/password authentication (as described in RFC1929)\n+        std::vector<uint8_t> vAuth;\n+        vAuth.push_back(0x01);\n+        if (auth->username.size() > 255 || auth->password.size() > 255)\n+            return error(\"Proxy username or password too long\");\n+        vAuth.push_back(auth->username.size());\n+        vAuth.insert(vAuth.end(), auth->username.begin(), auth->username.end());\n+        vAuth.push_back(auth->password.size());\n+        vAuth.insert(vAuth.end(), auth->password.begin(), auth->password.end());\n+        ret = send(hSocket, (const char*)begin_ptr(vAuth), vAuth.size(), MSG_NOSIGNAL);\n+        if (ret != (ssize_t)vAuth.size()) {\n+            CloseSocket(hSocket);\n+            return error(\"Error sending authentication to proxy\");\n+        }\n+        LogPrint(\"proxy\", \"SOCKS5 sending proxy authentication %s:%s\\n\", auth->username, auth->password);\n+        char pchRetA[2];\n+        if (!InterruptibleRecv(pchRetA, 2, SOCKS5_RECV_TIMEOUT, hSocket)) {\n+            CloseSocket(hSocket);\n+            return error(\"Error reading proxy authentication response\");\n+        }\n+        if (pchRetA[0] != 0x01 || pchRetA[1] != 0x00) {\n+            CloseSocket(hSocket);\n+            return error(\"Proxy authentication unsuccesful\");\n+        }\n+    } else if (pchRet1[1] == 0x00) {\n+        // Perform no authentication\n+    } else {\n+        CloseSocket(hSocket);\n+        return error(\"Proxy requested wrong authentication method %02x\", pchRet1[1]);\n+    }\n+    std::vector<uint8_t> vSocks5;\n+    vSocks5.push_back(0x05); // VER protocol version\n+    vSocks5.push_back(0x01); // CMD CONNECT\n+    vSocks5.push_back(0x00); // RSV Reserved\n+    vSocks5.push_back(0x03); // ATYP DOMAINNAME\n+    vSocks5.push_back(strDest.size()); // Length<=255 is checked at beginning of function\n+    vSocks5.insert(vSocks5.end(), strDest.begin(), strDest.end());\n+    vSocks5.push_back((port >> 8) & 0xFF);\n+    vSocks5.push_back((port >> 0) & 0xFF);\n+    ret = send(hSocket, (const char*)begin_ptr(vSocks5), vSocks5.size(), MSG_NOSIGNAL);\n+    if (ret != (ssize_t)vSocks5.size()) {\n         CloseSocket(hSocket);\n         return error(\"Error sending to proxy\");\n     }\n     char pchRet2[4];\n-    if (!InterruptibleRecv(pchRet2, 4, SOCKS5_RECV_TIMEOUT, hSocket))\n-    {\n+    if (!InterruptibleRecv(pchRet2, 4, SOCKS5_RECV_TIMEOUT, hSocket)) {\n         CloseSocket(hSocket);\n         return error(\"Error reading proxy response\");\n     }\n-    if (pchRet2[0] != 0x05)\n-    {\n+    if (pchRet2[0] != 0x05) {\n         CloseSocket(hSocket);\n         return error(\"Proxy failed to accept request\");\n     }\n-    if (pchRet2[1] != 0x00)\n-    {\n+    if (pchRet2[1] != 0x00) {\n         CloseSocket(hSocket);\n         switch (pchRet2[1])\n         {\n@@ -352,8 +394,7 @@ bool static Socks5(string strDest, int port, SOCKET& hSocket)\n             default:   return error(\"Proxy error: unknown\");\n         }\n     }\n-    if (pchRet2[2] != 0x00)\n-    {\n+    if (pchRet2[2] != 0x00) {\n         CloseSocket(hSocket);\n         return error(\"Error: malformed proxy response\");\n     }\n@@ -375,13 +416,11 @@ bool static Socks5(string strDest, int port, SOCKET& hSocket)\n         }\n         default: CloseSocket(hSocket); return error(\"Error: malformed proxy response\");\n     }\n-    if (!ret)\n-    {\n+    if (!ret) {\n         CloseSocket(hSocket);\n         return error(\"Error reading from proxy\");\n     }\n-    if (!InterruptibleRecv(pchRet3, 2, SOCKS5_RECV_TIMEOUT, hSocket))\n-    {\n+    if (!InterruptibleRecv(pchRet3, 2, SOCKS5_RECV_TIMEOUT, hSocket)) {\n         CloseSocket(hSocket);\n         return error(\"Error reading from proxy\");\n     }\n@@ -471,7 +510,7 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n     return true;\n }\n \n-bool SetProxy(enum Network net, CService addrProxy) {\n+bool SetProxy(enum Network net, const proxyType &addrProxy) {\n     assert(net >= 0 && net < NET_MAX);\n     if (!addrProxy.IsValid())\n         return false;\n@@ -489,15 +528,15 @@ bool GetProxy(enum Network net, proxyType &proxyInfoOut) {\n     return true;\n }\n \n-bool SetNameProxy(CService addrProxy) {\n+bool SetNameProxy(const proxyType &addrProxy) {\n     if (!addrProxy.IsValid())\n         return false;\n     LOCK(cs_proxyInfos);\n     nameProxy = addrProxy;\n     return true;\n }\n \n-bool GetNameProxy(CService &nameProxyOut) {\n+bool GetNameProxy(proxyType &nameProxyOut) {\n     LOCK(cs_proxyInfos);\n     if(!nameProxy.IsValid())\n         return false;\n@@ -513,37 +552,49 @@ bool HaveNameProxy() {\n bool IsProxy(const CNetAddr &addr) {\n     LOCK(cs_proxyInfos);\n     for (int i = 0; i < NET_MAX; i++) {\n-        if (addr == (CNetAddr)proxyInfo[i])\n+        if (addr == (CNetAddr)proxyInfo[i].proxy)\n             return true;\n     }\n     return false;\n }\n \n-bool ConnectSocket(const CService &addrDest, SOCKET& hSocketRet, int nTimeout, bool *outProxyConnectionFailed)\n+static bool ConnectThroughProxy(const proxyType &proxy, const std::string strDest, int port, SOCKET& hSocketRet, int nTimeout, bool *outProxyConnectionFailed)\n {\n-    proxyType proxy;\n-    if (outProxyConnectionFailed)\n-        *outProxyConnectionFailed = false;\n-    // no proxy needed (none set for target network)\n-    if (!GetProxy(addrDest.GetNetwork(), proxy))\n-        return ConnectSocketDirectly(addrDest, hSocketRet, nTimeout);\n-\n     SOCKET hSocket = INVALID_SOCKET;\n-\n     // first connect to proxy server\n-    if (!ConnectSocketDirectly(proxy, hSocket, nTimeout)) {\n+    if (!ConnectSocketDirectly(proxy.proxy, hSocket, nTimeout)) {\n         if (outProxyConnectionFailed)\n             *outProxyConnectionFailed = true;\n         return false;\n     }\n     // do socks negotiation\n-    if (!Socks5(addrDest.ToStringIP(), addrDest.GetPort(), hSocket))\n-        return false;\n+    if (proxy.randomize_credentials) {\n+        ProxyCredentials random_auth;\n+        random_auth.username = strprintf(\"%i\", insecure_rand());\n+        random_auth.password = strprintf(\"%i\", insecure_rand());\n+        if (!Socks5(strDest, (unsigned short)port, &random_auth, hSocket))\n+            return false;\n+    } else {\n+        if (!Socks5(strDest, (unsigned short)port, 0, hSocket))\n+            return false;\n+    }\n \n     hSocketRet = hSocket;\n     return true;\n }\n \n+bool ConnectSocket(const CService &addrDest, SOCKET& hSocketRet, int nTimeout, bool *outProxyConnectionFailed)\n+{\n+    proxyType proxy;\n+    if (outProxyConnectionFailed)\n+        *outProxyConnectionFailed = false;\n+\n+    if (GetProxy(addrDest.GetNetwork(), proxy))\n+        return ConnectThroughProxy(proxy, addrDest.ToStringIP(), addrDest.GetPort(), hSocketRet, nTimeout, outProxyConnectionFailed);\n+    else // no proxy needed (none set for target network)\n+        return ConnectSocketDirectly(addrDest, hSocketRet, nTimeout);\n+}\n+\n bool ConnectSocketByName(CService &addr, SOCKET& hSocketRet, const char *pszDest, int portDefault, int nTimeout, bool *outProxyConnectionFailed)\n {\n     string strDest;\n@@ -554,9 +605,7 @@ bool ConnectSocketByName(CService &addr, SOCKET& hSocketRet, const char *pszDest\n \n     SplitHostPort(string(pszDest), port, strDest);\n \n-    SOCKET hSocket = INVALID_SOCKET;\n-\n-    CService nameProxy;\n+    proxyType nameProxy;\n     GetNameProxy(nameProxy);\n \n     CService addrResolved(CNetAddr(strDest, fNameLookup && !HaveNameProxy()), port);\n@@ -569,18 +618,7 @@ bool ConnectSocketByName(CService &addr, SOCKET& hSocketRet, const char *pszDest\n \n     if (!HaveNameProxy())\n         return false;\n-    // first connect to name proxy server\n-    if (!ConnectSocketDirectly(nameProxy, hSocket, nTimeout)) {\n-        if (outProxyConnectionFailed)\n-            *outProxyConnectionFailed = true;\n-        return false;\n-    }\n-    // do socks negotiation\n-    if (!Socks5(strDest, (unsigned short)port, hSocket))\n-        return false;\n-\n-    hSocketRet = hSocket;\n-    return true;\n+    return ConnectThroughProxy(nameProxy, strDest, port, hSocketRet, nTimeout, outProxyConnectionFailed);\n }\n \n void CNetAddr::Init()"
      },
      {
        "sha": "6d2ca4afb22805ad5a68acc297965ad06c91c875",
        "filename": "src/netbase.h",
        "status": "modified",
        "additions": 13,
        "deletions": 3,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67a79493976a3d5f5dac6ec64993fc3f415cac43/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67a79493976a3d5f5dac6ec64993fc3f415cac43/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=67a79493976a3d5f5dac6ec64993fc3f415cac43",
        "patch": "@@ -168,15 +168,25 @@ class CService : public CNetAddr\n         }\n };\n \n-typedef CService proxyType;\n+class proxyType\n+{\n+public:\n+    proxyType(): randomize_credentials(false) {}\n+    proxyType(const CService &proxy, bool randomize_credentials=false): proxy(proxy), randomize_credentials(randomize_credentials) {}\n+\n+    bool IsValid() const { return proxy.IsValid(); }\n+\n+    CService proxy;\n+    bool randomize_credentials;\n+};\n \n enum Network ParseNetwork(std::string net);\n std::string GetNetworkName(enum Network net);\n void SplitHostPort(std::string in, int &portOut, std::string &hostOut);\n-bool SetProxy(enum Network net, CService addrProxy);\n+bool SetProxy(enum Network net, const proxyType &addrProxy);\n bool GetProxy(enum Network net, proxyType &proxyInfoOut);\n bool IsProxy(const CNetAddr &addr);\n-bool SetNameProxy(CService addrProxy);\n+bool SetNameProxy(const proxyType &addrProxy);\n bool HaveNameProxy();\n bool LookupHost(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions = 0, bool fAllowLookup = true);\n bool Lookup(const char *pszName, CService& addr, int portDefault = 0, bool fAllowLookup = true);"
      },
      {
        "sha": "41d6acf3584fb2d09b801b85902db84dd889c69a",
        "filename": "src/qt/optionsmodel.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67a79493976a3d5f5dac6ec64993fc3f415cac43/src/qt/optionsmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67a79493976a3d5f5dac6ec64993fc3f415cac43/src/qt/optionsmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsmodel.cpp?ref=67a79493976a3d5f5dac6ec64993fc3f415cac43",
        "patch": "@@ -335,8 +335,8 @@ bool OptionsModel::getProxySettings(QNetworkProxy& proxy) const\n     proxyType curProxy;\n     if (GetProxy(NET_IPV4, curProxy)) {\n         proxy.setType(QNetworkProxy::Socks5Proxy);\n-        proxy.setHostName(QString::fromStdString(curProxy.ToStringIP()));\n-        proxy.setPort(curProxy.GetPort());\n+        proxy.setHostName(QString::fromStdString(curProxy.proxy.ToStringIP()));\n+        proxy.setPort(curProxy.proxy.GetPort());\n \n         return true;\n     }"
      },
      {
        "sha": "f5bef2a0779c179f73b1d64dac8bc44bda1a30a7",
        "filename": "src/rpcmisc.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67a79493976a3d5f5dac6ec64993fc3f415cac43/src/rpcmisc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67a79493976a3d5f5dac6ec64993fc3f415cac43/src/rpcmisc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcmisc.cpp?ref=67a79493976a3d5f5dac6ec64993fc3f415cac43",
        "patch": "@@ -90,7 +90,7 @@ Value getinfo(const Array& params, bool fHelp)\n     obj.push_back(Pair(\"blocks\",        (int)chainActive.Height()));\n     obj.push_back(Pair(\"timeoffset\",    GetTimeOffset()));\n     obj.push_back(Pair(\"connections\",   (int)vNodes.size()));\n-    obj.push_back(Pair(\"proxy\",         (proxy.IsValid() ? proxy.ToStringIPPort() : string())));\n+    obj.push_back(Pair(\"proxy\",         (proxy.IsValid() ? proxy.proxy.ToStringIPPort() : string())));\n     obj.push_back(Pair(\"difficulty\",    (double)GetDifficulty()));\n     obj.push_back(Pair(\"testnet\",       Params().TestnetToBeDeprecatedFieldRPC()));\n #ifdef ENABLE_WALLET"
      },
      {
        "sha": "bdee5b9f2e33a2ba8d8c8cb5604d83c2f90fe946",
        "filename": "src/rpcnet.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67a79493976a3d5f5dac6ec64993fc3f415cac43/src/rpcnet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67a79493976a3d5f5dac6ec64993fc3f415cac43/src/rpcnet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcnet.cpp?ref=67a79493976a3d5f5dac6ec64993fc3f415cac43",
        "patch": "@@ -371,7 +371,8 @@ static Array GetNetworksInfo()\n         obj.push_back(Pair(\"name\", GetNetworkName(network)));\n         obj.push_back(Pair(\"limited\", IsLimited(network)));\n         obj.push_back(Pair(\"reachable\", IsReachable(network)));\n-        obj.push_back(Pair(\"proxy\", proxy.IsValid() ? proxy.ToStringIPPort() : string()));\n+        obj.push_back(Pair(\"proxy\", proxy.IsValid() ? proxy.proxy.ToStringIPPort() : string()));\n+        obj.push_back(Pair(\"proxy_randomize_credentials\", proxy.randomize_credentials));\n         networks.push_back(obj);\n     }\n     return networks;"
      }
    ]
  },
  {
    "sha": "6be3562e507d6a3e4c318f79c89e1def073b430c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2YmUzNTYyZTUwN2Q2YTNlNGMzMThmNzljODllMWRlZjA3M2I0MzBj",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-04-17T17:26:03Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-04-20T13:04:33Z"
      },
      "message": "rpc-tests: Add proxy test\n\nAdd test for -proxy, -onion and -proxyrandomize.",
      "tree": {
        "sha": "d836a8e93ecde355895a1e4d9b5ade139358850f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d836a8e93ecde355895a1e4d9b5ade139358850f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6be3562e507d6a3e4c318f79c89e1def073b430c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6be3562e507d6a3e4c318f79c89e1def073b430c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6be3562e507d6a3e4c318f79c89e1def073b430c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6be3562e507d6a3e4c318f79c89e1def073b430c/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "67a79493976a3d5f5dac6ec64993fc3f415cac43",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/67a79493976a3d5f5dac6ec64993fc3f415cac43",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/67a79493976a3d5f5dac6ec64993fc3f415cac43"
      }
    ],
    "stats": {
      "total": 307,
      "additions": 307,
      "deletions": 0
    },
    "files": [
      {
        "sha": "053e8b8a7fa9ee01b1c1afdef3ef7cc9cc20fb39",
        "filename": "qa/pull-tester/rpc-tests.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6be3562e507d6a3e4c318f79c89e1def073b430c/qa/pull-tester/rpc-tests.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6be3562e507d6a3e4c318f79c89e1def073b430c/qa/pull-tester/rpc-tests.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.sh?ref=6be3562e507d6a3e4c318f79c89e1def073b430c",
        "patch": "@@ -27,6 +27,7 @@ testScripts=(\n     'mempool_coinbase_spends.py'\n     'httpbasics.py'\n     'zapwallettxes.py'\n+    'proxy_test.py'\n #    'forknotify.py'\n );\n if [ \"x${ENABLE_BITCOIND}${ENABLE_UTILS}${ENABLE_WALLET}\" = \"x111\" ]; then"
      },
      {
        "sha": "d6d9e6725b60d196001c38805cae8fd7d62cd1a4",
        "filename": "qa/rpc-tests/proxy_test.py",
        "status": "added",
        "additions": 146,
        "deletions": 0,
        "changes": 146,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6be3562e507d6a3e4c318f79c89e1def073b430c/qa/rpc-tests/proxy_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6be3562e507d6a3e4c318f79c89e1def073b430c/qa/rpc-tests/proxy_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/proxy_test.py?ref=6be3562e507d6a3e4c318f79c89e1def073b430c",
        "patch": "@@ -0,0 +1,146 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2015 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+import socket\n+import traceback, sys\n+from binascii import hexlify\n+import time, os\n+\n+from socks5 import Socks5Configuration, Socks5Command, Socks5Server, AddressType\n+from test_framework import BitcoinTestFramework\n+from util import *\n+'''\n+Test plan:\n+- Start bitcoind's with different proxy configurations\n+- Use addnode to initiate connections\n+- Verify that proxies are connected to, and the right connection command is given\n+- Proxy configurations to test on bitcoind side:\n+    - `-proxy` (proxy everything)\n+    - `-onion` (proxy just onions)\n+    - `-proxyrandomize` Circuit randomization\n+- Proxy configurations to test on proxy side,\n+    - support no authentication (other proxy)\n+    - support no authentication + user/pass authentication (Tor)\n+    - proxy on IPv6\n+\n+- Create various proxies (as threads)\n+- Create bitcoinds that connect to them\n+- Manipulate the bitcoinds using addnode (onetry) an observe effects\n+\n+addnode connect to IPv4\n+addnode connect to IPv6\n+addnode connect to onion\n+addnode connect to generic DNS name\n+'''\n+\n+class ProxyTest(BitcoinTestFramework):        \n+    def __init__(self):\n+        # Create two proxies on different ports\n+        # ... one unauthenticated\n+        self.conf1 = Socks5Configuration()\n+        self.conf1.addr = ('127.0.0.1', 13000 + (os.getpid() % 1000))\n+        self.conf1.unauth = True\n+        self.conf1.auth = False\n+        # ... one supporting authenticated and unauthenticated (Tor)\n+        self.conf2 = Socks5Configuration()\n+        self.conf2.addr = ('127.0.0.1', 14000 + (os.getpid() % 1000))\n+        self.conf2.unauth = True\n+        self.conf2.auth = True\n+        # ... one on IPv6 with similar configuration\n+        self.conf3 = Socks5Configuration()\n+        self.conf3.af = socket.AF_INET6\n+        self.conf3.addr = ('::1', 15000 + (os.getpid() % 1000))\n+        self.conf3.unauth = True\n+        self.conf3.auth = True\n+\n+        self.serv1 = Socks5Server(self.conf1)\n+        self.serv1.start()\n+        self.serv2 = Socks5Server(self.conf2)\n+        self.serv2.start()\n+        self.serv3 = Socks5Server(self.conf3)\n+        self.serv3.start()\n+\n+    def setup_nodes(self):\n+        # Note: proxies are not used to connect to local nodes\n+        # this is because the proxy to use is based on CService.GetNetwork(), which return NET_UNROUTABLE for localhost\n+        return start_nodes(4, self.options.tmpdir, extra_args=[\n+            ['-listen', '-debug=net', '-debug=proxy', '-proxy=%s:%i' % (self.conf1.addr),'-proxyrandomize=1'], \n+            ['-listen', '-debug=net', '-debug=proxy', '-proxy=%s:%i' % (self.conf1.addr),'-onion=%s:%i' % (self.conf2.addr),'-proxyrandomize=0'], \n+            ['-listen', '-debug=net', '-debug=proxy', '-proxy=%s:%i' % (self.conf2.addr),'-proxyrandomize=1'], \n+            ['-listen', '-debug=net', '-debug=proxy', '-proxy=[%s]:%i' % (self.conf3.addr),'-proxyrandomize=0']\n+            ])\n+\n+    def node_test(self, node, proxies, auth):\n+        rv = []\n+        # Test: outgoing IPv4 connection through node\n+        node.addnode(\"15.61.23.23:1234\", \"onetry\")\n+        cmd = proxies[0].queue.get()\n+        assert(isinstance(cmd, Socks5Command))\n+        # Note: bitcoind's SOCKS5 implementation only sends atyp DOMAINNAME, even if connecting directly to IPv4/IPv6\n+        assert_equal(cmd.atyp, AddressType.DOMAINNAME)\n+        assert_equal(cmd.addr, \"15.61.23.23\")\n+        assert_equal(cmd.port, 1234)\n+        if not auth:\n+            assert_equal(cmd.username, None)\n+            assert_equal(cmd.password, None)\n+        rv.append(cmd)\n+\n+        # Test: outgoing IPv6 connection through node\n+        node.addnode(\"[1233:3432:2434:2343:3234:2345:6546:4534]:5443\", \"onetry\")\n+        cmd = proxies[1].queue.get()\n+        assert(isinstance(cmd, Socks5Command))\n+        # Note: bitcoind's SOCKS5 implementation only sends atyp DOMAINNAME, even if connecting directly to IPv4/IPv6\n+        assert_equal(cmd.atyp, AddressType.DOMAINNAME)\n+        assert_equal(cmd.addr, \"1233:3432:2434:2343:3234:2345:6546:4534\")\n+        assert_equal(cmd.port, 5443)\n+        if not auth:\n+            assert_equal(cmd.username, None)\n+            assert_equal(cmd.password, None)\n+        rv.append(cmd)\n+\n+        # Test: outgoing onion connection through node\n+        node.addnode(\"bitcoinostk4e4re.onion:8333\", \"onetry\")\n+        cmd = proxies[2].queue.get()\n+        assert(isinstance(cmd, Socks5Command))\n+        assert_equal(cmd.atyp, AddressType.DOMAINNAME)\n+        assert_equal(cmd.addr, \"bitcoinostk4e4re.onion\")\n+        assert_equal(cmd.port, 8333)\n+        if not auth:\n+            assert_equal(cmd.username, None)\n+            assert_equal(cmd.password, None)\n+        rv.append(cmd)\n+\n+        # Test: outgoing DNS name connection through node\n+        node.addnode(\"node.noumenon:8333\", \"onetry\")\n+        cmd = proxies[3].queue.get()\n+        assert(isinstance(cmd, Socks5Command))\n+        assert_equal(cmd.atyp, AddressType.DOMAINNAME)\n+        assert_equal(cmd.addr, \"node.noumenon\")\n+        assert_equal(cmd.port, 8333)\n+        if not auth:\n+            assert_equal(cmd.username, None)\n+            assert_equal(cmd.password, None)\n+        rv.append(cmd)\n+\n+        return rv\n+\n+    def run_test(self):\n+        # basic -proxy\n+        self.node_test(self.nodes[0], [self.serv1, self.serv1, self.serv1, self.serv1], False)\n+\n+        # -proxy plus -onion\n+        self.node_test(self.nodes[1], [self.serv1, self.serv1, self.serv2, self.serv1], False)\n+\n+        # -proxy plus -onion, -proxyrandomize\n+        rv = self.node_test(self.nodes[2], [self.serv2, self.serv2, self.serv2, self.serv2], True)\n+        # Check that credentials as used for -proxyrandomize connections are unique\n+        credentials = set((x.username,x.password) for x in rv)\n+        assert_equal(len(credentials), 4)\n+\n+        # proxy on IPv6 localhost\n+        self.node_test(self.nodes[3], [self.serv3, self.serv3, self.serv3, self.serv3], False)\n+        \n+if __name__ == '__main__':\n+    ProxyTest().main()\n+"
      },
      {
        "sha": "1dbfb98d5d3dd6892825aeaec8e37ca0d1566a98",
        "filename": "qa/rpc-tests/socks5.py",
        "status": "added",
        "additions": 160,
        "deletions": 0,
        "changes": 160,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6be3562e507d6a3e4c318f79c89e1def073b430c/qa/rpc-tests/socks5.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6be3562e507d6a3e4c318f79c89e1def073b430c/qa/rpc-tests/socks5.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/socks5.py?ref=6be3562e507d6a3e4c318f79c89e1def073b430c",
        "patch": "@@ -0,0 +1,160 @@\n+# Copyright (c) 2015 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+'''\n+Dummy Socks5 server for testing.\n+'''\n+from __future__ import print_function, division, unicode_literals\n+import socket, threading, Queue\n+import traceback, sys\n+\n+### Protocol constants\n+class Command:\n+    CONNECT = 0x01\n+\n+class AddressType:\n+    IPV4 = 0x01\n+    DOMAINNAME = 0x03\n+    IPV6 = 0x04\n+\n+### Utility functions\n+def recvall(s, n):\n+    '''Receive n bytes from a socket, or fail'''\n+    rv = bytearray()\n+    while n > 0:\n+        d = s.recv(n)\n+        if not d:\n+            raise IOError('Unexpected end of stream')\n+        rv.extend(d)\n+        n -= len(d)\n+    return rv\n+\n+### Implementation classes\n+class Socks5Configuration(object):\n+    '''Proxy configuration'''\n+    def __init__(self):\n+        self.addr = None # Bind address (must be set)\n+        self.af = socket.AF_INET # Bind address family\n+        self.unauth = False  # Support unauthenticated\n+        self.auth = False  # Support authentication\n+\n+class Socks5Command(object):\n+    '''Information about an incoming socks5 command'''\n+    def __init__(self, cmd, atyp, addr, port, username, password):\n+        self.cmd = cmd # Command (one of Command.*)\n+        self.atyp = atyp # Address type (one of AddressType.*)\n+        self.addr = addr # Address\n+        self.port = port # Port to connect to\n+        self.username = username\n+        self.password = password\n+    def __repr__(self):\n+        return 'Socks5Command(%s,%s,%s,%s,%s,%s)' % (self.cmd, self.atyp, self.addr, self.port, self.username, self.password)\n+\n+class Socks5Connection(object):\n+    def __init__(self, serv, conn, peer):\n+        self.serv = serv\n+        self.conn = conn\n+        self.peer = peer\n+\n+    def handle(self):\n+        '''\n+        Handle socks5 request according to RFC1928\n+        '''\n+        try:\n+            # Verify socks version\n+            ver = recvall(self.conn, 1)[0]\n+            if ver != 0x05:\n+                raise IOError('Invalid socks version %i' % ver)\n+            # Choose authentication method\n+            nmethods = recvall(self.conn, 1)[0]\n+            methods = bytearray(recvall(self.conn, nmethods))\n+            method = None\n+            if 0x02 in methods and self.serv.conf.auth:\n+                method = 0x02 # username/password\n+            elif 0x00 in methods and self.serv.conf.unauth:\n+                method = 0x00 # unauthenticated\n+            if method is None:\n+                raise IOError('No supported authentication method was offered')\n+            # Send response\n+            self.conn.sendall(bytearray([0x05, method]))\n+            # Read authentication (optional)\n+            username = None\n+            password = None\n+            if method == 0x02:\n+                ver = recvall(self.conn, 1)[0]\n+                if ver != 0x01:\n+                    raise IOError('Invalid auth packet version %i' % ver)\n+                ulen = recvall(self.conn, 1)[0]\n+                username = str(recvall(self.conn, ulen))\n+                plen = recvall(self.conn, 1)[0]\n+                password = str(recvall(self.conn, plen))\n+                # Send authentication response\n+                self.conn.sendall(bytearray([0x01, 0x00]))\n+\n+            # Read connect request\n+            (ver,cmd,rsv,atyp) = recvall(self.conn, 4)\n+            if ver != 0x05:\n+                raise IOError('Invalid socks version %i in connect request' % ver)\n+            if cmd != Command.CONNECT:\n+                raise IOError('Unhandled command %i in connect request' % cmd)\n+\n+            if atyp == AddressType.IPV4:\n+                addr = recvall(self.conn, 4)\n+            elif atyp == AddressType.DOMAINNAME:\n+                n = recvall(self.conn, 1)[0]\n+                addr = str(recvall(self.conn, n))\n+            elif atyp == AddressType.IPV6:\n+                addr = recvall(self.conn, 16)\n+            else:\n+                raise IOError('Unknown address type %i' % atyp)\n+            port_hi,port_lo = recvall(self.conn, 2)\n+            port = (port_hi << 8) | port_lo\n+\n+            # Send dummy response\n+            self.conn.sendall(bytearray([0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]))\n+\n+            cmdin = Socks5Command(cmd, atyp, addr, port, username, password)\n+            self.serv.queue.put(cmdin)\n+            print('Proxy: ', cmdin)\n+            # Fall through to disconnect\n+        except Exception,e:\n+            traceback.print_exc(file=sys.stderr)\n+            self.serv.queue.put(e)\n+        finally:\n+            self.conn.close()\n+\n+class Socks5Server(object):\n+    def __init__(self, conf):\n+        self.conf = conf\n+        self.s = socket.socket(conf.af)\n+        self.s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n+        self.s.bind(conf.addr)\n+        self.s.listen(5)\n+        self.running = False\n+        self.thread = None\n+        self.queue = Queue.Queue() # report connections and exceptions to client\n+\n+    def run(self):\n+        while self.running:\n+            (sockconn, peer) = self.s.accept()\n+            if self.running:\n+                conn = Socks5Connection(self, sockconn, peer)\n+                thread = threading.Thread(None, conn.handle)\n+                thread.daemon = True\n+                thread.start()\n+    \n+    def start(self):\n+        assert(not self.running)\n+        self.running = True\n+        self.thread = threading.Thread(None, self.run)\n+        self.thread.daemon = True\n+        self.thread.start()\n+\n+    def stop(self):\n+        self.running = False\n+        # connect to self to end run loop\n+        s = socket.socket(self.conf.af)\n+        s.connect(self.conf.addr)\n+        s.close()\n+        self.thread.join()\n+"
      }
    ]
  }
]