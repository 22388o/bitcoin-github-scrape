[
  {
    "sha": "88d73ab65c8e74c1598f6f457c3c46d6ff9de953",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4OGQ3M2FiNjVjOGU3NGMxNTk4ZjZmNDU3YzNjNDZkNmZmOWRlOTUz",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-03-01T20:10:32Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-06-12T17:23:35Z"
      },
      "message": "[net] Add a global sequence number to SendMessages()\n\nKeep an incrementing counter between loop iterations in ThreadMessageHandler.\n\nThis allows for synchronization between loop iterations in SendMessages.",
      "tree": {
        "sha": "b44085da58994d51c0003291b9fd6b3dad65ee06",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b44085da58994d51c0003291b9fd6b3dad65ee06"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/88d73ab65c8e74c1598f6f457c3c46d6ff9de953",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/88d73ab65c8e74c1598f6f457c3c46d6ff9de953",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/88d73ab65c8e74c1598f6f457c3c46d6ff9de953",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/88d73ab65c8e74c1598f6f457c3c46d6ff9de953/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f792395d13aa99ce51887db14e4f77a746d910e3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f792395d13aa99ce51887db14e4f77a746d910e3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f792395d13aa99ce51887db14e4f77a746d910e3"
      }
    ],
    "stats": {
      "total": 32,
      "additions": 18,
      "deletions": 14
    },
    "files": [
      {
        "sha": "ebd335e20cafc98d6d64c84d423a7ef73960b142",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/88d73ab65c8e74c1598f6f457c3c46d6ff9de953/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/88d73ab65c8e74c1598f6f457c3c46d6ff9de953/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=88d73ab65c8e74c1598f6f457c3c46d6ff9de953",
        "patch": "@@ -1944,8 +1944,10 @@ void CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFai\n \n void CConnman::ThreadMessageHandler()\n {\n+    uint64_t sequence_number = 0;\n     while (!flagInterruptMsgProc)\n     {\n+        ++sequence_number;\n         std::vector<CNode*> vNodesCopy;\n         {\n             LOCK(cs_vNodes);\n@@ -1970,7 +1972,7 @@ void CConnman::ThreadMessageHandler()\n             // Send messages\n             {\n                 LOCK(pnode->cs_sendProcessing);\n-                m_msgproc->SendMessages(pnode);\n+                m_msgproc->SendMessages(pnode, sequence_number);\n             }\n \n             if (flagInterruptMsgProc)"
      },
      {
        "sha": "e9ff9bc7c870373366a4357f2f8104868be97ccf",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/88d73ab65c8e74c1598f6f457c3c46d6ff9de953/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/88d73ab65c8e74c1598f6f457c3c46d6ff9de953/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=88d73ab65c8e74c1598f6f457c3c46d6ff9de953",
        "patch": "@@ -472,7 +472,7 @@ class NetEventsInterface\n {\n public:\n     virtual bool ProcessMessages(CNode* pnode, std::atomic<bool>& interrupt) = 0;\n-    virtual bool SendMessages(CNode* pnode) = 0;\n+    virtual bool SendMessages(CNode* pnode, uint64_t sequence_number) = 0;\n     virtual void InitializeNode(CNode* pnode) = 0;\n     virtual void FinalizeNode(NodeId id, bool& update_connection_time) = 0;\n "
      },
      {
        "sha": "d22ae449ead794cc6ecb66389736b661fb67fc36",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/88d73ab65c8e74c1598f6f457c3c46d6ff9de953/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/88d73ab65c8e74c1598f6f457c3c46d6ff9de953/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=88d73ab65c8e74c1598f6f457c3c46d6ff9de953",
        "patch": "@@ -3514,7 +3514,7 @@ class CompareInvMempoolOrder\n };\n }\n \n-bool PeerLogicValidation::SendMessages(CNode* pto)\n+bool PeerLogicValidation::SendMessages(CNode* pto, uint64_t sequence_number)\n {\n     const Consensus::Params& consensusParams = Params().GetConsensus();\n     {"
      },
      {
        "sha": "2be8ae708eb17a2c9bbb1ff2e0169edfb4c2849b",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/88d73ab65c8e74c1598f6f457c3c46d6ff9de953/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/88d73ab65c8e74c1598f6f457c3c46d6ff9de953/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=88d73ab65c8e74c1598f6f457c3c46d6ff9de953",
        "patch": "@@ -61,9 +61,11 @@ class PeerLogicValidation final : public CValidationInterface, public NetEventsI\n     * Send queued protocol messages to be sent to a give node.\n     *\n     * @param[in]   pto             The node which we are sending messages to.\n+    * @param[in]   sequence_number A counter that increments after SendMessages\n+    *                              has been called on all peers\n     * @return                      True if there is more work to be done\n     */\n-    bool SendMessages(CNode* pto) override EXCLUSIVE_LOCKS_REQUIRED(pto->cs_sendProcessing);\n+    bool SendMessages(CNode* pto, uint64_t sequence_number) override EXCLUSIVE_LOCKS_REQUIRED(pto->cs_sendProcessing);\n \n     /** Consider evicting an outbound peer based on the amount of time they've been behind our tip */\n     void ConsiderEviction(CNode *pto, int64_t time_in_seconds) EXCLUSIVE_LOCKS_REQUIRED(cs_main);"
      },
      {
        "sha": "dcf41572defd75b357b8143b41a1ec090a641aee",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/88d73ab65c8e74c1598f6f457c3c46d6ff9de953/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/88d73ab65c8e74c1598f6f457c3c46d6ff9de953/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=88d73ab65c8e74c1598f6f457c3c46d6ff9de953",
        "patch": "@@ -96,7 +96,7 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n     // Test starts here\n     {\n         LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n-        BOOST_CHECK(peerLogic->SendMessages(&dummyNode1)); // should result in getheaders\n+        BOOST_CHECK(peerLogic->SendMessages(&dummyNode1, 0)); // should result in getheaders\n     }\n     {\n         LOCK2(cs_main, dummyNode1.cs_vSend);\n@@ -109,7 +109,7 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n     SetMockTime(nStartTime+21*60);\n     {\n         LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n-        BOOST_CHECK(peerLogic->SendMessages(&dummyNode1)); // should result in getheaders\n+        BOOST_CHECK(peerLogic->SendMessages(&dummyNode1, 0)); // should result in getheaders\n     }\n     {\n         LOCK2(cs_main, dummyNode1.cs_vSend);\n@@ -119,7 +119,7 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n     SetMockTime(nStartTime+24*60);\n     {\n         LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n-        BOOST_CHECK(peerLogic->SendMessages(&dummyNode1)); // should result in disconnect\n+        BOOST_CHECK(peerLogic->SendMessages(&dummyNode1, 0)); // should result in disconnect\n     }\n     BOOST_CHECK(dummyNode1.fDisconnect == true);\n     SetMockTime(0);\n@@ -233,7 +233,7 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     }\n     {\n         LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n-        BOOST_CHECK(peerLogic->SendMessages(&dummyNode1));\n+        BOOST_CHECK(peerLogic->SendMessages(&dummyNode1, 0));\n     }\n     BOOST_CHECK(banman->IsBanned(addr1));\n     BOOST_CHECK(!banman->IsBanned(ip(0xa0b0c001|0x0000ff00))); // Different IP, not banned\n@@ -250,7 +250,7 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     }\n     {\n         LOCK2(cs_main, dummyNode2.cs_sendProcessing);\n-        BOOST_CHECK(peerLogic->SendMessages(&dummyNode2));\n+        BOOST_CHECK(peerLogic->SendMessages(&dummyNode2, 0));\n     }\n     BOOST_CHECK(!banman->IsBanned(addr2)); // 2 not banned yet...\n     BOOST_CHECK(banman->IsBanned(addr1));  // ... but 1 still should be\n@@ -260,7 +260,7 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     }\n     {\n         LOCK2(cs_main, dummyNode2.cs_sendProcessing);\n-        BOOST_CHECK(peerLogic->SendMessages(&dummyNode2));\n+        BOOST_CHECK(peerLogic->SendMessages(&dummyNode2, 0));\n     }\n     BOOST_CHECK(banman->IsBanned(addr2));\n \n@@ -289,7 +289,7 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n     }\n     {\n         LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n-        BOOST_CHECK(peerLogic->SendMessages(&dummyNode1));\n+        BOOST_CHECK(peerLogic->SendMessages(&dummyNode1, 0));\n     }\n     BOOST_CHECK(!banman->IsBanned(addr1));\n     {\n@@ -298,7 +298,7 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n     }\n     {\n         LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n-        BOOST_CHECK(peerLogic->SendMessages(&dummyNode1));\n+        BOOST_CHECK(peerLogic->SendMessages(&dummyNode1, 0));\n     }\n     BOOST_CHECK(!banman->IsBanned(addr1));\n     {\n@@ -307,7 +307,7 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n     }\n     {\n         LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n-        BOOST_CHECK(peerLogic->SendMessages(&dummyNode1));\n+        BOOST_CHECK(peerLogic->SendMessages(&dummyNode1, 0));\n     }\n     BOOST_CHECK(banman->IsBanned(addr1));\n     gArgs.ForceSetArg(\"-banscore\", std::to_string(DEFAULT_BANSCORE_THRESHOLD));\n@@ -339,7 +339,7 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     }\n     {\n         LOCK2(cs_main, dummyNode.cs_sendProcessing);\n-        BOOST_CHECK(peerLogic->SendMessages(&dummyNode));\n+        BOOST_CHECK(peerLogic->SendMessages(&dummyNode, 0));\n     }\n     BOOST_CHECK(banman->IsBanned(addr));\n "
      }
    ]
  },
  {
    "sha": "7249cad634a0de9fff55ea632899d99c50277bbd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3MjQ5Y2FkNjM0YTBkZTlmZmY1NWVhNjMyODk5ZDk5YzUwMjc3YmJk",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2018-12-21T19:40:04Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-06-12T17:57:00Z"
      },
      "message": "[p2p] Maintain a set of outbound peers",
      "tree": {
        "sha": "d41d66b314224eb82297988d1a67b772667d9153",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d41d66b314224eb82297988d1a67b772667d9153"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7249cad634a0de9fff55ea632899d99c50277bbd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7249cad634a0de9fff55ea632899d99c50277bbd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7249cad634a0de9fff55ea632899d99c50277bbd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7249cad634a0de9fff55ea632899d99c50277bbd/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "88d73ab65c8e74c1598f6f457c3c46d6ff9de953",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/88d73ab65c8e74c1598f6f457c3c46d6ff9de953",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/88d73ab65c8e74c1598f6f457c3c46d6ff9de953"
      }
    ],
    "stats": {
      "total": 9,
      "additions": 8,
      "deletions": 1
    },
    "files": [
      {
        "sha": "9d1514ec5043b7166d71ac029a99776ac15521d7",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7249cad634a0de9fff55ea632899d99c50277bbd/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7249cad634a0de9fff55ea632899d99c50277bbd/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=7249cad634a0de9fff55ea632899d99c50277bbd",
        "patch": "@@ -395,6 +395,7 @@ limitedmap<uint256, int64_t> g_already_asked_for GUARDED_BY(cs_main)(MAX_INV_SZ)\n \n /** Map maintaining per-node state. */\n static std::map<NodeId, CNodeState> mapNodeState GUARDED_BY(cs_main);\n+static std::set<NodeId> g_outbound_peers GUARDED_BY(cs_main);\n \n static CNodeState *State(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n     std::map<NodeId, CNodeState>::iterator it = mapNodeState.find(pnode);\n@@ -770,9 +771,13 @@ void PeerLogicValidation::InitializeNode(CNode *pnode) {\n     {\n         LOCK(cs_main);\n         mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, std::move(addrName), pnode->fInbound, pnode->m_manual_connection));\n+        if (!pnode->fInbound) {\n+            g_outbound_peers.insert(nodeid);\n+        }\n     }\n-    if(!pnode->fInbound)\n+    if(!pnode->fInbound) {\n         PushNodeVersion(pnode, connman, GetTime());\n+    }\n }\n \n void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n@@ -798,6 +803,7 @@ void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTim\n     g_outbound_peers_with_protect_from_disconnect -= state->m_chain_sync.m_protect;\n     assert(g_outbound_peers_with_protect_from_disconnect >= 0);\n \n+    g_outbound_peers.erase(nodeid);\n     mapNodeState.erase(nodeid);\n \n     if (mapNodeState.empty()) {\n@@ -806,6 +812,7 @@ void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTim\n         assert(nPreferredDownload == 0);\n         assert(nPeersWithValidatedDownloads == 0);\n         assert(g_outbound_peers_with_protect_from_disconnect == 0);\n+        assert(g_outbound_peers.empty());\n     }\n     LogPrint(BCLog::NET, \"Cleared nodestate for peer=%d\\n\", nodeid);\n }"
      }
    ]
  },
  {
    "sha": "b8ca5961389b15e922d19f5745c46e5845c5c8ae",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiOGNhNTk2MTM4OWIxNWU5MjJkMTlmNTc0NWM0NmU1ODQ1YzVjOGFl",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-02-27T16:52:07Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-06-16T18:21:04Z"
      },
      "message": "Refactor transaction getdata request logic",
      "tree": {
        "sha": "dc0dd7b4e39089568682e7ed7fe2878d7c12a4d9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/dc0dd7b4e39089568682e7ed7fe2878d7c12a4d9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b8ca5961389b15e922d19f5745c46e5845c5c8ae",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b8ca5961389b15e922d19f5745c46e5845c5c8ae",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b8ca5961389b15e922d19f5745c46e5845c5c8ae",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b8ca5961389b15e922d19f5745c46e5845c5c8ae/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7249cad634a0de9fff55ea632899d99c50277bbd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7249cad634a0de9fff55ea632899d99c50277bbd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7249cad634a0de9fff55ea632899d99c50277bbd"
      }
    ],
    "stats": {
      "total": 69,
      "additions": 41,
      "deletions": 28
    },
    "files": [
      {
        "sha": "f30076afa212efc0892c71d4b5655c7b79b594c5",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 28,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b8ca5961389b15e922d19f5745c46e5845c5c8ae/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b8ca5961389b15e922d19f5745c46e5845c5c8ae/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=b8ca5961389b15e922d19f5745c46e5845c5c8ae",
        "patch": "@@ -192,7 +192,11 @@ namespace {\n     static std::vector<std::pair<uint256, CTransactionRef>> vExtraTxnForCompact GUARDED_BY(g_cs_orphans);\n } // namespace\n \n+bool static AlreadyHave(const CInv& inv) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+static uint32_t GetFetchFlags(CNode* pfrom) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n namespace {\n+\n struct CBlockReject {\n     unsigned char chRejectCode;\n     std::string strRejectReason;\n@@ -746,6 +750,42 @@ void RequestTx(CNodeState* state, const uint256& txid, int64_t nNow) EXCLUSIVE_L\n     peer_download_state.m_tx_process_time.emplace(process_time, txid);\n }\n \n+//! Given a txid and a peer that we'd like to consider downloading a transaction\n+//! from: add an appropriate INV message to get_data if it is time to request\n+//! the transaction from the peer, and update the appropriate tx download state\n+//! (both the global state and the peer's state). Send a getdata message if the\n+//! get_data vector grows too large.\n+void TryRequestTx(CNodeState &state, CNode *pto, const uint256 &txid, std::vector<CInv> &get_data, const int64_t nNow, CConnman *connman, const CNetMsgMaker& msg_maker) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+{\n+    CInv inv(MSG_TX | GetFetchFlags(pto), txid);\n+    if (!AlreadyHave(inv)) {\n+        // If this transaction was last requested more than 1 minute ago,\n+        // then request.\n+        int64_t last_request_time = GetTxRequestTime(inv.hash);\n+        if (last_request_time <= nNow - GETDATA_TX_INTERVAL) {\n+            LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->GetId());\n+            get_data.push_back(inv);\n+            if (get_data.size() >= MAX_GETDATA_SZ) {\n+                connman->PushMessage(pto, msg_maker.Make(NetMsgType::GETDATA, get_data));\n+                get_data.clear();\n+            }\n+            UpdateTxRequestTime(inv.hash, nNow);\n+            state.m_tx_download.m_tx_in_flight.emplace(inv.hash, nNow);\n+        } else {\n+            // This transaction is in flight from someone else; queue\n+            // up processing to happen after the download times out\n+            // (with a slight delay for inbound peers, to prefer\n+            // requests to outbound peers).\n+            int64_t next_process_time = CalculateTxGetDataTime(txid, nNow, !state.fPreferredDownload);\n+            state.m_tx_download.m_tx_process_time.emplace(next_process_time, txid);\n+        }\n+    } else {\n+        // We have already seen this transaction, no need to download.\n+        state.m_tx_download.m_tx_announced.erase(inv.hash);\n+        state.m_tx_download.m_tx_in_flight.erase(inv.hash);\n+    }\n+}\n+\n } // namespace\n \n // This function is used for testing the stale tip eviction logic, see\n@@ -4020,36 +4060,9 @@ bool PeerLogicValidation::SendMessages(CNode* pto, uint64_t sequence_number)\n             // Erase this entry from tx_process_time (it may be added back for\n             // processing at a later time, see below)\n             tx_process_time.erase(tx_process_time.begin());\n-            CInv inv(MSG_TX | GetFetchFlags(pto), txid);\n-            if (!AlreadyHave(inv)) {\n-                // If this transaction was last requested more than 1 minute ago,\n-                // then request.\n-                int64_t last_request_time = GetTxRequestTime(inv.hash);\n-                if (last_request_time <= nNow - GETDATA_TX_INTERVAL) {\n-                    LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->GetId());\n-                    vGetData.push_back(inv);\n-                    if (vGetData.size() >= MAX_GETDATA_SZ) {\n-                        connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n-                        vGetData.clear();\n-                    }\n-                    UpdateTxRequestTime(inv.hash, nNow);\n-                    state.m_tx_download.m_tx_in_flight.emplace(inv.hash, nNow);\n-                } else {\n-                    // This transaction is in flight from someone else; queue\n-                    // up processing to happen after the download times out\n-                    // (with a slight delay for inbound peers, to prefer\n-                    // requests to outbound peers).\n-                    int64_t next_process_time = CalculateTxGetDataTime(txid, nNow, !state.fPreferredDownload);\n-                    tx_process_time.emplace(next_process_time, txid);\n-                }\n-            } else {\n-                // We have already seen this transaction, no need to download.\n-                state.m_tx_download.m_tx_announced.erase(inv.hash);\n-                state.m_tx_download.m_tx_in_flight.erase(inv.hash);\n-            }\n+            TryRequestTx(state, pto, txid, vGetData, nNow, connman, msgMaker);\n         }\n \n-\n         if (!vGetData.empty())\n             connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n "
      }
    ]
  },
  {
    "sha": "753883512aab5ec8fedef8723c96c91fe4822b5b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3NTM4ODM1MTJhYWI1ZWM4ZmVkZWY4NzIzYzk2YzkxZmU0ODIyYjVi",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2018-12-21T19:48:33Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-06-16T18:56:07Z"
      },
      "message": "Request NOTFOUND transactions immediately\n\nThanks to James O'Beirne for some of the code in this patch.",
      "tree": {
        "sha": "964afb83a3dcc5b9d3ee04882051b5b584fbcb62",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/964afb83a3dcc5b9d3ee04882051b5b584fbcb62"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/753883512aab5ec8fedef8723c96c91fe4822b5b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/753883512aab5ec8fedef8723c96c91fe4822b5b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/753883512aab5ec8fedef8723c96c91fe4822b5b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/753883512aab5ec8fedef8723c96c91fe4822b5b/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b8ca5961389b15e922d19f5745c46e5845c5c8ae",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b8ca5961389b15e922d19f5745c46e5845c5c8ae",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b8ca5961389b15e922d19f5745c46e5845c5c8ae"
      }
    ],
    "stats": {
      "total": 57,
      "additions": 56,
      "deletions": 1
    },
    "files": [
      {
        "sha": "077fe682050eed7b415c19c58a1c183a86ac022b",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 56,
        "deletions": 1,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/753883512aab5ec8fedef8723c96c91fe4822b5b/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/753883512aab5ec8fedef8723c96c91fe4822b5b/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=753883512aab5ec8fedef8723c96c91fe4822b5b",
        "patch": "@@ -79,7 +79,8 @@ static_assert(INBOUND_PEER_TX_DELAY >= MAX_GETDATA_RANDOM_DELAY,\n \"To preserve security, MAX_GETDATA_RANDOM_DELAY should not exceed INBOUND_PEER_DELAY\");\n /** Limit to avoid sending big packets. Not used in processing incoming GETDATA for compatibility */\n static const unsigned int MAX_GETDATA_SZ = 1000;\n-\n+/** Maximum number of NOTFOUND notifications we'll push to other peers */\n+static constexpr int32_t MAX_PEER_NOTFOUND = 100;\n \n struct COrphanTx {\n     // When modifying, adapt the copy of this definition in tests/DoS_tests.\n@@ -312,6 +313,15 @@ struct CNodeState {\n      *   an adversary from using inbound connections to blind us to a\n      *   transaction (InvBlock).\n      *\n+     *   When we call SendMessages() for a given peer, we'll first check to see\n+     *   if any NOTFOUND transactions have been added to m_tx_not_found -- we may\n+     *   have a txid queued up for download sometime in the future, but as soon\n+     *   as we've gotten a NOTFOUND from the peer we requested it from, we want\n+     *   to try downloading from a backup peer that has announced it. So we\n+     *   loop over the contents of m_tx_not_found, and request any transactions\n+     *   that have not yet been requested by others (within the\n+     *   MAX_GETDATA_TX_DELAY window).\n+     *\n      *   When we call SendMessages() for a given peer,\n      *   we will loop over the transactions in m_tx_process_time, looking\n      *   at the transactions whose process_time <= nNow. We'll request each\n@@ -341,6 +351,11 @@ struct CNodeState {\n      *   peers.\n      */\n     struct TxDownloadState {\n+        /* Notifications of NOTFOUND transactions (from other peers) which\n+         * this peer has recently announced.\n+         */\n+        std::list<uint256> m_tx_not_found;\n+\n         /* Track when to attempt download of announced transactions (process\n          * time in micros -> txid)\n          */\n@@ -843,7 +858,9 @@ void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTim\n     g_outbound_peers_with_protect_from_disconnect -= state->m_chain_sync.m_protect;\n     assert(g_outbound_peers_with_protect_from_disconnect >= 0);\n \n+    // Remove entry from g_outbound_peers, if present.\n     g_outbound_peers.erase(nodeid);\n+\n     mapNodeState.erase(nodeid);\n \n     if (mapNodeState.empty()) {\n@@ -3233,6 +3250,23 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     }\n                     state->m_tx_download.m_tx_in_flight.erase(in_flight_it);\n                     state->m_tx_download.m_tx_announced.erase(inv.hash);\n+                    EraseTxRequest(inv.hash);\n+                    // If we don't already have this transaction, check to see\n+                    // if any of our outbound peers have offered it to us, and\n+                    // if so signal them to try to request immediately. This avoids\n+                    // waiting for the download timeout to expire before\n+                    // re-requesting a transaction.\n+                    if (!AlreadyHave(inv)) {\n+                        for (const NodeId& outbound_id : g_outbound_peers) {\n+                            if (outbound_id == pfrom->GetId()) continue;\n+                            CNodeState *node_state = State(outbound_id);\n+                            if (!node_state->m_tx_download.m_tx_announced.count(inv.hash)) continue;\n+                            while (node_state->m_tx_download.m_tx_not_found.size() >= MAX_PEER_NOTFOUND) {\n+                                node_state->m_tx_download.m_tx_not_found.erase(state->m_tx_download.m_tx_not_found.begin());\n+                            }\n+                            node_state->m_tx_download.m_tx_not_found.push_back(inv.hash);\n+                        }\n+                    }\n                 }\n             }\n         }\n@@ -4054,6 +4088,27 @@ bool PeerLogicValidation::SendMessages(CNode* pto, uint64_t sequence_number)\n             state.m_tx_download.m_check_expiry_timer = nNow + TX_EXPIRY_INTERVAL/2 + GetRand(TX_EXPIRY_INTERVAL);\n         }\n \n+        // First check to see if there's anything in our notfound queue to request.\n+        if (!state.m_tx_download.m_tx_not_found.empty()) {\n+            // Check to see if it's our turn to drain the NOTFOUND queue.\n+            // The idea is that we would like to randomly assign NOTFOUND\n+            // transactions' next download request uniformly at random to our\n+            // outbound peers, even though we don't necessarily know which ones\n+            // will have the transaction available to download and not be up\n+            // against their in-flight limit (or any other future restrictions\n+            // we might impose).\n+            // Our algorithm is to use the SendMessages sequence number to rotate\n+            // through our outbound peers in turn.\n+            auto outbound_it = g_outbound_peers.begin();\n+            std::advance(outbound_it, sequence_number % g_outbound_peers.size());\n+            if (*outbound_it == pto->GetId()) {\n+                while (!state.m_tx_download.m_tx_not_found.empty() && state.m_tx_download.m_tx_in_flight.size() < MAX_PEER_TX_IN_FLIGHT) {\n+                    TryRequestTx(state, pto, state.m_tx_download.m_tx_not_found.front(), vGetData, nNow, connman, msgMaker);\n+                    state.m_tx_download.m_tx_not_found.pop_front();\n+                }\n+            }\n+        }\n+\n         auto& tx_process_time = state.m_tx_download.m_tx_process_time;\n         while (!tx_process_time.empty() && tx_process_time.begin()->first <= nNow && state.m_tx_download.m_tx_in_flight.size() < MAX_PEER_TX_IN_FLIGHT) {\n             const uint256 txid = tx_process_time.begin()->second;"
      }
    ]
  }
]