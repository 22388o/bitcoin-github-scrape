DrahtBot,2019-02-28T21:31:58Z,"<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#16279](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/16279.html) (Return the AcceptBlock CValidationState dir",https://github.com/bitcoin/bitcoin/pull/15505#issuecomment-468446603,468446603,
sdaftuar,2019-03-01T15:32:38Z,"Thanks for the nits; I'll address them later, but in the meantime I'm open to suggestions on how to better implement the random assignment of notfound transactions to the outbound peers that have announced them (I think the logic I have here should work, but it's a bit gross).",https://github.com/bitcoin/bitcoin/pull/15505#issuecomment-468704486,468704486,
sdaftuar,2019-03-01T20:25:23Z,"@jamesob Thanks for the helpful suggestions.  I rewrote this with `g_outbound_peers` being a set, and moving the global sequence number needed for peer selection to be in the interface between net and net_processing.  (It seems to me like the idea of having synchronization between loop iterations in ThreadMessageHandler is something that is occasionally useful in net_processing, so I hope the inte",https://github.com/bitcoin/bitcoin/pull/15505#issuecomment-468800182,468800182,
naumenkogs,2019-03-01T21:56:36Z,"I must be misunderstanding something.\n\nImagine we have 2 peers:\n[p1, p2]\nStart with seq_num = 1\n\nSendMessages(p1, 1 % 2 = 1): false\nSendMessages(p2, 1 % 2 = 1): false\n\nSendMessages(p1, 2 % 2 = 0): true\nSendMessages(p2, 2 % 2 = 0): true\n\nSo, p1 will be always called before p2 (and much likely to request something from p1)?",https://github.com/bitcoin/bitcoin/pull/15505#issuecomment-468825799,468825799,
jamesob,2019-03-01T22:02:45Z,@naumenkogs it's not the result of the modulus that is evaluated to determine whether to `notfound` flush for a given peer; `sequence_number % num_outbounds` is used as an index into the set of outbounds which then determines the peer whose turn it is to flush.,https://github.com/bitcoin/bitcoin/pull/15505#issuecomment-468827382,468827382,
sdaftuar,2019-03-01T22:04:54Z,"Let's say we have 2 peers, p1 and p2 in `g_outbound_peers`, and let's assume the `std::set` comparator puts them in that order when iterating through `g_outbound_peers`.  Let's also say both of them have something in their respective notfound queues.\n\nWhen the sequence number is 1, then 1 % 2 == 1, so we look at g_outbound_peers.begin() + 1, and we get p2's nodeid.  When we call SendMessage on",https://github.com/bitcoin/bitcoin/pull/15505#issuecomment-468827897,468827897,
naumenkogs,2019-03-01T22:07:12Z,"@sdaftuar @jamesob I see, you're right, thanks.\n\nI was not a big fan of extra sequence_numbers, but based on the discussion above and some thinking I don't see a cleaner way to select a peer in a fair way. This sequence_number is also likely to be useful somewhere else in future.\n\nutACK",https://github.com/bitcoin/bitcoin/pull/15505#issuecomment-468828466,468828466,
jamesob,2019-03-05T19:41:56Z,"utACK https://github.com/bitcoin/bitcoin/pull/15505/commits/f5dbb49c8922cb26d05862b7aacf161bde8ffc5a\n\nI was going to write a functional test for this, but I'm not sure there's a sensible way to do that given that it looks like we can't force `P2PDataStore` clients to be outbound connections for nodes under test. (see also: https://github.com/bitcoin/bitcoin/issues/14210)\n\nIf anyone can thi",https://github.com/bitcoin/bitcoin/pull/15505#issuecomment-469829789,469829789,
sdaftuar,2019-06-05T15:16:45Z,Closing for now.,https://github.com/bitcoin/bitcoin/pull/15505#issuecomment-499128040,499128040,
sdaftuar,2019-07-22T14:28:49Z,"Seems like not much interest here, closing for now.",https://github.com/bitcoin/bitcoin/pull/15505#issuecomment-513815553,513815553,
jkczyz,2019-07-30T23:41:06Z,"Rather than using a sequence number to determine which peer's notfound queue to drain, would the following work?\n\n1. When a `notfound` message is received, add each transaction to the notfound queue of a random peer selected from those that have announced the transaction.\n1. Unconditionally drain each peer's notfound queue.\n\nThis would avoid the added complexity of a sequence number. It ",https://github.com/bitcoin/bitcoin/pull/15505#issuecomment-516636613,516636613,
DrahtBot,2019-10-29T19:35:06Z,<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase,https://github.com/bitcoin/bitcoin/pull/15505#issuecomment-547593695,547593695,
jnewbery,2019-11-13T20:13:11Z,"@sdaftuar what do you think about @jkczyz's suggestion for randomly selecting which peer to request the tx from? Conceptually, I think I prefer it to the sequence counter in the net/net_processing interface.",https://github.com/bitcoin/bitcoin/pull/15505#issuecomment-553581678,553581678,
sdaftuar,2019-11-14T20:28:48Z,"> Rather than using a sequence number to determine which peer's notfound queue to drain, would the following work?\n> \n> 1. When a `notfound` message is received, add each transaction to the notfound queue of a random peer selected from those that have announced the transaction.\n> 2. Unconditionally drain each peer's notfound queue.\n\nThe reason I tend to avoid an approach like this is bec",https://github.com/bitcoin/bitcoin/pull/15505#issuecomment-554065417,554065417,
MarcoFalke,2019-11-15T19:39:12Z,@sdaftuar Are you still working on this to get it rebased or would you prefer some to take it over?,https://github.com/bitcoin/bitcoin/pull/15505#issuecomment-554499665,554499665,
sdaftuar,2019-11-15T20:07:50Z,Please consider this up for grabs.,https://github.com/bitcoin/bitcoin/pull/15505#issuecomment-554509350,554509350,
fanquake,2020-01-05T03:30:30Z,Going to close. @naumenkogs you might be interested in following up here?,https://github.com/bitcoin/bitcoin/pull/15505#issuecomment-570847699,570847699,
jamesob,2019-02-28T22:31:05Z,Seems like this could be a lot more succinct with [`vector::erase`](https://en.cppreference.com/w/cpp/container/vector/erase) - is there some reason to do it this way?,https://github.com/bitcoin/bitcoin/pull/15505#discussion_r261411613,261411613,src/net_processing.cpp
naumenkogs,2019-02-28T23:18:02Z,This comment seems outdated,https://github.com/bitcoin/bitcoin/pull/15505#discussion_r261425941,261425941,src/net_processing.cpp
practicalswift,2019-03-01T07:29:53Z,This `state` shadows the `state` in the outer scope.,https://github.com/bitcoin/bitcoin/pull/15505#discussion_r261501879,261501879,src/net_processing.cpp
practicalswift,2019-03-01T07:31:03Z,"I've got an important nessage for you: this should be ""message"".",https://github.com/bitcoin/bitcoin/pull/15505#discussion_r261502066,261502066,src/net_processing.cpp
jamesob,2019-03-01T15:09:27Z,"Nice doc. To get [doxygen](https://github.com/bitcoin/bitcoin/blob/master/doc/developer-notes.md#coding-style-doxygen-compatible-comments) to pick this up, you'll have to do\n```cpp\n//! this\n/// or this\n/**\n * or this\n */\n```",https://github.com/bitcoin/bitcoin/pull/15505#discussion_r261637907,261637907,src/net_processing.cpp
jamesob,2019-03-01T15:19:05Z,"This is just a style/readability thing, but you can avoid indenting the next ~23 lines by changing this to \n```cpp\nif (inv.type != MSG_TX && inv.type != MSG_WITNESS_TX) {\n    continue;\n}\n```",https://github.com/bitcoin/bitcoin/pull/15505#discussion_r261641756,261641756,src/net_processing.cpp
jamesob,2019-03-01T15:29:52Z,"Aid for fellow reviewers: `NOTFOUND` messages are assembled [here](https://github.com/bitcoin/bitcoin/blob/master/src/net_processing.cpp#L1458-L1468) and their structure exactly resembles `INV`s, which is why we can deserialize using `cInv` below.",https://github.com/bitcoin/bitcoin/pull/15505#discussion_r261646342,261646342,src/net_processing.cpp
sdaftuar,2019-03-01T15:31:47Z,"I guess I have an aversion to vector::erase because it requires moving all the other entries.  Possibly that concern doesn't make sense for such a small vector?\n\nBut the bigger issue here is why this is a vector at all -- originally I had this as a set, but then I changed it to be a vector in order to make the logic around when to drain the notfound queue for each peer make sense.  In short, I",https://github.com/bitcoin/bitcoin/pull/15505#discussion_r261647081,261647081,src/net_processing.cpp
jamesob,2019-03-01T15:55:31Z,"IMO more clearly written as\n```cpp\nif (!state->m_tx_download.m_tx_in_flight.count(inv.hash)) {\n...\n}\n```",https://github.com/bitcoin/bitcoin/pull/15505#discussion_r261656447,261656447,src/net_processing.cpp
jamesob,2019-03-01T16:15:55Z,"Correct me if I'm wrong here, but isn't this equivalent to doing something like\n```cpp\nif (GetRandInt(/* nMax= */g_outbound_peers.size()) == 0) {\n...\n}\n```\n?\n\nIf you think the potential performance difference (which IMO is probably negligible when shoulder-to-shoulder with network IO) is okay, just doing something like that would allow you to keep `g_outbound_peers` a set and prese",https://github.com/bitcoin/bitcoin/pull/15505#discussion_r261664629,261664629,src/net_processing.cpp
sdaftuar,2019-03-01T16:55:01Z,"Doing a 1 in N draw each time would introduce a bias to peers that are earlier in the loop, versus ones that are later in the loop.  Imagine if N=2, and we have two peers, peer0 and peer1.  peer0 would be selected with probability 1/2 + 1/8 + 1/32 + ... = 2/3.  If N=8, I think the first peer would have a 19% chance of being selected.",https://github.com/bitcoin/bitcoin/pull/15505#discussion_r261679609,261679609,src/net_processing.cpp
sdaftuar,2019-03-01T17:03:11Z,"I just realized that my hacky implementation here is broken too -- the `not_found_counter` will basically increment by the number of peers we have, so if the number of peers we have is equal the number of outbound peers we have (a common state for non-listening nodes) then we'll always be requesting notfound's from the first peer.",https://github.com/bitcoin/bitcoin/pull/15505#discussion_r261682428,261682428,src/net_processing.cpp
jamesob,2019-03-01T17:46:40Z,"I'm not sure I see how there's any bias based on the ordering of peers - the `GetRandInt` thing is an independent trial across peers, though of course we may end up draining multiple peers' `m_not_found` per single [`ThreadMessageHandler` loop](https://github.com/bitcoin/bitcoin/blob/master/src/net.cpp#L1954-L1978) if two peers both get `1/num_outbounds` lucky. Is there a reason we'd want to avoid",https://github.com/bitcoin/bitcoin/pull/15505#discussion_r261696397,261696397,src/net_processing.cpp
sdaftuar,2019-03-01T20:21:45Z,Fixed.,https://github.com/bitcoin/bitcoin/pull/15505#discussion_r261745805,261745805,src/net_processing.cpp
sdaftuar,2019-03-01T20:22:25Z,Fixed.,https://github.com/bitcoin/bitcoin/pull/15505#discussion_r261745982,261745982,src/net_processing.cpp
sdaftuar,2019-03-01T20:22:32Z,Fixed.,https://github.com/bitcoin/bitcoin/pull/15505#discussion_r261746003,261746003,src/net_processing.cpp
sdaftuar,2019-03-01T20:22:49Z,Done.,https://github.com/bitcoin/bitcoin/pull/15505#discussion_r261746079,261746079,src/net_processing.cpp
sdaftuar,2019-03-01T20:22:58Z,"Will leave as-is -- in this case I like being able to tell that the code block exactly matches the if condition, rather than matching the opposite of an if condition above it that would have caused the loop iteration to be skipped.",https://github.com/bitcoin/bitcoin/pull/15505#discussion_r261746119,261746119,src/net_processing.cpp
sdaftuar,2019-03-01T20:23:11Z,"Oops, I meant to use the iterator in the erase() call, saving an extra map lookup.  Just did that in the latest commit.",https://github.com/bitcoin/bitcoin/pull/15505#discussion_r261746168,261746168,src/net_processing.cpp
sdaftuar,2019-03-01T20:23:36Z,"Ok I redid this to be (hopefully) better, thanks.",https://github.com/bitcoin/bitcoin/pull/15505#discussion_r261746278,261746278,src/net_processing.cpp
