[
  {
    "sha": "32ca5de2af36e71aa720c2400836be7b0313b2a4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozMmNhNWRlMmFmMzZlNzFhYTcyMGMyNDAwODM2YmU3YjAzMTNiMmE0",
    "commit": {
      "author": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2013-05-29T07:33:22Z"
      },
      "committer": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2014-06-06T09:52:41Z"
      },
      "message": "Add simple replace-by-fee logic to mempool.\n\nReplaces transactions if a new transaction is seen with a higher fee,\nspecifically both a higher fee per KB and a higher absolute fee.\nChildren are evaluated for replacement as well, using a fixed\ndepth/breadth limit to prevent DoS attacks.\n\nThanks-to Zeilap for code review and suggestions.",
      "tree": {
        "sha": "6f90a4ac918c511969c265c73bb8748f09511267",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6f90a4ac918c511969c265c73bb8748f09511267"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/32ca5de2af36e71aa720c2400836be7b0313b2a4",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.14 (GNU/Linux)\n\niQGrBAABCACVBQJTkY9sXhSAAAAAABUAQGJsb2NraGFzaEBiaXRjb2luLm9yZzAw\nMDAwMDAwMDAwMDAwMDAzYTNmNzc5YzQ4M2UzODZmYWE3NDMyYTVhNzhkYzc4ZGJj\nNzJhNjg3MTBhMzRlNGYvFIAAAAAAFQARcGthLWFkZHJlc3NAZ251cGcub3JncGV0\nZUBwZXRlcnRvZC5vcmcACgkQJIFAPaXwkfsPMwf8DSQ++1ysmG3GjA/uvEaqVo83\nL40T7s6Q3dEdMhjzmnGo8NSGd5tZzclbhyS7U2ItjVglwFSq1+p9kewrC1RyOuKk\nTtZeIMMiVuXwhuQHPP5NYTR6eO0jPCTQIem4fygXfAqaCdeZyjd8C9BNMDDS3FDN\nchAiALsPuGkSmAhTj+Td2xS3vmCg3maPmkA6F/+3zQZJnEpjXRnYhW5WRGE2ODMu\ngBg1VpBS3in/UIwIo7Qh20qahI8cQIl2iJyt4Tpp5HCO4TEcEouzy4Sysh17+39H\nNgzUXW3+oIJL2M338utCFzxqbP/m26VhHlsGEDEFxjQMP6WdvYg39vTg/mTr/g==\n=XlTi\n-----END PGP SIGNATURE-----",
        "payload": "tree 6f90a4ac918c511969c265c73bb8748f09511267\nparent 345cb52e8ba878ca3e2590d5792b733ec11a1f0d\nauthor Peter Todd <pete@petertodd.org> 1369812802 -0400\ncommitter Peter Todd <pete@petertodd.org> 1402048361 -0400\n\nAdd simple replace-by-fee logic to mempool.\n\nReplaces transactions if a new transaction is seen with a higher fee,\nspecifically both a higher fee per KB and a higher absolute fee.\nChildren are evaluated for replacement as well, using a fixed\ndepth/breadth limit to prevent DoS attacks.\n\nThanks-to Zeilap for code review and suggestions.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/32ca5de2af36e71aa720c2400836be7b0313b2a4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/32ca5de2af36e71aa720c2400836be7b0313b2a4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/32ca5de2af36e71aa720c2400836be7b0313b2a4/comments",
    "author": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "345cb52e8ba878ca3e2590d5792b733ec11a1f0d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/345cb52e8ba878ca3e2590d5792b733ec11a1f0d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/345cb52e8ba878ca3e2590d5792b733ec11a1f0d"
      }
    ],
    "stats": {
      "total": 109,
      "additions": 95,
      "deletions": 14
    },
    "files": [
      {
        "sha": "1626f5fb0e0451a700530c1d24e5b8bc5e7a3a7d",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 95,
        "deletions": 14,
        "changes": 109,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32ca5de2af36e71aa720c2400836be7b0313b2a4/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32ca5de2af36e71aa720c2400836be7b0313b2a4/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=32ca5de2af36e71aa720c2400836be7b0313b2a4",
        "patch": "@@ -843,24 +843,13 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n     if (pool.exists(hash))\n         return false;\n \n-    // Check for conflicts with in-memory transactions\n-    {\n-    LOCK(pool.cs); // protect pool.mapNextTx\n-    for (unsigned int i = 0; i < tx.vin.size(); i++)\n-    {\n-        COutPoint outpoint = tx.vin[i].prevout;\n-        if (pool.mapNextTx.count(outpoint))\n-        {\n-            // Disable replacement feature for now\n-            return false;\n-        }\n-    }\n-    }\n-\n     {\n         CCoinsView dummy;\n         CCoinsViewCache view(dummy);\n \n+        int64_t nConflictingFees = 0;\n+        unsigned int nConflictingSize = 0;\n+\n         {\n         LOCK(pool.cs);\n         CCoinsViewMemPool viewMemPool(*pcoinsTip, pool);\n@@ -886,6 +875,43 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n             return state.Invalid(error(\"AcceptToMemoryPool : inputs already spent\"),\n                                  REJECT_DUPLICATE, \"bad-txns-inputs-spent\");\n \n+        // While we have the mempool locked determine total fees and size\n+        // of conflicting transactions.\n+\n+        // Populate set with conflicting transactions we're directly\n+        // double-spending.\n+        set<const CTransaction *> sptxConflicts;\n+        BOOST_FOREACH(const CTxIn txin, tx.vin) {\n+            if (pool.mapNextTx.count(txin.prevout))\n+                sptxConflicts.insert(pool.mapNextTx[txin.prevout].ptx);\n+        }\n+\n+        while (sptxConflicts.size())\n+        {\n+            std::set<const CTransaction *>::iterator it;\n+            it = sptxConflicts.begin();\n+            const CTransaction *ptxConflicting = *it;\n+            sptxConflicts.erase(it);\n+\n+            nConflictingFees += view.GetValueIn(*ptxConflicting) - ptxConflicting->GetValueOut();\n+            nConflictingSize += ::GetSerializeSize(*ptxConflicting, SER_NETWORK, PROTOCOL_VERSION);\n+\n+            // Limit DoS potential by simply rejecting large double-spends\n+            if (nConflictingSize > MAX_STANDARD_TX_SIZE * 2)\n+                return state.Invalid(error(\"AcceptToMemoryPool : too many conflicting txs for replacement; can't replace with %s\",\n+                                           hash.ToString()),\n+                                     REJECT_DUPLICATE, \"bad-txns-inputs-spent\");\n+\n+            // Add children\n+            uint256 hashConflicting = ptxConflicting->GetHash();\n+            for (unsigned int i = 0; i < ptxConflicting->vout.size(); i++)\n+            {\n+                COutPoint outpoint(hashConflicting, i);\n+                if (pool.mapNextTx.count(outpoint))\n+                    sptxConflicts.insert(pool.mapNextTx[outpoint].ptx);\n+            }\n+        }\n+\n         // Bring the best block into scope\n         view.GetBestBlock();\n \n@@ -945,14 +971,69 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n                          hash.ToString(),\n                          nFees, CTransaction::nMinRelayTxFee * 10000);\n \n+\n+        // If there are conflicting transactions, determine if replacing them\n+        // would be economically rational. In theory this would be simply \"pays\n+        // more fees-per-KB\" than conflicting modulo possible total fee\n+        // reductions, but we have to think about DoS attacks too.\n+        if (nConflictingSize > 0)\n+        {\n+            // First of all we can't allow a replacement unless it pays greater\n+            // fees than the transactions it conflicts with - if we did the\n+            // bandwidth used by those conflicting transactions would not be\n+            // paid for.\n+            if (nFees < nConflictingFees)\n+                return state.DoS(0,\n+                    error(\"AcceptToMemoryPool : rejecting replacement %s, pays less fees than conflicting txs; %s < %s\",\n+                          hash.ToString(),\n+                          FormatMoney(nFees),\n+                          FormatMoney(nConflictingFees)),\n+                    REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n+\n+            // Secondly in addition to paying more fees than the conflicts the\n+            // new transaction must additionally pay for its own bandwidth.\n+            int64_t nDeltaFees = nFees - nConflictingFees;\n+            int64_t nRelayFee = (int64_t)((double)nSize/1000 * CTransaction::nMinRelayTxFee);\n+            if (nDeltaFees < nRelayFee)\n+                return state.DoS(0,\n+                    error(\"AcceptToMemoryPool : rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n+                          hash.ToString(),\n+                          FormatMoney(nDeltaFees),\n+                          FormatMoney(nRelayFee)),\n+                    REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n+\n+            // Replace only if new fees-per-kb is > previous fees-per-kb.\n+            double dOldFeesPerKB = (double)nConflictingFees/((double)nConflictingSize/1000);\n+            double dNewFeesPerKB = (double)nFees/((double)nSize/1000);\n+            if (dOldFeesPerKB > dNewFeesPerKB)\n+                return state.DoS(0, error(\"AcceptToMemoryPool : rejecting uneconomical replacement %s; %f BTC/KB < %d BTC/KB\",\n+                                          hash.ToString(), dNewFeesPerKB/COIN, dOldFeesPerKB/COIN),\n+                                 REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n+        }\n+\n         // Check against previous transactions\n         // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n         if (!CheckInputs(tx, state, view, true, STANDARD_SCRIPT_VERIFY_FLAGS))\n         {\n             return error(\"AcceptToMemoryPool: : ConnectInputs failed %s\", hash.ToString());\n         }\n+\n+        // Remove conflicting transactions from the mempool\n+        list<CTransaction> ltxConflicted;\n+        mempool.removeConflicts(tx, ltxConflicted);\n+\n         // Store transaction in memory\n         pool.addUnchecked(hash, entry);\n+\n+        BOOST_FOREACH(const CTransaction &txConflicted, ltxConflicted) {\n+            LogPrint(\"mempool\", \"replacing tx %s with %s for %s BTC additional fees, %d delta bytes\\n\",\n+                    txConflicted.GetHash().ToString(),\n+                    hash.ToString(),\n+                    FormatMoney(nFees - nConflictingFees),\n+                    (int)nSize - (int)nConflictingSize);\n+\n+            // Should tell wallets about transactions that were replaced here.\n+        }\n     }\n \n     g_signals.SyncTransaction(hash, tx, NULL);"
      }
    ]
  }
]