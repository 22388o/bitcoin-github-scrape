[
  {
    "sha": "f393a533bebc088985f94c725b9af881500ba998",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMzkzYTUzM2JlYmMwODg5ODVmOTRjNzI1YjlhZjg4MTUwMGJhOTk4",
    "commit": {
      "author": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-06-08T18:06:58Z"
      },
      "committer": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-07-25T14:31:27Z"
      },
      "message": "Annotate AssertLockHeld() with ASSERT_CAPABILITY() for thread safety analysis",
      "tree": {
        "sha": "106f7fc744b1f3a8c4dfa0b55e9cc88ebdbf0fec",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/106f7fc744b1f3a8c4dfa0b55e9cc88ebdbf0fec"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f393a533bebc088985f94c725b9af881500ba998",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f393a533bebc088985f94c725b9af881500ba998",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f393a533bebc088985f94c725b9af881500ba998",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f393a533bebc088985f94c725b9af881500ba998/comments",
    "author": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "29b4ee64695f79511912ae127e66e0fe82f7a0d1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/29b4ee64695f79511912ae127e66e0fe82f7a0d1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/29b4ee64695f79511912ae127e66e0fe82f7a0d1"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 4,
      "deletions": 2
    },
    "files": [
      {
        "sha": "882ad5dc4c0038178692855468d1cc8c4a6a9eb7",
        "filename": "src/sync.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f393a533bebc088985f94c725b9af881500ba998/src/sync.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f393a533bebc088985f94c725b9af881500ba998/src/sync.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.h?ref=f393a533bebc088985f94c725b9af881500ba998",
        "patch": "@@ -74,13 +74,13 @@ class LOCKABLE AnnotatedMixin : public PARENT\n void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false);\n void LeaveCritical();\n std::string LocksHeld();\n-void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs);\n+void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) ASSERT_EXCLUSIVE_LOCK(cs);\n void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs);\n void DeleteLock(void* cs);\n #else\n void static inline EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false) {}\n void static inline LeaveCritical() {}\n-void static inline AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) {}\n+void static inline AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) ASSERT_EXCLUSIVE_LOCK(cs) {}\n void static inline AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) {}\n void static inline DeleteLock(void* cs) {}\n #endif"
      },
      {
        "sha": "d847269dff2ff75b41b23e943b67cc19881490fd",
        "filename": "src/threadsafety.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f393a533bebc088985f94c725b9af881500ba998/src/threadsafety.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f393a533bebc088985f94c725b9af881500ba998/src/threadsafety.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/threadsafety.h?ref=f393a533bebc088985f94c725b9af881500ba998",
        "patch": "@@ -31,6 +31,7 @@\n #define EXCLUSIVE_LOCKS_REQUIRED(...) __attribute__((exclusive_locks_required(__VA_ARGS__)))\n #define SHARED_LOCKS_REQUIRED(...) __attribute__((shared_locks_required(__VA_ARGS__)))\n #define NO_THREAD_SAFETY_ANALYSIS __attribute__((no_thread_safety_analysis))\n+#define ASSERT_EXCLUSIVE_LOCK(...) __attribute((assert_exclusive_lock(__VA_ARGS__)))\n #else\n #define LOCKABLE\n #define SCOPED_LOCKABLE\n@@ -50,6 +51,7 @@\n #define EXCLUSIVE_LOCKS_REQUIRED(...)\n #define SHARED_LOCKS_REQUIRED(...)\n #define NO_THREAD_SAFETY_ANALYSIS\n+#define ASSERT_EXCLUSIVE_LOCK(...)\n #endif // __GNUC__\n \n #endif // BITCOIN_THREADSAFETY_H"
      }
    ]
  },
  {
    "sha": "1e3bcd251768baeb95e555d51d2dc787a6b2acee",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxZTNiY2QyNTE3NjhiYWViOTVlNTU1ZDUxZDJkYzc4N2E2YjJhY2Vl",
    "commit": {
      "author": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-06-08T18:09:08Z"
      },
      "committer": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-07-25T19:23:53Z"
      },
      "message": "[net_processing] Add thread safety annotations",
      "tree": {
        "sha": "7c39f88706ccc0049841d41fa8e5d5e6779ce384",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7c39f88706ccc0049841d41fa8e5d5e6779ce384"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1e3bcd251768baeb95e555d51d2dc787a6b2acee",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1e3bcd251768baeb95e555d51d2dc787a6b2acee",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1e3bcd251768baeb95e555d51d2dc787a6b2acee",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1e3bcd251768baeb95e555d51d2dc787a6b2acee/comments",
    "author": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f393a533bebc088985f94c725b9af881500ba998",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f393a533bebc088985f94c725b9af881500ba998",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f393a533bebc088985f94c725b9af881500ba998"
      }
    ],
    "stats": {
      "total": 91,
      "additions": 46,
      "deletions": 45
    },
    "files": [
      {
        "sha": "d5d664b27e0eeb51b91cbae8848b84c085341ac7",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 46,
        "deletions": 45,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1e3bcd251768baeb95e555d51d2dc787a6b2acee/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1e3bcd251768baeb95e555d51d2dc787a6b2acee/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=1e3bcd251768baeb95e555d51d2dc787a6b2acee",
        "patch": "@@ -76,7 +76,7 @@ std::map<uint256, COrphanTx> mapOrphanTransactions GUARDED_BY(g_cs_orphans);\n void EraseOrphansFor(NodeId peer);\n \n /** Increase a node's misbehavior score. */\n-void Misbehaving(NodeId nodeid, int howmuch, const std::string& message=\"\");\n+void Misbehaving(NodeId nodeid, int howmuch, const std::string& message=\"\") EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n /** Average delay between local address broadcasts in seconds. */\n static constexpr unsigned int AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL = 24 * 60 * 60;\n@@ -96,22 +96,20 @@ static constexpr unsigned int MAX_FEEFILTER_CHANGE_DELAY = 5 * 60;\n // Internal stuff\n namespace {\n     /** Number of nodes with fSyncStarted. */\n-    int nSyncStarted = 0;\n+    int nSyncStarted GUARDED_BY(cs_main) = 0;\n \n     /**\n      * Sources of received blocks, saved to be able to send them reject\n-     * messages or ban them when processing happens afterwards. Protected by\n-     * cs_main.\n+     * messages or ban them when processing happens afterwards.\n      * Set mapBlockSource[hash].second to false if the node should not be\n      * punished if the block is invalid.\n      */\n-    std::map<uint256, std::pair<NodeId, bool>> mapBlockSource;\n+    std::map<uint256, std::pair<NodeId, bool>> mapBlockSource GUARDED_BY(cs_main);\n \n     /**\n      * Filter for transactions that were recently rejected by\n      * AcceptToMemoryPool. These are not rerequested until the chain tip\n-     * changes, at which point the entire filter is reset. Protected by\n-     * cs_main.\n+     * changes, at which point the entire filter is reset.\n      *\n      * Without this filter we'd be re-requesting txs from each of our peers,\n      * increasing bandwidth consumption considerably. For instance, with 100\n@@ -127,38 +125,38 @@ namespace {\n      *\n      * Memory used: 1.3 MB\n      */\n-    std::unique_ptr<CRollingBloomFilter> recentRejects;\n-    uint256 hashRecentRejectsChainTip;\n+    std::unique_ptr<CRollingBloomFilter> recentRejects GUARDED_BY(cs_main);\n+    uint256 hashRecentRejectsChainTip GUARDED_BY(cs_main);\n \n-    /** Blocks that are in flight, and that are in the queue to be downloaded. Protected by cs_main. */\n+    /** Blocks that are in flight, and that are in the queue to be downloaded. */\n     struct QueuedBlock {\n         uint256 hash;\n         const CBlockIndex* pindex;                               //!< Optional.\n         bool fValidatedHeaders;                                  //!< Whether this block has validated headers at the time of request.\n         std::unique_ptr<PartiallyDownloadedBlock> partialBlock;  //!< Optional, used for CMPCTBLOCK downloads\n     };\n-    std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> > mapBlocksInFlight;\n+    std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> > mapBlocksInFlight GUARDED_BY(cs_main);\n \n     /** Stack of nodes which we have set to announce using compact blocks */\n-    std::list<NodeId> lNodesAnnouncingHeaderAndIDs;\n+    std::list<NodeId> lNodesAnnouncingHeaderAndIDs GUARDED_BY(cs_main);\n \n     /** Number of preferable block download peers. */\n-    int nPreferredDownload = 0;\n+    int nPreferredDownload GUARDED_BY(cs_main) = 0;\n \n     /** Number of peers from which we're downloading blocks. */\n-    int nPeersWithValidatedDownloads = 0;\n+    int nPeersWithValidatedDownloads GUARDED_BY(cs_main) = 0;\n \n     /** Number of outbound peers with m_chain_sync.m_protect. */\n-    int g_outbound_peers_with_protect_from_disconnect = 0;\n+    int g_outbound_peers_with_protect_from_disconnect GUARDED_BY(cs_main) = 0;\n \n     /** When our tip was last updated. */\n     std::atomic<int64_t> g_last_tip_update(0);\n \n-    /** Relay map, protected by cs_main. */\n+    /** Relay map */\n     typedef std::map<uint256, CTransactionRef> MapRelay;\n-    MapRelay mapRelay;\n-    /** Expiration-time ordered list of (expire time, relay map entry) pairs, protected by cs_main). */\n-    std::deque<std::pair<int64_t, MapRelay::iterator>> vRelayExpiration;\n+    MapRelay mapRelay GUARDED_BY(cs_main);\n+    /** Expiration-time ordered list of (expire time, relay map entry) pairs. */\n+    std::deque<std::pair<int64_t, MapRelay::iterator>> vRelayExpiration GUARDED_BY(cs_main);\n \n     std::atomic<int64_t> nTimeBestReceived(0); // Used only to inform the wallet of when we last received a block\n \n@@ -302,18 +300,17 @@ struct CNodeState {\n     }\n };\n \n-/** Map maintaining per-node state. Requires cs_main. */\n-static std::map<NodeId, CNodeState> mapNodeState;\n+/** Map maintaining per-node state. */\n+static std::map<NodeId, CNodeState> mapNodeState GUARDED_BY(cs_main);\n \n-// Requires cs_main.\n-static CNodeState *State(NodeId pnode) {\n+static CNodeState *State(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n     std::map<NodeId, CNodeState>::iterator it = mapNodeState.find(pnode);\n     if (it == mapNodeState.end())\n         return nullptr;\n     return &it->second;\n }\n \n-static void UpdatePreferredDownload(CNode* node, CNodeState* state)\n+static void UpdatePreferredDownload(CNode* node, CNodeState* state) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     nPreferredDownload -= state->fPreferredDownload;\n \n@@ -344,10 +341,9 @@ static void PushNodeVersion(CNode *pnode, CConnman* connman, int64_t nTime)\n     }\n }\n \n-// Requires cs_main.\n // Returns a bool indicating whether we requested this block.\n // Also used if a block was /not/ received and timed out or started with another peer\n-static bool MarkBlockAsReceived(const uint256& hash) {\n+static bool MarkBlockAsReceived(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n     std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n     if (itInFlight != mapBlocksInFlight.end()) {\n         CNodeState *state = State(itInFlight->second.first);\n@@ -370,10 +366,9 @@ static bool MarkBlockAsReceived(const uint256& hash) {\n     return false;\n }\n \n-// Requires cs_main.\n // returns false, still setting pit, if the block was already in flight from the same peer\n // pit will only be valid as long as the same cs_main lock is being held\n-static bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex* pindex = nullptr, std::list<QueuedBlock>::iterator** pit = nullptr) {\n+static bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex* pindex = nullptr, std::list<QueuedBlock>::iterator** pit = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n     CNodeState *state = State(nodeid);\n     assert(state != nullptr);\n \n@@ -407,7 +402,7 @@ static bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlock\n }\n \n /** Check whether the last unknown block a peer advertised is not yet known. */\n-static void ProcessBlockAvailability(NodeId nodeid) {\n+static void ProcessBlockAvailability(NodeId nodeid) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n     CNodeState *state = State(nodeid);\n     assert(state != nullptr);\n \n@@ -423,7 +418,7 @@ static void ProcessBlockAvailability(NodeId nodeid) {\n }\n \n /** Update tracking information about which blocks a peer is assumed to have. */\n-static void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n+static void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n     CNodeState *state = State(nodeid);\n     assert(state != nullptr);\n \n@@ -447,7 +442,8 @@ static void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n  * lNodesAnnouncingHeaderAndIDs, and keeping that list under a certain size by\n  * removing the first element if necessary.\n  */\n-static void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman* connman) {\n+static void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman* connman)\n+{\n     AssertLockHeld(cs_main);\n     CNodeState* nodestate = State(nodeid);\n     if (!nodestate || !nodestate->fSupportsDesiredCmpctVersion) {\n@@ -463,11 +459,13 @@ static void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman* connma\n             }\n         }\n         connman->ForNode(nodeid, [connman](CNode* pfrom){\n+            AssertLockHeld(cs_main);\n             uint64_t nCMPCTBLOCKVersion = (pfrom->GetLocalServices() & NODE_WITNESS) ? 2 : 1;\n             if (lNodesAnnouncingHeaderAndIDs.size() >= 3) {\n                 // As per BIP152, we only get 3 of our peers to announce\n                 // blocks using compact encodings.\n                 connman->ForNode(lNodesAnnouncingHeaderAndIDs.front(), [connman, nCMPCTBLOCKVersion](CNode* pnodeStop){\n+                    AssertLockHeld(cs_main);\n                     connman->PushMessage(pnodeStop, CNetMsgMaker(pnodeStop->GetSendVersion()).Make(NetMsgType::SENDCMPCT, /*fAnnounceUsingCMPCTBLOCK=*/false, nCMPCTBLOCKVersion));\n                     return true;\n                 });\n@@ -480,7 +478,7 @@ static void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman* connma\n     }\n }\n \n-static bool TipMayBeStale(const Consensus::Params &consensusParams)\n+static bool TipMayBeStale(const Consensus::Params &consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     AssertLockHeld(cs_main);\n     if (g_last_tip_update == 0) {\n@@ -489,14 +487,12 @@ static bool TipMayBeStale(const Consensus::Params &consensusParams)\n     return g_last_tip_update < GetTime() - consensusParams.nPowTargetSpacing * 3 && mapBlocksInFlight.empty();\n }\n \n-// Requires cs_main\n-static bool CanDirectFetch(const Consensus::Params &consensusParams)\n+static bool CanDirectFetch(const Consensus::Params &consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     return chainActive.Tip()->GetBlockTime() > GetAdjustedTime() - consensusParams.nPowTargetSpacing * 20;\n }\n \n-// Requires cs_main\n-static bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex)\n+static bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     if (state->pindexBestKnownBlock && pindex == state->pindexBestKnownBlock->GetAncestor(pindex->nHeight))\n         return true;\n@@ -507,7 +503,8 @@ static bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex)\n \n /** Update pindexLastCommonBlock and add not-in-flight missing successors to vBlocks, until it has\n  *  at most count entries. */\n-static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) {\n+static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+{\n     if (count == 0)\n         return;\n \n@@ -797,10 +794,8 @@ unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)\n \n /**\n  * Mark a misbehaving peer to be banned depending upon the value of `-banscore`.\n- *\n- * Requires cs_main.\n  */\n-void Misbehaving(NodeId pnode, int howmuch, const std::string& message)\n+void Misbehaving(NodeId pnode, int howmuch, const std::string& message) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     if (howmuch == 0)\n         return;\n@@ -898,10 +893,10 @@ void PeerLogicValidation::BlockConnected(const std::shared_ptr<const CBlock>& pb\n \n // All of the following cache a recent block, and are protected by cs_most_recent_block\n static CCriticalSection cs_most_recent_block;\n-static std::shared_ptr<const CBlock> most_recent_block;\n-static std::shared_ptr<const CBlockHeaderAndShortTxIDs> most_recent_compact_block;\n-static uint256 most_recent_block_hash;\n-static bool fWitnessesPresentInMostRecentCompactBlock;\n+static std::shared_ptr<const CBlock> most_recent_block GUARDED_BY(cs_most_recent_block);\n+static std::shared_ptr<const CBlockHeaderAndShortTxIDs> most_recent_compact_block GUARDED_BY(cs_most_recent_block);\n+static uint256 most_recent_block_hash GUARDED_BY(cs_most_recent_block);\n+static bool fWitnessesPresentInMostRecentCompactBlock GUARDED_BY(cs_most_recent_block);\n \n /**\n  * Maintain state about the best-seen block and fast-announce a compact block\n@@ -930,6 +925,8 @@ void PeerLogicValidation::NewPoWValidBlock(const CBlockIndex *pindex, const std:\n     }\n \n     connman->ForEachNode([this, &pcmpctblock, pindex, &msgMaker, fWitnessEnabled, &hashBlock](CNode* pnode) {\n+        AssertLockHeld(cs_main);\n+\n         // TODO: Avoid the repeated-serialization here\n         if (pnode->nVersion < INVALID_CB_NO_BAN_VERSION || pnode->fDisconnect)\n             return;\n@@ -1327,7 +1324,7 @@ void static ProcessGetData(CNode* pfrom, const CChainParams& chainparams, CConnm\n     }\n }\n \n-static uint32_t GetFetchFlags(CNode* pfrom) {\n+static uint32_t GetFetchFlags(CNode* pfrom) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n     uint32_t nFetchFlags = 0;\n     if ((pfrom->GetLocalServices() & NODE_WITNESS) && State(pfrom->GetId())->fHaveWitness) {\n         nFetchFlags |= MSG_WITNESS_FLAG;\n@@ -3160,6 +3157,8 @@ void PeerLogicValidation::EvictExtraOutboundPeers(int64_t time_in_seconds)\n         LOCK(cs_main);\n \n         connman->ForEachNode([&](CNode* pnode) {\n+            AssertLockHeld(cs_main);\n+\n             // Ignore non-outbound peers, or nodes marked for disconnect already\n             if (!IsOutboundDisconnectionCandidate(pnode) || pnode->fDisconnect) return;\n             CNodeState *state = State(pnode->GetId());\n@@ -3173,6 +3172,8 @@ void PeerLogicValidation::EvictExtraOutboundPeers(int64_t time_in_seconds)\n         });\n         if (worst_peer != -1) {\n             bool disconnected = connman->ForNode(worst_peer, [&](CNode *pnode) {\n+                AssertLockHeld(cs_main);\n+\n                 // Only disconnect a peer that has been connected to us for\n                 // some reasonable fraction of our check-frequency, to give\n                 // it time for new information to have arrived."
      }
    ]
  }
]