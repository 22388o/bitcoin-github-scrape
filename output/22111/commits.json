[
  {
    "sha": "6f340cbb76a8221fc03c726328ca79a37e7be2d6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ZjM0MGNiYjc2YTgyMjFmYzAzYzcyNjMyOGNhNzlhMzdlN2JlMmQ2",
    "commit": {
      "author": {
        "name": "doianmai2020",
        "email": "69721895+doianmai2020@users.noreply.github.com",
        "date": "2021-05-31T12:56:02Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-05-31T12:56:02Z"
      },
      "message": "Revert \"MOVEONLY: CWallet transaction code out of wallet.cpp/.h\"",
      "tree": {
        "sha": "f00c454cbcaa5cecdaeb0f425d1e087d61b5f1b6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f00c454cbcaa5cecdaeb0f425d1e087d61b5f1b6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6f340cbb76a8221fc03c726328ca79a37e7be2d6",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgtNziCRBK7hj4Ov3rIwAA16AIADQ/Da8+v2jUo/6QX/IuQgyI\nlgo3YvIg685J6DtBJNP/BgsMgGIcfhxBlJqQN/KLYsxkUgD3Njm6+oeQbA4jT20N\nmy2efIXw8P7TXgUPEziT9Riipt58YI+qrH+PSOevgJgzENmEm/cwJBQoZovHOX53\n891A/sNxLYr5BGSD42XNO8iVg3uvjn2luE3CWvfPIzdibutEGWYTC8H5mmM3kU2+\nJEdx3Kusf5kxJXSaTUoV869s9i4/dAoW19VFjaOKX3291dkFT9GUyU+Lw7QjEepg\nn9Lbps0Ypun8f8jcTgaRc441y67u1ea3EEiRD8C64Y+JiWlIapmzdxy65KioNxQ=\n=4IOS\n-----END PGP SIGNATURE-----\n",
        "payload": "tree f00c454cbcaa5cecdaeb0f425d1e087d61b5f1b6\nparent 8462cd56010a8beadf95d4f3cb1357ca9d88493b\nauthor doianmai2020 <69721895+doianmai2020@users.noreply.github.com> 1622465762 +0700\ncommitter GitHub <noreply@github.com> 1622465762 +0700\n\nRevert \"MOVEONLY: CWallet transaction code out of wallet.cpp/.h\"\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6f340cbb76a8221fc03c726328ca79a37e7be2d6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6f340cbb76a8221fc03c726328ca79a37e7be2d6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6f340cbb76a8221fc03c726328ca79a37e7be2d6/comments",
    "author": {
      "login": "doianmai2020",
      "id": 69721895,
      "node_id": "MDQ6VXNlcjY5NzIxODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/69721895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/doianmai2020",
      "html_url": "https://github.com/doianmai2020",
      "followers_url": "https://api.github.com/users/doianmai2020/followers",
      "following_url": "https://api.github.com/users/doianmai2020/following{/other_user}",
      "gists_url": "https://api.github.com/users/doianmai2020/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/doianmai2020/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/doianmai2020/subscriptions",
      "organizations_url": "https://api.github.com/users/doianmai2020/orgs",
      "repos_url": "https://api.github.com/users/doianmai2020/repos",
      "events_url": "https://api.github.com/users/doianmai2020/events{/privacy}",
      "received_events_url": "https://api.github.com/users/doianmai2020/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8462cd56010a8beadf95d4f3cb1357ca9d88493b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8462cd56010a8beadf95d4f3cb1357ca9d88493b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8462cd56010a8beadf95d4f3cb1357ca9d88493b"
      }
    ],
    "stats": {
      "total": 3902,
      "additions": 1907,
      "deletions": 1995
    },
    "files": [
      {
        "sha": "80c142009c35ddf06164c626b2496534210b975b",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6f340cbb76a8221fc03c726328ca79a37e7be2d6/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6f340cbb76a8221fc03c726328ca79a37e7be2d6/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=6f340cbb76a8221fc03c726328ca79a37e7be2d6",
        "patch": "@@ -285,13 +285,10 @@ BITCOIN_CORE_H = \\\n   wallet/fees.h \\\n   wallet/ismine.h \\\n   wallet/load.h \\\n-  wallet/receive.h \\\n   wallet/rpcwallet.h \\\n   wallet/salvage.h \\\n   wallet/scriptpubkeyman.h \\\n-  wallet/spend.h \\\n   wallet/sqlite.h \\\n-  wallet/transaction.h \\\n   wallet/wallet.h \\\n   wallet/walletdb.h \\\n   wallet/wallettool.h \\\n@@ -409,12 +406,9 @@ libbitcoin_wallet_a_SOURCES = \\\n   wallet/fees.cpp \\\n   wallet/interfaces.cpp \\\n   wallet/load.cpp \\\n-  wallet/receive.cpp \\\n   wallet/rpcdump.cpp \\\n   wallet/rpcwallet.cpp \\\n   wallet/scriptpubkeyman.cpp \\\n-  wallet/spend.cpp \\\n-  wallet/transaction.cpp \\\n   wallet/wallet.cpp \\\n   wallet/walletdb.cpp \\\n   wallet/walletutil.cpp \\"
      },
      {
        "sha": "de81dbf32442dee720def608cc77cffb3ab63237",
        "filename": "src/wallet/receive.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 471,
        "changes": 471,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8462cd56010a8beadf95d4f3cb1357ca9d88493b/src/wallet/receive.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8462cd56010a8beadf95d4f3cb1357ca9d88493b/src/wallet/receive.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/receive.cpp?ref=8462cd56010a8beadf95d4f3cb1357ca9d88493b",
        "patch": "@@ -1,471 +0,0 @@\n-// Copyright (c) 2021 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <consensus/consensus.h>\n-#include <wallet/receive.h>\n-#include <wallet/transaction.h>\n-#include <wallet/wallet.h>\n-\n-isminetype CWallet::IsMine(const CTxIn &txin) const\n-{\n-    AssertLockHeld(cs_wallet);\n-    std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n-    if (mi != mapWallet.end())\n-    {\n-        const CWalletTx& prev = (*mi).second;\n-        if (txin.prevout.n < prev.tx->vout.size())\n-            return IsMine(prev.tx->vout[txin.prevout.n]);\n-    }\n-    return ISMINE_NO;\n-}\n-\n-bool CWallet::IsAllFromMe(const CTransaction& tx, const isminefilter& filter) const\n-{\n-    LOCK(cs_wallet);\n-\n-    for (const CTxIn& txin : tx.vin)\n-    {\n-        auto mi = mapWallet.find(txin.prevout.hash);\n-        if (mi == mapWallet.end())\n-            return false; // any unknown inputs can't be from us\n-\n-        const CWalletTx& prev = (*mi).second;\n-\n-        if (txin.prevout.n >= prev.tx->vout.size())\n-            return false; // invalid input!\n-\n-        if (!(IsMine(prev.tx->vout[txin.prevout.n]) & filter))\n-            return false;\n-    }\n-    return true;\n-}\n-\n-CAmount CWallet::GetCredit(const CTxOut& txout, const isminefilter& filter) const\n-{\n-    if (!MoneyRange(txout.nValue))\n-        throw std::runtime_error(std::string(__func__) + \": value out of range\");\n-    LOCK(cs_wallet);\n-    return ((IsMine(txout) & filter) ? txout.nValue : 0);\n-}\n-\n-CAmount CWallet::GetCredit(const CTransaction& tx, const isminefilter& filter) const\n-{\n-    CAmount nCredit = 0;\n-    for (const CTxOut& txout : tx.vout)\n-    {\n-        nCredit += GetCredit(txout, filter);\n-        if (!MoneyRange(nCredit))\n-            throw std::runtime_error(std::string(__func__) + \": value out of range\");\n-    }\n-    return nCredit;\n-}\n-\n-bool CWallet::IsChange(const CScript& script) const\n-{\n-    // TODO: fix handling of 'change' outputs. The assumption is that any\n-    // payment to a script that is ours, but is not in the address book\n-    // is change. That assumption is likely to break when we implement multisignature\n-    // wallets that return change back into a multi-signature-protected address;\n-    // a better way of identifying which outputs are 'the send' and which are\n-    // 'the change' will need to be implemented (maybe extend CWalletTx to remember\n-    // which output, if any, was change).\n-    AssertLockHeld(cs_wallet);\n-    if (IsMine(script))\n-    {\n-        CTxDestination address;\n-        if (!ExtractDestination(script, address))\n-            return true;\n-        if (!FindAddressBookEntry(address)) {\n-            return true;\n-        }\n-    }\n-    return false;\n-}\n-\n-bool CWallet::IsChange(const CTxOut& txout) const\n-{\n-    return IsChange(txout.scriptPubKey);\n-}\n-\n-CAmount CWallet::GetChange(const CTxOut& txout) const\n-{\n-    AssertLockHeld(cs_wallet);\n-    if (!MoneyRange(txout.nValue))\n-        throw std::runtime_error(std::string(__func__) + \": value out of range\");\n-    return (IsChange(txout) ? txout.nValue : 0);\n-}\n-\n-CAmount CWallet::GetChange(const CTransaction& tx) const\n-{\n-    LOCK(cs_wallet);\n-    CAmount nChange = 0;\n-    for (const CTxOut& txout : tx.vout)\n-    {\n-        nChange += GetChange(txout);\n-        if (!MoneyRange(nChange))\n-            throw std::runtime_error(std::string(__func__) + \": value out of range\");\n-    }\n-    return nChange;\n-}\n-\n-CAmount CWalletTx::GetCachableAmount(AmountType type, const isminefilter& filter, bool recalculate) const\n-{\n-    auto& amount = m_amounts[type];\n-    if (recalculate || !amount.m_cached[filter]) {\n-        amount.Set(filter, type == DEBIT ? pwallet->GetDebit(*tx, filter) : pwallet->GetCredit(*tx, filter));\n-        m_is_cache_empty = false;\n-    }\n-    return amount.m_value[filter];\n-}\n-\n-CAmount CWalletTx::GetCredit(const isminefilter& filter) const\n-{\n-    // Must wait until coinbase is safely deep enough in the chain before valuing it\n-    if (IsImmatureCoinBase())\n-        return 0;\n-\n-    CAmount credit = 0;\n-    if (filter & ISMINE_SPENDABLE) {\n-        // GetBalance can assume transactions in mapWallet won't change\n-        credit += GetCachableAmount(CREDIT, ISMINE_SPENDABLE);\n-    }\n-    if (filter & ISMINE_WATCH_ONLY) {\n-        credit += GetCachableAmount(CREDIT, ISMINE_WATCH_ONLY);\n-    }\n-    return credit;\n-}\n-\n-CAmount CWalletTx::GetDebit(const isminefilter& filter) const\n-{\n-    if (tx->vin.empty())\n-        return 0;\n-\n-    CAmount debit = 0;\n-    if (filter & ISMINE_SPENDABLE) {\n-        debit += GetCachableAmount(DEBIT, ISMINE_SPENDABLE);\n-    }\n-    if (filter & ISMINE_WATCH_ONLY) {\n-        debit += GetCachableAmount(DEBIT, ISMINE_WATCH_ONLY);\n-    }\n-    return debit;\n-}\n-\n-CAmount CWalletTx::GetChange() const\n-{\n-    if (fChangeCached)\n-        return nChangeCached;\n-    nChangeCached = pwallet->GetChange(*tx);\n-    fChangeCached = true;\n-    return nChangeCached;\n-}\n-\n-CAmount CWalletTx::GetImmatureCredit(bool fUseCache) const\n-{\n-    if (IsImmatureCoinBase() && IsInMainChain()) {\n-        return GetCachableAmount(IMMATURE_CREDIT, ISMINE_SPENDABLE, !fUseCache);\n-    }\n-\n-    return 0;\n-}\n-\n-CAmount CWalletTx::GetImmatureWatchOnlyCredit(const bool fUseCache) const\n-{\n-    if (IsImmatureCoinBase() && IsInMainChain()) {\n-        return GetCachableAmount(IMMATURE_CREDIT, ISMINE_WATCH_ONLY, !fUseCache);\n-    }\n-\n-    return 0;\n-}\n-\n-CAmount CWalletTx::GetAvailableCredit(bool fUseCache, const isminefilter& filter) const\n-{\n-    if (pwallet == nullptr)\n-        return 0;\n-\n-    // Avoid caching ismine for NO or ALL cases (could remove this check and simplify in the future).\n-    bool allow_cache = (filter & ISMINE_ALL) && (filter & ISMINE_ALL) != ISMINE_ALL;\n-\n-    // Must wait until coinbase is safely deep enough in the chain before valuing it\n-    if (IsImmatureCoinBase())\n-        return 0;\n-\n-    if (fUseCache && allow_cache && m_amounts[AVAILABLE_CREDIT].m_cached[filter]) {\n-        return m_amounts[AVAILABLE_CREDIT].m_value[filter];\n-    }\n-\n-    bool allow_used_addresses = (filter & ISMINE_USED) || !pwallet->IsWalletFlagSet(WALLET_FLAG_AVOID_REUSE);\n-    CAmount nCredit = 0;\n-    uint256 hashTx = GetHash();\n-    for (unsigned int i = 0; i < tx->vout.size(); i++)\n-    {\n-        if (!pwallet->IsSpent(hashTx, i) && (allow_used_addresses || !pwallet->IsSpentKey(hashTx, i))) {\n-            const CTxOut &txout = tx->vout[i];\n-            nCredit += pwallet->GetCredit(txout, filter);\n-            if (!MoneyRange(nCredit))\n-                throw std::runtime_error(std::string(__func__) + \" : value out of range\");\n-        }\n-    }\n-\n-    if (allow_cache) {\n-        m_amounts[AVAILABLE_CREDIT].Set(filter, nCredit);\n-        m_is_cache_empty = false;\n-    }\n-\n-    return nCredit;\n-}\n-\n-void CWalletTx::GetAmounts(std::list<COutputEntry>& listReceived,\n-                           std::list<COutputEntry>& listSent, CAmount& nFee, const isminefilter& filter) const\n-{\n-    nFee = 0;\n-    listReceived.clear();\n-    listSent.clear();\n-\n-    // Compute fee:\n-    CAmount nDebit = GetDebit(filter);\n-    if (nDebit > 0) // debit>0 means we signed/sent this transaction\n-    {\n-        CAmount nValueOut = tx->GetValueOut();\n-        nFee = nDebit - nValueOut;\n-    }\n-\n-    LOCK(pwallet->cs_wallet);\n-    // Sent/received.\n-    for (unsigned int i = 0; i < tx->vout.size(); ++i)\n-    {\n-        const CTxOut& txout = tx->vout[i];\n-        isminetype fIsMine = pwallet->IsMine(txout);\n-        // Only need to handle txouts if AT LEAST one of these is true:\n-        //   1) they debit from us (sent)\n-        //   2) the output is to us (received)\n-        if (nDebit > 0)\n-        {\n-            // Don't report 'change' txouts\n-            if (pwallet->IsChange(txout))\n-                continue;\n-        }\n-        else if (!(fIsMine & filter))\n-            continue;\n-\n-        // In either case, we need to get the destination address\n-        CTxDestination address;\n-\n-        if (!ExtractDestination(txout.scriptPubKey, address) && !txout.scriptPubKey.IsUnspendable())\n-        {\n-            pwallet->WalletLogPrintf(\"CWalletTx::GetAmounts: Unknown transaction type found, txid %s\\n\",\n-                                    this->GetHash().ToString());\n-            address = CNoDestination();\n-        }\n-\n-        COutputEntry output = {address, txout.nValue, (int)i};\n-\n-        // If we are debited by the transaction, add the output as a \"sent\" entry\n-        if (nDebit > 0)\n-            listSent.push_back(output);\n-\n-        // If we are receiving the output, add it as a \"received\" entry\n-        if (fIsMine & filter)\n-            listReceived.push_back(output);\n-    }\n-\n-}\n-\n-bool CWallet::IsTrusted(const CWalletTx& wtx, std::set<uint256>& trusted_parents) const\n-{\n-    AssertLockHeld(cs_wallet);\n-    // Quick answer in most cases\n-    if (!chain().checkFinalTx(*wtx.tx)) return false;\n-    int nDepth = wtx.GetDepthInMainChain();\n-    if (nDepth >= 1) return true;\n-    if (nDepth < 0) return false;\n-    // using wtx's cached debit\n-    if (!m_spend_zero_conf_change || !wtx.IsFromMe(ISMINE_ALL)) return false;\n-\n-    // Don't trust unconfirmed transactions from us unless they are in the mempool.\n-    if (!wtx.InMempool()) return false;\n-\n-    // Trusted if all inputs are from us and are in the mempool:\n-    for (const CTxIn& txin : wtx.tx->vin)\n-    {\n-        // Transactions not sent by us: not trusted\n-        const CWalletTx* parent = GetWalletTx(txin.prevout.hash);\n-        if (parent == nullptr) return false;\n-        const CTxOut& parentOut = parent->tx->vout[txin.prevout.n];\n-        // Check that this specific input being spent is trusted\n-        if (IsMine(parentOut) != ISMINE_SPENDABLE) return false;\n-        // If we've already trusted this parent, continue\n-        if (trusted_parents.count(parent->GetHash())) continue;\n-        // Recurse to check that the parent is also trusted\n-        if (!IsTrusted(*parent, trusted_parents)) return false;\n-        trusted_parents.insert(parent->GetHash());\n-    }\n-    return true;\n-}\n-\n-bool CWalletTx::IsTrusted() const\n-{\n-    std::set<uint256> trusted_parents;\n-    LOCK(pwallet->cs_wallet);\n-    return pwallet->IsTrusted(*this, trusted_parents);\n-}\n-\n-CWallet::Balance CWallet::GetBalance(const int min_depth, bool avoid_reuse) const\n-{\n-    Balance ret;\n-    isminefilter reuse_filter = avoid_reuse ? ISMINE_NO : ISMINE_USED;\n-    {\n-        LOCK(cs_wallet);\n-        std::set<uint256> trusted_parents;\n-        for (const auto& entry : mapWallet)\n-        {\n-            const CWalletTx& wtx = entry.second;\n-            const bool is_trusted{IsTrusted(wtx, trusted_parents)};\n-            const int tx_depth{wtx.GetDepthInMainChain()};\n-            const CAmount tx_credit_mine{wtx.GetAvailableCredit(/* fUseCache */ true, ISMINE_SPENDABLE | reuse_filter)};\n-            const CAmount tx_credit_watchonly{wtx.GetAvailableCredit(/* fUseCache */ true, ISMINE_WATCH_ONLY | reuse_filter)};\n-            if (is_trusted && tx_depth >= min_depth) {\n-                ret.m_mine_trusted += tx_credit_mine;\n-                ret.m_watchonly_trusted += tx_credit_watchonly;\n-            }\n-            if (!is_trusted && tx_depth == 0 && wtx.InMempool()) {\n-                ret.m_mine_untrusted_pending += tx_credit_mine;\n-                ret.m_watchonly_untrusted_pending += tx_credit_watchonly;\n-            }\n-            ret.m_mine_immature += wtx.GetImmatureCredit();\n-            ret.m_watchonly_immature += wtx.GetImmatureWatchOnlyCredit();\n-        }\n-    }\n-    return ret;\n-}\n-\n-std::map<CTxDestination, CAmount> CWallet::GetAddressBalances() const\n-{\n-    std::map<CTxDestination, CAmount> balances;\n-\n-    {\n-        LOCK(cs_wallet);\n-        std::set<uint256> trusted_parents;\n-        for (const auto& walletEntry : mapWallet)\n-        {\n-            const CWalletTx& wtx = walletEntry.second;\n-\n-            if (!IsTrusted(wtx, trusted_parents))\n-                continue;\n-\n-            if (wtx.IsImmatureCoinBase())\n-                continue;\n-\n-            int nDepth = wtx.GetDepthInMainChain();\n-            if (nDepth < (wtx.IsFromMe(ISMINE_ALL) ? 0 : 1))\n-                continue;\n-\n-            for (unsigned int i = 0; i < wtx.tx->vout.size(); i++)\n-            {\n-                CTxDestination addr;\n-                if (!IsMine(wtx.tx->vout[i]))\n-                    continue;\n-                if(!ExtractDestination(wtx.tx->vout[i].scriptPubKey, addr))\n-                    continue;\n-\n-                CAmount n = IsSpent(walletEntry.first, i) ? 0 : wtx.tx->vout[i].nValue;\n-                balances[addr] += n;\n-            }\n-        }\n-    }\n-\n-    return balances;\n-}\n-\n-std::set< std::set<CTxDestination> > CWallet::GetAddressGroupings() const\n-{\n-    AssertLockHeld(cs_wallet);\n-    std::set< std::set<CTxDestination> > groupings;\n-    std::set<CTxDestination> grouping;\n-\n-    for (const auto& walletEntry : mapWallet)\n-    {\n-        const CWalletTx& wtx = walletEntry.second;\n-\n-        if (wtx.tx->vin.size() > 0)\n-        {\n-            bool any_mine = false;\n-            // group all input addresses with each other\n-            for (const CTxIn& txin : wtx.tx->vin)\n-            {\n-                CTxDestination address;\n-                if(!IsMine(txin)) /* If this input isn't mine, ignore it */\n-                    continue;\n-                if(!ExtractDestination(mapWallet.at(txin.prevout.hash).tx->vout[txin.prevout.n].scriptPubKey, address))\n-                    continue;\n-                grouping.insert(address);\n-                any_mine = true;\n-            }\n-\n-            // group change with input addresses\n-            if (any_mine)\n-            {\n-               for (const CTxOut& txout : wtx.tx->vout)\n-                   if (IsChange(txout))\n-                   {\n-                       CTxDestination txoutAddr;\n-                       if(!ExtractDestination(txout.scriptPubKey, txoutAddr))\n-                           continue;\n-                       grouping.insert(txoutAddr);\n-                   }\n-            }\n-            if (grouping.size() > 0)\n-            {\n-                groupings.insert(grouping);\n-                grouping.clear();\n-            }\n-        }\n-\n-        // group lone addrs by themselves\n-        for (const auto& txout : wtx.tx->vout)\n-            if (IsMine(txout))\n-            {\n-                CTxDestination address;\n-                if(!ExtractDestination(txout.scriptPubKey, address))\n-                    continue;\n-                grouping.insert(address);\n-                groupings.insert(grouping);\n-                grouping.clear();\n-            }\n-    }\n-\n-    std::set< std::set<CTxDestination>* > uniqueGroupings; // a set of pointers to groups of addresses\n-    std::map< CTxDestination, std::set<CTxDestination>* > setmap;  // map addresses to the unique group containing it\n-    for (std::set<CTxDestination> _grouping : groupings)\n-    {\n-        // make a set of all the groups hit by this new group\n-        std::set< std::set<CTxDestination>* > hits;\n-        std::map< CTxDestination, std::set<CTxDestination>* >::iterator it;\n-        for (const CTxDestination& address : _grouping)\n-            if ((it = setmap.find(address)) != setmap.end())\n-                hits.insert((*it).second);\n-\n-        // merge all hit groups into a new single group and delete old groups\n-        std::set<CTxDestination>* merged = new std::set<CTxDestination>(_grouping);\n-        for (std::set<CTxDestination>* hit : hits)\n-        {\n-            merged->insert(hit->begin(), hit->end());\n-            uniqueGroupings.erase(hit);\n-            delete hit;\n-        }\n-        uniqueGroupings.insert(merged);\n-\n-        // update setmap\n-        for (const CTxDestination& element : *merged)\n-            setmap[element] = merged;\n-    }\n-\n-    std::set< std::set<CTxDestination> > ret;\n-    for (const std::set<CTxDestination>* uniqueGrouping : uniqueGroupings)\n-    {\n-        ret.insert(*uniqueGrouping);\n-        delete uniqueGrouping;\n-    }\n-\n-    return ret;\n-}"
      },
      {
        "sha": "8eead3241354e055254b3acdedc54707635a9dd3",
        "filename": "src/wallet/receive.h",
        "status": "removed",
        "additions": 0,
        "deletions": 20,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8462cd56010a8beadf95d4f3cb1357ca9d88493b/src/wallet/receive.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8462cd56010a8beadf95d4f3cb1357ca9d88493b/src/wallet/receive.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/receive.h?ref=8462cd56010a8beadf95d4f3cb1357ca9d88493b",
        "patch": "@@ -1,20 +0,0 @@\n-// Copyright (c) 2021 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#ifndef BITCOIN_WALLET_RECEIVE_H\n-#define BITCOIN_WALLET_RECEIVE_H\n-\n-#include <amount.h>\n-#include <wallet/ismine.h>\n-#include <wallet/transaction.h>\n-#include <wallet/wallet.h>\n-\n-struct COutputEntry\n-{\n-    CTxDestination destination;\n-    CAmount amount;\n-    int vout;\n-};\n-\n-#endif // BITCOIN_WALLET_RECEIVE_H"
      },
      {
        "sha": "97fc7acca5560aa8165b0409d8d53eaeb8649e76",
        "filename": "src/wallet/spend.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 978,
        "changes": 978,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8462cd56010a8beadf95d4f3cb1357ca9d88493b/src/wallet/spend.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8462cd56010a8beadf95d4f3cb1357ca9d88493b/src/wallet/spend.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/spend.cpp?ref=8462cd56010a8beadf95d4f3cb1357ca9d88493b",
        "patch": "@@ -1,978 +0,0 @@\n-// Copyright (c) 2021 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <consensus/validation.h>\n-#include <interfaces/chain.h>\n-#include <policy/policy.h>\n-#include <util/check.h>\n-#include <util/fees.h>\n-#include <util/moneystr.h>\n-#include <util/rbf.h>\n-#include <util/translation.h>\n-#include <wallet/coincontrol.h>\n-#include <wallet/fees.h>\n-#include <wallet/receive.h>\n-#include <wallet/spend.h>\n-#include <wallet/transaction.h>\n-#include <wallet/wallet.h>\n-\n-using interfaces::FoundBlock;\n-\n-static constexpr size_t OUTPUT_GROUP_MAX_ENTRIES{100};\n-\n-std::string COutput::ToString() const\n-{\n-    return strprintf(\"COutput(%s, %d, %d) [%s]\", tx->GetHash().ToString(), i, nDepth, FormatMoney(tx->tx->vout[i].nValue));\n-}\n-\n-int CalculateMaximumSignedInputSize(const CTxOut& txout, const CWallet* wallet, bool use_max_sig)\n-{\n-    CMutableTransaction txn;\n-    txn.vin.push_back(CTxIn(COutPoint()));\n-    if (!wallet->DummySignInput(txn.vin[0], txout, use_max_sig)) {\n-        return -1;\n-    }\n-    return GetVirtualTransactionInputSize(txn.vin[0]);\n-}\n-\n-// txouts needs to be in the order of tx.vin\n-TxSize CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, const std::vector<CTxOut>& txouts, bool use_max_sig)\n-{\n-    CMutableTransaction txNew(tx);\n-    if (!wallet->DummySignTx(txNew, txouts, use_max_sig)) {\n-        return TxSize{-1, -1};\n-    }\n-    CTransaction ctx(txNew);\n-    int64_t vsize = GetVirtualTransactionSize(ctx);\n-    int64_t weight = GetTransactionWeight(ctx);\n-    return TxSize{vsize, weight};\n-}\n-\n-TxSize CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, bool use_max_sig)\n-{\n-    std::vector<CTxOut> txouts;\n-    for (const CTxIn& input : tx.vin) {\n-        const auto mi = wallet->mapWallet.find(input.prevout.hash);\n-        // Can not estimate size without knowing the input details\n-        if (mi == wallet->mapWallet.end()) {\n-            return TxSize{-1, -1};\n-        }\n-        assert(input.prevout.n < mi->second.tx->vout.size());\n-        txouts.emplace_back(mi->second.tx->vout[input.prevout.n]);\n-    }\n-    return CalculateMaximumSignedTxSize(tx, wallet, txouts, use_max_sig);\n-}\n-\n-void CWallet::AvailableCoins(std::vector<COutput>& vCoins, const CCoinControl* coinControl, const CAmount& nMinimumAmount, const CAmount& nMaximumAmount, const CAmount& nMinimumSumAmount, const uint64_t nMaximumCount) const\n-{\n-    AssertLockHeld(cs_wallet);\n-\n-    vCoins.clear();\n-    CAmount nTotal = 0;\n-    // Either the WALLET_FLAG_AVOID_REUSE flag is not set (in which case we always allow), or we default to avoiding, and only in the case where\n-    // a coin control object is provided, and has the avoid address reuse flag set to false, do we allow already used addresses\n-    bool allow_used_addresses = !IsWalletFlagSet(WALLET_FLAG_AVOID_REUSE) || (coinControl && !coinControl->m_avoid_address_reuse);\n-    const int min_depth = {coinControl ? coinControl->m_min_depth : DEFAULT_MIN_DEPTH};\n-    const int max_depth = {coinControl ? coinControl->m_max_depth : DEFAULT_MAX_DEPTH};\n-    const bool only_safe = {coinControl ? !coinControl->m_include_unsafe_inputs : true};\n-\n-    std::set<uint256> trusted_parents;\n-    for (const auto& entry : mapWallet)\n-    {\n-        const uint256& wtxid = entry.first;\n-        const CWalletTx& wtx = entry.second;\n-\n-        if (!chain().checkFinalTx(*wtx.tx)) {\n-            continue;\n-        }\n-\n-        if (wtx.IsImmatureCoinBase())\n-            continue;\n-\n-        int nDepth = wtx.GetDepthInMainChain();\n-        if (nDepth < 0)\n-            continue;\n-\n-        // We should not consider coins which aren't at least in our mempool\n-        // It's possible for these to be conflicted via ancestors which we may never be able to detect\n-        if (nDepth == 0 && !wtx.InMempool())\n-            continue;\n-\n-        bool safeTx = IsTrusted(wtx, trusted_parents);\n-\n-        // We should not consider coins from transactions that are replacing\n-        // other transactions.\n-        //\n-        // Example: There is a transaction A which is replaced by bumpfee\n-        // transaction B. In this case, we want to prevent creation of\n-        // a transaction B' which spends an output of B.\n-        //\n-        // Reason: If transaction A were initially confirmed, transactions B\n-        // and B' would no longer be valid, so the user would have to create\n-        // a new transaction C to replace B'. However, in the case of a\n-        // one-block reorg, transactions B' and C might BOTH be accepted,\n-        // when the user only wanted one of them. Specifically, there could\n-        // be a 1-block reorg away from the chain where transactions A and C\n-        // were accepted to another chain where B, B', and C were all\n-        // accepted.\n-        if (nDepth == 0 && wtx.mapValue.count(\"replaces_txid\")) {\n-            safeTx = false;\n-        }\n-\n-        // Similarly, we should not consider coins from transactions that\n-        // have been replaced. In the example above, we would want to prevent\n-        // creation of a transaction A' spending an output of A, because if\n-        // transaction B were initially confirmed, conflicting with A and\n-        // A', we wouldn't want to the user to create a transaction D\n-        // intending to replace A', but potentially resulting in a scenario\n-        // where A, A', and D could all be accepted (instead of just B and\n-        // D, or just A and A' like the user would want).\n-        if (nDepth == 0 && wtx.mapValue.count(\"replaced_by_txid\")) {\n-            safeTx = false;\n-        }\n-\n-        if (only_safe && !safeTx) {\n-            continue;\n-        }\n-\n-        if (nDepth < min_depth || nDepth > max_depth) {\n-            continue;\n-        }\n-\n-        for (unsigned int i = 0; i < wtx.tx->vout.size(); i++) {\n-            // Only consider selected coins if add_inputs is false\n-            if (coinControl && !coinControl->m_add_inputs && !coinControl->IsSelected(COutPoint(entry.first, i))) {\n-                continue;\n-            }\n-\n-            if (wtx.tx->vout[i].nValue < nMinimumAmount || wtx.tx->vout[i].nValue > nMaximumAmount)\n-                continue;\n-\n-            if (coinControl && coinControl->HasSelected() && !coinControl->fAllowOtherInputs && !coinControl->IsSelected(COutPoint(entry.first, i)))\n-                continue;\n-\n-            if (IsLockedCoin(entry.first, i))\n-                continue;\n-\n-            if (IsSpent(wtxid, i))\n-                continue;\n-\n-            isminetype mine = IsMine(wtx.tx->vout[i]);\n-\n-            if (mine == ISMINE_NO) {\n-                continue;\n-            }\n-\n-            if (!allow_used_addresses && IsSpentKey(wtxid, i)) {\n-                continue;\n-            }\n-\n-            std::unique_ptr<SigningProvider> provider = GetSolvingProvider(wtx.tx->vout[i].scriptPubKey);\n-\n-            bool solvable = provider ? IsSolvable(*provider, wtx.tx->vout[i].scriptPubKey) : false;\n-            bool spendable = ((mine & ISMINE_SPENDABLE) != ISMINE_NO) || (((mine & ISMINE_WATCH_ONLY) != ISMINE_NO) && (coinControl && coinControl->fAllowWatchOnly && solvable));\n-\n-            vCoins.push_back(COutput(&wtx, i, nDepth, spendable, solvable, safeTx, (coinControl && coinControl->fAllowWatchOnly)));\n-\n-            // Checks the sum amount of all UTXO's.\n-            if (nMinimumSumAmount != MAX_MONEY) {\n-                nTotal += wtx.tx->vout[i].nValue;\n-\n-                if (nTotal >= nMinimumSumAmount) {\n-                    return;\n-                }\n-            }\n-\n-            // Checks the maximum number of UTXO's.\n-            if (nMaximumCount > 0 && vCoins.size() >= nMaximumCount) {\n-                return;\n-            }\n-        }\n-    }\n-}\n-\n-CAmount CWallet::GetAvailableBalance(const CCoinControl* coinControl) const\n-{\n-    LOCK(cs_wallet);\n-\n-    CAmount balance = 0;\n-    std::vector<COutput> vCoins;\n-    AvailableCoins(vCoins, coinControl);\n-    for (const COutput& out : vCoins) {\n-        if (out.fSpendable) {\n-            balance += out.tx->tx->vout[out.i].nValue;\n-        }\n-    }\n-    return balance;\n-}\n-\n-const CTxOut& CWallet::FindNonChangeParentOutput(const CTransaction& tx, int output) const\n-{\n-    AssertLockHeld(cs_wallet);\n-    const CTransaction* ptx = &tx;\n-    int n = output;\n-    while (IsChange(ptx->vout[n]) && ptx->vin.size() > 0) {\n-        const COutPoint& prevout = ptx->vin[0].prevout;\n-        auto it = mapWallet.find(prevout.hash);\n-        if (it == mapWallet.end() || it->second.tx->vout.size() <= prevout.n ||\n-            !IsMine(it->second.tx->vout[prevout.n])) {\n-            break;\n-        }\n-        ptx = it->second.tx.get();\n-        n = prevout.n;\n-    }\n-    return ptx->vout[n];\n-}\n-\n-std::map<CTxDestination, std::vector<COutput>> CWallet::ListCoins() const\n-{\n-    AssertLockHeld(cs_wallet);\n-\n-    std::map<CTxDestination, std::vector<COutput>> result;\n-    std::vector<COutput> availableCoins;\n-\n-    AvailableCoins(availableCoins);\n-\n-    for (const COutput& coin : availableCoins) {\n-        CTxDestination address;\n-        if ((coin.fSpendable || (IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) && coin.fSolvable)) &&\n-            ExtractDestination(FindNonChangeParentOutput(*coin.tx->tx, coin.i).scriptPubKey, address)) {\n-            result[address].emplace_back(std::move(coin));\n-        }\n-    }\n-\n-    std::vector<COutPoint> lockedCoins;\n-    ListLockedCoins(lockedCoins);\n-    // Include watch-only for LegacyScriptPubKeyMan wallets without private keys\n-    const bool include_watch_only = GetLegacyScriptPubKeyMan() && IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS);\n-    const isminetype is_mine_filter = include_watch_only ? ISMINE_WATCH_ONLY : ISMINE_SPENDABLE;\n-    for (const COutPoint& output : lockedCoins) {\n-        auto it = mapWallet.find(output.hash);\n-        if (it != mapWallet.end()) {\n-            int depth = it->second.GetDepthInMainChain();\n-            if (depth >= 0 && output.n < it->second.tx->vout.size() &&\n-                IsMine(it->second.tx->vout[output.n]) == is_mine_filter\n-            ) {\n-                CTxDestination address;\n-                if (ExtractDestination(FindNonChangeParentOutput(*it->second.tx, output.n).scriptPubKey, address)) {\n-                    result[address].emplace_back(\n-                        &it->second, output.n, depth, true /* spendable */, true /* solvable */, false /* safe */);\n-                }\n-            }\n-        }\n-    }\n-\n-    return result;\n-}\n-\n-std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outputs, const CoinSelectionParams& coin_sel_params, const CoinEligibilityFilter& filter, bool positive_only) const\n-{\n-    std::vector<OutputGroup> groups_out;\n-\n-    if (!coin_sel_params.m_avoid_partial_spends) {\n-        // Allowing partial spends  means no grouping. Each COutput gets its own OutputGroup.\n-        for (const COutput& output : outputs) {\n-            // Skip outputs we cannot spend\n-            if (!output.fSpendable) continue;\n-\n-            size_t ancestors, descendants;\n-            chain().getTransactionAncestry(output.tx->GetHash(), ancestors, descendants);\n-            CInputCoin input_coin = output.GetInputCoin();\n-\n-            // Make an OutputGroup containing just this output\n-            OutputGroup group{coin_sel_params};\n-            group.Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants, positive_only);\n-\n-            // Check the OutputGroup's eligibility. Only add the eligible ones.\n-            if (positive_only && group.GetSelectionAmount() <= 0) continue;\n-            if (group.m_outputs.size() > 0 && group.EligibleForSpending(filter)) groups_out.push_back(group);\n-        }\n-        return groups_out;\n-    }\n-\n-    // We want to combine COutputs that have the same scriptPubKey into single OutputGroups\n-    // except when there are more than OUTPUT_GROUP_MAX_ENTRIES COutputs grouped in an OutputGroup.\n-    // To do this, we maintain a map where the key is the scriptPubKey and the value is a vector of OutputGroups.\n-    // For each COutput, we check if the scriptPubKey is in the map, and if it is, the COutput's CInputCoin is added\n-    // to the last OutputGroup in the vector for the scriptPubKey. When the last OutputGroup has\n-    // OUTPUT_GROUP_MAX_ENTRIES CInputCoins, a new OutputGroup is added to the end of the vector.\n-    std::map<CScript, std::vector<OutputGroup>> spk_to_groups_map;\n-    for (const auto& output : outputs) {\n-        // Skip outputs we cannot spend\n-        if (!output.fSpendable) continue;\n-\n-        size_t ancestors, descendants;\n-        chain().getTransactionAncestry(output.tx->GetHash(), ancestors, descendants);\n-        CInputCoin input_coin = output.GetInputCoin();\n-        CScript spk = input_coin.txout.scriptPubKey;\n-\n-        std::vector<OutputGroup>& groups = spk_to_groups_map[spk];\n-\n-        if (groups.size() == 0) {\n-            // No OutputGroups for this scriptPubKey yet, add one\n-            groups.emplace_back(coin_sel_params);\n-        }\n-\n-        // Get the last OutputGroup in the vector so that we can add the CInputCoin to it\n-        // A pointer is used here so that group can be reassigned later if it is full.\n-        OutputGroup* group = &groups.back();\n-\n-        // Check if this OutputGroup is full. We limit to OUTPUT_GROUP_MAX_ENTRIES when using -avoidpartialspends\n-        // to avoid surprising users with very high fees.\n-        if (group->m_outputs.size() >= OUTPUT_GROUP_MAX_ENTRIES) {\n-            // The last output group is full, add a new group to the vector and use that group for the insertion\n-            groups.emplace_back(coin_sel_params);\n-            group = &groups.back();\n-        }\n-\n-        // Add the input_coin to group\n-        group->Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants, positive_only);\n-    }\n-\n-    // Now we go through the entire map and pull out the OutputGroups\n-    for (const auto& spk_and_groups_pair: spk_to_groups_map) {\n-        const std::vector<OutputGroup>& groups_per_spk= spk_and_groups_pair.second;\n-\n-        // Go through the vector backwards. This allows for the first item we deal with being the partial group.\n-        for (auto group_it = groups_per_spk.rbegin(); group_it != groups_per_spk.rend(); group_it++) {\n-            const OutputGroup& group = *group_it;\n-\n-            // Don't include partial groups if there are full groups too and we don't want partial groups\n-            if (group_it == groups_per_spk.rbegin() && groups_per_spk.size() > 1 && !filter.m_include_partial_groups) {\n-                continue;\n-            }\n-\n-            // Check the OutputGroup's eligibility. Only add the eligible ones.\n-            if (positive_only && group.GetSelectionAmount() <= 0) continue;\n-            if (group.m_outputs.size() > 0 && group.EligibleForSpending(filter)) groups_out.push_back(group);\n-        }\n-    }\n-\n-    return groups_out;\n-}\n-\n-bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<COutput> coins,\n-                                 std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params) const\n-{\n-    setCoinsRet.clear();\n-    nValueRet = 0;\n-\n-    // Note that unlike KnapsackSolver, we do not include the fee for creating a change output as BnB will not create a change output.\n-    std::vector<OutputGroup> positive_groups = GroupOutputs(coins, coin_selection_params, eligibility_filter, true /* positive_only */);\n-    if (SelectCoinsBnB(positive_groups, nTargetValue, coin_selection_params.m_cost_of_change, setCoinsRet, nValueRet)) {\n-        return true;\n-    }\n-    // The knapsack solver has some legacy behavior where it will spend dust outputs. We retain this behavior, so don't filter for positive only here.\n-    std::vector<OutputGroup> all_groups = GroupOutputs(coins, coin_selection_params, eligibility_filter, false /* positive_only */);\n-    // While nTargetValue includes the transaction fees for non-input things, it does not include the fee for creating a change output.\n-    // So we need to include that for KnapsackSolver as well, as we are expecting to create a change output.\n-    return KnapsackSolver(nTargetValue + coin_selection_params.m_change_fee, all_groups, setCoinsRet, nValueRet);\n-}\n-\n-bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CCoinControl& coin_control, CoinSelectionParams& coin_selection_params) const\n-{\n-    std::vector<COutput> vCoins(vAvailableCoins);\n-    CAmount value_to_select = nTargetValue;\n-\n-    // coin control -> return all selected outputs (we want all selected to go into the transaction for sure)\n-    if (coin_control.HasSelected() && !coin_control.fAllowOtherInputs)\n-    {\n-        for (const COutput& out : vCoins)\n-        {\n-            if (!out.fSpendable)\n-                 continue;\n-            nValueRet += out.tx->tx->vout[out.i].nValue;\n-            setCoinsRet.insert(out.GetInputCoin());\n-        }\n-        return (nValueRet >= nTargetValue);\n-    }\n-\n-    // calculate value from preset inputs and store them\n-    std::set<CInputCoin> setPresetCoins;\n-    CAmount nValueFromPresetInputs = 0;\n-\n-    std::vector<COutPoint> vPresetInputs;\n-    coin_control.ListSelected(vPresetInputs);\n-    for (const COutPoint& outpoint : vPresetInputs)\n-    {\n-        std::map<uint256, CWalletTx>::const_iterator it = mapWallet.find(outpoint.hash);\n-        if (it != mapWallet.end())\n-        {\n-            const CWalletTx& wtx = it->second;\n-            // Clearly invalid input, fail\n-            if (wtx.tx->vout.size() <= outpoint.n) {\n-                return false;\n-            }\n-            // Just to calculate the marginal byte size\n-            CInputCoin coin(wtx.tx, outpoint.n, wtx.GetSpendSize(outpoint.n, false));\n-            nValueFromPresetInputs += coin.txout.nValue;\n-            if (coin.m_input_bytes <= 0) {\n-                return false; // Not solvable, can't estimate size for fee\n-            }\n-            coin.effective_value = coin.txout.nValue - coin_selection_params.m_effective_feerate.GetFee(coin.m_input_bytes);\n-            if (coin_selection_params.m_subtract_fee_outputs) {\n-                value_to_select -= coin.txout.nValue;\n-            } else {\n-                value_to_select -= coin.effective_value;\n-            }\n-            setPresetCoins.insert(coin);\n-        } else {\n-            return false; // TODO: Allow non-wallet inputs\n-        }\n-    }\n-\n-    // remove preset inputs from vCoins so that Coin Selection doesn't pick them.\n-    for (std::vector<COutput>::iterator it = vCoins.begin(); it != vCoins.end() && coin_control.HasSelected();)\n-    {\n-        if (setPresetCoins.count(it->GetInputCoin()))\n-            it = vCoins.erase(it);\n-        else\n-            ++it;\n-    }\n-\n-    unsigned int limit_ancestor_count = 0;\n-    unsigned int limit_descendant_count = 0;\n-    chain().getPackageLimits(limit_ancestor_count, limit_descendant_count);\n-    const size_t max_ancestors = (size_t)std::max<int64_t>(1, limit_ancestor_count);\n-    const size_t max_descendants = (size_t)std::max<int64_t>(1, limit_descendant_count);\n-    const bool fRejectLongChains = gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS);\n-\n-    // form groups from remaining coins; note that preset coins will not\n-    // automatically have their associated (same address) coins included\n-    if (coin_control.m_avoid_partial_spends && vCoins.size() > OUTPUT_GROUP_MAX_ENTRIES) {\n-        // Cases where we have 101+ outputs all pointing to the same destination may result in\n-        // privacy leaks as they will potentially be deterministically sorted. We solve that by\n-        // explicitly shuffling the outputs before processing\n-        Shuffle(vCoins.begin(), vCoins.end(), FastRandomContext());\n-    }\n-\n-    // Coin Selection attempts to select inputs from a pool of eligible UTXOs to fund the\n-    // transaction at a target feerate. If an attempt fails, more attempts may be made using a more\n-    // permissive CoinEligibilityFilter.\n-    const bool res = [&] {\n-        // Pre-selected inputs already cover the target amount.\n-        if (value_to_select <= 0) return true;\n-\n-        // If possible, fund the transaction with confirmed UTXOs only. Prefer at least six\n-        // confirmations on outputs received from other wallets and only spend confirmed change.\n-        if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(1, 6, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params)) return true;\n-        if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(1, 1, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params)) return true;\n-\n-        // Fall back to using zero confirmation change (but with as few ancestors in the mempool as\n-        // possible) if we cannot fund the transaction otherwise.\n-        if (m_spend_zero_conf_change) {\n-            if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, 2), vCoins, setCoinsRet, nValueRet, coin_selection_params)) return true;\n-            if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)),\n-                                   vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n-                return true;\n-            }\n-            if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2),\n-                                   vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n-                return true;\n-            }\n-            // If partial groups are allowed, relax the requirement of spending OutputGroups (groups\n-            // of UTXOs sent to the same address, which are obviously controlled by a single wallet)\n-            // in their entirety.\n-            if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1, true /* include_partial_groups */),\n-                                   vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n-                return true;\n-            }\n-            // Try with unsafe inputs if they are allowed. This may spend unconfirmed outputs\n-            // received from other wallets.\n-            if (coin_control.m_include_unsafe_inputs\n-                && SelectCoinsMinConf(value_to_select,\n-                    CoinEligibilityFilter(0 /* conf_mine */, 0 /* conf_theirs */, max_ancestors-1, max_descendants-1, true /* include_partial_groups */),\n-                    vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n-                return true;\n-            }\n-            // Try with unlimited ancestors/descendants. The transaction will still need to meet\n-            // mempool ancestor/descendant policy to be accepted to mempool and broadcasted, but\n-            // OutputGroups use heuristics that may overestimate ancestor/descendant counts.\n-            if (!fRejectLongChains && SelectCoinsMinConf(value_to_select,\n-                                      CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max(), std::numeric_limits<uint64_t>::max(), true /* include_partial_groups */),\n-                                      vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n-                return true;\n-            }\n-        }\n-        // Coin Selection failed.\n-        return false;\n-    }();\n-\n-    // SelectCoinsMinConf clears setCoinsRet, so add the preset inputs from coin_control to the coinset\n-    util::insert(setCoinsRet, setPresetCoins);\n-\n-    // add preset inputs to the total value selected\n-    nValueRet += nValueFromPresetInputs;\n-\n-    return res;\n-}\n-\n-static bool IsCurrentForAntiFeeSniping(interfaces::Chain& chain, const uint256& block_hash)\n-{\n-    if (chain.isInitialBlockDownload()) {\n-        return false;\n-    }\n-    constexpr int64_t MAX_ANTI_FEE_SNIPING_TIP_AGE = 8 * 60 * 60; // in seconds\n-    int64_t block_time;\n-    CHECK_NONFATAL(chain.findBlock(block_hash, FoundBlock().time(block_time)));\n-    if (block_time < (GetTime() - MAX_ANTI_FEE_SNIPING_TIP_AGE)) {\n-        return false;\n-    }\n-    return true;\n-}\n-\n-/**\n- * Return a height-based locktime for new transactions (uses the height of the\n- * current chain tip unless we are not synced with the current chain\n- */\n-static uint32_t GetLocktimeForNewTransaction(interfaces::Chain& chain, const uint256& block_hash, int block_height)\n-{\n-    uint32_t locktime;\n-    // Discourage fee sniping.\n-    //\n-    // For a large miner the value of the transactions in the best block and\n-    // the mempool can exceed the cost of deliberately attempting to mine two\n-    // blocks to orphan the current best block. By setting nLockTime such that\n-    // only the next block can include the transaction, we discourage this\n-    // practice as the height restricted and limited blocksize gives miners\n-    // considering fee sniping fewer options for pulling off this attack.\n-    //\n-    // A simple way to think about this is from the wallet's point of view we\n-    // always want the blockchain to move forward. By setting nLockTime this\n-    // way we're basically making the statement that we only want this\n-    // transaction to appear in the next block; we don't want to potentially\n-    // encourage reorgs by allowing transactions to appear at lower heights\n-    // than the next block in forks of the best chain.\n-    //\n-    // Of course, the subsidy is high enough, and transaction volume low\n-    // enough, that fee sniping isn't a problem yet, but by implementing a fix\n-    // now we ensure code won't be written that makes assumptions about\n-    // nLockTime that preclude a fix later.\n-    if (IsCurrentForAntiFeeSniping(chain, block_hash)) {\n-        locktime = block_height;\n-\n-        // Secondly occasionally randomly pick a nLockTime even further back, so\n-        // that transactions that are delayed after signing for whatever reason,\n-        // e.g. high-latency mix networks and some CoinJoin implementations, have\n-        // better privacy.\n-        if (GetRandInt(10) == 0)\n-            locktime = std::max(0, (int)locktime - GetRandInt(100));\n-    } else {\n-        // If our chain is lagging behind, we can't discourage fee sniping nor help\n-        // the privacy of high-latency transactions. To avoid leaking a potentially\n-        // unique \"nLockTime fingerprint\", set nLockTime to a constant.\n-        locktime = 0;\n-    }\n-    assert(locktime < LOCKTIME_THRESHOLD);\n-    return locktime;\n-}\n-\n-bool CWallet::CreateTransactionInternal(\n-        const std::vector<CRecipient>& vecSend,\n-        CTransactionRef& tx,\n-        CAmount& nFeeRet,\n-        int& nChangePosInOut,\n-        bilingual_str& error,\n-        const CCoinControl& coin_control,\n-        FeeCalculation& fee_calc_out,\n-        bool sign)\n-{\n-    CAmount nValue = 0;\n-    const OutputType change_type = TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : m_default_change_type, vecSend);\n-    ReserveDestination reservedest(this, change_type);\n-    unsigned int nSubtractFeeFromAmount = 0;\n-    for (const auto& recipient : vecSend)\n-    {\n-        if (nValue < 0 || recipient.nAmount < 0)\n-        {\n-            error = _(\"Transaction amounts must not be negative\");\n-            return false;\n-        }\n-        nValue += recipient.nAmount;\n-\n-        if (recipient.fSubtractFeeFromAmount)\n-            nSubtractFeeFromAmount++;\n-    }\n-    if (vecSend.empty())\n-    {\n-        error = _(\"Transaction must have at least one recipient\");\n-        return false;\n-    }\n-\n-    CMutableTransaction txNew;\n-    FeeCalculation feeCalc;\n-    TxSize tx_sizes;\n-    int nBytes;\n-    {\n-        std::set<CInputCoin> setCoins;\n-        LOCK(cs_wallet);\n-        txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n-        {\n-            std::vector<COutput> vAvailableCoins;\n-            AvailableCoins(vAvailableCoins, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n-            CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n-            coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;\n-\n-            // Create change script that will be used if we need change\n-            // TODO: pass in scriptChange instead of reservedest so\n-            // change transaction isn't always pay-to-bitcoin-address\n-            CScript scriptChange;\n-\n-            // coin control: send change to custom address\n-            if (!std::get_if<CNoDestination>(&coin_control.destChange)) {\n-                scriptChange = GetScriptForDestination(coin_control.destChange);\n-            } else { // no coin control: send change to newly generated address\n-                // Note: We use a new key here to keep it from being obvious which side is the change.\n-                //  The drawback is that by not reusing a previous key, the change may be lost if a\n-                //  backup is restored, if the backup doesn't have the new private key for the change.\n-                //  If we reused the old key, it would be possible to add code to look for and\n-                //  rediscover unknown transactions that were written with keys of ours to recover\n-                //  post-backup change.\n-\n-                // Reserve a new key pair from key pool. If it fails, provide a dummy\n-                // destination in case we don't need change.\n-                CTxDestination dest;\n-                if (!reservedest.GetReservedDestination(dest, true)) {\n-                    error = _(\"Transaction needs a change address, but we can't generate it. Please call keypoolrefill first.\");\n-                }\n-                scriptChange = GetScriptForDestination(dest);\n-                // A valid destination implies a change script (and\n-                // vice-versa). An empty change script will abort later, if the\n-                // change keypool ran out, but change is required.\n-                CHECK_NONFATAL(IsValidDestination(dest) != scriptChange.empty());\n-            }\n-            CTxOut change_prototype_txout(0, scriptChange);\n-            coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);\n-\n-            // Get size of spending the change output\n-            int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n-            // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n-            // as lower-bound to allow BnB to do it's thing\n-            if (change_spend_size == -1) {\n-                coin_selection_params.change_spend_size = DUMMY_NESTED_P2WPKH_INPUT_SIZE;\n-            } else {\n-                coin_selection_params.change_spend_size = (size_t)change_spend_size;\n-            }\n-\n-            // Set discard feerate\n-            coin_selection_params.m_discard_feerate = GetDiscardRate(*this);\n-\n-            // Get the fee rate to use effective values in coin selection\n-            coin_selection_params.m_effective_feerate = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n-            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n-            // provided one\n-            if (coin_control.m_feerate && coin_selection_params.m_effective_feerate > *coin_control.m_feerate) {\n-                error = strprintf(_(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\"), coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), coin_selection_params.m_effective_feerate.ToString(FeeEstimateMode::SAT_VB));\n-                return false;\n-            }\n-            if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n-                // eventually allow a fallback fee\n-                error = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n-                return false;\n-            }\n-\n-            // Get long term estimate\n-            CCoinControl cc_temp;\n-            cc_temp.m_confirm_target = chain().estimateMaxBlocks();\n-            coin_selection_params.m_long_term_feerate = GetMinimumFeeRate(*this, cc_temp, nullptr);\n-\n-            // Calculate the cost of change\n-            // Cost of change is the cost of creating the change output + cost of spending the change output in the future.\n-            // For creating the change output now, we use the effective feerate.\n-            // For spending the change output in the future, we use the discard feerate for now.\n-            // So cost of change = (change output size * effective feerate) + (size of spending change output * discard feerate)\n-            coin_selection_params.m_change_fee = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.change_output_size);\n-            coin_selection_params.m_cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + coin_selection_params.m_change_fee;\n-\n-            coin_selection_params.m_subtract_fee_outputs = nSubtractFeeFromAmount != 0; // If we are doing subtract fee from recipient, don't use effective values\n-\n-            // vouts to the payees\n-            if (!coin_selection_params.m_subtract_fee_outputs) {\n-                coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n-            }\n-            for (const auto& recipient : vecSend)\n-            {\n-                CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n-\n-                // Include the fee cost for outputs.\n-                if (!coin_selection_params.m_subtract_fee_outputs) {\n-                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n-                }\n-\n-                if (IsDust(txout, chain().relayDustFee()))\n-                {\n-                    error = _(\"Transaction amount too small\");\n-                    return false;\n-                }\n-                txNew.vout.push_back(txout);\n-            }\n-\n-            // Include the fees for things that aren't inputs, excluding the change output\n-            const CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n-            CAmount nValueToSelect = nValue + not_input_fees;\n-\n-            // Choose coins to use\n-            CAmount inputs_sum = 0;\n-            setCoins.clear();\n-            if (!SelectCoins(vAvailableCoins, /* nTargetValue */ nValueToSelect, setCoins, inputs_sum, coin_control, coin_selection_params))\n-            {\n-                error = _(\"Insufficient funds\");\n-                return false;\n-            }\n-\n-            // Always make a change output\n-            // We will reduce the fee from this change output later, and remove the output if it is too small.\n-            const CAmount change_and_fee = inputs_sum - nValue;\n-            assert(change_and_fee >= 0);\n-            CTxOut newTxOut(change_and_fee, scriptChange);\n-\n-            if (nChangePosInOut == -1)\n-            {\n-                // Insert change txn at random position:\n-                nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n-            }\n-            else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n-            {\n-                error = _(\"Change index out of range\");\n-                return false;\n-            }\n-\n-            assert(nChangePosInOut != -1);\n-            auto change_position = txNew.vout.insert(txNew.vout.begin() + nChangePosInOut, newTxOut);\n-\n-            // Dummy fill vin for maximum size estimation\n-            //\n-            for (const auto& coin : setCoins) {\n-                txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));\n-            }\n-\n-            // Calculate the transaction fee\n-            tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n-            nBytes = tx_sizes.vsize;\n-            if (nBytes < 0) {\n-                error = _(\"Signing transaction failed\");\n-                return false;\n-            }\n-            nFeeRet = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n-\n-            // Subtract fee from the change output if not subtrating it from recipient outputs\n-            CAmount fee_needed = nFeeRet;\n-            if (nSubtractFeeFromAmount == 0) {\n-                change_position->nValue -= fee_needed;\n-            }\n-\n-            // We want to drop the change to fees if:\n-            // 1. The change output would be dust\n-            // 2. The change is within the (almost) exact match window, i.e. it is less than or equal to the cost of the change output (cost_of_change)\n-            CAmount change_amount = change_position->nValue;\n-            if (IsDust(*change_position, coin_selection_params.m_discard_feerate) || change_amount <= coin_selection_params.m_cost_of_change)\n-            {\n-                nChangePosInOut = -1;\n-                change_amount = 0;\n-                txNew.vout.erase(change_position);\n-\n-                // Because we have dropped this change, the tx size and required fee will be different, so let's recalculate those\n-                tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n-                nBytes = tx_sizes.vsize;\n-                fee_needed = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n-            }\n-\n-            // Update nFeeRet in case fee_needed changed due to dropping the change output\n-            if (fee_needed <= change_and_fee - change_amount) {\n-                nFeeRet = change_and_fee - change_amount;\n-            }\n-\n-            // Reduce output values for subtractFeeFromAmount\n-            if (nSubtractFeeFromAmount != 0) {\n-                CAmount to_reduce = fee_needed + change_amount - change_and_fee;\n-                int i = 0;\n-                bool fFirst = true;\n-                for (const auto& recipient : vecSend)\n-                {\n-                    if (i == nChangePosInOut) {\n-                        ++i;\n-                    }\n-                    CTxOut& txout = txNew.vout[i];\n-\n-                    if (recipient.fSubtractFeeFromAmount)\n-                    {\n-                        txout.nValue -= to_reduce / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient\n-\n-                        if (fFirst) // first receiver pays the remainder not divisible by output count\n-                        {\n-                            fFirst = false;\n-                            txout.nValue -= to_reduce % nSubtractFeeFromAmount;\n-                        }\n-\n-                        // Error if this output is reduced to be below dust\n-                        if (IsDust(txout, chain().relayDustFee())) {\n-                            if (txout.nValue < 0) {\n-                                error = _(\"The transaction amount is too small to pay the fee\");\n-                            } else {\n-                                error = _(\"The transaction amount is too small to send after the fee has been deducted\");\n-                            }\n-                            return false;\n-                        }\n-                    }\n-                    ++i;\n-                }\n-                nFeeRet = fee_needed;\n-            }\n-\n-            // Give up if change keypool ran out and change is required\n-            if (scriptChange.empty() && nChangePosInOut != -1) {\n-                return false;\n-            }\n-        }\n-\n-        // Shuffle selected coins and fill in final vin\n-        txNew.vin.clear();\n-        std::vector<CInputCoin> selected_coins(setCoins.begin(), setCoins.end());\n-        Shuffle(selected_coins.begin(), selected_coins.end(), FastRandomContext());\n-\n-        // Note how the sequence number is set to non-maxint so that\n-        // the nLockTime set above actually works.\n-        //\n-        // BIP125 defines opt-in RBF as any nSequence < maxint-1, so\n-        // we use the highest possible value in that range (maxint-2)\n-        // to avoid conflicting with other possible uses of nSequence,\n-        // and in the spirit of \"smallest possible change from prior\n-        // behavior.\"\n-        const uint32_t nSequence = coin_control.m_signal_bip125_rbf.value_or(m_signal_rbf) ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n-        for (const auto& coin : selected_coins) {\n-            txNew.vin.push_back(CTxIn(coin.outpoint, CScript(), nSequence));\n-        }\n-\n-        if (sign && !SignTransaction(txNew)) {\n-            error = _(\"Signing transaction failed\");\n-            return false;\n-        }\n-\n-        // Return the constructed transaction data.\n-        tx = MakeTransactionRef(std::move(txNew));\n-\n-        // Limit size\n-        if ((sign && GetTransactionWeight(*tx) > MAX_STANDARD_TX_WEIGHT) ||\n-            (!sign && tx_sizes.weight > MAX_STANDARD_TX_WEIGHT))\n-        {\n-            error = _(\"Transaction too large\");\n-            return false;\n-        }\n-    }\n-\n-    if (nFeeRet > m_default_max_tx_fee) {\n-        error = TransactionErrorString(TransactionError::MAX_FEE_EXCEEDED);\n-        return false;\n-    }\n-\n-    if (gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS)) {\n-        // Lastly, ensure this tx will pass the mempool's chain limits\n-        if (!chain().checkChainLimits(tx)) {\n-            error = _(\"Transaction has too long of a mempool chain\");\n-            return false;\n-        }\n-    }\n-\n-    // Before we return success, we assume any change key will be used to prevent\n-    // accidental re-use.\n-    reservedest.KeepDestination();\n-    fee_calc_out = feeCalc;\n-\n-    WalletLogPrintf(\"Fee Calculation: Fee:%d Bytes:%u Tgt:%d (requested %d) Reason:\\\"%s\\\" Decay %.5f: Estimation: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out) Fail: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out)\\n\",\n-              nFeeRet, nBytes, feeCalc.returnedTarget, feeCalc.desiredTarget, StringForFeeReason(feeCalc.reason), feeCalc.est.decay,\n-              feeCalc.est.pass.start, feeCalc.est.pass.end,\n-              (feeCalc.est.pass.totalConfirmed + feeCalc.est.pass.inMempool + feeCalc.est.pass.leftMempool) > 0.0 ? 100 * feeCalc.est.pass.withinTarget / (feeCalc.est.pass.totalConfirmed + feeCalc.est.pass.inMempool + feeCalc.est.pass.leftMempool) : 0.0,\n-              feeCalc.est.pass.withinTarget, feeCalc.est.pass.totalConfirmed, feeCalc.est.pass.inMempool, feeCalc.est.pass.leftMempool,\n-              feeCalc.est.fail.start, feeCalc.est.fail.end,\n-              (feeCalc.est.fail.totalConfirmed + feeCalc.est.fail.inMempool + feeCalc.est.fail.leftMempool) > 0.0 ? 100 * feeCalc.est.fail.withinTarget / (feeCalc.est.fail.totalConfirmed + feeCalc.est.fail.inMempool + feeCalc.est.fail.leftMempool) : 0.0,\n-              feeCalc.est.fail.withinTarget, feeCalc.est.fail.totalConfirmed, feeCalc.est.fail.inMempool, feeCalc.est.fail.leftMempool);\n-    return true;\n-}\n-\n-bool CWallet::CreateTransaction(\n-        const std::vector<CRecipient>& vecSend,\n-        CTransactionRef& tx,\n-        CAmount& nFeeRet,\n-        int& nChangePosInOut,\n-        bilingual_str& error,\n-        const CCoinControl& coin_control,\n-        FeeCalculation& fee_calc_out,\n-        bool sign)\n-{\n-    int nChangePosIn = nChangePosInOut;\n-    Assert(!tx); // tx is an out-param. TODO change the return type from bool to tx (or nullptr)\n-    bool res = CreateTransactionInternal(vecSend, tx, nFeeRet, nChangePosInOut, error, coin_control, fee_calc_out, sign);\n-    // try with avoidpartialspends unless it's enabled already\n-    if (res && nFeeRet > 0 /* 0 means non-functional fee rate estimation */ && m_max_aps_fee > -1 && !coin_control.m_avoid_partial_spends) {\n-        CCoinControl tmp_cc = coin_control;\n-        tmp_cc.m_avoid_partial_spends = true;\n-        CAmount nFeeRet2;\n-        CTransactionRef tx2;\n-        int nChangePosInOut2 = nChangePosIn;\n-        bilingual_str error2; // fired and forgotten; if an error occurs, we discard the results\n-        if (CreateTransactionInternal(vecSend, tx2, nFeeRet2, nChangePosInOut2, error2, tmp_cc, fee_calc_out, sign)) {\n-            // if fee of this alternative one is within the range of the max fee, we use this one\n-            const bool use_aps = nFeeRet2 <= nFeeRet + m_max_aps_fee;\n-            WalletLogPrintf(\"Fee non-grouped = %lld, grouped = %lld, using %s\\n\", nFeeRet, nFeeRet2, use_aps ? \"grouped\" : \"non-grouped\");\n-            if (use_aps) {\n-                tx = tx2;\n-                nFeeRet = nFeeRet2;\n-                nChangePosInOut = nChangePosInOut2;\n-            }\n-        }\n-    }\n-    return res;\n-}\n-\n-bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nChangePosInOut, bilingual_str& error, bool lockUnspents, const std::set<int>& setSubtractFeeFromOutputs, CCoinControl coinControl)\n-{\n-    std::vector<CRecipient> vecSend;\n-\n-    // Turn the txout set into a CRecipient vector.\n-    for (size_t idx = 0; idx < tx.vout.size(); idx++) {\n-        const CTxOut& txOut = tx.vout[idx];\n-        CRecipient recipient = {txOut.scriptPubKey, txOut.nValue, setSubtractFeeFromOutputs.count(idx) == 1};\n-        vecSend.push_back(recipient);\n-    }\n-\n-    coinControl.fAllowOtherInputs = true;\n-\n-    for (const CTxIn& txin : tx.vin) {\n-        coinControl.Select(txin.prevout);\n-    }\n-\n-    // Acquire the locks to prevent races to the new locked unspents between the\n-    // CreateTransaction call and LockCoin calls (when lockUnspents is true).\n-    LOCK(cs_wallet);\n-\n-    CTransactionRef tx_new;\n-    FeeCalculation fee_calc_out;\n-    if (!CreateTransaction(vecSend, tx_new, nFeeRet, nChangePosInOut, error, coinControl, fee_calc_out, false)) {\n-        return false;\n-    }\n-\n-    if (nChangePosInOut != -1) {\n-        tx.vout.insert(tx.vout.begin() + nChangePosInOut, tx_new->vout[nChangePosInOut]);\n-    }\n-\n-    // Copy output sizes from new transaction; they may have had the fee\n-    // subtracted from them.\n-    for (unsigned int idx = 0; idx < tx.vout.size(); idx++) {\n-        tx.vout[idx].nValue = tx_new->vout[idx].nValue;\n-    }\n-\n-    // Add new txins while keeping original txin scriptSig/order.\n-    for (const CTxIn& txin : tx_new->vin) {\n-        if (!coinControl.IsSelected(txin.prevout)) {\n-            tx.vin.push_back(txin);\n-\n-        }\n-        if (lockUnspents) {\n-            LockCoin(txin.prevout);\n-        }\n-\n-    }\n-\n-    return true;\n-}"
      },
      {
        "sha": "03f9a7c2b5023a70aa211057acbe92d9afa06643",
        "filename": "src/wallet/spend.h",
        "status": "removed",
        "additions": 0,
        "deletions": 64,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8462cd56010a8beadf95d4f3cb1357ca9d88493b/src/wallet/spend.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8462cd56010a8beadf95d4f3cb1357ca9d88493b/src/wallet/spend.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/spend.h?ref=8462cd56010a8beadf95d4f3cb1357ca9d88493b",
        "patch": "@@ -1,64 +0,0 @@\n-// Copyright (c) 2021 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#ifndef BITCOIN_WALLET_SPEND_H\n-#define BITCOIN_WALLET_SPEND_H\n-\n-#include <wallet/coinselection.h>\n-#include <wallet/transaction.h>\n-#include <wallet/wallet.h>\n-\n-class COutput\n-{\n-public:\n-    const CWalletTx *tx;\n-\n-    /** Index in tx->vout. */\n-    int i;\n-\n-    /**\n-     * Depth in block chain.\n-     * If > 0: the tx is on chain and has this many confirmations.\n-     * If = 0: the tx is waiting confirmation.\n-     * If < 0: a conflicting tx is on chain and has this many confirmations. */\n-    int nDepth;\n-\n-    /** Pre-computed estimated size of this output as a fully-signed input in a transaction. Can be -1 if it could not be calculated */\n-    int nInputBytes;\n-\n-    /** Whether we have the private keys to spend this output */\n-    bool fSpendable;\n-\n-    /** Whether we know how to spend this output, ignoring the lack of keys */\n-    bool fSolvable;\n-\n-    /** Whether to use the maximum sized, 72 byte signature when calculating the size of the input spend. This should only be set when watch-only outputs are allowed */\n-    bool use_max_sig;\n-\n-    /**\n-     * Whether this output is considered safe to spend. Unconfirmed transactions\n-     * from outside keys and unconfirmed replacement transactions are considered\n-     * unsafe and will not be used to fund new spending transactions.\n-     */\n-    bool fSafe;\n-\n-    COutput(const CWalletTx *txIn, int iIn, int nDepthIn, bool fSpendableIn, bool fSolvableIn, bool fSafeIn, bool use_max_sig_in = false)\n-    {\n-        tx = txIn; i = iIn; nDepth = nDepthIn; fSpendable = fSpendableIn; fSolvable = fSolvableIn; fSafe = fSafeIn; nInputBytes = -1; use_max_sig = use_max_sig_in;\n-        // If known and signable by the given wallet, compute nInputBytes\n-        // Failure will keep this value -1\n-        if (fSpendable && tx) {\n-            nInputBytes = tx->GetSpendSize(i, use_max_sig);\n-        }\n-    }\n-\n-    std::string ToString() const;\n-\n-    inline CInputCoin GetInputCoin() const\n-    {\n-        return CInputCoin(tx->tx, i, nInputBytes);\n-    }\n-};\n-\n-#endif // BITCOIN_WALLET_SPEND_H"
      },
      {
        "sha": "cf98b516f177325cae0c30103177a58c98dcbf70",
        "filename": "src/wallet/transaction.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 25,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8462cd56010a8beadf95d4f3cb1357ca9d88493b/src/wallet/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8462cd56010a8beadf95d4f3cb1357ca9d88493b/src/wallet/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/transaction.cpp?ref=8462cd56010a8beadf95d4f3cb1357ca9d88493b",
        "patch": "@@ -1,25 +0,0 @@\n-// Copyright (c) 2021 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <wallet/transaction.h>\n-\n-bool CWalletTx::IsEquivalentTo(const CWalletTx& _tx) const\n-{\n-        CMutableTransaction tx1 {*this->tx};\n-        CMutableTransaction tx2 {*_tx.tx};\n-        for (auto& txin : tx1.vin) txin.scriptSig = CScript();\n-        for (auto& txin : tx2.vin) txin.scriptSig = CScript();\n-        return CTransaction(tx1) == CTransaction(tx2);\n-}\n-\n-bool CWalletTx::InMempool() const\n-{\n-    return fInMempool;\n-}\n-\n-int64_t CWalletTx::GetTxTime() const\n-{\n-    int64_t n = nTimeSmart;\n-    return n ? n : nTimeReceived;\n-}"
      },
      {
        "sha": "b57ab3db4899a9a4f3622ae5d635ee38a37aaebf",
        "filename": "src/wallet/transaction.h",
        "status": "removed",
        "additions": 0,
        "deletions": 358,
        "changes": 358,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8462cd56010a8beadf95d4f3cb1357ca9d88493b/src/wallet/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8462cd56010a8beadf95d4f3cb1357ca9d88493b/src/wallet/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/transaction.h?ref=8462cd56010a8beadf95d4f3cb1357ca9d88493b",
        "patch": "@@ -1,358 +0,0 @@\n-// Copyright (c) 2021 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#ifndef BITCOIN_WALLET_TRANSACTION_H\n-#define BITCOIN_WALLET_TRANSACTION_H\n-\n-#include <amount.h>\n-#include <primitives/transaction.h>\n-#include <serialize.h>\n-#include <wallet/ismine.h>\n-#include <threadsafety.h>\n-#include <tinyformat.h>\n-#include <util/strencodings.h>\n-#include <util/string.h>\n-\n-#include <list>\n-#include <vector>\n-\n-struct COutputEntry;\n-\n-typedef std::map<std::string, std::string> mapValue_t;\n-\n-//Get the marginal bytes of spending the specified output\n-int CalculateMaximumSignedInputSize(const CTxOut& txout, const CWallet* pwallet, bool use_max_sig = false);\n-\n-static inline void ReadOrderPos(int64_t& nOrderPos, mapValue_t& mapValue)\n-{\n-    if (!mapValue.count(\"n\"))\n-    {\n-        nOrderPos = -1; // TODO: calculate elsewhere\n-        return;\n-    }\n-    nOrderPos = atoi64(mapValue[\"n\"]);\n-}\n-\n-static inline void WriteOrderPos(const int64_t& nOrderPos, mapValue_t& mapValue)\n-{\n-    if (nOrderPos == -1)\n-        return;\n-    mapValue[\"n\"] = ToString(nOrderPos);\n-}\n-\n-/** Legacy class used for deserializing vtxPrev for backwards compatibility.\n- * vtxPrev was removed in commit 93a18a3650292afbb441a47d1fa1b94aeb0164e3,\n- * but old wallet.dat files may still contain vtxPrev vectors of CMerkleTxs.\n- * These need to get deserialized for field alignment when deserializing\n- * a CWalletTx, but the deserialized values are discarded.**/\n-class CMerkleTx\n-{\n-public:\n-    template<typename Stream>\n-    void Unserialize(Stream& s)\n-    {\n-        CTransactionRef tx;\n-        uint256 hashBlock;\n-        std::vector<uint256> vMerkleBranch;\n-        int nIndex;\n-\n-        s >> tx >> hashBlock >> vMerkleBranch >> nIndex;\n-    }\n-};\n-\n-/**\n- * A transaction with a bunch of additional info that only the owner cares about.\n- * It includes any unrecorded transactions needed to link it back to the block chain.\n- */\n-class CWalletTx\n-{\n-private:\n-    const CWallet* const pwallet;\n-\n-    /** Constant used in hashBlock to indicate tx has been abandoned, only used at\n-     * serialization/deserialization to avoid ambiguity with conflicted.\n-     */\n-    static constexpr const uint256& ABANDON_HASH = uint256::ONE;\n-\n-public:\n-    /**\n-     * Key/value map with information about the transaction.\n-     *\n-     * The following keys can be read and written through the map and are\n-     * serialized in the wallet database:\n-     *\n-     *     \"comment\", \"to\"   - comment strings provided to sendtoaddress,\n-     *                         and sendmany wallet RPCs\n-     *     \"replaces_txid\"   - txid (as HexStr) of transaction replaced by\n-     *                         bumpfee on transaction created by bumpfee\n-     *     \"replaced_by_txid\" - txid (as HexStr) of transaction created by\n-     *                         bumpfee on transaction replaced by bumpfee\n-     *     \"from\", \"message\" - obsolete fields that could be set in UI prior to\n-     *                         2011 (removed in commit 4d9b223)\n-     *\n-     * The following keys are serialized in the wallet database, but shouldn't\n-     * be read or written through the map (they will be temporarily added and\n-     * removed from the map during serialization):\n-     *\n-     *     \"fromaccount\"     - serialized strFromAccount value\n-     *     \"n\"               - serialized nOrderPos value\n-     *     \"timesmart\"       - serialized nTimeSmart value\n-     *     \"spent\"           - serialized vfSpent value that existed prior to\n-     *                         2014 (removed in commit 93a18a3)\n-     */\n-    mapValue_t mapValue;\n-    std::vector<std::pair<std::string, std::string> > vOrderForm;\n-    unsigned int fTimeReceivedIsTxTime;\n-    unsigned int nTimeReceived; //!< time received by this node\n-    /**\n-     * Stable timestamp that never changes, and reflects the order a transaction\n-     * was added to the wallet. Timestamp is based on the block time for a\n-     * transaction added as part of a block, or else the time when the\n-     * transaction was received if it wasn't part of a block, with the timestamp\n-     * adjusted in both cases so timestamp order matches the order transactions\n-     * were added to the wallet. More details can be found in\n-     * CWallet::ComputeTimeSmart().\n-     */\n-    unsigned int nTimeSmart;\n-    /**\n-     * From me flag is set to 1 for transactions that were created by the wallet\n-     * on this bitcoin node, and set to 0 for transactions that were created\n-     * externally and came in through the network or sendrawtransaction RPC.\n-     */\n-    bool fFromMe;\n-    int64_t nOrderPos; //!< position in ordered transaction list\n-    std::multimap<int64_t, CWalletTx*>::const_iterator m_it_wtxOrdered;\n-\n-    // memory only\n-    enum AmountType { DEBIT, CREDIT, IMMATURE_CREDIT, AVAILABLE_CREDIT, AMOUNTTYPE_ENUM_ELEMENTS };\n-    CAmount GetCachableAmount(AmountType type, const isminefilter& filter, bool recalculate = false) const;\n-    mutable CachableAmount m_amounts[AMOUNTTYPE_ENUM_ELEMENTS];\n-    /**\n-     * This flag is true if all m_amounts caches are empty. This is particularly\n-     * useful in places where MarkDirty is conditionally called and the\n-     * condition can be expensive and thus can be skipped if the flag is true.\n-     * See MarkDestinationsDirty.\n-     */\n-    mutable bool m_is_cache_empty{true};\n-    mutable bool fChangeCached;\n-    mutable bool fInMempool;\n-    mutable CAmount nChangeCached;\n-\n-    CWalletTx(const CWallet* wallet, CTransactionRef arg)\n-        : pwallet(wallet),\n-          tx(std::move(arg))\n-    {\n-        Init();\n-    }\n-\n-    void Init()\n-    {\n-        mapValue.clear();\n-        vOrderForm.clear();\n-        fTimeReceivedIsTxTime = false;\n-        nTimeReceived = 0;\n-        nTimeSmart = 0;\n-        fFromMe = false;\n-        fChangeCached = false;\n-        fInMempool = false;\n-        nChangeCached = 0;\n-        nOrderPos = -1;\n-        m_confirm = Confirmation{};\n-    }\n-\n-    CTransactionRef tx;\n-\n-    /** New transactions start as UNCONFIRMED. At BlockConnected,\n-     * they will transition to CONFIRMED. In case of reorg, at BlockDisconnected,\n-     * they roll back to UNCONFIRMED. If we detect a conflicting transaction at\n-     * block connection, we update conflicted tx and its dependencies as CONFLICTED.\n-     * If tx isn't confirmed and outside of mempool, the user may switch it to ABANDONED\n-     * by using the abandontransaction call. This last status may be override by a CONFLICTED\n-     * or CONFIRMED transition.\n-     */\n-    enum Status {\n-        UNCONFIRMED,\n-        CONFIRMED,\n-        CONFLICTED,\n-        ABANDONED\n-    };\n-\n-    /** Confirmation includes tx status and a triplet of {block height/block hash/tx index in block}\n-     * at which tx has been confirmed. All three are set to 0 if tx is unconfirmed or abandoned.\n-     * Meaning of these fields changes with CONFLICTED state where they instead point to block hash\n-     * and block height of the deepest conflicting tx.\n-     */\n-    struct Confirmation {\n-        Status status;\n-        int block_height;\n-        uint256 hashBlock;\n-        int nIndex;\n-        Confirmation(Status s = UNCONFIRMED, int b = 0, uint256 h = uint256(), int i = 0) : status(s), block_height(b), hashBlock(h), nIndex(i) {}\n-    };\n-\n-    Confirmation m_confirm;\n-\n-    template<typename Stream>\n-    void Serialize(Stream& s) const\n-    {\n-        mapValue_t mapValueCopy = mapValue;\n-\n-        mapValueCopy[\"fromaccount\"] = \"\";\n-        WriteOrderPos(nOrderPos, mapValueCopy);\n-        if (nTimeSmart) {\n-            mapValueCopy[\"timesmart\"] = strprintf(\"%u\", nTimeSmart);\n-        }\n-\n-        std::vector<char> dummy_vector1; //!< Used to be vMerkleBranch\n-        std::vector<char> dummy_vector2; //!< Used to be vtxPrev\n-        bool dummy_bool = false; //!< Used to be fSpent\n-        uint256 serializedHash = isAbandoned() ? ABANDON_HASH : m_confirm.hashBlock;\n-        int serializedIndex = isAbandoned() || isConflicted() ? -1 : m_confirm.nIndex;\n-        s << tx << serializedHash << dummy_vector1 << serializedIndex << dummy_vector2 << mapValueCopy << vOrderForm << fTimeReceivedIsTxTime << nTimeReceived << fFromMe << dummy_bool;\n-    }\n-\n-    template<typename Stream>\n-    void Unserialize(Stream& s)\n-    {\n-        Init();\n-\n-        std::vector<uint256> dummy_vector1; //!< Used to be vMerkleBranch\n-        std::vector<CMerkleTx> dummy_vector2; //!< Used to be vtxPrev\n-        bool dummy_bool; //! Used to be fSpent\n-        int serializedIndex;\n-        s >> tx >> m_confirm.hashBlock >> dummy_vector1 >> serializedIndex >> dummy_vector2 >> mapValue >> vOrderForm >> fTimeReceivedIsTxTime >> nTimeReceived >> fFromMe >> dummy_bool;\n-\n-        /* At serialization/deserialization, an nIndex == -1 means that hashBlock refers to\n-         * the earliest block in the chain we know this or any in-wallet ancestor conflicts\n-         * with. If nIndex == -1 and hashBlock is ABANDON_HASH, it means transaction is abandoned.\n-         * In same context, an nIndex >= 0 refers to a confirmed transaction (if hashBlock set) or\n-         * unconfirmed one. Older clients interpret nIndex == -1 as unconfirmed for backward\n-         * compatibility (pre-commit 9ac63d6).\n-         */\n-        if (serializedIndex == -1 && m_confirm.hashBlock == ABANDON_HASH) {\n-            setAbandoned();\n-        } else if (serializedIndex == -1) {\n-            setConflicted();\n-        } else if (!m_confirm.hashBlock.IsNull()) {\n-            m_confirm.nIndex = serializedIndex;\n-            setConfirmed();\n-        }\n-\n-        ReadOrderPos(nOrderPos, mapValue);\n-        nTimeSmart = mapValue.count(\"timesmart\") ? (unsigned int)atoi64(mapValue[\"timesmart\"]) : 0;\n-\n-        mapValue.erase(\"fromaccount\");\n-        mapValue.erase(\"spent\");\n-        mapValue.erase(\"n\");\n-        mapValue.erase(\"timesmart\");\n-    }\n-\n-    void SetTx(CTransactionRef arg)\n-    {\n-        tx = std::move(arg);\n-    }\n-\n-    //! make sure balances are recalculated\n-    void MarkDirty()\n-    {\n-        m_amounts[DEBIT].Reset();\n-        m_amounts[CREDIT].Reset();\n-        m_amounts[IMMATURE_CREDIT].Reset();\n-        m_amounts[AVAILABLE_CREDIT].Reset();\n-        fChangeCached = false;\n-        m_is_cache_empty = true;\n-    }\n-\n-    //! filter decides which addresses will count towards the debit\n-    CAmount GetDebit(const isminefilter& filter) const;\n-    CAmount GetCredit(const isminefilter& filter) const;\n-    CAmount GetImmatureCredit(bool fUseCache = true) const;\n-    // TODO: Remove \"NO_THREAD_SAFETY_ANALYSIS\" and replace it with the correct\n-    // annotation \"EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\". The\n-    // annotation \"NO_THREAD_SAFETY_ANALYSIS\" was temporarily added to avoid\n-    // having to resolve the issue of member access into incomplete type CWallet.\n-    CAmount GetAvailableCredit(bool fUseCache = true, const isminefilter& filter = ISMINE_SPENDABLE) const NO_THREAD_SAFETY_ANALYSIS;\n-    CAmount GetImmatureWatchOnlyCredit(const bool fUseCache = true) const;\n-    CAmount GetChange() const;\n-\n-    /** Get the marginal bytes if spending the specified output from this transaction */\n-    int GetSpendSize(unsigned int out, bool use_max_sig = false) const\n-    {\n-        return CalculateMaximumSignedInputSize(tx->vout[out], pwallet, use_max_sig);\n-    }\n-\n-    void GetAmounts(std::list<COutputEntry>& listReceived,\n-                    std::list<COutputEntry>& listSent, CAmount& nFee, const isminefilter& filter) const;\n-\n-    bool IsFromMe(const isminefilter& filter) const\n-    {\n-        return (GetDebit(filter) > 0);\n-    }\n-\n-    /** True if only scriptSigs are different */\n-    bool IsEquivalentTo(const CWalletTx& tx) const;\n-\n-    bool InMempool() const;\n-    bool IsTrusted() const;\n-\n-    int64_t GetTxTime() const;\n-\n-    /** Pass this transaction to node for mempool insertion and relay to peers if flag set to true */\n-    bool SubmitMemoryPoolAndRelay(std::string& err_string, bool relay);\n-\n-    // TODO: Remove \"NO_THREAD_SAFETY_ANALYSIS\" and replace it with the correct\n-    // annotation \"EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\". The annotation\n-    // \"NO_THREAD_SAFETY_ANALYSIS\" was temporarily added to avoid having to\n-    // resolve the issue of member access into incomplete type CWallet. Note\n-    // that we still have the runtime check \"AssertLockHeld(pwallet->cs_wallet)\"\n-    // in place.\n-    std::set<uint256> GetConflicts() const NO_THREAD_SAFETY_ANALYSIS;\n-\n-    /**\n-     * Return depth of transaction in blockchain:\n-     * <0  : conflicts with a transaction this deep in the blockchain\n-     *  0  : in memory pool, waiting to be included in a block\n-     * >=1 : this many blocks deep in the main chain\n-     */\n-    // TODO: Remove \"NO_THREAD_SAFETY_ANALYSIS\" and replace it with the correct\n-    // annotation \"EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\". The annotation\n-    // \"NO_THREAD_SAFETY_ANALYSIS\" was temporarily added to avoid having to\n-    // resolve the issue of member access into incomplete type CWallet. Note\n-    // that we still have the runtime check \"AssertLockHeld(pwallet->cs_wallet)\"\n-    // in place.\n-    int GetDepthInMainChain() const NO_THREAD_SAFETY_ANALYSIS;\n-    bool IsInMainChain() const { return GetDepthInMainChain() > 0; }\n-\n-    /**\n-     * @return number of blocks to maturity for this transaction:\n-     *  0 : is not a coinbase transaction, or is a mature coinbase transaction\n-     * >0 : is a coinbase transaction which matures in this many blocks\n-     */\n-    int GetBlocksToMaturity() const;\n-    bool isAbandoned() const { return m_confirm.status == CWalletTx::ABANDONED; }\n-    void setAbandoned()\n-    {\n-        m_confirm.status = CWalletTx::ABANDONED;\n-        m_confirm.hashBlock = uint256();\n-        m_confirm.block_height = 0;\n-        m_confirm.nIndex = 0;\n-    }\n-    bool isConflicted() const { return m_confirm.status == CWalletTx::CONFLICTED; }\n-    void setConflicted() { m_confirm.status = CWalletTx::CONFLICTED; }\n-    bool isUnconfirmed() const { return m_confirm.status == CWalletTx::UNCONFIRMED; }\n-    void setUnconfirmed() { m_confirm.status = CWalletTx::UNCONFIRMED; }\n-    bool isConfirmed() const { return m_confirm.status == CWalletTx::CONFIRMED; }\n-    void setConfirmed() { m_confirm.status = CWalletTx::CONFIRMED; }\n-    const uint256& GetHash() const { return tx->GetHash(); }\n-    bool IsCoinBase() const { return tx->IsCoinBase(); }\n-    bool IsImmatureCoinBase() const;\n-\n-    // Disable copying of CWalletTx objects to prevent bugs where instances get\n-    // copied in and out of the mapWallet map, and fields are updated in the\n-    // wrong copy.\n-    CWalletTx(CWalletTx const &) = delete;\n-    void operator=(CWalletTx const &x) = delete;\n-};\n-\n-#endif // BITCOIN_WALLET_TRANSACTION_H"
      },
      {
        "sha": "10cc65a38e82edaaf9505214a5c260b244951166",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 1508,
        "deletions": 65,
        "changes": 1573,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6f340cbb76a8221fc03c726328ca79a37e7be2d6/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6f340cbb76a8221fc03c726328ca79a37e7be2d6/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=6f340cbb76a8221fc03c726328ca79a37e7be2d6",
        "patch": "@@ -53,6 +53,8 @@ const std::map<uint64_t,std::string> WALLET_FLAG_CAVEATS{\n     },\n };\n \n+static constexpr size_t OUTPUT_GROUP_MAX_ENTRIES{100};\n+\n RecursiveMutex cs_wallets;\n static std::vector<std::shared_ptr<CWallet>> vpwallets GUARDED_BY(cs_wallets);\n static std::list<LoadWalletFn> g_load_wallet_fns GUARDED_BY(cs_wallets);\n@@ -349,6 +351,11 @@ std::shared_ptr<CWallet> CreateWallet(interfaces::Chain& chain, const std::strin\n  * @{\n  */\n \n+std::string COutput::ToString() const\n+{\n+    return strprintf(\"COutput(%s, %d, %d) [%s]\", tx->GetHash().ToString(), i, nDepth, FormatMoney(tx->tx->vout[i].nValue));\n+}\n+\n const CWalletTx* CWallet::GetWalletTx(const uint256& hash) const\n {\n     AssertLockHeld(cs_wallet);\n@@ -1276,6 +1283,20 @@ void CWallet::BlockUntilSyncedToCurrentChain() const {\n     chain().waitForNotificationsIfTipChanged(last_block_hash);\n }\n \n+\n+isminetype CWallet::IsMine(const CTxIn &txin) const\n+{\n+    AssertLockHeld(cs_wallet);\n+    std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n+    if (mi != mapWallet.end())\n+    {\n+        const CWalletTx& prev = (*mi).second;\n+        if (txin.prevout.n < prev.tx->vout.size())\n+            return IsMine(prev.tx->vout[txin.prevout.n]);\n+    }\n+    return ISMINE_NO;\n+}\n+\n // Note that this function doesn't distinguish between a 0-valued input,\n // and a not-\"is mine\" (according to the filter) input.\n CAmount CWallet::GetDebit(const CTxIn &txin, const isminefilter& filter) const\n@@ -1316,6 +1337,49 @@ isminetype CWallet::IsMine(const CScript& script) const\n     return result;\n }\n \n+CAmount CWallet::GetCredit(const CTxOut& txout, const isminefilter& filter) const\n+{\n+    if (!MoneyRange(txout.nValue))\n+        throw std::runtime_error(std::string(__func__) + \": value out of range\");\n+    LOCK(cs_wallet);\n+    return ((IsMine(txout) & filter) ? txout.nValue : 0);\n+}\n+\n+bool CWallet::IsChange(const CTxOut& txout) const\n+{\n+    return IsChange(txout.scriptPubKey);\n+}\n+\n+bool CWallet::IsChange(const CScript& script) const\n+{\n+    // TODO: fix handling of 'change' outputs. The assumption is that any\n+    // payment to a script that is ours, but is not in the address book\n+    // is change. That assumption is likely to break when we implement multisignature\n+    // wallets that return change back into a multi-signature-protected address;\n+    // a better way of identifying which outputs are 'the send' and which are\n+    // 'the change' will need to be implemented (maybe extend CWalletTx to remember\n+    // which output, if any, was change).\n+    AssertLockHeld(cs_wallet);\n+    if (IsMine(script))\n+    {\n+        CTxDestination address;\n+        if (!ExtractDestination(script, address))\n+            return true;\n+        if (!FindAddressBookEntry(address)) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+CAmount CWallet::GetChange(const CTxOut& txout) const\n+{\n+    AssertLockHeld(cs_wallet);\n+    if (!MoneyRange(txout.nValue))\n+        throw std::runtime_error(std::string(__func__) + \": value out of range\");\n+    return (IsChange(txout) ? txout.nValue : 0);\n+}\n+\n bool CWallet::IsMine(const CTransaction& tx) const\n {\n     AssertLockHeld(cs_wallet);\n@@ -1342,6 +1406,52 @@ CAmount CWallet::GetDebit(const CTransaction& tx, const isminefilter& filter) co\n     return nDebit;\n }\n \n+bool CWallet::IsAllFromMe(const CTransaction& tx, const isminefilter& filter) const\n+{\n+    LOCK(cs_wallet);\n+\n+    for (const CTxIn& txin : tx.vin)\n+    {\n+        auto mi = mapWallet.find(txin.prevout.hash);\n+        if (mi == mapWallet.end())\n+            return false; // any unknown inputs can't be from us\n+\n+        const CWalletTx& prev = (*mi).second;\n+\n+        if (txin.prevout.n >= prev.tx->vout.size())\n+            return false; // invalid input!\n+\n+        if (!(IsMine(prev.tx->vout[txin.prevout.n]) & filter))\n+            return false;\n+    }\n+    return true;\n+}\n+\n+CAmount CWallet::GetCredit(const CTransaction& tx, const isminefilter& filter) const\n+{\n+    CAmount nCredit = 0;\n+    for (const CTxOut& txout : tx.vout)\n+    {\n+        nCredit += GetCredit(txout, filter);\n+        if (!MoneyRange(nCredit))\n+            throw std::runtime_error(std::string(__func__) + \": value out of range\");\n+    }\n+    return nCredit;\n+}\n+\n+CAmount CWallet::GetChange(const CTransaction& tx) const\n+{\n+    LOCK(cs_wallet);\n+    CAmount nChange = 0;\n+    for (const CTxOut& txout : tx.vout)\n+    {\n+        nChange += GetChange(txout);\n+        if (!MoneyRange(nChange))\n+            throw std::runtime_error(std::string(__func__) + \": value out of range\");\n+    }\n+    return nChange;\n+}\n+\n bool CWallet::IsHDEnabled() const\n {\n     // All Active ScriptPubKeyMans must be HD for this to be true\n@@ -1421,6 +1531,12 @@ bool CWallet::AddWalletFlags(uint64_t flags)\n     return LoadWalletFlags(flags);\n }\n \n+int64_t CWalletTx::GetTxTime() const\n+{\n+    int64_t n = nTimeSmart;\n+    return n ? n : nTimeReceived;\n+}\n+\n // Helper for producing a max-sized low-S low-R signature (eg 71 bytes)\n // or a max-sized low-S signature (e.g. 72 bytes) if use_max_sig is true\n bool CWallet::DummySignInput(CTxIn &tx_in, const CTxOut &txout, bool use_max_sig) const\n@@ -1511,6 +1627,100 @@ bool CWallet::ImportScriptPubKeys(const std::string& label, const std::set<CScri\n     return true;\n }\n \n+TxSize CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, bool use_max_sig)\n+{\n+    std::vector<CTxOut> txouts;\n+    for (const CTxIn& input : tx.vin) {\n+        const auto mi = wallet->mapWallet.find(input.prevout.hash);\n+        // Can not estimate size without knowing the input details\n+        if (mi == wallet->mapWallet.end()) {\n+            return TxSize{-1, -1};\n+        }\n+        assert(input.prevout.n < mi->second.tx->vout.size());\n+        txouts.emplace_back(mi->second.tx->vout[input.prevout.n]);\n+    }\n+    return CalculateMaximumSignedTxSize(tx, wallet, txouts, use_max_sig);\n+}\n+\n+// txouts needs to be in the order of tx.vin\n+TxSize CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, const std::vector<CTxOut>& txouts, bool use_max_sig)\n+{\n+    CMutableTransaction txNew(tx);\n+    if (!wallet->DummySignTx(txNew, txouts, use_max_sig)) {\n+        return TxSize{-1, -1};\n+    }\n+    CTransaction ctx(txNew);\n+    int64_t vsize = GetVirtualTransactionSize(ctx);\n+    int64_t weight = GetTransactionWeight(ctx);\n+    return TxSize{vsize, weight};\n+}\n+\n+int CalculateMaximumSignedInputSize(const CTxOut& txout, const CWallet* wallet, bool use_max_sig)\n+{\n+    CMutableTransaction txn;\n+    txn.vin.push_back(CTxIn(COutPoint()));\n+    if (!wallet->DummySignInput(txn.vin[0], txout, use_max_sig)) {\n+        return -1;\n+    }\n+    return GetVirtualTransactionInputSize(txn.vin[0]);\n+}\n+\n+void CWalletTx::GetAmounts(std::list<COutputEntry>& listReceived,\n+                           std::list<COutputEntry>& listSent, CAmount& nFee, const isminefilter& filter) const\n+{\n+    nFee = 0;\n+    listReceived.clear();\n+    listSent.clear();\n+\n+    // Compute fee:\n+    CAmount nDebit = GetDebit(filter);\n+    if (nDebit > 0) // debit>0 means we signed/sent this transaction\n+    {\n+        CAmount nValueOut = tx->GetValueOut();\n+        nFee = nDebit - nValueOut;\n+    }\n+\n+    LOCK(pwallet->cs_wallet);\n+    // Sent/received.\n+    for (unsigned int i = 0; i < tx->vout.size(); ++i)\n+    {\n+        const CTxOut& txout = tx->vout[i];\n+        isminetype fIsMine = pwallet->IsMine(txout);\n+        // Only need to handle txouts if AT LEAST one of these is true:\n+        //   1) they debit from us (sent)\n+        //   2) the output is to us (received)\n+        if (nDebit > 0)\n+        {\n+            // Don't report 'change' txouts\n+            if (pwallet->IsChange(txout))\n+                continue;\n+        }\n+        else if (!(fIsMine & filter))\n+            continue;\n+\n+        // In either case, we need to get the destination address\n+        CTxDestination address;\n+\n+        if (!ExtractDestination(txout.scriptPubKey, address) && !txout.scriptPubKey.IsUnspendable())\n+        {\n+            pwallet->WalletLogPrintf(\"CWalletTx::GetAmounts: Unknown transaction type found, txid %s\\n\",\n+                                    this->GetHash().ToString());\n+            address = CNoDestination();\n+        }\n+\n+        COutputEntry output = {address, txout.nValue, (int)i};\n+\n+        // If we are debited by the transaction, add the output as a \"sent\" entry\n+        if (nDebit > 0)\n+            listSent.push_back(output);\n+\n+        // If we are receiving the output, add it as a \"received\" entry\n+        if (fIsMine & filter)\n+            listReceived.push_back(output);\n+    }\n+\n+}\n+\n /**\n  * Scan active chain for relevant transactions after importing keys. This should\n  * be called whenever new keys are added to the wallet, with the oldest key\n@@ -1733,6 +1943,165 @@ std::set<uint256> CWalletTx::GetConflicts() const\n     return result;\n }\n \n+CAmount CWalletTx::GetCachableAmount(AmountType type, const isminefilter& filter, bool recalculate) const\n+{\n+    auto& amount = m_amounts[type];\n+    if (recalculate || !amount.m_cached[filter]) {\n+        amount.Set(filter, type == DEBIT ? pwallet->GetDebit(*tx, filter) : pwallet->GetCredit(*tx, filter));\n+        m_is_cache_empty = false;\n+    }\n+    return amount.m_value[filter];\n+}\n+\n+CAmount CWalletTx::GetDebit(const isminefilter& filter) const\n+{\n+    if (tx->vin.empty())\n+        return 0;\n+\n+    CAmount debit = 0;\n+    if (filter & ISMINE_SPENDABLE) {\n+        debit += GetCachableAmount(DEBIT, ISMINE_SPENDABLE);\n+    }\n+    if (filter & ISMINE_WATCH_ONLY) {\n+        debit += GetCachableAmount(DEBIT, ISMINE_WATCH_ONLY);\n+    }\n+    return debit;\n+}\n+\n+CAmount CWalletTx::GetCredit(const isminefilter& filter) const\n+{\n+    // Must wait until coinbase is safely deep enough in the chain before valuing it\n+    if (IsImmatureCoinBase())\n+        return 0;\n+\n+    CAmount credit = 0;\n+    if (filter & ISMINE_SPENDABLE) {\n+        // GetBalance can assume transactions in mapWallet won't change\n+        credit += GetCachableAmount(CREDIT, ISMINE_SPENDABLE);\n+    }\n+    if (filter & ISMINE_WATCH_ONLY) {\n+        credit += GetCachableAmount(CREDIT, ISMINE_WATCH_ONLY);\n+    }\n+    return credit;\n+}\n+\n+CAmount CWalletTx::GetImmatureCredit(bool fUseCache) const\n+{\n+    if (IsImmatureCoinBase() && IsInMainChain()) {\n+        return GetCachableAmount(IMMATURE_CREDIT, ISMINE_SPENDABLE, !fUseCache);\n+    }\n+\n+    return 0;\n+}\n+\n+CAmount CWalletTx::GetAvailableCredit(bool fUseCache, const isminefilter& filter) const\n+{\n+    if (pwallet == nullptr)\n+        return 0;\n+\n+    // Avoid caching ismine for NO or ALL cases (could remove this check and simplify in the future).\n+    bool allow_cache = (filter & ISMINE_ALL) && (filter & ISMINE_ALL) != ISMINE_ALL;\n+\n+    // Must wait until coinbase is safely deep enough in the chain before valuing it\n+    if (IsImmatureCoinBase())\n+        return 0;\n+\n+    if (fUseCache && allow_cache && m_amounts[AVAILABLE_CREDIT].m_cached[filter]) {\n+        return m_amounts[AVAILABLE_CREDIT].m_value[filter];\n+    }\n+\n+    bool allow_used_addresses = (filter & ISMINE_USED) || !pwallet->IsWalletFlagSet(WALLET_FLAG_AVOID_REUSE);\n+    CAmount nCredit = 0;\n+    uint256 hashTx = GetHash();\n+    for (unsigned int i = 0; i < tx->vout.size(); i++)\n+    {\n+        if (!pwallet->IsSpent(hashTx, i) && (allow_used_addresses || !pwallet->IsSpentKey(hashTx, i))) {\n+            const CTxOut &txout = tx->vout[i];\n+            nCredit += pwallet->GetCredit(txout, filter);\n+            if (!MoneyRange(nCredit))\n+                throw std::runtime_error(std::string(__func__) + \" : value out of range\");\n+        }\n+    }\n+\n+    if (allow_cache) {\n+        m_amounts[AVAILABLE_CREDIT].Set(filter, nCredit);\n+        m_is_cache_empty = false;\n+    }\n+\n+    return nCredit;\n+}\n+\n+CAmount CWalletTx::GetImmatureWatchOnlyCredit(const bool fUseCache) const\n+{\n+    if (IsImmatureCoinBase() && IsInMainChain()) {\n+        return GetCachableAmount(IMMATURE_CREDIT, ISMINE_WATCH_ONLY, !fUseCache);\n+    }\n+\n+    return 0;\n+}\n+\n+CAmount CWalletTx::GetChange() const\n+{\n+    if (fChangeCached)\n+        return nChangeCached;\n+    nChangeCached = pwallet->GetChange(*tx);\n+    fChangeCached = true;\n+    return nChangeCached;\n+}\n+\n+bool CWalletTx::InMempool() const\n+{\n+    return fInMempool;\n+}\n+\n+bool CWalletTx::IsTrusted() const\n+{\n+    std::set<uint256> trusted_parents;\n+    LOCK(pwallet->cs_wallet);\n+    return pwallet->IsTrusted(*this, trusted_parents);\n+}\n+\n+bool CWallet::IsTrusted(const CWalletTx& wtx, std::set<uint256>& trusted_parents) const\n+{\n+    AssertLockHeld(cs_wallet);\n+    // Quick answer in most cases\n+    if (!chain().checkFinalTx(*wtx.tx)) return false;\n+    int nDepth = wtx.GetDepthInMainChain();\n+    if (nDepth >= 1) return true;\n+    if (nDepth < 0) return false;\n+    // using wtx's cached debit\n+    if (!m_spend_zero_conf_change || !wtx.IsFromMe(ISMINE_ALL)) return false;\n+\n+    // Don't trust unconfirmed transactions from us unless they are in the mempool.\n+    if (!wtx.InMempool()) return false;\n+\n+    // Trusted if all inputs are from us and are in the mempool:\n+    for (const CTxIn& txin : wtx.tx->vin)\n+    {\n+        // Transactions not sent by us: not trusted\n+        const CWalletTx* parent = GetWalletTx(txin.prevout.hash);\n+        if (parent == nullptr) return false;\n+        const CTxOut& parentOut = parent->tx->vout[txin.prevout.n];\n+        // Check that this specific input being spent is trusted\n+        if (IsMine(parentOut) != ISMINE_SPENDABLE) return false;\n+        // If we've already trusted this parent, continue\n+        if (trusted_parents.count(parent->GetHash())) continue;\n+        // Recurse to check that the parent is also trusted\n+        if (!IsTrusted(*parent, trusted_parents)) return false;\n+        trusted_parents.insert(parent->GetHash());\n+    }\n+    return true;\n+}\n+\n+bool CWalletTx::IsEquivalentTo(const CWalletTx& _tx) const\n+{\n+        CMutableTransaction tx1 {*this->tx};\n+        CMutableTransaction tx2 {*_tx.tx};\n+        for (auto& txin : tx1.vin) txin.scriptSig = CScript();\n+        for (auto& txin : tx2.vin) txin.scriptSig = CScript();\n+        return CTransaction(tx1) == CTransaction(tx2);\n+}\n+\n // Rebroadcast transactions from the wallet. We do this on a random timer\n // to slightly obfuscate which transactions come from our wallet.\n //\n@@ -1793,101 +2162,601 @@ void MaybeResendWalletTxs()\n  * @{\n  */\n \n-bool CWallet::SignTransaction(CMutableTransaction& tx) const\n-{\n-    AssertLockHeld(cs_wallet);\n \n-    // Build coins map\n-    std::map<COutPoint, Coin> coins;\n-    for (auto& input : tx.vin) {\n-        std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(input.prevout.hash);\n-        if(mi == mapWallet.end() || input.prevout.n >= mi->second.tx->vout.size()) {\n-            return false;\n+CWallet::Balance CWallet::GetBalance(const int min_depth, bool avoid_reuse) const\n+{\n+    Balance ret;\n+    isminefilter reuse_filter = avoid_reuse ? ISMINE_NO : ISMINE_USED;\n+    {\n+        LOCK(cs_wallet);\n+        std::set<uint256> trusted_parents;\n+        for (const auto& entry : mapWallet)\n+        {\n+            const CWalletTx& wtx = entry.second;\n+            const bool is_trusted{IsTrusted(wtx, trusted_parents)};\n+            const int tx_depth{wtx.GetDepthInMainChain()};\n+            const CAmount tx_credit_mine{wtx.GetAvailableCredit(/* fUseCache */ true, ISMINE_SPENDABLE | reuse_filter)};\n+            const CAmount tx_credit_watchonly{wtx.GetAvailableCredit(/* fUseCache */ true, ISMINE_WATCH_ONLY | reuse_filter)};\n+            if (is_trusted && tx_depth >= min_depth) {\n+                ret.m_mine_trusted += tx_credit_mine;\n+                ret.m_watchonly_trusted += tx_credit_watchonly;\n+            }\n+            if (!is_trusted && tx_depth == 0 && wtx.InMempool()) {\n+                ret.m_mine_untrusted_pending += tx_credit_mine;\n+                ret.m_watchonly_untrusted_pending += tx_credit_watchonly;\n+            }\n+            ret.m_mine_immature += wtx.GetImmatureCredit();\n+            ret.m_watchonly_immature += wtx.GetImmatureWatchOnlyCredit();\n         }\n-        const CWalletTx& wtx = mi->second;\n-        coins[input.prevout] = Coin(wtx.tx->vout[input.prevout.n], wtx.m_confirm.block_height, wtx.IsCoinBase());\n     }\n-    std::map<int, std::string> input_errors;\n-    return SignTransaction(tx, coins, SIGHASH_ALL, input_errors);\n+    return ret;\n }\n \n-bool CWallet::SignTransaction(CMutableTransaction& tx, const std::map<COutPoint, Coin>& coins, int sighash, std::map<int, std::string>& input_errors) const\n+CAmount CWallet::GetAvailableBalance(const CCoinControl* coinControl) const\n {\n-    // Try to sign with all ScriptPubKeyMans\n-    for (ScriptPubKeyMan* spk_man : GetAllScriptPubKeyMans()) {\n-        // spk_man->SignTransaction will return true if the transaction is complete,\n-        // so we can exit early and return true if that happens\n-        if (spk_man->SignTransaction(tx, coins, sighash, input_errors)) {\n-            return true;\n+    LOCK(cs_wallet);\n+\n+    CAmount balance = 0;\n+    std::vector<COutput> vCoins;\n+    AvailableCoins(vCoins, coinControl);\n+    for (const COutput& out : vCoins) {\n+        if (out.fSpendable) {\n+            balance += out.tx->tx->vout[out.i].nValue;\n         }\n     }\n-\n-    // At this point, one input was not fully signed otherwise we would have exited already\n-    return false;\n+    return balance;\n }\n \n-TransactionError CWallet::FillPSBT(PartiallySignedTransaction& psbtx, bool& complete, int sighash_type, bool sign, bool bip32derivs, size_t * n_signed) const\n+void CWallet::AvailableCoins(std::vector<COutput>& vCoins, const CCoinControl* coinControl, const CAmount& nMinimumAmount, const CAmount& nMaximumAmount, const CAmount& nMinimumSumAmount, const uint64_t nMaximumCount) const\n {\n-    if (n_signed) {\n-        *n_signed = 0;\n-    }\n-    LOCK(cs_wallet);\n-    // Get all of the previous transactions\n-    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n-        const CTxIn& txin = psbtx.tx->vin[i];\n-        PSBTInput& input = psbtx.inputs.at(i);\n+    AssertLockHeld(cs_wallet);\n \n-        if (PSBTInputSigned(input)) {\n+    vCoins.clear();\n+    CAmount nTotal = 0;\n+    // Either the WALLET_FLAG_AVOID_REUSE flag is not set (in which case we always allow), or we default to avoiding, and only in the case where\n+    // a coin control object is provided, and has the avoid address reuse flag set to false, do we allow already used addresses\n+    bool allow_used_addresses = !IsWalletFlagSet(WALLET_FLAG_AVOID_REUSE) || (coinControl && !coinControl->m_avoid_address_reuse);\n+    const int min_depth = {coinControl ? coinControl->m_min_depth : DEFAULT_MIN_DEPTH};\n+    const int max_depth = {coinControl ? coinControl->m_max_depth : DEFAULT_MAX_DEPTH};\n+    const bool only_safe = {coinControl ? !coinControl->m_include_unsafe_inputs : true};\n+\n+    std::set<uint256> trusted_parents;\n+    for (const auto& entry : mapWallet)\n+    {\n+        const uint256& wtxid = entry.first;\n+        const CWalletTx& wtx = entry.second;\n+\n+        if (!chain().checkFinalTx(*wtx.tx)) {\n             continue;\n         }\n \n-        // If we have no utxo, grab it from the wallet.\n-        if (!input.non_witness_utxo) {\n-            const uint256& txhash = txin.prevout.hash;\n-            const auto it = mapWallet.find(txhash);\n-            if (it != mapWallet.end()) {\n-                const CWalletTx& wtx = it->second;\n-                // We only need the non_witness_utxo, which is a superset of the witness_utxo.\n-                //   The signing code will switch to the smaller witness_utxo if this is ok.\n-                input.non_witness_utxo = wtx.tx;\n-            }\n+        if (wtx.IsImmatureCoinBase())\n+            continue;\n+\n+        int nDepth = wtx.GetDepthInMainChain();\n+        if (nDepth < 0)\n+            continue;\n+\n+        // We should not consider coins which aren't at least in our mempool\n+        // It's possible for these to be conflicted via ancestors which we may never be able to detect\n+        if (nDepth == 0 && !wtx.InMempool())\n+            continue;\n+\n+        bool safeTx = IsTrusted(wtx, trusted_parents);\n+\n+        // We should not consider coins from transactions that are replacing\n+        // other transactions.\n+        //\n+        // Example: There is a transaction A which is replaced by bumpfee\n+        // transaction B. In this case, we want to prevent creation of\n+        // a transaction B' which spends an output of B.\n+        //\n+        // Reason: If transaction A were initially confirmed, transactions B\n+        // and B' would no longer be valid, so the user would have to create\n+        // a new transaction C to replace B'. However, in the case of a\n+        // one-block reorg, transactions B' and C might BOTH be accepted,\n+        // when the user only wanted one of them. Specifically, there could\n+        // be a 1-block reorg away from the chain where transactions A and C\n+        // were accepted to another chain where B, B', and C were all\n+        // accepted.\n+        if (nDepth == 0 && wtx.mapValue.count(\"replaces_txid\")) {\n+            safeTx = false;\n         }\n-    }\n \n-    // Fill in information from ScriptPubKeyMans\n-    for (ScriptPubKeyMan* spk_man : GetAllScriptPubKeyMans()) {\n-        int n_signed_this_spkm = 0;\n-        TransactionError res = spk_man->FillPSBT(psbtx, sighash_type, sign, bip32derivs, &n_signed_this_spkm);\n-        if (res != TransactionError::OK) {\n-            return res;\n+        // Similarly, we should not consider coins from transactions that\n+        // have been replaced. In the example above, we would want to prevent\n+        // creation of a transaction A' spending an output of A, because if\n+        // transaction B were initially confirmed, conflicting with A and\n+        // A', we wouldn't want to the user to create a transaction D\n+        // intending to replace A', but potentially resulting in a scenario\n+        // where A, A', and D could all be accepted (instead of just B and\n+        // D, or just A and A' like the user would want).\n+        if (nDepth == 0 && wtx.mapValue.count(\"replaced_by_txid\")) {\n+            safeTx = false;\n         }\n \n-        if (n_signed) {\n-            (*n_signed) += n_signed_this_spkm;\n+        if (only_safe && !safeTx) {\n+            continue;\n         }\n-    }\n \n-    // Complete if every input is now signed\n-    complete = true;\n-    for (const auto& input : psbtx.inputs) {\n-        complete &= PSBTInputSigned(input);\n-    }\n+        if (nDepth < min_depth || nDepth > max_depth) {\n+            continue;\n+        }\n \n-    return TransactionError::OK;\n-}\n+        for (unsigned int i = 0; i < wtx.tx->vout.size(); i++) {\n+            // Only consider selected coins if add_inputs is false\n+            if (coinControl && !coinControl->m_add_inputs && !coinControl->IsSelected(COutPoint(entry.first, i))) {\n+                continue;\n+            }\n \n-SigningResult CWallet::SignMessage(const std::string& message, const PKHash& pkhash, std::string& str_sig) const\n-{\n-    SignatureData sigdata;\n-    CScript script_pub_key = GetScriptForDestination(pkhash);\n-    for (const auto& spk_man_pair : m_spk_managers) {\n+            if (wtx.tx->vout[i].nValue < nMinimumAmount || wtx.tx->vout[i].nValue > nMaximumAmount)\n+                continue;\n+\n+            if (coinControl && coinControl->HasSelected() && !coinControl->fAllowOtherInputs && !coinControl->IsSelected(COutPoint(entry.first, i)))\n+                continue;\n+\n+            if (IsLockedCoin(entry.first, i))\n+                continue;\n+\n+            if (IsSpent(wtxid, i))\n+                continue;\n+\n+            isminetype mine = IsMine(wtx.tx->vout[i]);\n+\n+            if (mine == ISMINE_NO) {\n+                continue;\n+            }\n+\n+            if (!allow_used_addresses && IsSpentKey(wtxid, i)) {\n+                continue;\n+            }\n+\n+            std::unique_ptr<SigningProvider> provider = GetSolvingProvider(wtx.tx->vout[i].scriptPubKey);\n+\n+            bool solvable = provider ? IsSolvable(*provider, wtx.tx->vout[i].scriptPubKey) : false;\n+            bool spendable = ((mine & ISMINE_SPENDABLE) != ISMINE_NO) || (((mine & ISMINE_WATCH_ONLY) != ISMINE_NO) && (coinControl && coinControl->fAllowWatchOnly && solvable));\n+\n+            vCoins.push_back(COutput(&wtx, i, nDepth, spendable, solvable, safeTx, (coinControl && coinControl->fAllowWatchOnly)));\n+\n+            // Checks the sum amount of all UTXO's.\n+            if (nMinimumSumAmount != MAX_MONEY) {\n+                nTotal += wtx.tx->vout[i].nValue;\n+\n+                if (nTotal >= nMinimumSumAmount) {\n+                    return;\n+                }\n+            }\n+\n+            // Checks the maximum number of UTXO's.\n+            if (nMaximumCount > 0 && vCoins.size() >= nMaximumCount) {\n+                return;\n+            }\n+        }\n+    }\n+}\n+\n+std::map<CTxDestination, std::vector<COutput>> CWallet::ListCoins() const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    std::map<CTxDestination, std::vector<COutput>> result;\n+    std::vector<COutput> availableCoins;\n+\n+    AvailableCoins(availableCoins);\n+\n+    for (const COutput& coin : availableCoins) {\n+        CTxDestination address;\n+        if ((coin.fSpendable || (IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) && coin.fSolvable)) &&\n+            ExtractDestination(FindNonChangeParentOutput(*coin.tx->tx, coin.i).scriptPubKey, address)) {\n+            result[address].emplace_back(std::move(coin));\n+        }\n+    }\n+\n+    std::vector<COutPoint> lockedCoins;\n+    ListLockedCoins(lockedCoins);\n+    // Include watch-only for LegacyScriptPubKeyMan wallets without private keys\n+    const bool include_watch_only = GetLegacyScriptPubKeyMan() && IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS);\n+    const isminetype is_mine_filter = include_watch_only ? ISMINE_WATCH_ONLY : ISMINE_SPENDABLE;\n+    for (const COutPoint& output : lockedCoins) {\n+        auto it = mapWallet.find(output.hash);\n+        if (it != mapWallet.end()) {\n+            int depth = it->second.GetDepthInMainChain();\n+            if (depth >= 0 && output.n < it->second.tx->vout.size() &&\n+                IsMine(it->second.tx->vout[output.n]) == is_mine_filter\n+            ) {\n+                CTxDestination address;\n+                if (ExtractDestination(FindNonChangeParentOutput(*it->second.tx, output.n).scriptPubKey, address)) {\n+                    result[address].emplace_back(\n+                        &it->second, output.n, depth, true /* spendable */, true /* solvable */, false /* safe */);\n+                }\n+            }\n+        }\n+    }\n+\n+    return result;\n+}\n+\n+const CTxOut& CWallet::FindNonChangeParentOutput(const CTransaction& tx, int output) const\n+{\n+    AssertLockHeld(cs_wallet);\n+    const CTransaction* ptx = &tx;\n+    int n = output;\n+    while (IsChange(ptx->vout[n]) && ptx->vin.size() > 0) {\n+        const COutPoint& prevout = ptx->vin[0].prevout;\n+        auto it = mapWallet.find(prevout.hash);\n+        if (it == mapWallet.end() || it->second.tx->vout.size() <= prevout.n ||\n+            !IsMine(it->second.tx->vout[prevout.n])) {\n+            break;\n+        }\n+        ptx = it->second.tx.get();\n+        n = prevout.n;\n+    }\n+    return ptx->vout[n];\n+}\n+\n+bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<COutput> coins,\n+                                 std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params) const\n+{\n+    setCoinsRet.clear();\n+    nValueRet = 0;\n+\n+    // Note that unlike KnapsackSolver, we do not include the fee for creating a change output as BnB will not create a change output.\n+    std::vector<OutputGroup> positive_groups = GroupOutputs(coins, coin_selection_params, eligibility_filter, true /* positive_only */);\n+    if (SelectCoinsBnB(positive_groups, nTargetValue, coin_selection_params.m_cost_of_change, setCoinsRet, nValueRet)) {\n+        return true;\n+    }\n+    // The knapsack solver has some legacy behavior where it will spend dust outputs. We retain this behavior, so don't filter for positive only here.\n+    std::vector<OutputGroup> all_groups = GroupOutputs(coins, coin_selection_params, eligibility_filter, false /* positive_only */);\n+    // While nTargetValue includes the transaction fees for non-input things, it does not include the fee for creating a change output.\n+    // So we need to include that for KnapsackSolver as well, as we are expecting to create a change output.\n+    return KnapsackSolver(nTargetValue + coin_selection_params.m_change_fee, all_groups, setCoinsRet, nValueRet);\n+}\n+\n+bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CCoinControl& coin_control, CoinSelectionParams& coin_selection_params) const\n+{\n+    std::vector<COutput> vCoins(vAvailableCoins);\n+    CAmount value_to_select = nTargetValue;\n+\n+    // coin control -> return all selected outputs (we want all selected to go into the transaction for sure)\n+    if (coin_control.HasSelected() && !coin_control.fAllowOtherInputs)\n+    {\n+        for (const COutput& out : vCoins)\n+        {\n+            if (!out.fSpendable)\n+                 continue;\n+            nValueRet += out.tx->tx->vout[out.i].nValue;\n+            setCoinsRet.insert(out.GetInputCoin());\n+        }\n+        return (nValueRet >= nTargetValue);\n+    }\n+\n+    // calculate value from preset inputs and store them\n+    std::set<CInputCoin> setPresetCoins;\n+    CAmount nValueFromPresetInputs = 0;\n+\n+    std::vector<COutPoint> vPresetInputs;\n+    coin_control.ListSelected(vPresetInputs);\n+    for (const COutPoint& outpoint : vPresetInputs)\n+    {\n+        std::map<uint256, CWalletTx>::const_iterator it = mapWallet.find(outpoint.hash);\n+        if (it != mapWallet.end())\n+        {\n+            const CWalletTx& wtx = it->second;\n+            // Clearly invalid input, fail\n+            if (wtx.tx->vout.size() <= outpoint.n) {\n+                return false;\n+            }\n+            // Just to calculate the marginal byte size\n+            CInputCoin coin(wtx.tx, outpoint.n, wtx.GetSpendSize(outpoint.n, false));\n+            nValueFromPresetInputs += coin.txout.nValue;\n+            if (coin.m_input_bytes <= 0) {\n+                return false; // Not solvable, can't estimate size for fee\n+            }\n+            coin.effective_value = coin.txout.nValue - coin_selection_params.m_effective_feerate.GetFee(coin.m_input_bytes);\n+            if (coin_selection_params.m_subtract_fee_outputs) {\n+                value_to_select -= coin.txout.nValue;\n+            } else {\n+                value_to_select -= coin.effective_value;\n+            }\n+            setPresetCoins.insert(coin);\n+        } else {\n+            return false; // TODO: Allow non-wallet inputs\n+        }\n+    }\n+\n+    // remove preset inputs from vCoins so that Coin Selection doesn't pick them.\n+    for (std::vector<COutput>::iterator it = vCoins.begin(); it != vCoins.end() && coin_control.HasSelected();)\n+    {\n+        if (setPresetCoins.count(it->GetInputCoin()))\n+            it = vCoins.erase(it);\n+        else\n+            ++it;\n+    }\n+\n+    unsigned int limit_ancestor_count = 0;\n+    unsigned int limit_descendant_count = 0;\n+    chain().getPackageLimits(limit_ancestor_count, limit_descendant_count);\n+    const size_t max_ancestors = (size_t)std::max<int64_t>(1, limit_ancestor_count);\n+    const size_t max_descendants = (size_t)std::max<int64_t>(1, limit_descendant_count);\n+    const bool fRejectLongChains = gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS);\n+\n+    // form groups from remaining coins; note that preset coins will not\n+    // automatically have their associated (same address) coins included\n+    if (coin_control.m_avoid_partial_spends && vCoins.size() > OUTPUT_GROUP_MAX_ENTRIES) {\n+        // Cases where we have 101+ outputs all pointing to the same destination may result in\n+        // privacy leaks as they will potentially be deterministically sorted. We solve that by\n+        // explicitly shuffling the outputs before processing\n+        Shuffle(vCoins.begin(), vCoins.end(), FastRandomContext());\n+    }\n+\n+    // Coin Selection attempts to select inputs from a pool of eligible UTXOs to fund the\n+    // transaction at a target feerate. If an attempt fails, more attempts may be made using a more\n+    // permissive CoinEligibilityFilter.\n+    const bool res = [&] {\n+        // Pre-selected inputs already cover the target amount.\n+        if (value_to_select <= 0) return true;\n+\n+        // If possible, fund the transaction with confirmed UTXOs only. Prefer at least six\n+        // confirmations on outputs received from other wallets and only spend confirmed change.\n+        if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(1, 6, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params)) return true;\n+        if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(1, 1, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params)) return true;\n+\n+        // Fall back to using zero confirmation change (but with as few ancestors in the mempool as\n+        // possible) if we cannot fund the transaction otherwise.\n+        if (m_spend_zero_conf_change) {\n+            if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, 2), vCoins, setCoinsRet, nValueRet, coin_selection_params)) return true;\n+            if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)),\n+                                   vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n+                return true;\n+            }\n+            if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2),\n+                                   vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n+                return true;\n+            }\n+            // If partial groups are allowed, relax the requirement of spending OutputGroups (groups\n+            // of UTXOs sent to the same address, which are obviously controlled by a single wallet)\n+            // in their entirety.\n+            if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1, true /* include_partial_groups */),\n+                                   vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n+                return true;\n+            }\n+            // Try with unsafe inputs if they are allowed. This may spend unconfirmed outputs\n+            // received from other wallets.\n+            if (coin_control.m_include_unsafe_inputs\n+                && SelectCoinsMinConf(value_to_select,\n+                    CoinEligibilityFilter(0 /* conf_mine */, 0 /* conf_theirs */, max_ancestors-1, max_descendants-1, true /* include_partial_groups */),\n+                    vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n+                return true;\n+            }\n+            // Try with unlimited ancestors/descendants. The transaction will still need to meet\n+            // mempool ancestor/descendant policy to be accepted to mempool and broadcasted, but\n+            // OutputGroups use heuristics that may overestimate ancestor/descendant counts.\n+            if (!fRejectLongChains && SelectCoinsMinConf(value_to_select,\n+                                      CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max(), std::numeric_limits<uint64_t>::max(), true /* include_partial_groups */),\n+                                      vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n+                return true;\n+            }\n+        }\n+        // Coin Selection failed.\n+        return false;\n+    }();\n+\n+    // SelectCoinsMinConf clears setCoinsRet, so add the preset inputs from coin_control to the coinset\n+    util::insert(setCoinsRet, setPresetCoins);\n+\n+    // add preset inputs to the total value selected\n+    nValueRet += nValueFromPresetInputs;\n+\n+    return res;\n+}\n+\n+bool CWallet::SignTransaction(CMutableTransaction& tx) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    // Build coins map\n+    std::map<COutPoint, Coin> coins;\n+    for (auto& input : tx.vin) {\n+        std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(input.prevout.hash);\n+        if(mi == mapWallet.end() || input.prevout.n >= mi->second.tx->vout.size()) {\n+            return false;\n+        }\n+        const CWalletTx& wtx = mi->second;\n+        coins[input.prevout] = Coin(wtx.tx->vout[input.prevout.n], wtx.m_confirm.block_height, wtx.IsCoinBase());\n+    }\n+    std::map<int, std::string> input_errors;\n+    return SignTransaction(tx, coins, SIGHASH_ALL, input_errors);\n+}\n+\n+bool CWallet::SignTransaction(CMutableTransaction& tx, const std::map<COutPoint, Coin>& coins, int sighash, std::map<int, std::string>& input_errors) const\n+{\n+    // Try to sign with all ScriptPubKeyMans\n+    for (ScriptPubKeyMan* spk_man : GetAllScriptPubKeyMans()) {\n+        // spk_man->SignTransaction will return true if the transaction is complete,\n+        // so we can exit early and return true if that happens\n+        if (spk_man->SignTransaction(tx, coins, sighash, input_errors)) {\n+            return true;\n+        }\n+    }\n+\n+    // At this point, one input was not fully signed otherwise we would have exited already\n+    return false;\n+}\n+\n+TransactionError CWallet::FillPSBT(PartiallySignedTransaction& psbtx, bool& complete, int sighash_type, bool sign, bool bip32derivs, size_t * n_signed) const\n+{\n+    if (n_signed) {\n+        *n_signed = 0;\n+    }\n+    LOCK(cs_wallet);\n+    // Get all of the previous transactions\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        const CTxIn& txin = psbtx.tx->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (PSBTInputSigned(input)) {\n+            continue;\n+        }\n+\n+        // If we have no utxo, grab it from the wallet.\n+        if (!input.non_witness_utxo) {\n+            const uint256& txhash = txin.prevout.hash;\n+            const auto it = mapWallet.find(txhash);\n+            if (it != mapWallet.end()) {\n+                const CWalletTx& wtx = it->second;\n+                // We only need the non_witness_utxo, which is a superset of the witness_utxo.\n+                //   The signing code will switch to the smaller witness_utxo if this is ok.\n+                input.non_witness_utxo = wtx.tx;\n+            }\n+        }\n+    }\n+\n+    // Fill in information from ScriptPubKeyMans\n+    for (ScriptPubKeyMan* spk_man : GetAllScriptPubKeyMans()) {\n+        int n_signed_this_spkm = 0;\n+        TransactionError res = spk_man->FillPSBT(psbtx, sighash_type, sign, bip32derivs, &n_signed_this_spkm);\n+        if (res != TransactionError::OK) {\n+            return res;\n+        }\n+\n+        if (n_signed) {\n+            (*n_signed) += n_signed_this_spkm;\n+        }\n+    }\n+\n+    // Complete if every input is now signed\n+    complete = true;\n+    for (const auto& input : psbtx.inputs) {\n+        complete &= PSBTInputSigned(input);\n+    }\n+\n+    return TransactionError::OK;\n+}\n+\n+SigningResult CWallet::SignMessage(const std::string& message, const PKHash& pkhash, std::string& str_sig) const\n+{\n+    SignatureData sigdata;\n+    CScript script_pub_key = GetScriptForDestination(pkhash);\n+    for (const auto& spk_man_pair : m_spk_managers) {\n         if (spk_man_pair.second->CanProvide(script_pub_key, sigdata)) {\n             return spk_man_pair.second->SignMessage(message, pkhash, str_sig);\n         }\n     }\n     return SigningResult::PRIVATE_KEY_NOT_AVAILABLE;\n }\n \n+bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nChangePosInOut, bilingual_str& error, bool lockUnspents, const std::set<int>& setSubtractFeeFromOutputs, CCoinControl coinControl)\n+{\n+    std::vector<CRecipient> vecSend;\n+\n+    // Turn the txout set into a CRecipient vector.\n+    for (size_t idx = 0; idx < tx.vout.size(); idx++) {\n+        const CTxOut& txOut = tx.vout[idx];\n+        CRecipient recipient = {txOut.scriptPubKey, txOut.nValue, setSubtractFeeFromOutputs.count(idx) == 1};\n+        vecSend.push_back(recipient);\n+    }\n+\n+    coinControl.fAllowOtherInputs = true;\n+\n+    for (const CTxIn& txin : tx.vin) {\n+        coinControl.Select(txin.prevout);\n+    }\n+\n+    // Acquire the locks to prevent races to the new locked unspents between the\n+    // CreateTransaction call and LockCoin calls (when lockUnspents is true).\n+    LOCK(cs_wallet);\n+\n+    CTransactionRef tx_new;\n+    FeeCalculation fee_calc_out;\n+    if (!CreateTransaction(vecSend, tx_new, nFeeRet, nChangePosInOut, error, coinControl, fee_calc_out, false)) {\n+        return false;\n+    }\n+\n+    if (nChangePosInOut != -1) {\n+        tx.vout.insert(tx.vout.begin() + nChangePosInOut, tx_new->vout[nChangePosInOut]);\n+    }\n+\n+    // Copy output sizes from new transaction; they may have had the fee\n+    // subtracted from them.\n+    for (unsigned int idx = 0; idx < tx.vout.size(); idx++) {\n+        tx.vout[idx].nValue = tx_new->vout[idx].nValue;\n+    }\n+\n+    // Add new txins while keeping original txin scriptSig/order.\n+    for (const CTxIn& txin : tx_new->vin) {\n+        if (!coinControl.IsSelected(txin.prevout)) {\n+            tx.vin.push_back(txin);\n+\n+        }\n+        if (lockUnspents) {\n+            LockCoin(txin.prevout);\n+        }\n+\n+    }\n+\n+    return true;\n+}\n+\n+static bool IsCurrentForAntiFeeSniping(interfaces::Chain& chain, const uint256& block_hash)\n+{\n+    if (chain.isInitialBlockDownload()) {\n+        return false;\n+    }\n+    constexpr int64_t MAX_ANTI_FEE_SNIPING_TIP_AGE = 8 * 60 * 60; // in seconds\n+    int64_t block_time;\n+    CHECK_NONFATAL(chain.findBlock(block_hash, FoundBlock().time(block_time)));\n+    if (block_time < (GetTime() - MAX_ANTI_FEE_SNIPING_TIP_AGE)) {\n+        return false;\n+    }\n+    return true;\n+}\n+\n+/**\n+ * Return a height-based locktime for new transactions (uses the height of the\n+ * current chain tip unless we are not synced with the current chain\n+ */\n+static uint32_t GetLocktimeForNewTransaction(interfaces::Chain& chain, const uint256& block_hash, int block_height)\n+{\n+    uint32_t locktime;\n+    // Discourage fee sniping.\n+    //\n+    // For a large miner the value of the transactions in the best block and\n+    // the mempool can exceed the cost of deliberately attempting to mine two\n+    // blocks to orphan the current best block. By setting nLockTime such that\n+    // only the next block can include the transaction, we discourage this\n+    // practice as the height restricted and limited blocksize gives miners\n+    // considering fee sniping fewer options for pulling off this attack.\n+    //\n+    // A simple way to think about this is from the wallet's point of view we\n+    // always want the blockchain to move forward. By setting nLockTime this\n+    // way we're basically making the statement that we only want this\n+    // transaction to appear in the next block; we don't want to potentially\n+    // encourage reorgs by allowing transactions to appear at lower heights\n+    // than the next block in forks of the best chain.\n+    //\n+    // Of course, the subsidy is high enough, and transaction volume low\n+    // enough, that fee sniping isn't a problem yet, but by implementing a fix\n+    // now we ensure code won't be written that makes assumptions about\n+    // nLockTime that preclude a fix later.\n+    if (IsCurrentForAntiFeeSniping(chain, block_hash)) {\n+        locktime = block_height;\n+\n+        // Secondly occasionally randomly pick a nLockTime even further back, so\n+        // that transactions that are delayed after signing for whatever reason,\n+        // e.g. high-latency mix networks and some CoinJoin implementations, have\n+        // better privacy.\n+        if (GetRandInt(10) == 0)\n+            locktime = std::max(0, (int)locktime - GetRandInt(100));\n+    } else {\n+        // If our chain is lagging behind, we can't discourage fee sniping nor help\n+        // the privacy of high-latency transactions. To avoid leaking a potentially\n+        // unique \"nLockTime fingerprint\", set nLockTime to a constant.\n+        locktime = 0;\n+    }\n+    assert(locktime < LOCKTIME_THRESHOLD);\n+    return locktime;\n+}\n+\n OutputType CWallet::TransactionChangeType(const std::optional<OutputType>& change_type, const std::vector<CRecipient>& vecSend) const\n {\n     // If -changetype is specified, always use that change type.\n@@ -1916,6 +2785,363 @@ OutputType CWallet::TransactionChangeType(const std::optional<OutputType>& chang\n     return m_default_address_type;\n }\n \n+bool CWallet::CreateTransactionInternal(\n+        const std::vector<CRecipient>& vecSend,\n+        CTransactionRef& tx,\n+        CAmount& nFeeRet,\n+        int& nChangePosInOut,\n+        bilingual_str& error,\n+        const CCoinControl& coin_control,\n+        FeeCalculation& fee_calc_out,\n+        bool sign)\n+{\n+    CAmount nValue = 0;\n+    const OutputType change_type = TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : m_default_change_type, vecSend);\n+    ReserveDestination reservedest(this, change_type);\n+    unsigned int nSubtractFeeFromAmount = 0;\n+    for (const auto& recipient : vecSend)\n+    {\n+        if (nValue < 0 || recipient.nAmount < 0)\n+        {\n+            error = _(\"Transaction amounts must not be negative\");\n+            return false;\n+        }\n+        nValue += recipient.nAmount;\n+\n+        if (recipient.fSubtractFeeFromAmount)\n+            nSubtractFeeFromAmount++;\n+    }\n+    if (vecSend.empty())\n+    {\n+        error = _(\"Transaction must have at least one recipient\");\n+        return false;\n+    }\n+\n+    CMutableTransaction txNew;\n+    FeeCalculation feeCalc;\n+    TxSize tx_sizes;\n+    int nBytes;\n+    {\n+        std::set<CInputCoin> setCoins;\n+        LOCK(cs_wallet);\n+        txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n+        {\n+            std::vector<COutput> vAvailableCoins;\n+            AvailableCoins(vAvailableCoins, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n+            CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n+            coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;\n+\n+            // Create change script that will be used if we need change\n+            // TODO: pass in scriptChange instead of reservedest so\n+            // change transaction isn't always pay-to-bitcoin-address\n+            CScript scriptChange;\n+\n+            // coin control: send change to custom address\n+            if (!std::get_if<CNoDestination>(&coin_control.destChange)) {\n+                scriptChange = GetScriptForDestination(coin_control.destChange);\n+            } else { // no coin control: send change to newly generated address\n+                // Note: We use a new key here to keep it from being obvious which side is the change.\n+                //  The drawback is that by not reusing a previous key, the change may be lost if a\n+                //  backup is restored, if the backup doesn't have the new private key for the change.\n+                //  If we reused the old key, it would be possible to add code to look for and\n+                //  rediscover unknown transactions that were written with keys of ours to recover\n+                //  post-backup change.\n+\n+                // Reserve a new key pair from key pool. If it fails, provide a dummy\n+                // destination in case we don't need change.\n+                CTxDestination dest;\n+                if (!reservedest.GetReservedDestination(dest, true)) {\n+                    error = _(\"Transaction needs a change address, but we can't generate it. Please call keypoolrefill first.\");\n+                }\n+                scriptChange = GetScriptForDestination(dest);\n+                // A valid destination implies a change script (and\n+                // vice-versa). An empty change script will abort later, if the\n+                // change keypool ran out, but change is required.\n+                CHECK_NONFATAL(IsValidDestination(dest) != scriptChange.empty());\n+            }\n+            CTxOut change_prototype_txout(0, scriptChange);\n+            coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);\n+\n+            // Get size of spending the change output\n+            int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n+            // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n+            // as lower-bound to allow BnB to do it's thing\n+            if (change_spend_size == -1) {\n+                coin_selection_params.change_spend_size = DUMMY_NESTED_P2WPKH_INPUT_SIZE;\n+            } else {\n+                coin_selection_params.change_spend_size = (size_t)change_spend_size;\n+            }\n+\n+            // Set discard feerate\n+            coin_selection_params.m_discard_feerate = GetDiscardRate(*this);\n+\n+            // Get the fee rate to use effective values in coin selection\n+            coin_selection_params.m_effective_feerate = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && coin_selection_params.m_effective_feerate > *coin_control.m_feerate) {\n+                error = strprintf(_(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\"), coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), coin_selection_params.m_effective_feerate.ToString(FeeEstimateMode::SAT_VB));\n+                return false;\n+            }\n+            if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                error = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+                return false;\n+            }\n+\n+            // Get long term estimate\n+            CCoinControl cc_temp;\n+            cc_temp.m_confirm_target = chain().estimateMaxBlocks();\n+            coin_selection_params.m_long_term_feerate = GetMinimumFeeRate(*this, cc_temp, nullptr);\n+\n+            // Calculate the cost of change\n+            // Cost of change is the cost of creating the change output + cost of spending the change output in the future.\n+            // For creating the change output now, we use the effective feerate.\n+            // For spending the change output in the future, we use the discard feerate for now.\n+            // So cost of change = (change output size * effective feerate) + (size of spending change output * discard feerate)\n+            coin_selection_params.m_change_fee = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.change_output_size);\n+            coin_selection_params.m_cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + coin_selection_params.m_change_fee;\n+\n+            coin_selection_params.m_subtract_fee_outputs = nSubtractFeeFromAmount != 0; // If we are doing subtract fee from recipient, don't use effective values\n+\n+            // vouts to the payees\n+            if (!coin_selection_params.m_subtract_fee_outputs) {\n+                coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n+            }\n+            for (const auto& recipient : vecSend)\n+            {\n+                CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n+\n+                // Include the fee cost for outputs.\n+                if (!coin_selection_params.m_subtract_fee_outputs) {\n+                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n+                }\n+\n+                if (IsDust(txout, chain().relayDustFee()))\n+                {\n+                    error = _(\"Transaction amount too small\");\n+                    return false;\n+                }\n+                txNew.vout.push_back(txout);\n+            }\n+\n+            // Include the fees for things that aren't inputs, excluding the change output\n+            const CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n+            CAmount nValueToSelect = nValue + not_input_fees;\n+\n+            // Choose coins to use\n+            CAmount inputs_sum = 0;\n+            setCoins.clear();\n+            if (!SelectCoins(vAvailableCoins, /* nTargetValue */ nValueToSelect, setCoins, inputs_sum, coin_control, coin_selection_params))\n+            {\n+                error = _(\"Insufficient funds\");\n+                return false;\n+            }\n+\n+            // Always make a change output\n+            // We will reduce the fee from this change output later, and remove the output if it is too small.\n+            const CAmount change_and_fee = inputs_sum - nValue;\n+            assert(change_and_fee >= 0);\n+            CTxOut newTxOut(change_and_fee, scriptChange);\n+\n+            if (nChangePosInOut == -1)\n+            {\n+                // Insert change txn at random position:\n+                nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n+            }\n+            else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n+            {\n+                error = _(\"Change index out of range\");\n+                return false;\n+            }\n+\n+            assert(nChangePosInOut != -1);\n+            auto change_position = txNew.vout.insert(txNew.vout.begin() + nChangePosInOut, newTxOut);\n+\n+            // Dummy fill vin for maximum size estimation\n+            //\n+            for (const auto& coin : setCoins) {\n+                txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));\n+            }\n+\n+            // Calculate the transaction fee\n+            tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n+            nBytes = tx_sizes.vsize;\n+            if (nBytes < 0) {\n+                error = _(\"Signing transaction failed\");\n+                return false;\n+            }\n+            nFeeRet = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n+\n+            // Subtract fee from the change output if not subtrating it from recipient outputs\n+            CAmount fee_needed = nFeeRet;\n+            if (nSubtractFeeFromAmount == 0) {\n+                change_position->nValue -= fee_needed;\n+            }\n+\n+            // We want to drop the change to fees if:\n+            // 1. The change output would be dust\n+            // 2. The change is within the (almost) exact match window, i.e. it is less than or equal to the cost of the change output (cost_of_change)\n+            CAmount change_amount = change_position->nValue;\n+            if (IsDust(*change_position, coin_selection_params.m_discard_feerate) || change_amount <= coin_selection_params.m_cost_of_change)\n+            {\n+                nChangePosInOut = -1;\n+                change_amount = 0;\n+                txNew.vout.erase(change_position);\n+\n+                // Because we have dropped this change, the tx size and required fee will be different, so let's recalculate those\n+                tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n+                nBytes = tx_sizes.vsize;\n+                fee_needed = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n+            }\n+\n+            // Update nFeeRet in case fee_needed changed due to dropping the change output\n+            if (fee_needed <= change_and_fee - change_amount) {\n+                nFeeRet = change_and_fee - change_amount;\n+            }\n+\n+            // Reduce output values for subtractFeeFromAmount\n+            if (nSubtractFeeFromAmount != 0) {\n+                CAmount to_reduce = fee_needed + change_amount - change_and_fee;\n+                int i = 0;\n+                bool fFirst = true;\n+                for (const auto& recipient : vecSend)\n+                {\n+                    if (i == nChangePosInOut) {\n+                        ++i;\n+                    }\n+                    CTxOut& txout = txNew.vout[i];\n+\n+                    if (recipient.fSubtractFeeFromAmount)\n+                    {\n+                        txout.nValue -= to_reduce / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient\n+\n+                        if (fFirst) // first receiver pays the remainder not divisible by output count\n+                        {\n+                            fFirst = false;\n+                            txout.nValue -= to_reduce % nSubtractFeeFromAmount;\n+                        }\n+\n+                        // Error if this output is reduced to be below dust\n+                        if (IsDust(txout, chain().relayDustFee())) {\n+                            if (txout.nValue < 0) {\n+                                error = _(\"The transaction amount is too small to pay the fee\");\n+                            } else {\n+                                error = _(\"The transaction amount is too small to send after the fee has been deducted\");\n+                            }\n+                            return false;\n+                        }\n+                    }\n+                    ++i;\n+                }\n+                nFeeRet = fee_needed;\n+            }\n+\n+            // Give up if change keypool ran out and change is required\n+            if (scriptChange.empty() && nChangePosInOut != -1) {\n+                return false;\n+            }\n+        }\n+\n+        // Shuffle selected coins and fill in final vin\n+        txNew.vin.clear();\n+        std::vector<CInputCoin> selected_coins(setCoins.begin(), setCoins.end());\n+        Shuffle(selected_coins.begin(), selected_coins.end(), FastRandomContext());\n+\n+        // Note how the sequence number is set to non-maxint so that\n+        // the nLockTime set above actually works.\n+        //\n+        // BIP125 defines opt-in RBF as any nSequence < maxint-1, so\n+        // we use the highest possible value in that range (maxint-2)\n+        // to avoid conflicting with other possible uses of nSequence,\n+        // and in the spirit of \"smallest possible change from prior\n+        // behavior.\"\n+        const uint32_t nSequence = coin_control.m_signal_bip125_rbf.value_or(m_signal_rbf) ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n+        for (const auto& coin : selected_coins) {\n+            txNew.vin.push_back(CTxIn(coin.outpoint, CScript(), nSequence));\n+        }\n+\n+        if (sign && !SignTransaction(txNew)) {\n+            error = _(\"Signing transaction failed\");\n+            return false;\n+        }\n+\n+        // Return the constructed transaction data.\n+        tx = MakeTransactionRef(std::move(txNew));\n+\n+        // Limit size\n+        if ((sign && GetTransactionWeight(*tx) > MAX_STANDARD_TX_WEIGHT) ||\n+            (!sign && tx_sizes.weight > MAX_STANDARD_TX_WEIGHT))\n+        {\n+            error = _(\"Transaction too large\");\n+            return false;\n+        }\n+    }\n+\n+    if (nFeeRet > m_default_max_tx_fee) {\n+        error = TransactionErrorString(TransactionError::MAX_FEE_EXCEEDED);\n+        return false;\n+    }\n+\n+    if (gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS)) {\n+        // Lastly, ensure this tx will pass the mempool's chain limits\n+        if (!chain().checkChainLimits(tx)) {\n+            error = _(\"Transaction has too long of a mempool chain\");\n+            return false;\n+        }\n+    }\n+\n+    // Before we return success, we assume any change key will be used to prevent\n+    // accidental re-use.\n+    reservedest.KeepDestination();\n+    fee_calc_out = feeCalc;\n+\n+    WalletLogPrintf(\"Fee Calculation: Fee:%d Bytes:%u Tgt:%d (requested %d) Reason:\\\"%s\\\" Decay %.5f: Estimation: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out) Fail: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out)\\n\",\n+              nFeeRet, nBytes, feeCalc.returnedTarget, feeCalc.desiredTarget, StringForFeeReason(feeCalc.reason), feeCalc.est.decay,\n+              feeCalc.est.pass.start, feeCalc.est.pass.end,\n+              (feeCalc.est.pass.totalConfirmed + feeCalc.est.pass.inMempool + feeCalc.est.pass.leftMempool) > 0.0 ? 100 * feeCalc.est.pass.withinTarget / (feeCalc.est.pass.totalConfirmed + feeCalc.est.pass.inMempool + feeCalc.est.pass.leftMempool) : 0.0,\n+              feeCalc.est.pass.withinTarget, feeCalc.est.pass.totalConfirmed, feeCalc.est.pass.inMempool, feeCalc.est.pass.leftMempool,\n+              feeCalc.est.fail.start, feeCalc.est.fail.end,\n+              (feeCalc.est.fail.totalConfirmed + feeCalc.est.fail.inMempool + feeCalc.est.fail.leftMempool) > 0.0 ? 100 * feeCalc.est.fail.withinTarget / (feeCalc.est.fail.totalConfirmed + feeCalc.est.fail.inMempool + feeCalc.est.fail.leftMempool) : 0.0,\n+              feeCalc.est.fail.withinTarget, feeCalc.est.fail.totalConfirmed, feeCalc.est.fail.inMempool, feeCalc.est.fail.leftMempool);\n+    return true;\n+}\n+\n+bool CWallet::CreateTransaction(\n+        const std::vector<CRecipient>& vecSend,\n+        CTransactionRef& tx,\n+        CAmount& nFeeRet,\n+        int& nChangePosInOut,\n+        bilingual_str& error,\n+        const CCoinControl& coin_control,\n+        FeeCalculation& fee_calc_out,\n+        bool sign)\n+{\n+    int nChangePosIn = nChangePosInOut;\n+    Assert(!tx); // tx is an out-param. TODO change the return type from bool to tx (or nullptr)\n+    bool res = CreateTransactionInternal(vecSend, tx, nFeeRet, nChangePosInOut, error, coin_control, fee_calc_out, sign);\n+    // try with avoidpartialspends unless it's enabled already\n+    if (res && nFeeRet > 0 /* 0 means non-functional fee rate estimation */ && m_max_aps_fee > -1 && !coin_control.m_avoid_partial_spends) {\n+        CCoinControl tmp_cc = coin_control;\n+        tmp_cc.m_avoid_partial_spends = true;\n+        CAmount nFeeRet2;\n+        CTransactionRef tx2;\n+        int nChangePosInOut2 = nChangePosIn;\n+        bilingual_str error2; // fired and forgotten; if an error occurs, we discard the results\n+        if (CreateTransactionInternal(vecSend, tx2, nFeeRet2, nChangePosInOut2, error2, tmp_cc, fee_calc_out, sign)) {\n+            // if fee of this alternative one is within the range of the max fee, we use this one\n+            const bool use_aps = nFeeRet2 <= nFeeRet + m_max_aps_fee;\n+            WalletLogPrintf(\"Fee non-grouped = %lld, grouped = %lld, using %s\\n\", nFeeRet, nFeeRet2, use_aps ? \"grouped\" : \"non-grouped\");\n+            if (use_aps) {\n+                tx = tx2;\n+                nFeeRet = nFeeRet2;\n+                nChangePosInOut = nChangePosInOut2;\n+            }\n+        }\n+    }\n+    return res;\n+}\n+\n void CWallet::CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::vector<std::pair<std::string, std::string>> orderForm)\n {\n     LOCK(cs_wallet);\n@@ -2159,6 +3385,137 @@ void CWallet::MarkDestinationsDirty(const std::set<CTxDestination>& destinations\n     }\n }\n \n+std::map<CTxDestination, CAmount> CWallet::GetAddressBalances() const\n+{\n+    std::map<CTxDestination, CAmount> balances;\n+\n+    {\n+        LOCK(cs_wallet);\n+        std::set<uint256> trusted_parents;\n+        for (const auto& walletEntry : mapWallet)\n+        {\n+            const CWalletTx& wtx = walletEntry.second;\n+\n+            if (!IsTrusted(wtx, trusted_parents))\n+                continue;\n+\n+            if (wtx.IsImmatureCoinBase())\n+                continue;\n+\n+            int nDepth = wtx.GetDepthInMainChain();\n+            if (nDepth < (wtx.IsFromMe(ISMINE_ALL) ? 0 : 1))\n+                continue;\n+\n+            for (unsigned int i = 0; i < wtx.tx->vout.size(); i++)\n+            {\n+                CTxDestination addr;\n+                if (!IsMine(wtx.tx->vout[i]))\n+                    continue;\n+                if(!ExtractDestination(wtx.tx->vout[i].scriptPubKey, addr))\n+                    continue;\n+\n+                CAmount n = IsSpent(walletEntry.first, i) ? 0 : wtx.tx->vout[i].nValue;\n+                balances[addr] += n;\n+            }\n+        }\n+    }\n+\n+    return balances;\n+}\n+\n+std::set< std::set<CTxDestination> > CWallet::GetAddressGroupings() const\n+{\n+    AssertLockHeld(cs_wallet);\n+    std::set< std::set<CTxDestination> > groupings;\n+    std::set<CTxDestination> grouping;\n+\n+    for (const auto& walletEntry : mapWallet)\n+    {\n+        const CWalletTx& wtx = walletEntry.second;\n+\n+        if (wtx.tx->vin.size() > 0)\n+        {\n+            bool any_mine = false;\n+            // group all input addresses with each other\n+            for (const CTxIn& txin : wtx.tx->vin)\n+            {\n+                CTxDestination address;\n+                if(!IsMine(txin)) /* If this input isn't mine, ignore it */\n+                    continue;\n+                if(!ExtractDestination(mapWallet.at(txin.prevout.hash).tx->vout[txin.prevout.n].scriptPubKey, address))\n+                    continue;\n+                grouping.insert(address);\n+                any_mine = true;\n+            }\n+\n+            // group change with input addresses\n+            if (any_mine)\n+            {\n+               for (const CTxOut& txout : wtx.tx->vout)\n+                   if (IsChange(txout))\n+                   {\n+                       CTxDestination txoutAddr;\n+                       if(!ExtractDestination(txout.scriptPubKey, txoutAddr))\n+                           continue;\n+                       grouping.insert(txoutAddr);\n+                   }\n+            }\n+            if (grouping.size() > 0)\n+            {\n+                groupings.insert(grouping);\n+                grouping.clear();\n+            }\n+        }\n+\n+        // group lone addrs by themselves\n+        for (const auto& txout : wtx.tx->vout)\n+            if (IsMine(txout))\n+            {\n+                CTxDestination address;\n+                if(!ExtractDestination(txout.scriptPubKey, address))\n+                    continue;\n+                grouping.insert(address);\n+                groupings.insert(grouping);\n+                grouping.clear();\n+            }\n+    }\n+\n+    std::set< std::set<CTxDestination>* > uniqueGroupings; // a set of pointers to groups of addresses\n+    std::map< CTxDestination, std::set<CTxDestination>* > setmap;  // map addresses to the unique group containing it\n+    for (std::set<CTxDestination> _grouping : groupings)\n+    {\n+        // make a set of all the groups hit by this new group\n+        std::set< std::set<CTxDestination>* > hits;\n+        std::map< CTxDestination, std::set<CTxDestination>* >::iterator it;\n+        for (const CTxDestination& address : _grouping)\n+            if ((it = setmap.find(address)) != setmap.end())\n+                hits.insert((*it).second);\n+\n+        // merge all hit groups into a new single group and delete old groups\n+        std::set<CTxDestination>* merged = new std::set<CTxDestination>(_grouping);\n+        for (std::set<CTxDestination>* hit : hits)\n+        {\n+            merged->insert(hit->begin(), hit->end());\n+            uniqueGroupings.erase(hit);\n+            delete hit;\n+        }\n+        uniqueGroupings.insert(merged);\n+\n+        // update setmap\n+        for (const CTxDestination& element : *merged)\n+            setmap[element] = merged;\n+    }\n+\n+    std::set< std::set<CTxDestination> > ret;\n+    for (const std::set<CTxDestination>* uniqueGrouping : uniqueGroupings)\n+    {\n+        ret.insert(*uniqueGrouping);\n+        delete uniqueGrouping;\n+    }\n+\n+    return ret;\n+}\n+\n std::set<CTxDestination> CWallet::GetLabelAddresses(const std::string& label) const\n {\n     LOCK(cs_wallet);\n@@ -2874,6 +4231,92 @@ bool CWalletTx::IsImmatureCoinBase() const\n     return GetBlocksToMaturity() > 0;\n }\n \n+std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outputs, const CoinSelectionParams& coin_sel_params, const CoinEligibilityFilter& filter, bool positive_only) const\n+{\n+    std::vector<OutputGroup> groups_out;\n+\n+    if (!coin_sel_params.m_avoid_partial_spends) {\n+        // Allowing partial spends  means no grouping. Each COutput gets its own OutputGroup.\n+        for (const COutput& output : outputs) {\n+            // Skip outputs we cannot spend\n+            if (!output.fSpendable) continue;\n+\n+            size_t ancestors, descendants;\n+            chain().getTransactionAncestry(output.tx->GetHash(), ancestors, descendants);\n+            CInputCoin input_coin = output.GetInputCoin();\n+\n+            // Make an OutputGroup containing just this output\n+            OutputGroup group{coin_sel_params};\n+            group.Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants, positive_only);\n+\n+            // Check the OutputGroup's eligibility. Only add the eligible ones.\n+            if (positive_only && group.GetSelectionAmount() <= 0) continue;\n+            if (group.m_outputs.size() > 0 && group.EligibleForSpending(filter)) groups_out.push_back(group);\n+        }\n+        return groups_out;\n+    }\n+\n+    // We want to combine COutputs that have the same scriptPubKey into single OutputGroups\n+    // except when there are more than OUTPUT_GROUP_MAX_ENTRIES COutputs grouped in an OutputGroup.\n+    // To do this, we maintain a map where the key is the scriptPubKey and the value is a vector of OutputGroups.\n+    // For each COutput, we check if the scriptPubKey is in the map, and if it is, the COutput's CInputCoin is added\n+    // to the last OutputGroup in the vector for the scriptPubKey. When the last OutputGroup has\n+    // OUTPUT_GROUP_MAX_ENTRIES CInputCoins, a new OutputGroup is added to the end of the vector.\n+    std::map<CScript, std::vector<OutputGroup>> spk_to_groups_map;\n+    for (const auto& output : outputs) {\n+        // Skip outputs we cannot spend\n+        if (!output.fSpendable) continue;\n+\n+        size_t ancestors, descendants;\n+        chain().getTransactionAncestry(output.tx->GetHash(), ancestors, descendants);\n+        CInputCoin input_coin = output.GetInputCoin();\n+        CScript spk = input_coin.txout.scriptPubKey;\n+\n+        std::vector<OutputGroup>& groups = spk_to_groups_map[spk];\n+\n+        if (groups.size() == 0) {\n+            // No OutputGroups for this scriptPubKey yet, add one\n+            groups.emplace_back(coin_sel_params);\n+        }\n+\n+        // Get the last OutputGroup in the vector so that we can add the CInputCoin to it\n+        // A pointer is used here so that group can be reassigned later if it is full.\n+        OutputGroup* group = &groups.back();\n+\n+        // Check if this OutputGroup is full. We limit to OUTPUT_GROUP_MAX_ENTRIES when using -avoidpartialspends\n+        // to avoid surprising users with very high fees.\n+        if (group->m_outputs.size() >= OUTPUT_GROUP_MAX_ENTRIES) {\n+            // The last output group is full, add a new group to the vector and use that group for the insertion\n+            groups.emplace_back(coin_sel_params);\n+            group = &groups.back();\n+        }\n+\n+        // Add the input_coin to group\n+        group->Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants, positive_only);\n+    }\n+\n+    // Now we go through the entire map and pull out the OutputGroups\n+    for (const auto& spk_and_groups_pair: spk_to_groups_map) {\n+        const std::vector<OutputGroup>& groups_per_spk= spk_and_groups_pair.second;\n+\n+        // Go through the vector backwards. This allows for the first item we deal with being the partial group.\n+        for (auto group_it = groups_per_spk.rbegin(); group_it != groups_per_spk.rend(); group_it++) {\n+            const OutputGroup& group = *group_it;\n+\n+            // Don't include partial groups if there are full groups too and we don't want partial groups\n+            if (group_it == groups_per_spk.rbegin() && groups_per_spk.size() > 1 && !filter.m_include_partial_groups) {\n+                continue;\n+            }\n+\n+            // Check the OutputGroup's eligibility. Only add the eligible ones.\n+            if (positive_only && group.GetSelectionAmount() <= 0) continue;\n+            if (group.m_outputs.size() > 0 && group.EligibleForSpending(filter)) groups_out.push_back(group);\n+        }\n+    }\n+\n+    return groups_out;\n+}\n+\n bool CWallet::IsCrypted() const\n {\n     return HasEncryptionKeys();"
      },
      {
        "sha": "9a572bc6105c0341e520d246616b4168c628ac23",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 399,
        "deletions": 4,
        "changes": 403,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6f340cbb76a8221fc03c726328ca79a37e7be2d6/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6f340cbb76a8221fc03c726328ca79a37e7be2d6/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=6f340cbb76a8221fc03c726328ca79a37e7be2d6",
        "patch": "@@ -21,11 +21,8 @@\n #include <validationinterface.h>\n #include <wallet/coinselection.h>\n #include <wallet/crypter.h>\n-#include <external_signer.h>\n-#include <wallet/receive.h>\n #include <wallet/scriptpubkeyman.h>\n-#include <wallet/spend.h>\n-#include <wallet/transaction.h>\n+#include <external_signer.h>\n #include <wallet/walletdb.h>\n #include <wallet/walletutil.h>\n \n@@ -218,6 +215,403 @@ struct CRecipient\n     bool fSubtractFeeFromAmount;\n };\n \n+typedef std::map<std::string, std::string> mapValue_t;\n+\n+\n+static inline void ReadOrderPos(int64_t& nOrderPos, mapValue_t& mapValue)\n+{\n+    if (!mapValue.count(\"n\"))\n+    {\n+        nOrderPos = -1; // TODO: calculate elsewhere\n+        return;\n+    }\n+    nOrderPos = atoi64(mapValue[\"n\"]);\n+}\n+\n+\n+static inline void WriteOrderPos(const int64_t& nOrderPos, mapValue_t& mapValue)\n+{\n+    if (nOrderPos == -1)\n+        return;\n+    mapValue[\"n\"] = ToString(nOrderPos);\n+}\n+\n+struct COutputEntry\n+{\n+    CTxDestination destination;\n+    CAmount amount;\n+    int vout;\n+};\n+\n+/** Legacy class used for deserializing vtxPrev for backwards compatibility.\n+ * vtxPrev was removed in commit 93a18a3650292afbb441a47d1fa1b94aeb0164e3,\n+ * but old wallet.dat files may still contain vtxPrev vectors of CMerkleTxs.\n+ * These need to get deserialized for field alignment when deserializing\n+ * a CWalletTx, but the deserialized values are discarded.**/\n+class CMerkleTx\n+{\n+public:\n+    template<typename Stream>\n+    void Unserialize(Stream& s)\n+    {\n+        CTransactionRef tx;\n+        uint256 hashBlock;\n+        std::vector<uint256> vMerkleBranch;\n+        int nIndex;\n+\n+        s >> tx >> hashBlock >> vMerkleBranch >> nIndex;\n+    }\n+};\n+\n+//Get the marginal bytes of spending the specified output\n+int CalculateMaximumSignedInputSize(const CTxOut& txout, const CWallet* pwallet, bool use_max_sig = false);\n+\n+/**\n+ * A transaction with a bunch of additional info that only the owner cares about.\n+ * It includes any unrecorded transactions needed to link it back to the block chain.\n+ */\n+class CWalletTx\n+{\n+private:\n+    const CWallet* const pwallet;\n+\n+    /** Constant used in hashBlock to indicate tx has been abandoned, only used at\n+     * serialization/deserialization to avoid ambiguity with conflicted.\n+     */\n+    static constexpr const uint256& ABANDON_HASH = uint256::ONE;\n+\n+public:\n+    /**\n+     * Key/value map with information about the transaction.\n+     *\n+     * The following keys can be read and written through the map and are\n+     * serialized in the wallet database:\n+     *\n+     *     \"comment\", \"to\"   - comment strings provided to sendtoaddress,\n+     *                         and sendmany wallet RPCs\n+     *     \"replaces_txid\"   - txid (as HexStr) of transaction replaced by\n+     *                         bumpfee on transaction created by bumpfee\n+     *     \"replaced_by_txid\" - txid (as HexStr) of transaction created by\n+     *                         bumpfee on transaction replaced by bumpfee\n+     *     \"from\", \"message\" - obsolete fields that could be set in UI prior to\n+     *                         2011 (removed in commit 4d9b223)\n+     *\n+     * The following keys are serialized in the wallet database, but shouldn't\n+     * be read or written through the map (they will be temporarily added and\n+     * removed from the map during serialization):\n+     *\n+     *     \"fromaccount\"     - serialized strFromAccount value\n+     *     \"n\"               - serialized nOrderPos value\n+     *     \"timesmart\"       - serialized nTimeSmart value\n+     *     \"spent\"           - serialized vfSpent value that existed prior to\n+     *                         2014 (removed in commit 93a18a3)\n+     */\n+    mapValue_t mapValue;\n+    std::vector<std::pair<std::string, std::string> > vOrderForm;\n+    unsigned int fTimeReceivedIsTxTime;\n+    unsigned int nTimeReceived; //!< time received by this node\n+    /**\n+     * Stable timestamp that never changes, and reflects the order a transaction\n+     * was added to the wallet. Timestamp is based on the block time for a\n+     * transaction added as part of a block, or else the time when the\n+     * transaction was received if it wasn't part of a block, with the timestamp\n+     * adjusted in both cases so timestamp order matches the order transactions\n+     * were added to the wallet. More details can be found in\n+     * CWallet::ComputeTimeSmart().\n+     */\n+    unsigned int nTimeSmart;\n+    /**\n+     * From me flag is set to 1 for transactions that were created by the wallet\n+     * on this bitcoin node, and set to 0 for transactions that were created\n+     * externally and came in through the network or sendrawtransaction RPC.\n+     */\n+    bool fFromMe;\n+    int64_t nOrderPos; //!< position in ordered transaction list\n+    std::multimap<int64_t, CWalletTx*>::const_iterator m_it_wtxOrdered;\n+\n+    // memory only\n+    enum AmountType { DEBIT, CREDIT, IMMATURE_CREDIT, AVAILABLE_CREDIT, AMOUNTTYPE_ENUM_ELEMENTS };\n+    CAmount GetCachableAmount(AmountType type, const isminefilter& filter, bool recalculate = false) const;\n+    mutable CachableAmount m_amounts[AMOUNTTYPE_ENUM_ELEMENTS];\n+    /**\n+     * This flag is true if all m_amounts caches are empty. This is particularly\n+     * useful in places where MarkDirty is conditionally called and the\n+     * condition can be expensive and thus can be skipped if the flag is true.\n+     * See MarkDestinationsDirty.\n+     */\n+    mutable bool m_is_cache_empty{true};\n+    mutable bool fChangeCached;\n+    mutable bool fInMempool;\n+    mutable CAmount nChangeCached;\n+\n+    CWalletTx(const CWallet* wallet, CTransactionRef arg)\n+        : pwallet(wallet),\n+          tx(std::move(arg))\n+    {\n+        Init();\n+    }\n+\n+    void Init()\n+    {\n+        mapValue.clear();\n+        vOrderForm.clear();\n+        fTimeReceivedIsTxTime = false;\n+        nTimeReceived = 0;\n+        nTimeSmart = 0;\n+        fFromMe = false;\n+        fChangeCached = false;\n+        fInMempool = false;\n+        nChangeCached = 0;\n+        nOrderPos = -1;\n+        m_confirm = Confirmation{};\n+    }\n+\n+    CTransactionRef tx;\n+\n+    /** New transactions start as UNCONFIRMED. At BlockConnected,\n+     * they will transition to CONFIRMED. In case of reorg, at BlockDisconnected,\n+     * they roll back to UNCONFIRMED. If we detect a conflicting transaction at\n+     * block connection, we update conflicted tx and its dependencies as CONFLICTED.\n+     * If tx isn't confirmed and outside of mempool, the user may switch it to ABANDONED\n+     * by using the abandontransaction call. This last status may be override by a CONFLICTED\n+     * or CONFIRMED transition.\n+     */\n+    enum Status {\n+        UNCONFIRMED,\n+        CONFIRMED,\n+        CONFLICTED,\n+        ABANDONED\n+    };\n+\n+    /** Confirmation includes tx status and a triplet of {block height/block hash/tx index in block}\n+     * at which tx has been confirmed. All three are set to 0 if tx is unconfirmed or abandoned.\n+     * Meaning of these fields changes with CONFLICTED state where they instead point to block hash\n+     * and block height of the deepest conflicting tx.\n+     */\n+    struct Confirmation {\n+        Status status;\n+        int block_height;\n+        uint256 hashBlock;\n+        int nIndex;\n+        Confirmation(Status s = UNCONFIRMED, int b = 0, uint256 h = uint256(), int i = 0) : status(s), block_height(b), hashBlock(h), nIndex(i) {}\n+    };\n+\n+    Confirmation m_confirm;\n+\n+    template<typename Stream>\n+    void Serialize(Stream& s) const\n+    {\n+        mapValue_t mapValueCopy = mapValue;\n+\n+        mapValueCopy[\"fromaccount\"] = \"\";\n+        WriteOrderPos(nOrderPos, mapValueCopy);\n+        if (nTimeSmart) {\n+            mapValueCopy[\"timesmart\"] = strprintf(\"%u\", nTimeSmart);\n+        }\n+\n+        std::vector<char> dummy_vector1; //!< Used to be vMerkleBranch\n+        std::vector<char> dummy_vector2; //!< Used to be vtxPrev\n+        bool dummy_bool = false; //!< Used to be fSpent\n+        uint256 serializedHash = isAbandoned() ? ABANDON_HASH : m_confirm.hashBlock;\n+        int serializedIndex = isAbandoned() || isConflicted() ? -1 : m_confirm.nIndex;\n+        s << tx << serializedHash << dummy_vector1 << serializedIndex << dummy_vector2 << mapValueCopy << vOrderForm << fTimeReceivedIsTxTime << nTimeReceived << fFromMe << dummy_bool;\n+    }\n+\n+    template<typename Stream>\n+    void Unserialize(Stream& s)\n+    {\n+        Init();\n+\n+        std::vector<uint256> dummy_vector1; //!< Used to be vMerkleBranch\n+        std::vector<CMerkleTx> dummy_vector2; //!< Used to be vtxPrev\n+        bool dummy_bool; //! Used to be fSpent\n+        int serializedIndex;\n+        s >> tx >> m_confirm.hashBlock >> dummy_vector1 >> serializedIndex >> dummy_vector2 >> mapValue >> vOrderForm >> fTimeReceivedIsTxTime >> nTimeReceived >> fFromMe >> dummy_bool;\n+\n+        /* At serialization/deserialization, an nIndex == -1 means that hashBlock refers to\n+         * the earliest block in the chain we know this or any in-wallet ancestor conflicts\n+         * with. If nIndex == -1 and hashBlock is ABANDON_HASH, it means transaction is abandoned.\n+         * In same context, an nIndex >= 0 refers to a confirmed transaction (if hashBlock set) or\n+         * unconfirmed one. Older clients interpret nIndex == -1 as unconfirmed for backward\n+         * compatibility (pre-commit 9ac63d6).\n+         */\n+        if (serializedIndex == -1 && m_confirm.hashBlock == ABANDON_HASH) {\n+            setAbandoned();\n+        } else if (serializedIndex == -1) {\n+            setConflicted();\n+        } else if (!m_confirm.hashBlock.IsNull()) {\n+            m_confirm.nIndex = serializedIndex;\n+            setConfirmed();\n+        }\n+\n+        ReadOrderPos(nOrderPos, mapValue);\n+        nTimeSmart = mapValue.count(\"timesmart\") ? (unsigned int)atoi64(mapValue[\"timesmart\"]) : 0;\n+\n+        mapValue.erase(\"fromaccount\");\n+        mapValue.erase(\"spent\");\n+        mapValue.erase(\"n\");\n+        mapValue.erase(\"timesmart\");\n+    }\n+\n+    void SetTx(CTransactionRef arg)\n+    {\n+        tx = std::move(arg);\n+    }\n+\n+    //! make sure balances are recalculated\n+    void MarkDirty()\n+    {\n+        m_amounts[DEBIT].Reset();\n+        m_amounts[CREDIT].Reset();\n+        m_amounts[IMMATURE_CREDIT].Reset();\n+        m_amounts[AVAILABLE_CREDIT].Reset();\n+        fChangeCached = false;\n+        m_is_cache_empty = true;\n+    }\n+\n+    //! filter decides which addresses will count towards the debit\n+    CAmount GetDebit(const isminefilter& filter) const;\n+    CAmount GetCredit(const isminefilter& filter) const;\n+    CAmount GetImmatureCredit(bool fUseCache = true) const;\n+    // TODO: Remove \"NO_THREAD_SAFETY_ANALYSIS\" and replace it with the correct\n+    // annotation \"EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\". The\n+    // annotation \"NO_THREAD_SAFETY_ANALYSIS\" was temporarily added to avoid\n+    // having to resolve the issue of member access into incomplete type CWallet.\n+    CAmount GetAvailableCredit(bool fUseCache = true, const isminefilter& filter = ISMINE_SPENDABLE) const NO_THREAD_SAFETY_ANALYSIS;\n+    CAmount GetImmatureWatchOnlyCredit(const bool fUseCache = true) const;\n+    CAmount GetChange() const;\n+\n+    /** Get the marginal bytes if spending the specified output from this transaction */\n+    int GetSpendSize(unsigned int out, bool use_max_sig = false) const\n+    {\n+        return CalculateMaximumSignedInputSize(tx->vout[out], pwallet, use_max_sig);\n+    }\n+\n+    void GetAmounts(std::list<COutputEntry>& listReceived,\n+                    std::list<COutputEntry>& listSent, CAmount& nFee, const isminefilter& filter) const;\n+\n+    bool IsFromMe(const isminefilter& filter) const\n+    {\n+        return (GetDebit(filter) > 0);\n+    }\n+\n+    /** True if only scriptSigs are different */\n+    bool IsEquivalentTo(const CWalletTx& tx) const;\n+\n+    bool InMempool() const;\n+    bool IsTrusted() const;\n+\n+    int64_t GetTxTime() const;\n+\n+    /** Pass this transaction to node for mempool insertion and relay to peers if flag set to true */\n+    bool SubmitMemoryPoolAndRelay(std::string& err_string, bool relay);\n+\n+    // TODO: Remove \"NO_THREAD_SAFETY_ANALYSIS\" and replace it with the correct\n+    // annotation \"EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\". The annotation\n+    // \"NO_THREAD_SAFETY_ANALYSIS\" was temporarily added to avoid having to\n+    // resolve the issue of member access into incomplete type CWallet. Note\n+    // that we still have the runtime check \"AssertLockHeld(pwallet->cs_wallet)\"\n+    // in place.\n+    std::set<uint256> GetConflicts() const NO_THREAD_SAFETY_ANALYSIS;\n+\n+    /**\n+     * Return depth of transaction in blockchain:\n+     * <0  : conflicts with a transaction this deep in the blockchain\n+     *  0  : in memory pool, waiting to be included in a block\n+     * >=1 : this many blocks deep in the main chain\n+     */\n+    // TODO: Remove \"NO_THREAD_SAFETY_ANALYSIS\" and replace it with the correct\n+    // annotation \"EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\". The annotation\n+    // \"NO_THREAD_SAFETY_ANALYSIS\" was temporarily added to avoid having to\n+    // resolve the issue of member access into incomplete type CWallet. Note\n+    // that we still have the runtime check \"AssertLockHeld(pwallet->cs_wallet)\"\n+    // in place.\n+    int GetDepthInMainChain() const NO_THREAD_SAFETY_ANALYSIS;\n+    bool IsInMainChain() const { return GetDepthInMainChain() > 0; }\n+\n+    /**\n+     * @return number of blocks to maturity for this transaction:\n+     *  0 : is not a coinbase transaction, or is a mature coinbase transaction\n+     * >0 : is a coinbase transaction which matures in this many blocks\n+     */\n+    int GetBlocksToMaturity() const;\n+    bool isAbandoned() const { return m_confirm.status == CWalletTx::ABANDONED; }\n+    void setAbandoned()\n+    {\n+        m_confirm.status = CWalletTx::ABANDONED;\n+        m_confirm.hashBlock = uint256();\n+        m_confirm.block_height = 0;\n+        m_confirm.nIndex = 0;\n+    }\n+    bool isConflicted() const { return m_confirm.status == CWalletTx::CONFLICTED; }\n+    void setConflicted() { m_confirm.status = CWalletTx::CONFLICTED; }\n+    bool isUnconfirmed() const { return m_confirm.status == CWalletTx::UNCONFIRMED; }\n+    void setUnconfirmed() { m_confirm.status = CWalletTx::UNCONFIRMED; }\n+    bool isConfirmed() const { return m_confirm.status == CWalletTx::CONFIRMED; }\n+    void setConfirmed() { m_confirm.status = CWalletTx::CONFIRMED; }\n+    const uint256& GetHash() const { return tx->GetHash(); }\n+    bool IsCoinBase() const { return tx->IsCoinBase(); }\n+    bool IsImmatureCoinBase() const;\n+\n+    // Disable copying of CWalletTx objects to prevent bugs where instances get\n+    // copied in and out of the mapWallet map, and fields are updated in the\n+    // wrong copy.\n+    CWalletTx(CWalletTx const &) = delete;\n+    void operator=(CWalletTx const &x) = delete;\n+};\n+\n+class COutput\n+{\n+public:\n+    const CWalletTx *tx;\n+\n+    /** Index in tx->vout. */\n+    int i;\n+\n+    /**\n+     * Depth in block chain.\n+     * If > 0: the tx is on chain and has this many confirmations.\n+     * If = 0: the tx is waiting confirmation.\n+     * If < 0: a conflicting tx is on chain and has this many confirmations. */\n+    int nDepth;\n+\n+    /** Pre-computed estimated size of this output as a fully-signed input in a transaction. Can be -1 if it could not be calculated */\n+    int nInputBytes;\n+\n+    /** Whether we have the private keys to spend this output */\n+    bool fSpendable;\n+\n+    /** Whether we know how to spend this output, ignoring the lack of keys */\n+    bool fSolvable;\n+\n+    /** Whether to use the maximum sized, 72 byte signature when calculating the size of the input spend. This should only be set when watch-only outputs are allowed */\n+    bool use_max_sig;\n+\n+    /**\n+     * Whether this output is considered safe to spend. Unconfirmed transactions\n+     * from outside keys and unconfirmed replacement transactions are considered\n+     * unsafe and will not be used to fund new spending transactions.\n+     */\n+    bool fSafe;\n+\n+    COutput(const CWalletTx *txIn, int iIn, int nDepthIn, bool fSpendableIn, bool fSolvableIn, bool fSafeIn, bool use_max_sig_in = false)\n+    {\n+        tx = txIn; i = iIn; nDepth = nDepthIn; fSpendable = fSpendableIn; fSolvable = fSolvableIn; fSafe = fSafeIn; nInputBytes = -1; use_max_sig = use_max_sig_in;\n+        // If known and signable by the given wallet, compute nInputBytes\n+        // Failure will keep this value -1\n+        if (fSpendable && tx) {\n+            nInputBytes = tx->GetSpendSize(i, use_max_sig);\n+        }\n+    }\n+\n+    std::string ToString() const;\n+\n+    inline CInputCoin GetInputCoin() const\n+    {\n+        return CInputCoin(tx->tx, i, nInputBytes);\n+    }\n+};\n+\n class WalletRescanReserver; //forward declarations for ScanForWalletTransactions/RescanFromTime\n /**\n  * A CWallet maintains a set of transactions and balances, and provides the ability to create new transactions.\n@@ -227,6 +621,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n private:\n     CKeyingMaterial vMasterKey GUARDED_BY(cs_wallet);\n \n+\n     bool Unlock(const CKeyingMaterial& vMasterKeyIn, bool accept_no_keys = false);\n \n     std::atomic<bool> fAbortRescan{false};"
      },
      {
        "sha": "354e14f361e7441cc717f5ab86a4376e2bc7998d",
        "filename": "test/lint/lint-circular-dependencies.sh",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6f340cbb76a8221fc03c726328ca79a37e7be2d6/test/lint/lint-circular-dependencies.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6f340cbb76a8221fc03c726328ca79a37e7be2d6/test/lint/lint-circular-dependencies.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-circular-dependencies.sh?ref=6f340cbb76a8221fc03c726328ca79a37e7be2d6",
        "patch": "@@ -25,10 +25,6 @@ EXPECTED_CIRCULAR_DEPENDENCIES=(\n     \"wallet/fees -> wallet/wallet -> wallet/fees\"\n     \"wallet/wallet -> wallet/walletdb -> wallet/wallet\"\n     \"node/coinstats -> validation -> node/coinstats\"\n-    # Temporary circular dependencies that allow wallet.h/wallet.cpp to be\n-    # split up in a MOVEONLY commit. These are removed in #21206.\n-    \"wallet/receive -> wallet/wallet -> wallet/receive\"\n-    \"wallet/spend -> wallet/wallet -> wallet/spend\"\n )\n \n EXIT_CODE=0"
      }
    ]
  }
]