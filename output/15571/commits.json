[
  {
    "sha": "743b49ceaa3803c6b6efdcb32dcab880be617d8d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3NDNiNDljZWFhMzgwM2M2YjZlZmRjYjMyZGNhYjg4MGJlNjE3ZDhk",
    "commit": {
      "author": {
        "name": "Rojar Smith",
        "email": "rojarsmith@gmail.com",
        "date": "2019-03-04T07:10:10Z"
      },
      "committer": {
        "name": "Rojar Smith",
        "email": "rojarsmith@gmail.com",
        "date": "2019-03-04T07:10:10Z"
      },
      "message": "Fixed some times can not remove \"$SUFFIX-dirty\" on version number correctly with git tag using Gitian.",
      "tree": {
        "sha": "364d14f8e7963e4e0094a757b261e95ca978c811",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/364d14f8e7963e4e0094a757b261e95ca978c811"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/743b49ceaa3803c6b6efdcb32dcab880be617d8d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/743b49ceaa3803c6b6efdcb32dcab880be617d8d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/743b49ceaa3803c6b6efdcb32dcab880be617d8d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/743b49ceaa3803c6b6efdcb32dcab880be617d8d/comments",
    "author": {
      "login": "rojarsmith",
      "id": 10322636,
      "node_id": "MDQ6VXNlcjEwMzIyNjM2",
      "avatar_url": "https://avatars.githubusercontent.com/u/10322636?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rojarsmith",
      "html_url": "https://github.com/rojarsmith",
      "followers_url": "https://api.github.com/users/rojarsmith/followers",
      "following_url": "https://api.github.com/users/rojarsmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/rojarsmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rojarsmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rojarsmith/subscriptions",
      "organizations_url": "https://api.github.com/users/rojarsmith/orgs",
      "repos_url": "https://api.github.com/users/rojarsmith/repos",
      "events_url": "https://api.github.com/users/rojarsmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rojarsmith/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "rojarsmith",
      "id": 10322636,
      "node_id": "MDQ6VXNlcjEwMzIyNjM2",
      "avatar_url": "https://avatars.githubusercontent.com/u/10322636?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rojarsmith",
      "html_url": "https://github.com/rojarsmith",
      "followers_url": "https://api.github.com/users/rojarsmith/followers",
      "following_url": "https://api.github.com/users/rojarsmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/rojarsmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rojarsmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rojarsmith/subscriptions",
      "organizations_url": "https://api.github.com/users/rojarsmith/orgs",
      "repos_url": "https://api.github.com/users/rojarsmith/repos",
      "events_url": "https://api.github.com/users/rojarsmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rojarsmith/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2d46f1be0c3c8b7287aa1f62bb1f5b4a8d00ff6e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2d46f1be0c3c8b7287aa1f62bb1f5b4a8d00ff6e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2d46f1be0c3c8b7287aa1f62bb1f5b4a8d00ff6e"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 1,
      "deletions": 0
    },
    "files": [
      {
        "sha": "a1f6c1db62cacabd8689769eb522716913c5a4d4",
        "filename": "share/genbuild.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/743b49ceaa3803c6b6efdcb32dcab880be617d8d/share/genbuild.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/743b49ceaa3803c6b6efdcb32dcab880be617d8d/share/genbuild.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/genbuild.sh?ref=743b49ceaa3803c6b6efdcb32dcab880be617d8d",
        "patch": "@@ -31,6 +31,7 @@ if [ \"${BITCOIN_GENBUILD_NO_GIT}\" != \"1\" -a -e \"$(which git 2>/dev/null)\" -a \"$(\n     # if latest commit is tagged and not dirty, then override using the tag name\n     RAWDESC=$(git describe --abbrev=0 2>/dev/null)\n     if [ \"$(git rev-parse HEAD)\" = \"$(git rev-list -1 $RAWDESC 2>/dev/null)\" ]; then\n+        git checkout .\n         git diff-index --quiet HEAD -- && DESC=$RAWDESC\n     fi\n "
      }
    ]
  },
  {
    "sha": "46a2535615f8139e2ca9a37c3f5df32dd9ae07b0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NmEyNTM1NjE1ZjgxMzllMmNhOWEzN2MzZjVkZjMyZGQ5YWUwN2Iw",
    "commit": {
      "author": {
        "name": "Rojar Smith",
        "email": "rojarsmith@gmail.com",
        "date": "2019-03-10T05:36:47Z"
      },
      "committer": {
        "name": "Rojar Smith",
        "email": "rojarsmith@gmail.com",
        "date": "2019-03-10T05:36:47Z"
      },
      "message": "Add auto select custom fee when smart fee not initialized.",
      "tree": {
        "sha": "91d6a24833a7673cf8874fc7cf5cef2ee71d4815",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/91d6a24833a7673cf8874fc7cf5cef2ee71d4815"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/46a2535615f8139e2ca9a37c3f5df32dd9ae07b0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/46a2535615f8139e2ca9a37c3f5df32dd9ae07b0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/46a2535615f8139e2ca9a37c3f5df32dd9ae07b0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/46a2535615f8139e2ca9a37c3f5df32dd9ae07b0/comments",
    "author": {
      "login": "rojarsmith",
      "id": 10322636,
      "node_id": "MDQ6VXNlcjEwMzIyNjM2",
      "avatar_url": "https://avatars.githubusercontent.com/u/10322636?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rojarsmith",
      "html_url": "https://github.com/rojarsmith",
      "followers_url": "https://api.github.com/users/rojarsmith/followers",
      "following_url": "https://api.github.com/users/rojarsmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/rojarsmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rojarsmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rojarsmith/subscriptions",
      "organizations_url": "https://api.github.com/users/rojarsmith/orgs",
      "repos_url": "https://api.github.com/users/rojarsmith/repos",
      "events_url": "https://api.github.com/users/rojarsmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rojarsmith/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "rojarsmith",
      "id": 10322636,
      "node_id": "MDQ6VXNlcjEwMzIyNjM2",
      "avatar_url": "https://avatars.githubusercontent.com/u/10322636?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rojarsmith",
      "html_url": "https://github.com/rojarsmith",
      "followers_url": "https://api.github.com/users/rojarsmith/followers",
      "following_url": "https://api.github.com/users/rojarsmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/rojarsmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rojarsmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rojarsmith/subscriptions",
      "organizations_url": "https://api.github.com/users/rojarsmith/orgs",
      "repos_url": "https://api.github.com/users/rojarsmith/repos",
      "events_url": "https://api.github.com/users/rojarsmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rojarsmith/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "743b49ceaa3803c6b6efdcb32dcab880be617d8d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/743b49ceaa3803c6b6efdcb32dcab880be617d8d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/743b49ceaa3803c6b6efdcb32dcab880be617d8d"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 1,
      "deletions": 0
    },
    "files": [
      {
        "sha": "2febdd1ccdc7f42516235d5ebb3c8164b667dd58",
        "filename": "src/qt/sendcoinsdialog.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46a2535615f8139e2ca9a37c3f5df32dd9ae07b0/src/qt/sendcoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46a2535615f8139e2ca9a37c3f5df32dd9ae07b0/src/qt/sendcoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.cpp?ref=46a2535615f8139e2ca9a37c3f5df32dd9ae07b0",
        "patch": "@@ -697,6 +697,7 @@ void SendCoinsDialog::updateSmartFeeLabel()\n         QColor warning_colour(255 - (lightness / 5), 176 - (lightness / 3), 48 - (lightness / 14));\n         ui->fallbackFeeWarningLabel->setStyleSheet(\"QLabel { color: \" + warning_colour.name() + \"; }\");\n         ui->fallbackFeeWarningLabel->setIndent(QFontMetrics(ui->fallbackFeeWarningLabel->font()).width(\"x\"));\n+        ui->radioCustomFee->setChecked(true);\n     }\n     else\n     {"
      }
    ]
  },
  {
    "sha": "77363e9da04882063a1a4fb465cf5f40c9f7e83f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3NzM2M2U5ZGEwNDg4MjA2M2ExYTRmYjQ2NWNmNWY0MGM5ZjdlODNm",
    "commit": {
      "author": {
        "name": "Rojar Smith",
        "email": "rojarsmith@gmail.com",
        "date": "2019-03-10T06:00:50Z"
      },
      "committer": {
        "name": "Rojar Smith",
        "email": "rojarsmith@gmail.com",
        "date": "2019-03-10T06:00:50Z"
      },
      "message": "Merge branch 'master' of https://github.com/bitcoin/bitcoin",
      "tree": {
        "sha": "fc9cc111d8f4ac5e06f64c2cd3f7eca6485d789c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fc9cc111d8f4ac5e06f64c2cd3f7eca6485d789c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/77363e9da04882063a1a4fb465cf5f40c9f7e83f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/77363e9da04882063a1a4fb465cf5f40c9f7e83f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/77363e9da04882063a1a4fb465cf5f40c9f7e83f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/77363e9da04882063a1a4fb465cf5f40c9f7e83f/comments",
    "author": {
      "login": "rojarsmith",
      "id": 10322636,
      "node_id": "MDQ6VXNlcjEwMzIyNjM2",
      "avatar_url": "https://avatars.githubusercontent.com/u/10322636?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rojarsmith",
      "html_url": "https://github.com/rojarsmith",
      "followers_url": "https://api.github.com/users/rojarsmith/followers",
      "following_url": "https://api.github.com/users/rojarsmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/rojarsmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rojarsmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rojarsmith/subscriptions",
      "organizations_url": "https://api.github.com/users/rojarsmith/orgs",
      "repos_url": "https://api.github.com/users/rojarsmith/repos",
      "events_url": "https://api.github.com/users/rojarsmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rojarsmith/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "rojarsmith",
      "id": 10322636,
      "node_id": "MDQ6VXNlcjEwMzIyNjM2",
      "avatar_url": "https://avatars.githubusercontent.com/u/10322636?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rojarsmith",
      "html_url": "https://github.com/rojarsmith",
      "followers_url": "https://api.github.com/users/rojarsmith/followers",
      "following_url": "https://api.github.com/users/rojarsmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/rojarsmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rojarsmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rojarsmith/subscriptions",
      "organizations_url": "https://api.github.com/users/rojarsmith/orgs",
      "repos_url": "https://api.github.com/users/rojarsmith/repos",
      "events_url": "https://api.github.com/users/rojarsmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rojarsmith/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "46a2535615f8139e2ca9a37c3f5df32dd9ae07b0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/46a2535615f8139e2ca9a37c3f5df32dd9ae07b0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/46a2535615f8139e2ca9a37c3f5df32dd9ae07b0"
      },
      {
        "sha": "257f750cd986641afe04316ed0b22b646b56b60b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/257f750cd986641afe04316ed0b22b646b56b60b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/257f750cd986641afe04316ed0b22b646b56b60b"
      }
    ],
    "stats": {
      "total": 3051,
      "additions": 1599,
      "deletions": 1452
    },
    "files": [
      {
        "sha": "c49282585a030b902316d2b71a73b15b5840aaa2",
        "filename": ".python-version",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/.python-version",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/.python-version",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.python-version?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1 +1 @@\n-3.4.9\n+3.5.6"
      },
      {
        "sha": "fe6227baf66b7c25de1195d9242a14b365f2be14",
        "filename": ".style.yapf",
        "status": "added",
        "additions": 261,
        "deletions": 0,
        "changes": 261,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/.style.yapf",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/.style.yapf",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.style.yapf?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -0,0 +1,261 @@\n+[style]\n+# Align closing bracket with visual indentation.\n+align_closing_bracket_with_visual_indent=True\n+\n+# Allow dictionary keys to exist on multiple lines. For example:\n+#\n+#   x = {\n+#       ('this is the first element of a tuple',\n+#        'this is the second element of a tuple'):\n+#            value,\n+#   }\n+allow_multiline_dictionary_keys=False\n+\n+# Allow lambdas to be formatted on more than one line.\n+allow_multiline_lambdas=False\n+\n+# Allow splits before the dictionary value.\n+allow_split_before_dict_value=True\n+\n+# Number of blank lines surrounding top-level function and class\n+# definitions.\n+blank_lines_around_top_level_definition=2\n+\n+# Insert a blank line before a class-level docstring.\n+blank_line_before_class_docstring=False\n+\n+# Insert a blank line before a module docstring.\n+blank_line_before_module_docstring=False\n+\n+# Insert a blank line before a 'def' or 'class' immediately nested\n+# within another 'def' or 'class'. For example:\n+#\n+#   class Foo:\n+#                      # <------ this blank line\n+#     def method():\n+#       ...\n+blank_line_before_nested_class_or_def=False\n+\n+# Do not split consecutive brackets. Only relevant when\n+# dedent_closing_brackets is set. For example:\n+#\n+#    call_func_that_takes_a_dict(\n+#        {\n+#            'key1': 'value1',\n+#            'key2': 'value2',\n+#        }\n+#    )\n+#\n+# would reformat to:\n+#\n+#    call_func_that_takes_a_dict({\n+#        'key1': 'value1',\n+#        'key2': 'value2',\n+#    })\n+coalesce_brackets=False\n+\n+# The column limit.\n+column_limit=79\n+\n+# The style for continuation alignment. Possible values are:\n+#\n+# - SPACE: Use spaces for continuation alignment. This is default behavior.\n+# - FIXED: Use fixed number (CONTINUATION_INDENT_WIDTH) of columns\n+#   (ie: CONTINUATION_INDENT_WIDTH/INDENT_WIDTH tabs) for continuation\n+#   alignment.\n+# - LESS: Slightly left if cannot vertically align continuation lines with\n+#   indent characters.\n+# - VALIGN-RIGHT: Vertically align continuation lines with indent\n+#   characters. Slightly right (one more indent character) if cannot\n+#   vertically align continuation lines with indent characters.\n+#\n+# For options FIXED, and VALIGN-RIGHT are only available when USE_TABS is\n+# enabled.\n+continuation_align_style=SPACE\n+\n+# Indent width used for line continuations.\n+continuation_indent_width=4\n+\n+# Put closing brackets on a separate line, dedented, if the bracketed\n+# expression can't fit in a single line. Applies to all kinds of brackets,\n+# including function definitions and calls. For example:\n+#\n+#   config = {\n+#       'key1': 'value1',\n+#       'key2': 'value2',\n+#   }        # <--- this bracket is dedented and on a separate line\n+#\n+#   time_series = self.remote_client.query_entity_counters(\n+#       entity='dev3246.region1',\n+#       key='dns.query_latency_tcp',\n+#       transform=Transformation.AVERAGE(window=timedelta(seconds=60)),\n+#       start_ts=now()-timedelta(days=3),\n+#       end_ts=now(),\n+#   )        # <--- this bracket is dedented and on a separate line\n+dedent_closing_brackets=False\n+\n+# Disable the heuristic which places each list element on a separate line\n+# if the list is comma-terminated.\n+disable_ending_comma_heuristic=False\n+\n+# Place each dictionary entry onto its own line.\n+each_dict_entry_on_separate_line=True\n+\n+# The regex for an i18n comment. The presence of this comment stops\n+# reformatting of that line, because the comments are required to be\n+# next to the string they translate.\n+i18n_comment=\n+\n+# The i18n function call names. The presence of this function stops\n+# reformattting on that line, because the string it has cannot be moved\n+# away from the i18n comment.\n+i18n_function_call=\n+\n+# Indent the dictionary value if it cannot fit on the same line as the\n+# dictionary key. For example:\n+#\n+#   config = {\n+#       'key1':\n+#           'value1',\n+#       'key2': value1 +\n+#               value2,\n+#   }\n+indent_dictionary_value=False\n+\n+# The number of columns to use for indentation.\n+indent_width=4\n+\n+# Join short lines into one line. E.g., single line 'if' statements.\n+join_multiple_lines=True\n+\n+# Do not include spaces around selected binary operators. For example:\n+#\n+#   1 + 2 * 3 - 4 / 5\n+#\n+# will be formatted as follows when configured with \"*,/\":\n+#\n+#   1 + 2*3 - 4/5\n+#\n+no_spaces_around_selected_binary_operators=\n+\n+# Use spaces around default or named assigns.\n+spaces_around_default_or_named_assign=False\n+\n+# Use spaces around the power operator.\n+spaces_around_power_operator=False\n+\n+# The number of spaces required before a trailing comment.\n+spaces_before_comment=2\n+\n+# Insert a space between the ending comma and closing bracket of a list,\n+# etc.\n+space_between_ending_comma_and_closing_bracket=True\n+\n+# Split before arguments\n+split_all_comma_separated_values=False\n+\n+# Split before arguments if the argument list is terminated by a\n+# comma.\n+split_arguments_when_comma_terminated=False\n+\n+# Set to True to prefer splitting before '&', '|' or '^' rather than\n+# after.\n+split_before_bitwise_operator=True\n+\n+# Split before the closing bracket if a list or dict literal doesn't fit on\n+# a single line.\n+split_before_closing_bracket=True\n+\n+# Split before a dictionary or set generator (comp_for). For example, note\n+# the split before the 'for':\n+#\n+#   foo = {\n+#       variable: 'Hello world, have a nice day!'\n+#       for variable in bar if variable != 42\n+#   }\n+split_before_dict_set_generator=True\n+\n+# Split before the '.' if we need to split a longer expression:\n+#\n+#   foo = ('This is a really long string: {}, {}, {}, {}'.format(a, b, c, d))\n+#\n+# would reformat to something like:\n+#\n+#   foo = ('This is a really long string: {}, {}, {}, {}'\n+#          .format(a, b, c, d))\n+split_before_dot=False\n+\n+# Split after the opening paren which surrounds an expression if it doesn't\n+# fit on a single line.\n+split_before_expression_after_opening_paren=False\n+\n+# If an argument / parameter list is going to be split, then split before\n+# the first argument.\n+split_before_first_argument=False\n+\n+# Set to True to prefer splitting before 'and' or 'or' rather than\n+# after.\n+split_before_logical_operator=True\n+\n+# Split named assignments onto individual lines.\n+split_before_named_assigns=True\n+\n+# Set to True to split list comprehensions and generators that have\n+# non-trivial expressions and multiple clauses before each of these\n+# clauses. For example:\n+#\n+#   result = [\n+#       a_long_var + 100 for a_long_var in xrange(1000)\n+#       if a_long_var % 10]\n+#\n+# would reformat to something like:\n+#\n+#   result = [\n+#       a_long_var + 100\n+#       for a_long_var in xrange(1000)\n+#       if a_long_var % 10]\n+split_complex_comprehension=False\n+\n+# The penalty for splitting right after the opening bracket.\n+split_penalty_after_opening_bracket=30\n+\n+# The penalty for splitting the line after a unary operator.\n+split_penalty_after_unary_operator=10000\n+\n+# The penalty for splitting right before an if expression.\n+split_penalty_before_if_expr=0\n+\n+# The penalty of splitting the line around the '&', '|', and '^'\n+# operators.\n+split_penalty_bitwise_operator=300\n+\n+# The penalty for splitting a list comprehension or generator\n+# expression.\n+split_penalty_comprehension=80\n+\n+# The penalty for characters over the column limit.\n+split_penalty_excess_character=7000\n+\n+# The penalty incurred by adding a line split to the unwrapped line. The\n+# more line splits added the higher the penalty.\n+split_penalty_for_added_line_split=30\n+\n+# The penalty of splitting a list of \"import as\" names. For example:\n+#\n+#   from a_very_long_or_indented_module_name_yada_yad import (long_argument_1,\n+#                                                             long_argument_2,\n+#                                                             long_argument_3)\n+#\n+# would reformat to something like:\n+#\n+#   from a_very_long_or_indented_module_name_yada_yad import (\n+#       long_argument_1, long_argument_2, long_argument_3)\n+split_penalty_import_names=0\n+\n+# The penalty of splitting the line around the 'and' and 'or'\n+# operators.\n+split_penalty_logical_operator=300\n+\n+# Use the Tab character for indentation.\n+use_tabs=False\n+"
      },
      {
        "sha": "fea6b6d7bf4341e20071360c4d5f7325eb42dd59",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -46,7 +46,7 @@ jobs:\n       env:\n       cache: false\n       language: python\n-      python: '3.4' # Oldest supported version according to doc/dependencies.md\n+      python: '3.5' # Oldest supported version according to doc/dependencies.md\n       install:\n         - set -o errexit; source .travis/lint_04_install.sh\n       before_script:\n@@ -158,7 +158,7 @@ jobs:\n       name: 'macOS 10.10  [GOAL: deploy] [no functional tests]'\n       env: >-\n         HOST=x86_64-apple-darwin14\n-        PACKAGES=\"cmake imagemagick libcap-dev librsvg2-bin libz-dev libbz2-dev libtiff-tools python-dev python3-setuptools-git\"\n+        PACKAGES=\"cmake imagemagick libcap-dev librsvg2-bin libz-dev libbz2-dev libtiff-tools python3-dev python3-setuptools-git\"\n         OSX_SDK=10.11\n         RUN_UNIT_TESTS=false\n         RUN_FUNCTIONAL_TESTS=false"
      },
      {
        "sha": "0723243cd78010840797fa326119403ed6485d02",
        "filename": "build_msvc/bench_bitcoin/bench_bitcoin.vcxproj",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/build_msvc/bench_bitcoin/bench_bitcoin.vcxproj",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/build_msvc/bench_bitcoin/bench_bitcoin.vcxproj",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/bench_bitcoin/bench_bitcoin.vcxproj?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -32,6 +32,7 @@\n     <ClCompile Include=\"..\\..\\src\\bench\\examples.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\bench\\lockedpool.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\bench\\mempool_eviction.cpp\" />\n+    <ClCompile Include=\"..\\..\\src\\bench\\rpc_mempool.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\bench\\merkle_root.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\bench\\rollingbloom.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\bench\\verify_script.cpp\" />"
      },
      {
        "sha": "a08e708f8116dd758941263ff1aba94c063cd31f",
        "filename": "build_msvc/test_bitcoin/test_bitcoin.vcxproj",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/build_msvc/test_bitcoin/test_bitcoin.vcxproj",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/build_msvc/test_bitcoin/test_bitcoin.vcxproj",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/test_bitcoin/test_bitcoin.vcxproj?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -25,7 +25,7 @@\n     <ClCompile Include=\"..\\..\\src\\test\\gen\\*_gen.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\wallet\\test\\*_tests.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\test\\test_bitcoin.cpp\" />\n-    <ClCompile Include=\"..\\..\\src\\test\\test_bitcoin_main.cpp\" />\n+    <ClCompile Include=\"..\\..\\src\\test\\main.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\wallet\\test\\*_fixture.cpp\" />\n   </ItemGroup>\n   <ItemGroup>"
      },
      {
        "sha": "a3ba8ce8085485f19f82a233b6f91aac056cd07a",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -85,8 +85,8 @@ AC_PATH_TOOL(RANLIB, ranlib)\n AC_PATH_TOOL(STRIP, strip)\n AC_PATH_TOOL(GCOV, gcov)\n AC_PATH_PROG(LCOV, lcov)\n-dnl Python 3.4 is specified in .python-version and should be used if available, see doc/dependencies.md\n-AC_PATH_PROGS([PYTHON], [python3.4 python3.5 python3.6 python3.7 python3 python])\n+dnl Python 3.5 is specified in .python-version and should be used if available, see doc/dependencies.md\n+AC_PATH_PROGS([PYTHON], [python3.5 python3.6 python3.7 python3.8 python3 python])\n AC_PATH_PROG(GENHTML, genhtml)\n AC_PATH_PROG([GIT], [git])\n AC_PATH_PROG(CCACHE,ccache)"
      },
      {
        "sha": "d66eff66bec4a6f04016161dcbaddc9d58149325",
        "filename": "contrib/devtools/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/contrib/devtools/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/contrib/devtools/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/README.md?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -167,7 +167,7 @@ still compatible with the minimum supported Linux distribution versions.\n \n Example usage after a gitian build:\n \n-    find ../gitian-builder/build -type f -executable | xargs python contrib/devtools/symbol-check.py \n+    find ../gitian-builder/build -type f -executable | xargs python3 contrib/devtools/symbol-check.py\n \n If only supported symbols are used the return value will be 0 and the output will be empty.\n "
      },
      {
        "sha": "2e4657f1dd5433ad130f06cdf4d1c64a33f75960",
        "filename": "contrib/devtools/circular-dependencies.py",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/contrib/devtools/circular-dependencies.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/contrib/devtools/circular-dependencies.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/circular-dependencies.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -8,9 +8,18 @@\n     'core_write.cpp': 'core_io.cpp',\n }\n \n+# Directories with header-based modules, where the assumption that .cpp files\n+# define functions and variables declared in corresponding .h files is\n+# incorrect.\n+HEADER_MODULE_PATHS = [\n+    'interfaces/'\n+]\n+\n def module_name(path):\n     if path in MAPPING:\n         path = MAPPING[path]\n+    if any(path.startswith(dirpath) for dirpath in HEADER_MODULE_PATHS):\n+        return path\n     if path.endswith(\".h\"):\n         return path[:-2]\n     if path.endswith(\".c\"):"
      },
      {
        "sha": "92b72b1446cf6bacf92723b6a8da8786c0802557",
        "filename": "contrib/devtools/split-debug.sh.in",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/contrib/devtools/split-debug.sh.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/contrib/devtools/split-debug.sh.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/split-debug.sh.in?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/bin/sh\n-\n+set -e\n if [ $# -ne 3 ];\n     then echo \"usage: $0 <input> <stripped-binary> <debug-binary>\"\n fi"
      },
      {
        "sha": "7729dd7257dda0dd7d1e56f05c6acb2843a6bf87",
        "filename": "contrib/devtools/symbol-check.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/contrib/devtools/symbol-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/contrib/devtools/symbol-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/symbol-check.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -9,7 +9,7 @@\n \n Example usage:\n \n-    find ../gitian-builder/build -type f -executable | xargs python contrib/devtools/symbol-check.py\n+    find ../gitian-builder/build -type f -executable | xargs python3 contrib/devtools/symbol-check.py\n '''\n import subprocess\n import re"
      },
      {
        "sha": "43612d4b36ede2cca690fbe4eb99cbab1cb24ebf",
        "filename": "contrib/gitian-descriptors/gitian-linux.yml",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/contrib/gitian-descriptors/gitian-linux.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/contrib/gitian-descriptors/gitian-linux.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-linux.yml?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n ---\n-name: \"bitcoin-linux-0.18\"\n+name: \"bitcoin-core-linux-0.19\"\n enable_cache: true\n suites:\n - \"bionic\"\n@@ -30,12 +30,13 @@ packages:\n - \"faketime\"\n - \"bsdmainutils\"\n - \"ca-certificates\"\n-- \"python\"\n+- \"python3\"\n remotes:\n - \"url\": \"https://github.com/bitcoin/bitcoin.git\"\n   \"dir\": \"bitcoin\"\n files: []\n script: |\n+  set -e -o pipefail\n \n   WRAP_DIR=$HOME/wrapped\n   HOSTS=\"i686-pc-linux-gnu x86_64-linux-gnu arm-linux-gnueabihf aarch64-linux-gnu riscv64-linux-gnu\"\n@@ -179,8 +180,8 @@ script: |\n     find . -name \"lib*.la\" -delete\n     find . -name \"lib*.a\" -delete\n     rm -rf ${DISTNAME}/lib/pkgconfig\n-    find ${DISTNAME}/bin -type f -executable -exec ../contrib/devtools/split-debug.sh {} {} {}.dbg \\;\n-    find ${DISTNAME}/lib -type f -exec ../contrib/devtools/split-debug.sh {} {} {}.dbg \\;\n+    find ${DISTNAME}/bin -type f -executable -print0 | xargs -0 -n1 -I{} ../contrib/devtools/split-debug.sh {} {} {}.dbg\n+    find ${DISTNAME}/lib -type f -print0 | xargs -0 -n1 -I{} ../contrib/devtools/split-debug.sh {} {} {}.dbg\n     cp ../doc/README.md ${DISTNAME}/\n     find ${DISTNAME} -not -name \"*.dbg\" | sort | tar --no-recursion --mode='u+rw,go+r-w,a+X' --owner=0 --group=0 -c -T - | gzip -9n > ${OUTDIR}/${DISTNAME}-${i}.tar.gz\n     find ${DISTNAME} -name \"*.dbg\" | sort | tar --no-recursion --mode='u+rw,go+r-w,a+X' --owner=0 --group=0 -c -T - | gzip -9n > ${OUTDIR}/${DISTNAME}-${i}-debug.tar.gz"
      },
      {
        "sha": "df6cddbf03dcf3c6c0f9a48edc23f54c812b6cd1",
        "filename": "contrib/gitian-descriptors/gitian-osx-signer.yml",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/contrib/gitian-descriptors/gitian-osx-signer.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/contrib/gitian-descriptors/gitian-osx-signer.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-osx-signer.yml?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -12,6 +12,8 @@ remotes:\n files:\n - \"bitcoin-osx-unsigned.tar.gz\"\n script: |\n+  set -e -o pipefail\n+\n   WRAP_DIR=$HOME/wrapped\n   mkdir -p ${WRAP_DIR}\n   export PATH=`pwd`:$PATH"
      },
      {
        "sha": "2d18d0a3594e133c3a1bc72ed8844190259028fb",
        "filename": "contrib/gitian-descriptors/gitian-osx.yml",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/contrib/gitian-descriptors/gitian-osx.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/contrib/gitian-descriptors/gitian-osx.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-osx.yml?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n ---\n-name: \"bitcoin-osx-0.18\"\n+name: \"bitcoin-core-osx-0.19\"\n enable_cache: true\n suites:\n - \"bionic\"\n@@ -23,16 +23,18 @@ packages:\n - \"libcap-dev\"\n - \"libz-dev\"\n - \"libbz2-dev\"\n-- \"python\"\n-- \"python-dev\"\n-- \"python-setuptools\"\n+- \"python3\"\n+- \"python3-dev\"\n+- \"python3-setuptools\"\n - \"fonts-tuffy\"\n remotes:\n - \"url\": \"https://github.com/bitcoin/bitcoin.git\"\n   \"dir\": \"bitcoin\"\n files:\n - \"MacOSX10.11.sdk.tar.gz\"\n script: |\n+  set -e -o pipefail\n+\n   WRAP_DIR=$HOME/wrapped\n   HOSTS=\"x86_64-apple-darwin14\"\n   CONFIGFLAGS=\"--enable-reduce-exports --disable-bench --disable-gui-tests GENISOIMAGE=$WRAP_DIR/genisoimage\""
      },
      {
        "sha": "08d20177a69298023aa183e2364d2eb652f701b3",
        "filename": "contrib/gitian-descriptors/gitian-win-signer.yml",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/contrib/gitian-descriptors/gitian-win-signer.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/contrib/gitian-descriptors/gitian-win-signer.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-win-signer.yml?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -16,6 +16,8 @@ files:\n - \"osslsigncode-Backports-to-1.7.1.patch\"\n - \"bitcoin-win-unsigned.tar.gz\"\n script: |\n+  set -e -o pipefail\n+\n   BUILD_DIR=`pwd`\n   SIGDIR=${BUILD_DIR}/signature/win\n   UNSIGNED_DIR=${BUILD_DIR}/unsigned"
      },
      {
        "sha": "b80592903551f316356574d46ad20bb4d900ac26",
        "filename": "contrib/gitian-descriptors/gitian-win.yml",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/contrib/gitian-descriptors/gitian-win.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/contrib/gitian-descriptors/gitian-win.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-win.yml?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n ---\n-name: \"bitcoin-win-0.18\"\n+name: \"bitcoin-core-win-0.19\"\n enable_cache: true\n suites:\n - \"bionic\"\n@@ -20,13 +20,15 @@ packages:\n - \"nsis\"\n - \"zip\"\n - \"ca-certificates\"\n-- \"python\"\n+- \"python3\"\n - \"rename\"\n remotes:\n - \"url\": \"https://github.com/bitcoin/bitcoin.git\"\n   \"dir\": \"bitcoin\"\n files: []\n script: |\n+  set -e -o pipefail\n+\n   WRAP_DIR=$HOME/wrapped\n   HOSTS=\"i686-w64-mingw32 x86_64-w64-mingw32\"\n   CONFIGFLAGS=\"--enable-reduce-exports --disable-bench --disable-gui-tests\""
      },
      {
        "sha": "25a1c7351a297c751d630acd3f97fff6091710c8",
        "filename": "contrib/linearize/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/contrib/linearize/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/contrib/linearize/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/linearize/README.md?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,6 +1,5 @@\n # Linearize\n-Construct a linear, no-fork, best version of the Bitcoin blockchain. The scripts\n-run using Python 3 but are compatible with Python 2.\n+Construct a linear, no-fork, best version of the Bitcoin blockchain.\n \n ## Step 1: Download hash list\n "
      },
      {
        "sha": "468aec04b535088ddc4138dd6f8d1d8749a4739e",
        "filename": "contrib/linearize/linearize-data.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/contrib/linearize/linearize-data.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/contrib/linearize/linearize-data.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/linearize/linearize-data.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -16,7 +16,7 @@\n import datetime\n import time\n from collections import namedtuple\n-from binascii import hexlify, unhexlify\n+from binascii import unhexlify\n \n settings = {}\n \n@@ -61,7 +61,7 @@ def calc_hash_str(blk_hdr):\n     hash = calc_hdr_hash(blk_hdr)\n     hash = bufreverse(hash)\n     hash = wordreverse(hash)\n-    hash_str = hexlify(hash).decode('utf-8')\n+    hash_str = hash.hex()\n     return hash_str\n \n def get_blk_dt(blk_hdr):\n@@ -213,7 +213,7 @@ def run(self):\n \n             inMagic = inhdr[:4]\n             if (inMagic != self.settings['netmagic']):\n-                print(\"Invalid magic: \" + hexlify(inMagic).decode('utf-8'))\n+                print(\"Invalid magic: \" + inMagic.hex())\n                 return\n             inLenLE = inhdr[4:]\n             su = struct.unpack(\"<I\", inLenLE)"
      },
      {
        "sha": "66fdf7887fe97d829270513e83ac2de67f08c0a1",
        "filename": "contrib/zmq/zmq_sub3.4.py",
        "status": "removed",
        "additions": 0,
        "deletions": 90,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46a2535615f8139e2ca9a37c3f5df32dd9ae07b0/contrib/zmq/zmq_sub3.4.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46a2535615f8139e2ca9a37c3f5df32dd9ae07b0/contrib/zmq/zmq_sub3.4.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/zmq/zmq_sub3.4.py?ref=46a2535615f8139e2ca9a37c3f5df32dd9ae07b0",
        "patch": "@@ -1,90 +0,0 @@\n-#!/usr/bin/env python3\n-# Copyright (c) 2014-2018 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-\"\"\"\n-    ZMQ example using python3's asyncio\n-\n-    Bitcoin should be started with the command line arguments:\n-        bitcoind -testnet -daemon \\\n-                -zmqpubrawtx=tcp://127.0.0.1:28332 \\\n-                -zmqpubrawblock=tcp://127.0.0.1:28332 \\\n-                -zmqpubhashtx=tcp://127.0.0.1:28332 \\\n-                -zmqpubhashblock=tcp://127.0.0.1:28332\n-\n-    We use the asyncio library here.  `self.handle()` installs itself as a\n-    future at the end of the function.  Since it never returns with the event\n-    loop having an empty stack of futures, this creates an infinite loop.  An\n-    alternative is to wrap the contents of `handle` inside `while True`.\n-\n-    The `@asyncio.coroutine` decorator and the `yield from` syntax found here\n-    was introduced in python 3.4 and has been deprecated in favor of the `async`\n-    and `await` keywords respectively.\n-\n-    A blocking example using python 2.7 can be obtained from the git history:\n-    https://github.com/bitcoin/bitcoin/blob/37a7fe9e440b83e2364d5498931253937abe9294/contrib/zmq/zmq_sub.py\n-\"\"\"\n-\n-import binascii\n-import asyncio\n-import zmq\n-import zmq.asyncio\n-import signal\n-import struct\n-import sys\n-\n-if (sys.version_info.major, sys.version_info.minor) < (3, 4):\n-    print(\"This example only works with Python 3.4 and greater\")\n-    sys.exit(1)\n-\n-port = 28332\n-\n-class ZMQHandler():\n-    def __init__(self):\n-        self.loop = asyncio.get_event_loop()\n-        self.zmqContext = zmq.asyncio.Context()\n-\n-        self.zmqSubSocket = self.zmqContext.socket(zmq.SUB)\n-        self.zmqSubSocket.setsockopt(zmq.RCVHWM, 0)\n-        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"hashblock\")\n-        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"hashtx\")\n-        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawblock\")\n-        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawtx\")\n-        self.zmqSubSocket.connect(\"tcp://127.0.0.1:%i\" % port)\n-\n-    @asyncio.coroutine\n-    def handle(self) :\n-        msg = yield from self.zmqSubSocket.recv_multipart()\n-        topic = msg[0]\n-        body = msg[1]\n-        sequence = \"Unknown\"\n-        if len(msg[-1]) == 4:\n-          msgSequence = struct.unpack('<I', msg[-1])[-1]\n-          sequence = str(msgSequence)\n-        if topic == b\"hashblock\":\n-            print('- HASH BLOCK ('+sequence+') -')\n-            print(binascii.hexlify(body))\n-        elif topic == b\"hashtx\":\n-            print('- HASH TX  ('+sequence+') -')\n-            print(binascii.hexlify(body))\n-        elif topic == b\"rawblock\":\n-            print('- RAW BLOCK HEADER ('+sequence+') -')\n-            print(binascii.hexlify(body[:80]))\n-        elif topic == b\"rawtx\":\n-            print('- RAW TX ('+sequence+') -')\n-            print(binascii.hexlify(body))\n-        # schedule ourselves to receive the next message\n-        asyncio.ensure_future(self.handle())\n-\n-    def start(self):\n-        self.loop.add_signal_handler(signal.SIGINT, self.stop)\n-        self.loop.create_task(self.handle())\n-        self.loop.run_forever()\n-\n-    def stop(self):\n-        self.loop.stop()\n-        self.zmqContext.destroy()\n-\n-daemon = ZMQHandler()\n-daemon.start()"
      },
      {
        "sha": "b69584193a6d5745d11f8a5f8d8b0564f90e62ee",
        "filename": "depends/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/depends/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/depends/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/README.md?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -34,7 +34,7 @@ No other options are needed, the paths are automatically configured.\n \n #### For macOS cross compilation\n \n-    sudo apt-get install curl librsvg2-bin libtiff-tools bsdmainutils cmake imagemagick libcap-dev libz-dev libbz2-dev python-setuptools\n+    sudo apt-get install curl librsvg2-bin libtiff-tools bsdmainutils cmake imagemagick libcap-dev libz-dev libbz2-dev python3-setuptools\n \n #### For Win32/Win64 cross compilation\n "
      },
      {
        "sha": "da65bc347a16ef0e3a753d7685fcb9a786812d37",
        "filename": "doc/build-unix.md",
        "status": "modified",
        "additions": 2,
        "deletions": 8,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/doc/build-unix.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/doc/build-unix.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-unix.md?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -78,19 +78,13 @@ Now, you can either build from self-compiled [depends](/depends/README.md) or in\n \n BerkeleyDB is required for the wallet.\n \n-**For Ubuntu only:** db4.8 packages are available [here](https://launchpad.net/~bitcoin/+archive/bitcoin).\n-You can add the repository and install using the following commands:\n-\n-    sudo apt-get install software-properties-common\n-    sudo add-apt-repository ppa:bitcoin/bitcoin\n-    sudo apt-get update\n-    sudo apt-get install libdb4.8-dev libdb4.8++-dev\n-\n Ubuntu and Debian have their own libdb-dev and libdb++-dev packages, but these will install\n BerkeleyDB 5.1 or later. This will break binary wallet compatibility with the distributed executables, which\n are based on BerkeleyDB 4.8. If you do not care about wallet compatibility,\n pass `--with-incompatible-bdb` to configure.\n \n+Otherwise, you can build from self-compiled `depends` (see above).\n+\n To build Bitcoin Core without wallet, see [*Disable-wallet mode*](/doc/build-unix.md#disable-wallet-mode)\n \n "
      },
      {
        "sha": "036c585b4453a51fa68455775ddd766d4df89b72",
        "filename": "doc/build-windows.md",
        "status": "modified",
        "additions": 7,
        "deletions": 10,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/doc/build-windows.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/doc/build-windows.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-windows.md?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -71,6 +71,11 @@ If you want to build the windows installer with `make deploy` you need [NSIS](ht\n \n     sudo apt install nsis\n \n+Acquire the source in the usual way:\n+\n+    git clone https://github.com/bitcoin/bitcoin.git\n+    cd bitcoin\n+\n ## Building for 64-bit Windows\n \n The first step is to install the mingw-w64 cross-compilation tool chain:\n@@ -87,11 +92,7 @@ Note that for WSL the Bitcoin Core source path MUST be somewhere in the default\n example /usr/src/bitcoin, AND not under /mnt/d/. If this is not the case the dependency autoconf scripts will fail.\n This means you cannot use a directory that is located directly on the host Windows file system to perform the build.\n \n-Acquire the source in the usual way:\n-\n-    git clone https://github.com/bitcoin/bitcoin.git\n-\n-Once the source code is ready the build steps are below:\n+Build using:\n \n     PATH=$(echo \"$PATH\" | sed -e 's/:\\/mnt.*//g') # strip out problematic Windows %PATH% imported var\n     cd depends\n@@ -115,11 +116,7 @@ Note that for WSL the Bitcoin Core source path MUST be somewhere in the default\n example /usr/src/bitcoin, AND not under /mnt/d/. If this is not the case the dependency autoconf scripts will fail.\n This means you cannot use a directory that located directly on the host Windows file system to perform the build.\n \n-Acquire the source in the usual way:\n-\n-    git clone https://github.com/bitcoin/bitcoin.git\n-\n-Then build using:\n+Build using:\n \n     PATH=$(echo \"$PATH\" | sed -e 's/:\\/mnt.*//g') # strip out problematic Windows %PATH% imported var\n     cd depends"
      },
      {
        "sha": "0fb36184c240f5477fbb62bbdbfcdcbef1ddef39",
        "filename": "doc/dependencies.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/doc/dependencies.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/doc/dependencies.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/dependencies.md?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -22,7 +22,7 @@ These are the dependencies currently used by Bitcoin Core. You can find instruct\n | OpenSSL | [1.0.1k](https://www.openssl.org/source) |  | Yes |  |  |\n | PCRE |  |  |  |  | [Yes](https://github.com/bitcoin/bitcoin/blob/master/depends/packages/qt.mk#L66) |\n | protobuf | [2.6.1](https://github.com/google/protobuf/releases) |  | No |  |  |\n-| Python (tests) |  | [3.4](https://www.python.org/downloads) |  |  |  |\n+| Python (tests) |  | [3.5](https://www.python.org/downloads) |  |  |  |\n | qrencode | [3.4.4](https://fukuchi.org/works/qrencode) |  | No |  |  |\n | Qt | [5.9.7](https://download.qt.io/official_releases/qt/) | [5.5.1](https://github.com/bitcoin/bitcoin/issues/13478) | No |  |  |\n | XCB |  |  |  |  | [Yes](https://github.com/bitcoin/bitcoin/blob/master/depends/packages/qt.mk#L87) (Linux only) |"
      },
      {
        "sha": "4797a95bdb8cd9cda7f853ce405980ce359f9720",
        "filename": "doc/release-notes-14021.md",
        "status": "removed",
        "additions": 0,
        "deletions": 11,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46a2535615f8139e2ca9a37c3f5df32dd9ae07b0/doc/release-notes-14021.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46a2535615f8139e2ca9a37c3f5df32dd9ae07b0/doc/release-notes-14021.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-14021.md?ref=46a2535615f8139e2ca9a37c3f5df32dd9ae07b0",
        "patch": "@@ -1,11 +0,0 @@\n-Miscellaneous RPC Changes\n--------------------------\n-- Descriptors with key origin information imported through `importmulti` will have their key origin information stored in the wallet for use with creating PSBTs.\n-- If `bip32derivs` of both `walletprocesspsbt` and `walletcreatefundedpsbt` is set to true but the key metadata for a public key has not been updated yet, then that key will have a derivation path as if it were just an independent key (i.e. no derivation path and its master fingerprint is itself)\n-\n-Miscellaneous Wallet changes\n-----------------------------\n-\n-- The key metadata will need to be upgraded the first time that the HD seed is available.\n-For unencrypted wallets this will occur on wallet loading.\n-For encrypted wallets this will occur the first time the wallet is unlocked."
      },
      {
        "sha": "ea8fc3c34ed2a979d8f1a7feeef6fa6136473132",
        "filename": "doc/release-notes-14481.md",
        "status": "removed",
        "additions": 0,
        "deletions": 9,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46a2535615f8139e2ca9a37c3f5df32dd9ae07b0/doc/release-notes-14481.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46a2535615f8139e2ca9a37c3f5df32dd9ae07b0/doc/release-notes-14481.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-14481.md?ref=46a2535615f8139e2ca9a37c3f5df32dd9ae07b0",
        "patch": "@@ -1,9 +0,0 @@\n-Low-level RPC changes\n-----------------------\n-\n-The `listunspent` RPC has been modified so that it also returns `witnessScript`,\n-the witness script in the case of a P2WSH or P2SH-P2WSH output.\n-\n-The `signrawtransactionwithkey` and `signrawtransactionwithwallet` RPCs have been\n-modified so that they also optionally accept a `witnessScript`, the witness script in the\n-case of a P2WSH or P2SH-P2WSH output. This is compatible with the change to `listunspent`."
      },
      {
        "sha": "1cf36e85cffcc2dc88e51964ca0a2a8f565a2ed2",
        "filename": "doc/release-notes-14491.md",
        "status": "removed",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46a2535615f8139e2ca9a37c3f5df32dd9ae07b0/doc/release-notes-14491.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46a2535615f8139e2ca9a37c3f5df32dd9ae07b0/doc/release-notes-14491.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-14491.md?ref=46a2535615f8139e2ca9a37c3f5df32dd9ae07b0",
        "patch": "@@ -1,5 +0,0 @@\n-Descriptor import support\n----------------------\n-\n-The `importmulti` RPC now supports importing of addresses from descriptors. A \"desc\" parameter can be provided instead of the \"scriptPubKey\" in a request, as well as an optional range for ranged descriptors to specify the start and end of the range to import. More information about\n-descriptors can be found [here](https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md)."
      },
      {
        "sha": "5cb1d0aee77ce9678850b37252ee191329fb500f",
        "filename": "doc/release-notes-14667.md",
        "status": "removed",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46a2535615f8139e2ca9a37c3f5df32dd9ae07b0/doc/release-notes-14667.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46a2535615f8139e2ca9a37c3f5df32dd9ae07b0/doc/release-notes-14667.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-14667.md?ref=46a2535615f8139e2ca9a37c3f5df32dd9ae07b0",
        "patch": "@@ -1,4 +0,0 @@\n-New RPC methods\n-------------\n-\n-- `deriveaddresses` returns one or more addresses corresponding to an [output descriptor](/doc/descriptors.md)."
      },
      {
        "sha": "3be84db3e9b88cf82ab9c30805d0c1a4b2c8ffd6",
        "filename": "doc/release-notes-15226.md",
        "status": "removed",
        "additions": 0,
        "deletions": 8,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46a2535615f8139e2ca9a37c3f5df32dd9ae07b0/doc/release-notes-15226.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46a2535615f8139e2ca9a37c3f5df32dd9ae07b0/doc/release-notes-15226.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-15226.md?ref=46a2535615f8139e2ca9a37c3f5df32dd9ae07b0",
        "patch": "@@ -1,8 +0,0 @@\n-Miscellaneous RPC changes\n-------------\n-\n-- The RPC `createwallet` now has an optional `blank` argument that can be used to create a blank wallet.\n-Blank wallets do not have any keys or HD seed.\n-They cannot be opened in software older than 0.18.\n-Once a blank wallet has a HD seed set (by using `sethdseed`) or private keys, scripts, addresses, and other watch only things have been imported, the wallet is no longer blank and can be opened in 0.17.x.\n-Encrypting a blank wallet will also set a HD seed for it."
      },
      {
        "sha": "f478dc798d1592599e71899d2240e9be67b91a61",
        "filename": "doc/release-notes-15393.md",
        "status": "removed",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46a2535615f8139e2ca9a37c3f5df32dd9ae07b0/doc/release-notes-15393.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46a2535615f8139e2ca9a37c3f5df32dd9ae07b0/doc/release-notes-15393.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-15393.md?ref=46a2535615f8139e2ca9a37c3f5df32dd9ae07b0",
        "patch": "@@ -1,4 +0,0 @@\n-Dependencies\n-------------\n-\n-- The minimum required version of QT has been increased from 5.2 to 5.5.1 (the [depends system](https://github.com/bitcoin/bitcoin/blob/master/depends/README.md) provides 5.9.7)"
      },
      {
        "sha": "1149eb0dbcc76c11f2aa0da1a7c9a3365fcfb5a3",
        "filename": "doc/release-notes-15492.md",
        "status": "removed",
        "additions": 0,
        "deletions": 11,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46a2535615f8139e2ca9a37c3f5df32dd9ae07b0/doc/release-notes-15492.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46a2535615f8139e2ca9a37c3f5df32dd9ae07b0/doc/release-notes-15492.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-15492.md?ref=46a2535615f8139e2ca9a37c3f5df32dd9ae07b0",
        "patch": "@@ -1,11 +0,0 @@\n-Deprecated or removed RPCs\n---------------------------\n-- The wallet's `generate` RPC method was deprecated in v0.18 and has now\n-  been fully removed.  This RPC is only used for\n-  testing, but its implementation reached across multiple subsystems\n-  (wallet and mining), so it has been removed to simplify the\n-  wallet-node interface.  Projects that are using `generate` for testing\n-  purposes should transition to using the `generatetoaddress` RPC, which\n-  does not require or use the wallet component. Calling\n-  `generatetoaddress` with an address returned by the `getnewaddress`\n-  RPC gives the same functionality as the old `generate` RPC."
      },
      {
        "sha": "5ac8b44283975b9064e9be004f7bf7fad898b440",
        "filename": "doc/release-notes/release-notes-pr12255.md",
        "status": "removed",
        "additions": 0,
        "deletions": 17,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46a2535615f8139e2ca9a37c3f5df32dd9ae07b0/doc/release-notes/release-notes-pr12255.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46a2535615f8139e2ca9a37c3f5df32dd9ae07b0/doc/release-notes/release-notes-pr12255.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-pr12255.md?ref=46a2535615f8139e2ca9a37c3f5df32dd9ae07b0",
        "patch": "@@ -1,17 +0,0 @@\n-systemd init file\n-=========\n-\n-The systemd init file (`contrib/init/bitcoind.service`) has been changed to use\n-`/var/lib/bitcoind` as the data directory instead of `~bitcoin/.bitcoin`. This\n-change makes Bitcoin Core more consistent with other services, and makes the\n-systemd init config more consistent with existing Upstart and OpenRC configs.\n-\n-The configuration, PID, and data directories are now completely managed by\n-systemd, which will take care of their creation, permissions, etc. See\n-[`systemd.exec (5)`](https://www.freedesktop.org/software/systemd/man/systemd.exec.html#RuntimeDirectory=)\n-for more details.\n-\n-When using the provided init files under `contrib/init`, overriding the\n-`datadir` option in `/etc/bitcoin/bitcoin.conf` will have no effect. This is\n-because the command line arguments specified in the init files take precedence\n-over the options specified in `/etc/bitcoin/bitcoin.conf`."
      },
      {
        "sha": "b5475dc1c68d69e45a6f7a3c09e712bd9051c042",
        "filename": "share/examples/bitcoin.conf",
        "status": "modified",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/share/examples/bitcoin.conf",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/share/examples/bitcoin.conf",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/examples/bitcoin.conf?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -4,6 +4,10 @@\n  \n # Network-related settings:\n \n+# Note that if you use testnet or regtest, particularly with the options\n+# addnode, connect, port, bind, rpcport, rpcbind or wallet, you will also\n+# want to read \"[Sections]\" further down.\n+\n # Run on the test network instead of the real bitcoin network.\n #testnet=0\n \n@@ -53,6 +57,9 @@\n # Listening mode, enabled by default except when 'connect' is being used\n #listen=1\n \n+# Port on which to listen for connections (default: 8333, testnet: 18333, regtest: 18444)\n+#port=\n+\n # Maximum number of inbound+outbound connections.\n #maxconnections=\n \n@@ -115,6 +122,10 @@\n \n # Wallet options\n \n+# Specify where to find wallet, lockfile and logs. If not present, those files will be\n+# created as new.\n+#wallet=</path/to/dir>\n+\n # Create transactions that have enough fees so they are likely to begin confirmation within n blocks (default: 6).\n # This setting is over-ridden by the -paytxfee option.\n #txconfirmtarget=n\n@@ -142,3 +153,19 @@\n \n # Minimize to the system tray\n #minimizetotray=1\n+\n+# [Sections]\n+# Most options apply to mainnet, testnet and regtest.\n+# If you want to confine an option to just one network, you should add it in the\n+# relevant section below.\n+# EXCEPTIONS: The options addnode, connect, port, bind, rpcport, rpcbind and wallet\n+# only apply to mainnet unless they appear in the appropriate section below.\n+\n+# Options only for mainnet\n+[main]\n+\n+# Options only for testnet\n+[test]\n+\n+# Options only for regtest\n+[regtest]"
      },
      {
        "sha": "14db96325335f49d4a7152d6ae64e5aaab8af27e",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -568,12 +568,14 @@ bitcoin_wallet_LDADD = \\\n   $(LIBBITCOIN_CONSENSUS) \\\n   $(LIBBITCOIN_UTIL) \\\n   $(LIBBITCOIN_CRYPTO) \\\n+  $(LIBBITCOIN_ZMQ) \\\n   $(LIBLEVELDB) \\\n   $(LIBLEVELDB_SSE42) \\\n   $(LIBMEMENV) \\\n-  $(LIBSECP256K1)\n+  $(LIBSECP256K1) \\\n+  $(LIBUNIVALUE)\n \n-bitcoin_wallet_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS)\n+bitcoin_wallet_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(CRYPTO_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(MINIUPNPC_LIBS) $(ZMQ_LIBS)\n #\n \n # bitcoinconsensus library #"
      },
      {
        "sha": "3042f6df19d5777e8fe2bdc56d173d464f97bacf",
        "filename": "src/Makefile.bench.include",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/Makefile.bench.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/Makefile.bench.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.bench.include?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -26,6 +26,7 @@ bench_bench_bitcoin_SOURCES = \\\n   bench/gcs_filter.cpp \\\n   bench/merkle_root.cpp \\\n   bench/mempool_eviction.cpp \\\n+  bench/rpc_mempool.cpp \\\n   bench/verify_script.cpp \\\n   bench/base58.cpp \\\n   bench/bech32.cpp \\\n@@ -37,6 +38,7 @@ nodist_bench_bench_bitcoin_SOURCES = $(GENERATED_BENCH_FILES)\n bench_bench_bitcoin_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(EVENT_CLFAGS) $(EVENT_PTHREADS_CFLAGS) -I$(builddir)/bench/\n bench_bench_bitcoin_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n bench_bench_bitcoin_LDADD = \\\n+  $(LIBBITCOIN_SERVER) \\\n   $(LIBBITCOIN_WALLET) \\\n   $(LIBBITCOIN_SERVER) \\\n   $(LIBBITCOIN_COMMON) \\\n@@ -47,7 +49,9 @@ bench_bench_bitcoin_LDADD = \\\n   $(LIBLEVELDB_SSE42) \\\n   $(LIBMEMENV) \\\n   $(LIBSECP256K1) \\\n-  $(LIBUNIVALUE)\n+  $(LIBUNIVALUE) \\\n+  $(EVENT_PTHREADS_LIBS) \\\n+  $(EVENT_LIBS)\n \n if ENABLE_ZMQ\n bench_bench_bitcoin_LDADD += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)\n@@ -57,7 +61,7 @@ if ENABLE_WALLET\n bench_bench_bitcoin_SOURCES += bench/coin_selection.cpp\n endif\n \n-bench_bench_bitcoin_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS)\n+bench_bench_bitcoin_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(CRYPTO_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(MINIUPNPC_LIBS)\n bench_bench_bitcoin_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n \n CLEAN_BITCOIN_BENCH = bench/*.gcda bench/*.gcno $(GENERATED_BENCH_FILES)"
      },
      {
        "sha": "a6e07856160ca5ef503a0a66139ab1cb1f761cf6",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 42,
        "deletions": 255,
        "changes": 297,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -51,14 +51,32 @@ RAW_TEST_FILES =\n GENERATED_TEST_FILES = $(JSON_TEST_FILES:.json=.json.h) $(RAW_TEST_FILES:.raw=.raw.h)\n \n BITCOIN_TEST_SUITE = \\\n-  test/test_bitcoin_main.cpp \\\n+  test/main.cpp \\\n   test/test_bitcoin.h \\\n   test/test_bitcoin.cpp\n \n FUZZ_SUITE = \\\n+  test/test_bitcoin.h \\\n+  test/test_bitcoin.cpp \\\n   test/fuzz/fuzz.cpp \\\n   test/fuzz/fuzz.h\n \n+FUZZ_SUITE_LD_COMMON = \\\n+ $(LIBBITCOIN_SERVER) \\\n+ $(LIBBITCOIN_COMMON) \\\n+ $(LIBBITCOIN_UTIL) \\\n+ $(LIBBITCOIN_CONSENSUS) \\\n+ $(LIBBITCOIN_CRYPTO) \\\n+ $(LIBUNIVALUE) \\\n+ $(LIBLEVELDB) \\\n+ $(LIBLEVELDB_SSE42) \\\n+ $(BOOST_LIBS) \\\n+ $(LIBMEMENV) \\\n+ $(LIBSECP256K1) \\\n+ $(EVENT_LIBS) \\\n+ $(CRYPTO_LIBS) \\\n+ $(EVENT_PTHREADS_LIBS)\n+\n # test_bitcoin binary #\n BITCOIN_TESTS =\\\n   test/arith_uint256_tests.cpp \\\n@@ -91,7 +109,7 @@ BITCOIN_TESTS =\\\n   test/key_tests.cpp \\\n   test/limitedmap_tests.cpp \\\n   test/dbwrapper_tests.cpp \\\n-  test/main_tests.cpp \\\n+  test/validation_tests.cpp \\\n   test/mempool_tests.cpp \\\n   test/merkle_tests.cpp \\\n   test/merkleblock_tests.cpp \\\n@@ -170,366 +188,135 @@ test_test_bitcoin_LDADD += $(BDB_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(RAPIDC\n test_test_bitcoin_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS) -static\n \n if ENABLE_ZMQ\n-test_test_bitcoin_LDADD += $(ZMQ_LIBS)\n+test_test_bitcoin_LDADD += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)\n endif\n \n if ENABLE_FUZZ\n test_fuzz_block_deserialize_SOURCES = $(FUZZ_SUITE) test/fuzz/deserialize.cpp\n test_fuzz_block_deserialize_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -DBLOCK_DESERIALIZE=1\n test_fuzz_block_deserialize_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_block_deserialize_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-test_fuzz_block_deserialize_LDADD = \\\n- $(LIBUNIVALUE) \\\n- $(LIBBITCOIN_SERVER) \\\n- $(LIBBITCOIN_COMMON) \\\n- $(LIBBITCOIN_UTIL) \\\n- $(LIBBITCOIN_CONSENSUS) \\\n- $(LIBBITCOIN_CRYPTO) \\\n- $(LIBBITCOIN_CRYPTO_SSE41) \\\n- $(LIBBITCOIN_CRYPTO_AVX2) \\\n- $(LIBBITCOIN_CRYPTO_SHANI) \\\n- $(LIBSECP256K1)\n-test_fuzz_block_deserialize_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n+test_fuzz_block_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)\n \n test_fuzz_transaction_deserialize_SOURCES = $(FUZZ_SUITE) test/fuzz/deserialize.cpp\n test_fuzz_transaction_deserialize_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -DTRANSACTION_DESERIALIZE=1\n test_fuzz_transaction_deserialize_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_transaction_deserialize_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-test_fuzz_transaction_deserialize_LDADD = \\\n- $(LIBUNIVALUE) \\\n- $(LIBBITCOIN_SERVER) \\\n- $(LIBBITCOIN_COMMON) \\\n- $(LIBBITCOIN_UTIL) \\\n- $(LIBBITCOIN_CONSENSUS) \\\n- $(LIBBITCOIN_CRYPTO) \\\n- $(LIBBITCOIN_CRYPTO_SSE41) \\\n- $(LIBBITCOIN_CRYPTO_AVX2) \\\n- $(LIBBITCOIN_CRYPTO_SHANI) \\\n- $(LIBSECP256K1)\n-test_fuzz_transaction_deserialize_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n+test_fuzz_transaction_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)\n \n test_fuzz_blocklocator_deserialize_SOURCES = $(FUZZ_SUITE) test/fuzz/deserialize.cpp\n test_fuzz_blocklocator_deserialize_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -DBLOCKLOCATOR_DESERIALIZE=1\n test_fuzz_blocklocator_deserialize_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_blocklocator_deserialize_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-test_fuzz_blocklocator_deserialize_LDADD = \\\n- $(LIBUNIVALUE) \\\n- $(LIBBITCOIN_SERVER) \\\n- $(LIBBITCOIN_COMMON) \\\n- $(LIBBITCOIN_UTIL) \\\n- $(LIBBITCOIN_CONSENSUS) \\\n- $(LIBBITCOIN_CRYPTO) \\\n- $(LIBBITCOIN_CRYPTO_SSE41) \\\n- $(LIBBITCOIN_CRYPTO_AVX2) \\\n- $(LIBBITCOIN_CRYPTO_SHANI) \\\n- $(LIBSECP256K1)\n-test_fuzz_blocklocator_deserialize_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n+test_fuzz_blocklocator_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)\n \n test_fuzz_blockmerkleroot_SOURCES = $(FUZZ_SUITE) test/fuzz/deserialize.cpp\n test_fuzz_blockmerkleroot_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -DBLOCKMERKLEROOT=1\n test_fuzz_blockmerkleroot_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_blockmerkleroot_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-test_fuzz_blockmerkleroot_LDADD = \\\n- $(LIBUNIVALUE) \\\n- $(LIBBITCOIN_SERVER) \\\n- $(LIBBITCOIN_COMMON) \\\n- $(LIBBITCOIN_UTIL) \\\n- $(LIBBITCOIN_CONSENSUS) \\\n- $(LIBBITCOIN_CRYPTO) \\\n- $(LIBBITCOIN_CRYPTO_SSE41) \\\n- $(LIBBITCOIN_CRYPTO_AVX2) \\\n- $(LIBBITCOIN_CRYPTO_SHANI) \\\n- $(LIBSECP256K1)\n-test_fuzz_blockmerkleroot_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n+test_fuzz_blockmerkleroot_LDADD = $(FUZZ_SUITE_LD_COMMON)\n \n test_fuzz_addrman_deserialize_SOURCES = $(FUZZ_SUITE) test/fuzz/deserialize.cpp\n test_fuzz_addrman_deserialize_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -DADDRMAN_DESERIALIZE=1\n test_fuzz_addrman_deserialize_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_addrman_deserialize_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-test_fuzz_addrman_deserialize_LDADD = \\\n- $(LIBUNIVALUE) \\\n- $(LIBBITCOIN_SERVER) \\\n- $(LIBBITCOIN_COMMON) \\\n- $(LIBBITCOIN_UTIL) \\\n- $(LIBBITCOIN_CONSENSUS) \\\n- $(LIBBITCOIN_CRYPTO) \\\n- $(LIBBITCOIN_CRYPTO_SSE41) \\\n- $(LIBBITCOIN_CRYPTO_AVX2) \\\n- $(LIBBITCOIN_CRYPTO_SHANI) \\\n- $(LIBSECP256K1)\n-test_fuzz_addrman_deserialize_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n+test_fuzz_addrman_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)\n \n test_fuzz_blockheader_deserialize_SOURCES = $(FUZZ_SUITE) test/fuzz/deserialize.cpp\n test_fuzz_blockheader_deserialize_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -DBLOCKHEADER_DESERIALIZE=1\n test_fuzz_blockheader_deserialize_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_blockheader_deserialize_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-test_fuzz_blockheader_deserialize_LDADD = \\\n- $(LIBUNIVALUE) \\\n- $(LIBBITCOIN_SERVER) \\\n- $(LIBBITCOIN_COMMON) \\\n- $(LIBBITCOIN_UTIL) \\\n- $(LIBBITCOIN_CONSENSUS) \\\n- $(LIBBITCOIN_CRYPTO) \\\n- $(LIBBITCOIN_CRYPTO_SSE41) \\\n- $(LIBBITCOIN_CRYPTO_AVX2) \\\n- $(LIBBITCOIN_CRYPTO_SHANI) \\\n- $(LIBSECP256K1)\n-test_fuzz_blockheader_deserialize_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n+test_fuzz_blockheader_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)\n \n test_fuzz_banentry_deserialize_SOURCES = $(FUZZ_SUITE) test/fuzz/deserialize.cpp\n test_fuzz_banentry_deserialize_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -DBANENTRY_DESERIALIZE=1\n test_fuzz_banentry_deserialize_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_banentry_deserialize_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-test_fuzz_banentry_deserialize_LDADD = \\\n- $(LIBUNIVALUE) \\\n- $(LIBBITCOIN_SERVER) \\\n- $(LIBBITCOIN_COMMON) \\\n- $(LIBBITCOIN_UTIL) \\\n- $(LIBBITCOIN_CONSENSUS) \\\n- $(LIBBITCOIN_CRYPTO) \\\n- $(LIBBITCOIN_CRYPTO_SSE41) \\\n- $(LIBBITCOIN_CRYPTO_AVX2) \\\n- $(LIBBITCOIN_CRYPTO_SHANI) \\\n- $(LIBSECP256K1)\n-test_fuzz_banentry_deserialize_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n+test_fuzz_banentry_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)\n \n test_fuzz_txundo_deserialize_SOURCES = $(FUZZ_SUITE) test/fuzz/deserialize.cpp\n test_fuzz_txundo_deserialize_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -DTXUNDO_DESERIALIZE=1\n test_fuzz_txundo_deserialize_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_txundo_deserialize_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-test_fuzz_txundo_deserialize_LDADD = \\\n- $(LIBUNIVALUE) \\\n- $(LIBBITCOIN_SERVER) \\\n- $(LIBBITCOIN_COMMON) \\\n- $(LIBBITCOIN_UTIL) \\\n- $(LIBBITCOIN_CONSENSUS) \\\n- $(LIBBITCOIN_CRYPTO) \\\n- $(LIBBITCOIN_CRYPTO_SSE41) \\\n- $(LIBBITCOIN_CRYPTO_AVX2) \\\n- $(LIBBITCOIN_CRYPTO_SHANI) \\\n- $(LIBSECP256K1)\n-test_fuzz_txundo_deserialize_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n+test_fuzz_txundo_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)\n \n test_fuzz_blockundo_deserialize_SOURCES = $(FUZZ_SUITE) test/fuzz/deserialize.cpp\n test_fuzz_blockundo_deserialize_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -DBLOCKUNDO_DESERIALIZE=1\n test_fuzz_blockundo_deserialize_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_blockundo_deserialize_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-test_fuzz_blockundo_deserialize_LDADD = \\\n- $(LIBUNIVALUE) \\\n- $(LIBBITCOIN_SERVER) \\\n- $(LIBBITCOIN_COMMON) \\\n- $(LIBBITCOIN_UTIL) \\\n- $(LIBBITCOIN_CONSENSUS) \\\n- $(LIBBITCOIN_CRYPTO) \\\n- $(LIBBITCOIN_CRYPTO_SSE41) \\\n- $(LIBBITCOIN_CRYPTO_AVX2) \\\n- $(LIBBITCOIN_CRYPTO_SHANI) \\\n- $(LIBSECP256K1)\n-test_fuzz_blockundo_deserialize_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n+test_fuzz_blockundo_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)\n \n test_fuzz_coins_deserialize_SOURCES = $(FUZZ_SUITE) test/fuzz/deserialize.cpp\n test_fuzz_coins_deserialize_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -DCOINS_DESERIALIZE=1\n test_fuzz_coins_deserialize_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_coins_deserialize_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-test_fuzz_coins_deserialize_LDADD = \\\n- $(LIBUNIVALUE) \\\n- $(LIBBITCOIN_SERVER) \\\n- $(LIBBITCOIN_COMMON) \\\n- $(LIBBITCOIN_UTIL) \\\n- $(LIBBITCOIN_CONSENSUS) \\\n- $(LIBBITCOIN_CRYPTO) \\\n- $(LIBBITCOIN_CRYPTO_SSE41) \\\n- $(LIBBITCOIN_CRYPTO_AVX2) \\\n- $(LIBBITCOIN_CRYPTO_SHANI) \\\n- $(LIBSECP256K1)\n-test_fuzz_coins_deserialize_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n+test_fuzz_coins_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)\n \n test_fuzz_netaddr_deserialize_SOURCES = $(FUZZ_SUITE) test/fuzz/deserialize.cpp\n test_fuzz_netaddr_deserialize_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -DNETADDR_DESERIALIZE=1\n test_fuzz_netaddr_deserialize_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_netaddr_deserialize_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-test_fuzz_netaddr_deserialize_LDADD = \\\n- $(LIBUNIVALUE) \\\n- $(LIBBITCOIN_SERVER) \\\n- $(LIBBITCOIN_COMMON) \\\n- $(LIBBITCOIN_UTIL) \\\n- $(LIBBITCOIN_CONSENSUS) \\\n- $(LIBBITCOIN_CRYPTO) \\\n- $(LIBBITCOIN_CRYPTO_SSE41) \\\n- $(LIBBITCOIN_CRYPTO_AVX2) \\\n- $(LIBBITCOIN_CRYPTO_SHANI) \\\n- $(LIBSECP256K1)\n-test_fuzz_netaddr_deserialize_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n+test_fuzz_netaddr_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)\n \n test_fuzz_script_flags_SOURCES = $(FUZZ_SUITE) test/fuzz/script_flags.cpp\n test_fuzz_script_flags_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n test_fuzz_script_flags_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_script_flags_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-test_fuzz_script_flags_LDADD = \\\n- $(LIBUNIVALUE) \\\n- $(LIBBITCOIN_SERVER) \\\n- $(LIBBITCOIN_COMMON) \\\n- $(LIBBITCOIN_UTIL) \\\n- $(LIBBITCOIN_CONSENSUS) \\\n- $(LIBBITCOIN_CRYPTO) \\\n- $(LIBBITCOIN_CRYPTO_SSE41) \\\n- $(LIBBITCOIN_CRYPTO_AVX2) \\\n- $(LIBBITCOIN_CRYPTO_SHANI) \\\n- $(LIBSECP256K1)\n-test_fuzz_script_flags_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n+test_fuzz_script_flags_LDADD = $(FUZZ_SUITE_LD_COMMON)\n \n test_fuzz_service_deserialize_SOURCES = $(FUZZ_SUITE) test/fuzz/deserialize.cpp\n test_fuzz_service_deserialize_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -DSERVICE_DESERIALIZE=1\n test_fuzz_service_deserialize_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_service_deserialize_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-test_fuzz_service_deserialize_LDADD = \\\n- $(LIBUNIVALUE) \\\n- $(LIBBITCOIN_SERVER) \\\n- $(LIBBITCOIN_COMMON) \\\n- $(LIBBITCOIN_UTIL) \\\n- $(LIBBITCOIN_CONSENSUS) \\\n- $(LIBBITCOIN_CRYPTO) \\\n- $(LIBBITCOIN_CRYPTO_SSE41) \\\n- $(LIBBITCOIN_CRYPTO_AVX2) \\\n- $(LIBBITCOIN_CRYPTO_SHANI) \\\n- $(LIBSECP256K1)\n-test_fuzz_service_deserialize_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n+test_fuzz_service_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)\n \n test_fuzz_messageheader_deserialize_SOURCES = $(FUZZ_SUITE) test/fuzz/deserialize.cpp\n test_fuzz_messageheader_deserialize_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -DMESSAGEHEADER_DESERIALIZE=1\n test_fuzz_messageheader_deserialize_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_messageheader_deserialize_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-test_fuzz_messageheader_deserialize_LDADD = \\\n- $(LIBUNIVALUE) \\\n- $(LIBBITCOIN_SERVER) \\\n- $(LIBBITCOIN_COMMON) \\\n- $(LIBBITCOIN_UTIL) \\\n- $(LIBBITCOIN_CONSENSUS) \\\n- $(LIBBITCOIN_CRYPTO) \\\n- $(LIBBITCOIN_CRYPTO_SSE41) \\\n- $(LIBBITCOIN_CRYPTO_AVX2) \\\n- $(LIBBITCOIN_CRYPTO_SHANI) \\\n- $(LIBSECP256K1)\n-test_fuzz_messageheader_deserialize_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n+test_fuzz_messageheader_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)\n \n test_fuzz_address_deserialize_SOURCES = $(FUZZ_SUITE) test/fuzz/deserialize.cpp\n test_fuzz_address_deserialize_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -DADDRESS_DESERIALIZE=1\n test_fuzz_address_deserialize_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_address_deserialize_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-test_fuzz_address_deserialize_LDADD = \\\n- $(LIBUNIVALUE) \\\n- $(LIBBITCOIN_SERVER) \\\n- $(LIBBITCOIN_COMMON) \\\n- $(LIBBITCOIN_UTIL) \\\n- $(LIBBITCOIN_CONSENSUS) \\\n- $(LIBBITCOIN_CRYPTO) \\\n- $(LIBBITCOIN_CRYPTO_SSE41) \\\n- $(LIBBITCOIN_CRYPTO_AVX2) \\\n- $(LIBBITCOIN_CRYPTO_SHANI) \\\n- $(LIBSECP256K1)\n-test_fuzz_address_deserialize_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n+test_fuzz_address_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)\n \n test_fuzz_inv_deserialize_SOURCES = $(FUZZ_SUITE) test/fuzz/deserialize.cpp\n test_fuzz_inv_deserialize_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -DINV_DESERIALIZE=1\n test_fuzz_inv_deserialize_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_inv_deserialize_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-test_fuzz_inv_deserialize_LDADD = \\\n- $(LIBUNIVALUE) \\\n- $(LIBBITCOIN_SERVER) \\\n- $(LIBBITCOIN_COMMON) \\\n- $(LIBBITCOIN_UTIL) \\\n- $(LIBBITCOIN_CONSENSUS) \\\n- $(LIBBITCOIN_CRYPTO) \\\n- $(LIBBITCOIN_CRYPTO_SSE41) \\\n- $(LIBBITCOIN_CRYPTO_AVX2) \\\n- $(LIBBITCOIN_CRYPTO_SHANI) \\\n- $(LIBSECP256K1)\n-test_fuzz_inv_deserialize_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n+test_fuzz_inv_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)\n \n test_fuzz_bloomfilter_deserialize_SOURCES = $(FUZZ_SUITE) test/fuzz/deserialize.cpp\n test_fuzz_bloomfilter_deserialize_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -DBLOOMFILTER_DESERIALIZE=1\n test_fuzz_bloomfilter_deserialize_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_bloomfilter_deserialize_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-test_fuzz_bloomfilter_deserialize_LDADD = \\\n- $(LIBUNIVALUE) \\\n- $(LIBBITCOIN_SERVER) \\\n- $(LIBBITCOIN_COMMON) \\\n- $(LIBBITCOIN_UTIL) \\\n- $(LIBBITCOIN_CONSENSUS) \\\n- $(LIBBITCOIN_CRYPTO) \\\n- $(LIBBITCOIN_CRYPTO_SSE41) \\\n- $(LIBBITCOIN_CRYPTO_AVX2) \\\n- $(LIBBITCOIN_CRYPTO_SHANI) \\\n- $(LIBSECP256K1)\n-test_fuzz_bloomfilter_deserialize_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n+test_fuzz_bloomfilter_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)\n \n test_fuzz_diskblockindex_deserialize_SOURCES = $(FUZZ_SUITE) test/fuzz/deserialize.cpp\n test_fuzz_diskblockindex_deserialize_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -DDISKBLOCKINDEX_DESERIALIZE=1\n test_fuzz_diskblockindex_deserialize_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_diskblockindex_deserialize_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-test_fuzz_diskblockindex_deserialize_LDADD = \\\n- $(LIBUNIVALUE) \\\n- $(LIBBITCOIN_SERVER) \\\n- $(LIBBITCOIN_COMMON) \\\n- $(LIBBITCOIN_UTIL) \\\n- $(LIBBITCOIN_CONSENSUS) \\\n- $(LIBBITCOIN_CRYPTO) \\\n- $(LIBBITCOIN_CRYPTO_SSE41) \\\n- $(LIBBITCOIN_CRYPTO_AVX2) \\\n- $(LIBBITCOIN_CRYPTO_SHANI) \\\n- $(LIBSECP256K1)\n-test_fuzz_diskblockindex_deserialize_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n+test_fuzz_diskblockindex_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)\n \n test_fuzz_txoutcompressor_deserialize_SOURCES = $(FUZZ_SUITE) test/fuzz/deserialize.cpp\n test_fuzz_txoutcompressor_deserialize_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -DTXOUTCOMPRESSOR_DESERIALIZE=1\n test_fuzz_txoutcompressor_deserialize_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_txoutcompressor_deserialize_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-test_fuzz_txoutcompressor_deserialize_LDADD = \\\n- $(LIBUNIVALUE) \\\n- $(LIBBITCOIN_SERVER) \\\n- $(LIBBITCOIN_COMMON) \\\n- $(LIBBITCOIN_UTIL) \\\n- $(LIBBITCOIN_CONSENSUS) \\\n- $(LIBBITCOIN_CRYPTO) \\\n- $(LIBBITCOIN_CRYPTO_SSE41) \\\n- $(LIBBITCOIN_CRYPTO_AVX2) \\\n- $(LIBBITCOIN_CRYPTO_SHANI) \\\n- $(LIBSECP256K1)\n-test_fuzz_txoutcompressor_deserialize_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n+test_fuzz_txoutcompressor_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)\n \n test_fuzz_blocktransactions_deserialize_SOURCES = $(FUZZ_SUITE) test/fuzz/deserialize.cpp\n test_fuzz_blocktransactions_deserialize_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -DBLOCKTRANSACTIONS_DESERIALIZE=1\n test_fuzz_blocktransactions_deserialize_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_blocktransactions_deserialize_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-test_fuzz_blocktransactions_deserialize_LDADD = \\\n- $(LIBUNIVALUE) \\\n- $(LIBBITCOIN_SERVER) \\\n- $(LIBBITCOIN_COMMON) \\\n- $(LIBBITCOIN_UTIL) \\\n- $(LIBBITCOIN_CONSENSUS) \\\n- $(LIBBITCOIN_CRYPTO) \\\n- $(LIBBITCOIN_CRYPTO_SSE41) \\\n- $(LIBBITCOIN_CRYPTO_AVX2) \\\n- $(LIBBITCOIN_CRYPTO_SHANI) \\\n- $(LIBSECP256K1)\n-test_fuzz_blocktransactions_deserialize_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n+test_fuzz_blocktransactions_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)\n \n test_fuzz_blocktransactionsrequest_deserialize_SOURCES = $(FUZZ_SUITE) test/fuzz/deserialize.cpp\n test_fuzz_blocktransactionsrequest_deserialize_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -DBLOCKTRANSACTIONSREQUEST_DESERIALIZE=1\n test_fuzz_blocktransactionsrequest_deserialize_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_blocktransactionsrequest_deserialize_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-test_fuzz_blocktransactionsrequest_deserialize_LDADD = \\\n- $(LIBUNIVALUE) \\\n- $(LIBBITCOIN_SERVER) \\\n- $(LIBBITCOIN_COMMON) \\\n- $(LIBBITCOIN_UTIL) \\\n- $(LIBBITCOIN_CONSENSUS) \\\n- $(LIBBITCOIN_CRYPTO) \\\n- $(LIBBITCOIN_CRYPTO_SSE41) \\\n- $(LIBBITCOIN_CRYPTO_AVX2) \\\n- $(LIBBITCOIN_CRYPTO_SHANI) \\\n- $(LIBSECP256K1)\n-test_fuzz_blocktransactionsrequest_deserialize_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n+test_fuzz_blocktransactionsrequest_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)\n endif # ENABLE_FUZZ\n \n nodist_test_test_bitcoin_SOURCES = $(GENERATED_TEST_FILES)"
      },
      {
        "sha": "8a5f78d1c5161b3835038bf63c085464875371a9",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 2,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -239,7 +239,9 @@ void CAddrMan::Good_(const CService& addr, bool test_before_evict, int64_t nTime\n \n     // Will moving this address into tried evict another entry?\n     if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {\n-        LogPrint(BCLog::ADDRMAN, \"Collision inserting element into tried table, moving %s to m_tried_collisions=%d\\n\", addr.ToString(), m_tried_collisions.size());\n+        // Output the entry we'd be colliding with, for debugging purposes\n+        auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);\n+        LogPrint(BCLog::ADDRMAN, \"Collision inserting element into tried table (%s), moving %s to m_tried_collisions=%d\\n\", colliding_entry != mapInfo.end() ? colliding_entry->second.ToString() : \"\", addr.ToString(), m_tried_collisions.size());\n         if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {\n             m_tried_collisions.insert(nId);\n         }\n@@ -561,12 +563,19 @@ void CAddrMan::ResolveCollisions_()\n \n                     // Give address at least 60 seconds to successfully connect\n                     if (GetAdjustedTime() - info_old.nLastTry > 60) {\n-                        LogPrint(BCLog::ADDRMAN, \"Swapping %s for %s in tried table\\n\", info_new.ToString(), info_old.ToString());\n+                        LogPrint(BCLog::ADDRMAN, \"Replacing %s with %s in tried table\\n\", info_old.ToString(), info_new.ToString());\n \n                         // Replaces an existing address already in the tried table with the new address\n                         Good_(info_new, false, GetAdjustedTime());\n                         erase_collision = true;\n                     }\n+                } else if (GetAdjustedTime() - info_new.nLastSuccess > ADDRMAN_TEST_WINDOW) {\n+                    // If the collision hasn't resolved in some reasonable amount of time,\n+                    // just evict the old entry -- we must not be able to\n+                    // connect to it for some reason.\n+                    LogPrint(BCLog::ADDRMAN, \"Unable to test; replacing %s with %s in tried table anyway\\n\", info_old.ToString(), info_new.ToString());\n+                    Good_(info_new, false, GetAdjustedTime());\n+                    erase_collision = true;\n                 }\n             } else { // Collision is not actually a collision anymore\n                 Good_(info_new, false, GetAdjustedTime());"
      },
      {
        "sha": "e54184ce35de29a587bddd72d554c3d9a2eccac8",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -166,6 +166,9 @@ class CAddrInfo : public CAddress\n //! the maximum number of tried addr collisions to store\n #define ADDRMAN_SET_TRIED_COLLISION_SIZE 10\n \n+//! the maximum time we'll spend trying to resolve a tried table collision, in seconds\n+static const int64_t ADDRMAN_TEST_WINDOW = 40*60; // 40 minutes\n+\n /**\n  * Stochastical (IP) address manager\n  */"
      },
      {
        "sha": "67d8a255647b4e5766e7ae7c4649911da3c8199b",
        "filename": "src/bench/rpc_mempool.cpp",
        "status": "added",
        "additions": 43,
        "deletions": 0,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/bench/rpc_mempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/bench/rpc_mempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/rpc_mempool.cpp?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -0,0 +1,43 @@\n+// Copyright (c) 2011-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+#include <policy/policy.h>\n+#include <rpc/blockchain.h>\n+#include <txmempool.h>\n+\n+#include <univalue.h>\n+\n+#include <list>\n+#include <vector>\n+\n+static void AddTx(const CTransactionRef& tx, const CAmount& fee, CTxMemPool& pool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    LockPoints lp;\n+    pool.addUnchecked(CTxMemPoolEntry(tx, fee, /* time */ 0, /* height */ 1, /* spendsCoinbase */ false, /* sigOpCost */ 4, lp));\n+}\n+\n+static void RpcMempool(benchmark::State& state)\n+{\n+    CTxMemPool pool;\n+    LOCK2(cs_main, pool.cs);\n+\n+    for (int i = 0; i < 1000; ++i) {\n+        CMutableTransaction tx = CMutableTransaction();\n+        tx.vin.resize(1);\n+        tx.vin[0].scriptSig = CScript() << OP_1;\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+        tx.vout.resize(1);\n+        tx.vout[0].scriptPubKey = CScript() << OP_1 << OP_EQUAL;\n+        tx.vout[0].nValue = i;\n+        const CTransactionRef tx_r{MakeTransactionRef(tx)};\n+        AddTx(tx_r, /* fee */ i, pool);\n+    }\n+\n+    while (state.KeepRunning()) {\n+        (void)MempoolToJSON(pool, /*verbose*/ true);\n+    }\n+}\n+\n+BENCHMARK(RpcMempool, 40);"
      },
      {
        "sha": "e15213c552e0fa35c87567d4848509eb72f3f731",
        "filename": "src/blockfilter.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/blockfilter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/blockfilter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockfilter.cpp?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -251,6 +251,8 @@ bool BlockFilter::BuildParams(GCSFilter::Params& params) const\n         params.m_P = BASIC_FILTER_P;\n         params.m_M = BASIC_FILTER_M;\n         return true;\n+    case BlockFilterType::INVALID:\n+        return false;\n     }\n \n     return false;"
      },
      {
        "sha": "e5e087ed5a3addfd1770b4900df2f6ad4dad79f6",
        "filename": "src/blockfilter.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/blockfilter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/blockfilter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockfilter.h?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -83,9 +83,10 @@ class GCSFilter\n constexpr uint8_t BASIC_FILTER_P = 19;\n constexpr uint32_t BASIC_FILTER_M = 784931;\n \n-enum BlockFilterType : uint8_t\n+enum class BlockFilterType : uint8_t\n {\n     BASIC = 0,\n+    INVALID = 255,\n };\n \n /**\n@@ -95,7 +96,7 @@ enum BlockFilterType : uint8_t\n class BlockFilter\n {\n private:\n-    BlockFilterType m_filter_type;\n+    BlockFilterType m_filter_type = BlockFilterType::INVALID;\n     uint256 m_block_hash;\n     GCSFilter m_filter;\n "
      },
      {
        "sha": "0898d0ff2582c1261da7219bfdf9d7f761bc212e",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 12,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1468,11 +1468,11 @@ bool AppInitMain(InitInterfaces& interfaces)\n \n         uiInterface.InitMessage(_(\"Loading block index...\"));\n \n-        LOCK(cs_main);\n-\n         do {\n             const int64_t load_block_index_start_time = GetTimeMillis();\n+            bool is_coinsview_empty;\n             try {\n+                LOCK(cs_main);\n                 UnloadBlockIndex();\n                 pcoinsTip.reset();\n                 pcoinsdbview.reset();\n@@ -1544,7 +1544,7 @@ bool AppInitMain(InitInterfaces& interfaces)\n                 // The on-disk coinsdb is now in a good state, create the cache\n                 pcoinsTip.reset(new CCoinsViewCache(pcoinscatcher.get()));\n \n-                bool is_coinsview_empty = fReset || fReindexChainState || pcoinsTip->GetBestBlock().IsNull();\n+                is_coinsview_empty = fReset || fReindexChainState || pcoinsTip->GetBestBlock().IsNull();\n                 if (!is_coinsview_empty) {\n                     // LoadChainTip sets chainActive based on pcoinsTip's best block\n                     if (!LoadChainTip(chainparams)) {\n@@ -1553,18 +1553,25 @@ bool AppInitMain(InitInterfaces& interfaces)\n                     }\n                     assert(chainActive.Tip() != nullptr);\n                 }\n+            } catch (const std::exception& e) {\n+                LogPrintf(\"%s\\n\", e.what());\n+                strLoadError = _(\"Error opening block database\");\n+                break;\n+            }\n \n-                if (!fReset) {\n-                    // Note that RewindBlockIndex MUST run even if we're about to -reindex-chainstate.\n-                    // It both disconnects blocks based on chainActive, and drops block data in\n-                    // mapBlockIndex based on lack of available witness data.\n-                    uiInterface.InitMessage(_(\"Rewinding blocks...\"));\n-                    if (!RewindBlockIndex(chainparams)) {\n-                        strLoadError = _(\"Unable to rewind the database to a pre-fork state. You will need to redownload the blockchain\");\n-                        break;\n-                    }\n+            if (!fReset) {\n+                // Note that RewindBlockIndex MUST run even if we're about to -reindex-chainstate.\n+                // It both disconnects blocks based on chainActive, and drops block data in\n+                // mapBlockIndex based on lack of available witness data.\n+                uiInterface.InitMessage(_(\"Rewinding blocks...\"));\n+                if (!RewindBlockIndex(chainparams)) {\n+                    strLoadError = _(\"Unable to rewind the database to a pre-fork state. You will need to redownload the blockchain\");\n+                    break;\n                 }\n+            }\n \n+            try {\n+                LOCK(cs_main);\n                 if (!is_coinsview_empty) {\n                     uiInterface.InitMessage(_(\"Verifying blocks...\"));\n                     if (fHavePruned && gArgs.GetArg(\"-checkblocks\", DEFAULT_CHECKBLOCKS) > MIN_BLOCKS_TO_KEEP) {"
      },
      {
        "sha": "f77d1721535bee672b972156960b7a93bc6607a0",
        "filename": "src/interfaces/README.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/interfaces/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/interfaces/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/README.md?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -2,9 +2,9 @@\n \n The following interfaces are defined here:\n \n-* [`Chain`](chain.h) \u2014 used by wallet to access blockchain and mempool state. Added in [#10973](https://github.com/bitcoin/bitcoin/pull/10973).\n+* [`Chain`](chain.h) \u2014 used by wallet to access blockchain and mempool state. Added in [#14437](https://github.com/bitcoin/bitcoin/pull/14437), [#14711](https://github.com/bitcoin/bitcoin/pull/14711), [#15288](https://github.com/bitcoin/bitcoin/pull/15288), and [#10973](https://github.com/bitcoin/bitcoin/pull/10973).\n \n-* [`ChainClient`](chain.h) \u2014 used by node to start & stop `Chain` clients. Added in [#10973](https://github.com/bitcoin/bitcoin/pull/10973).\n+* [`ChainClient`](chain.h) \u2014 used by node to start & stop `Chain` clients. Added in [#14437](https://github.com/bitcoin/bitcoin/pull/14437).\n \n * [`Node`](node.h) \u2014 used by GUI to start & stop bitcoin node. Added in [#10244](https://github.com/bitcoin/bitcoin/pull/10244).\n "
      },
      {
        "sha": "2eecea28d02e1b45e8ec929417e044e823c0814a",
        "filename": "src/interfaces/chain.cpp",
        "status": "modified",
        "additions": 77,
        "deletions": 0,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/interfaces/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/interfaces/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.cpp?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -6,8 +6,19 @@\n \n #include <chain.h>\n #include <chainparams.h>\n+#include <interfaces/wallet.h>\n+#include <net.h>\n+#include <policy/fees.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n #include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <protocol.h>\n #include <sync.h>\n+#include <threadsafety.h>\n+#include <timedata.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n #include <uint256.h>\n #include <util/system.h>\n #include <validation.h>\n@@ -132,6 +143,17 @@ class LockImpl : public Chain::Lock\n         }\n         return nullopt;\n     }\n+    bool checkFinalTx(const CTransaction& tx) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return CheckFinalTx(tx);\n+    }\n+    bool submitToMemoryPool(const CTransactionRef& tx, CAmount absurd_fee, CValidationState& state) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return AcceptToMemoryPool(::mempool, state, tx, nullptr /* missing inputs */, nullptr /* txn replaced */,\n+            false /* bypass limits */, absurd_fee);\n+    }\n };\n \n class LockingStateImpl : public LockImpl, public UniqueLock<CCriticalSection>\n@@ -177,6 +199,61 @@ class ChainImpl : public Chain\n         LOCK(cs_main);\n         return GuessVerificationProgress(Params().TxData(), LookupBlockIndex(block_hash));\n     }\n+    RBFTransactionState isRBFOptIn(const CTransaction& tx) override\n+    {\n+        LOCK(::mempool.cs);\n+        return IsRBFOptIn(tx, ::mempool);\n+    }\n+    bool hasDescendantsInMempool(const uint256& txid) override\n+    {\n+        LOCK(::mempool.cs);\n+        auto it = ::mempool.GetIter(txid);\n+        return it && (*it)->GetCountWithDescendants() > 1;\n+    }\n+    void relayTransaction(const uint256& txid) override\n+    {\n+        CInv inv(MSG_TX, txid);\n+        g_connman->ForEachNode([&inv](CNode* node) { node->PushInventory(inv); });\n+    }\n+    void getTransactionAncestry(const uint256& txid, size_t& ancestors, size_t& descendants) override\n+    {\n+        ::mempool.GetTransactionAncestry(txid, ancestors, descendants);\n+    }\n+    bool checkChainLimits(const CTransactionRef& tx) override\n+    {\n+        LockPoints lp;\n+        CTxMemPoolEntry entry(tx, 0, 0, 0, false, 0, lp);\n+        CTxMemPool::setEntries ancestors;\n+        auto limit_ancestor_count = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        auto limit_ancestor_size = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT) * 1000;\n+        auto limit_descendant_count = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        auto limit_descendant_size = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT) * 1000;\n+        std::string unused_error_string;\n+        LOCK(::mempool.cs);\n+        return ::mempool.CalculateMemPoolAncestors(entry, ancestors, limit_ancestor_count, limit_ancestor_size,\n+            limit_descendant_count, limit_descendant_size, unused_error_string);\n+    }\n+    CFeeRate estimateSmartFee(int num_blocks, bool conservative, FeeCalculation* calc) override\n+    {\n+        return ::feeEstimator.estimateSmartFee(num_blocks, calc, conservative);\n+    }\n+    unsigned int estimateMaxBlocks() override\n+    {\n+        return ::feeEstimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE);\n+    }\n+    CFeeRate mempoolMinFee() override\n+    {\n+        return ::mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    }\n+    CAmount maxTxFee() override { return ::maxTxFee; }\n+    bool getPruneMode() override { return ::fPruneMode; }\n+    bool p2pEnabled() override { return g_connman != nullptr; }\n+    bool isInitialBlockDownload() override { return IsInitialBlockDownload(); }\n+    int64_t getAdjustedTime() override { return GetAdjustedTime(); }\n+    void initMessage(const std::string& message) override { ::uiInterface.InitMessage(message); }\n+    void initWarning(const std::string& message) override { InitWarning(message); }\n+    void initError(const std::string& message) override { InitError(message); }\n+    void loadWallet(std::unique_ptr<Wallet> wallet) override { ::uiInterface.LoadWallet(wallet); }\n };\n \n } // namespace"
      },
      {
        "sha": "037e8e9ff5d5f025663fa952e5a735fdd74514a2",
        "filename": "src/interfaces/chain.h",
        "status": "modified",
        "additions": 92,
        "deletions": 2,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/interfaces/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/interfaces/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.h?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -5,21 +5,49 @@\n #ifndef BITCOIN_INTERFACES_CHAIN_H\n #define BITCOIN_INTERFACES_CHAIN_H\n \n-#include <optional.h>\n+#include <optional.h>               // For Optional and nullopt\n+#include <primitives/transaction.h> // For CTransactionRef\n \n #include <memory>\n+#include <stddef.h>\n #include <stdint.h>\n #include <string>\n #include <vector>\n \n class CBlock;\n+class CFeeRate;\n class CScheduler;\n+class CValidationState;\n class uint256;\n+enum class RBFTransactionState;\n struct CBlockLocator;\n+struct FeeCalculation;\n \n namespace interfaces {\n \n-//! Interface for giving wallet processes access to blockchain state.\n+class Wallet;\n+\n+//! Interface giving clients (wallet processes, maybe other analysis tools in\n+//! the future) ability to access to the chain state, receive notifications,\n+//! estimate fees, and submit transactions.\n+//!\n+//! TODO: Current chain methods are too low level, exposing too much of the\n+//! internal workings of the bitcoin node, and not being very convenient to use.\n+//! Chain methods should be cleaned up and simplified over time. Examples:\n+//!\n+//! * The Chain::lock() method, which lets clients delay chain tip updates\n+//!   should be removed when clients are able to respond to updates\n+//!   asynchronously\n+//!   (https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-380101269).\n+//!\n+//! * The relayTransactions() and submitToMemoryPool() methods could be replaced\n+//!   with a higher-level broadcastTransaction method\n+//!   (https://github.com/bitcoin/bitcoin/pull/14978#issuecomment-459373984).\n+//!\n+//! * The initMessages() and loadWallet() methods which the wallet uses to send\n+//!   notifications to the GUI should go away when GUI and wallet can directly\n+//!   communicate with each other without going through the node\n+//!   (https://github.com/bitcoin/bitcoin/pull/15288#discussion_r253321096).\n class Chain\n {\n public:\n@@ -102,6 +130,14 @@ class Chain\n         //! is guaranteed to be an ancestor of the block used to create the\n         //! locator.\n         virtual Optional<int> findLocatorFork(const CBlockLocator& locator) = 0;\n+\n+        //! Check if transaction will be final given chain height current time.\n+        virtual bool checkFinalTx(const CTransaction& tx) = 0;\n+\n+        //! Add transaction to memory pool if the transaction fee is below the\n+        //! amount specified by absurd_fee. Returns false if the transaction\n+        //! could not be added due to the fee or for another reason.\n+        virtual bool submitToMemoryPool(const CTransactionRef& tx, CAmount absurd_fee, CValidationState& state) = 0;\n     };\n \n     //! Return Lock interface. Chain is locked when this is called, and\n@@ -127,6 +163,60 @@ class Chain\n     //! Estimate fraction of total transactions verified if blocks up to\n     //! the specified block hash are verified.\n     virtual double guessVerificationProgress(const uint256& block_hash) = 0;\n+\n+    //! Check if transaction is RBF opt in.\n+    virtual RBFTransactionState isRBFOptIn(const CTransaction& tx) = 0;\n+\n+    //! Check if transaction has descendants in mempool.\n+    virtual bool hasDescendantsInMempool(const uint256& txid) = 0;\n+\n+    //! Relay transaction.\n+    virtual void relayTransaction(const uint256& txid) = 0;\n+\n+    //! Calculate mempool ancestor and descendant counts for the given transaction.\n+    virtual void getTransactionAncestry(const uint256& txid, size_t& ancestors, size_t& descendants) = 0;\n+\n+    //! Check if transaction will pass the mempool's chain limits.\n+    virtual bool checkChainLimits(const CTransactionRef& tx) = 0;\n+\n+    //! Estimate smart fee.\n+    virtual CFeeRate estimateSmartFee(int num_blocks, bool conservative, FeeCalculation* calc = nullptr) = 0;\n+\n+    //! Fee estimator max target.\n+    virtual unsigned int estimateMaxBlocks() = 0;\n+\n+    //! Mempool minimum fee.\n+    virtual CFeeRate mempoolMinFee() = 0;\n+\n+    //! Node max tx fee setting (-maxtxfee).\n+    //! This could be replaced by a per-wallet max fee, as proposed at\n+    //! https://github.com/bitcoin/bitcoin/issues/15355\n+    //! But for the time being, wallets call this to access the node setting.\n+    virtual CAmount maxTxFee() = 0;\n+\n+    //! Check if pruning is enabled.\n+    virtual bool getPruneMode() = 0;\n+\n+    //! Check if p2p enabled.\n+    virtual bool p2pEnabled() = 0;\n+\n+    // Check if in IBD.\n+    virtual bool isInitialBlockDownload() = 0;\n+\n+    //! Get adjusted time.\n+    virtual int64_t getAdjustedTime() = 0;\n+\n+    //! Send init message.\n+    virtual void initMessage(const std::string& message) = 0;\n+\n+    //! Send init warning.\n+    virtual void initWarning(const std::string& message) = 0;\n+\n+    //! Send init error.\n+    virtual void initError(const std::string& message) = 0;\n+\n+    //! Send wallet load notification to the GUI.\n+    virtual void loadWallet(std::unique_ptr<Wallet> wallet) = 0;\n };\n \n //! Interface to let node manage chain clients (wallets, or maybe tools for"
      },
      {
        "sha": "6f7dce0c24686eaa7014e16014d42facc1f39894",
        "filename": "src/interfaces/node.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/interfaces/node.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/interfaces/node.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/node.cpp?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -275,7 +275,7 @@ class NodeImpl : public Node\n     }\n     std::unique_ptr<Handler> handleLoadWallet(LoadWalletFn fn) override\n     {\n-        return MakeHandler(::uiInterface.LoadWallet_connect([fn](std::shared_ptr<CWallet> wallet) { fn(MakeWallet(wallet)); }));\n+        return MakeHandler(::uiInterface.LoadWallet_connect([fn](std::unique_ptr<Wallet>& wallet) { fn(std::move(wallet)); }));\n     }\n     std::unique_ptr<Handler> handleNotifyNumConnectionsChanged(NotifyNumConnectionsChangedFn fn) override\n     {"
      },
      {
        "sha": "7abbee0912f0d2f54cf1f35f3e431e0ca7ceb933",
        "filename": "src/interfaces/wallet.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/interfaces/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/interfaces/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/wallet.cpp?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -56,7 +56,7 @@ class PendingWalletTxImpl : public PendingWalletTx\n         auto locked_chain = m_wallet.chain().lock();\n         LOCK(m_wallet.cs_wallet);\n         CValidationState state;\n-        if (!m_wallet.CommitTransaction(m_tx, std::move(value_map), std::move(order_form), m_key, g_connman.get(), state)) {\n+        if (!m_wallet.CommitTransaction(m_tx, std::move(value_map), std::move(order_form), m_key, state)) {\n             reject_reason = state.GetRejectReason();\n             return false;\n         }\n@@ -99,7 +99,7 @@ WalletTx MakeWalletTx(interfaces::Chain::Lock& locked_chain, CWallet& wallet, co\n //! Construct wallet tx status struct.\n WalletTxStatus MakeWalletTxStatus(interfaces::Chain::Lock& locked_chain, const CWalletTx& wtx)\n {\n-    LockAnnotation lock(::cs_main); // Temporary, for CheckFinalTx below. Removed in upcoming commit.\n+    LockAnnotation lock(::cs_main); // Temporary, for mapBlockIndex below. Removed in upcoming commit.\n \n     WalletTxStatus result;\n     auto mi = ::mapBlockIndex.find(wtx.hashBlock);\n@@ -109,7 +109,7 @@ WalletTxStatus MakeWalletTxStatus(interfaces::Chain::Lock& locked_chain, const C\n     result.depth_in_main_chain = wtx.GetDepthInMainChain(locked_chain);\n     result.time_received = wtx.nTimeReceived;\n     result.lock_time = wtx.tx->nLockTime;\n-    result.is_final = CheckFinalTx(*wtx.tx);\n+    result.is_final = locked_chain.checkFinalTx(*wtx.tx);\n     result.is_trusted = wtx.IsTrusted(locked_chain);\n     result.is_abandoned = wtx.isAbandoned();\n     result.is_coinbase = wtx.IsCoinBase();\n@@ -457,7 +457,7 @@ class WalletImpl : public Wallet\n     {\n         FeeCalculation fee_calc;\n         CAmount result;\n-        result = GetMinimumFee(*m_wallet, tx_bytes, coin_control, ::mempool, ::feeEstimator, &fee_calc);\n+        result = GetMinimumFee(*m_wallet, tx_bytes, coin_control, &fee_calc);\n         if (returned_target) *returned_target = fee_calc.returnedTarget;\n         if (reason) *reason = fee_calc.reason;\n         return result;"
      },
      {
        "sha": "ccab4a17189888530312d37df18ba7227cb52915",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1765,9 +1765,15 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n                 addr = addrman.Select(fFeeler);\n             }\n \n-            // if we selected an invalid address, restart\n-            if (!addr.IsValid() || setConnected.count(addr.GetGroup()) || IsLocal(addr))\n+            // Require outbound connections, other than feelers, to be to distinct network groups\n+            if (!fFeeler && setConnected.count(addr.GetGroup())) {\n                 break;\n+            }\n+\n+            // if we selected an invalid or local address, restart\n+            if (!addr.IsValid() || IsLocal(addr)) {\n+                break;\n+            }\n \n             // If we didn't find an appropriate destination after trying 100 addresses fetched from addrman,\n             // stop this loop, and let the outer loop run again (which sleeps, adds seed nodes, recalculates"
      },
      {
        "sha": "c73a97fd7d9c321ea96cb175918ac06f4f70d60b",
        "filename": "src/policy/rbf.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/policy/rbf.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/policy/rbf.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/rbf.cpp?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -14,7 +14,7 @@ bool SignalsOptInRBF(const CTransaction &tx)\n     return false;\n }\n \n-RBFTransactionState IsRBFOptIn(const CTransaction &tx, CTxMemPool &pool)\n+RBFTransactionState IsRBFOptIn(const CTransaction& tx, const CTxMemPool& pool)\n {\n     AssertLockHeld(pool.cs);\n "
      },
      {
        "sha": "a4f877731094d02ef82c3b0314b682dab1af3e6a",
        "filename": "src/policy/rbf.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/policy/rbf.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/policy/rbf.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/rbf.h?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -23,6 +23,6 @@ bool SignalsOptInRBF(const CTransaction &tx);\n // according to BIP 125\n // This involves checking sequence numbers of the transaction, as well\n // as the sequence numbers of all in-mempool ancestors.\n-RBFTransactionState IsRBFOptIn(const CTransaction &tx, CTxMemPool &pool) EXCLUSIVE_LOCKS_REQUIRED(pool.cs);\n+RBFTransactionState IsRBFOptIn(const CTransaction& tx, const CTxMemPool& pool) EXCLUSIVE_LOCKS_REQUIRED(pool.cs);\n \n #endif // BITCOIN_POLICY_RBF_H"
      },
      {
        "sha": "94413547d4a393c82d60d4c6ecaab4d26fde98c1",
        "filename": "src/qt/walletframe.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 17,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/qt/walletframe.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/qt/walletframe.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletframe.cpp?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -40,15 +40,11 @@ void WalletFrame::setClientModel(ClientModel *_clientModel)\n     this->clientModel = _clientModel;\n }\n \n-bool WalletFrame::addWallet(WalletModel *walletModel)\n+void WalletFrame::addWallet(WalletModel *walletModel)\n {\n-    if (!gui || !clientModel || !walletModel) {\n-        return false;\n-    }\n+    if (!gui || !clientModel || !walletModel) return;\n \n-    if (mapWalletViews.count(walletModel) > 0) {\n-        return false;\n-    }\n+    if (mapWalletViews.count(walletModel) > 0) return;\n \n     WalletView *walletView = new WalletView(platformStyle, this);\n     walletView->setBitcoinGUI(gui);\n@@ -72,31 +68,25 @@ bool WalletFrame::addWallet(WalletModel *walletModel)\n     });\n \n     connect(walletView, &WalletView::outOfSyncWarningClicked, this, &WalletFrame::outOfSyncWarningClicked);\n-\n-    return true;\n }\n \n-bool WalletFrame::setCurrentWallet(WalletModel* wallet_model)\n+void WalletFrame::setCurrentWallet(WalletModel* wallet_model)\n {\n-    if (mapWalletViews.count(wallet_model) == 0)\n-        return false;\n+    if (mapWalletViews.count(wallet_model) == 0) return;\n \n     WalletView *walletView = mapWalletViews.value(wallet_model);\n     walletStack->setCurrentWidget(walletView);\n     assert(walletView);\n     walletView->updateEncryptionStatus();\n-    return true;\n }\n \n-bool WalletFrame::removeWallet(WalletModel* wallet_model)\n+void WalletFrame::removeWallet(WalletModel* wallet_model)\n {\n-    if (mapWalletViews.count(wallet_model) == 0)\n-        return false;\n+    if (mapWalletViews.count(wallet_model) == 0) return;\n \n     WalletView *walletView = mapWalletViews.take(wallet_model);\n     walletStack->removeWidget(walletView);\n     delete walletView;\n-    return true;\n }\n \n void WalletFrame::removeAllWallets()"
      },
      {
        "sha": "156653f47dfa8b6a57372ce9dc612d859e7d50cf",
        "filename": "src/qt/walletframe.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/qt/walletframe.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/qt/walletframe.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletframe.h?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -36,9 +36,9 @@ class WalletFrame : public QFrame\n \n     void setClientModel(ClientModel *clientModel);\n \n-    bool addWallet(WalletModel *walletModel);\n-    bool setCurrentWallet(WalletModel* wallet_model);\n-    bool removeWallet(WalletModel* wallet_model);\n+    void addWallet(WalletModel *walletModel);\n+    void setCurrentWallet(WalletModel* wallet_model);\n+    void removeWallet(WalletModel* wallet_model);\n     void removeAllWallets();\n \n     bool handlePaymentRequest(const SendCoinsRecipient& recipient);"
      },
      {
        "sha": "baad3b2ce9afdf77d8c8e28dc02af1c6e408c69a",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -300,7 +300,7 @@ static bool rest_mempool_info(HTTPRequest* req, const std::string& strURIPart)\n \n     switch (rf) {\n     case RetFormat::JSON: {\n-        UniValue mempoolInfoObject = mempoolInfoToJSON();\n+        UniValue mempoolInfoObject = MempoolInfoToJSON(::mempool);\n \n         std::string strJSON = mempoolInfoObject.write() + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"application/json\");\n@@ -322,7 +322,7 @@ static bool rest_mempool_contents(HTTPRequest* req, const std::string& strURIPar\n \n     switch (rf) {\n     case RetFormat::JSON: {\n-        UniValue mempoolObject = mempoolToJSON(true);\n+        UniValue mempoolObject = MempoolToJSON(::mempool, true);\n \n         std::string strJSON = mempoolObject.write() + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"application/json\");"
      },
      {
        "sha": "1827aec637093c6cc84242679e1f17091705fbf8",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 31,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -405,9 +405,9 @@ static std::string EntryDescriptionString()\n            \"    \\\"bip125-replaceable\\\" : true|false,  (boolean) Whether this transaction could be replaced due to BIP125 (replace-by-fee)\\n\";\n }\n \n-static void entryToJSON(UniValue &info, const CTxMemPoolEntry &e) EXCLUSIVE_LOCKS_REQUIRED(::mempool.cs)\n+static void entryToJSON(const CTxMemPool& pool, UniValue& info, const CTxMemPoolEntry& e) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n {\n-    AssertLockHeld(mempool.cs);\n+    AssertLockHeld(pool.cs);\n \n     UniValue fees(UniValue::VOBJ);\n     fees.pushKV(\"base\", ValueFromAmount(e.GetFee()));\n@@ -427,12 +427,12 @@ static void entryToJSON(UniValue &info, const CTxMemPoolEntry &e) EXCLUSIVE_LOCK\n     info.pushKV(\"ancestorcount\", e.GetCountWithAncestors());\n     info.pushKV(\"ancestorsize\", e.GetSizeWithAncestors());\n     info.pushKV(\"ancestorfees\", e.GetModFeesWithAncestors());\n-    info.pushKV(\"wtxid\", mempool.vTxHashes[e.vTxHashesIdx].first.ToString());\n+    info.pushKV(\"wtxid\", pool.vTxHashes[e.vTxHashesIdx].first.ToString());\n     const CTransaction& tx = e.GetTx();\n     std::set<std::string> setDepends;\n     for (const CTxIn& txin : tx.vin)\n     {\n-        if (mempool.exists(txin.prevout.hash))\n+        if (pool.exists(txin.prevout.hash))\n             setDepends.insert(txin.prevout.hash.ToString());\n     }\n \n@@ -445,8 +445,8 @@ static void entryToJSON(UniValue &info, const CTxMemPoolEntry &e) EXCLUSIVE_LOCK\n     info.pushKV(\"depends\", depends);\n \n     UniValue spent(UniValue::VARR);\n-    const CTxMemPool::txiter &it = mempool.mapTx.find(tx.GetHash());\n-    const CTxMemPool::setEntries &setChildren = mempool.GetMemPoolChildren(it);\n+    const CTxMemPool::txiter& it = pool.mapTx.find(tx.GetHash());\n+    const CTxMemPool::setEntries& setChildren = pool.GetMemPoolChildren(it);\n     for (CTxMemPool::txiter childiter : setChildren) {\n         spent.push_back(childiter->GetTx().GetHash().ToString());\n     }\n@@ -455,7 +455,7 @@ static void entryToJSON(UniValue &info, const CTxMemPoolEntry &e) EXCLUSIVE_LOCK\n \n     // Add opt-in RBF status\n     bool rbfStatus = false;\n-    RBFTransactionState rbfState = IsRBFOptIn(tx, mempool);\n+    RBFTransactionState rbfState = IsRBFOptIn(tx, pool);\n     if (rbfState == RBFTransactionState::UNKNOWN) {\n         throw JSONRPCError(RPC_MISC_ERROR, \"Transaction is not in mempool\");\n     } else if (rbfState == RBFTransactionState::REPLACEABLE_BIP125) {\n@@ -465,25 +465,21 @@ static void entryToJSON(UniValue &info, const CTxMemPoolEntry &e) EXCLUSIVE_LOCK\n     info.pushKV(\"bip125-replaceable\", rbfStatus);\n }\n \n-UniValue mempoolToJSON(bool fVerbose)\n+UniValue MempoolToJSON(const CTxMemPool& pool, bool verbose)\n {\n-    if (fVerbose)\n-    {\n-        LOCK(mempool.cs);\n+    if (verbose) {\n+        LOCK(pool.cs);\n         UniValue o(UniValue::VOBJ);\n-        for (const CTxMemPoolEntry& e : mempool.mapTx)\n-        {\n+        for (const CTxMemPoolEntry& e : pool.mapTx) {\n             const uint256& hash = e.GetTx().GetHash();\n             UniValue info(UniValue::VOBJ);\n-            entryToJSON(info, e);\n+            entryToJSON(pool, info, e);\n             o.pushKV(hash.ToString(), info);\n         }\n         return o;\n-    }\n-    else\n-    {\n+    } else {\n         std::vector<uint256> vtxid;\n-        mempool.queryHashes(vtxid);\n+        pool.queryHashes(vtxid);\n \n         UniValue a(UniValue::VARR);\n         for (const uint256& hash : vtxid)\n@@ -525,7 +521,7 @@ static UniValue getrawmempool(const JSONRPCRequest& request)\n     if (!request.params[0].isNull())\n         fVerbose = request.params[0].get_bool();\n \n-    return mempoolToJSON(fVerbose);\n+    return MempoolToJSON(::mempool, fVerbose);\n }\n \n static UniValue getmempoolancestors(const JSONRPCRequest& request)\n@@ -591,7 +587,7 @@ static UniValue getmempoolancestors(const JSONRPCRequest& request)\n             const CTxMemPoolEntry &e = *ancestorIt;\n             const uint256& _hash = e.GetTx().GetHash();\n             UniValue info(UniValue::VOBJ);\n-            entryToJSON(info, e);\n+            entryToJSON(::mempool, info, e);\n             o.pushKV(_hash.ToString(), info);\n         }\n         return o;\n@@ -661,7 +657,7 @@ static UniValue getmempooldescendants(const JSONRPCRequest& request)\n             const CTxMemPoolEntry &e = *descendantIt;\n             const uint256& _hash = e.GetTx().GetHash();\n             UniValue info(UniValue::VOBJ);\n-            entryToJSON(info, e);\n+            entryToJSON(::mempool, info, e);\n             o.pushKV(_hash.ToString(), info);\n         }\n         return o;\n@@ -700,7 +696,7 @@ static UniValue getmempoolentry(const JSONRPCRequest& request)\n \n     const CTxMemPoolEntry &e = *it;\n     UniValue info(UniValue::VOBJ);\n-    entryToJSON(info, e);\n+    entryToJSON(::mempool, info, e);\n     return info;\n }\n \n@@ -1485,15 +1481,15 @@ static UniValue getchaintips(const JSONRPCRequest& request)\n     return res;\n }\n \n-UniValue mempoolInfoToJSON()\n+UniValue MempoolInfoToJSON(const CTxMemPool& pool)\n {\n     UniValue ret(UniValue::VOBJ);\n-    ret.pushKV(\"size\", (int64_t) mempool.size());\n-    ret.pushKV(\"bytes\", (int64_t) mempool.GetTotalTxSize());\n-    ret.pushKV(\"usage\", (int64_t) mempool.DynamicMemoryUsage());\n+    ret.pushKV(\"size\", (int64_t)pool.size());\n+    ret.pushKV(\"bytes\", (int64_t)pool.GetTotalTxSize());\n+    ret.pushKV(\"usage\", (int64_t)pool.DynamicMemoryUsage());\n     size_t maxmempool = gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n     ret.pushKV(\"maxmempool\", (int64_t) maxmempool);\n-    ret.pushKV(\"mempoolminfee\", ValueFromAmount(std::max(mempool.GetMinFee(maxmempool), ::minRelayTxFee).GetFeePerK()));\n+    ret.pushKV(\"mempoolminfee\", ValueFromAmount(std::max(pool.GetMinFee(maxmempool), ::minRelayTxFee).GetFeePerK()));\n     ret.pushKV(\"minrelaytxfee\", ValueFromAmount(::minRelayTxFee.GetFeePerK()));\n \n     return ret;\n@@ -1522,7 +1518,7 @@ static UniValue getmempoolinfo(const JSONRPCRequest& request)\n                 },\n             }.ToString());\n \n-    return mempoolInfoToJSON();\n+    return MempoolInfoToJSON(::mempool);\n }\n \n static UniValue preciousblock(const JSONRPCRequest& request)\n@@ -1583,15 +1579,15 @@ static UniValue invalidateblock(const JSONRPCRequest& request)\n     uint256 hash(ParseHashV(request.params[0], \"blockhash\"));\n     CValidationState state;\n \n+    CBlockIndex* pblockindex;\n     {\n         LOCK(cs_main);\n-        CBlockIndex* pblockindex = LookupBlockIndex(hash);\n+        pblockindex = LookupBlockIndex(hash);\n         if (!pblockindex) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n         }\n-\n-        InvalidateBlock(state, Params(), pblockindex);\n     }\n+    InvalidateBlock(state, Params(), pblockindex);\n \n     if (state.IsValid()) {\n         ActivateBestChain(state, Params());"
      },
      {
        "sha": "55d1de453fcd4ceb0f25fa47aacc610b903cf585",
        "filename": "src/rpc/blockchain.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/rpc/blockchain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/rpc/blockchain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.h?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -11,6 +11,7 @@\n \n class CBlock;\n class CBlockIndex;\n+class CTxMemPool;\n class UniValue;\n \n static constexpr int NUM_GETBLOCKSTATS_PERCENTILES = 5;\n@@ -30,10 +31,10 @@ void RPCNotifyBlockChange(bool ibd, const CBlockIndex *);\n UniValue blockToJSON(const CBlock& block, const CBlockIndex* tip, const CBlockIndex* blockindex, bool txDetails = false);\n \n /** Mempool information to JSON */\n-UniValue mempoolInfoToJSON();\n+UniValue MempoolInfoToJSON(const CTxMemPool& pool);\n \n /** Mempool to JSON */\n-UniValue mempoolToJSON(bool fVerbose = false);\n+UniValue MempoolToJSON(const CTxMemPool& pool, bool verbose = false);\n \n /** Block header to JSON */\n UniValue blockheaderToJSON(const CBlockIndex* tip, const CBlockIndex* blockindex);"
      },
      {
        "sha": "f2acb8fbf59773ff556698fb1986158b3a1f9036",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -843,7 +843,8 @@ static UniValue estimatesmartfee(const JSONRPCRequest& request)\n \n     RPCTypeCheck(request.params, {UniValue::VNUM, UniValue::VSTR});\n     RPCTypeCheckArgument(request.params[0], UniValue::VNUM);\n-    unsigned int conf_target = ParseConfirmTarget(request.params[0]);\n+    unsigned int max_target = ::feeEstimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE);\n+    unsigned int conf_target = ParseConfirmTarget(request.params[0], max_target);\n     bool conservative = true;\n     if (!request.params[1].isNull()) {\n         FeeEstimateMode fee_mode;\n@@ -915,7 +916,8 @@ static UniValue estimaterawfee(const JSONRPCRequest& request)\n \n     RPCTypeCheck(request.params, {UniValue::VNUM, UniValue::VNUM}, true);\n     RPCTypeCheckArgument(request.params[0], UniValue::VNUM);\n-    unsigned int conf_target = ParseConfirmTarget(request.params[0]);\n+    unsigned int max_target = ::feeEstimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE);\n+    unsigned int conf_target = ParseConfirmTarget(request.params[0], max_target);\n     double threshold = 0.95;\n     if (!request.params[1].isNull()) {\n         threshold = request.params[1].get_real();"
      },
      {
        "sha": "10979b43b0661b82bf6ee2053f29e33f28a934b8",
        "filename": "src/rpc/util.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/rpc/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/rpc/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.cpp?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -4,11 +4,9 @@\n \n #include <key_io.h>\n #include <keystore.h>\n-#include <policy/fees.h>\n #include <rpc/util.h>\n #include <tinyformat.h>\n #include <util/strencodings.h>\n-#include <validation.h>\n \n InitInterfaces* g_rpc_interfaces = nullptr;\n \n@@ -130,10 +128,9 @@ UniValue DescribeAddress(const CTxDestination& dest)\n     return boost::apply_visitor(DescribeAddressVisitor(), dest);\n }\n \n-unsigned int ParseConfirmTarget(const UniValue& value)\n+unsigned int ParseConfirmTarget(const UniValue& value, unsigned int max_target)\n {\n     int target = value.get_int();\n-    unsigned int max_target = ::feeEstimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE);\n     if (target < 1 || (unsigned int)target > max_target) {\n         throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid conf_target, must be between %u - %u\", 1, max_target));\n     }"
      },
      {
        "sha": "e4cc1fde441a9ea0d676c5bb84ef16d7dad465cf",
        "filename": "src/rpc/util.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/rpc/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/rpc/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.h?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -33,7 +33,7 @@ CScript CreateMultisigRedeemscript(const int required, const std::vector<CPubKey\n UniValue DescribeAddress(const CTxDestination& dest);\n \n //! Parse a confirm target option and raise an RPC error if it is invalid.\n-unsigned int ParseConfirmTarget(const UniValue& value);\n+unsigned int ParseConfirmTarget(const UniValue& value, unsigned int max_target);\n \n RPCErrorCode RPCErrorFromTransactionError(TransactionError terr);\n UniValue JSONRPCTransactionError(TransactionError terr, const std::string& err_string = \"\");"
      },
      {
        "sha": "cd0c36d802cee961abac8a4e2da7102183c45989",
        "filename": "src/test/blockfilter_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/test/blockfilter_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/test/blockfilter_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/blockfilter_tests.cpp?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -112,6 +112,12 @@ BOOST_AUTO_TEST_CASE(blockfilter_basic_test)\n     BOOST_CHECK_EQUAL(block_filter.GetFilterType(), block_filter2.GetFilterType());\n     BOOST_CHECK_EQUAL(block_filter.GetBlockHash(), block_filter2.GetBlockHash());\n     BOOST_CHECK(block_filter.GetEncodedFilter() == block_filter2.GetEncodedFilter());\n+\n+    BlockFilter default_ctor_block_filter_1;\n+    BlockFilter default_ctor_block_filter_2;\n+    BOOST_CHECK_EQUAL(default_ctor_block_filter_1.GetFilterType(), default_ctor_block_filter_2.GetFilterType());\n+    BOOST_CHECK_EQUAL(default_ctor_block_filter_1.GetBlockHash(), default_ctor_block_filter_2.GetBlockHash());\n+    BOOST_CHECK(default_ctor_block_filter_1.GetEncodedFilter() == default_ctor_block_filter_2.GetEncodedFilter());\n }\n \n BOOST_AUTO_TEST_CASE(blockfilters_json_test)"
      },
      {
        "sha": "8b03a7e46e6923c57092d9afd355f0ceedcdf3fd",
        "filename": "src/test/fuzz/fuzz.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/test/fuzz/fuzz.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/test/fuzz/fuzz.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/fuzz.h?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -10,8 +10,6 @@\n #include <vector>\n \n \n-const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n-\n void test_one_input(std::vector<uint8_t> buffer);\n \n #endif // BITCOIN_TEST_FUZZ_FUZZ_H"
      },
      {
        "sha": "ff3f36b56162f04d372ef5519d6f8165756cde7d",
        "filename": "src/test/main.cpp",
        "status": "added",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/test/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/test/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/main.cpp?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -0,0 +1,7 @@\n+// Copyright (c) 2011-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BOOST_TEST_MODULE Bitcoin Core Test Suite\n+\n+#include <boost/test/unit_test.hpp>"
      },
      {
        "sha": "cdfd4db589878e85db1122b452d3f60e052ba11b",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 30,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -66,36 +66,36 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n {\n     SetDataDir(\"tempdir\");\n     const CChainParams& chainparams = Params();\n-        // Ideally we'd move all the RPC tests to the functional testing framework\n-        // instead of unit tests, but for now we need these here.\n-\n-        RegisterAllCoreRPCCommands(tableRPC);\n-        ClearDatadirCache();\n-\n-        // We have to run a scheduler thread to prevent ActivateBestChain\n-        // from blocking due to queue overrun.\n-        threadGroup.create_thread(std::bind(&CScheduler::serviceQueue, &scheduler));\n-        GetMainSignals().RegisterBackgroundSignalScheduler(scheduler);\n-\n-        mempool.setSanityCheck(1.0);\n-        pblocktree.reset(new CBlockTreeDB(1 << 20, true));\n-        pcoinsdbview.reset(new CCoinsViewDB(1 << 23, true));\n-        pcoinsTip.reset(new CCoinsViewCache(pcoinsdbview.get()));\n-        if (!LoadGenesisBlock(chainparams)) {\n-            throw std::runtime_error(\"LoadGenesisBlock failed.\");\n-        }\n-        {\n-            CValidationState state;\n-            if (!ActivateBestChain(state, chainparams)) {\n-                throw std::runtime_error(strprintf(\"ActivateBestChain failed. (%s)\", FormatStateMessage(state)));\n-            }\n-        }\n-        nScriptCheckThreads = 3;\n-        for (int i=0; i < nScriptCheckThreads-1; i++)\n-            threadGroup.create_thread(&ThreadScriptCheck);\n-\n-        g_banman = MakeUnique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n-        g_connman = MakeUnique<CConnman>(0x1337, 0x1337); // Deterministic randomness for tests.\n+    // Ideally we'd move all the RPC tests to the functional testing framework\n+    // instead of unit tests, but for now we need these here.\n+\n+    RegisterAllCoreRPCCommands(tableRPC);\n+    ClearDatadirCache();\n+\n+    // We have to run a scheduler thread to prevent ActivateBestChain\n+    // from blocking due to queue overrun.\n+    threadGroup.create_thread(std::bind(&CScheduler::serviceQueue, &scheduler));\n+    GetMainSignals().RegisterBackgroundSignalScheduler(scheduler);\n+\n+    mempool.setSanityCheck(1.0);\n+    pblocktree.reset(new CBlockTreeDB(1 << 20, true));\n+    pcoinsdbview.reset(new CCoinsViewDB(1 << 23, true));\n+    pcoinsTip.reset(new CCoinsViewCache(pcoinsdbview.get()));\n+    if (!LoadGenesisBlock(chainparams)) {\n+        throw std::runtime_error(\"LoadGenesisBlock failed.\");\n+    }\n+\n+    CValidationState state;\n+    if (!ActivateBestChain(state, chainparams)) {\n+        throw std::runtime_error(strprintf(\"ActivateBestChain failed. (%s)\", FormatStateMessage(state)));\n+    }\n+\n+    nScriptCheckThreads = 3;\n+    for (int i = 0; i < nScriptCheckThreads - 1; i++)\n+        threadGroup.create_thread(&ThreadScriptCheck);\n+\n+    g_banman = MakeUnique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n+    g_connman = MakeUnique<CConnman>(0x1337, 0x1337); // Deterministic randomness for tests.\n }\n \n TestingSetup::~TestingSetup()"
      },
      {
        "sha": "38c6d85a8dcee30637e913f506a6cfd91ff33318",
        "filename": "src/test/test_bitcoin.h",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/test/test_bitcoin.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/test/test_bitcoin.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.h?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -71,10 +71,6 @@ struct BasicTestingSetup {\n /** Testing setup that configures a complete environment.\n  * Included are data directory, coins database, script check threads setup.\n  */\n-class CConnman;\n-class CNode;\n-\n-class PeerLogicValidation;\n struct TestingSetup : public BasicTestingSetup {\n     boost::thread_group threadGroup;\n     CScheduler scheduler;"
      },
      {
        "sha": "46b63b93b4a700092d25be55023e6c81c6f97ef8",
        "filename": "src/test/test_bitcoin_main.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 30,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46a2535615f8139e2ca9a37c3f5df32dd9ae07b0/src/test/test_bitcoin_main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46a2535615f8139e2ca9a37c3f5df32dd9ae07b0/src/test/test_bitcoin_main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin_main.cpp?ref=46a2535615f8139e2ca9a37c3f5df32dd9ae07b0",
        "patch": "@@ -1,30 +0,0 @@\n-// Copyright (c) 2011-2018 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#define BOOST_TEST_MODULE Bitcoin Test Suite\n-\n-#include <banman.h>\n-#include <net.h>\n-\n-#include <memory>\n-\n-#include <boost/test/unit_test.hpp>\n-\n-std::unique_ptr<CConnman> g_connman;\n-std::unique_ptr<BanMan> g_banman;\n-\n-[[noreturn]] void Shutdown(void* parg)\n-{\n-  std::exit(EXIT_SUCCESS);\n-}\n-\n-[[noreturn]] void StartShutdown()\n-{\n-  std::exit(EXIT_SUCCESS);\n-}\n-\n-bool ShutdownRequested()\n-{\n-  return false;\n-}"
      },
      {
        "sha": "8d06ecd3a923741c39c175ca93258a20b99d0bc5",
        "filename": "src/test/validation_tests.cpp",
        "status": "renamed",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/test/validation_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/test/validation_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_tests.cpp?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,17 +1,17 @@\n-// Copyright (c) 2014-2018 The Bitcoin Core developers\n+// Copyright (c) 2014-2019 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <chainparams.h>\n-#include <validation.h>\n #include <net.h>\n+#include <validation.h>\n \n #include <test/test_bitcoin.h>\n \n #include <boost/signals2/signal.hpp>\n #include <boost/test/unit_test.hpp>\n \n-BOOST_FIXTURE_TEST_SUITE(main_tests, TestingSetup)\n+BOOST_FIXTURE_TEST_SUITE(validation_tests, TestingSetup)\n \n static void TestBlockSubsidyHalvings(const Consensus::Params& consensusParams)\n {",
        "previous_filename": "src/test/main_tests.cpp"
      },
      {
        "sha": "ca556bdc7b566c191d34c3fb74706104b8d2c6fc",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -764,7 +764,7 @@ std::vector<CTxMemPool::indexed_transaction_set::const_iterator> CTxMemPool::Get\n     return iters;\n }\n \n-void CTxMemPool::queryHashes(std::vector<uint256>& vtxid)\n+void CTxMemPool::queryHashes(std::vector<uint256>& vtxid) const\n {\n     LOCK(cs);\n     auto iters = GetSortedDepthAndScore();"
      },
      {
        "sha": "a8a0f7fa45459eafec3451c43f35654534b21a96",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -184,7 +184,7 @@ struct update_lock_points\n     const LockPoints& lp;\n };\n \n-// extracts a transaction hash from CTxMempoolEntry or CTransactionRef\n+// extracts a transaction hash from CTxMemPoolEntry or CTransactionRef\n struct mempoolentry_txid\n {\n     typedef uint256 result_type;\n@@ -588,7 +588,7 @@ class CTxMemPool\n     void clear();\n     void _clear() EXCLUSIVE_LOCKS_REQUIRED(cs); //lock free\n     bool CompareDepthAndScore(const uint256& hasha, const uint256& hashb);\n-    void queryHashes(std::vector<uint256>& vtxid);\n+    void queryHashes(std::vector<uint256>& vtxid) const;\n     bool isSpent(const COutPoint& outpoint) const;\n     unsigned int GetTransactionsUpdated() const;\n     void AddTransactionsUpdated(unsigned int n);"
      },
      {
        "sha": "16ab24686b11799c7268e9cfa70b7da51be04463",
        "filename": "src/ui_interface.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/ui_interface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/ui_interface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ui_interface.cpp?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -52,7 +52,7 @@ void CClientUIInterface::InitMessage(const std::string& message) { return g_ui_s\n void CClientUIInterface::NotifyNumConnectionsChanged(int newNumConnections) { return g_ui_signals.NotifyNumConnectionsChanged(newNumConnections); }\n void CClientUIInterface::NotifyNetworkActiveChanged(bool networkActive) { return g_ui_signals.NotifyNetworkActiveChanged(networkActive); }\n void CClientUIInterface::NotifyAlertChanged() { return g_ui_signals.NotifyAlertChanged(); }\n-void CClientUIInterface::LoadWallet(std::shared_ptr<CWallet> wallet) { return g_ui_signals.LoadWallet(wallet); }\n+void CClientUIInterface::LoadWallet(std::unique_ptr<interfaces::Wallet>& wallet) { return g_ui_signals.LoadWallet(wallet); }\n void CClientUIInterface::ShowProgress(const std::string& title, int nProgress, bool resume_possible) { return g_ui_signals.ShowProgress(title, nProgress, resume_possible); }\n void CClientUIInterface::NotifyBlockTip(bool b, const CBlockIndex* i) { return g_ui_signals.NotifyBlockTip(b, i); }\n void CClientUIInterface::NotifyHeaderTip(bool b, const CBlockIndex* i) { return g_ui_signals.NotifyHeaderTip(b, i); }"
      },
      {
        "sha": "f1aebce3bb48a518fa7fe457816f0d06738f222f",
        "filename": "src/ui_interface.h",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/ui_interface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/ui_interface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ui_interface.h?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -11,14 +11,17 @@\n #include <stdint.h>\n #include <string>\n \n-class CWallet;\n class CBlockIndex;\n namespace boost {\n namespace signals2 {\n class connection;\n }\n } // namespace boost\n \n+namespace interfaces {\n+class Wallet;\n+} // namespace interfaces\n+\n /** General change type (added, updated, removed). */\n enum ChangeType\n {\n@@ -102,7 +105,7 @@ class CClientUIInterface\n     ADD_SIGNALS_DECL_WRAPPER(NotifyAlertChanged, void, );\n \n     /** A wallet has been loaded. */\n-    ADD_SIGNALS_DECL_WRAPPER(LoadWallet, void, std::shared_ptr<CWallet> wallet);\n+    ADD_SIGNALS_DECL_WRAPPER(LoadWallet, void, std::unique_ptr<interfaces::Wallet>& wallet);\n \n     /**\n      * Show progress e.g. for verifychain."
      },
      {
        "sha": "a9b5bcf4a450270b388c22a174287a2c9fef50b1",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 188,
        "deletions": 121,
        "changes": 309,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -178,7 +178,7 @@ class CChainState {\n \n     // Manual block validity manipulation:\n     bool PreciousBlock(CValidationState& state, const CChainParams& params, CBlockIndex* pindex) LOCKS_EXCLUDED(cs_main);\n-    bool InvalidateBlock(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool InvalidateBlock(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindex);\n     void ResetBlockFailureFlags(CBlockIndex* pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     bool ReplayBlocks(const CChainParams& params, CCoinsView* view);\n@@ -207,8 +207,10 @@ class CChainState {\n     CBlockIndex* FindMostWorkChain() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     void ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pindexNew, const FlatFilePos& pos, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n-\n     bool RollforwardBlock(const CBlockIndex* pindex, CCoinsViewCache& inputs, const CChainParams& params) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    //! Mark a block as not having block data\n+    void EraseBlockData(CBlockIndex* index) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n } g_chainstate;\n \n /**\n@@ -2626,6 +2628,14 @@ static void NotifyHeaderTip() LOCKS_EXCLUDED(cs_main) {\n     }\n }\n \n+static void LimitValidationInterfaceQueue() {\n+    AssertLockNotHeld(cs_main);\n+\n+    if (GetMainSignals().CallbacksPending() > 10) {\n+        SyncWithValidationInterfaceQueue();\n+    }\n+}\n+\n /**\n  * Make the best chain active, in multiple steps. The result is either failure\n  * or an activated best chain. pblock is either nullptr or a pointer to a block\n@@ -2654,15 +2664,13 @@ bool CChainState::ActivateBestChain(CValidationState &state, const CChainParams&\n     do {\n         boost::this_thread::interruption_point();\n \n-        if (GetMainSignals().CallbacksPending() > 10) {\n-            // Block until the validation queue drains. This should largely\n-            // never happen in normal operation, however may happen during\n-            // reindex, causing memory blowup if we run too far ahead.\n-            // Note that if a validationinterface callback ends up calling\n-            // ActivateBestChain this may lead to a deadlock! We should\n-            // probably have a DEBUG_LOCKORDER test for this in the future.\n-            SyncWithValidationInterfaceQueue();\n-        }\n+        // Block until the validation queue drains. This should largely\n+        // never happen in normal operation, however may happen during\n+        // reindex, causing memory blowup if we run too far ahead.\n+        // Note that if a validationinterface callback ends up calling\n+        // ActivateBestChain this may lead to a deadlock! We should\n+        // probably have a DEBUG_LOCKORDER test for this in the future.\n+        LimitValidationInterfaceQueue();\n \n         {\n             LOCK(cs_main);\n@@ -2773,64 +2781,85 @@ bool PreciousBlock(CValidationState& state, const CChainParams& params, CBlockIn\n \n bool CChainState::InvalidateBlock(CValidationState& state, const CChainParams& chainparams, CBlockIndex *pindex)\n {\n-    AssertLockHeld(cs_main);\n+    CBlockIndex* to_mark_failed = pindex;\n+    bool pindex_was_in_chain = false;\n+    int disconnected = 0;\n \n-    // We first disconnect backwards and then mark the blocks as invalid.\n-    // This prevents a case where pruned nodes may fail to invalidateblock\n-    // and be left unable to start as they have no tip candidates (as there\n-    // are no blocks that meet the \"have data and are not invalid per\n-    // nStatus\" criteria for inclusion in setBlockIndexCandidates).\n+    // Disconnect (descendants of) pindex, and mark them invalid.\n+    while (true) {\n+        if (ShutdownRequested()) break;\n \n-    bool pindex_was_in_chain = false;\n-    CBlockIndex *invalid_walk_tip = chainActive.Tip();\n+        // Make sure the queue of validation callbacks doesn't grow unboundedly.\n+        LimitValidationInterfaceQueue();\n \n-    DisconnectedBlockTransactions disconnectpool;\n-    while (chainActive.Contains(pindex)) {\n+        LOCK(cs_main);\n+        if (!chainActive.Contains(pindex)) break;\n         pindex_was_in_chain = true;\n+        CBlockIndex *invalid_walk_tip = chainActive.Tip();\n+\n         // ActivateBestChain considers blocks already in chainActive\n         // unconditionally valid already, so force disconnect away from it.\n-        if (!DisconnectTip(state, chainparams, &disconnectpool)) {\n-            // It's probably hopeless to try to make the mempool consistent\n-            // here if DisconnectTip failed, but we can try.\n-            UpdateMempoolForReorg(disconnectpool, false);\n-            return false;\n-        }\n-    }\n-\n-    // Now mark the blocks we just disconnected as descendants invalid\n-    // (note this may not be all descendants).\n-    while (pindex_was_in_chain && invalid_walk_tip != pindex) {\n-        invalid_walk_tip->nStatus |= BLOCK_FAILED_CHILD;\n+        DisconnectedBlockTransactions disconnectpool;\n+        bool ret = DisconnectTip(state, chainparams, &disconnectpool);\n+        // DisconnectTip will add transactions to disconnectpool.\n+        // Adjust the mempool to be consistent with the new tip, adding\n+        // transactions back to the mempool if disconnecting was succesful,\n+        // and we're not doing a very deep invalidation (in which case\n+        // keeping the mempool up to date is probably futile anyway).\n+        UpdateMempoolForReorg(disconnectpool, /* fAddToMempool = */ (++disconnected <= 10) && ret);\n+        if (!ret) return false;\n+        assert(invalid_walk_tip->pprev == chainActive.Tip());\n+\n+        // We immediately mark the disconnected blocks as invalid.\n+        // This prevents a case where pruned nodes may fail to invalidateblock\n+        // and be left unable to start as they have no tip candidates (as there\n+        // are no blocks that meet the \"have data and are not invalid per\n+        // nStatus\" criteria for inclusion in setBlockIndexCandidates).\n+        invalid_walk_tip->nStatus |= BLOCK_FAILED_VALID;\n         setDirtyBlockIndex.insert(invalid_walk_tip);\n         setBlockIndexCandidates.erase(invalid_walk_tip);\n-        invalid_walk_tip = invalid_walk_tip->pprev;\n-    }\n+        setBlockIndexCandidates.insert(invalid_walk_tip->pprev);\n+        if (invalid_walk_tip->pprev == to_mark_failed && (to_mark_failed->nStatus & BLOCK_FAILED_VALID)) {\n+            // We only want to mark the last disconnected block as BLOCK_FAILED_VALID; its children\n+            // need to be BLOCK_FAILED_CHILD instead.\n+            to_mark_failed->nStatus = (to_mark_failed->nStatus ^ BLOCK_FAILED_VALID) | BLOCK_FAILED_CHILD;\n+            setDirtyBlockIndex.insert(to_mark_failed);\n+        }\n \n-    // Mark the block itself as invalid.\n-    pindex->nStatus |= BLOCK_FAILED_VALID;\n-    setDirtyBlockIndex.insert(pindex);\n-    setBlockIndexCandidates.erase(pindex);\n-    m_failed_blocks.insert(pindex);\n+        // Track the last disconnected block, so we can correct its BLOCK_FAILED_CHILD status in future\n+        // iterations, or, if it's the last one, call InvalidChainFound on it.\n+        to_mark_failed = invalid_walk_tip;\n+    }\n \n-    // DisconnectTip will add transactions to disconnectpool; try to add these\n-    // back to the mempool.\n-    UpdateMempoolForReorg(disconnectpool, true);\n+    {\n+        LOCK(cs_main);\n+        if (chainActive.Contains(to_mark_failed)) {\n+            // If the to-be-marked invalid block is in the active chain, something is interfering and we can't proceed.\n+            return false;\n+        }\n \n-    // The resulting new best tip may not be in setBlockIndexCandidates anymore, so\n-    // add it again.\n-    BlockMap::iterator it = mapBlockIndex.begin();\n-    while (it != mapBlockIndex.end()) {\n-        if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->HaveTxsDownloaded() && !setBlockIndexCandidates.value_comp()(it->second, chainActive.Tip())) {\n-            setBlockIndexCandidates.insert(it->second);\n+        // Mark pindex (or the last disconnected block) as invalid, even when it never was in the main chain\n+        to_mark_failed->nStatus |= BLOCK_FAILED_VALID;\n+        setDirtyBlockIndex.insert(to_mark_failed);\n+        setBlockIndexCandidates.erase(to_mark_failed);\n+        m_failed_blocks.insert(to_mark_failed);\n+\n+        // The resulting new best tip may not be in setBlockIndexCandidates anymore, so\n+        // add it again.\n+        BlockMap::iterator it = mapBlockIndex.begin();\n+        while (it != mapBlockIndex.end()) {\n+            if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->HaveTxsDownloaded() && !setBlockIndexCandidates.value_comp()(it->second, chainActive.Tip())) {\n+                setBlockIndexCandidates.insert(it->second);\n+            }\n+            it++;\n         }\n-        it++;\n-    }\n \n-    InvalidChainFound(pindex);\n+        InvalidChainFound(to_mark_failed);\n+    }\n \n     // Only notify about a new block tip if the active chain was modified.\n     if (pindex_was_in_chain) {\n-        uiInterface.NotifyBlockTip(IsInitialBlockDownload(), pindex->pprev);\n+        uiInterface.NotifyBlockTip(IsInitialBlockDownload(), to_mark_failed->pprev);\n     }\n     return true;\n }\n@@ -4113,92 +4142,130 @@ bool ReplayBlocks(const CChainParams& params, CCoinsView* view) {\n     return g_chainstate.ReplayBlocks(params, view);\n }\n \n-bool CChainState::RewindBlockIndex(const CChainParams& params)\n+//! Helper for CChainState::RewindBlockIndex\n+void CChainState::EraseBlockData(CBlockIndex* index)\n {\n-    LOCK(cs_main);\n+    AssertLockHeld(cs_main);\n+    assert(!chainActive.Contains(index)); // Make sure this block isn't active\n+\n+    // Reduce validity\n+    index->nStatus = std::min<unsigned int>(index->nStatus & BLOCK_VALID_MASK, BLOCK_VALID_TREE) | (index->nStatus & ~BLOCK_VALID_MASK);\n+    // Remove have-data flags.\n+    index->nStatus &= ~(BLOCK_HAVE_DATA | BLOCK_HAVE_UNDO);\n+    // Remove storage location.\n+    index->nFile = 0;\n+    index->nDataPos = 0;\n+    index->nUndoPos = 0;\n+    // Remove various other things\n+    index->nTx = 0;\n+    index->nChainTx = 0;\n+    index->nSequenceId = 0;\n+    // Make sure it gets written.\n+    setDirtyBlockIndex.insert(index);\n+    // Update indexes\n+    setBlockIndexCandidates.erase(index);\n+    std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> ret = mapBlocksUnlinked.equal_range(index->pprev);\n+    while (ret.first != ret.second) {\n+        if (ret.first->second == index) {\n+            mapBlocksUnlinked.erase(ret.first++);\n+        } else {\n+            ++ret.first;\n+        }\n+    }\n+    // Mark parent as eligible for main chain again\n+    if (index->pprev && index->pprev->IsValid(BLOCK_VALID_TRANSACTIONS) && index->pprev->HaveTxsDownloaded()) {\n+        setBlockIndexCandidates.insert(index->pprev);\n+    }\n+}\n \n+bool CChainState::RewindBlockIndex(const CChainParams& params)\n+{\n     // Note that during -reindex-chainstate we are called with an empty chainActive!\n \n-    int nHeight = 1;\n-    while (nHeight <= chainActive.Height()) {\n-        // Although SCRIPT_VERIFY_WITNESS is now generally enforced on all\n-        // blocks in ConnectBlock, we don't need to go back and\n-        // re-download/re-verify blocks from before segwit actually activated.\n-        if (IsWitnessEnabled(chainActive[nHeight - 1], params.GetConsensus()) && !(chainActive[nHeight]->nStatus & BLOCK_OPT_WITNESS)) {\n-            break;\n+    // First erase all post-segwit blocks without witness not in the main chain,\n+    // as this can we done without costly DisconnectTip calls. Active\n+    // blocks will be dealt with below (releasing cs_main in between).\n+    {\n+        LOCK(cs_main);\n+        for (const auto& entry : mapBlockIndex) {\n+            if (IsWitnessEnabled(entry.second->pprev, params.GetConsensus()) && !(entry.second->nStatus & BLOCK_OPT_WITNESS) && !chainActive.Contains(entry.second)) {\n+                EraseBlockData(entry.second);\n+            }\n         }\n-        nHeight++;\n     }\n \n+    // Find what height we need to reorganize to.\n+    CBlockIndex *tip;\n+    int nHeight = 1;\n+    {\n+        LOCK(cs_main);\n+        while (nHeight <= chainActive.Height()) {\n+            // Although SCRIPT_VERIFY_WITNESS is now generally enforced on all\n+            // blocks in ConnectBlock, we don't need to go back and\n+            // re-download/re-verify blocks from before segwit actually activated.\n+            if (IsWitnessEnabled(chainActive[nHeight - 1], params.GetConsensus()) && !(chainActive[nHeight]->nStatus & BLOCK_OPT_WITNESS)) {\n+                break;\n+            }\n+            nHeight++;\n+        }\n+\n+        tip = chainActive.Tip();\n+    }\n     // nHeight is now the height of the first insufficiently-validated block, or tipheight + 1\n+\n     CValidationState state;\n-    CBlockIndex* pindex = chainActive.Tip();\n-    while (chainActive.Height() >= nHeight) {\n-        if (fPruneMode && !(chainActive.Tip()->nStatus & BLOCK_HAVE_DATA)) {\n-            // If pruning, don't try rewinding past the HAVE_DATA point;\n-            // since older blocks can't be served anyway, there's\n-            // no need to walk further, and trying to DisconnectTip()\n-            // will fail (and require a needless reindex/redownload\n-            // of the blockchain).\n-            break;\n-        }\n-        if (!DisconnectTip(state, params, nullptr)) {\n-            return error(\"RewindBlockIndex: unable to disconnect block at height %i (%s)\", pindex->nHeight, FormatStateMessage(state));\n+    // Loop until the tip is below nHeight, or we reach a pruned block.\n+    while (!ShutdownRequested()) {\n+        {\n+            LOCK(cs_main);\n+            // Make sure nothing changed from under us (this won't happen because RewindBlockIndex runs before importing/network are active)\n+            assert(tip == chainActive.Tip());\n+            if (tip == nullptr || tip->nHeight < nHeight) break;\n+            if (fPruneMode && !(tip->nStatus & BLOCK_HAVE_DATA)) {\n+                // If pruning, don't try rewinding past the HAVE_DATA point;\n+                // since older blocks can't be served anyway, there's\n+                // no need to walk further, and trying to DisconnectTip()\n+                // will fail (and require a needless reindex/redownload\n+                // of the blockchain).\n+                break;\n+            }\n+\n+            // Disconnect block\n+            if (!DisconnectTip(state, params, nullptr)) {\n+                return error(\"RewindBlockIndex: unable to disconnect block at height %i (%s)\", tip->nHeight, FormatStateMessage(state));\n+            }\n+\n+            // Reduce validity flag and have-data flags.\n+            // We do this after actual disconnecting, otherwise we'll end up writing the lack of data\n+            // to disk before writing the chainstate, resulting in a failure to continue if interrupted.\n+            // Note: If we encounter an insufficiently validated block that\n+            // is on chainActive, it must be because we are a pruning node, and\n+            // this block or some successor doesn't HAVE_DATA, so we were unable to\n+            // rewind all the way.  Blocks remaining on chainActive at this point\n+            // must not have their validity reduced.\n+            EraseBlockData(tip);\n+\n+            tip = tip->pprev;\n         }\n+        // Make sure the queue of validation callbacks doesn't grow unboundedly.\n+        LimitValidationInterfaceQueue();\n+\n         // Occasionally flush state to disk.\n         if (!FlushStateToDisk(params, state, FlushStateMode::PERIODIC)) {\n             LogPrintf(\"RewindBlockIndex: unable to flush state to disk (%s)\\n\", FormatStateMessage(state));\n             return false;\n         }\n     }\n \n-    // Reduce validity flag and have-data flags.\n-    // We do this after actual disconnecting, otherwise we'll end up writing the lack of data\n-    // to disk before writing the chainstate, resulting in a failure to continue if interrupted.\n-    for (const auto& entry : mapBlockIndex) {\n-        CBlockIndex* pindexIter = entry.second;\n-\n-        // Note: If we encounter an insufficiently validated block that\n-        // is on chainActive, it must be because we are a pruning node, and\n-        // this block or some successor doesn't HAVE_DATA, so we were unable to\n-        // rewind all the way.  Blocks remaining on chainActive at this point\n-        // must not have their validity reduced.\n-        if (IsWitnessEnabled(pindexIter->pprev, params.GetConsensus()) && !(pindexIter->nStatus & BLOCK_OPT_WITNESS) && !chainActive.Contains(pindexIter)) {\n-            // Reduce validity\n-            pindexIter->nStatus = std::min<unsigned int>(pindexIter->nStatus & BLOCK_VALID_MASK, BLOCK_VALID_TREE) | (pindexIter->nStatus & ~BLOCK_VALID_MASK);\n-            // Remove have-data flags.\n-            pindexIter->nStatus &= ~(BLOCK_HAVE_DATA | BLOCK_HAVE_UNDO);\n-            // Remove storage location.\n-            pindexIter->nFile = 0;\n-            pindexIter->nDataPos = 0;\n-            pindexIter->nUndoPos = 0;\n-            // Remove various other things\n-            pindexIter->nTx = 0;\n-            pindexIter->nChainTx = 0;\n-            pindexIter->nSequenceId = 0;\n-            // Make sure it gets written.\n-            setDirtyBlockIndex.insert(pindexIter);\n-            // Update indexes\n-            setBlockIndexCandidates.erase(pindexIter);\n-            std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> ret = mapBlocksUnlinked.equal_range(pindexIter->pprev);\n-            while (ret.first != ret.second) {\n-                if (ret.first->second == pindexIter) {\n-                    mapBlocksUnlinked.erase(ret.first++);\n-                } else {\n-                    ++ret.first;\n-                }\n-            }\n-        } else if (pindexIter->IsValid(BLOCK_VALID_TRANSACTIONS) && pindexIter->HaveTxsDownloaded()) {\n-            setBlockIndexCandidates.insert(pindexIter);\n-        }\n-    }\n-\n-    if (chainActive.Tip() != nullptr) {\n-        // We can't prune block index candidates based on our tip if we have\n-        // no tip due to chainActive being empty!\n-        PruneBlockIndexCandidates();\n+    {\n+        LOCK(cs_main);\n+        if (chainActive.Tip() != nullptr) {\n+            // We can't prune block index candidates based on our tip if we have\n+            // no tip due to chainActive being empty!\n+            PruneBlockIndexCandidates();\n \n-        CheckBlockIndex(params.GetConsensus());\n+            CheckBlockIndex(params.GetConsensus());\n+        }\n     }\n \n     return true;"
      },
      {
        "sha": "0acca013b57b26311d19190a12af8b88100b2d6f",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -443,7 +443,7 @@ CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& loc\n bool PreciousBlock(CValidationState& state, const CChainParams& params, CBlockIndex *pindex) LOCKS_EXCLUDED(cs_main);\n \n /** Mark a block as invalid. */\n-bool InvalidateBlock(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+bool InvalidateBlock(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindex);\n \n /** Remove invalidity status from a block and its descendants. */\n void ResetBlockFailureFlags(CBlockIndex* pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);"
      },
      {
        "sha": "a1c3a21d4b186e61b974d9fcd39036c8e98ecaca",
        "filename": "src/wallet/feebumper.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 6,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/wallet/feebumper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/wallet/feebumper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.cpp?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -27,9 +27,7 @@ static feebumper::Result PreconditionChecks(interfaces::Chain::Lock& locked_chai\n     }\n \n     {\n-        LOCK(mempool.cs);\n-        auto it_mp = mempool.mapTx.find(wtx.GetHash());\n-        if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n+        if (wallet->chain().hasDescendantsInMempool(wtx.GetHash())) {\n             errors.push_back(\"Transaction has descendants in the mempool\");\n             return feebumper::Result::INVALID_PARAMETER;\n         }\n@@ -146,7 +144,7 @@ Result CreateTransaction(const CWallet* wallet, const uint256& txid, const CCoin\n         new_fee = total_fee;\n         nNewFeeRate = CFeeRate(total_fee, maxNewTxSize);\n     } else {\n-        new_fee = GetMinimumFee(*wallet, maxNewTxSize, coin_control, mempool, ::feeEstimator, nullptr /* FeeCalculation */);\n+        new_fee = GetMinimumFee(*wallet, maxNewTxSize, coin_control, nullptr /* FeeCalculation */);\n         nNewFeeRate = CFeeRate(new_fee, maxNewTxSize);\n \n         // New fee rate must be at least old rate + minimum incremental relay rate\n@@ -197,7 +195,7 @@ Result CreateTransaction(const CWallet* wallet, const uint256& txid, const CCoin\n \n     // If the output would become dust, discard it (converting the dust to fee)\n     poutput->nValue -= nDelta;\n-    if (poutput->nValue <= GetDustThreshold(*poutput, GetDiscardRate(*wallet, ::feeEstimator))) {\n+    if (poutput->nValue <= GetDustThreshold(*poutput, GetDiscardRate(*wallet))) {\n         wallet->WalletLogPrintf(\"Bumping fee and discarding dust output\\n\");\n         new_fee += poutput->nValue;\n         mtx.vout.erase(mtx.vout.begin() + nOutput);\n@@ -247,7 +245,7 @@ Result CommitTransaction(CWallet* wallet, const uint256& txid, CMutableTransacti\n \n     CReserveKey reservekey(wallet);\n     CValidationState state;\n-    if (!wallet->CommitTransaction(tx, std::move(mapValue), oldWtx.vOrderForm, reservekey, g_connman.get(), state)) {\n+    if (!wallet->CommitTransaction(tx, std::move(mapValue), oldWtx.vOrderForm, reservekey, state)) {\n         // NOTE: CommitTransaction never returns false, so this should never happen.\n         errors.push_back(strprintf(\"The transaction was rejected: %s\", FormatStateMessage(state)));\n         return Result::WALLET_ERROR;"
      },
      {
        "sha": "545adaebc18c97450343fa3dd7706354c3ea3bac",
        "filename": "src/wallet/fees.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 9,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/wallet/fees.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/wallet/fees.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/fees.cpp?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -6,7 +6,6 @@\n #include <wallet/fees.h>\n \n #include <policy/policy.h>\n-#include <txmempool.h>\n #include <util/system.h>\n #include <validation.h>\n #include <wallet/coincontrol.h>\n@@ -19,9 +18,9 @@ CAmount GetRequiredFee(const CWallet& wallet, unsigned int nTxBytes)\n }\n \n \n-CAmount GetMinimumFee(const CWallet& wallet, unsigned int nTxBytes, const CCoinControl& coin_control, const CTxMemPool& pool, const CBlockPolicyEstimator& estimator, FeeCalculation* feeCalc)\n+CAmount GetMinimumFee(const CWallet& wallet, unsigned int nTxBytes, const CCoinControl& coin_control, FeeCalculation* feeCalc)\n {\n-    CAmount fee_needed = GetMinimumFeeRate(wallet, coin_control, pool, estimator, feeCalc).GetFee(nTxBytes);\n+    CAmount fee_needed = GetMinimumFeeRate(wallet, coin_control, feeCalc).GetFee(nTxBytes);\n     // Always obey the maximum\n     if (fee_needed > maxTxFee) {\n         fee_needed = maxTxFee;\n@@ -35,7 +34,7 @@ CFeeRate GetRequiredFeeRate(const CWallet& wallet)\n     return std::max(wallet.m_min_fee, ::minRelayTxFee);\n }\n \n-CFeeRate GetMinimumFeeRate(const CWallet& wallet, const CCoinControl& coin_control, const CTxMemPool& pool, const CBlockPolicyEstimator& estimator, FeeCalculation* feeCalc)\n+CFeeRate GetMinimumFeeRate(const CWallet& wallet, const CCoinControl& coin_control, FeeCalculation* feeCalc)\n {\n     /* User control of how to calculate fee uses the following parameter precedence:\n        1. coin_control.m_feerate\n@@ -64,7 +63,7 @@ CFeeRate GetMinimumFeeRate(const CWallet& wallet, const CCoinControl& coin_contr\n         if (coin_control.m_fee_mode == FeeEstimateMode::CONSERVATIVE) conservative_estimate = true;\n         else if (coin_control.m_fee_mode == FeeEstimateMode::ECONOMICAL) conservative_estimate = false;\n \n-        feerate_needed = estimator.estimateSmartFee(target, feeCalc, conservative_estimate);\n+        feerate_needed = wallet.chain().estimateSmartFee(target, conservative_estimate, feeCalc);\n         if (feerate_needed == CFeeRate(0)) {\n             // if we don't have enough data for estimateSmartFee, then use fallback fee\n             feerate_needed = wallet.m_fallback_fee;\n@@ -74,7 +73,7 @@ CFeeRate GetMinimumFeeRate(const CWallet& wallet, const CCoinControl& coin_contr\n             if (wallet.m_fallback_fee == CFeeRate(0)) return feerate_needed;\n         }\n         // Obey mempool min fee when using smart fee estimation\n-        CFeeRate min_mempool_feerate = pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+        CFeeRate min_mempool_feerate = wallet.chain().mempoolMinFee();\n         if (feerate_needed < min_mempool_feerate) {\n             feerate_needed = min_mempool_feerate;\n             if (feeCalc) feeCalc->reason = FeeReason::MEMPOOL_MIN;\n@@ -90,10 +89,10 @@ CFeeRate GetMinimumFeeRate(const CWallet& wallet, const CCoinControl& coin_contr\n     return feerate_needed;\n }\n \n-CFeeRate GetDiscardRate(const CWallet& wallet, const CBlockPolicyEstimator& estimator)\n+CFeeRate GetDiscardRate(const CWallet& wallet)\n {\n-    unsigned int highest_target = estimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE);\n-    CFeeRate discard_rate = estimator.estimateSmartFee(highest_target, nullptr /* FeeCalculation */, false /* conservative */);\n+    unsigned int highest_target = wallet.chain().estimateMaxBlocks();\n+    CFeeRate discard_rate = wallet.chain().estimateSmartFee(highest_target, false /* conservative */);\n     // Don't let discard_rate be greater than longest possible fee estimate if we get a valid fee estimate\n     discard_rate = (discard_rate == CFeeRate(0)) ? wallet.m_discard_rate : std::min(discard_rate, wallet.m_discard_rate);\n     // Discard rate must be at least dustRelayFee"
      },
      {
        "sha": "434f211dc243c15be2c05e981497267eec766d99",
        "filename": "src/wallet/fees.h",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/wallet/fees.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/wallet/fees.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/fees.h?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -8,10 +8,8 @@\n \n #include <amount.h>\n \n-class CBlockPolicyEstimator;\n class CCoinControl;\n class CFeeRate;\n-class CTxMemPool;\n class CWallet;\n struct FeeCalculation;\n \n@@ -25,7 +23,7 @@ CAmount GetRequiredFee(const CWallet& wallet, unsigned int nTxBytes);\n  * Estimate the minimum fee considering user set parameters\n  * and the required fee\n  */\n-CAmount GetMinimumFee(const CWallet& wallet, unsigned int nTxBytes, const CCoinControl& coin_control, const CTxMemPool& pool, const CBlockPolicyEstimator& estimator, FeeCalculation* feeCalc);\n+CAmount GetMinimumFee(const CWallet& wallet, unsigned int nTxBytes, const CCoinControl& coin_control, FeeCalculation* feeCalc);\n \n /**\n  * Return the minimum required feerate taking into account the\n@@ -37,11 +35,11 @@ CFeeRate GetRequiredFeeRate(const CWallet& wallet);\n  * Estimate the minimum fee rate considering user set parameters\n  * and the required fee\n  */\n-CFeeRate GetMinimumFeeRate(const CWallet& wallet, const CCoinControl& coin_control, const CTxMemPool& pool, const CBlockPolicyEstimator& estimator, FeeCalculation* feeCalc);\n+CFeeRate GetMinimumFeeRate(const CWallet& wallet, const CCoinControl& coin_control, FeeCalculation* feeCalc);\n \n /**\n  * Return the maximum feerate for discarding change.\n  */\n-CFeeRate GetDiscardRate(const CWallet& wallet, const CBlockPolicyEstimator& estimator);\n+CFeeRate GetDiscardRate(const CWallet& wallet);\n \n #endif // BITCOIN_WALLET_FEES_H"
      },
      {
        "sha": "7ad343c15fc873d5317151566416c8d87f67fe9e",
        "filename": "src/wallet/init.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 6,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/wallet/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/wallet/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/init.cpp?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -138,12 +138,15 @@ bool VerifyWallets(interfaces::Chain& chain, const std::vector<std::string>& wal\n         // The canonical path cleans the path, preventing >1 Berkeley environment instances for the same directory\n         fs::path canonical_wallet_dir = fs::canonical(wallet_dir, error);\n         if (error || !fs::exists(wallet_dir)) {\n-            return InitError(strprintf(_(\"Specified -walletdir \\\"%s\\\" does not exist\"), wallet_dir.string()));\n+            chain.initError(strprintf(_(\"Specified -walletdir \\\"%s\\\" does not exist\"), wallet_dir.string()));\n+            return false;\n         } else if (!fs::is_directory(wallet_dir)) {\n-            return InitError(strprintf(_(\"Specified -walletdir \\\"%s\\\" is not a directory\"), wallet_dir.string()));\n+            chain.initError(strprintf(_(\"Specified -walletdir \\\"%s\\\" is not a directory\"), wallet_dir.string()));\n+            return false;\n         // The canonical path transforms relative paths into absolute ones, so we check the non-canonical version\n         } else if (!wallet_dir.is_absolute()) {\n-            return InitError(strprintf(_(\"Specified -walletdir \\\"%s\\\" is a relative path\"), wallet_dir.string()));\n+            chain.initError(strprintf(_(\"Specified -walletdir \\\"%s\\\" is a relative path\"), wallet_dir.string()));\n+            return false;\n         }\n         gArgs.ForceSetArg(\"-walletdir\", canonical_wallet_dir.string());\n     }\n@@ -164,14 +167,15 @@ bool VerifyWallets(interfaces::Chain& chain, const std::vector<std::string>& wal\n         WalletLocation location(wallet_file);\n \n         if (!wallet_paths.insert(location.GetPath()).second) {\n-            return InitError(strprintf(_(\"Error loading wallet %s. Duplicate -wallet filename specified.\"), wallet_file));\n+            chain.initError(strprintf(_(\"Error loading wallet %s. Duplicate -wallet filename specified.\"), wallet_file));\n+            return false;\n         }\n \n         std::string error_string;\n         std::string warning_string;\n         bool verify_success = CWallet::Verify(chain, location, salvage_wallet, error_string, warning_string);\n-        if (!error_string.empty()) InitError(error_string);\n-        if (!warning_string.empty()) InitWarning(warning_string);\n+        if (!error_string.empty()) chain.initError(error_string);\n+        if (!warning_string.empty()) chain.initWarning(warning_string);\n         if (!verify_success) return false;\n     }\n "
      },
      {
        "sha": "684d900478924a81acce9a196376c32b0e804d37",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 4,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -157,8 +157,9 @@ UniValue importprivkey(const JSONRPCRequest& request)\n         if (!request.params[2].isNull())\n             fRescan = request.params[2].get_bool();\n \n-        if (fRescan && fPruneMode)\n+        if (fRescan && pwallet->chain().getPruneMode()) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"Rescan is disabled in pruned mode\");\n+        }\n \n         if (fRescan && !reserver.reserve()) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"Wallet is currently rescanning. Abort existing rescan or wait.\");\n@@ -313,8 +314,9 @@ UniValue importaddress(const JSONRPCRequest& request)\n     if (!request.params[2].isNull())\n         fRescan = request.params[2].get_bool();\n \n-    if (fRescan && fPruneMode)\n+    if (fRescan && pwallet->chain().getPruneMode()) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Rescan is disabled in pruned mode\");\n+    }\n \n     WalletRescanReserver reserver(pwallet);\n     if (fRescan && !reserver.reserve()) {\n@@ -501,8 +503,9 @@ UniValue importpubkey(const JSONRPCRequest& request)\n     if (!request.params[2].isNull())\n         fRescan = request.params[2].get_bool();\n \n-    if (fRescan && fPruneMode)\n+    if (fRescan && pwallet->chain().getPruneMode()) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Rescan is disabled in pruned mode\");\n+    }\n \n     WalletRescanReserver reserver(pwallet);\n     if (fRescan && !reserver.reserve()) {\n@@ -562,8 +565,9 @@ UniValue importwallet(const JSONRPCRequest& request)\n                 },\n             }.ToString());\n \n-    if (fPruneMode)\n+    if (pwallet->chain().getPruneMode()) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Importing wallets is disabled in pruned mode\");\n+    }\n \n     WalletRescanReserver reserver(pwallet);\n     if (!reserver.reserve()) {"
      },
      {
        "sha": "31a3209a49e770843f48990be6fd79f7b51d2cbd",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 20,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -123,8 +123,7 @@ static void WalletTxToJSON(interfaces::Chain& chain, interfaces::Chain::Lock& lo\n     // Add opt-in RBF status\n     std::string rbfStatus = \"no\";\n     if (confirms <= 0) {\n-        LOCK(mempool.cs);\n-        RBFTransactionState rbfState = IsRBFOptIn(*wtx.tx, mempool);\n+        RBFTransactionState rbfState = chain.isRBFOptIn(*wtx.tx);\n         if (rbfState == RBFTransactionState::UNKNOWN)\n             rbfStatus = \"unknown\";\n         else if (rbfState == RBFTransactionState::REPLACEABLE_BIP125)\n@@ -318,7 +317,7 @@ static CTransactionRef SendMoney(interfaces::Chain::Lock& locked_chain, CWallet\n     if (nValue > curBalance)\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Insufficient funds\");\n \n-    if (pwallet->GetBroadcastTransactions() && !g_connman) {\n+    if (pwallet->GetBroadcastTransactions() && !pwallet->chain().p2pEnabled()) {\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n     }\n \n@@ -340,7 +339,7 @@ static CTransactionRef SendMoney(interfaces::Chain::Lock& locked_chain, CWallet\n         throw JSONRPCError(RPC_WALLET_ERROR, strError);\n     }\n     CValidationState state;\n-    if (!pwallet->CommitTransaction(tx, std::move(mapValue), {} /* orderForm */, reservekey, g_connman.get(), state)) {\n+    if (!pwallet->CommitTransaction(tx, std::move(mapValue), {} /* orderForm */, reservekey, state)) {\n         strError = strprintf(\"Error: The transaction was rejected! Reason given: %s\", FormatStateMessage(state));\n         throw JSONRPCError(RPC_WALLET_ERROR, strError);\n     }\n@@ -424,7 +423,7 @@ static UniValue sendtoaddress(const JSONRPCRequest& request)\n     }\n \n     if (!request.params[6].isNull()) {\n-        coin_control.m_confirm_target = ParseConfirmTarget(request.params[6]);\n+        coin_control.m_confirm_target = ParseConfirmTarget(request.params[6], pwallet->chain().estimateMaxBlocks());\n     }\n \n     if (!request.params[7].isNull()) {\n@@ -606,7 +605,6 @@ static UniValue getreceivedbyaddress(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    LockAnnotation lock(::cs_main); // Temporary, for CheckFinalTx below. Removed in upcoming commit.\n     auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n@@ -629,8 +627,9 @@ static UniValue getreceivedbyaddress(const JSONRPCRequest& request)\n     CAmount nAmount = 0;\n     for (const std::pair<const uint256, CWalletTx>& pairWtx : pwallet->mapWallet) {\n         const CWalletTx& wtx = pairWtx.second;\n-        if (wtx.IsCoinBase() || !CheckFinalTx(*wtx.tx))\n+        if (wtx.IsCoinBase() || !locked_chain->checkFinalTx(*wtx.tx)) {\n             continue;\n+        }\n \n         for (const CTxOut& txout : wtx.tx->vout)\n             if (txout.scriptPubKey == scriptPubKey)\n@@ -678,7 +677,6 @@ static UniValue getreceivedbylabel(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    LockAnnotation lock(::cs_main); // Temporary, for CheckFinalTx below. Removed in upcoming commit.\n     auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n@@ -695,8 +693,9 @@ static UniValue getreceivedbylabel(const JSONRPCRequest& request)\n     CAmount nAmount = 0;\n     for (const std::pair<const uint256, CWalletTx>& pairWtx : pwallet->mapWallet) {\n         const CWalletTx& wtx = pairWtx.second;\n-        if (wtx.IsCoinBase() || !CheckFinalTx(*wtx.tx))\n+        if (wtx.IsCoinBase() || !locked_chain->checkFinalTx(*wtx.tx)) {\n             continue;\n+        }\n \n         for (const CTxOut& txout : wtx.tx->vout)\n         {\n@@ -860,7 +859,7 @@ static UniValue sendmany(const JSONRPCRequest& request)\n     auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n-    if (pwallet->GetBroadcastTransactions() && !g_connman) {\n+    if (pwallet->GetBroadcastTransactions() && !pwallet->chain().p2pEnabled()) {\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n     }\n \n@@ -886,7 +885,7 @@ static UniValue sendmany(const JSONRPCRequest& request)\n     }\n \n     if (!request.params[6].isNull()) {\n-        coin_control.m_confirm_target = ParseConfirmTarget(request.params[6]);\n+        coin_control.m_confirm_target = ParseConfirmTarget(request.params[6], pwallet->chain().estimateMaxBlocks());\n     }\n \n     if (!request.params[7].isNull()) {\n@@ -948,7 +947,7 @@ static UniValue sendmany(const JSONRPCRequest& request)\n     if (!fCreated)\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, strFailReason);\n     CValidationState state;\n-    if (!pwallet->CommitTransaction(tx, std::move(mapValue), {} /* orderForm */, keyChange, g_connman.get(), state)) {\n+    if (!pwallet->CommitTransaction(tx, std::move(mapValue), {} /* orderForm */, keyChange, state)) {\n         strFailReason = strprintf(\"Transaction commit failed:: %s\", FormatStateMessage(state));\n         throw JSONRPCError(RPC_WALLET_ERROR, strFailReason);\n     }\n@@ -1050,8 +1049,6 @@ struct tallyitem\n \n static UniValue ListReceived(interfaces::Chain::Lock& locked_chain, CWallet * const pwallet, const UniValue& params, bool by_label) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    LockAnnotation lock(::cs_main); // Temporary, for CheckFinalTx below. Removed in upcoming commit.\n-\n     // Minimum confirmations\n     int nMinDepth = 1;\n     if (!params[0].isNull())\n@@ -1082,8 +1079,9 @@ static UniValue ListReceived(interfaces::Chain::Lock& locked_chain, CWallet * co\n     for (const std::pair<const uint256, CWalletTx>& pairWtx : pwallet->mapWallet) {\n         const CWalletTx& wtx = pairWtx.second;\n \n-        if (wtx.IsCoinBase() || !CheckFinalTx(*wtx.tx))\n+        if (wtx.IsCoinBase() || !locked_chain.checkFinalTx(*wtx.tx)) {\n             continue;\n+        }\n \n         int nDepth = wtx.GetDepthInMainChain(locked_chain);\n         if (nDepth < nMinDepth)\n@@ -2694,8 +2692,9 @@ static UniValue resendwallettransactions(const JSONRPCRequest& request)\n              }.ToString()\n             );\n \n-    if (!g_connman)\n+    if (!pwallet->chain().p2pEnabled()) {\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n+    }\n \n     auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n@@ -2704,7 +2703,7 @@ static UniValue resendwallettransactions(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Error: Wallet transaction broadcasting is disabled with -walletbroadcast\");\n     }\n \n-    std::vector<uint256> txids = pwallet->ResendWalletTransactionsBefore(*locked_chain, GetTime(), g_connman.get());\n+    std::vector<uint256> txids = pwallet->ResendWalletTransactionsBefore(*locked_chain, GetTime());\n     UniValue result(UniValue::VARR);\n     for (const uint256& txid : txids)\n     {\n@@ -2993,7 +2992,7 @@ void FundTransaction(CWallet* const pwallet, CMutableTransaction& tx, CAmount& f\n             if (options.exists(\"feeRate\")) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot specify both conf_target and feeRate\");\n             }\n-            coinControl.m_confirm_target = ParseConfirmTarget(options[\"conf_target\"]);\n+            coinControl.m_confirm_target = ParseConfirmTarget(options[\"conf_target\"], pwallet->chain().estimateMaxBlocks());\n         }\n         if (options.exists(\"estimate_mode\")) {\n             if (options.exists(\"feeRate\")) {\n@@ -3283,7 +3282,7 @@ static UniValue bumpfee(const JSONRPCRequest& request)\n         if (options.exists(\"confTarget\") && options.exists(\"totalFee\")) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"confTarget and totalFee options should not both be set. Please provide either a confirmation target for fee estimation or an explicit total fee for the transaction.\");\n         } else if (options.exists(\"confTarget\")) { // TODO: alias this to conf_target\n-            coin_control.m_confirm_target = ParseConfirmTarget(options[\"confTarget\"]);\n+            coin_control.m_confirm_target = ParseConfirmTarget(options[\"confTarget\"], pwallet->chain().estimateMaxBlocks());\n         } else if (options.exists(\"totalFee\")) {\n             totalFee = options[\"totalFee\"].get_int64();\n             if (totalFee <= 0) {\n@@ -3837,7 +3836,7 @@ UniValue sethdseed(const JSONRPCRequest& request)\n             }.ToString());\n     }\n \n-    if (IsInitialBlockDownload()) {\n+    if (pwallet->chain().isInitialBlockDownload()) {\n         throw JSONRPCError(RPC_CLIENT_IN_INITIAL_DOWNLOAD, \"Cannot set a new HD seed while still in Initial Block Download\");\n     }\n "
      },
      {
        "sha": "af57dbf5f6dbe25ab9d24f69a4edc29ac82c1742",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -368,7 +368,7 @@ class ListCoinsTestingSetup : public TestChain100Setup\n         CCoinControl dummy;\n         BOOST_CHECK(wallet->CreateTransaction(*m_locked_chain, {recipient}, tx, reservekey, fee, changePos, error, dummy));\n         CValidationState state;\n-        BOOST_CHECK(wallet->CommitTransaction(tx, {}, {}, reservekey, nullptr, state));\n+        BOOST_CHECK(wallet->CommitTransaction(tx, {}, {}, reservekey, state));\n         CMutableTransaction blocktx;\n         {\n             LOCK(wallet->cs_wallet);"
      },
      {
        "sha": "e47f5fa95632c5e172a3c2af7fdaf9cac1a01e92",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 92,
        "deletions": 109,
        "changes": 201,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -12,6 +12,7 @@\n #include <consensus/validation.h>\n #include <fs.h>\n #include <interfaces/chain.h>\n+#include <interfaces/wallet.h>\n #include <key.h>\n #include <key_io.h>\n #include <keystore.h>\n@@ -192,7 +193,7 @@ CPubKey CWallet::GenerateNewKey(WalletBatch &batch, bool internal)\n {\n     assert(!IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS));\n     assert(!IsWalletFlagSet(WALLET_FLAG_BLANK_WALLET));\n-    AssertLockHeld(cs_wallet); // mapKeyMetadata\n+    AssertLockHeld(cs_wallet);\n     bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets\n \n     CKey secret;\n@@ -280,9 +281,9 @@ void CWallet::DeriveNewChildKey(WalletBatch &batch, CKeyMetadata& metadata, CKey\n         throw std::runtime_error(std::string(__func__) + \": Writing HD chain model failed\");\n }\n \n-bool CWallet::AddKeyPubKeyWithDB(WalletBatch &batch, const CKey& secret, const CPubKey &pubkey)\n+bool CWallet::AddKeyPubKeyWithDB(WalletBatch& batch, const CKey& secret, const CPubKey& pubkey)\n {\n-    AssertLockHeld(cs_wallet); // mapKeyMetadata\n+    AssertLockHeld(cs_wallet);\n \n     // Make sure we aren't adding private keys to private key disabled wallets\n     assert(!IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS));\n@@ -344,16 +345,16 @@ bool CWallet::AddCryptedKey(const CPubKey &vchPubKey,\n     }\n }\n \n-void CWallet::LoadKeyMetadata(const CKeyID& keyID, const CKeyMetadata &meta)\n+void CWallet::LoadKeyMetadata(const CKeyID& keyID, const CKeyMetadata& meta)\n {\n-    AssertLockHeld(cs_wallet); // mapKeyMetadata\n+    AssertLockHeld(cs_wallet);\n     UpdateTimeFirstKey(meta.nCreateTime);\n     mapKeyMetadata[keyID] = meta;\n }\n \n-void CWallet::LoadScriptMetadata(const CScriptID& script_id, const CKeyMetadata &meta)\n+void CWallet::LoadScriptMetadata(const CScriptID& script_id, const CKeyMetadata& meta)\n {\n-    AssertLockHeld(cs_wallet); // m_script_metadata\n+    AssertLockHeld(cs_wallet);\n     UpdateTimeFirstKey(meta.nCreateTime);\n     m_script_metadata[script_id] = meta;\n }\n@@ -366,7 +367,7 @@ bool CWallet::WriteKeyMetadata(const CKeyMetadata& meta, const CPubKey& pubkey,\n \n void CWallet::UpgradeKeyMetadata()\n {\n-    AssertLockHeld(cs_wallet); // mapKeyMetadata\n+    AssertLockHeld(cs_wallet);\n     if (IsLocked() || IsWalletFlagSet(WALLET_FLAG_KEY_ORIGIN_METADATA)) {\n         return;\n     }\n@@ -568,7 +569,7 @@ void CWallet::ChainStateFlushed(const CBlockLocator& loc)\n \n void CWallet::SetMinVersion(enum WalletFeature nVersion, WalletBatch* batch_in, bool fExplicit)\n {\n-    LOCK(cs_wallet); // nWalletVersion\n+    LOCK(cs_wallet);\n     if (nWalletVersion >= nVersion)\n         return;\n \n@@ -592,7 +593,7 @@ void CWallet::SetMinVersion(enum WalletFeature nVersion, WalletBatch* batch_in,\n \n bool CWallet::SetMaxVersion(int nVersion)\n {\n-    LOCK(cs_wallet); // nWalletVersion, nWalletMaxVersion\n+    LOCK(cs_wallet);\n     // cannot downgrade below current version\n     if (nWalletVersion > nVersion)\n         return false;\n@@ -876,9 +877,9 @@ DBErrors CWallet::ReorderTransactions()\n     return DBErrors::LOAD_OK;\n }\n \n-int64_t CWallet::IncOrderPosNext(WalletBatch *batch)\n+int64_t CWallet::IncOrderPosNext(WalletBatch* batch)\n {\n-    AssertLockHeld(cs_wallet); // nOrderPosNext\n+    AssertLockHeld(cs_wallet);\n     int64_t nRet = nOrderPosNext++;\n     if (batch) {\n         batch->WriteOrderPosNext(nOrderPosNext);\n@@ -940,7 +941,7 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn, bool fFlushOnClose)\n     wtx.BindWallet(this);\n     bool fInsertedNew = ret.second;\n     if (fInsertedNew) {\n-        wtx.nTimeReceived = GetAdjustedTime();\n+        wtx.nTimeReceived = chain().getAdjustedTime();\n         wtx.nOrderPos = IncOrderPosNext(&batch);\n         wtx.m_it_wtxOrdered = wtxOrdered.insert(std::make_pair(wtx.nOrderPos, &wtx));\n         wtx.nTimeSmart = ComputeTimeSmart(wtx);\n@@ -1886,25 +1887,21 @@ void CWallet::ReacceptWalletTransactions()\n     for (const std::pair<const int64_t, CWalletTx*>& item : mapSorted) {\n         CWalletTx& wtx = *(item.second);\n         CValidationState state;\n-        wtx.AcceptToMemoryPool(*locked_chain, maxTxFee, state);\n+        wtx.AcceptToMemoryPool(*locked_chain, state);\n     }\n }\n \n-bool CWalletTx::RelayWalletTransaction(interfaces::Chain::Lock& locked_chain, CConnman* connman)\n+bool CWalletTx::RelayWalletTransaction(interfaces::Chain::Lock& locked_chain)\n {\n     assert(pwallet->GetBroadcastTransactions());\n     if (!IsCoinBase() && !isAbandoned() && GetDepthInMainChain(locked_chain) == 0)\n     {\n         CValidationState state;\n         /* GetDepthInMainChain already catches known conflicts. */\n-        if (InMempool() || AcceptToMemoryPool(locked_chain, maxTxFee, state)) {\n+        if (InMempool() || AcceptToMemoryPool(locked_chain, state)) {\n             pwallet->WalletLogPrintf(\"Relaying wtx %s\\n\", GetHash().ToString());\n-            if (connman) {\n-                CInv inv(MSG_TX, GetHash());\n-                connman->ForEachNode([&inv](CNode* pnode)\n-                {\n-                    pnode->PushInventory(inv);\n-                });\n+            if (pwallet->chain().p2pEnabled()) {\n+                pwallet->chain().relayTransaction(GetHash());\n                 return true;\n             }\n         }\n@@ -2075,11 +2072,10 @@ bool CWalletTx::InMempool() const\n \n bool CWalletTx::IsTrusted(interfaces::Chain::Lock& locked_chain) const\n {\n-    LockAnnotation lock(::cs_main); // Temporary, for CheckFinalTx below. Removed in upcoming commit.\n-\n     // Quick answer in most cases\n-    if (!CheckFinalTx(*tx))\n+    if (!locked_chain.checkFinalTx(*tx)) {\n         return false;\n+    }\n     int nDepth = GetDepthInMainChain(locked_chain);\n     if (nDepth >= 1)\n         return true;\n@@ -2115,7 +2111,7 @@ bool CWalletTx::IsEquivalentTo(const CWalletTx& _tx) const\n         return CTransaction(tx1) == CTransaction(tx2);\n }\n \n-std::vector<uint256> CWallet::ResendWalletTransactionsBefore(interfaces::Chain::Lock& locked_chain, int64_t nTime, CConnman* connman)\n+std::vector<uint256> CWallet::ResendWalletTransactionsBefore(interfaces::Chain::Lock& locked_chain, int64_t nTime)\n {\n     std::vector<uint256> result;\n \n@@ -2134,8 +2130,9 @@ std::vector<uint256> CWallet::ResendWalletTransactionsBefore(interfaces::Chain::\n     for (const std::pair<const unsigned int, CWalletTx*>& item : mapSorted)\n     {\n         CWalletTx& wtx = *item.second;\n-        if (wtx.RelayWalletTransaction(locked_chain, connman))\n+        if (wtx.RelayWalletTransaction(locked_chain)) {\n             result.push_back(wtx.GetHash());\n+        }\n     }\n     return result;\n }\n@@ -2159,7 +2156,7 @@ void CWallet::ResendWalletTransactions(int64_t nBestBlockTime, CConnman* connman\n     // Rebroadcast unconfirmed txes older than 5 minutes before the last\n     // block was found:\n     auto locked_chain = chain().assumeLocked();  // Temporary. Removed in upcoming lock cleanup\n-    std::vector<uint256> relayed = ResendWalletTransactionsBefore(*locked_chain, nBestBlockTime-5*60, connman);\n+    std::vector<uint256> relayed = ResendWalletTransactionsBefore(*locked_chain, nBestBlockTime-5*60);\n     if (!relayed.empty())\n         WalletLogPrintf(\"%s: rebroadcast %u unconfirmed transactions\\n\", __func__, relayed.size());\n }\n@@ -2263,15 +2260,14 @@ CAmount CWallet::GetImmatureWatchOnlyBalance() const\n // trusted.\n CAmount CWallet::GetLegacyBalance(const isminefilter& filter, int minDepth) const\n {\n-    LockAnnotation lock(::cs_main); // Temporary, for CheckFinalTx below. Removed in upcoming commit.\n     auto locked_chain = chain().lock();\n     LOCK(cs_wallet);\n \n     CAmount balance = 0;\n     for (const auto& entry : mapWallet) {\n         const CWalletTx& wtx = entry.second;\n         const int depth = wtx.GetDepthInMainChain(*locked_chain);\n-        if (depth < 0 || !CheckFinalTx(*wtx.tx) || wtx.IsImmatureCoinBase(*locked_chain)) {\n+        if (depth < 0 || !locked_chain->checkFinalTx(*wtx.tx) || wtx.IsImmatureCoinBase(*locked_chain)) {\n             continue;\n         }\n \n@@ -2325,8 +2321,9 @@ void CWallet::AvailableCoins(interfaces::Chain::Lock& locked_chain, std::vector<\n         const uint256& wtxid = entry.first;\n         const CWalletTx* pcoin = &entry.second;\n \n-        if (!CheckFinalTx(*pcoin->tx))\n+        if (!locked_chain.checkFinalTx(*pcoin->tx)) {\n             continue;\n+        }\n \n         if (pcoin->IsImmatureCoinBase(locked_chain))\n             continue;\n@@ -2488,10 +2485,10 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n         FeeCalculation feeCalc;\n         CCoinControl temp;\n         temp.m_confirm_target = 1008;\n-        CFeeRate long_term_feerate = GetMinimumFeeRate(*this, temp, ::mempool, ::feeEstimator, &feeCalc);\n+        CFeeRate long_term_feerate = GetMinimumFeeRate(*this, temp, &feeCalc);\n \n         // Calculate cost of change\n-        CAmount cost_of_change = GetDiscardRate(*this, ::feeEstimator).GetFee(coin_selection_params.change_spend_size) + coin_selection_params.effective_fee.GetFee(coin_selection_params.change_output_size);\n+        CAmount cost_of_change = GetDiscardRate(*this).GetFee(coin_selection_params.change_spend_size) + coin_selection_params.effective_fee.GetFee(coin_selection_params.change_output_size);\n \n         // Filter by the min conf specs and add to utxo_pool and calculate effective value\n         for (OutputGroup& group : groups) {\n@@ -2617,9 +2614,9 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n     return res;\n }\n \n-bool CWallet::SignTransaction(CMutableTransaction &tx)\n+bool CWallet::SignTransaction(CMutableTransaction& tx)\n {\n-    AssertLockHeld(cs_wallet); // mapWallet\n+    AssertLockHeld(cs_wallet);\n \n     // sign the new tx\n     int nIn = 0;\n@@ -2861,10 +2858,10 @@ bool CWallet::CreateTransaction(interfaces::Chain::Lock& locked_chain, const std\n             CTxOut change_prototype_txout(0, scriptChange);\n             coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);\n \n-            CFeeRate discard_rate = GetDiscardRate(*this, ::feeEstimator);\n+            CFeeRate discard_rate = GetDiscardRate(*this);\n \n             // Get the fee rate to use effective values in coin selection\n-            CFeeRate nFeeRateNeeded = GetMinimumFeeRate(*this, coin_control, ::mempool, ::feeEstimator, &feeCalc);\n+            CFeeRate nFeeRateNeeded = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n \n             nFeeRet = 0;\n             bool pick_new_inputs = true;\n@@ -2997,7 +2994,7 @@ bool CWallet::CreateTransaction(interfaces::Chain::Lock& locked_chain, const std\n                     return false;\n                 }\n \n-                nFeeNeeded = GetMinimumFee(*this, nBytes, coin_control, ::mempool, ::feeEstimator, &feeCalc);\n+                nFeeNeeded = GetMinimumFee(*this, nBytes, coin_control, &feeCalc);\n                 if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n                     // eventually allow a fallback fee\n                     strFailReason = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n@@ -3025,7 +3022,7 @@ bool CWallet::CreateTransaction(interfaces::Chain::Lock& locked_chain, const std\n                     // change output. Only try this once.\n                     if (nChangePosInOut == -1 && nSubtractFeeFromAmount == 0 && pick_new_inputs) {\n                         unsigned int tx_size_with_change = nBytes + coin_selection_params.change_output_size + 2; // Add 2 as a buffer in case increasing # of outputs changes compact size\n-                        CAmount fee_needed_with_change = GetMinimumFee(*this, tx_size_with_change, coin_control, ::mempool, ::feeEstimator, nullptr);\n+                        CAmount fee_needed_with_change = GetMinimumFee(*this, tx_size_with_change, coin_control, nullptr);\n                         CAmount minimum_value_for_change = GetDustThreshold(change_prototype_txout, discard_rate);\n                         if (nFeeRet >= fee_needed_with_change + minimum_value_for_change) {\n                             pick_new_inputs = false;\n@@ -3130,16 +3127,7 @@ bool CWallet::CreateTransaction(interfaces::Chain::Lock& locked_chain, const std\n \n     if (gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS)) {\n         // Lastly, ensure this tx will pass the mempool's chain limits\n-        LockPoints lp;\n-        CTxMemPoolEntry entry(tx, 0, 0, 0, false, 0, lp);\n-        CTxMemPool::setEntries setAncestors;\n-        size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n-        size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n-        size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n-        size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n-        std::string errString;\n-        LOCK(::mempool.cs);\n-        if (!::mempool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n+        if (!chain().checkChainLimits(tx)) {\n             strFailReason = _(\"Transaction has too long of a mempool chain\");\n             return false;\n         }\n@@ -3159,7 +3147,7 @@ bool CWallet::CreateTransaction(interfaces::Chain::Lock& locked_chain, const std\n /**\n  * Call after CreateTransaction unless you want to abort\n  */\n-bool CWallet::CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::vector<std::pair<std::string, std::string>> orderForm, CReserveKey& reservekey, CConnman* connman, CValidationState& state)\n+bool CWallet::CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::vector<std::pair<std::string, std::string>> orderForm, CReserveKey& reservekey, CValidationState& state)\n {\n     {\n         auto locked_chain = chain().lock();\n@@ -3196,11 +3184,11 @@ bool CWallet::CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::ve\n         if (fBroadcastTransactions)\n         {\n             // Broadcast\n-            if (!wtx.AcceptToMemoryPool(*locked_chain, maxTxFee, state)) {\n+            if (!wtx.AcceptToMemoryPool(*locked_chain, state)) {\n                 WalletLogPrintf(\"CommitTransaction(): Transaction cannot be broadcast immediately, %s\\n\", FormatStateMessage(state));\n                 // TODO: if we expect the failure to be long term or permanent, instead delete wtx from the wallet and return failure.\n             } else {\n-                wtx.RelayWalletTransaction(*locked_chain, connman);\n+                wtx.RelayWalletTransaction(*locked_chain);\n             }\n         }\n     }\n@@ -3242,8 +3230,8 @@ DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n \n DBErrors CWallet::ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256>& vHashOut)\n {\n-    AssertLockHeld(cs_wallet); // mapWallet\n-    DBErrors nZapSelectTxRet = WalletBatch(*database,\"cr+\").ZapSelectTx(vHashIn, vHashOut);\n+    AssertLockHeld(cs_wallet);\n+    DBErrors nZapSelectTxRet = WalletBatch(*database, \"cr+\").ZapSelectTx(vHashIn, vHashOut);\n     for (uint256 hash : vHashOut) {\n         const auto& it = mapWallet.find(hash);\n         wtxOrdered.erase(it->second.m_it_wtxOrdered);\n@@ -3269,7 +3257,6 @@ DBErrors CWallet::ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256\n     MarkDirty();\n \n     return DBErrors::LOAD_OK;\n-\n }\n \n DBErrors CWallet::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n@@ -3389,7 +3376,7 @@ bool CWallet::NewKeyPool()\n \n size_t CWallet::KeypoolCountExternalKeys()\n {\n-    AssertLockHeld(cs_wallet); // setExternalKeyPool\n+    AssertLockHeld(cs_wallet);\n     return setExternalKeyPool.size() + set_pre_split_keypool.size();\n }\n \n@@ -3653,7 +3640,7 @@ std::map<CTxDestination, CAmount> CWallet::GetAddressBalances(interfaces::Chain:\n \n std::set< std::set<CTxDestination> > CWallet::GetAddressGroupings()\n {\n-    AssertLockHeld(cs_wallet); // mapWallet\n+    AssertLockHeld(cs_wallet);\n     std::set< std::set<CTxDestination> > groupings;\n     std::set<CTxDestination> grouping;\n \n@@ -3821,33 +3808,33 @@ void CWallet::MarkReserveKeysAsUsed(int64_t keypool_id)\n \n void CWallet::LockCoin(const COutPoint& output)\n {\n-    AssertLockHeld(cs_wallet); // setLockedCoins\n+    AssertLockHeld(cs_wallet);\n     setLockedCoins.insert(output);\n }\n \n void CWallet::UnlockCoin(const COutPoint& output)\n {\n-    AssertLockHeld(cs_wallet); // setLockedCoins\n+    AssertLockHeld(cs_wallet);\n     setLockedCoins.erase(output);\n }\n \n void CWallet::UnlockAllCoins()\n {\n-    AssertLockHeld(cs_wallet); // setLockedCoins\n+    AssertLockHeld(cs_wallet);\n     setLockedCoins.clear();\n }\n \n bool CWallet::IsLockedCoin(uint256 hash, unsigned int n) const\n {\n-    AssertLockHeld(cs_wallet); // setLockedCoins\n+    AssertLockHeld(cs_wallet);\n     COutPoint outpt(hash, n);\n \n     return (setLockedCoins.count(outpt) > 0);\n }\n \n void CWallet::ListLockedCoins(std::vector<COutPoint>& vOutpts) const\n {\n-    AssertLockHeld(cs_wallet); // setLockedCoins\n+    AssertLockHeld(cs_wallet);\n     for (std::set<COutPoint>::iterator it = setLockedCoins.begin();\n          it != setLockedCoins.end(); it++) {\n         COutPoint outpt = (*it);\n@@ -3857,8 +3844,8 @@ void CWallet::ListLockedCoins(std::vector<COutPoint>& vOutpts) const\n \n /** @} */ // end of Actions\n \n-void CWallet::GetKeyBirthTimes(interfaces::Chain::Lock& locked_chain, std::map<CTxDestination, int64_t> &mapKeyBirth) const {\n-    AssertLockHeld(cs_wallet); // mapKeyMetadata\n+void CWallet::GetKeyBirthTimes(interfaces::Chain::Lock& locked_chain, std::map<CTxDestination, int64_t>& mapKeyBirth) const {\n+    AssertLockHeld(cs_wallet);\n     mapKeyBirth.clear();\n \n     // get birth times for keys with metadata\n@@ -4092,17 +4079,17 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n     std::vector<CWalletTx> vWtx;\n \n     if (gArgs.GetBoolArg(\"-zapwallettxes\", false)) {\n-        uiInterface.InitMessage(_(\"Zapping all transactions from wallet...\"));\n+        chain.initMessage(_(\"Zapping all transactions from wallet...\"));\n \n         std::unique_ptr<CWallet> tempWallet = MakeUnique<CWallet>(chain, location, WalletDatabase::Create(location.GetPath()));\n         DBErrors nZapWalletRet = tempWallet->ZapWalletTx(vWtx);\n         if (nZapWalletRet != DBErrors::LOAD_OK) {\n-            InitError(strprintf(_(\"Error loading %s: Wallet corrupted\"), walletFile));\n+            chain.initError(strprintf(_(\"Error loading %s: Wallet corrupted\"), walletFile));\n             return nullptr;\n         }\n     }\n \n-    uiInterface.InitMessage(_(\"Loading wallet...\"));\n+    chain.initMessage(_(\"Loading wallet...\"));\n \n     int64_t nStart = GetTimeMillis();\n     bool fFirstRun = true;\n@@ -4113,31 +4100,31 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n     if (nLoadWalletRet != DBErrors::LOAD_OK)\n     {\n         if (nLoadWalletRet == DBErrors::CORRUPT) {\n-            InitError(strprintf(_(\"Error loading %s: Wallet corrupted\"), walletFile));\n+            chain.initError(strprintf(_(\"Error loading %s: Wallet corrupted\"), walletFile));\n             return nullptr;\n         }\n         else if (nLoadWalletRet == DBErrors::NONCRITICAL_ERROR)\n         {\n-            InitWarning(strprintf(_(\"Error reading %s! All keys read correctly, but transaction data\"\n-                                         \" or address book entries might be missing or incorrect.\"),\n+            chain.initWarning(strprintf(_(\"Error reading %s! All keys read correctly, but transaction data\"\n+                                          \" or address book entries might be missing or incorrect.\"),\n                 walletFile));\n         }\n         else if (nLoadWalletRet == DBErrors::TOO_NEW) {\n-            InitError(strprintf(_(\"Error loading %s: Wallet requires newer version of %s\"), walletFile, _(PACKAGE_NAME)));\n+            chain.initError(strprintf(_(\"Error loading %s: Wallet requires newer version of %s\"), walletFile, _(PACKAGE_NAME)));\n             return nullptr;\n         }\n         else if (nLoadWalletRet == DBErrors::NEED_REWRITE)\n         {\n-            InitError(strprintf(_(\"Wallet needed to be rewritten: restart %s to complete\"), _(PACKAGE_NAME)));\n+            chain.initError(strprintf(_(\"Wallet needed to be rewritten: restart %s to complete\"), _(PACKAGE_NAME)));\n             return nullptr;\n         }\n         else {\n-            InitError(strprintf(_(\"Error loading %s\"), walletFile));\n+            chain.initError(strprintf(_(\"Error loading %s\"), walletFile));\n             return nullptr;\n         }\n     }\n \n-    int prev_version = walletInstance->nWalletVersion;\n+    int prev_version = walletInstance->GetVersion();\n     if (gArgs.GetBoolArg(\"-upgradewallet\", fFirstRun))\n     {\n         int nMaxVersion = gArgs.GetArg(\"-upgradewallet\", 0);\n@@ -4151,7 +4138,7 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n             walletInstance->WalletLogPrintf(\"Allowing wallet upgrade up to %i\\n\", nMaxVersion);\n         if (nMaxVersion < walletInstance->GetVersion())\n         {\n-            InitError(_(\"Cannot downgrade wallet\"));\n+            chain.initError(_(\"Cannot downgrade wallet\"));\n             return nullptr;\n         }\n         walletInstance->SetMaxVersion(nMaxVersion);\n@@ -4162,9 +4149,9 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n         LOCK(walletInstance->cs_wallet);\n \n         // Do not upgrade versions to any version between HD_SPLIT and FEATURE_PRE_SPLIT_KEYPOOL unless already supporting HD_SPLIT\n-        int max_version = walletInstance->nWalletVersion;\n-        if (!walletInstance->CanSupportFeature(FEATURE_HD_SPLIT) && max_version >=FEATURE_HD_SPLIT && max_version < FEATURE_PRE_SPLIT_KEYPOOL) {\n-            InitError(_(\"Cannot upgrade a non HD split wallet without upgrading to support pre split keypool. Please use -upgradewallet=169900 or -upgradewallet with no version specified.\"));\n+        int max_version = walletInstance->GetVersion();\n+        if (!walletInstance->CanSupportFeature(FEATURE_HD_SPLIT) && max_version >= FEATURE_HD_SPLIT && max_version < FEATURE_PRE_SPLIT_KEYPOOL) {\n+            chain.initError(_(\"Cannot upgrade a non HD split wallet without upgrading to support pre split keypool. Please use -upgradewallet=169900 or -upgradewallet with no version specified.\"));\n             return nullptr;\n         }\n \n@@ -4192,7 +4179,7 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n         // Regenerate the keypool if upgraded to HD\n         if (hd_upgrade) {\n             if (!walletInstance->TopUpKeyPool()) {\n-                InitError(_(\"Unable to generate keys\"));\n+                chain.initError(_(\"Unable to generate keys\"));\n                 return nullptr;\n             }\n         }\n@@ -4216,42 +4203,42 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n \n         // Top up the keypool\n         if (walletInstance->CanGenerateKeys() && !walletInstance->TopUpKeyPool()) {\n-            InitError(_(\"Unable to generate initial keys\"));\n+            chain.initError(_(\"Unable to generate initial keys\"));\n             return nullptr;\n         }\n \n         auto locked_chain = chain.assumeLocked();  // Temporary. Removed in upcoming lock cleanup\n         walletInstance->ChainStateFlushed(locked_chain->getTipLocator());\n     } else if (wallet_creation_flags & WALLET_FLAG_DISABLE_PRIVATE_KEYS) {\n         // Make it impossible to disable private keys after creation\n-        InitError(strprintf(_(\"Error loading %s: Private keys can only be disabled during creation\"), walletFile));\n+        chain.initError(strprintf(_(\"Error loading %s: Private keys can only be disabled during creation\"), walletFile));\n         return NULL;\n     } else if (walletInstance->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n         LOCK(walletInstance->cs_KeyStore);\n         if (!walletInstance->mapKeys.empty() || !walletInstance->mapCryptedKeys.empty()) {\n-            InitWarning(strprintf(_(\"Warning: Private keys detected in wallet {%s} with disabled private keys\"), walletFile));\n+            chain.initWarning(strprintf(_(\"Warning: Private keys detected in wallet {%s} with disabled private keys\"), walletFile));\n         }\n     }\n \n     if (!gArgs.GetArg(\"-addresstype\", \"\").empty() && !ParseOutputType(gArgs.GetArg(\"-addresstype\", \"\"), walletInstance->m_default_address_type)) {\n-        InitError(strprintf(\"Unknown address type '%s'\", gArgs.GetArg(\"-addresstype\", \"\")));\n+        chain.initError(strprintf(\"Unknown address type '%s'\", gArgs.GetArg(\"-addresstype\", \"\")));\n         return nullptr;\n     }\n \n     if (!gArgs.GetArg(\"-changetype\", \"\").empty() && !ParseOutputType(gArgs.GetArg(\"-changetype\", \"\"), walletInstance->m_default_change_type)) {\n-        InitError(strprintf(\"Unknown change type '%s'\", gArgs.GetArg(\"-changetype\", \"\")));\n+        chain.initError(strprintf(\"Unknown change type '%s'\", gArgs.GetArg(\"-changetype\", \"\")));\n         return nullptr;\n     }\n \n     if (gArgs.IsArgSet(\"-mintxfee\")) {\n         CAmount n = 0;\n         if (!ParseMoney(gArgs.GetArg(\"-mintxfee\", \"\"), n) || 0 == n) {\n-            InitError(AmountErrMsg(\"mintxfee\", gArgs.GetArg(\"-mintxfee\", \"\")));\n+            chain.initError(AmountErrMsg(\"mintxfee\", gArgs.GetArg(\"-mintxfee\", \"\")));\n             return nullptr;\n         }\n         if (n > HIGH_TX_FEE_PER_KB) {\n-            InitWarning(AmountHighWarn(\"-mintxfee\") + \" \" +\n-                        _(\"This is the minimum transaction fee you pay on every transaction.\"));\n+            chain.initWarning(AmountHighWarn(\"-mintxfee\") + \" \" +\n+                              _(\"This is the minimum transaction fee you pay on every transaction.\"));\n         }\n         walletInstance->m_min_fee = CFeeRate(n);\n     }\n@@ -4260,41 +4247,41 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n     if (gArgs.IsArgSet(\"-fallbackfee\")) {\n         CAmount nFeePerK = 0;\n         if (!ParseMoney(gArgs.GetArg(\"-fallbackfee\", \"\"), nFeePerK)) {\n-            InitError(strprintf(_(\"Invalid amount for -fallbackfee=<amount>: '%s'\"), gArgs.GetArg(\"-fallbackfee\", \"\")));\n+            chain.initError(strprintf(_(\"Invalid amount for -fallbackfee=<amount>: '%s'\"), gArgs.GetArg(\"-fallbackfee\", \"\")));\n             return nullptr;\n         }\n         if (nFeePerK > HIGH_TX_FEE_PER_KB) {\n-            InitWarning(AmountHighWarn(\"-fallbackfee\") + \" \" +\n-                        _(\"This is the transaction fee you may pay when fee estimates are not available.\"));\n+            chain.initWarning(AmountHighWarn(\"-fallbackfee\") + \" \" +\n+                              _(\"This is the transaction fee you may pay when fee estimates are not available.\"));\n         }\n         walletInstance->m_fallback_fee = CFeeRate(nFeePerK);\n         walletInstance->m_allow_fallback_fee = nFeePerK != 0; //disable fallback fee in case value was set to 0, enable if non-null value\n     }\n     if (gArgs.IsArgSet(\"-discardfee\")) {\n         CAmount nFeePerK = 0;\n         if (!ParseMoney(gArgs.GetArg(\"-discardfee\", \"\"), nFeePerK)) {\n-            InitError(strprintf(_(\"Invalid amount for -discardfee=<amount>: '%s'\"), gArgs.GetArg(\"-discardfee\", \"\")));\n+            chain.initError(strprintf(_(\"Invalid amount for -discardfee=<amount>: '%s'\"), gArgs.GetArg(\"-discardfee\", \"\")));\n             return nullptr;\n         }\n         if (nFeePerK > HIGH_TX_FEE_PER_KB) {\n-            InitWarning(AmountHighWarn(\"-discardfee\") + \" \" +\n-                        _(\"This is the transaction fee you may discard if change is smaller than dust at this level\"));\n+            chain.initWarning(AmountHighWarn(\"-discardfee\") + \" \" +\n+                              _(\"This is the transaction fee you may discard if change is smaller than dust at this level\"));\n         }\n         walletInstance->m_discard_rate = CFeeRate(nFeePerK);\n     }\n     if (gArgs.IsArgSet(\"-paytxfee\")) {\n         CAmount nFeePerK = 0;\n         if (!ParseMoney(gArgs.GetArg(\"-paytxfee\", \"\"), nFeePerK)) {\n-            InitError(AmountErrMsg(\"paytxfee\", gArgs.GetArg(\"-paytxfee\", \"\")));\n+            chain.initError(AmountErrMsg(\"paytxfee\", gArgs.GetArg(\"-paytxfee\", \"\")));\n             return nullptr;\n         }\n         if (nFeePerK > HIGH_TX_FEE_PER_KB) {\n-            InitWarning(AmountHighWarn(\"-paytxfee\") + \" \" +\n-                        _(\"This is the transaction fee you will pay if you send a transaction.\"));\n+            chain.initWarning(AmountHighWarn(\"-paytxfee\") + \" \" +\n+                              _(\"This is the transaction fee you will pay if you send a transaction.\"));\n         }\n         walletInstance->m_pay_tx_fee = CFeeRate(nFeePerK, 1000);\n         if (walletInstance->m_pay_tx_fee < ::minRelayTxFee) {\n-            InitError(strprintf(_(\"Invalid amount for -paytxfee=<amount>: '%s' (must be at least %s)\"),\n+            chain.initError(strprintf(_(\"Invalid amount for -paytxfee=<amount>: '%s' (must be at least %s)\"),\n                 gArgs.GetArg(\"-paytxfee\", \"\"), ::minRelayTxFee.ToString()));\n             return nullptr;\n         }\n@@ -4335,20 +4322,19 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n         //We can't rescan beyond non-pruned blocks, stop and throw an error\n         //this might happen if a user uses an old wallet within a pruned node\n         // or if he ran -disablewallet for a longer time, then decided to re-enable\n-        if (fPruneMode)\n-        {\n+        if (chain.getPruneMode()) {\n             int block_height = *tip_height;\n             while (block_height > 0 && locked_chain->haveBlockOnDisk(block_height - 1) && rescan_height != block_height) {\n                 --block_height;\n             }\n \n             if (rescan_height != block_height) {\n-                InitError(_(\"Prune: last wallet synchronisation goes beyond pruned data. You need to -reindex (download the whole blockchain again in case of pruned node)\"));\n+                chain.initError(_(\"Prune: last wallet synchronisation goes beyond pruned data. You need to -reindex (download the whole blockchain again in case of pruned node)\"));\n                 return nullptr;\n             }\n         }\n \n-        uiInterface.InitMessage(_(\"Rescanning...\"));\n+        chain.initMessage(_(\"Rescanning...\"));\n         walletInstance->WalletLogPrintf(\"Rescanning last %i blocks (from block %i)...\\n\", *tip_height - rescan_height, rescan_height);\n \n         // No need to read and scan block if block was created before\n@@ -4363,7 +4349,7 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n         {\n             WalletRescanReserver reserver(walletInstance.get());\n             if (!reserver.reserve() || (ScanResult::SUCCESS != walletInstance->ScanForWalletTransactions(locked_chain->getBlockHash(rescan_height), {} /* stop block */, reserver, true /* update */).status)) {\n-                InitError(_(\"Failed to rescan the wallet during initialization\"));\n+                chain.initError(_(\"Failed to rescan the wallet during initialization\"));\n                 return nullptr;\n             }\n         }\n@@ -4396,7 +4382,7 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n         }\n     }\n \n-    uiInterface.LoadWallet(walletInstance);\n+    chain.loadWallet(interfaces::MakeWallet(walletInstance));\n \n     // Register with the validation interface. It's ok to do this after rescan since we're still holding cs_main.\n     RegisterValidationInterface(walletInstance.get());\n@@ -4479,17 +4465,14 @@ bool CMerkleTx::IsImmatureCoinBase(interfaces::Chain::Lock& locked_chain) const\n     return GetBlocksToMaturity(locked_chain) > 0;\n }\n \n-bool CWalletTx::AcceptToMemoryPool(interfaces::Chain::Lock& locked_chain, const CAmount& nAbsurdFee, CValidationState& state)\n+bool CWalletTx::AcceptToMemoryPool(interfaces::Chain::Lock& locked_chain, CValidationState& state)\n {\n-    LockAnnotation lock(::cs_main); // Temporary, for AcceptToMemoryPool below. Removed in upcoming commit.\n-\n     // We must set fInMempool here - while it will be re-set to true by the\n     // entered-mempool callback, if we did not there would be a race where a\n     // user could call sendmoney in a loop and hit spurious out of funds errors\n     // because we think that this newly generated transaction's change is\n     // unavailable as we're not yet aware that it is in the mempool.\n-    bool ret = ::AcceptToMemoryPool(mempool, state, tx, nullptr /* pfMissingInputs */,\n-                                nullptr /* plTxnReplaced */, false /* bypass_limits */, nAbsurdFee);\n+    bool ret = locked_chain.submitToMemoryPool(tx, pwallet->chain().maxTxFee(), state);\n     fInMempool |= ret;\n     return ret;\n }\n@@ -4520,7 +4503,7 @@ std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outpu\n             CInputCoin input_coin = output.GetInputCoin();\n \n             size_t ancestors, descendants;\n-            mempool.GetTransactionAncestry(output.tx->GetHash(), ancestors, descendants);\n+            chain().getTransactionAncestry(output.tx->GetHash(), ancestors, descendants);\n             if (!single_coin && ExtractDestination(output.tx->tx->vout[output.i].scriptPubKey, dst)) {\n                 // Limit output groups to no more than 10 entries, to protect\n                 // against inadvertently creating a too-large transaction"
      },
      {
        "sha": "ea196c8799536ad1d3d7067a6537ac9ecc9d0797",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 9,
        "deletions": 11,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -100,8 +100,6 @@ class CCoinControl;\n class COutput;\n class CReserveKey;\n class CScript;\n-class CTxMemPool;\n-class CBlockPolicyEstimator;\n class CWalletTx;\n struct FeeCalculation;\n enum class FeeEstimateMode;\n@@ -537,10 +535,10 @@ class CWalletTx : public CMerkleTx\n     int64_t GetTxTime() const;\n \n     // RelayWalletTransaction may only be called if fBroadcastTransactions!\n-    bool RelayWalletTransaction(interfaces::Chain::Lock& locked_chain, CConnman* connman);\n+    bool RelayWalletTransaction(interfaces::Chain::Lock& locked_chain);\n \n     /** Pass this transaction to the mempool. Fails if absolute fee exceeds absurd fee. */\n-    bool AcceptToMemoryPool(interfaces::Chain::Lock& locked_chain, const CAmount& nAbsurdFee, CValidationState& state);\n+    bool AcceptToMemoryPool(interfaces::Chain::Lock& locked_chain, CValidationState& state);\n \n     // TODO: Remove \"NO_THREAD_SAFETY_ANALYSIS\" and replace it with the correct\n     // annotation \"EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\". The annotation\n@@ -650,7 +648,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     WalletBatch *encrypted_batch GUARDED_BY(cs_wallet) = nullptr;\n \n     //! the current wallet version: clients below this version are not able to load the wallet\n-    int nWalletVersion = FEATURE_BASE;\n+    int nWalletVersion GUARDED_BY(cs_wallet){FEATURE_BASE};\n \n     //! the maximum wallet format version: memory-only variable that specifies to what version this wallet may be upgraded\n     int nWalletMaxVersion GUARDED_BY(cs_wallet) = FEATURE_BASE;\n@@ -700,11 +698,11 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     CHDChain hdChain;\n \n     /* HD derive new child key (on internal or external chain) */\n-    void DeriveNewChildKey(WalletBatch &batch, CKeyMetadata& metadata, CKey& secret, bool internal = false) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    void DeriveNewChildKey(WalletBatch& batch, CKeyMetadata& metadata, CKey& secret, bool internal = false) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n-    std::set<int64_t> setInternalKeyPool;\n+    std::set<int64_t> setInternalKeyPool GUARDED_BY(cs_wallet);\n     std::set<int64_t> setExternalKeyPool GUARDED_BY(cs_wallet);\n-    std::set<int64_t> set_pre_split_keypool;\n+    std::set<int64_t> set_pre_split_keypool GUARDED_BY(cs_wallet);\n     int64_t m_max_keypool_index GUARDED_BY(cs_wallet) = 0;\n     std::map<CKeyID, int64_t> m_pool_key_to_index;\n     std::atomic<uint64_t> m_wallet_flags{0};\n@@ -946,7 +944,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     void ReacceptWalletTransactions();\n     void ResendWalletTransactions(int64_t nBestBlockTime, CConnman* connman) override EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     // ResendWalletTransactionsBefore may only be called if fBroadcastTransactions!\n-    std::vector<uint256> ResendWalletTransactionsBefore(interfaces::Chain::Lock& locked_chain, int64_t nTime, CConnman* connman);\n+    std::vector<uint256> ResendWalletTransactionsBefore(interfaces::Chain::Lock& locked_chain, int64_t nTime);\n     CAmount GetBalance(const isminefilter& filter=ISMINE_SPENDABLE, const int min_depth=0) const;\n     CAmount GetUnconfirmedBalance() const;\n     CAmount GetImmatureBalance() const;\n@@ -971,7 +969,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n      */\n     bool CreateTransaction(interfaces::Chain::Lock& locked_chain, const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CReserveKey& reservekey, CAmount& nFeeRet, int& nChangePosInOut,\n                            std::string& strFailReason, const CCoinControl& coin_control, bool sign = true);\n-    bool CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::vector<std::pair<std::string, std::string>> orderForm, CReserveKey& reservekey, CConnman* connman, CValidationState& state);\n+    bool CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::vector<std::pair<std::string, std::string>> orderForm, CReserveKey& reservekey, CValidationState& state);\n \n     bool DummySignTx(CMutableTransaction &txNew, const std::set<CTxOut> &txouts, bool use_max_sig = false) const\n     {\n@@ -1067,7 +1065,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n \n     unsigned int GetKeyPoolSize() EXCLUSIVE_LOCKS_REQUIRED(cs_wallet)\n     {\n-        AssertLockHeld(cs_wallet); // set{Ex,In}ternalKeyPool\n+        AssertLockHeld(cs_wallet);\n         return setInternalKeyPool.size() + setExternalKeyPool.size();\n     }\n "
      },
      {
        "sha": "0e70ebba6dcb24d4b3f9189a284cf48c3e60f0b5",
        "filename": "test/functional/example_test.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/example_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/example_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/example_test.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2017-2018 The Bitcoin Core developers\n+# Copyright (c) 2017-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"An example functional test"
      },
      {
        "sha": "e7e4f84ad997d5234a74f6f905db710212a8a569",
        "filename": "test/functional/feature_assumevalid.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_assumevalid.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_assumevalid.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_assumevalid.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2014-2018 The Bitcoin Core developers\n+# Copyright (c) 2014-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test logic for skipping signature validation on old blocks."
      },
      {
        "sha": "21c832c1a928acfb0e1317da9ea260495002bb09",
        "filename": "test/functional/feature_bip68_sequence.py",
        "status": "modified",
        "additions": 15,
        "deletions": 15,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_bip68_sequence.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_bip68_sequence.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_bip68_sequence.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2014-2018 The Bitcoin Core developers\n+# Copyright (c) 2014-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test BIP68 implementation.\"\"\"\n@@ -10,7 +10,7 @@\n from test_framework.messages import COIN, COutPoint, CTransaction, CTxIn, CTxOut, FromHex, ToHex\n from test_framework.script import CScript\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, assert_greater_than, assert_raises_rpc_error, bytes_to_hex_str, get_bip9_status, satoshi_round, sync_blocks\n+from test_framework.util import assert_equal, assert_greater_than, assert_raises_rpc_error, get_bip9_status, satoshi_round, sync_blocks\n \n SEQUENCE_LOCKTIME_DISABLE_FLAG = (1<<31)\n SEQUENCE_LOCKTIME_TYPE_FLAG = (1<<22) # this means use time (0 means height)\n@@ -63,7 +63,7 @@ def test_disable_flag(self):\n         self.nodes[0].sendtoaddress(new_addr, 2) # send 2 BTC\n \n         utxos = self.nodes[0].listunspent(0, 0)\n-        assert(len(utxos) > 0)\n+        assert len(utxos) > 0\n \n         utxo = utxos[0]\n \n@@ -253,7 +253,7 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n             self.nodes[0].generate(1)\n             cur_time += 600\n \n-        assert(tx2.hash in self.nodes[0].getrawmempool())\n+        assert tx2.hash in self.nodes[0].getrawmempool()\n \n         test_nonzero_locks(tx2, self.nodes[0], self.relayfee, use_height_lock=True)\n         test_nonzero_locks(tx2, self.nodes[0], self.relayfee, use_height_lock=False)\n@@ -264,23 +264,23 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n         # Advance the time on the node so that we can test timelocks\n         self.nodes[0].setmocktime(cur_time+600)\n         self.nodes[0].generate(1)\n-        assert(tx2.hash not in self.nodes[0].getrawmempool())\n+        assert tx2.hash not in self.nodes[0].getrawmempool()\n \n         # Now that tx2 is not in the mempool, a sequence locked spend should\n         # succeed\n         tx3 = test_nonzero_locks(tx2, self.nodes[0], self.relayfee, use_height_lock=False)\n-        assert(tx3.hash in self.nodes[0].getrawmempool())\n+        assert tx3.hash in self.nodes[0].getrawmempool()\n \n         self.nodes[0].generate(1)\n-        assert(tx3.hash not in self.nodes[0].getrawmempool())\n+        assert tx3.hash not in self.nodes[0].getrawmempool()\n \n         # One more test, this time using height locks\n         tx4 = test_nonzero_locks(tx3, self.nodes[0], self.relayfee, use_height_lock=True)\n-        assert(tx4.hash in self.nodes[0].getrawmempool())\n+        assert tx4.hash in self.nodes[0].getrawmempool()\n \n         # Now try combining confirmed and unconfirmed inputs\n         tx5 = test_nonzero_locks(tx4, self.nodes[0], self.relayfee, use_height_lock=True)\n-        assert(tx5.hash not in self.nodes[0].getrawmempool())\n+        assert tx5.hash not in self.nodes[0].getrawmempool()\n \n         utxos = self.nodes[0].listunspent()\n         tx5.vin.append(CTxIn(COutPoint(int(utxos[0][\"txid\"], 16), utxos[0][\"vout\"]), nSequence=1))\n@@ -299,8 +299,8 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n         # If we invalidate the tip, tx3 should get added to the mempool, causing\n         # tx4 to be removed (fails sequence-lock).\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n-        assert(tx4.hash not in self.nodes[0].getrawmempool())\n-        assert(tx3.hash in self.nodes[0].getrawmempool())\n+        assert tx4.hash not in self.nodes[0].getrawmempool()\n+        assert tx3.hash in self.nodes[0].getrawmempool()\n \n         # Now mine 2 empty blocks to reorg out the current tip (labeled tip-1 in\n         # diagram above).\n@@ -319,8 +319,8 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n             cur_time += 1\n \n         mempool = self.nodes[0].getrawmempool()\n-        assert(tx3.hash not in mempool)\n-        assert(tx2.hash in mempool)\n+        assert tx3.hash not in mempool\n+        assert tx2.hash in mempool\n \n         # Reset the chain and get rid of the mocktimed-blocks\n         self.nodes[0].setmocktime(0)\n@@ -332,7 +332,7 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n     # being run, then it's possible the test has activated the soft fork, and\n     # this test should be moved to run earlier, or deleted.\n     def test_bip68_not_consensus(self):\n-        assert(get_bip9_status(self.nodes[0], 'csv')['status'] != 'active')\n+        assert get_bip9_status(self.nodes[0], 'csv')['status'] != 'active'\n         txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 2)\n \n         tx1 = FromHex(CTransaction(), self.nodes[0].getrawtransaction(txid))\n@@ -372,7 +372,7 @@ def test_bip68_not_consensus(self):\n         add_witness_commitment(block)\n         block.solve()\n \n-        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+        self.nodes[0].submitblock(block.serialize(True).hex())\n         assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n \n     def activateCSV(self):"
      },
      {
        "sha": "faf7f2025764114cea377e08a716852819567172",
        "filename": "test/functional/feature_block.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_block.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -773,7 +773,7 @@ def run_test(self):\n         self.move_tip(57)\n         b58 = self.next_block(58, spend=out[17])\n         tx = CTransaction()\n-        assert(len(out[17].vout) < 42)\n+        assert len(out[17].vout) < 42\n         tx.vin.append(CTxIn(COutPoint(out[17].sha256, 42), CScript([OP_TRUE]), 0xffffffff))\n         tx.vout.append(CTxOut(0, b\"\"))\n         tx.calc_sha256()\n@@ -824,7 +824,7 @@ def run_test(self):\n         tx.nLockTime = 0xffffffff  # this locktime is non-final\n         tx.vin.append(CTxIn(COutPoint(out[18].sha256, 0)))  # don't set nSequence\n         tx.vout.append(CTxOut(0, CScript([OP_TRUE])))\n-        assert(tx.vin[0].nSequence < 0xffffffff)\n+        assert tx.vin[0].nSequence < 0xffffffff\n         tx.calc_sha256()\n         b62 = self.update_block(62, [tx])\n         self.sync_blocks([b62], success=False, reject_reason='bad-txns-nonfinal')\n@@ -1143,8 +1143,8 @@ def run_test(self):\n         # now check that tx78 and tx79 have been put back into the peer's mempool\n         mempool = self.nodes[0].getrawmempool()\n         assert_equal(len(mempool), 2)\n-        assert(tx78.hash in mempool)\n-        assert(tx79.hash in mempool)\n+        assert tx78.hash in mempool\n+        assert tx79.hash in mempool\n \n         # Test invalid opcodes in dead execution paths.\n         #"
      },
      {
        "sha": "070242c1df2181fb56bbd2d1139024d71152ae91",
        "filename": "test/functional/feature_cltv.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_cltv.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_cltv.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_cltv.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2015-2018 The Bitcoin Core developers\n+# Copyright (c) 2015-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test BIP65 (CHECKLOCKTIMEVERIFY).\n@@ -15,7 +15,6 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n-    bytes_to_hex_str,\n     hex_str_to_bytes,\n )\n \n@@ -114,7 +113,7 @@ def run_test(self):\n         # rejected from the mempool for exactly that reason.\n         assert_equal(\n             [{'txid': spendtx.hash, 'allowed': False, 'reject-reason': '64: non-mandatory-script-verify-flag (Negative locktime)'}],\n-            self.nodes[0].testmempoolaccept(rawtxs=[bytes_to_hex_str(spendtx.serialize())], allowhighfees=True)\n+            self.nodes[0].testmempoolaccept(rawtxs=[spendtx.serialize().hex()], allowhighfees=True)\n         )\n \n         # Now we verify that a block with this transaction is also invalid."
      },
      {
        "sha": "13481b04782513117f6baa82d815a7b3cb3cac2f",
        "filename": "test/functional/feature_config_args.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_config_args.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_config_args.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_config_args.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2017-2018 The Bitcoin Core developers\n+# Copyright (c) 2017-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test various command line arguments and configuration file parameters.\"\"\""
      },
      {
        "sha": "ecc68217bb904cf61f92ef0a326083fc7ab95829",
        "filename": "test/functional/feature_csv_activation.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_csv_activation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_csv_activation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_csv_activation.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2015-2018 The Bitcoin Core developers\n+# Copyright (c) 2015-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test activation of the first version bits soft fork.\n@@ -106,7 +106,7 @@ def send_generic_input_tx(node, coinbases, address):\n def create_bip68txs(node, bip68inputs, txversion, address, locktime_delta=0):\n     \"\"\"Returns a list of bip68 transactions with different bits set.\"\"\"\n     txs = []\n-    assert(len(bip68inputs) >= 16)\n+    assert len(bip68inputs) >= 16\n     for i, (sdf, srhb, stf, srlb) in enumerate(product(*[[True, False]] * 4)):\n         locktime = relative_locktime(sdf, srhb, stf, srlb)\n         tx = create_transaction(node, bip68inputs[i], address, amount=Decimal(\"49.98\"))\n@@ -121,7 +121,7 @@ def create_bip68txs(node, bip68inputs, txversion, address, locktime_delta=0):\n def create_bip112txs(node, bip112inputs, varyOP_CSV, txversion, address, locktime_delta=0):\n     \"\"\"Returns a list of bip68 transactions with different bits set.\"\"\"\n     txs = []\n-    assert(len(bip112inputs) >= 16)\n+    assert len(bip112inputs) >= 16\n     for i, (sdf, srhb, stf, srlb) in enumerate(product(*[[True, False]] * 4)):\n         locktime = relative_locktime(sdf, srhb, stf, srlb)\n         tx = create_transaction(node, bip112inputs[i], address, amount=Decimal(\"49.98\"))"
      },
      {
        "sha": "62062926a6e7690e7c6a18f4b99f362c9070f4d4",
        "filename": "test/functional/feature_dbcrash.py",
        "status": "modified",
        "additions": 2,
        "deletions": 15,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_dbcrash.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_dbcrash.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_dbcrash.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2017-2018 The Bitcoin Core developers\n+# Copyright (c) 2017-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test recovery from a crash during chainstate writing.\n@@ -28,18 +28,12 @@\n import errno\n import http.client\n import random\n-import sys\n import time\n \n from test_framework.messages import COIN, COutPoint, CTransaction, CTxIn, CTxOut, ToHex\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal, create_confirmed_utxos, hex_str_to_bytes\n \n-HTTP_DISCONNECT_ERRORS = [http.client.CannotSendRequest]\n-try:\n-    HTTP_DISCONNECT_ERRORS.append(http.client.RemoteDisconnected)\n-except AttributeError:\n-    pass\n \n class ChainstateWriteCrashTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -110,14 +104,7 @@ def submit_block_catch_error(self, node_index, block):\n         try:\n             self.nodes[node_index].submitblock(block)\n             return True\n-        except http.client.BadStatusLine as e:\n-            # Prior to 3.5 BadStatusLine('') was raised for a remote disconnect error.\n-            if sys.version_info[0] == 3 and sys.version_info[1] < 5 and e.line == \"''\":\n-                self.log.debug(\"node %d submitblock raised exception: %s\", node_index, e)\n-                return False\n-            else:\n-                raise\n-        except tuple(HTTP_DISCONNECT_ERRORS) as e:\n+        except (http.client.CannotSendRequest, http.client.RemoteDisconnected) as e:\n             self.log.debug(\"node %d submitblock raised exception: %s\", node_index, e)\n             return False\n         except OSError as e:"
      },
      {
        "sha": "4ddfd80b079711f25b48f92fd9c85f0c95b7256a",
        "filename": "test/functional/feature_dersig.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_dersig.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_dersig.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_dersig.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2015-2018 The Bitcoin Core developers\n+# Copyright (c) 2015-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test BIP66 (DER SIG).\n@@ -14,7 +14,6 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n-    bytes_to_hex_str,\n     wait_until,\n )\n \n@@ -103,7 +102,7 @@ def run_test(self):\n         # rejected from the mempool for exactly that reason.\n         assert_equal(\n             [{'txid': spendtx.hash, 'allowed': False, 'reject-reason': '64: non-mandatory-script-verify-flag (Non-canonical DER signature)'}],\n-            self.nodes[0].testmempoolaccept(rawtxs=[bytes_to_hex_str(spendtx.serialize())], allowhighfees=True)\n+            self.nodes[0].testmempoolaccept(rawtxs=[spendtx.serialize().hex()], allowhighfees=True)\n         )\n \n         # Now we verify that a block with this transaction is also invalid."
      },
      {
        "sha": "13cf95155028b940dfbc1327da1535a8c7291f99",
        "filename": "test/functional/feature_notifications.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_notifications.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_notifications.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_notifications.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2014-2018 The Bitcoin Core developers\n+# Copyright (c) 2014-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the -alertnotify, -blocknotify and -walletnotify options.\"\"\""
      },
      {
        "sha": "e5d2f8dc46ae32c504d4942a1d6dfe01fcf96f0e",
        "filename": "test/functional/feature_nulldummy.py",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_nulldummy.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_nulldummy.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_nulldummy.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2016-2018 The Bitcoin Core developers\n+# Copyright (c) 2016-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test NULLDUMMY softfork.\n@@ -18,7 +18,7 @@\n from test_framework.messages import CTransaction\n from test_framework.script import CScript\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, assert_raises_rpc_error, bytes_to_hex_str\n+from test_framework.util import assert_equal, assert_raises_rpc_error\n \n NULLDUMMY_ERROR = \"non-mandatory-script-verify-flag (Dummy CHECKMULTISIG argument must be zero) (code 64)\"\n \n@@ -27,7 +27,7 @@ def trueDummy(tx):\n     newscript = []\n     for i in scriptSig:\n         if (len(newscript) == 0):\n-            assert(len(i) == 0)\n+            assert len(i) == 0\n             newscript.append(b'\\x51')\n         else:\n             newscript.append(i)\n@@ -64,17 +64,17 @@ def run_test(self):\n \n         self.log.info(\"Test 1: NULLDUMMY compliant base transactions should be accepted to mempool and mined before activation [430]\")\n         test1txs = [create_transaction(self.nodes[0], coinbase_txid[0], self.ms_address, amount=49)]\n-        txid1 = self.nodes[0].sendrawtransaction(bytes_to_hex_str(test1txs[0].serialize_with_witness()), True)\n+        txid1 = self.nodes[0].sendrawtransaction(test1txs[0].serialize_with_witness().hex(), True)\n         test1txs.append(create_transaction(self.nodes[0], txid1, self.ms_address, amount=48))\n-        txid2 = self.nodes[0].sendrawtransaction(bytes_to_hex_str(test1txs[1].serialize_with_witness()), True)\n+        txid2 = self.nodes[0].sendrawtransaction(test1txs[1].serialize_with_witness().hex(), True)\n         test1txs.append(create_transaction(self.nodes[0], coinbase_txid[1], self.wit_ms_address, amount=49))\n-        txid3 = self.nodes[0].sendrawtransaction(bytes_to_hex_str(test1txs[2].serialize_with_witness()), True)\n+        txid3 = self.nodes[0].sendrawtransaction(test1txs[2].serialize_with_witness().hex(), True)\n         self.block_submit(self.nodes[0], test1txs, False, True)\n \n         self.log.info(\"Test 2: Non-NULLDUMMY base multisig transaction should not be accepted to mempool before activation\")\n         test2tx = create_transaction(self.nodes[0], txid2, self.ms_address, amount=47)\n         trueDummy(test2tx)\n-        assert_raises_rpc_error(-26, NULLDUMMY_ERROR, self.nodes[0].sendrawtransaction, bytes_to_hex_str(test2tx.serialize_with_witness()), True)\n+        assert_raises_rpc_error(-26, NULLDUMMY_ERROR, self.nodes[0].sendrawtransaction, test2tx.serialize_with_witness().hex(), True)\n \n         self.log.info(\"Test 3: Non-NULLDUMMY base transactions should be accepted in a block before activation [431]\")\n         self.block_submit(self.nodes[0], [test2tx], False, True)\n@@ -83,19 +83,19 @@ def run_test(self):\n         test4tx = create_transaction(self.nodes[0], test2tx.hash, self.address, amount=46)\n         test6txs = [CTransaction(test4tx)]\n         trueDummy(test4tx)\n-        assert_raises_rpc_error(-26, NULLDUMMY_ERROR, self.nodes[0].sendrawtransaction, bytes_to_hex_str(test4tx.serialize_with_witness()), True)\n+        assert_raises_rpc_error(-26, NULLDUMMY_ERROR, self.nodes[0].sendrawtransaction, test4tx.serialize_with_witness().hex(), True)\n         self.block_submit(self.nodes[0], [test4tx])\n \n         self.log.info(\"Test 5: Non-NULLDUMMY P2WSH multisig transaction invalid after activation\")\n         test5tx = create_transaction(self.nodes[0], txid3, self.wit_address, amount=48)\n         test6txs.append(CTransaction(test5tx))\n         test5tx.wit.vtxinwit[0].scriptWitness.stack[0] = b'\\x01'\n-        assert_raises_rpc_error(-26, NULLDUMMY_ERROR, self.nodes[0].sendrawtransaction, bytes_to_hex_str(test5tx.serialize_with_witness()), True)\n+        assert_raises_rpc_error(-26, NULLDUMMY_ERROR, self.nodes[0].sendrawtransaction, test5tx.serialize_with_witness().hex(), True)\n         self.block_submit(self.nodes[0], [test5tx], True)\n \n         self.log.info(\"Test 6: NULLDUMMY compliant base/witness transactions should be accepted to mempool and in block after activation [432]\")\n         for i in test6txs:\n-            self.nodes[0].sendrawtransaction(bytes_to_hex_str(i.serialize_with_witness()), True)\n+            self.nodes[0].sendrawtransaction(i.serialize_with_witness().hex(), True)\n         self.block_submit(self.nodes[0], test6txs, True, True)\n \n     def block_submit(self, node, txs, witness=False, accept=False):\n@@ -108,7 +108,7 @@ def block_submit(self, node, txs, witness=False, accept=False):\n         witness and add_witness_commitment(block)\n         block.rehash()\n         block.solve()\n-        node.submitblock(bytes_to_hex_str(block.serialize(True)))\n+        node.submitblock(block.serialize(True).hex())\n         if (accept):\n             assert_equal(node.getbestblockhash(), block.hash)\n             self.tip = block.sha256"
      },
      {
        "sha": "be323d355e6f1a18c9aaa15fe87f21725eed4ea8",
        "filename": "test/functional/feature_proxy.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_proxy.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_proxy.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_proxy.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2015-2018 The Bitcoin Core developers\n+# Copyright (c) 2015-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test bitcoind with different proxy configuration.\n@@ -95,7 +95,7 @@ def node_test(self, node, proxies, auth, test_onion=True):\n         # Test: outgoing IPv4 connection through node\n         node.addnode(\"15.61.23.23:1234\", \"onetry\")\n         cmd = proxies[0].queue.get()\n-        assert(isinstance(cmd, Socks5Command))\n+        assert isinstance(cmd, Socks5Command)\n         # Note: bitcoind's SOCKS5 implementation only sends atyp DOMAINNAME, even if connecting directly to IPv4/IPv6\n         assert_equal(cmd.atyp, AddressType.DOMAINNAME)\n         assert_equal(cmd.addr, b\"15.61.23.23\")\n@@ -109,7 +109,7 @@ def node_test(self, node, proxies, auth, test_onion=True):\n             # Test: outgoing IPv6 connection through node\n             node.addnode(\"[1233:3432:2434:2343:3234:2345:6546:4534]:5443\", \"onetry\")\n             cmd = proxies[1].queue.get()\n-            assert(isinstance(cmd, Socks5Command))\n+            assert isinstance(cmd, Socks5Command)\n             # Note: bitcoind's SOCKS5 implementation only sends atyp DOMAINNAME, even if connecting directly to IPv4/IPv6\n             assert_equal(cmd.atyp, AddressType.DOMAINNAME)\n             assert_equal(cmd.addr, b\"1233:3432:2434:2343:3234:2345:6546:4534\")\n@@ -123,7 +123,7 @@ def node_test(self, node, proxies, auth, test_onion=True):\n             # Test: outgoing onion connection through node\n             node.addnode(\"bitcoinostk4e4re.onion:8333\", \"onetry\")\n             cmd = proxies[2].queue.get()\n-            assert(isinstance(cmd, Socks5Command))\n+            assert isinstance(cmd, Socks5Command)\n             assert_equal(cmd.atyp, AddressType.DOMAINNAME)\n             assert_equal(cmd.addr, b\"bitcoinostk4e4re.onion\")\n             assert_equal(cmd.port, 8333)\n@@ -135,7 +135,7 @@ def node_test(self, node, proxies, auth, test_onion=True):\n         # Test: outgoing DNS name connection through node\n         node.addnode(\"node.noumenon:8333\", \"onetry\")\n         cmd = proxies[3].queue.get()\n-        assert(isinstance(cmd, Socks5Command))\n+        assert isinstance(cmd, Socks5Command)\n         assert_equal(cmd.atyp, AddressType.DOMAINNAME)\n         assert_equal(cmd.addr, b\"node.noumenon\")\n         assert_equal(cmd.port, 8333)"
      },
      {
        "sha": "12da2655eed60b124da6c7973d5fa6bc4c29d554",
        "filename": "test/functional/feature_pruning.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_pruning.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2014-2018 The Bitcoin Core developers\n+# Copyright (c) 2014-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the pruning code.\n@@ -151,7 +151,7 @@ def reorg_test(self):\n             self.nodes[1].invalidateblock(curhash)\n             curhash = self.nodes[1].getblockhash(invalidheight - 1)\n \n-        assert(self.nodes[1].getblockcount() == invalidheight - 1)\n+        assert self.nodes[1].getblockcount() == invalidheight - 1\n         self.log.info(\"New best height: %d\" % self.nodes[1].getblockcount())\n \n         # Reboot node1 to clear those giant tx's from mempool\n@@ -219,17 +219,17 @@ def reorg_back(self):\n             blocks_to_mine = first_reorg_height + 1 - self.mainchainheight\n             self.log.info(\"Rewind node 0 to prev main chain to mine longer chain to trigger redownload. Blocks needed: %d\" % blocks_to_mine)\n             self.nodes[0].invalidateblock(curchainhash)\n-            assert(self.nodes[0].getblockcount() == self.mainchainheight)\n-            assert(self.nodes[0].getbestblockhash() == self.mainchainhash2)\n+            assert self.nodes[0].getblockcount() == self.mainchainheight\n+            assert self.nodes[0].getbestblockhash() == self.mainchainhash2\n             goalbesthash = self.nodes[0].generate(blocks_to_mine)[-1]\n             goalbestheight = first_reorg_height + 1\n \n         self.log.info(\"Verify node 2 reorged back to the main chain, some blocks of which it had to redownload\")\n         # Wait for Node 2 to reorg to proper height\n         wait_until(lambda: self.nodes[2].getblockcount() >= goalbestheight, timeout=900)\n-        assert(self.nodes[2].getbestblockhash() == goalbesthash)\n+        assert self.nodes[2].getbestblockhash() == goalbesthash\n         # Verify we can now have the data for a block previously pruned\n-        assert(self.nodes[2].getblock(self.forkhash)[\"height\"] == self.forkheight)\n+        assert self.nodes[2].getblock(self.forkhash)[\"height\"] == self.forkheight\n \n     def manual_test(self, node_number, use_timestamp):\n         # at this point, node has 995 blocks and has not yet run in prune mode"
      },
      {
        "sha": "a9c7226e46209675d9f84489102ae002e5c79ab2",
        "filename": "test/functional/feature_rbf.py",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_rbf.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_rbf.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_rbf.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2014-2018 The Bitcoin Core developers\n+# Copyright (c) 2014-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the RBF code.\"\"\"\n@@ -9,12 +9,12 @@\n from test_framework.messages import COIN, COutPoint, CTransaction, CTxIn, CTxOut\n from test_framework.script import CScript, OP_DROP\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, assert_raises_rpc_error, bytes_to_hex_str, satoshi_round\n+from test_framework.util import assert_equal, assert_raises_rpc_error, satoshi_round\n \n MAX_REPLACEMENT_LIMIT = 100\n \n def txToHex(tx):\n-    return bytes_to_hex_str(tx.serialize())\n+    return tx.serialize().hex()\n \n def make_utxo(node, amount, confirmed=True, scriptPubKey=CScript([1])):\n     \"\"\"Create a txout with a given amount and scriptPubKey\n@@ -56,7 +56,7 @@ def make_utxo(node, amount, confirmed=True, scriptPubKey=CScript([1])):\n             new_size = len(node.getrawmempool())\n             # Error out if we have something stuck in the mempool, as this\n             # would likely be a bug.\n-            assert(new_size < mempool_size)\n+            assert new_size < mempool_size\n             mempool_size = new_size\n \n     return COutPoint(int(txid, 16), 0)\n@@ -163,8 +163,8 @@ def test_simple_doublespend(self):\n \n         mempool = self.nodes[0].getrawmempool()\n \n-        assert (tx1a_txid not in mempool)\n-        assert (tx1b_txid in mempool)\n+        assert tx1a_txid not in mempool\n+        assert tx1b_txid in mempool\n \n         assert_equal(tx1b_hex, self.nodes[0].getrawtransaction(tx1b_txid))\n \n@@ -211,7 +211,7 @@ def test_doublespend_chain(self):\n \n         mempool = self.nodes[0].getrawmempool()\n         for doublespent_txid in chain_txids:\n-            assert(doublespent_txid not in mempool)\n+            assert doublespent_txid not in mempool\n \n     def test_doublespend_tree(self):\n         \"\"\"Doublespend of a big tree of transactions\"\"\"\n@@ -236,7 +236,7 @@ def branch(prevout, initial_value, max_txs, tree_width=5, fee=0.0001*COIN, _tota\n             tx.vout = vout\n             tx_hex = txToHex(tx)\n \n-            assert(len(tx.serialize()) < 100000)\n+            assert len(tx.serialize()) < 100000\n             txid = self.nodes[0].sendrawtransaction(tx_hex, True)\n             yield tx\n             _total_txs[0] += 1\n@@ -274,7 +274,7 @@ def branch(prevout, initial_value, max_txs, tree_width=5, fee=0.0001*COIN, _tota\n \n         for tx in tree_txs:\n             tx.rehash()\n-            assert (tx.hash not in mempool)\n+            assert tx.hash not in mempool\n \n         # Try again, but with more total transactions than the \"max txs\n         # double-spent at once\" anti-DoS limit.\n@@ -529,7 +529,7 @@ def test_prioritised_transactions(self):\n         # Now tx1b should be able to replace tx1a\n         tx1b_txid = self.nodes[0].sendrawtransaction(tx1b_hex, True)\n \n-        assert(tx1b_txid in self.nodes[0].getrawmempool())\n+        assert tx1b_txid in self.nodes[0].getrawmempool()\n \n         # 2. Check that absolute fee checks use modified fee.\n         tx1_outpoint = make_utxo(self.nodes[0], int(1.1*COIN))\n@@ -556,7 +556,7 @@ def test_prioritised_transactions(self):\n         # tx2b should now be accepted\n         tx2b_txid = self.nodes[0].sendrawtransaction(tx2b_hex, True)\n \n-        assert(tx2b_txid in self.nodes[0].getrawmempool())\n+        assert tx2b_txid in self.nodes[0].getrawmempool()\n \n     def test_rpc(self):\n         us0 = self.nodes[0].listunspent()[0]"
      },
      {
        "sha": "0128af8b65fc8ab09add59c5db4a6c8c8af6df83",
        "filename": "test/functional/feature_segwit.py",
        "status": "modified",
        "additions": 45,
        "deletions": 45,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_segwit.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2016-2018 The Bitcoin Core developers\n+# Copyright (c) 2016-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the SegWit changeover logic.\"\"\"\n@@ -18,7 +18,7 @@\n from test_framework.messages import COIN, COutPoint, CTransaction, CTxIn, CTxOut, FromHex, sha256, ToHex\n from test_framework.script import CScript, OP_HASH160, OP_CHECKSIG, OP_0, hash160, OP_EQUAL, OP_DUP, OP_EQUALVERIFY, OP_1, OP_2, OP_CHECKMULTISIG, OP_TRUE, OP_DROP\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, assert_raises_rpc_error, bytes_to_hex_str, connect_nodes, hex_str_to_bytes, sync_blocks, try_rpc\n+from test_framework.util import assert_equal, assert_raises_rpc_error, connect_nodes, hex_str_to_bytes, sync_blocks, try_rpc\n \n NODE_0 = 0\n NODE_2 = 2\n@@ -93,17 +93,17 @@ def run_test(self):\n         self.log.info(\"Verify sigops are counted in GBT with pre-BIP141 rules before the fork\")\n         txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n         tmpl = self.nodes[0].getblocktemplate({'rules': ['segwit']})\n-        assert(tmpl['sizelimit'] == 1000000)\n-        assert('weightlimit' not in tmpl)\n-        assert(tmpl['sigoplimit'] == 20000)\n-        assert(tmpl['transactions'][0]['hash'] == txid)\n-        assert(tmpl['transactions'][0]['sigops'] == 2)\n+        assert tmpl['sizelimit'] == 1000000\n+        assert 'weightlimit' not in tmpl\n+        assert tmpl['sigoplimit'] == 20000\n+        assert tmpl['transactions'][0]['hash'] == txid\n+        assert tmpl['transactions'][0]['sigops'] == 2\n         tmpl = self.nodes[0].getblocktemplate({'rules': ['segwit']})\n-        assert(tmpl['sizelimit'] == 1000000)\n-        assert('weightlimit' not in tmpl)\n-        assert(tmpl['sigoplimit'] == 20000)\n-        assert(tmpl['transactions'][0]['hash'] == txid)\n-        assert(tmpl['transactions'][0]['sigops'] == 2)\n+        assert tmpl['sizelimit'] == 1000000\n+        assert 'weightlimit' not in tmpl\n+        assert tmpl['sigoplimit'] == 20000\n+        assert tmpl['transactions'][0]['hash'] == txid\n+        assert tmpl['transactions'][0]['sigops'] == 2\n         self.nodes[0].generate(1)  # block 162\n \n         balance_presetup = self.nodes[0].getbalance()\n@@ -172,16 +172,16 @@ def run_test(self):\n         self.fail_accept(self.nodes[0], \"mandatory-script-verify-flag\", p2sh_ids[NODE_0][WIT_V1][0], False, witness_script(True, self.pubkey[0]))\n \n         self.log.info(\"Verify block and transaction serialization rpcs return differing serializations depending on rpc serialization flag\")\n-        assert(self.nodes[2].getblock(blockhash, False) != self.nodes[0].getblock(blockhash, False))\n-        assert(self.nodes[1].getblock(blockhash, False) == self.nodes[2].getblock(blockhash, False))\n+        assert self.nodes[2].getblock(blockhash, False) != self.nodes[0].getblock(blockhash, False)\n+        assert self.nodes[1].getblock(blockhash, False) == self.nodes[2].getblock(blockhash, False)\n \n         for tx_id in segwit_tx_list:\n             tx = FromHex(CTransaction(), self.nodes[2].gettransaction(tx_id)[\"hex\"])\n-            assert(self.nodes[2].getrawtransaction(tx_id, False, blockhash) != self.nodes[0].getrawtransaction(tx_id, False, blockhash))\n-            assert(self.nodes[1].getrawtransaction(tx_id, False, blockhash) == self.nodes[2].getrawtransaction(tx_id, False, blockhash))\n-            assert(self.nodes[0].getrawtransaction(tx_id, False, blockhash) != self.nodes[2].gettransaction(tx_id)[\"hex\"])\n-            assert(self.nodes[1].getrawtransaction(tx_id, False, blockhash) == self.nodes[2].gettransaction(tx_id)[\"hex\"])\n-            assert(self.nodes[0].getrawtransaction(tx_id, False, blockhash) == bytes_to_hex_str(tx.serialize_without_witness()))\n+            assert self.nodes[2].getrawtransaction(tx_id, False, blockhash) != self.nodes[0].getrawtransaction(tx_id, False, blockhash)\n+            assert self.nodes[1].getrawtransaction(tx_id, False, blockhash) == self.nodes[2].getrawtransaction(tx_id, False, blockhash)\n+            assert self.nodes[0].getrawtransaction(tx_id, False, blockhash) != self.nodes[2].gettransaction(tx_id)[\"hex\"]\n+            assert self.nodes[1].getrawtransaction(tx_id, False, blockhash) == self.nodes[2].gettransaction(tx_id)[\"hex\"]\n+            assert self.nodes[0].getrawtransaction(tx_id, False, blockhash) == tx.serialize_without_witness().hex()\n \n         self.log.info(\"Verify witness txs without witness data are invalid after the fork\")\n         self.fail_accept(self.nodes[2], 'non-mandatory-script-verify-flag (Witness program hash mismatch) (code 64)', wit_ids[NODE_2][WIT_V0][2], sign=False)\n@@ -198,11 +198,11 @@ def run_test(self):\n         self.log.info(\"Verify sigops are counted in GBT with BIP141 rules after the fork\")\n         txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n         tmpl = self.nodes[0].getblocktemplate({'rules': ['segwit']})\n-        assert(tmpl['sizelimit'] >= 3999577)  # actual maximum size is lower due to minimum mandatory non-witness data\n-        assert(tmpl['weightlimit'] == 4000000)\n-        assert(tmpl['sigoplimit'] == 80000)\n-        assert(tmpl['transactions'][0]['txid'] == txid)\n-        assert(tmpl['transactions'][0]['sigops'] == 8)\n+        assert tmpl['sizelimit'] >= 3999577  # actual maximum size is lower due to minimum mandatory non-witness data\n+        assert tmpl['weightlimit'] == 4000000\n+        assert tmpl['sigoplimit'] == 80000\n+        assert tmpl['transactions'][0]['txid'] == txid\n+        assert tmpl['transactions'][0]['sigops'] == 8\n \n         self.nodes[0].generate(1)  # Mine a block to clear the gbt cache\n \n@@ -214,8 +214,8 @@ def run_test(self):\n         txid1 = send_to_witness(1, self.nodes[0], find_spendable_utxo(self.nodes[0], 50), self.pubkey[0], False, Decimal(\"49.996\"))\n         hex_tx = self.nodes[0].gettransaction(txid)['hex']\n         tx = FromHex(CTransaction(), hex_tx)\n-        assert(tx.wit.is_null())  # This should not be a segwit input\n-        assert(txid1 in self.nodes[0].getrawmempool())\n+        assert tx.wit.is_null()  # This should not be a segwit input\n+        assert txid1 in self.nodes[0].getrawmempool()\n \n         # Now create tx2, which will spend from txid1.\n         tx = CTransaction()\n@@ -224,23 +224,23 @@ def run_test(self):\n         tx2_hex = self.nodes[0].signrawtransactionwithwallet(ToHex(tx))['hex']\n         txid2 = self.nodes[0].sendrawtransaction(tx2_hex)\n         tx = FromHex(CTransaction(), tx2_hex)\n-        assert(not tx.wit.is_null())\n+        assert not tx.wit.is_null()\n \n         # Now create tx3, which will spend from txid2\n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(int(txid2, 16), 0), b\"\"))\n         tx.vout.append(CTxOut(int(49.95 * COIN), CScript([OP_TRUE, OP_DROP] * 15 + [OP_TRUE])))  # Huge fee\n         tx.calc_sha256()\n         txid3 = self.nodes[0].sendrawtransaction(ToHex(tx))\n-        assert(tx.wit.is_null())\n-        assert(txid3 in self.nodes[0].getrawmempool())\n+        assert tx.wit.is_null()\n+        assert txid3 in self.nodes[0].getrawmempool()\n \n         # Check that getblocktemplate includes all transactions.\n         template = self.nodes[0].getblocktemplate({\"rules\": [\"segwit\"]})\n         template_txids = [t['txid'] for t in template['transactions']]\n-        assert(txid1 in template_txids)\n-        assert(txid2 in template_txids)\n-        assert(txid3 in template_txids)\n+        assert txid1 in template_txids\n+        assert txid2 in template_txids\n+        assert txid3 in template_txids\n \n         # Check that wtxid is properly reported in mempool entry\n         assert_equal(int(self.nodes[0].getmempoolentry(txid3)[\"wtxid\"], 16), tx.calc_sha256(True))\n@@ -392,22 +392,22 @@ def run_test(self):\n             v = self.nodes[0].getaddressinfo(i)\n             if (v['isscript']):\n                 bare = hex_str_to_bytes(v['hex'])\n-                importlist.append(bytes_to_hex_str(bare))\n-                importlist.append(bytes_to_hex_str(CScript([OP_0, sha256(bare)])))\n+                importlist.append(bare.hex())\n+                importlist.append(CScript([OP_0, sha256(bare)]).hex())\n             else:\n                 pubkey = hex_str_to_bytes(v['pubkey'])\n                 p2pk = CScript([pubkey, OP_CHECKSIG])\n                 p2pkh = CScript([OP_DUP, OP_HASH160, hash160(pubkey), OP_EQUALVERIFY, OP_CHECKSIG])\n-                importlist.append(bytes_to_hex_str(p2pk))\n-                importlist.append(bytes_to_hex_str(p2pkh))\n-                importlist.append(bytes_to_hex_str(CScript([OP_0, hash160(pubkey)])))\n-                importlist.append(bytes_to_hex_str(CScript([OP_0, sha256(p2pk)])))\n-                importlist.append(bytes_to_hex_str(CScript([OP_0, sha256(p2pkh)])))\n+                importlist.append(p2pk.hex())\n+                importlist.append(p2pkh.hex())\n+                importlist.append(CScript([OP_0, hash160(pubkey)]).hex())\n+                importlist.append(CScript([OP_0, sha256(p2pk)]).hex())\n+                importlist.append(CScript([OP_0, sha256(p2pkh)]).hex())\n \n-        importlist.append(bytes_to_hex_str(unsolvablep2pkh))\n-        importlist.append(bytes_to_hex_str(unsolvablep2wshp2pkh))\n-        importlist.append(bytes_to_hex_str(op1))\n-        importlist.append(bytes_to_hex_str(p2wshop1))\n+        importlist.append(unsolvablep2pkh.hex())\n+        importlist.append(unsolvablep2wshp2pkh.hex())\n+        importlist.append(op1.hex())\n+        importlist.append(p2wshop1.hex())\n \n         for i in importlist:\n             # import all generated addresses. The wallet already has the private keys for some of these, so catch JSON RPC\n@@ -535,7 +535,7 @@ def mine_and_test_listunspent(self, script_list, ismine):\n         for i in script_list:\n             tx.vout.append(CTxOut(10000000, i))\n         tx.rehash()\n-        signresults = self.nodes[0].signrawtransactionwithwallet(bytes_to_hex_str(tx.serialize_without_witness()))['hex']\n+        signresults = self.nodes[0].signrawtransactionwithwallet(tx.serialize_without_witness().hex())['hex']\n         txid = self.nodes[0].sendrawtransaction(signresults, True)\n         txs_mined[txid] = self.nodes[0].generate(1)[0]\n         sync_blocks(self.nodes)\n@@ -587,7 +587,7 @@ def create_and_mine_tx_from_txids(self, txids, success=True):\n                 tx.vin.append(CTxIn(COutPoint(int('0x' + i, 0), j)))\n         tx.vout.append(CTxOut(0, CScript()))\n         tx.rehash()\n-        signresults = self.nodes[0].signrawtransactionwithwallet(bytes_to_hex_str(tx.serialize_without_witness()))['hex']\n+        signresults = self.nodes[0].signrawtransactionwithwallet(tx.serialize_without_witness().hex())['hex']\n         self.nodes[0].sendrawtransaction(signresults, True)\n         self.nodes[0].generate(1)\n         sync_blocks(self.nodes)"
      },
      {
        "sha": "071392514116706834e77c1d460356f1b0356846",
        "filename": "test/functional/feature_versionbits_warning.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_versionbits_warning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/feature_versionbits_warning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_versionbits_warning.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2016-2018 The Bitcoin Core developers\n+# Copyright (c) 2016-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test version bits warning system.\n@@ -74,8 +74,8 @@ def run_test(self):\n         node.generatetoaddress(VB_PERIOD - VB_THRESHOLD + 1, node_deterministic_address)\n \n         # Check that we're not getting any versionbit-related errors in get*info()\n-        assert(not VB_PATTERN.match(node.getmininginfo()[\"warnings\"]))\n-        assert(not VB_PATTERN.match(node.getnetworkinfo()[\"warnings\"]))\n+        assert not VB_PATTERN.match(node.getmininginfo()[\"warnings\"])\n+        assert not VB_PATTERN.match(node.getnetworkinfo()[\"warnings\"])\n \n         # Build one period of blocks with VB_THRESHOLD blocks signaling some unknown bit\n         self.send_blocks_with_version(node.p2p, VB_THRESHOLD, VB_UNKNOWN_VERSION)\n@@ -95,8 +95,8 @@ def run_test(self):\n         # Generating one more block will be enough to generate an error.\n         node.generatetoaddress(1, node_deterministic_address)\n         # Check that get*info() shows the versionbits unknown rules warning\n-        assert(WARN_UNKNOWN_RULES_ACTIVE in node.getmininginfo()[\"warnings\"])\n-        assert(WARN_UNKNOWN_RULES_ACTIVE in node.getnetworkinfo()[\"warnings\"])\n+        assert WARN_UNKNOWN_RULES_ACTIVE in node.getmininginfo()[\"warnings\"]\n+        assert WARN_UNKNOWN_RULES_ACTIVE in node.getnetworkinfo()[\"warnings\"]\n         # Check that the alert file shows the versionbits unknown rules warning\n         wait_until(lambda: self.versionbits_in_alert_file(), timeout=60)\n "
      },
      {
        "sha": "f44fc768dc9f0c04657aafc59fd41de398a2832d",
        "filename": "test/functional/interface_bitcoin_cli.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/interface_bitcoin_cli.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/interface_bitcoin_cli.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_bitcoin_cli.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2017-2018 The Bitcoin Core developers\n+# Copyright (c) 2017-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test bitcoin-cli\"\"\"\n@@ -16,7 +16,7 @@ def run_test(self):\n         \"\"\"Main test logic\"\"\"\n \n         cli_response = self.nodes[0].cli(\"-version\").send_cli()\n-        assert(\"Bitcoin Core RPC client version\" in cli_response)\n+        assert \"Bitcoin Core RPC client version\" in cli_response\n \n         self.log.info(\"Compare responses from getwalletinfo RPC and `bitcoin-cli getwalletinfo`\")\n         if self.is_wallet_compiled():"
      },
      {
        "sha": "bb868d7115e0ef4ceb64de01acc36db4e83b38dd",
        "filename": "test/functional/interface_http.py",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/interface_http.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/interface_http.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_http.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2014-2018 The Bitcoin Core developers\n+# Copyright (c) 2014-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the RPC HTTP basics.\"\"\"\n@@ -30,14 +30,14 @@ def run_test(self):\n         conn.connect()\n         conn.request('POST', '/', '{\"method\": \"getbestblockhash\"}', headers)\n         out1 = conn.getresponse().read()\n-        assert(b'\"error\":null' in out1)\n-        assert(conn.sock is not None) #according to http/1.1 connection must still be open!\n+        assert b'\"error\":null' in out1\n+        assert conn.sock is not None  #according to http/1.1 connection must still be open!\n \n         #send 2nd request without closing connection\n         conn.request('POST', '/', '{\"method\": \"getchaintips\"}', headers)\n         out1 = conn.getresponse().read()\n-        assert(b'\"error\":null' in out1) #must also response with a correct json-rpc message\n-        assert(conn.sock is not None) #according to http/1.1 connection must still be open!\n+        assert b'\"error\":null' in out1  #must also response with a correct json-rpc message\n+        assert conn.sock is not None  #according to http/1.1 connection must still be open!\n         conn.close()\n \n         #same should be if we add keep-alive because this should be the std. behaviour\n@@ -47,14 +47,14 @@ def run_test(self):\n         conn.connect()\n         conn.request('POST', '/', '{\"method\": \"getbestblockhash\"}', headers)\n         out1 = conn.getresponse().read()\n-        assert(b'\"error\":null' in out1)\n-        assert(conn.sock is not None) #according to http/1.1 connection must still be open!\n+        assert b'\"error\":null' in out1\n+        assert conn.sock is not None  #according to http/1.1 connection must still be open!\n \n         #send 2nd request without closing connection\n         conn.request('POST', '/', '{\"method\": \"getchaintips\"}', headers)\n         out1 = conn.getresponse().read()\n-        assert(b'\"error\":null' in out1) #must also response with a correct json-rpc message\n-        assert(conn.sock is not None) #according to http/1.1 connection must still be open!\n+        assert b'\"error\":null' in out1  #must also response with a correct json-rpc message\n+        assert conn.sock is not None  #according to http/1.1 connection must still be open!\n         conn.close()\n \n         #now do the same with \"Connection: close\"\n@@ -64,8 +64,8 @@ def run_test(self):\n         conn.connect()\n         conn.request('POST', '/', '{\"method\": \"getbestblockhash\"}', headers)\n         out1 = conn.getresponse().read()\n-        assert(b'\"error\":null' in out1)\n-        assert(conn.sock is None) #now the connection must be closed after the response\n+        assert b'\"error\":null' in out1\n+        assert conn.sock is None  #now the connection must be closed after the response\n \n         #node1 (2nd node) is running with disabled keep-alive option\n         urlNode1 = urllib.parse.urlparse(self.nodes[1].url)\n@@ -76,7 +76,7 @@ def run_test(self):\n         conn.connect()\n         conn.request('POST', '/', '{\"method\": \"getbestblockhash\"}', headers)\n         out1 = conn.getresponse().read()\n-        assert(b'\"error\":null' in out1)\n+        assert b'\"error\":null' in out1\n \n         #node2 (third node) is running with standard keep-alive parameters which means keep-alive is on\n         urlNode2 = urllib.parse.urlparse(self.nodes[2].url)\n@@ -87,8 +87,8 @@ def run_test(self):\n         conn.connect()\n         conn.request('POST', '/', '{\"method\": \"getbestblockhash\"}', headers)\n         out1 = conn.getresponse().read()\n-        assert(b'\"error\":null' in out1)\n-        assert(conn.sock is not None) #connection must be closed because bitcoind should use keep-alive by default\n+        assert b'\"error\":null' in out1\n+        assert conn.sock is not None  #connection must be closed because bitcoind should use keep-alive by default\n \n         # Check excessive request size\n         conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)"
      },
      {
        "sha": "a036dfc790abb5bf64b7b58db94be1f1d962fd34",
        "filename": "test/functional/interface_rest.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/interface_rest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/interface_rest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_rest.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2014-2018 The Bitcoin Core developers\n+# Copyright (c) 2014-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the REST API.\"\"\"\n@@ -152,7 +152,7 @@ def run_test(self):\n         bin_response = self.test_rest_request(\"/getutxos\", http_method='POST', req_type=ReqType.BIN, body=bin_request, ret_type=RetType.BYTES)\n         output = BytesIO(bin_response)\n         chain_height, = unpack(\"i\", output.read(4))\n-        response_hash = binascii.hexlify(output.read(32)[::-1]).decode('ascii')\n+        response_hash = output.read(32)[::-1].hex()\n \n         assert_equal(bb_hash, response_hash)  # check if getutxo's chaintip during calculation was fine\n         assert_equal(chain_height, 102)  # chain height must be 102\n@@ -252,7 +252,7 @@ def run_test(self):\n         resp_hex = self.test_rest_request(\"/blockhashbyheight/{}\".format(block_json_obj['height']), req_type=ReqType.HEX, ret_type=RetType.OBJ)\n         assert_equal(resp_hex.read().decode('utf-8').rstrip(), bb_hash)\n         resp_bytes = self.test_rest_request(\"/blockhashbyheight/{}\".format(block_json_obj['height']), req_type=ReqType.BIN, ret_type=RetType.BYTES)\n-        blockhash = binascii.hexlify(resp_bytes[::-1]).decode('utf-8')\n+        blockhash = resp_bytes[::-1].hex()\n         assert_equal(blockhash, bb_hash)\n \n         # Check invalid blockhashbyheight requests"
      },
      {
        "sha": "67ab1f0130a90338d9ce0ea82e3201aa8b9984af",
        "filename": "test/functional/interface_rpc.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/interface_rpc.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/interface_rpc.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_rpc.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2018 The Bitcoin Core developers\n+# Copyright (c) 2018-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Tests some generic aspects of the RPC interface.\"\"\""
      },
      {
        "sha": "8e58c85c153831f4b0d3432df1f10b6f42c14f84",
        "filename": "test/functional/interface_zmq.py",
        "status": "modified",
        "additions": 7,
        "deletions": 8,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/interface_zmq.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/interface_zmq.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_zmq.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2015-2018 The Bitcoin Core developers\n+# Copyright (c) 2015-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the ZMQ notification interface.\"\"\"\n@@ -10,7 +10,6 @@\n from test_framework.messages import CTransaction\n from test_framework.util import (\n     assert_equal,\n-    bytes_to_hex_str,\n     hash256,\n )\n from io import BytesIO\n@@ -94,17 +93,17 @@ def _zmq_test(self):\n             tx = CTransaction()\n             tx.deserialize(BytesIO(hex))\n             tx.calc_sha256()\n-            assert_equal(tx.hash, bytes_to_hex_str(txid))\n+            assert_equal(tx.hash, txid.hex())\n \n             # Should receive the generated block hash.\n-            hash = bytes_to_hex_str(self.hashblock.receive())\n+            hash = self.hashblock.receive().hex()\n             assert_equal(genhashes[x], hash)\n             # The block should only have the coinbase txid.\n-            assert_equal([bytes_to_hex_str(txid)], self.nodes[1].getblock(hash)[\"tx\"])\n+            assert_equal([txid.hex()], self.nodes[1].getblock(hash)[\"tx\"])\n \n             # Should receive the generated raw block.\n             block = self.rawblock.receive()\n-            assert_equal(genhashes[x], bytes_to_hex_str(hash256(block[:80])))\n+            assert_equal(genhashes[x], hash256(block[:80]).hex())\n \n         if self.is_wallet_compiled():\n             self.log.info(\"Wait for tx from second node\")\n@@ -113,11 +112,11 @@ def _zmq_test(self):\n \n             # Should receive the broadcasted txid.\n             txid = self.hashtx.receive()\n-            assert_equal(payment_txid, bytes_to_hex_str(txid))\n+            assert_equal(payment_txid, txid.hex())\n \n             # Should receive the broadcasted raw transaction.\n             hex = self.rawtx.receive()\n-            assert_equal(payment_txid, bytes_to_hex_str(hash256(hex)))\n+            assert_equal(payment_txid, hash256(hex).hex())\n \n \n         self.log.info(\"Test the getzmqnotifications RPC\")"
      },
      {
        "sha": "fc811190505256e3049ba6ae1a47ef784585109d",
        "filename": "test/functional/mempool_accept.py",
        "status": "modified",
        "additions": 24,
        "deletions": 25,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/mempool_accept.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/mempool_accept.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_accept.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2017-2018 The Bitcoin Core developers\n+# Copyright (c) 2017-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test mempool acceptance of raw transactions.\"\"\"\n@@ -27,7 +27,6 @@\n from test_framework.util import (\n     assert_equal,\n     assert_raises_rpc_error,\n-    bytes_to_hex_str,\n     hex_str_to_bytes,\n )\n \n@@ -101,7 +100,7 @@ def run_test(self):\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_final)))\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': True}],\n-            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+            rawtxs=[tx.serialize().hex()],\n             allowhighfees=True,\n         )\n         node.sendrawtransaction(hexstring=raw_tx_final, allowhighfees=True)\n@@ -119,7 +118,7 @@ def run_test(self):\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_0)))\n         tx.vout[0].nValue -= int(fee * COIN)  # Double the fee\n         tx.vin[0].nSequence = BIP125_SEQUENCE_NUMBER + 1  # Now, opt out of RBF\n-        raw_tx_0 = node.signrawtransactionwithwallet(bytes_to_hex_str(tx.serialize()))['hex']\n+        raw_tx_0 = node.signrawtransactionwithwallet(tx.serialize().hex())['hex']\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_0)))\n         txid_0 = tx.rehash()\n         self.check_mempool_result(\n@@ -129,14 +128,14 @@ def run_test(self):\n \n         self.log.info('A transaction that conflicts with an unconfirmed tx')\n         # Send the transaction that replaces the mempool transaction and opts out of replaceability\n-        node.sendrawtransaction(hexstring=bytes_to_hex_str(tx.serialize()), allowhighfees=True)\n+        node.sendrawtransaction(hexstring=tx.serialize().hex(), allowhighfees=True)\n         # take original raw_tx_0\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_0)))\n         tx.vout[0].nValue -= int(4 * fee * COIN)  # Set more fee\n         # skip re-signing the tx\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '18: txn-mempool-conflict'}],\n-            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+            rawtxs=[tx.serialize().hex()],\n             allowhighfees=True,\n         )\n \n@@ -146,13 +145,13 @@ def run_test(self):\n         # skip re-signing the tx\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'missing-inputs'}],\n-            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+            rawtxs=[tx.serialize().hex()],\n         )\n \n         self.log.info('A transaction with missing inputs, that existed once in the past')\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_0)))\n         tx.vin[0].prevout.n = 1  # Set vout to 1, to spend the other outpoint (49 coins) of the in-chain-tx we want to double spend\n-        raw_tx_1 = node.signrawtransactionwithwallet(bytes_to_hex_str(tx.serialize()))['hex']\n+        raw_tx_1 = node.signrawtransactionwithwallet(tx.serialize().hex())['hex']\n         txid_1 = node.sendrawtransaction(hexstring=raw_tx_1, allowhighfees=True)\n         # Now spend both to \"clearly hide\" the outputs, ie. remove the coins from the utxo set by spending them\n         raw_tx_spend_both = node.signrawtransactionwithwallet(node.createrawtransaction(\n@@ -184,41 +183,41 @@ def run_test(self):\n         # Reference tx should be valid on itself\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': True}],\n-            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+            rawtxs=[tx.serialize().hex()],\n         )\n \n         self.log.info('A transaction with no outputs')\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n         tx.vout = []\n         # Skip re-signing the transaction for context independent checks from now on\n-        # tx.deserialize(BytesIO(hex_str_to_bytes(node.signrawtransactionwithwallet(bytes_to_hex_str(tx.serialize()))['hex'])))\n+        # tx.deserialize(BytesIO(hex_str_to_bytes(node.signrawtransactionwithwallet(tx.serialize().hex())['hex'])))\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '16: bad-txns-vout-empty'}],\n-            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+            rawtxs=[tx.serialize().hex()],\n         )\n \n         self.log.info('A really large transaction')\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n         tx.vin = [tx.vin[0]] * math.ceil(MAX_BLOCK_BASE_SIZE / len(tx.vin[0].serialize()))\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '16: bad-txns-oversize'}],\n-            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+            rawtxs=[tx.serialize().hex()],\n         )\n \n         self.log.info('A transaction with negative output value')\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n         tx.vout[0].nValue *= -1\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '16: bad-txns-vout-negative'}],\n-            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+            rawtxs=[tx.serialize().hex()],\n         )\n \n         self.log.info('A transaction with too large output value')\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n         tx.vout[0].nValue = 21000000 * COIN + 1\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '16: bad-txns-vout-toolarge'}],\n-            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+            rawtxs=[tx.serialize().hex()],\n         )\n \n         self.log.info('A transaction with too large sum of output values')\n@@ -227,15 +226,15 @@ def run_test(self):\n         tx.vout[0].nValue = 21000000 * COIN\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '16: bad-txns-txouttotal-toolarge'}],\n-            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+            rawtxs=[tx.serialize().hex()],\n         )\n \n         self.log.info('A transaction with duplicate inputs')\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n         tx.vin = [tx.vin[0]] * 2\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '16: bad-txns-inputs-duplicate'}],\n-            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+            rawtxs=[tx.serialize().hex()],\n         )\n \n         self.log.info('A coinbase transaction')\n@@ -244,49 +243,49 @@ def run_test(self):\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_coinbase_spent)))\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '16: coinbase'}],\n-            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+            rawtxs=[tx.serialize().hex()],\n         )\n \n         self.log.info('Some nonstandard transactions')\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n         tx.nVersion = 3  # A version currently non-standard\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '64: version'}],\n-            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+            rawtxs=[tx.serialize().hex()],\n         )\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n         tx.vout[0].scriptPubKey = CScript([OP_0])  # Some non-standard script\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '64: scriptpubkey'}],\n-            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+            rawtxs=[tx.serialize().hex()],\n         )\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n         tx.vin[0].scriptSig = CScript([OP_HASH160])  # Some not-pushonly scriptSig\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '64: scriptsig-not-pushonly'}],\n-            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+            rawtxs=[tx.serialize().hex()],\n         )\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n         output_p2sh_burn = CTxOut(nValue=540, scriptPubKey=CScript([OP_HASH160, hash160(b'burn'), OP_EQUAL]))\n         num_scripts = 100000 // len(output_p2sh_burn.serialize())  # Use enough outputs to make the tx too large for our policy\n         tx.vout = [output_p2sh_burn] * num_scripts\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '64: tx-size'}],\n-            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+            rawtxs=[tx.serialize().hex()],\n         )\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n         tx.vout[0] = output_p2sh_burn\n         tx.vout[0].nValue -= 1  # Make output smaller, such that it is dust for our policy\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '64: dust'}],\n-            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+            rawtxs=[tx.serialize().hex()],\n         )\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n         tx.vout[0].scriptPubKey = CScript([OP_RETURN, b'\\xff'])\n         tx.vout = [tx.vout[0]] * 2\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '64: multi-op-return'}],\n-            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+            rawtxs=[tx.serialize().hex()],\n         )\n \n         self.log.info('A timelocked transaction')\n@@ -295,7 +294,7 @@ def run_test(self):\n         tx.nLockTime = node.getblockcount() + 1\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '64: non-final'}],\n-            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+            rawtxs=[tx.serialize().hex()],\n         )\n \n         self.log.info('A transaction that is locked by BIP68 sequence logic')\n@@ -304,7 +303,7 @@ def run_test(self):\n         # Can skip re-signing the tx because of early rejection\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '64: non-BIP68-final'}],\n-            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+            rawtxs=[tx.serialize().hex()],\n             allowhighfees=True,\n         )\n "
      },
      {
        "sha": "351b27e94a0a2d999cc833624dfbfc6788e15cc4",
        "filename": "test/functional/mempool_limit.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/mempool_limit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/mempool_limit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_limit.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2014-2018 The Bitcoin Core developers\n+# Copyright (c) 2014-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test mempool limiting together/eviction with the wallet.\"\"\"\n@@ -47,9 +47,9 @@ def run_test(self):\n             txids[i] = create_lots_of_big_transactions(self.nodes[0], txouts, utxos[30*i:30*i+30], 30, (i+1)*base_fee)\n \n         self.log.info('The tx should be evicted by now')\n-        assert(txid not in self.nodes[0].getrawmempool())\n+        assert txid not in self.nodes[0].getrawmempool()\n         txdata = self.nodes[0].gettransaction(txid)\n-        assert(txdata['confirmations'] ==  0) #confirmation should still be 0\n+        assert txdata['confirmations'] ==  0  #confirmation should still be 0\n \n         self.log.info('Check that mempoolminfee is larger than minrelytxfee')\n         assert_equal(self.nodes[0].getmempoolinfo()['minrelaytxfee'], Decimal('0.00001000'))"
      },
      {
        "sha": "7cee215d54eb09afe039660783d1dbb5c68fdfbc",
        "filename": "test/functional/mempool_packages.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/mempool_packages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/mempool_packages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_packages.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2014-2018 The Bitcoin Core developers\n+# Copyright (c) 2014-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test descendant package tracking code.\"\"\"\n@@ -33,7 +33,7 @@ def chain_transaction(self, node, parent_txid, vout, value, fee, num_outputs):\n         signedtx = node.signrawtransactionwithwallet(rawtx)\n         txid = node.sendrawtransaction(signedtx['hex'])\n         fulltx = node.getrawtransaction(txid, 1)\n-        assert(len(fulltx['vout']) == num_outputs) # make sure we didn't generate a change output\n+        assert len(fulltx['vout']) == num_outputs  # make sure we didn't generate a change output\n         return (txid, send_value)\n \n     def run_test(self):\n@@ -125,13 +125,13 @@ def run_test(self):\n         assert_equal(len(v_ancestors), len(chain)-1)\n         for x in v_ancestors.keys():\n             assert_equal(mempool[x], v_ancestors[x])\n-        assert(chain[-1] not in v_ancestors.keys())\n+        assert chain[-1] not in v_ancestors.keys()\n \n         v_descendants = self.nodes[0].getmempooldescendants(chain[0], True)\n         assert_equal(len(v_descendants), len(chain)-1)\n         for x in v_descendants.keys():\n             assert_equal(mempool[x], v_descendants[x])\n-        assert(chain[0] not in v_descendants.keys())\n+        assert chain[0] not in v_descendants.keys()\n \n         # Check that ancestor modified fees includes fee deltas from\n         # prioritisetransaction"
      },
      {
        "sha": "187c9026f6dcf0924801fcbe423dc41207b730f4",
        "filename": "test/functional/mempool_resurrect.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/mempool_resurrect.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/mempool_resurrect.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_resurrect.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2014-2018 The Bitcoin Core developers\n+# Copyright (c) 2014-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test resurrection of mined transactions when the blockchain is re-organized.\"\"\"\n@@ -45,7 +45,7 @@ def run_test(self):\n         assert_equal(set(self.nodes[0].getrawmempool()), set())\n         for txid in spends1_id+spends2_id:\n             tx = self.nodes[0].gettransaction(txid)\n-            assert(tx[\"confirmations\"] > 0)\n+            assert tx[\"confirmations\"] > 0\n \n         # Use invalidateblock to re-org back\n         for node in self.nodes:\n@@ -55,15 +55,15 @@ def run_test(self):\n         assert_equal(set(self.nodes[0].getrawmempool()), set(spends1_id+spends2_id))\n         for txid in spends1_id+spends2_id:\n             tx = self.nodes[0].gettransaction(txid)\n-            assert(tx[\"confirmations\"] == 0)\n+            assert tx[\"confirmations\"] == 0\n \n         # Generate another block, they should all get mined\n         self.nodes[0].generate(1)\n         # mempool should be empty, all txns confirmed\n         assert_equal(set(self.nodes[0].getrawmempool()), set())\n         for txid in spends1_id+spends2_id:\n             tx = self.nodes[0].gettransaction(txid)\n-            assert(tx[\"confirmations\"] > 0)\n+            assert tx[\"confirmations\"] > 0\n \n \n if __name__ == '__main__':"
      },
      {
        "sha": "788aabc192c0e336b378fa8642c3749da24d4f7c",
        "filename": "test/functional/mining_basic.py",
        "status": "modified",
        "additions": 23,
        "deletions": 24,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/mining_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/mining_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mining_basic.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -27,7 +27,6 @@\n from test_framework.util import (\n     assert_equal,\n     assert_raises_rpc_error,\n-    bytes_to_hex_str as b2x,\n     connect_nodes_bi,\n )\n from test_framework.script import CScriptNum\n@@ -36,7 +35,7 @@\n def assert_template(node, block, expect, rehash=True):\n     if rehash:\n         block.hashMerkleRoot = block.calc_merkle_root()\n-    rsp = node.getblocktemplate(template_request={'data': b2x(block.serialize()), 'mode': 'proposal', 'rules': ['segwit']})\n+    rsp = node.getblocktemplate(template_request={'data': block.serialize().hex(), 'mode': 'proposal', 'rules': ['segwit']})\n     assert_equal(rsp, expect)\n \n \n@@ -64,8 +63,8 @@ def run_test(self):\n         def assert_submitblock(block, result_str_1, result_str_2=None):\n             block.solve()\n             result_str_2 = result_str_2 or 'duplicate-invalid'\n-            assert_equal(result_str_1, node.submitblock(hexdata=b2x(block.serialize())))\n-            assert_equal(result_str_2, node.submitblock(hexdata=b2x(block.serialize())))\n+            assert_equal(result_str_1, node.submitblock(hexdata=block.serialize().hex()))\n+            assert_equal(result_str_2, node.submitblock(hexdata=block.serialize().hex()))\n \n         self.log.info('getmininginfo')\n         mining_info = node.getmininginfo()\n@@ -112,7 +111,7 @@ def assert_submitblock(block, result_str_1, result_str_2=None):\n         assert_template(node, block, None)\n \n         self.log.info(\"submitblock: Test block decode failure\")\n-        assert_raises_rpc_error(-22, \"Block decode failed\", node.submitblock, b2x(block.serialize()[:-15]))\n+        assert_raises_rpc_error(-22, \"Block decode failed\", node.submitblock, block.serialize()[:-15].hex())\n \n         self.log.info(\"getblocktemplate: Test bad input hash for coinbase transaction\")\n         bad_block = copy.deepcopy(block)\n@@ -121,10 +120,10 @@ def assert_submitblock(block, result_str_1, result_str_2=None):\n         assert_template(node, bad_block, 'bad-cb-missing')\n \n         self.log.info(\"submitblock: Test invalid coinbase transaction\")\n-        assert_raises_rpc_error(-22, \"Block does not start with a coinbase\", node.submitblock, b2x(bad_block.serialize()))\n+        assert_raises_rpc_error(-22, \"Block does not start with a coinbase\", node.submitblock, bad_block.serialize().hex())\n \n         self.log.info(\"getblocktemplate: Test truncated final transaction\")\n-        assert_raises_rpc_error(-22, \"Block decode failed\", node.getblocktemplate, {'data': b2x(block.serialize()[:-1]), 'mode': 'proposal', 'rules': ['segwit']})\n+        assert_raises_rpc_error(-22, \"Block decode failed\", node.getblocktemplate, {'data': block.serialize()[:-1].hex(), 'mode': 'proposal', 'rules': ['segwit']})\n \n         self.log.info(\"getblocktemplate: Test duplicate transaction\")\n         bad_block = copy.deepcopy(block)\n@@ -153,7 +152,7 @@ def assert_submitblock(block, result_str_1, result_str_2=None):\n         bad_block_sn = bytearray(block.serialize())\n         assert_equal(bad_block_sn[BLOCK_HEADER_SIZE], 1)\n         bad_block_sn[BLOCK_HEADER_SIZE] += 1\n-        assert_raises_rpc_error(-22, \"Block decode failed\", node.getblocktemplate, {'data': b2x(bad_block_sn), 'mode': 'proposal', 'rules': ['segwit']})\n+        assert_raises_rpc_error(-22, \"Block decode failed\", node.getblocktemplate, {'data': bad_block_sn.hex(), 'mode': 'proposal', 'rules': ['segwit']})\n \n         self.log.info(\"getblocktemplate: Test bad bits\")\n         bad_block = copy.deepcopy(block)\n@@ -184,7 +183,7 @@ def assert_submitblock(block, result_str_1, result_str_2=None):\n         self.log.info('submitheader tests')\n         assert_raises_rpc_error(-22, 'Block header decode failed', lambda: node.submitheader(hexdata='xx' * BLOCK_HEADER_SIZE))\n         assert_raises_rpc_error(-22, 'Block header decode failed', lambda: node.submitheader(hexdata='ff' * (BLOCK_HEADER_SIZE-2)))\n-        assert_raises_rpc_error(-25, 'Must submit previous header', lambda: node.submitheader(hexdata=b2x(super(CBlock, bad_block).serialize())))\n+        assert_raises_rpc_error(-25, 'Must submit previous header', lambda: node.submitheader(hexdata=super(CBlock, bad_block).serialize().hex()))\n \n         block.nTime += 1\n         block.solve()\n@@ -193,43 +192,43 @@ def chain_tip(b_hash, *, status='headers-only', branchlen=1):\n             return {'hash': b_hash, 'height': 202, 'branchlen': branchlen, 'status': status}\n \n         assert chain_tip(block.hash) not in node.getchaintips()\n-        node.submitheader(hexdata=b2x(block.serialize()))\n+        node.submitheader(hexdata=block.serialize().hex())\n         assert chain_tip(block.hash) in node.getchaintips()\n-        node.submitheader(hexdata=b2x(CBlockHeader(block).serialize()))  # Noop\n+        node.submitheader(hexdata=CBlockHeader(block).serialize().hex())  # Noop\n         assert chain_tip(block.hash) in node.getchaintips()\n \n         bad_block_root = copy.deepcopy(block)\n         bad_block_root.hashMerkleRoot += 2\n         bad_block_root.solve()\n         assert chain_tip(bad_block_root.hash) not in node.getchaintips()\n-        node.submitheader(hexdata=b2x(CBlockHeader(bad_block_root).serialize()))\n+        node.submitheader(hexdata=CBlockHeader(bad_block_root).serialize().hex())\n         assert chain_tip(bad_block_root.hash) in node.getchaintips()\n         # Should still reject invalid blocks, even if we have the header:\n-        assert_equal(node.submitblock(hexdata=b2x(bad_block_root.serialize())), 'bad-txnmrklroot')\n-        assert_equal(node.submitblock(hexdata=b2x(bad_block_root.serialize())), 'bad-txnmrklroot')\n+        assert_equal(node.submitblock(hexdata=bad_block_root.serialize().hex()), 'bad-txnmrklroot')\n+        assert_equal(node.submitblock(hexdata=bad_block_root.serialize().hex()), 'bad-txnmrklroot')\n         assert chain_tip(bad_block_root.hash) in node.getchaintips()\n         # We know the header for this invalid block, so should just return early without error:\n-        node.submitheader(hexdata=b2x(CBlockHeader(bad_block_root).serialize()))\n+        node.submitheader(hexdata=CBlockHeader(bad_block_root).serialize().hex())\n         assert chain_tip(bad_block_root.hash) in node.getchaintips()\n \n         bad_block_lock = copy.deepcopy(block)\n         bad_block_lock.vtx[0].nLockTime = 2**32 - 1\n         bad_block_lock.vtx[0].rehash()\n         bad_block_lock.hashMerkleRoot = bad_block_lock.calc_merkle_root()\n         bad_block_lock.solve()\n-        assert_equal(node.submitblock(hexdata=b2x(bad_block_lock.serialize())), 'bad-txns-nonfinal')\n-        assert_equal(node.submitblock(hexdata=b2x(bad_block_lock.serialize())), 'duplicate-invalid')\n+        assert_equal(node.submitblock(hexdata=bad_block_lock.serialize().hex()), 'bad-txns-nonfinal')\n+        assert_equal(node.submitblock(hexdata=bad_block_lock.serialize().hex()), 'duplicate-invalid')\n         # Build a \"good\" block on top of the submitted bad block\n         bad_block2 = copy.deepcopy(block)\n         bad_block2.hashPrevBlock = bad_block_lock.sha256\n         bad_block2.solve()\n-        assert_raises_rpc_error(-25, 'bad-prevblk', lambda: node.submitheader(hexdata=b2x(CBlockHeader(bad_block2).serialize())))\n+        assert_raises_rpc_error(-25, 'bad-prevblk', lambda: node.submitheader(hexdata=CBlockHeader(bad_block2).serialize().hex()))\n \n         # Should reject invalid header right away\n         bad_block_time = copy.deepcopy(block)\n         bad_block_time.nTime = 1\n         bad_block_time.solve()\n-        assert_raises_rpc_error(-25, 'time-too-old', lambda: node.submitheader(hexdata=b2x(CBlockHeader(bad_block_time).serialize())))\n+        assert_raises_rpc_error(-25, 'time-too-old', lambda: node.submitheader(hexdata=CBlockHeader(bad_block_time).serialize().hex()))\n \n         # Should ask for the block from a p2p node, if they announce the header as well:\n         node.add_p2p_connection(P2PDataStore())\n@@ -240,11 +239,11 @@ def chain_tip(b_hash, *, status='headers-only', branchlen=1):\n \n         # Building a few blocks should give the same results\n         node.generatetoaddress(10, node.get_deterministic_priv_key().address)\n-        assert_raises_rpc_error(-25, 'time-too-old', lambda: node.submitheader(hexdata=b2x(CBlockHeader(bad_block_time).serialize())))\n-        assert_raises_rpc_error(-25, 'bad-prevblk', lambda: node.submitheader(hexdata=b2x(CBlockHeader(bad_block2).serialize())))\n-        node.submitheader(hexdata=b2x(CBlockHeader(block).serialize()))\n-        node.submitheader(hexdata=b2x(CBlockHeader(bad_block_root).serialize()))\n-        assert_equal(node.submitblock(hexdata=b2x(block.serialize())), 'duplicate')  # valid\n+        assert_raises_rpc_error(-25, 'time-too-old', lambda: node.submitheader(hexdata=CBlockHeader(bad_block_time).serialize().hex()))\n+        assert_raises_rpc_error(-25, 'bad-prevblk', lambda: node.submitheader(hexdata=CBlockHeader(bad_block2).serialize().hex()))\n+        node.submitheader(hexdata=CBlockHeader(block).serialize().hex())\n+        node.submitheader(hexdata=CBlockHeader(bad_block_root).serialize().hex())\n+        assert_equal(node.submitblock(hexdata=block.serialize().hex()), 'duplicate')  # valid\n \n \n if __name__ == '__main__':"
      },
      {
        "sha": "445ec124ce2b450cf0baf181a1a1fd59c315b32b",
        "filename": "test/functional/mining_getblocktemplate_longpoll.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/mining_getblocktemplate_longpoll.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/mining_getblocktemplate_longpoll.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mining_getblocktemplate_longpoll.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2014-2018 The Bitcoin Core developers\n+# Copyright (c) 2014-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test longpolling with getblocktemplate.\"\"\"\n@@ -38,27 +38,27 @@ def run_test(self):\n         longpollid = template['longpollid']\n         # longpollid should not change between successive invocations if nothing else happens\n         template2 = self.nodes[0].getblocktemplate({'rules': ['segwit']})\n-        assert(template2['longpollid'] == longpollid)\n+        assert template2['longpollid'] == longpollid\n \n         # Test 1: test that the longpolling wait if we do nothing\n         thr = LongpollThread(self.nodes[0])\n         thr.start()\n         # check that thread still lives\n         thr.join(5)  # wait 5 seconds or until thread exits\n-        assert(thr.is_alive())\n+        assert thr.is_alive()\n \n         # Test 2: test that longpoll will terminate if another node generates a block\n         self.nodes[1].generate(1)  # generate a block on another node\n         # check that thread will exit now that new transaction entered mempool\n         thr.join(5)  # wait 5 seconds or until thread exits\n-        assert(not thr.is_alive())\n+        assert not thr.is_alive()\n \n         # Test 3: test that longpoll will terminate if we generate a block ourselves\n         thr = LongpollThread(self.nodes[0])\n         thr.start()\n         self.nodes[0].generate(1)  # generate a block on another node\n         thr.join(5)  # wait 5 seconds or until thread exits\n-        assert(not thr.is_alive())\n+        assert not thr.is_alive()\n \n         # Test 4: test that introducing a new transaction into the mempool will terminate the longpoll\n         thr = LongpollThread(self.nodes[0])\n@@ -69,7 +69,7 @@ def run_test(self):\n         (txid, txhex, fee) = random_transaction(self.nodes, Decimal(\"1.1\"), min_relay_fee, Decimal(\"0.001\"), 20)\n         # after one minute, every 10 seconds the mempool is probed, so in 80 seconds it should have returned\n         thr.join(60 + 20)\n-        assert(not thr.is_alive())\n+        assert not thr.is_alive()\n \n if __name__ == '__main__':\n     GetBlockTemplateLPTest().main()"
      },
      {
        "sha": "687a5b527bfc3ac55506bc6950219a7f64241098",
        "filename": "test/functional/mining_prioritisetransaction.py",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/mining_prioritisetransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/mining_prioritisetransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mining_prioritisetransaction.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2015-2018 The Bitcoin Core developers\n+# Copyright (c) 2015-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the prioritisetransaction mining RPC.\"\"\"\n@@ -63,9 +63,9 @@ def run_test(self):\n         sizes = [0, 0, 0]\n         for i in range(3):\n             for j in txids[i]:\n-                assert(j in mempool)\n+                assert j in mempool\n                 sizes[i] += mempool[j]['size']\n-            assert(sizes[i] > MAX_BLOCK_BASE_SIZE) # Fail => raise utxo_count\n+            assert sizes[i] > MAX_BLOCK_BASE_SIZE  # Fail => raise utxo_count\n \n         # add a fee delta to something in the cheapest bucket and make sure it gets mined\n         # also check that a different entry in the cheapest bucket is NOT mined\n@@ -75,16 +75,16 @@ def run_test(self):\n \n         mempool = self.nodes[0].getrawmempool()\n         self.log.info(\"Assert that prioritised transaction was mined\")\n-        assert(txids[0][0] not in mempool)\n-        assert(txids[0][1] in mempool)\n+        assert txids[0][0] not in mempool\n+        assert txids[0][1] in mempool\n \n         high_fee_tx = None\n         for x in txids[2]:\n             if x not in mempool:\n                 high_fee_tx = x\n \n         # Something high-fee should have been mined!\n-        assert(high_fee_tx is not None)\n+        assert high_fee_tx is not None\n \n         # Add a prioritisation before a tx is in the mempool (de-prioritising a\n         # high-fee transaction so that it's now low fee).\n@@ -95,7 +95,7 @@ def run_test(self):\n \n         # Check to make sure our high fee rate tx is back in the mempool\n         mempool = self.nodes[0].getrawmempool()\n-        assert(high_fee_tx in mempool)\n+        assert high_fee_tx in mempool\n \n         # Now verify the modified-high feerate transaction isn't mined before\n         # the other high fee transactions. Keep mining until our mempool has\n@@ -107,14 +107,14 @@ def run_test(self):\n         # transactions should have been.\n         mempool = self.nodes[0].getrawmempool()\n         self.log.info(\"Assert that de-prioritised transaction is still in mempool\")\n-        assert(high_fee_tx in mempool)\n+        assert high_fee_tx in mempool\n         for x in txids[2]:\n             if (x != high_fee_tx):\n-                assert(x not in mempool)\n+                assert x not in mempool\n \n         # Create a free transaction.  Should be rejected.\n         utxo_list = self.nodes[0].listunspent()\n-        assert(len(utxo_list) > 0)\n+        assert len(utxo_list) > 0\n         utxo = utxo_list[0]\n \n         inputs = []\n@@ -127,7 +127,7 @@ def run_test(self):\n \n         # This will raise an exception due to min relay fee not being met\n         assert_raises_rpc_error(-26, \"min relay fee not met\", self.nodes[0].sendrawtransaction, tx_hex)\n-        assert(tx_id not in self.nodes[0].getrawmempool())\n+        assert tx_id not in self.nodes[0].getrawmempool()\n \n         # This is a less than 1000-byte transaction, so just set the fee\n         # to be the minimum for a 1000-byte transaction and check that it is\n@@ -136,7 +136,7 @@ def run_test(self):\n \n         self.log.info(\"Assert that prioritised free transaction is accepted to mempool\")\n         assert_equal(self.nodes[0].sendrawtransaction(tx_hex), tx_id)\n-        assert(tx_id in self.nodes[0].getrawmempool())\n+        assert tx_id in self.nodes[0].getrawmempool()\n \n         # Test that calling prioritisetransaction is sufficient to trigger\n         # getblocktemplate to (eventually) return a new block.\n@@ -147,7 +147,7 @@ def run_test(self):\n         self.nodes[0].setmocktime(mock_time+10)\n         new_template = self.nodes[0].getblocktemplate({'rules': ['segwit']})\n \n-        assert(template != new_template)\n+        assert template != new_template\n \n if __name__ == '__main__':\n     PrioritiseTransactionTest().main()"
      },
      {
        "sha": "82a14af9da8c78445331f76e58d1671806b0b836",
        "filename": "test/functional/p2p_compactblocks.py",
        "status": "modified",
        "additions": 23,
        "deletions": 23,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/p2p_compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/p2p_compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_compactblocks.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2016-2018 The Bitcoin Core developers\n+# Copyright (c) 2016-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test compact blocks (BIP 152).\n@@ -120,7 +120,7 @@ def make_utxos(self):\n         # Doesn't matter which node we use, just use node0.\n         block = self.build_block_on_tip(self.nodes[0])\n         self.test_node.send_and_ping(msg_block(block))\n-        assert(int(self.nodes[0].getbestblockhash(), 16) == block.sha256)\n+        assert int(self.nodes[0].getbestblockhash(), 16) == block.sha256\n         self.nodes[0].generate(100)\n \n         total_value = block.vtx[0].vout[0].nValue\n@@ -167,7 +167,7 @@ def check_announcement_of_new_block(node, peer, predicate):\n             peer.clear_block_announcement()\n             block_hash = int(node.generate(1)[0], 16)\n             peer.wait_for_block_announcement(block_hash, timeout=30)\n-            assert(peer.block_announced)\n+            assert peer.block_announced\n \n             with mininode_lock:\n                 assert predicate(peer), (\n@@ -303,7 +303,7 @@ def test_compactblock_construction(self, node, test_node, version, use_witness_a\n         # Now fetch and check the compact block\n         header_and_shortids = None\n         with mininode_lock:\n-            assert(\"cmpctblock\" in test_node.last_message)\n+            assert \"cmpctblock\" in test_node.last_message\n             # Convert the on-the-wire representation to absolute indexes\n             header_and_shortids = HeaderAndShortIDs(test_node.last_message[\"cmpctblock\"].header_and_shortids)\n         self.check_compactblock_construction_from_block(version, header_and_shortids, block_hash, block)\n@@ -319,7 +319,7 @@ def test_compactblock_construction(self, node, test_node, version, use_witness_a\n         # Now fetch and check the compact block\n         header_and_shortids = None\n         with mininode_lock:\n-            assert(\"cmpctblock\" in test_node.last_message)\n+            assert \"cmpctblock\" in test_node.last_message\n             # Convert the on-the-wire representation to absolute indexes\n             header_and_shortids = HeaderAndShortIDs(test_node.last_message[\"cmpctblock\"].header_and_shortids)\n         self.check_compactblock_construction_from_block(version, header_and_shortids, block_hash, block)\n@@ -330,7 +330,7 @@ def check_compactblock_construction_from_block(self, version, header_and_shortid\n         assert_equal(header_and_shortids.header.sha256, block_hash)\n \n         # Make sure the prefilled_txn appears to have included the coinbase\n-        assert(len(header_and_shortids.prefilled_txn) >= 1)\n+        assert len(header_and_shortids.prefilled_txn) >= 1\n         assert_equal(header_and_shortids.prefilled_txn[0].index, 0)\n \n         # Check that all prefilled_txn entries match what's in the block.\n@@ -345,7 +345,7 @@ def check_compactblock_construction_from_block(self, version, header_and_shortid\n                 assert_equal(wtxid, block.vtx[entry.index].calc_sha256(True))\n             else:\n                 # Shouldn't have received a witness\n-                assert(entry.tx.wit.is_null())\n+                assert entry.tx.wit.is_null()\n \n         # Check that the cmpctblock message announced all the transactions.\n         assert_equal(len(header_and_shortids.prefilled_txn) + len(header_and_shortids.shortids), len(block.vtx))\n@@ -407,7 +407,7 @@ def test_compactblock_requests(self, node, test_node, version, segwit):\n             assert_equal(int(node.getbestblockhash(), 16), block.hashPrevBlock)\n             # Expect a getblocktxn message.\n             with mininode_lock:\n-                assert(\"getblocktxn\" in test_node.last_message)\n+                assert \"getblocktxn\" in test_node.last_message\n                 absolute_indexes = test_node.last_message[\"getblocktxn\"].block_txn_request.to_absolute()\n             assert_equal(absolute_indexes, [0])  # should be a coinbase request\n \n@@ -447,7 +447,7 @@ def test_getblocktxn_response(compact_block, peer, expected_result):\n             msg = msg_cmpctblock(compact_block.to_p2p())\n             peer.send_and_ping(msg)\n             with mininode_lock:\n-                assert(\"getblocktxn\" in peer.last_message)\n+                assert \"getblocktxn\" in peer.last_message\n                 absolute_indexes = peer.last_message[\"getblocktxn\"].block_txn_request.to_absolute()\n             assert_equal(absolute_indexes, expected_result)\n \n@@ -487,7 +487,7 @@ def test_tip_after_message(node, peer, msg, tip):\n         block = self.build_block_with_transactions(node, utxo, 5)\n         self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n         test_node.send_and_ping(msg_tx(block.vtx[1]))\n-        assert(block.vtx[1].hash in node.getrawmempool())\n+        assert block.vtx[1].hash in node.getrawmempool()\n \n         # Prefill 4 out of the 6 transactions, and verify that only the one\n         # that was not in the mempool is requested.\n@@ -508,7 +508,7 @@ def test_tip_after_message(node, peer, msg, tip):\n         # Make sure all transactions were accepted.\n         mempool = node.getrawmempool()\n         for tx in block.vtx[1:]:\n-            assert(tx.hash in mempool)\n+            assert tx.hash in mempool\n \n         # Clear out last request.\n         with mininode_lock:\n@@ -519,7 +519,7 @@ def test_tip_after_message(node, peer, msg, tip):\n         test_tip_after_message(node, test_node, msg_cmpctblock(comp_block.to_p2p()), block.sha256)\n         with mininode_lock:\n             # Shouldn't have gotten a request for any transaction\n-            assert(\"getblocktxn\" not in test_node.last_message)\n+            assert \"getblocktxn\" not in test_node.last_message\n \n     # Incorrectly responding to a getblocktxn shouldn't cause the block to be\n     # permanently failed.\n@@ -537,15 +537,15 @@ def test_incorrect_blocktxn_response(self, node, test_node, version):\n         # Make sure all transactions were accepted.\n         mempool = node.getrawmempool()\n         for tx in block.vtx[1:6]:\n-            assert(tx.hash in mempool)\n+            assert tx.hash in mempool\n \n         # Send compact block\n         comp_block = HeaderAndShortIDs()\n         comp_block.initialize_from_block(block, prefill_list=[0], use_witness=(version == 2))\n         test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n         absolute_indexes = []\n         with mininode_lock:\n-            assert(\"getblocktxn\" in test_node.last_message)\n+            assert \"getblocktxn\" in test_node.last_message\n             absolute_indexes = test_node.last_message[\"getblocktxn\"].block_txn_request.to_absolute()\n         assert_equal(absolute_indexes, [6, 7, 8, 9, 10])\n \n@@ -569,7 +569,7 @@ def test_incorrect_blocktxn_response(self, node, test_node, version):\n         # We should receive a getdata request\n         wait_until(lambda: \"getdata\" in test_node.last_message, timeout=10, lock=mininode_lock)\n         assert_equal(len(test_node.last_message[\"getdata\"].inv), 1)\n-        assert(test_node.last_message[\"getdata\"].inv[0].type == 2 or test_node.last_message[\"getdata\"].inv[0].type == 2 | MSG_WITNESS_FLAG)\n+        assert test_node.last_message[\"getdata\"].inv[0].type == 2 or test_node.last_message[\"getdata\"].inv[0].type == 2 | MSG_WITNESS_FLAG\n         assert_equal(test_node.last_message[\"getdata\"].inv[0].hash, block.sha256)\n \n         # Deliver the block\n@@ -606,7 +606,7 @@ def test_getblocktxn_handler(self, node, test_node, version):\n                     assert_equal(tx.sha256, block.vtx[index].sha256)\n                     if version == 1:\n                         # Witnesses should have been stripped\n-                        assert(tx.wit.is_null())\n+                        assert tx.wit.is_null()\n                     else:\n                         # Check that the witness matches\n                         assert_equal(tx.calc_sha256(True), block.vtx[index].calc_sha256(True))\n@@ -669,7 +669,7 @@ def test_compactblocks_not_at_tip(self, node, test_node):\n                 assert_equal(x[\"status\"], \"headers-only\")\n                 found = True\n                 break\n-        assert(found)\n+        assert found\n \n         # Requesting this block via getblocktxn should silently fail\n         # (to avoid fingerprinting attacks).\n@@ -707,7 +707,7 @@ def test_end_to_end_block_relay(self, node, listeners):\n     # Test that we don't get disconnected if we relay a compact block with valid header,\n     # but invalid transactions.\n     def test_invalid_tx_in_compactblock(self, node, test_node, use_segwit):\n-        assert(len(self.utxos))\n+        assert len(self.utxos)\n         utxo = self.utxos[0]\n \n         block = self.build_block_with_transactions(node, utxo, 5)\n@@ -728,7 +728,7 @@ def test_invalid_tx_in_compactblock(self, node, test_node, use_segwit):\n         test_node.send_and_ping(msg)\n \n         # Check that the tip didn't advance\n-        assert(int(node.getbestblockhash(), 16) is not block.sha256)\n+        assert int(node.getbestblockhash(), 16) is not block.sha256\n         test_node.sync_with_ping()\n \n     # Helper for enabling cb announcements\n@@ -743,7 +743,7 @@ def request_cb_announcements(self, peer, node, version):\n         peer.send_and_ping(msg)\n \n     def test_compactblock_reconstruction_multiple_peers(self, node, stalling_peer, delivery_peer):\n-        assert(len(self.utxos))\n+        assert len(self.utxos)\n \n         def announce_cmpct_block(node, peer):\n             utxo = self.utxos.pop(0)\n@@ -764,7 +764,7 @@ def announce_cmpct_block(node, peer):\n         delivery_peer.sync_with_ping()\n         mempool = node.getrawmempool()\n         for tx in block.vtx[1:]:\n-            assert(tx.hash in mempool)\n+            assert tx.hash in mempool\n \n         delivery_peer.send_and_ping(msg_cmpctblock(cmpct_block.to_p2p()))\n         assert_equal(int(node.getbestblockhash(), 16), block.sha256)\n@@ -783,7 +783,7 @@ def announce_cmpct_block(node, peer):\n \n         cmpct_block.use_witness = True\n         delivery_peer.send_and_ping(msg_cmpctblock(cmpct_block.to_p2p()))\n-        assert(int(node.getbestblockhash(), 16) != block.sha256)\n+        assert int(node.getbestblockhash(), 16) != block.sha256\n \n         msg = msg_blocktxn()\n         msg.block_transactions.blockhash = block.sha256\n@@ -882,7 +882,7 @@ def run_test(self):\n         # Need to manually sync node0 and node1, because post-segwit activation,\n         # node1 will not download blocks from node0.\n         self.log.info(\"Syncing nodes...\")\n-        assert(self.nodes[0].getbestblockhash() != self.nodes[1].getbestblockhash())\n+        assert self.nodes[0].getbestblockhash() != self.nodes[1].getbestblockhash()\n         while (self.nodes[0].getblockcount() > self.nodes[1].getblockcount()):\n             block_hash = self.nodes[0].getblockhash(self.nodes[1].getblockcount() + 1)\n             self.nodes[1].submitblock(self.nodes[0].getblock(block_hash, False))"
      },
      {
        "sha": "b9863cf215561a56616fa8a874228b9ad8ceaf08",
        "filename": "test/functional/p2p_feefilter.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/p2p_feefilter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/p2p_feefilter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_feefilter.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2016-2018 The Bitcoin Core developers\n+# Copyright (c) 2016-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test processing of feefilter messages.\"\"\"\n@@ -57,15 +57,15 @@ def run_test(self):\n         # Test that invs are received for all txs at feerate of 20 sat/byte\n         node1.settxfee(Decimal(\"0.00020000\"))\n         txids = [node1.sendtoaddress(node1.getnewaddress(), 1) for x in range(3)]\n-        assert(allInvsMatch(txids, self.nodes[0].p2p))\n+        assert allInvsMatch(txids, self.nodes[0].p2p)\n         self.nodes[0].p2p.clear_invs()\n \n         # Set a filter of 15 sat/byte\n         self.nodes[0].p2p.send_and_ping(msg_feefilter(15000))\n \n         # Test that txs are still being received (paying 20 sat/byte)\n         txids = [node1.sendtoaddress(node1.getnewaddress(), 1) for x in range(3)]\n-        assert(allInvsMatch(txids, self.nodes[0].p2p))\n+        assert allInvsMatch(txids, self.nodes[0].p2p)\n         self.nodes[0].p2p.clear_invs()\n \n         # Change tx fee rate to 10 sat/byte and test they are no longer received\n@@ -82,13 +82,13 @@ def run_test(self):\n         # as well.\n         node0.settxfee(Decimal(\"0.00020000\"))\n         txids = [node0.sendtoaddress(node0.getnewaddress(), 1)]\n-        assert(allInvsMatch(txids, self.nodes[0].p2p))\n+        assert allInvsMatch(txids, self.nodes[0].p2p)\n         self.nodes[0].p2p.clear_invs()\n \n         # Remove fee filter and check that txs are received again\n         self.nodes[0].p2p.send_and_ping(msg_feefilter(0))\n         txids = [node1.sendtoaddress(node1.getnewaddress(), 1) for x in range(3)]\n-        assert(allInvsMatch(txids, self.nodes[0].p2p))\n+        assert allInvsMatch(txids, self.nodes[0].p2p)\n         self.nodes[0].p2p.clear_invs()\n \n if __name__ == '__main__':"
      },
      {
        "sha": "06049db54cc69c74cc5f1c5cfec2bde0fe8e4445",
        "filename": "test/functional/p2p_leak.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/p2p_leak.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/p2p_leak.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_leak.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2017-2018 The Bitcoin Core developers\n+# Copyright (c) 2017-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test message sending before handshake completion.\n@@ -117,9 +117,9 @@ def run_test(self):\n         wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 0)\n \n         # Make sure no unexpected messages came in\n-        assert(no_version_bannode.unexpected_msg == False)\n-        assert(no_version_idlenode.unexpected_msg == False)\n-        assert(no_verack_idlenode.unexpected_msg == False)\n+        assert no_version_bannode.unexpected_msg == False\n+        assert no_version_idlenode.unexpected_msg == False\n+        assert no_verack_idlenode.unexpected_msg == False\n \n \n if __name__ == '__main__':"
      },
      {
        "sha": "73bfdc868cd49de0bede99e88b2d5e2dd3ccfa0b",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 45,
        "deletions": 47,
        "changes": 92,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,9 +1,8 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2016-2018 The Bitcoin Core developers\n+# Copyright (c) 2016-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test segwit transactions and blocks on P2P network.\"\"\"\n-from binascii import hexlify\n import math\n import random\n import struct\n@@ -74,7 +73,6 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n-    bytes_to_hex_str,\n     connect_nodes,\n     disconnect_nodes,\n     get_bip9_status,\n@@ -317,7 +315,7 @@ def test_non_witness_transaction(self):\n \n         self.test_node.send_message(msg_witness_tx(tx))\n         self.test_node.sync_with_ping()  # make sure the tx was processed\n-        assert(tx.hash in self.nodes[0].getrawmempool())\n+        assert tx.hash in self.nodes[0].getrawmempool()\n         # Save this transaction for later\n         self.utxo.append(UTXO(tx.sha256, 0, 49 * 100000000))\n         self.nodes[0].generate(1)\n@@ -335,7 +333,7 @@ def test_unnecessary_witness_before_segwit_activation(self):\n         # Verify the hash with witness differs from the txid\n         # (otherwise our testing framework must be broken!)\n         tx.rehash()\n-        assert(tx.sha256 != tx.calc_sha256(with_witness=True))\n+        assert tx.sha256 != tx.calc_sha256(with_witness=True)\n \n         # Construct a segwit-signaling block that includes the transaction.\n         block = self.build_next_block(version=(VB_TOP_BITS | (1 << VB_WITNESS_BIT)))\n@@ -371,20 +369,20 @@ def test_block_relay(self):\n         block1.solve()\n \n         self.test_node.announce_block_and_wait_for_getdata(block1, use_header=False)\n-        assert(self.test_node.last_message[\"getdata\"].inv[0].type == blocktype)\n+        assert self.test_node.last_message[\"getdata\"].inv[0].type == blocktype\n         test_witness_block(self.nodes[0], self.test_node, block1, True)\n \n         block2 = self.build_next_block(version=4)\n         block2.solve()\n \n         self.test_node.announce_block_and_wait_for_getdata(block2, use_header=True)\n-        assert(self.test_node.last_message[\"getdata\"].inv[0].type == blocktype)\n+        assert self.test_node.last_message[\"getdata\"].inv[0].type == blocktype\n         test_witness_block(self.nodes[0], self.test_node, block2, True)\n \n         block3 = self.build_next_block(version=(VB_TOP_BITS | (1 << 15)))\n         block3.solve()\n         self.test_node.announce_block_and_wait_for_getdata(block3, use_header=True)\n-        assert(self.test_node.last_message[\"getdata\"].inv[0].type == blocktype)\n+        assert self.test_node.last_message[\"getdata\"].inv[0].type == blocktype\n         test_witness_block(self.nodes[0], self.test_node, block3, True)\n \n         # Check that we can getdata for witness blocks or regular blocks,\n@@ -413,8 +411,8 @@ def test_block_relay(self):\n             block = self.build_next_block()\n             self.update_witness_block_with_transactions(block, [])\n             # This gives us a witness commitment.\n-            assert(len(block.vtx[0].wit.vtxinwit) == 1)\n-            assert(len(block.vtx[0].wit.vtxinwit[0].scriptWitness.stack) == 1)\n+            assert len(block.vtx[0].wit.vtxinwit) == 1\n+            assert len(block.vtx[0].wit.vtxinwit[0].scriptWitness.stack) == 1\n             test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n             # Now try to retrieve it...\n             rpc_block = self.nodes[0].getblock(block.hash, False)\n@@ -448,7 +446,7 @@ def test_block_relay(self):\n             msg.headers = [CBlockHeader(block4)]\n             self.old_node.send_message(msg)\n             self.old_node.announce_tx_and_wait_for_getdata(block4.vtx[0])\n-            assert(block4.sha256 not in self.old_node.getdataset)\n+            assert block4.sha256 not in self.old_node.getdataset\n \n     @subtest\n     def test_v0_outputs_arent_spendable(self):\n@@ -537,7 +535,7 @@ def advance_to_segwit_started(self):\n         \"\"\"Mine enough blocks for segwit's vb state to be 'started'.\"\"\"\n         height = self.nodes[0].getblockcount()\n         # Will need to rewrite the tests here if we are past the first period\n-        assert(height < VB_PERIOD - 1)\n+        assert height < VB_PERIOD - 1\n         # Advance to end of period, status should now be 'started'\n         self.nodes[0].generate(VB_PERIOD - height - 1)\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'started')\n@@ -554,19 +552,19 @@ def test_getblocktemplate_before_lockin(self):\n                 # If this is a non-segwit node, we should not get a witness\n                 # commitment, nor a version bit signalling segwit.\n                 assert_equal(block_version & (1 << VB_WITNESS_BIT), 0)\n-                assert('default_witness_commitment' not in gbt_results)\n+                assert 'default_witness_commitment' not in gbt_results\n             else:\n                 # For segwit-aware nodes, check the version bit and the witness\n                 # commitment are correct.\n-                assert(block_version & (1 << VB_WITNESS_BIT) != 0)\n-                assert('default_witness_commitment' in gbt_results)\n+                assert block_version & (1 << VB_WITNESS_BIT) != 0\n+                assert 'default_witness_commitment' in gbt_results\n                 witness_commitment = gbt_results['default_witness_commitment']\n \n                 # Check that default_witness_commitment is present.\n                 witness_root = CBlock.get_merkle_root([ser_uint256(0),\n                                                        ser_uint256(txid)])\n                 script = get_witness_script(witness_root, 0)\n-                assert_equal(witness_commitment, bytes_to_hex_str(script))\n+                assert_equal(witness_commitment, script.hex())\n \n     @subtest\n     def advance_to_segwit_lockin(self):\n@@ -575,7 +573,7 @@ def advance_to_segwit_lockin(self):\n         # Advance to end of period, and verify lock-in happens at the end\n         self.nodes[0].generate(VB_PERIOD - 1)\n         height = self.nodes[0].getblockcount()\n-        assert((height % VB_PERIOD) == VB_PERIOD - 2)\n+        assert (height % VB_PERIOD) == VB_PERIOD - 2\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'started')\n         self.nodes[0].generate(1)\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'locked_in')\n@@ -600,7 +598,7 @@ def test_witness_tx_relay_before_segwit_activation(self):\n         # Verify that if a peer doesn't set nServices to include NODE_WITNESS,\n         # the getdata is just for the non-witness portion.\n         self.old_node.announce_tx_and_wait_for_getdata(tx)\n-        assert(self.old_node.last_message[\"getdata\"].inv[0].type == 1)\n+        assert self.old_node.last_message[\"getdata\"].inv[0].type == 1\n \n         # Since we haven't delivered the tx yet, inv'ing the same tx from\n         # a witness transaction ought not result in a getdata.\n@@ -686,13 +684,13 @@ def test_standardness_v0(self):\n         if self.segwit_status != 'active':\n             # Just check mempool acceptance, but don't add the transaction to the mempool, since witness is disallowed\n             # in blocks and the tx is impossible to mine right now.\n-            assert_equal(self.nodes[0].testmempoolaccept([bytes_to_hex_str(tx3.serialize_with_witness())]), [{'txid': tx3.hash, 'allowed': True}])\n+            assert_equal(self.nodes[0].testmempoolaccept([tx3.serialize_with_witness().hex()]), [{'txid': tx3.hash, 'allowed': True}])\n             # Create the same output as tx3, but by replacing tx\n             tx3_out = tx3.vout[0]\n             tx3 = tx\n             tx3.vout = [tx3_out]\n             tx3.rehash()\n-            assert_equal(self.nodes[0].testmempoolaccept([bytes_to_hex_str(tx3.serialize_with_witness())]), [{'txid': tx3.hash, 'allowed': True}])\n+            assert_equal(self.nodes[0].testmempoolaccept([tx3.serialize_with_witness().hex()]), [{'txid': tx3.hash, 'allowed': True}])\n         test_transaction_acceptance(self.nodes[0], self.test_node, tx3, with_witness=True, accepted=True)\n \n         self.nodes[0].generate(1)\n@@ -792,7 +790,7 @@ def test_witness_commitments(self):\n         block.solve()\n \n         # Test the test -- witness serialization should be different\n-        assert(msg_witness_block(block).serialize() != msg_block(block).serialize())\n+        assert msg_witness_block(block).serialize() != msg_block(block).serialize()\n \n         # This empty block should be valid.\n         test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n@@ -803,7 +801,7 @@ def test_witness_commitments(self):\n         block_2.solve()\n \n         # The commitment should have changed!\n-        assert(block_2.vtx[0].vout[-1] != block.vtx[0].vout[-1])\n+        assert block_2.vtx[0].vout[-1] != block.vtx[0].vout[-1]\n \n         # This should also be valid.\n         test_witness_block(self.nodes[0], self.test_node, block_2, accepted=True)\n@@ -850,7 +848,7 @@ def test_witness_commitments(self):\n         block_3.vtx[0].rehash()\n         block_3.hashMerkleRoot = block_3.calc_merkle_root()\n         block_3.rehash()\n-        assert(len(block_3.vtx[0].vout) == 4)  # 3 OP_returns\n+        assert len(block_3.vtx[0].vout) == 4  # 3 OP_returns\n         block_3.solve()\n         test_witness_block(self.nodes[0], self.test_node, block_3, accepted=True)\n \n@@ -881,19 +879,19 @@ def test_block_malleability(self):\n         block.solve()\n \n         block.vtx[0].wit.vtxinwit[0].scriptWitness.stack.append(b'a' * 5000000)\n-        assert(get_virtual_size(block) > MAX_BLOCK_BASE_SIZE)\n+        assert get_virtual_size(block) > MAX_BLOCK_BASE_SIZE\n \n         # We can't send over the p2p network, because this is too big to relay\n         # TODO: repeat this test with a block that can be relayed\n-        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+        self.nodes[0].submitblock(block.serialize(True).hex())\n \n-        assert(self.nodes[0].getbestblockhash() != block.hash)\n+        assert self.nodes[0].getbestblockhash() != block.hash\n \n         block.vtx[0].wit.vtxinwit[0].scriptWitness.stack.pop()\n-        assert(get_virtual_size(block) < MAX_BLOCK_BASE_SIZE)\n-        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+        assert get_virtual_size(block) < MAX_BLOCK_BASE_SIZE\n+        self.nodes[0].submitblock(block.serialize(True).hex())\n \n-        assert(self.nodes[0].getbestblockhash() == block.hash)\n+        assert self.nodes[0].getbestblockhash() == block.hash\n \n         # Now make sure that malleating the witness reserved value doesn't\n         # result in a block permanently marked bad.\n@@ -918,7 +916,7 @@ def test_witness_block_size(self):\n         # Test that witness-bearing blocks are limited at ceil(base + wit/4) <= 1MB.\n         block = self.build_next_block()\n \n-        assert(len(self.utxo) > 0)\n+        assert len(self.utxo) > 0\n \n         # Create a P2WSH transaction.\n         # The witness program will be a bunch of OP_2DROP's, followed by OP_TRUE.\n@@ -940,7 +938,7 @@ def test_witness_block_size(self):\n         for i in range(NUM_OUTPUTS):\n             parent_tx.vout.append(CTxOut(child_value, script_pubkey))\n         parent_tx.vout[0].nValue -= 50000\n-        assert(parent_tx.vout[0].nValue > 0)\n+        assert parent_tx.vout[0].nValue > 0\n         parent_tx.rehash()\n \n         child_tx = CTransaction()\n@@ -970,7 +968,7 @@ def test_witness_block_size(self):\n         assert_equal(vsize, MAX_BLOCK_BASE_SIZE + 1)\n         # Make sure that our test case would exceed the old max-network-message\n         # limit\n-        assert(len(block.serialize(True)) > 2 * 1024 * 1024)\n+        assert len(block.serialize(True)) > 2 * 1024 * 1024\n \n         test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n@@ -980,7 +978,7 @@ def test_witness_block_size(self):\n         block.vtx[0].vout.pop()\n         add_witness_commitment(block)\n         block.solve()\n-        assert(get_virtual_size(block) == MAX_BLOCK_BASE_SIZE)\n+        assert get_virtual_size(block) == MAX_BLOCK_BASE_SIZE\n \n         test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n@@ -998,14 +996,14 @@ def test_submit_block(self):\n         add_witness_commitment(block, nonce=1)\n         block.vtx[0].wit = CTxWitness()  # drop the nonce\n         block.solve()\n-        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n-        assert(self.nodes[0].getbestblockhash() != block.hash)\n+        self.nodes[0].submitblock(block.serialize(True).hex())\n+        assert self.nodes[0].getbestblockhash() != block.hash\n \n         # Now redo commitment with the standard nonce, but let bitcoind fill it in.\n         add_witness_commitment(block, nonce=0)\n         block.vtx[0].wit = CTxWitness()\n         block.solve()\n-        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+        self.nodes[0].submitblock(block.serialize(True).hex())\n         assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n \n         # This time, add a tx with non-empty witness, but don't supply\n@@ -1020,9 +1018,9 @@ def test_submit_block(self):\n         block_2.vtx[0].vout.pop()\n         block_2.vtx[0].wit = CTxWitness()\n \n-        self.nodes[0].submitblock(bytes_to_hex_str(block_2.serialize(True)))\n+        self.nodes[0].submitblock(block_2.serialize(True).hex())\n         # Tip should not advance!\n-        assert(self.nodes[0].getbestblockhash() != block_2.hash)\n+        assert self.nodes[0].getbestblockhash() != block_2.hash\n \n     @subtest\n     def test_extra_witness_data(self):\n@@ -1142,7 +1140,7 @@ def test_max_witness_program_length(self):\n \n         # This program is 19 max pushes (9937 bytes), then 64 more opcode-bytes.\n         long_witness_program = CScript([b'a' * 520] * 19 + [OP_DROP] * 63 + [OP_TRUE])\n-        assert(len(long_witness_program) == MAX_PROGRAM_LENGTH + 1)\n+        assert len(long_witness_program) == MAX_PROGRAM_LENGTH + 1\n         long_witness_hash = sha256(long_witness_program)\n         long_script_pubkey = CScript([OP_0, long_witness_hash])\n \n@@ -1166,7 +1164,7 @@ def test_max_witness_program_length(self):\n \n         # Try again with one less byte in the witness program\n         witness_program = CScript([b'a' * 520] * 19 + [OP_DROP] * 62 + [OP_TRUE])\n-        assert(len(witness_program) == MAX_PROGRAM_LENGTH)\n+        assert len(witness_program) == MAX_PROGRAM_LENGTH\n         witness_hash = sha256(witness_program)\n         script_pubkey = CScript([OP_0, witness_hash])\n \n@@ -1197,7 +1195,7 @@ def test_witness_input_length(self):\n         for i in range(10):\n             tx.vout.append(CTxOut(int(value / 10), script_pubkey))\n         tx.vout[0].nValue -= 1000\n-        assert(tx.vout[0].nValue >= 0)\n+        assert tx.vout[0].nValue >= 0\n \n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx])\n@@ -1347,8 +1345,8 @@ def test_tx_relay_after_segwit_activation(self):\n         assert_equal(raw_tx[\"vsize\"], vsize)\n         assert_equal(raw_tx[\"weight\"], weight)\n         assert_equal(len(raw_tx[\"vin\"][0][\"txinwitness\"]), 1)\n-        assert_equal(raw_tx[\"vin\"][0][\"txinwitness\"][0], hexlify(witness_program).decode('ascii'))\n-        assert(vsize != raw_tx[\"size\"])\n+        assert_equal(raw_tx[\"vin\"][0][\"txinwitness\"][0], witness_program.hex())\n+        assert vsize != raw_tx[\"size\"]\n \n         # Cleanup: mine the transactions and update utxo for next test\n         self.nodes[0].generate(1)\n@@ -1398,7 +1396,7 @@ def test_segwit_versions(self):\n \n         self.nodes[0].generate(1)  # Mine all the transactions\n         sync_blocks(self.nodes)\n-        assert(len(self.nodes[0].getrawmempool()) == 0)\n+        assert len(self.nodes[0].getrawmempool()) == 0\n \n         # Finally, verify that version 0 -> version 1 transactions\n         # are non-standard\n@@ -1667,7 +1665,7 @@ def test_signature_version_1(self):\n             # Create a slight bias for producing more utxos\n             num_outputs = random.randint(1, 11)\n             random.shuffle(temp_utxos)\n-            assert(len(temp_utxos) > num_inputs)\n+            assert len(temp_utxos) > num_inputs\n             tx = CTransaction()\n             total_value = 0\n             for i in range(num_inputs):\n@@ -1928,7 +1926,7 @@ def test_upgrade_after_activation(self):\n         sync_blocks(self.nodes)\n \n         # Make sure that this peer thinks segwit has activated.\n-        assert(get_bip9_status(self.nodes[2], 'segwit')['status'] == \"active\")\n+        assert get_bip9_status(self.nodes[2], 'segwit')['status'] == \"active\"\n \n         # Make sure this peer's blocks match those of node0.\n         height = self.nodes[2].getblockcount()\n@@ -1955,7 +1953,7 @@ def test_witness_sigops(self):\n         extra_sigops_available = MAX_SIGOP_COST % sigops_per_script\n \n         # We chose the number of checkmultisigs/checksigs to make this work:\n-        assert(extra_sigops_available < 100)  # steer clear of MAX_OPS_PER_SCRIPT\n+        assert extra_sigops_available < 100  # steer clear of MAX_OPS_PER_SCRIPT\n \n         # This script, when spent with the first\n         # N(=MAX_SIGOP_COST//sigops_per_script) outputs of our transaction,"
      },
      {
        "sha": "027852809b43982866ae001a9b7436188f2585a1",
        "filename": "test/functional/p2p_unrequested_blocks.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/p2p_unrequested_blocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/p2p_unrequested_blocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_unrequested_blocks.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2015-2018 The Bitcoin Core developers\n+# Copyright (c) 2015-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test processing of unrequested blocks.\n@@ -114,7 +114,7 @@ def run_test(self):\n             if x['hash'] == block_h1f.hash:\n                 assert_equal(x['status'], \"headers-only\")\n                 tip_entry_found = True\n-        assert(tip_entry_found)\n+        assert tip_entry_found\n         assert_raises_rpc_error(-1, \"Block not found on disk\", self.nodes[0].getblock, block_h1f.hash)\n \n         # 4. Send another two block that build on the fork.\n@@ -131,7 +131,7 @@ def run_test(self):\n             if x['hash'] == block_h2f.hash:\n                 assert_equal(x['status'], \"headers-only\")\n                 tip_entry_found = True\n-        assert(tip_entry_found)\n+        assert tip_entry_found\n \n         # But this block should be accepted by node since it has equal work.\n         self.nodes[0].getblock(block_h2f.hash)\n@@ -150,7 +150,7 @@ def run_test(self):\n             if x['hash'] == block_h3.hash:\n                 assert_equal(x['status'], \"headers-only\")\n                 tip_entry_found = True\n-        assert(tip_entry_found)\n+        assert tip_entry_found\n         self.nodes[0].getblock(block_h3.hash)\n \n         # But this block should be accepted by node since it has more work.\n@@ -263,7 +263,7 @@ def run_test(self):\n             if x['hash'] == block_292.hash:\n                 assert_equal(x['status'], \"headers-only\")\n                 tip_entry_found = True\n-        assert(tip_entry_found)\n+        assert tip_entry_found\n         assert_raises_rpc_error(-1, \"Block not found on disk\", self.nodes[0].getblock, block_292.hash)\n \n         test_node.send_message(msg_block(block_289f))"
      },
      {
        "sha": "acc7cd811c549340e61e49bb5bd71fecbe941489",
        "filename": "test/functional/rpc_bind.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_bind.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_bind.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_bind.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2014-2018 The Bitcoin Core developers\n+# Copyright (c) 2014-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test running bitcoind with the -rpcbind and -rpcallowip options.\"\"\""
      },
      {
        "sha": "facb05b54ce387f3272c6692a130916e9acb9cba",
        "filename": "test/functional/rpc_blockchain.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_blockchain.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2014-2018 The Bitcoin Core developers\n+# Copyright (c) 2014-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test RPCs related to blockchainstate.\n@@ -172,9 +172,9 @@ def _test_getchaintxstats(self):\n         assert_equal(chaintxstats['txcount'], 2)\n         assert_equal(chaintxstats['window_final_block_hash'], b1_hash)\n         assert_equal(chaintxstats['window_block_count'], 0)\n-        assert('window_tx_count' not in chaintxstats)\n-        assert('window_interval' not in chaintxstats)\n-        assert('txrate' not in chaintxstats)\n+        assert 'window_tx_count' not in chaintxstats\n+        assert 'window_interval' not in chaintxstats\n+        assert 'txrate' not in chaintxstats\n \n     def _test_gettxoutsetinfo(self):\n         node = self.nodes[0]"
      },
      {
        "sha": "01b8cb1854d9e799ce7394d31573730d7d19ab23",
        "filename": "test/functional/rpc_decodescript.py",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_decodescript.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_decodescript.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_decodescript.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,12 +1,12 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2015-2018 The Bitcoin Core developers\n+# Copyright (c) 2015-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test decoding scripts via decodescript RPC command.\"\"\"\n \n from test_framework.messages import CTransaction, sha256\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, bytes_to_hex_str, hex_str_to_bytes\n+from test_framework.util import assert_equal, hex_str_to_bytes\n \n from io import BytesIO\n \n@@ -81,7 +81,7 @@ def decodescript_script_pub_key(self):\n         rpc_result = self.nodes[0].decodescript(multisig_script)\n         assert_equal('2 ' + public_key + ' ' + public_key + ' ' + public_key +  ' 3 OP_CHECKMULTISIG', rpc_result['asm'])\n         # multisig in P2WSH\n-        multisig_script_hash = bytes_to_hex_str(sha256(hex_str_to_bytes(multisig_script)))\n+        multisig_script_hash = sha256(hex_str_to_bytes(multisig_script)).hex()\n         assert_equal('0 ' + multisig_script_hash, rpc_result['segwit']['asm'])\n \n         # 4) P2SH scriptPubKey\n@@ -119,7 +119,7 @@ def decodescript_script_pub_key(self):\n         rpc_result = self.nodes[0].decodescript(cltv_script)\n         assert_equal('OP_IF ' + public_key + ' OP_CHECKSIGVERIFY OP_ELSE 500000 OP_CHECKLOCKTIMEVERIFY OP_DROP OP_ENDIF ' + public_key + ' OP_CHECKSIG', rpc_result['asm'])\n         # CLTV script in P2WSH\n-        cltv_script_hash = bytes_to_hex_str(sha256(hex_str_to_bytes(cltv_script)))\n+        cltv_script_hash = sha256(hex_str_to_bytes(cltv_script)).hex()\n         assert_equal('0 ' + cltv_script_hash, rpc_result['segwit']['asm'])\n \n         # 7) P2PK scriptPubKey\n@@ -196,7 +196,7 @@ def decoderawtransaction_asm_sighashtype(self):\n         # some more full transaction tests of varying specific scriptSigs. used instead of\n         # tests in decodescript_script_sig because the decodescript RPC is specifically\n         # for working on scriptPubKeys (argh!).\n-        push_signature = bytes_to_hex_str(txSave.vin[0].scriptSig)[2:(0x48*2+4)]\n+        push_signature = txSave.vin[0].scriptSig.hex()[2:(0x48*2+4)]\n         signature = push_signature[2:]\n         der_signature = signature[:-2]\n         signature_sighash_decoded = der_signature + '[ALL]'\n@@ -206,23 +206,23 @@ def decoderawtransaction_asm_sighashtype(self):\n \n         # 1) P2PK scriptSig\n         txSave.vin[0].scriptSig = hex_str_to_bytes(push_signature)\n-        rpc_result = self.nodes[0].decoderawtransaction(bytes_to_hex_str(txSave.serialize()))\n+        rpc_result = self.nodes[0].decoderawtransaction(txSave.serialize().hex())\n         assert_equal(signature_sighash_decoded, rpc_result['vin'][0]['scriptSig']['asm'])\n \n         # make sure that the sighash decodes come out correctly for a more complex / lesser used case.\n         txSave.vin[0].scriptSig = hex_str_to_bytes(push_signature_2)\n-        rpc_result = self.nodes[0].decoderawtransaction(bytes_to_hex_str(txSave.serialize()))\n+        rpc_result = self.nodes[0].decoderawtransaction(txSave.serialize().hex())\n         assert_equal(signature_2_sighash_decoded, rpc_result['vin'][0]['scriptSig']['asm'])\n \n         # 2) multisig scriptSig\n         txSave.vin[0].scriptSig = hex_str_to_bytes('00' + push_signature + push_signature_2)\n-        rpc_result = self.nodes[0].decoderawtransaction(bytes_to_hex_str(txSave.serialize()))\n+        rpc_result = self.nodes[0].decoderawtransaction(txSave.serialize().hex())\n         assert_equal('0 ' + signature_sighash_decoded + ' ' + signature_2_sighash_decoded, rpc_result['vin'][0]['scriptSig']['asm'])\n \n         # 3) test a scriptSig that contains more than push operations.\n         # in fact, it contains an OP_RETURN with data specially crafted to cause improper decode if the code does not catch it.\n         txSave.vin[0].scriptSig = hex_str_to_bytes('6a143011020701010101010101020601010101010101')\n-        rpc_result = self.nodes[0].decoderawtransaction(bytes_to_hex_str(txSave.serialize()))\n+        rpc_result = self.nodes[0].decoderawtransaction(txSave.serialize().hex())\n         assert_equal('OP_RETURN 3011020701010101010101020601010101010101', rpc_result['vin'][0]['scriptSig']['asm'])\n \n     def run_test(self):"
      },
      {
        "sha": "9a21998d113fb277ececa01d9727bb7501f4cd93",
        "filename": "test/functional/rpc_deprecated.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_deprecated.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_deprecated.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_deprecated.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2017-2018 The Bitcoin Core developers\n+# Copyright (c) 2017-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test deprecation of RPC calls.\"\"\""
      },
      {
        "sha": "19846946921abb6cfec70bbb1437f514d85458cb",
        "filename": "test/functional/rpc_deriveaddresses.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_deriveaddresses.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_deriveaddresses.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_deriveaddresses.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2018 The Bitcoin Core developers\n+# Copyright (c) 2018-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the deriveaddresses rpc call.\"\"\""
      },
      {
        "sha": "d89fd6461fa5f3f9909c3781ef3a77093932f4f6",
        "filename": "test/functional/rpc_fundrawtransaction.py",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_fundrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_fundrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_fundrawtransaction.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2014-2018 The Bitcoin Core developers\n+# Copyright (c) 2014-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the fundrawtransaction RPC.\"\"\"\n@@ -94,7 +94,7 @@ def run_test(self):\n         rawtxfund = self.nodes[2].fundrawtransaction(rawtx)\n         fee = rawtxfund['fee']\n         dec_tx  = self.nodes[2].decoderawtransaction(rawtxfund['hex'])\n-        assert(len(dec_tx['vin']) > 0) #test that we have enough inputs\n+        assert len(dec_tx['vin']) > 0  #test that we have enough inputs\n \n         ##############################\n         # simple test with two coins #\n@@ -107,7 +107,7 @@ def run_test(self):\n         rawtxfund = self.nodes[2].fundrawtransaction(rawtx)\n         fee = rawtxfund['fee']\n         dec_tx  = self.nodes[2].decoderawtransaction(rawtxfund['hex'])\n-        assert(len(dec_tx['vin']) > 0) #test if we have enough inputs\n+        assert len(dec_tx['vin']) > 0  #test if we have enough inputs\n \n         ##############################\n         # simple test with two coins #\n@@ -120,7 +120,7 @@ def run_test(self):\n         rawtxfund = self.nodes[2].fundrawtransaction(rawtx)\n         fee = rawtxfund['fee']\n         dec_tx  = self.nodes[2].decoderawtransaction(rawtxfund['hex'])\n-        assert(len(dec_tx['vin']) > 0)\n+        assert len(dec_tx['vin']) > 0\n         assert_equal(dec_tx['vin'][0]['scriptSig']['hex'], '')\n \n \n@@ -139,7 +139,7 @@ def run_test(self):\n         for out in dec_tx['vout']:\n             totalOut += out['value']\n \n-        assert(len(dec_tx['vin']) > 0)\n+        assert len(dec_tx['vin']) > 0\n         assert_equal(dec_tx['vin'][0]['scriptSig']['hex'], '')\n \n \n@@ -363,7 +363,7 @@ def run_test(self):\n \n         #compare fee\n         feeDelta = Decimal(fundedTx['fee']) - Decimal(signedFee)\n-        assert(feeDelta >= 0 and feeDelta <= feeTolerance)\n+        assert feeDelta >= 0 and feeDelta <= feeTolerance\n         ############################################################\n \n         ############################################################\n@@ -378,7 +378,7 @@ def run_test(self):\n \n         #compare fee\n         feeDelta = Decimal(fundedTx['fee']) - Decimal(signedFee)\n-        assert(feeDelta >= 0 and feeDelta <= feeTolerance)\n+        assert feeDelta >= 0 and feeDelta <= feeTolerance\n         ############################################################\n \n \n@@ -405,7 +405,7 @@ def run_test(self):\n \n         #compare fee\n         feeDelta = Decimal(fundedTx['fee']) - Decimal(signedFee)\n-        assert(feeDelta >= 0 and feeDelta <= feeTolerance)\n+        assert feeDelta >= 0 and feeDelta <= feeTolerance\n         ############################################################\n \n \n@@ -438,7 +438,7 @@ def run_test(self):\n \n         #compare fee\n         feeDelta = Decimal(fundedTx['fee']) - Decimal(signedFee)\n-        assert(feeDelta >= 0 and feeDelta <= feeTolerance)\n+        assert feeDelta >= 0 and feeDelta <= feeTolerance\n         ############################################################\n \n \n@@ -558,7 +558,7 @@ def run_test(self):\n \n         #compare fee\n         feeDelta = Decimal(fundedTx['fee']) - Decimal(signedFee)\n-        assert(feeDelta >= 0 and feeDelta <= feeTolerance*19) #~19 inputs\n+        assert feeDelta >= 0 and feeDelta <= feeTolerance*19  #~19 inputs\n \n \n         #############################################\n@@ -620,7 +620,7 @@ def run_test(self):\n         assert_equal(len(res_dec[\"vin\"]), 1)\n         assert_equal(res_dec[\"vin\"][0][\"txid\"], watchonly_txid)\n \n-        assert(\"fee\" in result.keys())\n+        assert \"fee\" in result.keys()\n         assert_greater_than(result[\"changepos\"], -1)\n \n         ###############################################################\n@@ -635,16 +635,16 @@ def run_test(self):\n         result = self.nodes[3].fundrawtransaction(rawtx, True)\n         res_dec = self.nodes[0].decoderawtransaction(result[\"hex\"])\n         assert_equal(len(res_dec[\"vin\"]), 2)\n-        assert(res_dec[\"vin\"][0][\"txid\"] == watchonly_txid or res_dec[\"vin\"][1][\"txid\"] == watchonly_txid)\n+        assert res_dec[\"vin\"][0][\"txid\"] == watchonly_txid or res_dec[\"vin\"][1][\"txid\"] == watchonly_txid\n \n         assert_greater_than(result[\"fee\"], 0)\n         assert_greater_than(result[\"changepos\"], -1)\n         assert_equal(result[\"fee\"] + res_dec[\"vout\"][result[\"changepos\"]][\"value\"], watchonly_amount / 10)\n \n         signedtx = self.nodes[3].signrawtransactionwithwallet(result[\"hex\"])\n-        assert(not signedtx[\"complete\"])\n+        assert not signedtx[\"complete\"]\n         signedtx = self.nodes[0].signrawtransactionwithwallet(signedtx[\"hex\"])\n-        assert(signedtx[\"complete\"])\n+        assert signedtx[\"complete\"]\n         self.nodes[0].sendrawtransaction(signedtx[\"hex\"])\n         self.nodes[0].generate(1)\n         self.sync_all()\n@@ -676,10 +676,10 @@ def run_test(self):\n         for out in res_dec['vout']:\n             if out['value'] > 1.0:\n                 changeaddress += out['scriptPubKey']['addresses'][0]\n-        assert(changeaddress != \"\")\n+        assert changeaddress != \"\"\n         nextaddr = self.nodes[3].getnewaddress()\n         # Now the change address key should be removed from the keypool\n-        assert(changeaddress != nextaddr)\n+        assert changeaddress != nextaddr\n \n         ######################################\n         # Test subtractFeeFromOutputs option #"
      },
      {
        "sha": "e17a8f6421182b5e42107224d18c2db312c7fb07",
        "filename": "test/functional/rpc_getblockstats.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_getblockstats.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_getblockstats.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_getblockstats.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2017-2018 The Bitcoin Core developers\n+# Copyright (c) 2017-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n "
      },
      {
        "sha": "ecac9c2f82d5839df28ff56ec7280289bd12f3eb",
        "filename": "test/functional/rpc_named_arguments.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_named_arguments.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_named_arguments.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_named_arguments.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2016-2018 The Bitcoin Core developers\n+# Copyright (c) 2016-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test using named arguments for RPCs.\"\"\"\n@@ -17,7 +17,7 @@ def set_test_params(self):\n     def run_test(self):\n         node = self.nodes[0]\n         h = node.help(command='getblockchaininfo')\n-        assert(h.startswith('getblockchaininfo\\n'))\n+        assert h.startswith('getblockchaininfo\\n')\n \n         assert_raises_rpc_error(-8, 'Unknown named parameter', node.help, random='getblockchaininfo')\n "
      },
      {
        "sha": "da228df9c3003f76b4c6d12ba701f2640a281e42",
        "filename": "test/functional/rpc_preciousblock.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_preciousblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_preciousblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_preciousblock.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2015-2018 The Bitcoin Core developers\n+# Copyright (c) 2015-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the preciousblock RPC.\"\"\"\n@@ -16,15 +16,15 @@ def unidirectional_node_sync_via_rpc(node_src, node_dest):\n     blockhash = node_src.getbestblockhash()\n     while True:\n         try:\n-            assert(len(node_dest.getblock(blockhash, False)) > 0)\n+            assert len(node_dest.getblock(blockhash, False)) > 0\n             break\n         except:\n             blocks_to_copy.append(blockhash)\n             blockhash = node_src.getblockheader(blockhash, True)['previousblockhash']\n     blocks_to_copy.reverse()\n     for blockhash in blocks_to_copy:\n         blockdata = node_src.getblock(blockhash, False)\n-        assert(node_dest.submitblock(blockdata) in (None, 'inconclusive'))\n+        assert node_dest.submitblock(blockdata) in (None, 'inconclusive')\n \n def node_sync_via_rpc(nodes):\n     for node_src in nodes:\n@@ -57,7 +57,7 @@ def run_test(self):\n         self.log.info(\"Mine competing blocks E-F-G on Node 1\")\n         hashG = self.nodes[1].generatetoaddress(3, gen_address(1))[-1]\n         assert_equal(self.nodes[1].getblockcount(), 5)\n-        assert(hashC != hashG)\n+        assert hashC != hashG\n         self.log.info(\"Connect nodes and check no reorg occurs\")\n         # Submit competing blocks via RPC so any reorg should occur before we proceed (no way to wait on inaction for p2p sync)\n         node_sync_via_rpc(self.nodes[0:2])"
      },
      {
        "sha": "885e07c4dd4c0660bacec1d2a3c74b4f69a069e1",
        "filename": "test/functional/rpc_psbt.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_psbt.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_psbt.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_psbt.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2018 The Bitcoin Core developers\n+# Copyright (c) 2018-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the Partially Signed Transaction RPCs.\n@@ -47,11 +47,11 @@ def test_utxo_conversion(self):\n         utxos = online_node.listunspent(addresses=[offline_addr])\n         raw = online_node.createrawtransaction([{\"txid\":utxos[0][\"txid\"], \"vout\":utxos[0][\"vout\"]}],[{online_addr:0.9999}])\n         psbt = online_node.walletprocesspsbt(online_node.converttopsbt(raw))[\"psbt\"]\n-        assert(\"non_witness_utxo\" in mining_node.decodepsbt(psbt)[\"inputs\"][0])\n+        assert \"non_witness_utxo\" in mining_node.decodepsbt(psbt)[\"inputs\"][0]\n \n         # Have the offline node sign the PSBT (which will update the UTXO to segwit)\n         signed_psbt = offline_node.walletprocesspsbt(psbt)[\"psbt\"]\n-        assert(\"witness_utxo\" in mining_node.decodepsbt(signed_psbt)[\"inputs\"][0])\n+        assert \"witness_utxo\" in mining_node.decodepsbt(signed_psbt)[\"inputs\"][0]\n \n         # Make sure we can mine the resulting transaction\n         txid = mining_node.sendrawtransaction(mining_node.finalizepsbt(signed_psbt)[\"hex\"])"
      },
      {
        "sha": "fba9e75268b3097bd39ac8bfc1ab98c6faf526cb",
        "filename": "test/functional/rpc_rawtransaction.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_rawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_rawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_rawtransaction.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2014-2018 The Bitcoin Core developers\n+# Copyright (c) 2014-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the rawtransaction RPCs.\n@@ -17,7 +17,7 @@\n from io import BytesIO\n from test_framework.messages import CTransaction, ToHex\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, assert_raises_rpc_error, bytes_to_hex_str, connect_nodes_bi, hex_str_to_bytes\n+from test_framework.util import assert_equal, assert_raises_rpc_error, connect_nodes_bi, hex_str_to_bytes\n \n class multidict(dict):\n     \"\"\"Dictionary that allows duplicate keys.\n@@ -119,21 +119,21 @@ def run_test(self):\n         tx.deserialize(BytesIO(hex_str_to_bytes(self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs={address: 99}))))\n         assert_equal(len(tx.vout), 1)\n         assert_equal(\n-            bytes_to_hex_str(tx.serialize()),\n+            tx.serialize().hex(),\n             self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs=[{address: 99}]),\n         )\n         # Two outputs\n         tx.deserialize(BytesIO(hex_str_to_bytes(self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs=OrderedDict([(address, 99), (address2, 99)])))))\n         assert_equal(len(tx.vout), 2)\n         assert_equal(\n-            bytes_to_hex_str(tx.serialize()),\n+            tx.serialize().hex(),\n             self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs=[{address: 99}, {address2: 99}]),\n         )\n         # Multiple mixed outputs\n         tx.deserialize(BytesIO(hex_str_to_bytes(self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs=multidict([(address, 99), (address2, 99), ('data', '99')])))))\n         assert_equal(len(tx.vout), 3)\n         assert_equal(\n-            bytes_to_hex_str(tx.serialize()),\n+            tx.serialize().hex(),\n             self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs=[{address: 99}, {address2: 99}, {'data': '99'}]),\n         )\n "
      },
      {
        "sha": "63464779227bf3b91ba313c972c4bc20d1f00d38",
        "filename": "test/functional/rpc_scantxoutset.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_scantxoutset.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_scantxoutset.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_scantxoutset.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2018 The Bitcoin Core developers\n+# Copyright (c) 2018-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the scantxoutset rpc call.\"\"\""
      },
      {
        "sha": "0cb3ce42151d2dc83c0d03b968c6950e1b1ba8f1",
        "filename": "test/functional/rpc_signmessage.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_signmessage.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_signmessage.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_signmessage.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2016-2018 The Bitcoin Core developers\n+# Copyright (c) 2016-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test RPC commands for signing and verifying messages.\"\"\"\n@@ -25,18 +25,18 @@ def run_test(self):\n         expected_signature = 'INbVnW4e6PeRmsv2Qgu8NuopvrVjkcxob+sX8OcZG0SALhWybUjzMLPdAsXI46YZGb0KQTRii+wWIQzRpG/U+S0='\n         signature = self.nodes[0].signmessagewithprivkey(priv_key, message)\n         assert_equal(expected_signature, signature)\n-        assert(self.nodes[0].verifymessage(address, signature, message))\n+        assert self.nodes[0].verifymessage(address, signature, message)\n \n         self.log.info('test signing with an address with wallet')\n         address = self.nodes[0].getnewaddress()\n         signature = self.nodes[0].signmessage(address, message)\n-        assert(self.nodes[0].verifymessage(address, signature, message))\n+        assert self.nodes[0].verifymessage(address, signature, message)\n \n         self.log.info('test verifying with another address should not work')\n         other_address = self.nodes[0].getnewaddress()\n         other_signature = self.nodes[0].signmessage(other_address, message)\n-        assert(not self.nodes[0].verifymessage(other_address, signature, message))\n-        assert(not self.nodes[0].verifymessage(address, other_signature, message))\n+        assert not self.nodes[0].verifymessage(other_address, signature, message)\n+        assert not self.nodes[0].verifymessage(address, other_signature, message)\n \n if __name__ == '__main__':\n     SignMessagesTest().main()"
      },
      {
        "sha": "dcafc828573f08efe3bf94056990f23b5998ddf0",
        "filename": "test/functional/rpc_signrawtransaction.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_signrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_signrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_signrawtransaction.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,11 +1,11 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2015-2018 The Bitcoin Core developers\n+# Copyright (c) 2015-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test transaction signing using the signrawtransaction* RPCs.\"\"\"\n \n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, assert_raises_rpc_error, bytes_to_hex_str, hex_str_to_bytes\n+from test_framework.util import assert_equal, assert_raises_rpc_error, hex_str_to_bytes\n from test_framework.messages import sha256\n from test_framework.script import CScript, OP_0\n \n@@ -161,7 +161,7 @@ def witness_script_test(self):\n         unspent_output = self.nodes[1].listunspent(0, 999999, [p2sh_p2wsh_address[\"address\"]])[0]\n         assert_equal(unspent_output[\"witnessScript\"], p2sh_p2wsh_address[\"redeemScript\"])\n         p2sh_redeemScript = CScript([OP_0, sha256(hex_str_to_bytes(p2sh_p2wsh_address[\"redeemScript\"]))])\n-        assert_equal(unspent_output[\"redeemScript\"], bytes_to_hex_str(p2sh_redeemScript))\n+        assert_equal(unspent_output[\"redeemScript\"], p2sh_redeemScript.hex())\n         # Now create and sign a transaction spending that output on node[0], which doesn't know the scripts or keys\n         spending_tx = self.nodes[0].createrawtransaction([unspent_output], {self.nodes[1].getnewaddress(): Decimal(\"49.998\")})\n         spending_tx_signed = self.nodes[0].signrawtransactionwithkey(spending_tx, [embedded_privkey], [unspent_output])"
      },
      {
        "sha": "e86f91b1d0a112cc4951e79e05ebe82da9bcfbe7",
        "filename": "test/functional/rpc_uptime.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_uptime.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/rpc_uptime.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_uptime.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2017-2018 The Bitcoin Core developers\n+# Copyright (c) 2017-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the RPC call related to the uptime command.\n@@ -23,7 +23,7 @@ def run_test(self):\n     def _test_uptime(self):\n         wait_time = 10\n         self.nodes[0].setmocktime(int(time.time() + wait_time))\n-        assert(self.nodes[0].uptime() >= wait_time)\n+        assert self.nodes[0].uptime() >= wait_time\n \n \n if __name__ == '__main__':"
      },
      {
        "sha": "f36cffe957d7f7078f915f1e35298beb45cb497f",
        "filename": "test/functional/test_framework/address.py",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/test_framework/address.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/test_framework/address.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/address.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,11 +1,11 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2016-2018 The Bitcoin Core developers\n+# Copyright (c) 2016-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Encode and decode BASE58, P2PKH and P2SH addresses.\"\"\"\n \n from .script import hash256, hash160, sha256, CScript, OP_0\n-from .util import bytes_to_hex_str, hex_str_to_bytes\n+from .util import hex_str_to_bytes\n \n from . import segwit_addr\n \n@@ -16,9 +16,9 @@\n \n def byte_to_base58(b, version):\n     result = ''\n-    str = bytes_to_hex_str(b)\n-    str = bytes_to_hex_str(chr(version).encode('latin-1')) + str\n-    checksum = bytes_to_hex_str(hash256(hex_str_to_bytes(str)))\n+    str = b.hex()\n+    str = chr(version).encode('latin-1').hex() + str\n+    checksum = hash256(hex_str_to_bytes(str)).hex()\n     str += checksum[:8]\n     value = int('0x'+str,0)\n     while value > 0:\n@@ -32,12 +32,12 @@ def byte_to_base58(b, version):\n # TODO: def base58_decode\n \n def keyhash_to_p2pkh(hash, main = False):\n-    assert (len(hash) == 20)\n+    assert len(hash) == 20\n     version = 0 if main else 111\n     return byte_to_base58(hash, version)\n \n def scripthash_to_p2sh(hash, main = False):\n-    assert (len(hash) == 20)\n+    assert len(hash) == 20\n     version = 5 if main else 196\n     return byte_to_base58(hash, version)\n \n@@ -80,11 +80,11 @@ def check_key(key):\n         key = hex_str_to_bytes(key) # Assuming this is hex string\n     if (type(key) is bytes and (len(key) == 33 or len(key) == 65)):\n         return key\n-    assert(False)\n+    assert False\n \n def check_script(script):\n     if (type(script) is str):\n         script = hex_str_to_bytes(script) # Assuming this is hex string\n     if (type(script) is bytes or type(script) is CScript):\n         return script\n-    assert(False)\n+    assert False"
      },
      {
        "sha": "7ac044d0d01eb169501bd250409d5b78f5eb71e9",
        "filename": "test/functional/test_framework/blocktools.py",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/test_framework/blocktools.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/test_framework/blocktools.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/blocktools.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -20,7 +20,6 @@\n     CTxOut,\n     FromHex,\n     ToHex,\n-    bytes_to_hex_str,\n     hash256,\n     hex_str_to_bytes,\n     ser_string,\n@@ -132,7 +131,7 @@ def create_tx_with_script(prevtx, n, script_sig=b\"\", *, amount, script_pub_key=C\n        Can optionally pass scriptPubKey and scriptSig, default is anyone-can-spend output.\n     \"\"\"\n     tx = CTransaction()\n-    assert(n < len(prevtx.vout))\n+    assert n < len(prevtx.vout)\n     tx.vin.append(CTxIn(COutPoint(prevtx.sha256, n), script_sig, 0xffffffff))\n     tx.vout.append(CTxOut(amount, script_pub_key))\n     tx.calc_sha256()\n@@ -190,7 +189,7 @@ def witness_script(use_p2wsh, pubkey):\n         witness_program = CScript([OP_1, hex_str_to_bytes(pubkey), OP_1, OP_CHECKMULTISIG])\n         scripthash = sha256(witness_program)\n         pkscript = CScript([OP_0, scripthash])\n-    return bytes_to_hex_str(pkscript)\n+    return pkscript.hex()\n \n def create_witness_tx(node, use_p2wsh, utxo, pubkey, encode_p2sh, amount):\n     \"\"\"Return a transaction (in hex) that spends the given utxo to a segwit output.\n@@ -215,7 +214,7 @@ def send_to_witness(use_p2wsh, node, utxo, pubkey, encode_p2sh, amount, sign=Tru\n     tx_to_witness = create_witness_tx(node, use_p2wsh, utxo, pubkey, encode_p2sh, amount)\n     if (sign):\n         signed = node.signrawtransactionwithwallet(tx_to_witness)\n-        assert(\"errors\" not in signed or len([\"errors\"]) == 0)\n+        assert \"errors\" not in signed or len([\"errors\"]) == 0\n         return node.sendrawtransaction(signed[\"hex\"])\n     else:\n         if (insert_redeem_script):"
      },
      {
        "sha": "7cf51d9223ac9b7caf0e8b5605a03e0042670d9a",
        "filename": "test/functional/test_framework/messages.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/test_framework/messages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/test_framework/messages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/messages.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,7 +1,7 @@\n #!/usr/bin/env python3\n # Copyright (c) 2010 ArtForz -- public domain half-a-node\n # Copyright (c) 2012 Jeff Garzik\n-# Copyright (c) 2010-2018 The Bitcoin Core developers\n+# Copyright (c) 2010-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Bitcoin test framework primitive and message structures\n@@ -28,7 +28,7 @@\n import time\n \n from test_framework.siphash import siphash256\n-from test_framework.util import hex_str_to_bytes, bytes_to_hex_str, assert_equal\n+from test_framework.util import hex_str_to_bytes, assert_equal\n \n MIN_VERSION_SUPPORTED = 60001\n MY_VERSION = 70014  # past bip-31 for ping/pong\n@@ -181,7 +181,7 @@ def FromHex(obj, hex_string):\n \n # Convert a binary-serializable object to hex (eg for submission via RPC)\n def ToHex(obj):\n-    return bytes_to_hex_str(obj.serialize())\n+    return obj.serialize().hex()\n \n # Objects that map to bitcoind objects, which can be serialized/deserialized\n \n@@ -319,7 +319,7 @@ def serialize(self):\n \n     def __repr__(self):\n         return \"CTxIn(prevout=%s scriptSig=%s nSequence=%i)\" \\\n-            % (repr(self.prevout), bytes_to_hex_str(self.scriptSig),\n+            % (repr(self.prevout), self.scriptSig.hex(),\n                self.nSequence)\n \n \n@@ -343,7 +343,7 @@ def serialize(self):\n     def __repr__(self):\n         return \"CTxOut(nValue=%i.%08i scriptPubKey=%s)\" \\\n             % (self.nValue // COIN, self.nValue % COIN,\n-               bytes_to_hex_str(self.scriptPubKey))\n+               self.scriptPubKey.hex())\n \n \n class CScriptWitness:\n@@ -355,7 +355,7 @@ def __init__(self):\n \n     def __repr__(self):\n         return \"CScriptWitness(%s)\" % \\\n-               (\",\".join([bytes_to_hex_str(x) for x in self.stack]))\n+               (\",\".join([x.hex() for x in self.stack]))\n \n     def is_null(self):\n         if self.stack:"
      },
      {
        "sha": "52a840941b8be8839cfb895749f939a7e0ef6dd1",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,7 +1,7 @@\n #!/usr/bin/env python3\n # Copyright (c) 2010 ArtForz -- public domain half-a-node\n # Copyright (c) 2012 Jeff Garzik\n-# Copyright (c) 2010-2018 The Bitcoin Core developers\n+# Copyright (c) 2010-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Bitcoin P2P network half-a-node.\n@@ -218,10 +218,7 @@ def send_raw_message(self, raw_message_bytes):\n         def maybe_write():\n             if not self._transport:\n                 return\n-            # Python <3.4.4 does not have is_closing, so we have to check for\n-            # its existence explicitly as long as Bitcoin Core supports all\n-            # Python 3.4 versions.\n-            if hasattr(self._transport, 'is_closing') and self._transport.is_closing():\n+            if self._transport.is_closing():\n                 return\n             self._transport.write(raw_message_bytes)\n         NetworkThread.network_event_loop.call_soon_threadsafe(maybe_write)"
      },
      {
        "sha": "c98424e8e278026bdea2729b4c26f604fe66f5a0",
        "filename": "test/functional/test_framework/netutil.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/test_framework/netutil.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/test_framework/netutil.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/netutil.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2014-2018 The Bitcoin Core developers\n+# Copyright (c) 2014-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Linux network utilities.\n@@ -12,7 +12,7 @@\n import struct\n import array\n import os\n-from binascii import unhexlify, hexlify\n+from binascii import unhexlify\n \n # STATE_ESTABLISHED = '01'\n # STATE_SYN_SENT  = '02'\n@@ -129,17 +129,17 @@ def addr_to_hex(addr):\n                 if i == 0 or i == (len(addr)-1): # skip empty component at beginning or end\n                     continue\n                 x += 1 # :: skips to suffix\n-                assert(x < 2)\n+                assert x < 2\n             else: # two bytes per component\n                 val = int(comp, 16)\n                 sub[x].append(val >> 8)\n                 sub[x].append(val & 0xff)\n         nullbytes = 16 - len(sub[0]) - len(sub[1])\n-        assert((x == 0 and nullbytes == 0) or (x == 1 and nullbytes > 0))\n+        assert (x == 0 and nullbytes == 0) or (x == 1 and nullbytes > 0)\n         addr = sub[0] + ([0] * nullbytes) + sub[1]\n     else:\n         raise ValueError('Could not parse address %s' % addr)\n-    return hexlify(bytearray(addr)).decode('ascii')\n+    return bytearray(addr).hex()\n \n def test_ipv6_local():\n     '''"
      },
      {
        "sha": "384062b8084fe78d395d670326d9744384014376",
        "filename": "test/functional/test_framework/script.py",
        "status": "modified",
        "additions": 2,
        "deletions": 7,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/test_framework/script.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/test_framework/script.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/script.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2015-2018 The Bitcoin Core developers\n+# Copyright (c) 2015-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Functionality to build scripts, as well as SignatureHash().\n@@ -9,7 +9,6 @@\n \n from .messages import CTransaction, CTxOut, sha256, hash256, uint256_from_str, ser_uint256, ser_string\n \n-from binascii import hexlify\n import hashlib\n import struct\n \n@@ -450,10 +449,6 @@ def join(self, iterable):\n         # join makes no sense for a CScript()\n         raise NotImplementedError\n \n-    # Python 3.4 compatibility\n-    def hex(self):\n-        return hexlify(self).decode('ascii')\n-\n     def __new__(cls, value=b''):\n         if isinstance(value, bytes) or isinstance(value, bytearray):\n             return super(CScript, cls).__new__(cls, value)\n@@ -545,7 +540,7 @@ def __iter__(self):\n     def __repr__(self):\n         def _repr(o):\n             if isinstance(o, bytes):\n-                return \"x('%s')\" % hexlify(o).decode('ascii')\n+                return \"x('%s')\" % o.hex()\n             else:\n                 return repr(o)\n "
      },
      {
        "sha": "799b1c74b8b622f7bfaf6cf184357046b91dfb9c",
        "filename": "test/functional/test_framework/socks5.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/test_framework/socks5.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/test_framework/socks5.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/socks5.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2015-2018 The Bitcoin Core developers\n+# Copyright (c) 2015-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Dummy Socks5 server for testing.\"\"\"\n@@ -144,7 +144,7 @@ def run(self):\n                 thread.start()\n \n     def start(self):\n-        assert(not self.running)\n+        assert not self.running\n         self.running = True\n         self.thread = threading.Thread(None, self.run)\n         self.thread.daemon = True"
      },
      {
        "sha": "15d2e08c93ce5564a3b14aebac75a2af1afdea7a",
        "filename": "test/functional/test_framework/test_framework.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/test_framework/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/test_framework/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_framework.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2014-2018 The Bitcoin Core developers\n+# Copyright (c) 2014-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Base class for RPC testing.\"\"\""
      },
      {
        "sha": "ec5d3b267e35e833fca362ecfe3f7805ebb0bf69",
        "filename": "test/functional/test_framework/test_node.py",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/test_framework/test_node.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/test_framework/test_node.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_node.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2017-2018 The Bitcoin Core developers\n+# Copyright (c) 2017-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for bitcoind node under test\"\"\"\n@@ -31,9 +31,6 @@\n     p2p_port,\n )\n \n-# For Python 3.4 compatibility\n-JSONDecodeError = getattr(json, \"JSONDecodeError\", ValueError)\n-\n BITCOIND_PROC_WAIT_TIMEOUT = 60\n \n \n@@ -565,5 +562,5 @@ def send_cli(self, command=None, *args, **kwargs):\n             raise subprocess.CalledProcessError(returncode, self.binary, output=cli_stderr)\n         try:\n             return json.loads(cli_stdout, parse_float=decimal.Decimal)\n-        except JSONDecodeError:\n+        except json.JSONDecodeError:\n             return cli_stdout.rstrip(\"\\n\")"
      },
      {
        "sha": "034ed893f4d87be17995645ab393803dd614c3a1",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 5,
        "deletions": 8,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,11 +1,11 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2014-2018 The Bitcoin Core developers\n+# Copyright (c) 2014-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Helpful routines for regression testing.\"\"\"\n \n from base64 import b64encode\n-from binascii import hexlify, unhexlify\n+from binascii import unhexlify\n from decimal import Decimal, ROUND_DOWN\n import hashlib\n import inspect\n@@ -182,9 +182,6 @@ def check_json_precision():\n def count_bytes(hex_string):\n     return len(bytearray.fromhex(hex_string))\n \n-def bytes_to_hex_str(byte_str):\n-    return hexlify(byte_str).decode('ascii')\n-\n def hash256(byte_str):\n     sha256 = hashlib.sha256()\n     sha256.update(byte_str)\n@@ -267,7 +264,7 @@ def get_rpc_proxy(url, node_number, timeout=None, coveragedir=None):\n     return coverage.AuthServiceProxyWrapper(proxy, coverage_logfile)\n \n def p2p_port(n):\n-    assert(n <= MAX_NODES)\n+    assert n <= MAX_NODES\n     return PORT_MIN + n + (MAX_NODES * PortSeed.n) % (PORT_RANGE - 1 - MAX_NODES)\n \n def rpc_port(n):\n@@ -425,7 +422,7 @@ def gather_inputs(from_node, amount_needed, confirmations_required=1):\n     \"\"\"\n     Return a random set of unspent txouts that are enough to pay amount_needed\n     \"\"\"\n-    assert(confirmations_required >= 0)\n+    assert confirmations_required >= 0\n     utxo = from_node.listunspent(confirmations_required)\n     random.shuffle(utxo)\n     inputs = []\n@@ -503,7 +500,7 @@ def create_confirmed_utxos(fee, node, count):\n         node.generate(1)\n \n     utxos = node.listunspent()\n-    assert(len(utxos) >= count)\n+    assert len(utxos) >= count\n     return utxos\n \n # Create large OP_RETURN txouts that can be appended to a transaction"
      },
      {
        "sha": "a0d9f820e69b85713902cc66dae85c042d6a7988",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2014-2018 The Bitcoin Core developers\n+# Copyright (c) 2014-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Run regression test suite."
      },
      {
        "sha": "a44aa5a18e3e00dc0c32577ea224538222da011d",
        "filename": "test/functional/wallet_address_types.py",
        "status": "modified",
        "additions": 29,
        "deletions": 29,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/wallet_address_types.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/wallet_address_types.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_address_types.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2017-2018 The Bitcoin Core developers\n+# Copyright (c) 2017-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test that the wallet can send and receive using all combinations of address types.\n@@ -102,62 +102,62 @@ def get_balances(self, confirmed=True):\n     def test_address(self, node, address, multisig, typ):\n         \"\"\"Run sanity checks on an address.\"\"\"\n         info = self.nodes[node].getaddressinfo(address)\n-        assert(self.nodes[node].validateaddress(address)['isvalid'])\n+        assert self.nodes[node].validateaddress(address)['isvalid']\n         assert_equal(info.get('solvable'), True)\n \n         if not multisig and typ == 'legacy':\n             # P2PKH\n-            assert(not info['isscript'])\n-            assert(not info['iswitness'])\n-            assert('pubkey' in info)\n+            assert not info['isscript']\n+            assert not info['iswitness']\n+            assert 'pubkey' in info\n         elif not multisig and typ == 'p2sh-segwit':\n             # P2SH-P2WPKH\n-            assert(info['isscript'])\n-            assert(not info['iswitness'])\n+            assert info['isscript']\n+            assert not info['iswitness']\n             assert_equal(info['script'], 'witness_v0_keyhash')\n-            assert('pubkey' in info)\n+            assert 'pubkey' in info\n         elif not multisig and typ == 'bech32':\n             # P2WPKH\n-            assert(not info['isscript'])\n-            assert(info['iswitness'])\n+            assert not info['isscript']\n+            assert info['iswitness']\n             assert_equal(info['witness_version'], 0)\n             assert_equal(len(info['witness_program']), 40)\n-            assert('pubkey' in info)\n+            assert 'pubkey' in info\n         elif typ == 'legacy':\n             # P2SH-multisig\n-            assert(info['isscript'])\n+            assert info['isscript']\n             assert_equal(info['script'], 'multisig')\n-            assert(not info['iswitness'])\n-            assert('pubkeys' in info)\n+            assert not info['iswitness']\n+            assert 'pubkeys' in info\n         elif typ == 'p2sh-segwit':\n             # P2SH-P2WSH-multisig\n-            assert(info['isscript'])\n+            assert info['isscript']\n             assert_equal(info['script'], 'witness_v0_scripthash')\n-            assert(not info['iswitness'])\n-            assert(info['embedded']['isscript'])\n+            assert not info['iswitness']\n+            assert info['embedded']['isscript']\n             assert_equal(info['embedded']['script'], 'multisig')\n-            assert(info['embedded']['iswitness'])\n+            assert info['embedded']['iswitness']\n             assert_equal(info['embedded']['witness_version'], 0)\n             assert_equal(len(info['embedded']['witness_program']), 64)\n-            assert('pubkeys' in info['embedded'])\n+            assert 'pubkeys' in info['embedded']\n         elif typ == 'bech32':\n             # P2WSH-multisig\n-            assert(info['isscript'])\n+            assert info['isscript']\n             assert_equal(info['script'], 'multisig')\n-            assert(info['iswitness'])\n+            assert info['iswitness']\n             assert_equal(info['witness_version'], 0)\n             assert_equal(len(info['witness_program']), 64)\n-            assert('pubkeys' in info)\n+            assert 'pubkeys' in info\n         else:\n             # Unknown type\n-            assert(False)\n+            assert False\n \n     def test_desc(self, node, address, multisig, typ, utxo):\n         \"\"\"Run sanity checks on a descriptor reported by getaddressinfo.\"\"\"\n         info = self.nodes[node].getaddressinfo(address)\n-        assert('desc' in info)\n+        assert 'desc' in info\n         assert_equal(info['desc'], utxo['desc'])\n-        assert(self.nodes[node].validateaddress(address)['isvalid'])\n+        assert self.nodes[node].validateaddress(address)['isvalid']\n \n         # Use a ridiculously roundabout way to find the key origin info through\n         # the PSBT logic. However, this does test consistency between the PSBT reported\n@@ -172,11 +172,11 @@ def test_desc(self, node, address, multisig, typ, utxo):\n             key_descs[deriv['pubkey']] = '[' + deriv['master_fingerprint'] + deriv['path'][1:] + ']' + deriv['pubkey']\n \n         # Verify the descriptor checksum against the Python implementation\n-        assert(descsum_check(info['desc']))\n+        assert descsum_check(info['desc'])\n         # Verify that stripping the checksum and recreating it using Python roundtrips\n-        assert(info['desc'] == descsum_create(info['desc'][:-9]))\n+        assert info['desc'] == descsum_create(info['desc'][:-9])\n         # Verify that stripping the checksum and feeding it to getdescriptorinfo roundtrips\n-        assert(info['desc'] == self.nodes[0].getdescriptorinfo(info['desc'][:-9])['descriptor'])\n+        assert info['desc'] == self.nodes[0].getdescriptorinfo(info['desc'][:-9])['descriptor']\n \n         if not multisig and typ == 'legacy':\n             # P2PKH\n@@ -198,7 +198,7 @@ def test_desc(self, node, address, multisig, typ, utxo):\n             assert_equal(info['desc'], descsum_create(\"wsh(multi(2,%s,%s))\" % (key_descs[info['pubkeys'][0]], key_descs[info['pubkeys'][1]])))\n         else:\n             # Unknown type\n-            assert(False)\n+            assert False\n \n     def test_change_output_type(self, node_sender, destinations, expected_type):\n         txid = self.nodes[node_sender].sendmany(dummy=\"\", amounts=dict.fromkeys(destinations, 0.001))"
      },
      {
        "sha": "fc752e5ac0da7087d1f1908fd4911c5306a1caca",
        "filename": "test/functional/wallet_bumpfee.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/wallet_bumpfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/wallet_bumpfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_bumpfee.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2016-2018 The Bitcoin Core developers\n+# Copyright (c) 2016-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the bumpfee RPC.\n@@ -19,7 +19,7 @@\n from test_framework.blocktools import add_witness_commitment, create_block, create_coinbase, send_to_witness\n from test_framework.messages import BIP125_SEQUENCE_NUMBER, CTransaction\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, assert_greater_than, assert_raises_rpc_error, bytes_to_hex_str, connect_nodes_bi, hex_str_to_bytes, sync_mempools\n+from test_framework.util import assert_equal, assert_greater_than, assert_raises_rpc_error, connect_nodes_bi, hex_str_to_bytes, sync_mempools\n \n WALLET_PASSPHRASE = \"test\"\n WALLET_PASSPHRASE_TIMEOUT = 3600\n@@ -298,7 +298,7 @@ def submit_block_with_tx(node, tx):\n     block.hashMerkleRoot = block.calc_merkle_root()\n     add_witness_commitment(block)\n     block.solve()\n-    node.submitblock(bytes_to_hex_str(block.serialize(True)))\n+    node.submitblock(block.serialize(True).hex())\n     return block\n \n "
      },
      {
        "sha": "0b584a0bb2933f01d36f7c141f33217b05f8f1ae",
        "filename": "test/functional/wallet_create_tx.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/wallet_create_tx.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/wallet_create_tx.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_create_tx.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2018 The Bitcoin Core developers\n+# Copyright (c) 2018-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n "
      },
      {
        "sha": "8ec4b98b6e7e13248aa6c1b73597a65af3e812e5",
        "filename": "test/functional/wallet_createwallet.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/wallet_createwallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/wallet_createwallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_createwallet.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2018 The Bitcoin Core developers\n+# Copyright (c) 2018-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test createwallet arguments.\n@@ -40,8 +40,8 @@ def run_test(self):\n         privkey = w0.dumpprivkey(addr)\n         assert_raises_rpc_error(-4, 'Cannot import private keys to a wallet with private keys disabled', w1.importprivkey, privkey)\n         result = w1.importmulti([{'scriptPubKey': {'address': addr}, 'timestamp': 'now', 'keys': [privkey]}])\n-        assert(not result[0]['success'])\n-        assert('warning' not in result[0])\n+        assert not result[0]['success']\n+        assert 'warning' not in result[0]\n         assert_equal(result[0]['error']['code'], -4)\n         assert_equal(result[0]['error']['message'], 'Cannot import private keys to a wallet with private keys disabled')\n "
      },
      {
        "sha": "7c2ec56b5aaba57622633df010a7d24a856a0feb",
        "filename": "test/functional/wallet_disable.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/wallet_disable.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/wallet_disable.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_disable.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2015-2018 The Bitcoin Core developers\n+# Copyright (c) 2015-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test a node with the -disablewallet option.\n@@ -21,9 +21,9 @@ def run_test (self):\n         # Make sure wallet is really disabled\n         assert_raises_rpc_error(-32601, 'Method not found', self.nodes[0].getwalletinfo)\n         x = self.nodes[0].validateaddress('3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy')\n-        assert(x['isvalid'] == False)\n+        assert x['isvalid'] == False\n         x = self.nodes[0].validateaddress('mneYUmWYsuk7kySiURxCi3AGxrAqZxLgPZ')\n-        assert(x['isvalid'] == True)\n+        assert x['isvalid'] == True\n \n         # Checking mining to an address without a wallet. Generating to a valid address should succeed\n         # but generating to an invalid address will fail."
      },
      {
        "sha": "53edf710b9a2ff88107062c033541163233a7480",
        "filename": "test/functional/wallet_dump.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/wallet_dump.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/wallet_dump.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_dump.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2016-2018 The Bitcoin Core developers\n+# Copyright (c) 2016-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the dumpwallet RPC.\"\"\"\n@@ -46,10 +46,10 @@ def read_dump(file_name, addrs, script_addrs, hd_master_addr_old):\n                 keypath = None\n                 if keytype == \"inactivehdseed=1\":\n                     # ensure the old master is still available\n-                    assert (hd_master_addr_old == addr)\n+                    assert hd_master_addr_old == addr\n                 elif keytype == \"hdseed=1\":\n                     # ensure we have generated a new hd master key\n-                    assert (hd_master_addr_old != addr)\n+                    assert hd_master_addr_old != addr\n                     hd_master_addr_ret = addr\n                 elif keytype == \"script=1\":\n                     # scripts don't have keypaths"
      },
      {
        "sha": "97172d8b82d1d9529941906e01d7117f33f6ca5a",
        "filename": "test/functional/wallet_hd.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/wallet_hd.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/wallet_hd.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_hd.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2016-2018 The Bitcoin Core developers\n+# Copyright (c) 2016-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test Hierarchical Deterministic wallet function.\"\"\""
      },
      {
        "sha": "5bfbaa2f0b602457a05c35ef0256bda41a49ec5c",
        "filename": "test/functional/wallet_importmulti.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/wallet_importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/wallet_importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importmulti.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2014-2018 The Bitcoin Core developers\n+# Copyright (c) 2014-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the importmulti RPC.\n@@ -25,7 +25,6 @@\n     assert_equal,\n     assert_greater_than,\n     assert_raises_rpc_error,\n-    bytes_to_hex_str,\n )\n from test_framework.wallet_util import (\n     get_key,\n@@ -127,7 +126,7 @@ def run_test(self):\n \n         # Nonstandard scriptPubKey + !internal\n         self.log.info(\"Should not import a nonstandard scriptPubKey without internal flag\")\n-        nonstandardScriptPubKey = key.p2pkh_script + bytes_to_hex_str(CScript([OP_NOP]))\n+        nonstandardScriptPubKey = key.p2pkh_script + CScript([OP_NOP]).hex()\n         key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": nonstandardScriptPubKey,\n                                \"timestamp\": \"now\"},"
      },
      {
        "sha": "e3aeb61197be5e642835b5d3ffd73014611e0788",
        "filename": "test/functional/wallet_keypool.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/wallet_keypool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/wallet_keypool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_keypool.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2014-2018 The Bitcoin Core developers\n+# Copyright (c) 2014-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the wallet keypool and interaction with wallet encryption/locking.\"\"\"\n@@ -21,16 +21,16 @@ def run_test(self):\n         addr_before_encrypting = nodes[0].getnewaddress()\n         addr_before_encrypting_data = nodes[0].getaddressinfo(addr_before_encrypting)\n         wallet_info_old = nodes[0].getwalletinfo()\n-        assert(addr_before_encrypting_data['hdseedid'] == wallet_info_old['hdseedid'])\n+        assert addr_before_encrypting_data['hdseedid'] == wallet_info_old['hdseedid']\n \n         # Encrypt wallet and wait to terminate\n         nodes[0].encryptwallet('test')\n         # Keep creating keys\n         addr = nodes[0].getnewaddress()\n         addr_data = nodes[0].getaddressinfo(addr)\n         wallet_info = nodes[0].getwalletinfo()\n-        assert(addr_before_encrypting_data['hdseedid'] != wallet_info['hdseedid'])\n-        assert(addr_data['hdseedid'] == wallet_info['hdseedid'])\n+        assert addr_before_encrypting_data['hdseedid'] != wallet_info['hdseedid']\n+        assert addr_data['hdseedid'] == wallet_info['hdseedid']\n         assert_raises_rpc_error(-12, \"Error: Keypool ran out, please call keypoolrefill first\", nodes[0].getnewaddress)\n \n         # put six (plus 2) new keys in the keypool (100% external-, +100% internal-keys, 1 in min)\n@@ -59,7 +59,7 @@ def run_test(self):\n         addr.add(nodes[0].getnewaddress())\n         addr.add(nodes[0].getnewaddress())\n         addr.add(nodes[0].getnewaddress())\n-        assert(len(addr) == 6)\n+        assert len(addr) == 6\n         # the next one should fail\n         assert_raises_rpc_error(-12, \"Error: Keypool ran out, please call keypoolrefill first\", nodes[0].getnewaddress)\n "
      },
      {
        "sha": "e099bab6a3d7315d7fab7903d46f8c9f575f2fb3",
        "filename": "test/functional/wallet_keypool_topup.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/wallet_keypool_topup.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/wallet_keypool_topup.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_keypool_topup.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2017-2018 The Bitcoin Core developers\n+# Copyright (c) 2017-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test HD Wallet keypool restore function.\n@@ -55,11 +55,11 @@ def run_test(self):\n             # Make sure we're creating the outputs we expect\n             address_details = self.nodes[idx].validateaddress(addr_extpool)\n             if i == 0:\n-                assert(not address_details[\"isscript\"] and not address_details[\"iswitness\"])\n+                assert not address_details[\"isscript\"] and not address_details[\"iswitness\"]\n             elif i == 1:\n-                assert(address_details[\"isscript\"] and not address_details[\"iswitness\"])\n+                assert address_details[\"isscript\"] and not address_details[\"iswitness\"]\n             else:\n-                assert(not address_details[\"isscript\"] and address_details[\"iswitness\"])\n+                assert not address_details[\"isscript\"] and address_details[\"iswitness\"]\n \n \n             self.log.info(\"Send funds to wallet\")"
      },
      {
        "sha": "f8268fab352acee5e0cd179623f4c8fd10da14b3",
        "filename": "test/functional/wallet_listtransactions.py",
        "status": "modified",
        "additions": 9,
        "deletions": 10,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/wallet_listtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/wallet_listtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_listtransactions.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2014-2018 The Bitcoin Core developers\n+# Copyright (c) 2014-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the listtransactions API.\"\"\"\n@@ -11,7 +11,6 @@\n from test_framework.util import (\n     assert_array_result,\n     assert_equal,\n-    bytes_to_hex_str,\n     hex_str_to_bytes,\n     sync_mempools,\n )\n@@ -126,7 +125,7 @@ def get_unconfirmed_utxo_entry(node, txid_to_match):\n \n         # 1. Chain a few transactions that don't opt-in.\n         txid_1 = self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 1)\n-        assert(not is_opt_in(self.nodes[0], txid_1))\n+        assert not is_opt_in(self.nodes[0], txid_1)\n         assert_array_result(self.nodes[0].listtransactions(), {\"txid\": txid_1}, {\"bip125-replaceable\": \"no\"})\n         sync_mempools(self.nodes)\n         assert_array_result(self.nodes[1].listtransactions(), {\"txid\": txid_1}, {\"bip125-replaceable\": \"no\"})\n@@ -146,7 +145,7 @@ def get_unconfirmed_utxo_entry(node, txid_to_match):\n         txid_2 = self.nodes[1].sendrawtransaction(tx2_signed)\n \n         # ...and check the result\n-        assert(not is_opt_in(self.nodes[1], txid_2))\n+        assert not is_opt_in(self.nodes[1], txid_2)\n         assert_array_result(self.nodes[1].listtransactions(), {\"txid\": txid_2}, {\"bip125-replaceable\": \"no\"})\n         sync_mempools(self.nodes)\n         assert_array_result(self.nodes[0].listtransactions(), {\"txid\": txid_2}, {\"bip125-replaceable\": \"no\"})\n@@ -158,11 +157,11 @@ def get_unconfirmed_utxo_entry(node, txid_to_match):\n         tx3 = self.nodes[0].createrawtransaction(inputs, outputs)\n         tx3_modified = tx_from_hex(tx3)\n         tx3_modified.vin[0].nSequence = 0\n-        tx3 = bytes_to_hex_str(tx3_modified.serialize())\n+        tx3 = tx3_modified.serialize().hex()\n         tx3_signed = self.nodes[0].signrawtransactionwithwallet(tx3)['hex']\n         txid_3 = self.nodes[0].sendrawtransaction(tx3_signed)\n \n-        assert(is_opt_in(self.nodes[0], txid_3))\n+        assert is_opt_in(self.nodes[0], txid_3)\n         assert_array_result(self.nodes[0].listtransactions(), {\"txid\": txid_3}, {\"bip125-replaceable\": \"yes\"})\n         sync_mempools(self.nodes)\n         assert_array_result(self.nodes[1].listtransactions(), {\"txid\": txid_3}, {\"bip125-replaceable\": \"yes\"})\n@@ -176,18 +175,18 @@ def get_unconfirmed_utxo_entry(node, txid_to_match):\n         tx4_signed = self.nodes[1].signrawtransactionwithwallet(tx4)[\"hex\"]\n         txid_4 = self.nodes[1].sendrawtransaction(tx4_signed)\n \n-        assert(not is_opt_in(self.nodes[1], txid_4))\n+        assert not is_opt_in(self.nodes[1], txid_4)\n         assert_array_result(self.nodes[1].listtransactions(), {\"txid\": txid_4}, {\"bip125-replaceable\": \"yes\"})\n         sync_mempools(self.nodes)\n         assert_array_result(self.nodes[0].listtransactions(), {\"txid\": txid_4}, {\"bip125-replaceable\": \"yes\"})\n \n         # Replace tx3, and check that tx4 becomes unknown\n         tx3_b = tx3_modified\n         tx3_b.vout[0].nValue -= int(Decimal(\"0.004\") * COIN)  # bump the fee\n-        tx3_b = bytes_to_hex_str(tx3_b.serialize())\n+        tx3_b = tx3_b.serialize().hex()\n         tx3_b_signed = self.nodes[0].signrawtransactionwithwallet(tx3_b)['hex']\n         txid_3b = self.nodes[0].sendrawtransaction(tx3_b_signed, True)\n-        assert(is_opt_in(self.nodes[0], txid_3b))\n+        assert is_opt_in(self.nodes[0], txid_3b)\n \n         assert_array_result(self.nodes[0].listtransactions(), {\"txid\": txid_4}, {\"bip125-replaceable\": \"unknown\"})\n         sync_mempools(self.nodes)\n@@ -203,7 +202,7 @@ def get_unconfirmed_utxo_entry(node, txid_to_match):\n \n         # After mining a transaction, it's no longer BIP125-replaceable\n         self.nodes[0].generate(1)\n-        assert(txid_3b not in self.nodes[0].getrawmempool())\n+        assert txid_3b not in self.nodes[0].getrawmempool()\n         assert_equal(self.nodes[0].gettransaction(txid_3b)[\"bip125-replaceable\"], \"no\")\n         assert_equal(self.nodes[0].gettransaction(txid_4)[\"bip125-replaceable\"], \"unknown\")\n "
      },
      {
        "sha": "984ffab5a437f99b167810f238b78e46ce1c34f1",
        "filename": "test/functional/wallet_multiwallet.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/wallet_multiwallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/wallet_multiwallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_multiwallet.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2017-2018 The Bitcoin Core developers\n+# Copyright (c) 2017-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test multiwallet."
      },
      {
        "sha": "af1b321a07b29ed9cc76241e0f7f992d79363d1a",
        "filename": "test/functional/wallet_txn_clone.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/wallet_txn_clone.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/wallet_txn_clone.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_txn_clone.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2014-2018 The Bitcoin Core developers\n+# Copyright (c) 2014-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the wallet accounts properly when there are cloned transactions with malleated scriptsigs.\"\"\"\n@@ -8,7 +8,6 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n-    bytes_to_hex_str as b2x,\n     connect_nodes,\n     disconnect_nodes,\n     sync_blocks,\n@@ -82,7 +81,7 @@ def run_test(self):\n \n         # Use a different signature hash type to sign.  This creates an equivalent but malleated clone.\n         # Don't send the clone anywhere yet\n-        tx1_clone = self.nodes[0].signrawtransactionwithwallet(b2x(clone_tx.serialize()), None, \"ALL|ANYONECANPAY\")\n+        tx1_clone = self.nodes[0].signrawtransactionwithwallet(clone_tx.serialize().hex(), None, \"ALL|ANYONECANPAY\")\n         assert_equal(tx1_clone[\"complete\"], True)\n \n         # Have node0 mine a block, if requested:"
      },
      {
        "sha": "8dcfd74f56098447aa6c42194335fbc88264420d",
        "filename": "test/functional/wallet_txn_doublespend.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/wallet_txn_doublespend.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/functional/wallet_txn_doublespend.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_txn_doublespend.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2014-2018 The Bitcoin Core developers\n+# Copyright (c) 2014-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the wallet accounts properly when there is a double-spend conflict.\"\"\""
      },
      {
        "sha": "3b05d5055cf1da072017458e0a698a487da1dafe",
        "filename": "test/lint/check-doc.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/lint/check-doc.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/lint/check-doc.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/check-doc.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2015-2018 The Bitcoin Core developers\n+# Copyright (c) 2015-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n "
      },
      {
        "sha": "224e62f04abdb5c8d5f55ac65f975f560e52f756",
        "filename": "test/lint/lint-format-strings.py",
        "status": "modified",
        "additions": 28,
        "deletions": 28,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/lint/lint-format-strings.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77363e9da04882063a1a4fb465cf5f40c9f7e83f/test/lint/lint-format-strings.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-format-strings.py?ref=77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "patch": "@@ -1,6 +1,6 @@\n #!/usr/bin/env python3\n #\n-# Copyright (c) 2018 The Bitcoin Core developers\n+# Copyright (c) 2018-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n #\n@@ -39,7 +39,7 @@ def parse_function_calls(function_name, source_code):\n     >>> len(parse_function_calls(\"foo\", \"#define FOO foo();\"))\n     0\n     \"\"\"\n-    assert(type(function_name) is str and type(source_code) is str and function_name)\n+    assert type(function_name) is str and type(source_code) is str and function_name\n     lines = [re.sub(\"// .*\", \" \", line).strip()\n              for line in source_code.split(\"\\n\")\n              if not line.strip().startswith(\"#\")]\n@@ -53,7 +53,7 @@ def normalize(s):\n     >>> normalize(\"  /* nothing */   foo\\tfoo  /* bar */  foo     \")\n     'foo foo foo'\n     \"\"\"\n-    assert(type(s) is str)\n+    assert type(s) is str\n     s = s.replace(\"\\n\", \" \")\n     s = s.replace(\"\\t\", \" \")\n     s = re.sub(\"/\\*.*?\\*/\", \" \", s)\n@@ -77,7 +77,7 @@ def escape(s):\n     >>> escape(r'foo \\\\t foo \\\\n foo \\\\\\\\ foo \\\\ foo \\\\\"bar\\\\\"')\n     'foo [escaped-tab] foo [escaped-newline] foo \\\\\\\\\\\\\\\\ foo \\\\\\\\ foo [escaped-quote]bar[escaped-quote]'\n     \"\"\"\n-    assert(type(s) is str)\n+    assert type(s) is str\n     for raw_value, escaped_value in ESCAPE_MAP.items():\n         s = s.replace(raw_value, escaped_value)\n     return s\n@@ -92,7 +92,7 @@ def unescape(s):\n     >>> unescape(\"foo [escaped-tab] foo [escaped-newline] foo \\\\\\\\\\\\\\\\ foo \\\\\\\\ foo [escaped-quote]bar[escaped-quote]\")\n     'foo \\\\\\\\t foo \\\\\\\\n foo \\\\\\\\\\\\\\\\ foo \\\\\\\\ foo \\\\\\\\\"bar\\\\\\\\\"'\n     \"\"\"\n-    assert(type(s) is str)\n+    assert type(s) is str\n     for raw_value, escaped_value in ESCAPE_MAP.items():\n         s = s.replace(escaped_value, raw_value)\n     return s\n@@ -151,10 +151,10 @@ def parse_function_call_and_arguments(function_name, function_call):\n     >>> parse_function_call_and_arguments(\"strprintf\", 'strprintf(\"%s (%d)\", foo>foo<1,2>(1,2),err)');\n     ['strprintf(', '\"%s (%d)\",', ' foo>foo<1,2>(1,2),', 'err', ')']\n     \"\"\"\n-    assert(type(function_name) is str and type(function_call) is str and function_name)\n+    assert type(function_name) is str and type(function_call) is str and function_name\n     remaining = normalize(escape(function_call))\n     expected_function_call = \"{}(\".format(function_name)\n-    assert(remaining.startswith(expected_function_call))\n+    assert remaining.startswith(expected_function_call)\n     parts = [expected_function_call]\n     remaining = remaining[len(expected_function_call):]\n     open_parentheses = 1\n@@ -213,7 +213,7 @@ def parse_string_content(argument):\n     >>> parse_string_content('1 2 3')\n     ''\n     \"\"\"\n-    assert(type(argument) is str)\n+    assert type(argument) is str\n     string_content = \"\"\n     in_string = False\n     for char in normalize(escape(argument)):\n@@ -240,7 +240,7 @@ def count_format_specifiers(format_string):\n     >>> count_format_specifiers(\"foo %d bar %i foo %% foo %*d foo\")\n     4\n     \"\"\"\n-    assert(type(format_string) is str)\n+    assert type(format_string) is str\n     format_string = format_string.replace('%%', 'X')\n     n = 0\n     in_specifier = False\n@@ -262,27 +262,27 @@ def main():\n     parser.add_argument(\"--skip-arguments\", type=int, help=\"number of arguments before the format string \"\n                         \"argument (e.g. 1 in the case of fprintf)\", default=0)\n     parser.add_argument(\"function_name\", help=\"function name (e.g. fprintf)\", default=None)\n-    parser.add_argument(\"file\", type=argparse.FileType(\"r\", encoding=\"utf-8\"), nargs=\"*\", help=\"C++ source code file (e.g. foo.cpp)\")\n+    parser.add_argument(\"file\", nargs=\"*\", help=\"C++ source code file (e.g. foo.cpp)\")\n     args = parser.parse_args()\n-\n     exit_code = 0\n-    for f in args.file:\n-        for function_call_str in parse_function_calls(args.function_name, f.read()):\n-            parts = parse_function_call_and_arguments(args.function_name, function_call_str)\n-            relevant_function_call_str = unescape(\"\".join(parts))[:512]\n-            if (f.name, relevant_function_call_str) in FALSE_POSITIVES:\n-                continue\n-            if len(parts) < 3 + args.skip_arguments:\n-                exit_code = 1\n-                print(\"{}: Could not parse function call string \\\"{}(...)\\\": {}\".format(f.name, args.function_name, relevant_function_call_str))\n-                continue\n-            argument_count = len(parts) - 3 - args.skip_arguments\n-            format_str = parse_string_content(parts[1 + args.skip_arguments])\n-            format_specifier_count = count_format_specifiers(format_str)\n-            if format_specifier_count != argument_count:\n-                exit_code = 1\n-                print(\"{}: Expected {} argument(s) after format string but found {} argument(s): {}\".format(f.name, format_specifier_count, argument_count, relevant_function_call_str))\n-                continue\n+    for filename in args.file:\n+        with open(filename, \"r\", encoding=\"utf-8\") as f:\n+            for function_call_str in parse_function_calls(args.function_name, f.read()):\n+                parts = parse_function_call_and_arguments(args.function_name, function_call_str)\n+                relevant_function_call_str = unescape(\"\".join(parts))[:512]\n+                if (f.name, relevant_function_call_str) in FALSE_POSITIVES:\n+                    continue\n+                if len(parts) < 3 + args.skip_arguments:\n+                    exit_code = 1\n+                    print(\"{}: Could not parse function call string \\\"{}(...)\\\": {}\".format(f.name, args.function_name, relevant_function_call_str))\n+                    continue\n+                argument_count = len(parts) - 3 - args.skip_arguments\n+                format_str = parse_string_content(parts[1 + args.skip_arguments])\n+                format_specifier_count = count_format_specifiers(format_str)\n+                if format_specifier_count != argument_count:\n+                    exit_code = 1\n+                    print(\"{}: Expected {} argument(s) after format string but found {} argument(s): {}\".format(f.name, format_specifier_count, argument_count, relevant_function_call_str))\n+                    continue\n     sys.exit(exit_code)\n \n "
      }
    ]
  },
  {
    "sha": "c4445732188a594c67721d5b8392608f8f64b121",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNDQ0NTczMjE4OGE1OTRjNjc3MjFkNWI4MzkyNjA4ZjhmNjRiMTIx",
    "commit": {
      "author": {
        "name": "Rojar Smith",
        "email": "rojarsmith@gmail.com",
        "date": "2019-03-10T05:36:47Z"
      },
      "committer": {
        "name": "Rojar Smith",
        "email": "rojarsmith@gmail.com",
        "date": "2019-03-10T06:19:26Z"
      },
      "message": "Add auto select custom fee when smart fee not initialized.",
      "tree": {
        "sha": "732cb90af3d9bf4a6b3b2615d1abc5ba5b7b6d32",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/732cb90af3d9bf4a6b3b2615d1abc5ba5b7b6d32"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c4445732188a594c67721d5b8392608f8f64b121",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c4445732188a594c67721d5b8392608f8f64b121",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c4445732188a594c67721d5b8392608f8f64b121",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c4445732188a594c67721d5b8392608f8f64b121/comments",
    "author": {
      "login": "rojarsmith",
      "id": 10322636,
      "node_id": "MDQ6VXNlcjEwMzIyNjM2",
      "avatar_url": "https://avatars.githubusercontent.com/u/10322636?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rojarsmith",
      "html_url": "https://github.com/rojarsmith",
      "followers_url": "https://api.github.com/users/rojarsmith/followers",
      "following_url": "https://api.github.com/users/rojarsmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/rojarsmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rojarsmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rojarsmith/subscriptions",
      "organizations_url": "https://api.github.com/users/rojarsmith/orgs",
      "repos_url": "https://api.github.com/users/rojarsmith/repos",
      "events_url": "https://api.github.com/users/rojarsmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rojarsmith/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "rojarsmith",
      "id": 10322636,
      "node_id": "MDQ6VXNlcjEwMzIyNjM2",
      "avatar_url": "https://avatars.githubusercontent.com/u/10322636?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rojarsmith",
      "html_url": "https://github.com/rojarsmith",
      "followers_url": "https://api.github.com/users/rojarsmith/followers",
      "following_url": "https://api.github.com/users/rojarsmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/rojarsmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rojarsmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rojarsmith/subscriptions",
      "organizations_url": "https://api.github.com/users/rojarsmith/orgs",
      "repos_url": "https://api.github.com/users/rojarsmith/repos",
      "events_url": "https://api.github.com/users/rojarsmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rojarsmith/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "257f750cd986641afe04316ed0b22b646b56b60b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/257f750cd986641afe04316ed0b22b646b56b60b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/257f750cd986641afe04316ed0b22b646b56b60b"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 1,
      "deletions": 0
    },
    "files": [
      {
        "sha": "2febdd1ccdc7f42516235d5ebb3c8164b667dd58",
        "filename": "src/qt/sendcoinsdialog.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c4445732188a594c67721d5b8392608f8f64b121/src/qt/sendcoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c4445732188a594c67721d5b8392608f8f64b121/src/qt/sendcoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.cpp?ref=c4445732188a594c67721d5b8392608f8f64b121",
        "patch": "@@ -697,6 +697,7 @@ void SendCoinsDialog::updateSmartFeeLabel()\n         QColor warning_colour(255 - (lightness / 5), 176 - (lightness / 3), 48 - (lightness / 14));\n         ui->fallbackFeeWarningLabel->setStyleSheet(\"QLabel { color: \" + warning_colour.name() + \"; }\");\n         ui->fallbackFeeWarningLabel->setIndent(QFontMetrics(ui->fallbackFeeWarningLabel->font()).width(\"x\"));\n+        ui->radioCustomFee->setChecked(true);\n     }\n     else\n     {"
      }
    ]
  },
  {
    "sha": "41de5b8f9af61df34774cec5080f242d1ca752bc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MWRlNWI4ZjlhZjYxZGYzNDc3NGNlYzUwODBmMjQyZDFjYTc1MmJj",
    "commit": {
      "author": {
        "name": "Rojar Smith",
        "email": "rojarsmith@gmail.com",
        "date": "2019-03-10T06:28:28Z"
      },
      "committer": {
        "name": "Rojar Smith",
        "email": "rojarsmith@gmail.com",
        "date": "2019-03-10T06:28:28Z"
      },
      "message": "Merge branch 'master' into mydev",
      "tree": {
        "sha": "fc9cc111d8f4ac5e06f64c2cd3f7eca6485d789c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fc9cc111d8f4ac5e06f64c2cd3f7eca6485d789c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/41de5b8f9af61df34774cec5080f242d1ca752bc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/41de5b8f9af61df34774cec5080f242d1ca752bc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/41de5b8f9af61df34774cec5080f242d1ca752bc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/41de5b8f9af61df34774cec5080f242d1ca752bc/comments",
    "author": {
      "login": "rojarsmith",
      "id": 10322636,
      "node_id": "MDQ6VXNlcjEwMzIyNjM2",
      "avatar_url": "https://avatars.githubusercontent.com/u/10322636?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rojarsmith",
      "html_url": "https://github.com/rojarsmith",
      "followers_url": "https://api.github.com/users/rojarsmith/followers",
      "following_url": "https://api.github.com/users/rojarsmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/rojarsmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rojarsmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rojarsmith/subscriptions",
      "organizations_url": "https://api.github.com/users/rojarsmith/orgs",
      "repos_url": "https://api.github.com/users/rojarsmith/repos",
      "events_url": "https://api.github.com/users/rojarsmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rojarsmith/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "rojarsmith",
      "id": 10322636,
      "node_id": "MDQ6VXNlcjEwMzIyNjM2",
      "avatar_url": "https://avatars.githubusercontent.com/u/10322636?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rojarsmith",
      "html_url": "https://github.com/rojarsmith",
      "followers_url": "https://api.github.com/users/rojarsmith/followers",
      "following_url": "https://api.github.com/users/rojarsmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/rojarsmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rojarsmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rojarsmith/subscriptions",
      "organizations_url": "https://api.github.com/users/rojarsmith/orgs",
      "repos_url": "https://api.github.com/users/rojarsmith/repos",
      "events_url": "https://api.github.com/users/rojarsmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rojarsmith/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c4445732188a594c67721d5b8392608f8f64b121",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c4445732188a594c67721d5b8392608f8f64b121",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c4445732188a594c67721d5b8392608f8f64b121"
      },
      {
        "sha": "77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/77363e9da04882063a1a4fb465cf5f40c9f7e83f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/77363e9da04882063a1a4fb465cf5f40c9f7e83f"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 1,
      "deletions": 0
    },
    "files": [
      {
        "sha": "a1f6c1db62cacabd8689769eb522716913c5a4d4",
        "filename": "share/genbuild.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/41de5b8f9af61df34774cec5080f242d1ca752bc/share/genbuild.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/41de5b8f9af61df34774cec5080f242d1ca752bc/share/genbuild.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/genbuild.sh?ref=41de5b8f9af61df34774cec5080f242d1ca752bc",
        "patch": "@@ -31,6 +31,7 @@ if [ \"${BITCOIN_GENBUILD_NO_GIT}\" != \"1\" -a -e \"$(which git 2>/dev/null)\" -a \"$(\n     # if latest commit is tagged and not dirty, then override using the tag name\n     RAWDESC=$(git describe --abbrev=0 2>/dev/null)\n     if [ \"$(git rev-parse HEAD)\" = \"$(git rev-list -1 $RAWDESC 2>/dev/null)\" ]; then\n+        git checkout .\n         git diff-index --quiet HEAD -- && DESC=$RAWDESC\n     fi\n "
      }
    ]
  }
]