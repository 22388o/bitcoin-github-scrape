[
  {
    "sha": "fd6580e405699ccb051fd2a34525e48d3253673d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZDY1ODBlNDA1Njk5Y2NiMDUxZmQyYTM0NTI1ZTQ4ZDMyNTM2NzNk",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-12-04T02:49:22Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-09T05:10:46Z"
      },
      "message": "[refactor] txmempool: split epoch logic into class",
      "tree": {
        "sha": "e0812c48cdf0dbb5222e69b9e5ab764a9a115bbf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e0812c48cdf0dbb5222e69b9e5ab764a9a115bbf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fd6580e405699ccb051fd2a34525e48d3253673d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fd6580e405699ccb051fd2a34525e48d3253673d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fd6580e405699ccb051fd2a34525e48d3253673d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fd6580e405699ccb051fd2a34525e48d3253673d/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b09ad737eef63ee527083d9a5fafea4c2237470b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b09ad737eef63ee527083d9a5fafea4c2237470b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b09ad737eef63ee527083d9a5fafea4c2237470b"
      }
    ],
    "stats": {
      "total": 170,
      "additions": 107,
      "deletions": 63
    },
    "files": [
      {
        "sha": "3b64d4a1dfacfbfe994c3ebfe7c07dcecf1a337f",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd6580e405699ccb051fd2a34525e48d3253673d/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd6580e405699ccb051fd2a34525e48d3253673d/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=fd6580e405699ccb051fd2a34525e48d3253673d",
        "patch": "@@ -231,6 +231,7 @@ BITCOIN_CORE_H = \\\n   util/bip32.h \\\n   util/bytevectorhash.h \\\n   util/check.h \\\n+  util/epochguard.h \\\n   util/error.h \\\n   util/fees.h \\\n   util/golombrice.h \\"
      },
      {
        "sha": "773149ae9790b270325e7f3ae03d52f0cae8569a",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 21,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd6580e405699ccb051fd2a34525e48d3253673d/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd6580e405699ccb051fd2a34525e48d3253673d/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=fd6580e405699ccb051fd2a34525e48d3253673d",
        "patch": "@@ -23,7 +23,7 @@ CTxMemPoolEntry::CTxMemPoolEntry(const CTransactionRef& _tx, const CAmount& _nFe\n                                  int64_t _nTime, unsigned int _entryHeight,\n                                  bool _spendsCoinbase, int64_t _sigOpsCost, LockPoints lp)\n     : tx(_tx), nFee(_nFee), nTxWeight(GetTransactionWeight(*tx)), nUsageSize(RecursiveDynamicUsage(tx)), nTime(_nTime), entryHeight(_entryHeight),\n-    spendsCoinbase(_spendsCoinbase), sigOpCost(_sigOpsCost), lockPoints(lp), m_epoch(0)\n+    spendsCoinbase(_spendsCoinbase), sigOpCost(_sigOpsCost), lockPoints(lp)\n {\n     nCountWithDescendants = 1;\n     nSizeWithDescendants = GetTxSize();\n@@ -132,7 +132,7 @@ void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<uint256> &vHashes\n         // include them, and update their CTxMemPoolEntry::m_parents to include this tx.\n         // we cache the in-mempool children to avoid duplicate updates\n         {\n-            const auto epoch = GetFreshEpoch();\n+            WITH_FRESH_EPOCH(m_epoch);\n             for (; iter != mapNextTx.end() && iter->first->hash == hash; ++iter) {\n                 const uint256 &childHash = iter->second->GetHash();\n                 txiter childIter = mapTx.find(childHash);\n@@ -1117,22 +1117,3 @@ void CTxMemPool::SetIsLoaded(bool loaded)\n     LOCK(cs);\n     m_is_loaded = loaded;\n }\n-\n-\n-CTxMemPool::EpochGuard CTxMemPool::GetFreshEpoch() const\n-{\n-    return EpochGuard(*this);\n-}\n-CTxMemPool::EpochGuard::EpochGuard(const CTxMemPool& in) : pool(in)\n-{\n-    assert(!pool.m_has_epoch_guard);\n-    ++pool.m_epoch;\n-    pool.m_has_epoch_guard = true;\n-}\n-\n-CTxMemPool::EpochGuard::~EpochGuard()\n-{\n-    // prevents stale results being used\n-    ++pool.m_epoch;\n-    pool.m_has_epoch_guard = false;\n-}"
      },
      {
        "sha": "7b8fe28ad74cbd7e72f6bfcbafc479570bb38e62",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 13,
        "deletions": 42,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd6580e405699ccb051fd2a34525e48d3253673d/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd6580e405699ccb051fd2a34525e48d3253673d/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=fd6580e405699ccb051fd2a34525e48d3253673d",
        "patch": "@@ -21,6 +21,7 @@\n #include <primitives/transaction.h>\n #include <random.h>\n #include <sync.h>\n+#include <util/epochguard.h>\n #include <util/hasher.h>\n \n #include <boost/multi_index_container.hpp>\n@@ -63,6 +64,7 @@ struct CompareIteratorByHash {\n         return a->GetTx().GetHash() < b->GetTx().GetHash();\n     }\n };\n+\n /** \\class CTxMemPoolEntry\n  *\n  * CTxMemPoolEntry stores data about the corresponding transaction, as well\n@@ -155,7 +157,7 @@ class CTxMemPoolEntry\n     Children& GetMemPoolChildren() const { return m_children; }\n \n     mutable size_t vTxHashesIdx; //!< Index in mempool's vTxHashes\n-    mutable uint64_t m_epoch; //!< epoch when last touched, useful for graph algorithms\n+    mutable Epoch::Marker m_epoch_marker; //!< epoch when last touched, useful for graph algorithms\n };\n \n // Helpers for modifying CTxMemPool::mapTx, which is a boost multi_index.\n@@ -485,8 +487,7 @@ class CTxMemPool\n     mutable int64_t lastRollingFeeUpdate;\n     mutable bool blockSinceLastRollingFeeBump;\n     mutable double rollingMinimumFeeRate; //!< minimum fee to get into the pool, decreases exponentially\n-    mutable uint64_t m_epoch{0};\n-    mutable bool m_has_epoch_guard{false};\n+    mutable Epoch m_epoch GUARDED_BY(cs);\n \n     // In-memory counter for external mempool tracking purposes.\n     // This number is incremented once every time a transaction\n@@ -665,7 +666,7 @@ class CTxMemPool\n      *  for).  Note: vHashesToUpdate should be the set of transactions from the\n      *  disconnected block that have been accepted back into the mempool.\n      */\n-    void UpdateTransactionsFromBlock(const std::vector<uint256>& vHashesToUpdate) EXCLUSIVE_LOCKS_REQUIRED(cs, cs_main);\n+    void UpdateTransactionsFromBlock(const std::vector<uint256>& vHashesToUpdate) EXCLUSIVE_LOCKS_REQUIRED(cs, cs_main) LOCKS_EXCLUDED(m_epoch);\n \n     /** Try to calculate all in-mempool ancestors of entry.\n      *  (these are all calculated including the tx itself)\n@@ -826,52 +827,22 @@ class CTxMemPool\n      */\n     void removeUnchecked(txiter entry, MemPoolRemovalReason reason) EXCLUSIVE_LOCKS_REQUIRED(cs);\n public:\n-    /** EpochGuard: RAII-style guard for using epoch-based graph traversal algorithms.\n-     *     When walking ancestors or descendants, we generally want to avoid\n-     * visiting the same transactions twice. Some traversal algorithms use\n-     * std::set (or setEntries) to deduplicate the transaction we visit.\n-     * However, use of std::set is algorithmically undesirable because it both\n-     * adds an asymptotic factor of O(log n) to traverals cost and triggers O(n)\n-     * more dynamic memory allocations.\n-     *     In many algorithms we can replace std::set with an internal mempool\n-     * counter to track the time (or, \"epoch\") that we began a traversal, and\n-     * check + update a per-transaction epoch for each transaction we look at to\n-     * determine if that transaction has not yet been visited during the current\n-     * traversal's epoch.\n-     *     Algorithms using std::set can be replaced on a one by one basis.\n-     * Both techniques are not fundamentally incompatible across the codebase.\n-     * Generally speaking, however, the remaining use of std::set for mempool\n-     * traversal should be viewed as a TODO for replacement with an epoch based\n-     * traversal, rather than a preference for std::set over epochs in that\n-     * algorithm.\n-     */\n-    class EpochGuard {\n-        const CTxMemPool& pool;\n-        public:\n-        explicit EpochGuard(const CTxMemPool& in);\n-        ~EpochGuard();\n-    };\n-    // N.B. GetFreshEpoch modifies mutable state via the EpochGuard construction\n-    // (and later destruction)\n-    EpochGuard GetFreshEpoch() const EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n     /** visited marks a CTxMemPoolEntry as having been traversed\n-     * during the lifetime of the most recently created EpochGuard\n+     * during the lifetime of the most recently created Epoch::Guard\n      * and returns false if we are the first visitor, true otherwise.\n      *\n-     * An EpochGuard must be held when visited is called or an assert will be\n+     * An Epoch::Guard must be held when visited is called or an assert will be\n      * triggered.\n      *\n      */\n-    bool visited(txiter it) const EXCLUSIVE_LOCKS_REQUIRED(cs) {\n-        assert(m_has_epoch_guard);\n-        bool ret = it->m_epoch >= m_epoch;\n-        it->m_epoch = std::max(it->m_epoch, m_epoch);\n-        return ret;\n+    bool visited(const txiter it) const EXCLUSIVE_LOCKS_REQUIRED(cs, m_epoch)\n+    {\n+        return m_epoch.visited(it->m_epoch_marker);\n     }\n \n-    bool visited(Optional<txiter> it) const EXCLUSIVE_LOCKS_REQUIRED(cs) {\n-        assert(m_has_epoch_guard);\n+    bool visited(Optional<txiter> it) const EXCLUSIVE_LOCKS_REQUIRED(cs, m_epoch)\n+    {\n+        assert(m_epoch.guarded()); // verify guard even when it==nullopt\n         return !it || visited(*it);\n     }\n };"
      },
      {
        "sha": "1570ec4eb4c801ea509a0a0674da9261506127cf",
        "filename": "src/util/epochguard.h",
        "status": "added",
        "additions": 91,
        "deletions": 0,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd6580e405699ccb051fd2a34525e48d3253673d/src/util/epochguard.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd6580e405699ccb051fd2a34525e48d3253673d/src/util/epochguard.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/epochguard.h?ref=fd6580e405699ccb051fd2a34525e48d3253673d",
        "patch": "@@ -0,0 +1,91 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_EPOCHGUARD_H\n+#define BITCOIN_UTIL_EPOCHGUARD_H\n+\n+#include <threadsafety.h>\n+\n+#include <cassert>\n+\n+/** Epoch: RAII-style guard for using epoch-based graph traversal algorithms.\n+ *     When walking ancestors or descendants, we generally want to avoid\n+ * visiting the same transactions twice. Some traversal algorithms use\n+ * std::set (or setEntries) to deduplicate the transaction we visit.\n+ * However, use of std::set is algorithmically undesirable because it both\n+ * adds an asymptotic factor of O(log n) to traversals cost and triggers O(n)\n+ * more dynamic memory allocations.\n+ *     In many algorithms we can replace std::set with an internal mempool\n+ * counter to track the time (or, \"epoch\") that we began a traversal, and\n+ * check + update a per-transaction epoch for each transaction we look at to\n+ * determine if that transaction has not yet been visited during the current\n+ * traversal's epoch.\n+ *     Algorithms using std::set can be replaced on a one by one basis.\n+ * Both techniques are not fundamentally incompatible across the codebase.\n+ * Generally speaking, however, the remaining use of std::set for mempool\n+ * traversal should be viewed as a TODO for replacement with an epoch based\n+ * traversal, rather than a preference for std::set over epochs in that\n+ * algorithm.\n+ */\n+\n+class LOCKABLE Epoch\n+{\n+private:\n+    uint64_t m_raw_epoch = 0;\n+    bool m_guarded = false;\n+\n+public:\n+    Epoch() = default;\n+    Epoch(const Epoch&) = delete;\n+    Epoch& operator=(const Epoch&) = delete;\n+\n+    bool guarded() const { return m_guarded; }\n+\n+    class Marker\n+    {\n+    private:\n+        uint64_t m_marker = 0;\n+\n+        // only allow modification via Epoch member functions\n+        friend class Epoch;\n+        Marker& operator=(const Marker&) = delete;\n+    };\n+\n+    class SCOPED_LOCKABLE Guard\n+    {\n+    private:\n+        Epoch& m_epoch;\n+\n+    public:\n+        explicit Guard(Epoch& epoch) EXCLUSIVE_LOCK_FUNCTION(epoch) : m_epoch(epoch)\n+        {\n+            assert(!m_epoch.m_guarded);\n+            ++m_epoch.m_raw_epoch;\n+            m_epoch.m_guarded = true;\n+        }\n+        ~Guard() UNLOCK_FUNCTION()\n+        {\n+            assert(m_epoch.m_guarded);\n+            ++m_epoch.m_raw_epoch; // ensure clear separation between epochs\n+            m_epoch.m_guarded = false;\n+        }\n+    };\n+\n+    bool visited(Marker& marker) const EXCLUSIVE_LOCKS_REQUIRED(*this)\n+    {\n+        assert(m_guarded);\n+        if (marker.m_marker < m_raw_epoch) {\n+            // marker is from a previous epoch, so this is its first visit\n+            marker.m_marker = m_raw_epoch;\n+            return false;\n+        } else {\n+            return true;\n+        }\n+    }\n+};\n+\n+#define WITH_FRESH_EPOCH(epoch) const Epoch::Guard PASTE2(epoch_guard_, __COUNTER__)(epoch)\n+\n+#endif // BITCOIN_UTIL_EPOCHGUARD_H"
      }
    ]
  }
]