[
  {
    "sha": "e68172ed9fd0e35d4e848142e9b36ffcc41de254",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNjgxNzJlZDlmZDBlMzVkNGU4NDgxNDJlOWIzNmZmY2M0MWRlMjU0",
    "commit": {
      "author": {
        "name": "Ethan Heilman",
        "email": "ethan@geographicslab.org",
        "date": "2016-10-27T17:55:39Z"
      },
      "committer": {
        "name": "e0",
        "email": "ethan.r.heilman@gmail.com",
        "date": "2018-03-06T16:21:01Z"
      },
      "message": "Add test-before-evict discipline to addrman\n\nChanges addrman to use the test-before-evict discipline in which an\naddress is to be evicted from the tried table is first tested and if\nit is still online it is not evicted.\n\nAdds tests to provide test coverage for this change.\n\nThis change was suggested as Countermeasure 3 in\nEclipse Attacks on Bitcoin\u2019s Peer-to-Peer Network, Ethan Heilman,\nAlison Kendler, Aviv Zohar, Sharon Goldberg. ePrint Archive Report\n2015/263. March 2015.",
      "tree": {
        "sha": "d7ce5da09cf039698d7e914e1144d304367f2d9a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d7ce5da09cf039698d7e914e1144d304367f2d9a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e68172ed9fd0e35d4e848142e9b36ffcc41de254",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e68172ed9fd0e35d4e848142e9b36ffcc41de254",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e68172ed9fd0e35d4e848142e9b36ffcc41de254",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e68172ed9fd0e35d4e848142e9b36ffcc41de254/comments",
    "author": {
      "login": "EthanHeilman",
      "id": 274814,
      "node_id": "MDQ6VXNlcjI3NDgxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/274814?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/EthanHeilman",
      "html_url": "https://github.com/EthanHeilman",
      "followers_url": "https://api.github.com/users/EthanHeilman/followers",
      "following_url": "https://api.github.com/users/EthanHeilman/following{/other_user}",
      "gists_url": "https://api.github.com/users/EthanHeilman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/EthanHeilman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/EthanHeilman/subscriptions",
      "organizations_url": "https://api.github.com/users/EthanHeilman/orgs",
      "repos_url": "https://api.github.com/users/EthanHeilman/repos",
      "events_url": "https://api.github.com/users/EthanHeilman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/EthanHeilman/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "EthanHeilman",
      "id": 274814,
      "node_id": "MDQ6VXNlcjI3NDgxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/274814?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/EthanHeilman",
      "html_url": "https://github.com/EthanHeilman",
      "followers_url": "https://api.github.com/users/EthanHeilman/followers",
      "following_url": "https://api.github.com/users/EthanHeilman/following{/other_user}",
      "gists_url": "https://api.github.com/users/EthanHeilman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/EthanHeilman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/EthanHeilman/subscriptions",
      "organizations_url": "https://api.github.com/users/EthanHeilman/orgs",
      "repos_url": "https://api.github.com/users/EthanHeilman/repos",
      "events_url": "https://api.github.com/users/EthanHeilman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/EthanHeilman/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bf3353de90598f08a68d966c50b57ceaeb5b5d96",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bf3353de90598f08a68d966c50b57ceaeb5b5d96",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bf3353de90598f08a68d966c50b57ceaeb5b5d96"
      }
    ],
    "stats": {
      "total": 338,
      "additions": 319,
      "deletions": 19
    },
    "files": [
      {
        "sha": "9a7fad490079863623df4afca6b54e1c0e101f99",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 95,
        "deletions": 4,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e68172ed9fd0e35d4e848142e9b36ffcc41de254/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e68172ed9fd0e35d4e848142e9b36ffcc41de254/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=e68172ed9fd0e35d4e848142e9b36ffcc41de254",
        "patch": "@@ -187,7 +187,7 @@ void CAddrMan::MakeTried(CAddrInfo& info, int nId)\n     info.fInTried = true;\n }\n \n-void CAddrMan::Good_(const CService& addr, int64_t nTime)\n+void CAddrMan::Good_(const CService& addr, bool test_before_evict, int64_t nTime)\n {\n     int nId;\n \n@@ -233,10 +233,22 @@ void CAddrMan::Good_(const CService& addr, int64_t nTime)\n     if (nUBucket == -1)\n         return;\n \n-    LogPrint(BCLog::ADDRMAN, \"Moving %s to tried\\n\", addr.ToString());\n+    // which tried bucket to move the entry to\n+    int tried_bucket = info.GetTriedBucket(nKey);\n+    int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);\n+\n+    // Will moving this address into tried evict another entry?\n+    if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {\n+        LogPrint(BCLog::ADDRMAN, \"addrman\", \"Collision inserting element into tried table, moving %s to m_tried_collisions=%d\\n\", addr.ToString(), m_tried_collisions.size());\n+        if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {\n+            m_tried_collisions.insert(nId);\n+        }\n+    } else {\n+        LogPrint(BCLog::ADDRMAN, \"Moving %s to tried\\n\", addr.ToString());\n \n-    // move nId to the tried tables\n-    MakeTried(info, nId);\n+        // move nId to the tried tables\n+        MakeTried(info, nId);\n+    }\n }\n \n bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimePenalty)\n@@ -521,3 +533,82 @@ void CAddrMan::SetServices_(const CService& addr, ServiceFlags nServices)\n int CAddrMan::RandomInt(int nMax){\n     return GetRandInt(nMax);\n }\n+\n+void CAddrMan::ResolveCollisions_()\n+{\n+    for (std::set<int>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {\n+        int id_new = *it;\n+\n+        bool erase_collision = false;\n+\n+        // If id_new not found in mapInfo remove it from m_tried_collisions\n+        if (mapInfo.count(id_new) != 1) {\n+            erase_collision = true;\n+        } else {\n+            CAddrInfo& info_new = mapInfo[id_new];\n+\n+            // Which tried bucket to move the entry to.\n+            int tried_bucket = info_new.GetTriedBucket(nKey);\n+            int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);\n+            if (!info_new.IsValid()) { // id_new may no longer map to a valid address\n+                erase_collision = true;\n+            } else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty\n+\n+                // Get the to-be-evicted address that is being tested\n+                int id_old = vvTried[tried_bucket][tried_bucket_pos];\n+                CAddrInfo& info_old = mapInfo[id_old];\n+\n+                // Has successfully connected in last X hours\n+                if (GetAdjustedTime() - info_old.nLastSuccess < ADDRMAN_REPLACEMENT_HOURS*(60*60)) {\n+                    erase_collision = true;\n+                } else if (GetAdjustedTime() - info_old.nLastTry < ADDRMAN_REPLACEMENT_HOURS*(60*60)) { // attempted to connect and failed in last X hours\n+\n+                    // Give address at least 60 seconds to successfully connect\n+                    if (GetAdjustedTime() - info_old.nLastTry > 60) {\n+                        LogPrint(BCLog::ADDRMAN, \"addrman\", \"Swapping %s for %s in tried table\\n\", info_new.ToString(), info_old.ToString());\n+\n+                        // Replaces an existing address already in the tried table with the new address\n+                        Good_(info_new, false, GetAdjustedTime());\n+                        erase_collision = true;\n+                    }\n+                }\n+            } else { // Collision is not actually a collision anymore\n+                Good_(info_new, false, GetAdjustedTime());\n+                erase_collision = true;\n+            }\n+        }\n+\n+        if (erase_collision) {\n+            m_tried_collisions.erase(it++);\n+        } else {\n+            it++;\n+        }\n+    }\n+}\n+\n+CAddrInfo CAddrMan::SelectTriedCollision_()\n+{\n+    if (m_tried_collisions.size() == 0) return CAddrInfo();\n+\n+    std::set<int>::iterator it = m_tried_collisions.begin();\n+\n+    // Selects a random element from m_tried_collisions\n+    std::advance(it, GetRandInt(m_tried_collisions.size()));\n+    int id_new = *it;\n+\n+    // If id_new not found in mapInfo remove it from m_tried_collisions\n+    if (mapInfo.count(id_new) != 1) {\n+        m_tried_collisions.erase(it);\n+        return CAddrInfo();\n+    }\n+\n+    CAddrInfo& newInfo = mapInfo[id_new];\n+\n+    // which tried bucket to move the entry to\n+    int tried_bucket = newInfo.GetTriedBucket(nKey);\n+    int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);\n+\n+    int id_old = vvTried[tried_bucket][tried_bucket_pos];\n+\n+    return mapInfo[id_old];\n+}"
      },
      {
        "sha": "67423c6c55baf3709a86f51fe94fa6c6a2bf0b24",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 40,
        "deletions": 3,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e68172ed9fd0e35d4e848142e9b36ffcc41de254/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e68172ed9fd0e35d4e848142e9b36ffcc41de254/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=e68172ed9fd0e35d4e848142e9b36ffcc41de254",
        "patch": "@@ -165,6 +165,9 @@ class CAddrInfo : public CAddress\n //! ... in at least this many days\n #define ADDRMAN_MIN_FAIL_DAYS 7\n \n+//! how recent a successful connection should be before we allow an address to be evicted from tried\n+#define ADDRMAN_REPLACEMENT_HOURS 4\n+\n //! the maximum percentage of nodes to return in a getaddr call\n #define ADDRMAN_GETADDR_MAX_PCT 23\n \n@@ -176,6 +179,9 @@ class CAddrInfo : public CAddress\n #define ADDRMAN_NEW_BUCKET_COUNT (1 << ADDRMAN_NEW_BUCKET_COUNT_LOG2)\n #define ADDRMAN_BUCKET_SIZE (1 << ADDRMAN_BUCKET_SIZE_LOG2)\n \n+//! the maximum number of tried addr collisions to store\n+#define ADDRMAN_SET_TRIED_COLLISION_SIZE 10\n+\n /** \n  * Stochastical (IP) address manager \n  */\n@@ -212,6 +218,9 @@ class CAddrMan\n     //! last time Good was called (memory only)\n     int64_t nLastGood;\n \n+    //! Holds addrs inserted into tried table that collide with existing entries. Test-before-evict discpline used to resolve these collisions.\n+    std::set<int> m_tried_collisions;\n+\n protected:\n     //! secret key to randomize bucket select with\n     uint256 nKey;\n@@ -239,7 +248,7 @@ class CAddrMan\n     void ClearNew(int nUBucket, int nUBucketPos);\n \n     //! Mark an entry \"good\", possibly moving it from \"new\" to \"tried\".\n-    void Good_(const CService &addr, int64_t nTime);\n+    void Good_(const CService &addr, bool test_before_evict, int64_t time);\n \n     //! Add an entry to the \"new\" table.\n     bool Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty);\n@@ -250,6 +259,12 @@ class CAddrMan\n     //! Select an address to connect to, if newOnly is set to true, only the new table is selected from.\n     CAddrInfo Select_(bool newOnly);\n \n+    //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n+    void ResolveCollisions_();\n+\n+    //! Return a random to-be-evicted tried table address.\n+    CAddrInfo SelectTriedCollision_();\n+\n     //! Wraps GetRandInt to allow tests to override RandomInt and make it determinismistic.\n     virtual int RandomInt(int nMax);\n \n@@ -537,11 +552,11 @@ class CAddrMan\n     }\n \n     //! Mark an entry as accessible.\n-    void Good(const CService &addr, int64_t nTime = GetAdjustedTime())\n+    void Good(const CService &addr, bool test_before_evict = true, int64_t nTime = GetAdjustedTime())\n     {\n         LOCK(cs);\n         Check();\n-        Good_(addr, nTime);\n+        Good_(addr, test_before_evict, nTime);\n         Check();\n     }\n \n@@ -554,6 +569,28 @@ class CAddrMan\n         Check();\n     }\n \n+    //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n+    void ResolveCollisions()\n+    {\n+        LOCK(cs);\n+        Check();\n+        ResolveCollisions_();\n+        Check();\n+    }\n+\n+    //! Randomly select an address in tried that another address is attempting to evict.\n+    CAddrInfo SelectTriedCollision()\n+    {\n+        CAddrInfo ret;\n+        {\n+            LOCK(cs);\n+            Check();\n+            ret = SelectTriedCollision_();\n+            Check();\n+        }\n+        return ret;\n+    }\n+\n     /**\n      * Choose an address to connect to.\n      */"
      },
      {
        "sha": "e08ce0fd33370e96a4ecdeb14a45709526f85206",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e68172ed9fd0e35d4e848142e9b36ffcc41de254/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e68172ed9fd0e35d4e848142e9b36ffcc41de254/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=e68172ed9fd0e35d4e848142e9b36ffcc41de254",
        "patch": "@@ -1824,11 +1824,18 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n             }\n         }\n \n+        addrman.ResolveCollisions();\n+\n         int64_t nANow = GetAdjustedTime();\n         int nTries = 0;\n         while (!interruptNet)\n         {\n-            CAddrInfo addr = addrman.Select(fFeeler);\n+            CAddrInfo addr = addrman.SelectTriedCollision();\n+\n+            // SelectTriedCollision returns an invalid address if it is empty.\n+            if (!fFeeler || !addr.IsValid()) {\n+                addr = addrman.Select(fFeeler);\n+            }\n \n             // if we selected an invalid address, restart\n             if (!addr.IsValid() || setConnected.count(addr.GetGroup()) || IsLocal(addr))"
      },
      {
        "sha": "0d8bd901195487f51fdcd93fdfad7a3fc3587e8c",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 176,
        "deletions": 11,
        "changes": 187,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e68172ed9fd0e35d4e848142e9b36ffcc41de254/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e68172ed9fd0e35d4e848142e9b36ffcc41de254/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=e68172ed9fd0e35d4e848142e9b36ffcc41de254",
        "patch": "@@ -52,6 +52,17 @@ class CAddrManTest : public CAddrMan\n     {\n         CAddrMan::Delete(nId);\n     }\n+\n+    // Simulates connection failure so that we can test eviction of offline nodes\n+    void SimConnFail(CService& addr)\n+    {\n+         int64_t nLastSuccess = 1;\n+         Good_(addr, true, nLastSuccess); // Set last good connection in the deep past.\n+\n+         bool count_failure = false;\n+         int64_t nLastTry = GetAdjustedTime()-61;\n+         Attempt(addr, count_failure, nLastTry);\n+     }\n };\n \n static CNetAddr ResolveIP(const char* ip)\n@@ -226,7 +237,7 @@ BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n     BOOST_CHECK_EQUAL(addrman.size(), 0);\n \n     for (unsigned int i = 1; i < 18; i++) {\n-        CService addr = ResolveService(\"250.1.1.\" + boost::to_string(i));\n+        CService addr = ResolveService(\"250.1.1.\" + std::to_string(i));\n         addrman.Add(CAddress(addr, NODE_NONE), source);\n \n         //Test: No collision in new table yet.\n@@ -252,7 +263,7 @@ BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n     BOOST_CHECK_EQUAL(addrman.size(), 0);\n \n     for (unsigned int i = 1; i < 80; i++) {\n-        CService addr = ResolveService(\"250.1.1.\" + boost::to_string(i));\n+        CService addr = ResolveService(\"250.1.1.\" + std::to_string(i));\n         addrman.Add(CAddress(addr, NODE_NONE), source);\n         addrman.Good(CAddress(addr, NODE_NONE));\n \n@@ -385,7 +396,7 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n     for (unsigned int i = 1; i < (8 * 256); i++) {\n         int octet1 = i % 256;\n         int octet2 = i >> 8 % 256;\n-        std::string strAddr = boost::to_string(octet1) + \".\" + boost::to_string(octet2) + \".1.23\";\n+        std::string strAddr = std::to_string(octet1) + \".\" + std::to_string(octet2) + \".1.23\";\n         CAddress addr = CAddress(ResolveService(strAddr), NODE_NONE);\n \n         // Ensure that for all addrs in addrman, isTerrible == false.\n@@ -436,8 +447,8 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n     std::set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n         CAddrInfo infoi = CAddrInfo(\n-            CAddress(ResolveService(\"250.1.1.\" + boost::to_string(i)), NODE_NONE),\n-            ResolveIP(\"250.1.1.\" + boost::to_string(i)));\n+            CAddress(ResolveService(\"250.1.1.\" + std::to_string(i)), NODE_NONE),\n+            ResolveIP(\"250.1.1.\" + std::to_string(i)));\n         int bucket = infoi.GetTriedBucket(nKey1);\n         buckets.insert(bucket);\n     }\n@@ -448,8 +459,8 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n     buckets.clear();\n     for (int j = 0; j < 255; j++) {\n         CAddrInfo infoj = CAddrInfo(\n-            CAddress(ResolveService(\"250.\" + boost::to_string(j) + \".1.1\"), NODE_NONE),\n-            ResolveIP(\"250.\" + boost::to_string(j) + \".1.1\"));\n+            CAddress(ResolveService(\"250.\" + std::to_string(j) + \".1.1\"), NODE_NONE),\n+            ResolveIP(\"250.\" + std::to_string(j) + \".1.1\"));\n         int bucket = infoj.GetTriedBucket(nKey1);\n         buckets.insert(bucket);\n     }\n@@ -488,8 +499,8 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     std::set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n         CAddrInfo infoi = CAddrInfo(\n-            CAddress(ResolveService(\"250.1.1.\" + boost::to_string(i)), NODE_NONE),\n-            ResolveIP(\"250.1.1.\" + boost::to_string(i)));\n+            CAddress(ResolveService(\"250.1.1.\" + std::to_string(i)), NODE_NONE),\n+            ResolveIP(\"250.1.1.\" + std::to_string(i)));\n         int bucket = infoi.GetNewBucket(nKey1);\n         buckets.insert(bucket);\n     }\n@@ -501,7 +512,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     for (int j = 0; j < 4 * 255; j++) {\n         CAddrInfo infoj = CAddrInfo(CAddress(\n                                         ResolveService(\n-                                            boost::to_string(250 + (j / 255)) + \".\" + boost::to_string(j % 256) + \".1.1\"), NODE_NONE),\n+                                            std::to_string(250 + (j / 255)) + \".\" + std::to_string(j % 256) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"251.4.1.1\"));\n         int bucket = infoj.GetNewBucket(nKey1);\n         buckets.insert(bucket);\n@@ -514,12 +525,166 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     for (int p = 0; p < 255; p++) {\n         CAddrInfo infoj = CAddrInfo(\n             CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE),\n-            ResolveIP(\"250.\" + boost::to_string(p) + \".1.1\"));\n+            ResolveIP(\"250.\" + std::to_string(p) + \".1.1\"));\n         int bucket = infoj.GetNewBucket(nKey1);\n         buckets.insert(bucket);\n     }\n     // Test: IP addresses in the different source groups should map to more\n     //  than 64 buckets.\n     BOOST_CHECK(buckets.size() > 64);\n }\n+\n+\n+BOOST_AUTO_TEST_CASE(addrman_selecttriedcollision)\n+{\n+    CAddrManTest addrman;\n+\n+    // Set addrman addr placement to be deterministic.\n+    addrman.MakeDeterministic();\n+\n+    BOOST_CHECK(addrman.size() == 0);\n+\n+    // Empty addrman should return blank addrman info.\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+\n+    // Add twenty two addresses.\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    for (unsigned int i = 1; i < 23; i++) {\n+        CService addr = ResolveService(\"250.1.1.\"+std::to_string(i));\n+        addrman.Add(CAddress(addr, NODE_NONE), source);\n+        addrman.Good(addr);\n+\n+        // No collisions yet.\n+        BOOST_CHECK(addrman.size() == i);\n+        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    }\n+\n+    // Ensure Good handles duplicates well.\n+    for (unsigned int i = 1; i < 23; i++) {\n+        CService addr = ResolveService(\"250.1.1.\"+std::to_string(i));\n+        addrman.Good(addr);\n+\n+        BOOST_CHECK(addrman.size() == 22);\n+        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    }\n+\n+}\n+\n+BOOST_AUTO_TEST_CASE(addrman_noevict)\n+{\n+    CAddrManTest addrman;\n+\n+    // Set addrman addr placement to be deterministic.\n+    addrman.MakeDeterministic();\n+\n+    // Add twenty two addresses.\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    for (unsigned int i = 1; i < 23; i++) {\n+        CService addr = ResolveService(\"250.1.1.\"+std::to_string(i));\n+        addrman.Add(CAddress(addr, NODE_NONE), source);\n+        addrman.Good(addr);\n+\n+        // No collision yet.\n+        BOOST_CHECK(addrman.size() == i);\n+        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    }\n+\n+    // Collision between 23 and 19.\n+    CService addr23 = ResolveService(\"250.1.1.23\");\n+    addrman.Add(CAddress(addr23, NODE_NONE), source);\n+    addrman.Good(addr23);\n+\n+    BOOST_CHECK(addrman.size() == 23);\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"250.1.1.19:0\");\n+\n+    // 23 should be discarded and 19 not evicted.\n+    addrman.ResolveCollisions();\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+\n+    // Lets create two collisions.\n+    for (unsigned int i = 24; i < 33; i++) {\n+        CService addr = ResolveService(\"250.1.1.\"+std::to_string(i));\n+        addrman.Add(CAddress(addr, NODE_NONE), source);\n+        addrman.Good(addr);\n+\n+        BOOST_CHECK(addrman.size() == i);\n+        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    }\n+\n+    // Cause a collision.\n+    CService addr33 = ResolveService(\"250.1.1.33\");\n+    addrman.Add(CAddress(addr33, NODE_NONE), source);\n+    addrman.Good(addr33);\n+    BOOST_CHECK(addrman.size() == 33);\n+\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"250.1.1.27:0\");\n+\n+    // Cause a second collision.\n+    addrman.Add(CAddress(addr23, NODE_NONE), source);\n+    addrman.Good(addr23);\n+    BOOST_CHECK(addrman.size() == 33);\n+\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() != \"[::]:0\");\n+    addrman.ResolveCollisions();\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(addrman_evictionworks)\n+{\n+    CAddrManTest addrman;\n+\n+    // Set addrman addr placement to be deterministic.\n+    addrman.MakeDeterministic();\n+\n+    BOOST_CHECK(addrman.size() == 0);\n+\n+    // Empty addrman should return blank addrman info.\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+\n+    // Add twenty two addresses.\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    for (unsigned int i = 1; i < 23; i++) {\n+        CService addr = ResolveService(\"250.1.1.\"+std::to_string(i));\n+        addrman.Add(CAddress(addr, NODE_NONE), source);\n+        addrman.Good(addr);\n+\n+        // No collision yet.\n+        BOOST_CHECK(addrman.size() == i);\n+        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    }\n+\n+    // Collision between 23 and 19.\n+    CService addr = ResolveService(\"250.1.1.23\");\n+    addrman.Add(CAddress(addr, NODE_NONE), source);\n+    addrman.Good(addr);\n+\n+    BOOST_CHECK(addrman.size() == 23);\n+    CAddrInfo info = addrman.SelectTriedCollision();\n+    BOOST_CHECK(info.ToString() == \"250.1.1.19:0\");\n+\n+    // Ensure test of address fails, so that it is evicted.\n+    addrman.SimConnFail(info);\n+\n+    // Should swap 23 for 19.\n+    addrman.ResolveCollisions();\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+\n+    // If 23 was swapped for 19, then this should cause no collisions.\n+    addrman.Add(CAddress(addr, NODE_NONE), source);\n+    addrman.Good(addr);\n+\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+\n+    // If we insert 19 is should collide with 23.\n+    CService addr19 = ResolveService(\"250.1.1.19\");\n+    addrman.Add(CAddress(addr19, NODE_NONE), source);\n+    addrman.Good(addr19);\n+\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"250.1.1.23:0\");\n+\n+    addrman.ResolveCollisions();\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+}\n+\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  }
]