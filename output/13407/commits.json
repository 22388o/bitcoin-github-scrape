[
  {
    "sha": "4e918b201a34f5f6c92b4c97b4376df055b25bd5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ZTkxOGIyMDFhMzRmNWY2YzkyYjRjOTdiNDM3NmRmMDU1YjI1YmQ1",
    "commit": {
      "author": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-06-06T17:06:48Z"
      },
      "committer": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-08-12T15:11:23Z"
      },
      "message": "[refactor, move-only-ish] Refactor mempool accept/reject logic\n\nCreate separate functions to handle responses when a transaction\nreceived from a peer is accepted or rejected.",
      "tree": {
        "sha": "4c67fa51f9b87f76c9c0801ce0eb13a8b23a65fc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4c67fa51f9b87f76c9c0801ce0eb13a8b23a65fc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4e918b201a34f5f6c92b4c97b4376df055b25bd5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4e918b201a34f5f6c92b4c97b4376df055b25bd5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4e918b201a34f5f6c92b4c97b4376df055b25bd5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4e918b201a34f5f6c92b4c97b4376df055b25bd5/comments",
    "author": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0df7a6c13ec484f9f31cfe3ed3039098a9bef124",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0df7a6c13ec484f9f31cfe3ed3039098a9bef124",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0df7a6c13ec484f9f31cfe3ed3039098a9bef124"
      }
    ],
    "stats": {
      "total": 341,
      "additions": 186,
      "deletions": 155
    },
    "files": [
      {
        "sha": "aec26e02a29b5630b36c4fe85eeecbec5494ff60",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 186,
        "deletions": 155,
        "changes": 341,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4e918b201a34f5f6c92b4c97b4376df055b25bd5/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4e918b201a34f5f6c92b4c97b4376df055b25bd5/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=4e918b201a34f5f6c92b4c97b4376df055b25bd5",
        "patch": "@@ -72,6 +72,12 @@ struct COrphanTx {\n };\n static CCriticalSection g_cs_orphans;\n std::map<uint256, COrphanTx> mapOrphanTransactions GUARDED_BY(g_cs_orphans);\n+static void ProcessMempoolAccept(CConnman *, CNode *, const CTransaction&, std::list<CTransactionRef>&) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans);\n+static void ProcessMempoolReject(CConnman * connman, CNode * pfrom,\n+                                 const CNetMsgMaker msgMaker, const std::string& strCommand,\n+                                 const CTransactionRef& ptx, const CValidationState& state,\n+                                 bool missing_inputs, bool enable_bip61) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans);\n+static void ProcessMempoolMissingInputs(CNode * pfrom, const CTransactionRef& ptx) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans);\n \n void EraseOrphansFor(NodeId peer);\n \n@@ -2209,8 +2215,6 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             return true;\n         }\n \n-        std::deque<COutPoint> vWorkQueue;\n-        std::vector<uint256> vEraseQueue;\n         CTransactionRef ptx;\n         vRecv >> ptx;\n         const CTransaction& tx = *ptx;\n@@ -2228,160 +2232,13 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         std::list<CTransactionRef> lRemovedTxn;\n \n-        if (!AlreadyHave(inv) &&\n-            AcceptToMemoryPool(mempool, state, ptx, &fMissingInputs, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n-            mempool.check(pcoinsTip.get());\n-            RelayTransaction(tx, connman);\n-            for (unsigned int i = 0; i < tx.vout.size(); i++) {\n-                vWorkQueue.emplace_back(inv.hash, i);\n-            }\n-\n-            pfrom->nLastTXTime = GetTime();\n-\n-            LogPrint(BCLog::MEMPOOL, \"AcceptToMemoryPool: peer=%d: accepted %s (poolsz %u txn, %u kB)\\n\",\n-                pfrom->GetId(),\n-                tx.GetHash().ToString(),\n-                mempool.size(), mempool.DynamicMemoryUsage() / 1000);\n-\n-            // Recursively process any orphan transactions that depended on this one\n-            std::set<NodeId> setMisbehaving;\n-            while (!vWorkQueue.empty()) {\n-                auto itByPrev = mapOrphanTransactionsByPrev.find(vWorkQueue.front());\n-                vWorkQueue.pop_front();\n-                if (itByPrev == mapOrphanTransactionsByPrev.end())\n-                    continue;\n-                for (auto mi = itByPrev->second.begin();\n-                     mi != itByPrev->second.end();\n-                     ++mi)\n-                {\n-                    const CTransactionRef& porphanTx = (*mi)->second.tx;\n-                    const CTransaction& orphanTx = *porphanTx;\n-                    const uint256& orphanHash = orphanTx.GetHash();\n-                    NodeId fromPeer = (*mi)->second.fromPeer;\n-                    bool fMissingInputs2 = false;\n-                    // Use a dummy CValidationState so someone can't setup nodes to counter-DoS based on orphan\n-                    // resolution (that is, feeding people an invalid transaction based on LegitTxX in order to get\n-                    // anyone relaying LegitTxX banned)\n-                    CValidationState stateDummy;\n-\n-\n-                    if (setMisbehaving.count(fromPeer))\n-                        continue;\n-                    if (AcceptToMemoryPool(mempool, stateDummy, porphanTx, &fMissingInputs2, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n-                        LogPrint(BCLog::MEMPOOL, \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n-                        RelayTransaction(orphanTx, connman);\n-                        for (unsigned int i = 0; i < orphanTx.vout.size(); i++) {\n-                            vWorkQueue.emplace_back(orphanHash, i);\n-                        }\n-                        vEraseQueue.push_back(orphanHash);\n-                    }\n-                    else if (!fMissingInputs2)\n-                    {\n-                        int nDos = 0;\n-                        if (stateDummy.IsInvalid(nDos) && nDos > 0)\n-                        {\n-                            // Punish peer that gave us an invalid orphan tx\n-                            Misbehaving(fromPeer, nDos);\n-                            setMisbehaving.insert(fromPeer);\n-                            LogPrint(BCLog::MEMPOOL, \"   invalid orphan tx %s\\n\", orphanHash.ToString());\n-                        }\n-                        // Has inputs but not accepted to mempool\n-                        // Probably non-standard or insufficient fee\n-                        LogPrint(BCLog::MEMPOOL, \"   removed orphan tx %s\\n\", orphanHash.ToString());\n-                        vEraseQueue.push_back(orphanHash);\n-                        if (!orphanTx.HasWitness() && !stateDummy.CorruptionPossible()) {\n-                            // Do not use rejection cache for witness transactions or\n-                            // witness-stripped transactions, as they can have been malleated.\n-                            // See https://github.com/bitcoin/bitcoin/issues/8279 for details.\n-                            assert(recentRejects);\n-                            recentRejects->insert(orphanHash);\n-                        }\n-                    }\n-                    mempool.check(pcoinsTip.get());\n-                }\n-            }\n-\n-            for (uint256 hash : vEraseQueue)\n-                EraseOrphanTx(hash);\n-        }\n-        else if (fMissingInputs)\n-        {\n-            bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n-            for (const CTxIn& txin : tx.vin) {\n-                if (recentRejects->contains(txin.prevout.hash)) {\n-                    fRejectedParents = true;\n-                    break;\n-                }\n-            }\n-            if (!fRejectedParents) {\n-                uint32_t nFetchFlags = GetFetchFlags(pfrom);\n-                for (const CTxIn& txin : tx.vin) {\n-                    CInv _inv(MSG_TX | nFetchFlags, txin.prevout.hash);\n-                    pfrom->AddInventoryKnown(_inv);\n-                    if (!AlreadyHave(_inv)) pfrom->AskFor(_inv);\n-                }\n-                AddOrphanTx(ptx, pfrom->GetId());\n-\n-                // DoS prevention: do not allow mapOrphanTransactions to grow unbounded\n-                unsigned int nMaxOrphanTx = (unsigned int)std::max((int64_t)0, gArgs.GetArg(\"-maxorphantx\", DEFAULT_MAX_ORPHAN_TRANSACTIONS));\n-                unsigned int nEvicted = LimitOrphanTxSize(nMaxOrphanTx);\n-                if (nEvicted > 0) {\n-                    LogPrint(BCLog::MEMPOOL, \"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n-                }\n+        if (!AlreadyHave(inv)) {\n+            if (AcceptToMemoryPool(mempool, state, ptx, &fMissingInputs, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n+                assert(!state.IsInvalid());\n+                ProcessMempoolAccept(connman, pfrom, tx, lRemovedTxn);\n             } else {\n-                LogPrint(BCLog::MEMPOOL, \"not keeping orphan with rejected parents %s\\n\",tx.GetHash().ToString());\n-                // We will continue to reject this tx since it has rejected\n-                // parents so avoid re-requesting it from other peers.\n-                recentRejects->insert(tx.GetHash());\n-            }\n-        } else {\n-            if (!tx.HasWitness() && !state.CorruptionPossible()) {\n-                // Do not use rejection cache for witness transactions or\n-                // witness-stripped transactions, as they can have been malleated.\n-                // See https://github.com/bitcoin/bitcoin/issues/8279 for details.\n-                assert(recentRejects);\n-                recentRejects->insert(tx.GetHash());\n-                if (RecursiveDynamicUsage(*ptx) < 100000) {\n-                    AddToCompactExtraTransactions(ptx);\n-                }\n-            } else if (tx.HasWitness() && RecursiveDynamicUsage(*ptx) < 100000) {\n-                AddToCompactExtraTransactions(ptx);\n-            }\n-\n-            if (pfrom->fWhitelisted && gArgs.GetBoolArg(\"-whitelistforcerelay\", DEFAULT_WHITELISTFORCERELAY)) {\n-                // Always relay transactions received from whitelisted peers, even\n-                // if they were already in the mempool or rejected from it due\n-                // to policy, allowing the node to function as a gateway for\n-                // nodes hidden behind it.\n-                //\n-                // Never relay transactions that we would assign a non-zero DoS\n-                // score for, as we expect peers to do the same with us in that\n-                // case.\n-                int nDoS = 0;\n-                if (!state.IsInvalid(nDoS) || nDoS == 0) {\n-                    LogPrintf(\"Force relaying tx %s from whitelisted peer=%d\\n\", tx.GetHash().ToString(), pfrom->GetId());\n-                    RelayTransaction(tx, connman);\n-                } else {\n-                    LogPrintf(\"Not relaying invalid transaction %s from whitelisted peer=%d (%s)\\n\", tx.GetHash().ToString(), pfrom->GetId(), FormatStateMessage(state));\n-                }\n-            }\n-        }\n-\n-        for (const CTransactionRef& removedTx : lRemovedTxn)\n-            AddToCompactExtraTransactions(removedTx);\n-\n-        int nDoS = 0;\n-        if (state.IsInvalid(nDoS))\n-        {\n-            LogPrint(BCLog::MEMPOOLREJ, \"%s from peer=%d was not accepted: %s\\n\", tx.GetHash().ToString(),\n-                pfrom->GetId(),\n-                FormatStateMessage(state));\n-            if (enable_bip61 && state.GetRejectCode() > 0 && state.GetRejectCode() < REJECT_INTERNAL) { // Never send AcceptToMemoryPool's internal codes over P2P\n-                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n-                                   state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), inv.hash));\n-            }\n-            if (nDoS > 0) {\n-                Misbehaving(pfrom->GetId(), nDoS);\n+                assert(lRemovedTxn.empty());\n+                ProcessMempoolReject(connman, pfrom, msgMaker, strCommand, ptx, state, fMissingInputs, enable_bip61);\n             }\n         }\n     }\n@@ -3101,6 +2958,180 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     return fMoreWork;\n }\n \n+static void ProcessMempoolAccept(CConnman * connman, CNode * pfrom, const CTransaction& tx, std::list<CTransactionRef>& lRemovedTxn) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans)\n+{\n+    std::deque<COutPoint> vWorkQueue;\n+    std::vector<uint256> vEraseQueue;\n+\n+    mempool.check(pcoinsTip.get());\n+    RelayTransaction(tx, connman);\n+    for (unsigned int i = 0; i < tx.vout.size(); i++) {\n+        vWorkQueue.emplace_back(tx.GetHash(), i);\n+    }\n+\n+    pfrom->nLastTXTime = GetTime();\n+\n+    LogPrint(BCLog::MEMPOOL, \"AcceptToMemoryPool: peer=%d: accepted %s (poolsz %u txn, %u kB)\\n\",\n+             pfrom->GetId(),\n+             tx.GetHash().ToString(),\n+             mempool.size(), mempool.DynamicMemoryUsage() / 1000);\n+\n+    // Recursively process any orphan transactions that depended on this one\n+    std::set<NodeId> setMisbehaving;\n+    while (!vWorkQueue.empty()) {\n+        auto itByPrev = mapOrphanTransactionsByPrev.find(vWorkQueue.front());\n+        vWorkQueue.pop_front();\n+        if (itByPrev == mapOrphanTransactionsByPrev.end())\n+            continue;\n+        for (auto mi = itByPrev->second.begin();\n+             mi != itByPrev->second.end();\n+             ++mi)\n+        {\n+            const CTransactionRef& porphanTx = (*mi)->second.tx;\n+            const CTransaction& orphanTx = *porphanTx;\n+            const uint256& orphanHash = orphanTx.GetHash();\n+            NodeId fromPeer = (*mi)->second.fromPeer;\n+            bool fMissingInputs2 = false;\n+            // Use a dummy CValidationState so someone can't setup nodes to counter-DoS based on orphan\n+            // resolution (that is, feeding people an invalid transaction based on LegitTxX in order to get\n+            // anyone relaying LegitTxX banned)\n+            CValidationState stateDummy;\n+\n+\n+            if (setMisbehaving.count(fromPeer))\n+                continue;\n+            if (AcceptToMemoryPool(mempool, stateDummy, porphanTx, &fMissingInputs2, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n+                LogPrint(BCLog::MEMPOOL, \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n+                RelayTransaction(orphanTx, connman);\n+                for (unsigned int i = 0; i < orphanTx.vout.size(); i++) {\n+                    vWorkQueue.emplace_back(orphanHash, i);\n+                }\n+                vEraseQueue.push_back(orphanHash);\n+            }\n+            else if (!fMissingInputs2)\n+            {\n+                int nDos = 0;\n+                if (stateDummy.IsInvalid(nDos) && nDos > 0)\n+                {\n+                    // Punish peer that gave us an invalid orphan tx\n+                    Misbehaving(fromPeer, nDos);\n+                    setMisbehaving.insert(fromPeer);\n+                    LogPrint(BCLog::MEMPOOL, \"   invalid orphan tx %s\\n\", orphanHash.ToString());\n+                }\n+                // Has inputs but not accepted to mempool\n+                // Probably non-standard or insufficient fee\n+                LogPrint(BCLog::MEMPOOL, \"   removed orphan tx %s\\n\", orphanHash.ToString());\n+                vEraseQueue.push_back(orphanHash);\n+                if (!orphanTx.HasWitness() && !stateDummy.CorruptionPossible()) {\n+                    // Do not use rejection cache for witness transactions or\n+                    // witness-stripped transactions, as they can have been malleated.\n+                    // See https://github.com/bitcoin/bitcoin/issues/8279 for details.\n+                    assert(recentRejects);\n+                    recentRejects->insert(orphanHash);\n+                }\n+            }\n+            mempool.check(pcoinsTip.get());\n+        }\n+    }\n+\n+    for (uint256 hash : vEraseQueue)\n+        EraseOrphanTx(hash);\n+\n+    for (const CTransactionRef& removedTx : lRemovedTxn)\n+        AddToCompactExtraTransactions(removedTx);\n+}\n+\n+static void ProcessMempoolReject(CConnman * connman, CNode * pfrom,\n+                                 const CNetMsgMaker msgMaker, const std::string& strCommand,\n+                                 const CTransactionRef& ptx, const CValidationState& state, bool missing_inputs, bool enable_bip61) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans)\n+{\n+    const CTransaction& tx = *ptx;\n+\n+    if (missing_inputs) {\n+        ProcessMempoolMissingInputs(pfrom, ptx);\n+    } else {\n+        if (!tx.HasWitness() && !state.CorruptionPossible()) {\n+            // Do not use rejection cache for witness transactions or\n+            // witness-stripped transactions, as they can have been malleated.\n+            // See https://github.com/bitcoin/bitcoin/issues/8279 for details.\n+            assert(recentRejects);\n+            recentRejects->insert(tx.GetHash());\n+            if (RecursiveDynamicUsage(*ptx) < 100000) {\n+                AddToCompactExtraTransactions(ptx);\n+            }\n+        } else if (tx.HasWitness() && RecursiveDynamicUsage(*ptx) < 100000) {\n+            AddToCompactExtraTransactions(ptx);\n+        }\n+\n+        if (pfrom->fWhitelisted && gArgs.GetBoolArg(\"-whitelistforcerelay\", DEFAULT_WHITELISTFORCERELAY)) {\n+            // Always relay transactions received from whitelisted peers, even\n+            // if they were already in the mempool or rejected from it due\n+            // to policy, allowing the node to function as a gateway for\n+            // nodes hidden behind it.\n+            //\n+            // Never relay transactions that we would assign a non-zero DoS\n+            // score for, as we expect peers to do the same with us in that\n+            // case.\n+            int nDoS = 0;\n+            if (!state.IsInvalid(nDoS) || nDoS == 0) {\n+                LogPrintf(\"Force relaying tx %s from whitelisted peer=%d\\n\", tx.GetHash().ToString(), pfrom->GetId());\n+                RelayTransaction(tx, connman);\n+            } else {\n+                LogPrintf(\"Not relaying invalid transaction %s from whitelisted peer=%d (%s)\\n\", tx.GetHash().ToString(), pfrom->GetId(), FormatStateMessage(state));\n+            }\n+        }\n+    }\n+\n+    int nDoS = 0;\n+    if (state.IsInvalid(nDoS))\n+    {\n+        LogPrint(BCLog::MEMPOOLREJ, \"%s from peer=%d was not accepted: %s\\n\", tx.GetHash().ToString(),\n+                 pfrom->GetId(),\n+                 FormatStateMessage(state));\n+        if (enable_bip61 && state.GetRejectCode() > 0 && state.GetRejectCode() < REJECT_INTERNAL) { // Never send AcceptToMemoryPool's internal codes over P2P\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n+                                                      state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), tx.GetHash()));\n+        }\n+        if (nDoS > 0) {\n+            Misbehaving(pfrom->GetId(), nDoS);\n+        }\n+    }\n+}\n+\n+static void ProcessMempoolMissingInputs(CNode * pfrom, const CTransactionRef& ptx) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans)\n+{\n+    const CTransaction& tx = *ptx;\n+\n+    bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n+    for (const CTxIn& txin : tx.vin) {\n+        if (recentRejects->contains(txin.prevout.hash)) {\n+            fRejectedParents = true;\n+            break;\n+        }\n+    }\n+    if (!fRejectedParents) {\n+        uint32_t nFetchFlags = GetFetchFlags(pfrom);\n+        for (const CTxIn& txin : tx.vin) {\n+            CInv _inv(MSG_TX | nFetchFlags, txin.prevout.hash);\n+            pfrom->AddInventoryKnown(_inv);\n+            if (!AlreadyHave(_inv)) pfrom->AskFor(_inv);\n+        }\n+        AddOrphanTx(ptx, pfrom->GetId());\n+\n+        // DoS prevention: do not allow mapOrphanTransactions to grow unbounded\n+        unsigned int nMaxOrphanTx = (unsigned int)std::max((int64_t)0, gArgs.GetArg(\"-maxorphantx\", DEFAULT_MAX_ORPHAN_TRANSACTIONS));\n+        unsigned int nEvicted = LimitOrphanTxSize(nMaxOrphanTx);\n+        if (nEvicted > 0) {\n+            LogPrint(BCLog::MEMPOOL, \"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n+        }\n+    } else {\n+        LogPrint(BCLog::MEMPOOL, \"not keeping orphan with rejected parents %s\\n\",tx.GetHash().ToString());\n+        // We will continue to reject this tx since it has rejected\n+        // parents so avoid re-requesting it from other peers.\n+        recentRejects->insert(tx.GetHash());\n+    }\n+}\n+\n void PeerLogicValidation::ConsiderEviction(CNode *pto, int64_t time_in_seconds)\n {\n     AssertLockHeld(cs_main);"
      }
    ]
  }
]