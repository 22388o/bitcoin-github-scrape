[
  {
    "sha": "20e01b1a03819d843a860284033b48a5e3b65ff7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMGUwMWIxYTAzODE5ZDg0M2E4NjAyODQwMzNiNDhhNWUzYjY1ZmY3",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-09-19T17:21:46Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-09-19T17:21:46Z"
      },
      "message": "Apply clang-format on some infrequently-updated files",
      "tree": {
        "sha": "5b390722b053ce5b448919bda2695d173980ffb5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5b390722b053ce5b448919bda2695d173980ffb5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/20e01b1a03819d843a860284033b48a5e3b65ff7",
      "comment_count": 1,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/20e01b1a03819d843a860284033b48a5e3b65ff7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/20e01b1a03819d843a860284033b48a5e3b65ff7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/20e01b1a03819d843a860284033b48a5e3b65ff7/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2fc6c67400e91846ca1c1c57011e57491013f9bd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2fc6c67400e91846ca1c1c57011e57491013f9bd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2fc6c67400e91846ca1c1c57011e57491013f9bd"
      }
    ],
    "stats": {
      "total": 1591,
      "additions": 847,
      "deletions": 744
    },
    "files": [
      {
        "sha": "7b674a66e7cbfc93dd2628aeabc2578d0793e400",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 110,
        "deletions": 115,
        "changes": 225,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -9,7 +9,7 @@\n \n using namespace std;\n \n-int CAddrInfo::GetTriedBucket(const std::vector<unsigned char> &nKey) const\n+int CAddrInfo::GetTriedBucket(const std::vector<unsigned char>& nKey) const\n {\n     CDataStream ss1(SER_GETHASH, 0);\n     std::vector<unsigned char> vchKey = GetKey();\n@@ -23,7 +23,7 @@ int CAddrInfo::GetTriedBucket(const std::vector<unsigned char> &nKey) const\n     return hash2 % ADDRMAN_TRIED_BUCKET_COUNT;\n }\n \n-int CAddrInfo::GetNewBucket(const std::vector<unsigned char> &nKey, const CNetAddr& src) const\n+int CAddrInfo::GetNewBucket(const std::vector<unsigned char>& nKey, const CNetAddr& src) const\n {\n     CDataStream ss1(SER_GETHASH, 0);\n     std::vector<unsigned char> vchGroupKey = GetGroup();\n@@ -39,19 +39,19 @@ int CAddrInfo::GetNewBucket(const std::vector<unsigned char> &nKey, const CNetAd\n \n bool CAddrInfo::IsTerrible(int64_t nNow) const\n {\n-    if (nLastTry && nLastTry >= nNow-60) // never remove things tried the last minute\n+    if (nLastTry && nLastTry >= nNow - 60) // never remove things tried the last minute\n         return false;\n \n-    if (nTime > nNow + 10*60) // came in a flying DeLorean\n+    if (nTime > nNow + 10 * 60) // came in a flying DeLorean\n         return true;\n \n-    if (nTime==0 || nNow-nTime > ADDRMAN_HORIZON_DAYS*24*60*60) // not seen in recent history\n+    if (nTime == 0 || nNow - nTime > ADDRMAN_HORIZON_DAYS * 24 * 60 * 60) // not seen in recent history\n         return true;\n \n-    if (nLastSuccess==0 && nAttempts>=ADDRMAN_RETRIES) // tried N times and never a success\n+    if (nLastSuccess == 0 && nAttempts >= ADDRMAN_RETRIES) // tried N times and never a success\n         return true;\n \n-    if (nNow-nLastSuccess > ADDRMAN_MIN_FAIL_DAYS*24*60*60 && nAttempts>=ADDRMAN_MAX_FAILURES) // N successive failures in the last week\n+    if (nNow - nLastSuccess > ADDRMAN_MIN_FAIL_DAYS * 24 * 60 * 60 && nAttempts >= ADDRMAN_MAX_FAILURES) // N successive failures in the last week\n         return true;\n \n     return false;\n@@ -64,23 +64,25 @@ double CAddrInfo::GetChance(int64_t nNow) const\n     int64_t nSinceLastSeen = nNow - nTime;\n     int64_t nSinceLastTry = nNow - nLastTry;\n \n-    if (nSinceLastSeen < 0) nSinceLastSeen = 0;\n-    if (nSinceLastTry < 0) nSinceLastTry = 0;\n+    if (nSinceLastSeen < 0)\n+        nSinceLastSeen = 0;\n+    if (nSinceLastTry < 0)\n+        nSinceLastTry = 0;\n \n     fChance *= 600.0 / (600.0 + nSinceLastSeen);\n \n     // deprioritize very recent attempts away\n-    if (nSinceLastTry < 60*10)\n+    if (nSinceLastTry < 60 * 10)\n         fChance *= 0.01;\n \n     // deprioritize 50% after each failed attempt\n-    for (int n=0; n<nAttempts; n++)\n+    for (int n = 0; n < nAttempts; n++)\n         fChance /= 1.5;\n \n     return fChance;\n }\n \n-CAddrInfo* CAddrMan::Find(const CNetAddr& addr, int *pnId)\n+CAddrInfo* CAddrMan::Find(const CNetAddr& addr, int* pnId)\n {\n     std::map<CNetAddr, int>::iterator it = mapAddr.find(addr);\n     if (it == mapAddr.end())\n@@ -93,7 +95,7 @@ CAddrInfo* CAddrMan::Find(const CNetAddr& addr, int *pnId)\n     return NULL;\n }\n \n-CAddrInfo* CAddrMan::Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId)\n+CAddrInfo* CAddrMan::Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId)\n {\n     int nId = nIdCount++;\n     mapInfo[nId] = CAddrInfo(addr, addrSource);\n@@ -127,22 +129,21 @@ void CAddrMan::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2)\n \n int CAddrMan::SelectTried(int nKBucket)\n {\n-    std::vector<int> &vTried = vvTried[nKBucket];\n+    std::vector<int>& vTried = vvTried[nKBucket];\n \n     // random shuffle the first few elements (using the entire list)\n     // find the least recently tried among them\n     int64_t nOldest = -1;\n     int nOldestPos = -1;\n-    for (unsigned int i = 0; i < ADDRMAN_TRIED_ENTRIES_INSPECT_ON_EVICT && i < vTried.size(); i++)\n-    {\n+    for (unsigned int i = 0; i < ADDRMAN_TRIED_ENTRIES_INSPECT_ON_EVICT && i < vTried.size(); i++) {\n         int nPos = GetRandInt(vTried.size() - i) + i;\n         int nTemp = vTried[nPos];\n         vTried[nPos] = vTried[i];\n         vTried[i] = nTemp;\n         assert(nOldest == -1 || mapInfo.count(nTemp) == 1);\n         if (nOldest == -1 || mapInfo[nTemp].nLastSuccess < mapInfo[nOldest].nLastSuccess) {\n-           nOldest = nTemp;\n-           nOldestPos = nPos;\n+            nOldest = nTemp;\n+            nOldestPos = nPos;\n         }\n     }\n \n@@ -152,18 +153,15 @@ int CAddrMan::SelectTried(int nKBucket)\n int CAddrMan::ShrinkNew(int nUBucket)\n {\n     assert(nUBucket >= 0 && (unsigned int)nUBucket < vvNew.size());\n-    std::set<int> &vNew = vvNew[nUBucket];\n+    std::set<int>& vNew = vvNew[nUBucket];\n \n     // first look for deletable items\n-    for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n-    {\n+    for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++) {\n         assert(mapInfo.count(*it));\n-        CAddrInfo &info = mapInfo[*it];\n-        if (info.IsTerrible())\n-        {\n-            if (--info.nRefCount == 0)\n-            {\n-                SwapRandom(info.nRandomPos, vRandom.size()-1);\n+        CAddrInfo& info = mapInfo[*it];\n+        if (info.IsTerrible()) {\n+            if (--info.nRefCount == 0) {\n+                SwapRandom(info.nRandomPos, vRandom.size() - 1);\n                 vRandom.pop_back();\n                 mapAddr.erase(info);\n                 mapInfo.erase(*it);\n@@ -178,21 +176,18 @@ int CAddrMan::ShrinkNew(int nUBucket)\n     int n[4] = {GetRandInt(vNew.size()), GetRandInt(vNew.size()), GetRandInt(vNew.size()), GetRandInt(vNew.size())};\n     int nI = 0;\n     int nOldest = -1;\n-    for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n-    {\n-        if (nI == n[0] || nI == n[1] || nI == n[2] || nI == n[3])\n-        {\n+    for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++) {\n+        if (nI == n[0] || nI == n[1] || nI == n[2] || nI == n[3]) {\n             assert(nOldest == -1 || mapInfo.count(*it) == 1);\n             if (nOldest == -1 || mapInfo[*it].nTime < mapInfo[nOldest].nTime)\n                 nOldest = *it;\n         }\n         nI++;\n     }\n     assert(mapInfo.count(nOldest) == 1);\n-    CAddrInfo &info = mapInfo[nOldest];\n-    if (--info.nRefCount == 0)\n-    {\n-        SwapRandom(info.nRandomPos, vRandom.size()-1);\n+    CAddrInfo& info = mapInfo[nOldest];\n+    if (--info.nRefCount == 0) {\n+        SwapRandom(info.nRandomPos, vRandom.size() - 1);\n         vRandom.pop_back();\n         mapAddr.erase(info);\n         mapInfo.erase(nOldest);\n@@ -208,8 +203,7 @@ void CAddrMan::MakeTried(CAddrInfo& info, int nId, int nOrigin)\n     assert(vvNew[nOrigin].count(nId) == 1);\n \n     // remove the entry from all new buckets\n-    for (std::vector<std::set<int> >::iterator it = vvNew.begin(); it != vvNew.end(); it++)\n-    {\n+    for (std::vector<std::set<int> >::iterator it = vvNew.begin(); it != vvNew.end(); it++) {\n         if ((*it).erase(nId))\n             info.nRefCount--;\n     }\n@@ -219,11 +213,10 @@ void CAddrMan::MakeTried(CAddrInfo& info, int nId, int nOrigin)\n \n     // what tried bucket to move the entry to\n     int nKBucket = info.GetTriedBucket(nKey);\n-    std::vector<int> &vTried = vvTried[nKBucket];\n+    std::vector<int>& vTried = vvTried[nKBucket];\n \n     // first check whether there is place to just add it\n-    if (vTried.size() < ADDRMAN_TRIED_BUCKET_SIZE)\n-    {\n+    if (vTried.size() < ADDRMAN_TRIED_BUCKET_SIZE) {\n         vTried.push_back(nId);\n         nTried++;\n         info.fInTried = true;\n@@ -236,7 +229,7 @@ void CAddrMan::MakeTried(CAddrInfo& info, int nId, int nOrigin)\n     // find which new bucket it belongs to\n     assert(mapInfo.count(vTried[nPos]) == 1);\n     int nUBucket = mapInfo[vTried[nPos]].GetNewBucket(nKey);\n-    std::set<int> &vNew = vvNew[nUBucket];\n+    std::set<int>& vNew = vvNew[nUBucket];\n \n     // remove the to-be-replaced tried entry from the tried set\n     CAddrInfo& infoOld = mapInfo[vTried[nPos]];\n@@ -245,8 +238,7 @@ void CAddrMan::MakeTried(CAddrInfo& info, int nId, int nOrigin)\n     // do not update nTried, as we are going to move something else there immediately\n \n     // check whether there is place in that one,\n-    if (vNew.size() < ADDRMAN_NEW_BUCKET_SIZE)\n-    {\n+    if (vNew.size() < ADDRMAN_NEW_BUCKET_SIZE) {\n         // if so, move it back there\n         vNew.insert(vTried[nPos]);\n     } else {\n@@ -261,16 +253,16 @@ void CAddrMan::MakeTried(CAddrInfo& info, int nId, int nOrigin)\n     return;\n }\n \n-void CAddrMan::Good_(const CService &addr, int64_t nTime)\n+void CAddrMan::Good_(const CService& addr, int64_t nTime)\n {\n     int nId;\n-    CAddrInfo *pinfo = Find(addr, &nId);\n+    CAddrInfo* pinfo = Find(addr, &nId);\n \n     // if not found, bail out\n     if (!pinfo)\n         return;\n \n-    CAddrInfo &info = *pinfo;\n+    CAddrInfo& info = *pinfo;\n \n     // check whether we are talking about the exact same CService (including same port)\n     if (info != addr)\n@@ -289,38 +281,36 @@ void CAddrMan::Good_(const CService &addr, int64_t nTime)\n     // find a bucket it is in now\n     int nRnd = GetRandInt(vvNew.size());\n     int nUBucket = -1;\n-    for (unsigned int n = 0; n < vvNew.size(); n++)\n-    {\n-        int nB = (n+nRnd) % vvNew.size();\n-        std::set<int> &vNew = vvNew[nB];\n-        if (vNew.count(nId))\n-        {\n+    for (unsigned int n = 0; n < vvNew.size(); n++) {\n+        int nB = (n + nRnd) % vvNew.size();\n+        std::set<int>& vNew = vvNew[nB];\n+        if (vNew.count(nId)) {\n             nUBucket = nB;\n             break;\n         }\n     }\n \n     // if no bucket is found, something bad happened;\n     // TODO: maybe re-add the node, but for now, just bail out\n-    if (nUBucket == -1) return;\n+    if (nUBucket == -1)\n+        return;\n \n     LogPrint(\"addrman\", \"Moving %s to tried\\n\", addr.ToString());\n \n     // move nId to the tried tables\n     MakeTried(info, nId, nUBucket);\n }\n \n-bool CAddrMan::Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty)\n+bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimePenalty)\n {\n     if (!addr.IsRoutable())\n         return false;\n \n     bool fNew = false;\n     int nId;\n-    CAddrInfo *pinfo = Find(addr, &nId);\n+    CAddrInfo* pinfo = Find(addr, &nId);\n \n-    if (pinfo)\n-    {\n+    if (pinfo) {\n         // periodically update nTime\n         bool fCurrentlyOnline = (GetAdjustedTime() - addr.nTime < 24 * 60 * 60);\n         int64_t nUpdateInterval = (fCurrentlyOnline ? 60 * 60 : 24 * 60 * 60);\n@@ -344,7 +334,7 @@ bool CAddrMan::Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimeP\n \n         // stochastic test: previous nRefCount == N: 2^N times harder to increase it\n         int nFactor = 1;\n-        for (int n=0; n<pinfo->nRefCount; n++)\n+        for (int n = 0; n < pinfo->nRefCount; n++)\n             nFactor *= 2;\n         if (nFactor > 1 && (GetRandInt(nFactor) != 0))\n             return false;\n@@ -356,9 +346,8 @@ bool CAddrMan::Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimeP\n     }\n \n     int nUBucket = pinfo->GetNewBucket(nKey, source);\n-    std::set<int> &vNew = vvNew[nUBucket];\n-    if (!vNew.count(nId))\n-    {\n+    std::set<int>& vNew = vvNew[nUBucket];\n+    if (!vNew.count(nId)) {\n         pinfo->nRefCount++;\n         if (vNew.size() == ADDRMAN_NEW_BUCKET_SIZE)\n             ShrinkNew(nUBucket);\n@@ -367,15 +356,15 @@ bool CAddrMan::Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimeP\n     return fNew;\n }\n \n-void CAddrMan::Attempt_(const CService &addr, int64_t nTime)\n+void CAddrMan::Attempt_(const CService& addr, int64_t nTime)\n {\n-    CAddrInfo *pinfo = Find(addr);\n+    CAddrInfo* pinfo = Find(addr);\n \n     // if not found, bail out\n     if (!pinfo)\n         return;\n \n-    CAddrInfo &info = *pinfo;\n+    CAddrInfo& info = *pinfo;\n \n     // check whether we are talking about the exact same CService (including same port)\n     if (info != addr)\n@@ -393,37 +382,36 @@ CAddress CAddrMan::Select_(int nUnkBias)\n \n     double nCorTried = sqrt(nTried) * (100.0 - nUnkBias);\n     double nCorNew = sqrt(nNew) * nUnkBias;\n-    if ((nCorTried + nCorNew)*GetRandInt(1<<30)/(1<<30) < nCorTried)\n-    {\n+    if ((nCorTried + nCorNew) * GetRandInt(1 << 30) / (1 << 30) < nCorTried) {\n         // use a tried node\n         double fChanceFactor = 1.0;\n-        while(1)\n-        {\n+        while (1) {\n             int nKBucket = GetRandInt(vvTried.size());\n-            std::vector<int> &vTried = vvTried[nKBucket];\n-            if (vTried.size() == 0) continue;\n+            std::vector<int>& vTried = vvTried[nKBucket];\n+            if (vTried.size() == 0)\n+                continue;\n             int nPos = GetRandInt(vTried.size());\n             assert(mapInfo.count(vTried[nPos]) == 1);\n-            CAddrInfo &info = mapInfo[vTried[nPos]];\n-            if (GetRandInt(1<<30) < fChanceFactor*info.GetChance()*(1<<30))\n+            CAddrInfo& info = mapInfo[vTried[nPos]];\n+            if (GetRandInt(1 << 30) < fChanceFactor * info.GetChance() * (1 << 30))\n                 return info;\n             fChanceFactor *= 1.2;\n         }\n     } else {\n         // use a new node\n         double fChanceFactor = 1.0;\n-        while(1)\n-        {\n+        while (1) {\n             int nUBucket = GetRandInt(vvNew.size());\n-            std::set<int> &vNew = vvNew[nUBucket];\n-            if (vNew.size() == 0) continue;\n+            std::set<int>& vNew = vvNew[nUBucket];\n+            if (vNew.size() == 0)\n+                continue;\n             int nPos = GetRandInt(vNew.size());\n             std::set<int>::iterator it = vNew.begin();\n             while (nPos--)\n                 it++;\n             assert(mapInfo.count(*it) == 1);\n-            CAddrInfo &info = mapInfo[*it];\n-            if (GetRandInt(1<<30) < fChanceFactor*info.GetChance()*(1<<30))\n+            CAddrInfo& info = mapInfo[*it];\n+            if (GetRandInt(1 << 30) < fChanceFactor * info.GetChance() * (1 << 30))\n                 return info;\n             fChanceFactor *= 1.2;\n         }\n@@ -436,69 +424,76 @@ int CAddrMan::Check_()\n     std::set<int> setTried;\n     std::map<int, int> mapNew;\n \n-    if (vRandom.size() != nTried + nNew) return -7;\n+    if (vRandom.size() != nTried + nNew)\n+        return -7;\n \n-    for (std::map<int, CAddrInfo>::iterator it = mapInfo.begin(); it != mapInfo.end(); it++)\n-    {\n+    for (std::map<int, CAddrInfo>::iterator it = mapInfo.begin(); it != mapInfo.end(); it++) {\n         int n = (*it).first;\n-        CAddrInfo &info = (*it).second;\n-        if (info.fInTried)\n-        {\n-\n-            if (!info.nLastSuccess) return -1;\n-            if (info.nRefCount) return -2;\n+        CAddrInfo& info = (*it).second;\n+        if (info.fInTried) {\n+            if (!info.nLastSuccess)\n+                return -1;\n+            if (info.nRefCount)\n+                return -2;\n             setTried.insert(n);\n         } else {\n-            if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS) return -3;\n-            if (!info.nRefCount) return -4;\n+            if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)\n+                return -3;\n+            if (!info.nRefCount)\n+                return -4;\n             mapNew[n] = info.nRefCount;\n         }\n-        if (mapAddr[info] != n) return -5;\n-        if (info.nRandomPos<0 || info.nRandomPos>=vRandom.size() || vRandom[info.nRandomPos] != n) return -14;\n-        if (info.nLastTry < 0) return -6;\n-        if (info.nLastSuccess < 0) return -8;\n+        if (mapAddr[info] != n)\n+            return -5;\n+        if (info.nRandomPos < 0 || info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)\n+            return -14;\n+        if (info.nLastTry < 0)\n+            return -6;\n+        if (info.nLastSuccess < 0)\n+            return -8;\n     }\n \n-    if (setTried.size() != nTried) return -9;\n-    if (mapNew.size() != nNew) return -10;\n+    if (setTried.size() != nTried)\n+        return -9;\n+    if (mapNew.size() != nNew)\n+        return -10;\n \n-    for (int n=0; n<vvTried.size(); n++)\n-    {\n-        std::vector<int> &vTried = vvTried[n];\n-        for (std::vector<int>::iterator it = vTried.begin(); it != vTried.end(); it++)\n-        {\n-            if (!setTried.count(*it)) return -11;\n+    for (int n = 0; n < vvTried.size(); n++) {\n+        std::vector<int>& vTried = vvTried[n];\n+        for (std::vector<int>::iterator it = vTried.begin(); it != vTried.end(); it++) {\n+            if (!setTried.count(*it))\n+                return -11;\n             setTried.erase(*it);\n         }\n     }\n \n-    for (int n=0; n<vvNew.size(); n++)\n-    {\n-        std::set<int> &vNew = vvNew[n];\n-        for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n-        {\n-            if (!mapNew.count(*it)) return -12;\n+    for (int n = 0; n < vvNew.size(); n++) {\n+        std::set<int>& vNew = vvNew[n];\n+        for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++) {\n+            if (!mapNew.count(*it))\n+                return -12;\n             if (--mapNew[*it] == 0)\n                 mapNew.erase(*it);\n         }\n     }\n \n-    if (setTried.size()) return -13;\n-    if (mapNew.size()) return -15;\n+    if (setTried.size())\n+        return -13;\n+    if (mapNew.size())\n+        return -15;\n \n     return 0;\n }\n #endif\n \n-void CAddrMan::GetAddr_(std::vector<CAddress> &vAddr)\n+void CAddrMan::GetAddr_(std::vector<CAddress>& vAddr)\n {\n     unsigned int nNodes = ADDRMAN_GETADDR_MAX_PCT * vRandom.size() / 100;\n     if (nNodes > ADDRMAN_GETADDR_MAX)\n         nNodes = ADDRMAN_GETADDR_MAX;\n \n     // gather a list of random nodes, skipping those of low quality\n-    for (unsigned int n = 0; n < vRandom.size(); n++)\n-    {\n+    for (unsigned int n = 0; n < vRandom.size(); n++) {\n         if (vAddr.size() >= nNodes)\n             break;\n \n@@ -512,15 +507,15 @@ void CAddrMan::GetAddr_(std::vector<CAddress> &vAddr)\n     }\n }\n \n-void CAddrMan::Connected_(const CService &addr, int64_t nTime)\n+void CAddrMan::Connected_(const CService& addr, int64_t nTime)\n {\n-    CAddrInfo *pinfo = Find(addr);\n+    CAddrInfo* pinfo = Find(addr);\n \n     // if not found, bail out\n     if (!pinfo)\n         return;\n \n-    CAddrInfo &info = *pinfo;\n+    CAddrInfo& info = *pinfo;\n \n     // check whether we are talking about the exact same CService (including same port)\n     if (info != addr)"
      },
      {
        "sha": "dfe26f1b1e222196f6a76391bbb783572a51eabb",
        "filename": "src/allocators.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/allocators.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/allocators.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/allocators.cpp?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -37,13 +37,13 @@ static inline size_t GetSystemPageSize()\n     page_size = sSysInfo.dwPageSize;\n #elif defined(PAGESIZE) // defined in limits.h\n     page_size = PAGESIZE;\n-#else // assume some POSIX OS\n+#else                   // assume some POSIX OS\n     page_size = sysconf(_SC_PAGESIZE);\n #endif\n     return page_size;\n }\n \n-bool MemoryPageLocker::Lock(const void *addr, size_t len)\n+bool MemoryPageLocker::Lock(const void* addr, size_t len)\n {\n #ifdef WIN32\n     return VirtualLock(const_cast<void*>(addr), len) != 0;\n@@ -52,7 +52,7 @@ bool MemoryPageLocker::Lock(const void *addr, size_t len)\n #endif\n }\n \n-bool MemoryPageLocker::Unlock(const void *addr, size_t len)\n+bool MemoryPageLocker::Unlock(const void* addr, size_t len)\n {\n #ifdef WIN32\n     return VirtualUnlock(const_cast<void*>(addr), len) != 0;\n@@ -64,4 +64,3 @@ bool MemoryPageLocker::Unlock(const void *addr, size_t len)\n LockedPageManager::LockedPageManager() : LockedPageManagerBase<MemoryPageLocker>(GetSystemPageSize())\n {\n }\n-"
      },
      {
        "sha": "6b69e7ae69cf28f658588ea81011d69ff351d312",
        "filename": "src/allocators.h",
        "status": "modified",
        "additions": 49,
        "deletions": 41,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/allocators.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/allocators.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/allocators.h?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -26,14 +26,14 @@\n  * small objects that span up to a few pages, mostly smaller than a page. To support large allocations,\n  * something like an interval tree would be the preferred data structure.\n  */\n-template <class Locker> class LockedPageManagerBase\n+template <class Locker>\n+class LockedPageManagerBase\n {\n public:\n-    LockedPageManagerBase(size_t page_size):\n-        page_size(page_size)\n+    LockedPageManagerBase(size_t page_size) : page_size(page_size)\n     {\n         // Determine bitmask for extracting page from address\n-        assert(!(page_size & (page_size-1))); // size must be power of two\n+        assert(!(page_size & (page_size - 1))); // size must be power of two\n         page_mask = ~(page_size - 1);\n     }\n \n@@ -44,43 +44,42 @@ template <class Locker> class LockedPageManagerBase\n \n \n     // For all pages in affected range, increase lock count\n-    void LockRange(void *p, size_t size)\n+    void LockRange(void* p, size_t size)\n     {\n         boost::mutex::scoped_lock lock(mutex);\n-        if(!size) return;\n+        if (!size)\n+            return;\n         const size_t base_addr = reinterpret_cast<size_t>(p);\n         const size_t start_page = base_addr & page_mask;\n         const size_t end_page = (base_addr + size - 1) & page_mask;\n-        for(size_t page = start_page; page <= end_page; page += page_size)\n-        {\n+        for (size_t page = start_page; page <= end_page; page += page_size) {\n             Histogram::iterator it = histogram.find(page);\n-            if(it == histogram.end()) // Newly locked page\n+            if (it == histogram.end()) // Newly locked page\n             {\n                 locker.Lock(reinterpret_cast<void*>(page), page_size);\n                 histogram.insert(std::make_pair(page, 1));\n-            }\n-            else // Page was already locked; increase counter\n+            } else // Page was already locked; increase counter\n             {\n                 it->second += 1;\n             }\n         }\n     }\n \n     // For all pages in affected range, decrease lock count\n-    void UnlockRange(void *p, size_t size)\n+    void UnlockRange(void* p, size_t size)\n     {\n         boost::mutex::scoped_lock lock(mutex);\n-        if(!size) return;\n+        if (!size)\n+            return;\n         const size_t base_addr = reinterpret_cast<size_t>(p);\n         const size_t start_page = base_addr & page_mask;\n         const size_t end_page = (base_addr + size - 1) & page_mask;\n-        for(size_t page = start_page; page <= end_page; page += page_size)\n-        {\n+        for (size_t page = start_page; page <= end_page; page += page_size) {\n             Histogram::iterator it = histogram.find(page);\n             assert(it != histogram.end()); // Cannot unlock an area that was not locked\n             // Decrease counter for page, when it is zero, the page will be unlocked\n             it->second -= 1;\n-            if(it->second == 0) // Nothing on the page anymore that keeps it locked\n+            if (it->second == 0) // Nothing on the page anymore that keeps it locked\n             {\n                 // Unlock page and remove the count from histogram\n                 locker.Unlock(reinterpret_cast<void*>(page), page_size);\n@@ -101,7 +100,7 @@ template <class Locker> class LockedPageManagerBase\n     boost::mutex mutex;\n     size_t page_size, page_mask;\n     // map of page base address to lock count\n-    typedef std::map<size_t,int> Histogram;\n+    typedef std::map<size_t, int> Histogram;\n     Histogram histogram;\n };\n \n@@ -116,11 +115,11 @@ class MemoryPageLocker\n     /** Lock memory pages.\n      * addr and len must be a multiple of the system page size\n      */\n-    bool Lock(const void *addr, size_t len);\n+    bool Lock(const void* addr, size_t len);\n     /** Unlock memory pages.\n      * addr and len must be a multiple of the system page size\n      */\n-    bool Unlock(const void *addr, size_t len);\n+    bool Unlock(const void* addr, size_t len);\n };\n \n /**\n@@ -134,10 +133,10 @@ class MemoryPageLocker\n  * secure_allocator are created. So instead of having LockedPageManager also be\n  * static-initialized, it is created on demand.\n  */\n-class LockedPageManager: public LockedPageManagerBase<MemoryPageLocker>\n+class LockedPageManager : public LockedPageManagerBase<MemoryPageLocker>\n {\n public:\n-    static LockedPageManager& Instance() \n+    static LockedPageManager& Instance()\n     {\n         boost::call_once(LockedPageManager::CreateInstance, LockedPageManager::init_flag);\n         return *LockedPageManager::_instance;\n@@ -165,11 +164,15 @@ class LockedPageManager: public LockedPageManagerBase<MemoryPageLocker>\n // Functions for directly locking/unlocking memory objects.\n // Intended for non-dynamically allocated structures.\n //\n-template<typename T> void LockObject(const T &t) {\n+template <typename T>\n+void LockObject(const T& t)\n+{\n     LockedPageManager::Instance().LockRange((void*)(&t), sizeof(T));\n }\n \n-template<typename T> void UnlockObject(const T &t) {\n+template <typename T>\n+void UnlockObject(const T& t)\n+{\n     OPENSSL_cleanse((void*)(&t), sizeof(T));\n     LockedPageManager::Instance().UnlockRange((void*)(&t), sizeof(T));\n }\n@@ -178,13 +181,12 @@ template<typename T> void UnlockObject(const T &t) {\n // Allocator that locks its contents from being paged\n // out of memory and clears its contents before deletion.\n //\n-template<typename T>\n-struct secure_allocator : public std::allocator<T>\n-{\n+template <typename T>\n+struct secure_allocator : public std::allocator<T> {\n     // MSVC8 default copy constructor is broken\n     typedef std::allocator<T> base;\n     typedef typename base::size_type size_type;\n-    typedef typename base::difference_type  difference_type;\n+    typedef typename base::difference_type difference_type;\n     typedef typename base::pointer pointer;\n     typedef typename base::const_pointer const_pointer;\n     typedef typename base::reference reference;\n@@ -193,14 +195,18 @@ struct secure_allocator : public std::allocator<T>\n     secure_allocator() throw() {}\n     secure_allocator(const secure_allocator& a) throw() : base(a) {}\n     template <typename U>\n-    secure_allocator(const secure_allocator<U>& a) throw() : base(a) {}\n+    secure_allocator(const secure_allocator<U>& a) throw() : base(a)\n+    {\n+    }\n     ~secure_allocator() throw() {}\n-    template<typename _Other> struct rebind\n-    { typedef secure_allocator<_Other> other; };\n+    template <typename _Other>\n+    struct rebind {\n+        typedef secure_allocator<_Other> other;\n+    };\n \n-    T* allocate(std::size_t n, const void *hint = 0)\n+    T* allocate(std::size_t n, const void* hint = 0)\n     {\n-        T *p;\n+        T* p;\n         p = std::allocator<T>::allocate(n, hint);\n         if (p != NULL)\n             LockedPageManager::Instance().LockRange(p, sizeof(T) * n);\n@@ -209,8 +215,7 @@ struct secure_allocator : public std::allocator<T>\n \n     void deallocate(T* p, std::size_t n)\n     {\n-        if (p != NULL)\n-        {\n+        if (p != NULL) {\n             OPENSSL_cleanse(p, sizeof(T) * n);\n             LockedPageManager::Instance().UnlockRange(p, sizeof(T) * n);\n         }\n@@ -222,13 +227,12 @@ struct secure_allocator : public std::allocator<T>\n //\n // Allocator that clears its contents before deletion.\n //\n-template<typename T>\n-struct zero_after_free_allocator : public std::allocator<T>\n-{\n+template <typename T>\n+struct zero_after_free_allocator : public std::allocator<T> {\n     // MSVC8 default copy constructor is broken\n     typedef std::allocator<T> base;\n     typedef typename base::size_type size_type;\n-    typedef typename base::difference_type  difference_type;\n+    typedef typename base::difference_type difference_type;\n     typedef typename base::pointer pointer;\n     typedef typename base::const_pointer const_pointer;\n     typedef typename base::reference reference;\n@@ -237,10 +241,14 @@ struct zero_after_free_allocator : public std::allocator<T>\n     zero_after_free_allocator() throw() {}\n     zero_after_free_allocator(const zero_after_free_allocator& a) throw() : base(a) {}\n     template <typename U>\n-    zero_after_free_allocator(const zero_after_free_allocator<U>& a) throw() : base(a) {}\n+    zero_after_free_allocator(const zero_after_free_allocator<U>& a) throw() : base(a)\n+    {\n+    }\n     ~zero_after_free_allocator() throw() {}\n-    template<typename _Other> struct rebind\n-    { typedef zero_after_free_allocator<_Other> other; };\n+    template <typename _Other>\n+    struct rebind {\n+        typedef zero_after_free_allocator<_Other> other;\n+    };\n \n     void deallocate(T* p, std::size_t n)\n     {"
      },
      {
        "sha": "9750f0a161d9e4221c7dfd870ea12dd8ee3cf605",
        "filename": "src/base58.cpp",
        "status": "modified",
        "additions": 80,
        "deletions": 49,
        "changes": 129,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/base58.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/base58.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.cpp?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -18,7 +18,8 @@\n /* All alphanumeric characters except for \"0\", \"I\", \"O\", and \"l\" */\n static const char* pszBase58 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n \n-bool DecodeBase58(const char *psz, std::vector<unsigned char>& vch) {\n+bool DecodeBase58(const char* psz, std::vector<unsigned char>& vch)\n+{\n     // Skip leading spaces.\n     while (*psz && isspace(*psz))\n         psz++;\n@@ -33,7 +34,7 @@ bool DecodeBase58(const char *psz, std::vector<unsigned char>& vch) {\n     // Process the characters.\n     while (*psz && !isspace(*psz)) {\n         // Decode base58 character\n-        const char *ch = strchr(pszBase58, *psz);\n+        const char* ch = strchr(pszBase58, *psz);\n         if (ch == NULL)\n             return false;\n         // Apply \"b256 = b256 * 58 + ch\".\n@@ -59,11 +60,12 @@ bool DecodeBase58(const char *psz, std::vector<unsigned char>& vch) {\n     vch.reserve(zeroes + (b256.end() - it));\n     vch.assign(zeroes, 0x00);\n     while (it != b256.end())\n-      vch.push_back(*(it++));\n+        vch.push_back(*(it++));\n     return true;\n }\n \n-std::string EncodeBase58(const unsigned char* pbegin, const unsigned char* pend) {\n+std::string EncodeBase58(const unsigned char* pbegin, const unsigned char* pend)\n+{\n     // Skip & count leading zeroes.\n     int zeroes = 0;\n     while (pbegin != pend && *pbegin == 0) {\n@@ -97,61 +99,68 @@ std::string EncodeBase58(const unsigned char* pbegin, const unsigned char* pend)\n     return str;\n }\n \n-std::string EncodeBase58(const std::vector<unsigned char>& vch) {\n+std::string EncodeBase58(const std::vector<unsigned char>& vch)\n+{\n     return EncodeBase58(&vch[0], &vch[0] + vch.size());\n }\n \n-bool DecodeBase58(const std::string& str, std::vector<unsigned char>& vchRet) {\n+bool DecodeBase58(const std::string& str, std::vector<unsigned char>& vchRet)\n+{\n     return DecodeBase58(str.c_str(), vchRet);\n }\n \n-std::string EncodeBase58Check(const std::vector<unsigned char>& vchIn) {\n+std::string EncodeBase58Check(const std::vector<unsigned char>& vchIn)\n+{\n     // add 4-byte hash check to the end\n     std::vector<unsigned char> vch(vchIn);\n     uint256 hash = Hash(vch.begin(), vch.end());\n     vch.insert(vch.end(), (unsigned char*)&hash, (unsigned char*)&hash + 4);\n     return EncodeBase58(vch);\n }\n \n-bool DecodeBase58Check(const char* psz, std::vector<unsigned char>& vchRet) {\n+bool DecodeBase58Check(const char* psz, std::vector<unsigned char>& vchRet)\n+{\n     if (!DecodeBase58(psz, vchRet) ||\n-        (vchRet.size() < 4))\n-    {\n+        (vchRet.size() < 4)) {\n         vchRet.clear();\n         return false;\n     }\n     // re-calculate the checksum, insure it matches the included 4-byte checksum\n-    uint256 hash = Hash(vchRet.begin(), vchRet.end()-4);\n-    if (memcmp(&hash, &vchRet.end()[-4], 4) != 0)\n-    {\n+    uint256 hash = Hash(vchRet.begin(), vchRet.end() - 4);\n+    if (memcmp(&hash, &vchRet.end()[-4], 4) != 0) {\n         vchRet.clear();\n         return false;\n     }\n-    vchRet.resize(vchRet.size()-4);\n+    vchRet.resize(vchRet.size() - 4);\n     return true;\n }\n \n-bool DecodeBase58Check(const std::string& str, std::vector<unsigned char>& vchRet) {\n+bool DecodeBase58Check(const std::string& str, std::vector<unsigned char>& vchRet)\n+{\n     return DecodeBase58Check(str.c_str(), vchRet);\n }\n \n-CBase58Data::CBase58Data() {\n+CBase58Data::CBase58Data()\n+{\n     vchVersion.clear();\n     vchData.clear();\n }\n \n-void CBase58Data::SetData(const std::vector<unsigned char> &vchVersionIn, const void* pdata, size_t nSize) {\n+void CBase58Data::SetData(const std::vector<unsigned char>& vchVersionIn, const void* pdata, size_t nSize)\n+{\n     vchVersion = vchVersionIn;\n     vchData.resize(nSize);\n     if (!vchData.empty())\n         memcpy(&vchData[0], pdata, nSize);\n }\n \n-void CBase58Data::SetData(const std::vector<unsigned char> &vchVersionIn, const unsigned char *pbegin, const unsigned char *pend) {\n+void CBase58Data::SetData(const std::vector<unsigned char>& vchVersionIn, const unsigned char* pbegin, const unsigned char* pend)\n+{\n     SetData(vchVersionIn, (void*)pbegin, pend - pbegin);\n }\n \n-bool CBase58Data::SetString(const char* psz, unsigned int nVersionBytes) {\n+bool CBase58Data::SetString(const char* psz, unsigned int nVersionBytes)\n+{\n     std::vector<unsigned char> vchTemp;\n     bool rc58 = DecodeBase58Check(psz, vchTemp);\n     if ((!rc58) || (vchTemp.size() < nVersionBytes)) {\n@@ -167,65 +176,80 @@ bool CBase58Data::SetString(const char* psz, unsigned int nVersionBytes) {\n     return true;\n }\n \n-bool CBase58Data::SetString(const std::string& str) {\n+bool CBase58Data::SetString(const std::string& str)\n+{\n     return SetString(str.c_str());\n }\n \n-std::string CBase58Data::ToString() const {\n+std::string CBase58Data::ToString() const\n+{\n     std::vector<unsigned char> vch = vchVersion;\n     vch.insert(vch.end(), vchData.begin(), vchData.end());\n     return EncodeBase58Check(vch);\n }\n \n-int CBase58Data::CompareTo(const CBase58Data& b58) const {\n-    if (vchVersion < b58.vchVersion) return -1;\n-    if (vchVersion > b58.vchVersion) return  1;\n-    if (vchData < b58.vchData)   return -1;\n-    if (vchData > b58.vchData)   return  1;\n+int CBase58Data::CompareTo(const CBase58Data& b58) const\n+{\n+    if (vchVersion < b58.vchVersion)\n+        return -1;\n+    if (vchVersion > b58.vchVersion)\n+        return 1;\n+    if (vchData < b58.vchData)\n+        return -1;\n+    if (vchData > b58.vchData)\n+        return 1;\n     return 0;\n }\n \n-namespace {\n+namespace\n+{\n+class CBitcoinAddressVisitor : public boost::static_visitor<bool>\n+{\n+private:\n+    CBitcoinAddress* addr;\n \n-    class CBitcoinAddressVisitor : public boost::static_visitor<bool> {\n-    private:\n-        CBitcoinAddress *addr;\n-    public:\n-        CBitcoinAddressVisitor(CBitcoinAddress *addrIn) : addr(addrIn) { }\n+public:\n+    CBitcoinAddressVisitor(CBitcoinAddress* addrIn) : addr(addrIn) {}\n \n-        bool operator()(const CKeyID &id) const { return addr->Set(id); }\n-        bool operator()(const CScriptID &id) const { return addr->Set(id); }\n-        bool operator()(const CNoDestination &no) const { return false; }\n-    };\n+    bool operator()(const CKeyID& id) const { return addr->Set(id); }\n+    bool operator()(const CScriptID& id) const { return addr->Set(id); }\n+    bool operator()(const CNoDestination& no) const { return false; }\n+};\n \n } // anon namespace\n \n-bool CBitcoinAddress::Set(const CKeyID &id) {\n+bool CBitcoinAddress::Set(const CKeyID& id)\n+{\n     SetData(Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS), &id, 20);\n     return true;\n }\n \n-bool CBitcoinAddress::Set(const CScriptID &id) {\n+bool CBitcoinAddress::Set(const CScriptID& id)\n+{\n     SetData(Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS), &id, 20);\n     return true;\n }\n \n-bool CBitcoinAddress::Set(const CTxDestination &dest) {\n+bool CBitcoinAddress::Set(const CTxDestination& dest)\n+{\n     return boost::apply_visitor(CBitcoinAddressVisitor(this), dest);\n }\n \n-bool CBitcoinAddress::IsValid() const {\n+bool CBitcoinAddress::IsValid() const\n+{\n     return IsValid(Params());\n }\n \n-bool CBitcoinAddress::IsValid(const CChainParams &params) const {\n+bool CBitcoinAddress::IsValid(const CChainParams& params) const\n+{\n     bool fCorrectSize = vchData.size() == 20;\n     bool fKnownVersion = vchVersion == params.Base58Prefix(CChainParams::PUBKEY_ADDRESS) ||\n                          vchVersion == params.Base58Prefix(CChainParams::SCRIPT_ADDRESS);\n     return fCorrectSize && fKnownVersion;\n }\n \n-CTxDestination CBitcoinAddress::Get() const {\n+CTxDestination CBitcoinAddress::Get() const\n+{\n     if (!IsValid())\n         return CNoDestination();\n     uint160 id;\n@@ -238,7 +262,8 @@ CTxDestination CBitcoinAddress::Get() const {\n         return CNoDestination();\n }\n \n-bool CBitcoinAddress::GetKeyID(CKeyID &keyID) const {\n+bool CBitcoinAddress::GetKeyID(CKeyID& keyID) const\n+{\n     if (!IsValid() || vchVersion != Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS))\n         return false;\n     uint160 id;\n@@ -247,33 +272,39 @@ bool CBitcoinAddress::GetKeyID(CKeyID &keyID) const {\n     return true;\n }\n \n-bool CBitcoinAddress::IsScript() const {\n+bool CBitcoinAddress::IsScript() const\n+{\n     return IsValid() && vchVersion == Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS);\n }\n \n-void CBitcoinSecret::SetKey(const CKey& vchSecret) {\n+void CBitcoinSecret::SetKey(const CKey& vchSecret)\n+{\n     assert(vchSecret.IsValid());\n     SetData(Params().Base58Prefix(CChainParams::SECRET_KEY), vchSecret.begin(), vchSecret.size());\n     if (vchSecret.IsCompressed())\n         vchData.push_back(1);\n }\n \n-CKey CBitcoinSecret::GetKey() {\n+CKey CBitcoinSecret::GetKey()\n+{\n     CKey ret;\n     ret.Set(&vchData[0], &vchData[32], vchData.size() > 32 && vchData[32] == 1);\n     return ret;\n }\n \n-bool CBitcoinSecret::IsValid() const {\n+bool CBitcoinSecret::IsValid() const\n+{\n     bool fExpectedFormat = vchData.size() == 32 || (vchData.size() == 33 && vchData[32] == 1);\n     bool fCorrectVersion = vchVersion == Params().Base58Prefix(CChainParams::SECRET_KEY);\n     return fExpectedFormat && fCorrectVersion;\n }\n \n-bool CBitcoinSecret::SetString(const char* pszSecret) {\n+bool CBitcoinSecret::SetString(const char* pszSecret)\n+{\n     return CBase58Data::SetString(pszSecret) && IsValid();\n }\n \n-bool CBitcoinSecret::SetString(const std::string& strSecret) {\n+bool CBitcoinSecret::SetString(const std::string& strSecret)\n+{\n     return SetString(strSecret.c_str());\n }"
      },
      {
        "sha": "98bb5b855fe3a10ca351dd2a7ab4a30417f81f66",
        "filename": "src/chainparamsbase.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 23,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/chainparamsbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/chainparamsbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsbase.cpp?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -17,9 +17,11 @@ using namespace boost::assign;\n // Main network\n //\n \n-class CBaseMainParams : public CBaseChainParams {\n+class CBaseMainParams : public CBaseChainParams\n+{\n public:\n-    CBaseMainParams() {\n+    CBaseMainParams()\n+    {\n         networkID = CBaseChainParams::MAIN;\n         nRPCPort = 8332;\n     }\n@@ -29,9 +31,11 @@ static CBaseMainParams mainParams;\n //\n // Testnet (v3)\n //\n-class CBaseTestNetParams : public CBaseMainParams {\n+class CBaseTestNetParams : public CBaseMainParams\n+{\n public:\n-    CBaseTestNetParams() {\n+    CBaseTestNetParams()\n+    {\n         networkID = CBaseChainParams::TESTNET;\n         nRPCPort = 18332;\n         strDataDir = \"testnet3\";\n@@ -42,40 +46,45 @@ static CBaseTestNetParams testNetParams;\n //\n // Regression test\n //\n-class CBaseRegTestParams : public CBaseTestNetParams {\n+class CBaseRegTestParams : public CBaseTestNetParams\n+{\n public:\n-    CBaseRegTestParams() {\n+    CBaseRegTestParams()\n+    {\n         networkID = CBaseChainParams::REGTEST;\n         strDataDir = \"regtest\";\n     }\n };\n static CBaseRegTestParams regTestParams;\n \n-static CBaseChainParams *pCurrentBaseParams = 0;\n+static CBaseChainParams* pCurrentBaseParams = 0;\n \n-const CBaseChainParams &BaseParams() {\n+const CBaseChainParams& BaseParams()\n+{\n     assert(pCurrentBaseParams);\n     return *pCurrentBaseParams;\n }\n \n-void SelectBaseParams(CBaseChainParams::Network network) {\n+void SelectBaseParams(CBaseChainParams::Network network)\n+{\n     switch (network) {\n-        case CBaseChainParams::MAIN:\n-            pCurrentBaseParams = &mainParams;\n-            break;\n-        case CBaseChainParams::TESTNET:\n-            pCurrentBaseParams = &testNetParams;\n-            break;\n-        case CBaseChainParams::REGTEST:\n-            pCurrentBaseParams = &regTestParams;\n-            break;\n-        default:\n-            assert(false && \"Unimplemented network\");\n-            return;\n+    case CBaseChainParams::MAIN:\n+        pCurrentBaseParams = &mainParams;\n+        break;\n+    case CBaseChainParams::TESTNET:\n+        pCurrentBaseParams = &testNetParams;\n+        break;\n+    case CBaseChainParams::REGTEST:\n+        pCurrentBaseParams = &regTestParams;\n+        break;\n+    default:\n+        assert(false && \"Unimplemented network\");\n+        return;\n     }\n }\n \n-bool SelectBaseParamsFromCommandLine() {\n+bool SelectBaseParamsFromCommandLine()\n+{\n     bool fRegTest = GetBoolArg(\"-regtest\", false);\n     bool fTestNet = GetBoolArg(\"-testnet\", false);\n \n@@ -93,6 +102,7 @@ bool SelectBaseParamsFromCommandLine() {\n     return true;\n }\n \n-bool AreBaseParamsConfigured() {\n+bool AreBaseParamsConfigured()\n+{\n     return pCurrentBaseParams != NULL;\n }"
      },
      {
        "sha": "c054f03f17398e4c8ecf6c69000c7925000b2cef",
        "filename": "src/chainparamsbase.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/chainparamsbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/chainparamsbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsbase.h?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -26,6 +26,7 @@ class CBaseChainParams\n     const std::string& DataDir() const { return strDataDir; }\n     int RPCPort() const { return nRPCPort; }\n     Network NetworkID() const { return networkID; }\n+\n protected:\n     CBaseChainParams() {}\n \n@@ -38,7 +39,7 @@ class CBaseChainParams\n  * Return the currently selected parameters. This won't change after app startup\n  * outside of the unit tests.\n  */\n-const CBaseChainParams &BaseParams();\n+const CBaseChainParams& BaseParams();\n \n /** Sets the params returned by Params() to those for the given network. */\n void SelectBaseParams(CBaseChainParams::Network network);"
      },
      {
        "sha": "fca046559ae923b6ada8ff085849edf81f03621d",
        "filename": "src/checkpoints.h",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/checkpoints.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/checkpoints.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkpoints.h?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -13,20 +13,20 @@ class uint256;\n /** Block-chain checkpoints are compiled-in sanity checks.\n  * They are updated every release or three.\n  */\n-namespace Checkpoints {\n+namespace Checkpoints\n+{\n+// Returns true if block passes checkpoint checks\n+bool CheckBlock(int nHeight, const uint256& hash);\n \n-    // Returns true if block passes checkpoint checks\n-    bool CheckBlock(int nHeight, const uint256& hash);\n+// Return conservative estimate of total number of blocks, 0 if unknown\n+int GetTotalBlocksEstimate();\n \n-    // Return conservative estimate of total number of blocks, 0 if unknown\n-    int GetTotalBlocksEstimate();\n+// Returns last CBlockIndex* in mapBlockIndex that is a checkpoint\n+CBlockIndex* GetLastCheckpoint();\n \n-    // Returns last CBlockIndex* in mapBlockIndex that is a checkpoint\n-    CBlockIndex* GetLastCheckpoint();\n+double GuessVerificationProgress(CBlockIndex* pindex, bool fSigchecks = true);\n \n-    double GuessVerificationProgress(CBlockIndex *pindex, bool fSigchecks = true);\n-\n-    extern bool fEnabled;\n+extern bool fEnabled;\n \n } //namespace Checkpoints\n "
      },
      {
        "sha": "b2a713e64671dfbbfd787b182dfbc5aee74d274f",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 36,
        "deletions": 23,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -13,7 +13,8 @@\n #include <boost/thread/locks.hpp>\n #include <boost/thread/mutex.hpp>\n \n-template<typename T> class CCheckQueueControl;\n+template <typename T>\n+class CCheckQueueControl;\n \n /** Queue for verifications that have to be performed.\n   * The verifications are represented by a type T, which must provide an\n@@ -24,7 +25,9 @@ template<typename T> class CCheckQueueControl;\n   * the master is done adding work, it temporarily joins the worker pool\n   * as an N'th worker, until all jobs are done.\n   */\n-template<typename T> class CCheckQueue {\n+template <typename T>\n+class CCheckQueue\n+{\n private:\n     // Mutex to protect the inner state\n     boost::mutex mutex;\n@@ -60,8 +63,9 @@ template<typename T> class CCheckQueue {\n     unsigned int nBatchSize;\n \n     // Internal function that does bulk of the verification work.\n-    bool Loop(bool fMaster = false) {\n-        boost::condition_variable &cond = fMaster ? condMaster : condWorker;\n+    bool Loop(bool fMaster = false)\n+    {\n+        boost::condition_variable& cond = fMaster ? condMaster : condWorker;\n         std::vector<T> vChecks;\n         vChecks.reserve(nBatchSize);\n         unsigned int nNow = 0;\n@@ -103,41 +107,43 @@ template<typename T> class CCheckQueue {\n                 nNow = std::max(1U, std::min(nBatchSize, (unsigned int)queue.size() / (nTotal + nIdle + 1)));\n                 vChecks.resize(nNow);\n                 for (unsigned int i = 0; i < nNow; i++) {\n-                     // We want the lock on the mutex to be as short as possible, so swap jobs from the global\n-                     // queue to the local batch vector instead of copying.\n-                     vChecks[i].swap(queue.back());\n-                     queue.pop_back();\n+                    // We want the lock on the mutex to be as short as possible, so swap jobs from the global\n+                    // queue to the local batch vector instead of copying.\n+                    vChecks[i].swap(queue.back());\n+                    queue.pop_back();\n                 }\n                 // Check whether we need to do work at all\n                 fOk = fAllOk;\n             }\n             // execute work\n-            BOOST_FOREACH(T &check, vChecks)\n+            BOOST_FOREACH (T& check, vChecks)\n                 if (fOk)\n                     fOk = check();\n             vChecks.clear();\n-        } while(true);\n+        } while (true);\n     }\n \n public:\n     // Create a new check queue\n-    CCheckQueue(unsigned int nBatchSizeIn) :\n-        nIdle(0), nTotal(0), fAllOk(true), nTodo(0), fQuit(false), nBatchSize(nBatchSizeIn) {}\n+    CCheckQueue(unsigned int nBatchSizeIn) : nIdle(0), nTotal(0), fAllOk(true), nTodo(0), fQuit(false), nBatchSize(nBatchSizeIn) {}\n \n     // Worker thread\n-    void Thread() {\n+    void Thread()\n+    {\n         Loop();\n     }\n \n     // Wait until execution finishes, and return whether all evaluations where succesful.\n-    bool Wait() {\n+    bool Wait()\n+    {\n         return Loop(true);\n     }\n \n     // Add a batch of checks to the queue\n-    void Add(std::vector<T> &vChecks) {\n+    void Add(std::vector<T>& vChecks)\n+    {\n         boost::unique_lock<boost::mutex> lock(mutex);\n-        BOOST_FOREACH(T &check, vChecks) {\n+        BOOST_FOREACH (T& check, vChecks) {\n             queue.push_back(T());\n             check.swap(queue.back());\n         }\n@@ -148,7 +154,8 @@ template<typename T> class CCheckQueue {\n             condWorker.notify_all();\n     }\n \n-    ~CCheckQueue() {\n+    ~CCheckQueue()\n+    {\n     }\n \n     friend class CCheckQueueControl<T>;\n@@ -157,13 +164,16 @@ template<typename T> class CCheckQueue {\n /** RAII-style controller object for a CCheckQueue that guarantees the passed\n  *  queue is finished before continuing.\n  */\n-template<typename T> class CCheckQueueControl {\n+template <typename T>\n+class CCheckQueueControl\n+{\n private:\n-    CCheckQueue<T> *pqueue;\n+    CCheckQueue<T>* pqueue;\n     bool fDone;\n \n public:\n-    CCheckQueueControl(CCheckQueue<T> *pqueueIn) : pqueue(pqueueIn), fDone(false) {\n+    CCheckQueueControl(CCheckQueue<T>* pqueueIn) : pqueue(pqueueIn), fDone(false)\n+    {\n         // passed queue is supposed to be unused, or NULL\n         if (pqueue != NULL) {\n             assert(pqueue->nTotal == pqueue->nIdle);\n@@ -172,20 +182,23 @@ template<typename T> class CCheckQueueControl {\n         }\n     }\n \n-    bool Wait() {\n+    bool Wait()\n+    {\n         if (pqueue == NULL)\n             return true;\n         bool fRet = pqueue->Wait();\n         fDone = true;\n         return fRet;\n     }\n \n-    void Add(std::vector<T> &vChecks) {\n+    void Add(std::vector<T>& vChecks)\n+    {\n         if (pqueue != NULL)\n             pqueue->Add(vChecks);\n     }\n \n-    ~CCheckQueueControl() {\n+    ~CCheckQueueControl()\n+    {\n         if (!fDone)\n             Wait();\n     }"
      },
      {
        "sha": "cd7ceb78f0eb8c7b3709506bded7e984eb87a56a",
        "filename": "src/clientversion.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/clientversion.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/clientversion.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/clientversion.h?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -13,13 +13,13 @@\n //\n \n // These need to be macros, as version.cpp's and bitcoin*-res.rc's voodoo requires it\n-#define CLIENT_VERSION_MAJOR       0\n-#define CLIENT_VERSION_MINOR       9\n-#define CLIENT_VERSION_REVISION    99\n-#define CLIENT_VERSION_BUILD       0\n+#define CLIENT_VERSION_MAJOR 0\n+#define CLIENT_VERSION_MINOR 9\n+#define CLIENT_VERSION_REVISION 99\n+#define CLIENT_VERSION_BUILD 0\n \n // Set to true for release, false for prerelease or test build\n-#define CLIENT_VERSION_IS_RELEASE  false\n+#define CLIENT_VERSION_IS_RELEASE false\n \n // Copyright year (2009-this)\n // Todo: update this when changing our copyright comments in the source\n@@ -33,6 +33,6 @@\n #define DO_STRINGIZE(X) #X\n \n // Copyright string used in Windows .rc files\n-#define COPYRIGHT_STR          \"2009-\" STRINGIZE(COPYRIGHT_YEAR) \" The Bitcoin Core Developers\"\n+#define COPYRIGHT_STR \"2009-\" STRINGIZE(COPYRIGHT_YEAR) \" The Bitcoin Core Developers\"\n \n #endif // CLIENTVERSION_H"
      },
      {
        "sha": "033092c01954ea9a75f9b30deeda1a52055c3926",
        "filename": "src/coincontrol.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/coincontrol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/coincontrol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coincontrol.h?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -57,7 +57,6 @@ class CCoinControl\n \n private:\n     std::set<COutPoint> setSelected;\n-\n };\n \n #endif // COINCONTROL_H"
      },
      {
        "sha": "12650e459f392bf36f797bbfd6abbf6bc330a68f",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 58,
        "deletions": 86,
        "changes": 144,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -30,7 +30,6 @@ using namespace boost;\n unsigned int nWalletDBUpdated;\n \n \n-\n //\n // CDB\n //\n@@ -94,15 +93,15 @@ bool CDBEnv::Open(const boost::filesystem::path& pathIn)\n     dbenv.set_flags(DB_TXN_WRITE_NOSYNC, 1);\n     dbenv.log_set_config(DB_LOG_AUTO_REMOVE, 1);\n     int ret = dbenv.open(path.string().c_str(),\n-                     DB_CREATE     |\n-                     DB_INIT_LOCK  |\n-                     DB_INIT_LOG   |\n-                     DB_INIT_MPOOL |\n-                     DB_INIT_TXN   |\n-                     DB_THREAD     |\n-                     DB_RECOVER    |\n-                     nEnvFlags,\n-                     S_IRUSR | S_IWUSR);\n+                         DB_CREATE |\n+                             DB_INIT_LOCK |\n+                             DB_INIT_LOG |\n+                             DB_INIT_MPOOL |\n+                             DB_INIT_TXN |\n+                             DB_THREAD |\n+                             DB_RECOVER |\n+                             nEnvFlags,\n+                         S_IRUSR | S_IWUSR);\n     if (ret != 0)\n         return error(\"CDBEnv::Open : Error %d opening database environment: %s\\n\", ret, DbEnv::strerror(ret));\n \n@@ -121,21 +120,21 @@ void CDBEnv::MakeMock()\n     LogPrint(\"db\", \"CDBEnv::MakeMock\\n\");\n \n     dbenv.set_cachesize(1, 0, 1);\n-    dbenv.set_lg_bsize(10485760*4);\n+    dbenv.set_lg_bsize(10485760 * 4);\n     dbenv.set_lg_max(10485760);\n     dbenv.set_lk_max_locks(10000);\n     dbenv.set_lk_max_objects(10000);\n     dbenv.set_flags(DB_AUTO_COMMIT, 1);\n     dbenv.log_set_config(DB_LOG_IN_MEMORY, 1);\n     int ret = dbenv.open(NULL,\n-                     DB_CREATE     |\n-                     DB_INIT_LOCK  |\n-                     DB_INIT_LOG   |\n-                     DB_INIT_MPOOL |\n-                     DB_INIT_TXN   |\n-                     DB_THREAD     |\n-                     DB_PRIVATE,\n-                     S_IRUSR | S_IWUSR);\n+                         DB_CREATE |\n+                             DB_INIT_LOCK |\n+                             DB_INIT_LOG |\n+                             DB_INIT_MPOOL |\n+                             DB_INIT_TXN |\n+                             DB_THREAD |\n+                             DB_PRIVATE,\n+                         S_IRUSR | S_IWUSR);\n     if (ret > 0)\n         throw runtime_error(strprintf(\"CDBEnv::MakeMock : Error %d opening database environment.\", ret));\n \n@@ -160,30 +159,27 @@ CDBEnv::VerifyResult CDBEnv::Verify(std::string strFile, bool (*recoverFunc)(CDB\n     return (fRecovered ? RECOVER_OK : RECOVER_FAIL);\n }\n \n-bool CDBEnv::Salvage(std::string strFile, bool fAggressive,\n-                     std::vector<CDBEnv::KeyValPair >& vResult)\n+bool CDBEnv::Salvage(std::string strFile, bool fAggressive, std::vector<CDBEnv::KeyValPair>& vResult)\n {\n     LOCK(cs_db);\n     assert(mapFileUseCount.count(strFile) == 0);\n \n     u_int32_t flags = DB_SALVAGE;\n-    if (fAggressive) flags |= DB_AGGRESSIVE;\n+    if (fAggressive)\n+        flags |= DB_AGGRESSIVE;\n \n     stringstream strDump;\n \n     Db db(&dbenv, 0);\n     int result = db.verify(strFile.c_str(), NULL, &strDump, flags);\n-    if (result == DB_VERIFY_BAD)\n-    {\n+    if (result == DB_VERIFY_BAD) {\n         LogPrintf(\"CDBEnv::Salvage : Database salvage found errors, all data may not be recoverable.\\n\");\n-        if (!fAggressive)\n-        {\n+        if (!fAggressive) {\n             LogPrintf(\"CDBEnv::Salvage : Rerun with aggressive mode to ignore errors and continue.\\n\");\n             return false;\n         }\n     }\n-    if (result != 0 && result != DB_VERIFY_BAD)\n-    {\n+    if (result != 0 && result != DB_VERIFY_BAD) {\n         LogPrintf(\"CDBEnv::Salvage : Database salvage failed with result %d.\\n\", result);\n         return false;\n     }\n@@ -201,13 +197,11 @@ bool CDBEnv::Salvage(std::string strFile, bool fAggressive,\n         getline(strDump, strLine); // Skip past header\n \n     std::string keyHex, valueHex;\n-    while (!strDump.eof() && keyHex != \"DATA=END\")\n-    {\n+    while (!strDump.eof() && keyHex != \"DATA=END\") {\n         getline(strDump, keyHex);\n-        if (keyHex != \"DATA_END\")\n-        {\n+        if (keyHex != \"DATA_END\") {\n             getline(strDump, valueHex);\n-            vResult.push_back(make_pair(ParseHex(keyHex),ParseHex(valueHex)));\n+            vResult.push_back(make_pair(ParseHex(keyHex), ParseHex(valueHex)));\n         }\n     }\n \n@@ -224,8 +218,7 @@ void CDBEnv::CheckpointLSN(const std::string& strFile)\n }\n \n \n-CDB::CDB(const std::string& strFilename, const char* pszMode) :\n-    pdb(NULL), activeTxn(NULL)\n+CDB::CDB(const std::string& strFilename, const char* pszMode) : pdb(NULL), activeTxn(NULL)\n {\n     int ret;\n     fReadOnly = (!strchr(pszMode, '+') && !strchr(pszMode, 'w'));\n@@ -245,37 +238,33 @@ CDB::CDB(const std::string& strFilename, const char* pszMode) :\n         strFile = strFilename;\n         ++bitdb.mapFileUseCount[strFile];\n         pdb = bitdb.mapDb[strFile];\n-        if (pdb == NULL)\n-        {\n+        if (pdb == NULL) {\n             pdb = new Db(&bitdb.dbenv, 0);\n \n             bool fMockDb = bitdb.IsMock();\n-            if (fMockDb)\n-            {\n-                DbMpoolFile*mpf = pdb->get_mpf();\n+            if (fMockDb) {\n+                DbMpoolFile* mpf = pdb->get_mpf();\n                 ret = mpf->set_flags(DB_MPOOL_NOFILE, 1);\n                 if (ret != 0)\n                     throw runtime_error(strprintf(\"CDB : Failed to configure for no temp file backing for database %s\", strFile));\n             }\n \n-            ret = pdb->open(NULL, // Txn pointer\n-                            fMockDb ? NULL : strFile.c_str(), // Filename\n+            ret = pdb->open(NULL,                               // Txn pointer\n+                            fMockDb ? NULL : strFile.c_str(),   // Filename\n                             fMockDb ? strFile.c_str() : \"main\", // Logical db name\n-                            DB_BTREE, // Database type\n-                            nFlags, // Flags\n+                            DB_BTREE,                           // Database type\n+                            nFlags,                             // Flags\n                             0);\n \n-            if (ret != 0)\n-            {\n+            if (ret != 0) {\n                 delete pdb;\n                 pdb = NULL;\n                 --bitdb.mapFileUseCount[strFile];\n                 strFile = \"\";\n                 throw runtime_error(strprintf(\"CDB : Error %d, can't open database %s\", ret, strFile));\n             }\n \n-            if (fCreate && !Exists(string(\"version\")))\n-            {\n+            if (fCreate && !Exists(string(\"version\"))) {\n                 bool fTmp = fReadOnly;\n                 fReadOnly = false;\n                 WriteVersion(CLIENT_VERSION);\n@@ -297,7 +286,7 @@ void CDB::Flush()\n     if (fReadOnly)\n         nMinutes = 1;\n \n-    bitdb.dbenv.txn_checkpoint(nMinutes ? GetArg(\"-dblogsize\", 100)*1024 : 0, nMinutes, 0);\n+    bitdb.dbenv.txn_checkpoint(nMinutes ? GetArg(\"-dblogsize\", 100) * 1024 : 0, nMinutes, 0);\n }\n \n void CDB::Close()\n@@ -321,8 +310,7 @@ void CDBEnv::CloseDb(const string& strFile)\n {\n     {\n         LOCK(cs_db);\n-        if (mapDb[strFile] != NULL)\n-        {\n+        if (mapDb[strFile] != NULL) {\n             // Close the database handle\n             Db* pdb = mapDb[strFile];\n             pdb->close(0);\n@@ -343,12 +331,10 @@ bool CDBEnv::RemoveDb(const string& strFile)\n \n bool CDB::Rewrite(const string& strFile, const char* pszSkip)\n {\n-    while (true)\n-    {\n+    while (true) {\n         {\n             LOCK(bitdb.cs_db);\n-            if (!bitdb.mapFileUseCount.count(strFile) || bitdb.mapFileUseCount[strFile] == 0)\n-            {\n+            if (!bitdb.mapFileUseCount.count(strFile) || bitdb.mapFileUseCount[strFile] == 0) {\n                 // Flush log data to the dat file\n                 bitdb.CloseDb(strFile);\n                 bitdb.CheckpointLSN(strFile);\n@@ -361,41 +347,35 @@ bool CDB::Rewrite(const string& strFile, const char* pszSkip)\n                     CDB db(strFile.c_str(), \"r\");\n                     Db* pdbCopy = new Db(&bitdb.dbenv, 0);\n \n-                    int ret = pdbCopy->open(NULL,                 // Txn pointer\n-                                            strFileRes.c_str(),   // Filename\n-                                            \"main\",    // Logical db name\n-                                            DB_BTREE,  // Database type\n-                                            DB_CREATE,    // Flags\n+                    int ret = pdbCopy->open(NULL,               // Txn pointer\n+                                            strFileRes.c_str(), // Filename\n+                                            \"main\",             // Logical db name\n+                                            DB_BTREE,           // Database type\n+                                            DB_CREATE,          // Flags\n                                             0);\n-                    if (ret > 0)\n-                    {\n+                    if (ret > 0) {\n                         LogPrintf(\"CDB::Rewrite : Can't create database file %s\\n\", strFileRes);\n                         fSuccess = false;\n                     }\n \n                     Dbc* pcursor = db.GetCursor();\n                     if (pcursor)\n-                        while (fSuccess)\n-                        {\n+                        while (fSuccess) {\n                             CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n                             CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n                             int ret = db.ReadAtCursor(pcursor, ssKey, ssValue, DB_NEXT);\n-                            if (ret == DB_NOTFOUND)\n-                            {\n+                            if (ret == DB_NOTFOUND) {\n                                 pcursor->close();\n                                 break;\n-                            }\n-                            else if (ret != 0)\n-                            {\n+                            } else if (ret != 0) {\n                                 pcursor->close();\n                                 fSuccess = false;\n                                 break;\n                             }\n                             if (pszSkip &&\n                                 strncmp(&ssKey[0], pszSkip, std::min(ssKey.size(), strlen(pszSkip))) == 0)\n                                 continue;\n-                            if (strncmp(&ssKey[0], \"\\x07version\", 8) == 0)\n-                            {\n+                            if (strncmp(&ssKey[0], \"\\x07version\", 8) == 0) {\n                                 // Update version:\n                                 ssValue.clear();\n                                 ssValue << CLIENT_VERSION;\n@@ -406,17 +386,15 @@ bool CDB::Rewrite(const string& strFile, const char* pszSkip)\n                             if (ret2 > 0)\n                                 fSuccess = false;\n                         }\n-                    if (fSuccess)\n-                    {\n+                    if (fSuccess) {\n                         db.Close();\n                         bitdb.CloseDb(strFile);\n                         if (pdbCopy->close(0))\n                             fSuccess = false;\n                         delete pdbCopy;\n                     }\n                 }\n-                if (fSuccess)\n-                {\n+                if (fSuccess) {\n                     Db dbA(&bitdb.dbenv, 0);\n                     if (dbA.remove(strFile.c_str(), NULL, 0))\n                         fSuccess = false;\n@@ -445,13 +423,11 @@ void CDBEnv::Flush(bool fShutdown)\n     {\n         LOCK(cs_db);\n         map<string, int>::iterator mi = mapFileUseCount.begin();\n-        while (mi != mapFileUseCount.end())\n-        {\n+        while (mi != mapFileUseCount.end()) {\n             string strFile = (*mi).first;\n             int nRefCount = (*mi).second;\n             LogPrint(\"db\", \"CDBEnv::Flush : Flushing %s (refcount = %d)...\\n\", strFile, nRefCount);\n-            if (nRefCount == 0)\n-            {\n+            if (nRefCount == 0) {\n                 // Move log data to the dat file\n                 CloseDb(strFile);\n                 LogPrint(\"db\", \"CDBEnv::Flush : %s checkpoint\\n\", strFile);\n@@ -461,16 +437,13 @@ void CDBEnv::Flush(bool fShutdown)\n                     dbenv.lsn_reset(strFile.c_str(), 0);\n                 LogPrint(\"db\", \"CDBEnv::Flush : %s closed\\n\", strFile);\n                 mapFileUseCount.erase(mi++);\n-            }\n-            else\n+            } else\n                 mi++;\n         }\n         LogPrint(\"db\", \"CDBEnv::Flush : Flush(%s)%s took %15dms\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" database not started\", GetTimeMillis() - nStart);\n-        if (fShutdown)\n-        {\n+        if (fShutdown) {\n             char** listp;\n-            if (mapFileUseCount.empty())\n-            {\n+            if (mapFileUseCount.empty()) {\n                 dbenv.log_archive(&listp, DB_ARCH_REMOVE);\n                 Close();\n                 if (!fMockDb)\n@@ -479,4 +452,3 @@ void CDBEnv::Flush(bool fShutdown)\n         }\n     }\n }\n-"
      },
      {
        "sha": "d20239938377864beaf2e307636ff7d5df8d4be2",
        "filename": "src/db.h",
        "status": "modified",
        "additions": 16,
        "deletions": 17,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.h?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -54,7 +54,9 @@ class CDBEnv\n      * This must be called BEFORE strFile is opened.\n      * Returns true if strFile is OK.\n      */\n-    enum VerifyResult { VERIFY_OK, RECOVER_OK, RECOVER_FAIL };\n+    enum VerifyResult { VERIFY_OK,\n+                        RECOVER_OK,\n+                        RECOVER_FAIL };\n     VerifyResult Verify(std::string strFile, bool (*recoverFunc)(CDBEnv& dbenv, std::string strFile));\n     /*\n      * Salvage data from a file that Verify says is bad.\n@@ -66,15 +68,15 @@ class CDBEnv\n     typedef std::pair<std::vector<unsigned char>, std::vector<unsigned char> > KeyValPair;\n     bool Salvage(std::string strFile, bool fAggressive, std::vector<KeyValPair>& vResult);\n \n-    bool Open(const boost::filesystem::path &path);\n+    bool Open(const boost::filesystem::path& path);\n     void Close();\n     void Flush(bool fShutdown);\n     void CheckpointLSN(const std::string& strFile);\n \n     void CloseDb(const std::string& strFile);\n     bool RemoveDb(const std::string& strFile);\n \n-    DbTxn *TxnBegin(int flags=DB_TXN_WRITE_NOSYNC)\n+    DbTxn* TxnBegin(int flags = DB_TXN_WRITE_NOSYNC)\n     {\n         DbTxn* ptxn = NULL;\n         int ret = dbenv.txn_begin(NULL, &ptxn, flags);\n@@ -93,10 +95,10 @@ class CDB\n protected:\n     Db* pdb;\n     std::string strFile;\n-    DbTxn *activeTxn;\n+    DbTxn* activeTxn;\n     bool fReadOnly;\n \n-    explicit CDB(const std::string& strFilename, const char* pszMode=\"r+\");\n+    explicit CDB(const std::string& strFilename, const char* pszMode = \"r+\");\n     ~CDB() { Close(); }\n \n public:\n@@ -108,7 +110,7 @@ class CDB\n     void operator=(const CDB&);\n \n protected:\n-    template<typename K, typename T>\n+    template <typename K, typename T>\n     bool Read(const K& key, T& value)\n     {\n         if (!pdb)\n@@ -132,8 +134,7 @@ class CDB\n         try {\n             CDataStream ssValue((char*)datValue.get_data(), (char*)datValue.get_data() + datValue.get_size(), SER_DISK, CLIENT_VERSION);\n             ssValue >> value;\n-        }\n-        catch (const std::exception &) {\n+        } catch (const std::exception&) {\n             return false;\n         }\n \n@@ -143,8 +144,8 @@ class CDB\n         return (ret == 0);\n     }\n \n-    template<typename K, typename T>\n-    bool Write(const K& key, const T& value, bool fOverwrite=true)\n+    template <typename K, typename T>\n+    bool Write(const K& key, const T& value, bool fOverwrite = true)\n     {\n         if (!pdb)\n             return false;\n@@ -172,7 +173,7 @@ class CDB\n         return (ret == 0);\n     }\n \n-    template<typename K>\n+    template <typename K>\n     bool Erase(const K& key)\n     {\n         if (!pdb)\n@@ -194,7 +195,7 @@ class CDB\n         return (ret == 0 || ret == DB_NOTFOUND);\n     }\n \n-    template<typename K>\n+    template <typename K>\n     bool Exists(const K& key)\n     {\n         if (!pdb)\n@@ -225,18 +226,16 @@ class CDB\n         return pcursor;\n     }\n \n-    int ReadAtCursor(Dbc* pcursor, CDataStream& ssKey, CDataStream& ssValue, unsigned int fFlags=DB_NEXT)\n+    int ReadAtCursor(Dbc* pcursor, CDataStream& ssKey, CDataStream& ssValue, unsigned int fFlags = DB_NEXT)\n     {\n         // Read at cursor\n         Dbt datKey;\n-        if (fFlags == DB_SET || fFlags == DB_SET_RANGE || fFlags == DB_GET_BOTH || fFlags == DB_GET_BOTH_RANGE)\n-        {\n+        if (fFlags == DB_SET || fFlags == DB_SET_RANGE || fFlags == DB_GET_BOTH || fFlags == DB_GET_BOTH_RANGE) {\n             datKey.set_data(&ssKey[0]);\n             datKey.set_size(ssKey.size());\n         }\n         Dbt datValue;\n-        if (fFlags == DB_GET_BOTH || fFlags == DB_GET_BOTH_RANGE)\n-        {\n+        if (fFlags == DB_GET_BOTH || fFlags == DB_GET_BOTH_RANGE) {\n             datValue.set_data(&ssValue[0]);\n             datValue.set_size(ssValue.size());\n         }"
      },
      {
        "sha": "4ce4da4c30e1c31ecebad9cbb22a2bc87d369ee8",
        "filename": "src/hash.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 14,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/hash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/hash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.cpp?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -1,6 +1,6 @@\n #include \"hash.h\"\n \n-inline uint32_t ROTL32 ( uint32_t x, int8_t r )\n+inline uint32_t ROTL32(uint32_t x, int8_t r)\n {\n     return (x << r) | (x >> (32 - r));\n }\n@@ -16,33 +16,37 @@ unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char\n \n     //----------\n     // body\n-    const uint32_t * blocks = (const uint32_t *)(&vDataToHash[0] + nblocks*4);\n+    const uint32_t* blocks = (const uint32_t*)(&vDataToHash[0] + nblocks * 4);\n \n-    for(int i = -nblocks; i; i++)\n-    {\n+    for (int i = -nblocks; i; i++) {\n         uint32_t k1 = blocks[i];\n \n         k1 *= c1;\n-        k1 = ROTL32(k1,15);\n+        k1 = ROTL32(k1, 15);\n         k1 *= c2;\n \n         h1 ^= k1;\n-        h1 = ROTL32(h1,13); \n-        h1 = h1*5+0xe6546b64;\n+        h1 = ROTL32(h1, 13);\n+        h1 = h1 * 5 + 0xe6546b64;\n     }\n \n     //----------\n     // tail\n-    const uint8_t * tail = (const uint8_t*)(&vDataToHash[0] + nblocks*4);\n+    const uint8_t* tail = (const uint8_t*)(&vDataToHash[0] + nblocks * 4);\n \n     uint32_t k1 = 0;\n \n-    switch(vDataToHash.size() & 3)\n-    {\n-    case 3: k1 ^= tail[2] << 16;\n-    case 2: k1 ^= tail[1] << 8;\n-    case 1: k1 ^= tail[0];\n-            k1 *= c1; k1 = ROTL32(k1,15); k1 *= c2; h1 ^= k1;\n+    switch (vDataToHash.size() & 3) {\n+    case 3:\n+        k1 ^= tail[2] << 16;\n+    case 2:\n+        k1 ^= tail[1] << 8;\n+    case 1:\n+        k1 ^= tail[0];\n+        k1 *= c1;\n+        k1 = ROTL32(k1, 15);\n+        k1 *= c2;\n+        h1 ^= k1;\n     };\n \n     //----------"
      },
      {
        "sha": "aaf8c07e6e86c1b15acf2f1180999996a284b9cb",
        "filename": "src/init.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/init.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/init.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.h?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -10,8 +10,9 @@\n \n class CWallet;\n \n-namespace boost {\n-    class thread_group;\n+namespace boost\n+{\n+class thread_group;\n } // namespace boost\n \n extern CWallet* pwalletMain;\n@@ -22,8 +23,7 @@ void Shutdown();\n bool AppInit2(boost::thread_group& threadGroup);\n \n /* The help message mode determines what help message to show */\n-enum HelpMessageMode\n-{\n+enum HelpMessageMode {\n     HMM_BITCOIND,\n     HMM_BITCOIN_QT\n };"
      },
      {
        "sha": "3863e95cffb025f84a3d4c4bbb3d4d60eac11e00",
        "filename": "src/key.h",
        "status": "modified",
        "additions": 79,
        "deletions": 52,
        "changes": 131,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/key.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/key.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.h?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -26,27 +26,29 @@\n class CKeyID : public uint160\n {\n public:\n-    CKeyID() : uint160(0) { }\n-    CKeyID(const uint160 &in) : uint160(in) { }\n+    CKeyID() : uint160(0) {}\n+    CKeyID(const uint160& in) : uint160(in) {}\n };\n \n /** A reference to a CScript: the Hash160 of its serialization (see script.h) */\n class CScriptID : public uint160\n {\n public:\n-    CScriptID() : uint160(0) { }\n-    CScriptID(const uint160 &in) : uint160(in) { }\n+    CScriptID() : uint160(0) {}\n+    CScriptID(const uint160& in) : uint160(in) {}\n };\n \n /** An encapsulated public key. */\n-class CPubKey {\n+class CPubKey\n+{\n private:\n     // Just store the serialized data.\n     // Its length can very cheaply be computed from the first byte.\n     unsigned char vch[65];\n \n     // Compute the length of a pubkey with a given first byte.\n-    unsigned int static GetLen(unsigned char chHeader) {\n+    unsigned int static GetLen(unsigned char chHeader)\n+    {\n         if (chHeader == 2 || chHeader == 3)\n             return 33;\n         if (chHeader == 4 || chHeader == 6 || chHeader == 7)\n@@ -55,66 +57,79 @@ class CPubKey {\n     }\n \n     // Set this key data to be invalid\n-    void Invalidate() {\n+    void Invalidate()\n+    {\n         vch[0] = 0xFF;\n     }\n \n public:\n     // Construct an invalid public key.\n-    CPubKey() {\n+    CPubKey()\n+    {\n         Invalidate();\n     }\n \n     // Initialize a public key using begin/end iterators to byte data.\n-    template<typename T>\n-    void Set(const T pbegin, const T pend) {\n+    template <typename T>\n+    void Set(const T pbegin, const T pend)\n+    {\n         int len = pend == pbegin ? 0 : GetLen(pbegin[0]);\n-        if (len && len == (pend-pbegin))\n+        if (len && len == (pend - pbegin))\n             memcpy(vch, (unsigned char*)&pbegin[0], len);\n         else\n             Invalidate();\n     }\n \n     // Construct a public key using begin/end iterators to byte data.\n-    template<typename T>\n-    CPubKey(const T pbegin, const T pend) {\n+    template <typename T>\n+    CPubKey(const T pbegin, const T pend)\n+    {\n         Set(pbegin, pend);\n     }\n \n     // Construct a public key from a byte vector.\n-    CPubKey(const std::vector<unsigned char> &vch) {\n+    CPubKey(const std::vector<unsigned char>& vch)\n+    {\n         Set(vch.begin(), vch.end());\n     }\n \n     // Simple read-only vector-like interface to the pubkey data.\n     unsigned int size() const { return GetLen(vch[0]); }\n-    const unsigned char *begin() const { return vch; }\n-    const unsigned char *end() const { return vch+size(); }\n-    const unsigned char &operator[](unsigned int pos) const { return vch[pos]; }\n+    const unsigned char* begin() const { return vch; }\n+    const unsigned char* end() const { return vch + size(); }\n+    const unsigned char& operator[](unsigned int pos) const { return vch[pos]; }\n \n     // Comparator implementation.\n-    friend bool operator==(const CPubKey &a, const CPubKey &b) {\n+    friend bool operator==(const CPubKey& a, const CPubKey& b)\n+    {\n         return a.vch[0] == b.vch[0] &&\n                memcmp(a.vch, b.vch, a.size()) == 0;\n     }\n-    friend bool operator!=(const CPubKey &a, const CPubKey &b) {\n+    friend bool operator!=(const CPubKey& a, const CPubKey& b)\n+    {\n         return !(a == b);\n     }\n-    friend bool operator<(const CPubKey &a, const CPubKey &b) {\n+    friend bool operator<(const CPubKey& a, const CPubKey& b)\n+    {\n         return a.vch[0] < b.vch[0] ||\n                (a.vch[0] == b.vch[0] && memcmp(a.vch, b.vch, a.size()) < 0);\n     }\n \n     // Implement serialization, as if this was a byte vector.\n-    unsigned int GetSerializeSize(int nType, int nVersion) const {\n+    unsigned int GetSerializeSize(int nType, int nVersion) const\n+    {\n         return size() + 1;\n     }\n-    template<typename Stream> void Serialize(Stream &s, int nType, int nVersion) const {\n+    template <typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const\n+    {\n         unsigned int len = size();\n         ::WriteCompactSize(s, len);\n         s.write((char*)vch, len);\n     }\n-    template<typename Stream> void Unserialize(Stream &s, int nType, int nVersion) {\n+    template <typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion)\n+    {\n         unsigned int len = ::ReadCompactSize(s);\n         if (len <= 65) {\n             s.read((char*)vch, len);\n@@ -128,36 +143,40 @@ class CPubKey {\n     }\n \n     // Get the KeyID of this public key (hash of its serialization)\n-    CKeyID GetID() const {\n-        return CKeyID(Hash160(vch, vch+size()));\n+    CKeyID GetID() const\n+    {\n+        return CKeyID(Hash160(vch, vch + size()));\n     }\n \n     // Get the 256-bit hash of this public key.\n-    uint256 GetHash() const {\n-        return Hash(vch, vch+size());\n+    uint256 GetHash() const\n+    {\n+        return Hash(vch, vch + size());\n     }\n \n     // Check syntactic correctness.\n     //\n     // Note that this is consensus critical as CheckSig() calls it!\n-    bool IsValid() const {\n+    bool IsValid() const\n+    {\n         return size() > 0;\n     }\n \n     // fully validate whether this is a valid public key (more expensive than IsValid())\n     bool IsFullyValid() const;\n \n     // Check whether this is a compressed public key.\n-    bool IsCompressed() const {\n+    bool IsCompressed() const\n+    {\n         return size() == 33;\n     }\n \n     // Verify a DER signature (~72 bytes).\n     // If this public key is not fully valid, the return value will be false.\n-    bool Verify(const uint256 &hash, const std::vector<unsigned char>& vchSig) const;\n+    bool Verify(const uint256& hash, const std::vector<unsigned char>& vchSig) const;\n \n     // Recover a public key from a compact signature.\n-    bool RecoverCompact(const uint256 &hash, const std::vector<unsigned char>& vchSig);\n+    bool RecoverCompact(const uint256& hash, const std::vector<unsigned char>& vchSig);\n \n     // Turn this public key into an uncompressed public key.\n     bool Decompress();\n@@ -172,7 +191,8 @@ class CPubKey {\n typedef std::vector<unsigned char, secure_allocator<unsigned char> > CPrivKey;\n \n /** An encapsulated private key. */\n-class CKey {\n+class CKey\n+{\n private:\n     // Whether this private key is valid. We check for correctness when modifying the key\n     // data, so fValid should always correspond to the actual state.\n@@ -185,33 +205,38 @@ class CKey {\n     unsigned char vch[32];\n \n     // Check whether the 32-byte array pointed to be vch is valid keydata.\n-    bool static Check(const unsigned char *vch);\n-public:\n+    bool static Check(const unsigned char* vch);\n \n+public:\n     // Construct an invalid private key.\n-    CKey() : fValid(false), fCompressed(false) {\n+    CKey() : fValid(false), fCompressed(false)\n+    {\n         LockObject(vch);\n     }\n \n     // Copy constructor. This is necessary because of memlocking.\n-    CKey(const CKey &secret) : fValid(secret.fValid), fCompressed(secret.fCompressed) {\n+    CKey(const CKey& secret) : fValid(secret.fValid), fCompressed(secret.fCompressed)\n+    {\n         LockObject(vch);\n         memcpy(vch, secret.vch, sizeof(vch));\n     }\n \n     // Destructor (again necessary because of memlocking).\n-    ~CKey() {\n+    ~CKey()\n+    {\n         UnlockObject(vch);\n     }\n \n-    friend bool operator==(const CKey &a, const CKey &b) {\n+    friend bool operator==(const CKey& a, const CKey& b)\n+    {\n         return a.fCompressed == b.fCompressed && a.size() == b.size() &&\n                memcmp(&a.vch[0], &b.vch[0], a.size()) == 0;\n     }\n \n     // Initialize using begin and end iterators to byte data.\n-    template<typename T>\n-    void Set(const T pbegin, const T pend, bool fCompressedIn) {\n+    template <typename T>\n+    void Set(const T pbegin, const T pend, bool fCompressedIn)\n+    {\n         if (pend - pbegin != 32) {\n             fValid = false;\n             return;\n@@ -227,8 +252,8 @@ class CKey {\n \n     // Simple read-only vector-like interface.\n     unsigned int size() const { return (fValid ? 32 : 0); }\n-    const unsigned char *begin() const { return vch; }\n-    const unsigned char *end() const { return vch + size(); }\n+    const unsigned char* begin() const { return vch; }\n+    const unsigned char* end() const { return vch + size(); }\n \n     // Check whether this private key is valid.\n     bool IsValid() const { return fValid; }\n@@ -237,7 +262,7 @@ class CKey {\n     bool IsCompressed() const { return fCompressed; }\n \n     // Initialize from a CPrivKey (serialized OpenSSL private key data).\n-    bool SetPrivKey(const CPrivKey &vchPrivKey, bool fCompressed);\n+    bool SetPrivKey(const CPrivKey& vchPrivKey, bool fCompressed);\n \n     // Generate a new private key using a cryptographic PRNG.\n     void MakeNewKey(bool fCompressed);\n@@ -251,23 +276,23 @@ class CKey {\n     CPubKey GetPubKey() const;\n \n     // Create a DER-serialized signature.\n-    bool Sign(const uint256 &hash, std::vector<unsigned char>& vchSig) const;\n+    bool Sign(const uint256& hash, std::vector<unsigned char>& vchSig) const;\n \n     // Create a compact signature (65 bytes), which allows reconstructing the used public key.\n     // The format is one header byte, followed by two times 32 bytes for the serialized r and s values.\n     // The header byte: 0x1B = first key with even y, 0x1C = first key with odd y,\n     //                  0x1D = second key with even y, 0x1E = second key with odd y,\n     //                  add 0x04 for compressed keys.\n-    bool SignCompact(const uint256 &hash, std::vector<unsigned char>& vchSig) const;\n+    bool SignCompact(const uint256& hash, std::vector<unsigned char>& vchSig) const;\n \n     // Derive BIP32 child key.\n     bool Derive(CKey& keyChild, unsigned char ccChild[32], unsigned int nChild, const unsigned char cc[32]) const;\n \n     // Load private key and check that public key matches.\n-    bool Load(CPrivKey &privkey, CPubKey &vchPubKey, bool fSkipCheck);\n+    bool Load(CPrivKey& privkey, CPubKey& vchPubKey, bool fSkipCheck);\n \n     // Check whether an element of a signature (r or s) is valid.\n-    static bool CheckSignatureElement(const unsigned char *vch, int len, bool half);\n+    static bool CheckSignatureElement(const unsigned char* vch, int len, bool half);\n };\n \n struct CExtPubKey {\n@@ -277,14 +302,15 @@ struct CExtPubKey {\n     unsigned char vchChainCode[32];\n     CPubKey pubkey;\n \n-    friend bool operator==(const CExtPubKey &a, const CExtPubKey &b) {\n+    friend bool operator==(const CExtPubKey& a, const CExtPubKey& b)\n+    {\n         return a.nDepth == b.nDepth && memcmp(&a.vchFingerprint[0], &b.vchFingerprint[0], 4) == 0 && a.nChild == b.nChild &&\n                memcmp(&a.vchChainCode[0], &b.vchChainCode[0], 32) == 0 && a.pubkey == b.pubkey;\n     }\n \n     void Encode(unsigned char code[74]) const;\n     void Decode(const unsigned char code[74]);\n-    bool Derive(CExtPubKey &out, unsigned int nChild) const;\n+    bool Derive(CExtPubKey& out, unsigned int nChild) const;\n };\n \n struct CExtKey {\n@@ -294,16 +320,17 @@ struct CExtKey {\n     unsigned char vchChainCode[32];\n     CKey key;\n \n-    friend bool operator==(const CExtKey &a, const CExtKey &b) {\n+    friend bool operator==(const CExtKey& a, const CExtKey& b)\n+    {\n         return a.nDepth == b.nDepth && memcmp(&a.vchFingerprint[0], &b.vchFingerprint[0], 4) == 0 && a.nChild == b.nChild &&\n                memcmp(&a.vchChainCode[0], &b.vchChainCode[0], 32) == 0 && a.key == b.key;\n     }\n \n     void Encode(unsigned char code[74]) const;\n     void Decode(const unsigned char code[74]);\n-    bool Derive(CExtKey &out, unsigned int nChild) const;\n+    bool Derive(CExtKey& out, unsigned int nChild) const;\n     CExtPubKey Neuter() const;\n-    void SetMaster(const unsigned char *seed, unsigned int nSeedLen);\n+    void SetMaster(const unsigned char* seed, unsigned int nSeedLen);\n };\n \n /** Check that required EC support is available at runtime */"
      },
      {
        "sha": "8ce3e7b47088df4497029da5636b61881003cd29",
        "filename": "src/leveldbwrapper.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 5,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/leveldbwrapper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/leveldbwrapper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldbwrapper.cpp?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -12,7 +12,8 @@\n #include <leveldb/filter_policy.h>\n #include <memenv.h>\n \n-void HandleError(const leveldb::Status &status) throw(leveldb_error) {\n+void HandleError(const leveldb::Status& status) throw(leveldb_error)\n+{\n     if (status.ok())\n         return;\n     LogPrintf(\"%s\\n\", status.ToString());\n@@ -25,7 +26,8 @@ void HandleError(const leveldb::Status &status) throw(leveldb_error) {\n     throw leveldb_error(\"Unknown database error\");\n }\n \n-static leveldb::Options GetOptions(size_t nCacheSize) {\n+static leveldb::Options GetOptions(size_t nCacheSize)\n+{\n     leveldb::Options options;\n     options.block_cache = leveldb::NewLRUCache(nCacheSize / 2);\n     options.write_buffer_size = nCacheSize / 4; // up to two write buffers may be held in memory simultaneously\n@@ -40,7 +42,8 @@ static leveldb::Options GetOptions(size_t nCacheSize) {\n     return options;\n }\n \n-CLevelDBWrapper::CLevelDBWrapper(const boost::filesystem::path &path, size_t nCacheSize, bool fMemory, bool fWipe) {\n+CLevelDBWrapper::CLevelDBWrapper(const boost::filesystem::path& path, size_t nCacheSize, bool fMemory, bool fWipe)\n+{\n     penv = NULL;\n     readoptions.verify_checksums = true;\n     iteroptions.verify_checksums = true;\n@@ -64,7 +67,8 @@ CLevelDBWrapper::CLevelDBWrapper(const boost::filesystem::path &path, size_t nCa\n     LogPrintf(\"Opened LevelDB successfully\\n\");\n }\n \n-CLevelDBWrapper::~CLevelDBWrapper() {\n+CLevelDBWrapper::~CLevelDBWrapper()\n+{\n     delete pdb;\n     pdb = NULL;\n     delete options.filter_policy;\n@@ -75,7 +79,8 @@ CLevelDBWrapper::~CLevelDBWrapper() {\n     options.env = NULL;\n }\n \n-bool CLevelDBWrapper::WriteBatch(CLevelDBBatch &batch, bool fSync) throw(leveldb_error) {\n+bool CLevelDBWrapper::WriteBatch(CLevelDBBatch& batch, bool fSync) throw(leveldb_error)\n+{\n     leveldb::Status status = pdb->Write(fSync ? syncoptions : writeoptions, &batch.batch);\n     HandleError(status);\n     return true;"
      },
      {
        "sha": "da5ba61c7b04fc35d6643ad5381208a6ecc8d066",
        "filename": "src/leveldbwrapper.h",
        "status": "modified",
        "additions": 31,
        "deletions": 16,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/leveldbwrapper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/leveldbwrapper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldbwrapper.h?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -17,10 +17,10 @@\n class leveldb_error : public std::runtime_error\n {\n public:\n-    leveldb_error(const std::string &msg) : std::runtime_error(msg) {}\n+    leveldb_error(const std::string& msg) : std::runtime_error(msg) {}\n };\n \n-void HandleError(const leveldb::Status &status) throw(leveldb_error);\n+void HandleError(const leveldb::Status& status) throw(leveldb_error);\n \n // Batch of changes queued to be written to a CLevelDBWrapper\n class CLevelDBBatch\n@@ -31,7 +31,9 @@ class CLevelDBBatch\n     leveldb::WriteBatch batch;\n \n public:\n-    template<typename K, typename V> void Write(const K& key, const V& value) {\n+    template <typename K, typename V>\n+    void Write(const K& key, const V& value)\n+    {\n         CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n         ssKey.reserve(ssKey.GetSerializeSize(key));\n         ssKey << key;\n@@ -45,7 +47,9 @@ class CLevelDBBatch\n         batch.Put(slKey, slValue);\n     }\n \n-    template<typename K> void Erase(const K& key) {\n+    template <typename K>\n+    void Erase(const K& key)\n+    {\n         CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n         ssKey.reserve(ssKey.GetSerializeSize(key));\n         ssKey << key;\n@@ -59,7 +63,7 @@ class CLevelDBWrapper\n {\n private:\n     // custom environment this database is using (may be NULL in case of default environment)\n-    leveldb::Env *penv;\n+    leveldb::Env* penv;\n \n     // database options used\n     leveldb::Options options;\n@@ -77,13 +81,15 @@ class CLevelDBWrapper\n     leveldb::WriteOptions syncoptions;\n \n     // the database itself\n-    leveldb::DB *pdb;\n+    leveldb::DB* pdb;\n \n public:\n-    CLevelDBWrapper(const boost::filesystem::path &path, size_t nCacheSize, bool fMemory = false, bool fWipe = false);\n+    CLevelDBWrapper(const boost::filesystem::path& path, size_t nCacheSize, bool fMemory = false, bool fWipe = false);\n     ~CLevelDBWrapper();\n \n-    template<typename K, typename V> bool Read(const K& key, V& value) const throw(leveldb_error) {\n+    template <typename K, typename V>\n+    bool Read(const K& key, V& value) const throw(leveldb_error)\n+    {\n         CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n         ssKey.reserve(ssKey.GetSerializeSize(key));\n         ssKey << key;\n@@ -100,19 +106,23 @@ class CLevelDBWrapper\n         try {\n             CDataStream ssValue(strValue.data(), strValue.data() + strValue.size(), SER_DISK, CLIENT_VERSION);\n             ssValue >> value;\n-        } catch(const std::exception &) {\n+        } catch (const std::exception&) {\n             return false;\n         }\n         return true;\n     }\n \n-    template<typename K, typename V> bool Write(const K& key, const V& value, bool fSync = false) throw(leveldb_error) {\n+    template <typename K, typename V>\n+    bool Write(const K& key, const V& value, bool fSync = false) throw(leveldb_error)\n+    {\n         CLevelDBBatch batch;\n         batch.Write(key, value);\n         return WriteBatch(batch, fSync);\n     }\n \n-    template<typename K> bool Exists(const K& key) const throw(leveldb_error) {\n+    template <typename K>\n+    bool Exists(const K& key) const throw(leveldb_error)\n+    {\n         CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n         ssKey.reserve(ssKey.GetSerializeSize(key));\n         ssKey << key;\n@@ -129,26 +139,31 @@ class CLevelDBWrapper\n         return true;\n     }\n \n-    template<typename K> bool Erase(const K& key, bool fSync = false) throw(leveldb_error) {\n+    template <typename K>\n+    bool Erase(const K& key, bool fSync = false) throw(leveldb_error)\n+    {\n         CLevelDBBatch batch;\n         batch.Erase(key);\n         return WriteBatch(batch, fSync);\n     }\n \n-    bool WriteBatch(CLevelDBBatch &batch, bool fSync = false) throw(leveldb_error);\n+    bool WriteBatch(CLevelDBBatch& batch, bool fSync = false) throw(leveldb_error);\n \n     // not available for LevelDB; provide for compatibility with BDB\n-    bool Flush() {\n+    bool Flush()\n+    {\n         return true;\n     }\n \n-    bool Sync() throw(leveldb_error) {\n+    bool Sync() throw(leveldb_error)\n+    {\n         CLevelDBBatch batch;\n         return WriteBatch(batch, true);\n     }\n \n     // not exactly clean encapsulation, but it's easiest for now\n-    leveldb::Iterator *NewIterator() {\n+    leveldb::Iterator* NewIterator()\n+    {\n         return pdb->NewIterator(iteroptions);\n     }\n };"
      },
      {
        "sha": "4bc8d9e5aa514b4039ae7080d1bc60dc269275b8",
        "filename": "src/limitedmap.h",
        "status": "modified",
        "additions": 7,
        "deletions": 11,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/limitedmap.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/limitedmap.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/limitedmap.h?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -9,7 +9,8 @@\n #include <map>\n \n /** STL-like map container that only keeps the N elements with the highest value. */\n-template <typename K, typename V> class limitedmap\n+template <typename K, typename V>\n+class limitedmap\n {\n public:\n     typedef K key_type;\n@@ -36,10 +37,8 @@ template <typename K, typename V> class limitedmap\n     void insert(const value_type& x)\n     {\n         std::pair<iterator, bool> ret = map.insert(x);\n-        if (ret.second)\n-        {\n-            if (nMaxSize && map.size() == nMaxSize)\n-            {\n+        if (ret.second) {\n+            if (nMaxSize && map.size() == nMaxSize) {\n                 map.erase(rmap.begin()->second);\n                 rmap.erase(rmap.begin());\n             }\n@@ -54,8 +53,7 @@ template <typename K, typename V> class limitedmap\n             return;\n         std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n         for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n-            if (it->second == itTarget)\n-            {\n+            if (it->second == itTarget) {\n                 rmap.erase(it);\n                 map.erase(itTarget);\n                 return;\n@@ -72,8 +70,7 @@ template <typename K, typename V> class limitedmap\n             return;\n         std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n         for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n-            if (it->second == itTarget)\n-            {\n+            if (it->second == itTarget) {\n                 rmap.erase(it);\n                 itTarget->second = v;\n                 rmap.insert(make_pair(v, itTarget));\n@@ -88,8 +85,7 @@ template <typename K, typename V> class limitedmap\n     size_type max_size(size_type s)\n     {\n         if (s)\n-            while (map.size() > s)\n-            {\n+            while (map.size() > s) {\n                 map.erase(rmap.begin()->second);\n                 rmap.erase(rmap.begin());\n             }"
      },
      {
        "sha": "1691875f57bfca781f6d6397bdffe564b84eb5a9",
        "filename": "src/mruset.h",
        "status": "modified",
        "additions": 10,
        "deletions": 8,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/mruset.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/mruset.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/mruset.h?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -10,7 +10,8 @@\n #include <utility>\n \n /** STL-like set container that only keeps the most recent N elements. */\n-template <typename T> class mruset\n+template <typename T>\n+class mruset\n {\n public:\n     typedef T key_type;\n@@ -32,17 +33,19 @@ template <typename T> class mruset\n     bool empty() const { return set.empty(); }\n     iterator find(const key_type& k) const { return set.find(k); }\n     size_type count(const key_type& k) const { return set.count(k); }\n-    void clear() { set.clear(); queue.clear(); }\n+    void clear()\n+    {\n+        set.clear();\n+        queue.clear();\n+    }\n     bool inline friend operator==(const mruset<T>& a, const mruset<T>& b) { return a.set == b.set; }\n     bool inline friend operator==(const mruset<T>& a, const std::set<T>& b) { return a.set == b; }\n     bool inline friend operator<(const mruset<T>& a, const mruset<T>& b) { return a.set < b.set; }\n     std::pair<iterator, bool> insert(const key_type& x)\n     {\n         std::pair<iterator, bool> ret = set.insert(x);\n-        if (ret.second)\n-        {\n-            if (nMaxSize && queue.size() == nMaxSize)\n-            {\n+        if (ret.second) {\n+            if (nMaxSize && queue.size() == nMaxSize) {\n                 set.erase(queue.front());\n                 queue.pop_front();\n             }\n@@ -54,8 +57,7 @@ template <typename T> class mruset\n     size_type max_size(size_type s)\n     {\n         if (s)\n-            while (queue.size() > s)\n-            {\n+            while (queue.size() > s) {\n                 set.erase(queue.front());\n                 queue.pop_front();\n             }"
      },
      {
        "sha": "f786a20db5074d1c4fb66078188b0bec8accff75",
        "filename": "src/noui.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/noui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/noui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/noui.cpp?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -35,7 +35,7 @@ static bool noui_ThreadSafeMessageBox(const std::string& message, const std::str\n     return false;\n }\n \n-static void noui_InitMessage(const std::string &message)\n+static void noui_InitMessage(const std::string& message)\n {\n     LogPrintf(\"init message: %s\\n\", message);\n }"
      },
      {
        "sha": "b73041a9fdc532f582e006aab9241c65b80f67ff",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 76,
        "deletions": 75,
        "changes": 151,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -4,7 +4,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #ifndef __cplusplus\n-# error This header can only be compiled as C++.\n+#error This header can only be compiled as C++.\n #endif\n \n #ifndef __INCLUDED_PROTOCOL_H__\n@@ -28,43 +28,43 @@\n  */\n class CMessageHeader\n {\n-    public:\n-        CMessageHeader();\n-        CMessageHeader(const char* pszCommand, unsigned int nMessageSizeIn);\n+public:\n+    CMessageHeader();\n+    CMessageHeader(const char* pszCommand, unsigned int nMessageSizeIn);\n \n-        std::string GetCommand() const;\n-        bool IsValid() const;\n+    std::string GetCommand() const;\n+    bool IsValid() const;\n \n-        ADD_SERIALIZE_METHODS;\n+    ADD_SERIALIZE_METHODS;\n \n-        template <typename Stream, typename Operation>\n-        inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n-            READWRITE(FLATDATA(pchMessageStart));\n-            READWRITE(FLATDATA(pchCommand));\n-            READWRITE(nMessageSize);\n-            READWRITE(nChecksum);\n-        }\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n+        READWRITE(FLATDATA(pchMessageStart));\n+        READWRITE(FLATDATA(pchCommand));\n+        READWRITE(nMessageSize);\n+        READWRITE(nChecksum);\n+    }\n \n     // TODO: make private (improves encapsulation)\n-    public:\n-        enum {\n-            COMMAND_SIZE=12,\n-            MESSAGE_SIZE_SIZE=sizeof(int),\n-            CHECKSUM_SIZE=sizeof(int),\n-\n-            MESSAGE_SIZE_OFFSET=MESSAGE_START_SIZE+COMMAND_SIZE,\n-            CHECKSUM_OFFSET=MESSAGE_SIZE_OFFSET+MESSAGE_SIZE_SIZE,\n-            HEADER_SIZE=MESSAGE_START_SIZE+COMMAND_SIZE+MESSAGE_SIZE_SIZE+CHECKSUM_SIZE\n-        };\n-        char pchMessageStart[MESSAGE_START_SIZE];\n-        char pchCommand[COMMAND_SIZE];\n-        unsigned int nMessageSize;\n-        unsigned int nChecksum;\n+public:\n+    enum {\n+        COMMAND_SIZE = 12,\n+        MESSAGE_SIZE_SIZE = sizeof(int),\n+        CHECKSUM_SIZE = sizeof(int),\n+\n+        MESSAGE_SIZE_OFFSET = MESSAGE_START_SIZE + COMMAND_SIZE,\n+        CHECKSUM_OFFSET = MESSAGE_SIZE_OFFSET + MESSAGE_SIZE_SIZE,\n+        HEADER_SIZE = MESSAGE_START_SIZE + COMMAND_SIZE + MESSAGE_SIZE_SIZE + CHECKSUM_SIZE\n+    };\n+    char pchMessageStart[MESSAGE_START_SIZE];\n+    char pchCommand[COMMAND_SIZE];\n+    unsigned int nMessageSize;\n+    unsigned int nChecksum;\n };\n \n /** nServices flags */\n-enum\n-{\n+enum {\n     NODE_NETWORK = (1 << 0),\n \n     // Bits 24-31 are reserved for temporary experiments. Just pick a bit that\n@@ -79,68 +79,69 @@ enum\n /** A CService with information about it as peer */\n class CAddress : public CService\n {\n-    public:\n-        CAddress();\n-        explicit CAddress(CService ipIn, uint64_t nServicesIn=NODE_NETWORK);\n-\n-        void Init();\n-\n-        ADD_SERIALIZE_METHODS;\n-\n-        template <typename Stream, typename Operation>\n-        inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n-            if (ser_action.ForRead())\n-                Init();\n-            if (nType & SER_DISK)\n-                READWRITE(nVersion);\n-            if ((nType & SER_DISK) ||\n-                (nVersion >= CADDR_TIME_VERSION && !(nType & SER_GETHASH)))\n-                READWRITE(nTime);\n-            READWRITE(nServices);\n-            READWRITE(*(CService*)this);\n-        }\n+public:\n+    CAddress();\n+    explicit CAddress(CService ipIn, uint64_t nServicesIn = NODE_NETWORK);\n+\n+    void Init();\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n+        if (ser_action.ForRead())\n+            Init();\n+        if (nType & SER_DISK)\n+            READWRITE(nVersion);\n+        if ((nType & SER_DISK) ||\n+            (nVersion >= CADDR_TIME_VERSION && !(nType & SER_GETHASH)))\n+            READWRITE(nTime);\n+        READWRITE(nServices);\n+        READWRITE(*(CService*)this);\n+    }\n \n     // TODO: make private (improves encapsulation)\n-    public:\n-        uint64_t nServices;\n+public:\n+    uint64_t nServices;\n \n-        // disk and network only\n-        unsigned int nTime;\n+    // disk and network only\n+    unsigned int nTime;\n \n-        // memory only\n-        int64_t nLastTry;\n+    // memory only\n+    int64_t nLastTry;\n };\n \n /** inv message data */\n class CInv\n {\n-    public:\n-        CInv();\n-        CInv(int typeIn, const uint256& hashIn);\n-        CInv(const std::string& strType, const uint256& hashIn);\n+public:\n+    CInv();\n+    CInv(int typeIn, const uint256& hashIn);\n+    CInv(const std::string& strType, const uint256& hashIn);\n \n-        ADD_SERIALIZE_METHODS;\n+    ADD_SERIALIZE_METHODS;\n \n-        template <typename Stream, typename Operation>\n-        inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n-            READWRITE(type);\n-            READWRITE(hash);\n-        }\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n+        READWRITE(type);\n+        READWRITE(hash);\n+    }\n \n-        friend bool operator<(const CInv& a, const CInv& b);\n+    friend bool operator<(const CInv& a, const CInv& b);\n \n-        bool IsKnownType() const;\n-        const char* GetCommand() const;\n-        std::string ToString() const;\n+    bool IsKnownType() const;\n+    const char* GetCommand() const;\n+    std::string ToString() const;\n \n     // TODO: make private (improves encapsulation)\n-    public:\n-        int type;\n-        uint256 hash;\n+public:\n+    int type;\n+    uint256 hash;\n };\n \n-enum\n-{\n+enum {\n     MSG_TX = 1,\n     MSG_BLOCK,\n     // Nodes may always request a MSG_FILTERED_BLOCK in a getdata, however,"
      },
      {
        "sha": "998e7dfb08a035dc5b70ade9b91b129dbfc996de",
        "filename": "src/random.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 16,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/random.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/random.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.cpp?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -8,8 +8,8 @@\n #ifdef WIN32\n #include \"compat.h\" // for Windows API\n #endif\n-#include \"serialize.h\" // for begin_ptr(vec)\n-#include \"util.h\" // for LogPrint()\n+#include \"serialize.h\"        // for begin_ptr(vec)\n+#include \"util.h\"             // for LogPrint()\n #include \"utilstrencodings.h\" // for GetTime()\n \n #include <limits>\n@@ -56,36 +56,33 @@ void RandAddSeedPerfmon()\n #ifdef WIN32\n     // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n     // Seed with the entire set of perfmon data\n-    std::vector <unsigned char> vData(250000,0);\n+    std::vector<unsigned char> vData(250000, 0);\n     long ret = 0;\n     unsigned long nSize = 0;\n     const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n-    while (true)\n-    {\n+    while (true) {\n         nSize = vData.size();\n         ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", NULL, NULL, begin_ptr(vData), &nSize);\n         if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n             break;\n-        vData.resize(std::max((vData.size()*3)/2, nMaxSize)); // Grow size of buffer exponentially\n+        vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n     }\n     RegCloseKey(HKEY_PERFORMANCE_DATA);\n-    if (ret == ERROR_SUCCESS)\n-    {\n-        RAND_add(begin_ptr(vData), nSize, nSize/100.0);\n+    if (ret == ERROR_SUCCESS) {\n+        RAND_add(begin_ptr(vData), nSize, nSize / 100.0);\n         OPENSSL_cleanse(begin_ptr(vData), nSize);\n         LogPrint(\"rand\", \"%s: %lu bytes\\n\", __func__, nSize);\n     } else {\n         static bool warned = false; // Warn only once\n-        if (!warned)\n-        {\n+        if (!warned) {\n             LogPrintf(\"%s: Warning: RegQueryValueExA(HKEY_PERFORMANCE_DATA) failed with code %i\\n\", __func__, ret);\n             warned = true;\n         }\n     }\n #endif\n }\n \n-bool GetRandBytes(unsigned char *buf, int num)\n+bool GetRandBytes(unsigned char* buf, int num)\n {\n     if (RAND_bytes(buf, num) != 1) {\n         LogPrintf(\"%s: OpenSSL RAND_bytes() failed with error: %s\\n\", __func__, ERR_error_string(ERR_get_error(), NULL));\n@@ -126,18 +123,17 @@ uint32_t insecure_rand_Rw = 11;\n void seed_insecure_rand(bool fDeterministic)\n {\n     // The seed values have some unlikely fixed points which we avoid.\n-    if(fDeterministic)\n-    {\n+    if (fDeterministic) {\n         insecure_rand_Rz = insecure_rand_Rw = 11;\n     } else {\n         uint32_t tmp;\n         do {\n             GetRandBytes((unsigned char*)&tmp, 4);\n-        } while(tmp == 0 || tmp == 0x9068ffffU);\n+        } while (tmp == 0 || tmp == 0x9068ffffU);\n         insecure_rand_Rz = tmp;\n         do {\n             GetRandBytes((unsigned char*)&tmp, 4);\n-        } while(tmp == 0 || tmp == 0x464fffffU);\n+        } while (tmp == 0 || tmp == 0x464fffffU);\n         insecure_rand_Rw = tmp;\n     }\n }"
      },
      {
        "sha": "161ebe89860aedfe96353cf30f06c159450c68a5",
        "filename": "src/random.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/random.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/random.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.h?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -19,7 +19,7 @@ void RandAddSeedPerfmon();\n /**\n  * Functions to gather random data via the OpenSSL PRNG\n  */\n-bool GetRandBytes(unsigned char *buf, int num);\n+bool GetRandBytes(unsigned char* buf, int num);\n uint64_t GetRand(uint64_t nMax);\n int GetRandInt(int nMax);\n uint256 GetRandHash();"
      },
      {
        "sha": "307aa2aab8b0c7aa9ee1fae41d19964d7604eff8",
        "filename": "src/rpcclient.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/rpcclient.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/rpcclient.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcclient.h?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -10,6 +10,6 @@\n #include \"json/json_spirit_utils.h\"\n #include \"json/json_spirit_writer_template.h\"\n \n-json_spirit::Array RPCConvertValues(const std::string &strMethod, const std::vector<std::string> &strParams);\n+json_spirit::Array RPCConvertValues(const std::string& strMethod, const std::vector<std::string>& strParams);\n \n #endif // _BITCOINRPC_CLIENT_H_"
      },
      {
        "sha": "ef35c9d646a5edec75af6bfda1597a53a2ad8e34",
        "filename": "src/sync.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 24,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/sync.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/sync.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.cpp?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -32,8 +32,7 @@ void PrintLockContention(const char* pszName, const char* pszFile, int nLine)\n // Complain if any thread tries to lock in a different order.\n //\n \n-struct CLockLocation\n-{\n+struct CLockLocation {\n     CLockLocation(const char* pszName, const char* pszFile, int nLine)\n     {\n         mutexName = pszName;\n@@ -43,7 +42,7 @@ struct CLockLocation\n \n     std::string ToString() const\n     {\n-        return mutexName+\"  \"+sourceFile+\":\"+itostr(sourceLine);\n+        return mutexName + \"  \" + sourceFile + \":\" + itostr(sourceLine);\n     }\n \n     std::string MutexName() const { return mutexName; }\n@@ -54,7 +53,7 @@ struct CLockLocation\n     int sourceLine;\n };\n \n-typedef std::vector< std::pair<void*, CLockLocation> > LockStack;\n+typedef std::vector<std::pair<void*, CLockLocation> > LockStack;\n \n static boost::mutex dd_mutex;\n static std::map<std::pair<void*, void*>, LockStack> lockorders;\n@@ -65,17 +64,19 @@ static void potential_deadlock_detected(const std::pair<void*, void*>& mismatch,\n {\n     LogPrintf(\"POTENTIAL DEADLOCK DETECTED\\n\");\n     LogPrintf(\"Previous lock order was:\\n\");\n-    BOOST_FOREACH(const PAIRTYPE(void*, CLockLocation)& i, s2)\n-    {\n-        if (i.first == mismatch.first) LogPrintf(\" (1)\");\n-        if (i.first == mismatch.second) LogPrintf(\" (2)\");\n+    BOOST_FOREACH (const PAIRTYPE(void*, CLockLocation) & i, s2) {\n+        if (i.first == mismatch.first)\n+            LogPrintf(\" (1)\");\n+        if (i.first == mismatch.second)\n+            LogPrintf(\" (2)\");\n         LogPrintf(\" %s\\n\", i.second.ToString());\n     }\n     LogPrintf(\"Current lock order is:\\n\");\n-    BOOST_FOREACH(const PAIRTYPE(void*, CLockLocation)& i, s1)\n-    {\n-        if (i.first == mismatch.first) LogPrintf(\" (1)\");\n-        if (i.first == mismatch.second) LogPrintf(\" (2)\");\n+    BOOST_FOREACH (const PAIRTYPE(void*, CLockLocation) & i, s1) {\n+        if (i.first == mismatch.first)\n+            LogPrintf(\" (1)\");\n+        if (i.first == mismatch.second)\n+            LogPrintf(\" (2)\");\n         LogPrintf(\" %s\\n\", i.second.ToString());\n     }\n }\n@@ -91,17 +92,17 @@ static void push_lock(void* c, const CLockLocation& locklocation, bool fTry)\n     (*lockstack).push_back(std::make_pair(c, locklocation));\n \n     if (!fTry) {\n-        BOOST_FOREACH(const PAIRTYPE(void*, CLockLocation)& i, (*lockstack)) {\n-            if (i.first == c) break;\n+        BOOST_FOREACH (const PAIRTYPE(void*, CLockLocation) & i, (*lockstack)) {\n+            if (i.first == c)\n+                break;\n \n             std::pair<void*, void*> p1 = std::make_pair(i.first, c);\n             if (lockorders.count(p1))\n                 continue;\n             lockorders[p1] = (*lockstack);\n \n             std::pair<void*, void*> p2 = std::make_pair(c, i.first);\n-            if (lockorders.count(p2))\n-            {\n+            if (lockorders.count(p2)) {\n                 potential_deadlock_detected(p1, lockorders[p2], lockorders[p1]);\n                 break;\n             }\n@@ -112,8 +113,7 @@ static void push_lock(void* c, const CLockLocation& locklocation, bool fTry)\n \n static void pop_lock()\n {\n-    if (fDebug)\n-    {\n+    if (fDebug) {\n         const CLockLocation& locklocation = (*lockstack).rbegin()->second;\n         LogPrint(\"lock\", \"Unlocked: %s\\n\", locklocation.ToString());\n     }\n@@ -135,17 +135,17 @@ void LeaveCritical()\n std::string LocksHeld()\n {\n     std::string result;\n-    BOOST_FOREACH(const PAIRTYPE(void*, CLockLocation)&i, *lockstack)\n+    BOOST_FOREACH (const PAIRTYPE(void*, CLockLocation) & i, *lockstack)\n         result += i.second.ToString() + std::string(\"\\n\");\n     return result;\n }\n \n-void AssertLockHeldInternal(const char *pszName, const char* pszFile, int nLine, void *cs)\n+void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs)\n {\n-    BOOST_FOREACH(const PAIRTYPE(void*, CLockLocation)&i, *lockstack)\n-        if (i.first == cs) return;\n-    fprintf(stderr, \"Assertion failed: lock %s not held in %s:%i; locks held:\\n%s\",\n-            pszName, pszFile, nLine, LocksHeld().c_str());\n+    BOOST_FOREACH (const PAIRTYPE(void*, CLockLocation) & i, *lockstack)\n+        if (i.first == cs)\n+            return;\n+    fprintf(stderr, \"Assertion failed: lock %s not held in %s:%i; locks held:\\n%s\", pszName, pszFile, nLine, LocksHeld().c_str());\n     abort();\n }\n "
      },
      {
        "sha": "cd0aa7b20e7177c25192e67eb342f735a9690cb9",
        "filename": "src/sync.h",
        "status": "modified",
        "additions": 40,
        "deletions": 30,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/sync.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/sync.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.h?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -48,7 +48,6 @@ LEAVE_CRITICAL_SECTION(mutex); // no RAII\n  */\n \n \n-\n ///////////////////////////////\n //                           //\n // THE ACTUAL IMPLEMENTATION //\n@@ -63,17 +62,17 @@ class LOCKABLE AnnotatedMixin : public PARENT\n public:\n     void lock() EXCLUSIVE_LOCK_FUNCTION()\n     {\n-      PARENT::lock();\n+        PARENT::lock();\n     }\n \n     void unlock() UNLOCK_FUNCTION()\n     {\n-      PARENT::unlock();\n+        PARENT::unlock();\n     }\n \n     bool try_lock() EXCLUSIVE_TRYLOCK_FUNCTION(true)\n     {\n-      return PARENT::try_lock();\n+        return PARENT::try_lock();\n     }\n };\n \n@@ -91,11 +90,13 @@ typedef boost::condition_variable CConditionVariable;\n void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false);\n void LeaveCritical();\n std::string LocksHeld();\n-void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void *cs);\n+void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs);\n #else\n-void static inline EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false) {}\n+void static inline EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false)\n+{\n+}\n void static inline LeaveCritical() {}\n-void static inline AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void *cs) {}\n+void static inline AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) {}\n #endif\n #define AssertLockHeld(cs) AssertLockHeldInternal(#cs, __FILE__, __LINE__, &cs)\n \n@@ -104,7 +105,7 @@ void PrintLockContention(const char* pszName, const char* pszFile, int nLine);\n #endif\n \n /** Wrapper around boost::unique_lock<Mutex> */\n-template<typename Mutex>\n+template <typename Mutex>\n class CMutexLock\n {\n private:\n@@ -114,11 +115,10 @@ class CMutexLock\n     {\n         EnterCritical(pszName, pszFile, nLine, (void*)(lock.mutex()));\n #ifdef DEBUG_LOCKCONTENTION\n-        if (!lock.try_lock())\n-        {\n+        if (!lock.try_lock()) {\n             PrintLockContention(pszName, pszFile, nLine);\n #endif\n-        lock.lock();\n+            lock.lock();\n #ifdef DEBUG_LOCKCONTENTION\n         }\n #endif\n@@ -157,19 +157,19 @@ class CMutexLock\n typedef CMutexLock<CCriticalSection> CCriticalBlock;\n \n #define LOCK(cs) CCriticalBlock criticalblock(cs, #cs, __FILE__, __LINE__)\n-#define LOCK2(cs1,cs2) CCriticalBlock criticalblock1(cs1, #cs1, __FILE__, __LINE__),criticalblock2(cs2, #cs2, __FILE__, __LINE__)\n-#define TRY_LOCK(cs,name) CCriticalBlock name(cs, #cs, __FILE__, __LINE__, true)\n+#define LOCK2(cs1, cs2) CCriticalBlock criticalblock1(cs1, #cs1, __FILE__, __LINE__), criticalblock2(cs2, #cs2, __FILE__, __LINE__)\n+#define TRY_LOCK(cs, name) CCriticalBlock name(cs, #cs, __FILE__, __LINE__, true)\n \n-#define ENTER_CRITICAL_SECTION(cs) \\\n-    { \\\n+#define ENTER_CRITICAL_SECTION(cs)                            \\\n+    {                                                         \\\n         EnterCritical(#cs, __FILE__, __LINE__, (void*)(&cs)); \\\n-        (cs).lock(); \\\n+        (cs).lock();                                          \\\n     }\n \n #define LEAVE_CRITICAL_SECTION(cs) \\\n-    { \\\n-        (cs).unlock(); \\\n-        LeaveCritical(); \\\n+    {                              \\\n+        (cs).unlock();             \\\n+        LeaveCritical();           \\\n     }\n \n class CSemaphore\n@@ -182,23 +182,26 @@ class CSemaphore\n public:\n     CSemaphore(int init) : value(init) {}\n \n-    void wait() {\n+    void wait()\n+    {\n         boost::unique_lock<boost::mutex> lock(mutex);\n         while (value < 1) {\n             condition.wait(lock);\n         }\n         value--;\n     }\n \n-    bool try_wait() {\n+    bool try_wait()\n+    {\n         boost::unique_lock<boost::mutex> lock(mutex);\n         if (value < 1)\n             return false;\n         value--;\n         return true;\n     }\n \n-    void post() {\n+    void post()\n+    {\n         {\n             boost::unique_lock<boost::mutex> lock(mutex);\n             value++;\n@@ -211,31 +214,35 @@ class CSemaphore\n class CSemaphoreGrant\n {\n private:\n-    CSemaphore *sem;\n+    CSemaphore* sem;\n     bool fHaveGrant;\n \n public:\n-    void Acquire() {\n+    void Acquire()\n+    {\n         if (fHaveGrant)\n             return;\n         sem->wait();\n         fHaveGrant = true;\n     }\n \n-    void Release() {\n+    void Release()\n+    {\n         if (!fHaveGrant)\n             return;\n         sem->post();\n         fHaveGrant = false;\n     }\n \n-    bool TryAcquire() {\n+    bool TryAcquire()\n+    {\n         if (!fHaveGrant && sem->try_wait())\n             fHaveGrant = true;\n         return fHaveGrant;\n     }\n \n-    void MoveTo(CSemaphoreGrant &grant) {\n+    void MoveTo(CSemaphoreGrant& grant)\n+    {\n         grant.Release();\n         grant.sem = sem;\n         grant.fHaveGrant = fHaveGrant;\n@@ -245,18 +252,21 @@ class CSemaphoreGrant\n \n     CSemaphoreGrant() : sem(NULL), fHaveGrant(false) {}\n \n-    CSemaphoreGrant(CSemaphore &sema, bool fTry = false) : sem(&sema), fHaveGrant(false) {\n+    CSemaphoreGrant(CSemaphore& sema, bool fTry = false) : sem(&sema), fHaveGrant(false)\n+    {\n         if (fTry)\n             TryAcquire();\n         else\n             Acquire();\n     }\n \n-    ~CSemaphoreGrant() {\n+    ~CSemaphoreGrant()\n+    {\n         Release();\n     }\n \n-    operator bool() {\n+    operator bool()\n+    {\n         return fHaveGrant;\n     }\n };"
      },
      {
        "sha": "7515d050e725c1c7e18b9147477bbf34a3002ae8",
        "filename": "src/threadsafety.h",
        "status": "modified",
        "additions": 20,
        "deletions": 20,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/threadsafety.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/threadsafety.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/threadsafety.h?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -13,24 +13,24 @@\n // See http://clang.llvm.org/docs/LanguageExtensions.html#threadsafety\n // for documentation.  The clang compiler can do advanced static analysis\n // of locking when given the -Wthread-safety option.\n-#define LOCKABLE                        __attribute__ ((lockable))\n-#define SCOPED_LOCKABLE                 __attribute__ ((scoped_lockable))\n-#define GUARDED_BY(x)                   __attribute__ ((guarded_by(x)))\n-#define GUARDED_VAR                     __attribute__ ((guarded_var))\n-#define PT_GUARDED_BY(x)                __attribute__ ((pt_guarded_by(x)))\n-#define PT_GUARDED_VAR                  __attribute__ ((pt_guarded_var))\n-#define ACQUIRED_AFTER(...)             __attribute__ ((acquired_after(__VA_ARGS__)))\n-#define ACQUIRED_BEFORE(...)            __attribute__ ((acquired_before(__VA_ARGS__)))\n-#define EXCLUSIVE_LOCK_FUNCTION(...)    __attribute__ ((exclusive_lock_function(__VA_ARGS__)))\n-#define SHARED_LOCK_FUNCTION(...)       __attribute__ ((shared_lock_function(__VA_ARGS__)))\n-#define EXCLUSIVE_TRYLOCK_FUNCTION(...) __attribute__ ((exclusive_trylock_function(__VA_ARGS__)))\n-#define SHARED_TRYLOCK_FUNCTION(...)    __attribute__ ((shared_trylock_function(__VA_ARGS__)))\n-#define UNLOCK_FUNCTION(...)            __attribute__ ((unlock_function(__VA_ARGS__)))\n-#define LOCK_RETURNED(x)                __attribute__ ((lock_returned(x)))\n-#define LOCKS_EXCLUDED(...)             __attribute__ ((locks_excluded(__VA_ARGS__)))\n-#define EXCLUSIVE_LOCKS_REQUIRED(...)   __attribute__ ((exclusive_locks_required(__VA_ARGS__)))\n-#define SHARED_LOCKS_REQUIRED(...)      __attribute__ ((shared_locks_required(__VA_ARGS__)))\n-#define NO_THREAD_SAFETY_ANALYSIS       __attribute__ ((no_thread_safety_analysis))\n+#define LOCKABLE __attribute__((lockable))\n+#define SCOPED_LOCKABLE __attribute__((scoped_lockable))\n+#define GUARDED_BY(x) __attribute__((guarded_by(x)))\n+#define GUARDED_VAR __attribute__((guarded_var))\n+#define PT_GUARDED_BY(x) __attribute__((pt_guarded_by(x)))\n+#define PT_GUARDED_VAR __attribute__((pt_guarded_var))\n+#define ACQUIRED_AFTER(...) __attribute__((acquired_after(__VA_ARGS__)))\n+#define ACQUIRED_BEFORE(...) __attribute__((acquired_before(__VA_ARGS__)))\n+#define EXCLUSIVE_LOCK_FUNCTION(...) __attribute__((exclusive_lock_function(__VA_ARGS__)))\n+#define SHARED_LOCK_FUNCTION(...) __attribute__((shared_lock_function(__VA_ARGS__)))\n+#define EXCLUSIVE_TRYLOCK_FUNCTION(...) __attribute__((exclusive_trylock_function(__VA_ARGS__)))\n+#define SHARED_TRYLOCK_FUNCTION(...) __attribute__((shared_trylock_function(__VA_ARGS__)))\n+#define UNLOCK_FUNCTION(...) __attribute__((unlock_function(__VA_ARGS__)))\n+#define LOCK_RETURNED(x) __attribute__((lock_returned(x)))\n+#define LOCKS_EXCLUDED(...) __attribute__((locks_excluded(__VA_ARGS__)))\n+#define EXCLUSIVE_LOCKS_REQUIRED(...) __attribute__((exclusive_locks_required(__VA_ARGS__)))\n+#define SHARED_LOCKS_REQUIRED(...) __attribute__((shared_locks_required(__VA_ARGS__)))\n+#define NO_THREAD_SAFETY_ANALYSIS __attribute__((no_thread_safety_analysis))\n #else\n #define LOCKABLE\n #define SCOPED_LOCKABLE\n@@ -50,6 +50,6 @@\n #define EXCLUSIVE_LOCKS_REQUIRED(...)\n #define SHARED_LOCKS_REQUIRED(...)\n #define NO_THREAD_SAFETY_ANALYSIS\n-#endif  // __GNUC__\n+#endif // __GNUC__\n \n-#endif  // BITCOIN_THREADSAFETY_H\n+#endif // BITCOIN_THREADSAFETY_H"
      },
      {
        "sha": "2c20f4efd5e4bd376f3b302b890ea9768773c9fe",
        "filename": "src/timedata.h",
        "status": "modified",
        "additions": 11,
        "deletions": 12,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/timedata.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/timedata.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.h?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -15,15 +15,16 @@ class CNetAddr;\n /** Median filter over a stream of values.\n  * Returns the median of the last N numbers\n  */\n-template <typename T> class CMedianFilter\n+template <typename T>\n+class CMedianFilter\n {\n private:\n     std::vector<T> vValues;\n     std::vector<T> vSorted;\n     unsigned int nSize;\n+\n public:\n-    CMedianFilter(unsigned int size, T initial_value):\n-        nSize(size)\n+    CMedianFilter(unsigned int size, T initial_value) : nSize(size)\n     {\n         vValues.reserve(size);\n         vValues.push_back(initial_value);\n@@ -32,8 +33,7 @@ template <typename T> class CMedianFilter\n \n     void input(T value)\n     {\n-        if(vValues.size() == nSize)\n-        {\n+        if (vValues.size() == nSize) {\n             vValues.erase(vValues.begin());\n         }\n         vValues.push_back(value);\n@@ -46,14 +46,13 @@ template <typename T> class CMedianFilter\n     T median() const\n     {\n         int size = vSorted.size();\n-        assert(size>0);\n-        if(size & 1) // Odd number of elements\n+        assert(size > 0);\n+        if (size & 1) // Odd number of elements\n         {\n-            return vSorted[size/2];\n-        }\n-        else // Even number of elements\n+            return vSorted[size / 2];\n+        } else // Even number of elements\n         {\n-            return (vSorted[size/2-1] + vSorted[size/2]) / 2;\n+            return (vSorted[size / 2 - 1] + vSorted[size / 2]) / 2;\n         }\n     }\n \n@@ -62,7 +61,7 @@ template <typename T> class CMedianFilter\n         return vValues.size();\n     }\n \n-    std::vector<T> sorted () const\n+    std::vector<T> sorted() const\n     {\n         return vSorted;\n     }"
      },
      {
        "sha": "79406f24757b5ae815c905f17fc9b44f3f5c9f9f",
        "filename": "src/uint256.cpp",
        "status": "modified",
        "additions": 77,
        "deletions": 56,
        "changes": 133,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/uint256.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/uint256.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/uint256.cpp?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -10,21 +10,21 @@\n #include <stdio.h>\n #include <string.h>\n \n-template<unsigned int BITS>\n+template <unsigned int BITS>\n base_uint<BITS>::base_uint(const std::string& str)\n {\n     SetHex(str);\n }\n \n-template<unsigned int BITS>\n+template <unsigned int BITS>\n base_uint<BITS>::base_uint(const std::vector<unsigned char>& vch)\n {\n     if (vch.size() != sizeof(pn))\n         throw uint_error(\"Converting vector of wrong size to base_uint\");\n     memcpy(pn, &vch[0], sizeof(pn));\n }\n \n-template<unsigned int BITS>\n+template <unsigned int BITS>\n base_uint<BITS>& base_uint<BITS>::operator<<=(unsigned int shift)\n {\n     base_uint<BITS> a(*this);\n@@ -33,15 +33,15 @@ base_uint<BITS>& base_uint<BITS>::operator<<=(unsigned int shift)\n     int k = shift / 32;\n     shift = shift % 32;\n     for (int i = 0; i < WIDTH; i++) {\n-        if (i+k+1 < WIDTH && shift != 0)\n-            pn[i+k+1] |= (a.pn[i] >> (32-shift));\n-        if (i+k < WIDTH)\n-            pn[i+k] |= (a.pn[i] << shift);\n+        if (i + k + 1 < WIDTH && shift != 0)\n+            pn[i + k + 1] |= (a.pn[i] >> (32 - shift));\n+        if (i + k < WIDTH)\n+            pn[i + k] |= (a.pn[i] << shift);\n     }\n     return *this;\n }\n \n-template<unsigned int BITS>\n+template <unsigned int BITS>\n base_uint<BITS>& base_uint<BITS>::operator>>=(unsigned int shift)\n {\n     base_uint<BITS> a(*this);\n@@ -50,15 +50,15 @@ base_uint<BITS>& base_uint<BITS>::operator>>=(unsigned int shift)\n     int k = shift / 32;\n     shift = shift % 32;\n     for (int i = 0; i < WIDTH; i++) {\n-        if (i-k-1 >= 0 && shift != 0)\n-            pn[i-k-1] |= (a.pn[i] << (32-shift));\n-        if (i-k >= 0)\n-            pn[i-k] |= (a.pn[i] >> shift);\n+        if (i - k - 1 >= 0 && shift != 0)\n+            pn[i - k - 1] |= (a.pn[i] << (32 - shift));\n+        if (i - k >= 0)\n+            pn[i - k] |= (a.pn[i] >> shift);\n     }\n     return *this;\n }\n \n-template<unsigned int BITS>\n+template <unsigned int BITS>\n base_uint<BITS>& base_uint<BITS>::operator*=(uint32_t b32)\n {\n     uint64_t carry = 0;\n@@ -70,7 +70,7 @@ base_uint<BITS>& base_uint<BITS>::operator*=(uint32_t b32)\n     return *this;\n }\n \n-template<unsigned int BITS>\n+template <unsigned int BITS>\n base_uint<BITS>& base_uint<BITS>::operator*=(const base_uint& b)\n {\n     base_uint<BITS> a = *this;\n@@ -86,12 +86,12 @@ base_uint<BITS>& base_uint<BITS>::operator*=(const base_uint& b)\n     return *this;\n }\n \n-template<unsigned int BITS>\n+template <unsigned int BITS>\n base_uint<BITS>& base_uint<BITS>::operator/=(const base_uint& b)\n {\n-    base_uint<BITS> div = b; // make a copy, so we can shift.\n+    base_uint<BITS> div = b;     // make a copy, so we can shift.\n     base_uint<BITS> num = *this; // make a copy, so we can subtract.\n-    *this = 0; // the quotient.\n+    *this = 0;                   // the quotient.\n     int num_bits = num.bits();\n     int div_bits = div.bits();\n     if (div_bits == 0)\n@@ -112,9 +112,10 @@ base_uint<BITS>& base_uint<BITS>::operator/=(const base_uint& b)\n     return *this;\n }\n \n-template<unsigned int BITS>\n-int base_uint<BITS>::CompareTo(const base_uint<BITS>& b) const {\n-    for (int i = WIDTH-1; i >= 0; i--) {\n+template <unsigned int BITS>\n+int base_uint<BITS>::CompareTo(const base_uint<BITS>& b) const\n+{\n+    for (int i = WIDTH - 1; i >= 0; i--) {\n         if (pn[i] < b.pn[i])\n             return -1;\n         if (pn[i] > b.pn[i])\n@@ -123,9 +124,10 @@ int base_uint<BITS>::CompareTo(const base_uint<BITS>& b) const {\n     return 0;\n }\n \n-template<unsigned int BITS>\n-bool base_uint<BITS>::EqualTo(uint64_t b) const {\n-    for (int i = WIDTH-1; i >= 2; i--) {\n+template <unsigned int BITS>\n+bool base_uint<BITS>::EqualTo(uint64_t b) const\n+{\n+    for (int i = WIDTH - 1; i >= 2; i--) {\n         if (pn[i])\n             return false;\n     }\n@@ -136,7 +138,7 @@ bool base_uint<BITS>::EqualTo(uint64_t b) const {\n     return true;\n }\n \n-template<unsigned int BITS>\n+template <unsigned int BITS>\n double base_uint<BITS>::getdouble() const\n {\n     double ret = 0.0;\n@@ -148,19 +150,19 @@ double base_uint<BITS>::getdouble() const\n     return ret;\n }\n \n-template<unsigned int BITS>\n+template <unsigned int BITS>\n std::string base_uint<BITS>::GetHex() const\n {\n-    char psz[sizeof(pn)*2 + 1];\n+    char psz[sizeof(pn) * 2 + 1];\n     for (unsigned int i = 0; i < sizeof(pn); i++)\n-        sprintf(psz + i*2, \"%02x\", ((unsigned char*)pn)[sizeof(pn) - i - 1]);\n-    return std::string(psz, psz + sizeof(pn)*2);\n+        sprintf(psz + i * 2, \"%02x\", ((unsigned char*)pn)[sizeof(pn) - i - 1]);\n+    return std::string(psz, psz + sizeof(pn) * 2);\n }\n \n-template<unsigned int BITS>\n+template <unsigned int BITS>\n void base_uint<BITS>::SetHex(const char* psz)\n {\n-    memset(pn,0,sizeof(pn));\n+    memset(pn, 0, sizeof(pn));\n \n     // skip leading spaces\n     while (isspace(*psz))\n@@ -186,28 +188,28 @@ void base_uint<BITS>::SetHex(const char* psz)\n     }\n }\n \n-template<unsigned int BITS>\n+template <unsigned int BITS>\n void base_uint<BITS>::SetHex(const std::string& str)\n {\n     SetHex(str.c_str());\n }\n \n-template<unsigned int BITS>\n+template <unsigned int BITS>\n std::string base_uint<BITS>::ToString() const\n {\n     return (GetHex());\n }\n \n-template<unsigned int BITS>\n+template <unsigned int BITS>\n unsigned int base_uint<BITS>::bits() const\n {\n-    for (int pos = WIDTH-1; pos >= 0; pos--) {\n+    for (int pos = WIDTH - 1; pos >= 0; pos--) {\n         if (pn[pos]) {\n             for (int bits = 31; bits > 0; bits--) {\n-                if (pn[pos] & 1<<bits)\n-                    return 32*pos + bits + 1;\n+                if (pn[pos] & 1 << bits)\n+                    return 32 * pos + bits + 1;\n             }\n-            return 32*pos + 1;\n+            return 32 * pos + 1;\n         }\n     }\n     return 0;\n@@ -249,16 +251,16 @@ template unsigned int base_uint<256>::bits() const;\n \n // This implementation directly uses shifts instead of going\n // through an intermediate MPI representation.\n-uint256& uint256::SetCompact(uint32_t nCompact, bool *pfNegative, bool *pfOverflow)\n+uint256& uint256::SetCompact(uint32_t nCompact, bool* pfNegative, bool* pfOverflow)\n {\n     int nSize = nCompact >> 24;\n     uint32_t nWord = nCompact & 0x007fffff;\n     if (nSize <= 3) {\n-        nWord >>= 8*(3-nSize);\n+        nWord >>= 8 * (3 - nSize);\n         *this = nWord;\n     } else {\n         *this = nWord;\n-        *this <<= 8*(nSize-3);\n+        *this <<= 8 * (nSize - 3);\n     }\n     if (pfNegative)\n         *pfNegative = nWord != 0 && (nCompact & 0x00800000) != 0;\n@@ -274,9 +276,9 @@ uint32_t uint256::GetCompact(bool fNegative) const\n     int nSize = (bits() + 7) / 8;\n     uint32_t nCompact = 0;\n     if (nSize <= 3) {\n-        nCompact = GetLow64() << 8*(3-nSize);\n+        nCompact = GetLow64() << 8 * (3 - nSize);\n     } else {\n-        uint256 bn = *this >> 8*(nSize-3);\n+        uint256 bn = *this >> 8 * (nSize - 3);\n         nCompact = bn.GetLow64();\n     }\n     // The 0x00800000 bit denotes the sign.\n@@ -295,27 +297,46 @@ uint32_t uint256::GetCompact(bool fNegative) const\n static void inline HashMix(uint32_t& a, uint32_t& b, uint32_t& c)\n {\n     // Taken from lookup3, by Bob Jenkins.\n-    a -= c; a ^= ((c <<  4) | (c >> 28)); c += b;\n-    b -= a; b ^= ((a <<  6) | (a >> 26)); a += c;\n-    c -= b; c ^= ((b <<  8) | (b >> 24)); b += a;\n-    a -= c; a ^= ((c << 16) | (c >> 16)); c += b;\n-    b -= a; b ^= ((a << 19) | (a >> 13)); a += c;\n-    c -= b; c ^= ((b <<  4) | (b >> 28)); b += a;\n+    a -= c;\n+    a ^= ((c << 4) | (c >> 28));\n+    c += b;\n+    b -= a;\n+    b ^= ((a << 6) | (a >> 26));\n+    a += c;\n+    c -= b;\n+    c ^= ((b << 8) | (b >> 24));\n+    b += a;\n+    a -= c;\n+    a ^= ((c << 16) | (c >> 16));\n+    c += b;\n+    b -= a;\n+    b ^= ((a << 19) | (a >> 13));\n+    a += c;\n+    c -= b;\n+    c ^= ((b << 4) | (b >> 28));\n+    b += a;\n }\n \n static void inline HashFinal(uint32_t& a, uint32_t& b, uint32_t& c)\n {\n     // Taken from lookup3, by Bob Jenkins.\n-    c ^= b; c -= ((b << 14) | (b >> 18));\n-    a ^= c; a -= ((c << 11) | (c >> 21));\n-    b ^= a; b -= ((a << 25) | (a >>  7));\n-    c ^= b; c -= ((b << 16) | (b >> 16));\n-    a ^= c; a -= ((c <<  4) | (c >> 28));\n-    b ^= a; b -= ((a << 14) | (a >> 18));\n-    c ^= b; c -= ((b << 24) | (b >>  8));\n+    c ^= b;\n+    c -= ((b << 14) | (b >> 18));\n+    a ^= c;\n+    a -= ((c << 11) | (c >> 21));\n+    b ^= a;\n+    b -= ((a << 25) | (a >> 7));\n+    c ^= b;\n+    c -= ((b << 16) | (b >> 16));\n+    a ^= c;\n+    a -= ((c << 4) | (c >> 28));\n+    b ^= a;\n+    b -= ((a << 14) | (a >> 18));\n+    c ^= b;\n+    c -= ((b << 24) | (b >> 8));\n }\n \n-uint64_t uint256::GetHash(const uint256 &salt) const\n+uint64_t uint256::GetHash(const uint256& salt) const\n {\n     uint32_t a, b, c;\n     a = b = c = 0xdeadbeef + (WIDTH << 2);"
      },
      {
        "sha": "95632fdab7066a3a20bafbef98efdd2425a3dfcf",
        "filename": "src/version.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 22,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20e01b1a03819d843a860284033b48a5e3b65ff7/src/version.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20e01b1a03819d843a860284033b48a5e3b65ff7/src/version.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/version.cpp?ref=20e01b1a03819d843a860284033b48a5e3b65ff7",
        "patch": "@@ -16,7 +16,7 @@\n const std::string CLIENT_NAME(\"Satoshi\");\n \n // Client version number\n-#define CLIENT_VERSION_SUFFIX   \"\"\n+#define CLIENT_VERSION_SUFFIX \"\"\n \n \n // The following part of the code determines the CLIENT_BUILD variable.\n@@ -35,51 +35,51 @@ const std::string CLIENT_NAME(\"Satoshi\");\n \n // First, include build.h if requested\n #ifdef HAVE_BUILD_INFO\n-#    include \"build.h\"\n+#include \"build.h\"\n #endif\n \n // git will put \"#define GIT_ARCHIVE 1\" on the next line inside archives. $Format:%n#define GIT_ARCHIVE 1$\n #ifdef GIT_ARCHIVE\n-#    define GIT_COMMIT_ID \"$Format:%h$\"\n-#    define GIT_COMMIT_DATE \"$Format:%cD$\"\n+#define GIT_COMMIT_ID \"$Format:%h$\"\n+#define GIT_COMMIT_DATE \"$Format:%cD$\"\n #endif\n \n-#define BUILD_DESC_WITH_SUFFIX(maj,min,rev,build,suffix) \\\n+#define BUILD_DESC_WITH_SUFFIX(maj, min, rev, build, suffix) \\\n     \"v\" DO_STRINGIZE(maj) \".\" DO_STRINGIZE(min) \".\" DO_STRINGIZE(rev) \".\" DO_STRINGIZE(build) \"-\" DO_STRINGIZE(suffix)\n \n-#define BUILD_DESC_FROM_COMMIT(maj,min,rev,build,commit) \\\n+#define BUILD_DESC_FROM_COMMIT(maj, min, rev, build, commit) \\\n     \"v\" DO_STRINGIZE(maj) \".\" DO_STRINGIZE(min) \".\" DO_STRINGIZE(rev) \".\" DO_STRINGIZE(build) \"-g\" commit\n \n-#define BUILD_DESC_FROM_UNKNOWN(maj,min,rev,build) \\\n+#define BUILD_DESC_FROM_UNKNOWN(maj, min, rev, build) \\\n     \"v\" DO_STRINGIZE(maj) \".\" DO_STRINGIZE(min) \".\" DO_STRINGIZE(rev) \".\" DO_STRINGIZE(build) \"-unk\"\n \n #ifndef BUILD_DESC\n-#    ifdef BUILD_SUFFIX\n-#        define BUILD_DESC BUILD_DESC_WITH_SUFFIX(CLIENT_VERSION_MAJOR, CLIENT_VERSION_MINOR, CLIENT_VERSION_REVISION, CLIENT_VERSION_BUILD, BUILD_SUFFIX)\n-#    elif defined(GIT_COMMIT_ID)\n-#        define BUILD_DESC BUILD_DESC_FROM_COMMIT(CLIENT_VERSION_MAJOR, CLIENT_VERSION_MINOR, CLIENT_VERSION_REVISION, CLIENT_VERSION_BUILD, GIT_COMMIT_ID)\n-#    else\n-#        define BUILD_DESC BUILD_DESC_FROM_UNKNOWN(CLIENT_VERSION_MAJOR, CLIENT_VERSION_MINOR, CLIENT_VERSION_REVISION, CLIENT_VERSION_BUILD)\n-#    endif\n+#ifdef BUILD_SUFFIX\n+#define BUILD_DESC BUILD_DESC_WITH_SUFFIX(CLIENT_VERSION_MAJOR, CLIENT_VERSION_MINOR, CLIENT_VERSION_REVISION, CLIENT_VERSION_BUILD, BUILD_SUFFIX)\n+#elif defined(GIT_COMMIT_ID)\n+#define BUILD_DESC BUILD_DESC_FROM_COMMIT(CLIENT_VERSION_MAJOR, CLIENT_VERSION_MINOR, CLIENT_VERSION_REVISION, CLIENT_VERSION_BUILD, GIT_COMMIT_ID)\n+#else\n+#define BUILD_DESC BUILD_DESC_FROM_UNKNOWN(CLIENT_VERSION_MAJOR, CLIENT_VERSION_MINOR, CLIENT_VERSION_REVISION, CLIENT_VERSION_BUILD)\n+#endif\n #endif\n \n #ifndef BUILD_DATE\n-#    ifdef GIT_COMMIT_DATE\n-#        define BUILD_DATE GIT_COMMIT_DATE\n-#    else\n-#        define BUILD_DATE __DATE__ \", \" __TIME__\n-#    endif\n+#ifdef GIT_COMMIT_DATE\n+#define BUILD_DATE GIT_COMMIT_DATE\n+#else\n+#define BUILD_DATE __DATE__ \", \" __TIME__\n+#endif\n #endif\n \n const std::string CLIENT_BUILD(BUILD_DESC CLIENT_VERSION_SUFFIX);\n const std::string CLIENT_DATE(BUILD_DATE);\n \n static std::string FormatVersion(int nVersion)\n {\n-    if (nVersion%100 == 0)\n-        return strprintf(\"%d.%d.%d\", nVersion/1000000, (nVersion/10000)%100, (nVersion/100)%100);\n+    if (nVersion % 100 == 0)\n+        return strprintf(\"%d.%d.%d\", nVersion / 1000000, (nVersion / 10000) % 100, (nVersion / 100) % 100);\n     else\n-        return strprintf(\"%d.%d.%d.%d\", nVersion/1000000, (nVersion/10000)%100, (nVersion/100)%100, nVersion%100);\n+        return strprintf(\"%d.%d.%d.%d\", nVersion / 1000000, (nVersion / 10000) % 100, (nVersion / 100) % 100, nVersion % 100);\n }\n \n std::string FormatFullVersion()"
      }
    ]
  }
]