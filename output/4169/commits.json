[
  {
    "sha": "0655fac0b11c7fa1992f50537887728a0878a5eb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNjU1ZmFjMGIxMWM3ZmExOTkyZjUwNTM3ODg3NzI4YTA4NzhhNWVi",
    "commit": {
      "author": {
        "name": "Philip Kaufmann",
        "email": "phil.kaufmann@t-online.de",
        "date": "2014-05-10T12:47:16Z"
      },
      "committer": {
        "name": "Philip Kaufmann",
        "email": "phil.kaufmann@t-online.de",
        "date": "2014-06-21T22:33:42Z"
      },
      "message": "miner: indentation fixes, remove for (;;)\n\n- change a for (;;) into while (true), as we nowhere else use the first\n- init nNonceFound to 0\n- fix indentation in BitcoinMiner try/catch block",
      "tree": {
        "sha": "961f7a2bd7b2ebf9a68120d013be6ef0eb13e70b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/961f7a2bd7b2ebf9a68120d013be6ef0eb13e70b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0655fac0b11c7fa1992f50537887728a0878a5eb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0655fac0b11c7fa1992f50537887728a0878a5eb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0655fac0b11c7fa1992f50537887728a0878a5eb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0655fac0b11c7fa1992f50537887728a0878a5eb/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "8f59251b83cd9c862aee53dd50ce32bcab12ed6d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8f59251b83cd9c862aee53dd50ce32bcab12ed6d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8f59251b83cd9c862aee53dd50ce32bcab12ed6d"
      }
    ],
    "stats": {
      "total": 199,
      "additions": 101,
      "deletions": 98
    },
    "files": [
      {
        "sha": "3daf823fd8848f109b00df3b613cd600ebf776af",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 101,
        "deletions": 98,
        "changes": 199,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0655fac0b11c7fa1992f50537887728a0878a5eb/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0655fac0b11c7fa1992f50537887728a0878a5eb/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=0655fac0b11c7fa1992f50537887728a0878a5eb",
        "patch": "@@ -49,7 +49,6 @@ class COrphan\n     }\n };\n \n-\n uint64_t nLastBlockTx = 0;\n uint64_t nLastBlockSize = 0;\n \n@@ -58,8 +57,10 @@ typedef boost::tuple<double, CFeeRate, const CTransaction*> TxPriority;\n class TxPriorityCompare\n {\n     bool byFee;\n+\n public:\n     TxPriorityCompare(bool _byFee) : byFee(_byFee) { }\n+\n     bool operator()(const TxPriority& a, const TxPriority& b)\n     {\n         if (byFee)\n@@ -114,6 +115,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n \n     // Collect memory pool transactions into the block\n     int64_t nFees = 0;\n+\n     {\n         LOCK2(cs_main, mempool.cs);\n         CBlockIndex* pindexPrev = chainActive.Tip();\n@@ -269,7 +271,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n             if (fPrintPriority)\n             {\n                 LogPrintf(\"priority %.1f fee %s txid %s\\n\",\n-                          dPriority, feeRate.ToString(), tx.GetHash().ToString());\n+                    dPriority, feeRate.ToString(), tx.GetHash().ToString());\n             }\n \n             // Add transactions that depend on this one to the priority queue\n@@ -334,7 +336,6 @@ void IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int&\n     pblock->hashMerkleRoot = pblock->BuildMerkleTree();\n }\n \n-\n #ifdef ENABLE_WALLET\n //////////////////////////////////////////////////////////////////////////////\n //\n@@ -349,15 +350,16 @@ int64_t nHPSTimerStart = 0;\n // nonce is 0xffff0000 or above, the block is rebuilt and nNonce starts over at\n // zero.\n //\n-bool static ScanHash(const CBlockHeader *pblock, uint32_t& nNonce, uint256 *phash) {\n+bool static ScanHash(const CBlockHeader *pblock, uint32_t& nNonce, uint256 *phash)\n+{\n     // Write the first 76 bytes of the block header to a double-SHA256 state.\n     CHash256 hasher;\n     CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n     ss << *pblock;\n     assert(ss.size() == 80);\n     hasher.Write((unsigned char*)&ss[0], 76);\n \n-    for (;;) {\n+    while (true) {\n         nNonce++;\n \n         // Write the last 4 bytes of the block header (the nonce) to a copy of\n@@ -435,114 +437,115 @@ void static BitcoinMiner(CWallet *pwallet)\n     CReserveKey reservekey(pwallet);\n     unsigned int nExtraNonce = 0;\n \n-    try { while (true) {\n-        if (Params().MiningRequiresPeers()) {\n-            // Busy-wait for the network to come online so we don't waste time mining\n-            // on an obsolete chain. In regtest mode we expect to fly solo.\n-            while (vNodes.empty())\n-                MilliSleep(1000);\n-        }\n-\n-        //\n-        // Create new block\n-        //\n-        unsigned int nTransactionsUpdatedLast = mempool.GetTransactionsUpdated();\n-        CBlockIndex* pindexPrev = chainActive.Tip();\n-\n-        auto_ptr<CBlockTemplate> pblocktemplate(CreateNewBlockWithKey(reservekey));\n-        if (!pblocktemplate.get())\n-            return;\n-        CBlock *pblock = &pblocktemplate->block;\n-        IncrementExtraNonce(pblock, pindexPrev, nExtraNonce);\n-\n-        LogPrintf(\"Running BitcoinMiner with %u transactions in block (%u bytes)\\n\", pblock->vtx.size(),\n-               ::GetSerializeSize(*pblock, SER_NETWORK, PROTOCOL_VERSION));\n-\n-        //\n-        // Search\n-        //\n-        int64_t nStart = GetTime();\n-        uint256 hashTarget = uint256().SetCompact(pblock->nBits);\n-        uint256 hash;\n-        uint32_t nNonce = 0;\n-        uint32_t nOldNonce = 0;\n-        while (true)\n-        {\n-            bool fFound = ScanHash(pblock, nNonce, &hash);\n-            uint32_t nHashesDone = nNonce - nOldNonce;\n-            nOldNonce = nNonce;\n+    try {\n+        while (true) {\n+            if (Params().MiningRequiresPeers()) {\n+                // Busy-wait for the network to come online so we don't waste time mining\n+                // on an obsolete chain. In regtest mode we expect to fly solo.\n+                while (vNodes.empty())\n+                    MilliSleep(1000);\n+            }\n \n-            // Check if something found\n-            if (fFound)\n-            {\n-                if (hash <= hashTarget)\n+            //\n+            // Create new block\n+            //\n+            unsigned int nTransactionsUpdatedLast = mempool.GetTransactionsUpdated();\n+            CBlockIndex* pindexPrev = chainActive.Tip();\n+\n+            auto_ptr<CBlockTemplate> pblocktemplate(CreateNewBlockWithKey(reservekey));\n+            if (!pblocktemplate.get())\n+                return;\n+            CBlock *pblock = &pblocktemplate->block;\n+            IncrementExtraNonce(pblock, pindexPrev, nExtraNonce);\n+\n+            LogPrintf(\"Running BitcoinMiner with %u transactions in block (%u bytes)\\n\", pblock->vtx.size(),\n+                ::GetSerializeSize(*pblock, SER_NETWORK, PROTOCOL_VERSION));\n+\n+            //\n+            // Search\n+            //\n+            int64_t nStart = GetTime();\n+            uint256 hashTarget = uint256().SetCompact(pblock->nBits);\n+            uint256 hash;\n+            uint32_t nNonce = 0;\n+            uint32_t nOldNonce = 0;\n+            while (true) {\n+                bool fFound = ScanHash(pblock, nNonce, &hash);\n+                uint32_t nHashesDone = nNonce - nOldNonce;\n+                nOldNonce = nNonce;\n+\n+                // Check if something found\n+                if (fFound)\n                 {\n-                    // Found a solution\n-                    pblock->nNonce = nNonce;\n-                    assert(hash == pblock->GetHash());\n+                    if (hash <= hashTarget)\n+                    {\n+                        // Found a solution\n+                        pblock->nNonce = nNonce;\n+                        assert(hash == pblock->GetHash());\n \n-                    SetThreadPriority(THREAD_PRIORITY_NORMAL);\n-                    CheckWork(pblock, *pwallet, reservekey);\n-                    SetThreadPriority(THREAD_PRIORITY_LOWEST);\n+                        SetThreadPriority(THREAD_PRIORITY_NORMAL);\n+                        CheckWork(pblock, *pwallet, reservekey);\n+                        SetThreadPriority(THREAD_PRIORITY_LOWEST);\n \n-                    // In regression test mode, stop mining after a block is found.\n-                    if (Params().MineBlocksOnDemand())\n-                        throw boost::thread_interrupted();\n+                        // In regression test mode, stop mining after a block is found.\n+                        if (Params().MineBlocksOnDemand())\n+                            throw boost::thread_interrupted();\n \n-                    break;\n+                        break;\n+                    }\n                 }\n-            }\n \n-            // Meter hashes/sec\n-            static int64_t nHashCounter;\n-            if (nHPSTimerStart == 0)\n-            {\n-                nHPSTimerStart = GetTimeMillis();\n-                nHashCounter = 0;\n-            }\n-            else\n-                nHashCounter += nHashesDone;\n-            if (GetTimeMillis() - nHPSTimerStart > 4000)\n-            {\n-                static CCriticalSection cs;\n+                // Meter hashes/sec\n+                static int64_t nHashCounter;\n+                if (nHPSTimerStart == 0)\n                 {\n-                    LOCK(cs);\n-                    if (GetTimeMillis() - nHPSTimerStart > 4000)\n+                    nHPSTimerStart = GetTimeMillis();\n+                    nHashCounter = 0;\n+                }\n+                else\n+                    nHashCounter += nHashesDone;\n+                if (GetTimeMillis() - nHPSTimerStart > 4000)\n+                {\n+                    static CCriticalSection cs;\n                     {\n-                        dHashesPerSec = 1000.0 * nHashCounter / (GetTimeMillis() - nHPSTimerStart);\n-                        nHPSTimerStart = GetTimeMillis();\n-                        nHashCounter = 0;\n-                        static int64_t nLogTime;\n-                        if (GetTime() - nLogTime > 30 * 60)\n+                        LOCK(cs);\n+                        if (GetTimeMillis() - nHPSTimerStart > 4000)\n                         {\n-                            nLogTime = GetTime();\n-                            LogPrintf(\"hashmeter %6.0f khash/s\\n\", dHashesPerSec/1000.0);\n+                            dHashesPerSec = 1000.0 * nHashCounter / (GetTimeMillis() - nHPSTimerStart);\n+                            nHPSTimerStart = GetTimeMillis();\n+                            nHashCounter = 0;\n+                            static int64_t nLogTime;\n+                            if (GetTime() - nLogTime > 30 * 60)\n+                            {\n+                                nLogTime = GetTime();\n+                                LogPrintf(\"hashmeter %6.0f khash/s\\n\", dHashesPerSec/1000.0);\n+                            }\n                         }\n                     }\n                 }\n-            }\n \n-            // Check for stop or if block needs to be rebuilt\n-            boost::this_thread::interruption_point();\n-            // Regtest mode doesn't require peers\n-            if (vNodes.empty() && Params().MiningRequiresPeers())\n-                break;\n-            if (nNonce >= 0xffff0000)\n-                break;\n-            if (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && GetTime() - nStart > 60)\n-                break;\n-            if (pindexPrev != chainActive.Tip())\n-                break;\n-\n-            // Update nTime every few seconds\n-            UpdateTime(*pblock, pindexPrev);\n-            if (Params().AllowMinDifficultyBlocks())\n-            {\n-                // Changing pblock->nTime can change work required on testnet:\n-                hashTarget.SetCompact(pblock->nBits);\n+                // Check for stop or if block needs to be rebuilt\n+                boost::this_thread::interruption_point();\n+                // Regtest mode doesn't require peers\n+                if (vNodes.empty() && Params().MiningRequiresPeers())\n+                    break;\n+                if (nNonce >= 0xffff0000)\n+                    break;\n+                if (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && GetTime() - nStart > 60)\n+                    break;\n+                if (pindexPrev != chainActive.Tip())\n+                    break;\n+\n+                // Update nTime every few seconds\n+                UpdateTime(*pblock, pindexPrev);\n+                if (Params().AllowMinDifficultyBlocks())\n+                {\n+                    // Changing pblock->nTime can change work required on testnet:\n+                    hashTarget.SetCompact(pblock->nBits);\n+                }\n             }\n         }\n-    } }\n+    }\n     catch (boost::thread_interrupted)\n     {\n         LogPrintf(\"BitcoinMiner terminated\\n\");\n@@ -577,4 +580,4 @@ void GenerateBitcoins(bool fGenerate, CWallet* pwallet, int nThreads)\n         minerThreads->create_thread(boost::bind(&BitcoinMiner, pwallet));\n }\n \n-#endif\n+#endif // ENABLE_WALLET"
      }
    ]
  }
]