[
  {
    "sha": "dd869c60ca069fa3eea3dd1aab977b8a10e05f2f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkZDg2OWM2MGNhMDY5ZmEzZWVhM2RkMWFhYjk3N2I4YTEwZTA1ZjJm",
    "commit": {
      "author": {
        "name": "Gregory Maxwell",
        "email": "greg@xiph.org",
        "date": "2017-06-11T23:39:04Z"
      },
      "committer": {
        "name": "Gregory Maxwell",
        "email": "greg@xiph.org",
        "date": "2017-06-12T22:44:55Z"
      },
      "message": "Add an explanation of quickly hashing onto a non-power of two range.\n\nIn Olaoluwa Osuntokun's recent protocol proposal they were using a\n mod in an inner loop.  I wanted to suggest a normative protocol\n change to use the trick we use here, but to find an explanation\n of it I had to dig up the PR on github.  After I posted about it\n several other developers commented that it was very interesting\n and they were unaware of it.\n\nI think ideally the code should be self documenting and help\n educate other contributors about non-obvious techniques that\n we use.  So I've written a description of the technique with\n citations for future reference.",
      "tree": {
        "sha": "1c87af2fb7b99a1a0177d2fdbd583ebed5c0a257",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1c87af2fb7b99a1a0177d2fdbd583ebed5c0a257"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dd869c60ca069fa3eea3dd1aab977b8a10e05f2f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dd869c60ca069fa3eea3dd1aab977b8a10e05f2f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dd869c60ca069fa3eea3dd1aab977b8a10e05f2f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dd869c60ca069fa3eea3dd1aab977b8a10e05f2f/comments",
    "author": {
      "login": "gmaxwell",
      "id": 858454,
      "node_id": "MDQ6VXNlcjg1ODQ1NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gmaxwell",
      "html_url": "https://github.com/gmaxwell",
      "followers_url": "https://api.github.com/users/gmaxwell/followers",
      "following_url": "https://api.github.com/users/gmaxwell/following{/other_user}",
      "gists_url": "https://api.github.com/users/gmaxwell/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
      "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
      "repos_url": "https://api.github.com/users/gmaxwell/repos",
      "events_url": "https://api.github.com/users/gmaxwell/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gmaxwell",
      "id": 858454,
      "node_id": "MDQ6VXNlcjg1ODQ1NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gmaxwell",
      "html_url": "https://github.com/gmaxwell",
      "followers_url": "https://api.github.com/users/gmaxwell/followers",
      "following_url": "https://api.github.com/users/gmaxwell/following{/other_user}",
      "gists_url": "https://api.github.com/users/gmaxwell/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
      "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
      "repos_url": "https://api.github.com/users/gmaxwell/repos",
      "events_url": "https://api.github.com/users/gmaxwell/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2c2d98806253db8c83055800a6bb14814a2f12b1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2c2d98806253db8c83055800a6bb14814a2f12b1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2c2d98806253db8c83055800a6bb14814a2f12b1"
      }
    ],
    "stats": {
      "total": 31,
      "additions": 31,
      "deletions": 0
    },
    "files": [
      {
        "sha": "692eb583382aa43b46c95b9749ac6857d327c10b",
        "filename": "src/cuckoocache.h",
        "status": "modified",
        "additions": 31,
        "deletions": 0,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd869c60ca069fa3eea3dd1aab977b8a10e05f2f/src/cuckoocache.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd869c60ca069fa3eea3dd1aab977b8a10e05f2f/src/cuckoocache.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/cuckoocache.h?ref=dd869c60ca069fa3eea3dd1aab977b8a10e05f2f",
        "patch": "@@ -206,6 +206,37 @@ class cache\n     /** compute_hashes is convenience for not having to write out this\n      * expression everywhere we use the hash values of an Element.\n      *\n+     * We need to map the 32-bit input hash onto a hash bucket in a range [0, size) in a\n+     *  manner which preserves as much of the hash's uniformity as possible.  Ideally\n+     *  this would be done by bitmasking but the size is usually not a power of two.\n+     *\n+     * The naive approach would be to use a mod -- which isn't perfectly uniform but so\n+     *  long as the hash is much larger than size it is not that bad.  Unfortunately,\n+     *  mod/division is fairly slow on ordinary microprocessors (e.g. 90-ish cycles on\n+     *  haswell, ARM doesn't even have an instruction for it.); when the divisor is a\n+     *  constant the compiler will do clever tricks to turn it into a multiply+add+shift,\n+     *  but size is a run-time value so the compiler can't do that here.\n+     *\n+     * One option would be to implement the same trick the compiler uses and compute the\n+     *  constants for exact division based on the size, as described in \"{N}-bit Unsigned\n+     *  Division via {N}-bit Multiply-Add\" by Arch D. Robison in 2005. But that code is\n+     *  somewhat complicated and the result is still slower than other options:\n+     *\n+     * Instead we treat the 32-bit random number as a Q32 fixed-point number in the range\n+     *  [0,1) and simply multiply it by the size.  Then we just shift the result down by\n+     *  32-bits to get our bucket number.  The results has non-uniformity the same as a\n+     *  mod, but it is much faster to compute. More about this technique can be found at\n+     *  http://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/\n+     *\n+     * The resulting non-uniformity is also more equally distributed which would be\n+     *  advantageous for something like linear probing, though it shouldn't matter\n+     *  one way or the other for a cuckoo table.\n+     *\n+     * The primary disadvantage of this approach is increased intermediate precision is\n+     *  required but for a 32-bit random number we only need the high 32 bits of a\n+     *  32*32->64 multiply, which means the operation is reasonably fast even on a\n+     *  typical 32-bit processor.\n+     *\n      * @param e the element whose hashes will be returned\n      * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n      */"
      }
    ]
  }
]