[
  {
    "sha": "dcc8332543f8fb6d1bb47cb270fcbb6a814a7d6e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkY2M4MzMyNTQzZjhmYjZkMWJiNDdjYjI3MGZjYmI2YTgxNGE3ZDZl",
    "commit": {
      "author": {
        "name": "Andrew Toth",
        "email": "andrewstoth@gmail.com",
        "date": "2020-03-27T15:00:10Z"
      },
      "committer": {
        "name": "Andrew Toth",
        "email": "andrewstoth@gmail.com",
        "date": "2020-03-27T15:00:10Z"
      },
      "message": "Add generateblock rpc",
      "tree": {
        "sha": "ee8fdeb4cb550416b1141d6a590ce53e83ca4696",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ee8fdeb4cb550416b1141d6a590ce53e83ca4696"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dcc8332543f8fb6d1bb47cb270fcbb6a814a7d6e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dcc8332543f8fb6d1bb47cb270fcbb6a814a7d6e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dcc8332543f8fb6d1bb47cb270fcbb6a814a7d6e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dcc8332543f8fb6d1bb47cb270fcbb6a814a7d6e/comments",
    "author": {
      "login": "andrewtoth",
      "id": 237213,
      "node_id": "MDQ6VXNlcjIzNzIxMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/andrewtoth",
      "html_url": "https://github.com/andrewtoth",
      "followers_url": "https://api.github.com/users/andrewtoth/followers",
      "following_url": "https://api.github.com/users/andrewtoth/following{/other_user}",
      "gists_url": "https://api.github.com/users/andrewtoth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/andrewtoth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
      "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
      "repos_url": "https://api.github.com/users/andrewtoth/repos",
      "events_url": "https://api.github.com/users/andrewtoth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "andrewtoth",
      "id": 237213,
      "node_id": "MDQ6VXNlcjIzNzIxMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/andrewtoth",
      "html_url": "https://github.com/andrewtoth",
      "followers_url": "https://api.github.com/users/andrewtoth/followers",
      "following_url": "https://api.github.com/users/andrewtoth/following{/other_user}",
      "gists_url": "https://api.github.com/users/andrewtoth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/andrewtoth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
      "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
      "repos_url": "https://api.github.com/users/andrewtoth/repos",
      "events_url": "https://api.github.com/users/andrewtoth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e3154aacf444a29f9f5642b6c937e875ab9a2c13",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3154aacf444a29f9f5642b6c937e875ab9a2c13",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e3154aacf444a29f9f5642b6c937e875ab9a2c13"
      }
    ],
    "stats": {
      "total": 228,
      "additions": 197,
      "deletions": 31
    },
    "files": [
      {
        "sha": "5ab23c7f4fcd5985ae2ee51d431eca65507f0b86",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dcc8332543f8fb6d1bb47cb270fcbb6a814a7d6e/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dcc8332543f8fb6d1bb47cb270fcbb6a814a7d6e/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=dcc8332543f8fb6d1bb47cb270fcbb6a814a7d6e",
        "patch": "@@ -39,6 +39,17 @@ int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParam\n     return nNewTime - nOldTime;\n }\n \n+void RegenerateCommitments(CBlock& block)\n+{\n+    CMutableTransaction tx{*block.vtx.at(0)};\n+    tx.vout.erase(tx.vout.begin() + GetWitnessCommitmentIndex(block));\n+    block.vtx.at(0) = MakeTransactionRef(tx);\n+\n+    GenerateCoinbaseCommitment(block, WITH_LOCK(cs_main, return LookupBlockIndex(block.hashPrevBlock)), Params().GetConsensus());\n+\n+    block.hashMerkleRoot = BlockMerkleRoot(block);\n+}\n+\n BlockAssembler::Options::Options() {\n     blockMinFeeRate = CFeeRate(DEFAULT_BLOCK_MIN_TX_FEE);\n     nBlockMaxWeight = DEFAULT_BLOCK_MAX_WEIGHT;"
      },
      {
        "sha": "b9ffb34a2df8002f1f7a1d10137877e38f34e835",
        "filename": "src/miner.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dcc8332543f8fb6d1bb47cb270fcbb6a814a7d6e/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dcc8332543f8fb6d1bb47cb270fcbb6a814a7d6e/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=dcc8332543f8fb6d1bb47cb270fcbb6a814a7d6e",
        "patch": "@@ -203,4 +203,7 @@ class BlockAssembler\n void IncrementExtraNonce(CBlock* pblock, const CBlockIndex* pindexPrev, unsigned int& nExtraNonce);\n int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev);\n \n+/** Update an old GenerateCoinbaseCommitment from CreateNewBlock after the block txs have changed */\n+void RegenerateCommitments(CBlock& block);\n+\n #endif // BITCOIN_MINER_H"
      },
      {
        "sha": "64c74011996d0e345e644348da9612db3b746a36",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dcc8332543f8fb6d1bb47cb270fcbb6a814a7d6e/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dcc8332543f8fb6d1bb47cb270fcbb6a814a7d6e/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=dcc8332543f8fb6d1bb47cb270fcbb6a814a7d6e",
        "patch": "@@ -33,6 +33,7 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"generatetoaddress\", 2, \"maxtries\" },\n     { \"generatetodescriptor\", 0, \"num_blocks\" },\n     { \"generatetodescriptor\", 2, \"maxtries\" },\n+    { \"generateblock\", 1, \"transactions\" },\n     { \"getnetworkhashps\", 0, \"nblocks\" },\n     { \"getnetworkhashps\", 1, \"height\" },\n     { \"sendtoaddress\", 1, \"amount\" },"
      },
      {
        "sha": "c27e720816fec5cf288a94448374eac84de7dd26",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 182,
        "deletions": 31,
        "changes": 213,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dcc8332543f8fb6d1bb47cb270fcbb6a814a7d6e/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dcc8332543f8fb6d1bb47cb270fcbb6a814a7d6e/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=dcc8332543f8fb6d1bb47cb270fcbb6a814a7d6e",
        "patch": "@@ -100,6 +100,36 @@ static UniValue getnetworkhashps(const JSONRPCRequest& request)\n     return GetNetworkHashPS(!request.params[0].isNull() ? request.params[0].get_int() : 120, !request.params[1].isNull() ? request.params[1].get_int() : -1);\n }\n \n+static bool GenerateBlock(CBlock& block, uint64_t& max_tries, unsigned int& extra_nonce, uint256& block_hash)\n+{\n+    block_hash.SetNull();\n+\n+    {\n+        LOCK(cs_main);\n+        IncrementExtraNonce(&block, ::ChainActive().Tip(), extra_nonce);\n+    }\n+\n+    CChainParams chainparams(Params());\n+\n+    while (max_tries > 0 && block.nNonce < std::numeric_limits<uint32_t>::max() && !CheckProofOfWork(block.GetHash(), block.nBits, chainparams.GetConsensus()) && !ShutdownRequested()) {\n+        ++block.nNonce;\n+        --max_tries;\n+    }\n+    if (max_tries == 0 || ShutdownRequested()) {\n+        return false;\n+    }\n+    if (block.nNonce == std::numeric_limits<uint32_t>::max()) {\n+        return true;\n+    }\n+\n+    std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(block);\n+    if (!ProcessNewBlock(chainparams, shared_pblock, true, nullptr))\n+        throw JSONRPCError(RPC_INTERNAL_ERROR, \"ProcessNewBlock, block not accepted\");\n+\n+    block_hash = block.GetHash();\n+    return true;\n+}\n+\n static UniValue generateBlocks(const CTxMemPool& mempool, const CScript& coinbase_script, int nGenerate, uint64_t nMaxTries)\n {\n     int nHeightEnd = 0;\n@@ -118,29 +148,54 @@ static UniValue generateBlocks(const CTxMemPool& mempool, const CScript& coinbas\n         if (!pblocktemplate.get())\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"Couldn't create new block\");\n         CBlock *pblock = &pblocktemplate->block;\n-        {\n-            LOCK(cs_main);\n-            IncrementExtraNonce(pblock, ::ChainActive().Tip(), nExtraNonce);\n-        }\n-        while (nMaxTries > 0 && pblock->nNonce < std::numeric_limits<uint32_t>::max() && !CheckProofOfWork(pblock->GetHash(), pblock->nBits, Params().GetConsensus()) && !ShutdownRequested()) {\n-            ++pblock->nNonce;\n-            --nMaxTries;\n-        }\n-        if (nMaxTries == 0 || ShutdownRequested()) {\n+\n+        uint256 block_hash;\n+        if (!GenerateBlock(*pblock, nMaxTries, nExtraNonce, block_hash)) {\n             break;\n         }\n-        if (pblock->nNonce == std::numeric_limits<uint32_t>::max()) {\n-            continue;\n+\n+        if (!block_hash.IsNull()) {\n+            ++nHeight;\n+            blockHashes.push_back(block_hash.GetHex());\n         }\n-        std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(*pblock);\n-        if (!ProcessNewBlock(Params(), shared_pblock, true, nullptr))\n-            throw JSONRPCError(RPC_INTERNAL_ERROR, \"ProcessNewBlock, block not accepted\");\n-        ++nHeight;\n-        blockHashes.push_back(pblock->GetHash().GetHex());\n     }\n     return blockHashes;\n }\n \n+static bool getScriptFromDescriptor(const std::string& descriptor, CScript& script, std::string& error)\n+{\n+    FlatSigningProvider key_provider;\n+    const auto desc = Parse(descriptor, key_provider, error, /* require_checksum = */ false);\n+    if (desc) {\n+        if (desc->IsRange()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Ranged descriptor not accepted. Maybe pass through deriveaddresses first?\");\n+        }\n+\n+        FlatSigningProvider provider;\n+        std::vector<CScript> scripts;\n+        if (!desc->Expand(0, key_provider, scripts, provider)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Cannot derive script without private keys\"));\n+        }\n+\n+        // Combo desriptors can have 2 or 4 scripts, so we can't just check scripts.size() == 1\n+        CHECK_NONFATAL(scripts.size() > 0 && scripts.size() <= 4);\n+\n+        if (scripts.size() == 1) {\n+            script = scripts.at(0);\n+        } else if (scripts.size() == 4) {\n+            // For uncompressed keys, take the 3rd script, since it is p2wpkh\n+            script = scripts.at(2);\n+        } else {\n+            // Else take the 2nd script, since it is p2pkh\n+            script = scripts.at(1);\n+        }\n+\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n static UniValue generatetodescriptor(const JSONRPCRequest& request)\n {\n     RPCHelpMan{\n@@ -165,27 +220,15 @@ static UniValue generatetodescriptor(const JSONRPCRequest& request)\n     const int num_blocks{request.params[0].get_int()};\n     const int64_t max_tries{request.params[2].isNull() ? 1000000 : request.params[2].get_int()};\n \n-    FlatSigningProvider key_provider;\n+    CScript coinbase_script;\n     std::string error;\n-    const auto desc = Parse(request.params[1].get_str(), key_provider, error, /* require_checksum = */ false);\n-    if (!desc) {\n+    if (!getScriptFromDescriptor(request.params[1].get_str(), coinbase_script, error)) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, error);\n     }\n-    if (desc->IsRange()) {\n-        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Ranged descriptor not accepted. Maybe pass through deriveaddresses first?\");\n-    }\n-\n-    FlatSigningProvider provider;\n-    std::vector<CScript> coinbase_script;\n-    if (!desc->Expand(0, key_provider, coinbase_script, provider)) {\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Cannot derive script without private keys\"));\n-    }\n \n     const CTxMemPool& mempool = EnsureMemPool();\n \n-    CHECK_NONFATAL(coinbase_script.size() == 1);\n-\n-    return generateBlocks(mempool, coinbase_script.at(0), num_blocks, max_tries);\n+    return generateBlocks(mempool, coinbase_script, num_blocks, max_tries);\n }\n \n static UniValue generatetoaddress(const JSONRPCRequest& request)\n@@ -228,6 +271,113 @@ static UniValue generatetoaddress(const JSONRPCRequest& request)\n     return generateBlocks(mempool, coinbase_script, nGenerate, nMaxTries);\n }\n \n+static UniValue generateblock(const JSONRPCRequest& request)\n+{\n+    RPCHelpMan{\"generateblock\",\n+        \"\\nMine a block with a set of ordered transactions immediately to a specified address or descriptor (before the RPC call returns)\\n\",\n+        {\n+            {\"address/descriptor\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The address or descriptor to send the newly generated bitcoin to.\"},\n+            {\"transactions\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"An array of hex strings which are either txids or raw transactions.\\n\"\n+                \"Txids must reference transactions currently in the mempool.\\n\"\n+                \"All transactions must be valid and in valid order, otherwise the block will be rejected.\",\n+                {\n+                    {\"rawtx/txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::OMITTED, \"\"},\n+                },\n+            }\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+            {\n+                {RPCResult::Type::STR_HEX, \"hash\", \"hash of generated block\"}\n+            }\n+        },\n+        RPCExamples{\n+            \"\\nGenerate a block to myaddress, with txs rawtx and mempool_txid\\n\"\n+            + HelpExampleCli(\"generateblock\", R\"(\"myaddress\" '[\"rawtx\", \"mempool_txid\"]')\")\n+        },\n+    }.Check(request);\n+\n+    const auto address_or_descriptor = request.params[0].get_str();\n+    CScript coinbase_script;\n+    std::string error;\n+\n+    if (!getScriptFromDescriptor(address_or_descriptor, coinbase_script, error)) {\n+        const auto destination = DecodeDestination(address_or_descriptor);\n+        if (!IsValidDestination(destination)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Error: Invalid address or descriptor\");\n+        }\n+\n+        coinbase_script = GetScriptForDestination(destination);\n+    }\n+\n+    const CTxMemPool& mempool = EnsureMemPool();\n+\n+    std::vector<CTransactionRef> txs;\n+    const auto raw_txs_or_txids = request.params[1].get_array();\n+    for (size_t i = 0; i < raw_txs_or_txids.size(); i++) {\n+        const auto str(raw_txs_or_txids[i].get_str());\n+\n+        uint256 hash;\n+        CMutableTransaction mtx;\n+        if (ParseHashStr(str, hash)) {\n+\n+            const auto tx = mempool.get(hash);\n+            if (!tx) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Transaction %s not in mempool.\", str));\n+            }\n+\n+            txs.emplace_back(tx);\n+\n+        } else if (DecodeHexTx(mtx, str)) {\n+            txs.push_back(MakeTransactionRef(std::move(mtx)));\n+\n+        } else {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"Transaction decode failed for %s\", str));\n+        }\n+    }\n+\n+    CChainParams chainparams(Params());\n+    CBlock block;\n+\n+    {\n+        LOCK(cs_main);\n+\n+        CTxMemPool empty_mempool;\n+        std::unique_ptr<CBlockTemplate> blocktemplate(BlockAssembler(empty_mempool, chainparams).CreateNewBlock(coinbase_script));\n+        if (!blocktemplate) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Couldn't create new block\");\n+        }\n+        block = blocktemplate->block;\n+    }\n+\n+    CHECK_NONFATAL(block.vtx.size() == 1);\n+\n+    // Add transactions\n+    block.vtx.insert(block.vtx.end(), txs.begin(), txs.end());\n+    RegenerateCommitments(block);\n+\n+    {\n+        LOCK(cs_main);\n+\n+        BlockValidationState state;\n+        if (!TestBlockValidity(state, chainparams, block, LookupBlockIndex(block.hashPrevBlock), false, false)) {\n+            throw JSONRPCError(RPC_VERIFY_ERROR, strprintf(\"TestBlockValidity failed: %s\", state.ToString()));\n+        }\n+    }\n+\n+    uint256 block_hash;\n+    uint64_t max_tries{1000000};\n+    unsigned int extra_nonce{0};\n+\n+    if (!GenerateBlock(block, max_tries, extra_nonce, block_hash) || block_hash.IsNull()) {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Failed to make block.\");\n+    }\n+\n+    UniValue obj(UniValue::VOBJ);\n+    obj.pushKV(\"hash\", block_hash.GetHex());\n+    return obj;\n+}\n+\n static UniValue getmininginfo(const JSONRPCRequest& request)\n {\n             RPCHelpMan{\"getmininginfo\",\n@@ -1035,6 +1185,7 @@ static const CRPCCommand commands[] =\n \n     { \"generating\",         \"generatetoaddress\",      &generatetoaddress,      {\"nblocks\",\"address\",\"maxtries\"} },\n     { \"generating\",         \"generatetodescriptor\",   &generatetodescriptor,   {\"num_blocks\",\"descriptor\",\"maxtries\"} },\n+    { \"generating\",         \"generateblock\",          &generateblock,    {\"address\",\"transactions\"} },\n \n     { \"util\",               \"estimatesmartfee\",       &estimatesmartfee,       {\"conf_target\", \"estimate_mode\"} },\n "
      }
    ]
  },
  {
    "sha": "7524b6479cb20471d827aec5500925c86c62ce1c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3NTI0YjY0NzljYjIwNDcxZDgyN2FlYzU1MDA5MjVjODZjNjJjZTFj",
    "commit": {
      "author": {
        "name": "Andrew Toth",
        "email": "andrewstoth@gmail.com",
        "date": "2020-03-27T16:09:31Z"
      },
      "committer": {
        "name": "Andrew Toth",
        "email": "andrewstoth@gmail.com",
        "date": "2020-03-27T16:09:31Z"
      },
      "message": "Add tests for generateblock",
      "tree": {
        "sha": "6c316fe908df11e7cd298dddc6fbd60e175ff4c3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6c316fe908df11e7cd298dddc6fbd60e175ff4c3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7524b6479cb20471d827aec5500925c86c62ce1c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7524b6479cb20471d827aec5500925c86c62ce1c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7524b6479cb20471d827aec5500925c86c62ce1c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7524b6479cb20471d827aec5500925c86c62ce1c/comments",
    "author": {
      "login": "andrewtoth",
      "id": 237213,
      "node_id": "MDQ6VXNlcjIzNzIxMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/andrewtoth",
      "html_url": "https://github.com/andrewtoth",
      "followers_url": "https://api.github.com/users/andrewtoth/followers",
      "following_url": "https://api.github.com/users/andrewtoth/following{/other_user}",
      "gists_url": "https://api.github.com/users/andrewtoth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/andrewtoth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
      "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
      "repos_url": "https://api.github.com/users/andrewtoth/repos",
      "events_url": "https://api.github.com/users/andrewtoth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "andrewtoth",
      "id": 237213,
      "node_id": "MDQ6VXNlcjIzNzIxMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/andrewtoth",
      "html_url": "https://github.com/andrewtoth",
      "followers_url": "https://api.github.com/users/andrewtoth/followers",
      "following_url": "https://api.github.com/users/andrewtoth/following{/other_user}",
      "gists_url": "https://api.github.com/users/andrewtoth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/andrewtoth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
      "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
      "repos_url": "https://api.github.com/users/andrewtoth/repos",
      "events_url": "https://api.github.com/users/andrewtoth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "dcc8332543f8fb6d1bb47cb270fcbb6a814a7d6e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dcc8332543f8fb6d1bb47cb270fcbb6a814a7d6e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dcc8332543f8fb6d1bb47cb270fcbb6a814a7d6e"
      }
    ],
    "stats": {
      "total": 106,
      "additions": 106,
      "deletions": 0
    },
    "files": [
      {
        "sha": "f23d9ec5569e54a3bc84e4081741f9b95c3c20a5",
        "filename": "test/functional/rpc_generateblock.py",
        "status": "added",
        "additions": 105,
        "deletions": 0,
        "changes": 105,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7524b6479cb20471d827aec5500925c86c62ce1c/test/functional/rpc_generateblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7524b6479cb20471d827aec5500925c86c62ce1c/test/functional/rpc_generateblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_generateblock.py?ref=7524b6479cb20471d827aec5500925c86c62ce1c",
        "patch": "@@ -0,0 +1,105 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+'''Test generateblock rpc.\n+'''\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+class GenerateBlockTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        node = self.nodes[0]\n+\n+        self.log.info('Generate an empty block to address')\n+        address = node.getnewaddress()\n+        hash = node.generateblock(address, [])['hash']\n+        block = node.getblock(hash, 2)\n+        assert_equal(len(block['tx']), 1)\n+        assert_equal(block['tx'][0]['vout'][0]['scriptPubKey']['addresses'][0], address)\n+\n+        self.log.info('Generate an empty block to a descriptor')\n+        hash = node.generateblock('addr(' + address + ')', [])['hash']\n+        block = node.getblock(hash, 2)\n+        assert_equal(len(block['tx']), 1)\n+        assert_equal(block['tx'][0]['vout'][0]['scriptPubKey']['addresses'][0], address)\n+\n+        self.log.info('Generate an empty block to a combo descriptor with compressed pubkey')\n+        combo_key = '0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'\n+        combo_address = 'bcrt1qw508d6qejxtdg4y5r3zarvary0c5xw7kygt080'\n+        hash = node.generateblock('combo(' + combo_key + ')', [])['hash']\n+        block = node.getblock(hash, 2)\n+        assert_equal(len(block['tx']), 1)\n+        assert_equal(block['tx'][0]['vout'][0]['scriptPubKey']['addresses'][0], combo_address)\n+\n+        self.log.info('Generate an empty block to a combo descriptor with uncompressed pubkey')\n+        combo_key = '0408ef68c46d20596cc3f6ddf7c8794f71913add807f1dc55949fa805d764d191c0b7ce6894c126fce0babc6663042f3dde9b0cf76467ea315514e5a6731149c67'\n+        combo_address = 'mkc9STceoCcjoXEXe6cm66iJbmjM6zR9B2'\n+        hash = node.generateblock('combo(' + combo_key + ')', [])['hash']\n+        block = node.getblock(hash, 2)\n+        assert_equal(len(block['tx']), 1)\n+        assert_equal(block['tx'][0]['vout'][0]['scriptPubKey']['addresses'][0], combo_address)\n+\n+        # Generate 110 blocks to spend\n+        node.generatetoaddress(110, address)\n+\n+        # Generate some extra mempool transactions to verify they don't get mined\n+        for i in range(10):\n+            node.sendtoaddress(address, 0.001)\n+\n+        self.log.info('Generate block with txid')\n+        txid = node.sendtoaddress(address, 1)\n+        hash = node.generateblock(address, [txid])['hash']\n+        block = node.getblock(hash, 1)\n+        assert_equal(len(block['tx']), 2)\n+        assert_equal(block['tx'][1], txid)\n+\n+        self.log.info('Generate block with raw tx')\n+        utxos = node.listunspent(addresses=[address])\n+        raw = node.createrawtransaction([{'txid':utxos[0]['txid'], 'vout':utxos[0]['vout']}],[{address:1}])\n+        signed_raw = node.signrawtransactionwithwallet(raw)['hex']\n+        hash = node.generateblock(address, [signed_raw])['hash']\n+        block = node.getblock(hash, 1)\n+        assert_equal(len(block['tx']), 2)\n+        txid = block['tx'][1]\n+        assert_equal(node.gettransaction(txid)['hex'], signed_raw)\n+\n+        self.log.info('Fail to generate block with out of order txs')\n+        raw1 = node.createrawtransaction([{'txid':txid, 'vout':0}],[{address:0.9999}])\n+        signed_raw1 = node.signrawtransactionwithwallet(raw1)['hex']\n+        txid1 = node.sendrawtransaction(signed_raw1)\n+        raw2 = node.createrawtransaction([{'txid':txid1, 'vout':0}],[{address:0.999}])\n+        signed_raw2 = node.signrawtransactionwithwallet(raw2)['hex']\n+        assert_raises_rpc_error(-25, 'TestBlockValidity failed: bad-txns-inputs-missingorspent', node.generateblock, address, [signed_raw2, txid1])\n+\n+        self.log.info('Fail to generate block with txid not in mempool')\n+        missing_txid = '0000000000000000000000000000000000000000000000000000000000000000'\n+        assert_raises_rpc_error(-5, 'Transaction ' + missing_txid + ' not in mempool.', node.generateblock, address, [missing_txid])\n+\n+        self.log.info('Fail to generate block with invalid raw tx')\n+        invalid_raw_tx = '0000'\n+        assert_raises_rpc_error(-22, 'Transaction decode failed for ' + invalid_raw_tx, node.generateblock, address, [invalid_raw_tx])\n+\n+        self.log.info('Fail to generate block with invalid address/descriptor')\n+        assert_raises_rpc_error(-5, 'Invalid address or descriptor', node.generateblock, '1234', [])\n+\n+        self.log.info('Fail to generate block with a ranged descriptor')\n+        ranged_descriptor = 'pkh(tpubD6NzVbkrYhZ4XgiXtGrdW5XDAPFCL9h7we1vwNCpn8tGbBcgfVYjXyhWo4E1xkh56hjod1RhGjxbaTLV3X4FyWuejifB9jusQ46QzG87VKp/0/*)'\n+        assert_raises_rpc_error(-8, 'Ranged descriptor not accepted. Maybe pass through deriveaddresses first?', node.generateblock, ranged_descriptor, [])\n+\n+        self.log.info('Fail to generate block with a descriptor missing a private key')\n+        child_descriptor = 'pkh(tpubD6NzVbkrYhZ4XgiXtGrdW5XDAPFCL9h7we1vwNCpn8tGbBcgfVYjXyhWo4E1xkh56hjod1RhGjxbaTLV3X4FyWuejifB9jusQ46QzG87VKp/0\\'/0)'\n+        assert_raises_rpc_error(-5, 'Cannot derive script without private keys', node.generateblock, child_descriptor, [])\n+\n+if __name__ == '__main__':\n+    GenerateBlockTest().main()"
      },
      {
        "sha": "e59b357d0beda9596929ff3718e4cd506d897ce4",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7524b6479cb20471d827aec5500925c86c62ce1c/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7524b6479cb20471d827aec5500925c86c62ce1c/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=7524b6479cb20471d827aec5500925c86c62ce1c",
        "patch": "@@ -171,6 +171,7 @@\n     'wallet_importprunedfunds.py',\n     'p2p_leak_tx.py',\n     'rpc_signmessage.py',\n+    'rpc_generateblock.py',\n     'wallet_balance.py',\n     'feature_nulldummy.py',\n     'mempool_accept.py',"
      }
    ]
  }
]