[
  {
    "sha": "fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTg3ZGEyZjE3MmFlMmU2ZGMxNWU5ZWQxNTZhMzU2NGE4ZWNmYmRk",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-06-18T21:28:37Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-06-25T18:06:41Z"
      },
      "message": "qa: Avoid start/stop of the network thread mid-test",
      "tree": {
        "sha": "2693cae5718e45e84182d85a4d041fc084d6bd8e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2693cae5718e45e84182d85a4d041fc084d6bd8e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGcBAABCgAGBQJbMS8xAAoJEM4rdWl+aaVIEn4MAMFs/Kt9SNocn2hVefqc63hn\nQ7lzUWOFZp16HPsPG7Q4TAQSKEND75FfV7sYJCuS2QNEiceiTOwBTetRshjjGACr\nDiRBlYUmdks3gNqO5OICt/MryHXOpPj2pK4m/h4CO8MnM7sND6tzVlXpPnyONFcv\nnzTIu4hdHD63pYSglZVPft5OTwuw+gpLi4BHZLvpUOmqM26uv21GCxlebeL3Ji6j\nqXzDuTNHq0/E5jiEOWPK0V+JDd8W8t0bUYQw/g8enzT/vvrlHpjHMSkxqdGP7hLD\npHoH0DGWPHb3H7qhxIOxqDYgaY+zM5OA2vkmZDbUbqBpFHBJXHSUqpGwlV4FuRU6\n/H/bs7u9l3PdOVE7BNWkNGCuK5Um5djnXDbecYm5OWAtXP3YXQAeWsPgqcAOaJty\nrhbr8LVEOTdoSUZrxhZeSAclBlSGVRQRxQkIOBsNi8WoagXmEF6J4dXZQWATcVRZ\n40lih67fuhrdGguODzTyorrwW+PiHBsjy4lUjfxXEQ==\n=zoJJ\n-----END PGP SIGNATURE-----",
        "payload": "tree 2693cae5718e45e84182d85a4d041fc084d6bd8e\nparent fa1eac9cdb1a491d5947b6972b87833792a16fe3\nauthor MarcoFalke <falke.marco@gmail.com> 1529357317 -0400\ncommitter MarcoFalke <falke.marco@gmail.com> 1529950001 -0400\n\nqa: Avoid start/stop of the network thread mid-test\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fa1eac9cdb1a491d5947b6972b87833792a16fe3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa1eac9cdb1a491d5947b6972b87833792a16fe3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fa1eac9cdb1a491d5947b6972b87833792a16fe3"
      }
    ],
    "stats": {
      "total": 321,
      "additions": 98,
      "deletions": 223
    },
    "files": [
      {
        "sha": "e6365222ffe6183e598728b07f5444a3dedb236b",
        "filename": "test/functional/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 5,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/README.md?ref=fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
        "patch": "@@ -76,18 +76,14 @@ over the network (`CBlock`, `CTransaction`, etc, along with the network-level\n wrappers for them, `msg_block`, `msg_tx`, etc).\n \n - P2P tests have two threads. One thread handles all network communication\n-with the bitcoind(s) being tested (using python's asyncore package); the other\n+with the bitcoind(s) being tested in a callback-based event loop; the other\n implements the test logic.\n \n - `P2PConnection` is the class used to connect to a bitcoind.  `P2PInterface`\n contains the higher level logic for processing P2P payloads and connecting to\n the Bitcoin Core node application logic. For custom behaviour, subclass the\n P2PInterface object and override the callback methods.\n \n-- Call `network_thread_start()` after all `P2PInterface` objects are created to\n-start the networking thread.  (Continue with the test logic in your existing\n-thread.)\n-\n - Can be used to write tests where specific P2P protocol behavior is tested.\n Examples tests are `p2p_unrequested_blocks.py`, `p2p_compactblocks.py`.\n "
      },
      {
        "sha": "e2f1cc05b3e080989cc698eb6ea7f5579325fee0",
        "filename": "test/functional/example_test.py",
        "status": "modified",
        "additions": 0,
        "deletions": 10,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/example_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/example_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/example_test.py?ref=fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
        "patch": "@@ -21,8 +21,6 @@\n     mininode_lock,\n     msg_block,\n     msg_getdata,\n-    network_thread_join,\n-    network_thread_start,\n )\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n@@ -135,9 +133,6 @@ def run_test(self):\n         # Create P2P connections to two of the nodes\n         self.nodes[0].add_p2p_connection(BaseNode())\n \n-        # Start up network handling in another thread. This needs to be called\n-        # after the P2P connections have been created.\n-        network_thread_start()\n         # wait_for_verack ensures that the P2P connection is fully up.\n         self.nodes[0].p2p.wait_for_verack()\n \n@@ -189,14 +184,9 @@ def run_test(self):\n         connect_nodes(self.nodes[1], 2)\n \n         self.log.info(\"Add P2P connection to node2\")\n-        # We can't add additional P2P connections once the network thread has started. Disconnect the connection\n-        # to node0, wait for the network thread to terminate, then connect to node2. This is specific to\n-        # the current implementation of the network thread and may be improved in future.\n         self.nodes[0].disconnect_p2ps()\n-        network_thread_join()\n \n         self.nodes[2].add_p2p_connection(BaseNode())\n-        network_thread_start()\n         self.nodes[2].p2p.wait_for_verack()\n \n         self.log.info(\"Wait for node2 reach current tip. Test that it has propagated all the blocks to us\")"
      },
      {
        "sha": "933a4740dd9bec23cfb07da9b960817ba6806757",
        "filename": "test/functional/feature_assumevalid.py",
        "status": "modified",
        "additions": 10,
        "deletions": 16,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/feature_assumevalid.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/feature_assumevalid.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_assumevalid.py?ref=fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
        "patch": "@@ -33,16 +33,16 @@\n \n from test_framework.blocktools import (create_block, create_coinbase)\n from test_framework.key import CECKey\n-from test_framework.mininode import (CBlockHeader,\n-                                     COutPoint,\n-                                     CTransaction,\n-                                     CTxIn,\n-                                     CTxOut,\n-                                     network_thread_join,\n-                                     network_thread_start,\n-                                     P2PInterface,\n-                                     msg_block,\n-                                     msg_headers)\n+from test_framework.messages import (\n+    CBlockHeader,\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxOut,\n+    msg_block,\n+    msg_headers\n+)\n+from test_framework.mininode import P2PInterface\n from test_framework.script import (CScript, OP_TRUE)\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal\n@@ -98,8 +98,6 @@ def run_test(self):\n \n         # Connect to node0\n         p2p0 = self.nodes[0].add_p2p_connection(BaseNode())\n-\n-        network_thread_start()\n         self.nodes[0].p2p.wait_for_verack()\n \n         # Build the blockchain\n@@ -160,9 +158,7 @@ def run_test(self):\n             self.block_time += 1\n             height += 1\n \n-        # We're adding new connections so terminate the network thread\n         self.nodes[0].disconnect_p2ps()\n-        network_thread_join()\n \n         # Start node1 and node2 with assumevalid so they accept a block with a bad signature.\n         self.start_node(1, extra_args=[\"-assumevalid=\" + hex(block102.sha256)])\n@@ -172,8 +168,6 @@ def run_test(self):\n         p2p1 = self.nodes[1].add_p2p_connection(BaseNode())\n         p2p2 = self.nodes[2].add_p2p_connection(BaseNode())\n \n-        network_thread_start()\n-\n         p2p0.wait_for_verack()\n         p2p1.wait_for_verack()\n         p2p2.wait_for_verack()"
      },
      {
        "sha": "62c0582381a81ac844bf65c481b6c8d882ebeeda",
        "filename": "test/functional/feature_block.py",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/feature_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/feature_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_block.py?ref=fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
        "patch": "@@ -20,7 +20,7 @@\n     uint256_from_compact,\n     uint256_from_str,\n )\n-from test_framework.mininode import P2PDataStore, network_thread_start, network_thread_join\n+from test_framework.mininode import P2PDataStore\n from test_framework.script import (\n     CScript,\n     MAX_SCRIPT_ELEMENT_SIZE,\n@@ -1299,7 +1299,6 @@ def bootstrap_p2p(self):\n \n         Helper to connect and wait for version handshake.\"\"\"\n         self.nodes[0].add_p2p_connection(P2PDataStore())\n-        network_thread_start()\n         # We need to wait for the initial getheaders from the peer before we\n         # start populating our blockstore. If we don't, then we may run ahead\n         # to the next subtest before we receive the getheaders. We'd then send\n@@ -1314,7 +1313,6 @@ def reconnect_p2p(self):\n         The node gets disconnected several times in this test. This helper\n         method reconnects the p2p and restarts the network thread.\"\"\"\n         self.nodes[0].disconnect_p2ps()\n-        network_thread_join()\n         self.bootstrap_p2p()\n \n     def sync_blocks(self, blocks, success=True, reject_code=None, reject_reason=None, request_block=True, reconnect=False, timeout=60):"
      },
      {
        "sha": "b484bffe0dca85ddd7d46179628a77ea8e76fc8d",
        "filename": "test/functional/feature_cltv.py",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/feature_cltv.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/feature_cltv.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_cltv.py?ref=fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
        "patch": "@@ -67,10 +67,6 @@ def set_test_params(self):\n \n     def run_test(self):\n         self.nodes[0].add_p2p_connection(P2PInterface())\n-\n-        network_thread_start()\n-\n-        # wait_for_verack ensures that the P2P connection is fully up.\n         self.nodes[0].p2p.wait_for_verack()\n \n         self.log.info(\"Mining %d blocks\", CLTV_HEIGHT - 2)"
      },
      {
        "sha": "2499214fbd2b7ef4fcea2d37adab75974bdeb24c",
        "filename": "test/functional/feature_csv_activation.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/feature_csv_activation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/feature_csv_activation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_csv_activation.py?ref=fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
        "patch": "@@ -49,7 +49,7 @@\n \n from test_framework.blocktools import create_coinbase, create_block\n from test_framework.messages import ToHex, CTransaction\n-from test_framework.mininode import network_thread_start, P2PDataStore\n+from test_framework.mininode import P2PDataStore\n from test_framework.script import (\n     CScript,\n     OP_CHECKSEQUENCEVERIFY,\n@@ -183,7 +183,6 @@ def sync_blocks(self, blocks, success=True, reject_code=None, reject_reason=None\n \n     def run_test(self):\n         self.nodes[0].add_p2p_connection(P2PDataStore())\n-        network_thread_start()\n         self.nodes[0].p2p.wait_for_verack()\n \n         self.log.info(\"Generate blocks in the past for coinbase outputs.\")"
      },
      {
        "sha": "13224466d32e1d968d6c30315e35309d9375e29a",
        "filename": "test/functional/feature_dersig.py",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/feature_dersig.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/feature_dersig.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_dersig.py?ref=fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
        "patch": "@@ -56,8 +56,6 @@ def set_test_params(self):\n     def run_test(self):\n         self.nodes[0].add_p2p_connection(P2PInterface())\n \n-        network_thread_start()\n-\n         # wait_for_verack ensures that the P2P connection is fully up.\n         self.nodes[0].p2p.wait_for_verack()\n "
      },
      {
        "sha": "c413ecf70517de721be60243d539b1472780ef54",
        "filename": "test/functional/feature_maxuploadtarget.py",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/feature_maxuploadtarget.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/feature_maxuploadtarget.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_maxuploadtarget.py?ref=fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
        "patch": "@@ -57,7 +57,6 @@ def run_test(self):\n         for _ in range(3):\n             p2p_conns.append(self.nodes[0].add_p2p_connection(TestP2PConn()))\n \n-        network_thread_start()\n         for p2pc in p2p_conns:\n             p2pc.wait_for_verack()\n \n@@ -148,8 +147,6 @@ def run_test(self):\n \n         # Reconnect to self.nodes[0]\n         self.nodes[0].add_p2p_connection(TestP2PConn())\n-\n-        network_thread_start()\n         self.nodes[0].p2p.wait_for_verack()\n \n         #retrieve 20 blocks which should be enough to break the 1MB limit"
      },
      {
        "sha": "24659eac77d7f313a95f9b8a0a4252bf14d950ad",
        "filename": "test/functional/feature_nulldummy.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/feature_nulldummy.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/feature_nulldummy.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_nulldummy.py?ref=fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
        "patch": "@@ -15,7 +15,7 @@\n \n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n-from test_framework.mininode import CTransaction, network_thread_start\n+from test_framework.messages import CTransaction\n from test_framework.blocktools import create_coinbase, create_block, add_witness_commitment\n from test_framework.script import CScript\n from io import BytesIO\n@@ -50,7 +50,6 @@ def run_test(self):\n         self.wit_address = self.nodes[0].addwitnessaddress(self.address)\n         self.wit_ms_address = self.nodes[0].addmultisigaddress(1, [self.address], '', 'p2sh-segwit')['address']\n \n-        network_thread_start()\n         self.coinbase_blocks = self.nodes[0].generate(2) # Block 2\n         coinbase_txid = []\n         for i in self.coinbase_blocks:"
      },
      {
        "sha": "a03c20b088b55c6af91dfdd0e019790f44a967d3",
        "filename": "test/functional/feature_versionbits_warning.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/feature_versionbits_warning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/feature_versionbits_warning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_versionbits_warning.py?ref=fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
        "patch": "@@ -12,7 +12,7 @@\n \n from test_framework.blocktools import create_block, create_coinbase\n from test_framework.messages import msg_block\n-from test_framework.mininode import P2PInterface, network_thread_start, mininode_lock\n+from test_framework.mininode import P2PInterface, mininode_lock\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import wait_until\n \n@@ -65,7 +65,6 @@ def run_test(self):\n         # Handy alias\n         node = self.nodes[0]\n         node.add_p2p_connection(P2PInterface())\n-        network_thread_start()\n         node.p2p.wait_for_verack()\n \n         # Mine one period worth of blocks"
      },
      {
        "sha": "17aacd815228ceda729fe5f7c9abe24c982a81cf",
        "filename": "test/functional/p2p_compactblocks.py",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/p2p_compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/p2p_compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_compactblocks.py?ref=fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
        "patch": "@@ -788,13 +788,11 @@ def announce_cmpct_block(node, peer):\n         assert_equal(int(node.getbestblockhash(), 16), block.sha256)\n \n     def run_test(self):\n-        # Setup the p2p connections and start up the network thread.\n+        # Setup the p2p connections\n         self.test_node = self.nodes[0].add_p2p_connection(TestP2PConn())\n         self.segwit_node = self.nodes[1].add_p2p_connection(TestP2PConn(), services=NODE_NETWORK|NODE_WITNESS)\n         self.old_node = self.nodes[1].add_p2p_connection(TestP2PConn(), services=NODE_NETWORK)\n \n-        network_thread_start()\n-\n         self.test_node.wait_for_verack()\n \n         # We will need UTXOs to construct transactions in later tests."
      },
      {
        "sha": "5b3fa0186a9f73fd1c64d4298983531b025f7de1",
        "filename": "test/functional/p2p_feefilter.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/p2p_feefilter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/p2p_feefilter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_feefilter.py?ref=fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
        "patch": "@@ -47,9 +47,8 @@ def run_test(self):\n         node1.generate(1)\n         sync_blocks(self.nodes)\n \n-        # Setup the p2p connections and start up the network thread.\n+        # Setup the p2p connections\n         self.nodes[0].add_p2p_connection(TestP2PConn())\n-        network_thread_start()\n         self.nodes[0].p2p.wait_for_verack()\n \n         # Test that invs are received for all txs at feerate of 20 sat/byte"
      },
      {
        "sha": "61f9ec014b8288ef784d7b6dd17684088ef1a952",
        "filename": "test/functional/p2p_fingerprint.py",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/p2p_fingerprint.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/p2p_fingerprint.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_fingerprint.py?ref=fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
        "patch": "@@ -18,7 +18,6 @@\n     msg_block,\n     msg_getdata,\n     msg_getheaders,\n-    network_thread_start,\n     wait_until,\n )\n from test_framework.test_framework import BitcoinTestFramework\n@@ -76,8 +75,6 @@ def last_header_equals(self, expected_hash, node):\n     # last month but that have over a month's worth of work are also withheld.\n     def run_test(self):\n         node0 = self.nodes[0].add_p2p_connection(P2PInterface())\n-\n-        network_thread_start()\n         node0.wait_for_verack()\n \n         # Set node time to 60 days ago"
      },
      {
        "sha": "c9819680264b7e0c374640d353a2154802d5eb03",
        "filename": "test/functional/p2p_invalid_block.py",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/p2p_invalid_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/p2p_invalid_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_block.py?ref=fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
        "patch": "@@ -14,7 +14,7 @@\n \n from test_framework.blocktools import create_block, create_coinbase, create_transaction\n from test_framework.messages import COIN\n-from test_framework.mininode import network_thread_start, P2PDataStore\n+from test_framework.mininode import P2PDataStore\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal\n \n@@ -28,8 +28,6 @@ def run_test(self):\n         # Add p2p connection to node0\n         node = self.nodes[0]  # convenience reference to the node\n         node.add_p2p_connection(P2PDataStore())\n-\n-        network_thread_start()\n         node.p2p.wait_for_verack()\n \n         best_block = node.getblock(node.getbestblockhash())"
      },
      {
        "sha": "a7a86f89fdb3b20cd13ed81726e9a76765cf9f4f",
        "filename": "test/functional/p2p_invalid_tx.py",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/p2p_invalid_tx.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/p2p_invalid_tx.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_tx.py?ref=fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
        "patch": "@@ -13,7 +13,7 @@\n     CTxIn,\n     CTxOut,\n )\n-from test_framework.mininode import network_thread_start, P2PDataStore, network_thread_join\n+from test_framework.mininode import P2PDataStore\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n@@ -32,7 +32,6 @@ def bootstrap_p2p(self, *, num_connections=1):\n         Helper to connect and wait for version handshake.\"\"\"\n         for _ in range(num_connections):\n             self.nodes[0].add_p2p_connection(P2PDataStore())\n-        network_thread_start()\n         self.nodes[0].p2p.wait_for_verack()\n \n     def reconnect_p2p(self, **kwargs):\n@@ -41,7 +40,6 @@ def reconnect_p2p(self, **kwargs):\n         The node gets disconnected several times in this test. This helper\n         method reconnects the p2p and restarts the network thread.\"\"\"\n         self.nodes[0].disconnect_p2ps()\n-        network_thread_join()\n         self.bootstrap_p2p(**kwargs)\n \n     def run_test(self):"
      },
      {
        "sha": "ecb9a56fe13b4901512f635cb50ad3e8a927e04c",
        "filename": "test/functional/p2p_leak.py",
        "status": "modified",
        "additions": 2,
        "deletions": 7,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/p2p_leak.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/p2p_leak.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_leak.py?ref=fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
        "patch": "@@ -103,8 +103,6 @@ def run_test(self):\n         unsupported_service_bit5_node = self.nodes[0].add_p2p_connection(CLazyNode(), services=NODE_NETWORK|NODE_UNSUPPORTED_SERVICE_BIT_5)\n         unsupported_service_bit7_node = self.nodes[0].add_p2p_connection(CLazyNode(), services=NODE_NETWORK|NODE_UNSUPPORTED_SERVICE_BIT_7)\n \n-        network_thread_start()\n-\n         wait_until(lambda: no_version_bannode.ever_connected, timeout=10, lock=mininode_lock)\n         wait_until(lambda: no_version_idlenode.ever_connected, timeout=10, lock=mininode_lock)\n         wait_until(lambda: no_verack_idlenode.version_received, timeout=10, lock=mininode_lock)\n@@ -126,9 +124,8 @@ def run_test(self):\n \n         self.nodes[0].disconnect_p2ps()\n \n-        # Wait until all connections are closed and the network thread has terminated\n+        # Wait until all connections are closed\n         wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 0)\n-        network_thread_join()\n \n         # Make sure no unexpected messages came in\n         assert(no_version_bannode.unexpected_msg == False)\n@@ -143,11 +140,9 @@ def run_test(self):\n         allowed_service_bit5_node = self.nodes[0].add_p2p_connection(P2PInterface(), services=NODE_NETWORK|NODE_UNSUPPORTED_SERVICE_BIT_5)\n         allowed_service_bit7_node = self.nodes[0].add_p2p_connection(P2PInterface(), services=NODE_NETWORK|NODE_UNSUPPORTED_SERVICE_BIT_7)\n \n-        # Network thread stopped when all previous P2PInterfaces disconnected. Restart it\n-        network_thread_start()\n-\n         wait_until(lambda: allowed_service_bit5_node.message_count[\"verack\"], lock=mininode_lock)\n         wait_until(lambda: allowed_service_bit7_node.message_count[\"verack\"], lock=mininode_lock)\n \n+\n if __name__ == '__main__':\n     P2PLeakTest().main()"
      },
      {
        "sha": "5a1fb60fb5c241c78adf9b39b39789a46d68df41",
        "filename": "test/functional/p2p_mempool.py",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/p2p_mempool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/p2p_mempool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_mempool.py?ref=fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
        "patch": "@@ -21,7 +21,6 @@ def set_test_params(self):\n     def run_test(self):\n         # Add a p2p connection\n         self.nodes[0].add_p2p_connection(P2PInterface())\n-        network_thread_start()\n         self.nodes[0].p2p.wait_for_verack()\n \n         #request mempool"
      },
      {
        "sha": "4a24e24dafeb1c05c09171c774684841dfa7227f",
        "filename": "test/functional/p2p_node_network_limited.py",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/p2p_node_network_limited.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/p2p_node_network_limited.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_node_network_limited.py?ref=fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
        "patch": "@@ -9,7 +9,7 @@\n     - send a block within 288 + 2 of the tip\n     - disconnect peers who request blocks older than that.\"\"\"\n from test_framework.messages import CInv, msg_getdata, msg_verack\n-from test_framework.mininode import NODE_BLOOM, NODE_NETWORK_LIMITED, NODE_WITNESS, P2PInterface, wait_until, mininode_lock, network_thread_start, network_thread_join\n+from test_framework.mininode import NODE_BLOOM, NODE_NETWORK_LIMITED, NODE_WITNESS, P2PInterface, wait_until, mininode_lock\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal, disconnect_nodes, connect_nodes_bi, sync_blocks\n \n@@ -48,7 +48,6 @@ def setup_network(self):\n \n     def run_test(self):\n         node = self.nodes[0].add_p2p_connection(P2PIgnoreInv())\n-        network_thread_start()\n         node.wait_for_verack()\n \n         expected_services = NODE_BLOOM | NODE_WITNESS | NODE_NETWORK_LIMITED\n@@ -74,9 +73,7 @@ def run_test(self):\n \n         self.log.info(\"Check local address relay, do a fresh connection.\")\n         self.nodes[0].disconnect_p2ps()\n-        network_thread_join()\n         node1 = self.nodes[0].add_p2p_connection(P2PIgnoreInv())\n-        network_thread_start()\n         node1.wait_for_verack()\n         node1.send_message(msg_verack())\n "
      },
      {
        "sha": "a2b86ff82db4c3678f40d5828dbc47917b1d9174",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
        "patch": "@@ -1964,18 +1964,15 @@ def test_non_standard_witness(self):\n \n         self.utxo.pop(0)\n \n-\n     def run_test(self):\n-        # Setup the p2p connections and start up the network thread.\n+        # Setup the p2p connections\n         # self.test_node sets NODE_WITNESS|NODE_NETWORK\n         self.test_node = self.nodes[0].add_p2p_connection(TestP2PConn(), services=NODE_NETWORK|NODE_WITNESS)\n         # self.old_node sets only NODE_NETWORK\n         self.old_node = self.nodes[0].add_p2p_connection(TestP2PConn(), services=NODE_NETWORK)\n         # self.std_node is for testing node1 (fRequireStandard=true)\n         self.std_node = self.nodes[1].add_p2p_connection(TestP2PConn(), services=NODE_NETWORK|NODE_WITNESS)\n \n-        network_thread_start()\n-\n         # Keep a place to store utxo's that can be used in later tests\n         self.utxo = []\n "
      },
      {
        "sha": "d40b6af2ee6a41fc83d55695b8678ca168f19fcc",
        "filename": "test/functional/p2p_sendheaders.py",
        "status": "modified",
        "additions": 1,
        "deletions": 6,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/p2p_sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/p2p_sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_sendheaders.py?ref=fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
        "patch": "@@ -90,7 +90,6 @@\n     CBlockHeader,\n     CInv,\n     NODE_WITNESS,\n-    network_thread_start,\n     P2PInterface,\n     mininode_lock,\n     msg_block,\n@@ -238,15 +237,11 @@ def mine_reorg(self, length):\n         return [int(x, 16) for x in all_hashes]\n \n     def run_test(self):\n-        # Setup the p2p connections and start up the network thread.\n+        # Setup the p2p connections\n         inv_node = self.nodes[0].add_p2p_connection(BaseNode())\n         # Make sure NODE_NETWORK is not set for test_node, so no block download\n         # will occur outside of direct fetching\n         test_node = self.nodes[0].add_p2p_connection(BaseNode(), services=NODE_WITNESS)\n-\n-        network_thread_start()\n-\n-        # Test logic begins here\n         inv_node.wait_for_verack()\n         test_node.wait_for_verack()\n "
      },
      {
        "sha": "7a4ef1c05cc4ae0bcd4c5976b3f574ec8d081afe",
        "filename": "test/functional/p2p_timeouts.py",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/p2p_timeouts.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/p2p_timeouts.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_timeouts.py?ref=fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
        "patch": "@@ -38,13 +38,11 @@ def set_test_params(self):\n         self.num_nodes = 1\n \n     def run_test(self):\n-        # Setup the p2p connections and start up the network thread.\n+        # Setup the p2p connections\n         no_verack_node = self.nodes[0].add_p2p_connection(TestP2PConn())\n         no_version_node = self.nodes[0].add_p2p_connection(TestP2PConn(), send_version=False)\n         no_send_node = self.nodes[0].add_p2p_connection(TestP2PConn(), send_version=False)\n \n-        network_thread_start()\n-\n         sleep(1)\n \n         assert no_verack_node.is_connected"
      },
      {
        "sha": "5f2d65c3f53ac6d9d28ac6cd1e8ef36e28417576",
        "filename": "test/functional/p2p_unrequested_blocks.py",
        "status": "modified",
        "additions": 1,
        "deletions": 9,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/p2p_unrequested_blocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/p2p_unrequested_blocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_unrequested_blocks.py?ref=fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
        "patch": "@@ -73,15 +73,11 @@ def setup_network(self):\n         self.setup_nodes()\n \n     def run_test(self):\n-        # Setup the p2p connections and start up the network thread.\n+        # Setup the p2p connections\n         # test_node connects to node0 (not whitelisted)\n         test_node = self.nodes[0].add_p2p_connection(P2PInterface())\n         # min_work_node connects to node1 (whitelisted)\n         min_work_node = self.nodes[1].add_p2p_connection(P2PInterface())\n-\n-        network_thread_start()\n-\n-        # Test logic begins here\n         test_node.wait_for_verack()\n         min_work_node.wait_for_verack()\n \n@@ -204,10 +200,8 @@ def run_test(self):\n \n         self.nodes[0].disconnect_p2ps()\n         self.nodes[1].disconnect_p2ps()\n-        network_thread_join()\n \n         test_node = self.nodes[0].add_p2p_connection(P2PInterface())\n-        network_thread_start()\n         test_node.wait_for_verack()\n \n         test_node.send_message(msg_block(block_h1f))\n@@ -293,8 +287,6 @@ def run_test(self):\n \n             self.nodes[0].disconnect_p2ps()\n             test_node = self.nodes[0].add_p2p_connection(P2PInterface())\n-\n-            network_thread_start()\n             test_node.wait_for_verack()\n \n         # We should have failed reorg and switched back to 290 (but have block 291)"
      },
      {
        "sha": "155d30317a3576f675de6e4a961371d49c1ffa79",
        "filename": "test/functional/rpc_blockchain.py",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/rpc_blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/rpc_blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_blockchain.py?ref=fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
        "patch": "@@ -41,7 +41,6 @@\n )\n from test_framework.mininode import (\n     P2PInterface,\n-    network_thread_start,\n )\n \n \n@@ -262,7 +261,6 @@ def _test_waitforblockheight(self):\n \n         # Start a P2P connection since we'll need to create some blocks.\n         node.add_p2p_connection(P2PInterface())\n-        network_thread_start()\n         node.p2p.wait_for_verack()\n \n         current_height = node.getblock(node.getbestblockhash())['height']"
      },
      {
        "sha": "29bf33fa5bec20c45c576aa1a96ab280bd23db83",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 59,
        "deletions": 119,
        "changes": 178,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
        "patch": "@@ -13,11 +13,10 @@\n P2PInterface: A high-level interface object for communicating to a node over P2P\n P2PDataStore: A p2p interface class that keeps a store of transactions and blocks\n               and can respond correctly to getdata and getheaders messages\"\"\"\n-import asyncore\n+import asyncio\n from collections import defaultdict\n from io import BytesIO\n import logging\n-import socket\n import struct\n import sys\n import threading\n@@ -57,7 +56,8 @@\n     \"regtest\": b\"\\xfa\\xbf\\xb5\\xda\",   # regtest\n }\n \n-class P2PConnection(asyncore.dispatcher):\n+\n+class P2PConnection(asyncio.Protocol):\n     \"\"\"A low-level connection object to a node's P2P interface.\n \n     This class is responsible for:\n@@ -71,68 +71,59 @@ class P2PConnection(asyncore.dispatcher):\n     sub-classed and the on_message() callback overridden.\"\"\"\n \n     def __init__(self):\n-        # All P2PConnections must be created before starting the NetworkThread.\n-        # assert that the network thread is not running.\n-        assert not network_thread_running()\n-\n-        super().__init__(map=mininode_socket_map)\n-\n-        self._conn_open = False\n+        # The underlying transport of the connection.\n+        # Should only call methods on this from the NetworkThread, c.f. call_soon_threadsafe\n+        self._transport = None\n \n     @property\n     def is_connected(self):\n-        return self._conn_open\n+        return self._transport is not None\n \n     def peer_connect(self, dstaddr, dstport, net=\"regtest\"):\n+        assert not self.is_connected\n         self.dstaddr = dstaddr\n         self.dstport = dstport\n-        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)\n-        self.socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n-        self.sendbuf = b\"\"\n+        # The initial message to send after the connection was made:\n+        self.on_connection_send_msg = None\n         self.recvbuf = b\"\"\n-        self._asyncore_pre_connection = True\n         self.network = net\n-        self.disconnect = False\n-\n         logger.debug('Connecting to Bitcoin Node: %s:%d' % (self.dstaddr, self.dstport))\n \n-        try:\n-            self.connect((dstaddr, dstport))\n-        except:\n-            self.handle_close()\n+        loop = NetworkThread.network_event_loop\n+        conn_gen_unsafe = loop.create_connection(lambda: self, host=self.dstaddr, port=self.dstport)\n+        conn_gen = lambda: loop.call_soon_threadsafe(loop.create_task, conn_gen_unsafe)\n+        return conn_gen\n \n     def peer_disconnect(self):\n         # Connection could have already been closed by other end.\n-        if self.is_connected:\n-            self.disconnect = True  # Signal asyncore to disconnect\n+        NetworkThread.network_event_loop.call_soon_threadsafe(lambda: self._transport and self._transport.abort())\n \n     # Connection and disconnection methods\n \n-    def handle_connect(self):\n-        \"\"\"asyncore callback when a connection is opened.\"\"\"\n-        if not self.is_connected:\n-            logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n-            self._conn_open = True\n-            self._asyncore_pre_connection = False\n-            self.on_open()\n-\n-    def handle_close(self):\n-        \"\"\"asyncore callback when a connection is closed.\"\"\"\n-        logger.debug(\"Closing connection to: %s:%d\" % (self.dstaddr, self.dstport))\n-        self._conn_open = False\n+    def connection_made(self, transport):\n+        \"\"\"asyncio callback when a connection is opened.\"\"\"\n+        assert not self._transport\n+        logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n+        self._transport = transport\n+        if self.on_connection_send_msg:\n+            self.send_message(self.on_connection_send_msg)\n+            self.on_connection_send_msg = None  # Never used again\n+        self.on_open()\n+\n+    def connection_lost(self, exc):\n+        \"\"\"asyncio callback when a connection is closed.\"\"\"\n+        if exc:\n+            logger.warning(\"Connection lost to {}:{} due to {}\".format(self.dstaddr, self.dstport, exc))\n+        else:\n+            logger.debug(\"Closed connection to: %s:%d\" % (self.dstaddr, self.dstport))\n+        self._transport = None\n         self.recvbuf = b\"\"\n-        self.sendbuf = b\"\"\n-        try:\n-            self.close()\n-        except:\n-            pass\n         self.on_close()\n \n     # Socket read methods\n \n-    def handle_read(self):\n-        \"\"\"asyncore callback when data is read from the socket.\"\"\"\n-        t = self.recv(8192)\n+    def data_received(self, t):\n+        \"\"\"asyncio callback when data is read from the socket.\"\"\"\n         if len(t) > 0:\n             self.recvbuf += t\n             self._on_data()\n@@ -179,30 +170,6 @@ def on_message(self, message):\n \n     # Socket write methods\n \n-    def writable(self):\n-        \"\"\"asyncore method to determine whether the handle_write() callback should be called on the next loop.\"\"\"\n-        with mininode_lock:\n-            length = len(self.sendbuf)\n-        return length > 0 or self._asyncore_pre_connection\n-\n-    def handle_write(self):\n-        \"\"\"asyncore callback when data should be written to the socket.\"\"\"\n-        with mininode_lock:\n-            # asyncore does not expose socket connection, only the first read/write\n-            # event, thus we must check connection manually here to know when we\n-            # actually connect\n-            if self._asyncore_pre_connection:\n-                self.handle_connect()\n-            if not self.writable():\n-                return\n-\n-            try:\n-                sent = self.send(self.sendbuf)\n-            except:\n-                self.handle_close()\n-                return\n-            self.sendbuf = self.sendbuf[sent:]\n-\n     def send_message(self, message):\n         \"\"\"Send a P2P message over the socket.\n \n@@ -212,15 +179,7 @@ def send_message(self, message):\n             raise IOError('Not connected')\n         self._log_message(\"send\", message)\n         tmsg = self._build_message(message)\n-        with mininode_lock:\n-            if len(self.sendbuf) == 0:\n-                try:\n-                    sent = self.send(tmsg)\n-                    self.sendbuf = tmsg[sent:]\n-                except BlockingIOError:\n-                    self.sendbuf = tmsg\n-            else:\n-                self.sendbuf += tmsg\n+        NetworkThread.network_event_loop.call_soon_threadsafe(lambda: self._transport and self._transport.write(tmsg))\n \n     # Class utility methods\n \n@@ -274,7 +233,7 @@ def __init__(self):\n         self.nServices = 0\n \n     def peer_connect(self, *args, services=NODE_NETWORK|NODE_WITNESS, send_version=True, **kwargs):\n-        super().peer_connect(*args, **kwargs)\n+        create_conn = super().peer_connect(*args, **kwargs)\n \n         if send_version:\n             # Send a version msg\n@@ -284,7 +243,9 @@ def peer_connect(self, *args, services=NODE_NETWORK|NODE_WITNESS, send_version=T\n             vt.addrTo.port = self.dstport\n             vt.addrFrom.ip = \"0.0.0.0\"\n             vt.addrFrom.port = 0\n-            self.sendbuf = self._build_message(vt)  # Will be sent right after handle_connect\n+            self.on_connection_send_msg = vt  # Will be sent soon after connection_made\n+\n+        return create_conn\n \n     # Message receiving methods\n \n@@ -408,56 +369,35 @@ def sync_with_ping(self, timeout=60):\n         self.ping_counter += 1\n \n \n-# Keep our own socket map for asyncore, so that we can track disconnects\n-# ourselves (to work around an issue with closing an asyncore socket when\n-# using select)\n-mininode_socket_map = dict()\n-\n-# One lock for synchronizing all data access between the networking thread (see\n+# One lock for synchronizing all data access between the network event loop (see\n # NetworkThread below) and the thread running the test logic.  For simplicity,\n-# P2PConnection acquires this lock whenever delivering a message to a P2PInterface,\n-# and whenever adding anything to the send buffer (in send_message()).  This\n-# lock should be acquired in the thread running the test logic to synchronize\n+# P2PConnection acquires this lock whenever delivering a message to a P2PInterface.\n+# This lock should be acquired in the thread running the test logic to synchronize\n # access to any data shared with the P2PInterface or P2PConnection.\n mininode_lock = threading.RLock()\n \n+\n class NetworkThread(threading.Thread):\n+    network_event_loop = None\n+\n     def __init__(self):\n         super().__init__(name=\"NetworkThread\")\n+        # There is only one event loop and no more than one thread must be created\n+        assert not self.network_event_loop\n+\n+        NetworkThread.network_event_loop = asyncio.new_event_loop()\n \n     def run(self):\n-        while mininode_socket_map:\n-            # We check for whether to disconnect outside of the asyncore\n-            # loop to work around the behavior of asyncore when using\n-            # select\n-            disconnected = []\n-            for fd, obj in mininode_socket_map.items():\n-                if obj.disconnect:\n-                    disconnected.append(obj)\n-            [obj.handle_close() for obj in disconnected]\n-            asyncore.loop(0.1, use_poll=True, map=mininode_socket_map, count=1)\n-        logger.debug(\"Network thread closing\")\n-\n-def network_thread_start():\n-    \"\"\"Start the network thread.\"\"\"\n-    # Only one network thread may run at a time\n-    assert not network_thread_running()\n-\n-    NetworkThread().start()\n-\n-def network_thread_running():\n-    \"\"\"Return whether the network thread is running.\"\"\"\n-    return any([thread.name == \"NetworkThread\" for thread in threading.enumerate()])\n-\n-def network_thread_join(timeout=10):\n-    \"\"\"Wait timeout seconds for the network thread to terminate.\n-\n-    Throw if the network thread doesn't terminate in timeout seconds.\"\"\"\n-    network_threads = [thread for thread in threading.enumerate() if thread.name == \"NetworkThread\"]\n-    assert len(network_threads) <= 1\n-    for thread in network_threads:\n-        thread.join(timeout)\n-        assert not thread.is_alive()\n+        \"\"\"Start the network thread.\"\"\"\n+        self.network_event_loop.run_forever()\n+\n+    def close(self, timeout=10):\n+        \"\"\"Close the connections and network event loop.\"\"\"\n+        self.network_event_loop.call_soon_threadsafe(self.network_event_loop.stop)\n+        wait_until(lambda: not self.network_event_loop.is_running(), timeout=timeout)\n+        self.network_event_loop.close()\n+        self.join(timeout)\n+\n \n class P2PDataStore(P2PInterface):\n     \"\"\"A P2P data store class."
      },
      {
        "sha": "abe8d12e59613d5cc6c5e006fc01aea9355dc220",
        "filename": "test/functional/test_framework/test_framework.py",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/test_framework/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/test_framework/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_framework.py?ref=fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
        "patch": "@@ -18,6 +18,7 @@\n from .authproxy import JSONRPCException\n from . import coverage\n from .test_node import TestNode\n+from .mininode import NetworkThread\n from .util import (\n     MAX_NODES,\n     PortSeed,\n@@ -83,6 +84,7 @@ def __init__(self):\n         \"\"\"Sets test framework defaults. Do not override this method. Instead, override the set_test_params() method\"\"\"\n         self.setup_clean_chain = False\n         self.nodes = []\n+        self.network_thread = None\n         self.mocktime = 0\n         self.supports_cli = False\n         self.bind_to_localhost_only = True\n@@ -144,6 +146,10 @@ def main(self):\n             self.options.tmpdir = tempfile.mkdtemp(prefix=\"test\")\n         self._start_logging()\n \n+        self.log.debug('Setting up network thread')\n+        self.network_thread = NetworkThread()\n+        self.network_thread.start()\n+\n         success = TestStatus.FAILED\n \n         try:\n@@ -171,6 +177,8 @@ def main(self):\n             print(\"Testcase failed. Attaching python debugger. Enter ? for help\")\n             pdb.set_trace()\n \n+        self.log.debug('Closing down network thread')\n+        self.network_thread.close()\n         if not self.options.noshutdown:\n             self.log.info(\"Stopping nodes\")\n             if self.nodes:"
      },
      {
        "sha": "287dc0e53e0b9918e159c2e76377d1fdbd8ebef5",
        "filename": "test/functional/test_framework/test_node.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/test_framework/test_node.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd/test/functional/test_framework/test_node.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_node.py?ref=fa87da2f172ae2e6dc15e9ed156a3564a8ecfbdd",
        "patch": "@@ -289,7 +289,7 @@ def add_p2p_connection(self, p2p_conn, *args, **kwargs):\n         if 'dstaddr' not in kwargs:\n             kwargs['dstaddr'] = '127.0.0.1'\n \n-        p2p_conn.peer_connect(*args, **kwargs)\n+        p2p_conn.peer_connect(*args, **kwargs)()\n         self.p2ps.append(p2p_conn)\n \n         return p2p_conn\n@@ -343,10 +343,10 @@ def __getattr__(self, command):\n     def batch(self, requests):\n         results = []\n         for request in requests:\n-           try:\n-               results.append(dict(result=request()))\n-           except JSONRPCException as e:\n-               results.append(dict(error=e))\n+            try:\n+                results.append(dict(result=request()))\n+            except JSONRPCException as e:\n+                results.append(dict(error=e))\n         return results\n \n     def send_cli(self, command=None, *args, **kwargs):"
      }
    ]
  }
]