[
  {
    "sha": "faa9a74c9e99eb43ba0d27fa906767ee88011aeb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYWE5YTc0YzllOTllYjQzYmEwZDI3ZmE5MDY3NjdlZTg4MDExYWVi",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2020-07-11T08:41:23Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2020-07-14T10:29:47Z"
      },
      "message": "test: Fail wait_until early if connection is lost",
      "tree": {
        "sha": "836e1e781cf7caef0535341cae46280a3931bf43",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/836e1e781cf7caef0535341cae46280a3931bf43"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/faa9a74c9e99eb43ba0d27fa906767ee88011aeb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUjx7gv/bIrxLeoCnDzsbGEGXFCWfFVO0a5OWvNbD5m566lz2VUuf86tzbUPogCE\nlMeci5E62J8FOPrCjJimMt4wcOMWsCQ/DfLZIRtlDx7K/2MAe/Pfm+vAWI73z6Pf\nlOEY1FXubLUQTIOmZDoZS07hi84vkZEFoDyQ8tZosp1y3bcb3ApWUF8EZkHxd+l2\nRWQKEQZMolLqyNMDWyuTJ4sLoMVvqFBvl/SvK5b3DXOY4IxQH0Zfa86+7zvY49im\ngKd/yFaYd4wkBWnJyLfKr4UuM4PSRMjiCwhU/0hQnFyWIViq10XVl6+zvapdeayx\nYY/7tVZenR1yiLbZ1OP5Ba/DTytcb3pUUqJ2RTGN5ohUIMtBXxc6rqyhtwCYoIwd\nXWLEUyB6UDTcCpwoCXD8IimjYPmFi9Nx88DZkqH+tnYhsz4AUUPSyDUJnEG/cURi\nVPllECOnfUyJWFWi9f6rqVrNGngFJ/tdyiCFILw0kup9AHbybwrEPCSQKrZ7apH8\nZg8b11nc\n=iHk1\n-----END PGP SIGNATURE-----",
        "payload": "tree 836e1e781cf7caef0535341cae46280a3931bf43\nparent ca055885c631de8ac0ffe24be6b02835dbcc039d\nauthor MarcoFalke <falke.marco@gmail.com> 1594456883 +0200\ncommitter MarcoFalke <falke.marco@gmail.com> 1594722587 +0200\n\ntest: Fail wait_until early if connection is lost\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/faa9a74c9e99eb43ba0d27fa906767ee88011aeb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/faa9a74c9e99eb43ba0d27fa906767ee88011aeb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/faa9a74c9e99eb43ba0d27fa906767ee88011aeb/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ca055885c631de8ac0ffe24be6b02835dbcc039d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ca055885c631de8ac0ffe24be6b02835dbcc039d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ca055885c631de8ac0ffe24be6b02835dbcc039d"
      }
    ],
    "stats": {
      "total": 56,
      "additions": 27,
      "deletions": 29
    },
    "files": [
      {
        "sha": "c8e2616b79ece46a078f285ff35e3eaa08430c6a",
        "filename": "test/functional/p2p_filter.py",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/faa9a74c9e99eb43ba0d27fa906767ee88011aeb/test/functional/p2p_filter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/faa9a74c9e99eb43ba0d27fa906767ee88011aeb/test/functional/p2p_filter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_filter.py?ref=faa9a74c9e99eb43ba0d27fa906767ee88011aeb",
        "patch": "@@ -218,7 +218,11 @@ def run_test(self):\n         # Add peer but do not send version yet\n         filter_peer_without_nrelay = self.nodes[0].add_p2p_connection(P2PBloomFilter(), send_version=False, wait_for_verack=False)\n         # Send version with fRelay=False\n-        filter_peer_without_nrelay.wait_until(lambda: filter_peer_without_nrelay.is_connected, timeout=10)\n+        filter_peer_without_nrelay.wait_until(\n+            lambda: filter_peer_without_nrelay.is_connected,\n+            timeout=10,\n+            check_connected=False,\n+        )\n         version_without_fRelay = msg_version()\n         version_without_fRelay.nRelay = 0\n         filter_peer_without_nrelay.send_message(version_without_fRelay)"
      },
      {
        "sha": "5f5fd3e104df7dee8334e949595faa1115a8a611",
        "filename": "test/functional/p2p_ping.py",
        "status": "modified",
        "additions": 8,
        "deletions": 13,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/faa9a74c9e99eb43ba0d27fa906767ee88011aeb/test/functional/p2p_ping.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/faa9a74c9e99eb43ba0d27fa906767ee88011aeb/test/functional/p2p_ping.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_ping.py?ref=faa9a74c9e99eb43ba0d27fa906767ee88011aeb",
        "patch": "@@ -7,13 +7,8 @@\n \n import time\n \n-from test_framework.messages import (\n-    msg_pong,\n-)\n-from test_framework.mininode import (\n-    P2PInterface,\n-    wait_until,\n-)\n+from test_framework.messages import msg_pong\n+from test_framework.mininode import P2PInterface\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal\n \n@@ -78,7 +73,7 @@ def run_test(self):\n         with self.nodes[0].assert_debug_log(['pong peer=0: Nonce mismatch']):\n             # mock time PING_INTERVAL ahead to trigger node into sending a ping\n             self.mock_forward(PING_INTERVAL + 1)\n-            wait_until(lambda: 'ping' in no_pong_node.last_message)\n+            no_pong_node.wait_until(lambda: 'ping' in no_pong_node.last_message)\n             self.mock_forward(9)\n             # Send the wrong pong\n             no_pong_node.send_and_ping(msg_pong(no_pong_node.last_message.pop('ping').nonce - 1))\n@@ -93,27 +88,27 @@ def run_test(self):\n         assert 'ping' not in no_pong_node.last_message\n         # mock time PING_INTERVAL ahead to trigger node into sending a ping\n         self.mock_forward(PING_INTERVAL + 1)\n-        wait_until(lambda: 'ping' in no_pong_node.last_message)\n+        no_pong_node.wait_until(lambda: 'ping' in no_pong_node.last_message)\n         ping_delay = 29\n         self.mock_forward(ping_delay)\n-        wait_until(lambda: 'ping' in no_pong_node.last_message)\n+        no_pong_node.wait_until(lambda: 'ping' in no_pong_node.last_message)\n         no_pong_node.send_and_ping(msg_pong(no_pong_node.last_message.pop('ping').nonce))\n         self.check_peer_info(pingtime=ping_delay, minping=ping_delay, pingwait=None)\n \n         self.log.info('Check that minping is decreased after a fast roundtrip')\n         # mock time PING_INTERVAL ahead to trigger node into sending a ping\n         self.mock_forward(PING_INTERVAL + 1)\n-        wait_until(lambda: 'ping' in no_pong_node.last_message)\n+        no_pong_node.wait_until(lambda: 'ping' in no_pong_node.last_message)\n         ping_delay = 9\n         self.mock_forward(ping_delay)\n-        wait_until(lambda: 'ping' in no_pong_node.last_message)\n+        no_pong_node.wait_until(lambda: 'ping' in no_pong_node.last_message)\n         no_pong_node.send_and_ping(msg_pong(no_pong_node.last_message.pop('ping').nonce))\n         self.check_peer_info(pingtime=ping_delay, minping=ping_delay, pingwait=None)\n \n         self.log.info('Check that peer is disconnected after ping timeout')\n         assert 'ping' not in no_pong_node.last_message\n         self.nodes[0].ping()\n-        wait_until(lambda: 'ping' in no_pong_node.last_message)\n+        no_pong_node.wait_until(lambda: 'ping' in no_pong_node.last_message)\n         with self.nodes[0].assert_debug_log(['ping timeout: 1201.000000s']):\n             self.mock_forward(20 * 60 + 1)\n             time.sleep(4)  # peertimeout + 1"
      },
      {
        "sha": "eda5c5ba0afb5d28a710cfcb30041ea3bb882a9e",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 14,
        "deletions": 15,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/faa9a74c9e99eb43ba0d27fa906767ee88011aeb/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/faa9a74c9e99eb43ba0d27fa906767ee88011aeb/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=faa9a74c9e99eb43ba0d27fa906767ee88011aeb",
        "patch": "@@ -378,18 +378,22 @@ def on_version(self, message):\n \n     # Connection helper methods\n \n-    def wait_until(self, test_function, timeout=60):\n+    def wait_until(self, test_function_in, *, timeout=60, check_connected=True):\n+        def test_function():\n+            if check_connected:\n+                assert self.is_connected\n+            return test_function_in()\n+\n         wait_until(test_function, timeout=timeout, lock=mininode_lock, timeout_factor=self.timeout_factor)\n \n     def wait_for_disconnect(self, timeout=60):\n         test_function = lambda: not self.is_connected\n-        self.wait_until(test_function, timeout=timeout)\n+        self.wait_until(test_function, timeout=timeout, check_connected=False)\n \n     # Message receiving helper methods\n \n     def wait_for_tx(self, txid, timeout=60):\n         def test_function():\n-            assert self.is_connected\n             if not self.last_message.get('tx'):\n                 return False\n             return self.last_message['tx'].tx.rehash() == txid\n@@ -398,14 +402,12 @@ def test_function():\n \n     def wait_for_block(self, blockhash, timeout=60):\n         def test_function():\n-            assert self.is_connected\n             return self.last_message.get(\"block\") and self.last_message[\"block\"].block.rehash() == blockhash\n \n         self.wait_until(test_function, timeout=timeout)\n \n     def wait_for_header(self, blockhash, timeout=60):\n         def test_function():\n-            assert self.is_connected\n             last_headers = self.last_message.get('headers')\n             if not last_headers:\n                 return False\n@@ -415,7 +417,6 @@ def test_function():\n \n     def wait_for_merkleblock(self, blockhash, timeout=60):\n         def test_function():\n-            assert self.is_connected\n             last_filtered_block = self.last_message.get('merkleblock')\n             if not last_filtered_block:\n                 return False\n@@ -427,9 +428,7 @@ def wait_for_getdata(self, hash_list, timeout=60):\n         \"\"\"Waits for a getdata message.\n \n         The object hashes in the inventory vector must match the provided hash_list.\"\"\"\n-\n         def test_function():\n-            assert self.is_connected\n             last_data = self.last_message.get(\"getdata\")\n             if not last_data:\n                 return False\n@@ -444,9 +443,7 @@ def wait_for_getheaders(self, timeout=60):\n         value must be explicitly cleared before calling this method, or this will return\n         immediately with success. TODO: change this method to take a hash value and only\n         return true if the correct block header has been requested.\"\"\"\n-\n         def test_function():\n-            assert self.is_connected\n             return self.last_message.get(\"getheaders\")\n \n         self.wait_until(test_function, timeout=timeout)\n@@ -457,7 +454,6 @@ def wait_for_inv(self, expected_inv, timeout=60):\n             raise NotImplementedError(\"wait_for_inv() will only verify the first inv object\")\n \n         def test_function():\n-            assert self.is_connected\n             return self.last_message.get(\"inv\") and \\\n                                 self.last_message[\"inv\"].inv[0].type == expected_inv[0].type and \\\n                                 self.last_message[\"inv\"].inv[0].hash == expected_inv[0].hash\n@@ -468,7 +464,7 @@ def wait_for_verack(self, timeout=60):\n         def test_function():\n             return self.message_count[\"verack\"]\n \n-        self.wait_until(test_function, timeout=timeout)\n+        self.wait_until(test_function, timeout=timeout, check_connected=False)\n \n     # Message sending helper functions\n \n@@ -481,7 +477,6 @@ def sync_with_ping(self, timeout=60):\n         self.send_message(msg_ping(nonce=self.ping_counter))\n \n         def test_function():\n-            assert self.is_connected\n             return self.last_message.get(\"pong\") and self.last_message[\"pong\"].nonce == self.ping_counter\n \n         self.wait_until(test_function, timeout=timeout)\n@@ -599,7 +594,11 @@ def send_blocks_and_test(self, blocks, node, *, success=True, force_send=False,\n                     self.send_message(msg_block(block=b))\n             else:\n                 self.send_message(msg_headers([CBlockHeader(block) for block in blocks]))\n-                self.wait_until(lambda: blocks[-1].sha256 in self.getdata_requests, timeout=timeout)\n+                self.wait_until(\n+                    lambda: blocks[-1].sha256 in self.getdata_requests,\n+                    timeout=timeout,\n+                    check_connected=success,\n+                )\n \n             if expect_disconnect:\n                 self.wait_for_disconnect(timeout=timeout)\n@@ -667,6 +666,6 @@ def wait_for_broadcast(self, txns, timeout=60):\n         The mempool should mark unbroadcast=False for these transactions.\n         \"\"\"\n         # Wait until invs have been received (and getdatas sent) for each txid.\n-        self.wait_until(lambda: set(self.tx_invs_received.keys()) == set([int(tx, 16) for tx in txns]), timeout)\n+        self.wait_until(lambda: set(self.tx_invs_received.keys()) == set([int(tx, 16) for tx in txns]), timeout=timeout)\n         # Flush messages and wait for the getdatas to be processed\n         self.sync_with_ping()"
      }
    ]
  }
]