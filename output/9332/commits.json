[
  {
    "sha": "98ea64cf232c34d4b1aebe738b3956191667cd76",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5OGVhNjRjZjIzMmMzNGQ0YjFhZWJlNzM4YjM5NTYxOTE2NjdjZDc2",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2016-11-28T22:19:27Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2018-02-22T15:04:42Z"
      },
      "message": "Let wallet importmulti RPC accept labels for standard scriptPubKeys\n\nAllow importmulti RPC to apply address labels when importing standard\nscriptPubKeys. This makes the importmulti RPC less finnicky about import\nformats and also simpler internally.",
      "tree": {
        "sha": "fa5a3e1778d190b28b57e77b2324bd651116684f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fa5a3e1778d190b28b57e77b2324bd651116684f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/98ea64cf232c34d4b1aebe738b3956191667cd76",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/98ea64cf232c34d4b1aebe738b3956191667cd76",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/98ea64cf232c34d4b1aebe738b3956191667cd76",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/98ea64cf232c34d4b1aebe738b3956191667cd76/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "aae64a21ba25ca86fe2bbb581681dc20d613fb44",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aae64a21ba25ca86fe2bbb581681dc20d613fb44",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/aae64a21ba25ca86fe2bbb581681dc20d613fb44"
      }
    ],
    "stats": {
      "total": 79,
      "additions": 28,
      "deletions": 51
    },
    "files": [
      {
        "sha": "caaacdd72c48e531d0cc857f79eb97153a83adb1",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 34,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/98ea64cf232c34d4b1aebe738b3956191667cd76/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/98ea64cf232c34d4b1aebe738b3956191667cd76/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=98ea64cf232c34d4b1aebe738b3956191667cd76",
        "patch": "@@ -838,6 +838,9 @@ UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int6\n \n             std::vector<unsigned char> vData(ParseHex(output));\n             script = CScript(vData.begin(), vData.end());\n+            if (!ExtractDestination(script, dest) && !internal) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n+            }\n         }\n \n         // Watchonly and private keys\n@@ -850,11 +853,6 @@ UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int6\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n         }\n \n-        // Not having Internal + Script\n-        if (!internal && isScript) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set for hex scriptPubKey\");\n-        }\n-\n         // Keys / PubKeys size check.\n         if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n@@ -965,21 +963,10 @@ UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int6\n                 CTxDestination pubkey_dest = pubKey.GetID();\n \n                 // Consistency check.\n-                if (!isScript && !(pubkey_dest == dest)) {\n+                if (!(pubkey_dest == dest)) {\n                     throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n                 }\n \n-                // Consistency check.\n-                if (isScript) {\n-                    CTxDestination destination;\n-\n-                    if (ExtractDestination(script, destination)) {\n-                        if (!(destination == pubkey_dest)) {\n-                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                        }\n-                    }\n-                }\n-\n                 CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n \n                 if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n@@ -1036,21 +1023,10 @@ UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int6\n                 CTxDestination pubkey_dest = pubKey.GetID();\n \n                 // Consistency check.\n-                if (!isScript && !(pubkey_dest == dest)) {\n+                if (!(pubkey_dest == dest)) {\n                     throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n                 }\n \n-                // Consistency check.\n-                if (isScript) {\n-                    CTxDestination destination;\n-\n-                    if (ExtractDestination(script, destination)) {\n-                        if (!(destination == pubkey_dest)) {\n-                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                        }\n-                    }\n-                }\n-\n                 CKeyID vchAddress = pubKey.GetID();\n                 pwallet->MarkDirty();\n                 pwallet->SetAddressBook(vchAddress, label, \"receive\");\n@@ -1082,11 +1058,9 @@ UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int6\n                     throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n                 }\n \n-                if (scriptPubKey.getType() == UniValue::VOBJ) {\n-                    // add to address book or update label\n-                    if (IsValidDestination(dest)) {\n-                        pwallet->SetAddressBook(dest, label, \"receive\");\n-                    }\n+                // add to address book or update label\n+                if (IsValidDestination(dest)) {\n+                    pwallet->SetAddressBook(dest, label, \"receive\");\n                 }\n \n                 success = true;"
      },
      {
        "sha": "a7095e1a24d2afaba11918199a5f7de4d21fe4a3",
        "filename": "test/functional/wallet_import_rescan.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/98ea64cf232c34d4b1aebe738b3956191667cd76/test/functional/wallet_import_rescan.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/98ea64cf232c34d4b1aebe738b3956191667cd76/test/functional/wallet_import_rescan.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_import_rescan.py?ref=98ea64cf232c34d4b1aebe738b3956191667cd76",
        "patch": "@@ -26,7 +26,7 @@\n import enum\n import itertools\n \n-Call = enum.Enum(\"Call\", \"single multi\")\n+Call = enum.Enum(\"Call\", \"single multiaddress multiscript\")\n Data = enum.Enum(\"Data\", \"address pub priv\")\n Rescan = enum.Enum(\"Rescan\", \"no yes late_timestamp\")\n \n@@ -54,11 +54,11 @@ def do_import(self, timestamp):\n                 response = self.try_rpc(self.node.importprivkey, self.key, self.label, self.rescan == Rescan.yes)\n             assert_equal(response, None)\n \n-        elif self.call == Call.multi:\n+        elif self.call in (Call.multiaddress, Call.multiscript):\n             response = self.node.importmulti([{\n                 \"scriptPubKey\": {\n                     \"address\": self.address[\"address\"]\n-                },\n+                } if self.call == Call.multiaddress else self.address[\"scriptPubKey\"],\n                 \"timestamp\": timestamp + TIMESTAMP_WINDOW + (1 if self.rescan == Rescan.late_timestamp else 0),\n                 \"pubkeys\": [self.address[\"pubkey\"]] if self.data == Data.pub else [],\n                 \"keys\": [self.key] if self.data == Data.priv else [],\n@@ -136,7 +136,7 @@ def run_test(self):\n             variant.label = \"label {} {}\".format(i, variant)\n             variant.address = self.nodes[1].getaddressinfo(self.nodes[1].getnewaddress(variant.label))\n             variant.key = self.nodes[1].dumpprivkey(variant.address[\"address\"])\n-            variant.initial_amount = 10 - (i + 1) / 4.0\n+            variant.initial_amount = 1 - (i + 1) / 64\n             variant.initial_txid = self.nodes[0].sendtoaddress(variant.address[\"address\"], variant.initial_amount)\n \n         # Generate a block containing the initial transactions, then another\n@@ -166,7 +166,7 @@ def run_test(self):\n \n         # Create new transactions sending to each address.\n         for i, variant in enumerate(IMPORT_VARIANTS):\n-            variant.sent_amount = 10 - (2 * i + 1) / 8.0\n+            variant.sent_amount = 1 - (2 * i + 1) / 128\n             variant.sent_txid = self.nodes[0].sendtoaddress(variant.address[\"address\"], variant.sent_amount)\n \n         # Generate a block containing the new transactions."
      },
      {
        "sha": "0b4065ed7e172767b0ac0c61dbb022bd77e7bb28",
        "filename": "test/functional/wallet_importmulti.py",
        "status": "modified",
        "additions": 15,
        "deletions": 12,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/98ea64cf232c34d4b1aebe738b3956191667cd76/test/functional/wallet_importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/98ea64cf232c34d4b1aebe738b3956191667cd76/test/functional/wallet_importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importmulti.py?ref=98ea64cf232c34d4b1aebe738b3956191667cd76",
        "patch": "@@ -3,6 +3,8 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the importmulti RPC.\"\"\"\n+\n+from test_framework import script\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n \n@@ -79,16 +81,17 @@ def run_test (self):\n         assert_equal(address_assert['ismine'], False)\n         assert_equal(address_assert['timestamp'], timestamp)\n \n-        # ScriptPubKey + !internal\n-        self.log.info(\"Should not import a scriptPubKey without internal flag\")\n+        # Nonstandard scriptPubKey + !internal\n+        self.log.info(\"Should not import a nonstandard scriptPubKey without internal flag\")\n+        nonstandardScriptPubKey = address['scriptPubKey'] + bytes_to_hex_str(script.CScript([script.OP_NOP]))\n         address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": address['scriptPubKey'],\n+            \"scriptPubKey\": nonstandardScriptPubKey,\n             \"timestamp\": \"now\",\n         }])\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -8)\n-        assert_equal(result[0]['error']['message'], 'Internal must be set for hex scriptPubKey')\n+        assert_equal(result[0]['error']['message'], 'Internal must be set to true for nonstandard scriptPubKey imports.')\n         address_assert = self.nodes[1].getaddressinfo(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n@@ -128,18 +131,18 @@ def run_test (self):\n         assert_equal(address_assert['ismine'], False)\n         assert_equal(address_assert['timestamp'], timestamp)\n \n-        # ScriptPubKey + Public key + !internal\n-        self.log.info(\"Should not import a scriptPubKey without internal and with public key\")\n+        # Nonstandard scriptPubKey + Public key + !internal\n+        self.log.info(\"Should not import a nonstandard scriptPubKey without internal and with public key\")\n         address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         request = [{\n-            \"scriptPubKey\": address['scriptPubKey'],\n+            \"scriptPubKey\": nonstandardScriptPubKey,\n             \"timestamp\": \"now\",\n             \"pubkeys\": [ address['pubkey'] ]\n         }]\n         result = self.nodes[1].importmulti(request)\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -8)\n-        assert_equal(result[0]['error']['message'], 'Internal must be set for hex scriptPubKey')\n+        assert_equal(result[0]['error']['message'], 'Internal must be set to true for nonstandard scriptPubKey imports.')\n         address_assert = self.nodes[1].getaddressinfo(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n@@ -207,17 +210,17 @@ def run_test (self):\n         assert_equal(address_assert['ismine'], True)\n         assert_equal(address_assert['timestamp'], timestamp)\n \n-        # ScriptPubKey + Private key + !internal\n-        self.log.info(\"Should not import a scriptPubKey without internal and with private key\")\n+        # Nonstandard scriptPubKey + Private key + !internal\n+        self.log.info(\"Should not import a nonstandard scriptPubKey without internal and with private key\")\n         address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": address['scriptPubKey'],\n+            \"scriptPubKey\": nonstandardScriptPubKey,\n             \"timestamp\": \"now\",\n             \"keys\": [ self.nodes[0].dumpprivkey(address['address']) ]\n         }])\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -8)\n-        assert_equal(result[0]['error']['message'], 'Internal must be set for hex scriptPubKey')\n+        assert_equal(result[0]['error']['message'], 'Internal must be set to true for nonstandard scriptPubKey imports.')\n         address_assert = self.nodes[1].getaddressinfo(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)"
      }
    ]
  }
]