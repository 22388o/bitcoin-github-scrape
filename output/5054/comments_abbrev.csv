laanwj,2014-10-07T06:58:57Z,> These implicit castings are dangerous.\n\nCan you explain why?\n,https://github.com/bitcoin/bitcoin/pull/5054#issuecomment-58144634,58144634,
jtimon,2014-10-07T08:59:06Z,The implicit casting can cause hard to find segmentation faults. Any function or method (including constructors) that takes a CTransaction (or a reference to it) as parameter will create a temporary instance using the implicit constructor from a CMutableTransaction. That instance is only in memory during the execution of the function and gets destroyed just after it. Any later access to a referenc,https://github.com/bitcoin/bitcoin/pull/5054#issuecomment-58155613,58155613,
laanwj,2014-10-07T09:06:59Z,"Indeed, the parameter will create a temporary instance using the implicit constructor. It will have the scope of the current statement only.\n\nIsn't the root issue then that some functions assume that a const reference that is passed has a longer validity than the function call? Not the implicit conversion itself?\n\nIe if a function takes a `const std::string &`, this could be a temporary conver",https://github.com/bitcoin/bitcoin/pull/5054#issuecomment-58156491,58156491,
jtimon,2014-10-07T21:29:54Z,"What you say makes sense, but creating an additional copy has some cost that I would like to save when it's not necessary. Maybe this only makes sense after #4989.\n@sipa told me that he introduced that constructor without the explicit keyword to minimize the diff but leave it as something to do later.\n",https://github.com/bitcoin/bitcoin/pull/5054#issuecomment-58265971,58265971,
laanwj,2014-10-08T06:46:03Z,"So use a pointer, then. I think no matter what, assuming that a reference that is passed to a function outlives that function is wrong.\nImplicit conversions are just a fact of life with references. You can make one constructor explicit, but this will keep biting you as long as you use C++.\n",https://github.com/bitcoin/bitcoin/pull/5054#issuecomment-58317090,58317090,
jtimon,2014-10-08T10:33:42Z,"I tried to do it with pointers and castings instead of implicit constructors but the tests keep failing "" memory access violation""\nhttps://github.com/jtimon/bitcoin/tree/ptrsighash\n\nWe could make all constructors with a single parameter explicit. We could even make that a style rule. If we did, when we ""assume that a reference that is passed to a function outlives that function""  either by mist",https://github.com/bitcoin/bitcoin/pull/5054#issuecomment-58338945,58338945,
laanwj,2014-10-08T11:25:11Z,"I am not _blaming_ C++. I'm just saying that temporaries are something to be expected if you use (const) references. You can try to change the world around it, or just accept it and use a style that is not conductive to a kind of error. Even if you make sure that all constructors in bitcoin core itself are explicit, there could still be an implicit conversion through boost, or the standard library",https://github.com/bitcoin/bitcoin/pull/5054#issuecomment-58343659,58343659,
jtimon,2014-10-28T16:58:33Z,"Avoiding a copy is probably always an optimization. Your rule of simply not using constructors that use a const ref and expect it to remain in memory makes a lot of sense to me.\nI wasn't misunderstanding explicit, I was misunderstanding const&.\nThanks for the explanations, closing (and sorry for not having closing it earlier).\n",https://github.com/bitcoin/bitcoin/pull/5054#issuecomment-60791020,60791020,
