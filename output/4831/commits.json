[
  {
    "sha": "b9e5772597c1ae4601916a2d76a8e09bd46c4c2a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiOWU1NzcyNTk3YzFhZTQ2MDE5MTZhMmQ3NmE4ZTA5YmQ0NmM0YzJh",
    "commit": {
      "author": {
        "name": "Ashley Holman",
        "email": "dscvlt@gmail.com",
        "date": "2014-09-03T08:19:48Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-09-18T10:14:27Z"
      },
      "message": "sync: Add CTimeoutCondition\n\nA condition that can wait for a specified timeout, this is useful when\nit is known in advance that events have to be processed at some time in the\nfuture.",
      "tree": {
        "sha": "4f1be020b9515863c806c25cb8f36845656012f2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4f1be020b9515863c806c25cb8f36845656012f2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b9e5772597c1ae4601916a2d76a8e09bd46c4c2a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b9e5772597c1ae4601916a2d76a8e09bd46c4c2a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b9e5772597c1ae4601916a2d76a8e09bd46c4c2a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b9e5772597c1ae4601916a2d76a8e09bd46c4c2a/comments",
    "author": {
      "login": "ashleyholman",
      "id": 549484,
      "node_id": "MDQ6VXNlcjU0OTQ4NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/549484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ashleyholman",
      "html_url": "https://github.com/ashleyholman",
      "followers_url": "https://api.github.com/users/ashleyholman/followers",
      "following_url": "https://api.github.com/users/ashleyholman/following{/other_user}",
      "gists_url": "https://api.github.com/users/ashleyholman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ashleyholman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ashleyholman/subscriptions",
      "organizations_url": "https://api.github.com/users/ashleyholman/orgs",
      "repos_url": "https://api.github.com/users/ashleyholman/repos",
      "events_url": "https://api.github.com/users/ashleyholman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ashleyholman/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7fd881367544fcc9e70130bf448a181794da26ab",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7fd881367544fcc9e70130bf448a181794da26ab",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7fd881367544fcc9e70130bf448a181794da26ab"
      }
    ],
    "stats": {
      "total": 35,
      "additions": 35,
      "deletions": 0
    },
    "files": [
      {
        "sha": "fdfbd75e0f7a2350da20ed628eaf2987436f7fa4",
        "filename": "src/sync.h",
        "status": "modified",
        "additions": 35,
        "deletions": 0,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9e5772597c1ae4601916a2d76a8e09bd46c4c2a/src/sync.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9e5772597c1ae4601916a2d76a8e09bd46c4c2a/src/sync.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.h?ref=b9e5772597c1ae4601916a2d76a8e09bd46c4c2a",
        "patch": "@@ -103,6 +103,41 @@ void static inline AssertLockHeldInternal(const char* pszName, const char* pszFi\n void PrintLockContention(const char* pszName, const char* pszFile, int nLine);\n #endif\n \n+class CTimeoutCondition\n+{\n+private:\n+    boost::condition_variable condition;\n+    boost::mutex mutex;\n+    bool fHasWork;\n+    boost::posix_time::ptime alarm;\n+\n+public:\n+    void wait() {\n+        boost::unique_lock<boost::mutex> lock(mutex);\n+        while (!fHasWork) {\n+            condition.wait(lock);\n+        }\n+        fHasWork = false;\n+    }\n+\n+    void timed_wait(int milliseconds) {\n+        boost::unique_lock<boost::mutex> lock(mutex);\n+        boost::posix_time::ptime now = boost::posix_time::microsec_clock::universal_time();\n+        alarm = now + boost::posix_time::milliseconds(milliseconds);\n+        while (!fHasWork && now < alarm) {\n+            condition.timed_wait(lock, alarm);\n+            now = boost::posix_time::microsec_clock::universal_time();\n+        }\n+        fHasWork = false;\n+    }\n+\n+    void notify_one() {\n+        boost::unique_lock<boost::mutex> lock(mutex);\n+        fHasWork = true;\n+        condition.notify_one();\n+    }\n+};\n+\n /** Wrapper around boost::unique_lock<Mutex> */\n template<typename Mutex>\n class CMutexLock"
      }
    ]
  },
  {
    "sha": "7ea2476c0a5101d8b93abdebb86c1121fa76f3ea",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZWEyNDc2YzBhNTEwMWQ4YjkzYWJkZWJiODZjMTEyMWZhNzZmM2Vh",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-09-03T08:25:17Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-09-18T10:14:28Z"
      },
      "message": "net: add StartThreads and StopThreads signals\n\nThis allows modules to maintain their own threads.",
      "tree": {
        "sha": "d978eab54439a6bc1cccf15363e4ae976f7914ae",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d978eab54439a6bc1cccf15363e4ae976f7914ae"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7ea2476c0a5101d8b93abdebb86c1121fa76f3ea",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7ea2476c0a5101d8b93abdebb86c1121fa76f3ea",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7ea2476c0a5101d8b93abdebb86c1121fa76f3ea",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7ea2476c0a5101d8b93abdebb86c1121fa76f3ea/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b9e5772597c1ae4601916a2d76a8e09bd46c4c2a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b9e5772597c1ae4601916a2d76a8e09bd46c4c2a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b9e5772597c1ae4601916a2d76a8e09bd46c4c2a"
      }
    ],
    "stats": {
      "total": 9,
      "additions": 9,
      "deletions": 0
    },
    "files": [
      {
        "sha": "7b4e0a07ff0aac0bc45c6fcd6bdaab5c1999287f",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7ea2476c0a5101d8b93abdebb86c1121fa76f3ea/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7ea2476c0a5101d8b93abdebb86c1121fa76f3ea/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=7ea2476c0a5101d8b93abdebb86c1121fa76f3ea",
        "patch": "@@ -1776,11 +1776,18 @@ void StartNode(boost::thread_group& threadGroup)\n \n     // Dump network addresses\n     threadGroup.create_thread(boost::bind(&LoopForever<void (*)()>, \"dumpaddr\", &DumpAddresses, DUMP_ADDRESSES_INTERVAL * 1000));\n+\n+    // Start miscellaneous threads\n+    g_signals.StartThreads(threadGroup);\n }\n \n bool StopNode()\n {\n     LogPrintf(\"StopNode()\\n\");\n+\n+    // Stop miscellaneous threads\n+    g_signals.StopThreads();\n+\n     MapPort(false);\n     if (semOutbound)\n         for (int i=0; i<MAX_OUTBOUND_CONNECTIONS; i++)"
      },
      {
        "sha": "5895ae613ec2eafa686f25c58ddef3773bd53286",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7ea2476c0a5101d8b93abdebb86c1121fa76f3ea/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7ea2476c0a5101d8b93abdebb86c1121fa76f3ea/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=7ea2476c0a5101d8b93abdebb86c1121fa76f3ea",
        "patch": "@@ -83,6 +83,8 @@ struct CNodeSignals\n     boost::signals2::signal<bool (CNode*, bool)> SendMessages;\n     boost::signals2::signal<void (NodeId, const CNode*)> InitializeNode;\n     boost::signals2::signal<void (NodeId)> FinalizeNode;\n+    boost::signals2::signal<void (boost::thread_group& threadGroup)> StartThreads;\n+    boost::signals2::signal<void ()> StopThreads;\n };\n \n "
      }
    ]
  },
  {
    "sha": "9cbaaf61ade4b91469f3d728795ec83859c25192",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5Y2JhYWY2MWFkZTRiOTE0NjlmM2Q3Mjg3OTVlYzgzODU5YzI1MTky",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-09-03T08:26:50Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-09-18T10:22:36Z"
      },
      "message": "net: Better inventory request management",
      "tree": {
        "sha": "8ca997cfec3c53fca5c5cd9fea8887949141e5a0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8ca997cfec3c53fca5c5cd9fea8887949141e5a0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9cbaaf61ade4b91469f3d728795ec83859c25192",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9cbaaf61ade4b91469f3d728795ec83859c25192",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9cbaaf61ade4b91469f3d728795ec83859c25192",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9cbaaf61ade4b91469f3d728795ec83859c25192/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7ea2476c0a5101d8b93abdebb86c1121fa76f3ea",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7ea2476c0a5101d8b93abdebb86c1121fa76f3ea",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7ea2476c0a5101d8b93abdebb86c1121fa76f3ea"
      }
    ],
    "stats": {
      "total": 473,
      "additions": 414,
      "deletions": 59
    },
    "files": [
      {
        "sha": "9c0833df8debb191a00969f4a4071a56eb5d593c",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9cbaaf61ade4b91469f3d728795ec83859c25192/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9cbaaf61ade4b91469f3d728795ec83859c25192/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=9cbaaf61ade4b91469f3d728795ec83859c25192",
        "patch": "@@ -91,6 +91,7 @@ BITCOIN_CORE_H = \\\n   mruset.h \\\n   netbase.h \\\n   net.h \\\n+  netaskfor.h \\\n   noui.h \\\n   pow.h \\\n   protocol.h \\\n@@ -151,6 +152,7 @@ libbitcoin_server_a_SOURCES = \\\n   main.cpp \\\n   miner.cpp \\\n   net.cpp \\\n+  netaskfor.cpp \\\n   noui.cpp \\\n   pow.cpp \\\n   rpcblockchain.cpp \\"
      },
      {
        "sha": "8ac41eb7395af3833745824cf8be76444888d1c7",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9cbaaf61ade4b91469f3d728795ec83859c25192/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9cbaaf61ade4b91469f3d728795ec83859c25192/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=9cbaaf61ade4b91469f3d728795ec83859c25192",
        "patch": "@@ -16,6 +16,7 @@\n #include \"main.h\"\n #include \"miner.h\"\n #include \"net.h\"\n+#include \"netaskfor.h\"\n #include \"rpcserver.h\"\n #include \"txdb.h\"\n #include \"ui_interface.h\"\n@@ -129,6 +130,7 @@ void Shutdown()\n #endif\n     StopNode();\n     UnregisterNodeSignals(GetNodeSignals());\n+    NetAskFor::UnregisterNodeSignals(GetNodeSignals());\n \n     {\n         boost::filesystem::path est_path = GetDataDir() / FEE_ESTIMATES_FILENAME;\n@@ -791,6 +793,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n     // ********************************************************* Step 6: network initialization\n \n     RegisterNodeSignals(GetNodeSignals());\n+    NetAskFor::RegisterNodeSignals(GetNodeSignals());\n \n     if (mapArgs.count(\"-onlynet\")) {\n         std::set<enum Network> nets;"
      },
      {
        "sha": "e660d96da3ae0f1cc62200b464116cff5144027a",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 24,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9cbaaf61ade4b91469f3d728795ec83859c25192/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9cbaaf61ade4b91469f3d728795ec83859c25192/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=9cbaaf61ade4b91469f3d728795ec83859c25192",
        "patch": "@@ -12,6 +12,7 @@\n #include \"checkqueue.h\"\n #include \"init.h\"\n #include \"net.h\"\n+#include \"netaskfor.h\"\n #include \"pow.h\"\n #include \"txdb.h\"\n #include \"txmempool.h\"\n@@ -3656,7 +3657,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                     if (inv.type == MSG_BLOCK)\n                         AddBlockToQueue(pfrom->GetId(), inv.hash);\n                     else\n-                        pfrom->AskFor(inv);\n+                        NetAskFor::AskFor(pfrom, inv);\n                 }\n             } else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash)) {\n                 PushGetBlocks(pfrom, chainActive.Tip(), GetOrphanRoot(inv.hash));\n@@ -3781,14 +3782,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n         CInv inv(MSG_TX, tx.GetHash());\n         pfrom->AddInventoryKnown(inv);\n+        NetAskFor::Completed(pfrom, inv);\n \n         LOCK(cs_main);\n \n         bool fMissingInputs = false;\n         CValidationState state;\n \n-        mapAlreadyAskedFor.erase(inv);\n-\n         if (AcceptToMemoryPool(mempool, state, tx, true, &fMissingInputs))\n         {\n             mempool.check(pcoinsTip);\n@@ -4443,7 +4443,6 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n         // received a (requested) block in one minute, and that all blocks are\n         // in flight for over two minutes, since we first had a chance to\n         // process an incoming block.\n-        int64_t nNow = GetTimeMicros();\n         if (!pto->fDisconnect && state.nBlocksInFlight &&\n             state.nLastBlockReceive < state.nLastBlockProcess - BLOCK_DOWNLOAD_TIMEOUT*1000000 &&\n             state.vBlocksInFlight.front().nTime < state.nLastBlockProcess - 2*BLOCK_DOWNLOAD_TIMEOUT*1000000) {\n@@ -4469,26 +4468,6 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n                 vGetData.clear();\n             }\n         }\n-\n-        //\n-        // Message: getdata (non-blocks)\n-        //\n-        while (!pto->fDisconnect && !pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)\n-        {\n-            const CInv& inv = (*pto->mapAskFor.begin()).second;\n-            if (!AlreadyHave(inv))\n-            {\n-                if (fDebug)\n-                    LogPrint(\"net\", \"Requesting %s peer=%d\\n\", inv.ToString(), pto->id);\n-                vGetData.push_back(inv);\n-                if (vGetData.size() >= 1000)\n-                {\n-                    pto->PushMessage(\"getdata\", vGetData);\n-                    vGetData.clear();\n-                }\n-            }\n-            pto->mapAskFor.erase(pto->mapAskFor.begin());\n-        }\n         if (!vGetData.empty())\n             pto->PushMessage(\"getdata\", vGetData);\n "
      },
      {
        "sha": "b9f3094be56b7ffed6e935e22a0b83481aed029b",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 31,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9cbaaf61ade4b91469f3d728795ec83859c25192/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9cbaaf61ade4b91469f3d728795ec83859c25192/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=9cbaaf61ade4b91469f3d728795ec83859c25192",
        "patch": "@@ -84,7 +84,6 @@ CCriticalSection cs_vNodes;\n map<CInv, CDataStream> mapRelay;\n deque<pair<int64_t, CInv> > vRelayExpiration;\n CCriticalSection cs_mapRelay;\n-limitedmap<CInv, int64_t> mapAlreadyAskedFor(MAX_INV_SZ);\n \n static deque<string> vOneShots;\n CCriticalSection cs_vOneShots;\n@@ -2107,36 +2106,6 @@ CNode::~CNode()\n     GetNodeSignals().FinalizeNode(GetId());\n }\n \n-void CNode::AskFor(const CInv& inv)\n-{\n-    if (mapAskFor.size() > MAPASKFOR_MAX_SZ)\n-        return;\n-    // We're using mapAskFor as a priority queue,\n-    // the key is the earliest time the request can be sent\n-    int64_t nRequestTime;\n-    limitedmap<CInv, int64_t>::const_iterator it = mapAlreadyAskedFor.find(inv);\n-    if (it != mapAlreadyAskedFor.end())\n-        nRequestTime = it->second;\n-    else\n-        nRequestTime = 0;\n-    LogPrint(\"net\", \"askfor %s  %d (%s) peer=%d\\n\", inv.ToString(), nRequestTime, DateTimeStrFormat(\"%H:%M:%S\", nRequestTime/1000000), id);\n-\n-    // Make sure not to reuse time indexes to keep things in the same order\n-    int64_t nNow = GetTimeMicros() - 1000000;\n-    static int64_t nLastTime;\n-    ++nLastTime;\n-    nNow = std::max(nNow, nLastTime);\n-    nLastTime = nNow;\n-\n-    // Each retry is 2 minutes after the last\n-    nRequestTime = std::max(nRequestTime + 2 * 60 * 1000000, nNow);\n-    if (it != mapAlreadyAskedFor.end())\n-        mapAlreadyAskedFor.update(it, nRequestTime);\n-    else\n-        mapAlreadyAskedFor.insert(std::make_pair(inv, nRequestTime));\n-    mapAskFor.insert(std::make_pair(nRequestTime, inv));\n-}\n-\n void CNode::BeginMessage(const char* pszCommand) EXCLUSIVE_LOCK_FUNCTION(cs_vSend)\n {\n     ENTER_CRITICAL_SECTION(cs_vSend);"
      },
      {
        "sha": "0ea29952dfab46f833b2f1ff1fbb1b95fccd6f69",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9cbaaf61ade4b91469f3d728795ec83859c25192/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9cbaaf61ade4b91469f3d728795ec83859c25192/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=9cbaaf61ade4b91469f3d728795ec83859c25192",
        "patch": "@@ -129,7 +129,6 @@ extern CCriticalSection cs_vNodes;\n extern std::map<CInv, CDataStream> mapRelay;\n extern std::deque<std::pair<int64_t, CInv> > vRelayExpiration;\n extern CCriticalSection cs_mapRelay;\n-extern limitedmap<CInv, int64_t> mapAlreadyAskedFor;\n \n extern std::vector<std::string> vAddedNodes;\n extern CCriticalSection cs_vAddedNodes;\n@@ -293,7 +292,6 @@ class CNode\n     mruset<CInv> setInventoryKnown;\n     std::vector<CInv> vInventoryToSend;\n     CCriticalSection cs_inventory;\n-    std::multimap<int64_t, CInv> mapAskFor;\n \n     // Ping time measurement:\n     // The pong reply we're expecting, or 0 if no pong expected.\n@@ -395,8 +393,6 @@ class CNode\n         }\n     }\n \n-    void AskFor(const CInv& inv);\n-\n     // TODO: Document the postcondition of this function.  Is cs_vSend locked?\n     void BeginMessage(const char* pszCommand) EXCLUSIVE_LOCK_FUNCTION(cs_vSend);\n "
      },
      {
        "sha": "6624123221662448bdf4326a4a975d4b2fe23ea9",
        "filename": "src/netaskfor.cpp",
        "status": "added",
        "additions": 360,
        "deletions": 0,
        "changes": 360,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9cbaaf61ade4b91469f3d728795ec83859c25192/src/netaskfor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9cbaaf61ade4b91469f3d728795ec83859c25192/src/netaskfor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaskfor.cpp?ref=9cbaaf61ade4b91469f3d728795ec83859c25192",
        "patch": "@@ -0,0 +1,360 @@\n+// Copyright (c) 2009-2014 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#include \"netaskfor.h\"\n+\n+#include <boost/thread.hpp>\n+\n+#include \"net.h\"\n+#include \"util.h\"\n+\n+/**\n+ * Inventory item request management.\n+ *\n+ * Maintains state separate from CNode.\n+ * There is a two-way mapping between CNodeAskForState and mapInvRequests.\n+ */\n+namespace {\n+\n+/** Node specific state for netaskfor module */\n+class CNodeAskForState\n+{\n+public:\n+    CNodeAskForState(): node(0) {}\n+\n+    /** Set of inv items that are being requested from this node */\n+    std::set<CInv> setAskFor;\n+\n+    /** Group up to 1000 outgoing requests per node */\n+    std::vector<CInv> outgoingRequests;\n+\n+    /** Network connection associated with this node */\n+    CNode *node; /// TODO ugly but needed for sending getdata\n+};\n+\n+typedef std::multimap<int64_t, CInv> InvRequestsWorkQueue;\n+\n+/** State of one inventory item request.\n+ * @note in this structure we store NodeIds instead of CNodeAskForState*, as this\n+ * would double memory usage on 64-bit (on the other hand, that would reduce the number of map\n+ * lookups needed...)\n+ */\n+class CInvState\n+{\n+public:\n+    typedef std::set<NodeId> NodeSet;\n+    /** IDs of nodes that have this item */\n+    NodeSet nodes;\n+    /** IDs of nodes that we have not tried requesting this inv from already */\n+    NodeSet notRequestedFrom;\n+    /** Current node that this is being requested from */\n+    NodeId beingRequestedFrom;\n+    /** Must correspond to current entry in work queue for this\n+     *  inventory item (or invRequestsWorkQueue.end())\n+     */\n+    InvRequestsWorkQueue::iterator workQueueIter;\n+};\n+typedef std::map<CInv, CInvState> MapInvRequests;\n+\n+/** Local data, all protected by cs_invRequests */\n+CCriticalSection cs_invRequests;\n+/** Map node id to local state */\n+std::map<NodeId, CNodeAskForState> mapNodeAskForState;\n+/** Map inv to current request state */\n+MapInvRequests mapInvRequests;\n+/** The work queue keeps track of when is the next time a request needs\n+ * to be revisited.\n+ * @invariant Each request has at most one entry.\n+ * @note Theoretically this could be a deque instead of a map, as we only add to\n+ * the end (assuming monotonic time) and to the beginning (first tries have\n+ * t=0), and remove from the beginning. However std::deque invalidates\n+ * iterators so we cannot keep around an iterator to remove the work queue item\n+ * on cancel.\n+ */\n+InvRequestsWorkQueue invRequestsWorkQueue;\n+CTimeoutCondition condInvRequests;\n+/** Exit thread flag */\n+bool fStopThread;\n+\n+/** Get local state for a node id.\n+ * @note Requires that cs_invRequests is held\n+ */\n+CNodeAskForState *State(NodeId pnode)\n+{\n+    std::map<NodeId, CNodeAskForState>::iterator it = mapNodeAskForState.find(pnode);\n+    if (it == mapNodeAskForState.end())\n+        return NULL;\n+    return &it->second;\n+}\n+\n+/** Handler for when a new node appears */\n+void InitializeNode(NodeId nodeid, const CNode *pnode)\n+{\n+    LOCK(cs_invRequests);\n+    mapNodeAskForState.insert(std::make_pair(nodeid, CNodeAskForState()));\n+}\n+\n+/** Handler to clean up when a node goes away */\n+void FinalizeNode(NodeId nodeid)\n+{\n+    LOCK(cs_invRequests);\n+    CNodeAskForState *state = State(nodeid);\n+    assert(state);\n+\n+    /// Clean up any requests that were underway to the node,\n+    /// or refer to the node.\n+    BOOST_FOREACH(const CInv &inv, state->setAskFor)\n+    {\n+        MapInvRequests::iterator i = mapInvRequests.find(inv);\n+        if (i != mapInvRequests.end())\n+        {\n+            i->second.nodes.erase(nodeid);\n+            i->second.notRequestedFrom.erase(nodeid);\n+\n+            if (i->second.beingRequestedFrom == nodeid)\n+            {\n+                LogPrint(\"netaskfor\", \"%s: Inv item %s was being requested from destructing node %i\\n\",\n+                        __func__,\n+                        inv.ToString(), nodeid);\n+                i->second.beingRequestedFrom = 0;\n+                /// Make sure the old workqueue item for the inv is removed,\n+                /// to avoid spurious retries\n+                if (i->second.workQueueIter != invRequestsWorkQueue.end())\n+                    invRequestsWorkQueue.erase(i->second.workQueueIter);\n+                /// Re-trigger request logic\n+                i->second.workQueueIter = invRequestsWorkQueue.insert(std::make_pair(0, inv));\n+                condInvRequests.notify_one();\n+            }\n+        }\n+    }\n+    mapNodeAskForState.erase(nodeid);\n+}\n+\n+/** Forget a certain inventory item request\n+ * @note requires that cs_invRequests lock is held.\n+ */\n+void Forget(MapInvRequests::iterator i)\n+{\n+    /// Remove reference to this inventory item request from nodes\n+    BOOST_FOREACH(NodeId nodeid, i->second.nodes)\n+    {\n+        CNodeAskForState *state = State(nodeid);\n+        assert(state);\n+        state->setAskFor.erase(i->first);\n+    }\n+    /// Remove from workqueue\n+    if (i->second.workQueueIter != invRequestsWorkQueue.end())\n+        invRequestsWorkQueue.erase(i->second.workQueueIter);\n+    /// Remove from map\n+    mapInvRequests.erase(i);\n+}\n+\n+/** Flushes queued getdatas to a node by id.\n+ * @note requires that cs_invRequests lock is held.\n+ */\n+void FlushGetdata(NodeId nodeid)\n+{\n+    CNodeAskForState *state = State(nodeid);\n+    assert(state && state->node);\n+    CNode *node = state->node;\n+\n+    /// Don't send empty getdatas, ever\n+    if (state->outgoingRequests.empty())\n+        return;\n+\n+    std::stringstream debug;\n+    BOOST_FOREACH(const CInv &inv, state->outgoingRequests)\n+        debug << inv.ToString() << \" \";\n+    LogPrint(\"netaskfor\", \"%s: peer=%i getdata %s\\n\", __func__, nodeid, debug.str());\n+\n+    node->PushMessage(\"getdata\", state->outgoingRequests);\n+    state->outgoingRequests.clear();\n+}\n+\n+/** Queues a getdata to a node by id\n+ * @note requires that cs_invRequests lock is held.\n+ */\n+void QueueGetdata(NodeId nodeid, const CInv &inv, bool isRetry)\n+{\n+    CNodeAskForState *state = State(nodeid);\n+    assert(state);\n+\n+    LogPrint(\"netaskfor\", \"%s: Requesting item %s from node %i (%s)\\n\", __func__,\n+            inv.ToString(), nodeid,\n+            isRetry ? \"retry\" : \"first request\");\n+\n+    state->outgoingRequests.push_back(inv);\n+\n+    /// Make sure a getdata request doesn't contain more than 1000 entries\n+    /// Flush prematurely if this is going to be the case.\n+    if(state->outgoingRequests.size() >= 1000)\n+        FlushGetdata(nodeid);\n+}\n+\n+void ThreadHandleAskFor()\n+{\n+    while (!fStopThread)\n+    {\n+        LogPrint(\"netaskfor\", \"%s: iteration\\n\", __func__);\n+        int64_t timeToNext = std::numeric_limits<int64_t>::max();\n+\n+        {\n+            LOCK(cs_invRequests);\n+            int64_t now = GetTimeMillis();\n+            std::set<NodeId> nodesToFlush;\n+            /// Process work queue entries that are timestamped either now or before now\n+            while (!invRequestsWorkQueue.empty() && invRequestsWorkQueue.begin()->first <= now)\n+            {\n+                const CInv &inv = invRequestsWorkQueue.begin()->second;\n+                MapInvRequests::iterator it = mapInvRequests.find(inv);\n+                LogPrint(\"netaskfor\", \"%s: processing item %s\\n\", __func__, inv.ToString());\n+                if (it != mapInvRequests.end())\n+                {\n+                    CInvState &invstate = it->second;\n+                    invstate.workQueueIter = invRequestsWorkQueue.end();\n+                    /// Pick a node to request from, if available\n+                    ///\n+                    /// Currently this picks the node with the lowest node id\n+                    /// (notRequestedFrom is an ordered set) that offers the item\n+                    /// that we haven't tried yet. This is usually the\n+                    /// longest-connected node that we know to have the data.\n+                    if (invstate.notRequestedFrom.empty())\n+                    {\n+                        LogPrint(\"netaskfor\", \"%s: No more nodes to request item %s from, discarding request\\n\", __func__, inv.ToString());\n+                        Forget(it);\n+                    } else {\n+                        CInvState::NodeSet::iterator first = invstate.notRequestedFrom.begin();\n+                        NodeId nodeid = *first;\n+                        invstate.notRequestedFrom.erase(first);\n+                        invstate.beingRequestedFrom = nodeid;\n+\n+                        QueueGetdata(nodeid, inv, invRequestsWorkQueue.begin()->first != 0);\n+                        nodesToFlush.insert(nodeid);\n+\n+                        /// Need to revisit this request after timeout\n+                        invstate.workQueueIter = invRequestsWorkQueue.insert(std::make_pair(now + NetAskFor::REQUEST_TIMEOUT, inv));\n+                    }\n+                } else {\n+                    LogPrint(\"netaskfor\", \"%s: request for item %s is missing!\\n\", __func__, inv.ToString());\n+                }\n+                invRequestsWorkQueue.erase(invRequestsWorkQueue.begin());\n+            }\n+\n+            /// Send remaining outgoing requests to nodes\n+            /// Not doing this after every iteration could save a few bytes at the\n+            /// expense of delaying getdatas for longer (would need to be taken into\n+            /// account in the timeout logic!).\n+            BOOST_FOREACH(NodeId nodeid, nodesToFlush)\n+                FlushGetdata(nodeid);\n+\n+            /// Compute time to next event\n+            if (!invRequestsWorkQueue.empty())\n+                timeToNext = invRequestsWorkQueue.begin()->first - GetTimeMillis();\n+        }\n+\n+\n+        /// If we don't know how long until next work item, wait until woken up\n+        if (timeToNext == std::numeric_limits<int64_t>::max())\n+        {\n+            LogPrint(\"netaskfor\", \"%s: blocking\\n\", __func__);\n+            condInvRequests.wait();\n+        } else if (timeToNext > 0)\n+        {\n+            LogPrint(\"netaskfor\", \"%s: waiting for %d ms\\n\", __func__, timeToNext);\n+            condInvRequests.timed_wait(timeToNext);\n+        }\n+    }\n+}\n+\n+void StartThreads(boost::thread_group& threadGroup)\n+{\n+    fStopThread = false;\n+    /// Inventory management thread\n+    threadGroup.create_thread(boost::bind(&TraceThread<void (*)()>, \"askfor\", &ThreadHandleAskFor));\n+}\n+\n+void StopThreads()\n+{\n+    fStopThread = true;\n+    condInvRequests.notify_one();\n+}\n+\n+}\n+\n+namespace NetAskFor\n+{\n+\n+void Completed(CNode *node, const CInv& inv)\n+{\n+    /// As soon as this is possible this should be subscribed to the 'tx' P2P\n+    /// message directly, instead of rely on being called from main.\n+    LOCK(cs_invRequests);\n+    MapInvRequests::iterator i = mapInvRequests.find(inv);\n+    if (i != mapInvRequests.end())\n+    {\n+        LogPrint(\"netaskfor\", \"%s: %s peer=%i\\n\", __func__, inv.ToString(), node->GetId());\n+        Forget(i);\n+    } else {\n+        /// This can happen if a node sends a transaction without unannouncing it with 'inv'\n+        /// first, or then we retry a request, which completes (and thus forget about), and then\n+        /// the original node comes back and sends our requested data anyway.\n+        LogPrint(\"netaskfor\", \"%s: %s not found! peer=%i\\n\", __func__, inv.ToString(), node->GetId());\n+    }\n+}\n+\n+void AskFor(CNode *node, const CInv& inv)\n+{\n+    LOCK(cs_invRequests);\n+    NodeId nodeid = node->GetId();\n+    CNodeAskForState *state = State(nodeid);\n+    assert(state);\n+    state->node = node;\n+\n+    /// Bound number of concurrent inventory requests to each node, this has\n+    /// the indirect effect of bounding all data structures.\n+    if (state->setAskFor.size() > MAX_SETASKFOR_SZ)\n+        return;\n+\n+    LogPrint(\"netaskfor\", \"askfor %s  peer=%d\\n\", inv.ToString(), nodeid);\n+\n+    MapInvRequests::iterator it = mapInvRequests.find(inv);\n+    if (it == mapInvRequests.end())\n+    {\n+        std::pair<MapInvRequests::iterator, bool> ins = mapInvRequests.insert(std::make_pair(inv, CInvState()));\n+        it = ins.first;\n+        /// As this is the first time that this item gets announced by anyone, add it to the work queue immediately\n+        it->second.workQueueIter = invRequestsWorkQueue.insert(std::make_pair(0, inv));\n+        condInvRequests.notify_one();\n+    }\n+    std::pair<CInvState::NodeSet::iterator, bool> ins2 = it->second.nodes.insert(nodeid);\n+    if (ins2.second)\n+    {\n+        /// If this is the first time this node announces the inv item, add it to the set of untried nodes\n+        /// for the item.\n+        it->second.notRequestedFrom.insert(nodeid);\n+    }\n+    state->setAskFor.insert(inv);\n+}\n+\n+void RegisterNodeSignals(CNodeSignals& nodeSignals)\n+{\n+    nodeSignals.InitializeNode.connect(&InitializeNode);\n+    nodeSignals.FinalizeNode.connect(&FinalizeNode);\n+    nodeSignals.StartThreads.connect(&StartThreads);\n+    nodeSignals.StopThreads.connect(&StopThreads);\n+}\n+\n+void UnregisterNodeSignals(CNodeSignals& nodeSignals)\n+{\n+    nodeSignals.InitializeNode.disconnect(&InitializeNode);\n+    nodeSignals.FinalizeNode.disconnect(&FinalizeNode);\n+    nodeSignals.StartThreads.disconnect(&StartThreads);\n+    nodeSignals.StopThreads.disconnect(&StopThreads);\n+}\n+\n+};"
      },
      {
        "sha": "1a00eba15a9aabeab3d477a6d0392c8bb524834d",
        "filename": "src/netaskfor.h",
        "status": "added",
        "additions": 46,
        "deletions": 0,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9cbaaf61ade4b91469f3d728795ec83859c25192/src/netaskfor.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9cbaaf61ade4b91469f3d728795ec83859c25192/src/netaskfor.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaskfor.h?ref=9cbaaf61ade4b91469f3d728795ec83859c25192",
        "patch": "@@ -0,0 +1,46 @@\n+// Copyright (c) 2009-2014 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+/** Inventory request management */\n+#ifndef BITCOIN_NETASKFOR_H\n+#define BITCOIN_NETASKFOR_H\n+\n+#include \"protocol.h\"\n+#include \"sync.h\"\n+\n+#include <map>\n+#include <set>\n+\n+class CNode;\n+class CNodeSignals;\n+\n+namespace NetAskFor\n+{\n+/** Retry ask for inventory item to a different node if node doesn't\n+ * respond with data within this time (in ms)\n+ */\n+const int64_t REQUEST_TIMEOUT = 2 * 60 * 1000;\n+\n+/** The maximum number of inv requests that can be in flight from a node */\n+static const unsigned int MAX_SETASKFOR_SZ = 10000;\n+\n+/** Register node signals for inventory request handling */\n+void RegisterNodeSignals(CNodeSignals& nodeSignals);\n+\n+/** Unregister node signals for inventory request handling */\n+void UnregisterNodeSignals(CNodeSignals& nodeSignals);\n+\n+/** Notify that a node owns a certain inventory item,\n+ * also initiate a inventory item request if none exists yet for it.\n+ */\n+void AskFor(CNode *node, const CInv &inv);\n+\n+/** Forget an inventory item request. This must be called from the\n+ *  'tx' message handler.\n+ */\n+void Completed(CNode *node, const CInv &inv);\n+\n+};\n+\n+#endif // BITCOIN_NETASKFOR"
      }
    ]
  }
]