[
  {
    "sha": "c6b4bfb4b3507f1a62290869d7435b0f54032104",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNmI0YmZiNGIzNTA3ZjFhNjIyOTA4NjlkNzQzNWIwZjU0MDMyMTA0",
    "commit": {
      "author": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2020-06-29T09:44:12Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2021-03-08T23:17:56Z"
      },
      "message": "net: Make DNS lookup code testable",
      "tree": {
        "sha": "e6c624a1b2806f63f464052a81e9f36abe62b61d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e6c624a1b2806f63f464052a81e9f36abe62b61d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c6b4bfb4b3507f1a62290869d7435b0f54032104",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6b4bfb4b3507f1a62290869d7435b0f54032104",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c6b4bfb4b3507f1a62290869d7435b0f54032104",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6b4bfb4b3507f1a62290869d7435b0f54032104/comments",
    "author": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a8b0892b743bf5b0bd7192f801fbc6144320052b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a8b0892b743bf5b0bd7192f801fbc6144320052b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a8b0892b743bf5b0bd7192f801fbc6144320052b"
      }
    ],
    "stats": {
      "total": 137,
      "additions": 76,
      "deletions": 61
    },
    "files": [
      {
        "sha": "b95bb05e71f418b03de3d284a46bcf29fc38b521",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 61,
        "deletions": 55,
        "changes": 116,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6b4bfb4b3507f1a62290869d7435b0f54032104/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6b4bfb4b3507f1a62290869d7435b0f54032104/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=c6b4bfb4b3507f1a62290869d7435b0f54032104",
        "patch": "@@ -42,6 +42,50 @@ bool fNameLookup = DEFAULT_NAME_LOOKUP;\n int g_socks5_recv_timeout = 20 * 1000;\n static std::atomic<bool> interruptSocks5Recv(false);\n \n+std::vector<CNetAddr> WrappedGetAddrInfo(const std::string& name, bool allow_lookup)\n+{\n+    addrinfo ai_hint{};\n+    // We want a TCP port, which is a streaming socket type\n+    ai_hint.ai_socktype = SOCK_STREAM;\n+    ai_hint.ai_protocol = IPPROTO_TCP;\n+    // We don't care which address family (IPv4 or IPv6) is returned\n+    ai_hint.ai_family = AF_UNSPEC;\n+    // If we allow lookups of hostnames, use the AI_ADDRCONFIG flag to only\n+    // return addresses whose family we have an address configured for.\n+    //\n+    // If we don't allow lookups, then use the AI_NUMERICHOST flag for\n+    // getaddrinfo to only decode numerical network addresses and suppress\n+    // hostname lookups.\n+    ai_hint.ai_flags = allow_lookup ? AI_ADDRCONFIG : AI_NUMERICHOST;\n+\n+    addrinfo* ai_res{nullptr};\n+    const int n_err{getaddrinfo(name.c_str(), nullptr, &ai_hint, &ai_res)};\n+    if (n_err != 0) {\n+        return {};\n+    }\n+\n+    // Traverse the linked list starting with ai_trav.\n+    addrinfo* ai_trav{ai_res};\n+    std::vector<CNetAddr> resolved_addresses;\n+    while (ai_trav != nullptr) {\n+        if (ai_trav->ai_family == AF_INET) {\n+            assert(ai_trav->ai_addrlen >= sizeof(sockaddr_in));\n+            resolved_addresses.emplace_back(reinterpret_cast<sockaddr_in*>(ai_trav->ai_addr)->sin_addr);\n+        }\n+        if (ai_trav->ai_family == AF_INET6) {\n+            assert(ai_trav->ai_addrlen >= sizeof(sockaddr_in6));\n+            const sockaddr_in6* s6{reinterpret_cast<sockaddr_in6*>(ai_trav->ai_addr)};\n+            resolved_addresses.emplace_back(s6->sin6_addr, s6->sin6_scope_id);\n+        }\n+        ai_trav = ai_trav->ai_next;\n+    }\n+    freeaddrinfo(ai_res);\n+\n+    return resolved_addresses;\n+}\n+\n+DNSLookupFn g_dns_lookup{WrappedGetAddrInfo};\n+\n enum Network ParseNetwork(const std::string& net_in) {\n     std::string net = ToLower(net_in);\n     if (net == \"ipv4\") return NET_IPV4;\n@@ -87,7 +131,7 @@ std::vector<std::string> GetNetworkNames(bool append_unroutable)\n     return names;\n }\n \n-bool static LookupIntern(const std::string& name, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n+static bool LookupIntern(const std::string& name, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup, DNSLookupFn dns_lookup_function)\n {\n     vIP.clear();\n \n@@ -109,54 +153,16 @@ bool static LookupIntern(const std::string& name, std::vector<CNetAddr>& vIP, un\n         }\n     }\n \n-    struct addrinfo aiHint;\n-    memset(&aiHint, 0, sizeof(struct addrinfo));\n-\n-    // We want a TCP port, which is a streaming socket type\n-    aiHint.ai_socktype = SOCK_STREAM;\n-    aiHint.ai_protocol = IPPROTO_TCP;\n-    // We don't care which address family (IPv4 or IPv6) is returned\n-    aiHint.ai_family = AF_UNSPEC;\n-    // If we allow lookups of hostnames, use the AI_ADDRCONFIG flag to only\n-    // return addresses whose family we have an address configured for.\n-    //\n-    // If we don't allow lookups, then use the AI_NUMERICHOST flag for\n-    // getaddrinfo to only decode numerical network addresses and suppress\n-    // hostname lookups.\n-    aiHint.ai_flags = fAllowLookup ? AI_ADDRCONFIG : AI_NUMERICHOST;\n-    struct addrinfo *aiRes = nullptr;\n-    int nErr = getaddrinfo(name.c_str(), nullptr, &aiHint, &aiRes);\n-    if (nErr)\n-        return false;\n-\n-    // Traverse the linked list starting with aiTrav, add all non-internal\n-    // IPv4,v6 addresses to vIP while respecting nMaxSolutions.\n-    struct addrinfo *aiTrav = aiRes;\n-    while (aiTrav != nullptr && (nMaxSolutions == 0 || vIP.size() < nMaxSolutions))\n-    {\n-        CNetAddr resolved;\n-        if (aiTrav->ai_family == AF_INET)\n-        {\n-            assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in));\n-            resolved = CNetAddr(((struct sockaddr_in*)(aiTrav->ai_addr))->sin_addr);\n-        }\n-\n-        if (aiTrav->ai_family == AF_INET6)\n-        {\n-            assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in6));\n-            struct sockaddr_in6* s6 = (struct sockaddr_in6*) aiTrav->ai_addr;\n-            resolved = CNetAddr(s6->sin6_addr, s6->sin6_scope_id);\n+    for (const CNetAddr& resolved : dns_lookup_function(name, fAllowLookup)) {\n+        if (nMaxSolutions > 0 && vIP.size() >= nMaxSolutions) {\n+            break;\n         }\n         /* Never allow resolving to an internal address. Consider any such result invalid */\n         if (!resolved.IsInternal()) {\n             vIP.push_back(resolved);\n         }\n-\n-        aiTrav = aiTrav->ai_next;\n     }\n \n-    freeaddrinfo(aiRes);\n-\n     return (vIP.size() > 0);\n }\n \n@@ -175,7 +181,7 @@ bool static LookupIntern(const std::string& name, std::vector<CNetAddr>& vIP, un\n  * @see Lookup(const char *, std::vector<CService>&, int, bool, unsigned int)\n  *      for additional parameter descriptions.\n  */\n-bool LookupHost(const std::string& name, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n+bool LookupHost(const std::string& name, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup, DNSLookupFn dns_lookup_function)\n {\n     if (!ValidAsCString(name)) {\n         return false;\n@@ -187,7 +193,7 @@ bool LookupHost(const std::string& name, std::vector<CNetAddr>& vIP, unsigned in\n         strHost = strHost.substr(1, strHost.size() - 2);\n     }\n \n-    return LookupIntern(strHost, vIP, nMaxSolutions, fAllowLookup);\n+    return LookupIntern(strHost, vIP, nMaxSolutions, fAllowLookup, dns_lookup_function);\n }\n \n  /**\n@@ -196,13 +202,13 @@ bool LookupHost(const std::string& name, std::vector<CNetAddr>& vIP, unsigned in\n  * @see LookupHost(const std::string&, std::vector<CNetAddr>&, unsigned int, bool) for\n  *      additional parameter descriptions.\n  */\n-bool LookupHost(const std::string& name, CNetAddr& addr, bool fAllowLookup)\n+bool LookupHost(const std::string& name, CNetAddr& addr, bool fAllowLookup, DNSLookupFn dns_lookup_function)\n {\n     if (!ValidAsCString(name)) {\n         return false;\n     }\n     std::vector<CNetAddr> vIP;\n-    LookupHost(name, vIP, 1, fAllowLookup);\n+    LookupHost(name, vIP, 1, fAllowLookup, dns_lookup_function);\n     if(vIP.empty())\n         return false;\n     addr = vIP.front();\n@@ -229,7 +235,7 @@ bool LookupHost(const std::string& name, CNetAddr& addr, bool fAllowLookup)\n  * @returns Whether or not the service string successfully resolved to any\n  *          resulting services.\n  */\n-bool Lookup(const std::string& name, std::vector<CService>& vAddr, int portDefault, bool fAllowLookup, unsigned int nMaxSolutions)\n+bool Lookup(const std::string& name, std::vector<CService>& vAddr, int portDefault, bool fAllowLookup, unsigned int nMaxSolutions, DNSLookupFn dns_lookup_function)\n {\n     if (name.empty() || !ValidAsCString(name)) {\n         return false;\n@@ -239,7 +245,7 @@ bool Lookup(const std::string& name, std::vector<CService>& vAddr, int portDefau\n     SplitHostPort(name, port, hostname);\n \n     std::vector<CNetAddr> vIP;\n-    bool fRet = LookupIntern(hostname, vIP, nMaxSolutions, fAllowLookup);\n+    bool fRet = LookupIntern(hostname, vIP, nMaxSolutions, fAllowLookup, dns_lookup_function);\n     if (!fRet)\n         return false;\n     vAddr.resize(vIP.size());\n@@ -254,13 +260,13 @@ bool Lookup(const std::string& name, std::vector<CService>& vAddr, int portDefau\n  * @see Lookup(const char *, std::vector<CService>&, int, bool, unsigned int)\n  *      for additional parameter descriptions.\n  */\n-bool Lookup(const std::string& name, CService& addr, int portDefault, bool fAllowLookup)\n+bool Lookup(const std::string& name, CService& addr, int portDefault, bool fAllowLookup, DNSLookupFn dns_lookup_function)\n {\n     if (!ValidAsCString(name)) {\n         return false;\n     }\n     std::vector<CService> vService;\n-    bool fRet = Lookup(name, vService, portDefault, fAllowLookup, 1);\n+    bool fRet = Lookup(name, vService, portDefault, fAllowLookup, 1, dns_lookup_function);\n     if (!fRet)\n         return false;\n     addr = vService[0];\n@@ -277,15 +283,15 @@ bool Lookup(const std::string& name, CService& addr, int portDefault, bool fAllo\n  * @see Lookup(const char *, CService&, int, bool) for additional parameter\n  *      descriptions.\n  */\n-CService LookupNumeric(const std::string& name, int portDefault)\n+CService LookupNumeric(const std::string& name, int portDefault, DNSLookupFn dns_lookup_function)\n {\n     if (!ValidAsCString(name)) {\n         return {};\n     }\n     CService addr;\n     // \"1.2:345\" will fail to resolve the ip, but will still set the port.\n     // If the ip fails to resolve, re-init the result.\n-    if(!Lookup(name, addr, portDefault, false))\n+    if(!Lookup(name, addr, portDefault, false, dns_lookup_function))\n         addr = CService();\n     return addr;\n }\n@@ -811,7 +817,7 @@ bool ConnectThroughProxy(const proxyType& proxy, const std::string& strDest, int\n  *\n  * @returns Whether the operation succeeded or not.\n  */\n-bool LookupSubNet(const std::string& strSubnet, CSubNet& ret)\n+bool LookupSubNet(const std::string& strSubnet, CSubNet& ret, DNSLookupFn dns_lookup_function)\n {\n     if (!ValidAsCString(strSubnet)) {\n         return false;\n@@ -822,7 +828,7 @@ bool LookupSubNet(const std::string& strSubnet, CSubNet& ret)\n     std::string strAddress = strSubnet.substr(0, slash);\n     // TODO: Use LookupHost(const std::string&, CNetAddr&, bool) instead to just get\n     //       one CNetAddr.\n-    if (LookupHost(strAddress, vIP, 1, false))\n+    if (LookupHost(strAddress, vIP, 1, false, dns_lookup_function))\n     {\n         CNetAddr network = vIP[0];\n         if (slash != strSubnet.npos)\n@@ -837,7 +843,7 @@ bool LookupSubNet(const std::string& strSubnet, CSubNet& ret)\n             else // If not a valid number, try full netmask syntax\n             {\n                 // Never allow lookup for netmask\n-                if (LookupHost(strNetmask, vIP, 1, false)) {\n+                if (LookupHost(strNetmask, vIP, 1, false, dns_lookup_function)) {\n                     ret = CSubNet(network, vIP[0]);\n                     return ret.IsValid();\n                 }"
      },
      {
        "sha": "227da1a63b34e964794637d59dd7c520a323f1e1",
        "filename": "src/netbase.h",
        "status": "modified",
        "additions": 15,
        "deletions": 6,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6b4bfb4b3507f1a62290869d7435b0f54032104/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6b4bfb4b3507f1a62290869d7435b0f54032104/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=c6b4bfb4b3507f1a62290869d7435b0f54032104",
        "patch": "@@ -64,6 +64,11 @@ struct ProxyCredentials\n     std::string password;\n };\n \n+/**\n+ * Wrapper for getaddrinfo(3). Do not use directly: call Lookup/LookupHost/LookupNumeric/LookupSubNet.\n+ */\n+std::vector<CNetAddr> WrappedGetAddrInfo(const std::string& name, bool allow_lookup);\n+\n enum Network ParseNetwork(const std::string& net);\n std::string GetNetworkName(enum Network net);\n /** Return a vector of publicly routable Network names; optionally append NET_UNROUTABLE. */\n@@ -74,12 +79,16 @@ bool IsProxy(const CNetAddr &addr);\n bool SetNameProxy(const proxyType &addrProxy);\n bool HaveNameProxy();\n bool GetNameProxy(proxyType &nameProxyOut);\n-bool LookupHost(const std::string& name, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup);\n-bool LookupHost(const std::string& name, CNetAddr& addr, bool fAllowLookup);\n-bool Lookup(const std::string& name, CService& addr, int portDefault, bool fAllowLookup);\n-bool Lookup(const std::string& name, std::vector<CService>& vAddr, int portDefault, bool fAllowLookup, unsigned int nMaxSolutions);\n-CService LookupNumeric(const std::string& name, int portDefault = 0);\n-bool LookupSubNet(const std::string& strSubnet, CSubNet& subnet);\n+\n+using DNSLookupFn = std::function<std::vector<CNetAddr>(const std::string&, bool)>;\n+extern DNSLookupFn g_dns_lookup;\n+\n+bool LookupHost(const std::string& name, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup, DNSLookupFn dns_lookup_function = g_dns_lookup);\n+bool LookupHost(const std::string& name, CNetAddr& addr, bool fAllowLookup, DNSLookupFn dns_lookup_function = g_dns_lookup);\n+bool Lookup(const std::string& name, CService& addr, int portDefault, bool fAllowLookup, DNSLookupFn dns_lookup_function = g_dns_lookup);\n+bool Lookup(const std::string& name, std::vector<CService>& vAddr, int portDefault, bool fAllowLookup, unsigned int nMaxSolutions, DNSLookupFn dns_lookup_function = g_dns_lookup);\n+CService LookupNumeric(const std::string& name, int portDefault = 0, DNSLookupFn dns_lookup_function = g_dns_lookup);\n+bool LookupSubNet(const std::string& strSubnet, CSubNet& subnet, DNSLookupFn dns_lookup_function = g_dns_lookup);\n \n /**\n  * Create a TCP socket in the given address family."
      }
    ]
  },
  {
    "sha": "e5280751890b02abb558b37eb0e0401493f148b4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNTI4MDc1MTg5MGIwMmFiYjU1OGIzN2ViMGUwNDAxNDkzZjE0OGI0",
    "commit": {
      "author": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2020-06-29T22:11:13Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2021-03-08T23:17:56Z"
      },
      "message": "tests: Add fuzzing harness for Lookup(...)/LookupHost(...)/LookupNumeric(...)/LookupSubNet(...)",
      "tree": {
        "sha": "c6319d6a03d18b95d413bd14fb2ca230afb8820e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c6319d6a03d18b95d413bd14fb2ca230afb8820e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e5280751890b02abb558b37eb0e0401493f148b4",
      "comment_count": 1,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e5280751890b02abb558b37eb0e0401493f148b4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e5280751890b02abb558b37eb0e0401493f148b4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e5280751890b02abb558b37eb0e0401493f148b4/comments",
    "author": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c6b4bfb4b3507f1a62290869d7435b0f54032104",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6b4bfb4b3507f1a62290869d7435b0f54032104",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c6b4bfb4b3507f1a62290869d7435b0f54032104"
      }
    ],
    "stats": {
      "total": 78,
      "additions": 78,
      "deletions": 0
    },
    "files": [
      {
        "sha": "625d825259368a9f17ae29c307d94c3c1c2ccafd",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e5280751890b02abb558b37eb0e0401493f148b4/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e5280751890b02abb558b37eb0e0401493f148b4/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=e5280751890b02abb558b37eb0e0401493f148b4",
        "patch": "@@ -252,6 +252,7 @@ test_fuzz_fuzz_SOURCES = \\\n  test/fuzz/net.cpp \\\n  test/fuzz/net_permissions.cpp \\\n  test/fuzz/netaddress.cpp \\\n+ test/fuzz/netbase_dns_lookup.cpp \\\n  test/fuzz/node_eviction.cpp \\\n  test/fuzz/p2p_transport_deserializer.cpp \\\n  test/fuzz/parse_hd_keypath.cpp \\"
      },
      {
        "sha": "786440c8a45678e920fd6da7a5a32b1e2c3df9ed",
        "filename": "src/test/fuzz/netbase_dns_lookup.cpp",
        "status": "added",
        "additions": 77,
        "deletions": 0,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e5280751890b02abb558b37eb0e0401493f148b4/src/test/fuzz/netbase_dns_lookup.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e5280751890b02abb558b37eb0e0401493f148b4/src/test/fuzz/netbase_dns_lookup.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/netbase_dns_lookup.cpp?ref=e5280751890b02abb558b37eb0e0401493f148b4",
        "patch": "@@ -0,0 +1,77 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+FuzzedDataProvider* fuzzed_data_provider_ptr = nullptr;\n+\n+std::vector<CNetAddr> fuzzed_dns_lookup_function(const std::string& name, bool allow_lookup)\n+{\n+    std::vector<CNetAddr> resolved_addresses;\n+    while (fuzzed_data_provider_ptr->ConsumeBool()) {\n+        resolved_addresses.push_back(ConsumeNetAddr(*fuzzed_data_provider_ptr));\n+    }\n+    return resolved_addresses;\n+}\n+} // namespace\n+\n+FUZZ_TARGET(netbase_dns_lookup)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    fuzzed_data_provider_ptr = &fuzzed_data_provider;\n+    const std::string name = fuzzed_data_provider.ConsumeRandomLengthString(512);\n+    const unsigned int max_results = fuzzed_data_provider.ConsumeIntegral<unsigned int>();\n+    const bool allow_lookup = fuzzed_data_provider.ConsumeBool();\n+    const int default_port = fuzzed_data_provider.ConsumeIntegral<int>();\n+    {\n+        std::vector<CNetAddr> resolved_addresses;\n+        if (LookupHost(name, resolved_addresses, max_results, allow_lookup, fuzzed_dns_lookup_function)) {\n+            for (const CNetAddr& resolved_address : resolved_addresses) {\n+                assert(!resolved_address.IsInternal());\n+            }\n+        }\n+        assert(resolved_addresses.size() <= max_results || max_results == 0);\n+    }\n+    {\n+        CNetAddr resolved_address;\n+        if (LookupHost(name, resolved_address, allow_lookup, fuzzed_dns_lookup_function)) {\n+            assert(!resolved_address.IsInternal());\n+        }\n+    }\n+    {\n+        std::vector<CService> resolved_services;\n+        if (Lookup(name, resolved_services, default_port, allow_lookup, max_results, fuzzed_dns_lookup_function)) {\n+            for (const CNetAddr& resolved_service : resolved_services) {\n+                assert(!resolved_service.IsInternal());\n+            }\n+        }\n+        assert(resolved_services.size() <= max_results || max_results == 0);\n+    }\n+    {\n+        CService resolved_service;\n+        if (Lookup(name, resolved_service, default_port, allow_lookup, fuzzed_dns_lookup_function)) {\n+            assert(!resolved_service.IsInternal());\n+        }\n+    }\n+    {\n+        CService resolved_service = LookupNumeric(name, default_port, fuzzed_dns_lookup_function);\n+        assert(!resolved_service.IsInternal());\n+    }\n+    {\n+        CSubNet resolved_subnet;\n+        if (LookupSubNet(name, resolved_subnet, fuzzed_dns_lookup_function)) {\n+            assert(resolved_subnet.IsValid());\n+        }\n+    }\n+    fuzzed_data_provider_ptr = nullptr;\n+}"
      }
    ]
  }
]