[
  {
    "sha": "1ee07b5e207771f68b1686804c3eb474f7f6648f",
    "node_id": "C_kwDOABII59oAKDFlZTA3YjVlMjA3NzcxZjY4YjE2ODY4MDRjM2ViNDc0ZjdmNjY0OGY",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2020-03-29T20:28:35Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-10-25T09:27:30Z"
      },
      "message": "test: Limit scope of id global which is shared between subtests\n\nThis is needed to use ASSERT_DEBUG_LOG, which may include a fixed node\nnumber",
      "tree": {
        "sha": "ccda0e58c4f6d4b6eedc1f798096c6e7be2624e5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ccda0e58c4f6d4b6eedc1f798096c6e7be2624e5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1ee07b5e207771f68b1686804c3eb474f7f6648f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1ee07b5e207771f68b1686804c3eb474f7f6648f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1ee07b5e207771f68b1686804c3eb474f7f6648f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1ee07b5e207771f68b1686804c3eb474f7f6648f/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "224e90d9fdf895d3ee212edcf7dec3eb4d94ce91",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/224e90d9fdf895d3ee212edcf7dec3eb4d94ce91",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/224e90d9fdf895d3ee212edcf7dec3eb4d94ce91"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 4,
      "deletions": 2
    },
    "files": [
      {
        "sha": "2f6b82d84b1826f7212be0c3cadff0c08d948e63",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ee07b5e207771f68b1686804c3eb474f7f6648f/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ee07b5e207771f68b1686804c3eb474f7f6648f/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=1ee07b5e207771f68b1686804c3eb474f7f6648f",
        "patch": "@@ -34,8 +34,6 @@ static CService ip(uint32_t i)\n     return CService(CNetAddr(s), Params().GetDefaultPort());\n }\n \n-static NodeId id = 0;\n-\n void UpdateLastBlockAnnounceTime(NodeId node, int64_t time_in_seconds);\n \n BOOST_FIXTURE_TEST_SUITE(denialofservice_tests, TestingSetup)\n@@ -59,6 +57,7 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n \n     // Mock an outbound peer\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n+    static NodeId id = 0;\n     CNode dummyNode1(id++, ServiceFlags(NODE_NETWORK | NODE_WITNESS), INVALID_SOCKET, addr1, /* nKeyedNetGroupIn */ 0, /* nLocalHostNonceIn */ 0, CAddress(), /* pszDest */ \"\", ConnectionType::OUTBOUND_FULL_RELAY, /* inbound_onion */ false);\n     dummyNode1.SetCommonVersion(PROTOCOL_VERSION);\n \n@@ -108,6 +107,7 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n static void AddRandomOutboundPeer(std::vector<CNode*>& vNodes, PeerManager& peerLogic, ConnmanTestMsg& connman)\n {\n     CAddress addr(ip(g_insecure_rand_ctx.randbits(32)), NODE_NONE);\n+    static NodeId id = 0;\n     vNodes.emplace_back(new CNode(id++, ServiceFlags(NODE_NETWORK | NODE_WITNESS), INVALID_SOCKET, addr, /* nKeyedNetGroupIn */ 0, /* nLocalHostNonceIn */ 0, CAddress(), /* pszDest */ \"\", ConnectionType::OUTBOUND_FULL_RELAY, /* inbound_onion */ false));\n     CNode &node = *vNodes.back();\n     node.SetCommonVersion(PROTOCOL_VERSION);\n@@ -212,6 +212,7 @@ BOOST_AUTO_TEST_CASE(peer_discouragement)\n     std::array<CNode*, 3> nodes;\n \n     banman->ClearBanned();\n+    static NodeId id = 0;\n     nodes[0] = new CNode{id++, NODE_NETWORK, INVALID_SOCKET, addr[0], /* nKeyedNetGroupIn */ 0,\n                          /* nLocalHostNonceIn */ 0, CAddress(), /* pszDest */ \"\",\n                          ConnectionType::INBOUND, /* inbound_onion */ false};\n@@ -297,6 +298,7 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     SetMockTime(nStartTime); // Overrides future calls to GetTime()\n \n     CAddress addr(ip(0xa0b0c001), NODE_NONE);\n+    static NodeId id = 0;\n     CNode dummyNode(id++, NODE_NETWORK, INVALID_SOCKET, addr, /* nKeyedNetGroupIn */ 4, /* nLocalHostNonceIn */ 4, CAddress(), /* pszDest */ \"\", ConnectionType::INBOUND, /* inbound_onion */ false);\n     dummyNode.SetCommonVersion(PROTOCOL_VERSION);\n     peerLogic->InitializeNode(&dummyNode);"
      }
    ]
  },
  {
    "sha": "67cc933c366913813f4dbd605014a640a229ca41",
    "node_id": "C_kwDOABII59oAKDY3Y2M5MzNjMzY2OTEzODEzZjRkYmQ2MDUwMTRhNjQwYTIyOWNhNDE",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2020-03-29T20:49:32Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-10-25T09:28:42Z"
      },
      "message": "net: Make stale tip check time type-safe, extend test\n\n* GetTime is the non-type-safe and deprecated version of GetTime<>\n* Extend test with ASSERT_DEBUG_LOG\n* Extend test with case where a block is in flight from a node that is\n  about to be evicted",
      "tree": {
        "sha": "2e5911c3cad0fd9472ab2490dfab644cdde67dd8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2e5911c3cad0fd9472ab2490dfab644cdde67dd8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/67cc933c366913813f4dbd605014a640a229ca41",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/67cc933c366913813f4dbd605014a640a229ca41",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/67cc933c366913813f4dbd605014a640a229ca41",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/67cc933c366913813f4dbd605014a640a229ca41/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1ee07b5e207771f68b1686804c3eb474f7f6648f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1ee07b5e207771f68b1686804c3eb474f7f6648f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1ee07b5e207771f68b1686804c3eb474f7f6648f"
      }
    ],
    "stats": {
      "total": 157,
      "additions": 123,
      "deletions": 34
    },
    "files": [
      {
        "sha": "76c13ea7f186c6360c4599bbd6f385fc3e220f39",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 23,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67cc933c366913813f4dbd605014a640a229ca41/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67cc933c366913813f4dbd605014a640a229ca41/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=67cc933c366913813f4dbd605014a640a229ca41",
        "patch": "@@ -57,12 +57,12 @@ static constexpr auto HEADERS_DOWNLOAD_TIMEOUT_PER_HEADER = 1ms;\n static constexpr int32_t MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT = 4;\n /** Timeout for (unprotected) outbound peers to sync to our chainwork, in seconds */\n static constexpr int64_t CHAIN_SYNC_TIMEOUT = 20 * 60; // 20 minutes\n-/** How frequently to check for stale tips, in seconds */\n-static constexpr int64_t STALE_CHECK_INTERVAL = 10 * 60; // 10 minutes\n-/** How frequently to check for extra outbound peers and disconnect, in seconds */\n-static constexpr int64_t EXTRA_PEER_CHECK_INTERVAL = 45;\n-/** Minimum time an outbound-peer-eviction candidate must be connected for, in order to evict, in seconds */\n-static constexpr int64_t MINIMUM_CONNECT_TIME = 30;\n+/** How frequently to check for stale tips */\n+static constexpr std::chrono::minutes STALE_CHECK_INTERVAL{10};\n+/** How frequently to check for extra outbound peers and disconnect */\n+static constexpr std::chrono::seconds EXTRA_PEER_CHECK_INTERVAL{45};\n+/** Minimum time an outbound-peer-eviction candidate must be connected for, in order to evict */\n+static constexpr std::chrono::seconds MINIMUM_CONNECT_TIME{30};\n /** SHA256(\"main address relay\")[0:8] */\n static constexpr uint64_t RANDOMIZER_ID_ADDRESS_RELAY = 0x3cac0035b5866b90ULL;\n /// Age after which a stale block will no longer be served if requested as\n@@ -329,7 +329,7 @@ class PeerManagerImpl final : public PeerManager\n     void ConsiderEviction(CNode& pto, int64_t time_in_seconds) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     /** If we have extra outbound peers, try to disconnect the one with the oldest block announcement */\n-    void EvictExtraOutboundPeers(int64_t time_in_seconds) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    void EvictExtraOutboundPeers(std::chrono::seconds time) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     /** Retrieve unbroadcast transactions from the mempool and reattempt sending to peers */\n     void ReattemptInitialBroadcast(CScheduler& scheduler);\n@@ -421,7 +421,7 @@ class PeerManagerImpl final : public PeerManager\n     std::atomic<int> m_best_height{-1};\n \n     /** Next time to check for stale tip */\n-    int64_t m_stale_tip_check_time{0};\n+    std::chrono::seconds m_stale_tip_check_time{0};\n \n     /** Whether this node is running in blocks only mode */\n     const bool m_ignore_incoming_txs;\n@@ -540,7 +540,7 @@ class PeerManagerImpl final : public PeerManager\n     std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> > mapBlocksInFlight GUARDED_BY(cs_main);\n \n     /** When our tip was last updated. */\n-    std::atomic<int64_t> m_last_tip_update{0};\n+    std::atomic<std::chrono::seconds> m_last_tip_update{0s};\n \n     /** Determine whether or not a peer can request a transaction, and return it (or nullptr if not found or not allowed). */\n     CTransactionRef FindTxForGetData(const CNode& peer, const GenTxid& gtxid, const std::chrono::seconds mempool_req, const std::chrono::seconds now) LOCKS_EXCLUDED(cs_main);\n@@ -946,10 +946,10 @@ bool PeerManagerImpl::TipMayBeStale()\n {\n     AssertLockHeld(cs_main);\n     const Consensus::Params& consensusParams = m_chainparams.GetConsensus();\n-    if (m_last_tip_update == 0) {\n-        m_last_tip_update = GetTime();\n+    if (m_last_tip_update.load().count() == 0) {\n+        m_last_tip_update = GetTime<std::chrono::seconds>();\n     }\n-    return m_last_tip_update < GetTime() - consensusParams.nPowTargetSpacing * 3 && mapBlocksInFlight.empty();\n+    return m_last_tip_update.load() < GetTime<std::chrono::seconds>() - std::chrono::seconds{consensusParams.nPowTargetSpacing} * 3 && mapBlocksInFlight.empty();\n }\n \n bool PeerManagerImpl::CanDirectFetch()\n@@ -1150,6 +1150,7 @@ void UpdateLastBlockAnnounceTime(NodeId node, int64_t time_in_seconds)\n     LOCK(cs_main);\n     CNodeState *state = State(node);\n     if (state) state->m_last_block_announcement = time_in_seconds;\n+    if (state) state->fHaveWitness = true;\n }\n \n void PeerManagerImpl::InitializeNode(CNode *pnode)\n@@ -1453,7 +1454,7 @@ void PeerManagerImpl::StartScheduledTasks(CScheduler& scheduler)\n     // combine them in one function and schedule at the quicker (peer-eviction)\n     // timer.\n     static_assert(EXTRA_PEER_CHECK_INTERVAL < STALE_CHECK_INTERVAL, \"peer eviction timer should be less than stale tip check timer\");\n-    scheduler.scheduleEvery([this] { this->CheckForStaleTipAndEvictPeers(); }, std::chrono::seconds{EXTRA_PEER_CHECK_INTERVAL});\n+    scheduler.scheduleEvery([this] { this->CheckForStaleTipAndEvictPeers(); }, EXTRA_PEER_CHECK_INTERVAL);\n \n     // schedule next run for 10-15 minutes in the future\n     const std::chrono::milliseconds delta = std::chrono::minutes{10} + GetRandMillis(std::chrono::minutes{5});\n@@ -1468,7 +1469,7 @@ void PeerManagerImpl::StartScheduledTasks(CScheduler& scheduler)\n void PeerManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindex)\n {\n     m_orphanage.EraseForBlock(*pblock);\n-    m_last_tip_update = GetTime();\n+    m_last_tip_update = GetTime<std::chrono::seconds>();\n \n     {\n         LOCK(m_recent_confirmed_transactions_mutex);\n@@ -4184,7 +4185,7 @@ void PeerManagerImpl::ConsiderEviction(CNode& pto, int64_t time_in_seconds)\n     }\n }\n \n-void PeerManagerImpl::EvictExtraOutboundPeers(int64_t time_in_seconds)\n+void PeerManagerImpl::EvictExtraOutboundPeers(std::chrono::seconds time)\n {\n     // If we have any extra block-relay-only peers, disconnect the youngest unless\n     // it's given us a block -- in which case, compare with the second-youngest, and\n@@ -4218,7 +4219,7 @@ void PeerManagerImpl::EvictExtraOutboundPeers(int64_t time_in_seconds)\n             // valid headers chain with at least as much work as our tip.\n             CNodeState *node_state = State(pnode->GetId());\n             if (node_state == nullptr ||\n-                (time_in_seconds - pnode->nTimeConnected >= MINIMUM_CONNECT_TIME && node_state->nBlocksInFlight == 0)) {\n+                (time - std::chrono::seconds{pnode->nTimeConnected} >= MINIMUM_CONNECT_TIME && node_state->nBlocksInFlight == 0)) {\n                 pnode->fDisconnect = true;\n                 LogPrint(BCLog::NET, \"disconnecting extra block-relay-only peer=%d (last block received at time %d)\\n\", pnode->GetId(), pnode->nLastBlockTime);\n                 return true;\n@@ -4263,8 +4264,8 @@ void PeerManagerImpl::EvictExtraOutboundPeers(int64_t time_in_seconds)\n                 // it time for new information to have arrived.\n                 // Also don't disconnect any peer we're trying to download a\n                 // block from.\n-                CNodeState &state = *State(pnode->GetId());\n-                if (time_in_seconds - pnode->nTimeConnected > MINIMUM_CONNECT_TIME && state.nBlocksInFlight == 0) {\n+                CNodeState& state = *State(pnode->GetId());\n+                if (time - std::chrono::seconds{pnode->nTimeConnected} > MINIMUM_CONNECT_TIME && state.nBlocksInFlight == 0) {\n                     LogPrint(BCLog::NET, \"disconnecting extra outbound peer=%d (last block announcement received at time %d)\\n\", pnode->GetId(), oldest_block_announcement);\n                     pnode->fDisconnect = true;\n                     return true;\n@@ -4289,20 +4290,20 @@ void PeerManagerImpl::CheckForStaleTipAndEvictPeers()\n {\n     LOCK(cs_main);\n \n-    int64_t time_in_seconds = GetTime();\n+    const auto time = GetTime<std::chrono::seconds>();\n \n-    EvictExtraOutboundPeers(time_in_seconds);\n+    EvictExtraOutboundPeers(time);\n \n-    if (time_in_seconds > m_stale_tip_check_time) {\n+    if (time > m_stale_tip_check_time) {\n         // Check whether our tip is stale, and if so, allow using an extra\n         // outbound peer\n         if (!fImporting && !fReindex && m_connman.GetNetworkActive() && m_connman.GetUseAddrmanOutgoing() && TipMayBeStale()) {\n-            LogPrintf(\"Potential stale tip detected, will try using extra outbound peer (last tip update: %d seconds ago)\\n\", time_in_seconds - m_last_tip_update);\n+            LogPrintf(\"Potential stale tip detected, will try using extra outbound peer (last tip update: %d seconds ago)\\n\", count_seconds(time - m_last_tip_update.load()));\n             m_connman.SetTryNewOutboundPeer(true);\n         } else if (m_connman.GetTryNewOutboundPeer()) {\n             m_connman.SetTryNewOutboundPeer(false);\n         }\n-        m_stale_tip_check_time = time_in_seconds + STALE_CHECK_INTERVAL;\n+        m_stale_tip_check_time = time + STALE_CHECK_INTERVAL;\n     }\n \n     if (!m_initial_sync_finished && CanDirectFetch()) {"
      },
      {
        "sha": "935eb86ecb0f142a5eb41195f7328e6a64206212",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 72,
        "deletions": 5,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67cc933c366913813f4dbd605014a640a229ca41/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67cc933c366913813f4dbd605014a640a229ca41/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=67cc933c366913813f4dbd605014a640a229ca41",
        "patch": "@@ -9,13 +9,18 @@\n #include <chainparams.h>\n #include <net.h>\n #include <net_processing.h>\n+#include <netmessagemaker.h>\n+#include <pow.h>\n #include <pubkey.h>\n #include <script/sign.h>\n #include <script/signingprovider.h>\n #include <script/standard.h>\n #include <serialize.h>\n+#include <test/util/logging.h>\n+#include <test/util/mining.h>\n #include <test/util/net.h>\n #include <test/util/setup_common.h>\n+#include <test/util/wallet.h>\n #include <txorphanage.h>\n #include <util/string.h>\n #include <util/system.h>\n@@ -36,7 +41,7 @@ static CService ip(uint32_t i)\n \n void UpdateLastBlockAnnounceTime(NodeId node, int64_t time_in_seconds);\n \n-BOOST_FIXTURE_TEST_SUITE(denialofservice_tests, TestingSetup)\n+BOOST_FIXTURE_TEST_SUITE(denialofservice_tests, RegTestingSetup)\n \n // Test eviction of an outbound peer whose chain never advances\n // Mock a node connection, and use mocktime to simulate a peer\n@@ -130,6 +135,7 @@ BOOST_AUTO_TEST_CASE(stale_tip_peer_management)\n     options.nMaxConnections = DEFAULT_MAX_PEER_CONNECTIONS;\n     options.m_max_outbound_full_relay = max_outbound_full_relay;\n     options.nMaxFeeler = MAX_FEELER_CONNECTIONS;\n+    options.m_msgproc = peerLogic.get();\n \n     connman->Init(options);\n     std::vector<CNode *> vNodes;\n@@ -146,11 +152,16 @@ BOOST_AUTO_TEST_CASE(stale_tip_peer_management)\n         BOOST_CHECK(node->fDisconnect == false);\n     }\n \n-    SetMockTime(GetTime() + 3 * chainparams.GetConsensus().nPowTargetSpacing + 1);\n+    auto mocked_time = GetTime() + 3 * chainparams.GetConsensus().nPowTargetSpacing + 1;\n+    SetMockTime(mocked_time);\n \n     // Now tip should definitely be stale, and we should look for an extra\n     // outbound peer\n-    peerLogic->CheckForStaleTipAndEvictPeers();\n+    {\n+        ASSERT_DEBUG_LOG(\"Potential stale tip detected, will try using extra outbound peer (last tip update: 1801 seconds ago)\");\n+        ASSERT_DEBUG_LOG(\"net: setting try another outbound peer=true\");\n+        peerLogic->CheckForStaleTipAndEvictPeers();\n+    }\n     BOOST_CHECK(connman->GetTryNewOutboundPeer());\n \n     // Still no peers should be marked for disconnection\n@@ -163,7 +174,11 @@ BOOST_AUTO_TEST_CASE(stale_tip_peer_management)\n     // required time connected check should be satisfied).\n     AddRandomOutboundPeer(vNodes, *peerLogic, *connman);\n \n-    peerLogic->CheckForStaleTipAndEvictPeers();\n+    {\n+        ASSERT_DEBUG_LOG(\"disconnecting extra outbound peer=8 (last block announcement received at time 0)\");\n+        ASSERT_DEBUG_LOG(\"net: setting try another outbound peer=false\");\n+        peerLogic->CheckForStaleTipAndEvictPeers();\n+    }\n     for (int i = 0; i < max_outbound_full_relay; ++i) {\n         BOOST_CHECK(vNodes[i]->fDisconnect == false);\n     }\n@@ -176,13 +191,65 @@ BOOST_AUTO_TEST_CASE(stale_tip_peer_management)\n     // peer, and check that the next newest node gets evicted.\n     UpdateLastBlockAnnounceTime(vNodes.back()->GetId(), GetTime());\n \n-    peerLogic->CheckForStaleTipAndEvictPeers();\n+    {\n+        ASSERT_DEBUG_LOG(\"disconnecting extra outbound peer=7 (last block announcement received at time 0)\");\n+        ASSERT_DEBUG_LOG(\"net: setting try another outbound peer=false\");\n+        peerLogic->CheckForStaleTipAndEvictPeers();\n+    }\n     for (int i = 0; i < max_outbound_full_relay - 1; ++i) {\n         BOOST_CHECK(vNodes[i]->fDisconnect == false);\n     }\n     BOOST_CHECK(vNodes[max_outbound_full_relay-1]->fDisconnect == true);\n     BOOST_CHECK(vNodes.back()->fDisconnect == false);\n \n+    vNodes[max_outbound_full_relay-1]->fDisconnect = false;\n+    UpdateLastBlockAnnounceTime(vNodes.back()->GetId(), 0);\n+\n+    // Set CanDirectFetch() to true by generating a block\n+    {\n+        auto block = PrepareBlock(m_node, CScript{OP_TRUE});\n+        block->nTime = mocked_time;\n+        SolvePow(*block);\n+        m_node.chainman->ProcessNewBlock(chainparams, block, true, nullptr);\n+    }\n+    // Last node pretends to send a block\n+    std::vector<CBlock> headers;\n+    {\n+        {\n+            LOCK(cs_main);\n+            const auto tip = ::ChainActive().Tip();\n+            CBlock dummy{tip->GetBlockHeader()};\n+            dummy.hashPrevBlock = tip->GetBlockHash();\n+            dummy.nTime = mocked_time + 1;\n+            SolvePow(dummy);\n+\n+            headers.emplace_back(dummy);\n+        }\n+\n+        connman->ReceiveMsgFrom(*vNodes.back(), NetMsgType::HEADERS, headers);\n+\n+        vNodes.back()->fPauseSend = false;\n+        vNodes.back()->nVersion = PROTOCOL_VERSION;\n+    }\n+    {\n+        LogPrintTest(\"Check that node is protected when it pretends to have a block\");\n+        LOCK(vNodes.back()->cs_sendProcessing);\n+        ASSERT_DEBUG_LOG(\"received: headers (82 bytes) peer=8\");\n+        ASSERT_DEBUG_LOG(\"sending getdata (37 bytes) peer=8\");\n+        ASSERT_DEBUG_LOG(\"Requesting block \" + headers.front().GetHash().ToString() + \" from  peer=8\");\n+        ASSERT_DEBUG_LOG(\"Protecting outbound peer=8 from eviction\");\n+        connman->ProcessMessagesOnce(*vNodes.back());\n+    }\n+    {\n+        ASSERT_DEBUG_LOG(\"disconnecting extra outbound peer=7 (last block announcement received at time 0)\");\n+        ASSERT_DEBUG_LOG(\"net: setting try another outbound peer=false\");\n+        peerLogic->CheckForStaleTipAndEvictPeers();\n+    }\n+    for (int i = 0; i < max_outbound_full_relay; ++i) {\n+        const bool is_8th{i == 7};\n+        BOOST_CHECK(vNodes[i]->fDisconnect == is_8th);\n+    }\n+\n     for (const CNode *node : vNodes) {\n         peerLogic->FinalizeNode(*node);\n     }"
      },
      {
        "sha": "b653099015f8587631f1683b5d8b6ecbde418299",
        "filename": "src/test/util/logging.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67cc933c366913813f4dbd605014a640a229ca41/src/test/util/logging.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67cc933c366913813f4dbd605014a640a229ca41/src/test/util/logging.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/logging.cpp?ref=67cc933c366913813f4dbd605014a640a229ca41",
        "patch": "@@ -10,6 +10,8 @@\n \n #include <stdexcept>\n \n+void LogPrintTest(const std::string& info) { LogPrintf(\"[test] %s\\n\", info); }\n+\n DebugLogHelper::DebugLogHelper(std::string message, MatchFn match)\n     : m_message{std::move(message)}, m_match(std::move(match))\n {"
      },
      {
        "sha": "06e9518169ad95c33fe4d34e11a1811ee4d04021",
        "filename": "src/test/util/logging.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67cc933c366913813f4dbd605014a640a229ca41/src/test/util/logging.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67cc933c366913813f4dbd605014a640a229ca41/src/test/util/logging.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/logging.h?ref=67cc933c366913813f4dbd605014a640a229ca41",
        "patch": "@@ -11,6 +11,9 @@\n #include <list>\n #include <string>\n \n+/** Insert log from a test */\n+void LogPrintTest(const std::string& info);\n+\n class DebugLogHelper\n {\n     const std::string m_message;"
      },
      {
        "sha": "92af2e7acf3c3154ba44aaf687ad6d176b1f12ef",
        "filename": "src/test/util/mining.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 6,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67cc933c366913813f4dbd605014a640a229ca41/src/test/util/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67cc933c366913813f4dbd605014a640a229ca41/src/test/util/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/mining.cpp?ref=67cc933c366913813f4dbd605014a640a229ca41",
        "patch": "@@ -56,15 +56,18 @@ std::vector<std::shared_ptr<CBlock>> CreateBlockChain(size_t total_height, const\n     return ret;\n }\n \n-CTxIn MineBlock(const NodeContext& node, const CScript& coinbase_scriptPubKey)\n+void SolvePow(CBlock& block)\n {\n-    auto block = PrepareBlock(node, coinbase_scriptPubKey);\n-\n-    while (!CheckProofOfWork(block->GetHash(), block->nBits, Params().GetConsensus())) {\n-        ++block->nNonce;\n-        assert(block->nNonce);\n+    while (!CheckProofOfWork(block.GetHash(), block.nBits, Params().GetConsensus())) {\n+        ++block.nNonce;\n+        assert(block.nNonce);\n     }\n+}\n \n+CTxIn MineBlock(const NodeContext& node, const CScript& coinbase_scriptPubKey)\n+{\n+    auto block = PrepareBlock(node, coinbase_scriptPubKey);\n+    SolvePow(*block);\n     bool processed{Assert(node.chainman)->ProcessNewBlock(Params(), block, true, nullptr)};\n     assert(processed);\n "
      },
      {
        "sha": "7e7ab9be2e674f91b69eeebe296513513e6f336a",
        "filename": "src/test/util/mining.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67cc933c366913813f4dbd605014a640a229ca41/src/test/util/mining.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67cc933c366913813f4dbd605014a640a229ca41/src/test/util/mining.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/mining.h?ref=67cc933c366913813f4dbd605014a640a229ca41",
        "patch": "@@ -18,6 +18,9 @@ struct NodeContext;\n /** Create a blockchain, starting from genesis */\n std::vector<std::shared_ptr<CBlock>> CreateBlockChain(size_t total_height, const CChainParams& params);\n \n+/** Work on the proof-of-work puzzle */\n+void SolvePow(CBlock& block);\n+\n /** Returns the generated coin */\n CTxIn MineBlock(const NodeContext&, const CScript& coinbase_scriptPubKey);\n "
      },
      {
        "sha": "1b0094604144e6a970e8d3907471e9fbcf297962",
        "filename": "src/test/util/net.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67cc933c366913813f4dbd605014a640a229ca41/src/test/util/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67cc933c366913813f4dbd605014a640a229ca41/src/test/util/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/net.h?ref=67cc933c366913813f4dbd605014a640a229ca41",
        "patch": "@@ -9,6 +9,7 @@\n #include <netaddress.h>\n #include <net.h>\n #include <util/sock.h>\n+#include <netmessagemaker.h>\n \n #include <array>\n #include <cassert>\n@@ -42,6 +43,15 @@ struct ConnmanTestMsg : public CConnman {\n     void NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const;\n \n     bool ReceiveMsgFrom(CNode& node, CSerializedNetMsg& ser_msg) const;\n+\n+    template <typename P>\n+    void ReceiveMsgFrom(CNode& node, const std::string& type, const P& payload)\n+    {\n+        const CNetMsgMaker msg_maker(PROTOCOL_VERSION);\n+        CSerializedNetMsg m_ser = msg_maker.Make(type.c_str(), payload);\n+\n+        assert(ReceiveMsgFrom(node, m_ser));\n+    }\n };\n \n constexpr ServiceFlags ALL_SERVICE_FLAGS[]{"
      }
    ]
  }
]