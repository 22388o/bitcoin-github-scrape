[
  {
    "sha": "fa389471251f043ec25e7b01e59b37d3b921ce54",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTM4OTQ3MTI1MWYwNDNlYzI1ZTdiMDFlNTliMzdkM2I5MjFjZTU0",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-04-27T19:06:48Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-06-13T07:39:37Z"
      },
      "message": "refactor: Remove ::Params() global from inside CChainState member functions\n\nIt is confusing and verbose to repeatedly access the global when a\nmember variable can simply refer to it.",
      "tree": {
        "sha": "b3ad8c756e1cf7a5d7659e87b5e6563715b1abbf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b3ad8c756e1cf7a5d7659e87b5e6563715b1abbf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa389471251f043ec25e7b01e59b37d3b921ce54",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUgvJwv7BYL3WFndyFfHDtflPfHHyUQyH1sVNuaUxL+gtNPkndTgwp+aiE3Is61K\nbyfta9ECsIw/q4KlQsBcwUB+zYYo8mP9z88Z5eBgE8wH7qWGpRXQlpq5PTm/taaY\n0pQhwp1KQDEqnExqmGlU6tNWw6FEPoJJej4LwYWmju/hw82vjLmcIsOJATRWOCX3\n+Gnuf0bSaz7yKInY4W6zVh64RvXEO+Q35yM4OndxKa3C7m1MEQzC8Gg1SKb6zT98\nf+BGHeBCmgIXnTx3fqclhqjObMNl+my5FNidNbo0lL6B3VTQZb1U3YpdS+0m9JhJ\nCeLrJHYhaMVaFgWlPU64lbkMRrF/DI/MyAhgQPVGiFLClsEVcp8Da+Ii1172FAFz\nCjZCcWbOEXw2ewNDh/pJQjVfbdlHcnohzfXWYwgqWkvhxzIl9A3P3RnQTaoY9+3s\nJKR1Tn63zIKWjBXtHCM7k7BgTaIQR/qi44N7N0jMUGDqa1NWJIapDwWRd9UUt3JR\nKAACj73A\n=ZiUQ\n-----END PGP SIGNATURE-----",
        "payload": "tree b3ad8c756e1cf7a5d7659e87b5e6563715b1abbf\nparent 9c1ec689f353d3d7c34695a074f82bb2ea449538\nauthor MarcoFalke <falke.marco@gmail.com> 1619550408 +0200\ncommitter MarcoFalke <falke.marco@gmail.com> 1623569977 +0200\n\nrefactor: Remove ::Params() global from inside CChainState member functions\n\nIt is confusing and verbose to repeatedly access the global when a\nmember variable can simply refer to it.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa389471251f043ec25e7b01e59b37d3b921ce54",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa389471251f043ec25e7b01e59b37d3b921ce54",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa389471251f043ec25e7b01e59b37d3b921ce54/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9c1ec689f353d3d7c34695a074f82bb2ea449538",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9c1ec689f353d3d7c34695a074f82bb2ea449538",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9c1ec689f353d3d7c34695a074f82bb2ea449538"
      }
    ],
    "stats": {
      "total": 22,
      "additions": 11,
      "deletions": 11
    },
    "files": [
      {
        "sha": "857be660fe3374644d5fb69a3475caeafbff58af",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 11,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa389471251f043ec25e7b01e59b37d3b921ce54/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa389471251f043ec25e7b01e59b37d3b921ce54/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=fa389471251f043ec25e7b01e59b37d3b921ce54",
        "patch": "@@ -1210,6 +1210,7 @@ void CoinsViews::InitCache()\n \n CChainState::CChainState(CTxMemPool& mempool, BlockManager& blockman, std::optional<uint256> from_snapshot_blockhash)\n     : m_mempool(mempool),\n+      m_params(::Params()),\n       m_blockman(blockman),\n       m_from_snapshot_blockhash(from_snapshot_blockhash) {}\n \n@@ -2196,20 +2197,19 @@ bool CChainState::FlushStateToDisk(\n     return true;\n }\n \n-void CChainState::ForceFlushStateToDisk() {\n+void CChainState::ForceFlushStateToDisk()\n+{\n     BlockValidationState state;\n-    const CChainParams& chainparams = Params();\n-    if (!this->FlushStateToDisk(chainparams, state, FlushStateMode::ALWAYS)) {\n+    if (!this->FlushStateToDisk(m_params, state, FlushStateMode::ALWAYS)) {\n         LogPrintf(\"%s: failed to flush state (%s)\\n\", __func__, state.ToString());\n     }\n }\n \n-void CChainState::PruneAndFlush() {\n+void CChainState::PruneAndFlush()\n+{\n     BlockValidationState state;\n     fCheckForPruning = true;\n-    const CChainParams& chainparams = Params();\n-\n-    if (!this->FlushStateToDisk(chainparams, state, FlushStateMode::NONE)) {\n+    if (!this->FlushStateToDisk(m_params, state, FlushStateMode::NONE)) {\n         LogPrintf(\"%s: failed to flush state (%s)\\n\", __func__, state.ToString());\n     }\n }\n@@ -4507,16 +4507,14 @@ bool CChainState::ResizeCoinsCaches(size_t coinstip_size, size_t coinsdb_size)\n         this->ToString(), coinstip_size * (1.0 / 1024 / 1024));\n \n     BlockValidationState state;\n-    const CChainParams& chainparams = Params();\n-\n     bool ret;\n \n     if (coinstip_size > old_coinstip_size) {\n         // Likely no need to flush if cache sizes have grown.\n-        ret = FlushStateToDisk(chainparams, state, FlushStateMode::IF_NEEDED);\n+        ret = FlushStateToDisk(m_params, state, FlushStateMode::IF_NEEDED);\n     } else {\n         // Otherwise, flush state to disk and deallocate the in-memory coins map.\n-        ret = FlushStateToDisk(chainparams, state, FlushStateMode::ALWAYS);\n+        ret = FlushStateToDisk(m_params, state, FlushStateMode::ALWAYS);\n         CoinsTip().ReallocateCache();\n     }\n     return ret;"
      },
      {
        "sha": "6f263ba5ffc7aaaf084da7d87800b9e797533b81",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa389471251f043ec25e7b01e59b37d3b921ce54/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa389471251f043ec25e7b01e59b37d3b921ce54/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=fa389471251f043ec25e7b01e59b37d3b921ce54",
        "patch": "@@ -595,6 +595,8 @@ class CChainState\n     //! mempool that is kept in sync with the chain\n     CTxMemPool& m_mempool;\n \n+    const CChainParams& m_params;\n+\n     //! Manages the UTXO set, which is a reflection of the contents of `m_chain`.\n     std::unique_ptr<CoinsViews> m_coins_views;\n "
      }
    ]
  },
  {
    "sha": "fa0d9211ef87a682573aaae932c0c440acbcb8a8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTBkOTIxMWVmODdhNjgyNTczYWFhZTkzMmMwYzQ0MGFjYmNiOGE4",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-04-27T20:54:53Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-06-13T07:43:54Z"
      },
      "message": "refactor: Remove chainparams arg from CChainState member functions\n\nPassing this is confusing and redundant with the m_params member.",
      "tree": {
        "sha": "947d43557612f0e60523faad2c1fc369191cd091",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/947d43557612f0e60523faad2c1fc369191cd091"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa0d9211ef87a682573aaae932c0c440acbcb8a8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUh7YAv8DMgqOBtpsRcf/6xo6ROoBHeeLjT6t15mQacaFIYTj1G2npqhpSJJ5o1Q\nXmYJ1kEAtej9ca8eMiqb1ZNeIq3vcZ2r8YuU7D4A7FnWrRDIL1+Tc9Kkn2DzZ6IL\nIbLUg/4be6iRyl4TsmG/ppUnrUsdNxuIugjwRPxXNd+htqdALb5jH0wU8smKTWmk\nzCFYyzqxa4vKYKheyMYEQ/XQuar5mpe1pMxisKr5RPpDBxiaMLp08XqhpU6ZxNFw\n9Fz/0FrSq5Bm6274odalV+RGqTzUJBXApxNpTGoRlWysdxM1rBAePTgUl0uNtr47\nmpb/nSjzSz8DfpV0Au1m9HxMUo04ObFNbklPQh1oyfrDDGE3maxSFm0OYLCNUJWD\nS9NKjnNnU1lCGfz4FYQFVuILat7OJ26vEuh4+5BXj+f3U77K5kIRovb3s3QGSrx2\nIpTmmVz9gfo7mdWMOF6J0YQQOway9Sz8klgkrtqSHCUHneNvLwXGTPCaYba+Gof6\noJ2mBckV\n=eMD3\n-----END PGP SIGNATURE-----",
        "payload": "tree 947d43557612f0e60523faad2c1fc369191cd091\nparent fa389471251f043ec25e7b01e59b37d3b921ce54\nauthor MarcoFalke <falke.marco@gmail.com> 1619556893 +0200\ncommitter MarcoFalke <falke.marco@gmail.com> 1623570234 +0200\n\nrefactor: Remove chainparams arg from CChainState member functions\n\nPassing this is confusing and redundant with the m_params member.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa0d9211ef87a682573aaae932c0c440acbcb8a8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa0d9211ef87a682573aaae932c0c440acbcb8a8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa0d9211ef87a682573aaae932c0c440acbcb8a8/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fa389471251f043ec25e7b01e59b37d3b921ce54",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa389471251f043ec25e7b01e59b37d3b921ce54",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fa389471251f043ec25e7b01e59b37d3b921ce54"
      }
    ],
    "stats": {
      "total": 282,
      "additions": 142,
      "deletions": 140
    },
    "files": [
      {
        "sha": "daa5b918169046523faeeb14acf8e0e06a49cc89",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0d9211ef87a682573aaae932c0c440acbcb8a8/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0d9211ef87a682573aaae932c0c440acbcb8a8/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=fa0d9211ef87a682573aaae932c0c440acbcb8a8",
        "patch": "@@ -1372,7 +1372,7 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n                 // block file from disk.\n                 // Note that it also sets fReindex based on the disk flag!\n                 // From here on out fReindex and fReset mean something different!\n-                if (!chainman.LoadBlockIndex(chainparams)) {\n+                if (!chainman.LoadBlockIndex()) {\n                     if (ShutdownRequested()) break;\n                     strLoadError = _(\"Error loading block database\");\n                     break;\n@@ -1396,7 +1396,7 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n                 // If we're not mid-reindex (based on disk + args), add a genesis block on disk\n                 // (otherwise we use the one already on disk).\n                 // This is called again in ThreadImport after the reindex completes.\n-                if (!fReindex && !chainman.ActiveChainstate().LoadGenesisBlock(chainparams)) {\n+                if (!fReindex && !chainman.ActiveChainstate().LoadGenesisBlock()) {\n                     strLoadError = _(\"Error initializing block database\");\n                     break;\n                 }\n@@ -1427,7 +1427,7 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n                     }\n \n                     // ReplayBlocks is a no-op if we cleared the coinsviewdb with -reindex or -reindex-chainstate\n-                    if (!chainstate->ReplayBlocks(chainparams)) {\n+                    if (!chainstate->ReplayBlocks()) {\n                         strLoadError = _(\"Unable to replay blocks. You will need to rebuild the database using -reindex-chainstate.\");\n                         failed_chainstate_init = true;\n                         break;\n@@ -1439,7 +1439,7 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n \n                     if (!is_coinsview_empty(chainstate)) {\n                         // LoadChainTip initializes the chain based on CoinsTip()'s best block\n-                        if (!chainstate->LoadChainTip(chainparams)) {\n+                        if (!chainstate->LoadChainTip()) {\n                             strLoadError = _(\"Error initializing block database\");\n                             failed_chainstate_init = true;\n                             break; // out of the per-chainstate loop\n@@ -1461,7 +1461,7 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n                 LOCK(cs_main);\n                 auto chainstates{chainman.GetAll()};\n                 if (std::any_of(chainstates.begin(), chainstates.end(),\n-                                [&chainparams](const CChainState* cs) EXCLUSIVE_LOCKS_REQUIRED(cs_main) { return cs->NeedsRedownload(chainparams); })) {\n+                                [](const CChainState* cs) EXCLUSIVE_LOCKS_REQUIRED(cs_main) { return cs->NeedsRedownload(); })) {\n                     strLoadError = strprintf(_(\"Witness data for blocks after height %d requires validation. Please restart with -reindex.\"),\n                                              chainparams.GetConsensus().SegwitHeight);\n                     break;"
      },
      {
        "sha": "50b94eb9a21f41cdde4f8c496ea060308f88b303",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0d9211ef87a682573aaae932c0c440acbcb8a8/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0d9211ef87a682573aaae932c0c440acbcb8a8/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=fa0d9211ef87a682573aaae932c0c440acbcb8a8",
        "patch": "@@ -1694,7 +1694,7 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv&\n     } // release cs_main before calling ActivateBestChain\n     if (need_activate_chain) {\n         BlockValidationState state;\n-        if (!m_chainman.ActiveChainstate().ActivateBestChain(state, m_chainparams, a_recent_block)) {\n+        if (!m_chainman.ActiveChainstate().ActivateBestChain(state, a_recent_block)) {\n             LogPrint(BCLog::NET, \"failed to activate chain (%s)\\n\", state.ToString());\n         }\n     }\n@@ -2920,7 +2920,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 a_recent_block = most_recent_block;\n             }\n             BlockValidationState state;\n-            if (!m_chainman.ActiveChainstate().ActivateBestChain(state, m_chainparams, a_recent_block)) {\n+            if (!m_chainman.ActiveChainstate().ActivateBestChain(state, a_recent_block)) {\n                 LogPrint(BCLog::NET, \"failed to activate chain (%s)\\n\", state.ToString());\n             }\n         }"
      },
      {
        "sha": "0083b74b3382c3ccf470f0cf69898ad9a445e434",
        "filename": "src/node/blockstorage.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0d9211ef87a682573aaae932c0c440acbcb8a8/src/node/blockstorage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0d9211ef87a682573aaae932c0c440acbcb8a8/src/node/blockstorage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/blockstorage.cpp?ref=fa0d9211ef87a682573aaae932c0c440acbcb8a8",
        "patch": "@@ -493,7 +493,6 @@ struct CImportingNow {\n \n void ThreadImport(ChainstateManager& chainman, std::vector<fs::path> vImportFiles, const ArgsManager& args)\n {\n-    const CChainParams& chainparams = Params();\n     ScheduleBatchPriority();\n \n     {\n@@ -512,7 +511,7 @@ void ThreadImport(ChainstateManager& chainman, std::vector<fs::path> vImportFile\n                     break; // This error is logged in OpenBlockFile\n                 }\n                 LogPrintf(\"Reindexing block file blk%05u.dat...\\n\", (unsigned int)nFile);\n-                chainman.ActiveChainstate().LoadExternalBlockFile(chainparams, file, &pos);\n+                chainman.ActiveChainstate().LoadExternalBlockFile(file, &pos);\n                 if (ShutdownRequested()) {\n                     LogPrintf(\"Shutdown requested. Exit %s\\n\", __func__);\n                     return;\n@@ -523,15 +522,15 @@ void ThreadImport(ChainstateManager& chainman, std::vector<fs::path> vImportFile\n             fReindex = false;\n             LogPrintf(\"Reindexing finished\\n\");\n             // To avoid ending up in a situation without genesis block, re-try initializing (no-op if reindexing worked):\n-            chainman.ActiveChainstate().LoadGenesisBlock(chainparams);\n+            chainman.ActiveChainstate().LoadGenesisBlock();\n         }\n \n         // -loadblock=\n         for (const fs::path& path : vImportFiles) {\n             FILE* file = fsbridge::fopen(path, \"rb\");\n             if (file) {\n                 LogPrintf(\"Importing blocks file %s...\\n\", path.string());\n-                chainman.ActiveChainstate().LoadExternalBlockFile(chainparams, file);\n+                chainman.ActiveChainstate().LoadExternalBlockFile(file);\n                 if (ShutdownRequested()) {\n                     LogPrintf(\"Shutdown requested. Exit %s\\n\", __func__);\n                     return;\n@@ -548,7 +547,7 @@ void ThreadImport(ChainstateManager& chainman, std::vector<fs::path> vImportFile\n         // the relevant pointers before the ABC call.\n         for (CChainState* chainstate : WITH_LOCK(::cs_main, return chainman.GetAll())) {\n             BlockValidationState state;\n-            if (!chainstate->ActivateBestChain(state, chainparams, nullptr)) {\n+            if (!chainstate->ActivateBestChain(state, nullptr)) {\n                 LogPrintf(\"Failed to connect best block (%s)\\n\", state.ToString());\n                 StartShutdown();\n                 return;"
      },
      {
        "sha": "94d2b045de55f20dc826ee3ba4c6946baacccdcf",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0d9211ef87a682573aaae932c0c440acbcb8a8/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0d9211ef87a682573aaae932c0c440acbcb8a8/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=fa0d9211ef87a682573aaae932c0c440acbcb8a8",
        "patch": "@@ -1706,7 +1706,7 @@ static RPCHelpMan preciousblock()\n     }\n \n     BlockValidationState state;\n-    chainman.ActiveChainstate().PreciousBlock(state, Params(), pblockindex);\n+    chainman.ActiveChainstate().PreciousBlock(state, pblockindex);\n \n     if (!state.IsValid()) {\n         throw JSONRPCError(RPC_DATABASE_ERROR, state.ToString());\n@@ -1743,10 +1743,10 @@ static RPCHelpMan invalidateblock()\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n         }\n     }\n-    chainman.ActiveChainstate().InvalidateBlock(state, Params(), pblockindex);\n+    chainman.ActiveChainstate().InvalidateBlock(state, pblockindex);\n \n     if (state.IsValid()) {\n-        chainman.ActiveChainstate().ActivateBestChain(state, Params());\n+        chainman.ActiveChainstate().ActivateBestChain(state);\n     }\n \n     if (!state.IsValid()) {\n@@ -1787,7 +1787,7 @@ static RPCHelpMan reconsiderblock()\n     }\n \n     BlockValidationState state;\n-    chainman.ActiveChainstate().ActivateBestChain(state, Params());\n+    chainman.ActiveChainstate().ActivateBestChain(state);\n \n     if (!state.IsValid()) {\n         throw JSONRPCError(RPC_DATABASE_ERROR, state.ToString());"
      },
      {
        "sha": "bfa977520b6826c7d4a87c0dc8a20bd9f3789cbd",
        "filename": "src/test/fuzz/load_external_block_file.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0d9211ef87a682573aaae932c0c440acbcb8a8/src/test/fuzz/load_external_block_file.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0d9211ef87a682573aaae932c0c440acbcb8a8/src/test/fuzz/load_external_block_file.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/load_external_block_file.cpp?ref=fa0d9211ef87a682573aaae932c0c440acbcb8a8",
        "patch": "@@ -32,5 +32,5 @@ FUZZ_TARGET_INIT(load_external_block_file, initialize_load_external_block_file)\n         return;\n     }\n     FlatFilePos flat_file_pos;\n-    g_setup->m_node.chainman->ActiveChainstate().LoadExternalBlockFile(Params(), fuzzed_block_file, fuzzed_data_provider.ConsumeBool() ? &flat_file_pos : nullptr);\n+    g_setup->m_node.chainman->ActiveChainstate().LoadExternalBlockFile(fuzzed_block_file, fuzzed_data_provider.ConsumeBool() ? &flat_file_pos : nullptr);\n }"
      },
      {
        "sha": "44779f7d7cef52bf914ecee86eb0ef49e7d09b91",
        "filename": "src/test/interfaces_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0d9211ef87a682573aaae932c0c440acbcb8a8/src/test/interfaces_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0d9211ef87a682573aaae932c0c440acbcb8a8/src/test/interfaces_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/interfaces_tests.cpp?ref=fa0d9211ef87a682573aaae932c0c440acbcb8a8",
        "patch": "@@ -98,7 +98,7 @@ BOOST_AUTO_TEST_CASE(findCommonAncestor)\n     auto* orig_tip = active.Tip();\n     for (int i = 0; i < 10; ++i) {\n         BlockValidationState state;\n-        m_node.chainman->ActiveChainstate().InvalidateBlock(state, Params(), active.Tip());\n+        m_node.chainman->ActiveChainstate().InvalidateBlock(state, active.Tip());\n     }\n     BOOST_CHECK_EQUAL(active.Height(), orig_tip->nHeight - 10);\n     coinbaseKey.MakeNewKey(true);"
      },
      {
        "sha": "736958347083be942418228151c0251cf6b117b3",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0d9211ef87a682573aaae932c0c440acbcb8a8/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0d9211ef87a682573aaae932c0c440acbcb8a8/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=fa0d9211ef87a682573aaae932c0c440acbcb8a8",
        "patch": "@@ -186,12 +186,12 @@ TestingSetup::TestingSetup(const std::string& chainName, const std::vector<const\n     assert(!m_node.chainman->ActiveChainstate().CanFlushToDisk());\n     m_node.chainman->ActiveChainstate().InitCoinsCache(1 << 23);\n     assert(m_node.chainman->ActiveChainstate().CanFlushToDisk());\n-    if (!m_node.chainman->ActiveChainstate().LoadGenesisBlock(chainparams)) {\n+    if (!m_node.chainman->ActiveChainstate().LoadGenesisBlock()) {\n         throw std::runtime_error(\"LoadGenesisBlock failed.\");\n     }\n \n     BlockValidationState state;\n-    if (!m_node.chainman->ActiveChainstate().ActivateBestChain(state, chainparams)) {\n+    if (!m_node.chainman->ActiveChainstate().ActivateBestChain(state)) {\n         throw std::runtime_error(strprintf(\"ActivateBestChain failed. (%s)\", state.ToString()));\n     }\n "
      },
      {
        "sha": "7c1db9d4b9c62f709836efa153136d5290488b1c",
        "filename": "src/test/validation_chainstatemanager_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0d9211ef87a682573aaae932c0c440acbcb8a8/src/test/validation_chainstatemanager_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0d9211ef87a682573aaae932c0c440acbcb8a8/src/test/validation_chainstatemanager_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_chainstatemanager_tests.cpp?ref=fa0d9211ef87a682573aaae932c0c440acbcb8a8",
        "patch": "@@ -31,7 +31,6 @@ BOOST_AUTO_TEST_CASE(chainstatemanager)\n     CTxMemPool& mempool = *m_node.mempool;\n \n     std::vector<CChainState*> chainstates;\n-    const CChainParams& chainparams = Params();\n \n     BOOST_CHECK(!manager.SnapshotBlockhash().has_value());\n \n@@ -76,9 +75,9 @@ BOOST_AUTO_TEST_CASE(chainstatemanager)\n         /* cache_size_bytes */ 1 << 23, /* in_memory */ true, /* should_wipe */ false);\n     WITH_LOCK(::cs_main, c2.InitCoinsCache(1 << 23));\n     // Unlike c1, which doesn't have any blocks. Gets us different tip, height.\n-    c2.LoadGenesisBlock(chainparams);\n+    c2.LoadGenesisBlock();\n     BlockValidationState _;\n-    BOOST_CHECK(c2.ActivateBestChain(_, chainparams, nullptr));\n+    BOOST_CHECK(c2.ActivateBestChain(_, nullptr));\n \n     BOOST_CHECK(manager.IsSnapshotActive());\n     BOOST_CHECK(!manager.IsSnapshotValidated());\n@@ -138,7 +137,7 @@ BOOST_AUTO_TEST_CASE(chainstatemanager_rebalance_caches)\n     {\n         LOCK(::cs_main);\n         c1.InitCoinsCache(1 << 23);\n-        BOOST_REQUIRE(c1.LoadGenesisBlock(Params()));\n+        BOOST_REQUIRE(c1.LoadGenesisBlock());\n         c1.CoinsTip().SetBestBlock(InsecureRand256());\n         manager.MaybeRebalanceCaches();\n     }\n@@ -156,7 +155,7 @@ BOOST_AUTO_TEST_CASE(chainstatemanager_rebalance_caches)\n     {\n         LOCK(::cs_main);\n         c2.InitCoinsCache(1 << 23);\n-        BOOST_REQUIRE(c2.LoadGenesisBlock(Params()));\n+        BOOST_REQUIRE(c2.LoadGenesisBlock());\n         c2.CoinsTip().SetBestBlock(InsecureRand256());\n         manager.MaybeRebalanceCaches();\n     }"
      },
      {
        "sha": "425d78176028b2c070c1dfb3362bff70987df114",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 100,
        "deletions": 94,
        "changes": 194,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0d9211ef87a682573aaae932c0c440acbcb8a8/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0d9211ef87a682573aaae932c0c440acbcb8a8/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=fa0d9211ef87a682573aaae932c0c440acbcb8a8",
        "patch": "@@ -1124,7 +1124,7 @@ static MempoolAcceptResult AcceptToMemoryPoolWithTime(const CChainParams& chainp\n     }\n     // After we've (potentially) uncached entries, ensure our coins cache is still within its size limits\n     BlockValidationState state_dummy;\n-    active_chainstate.FlushStateToDisk(chainparams, state_dummy, FlushStateMode::PERIODIC);\n+    active_chainstate.FlushStateToDisk(state_dummy, FlushStateMode::PERIODIC);\n     return result;\n }\n \n@@ -1725,7 +1725,7 @@ static int64_t nBlocksTotal = 0;\n  *  Validity checks that depend on the UTXO set are also done; ConnectBlock()\n  *  can fail if those validity checks fail (among other reasons). */\n bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state, CBlockIndex* pindex,\n-                  CCoinsViewCache& view, const CChainParams& chainparams, bool fJustCheck)\n+                               CCoinsViewCache& view, bool fJustCheck)\n {\n     AssertLockHeld(cs_main);\n     assert(pindex);\n@@ -1745,7 +1745,7 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n     // is enforced in ContextualCheckBlockHeader(); we wouldn't want to\n     // re-enforce that rule here (at least until we make it impossible for\n     // GetAdjustedTime() to go backward).\n-    if (!CheckBlock(block, state, chainparams.GetConsensus(), !fJustCheck, !fJustCheck)) {\n+    if (!CheckBlock(block, state, m_params.GetConsensus(), !fJustCheck, !fJustCheck)) {\n         if (state.GetResult() == BlockValidationResult::BLOCK_MUTATED) {\n             // We don't write down blocks to disk if they may have been\n             // corrupted, so this should be impossible unless we're having hardware\n@@ -1763,7 +1763,7 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n \n     // Special case for the genesis block, skipping connection of its transactions\n     // (its coinbase is unspendable)\n-    if (block.GetHash() == chainparams.GetConsensus().hashGenesisBlock) {\n+    if (block.GetHash() == m_params.GetConsensus().hashGenesisBlock) {\n         if (!fJustCheck)\n             view.SetBestBlock(pindex->GetBlockHash());\n         return true;\n@@ -1795,7 +1795,7 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n                 //  artificially set the default assumed verified block further back.\n                 // The test against nMinimumChainWork prevents the skipping when denied access to any chain at\n                 //  least as good as the expected chain.\n-                fScriptChecks = (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, chainparams.GetConsensus()) <= 60 * 60 * 24 * 7 * 2);\n+                fScriptChecks = (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, m_params.GetConsensus()) <= 60 * 60 * 24 * 7 * 2);\n             }\n         }\n     }\n@@ -1875,9 +1875,9 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n     // be reset before it reaches block 1,983,702 and starts doing unnecessary\n     // BIP30 checking again.\n     assert(pindex->pprev);\n-    CBlockIndex *pindexBIP34height = pindex->pprev->GetAncestor(chainparams.GetConsensus().BIP34Height);\n+    CBlockIndex* pindexBIP34height = pindex->pprev->GetAncestor(m_params.GetConsensus().BIP34Height);\n     //Only continue to enforce if we're below BIP34 activation height or the block hash at that height doesn't correspond.\n-    fEnforceBIP30 = fEnforceBIP30 && (!pindexBIP34height || !(pindexBIP34height->GetBlockHash() == chainparams.GetConsensus().BIP34Hash));\n+    fEnforceBIP30 = fEnforceBIP30 && (!pindexBIP34height || !(pindexBIP34height->GetBlockHash() == m_params.GetConsensus().BIP34Hash));\n \n     // TODO: Remove BIP30 checking from block height 1,983,702 on, once we have a\n     // consensus change that ensures coinbases at those heights can not\n@@ -1895,12 +1895,12 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n \n     // Start enforcing BIP68 (sequence locks)\n     int nLockTimeFlags = 0;\n-    if (pindex->nHeight >= chainparams.GetConsensus().CSVHeight) {\n+    if (pindex->nHeight >= m_params.GetConsensus().CSVHeight) {\n         nLockTimeFlags |= LOCKTIME_VERIFY_SEQUENCE;\n     }\n \n     // Get the script flags for this block\n-    unsigned int flags = GetBlockScriptFlags(pindex, chainparams.GetConsensus());\n+    unsigned int flags = GetBlockScriptFlags(pindex, m_params.GetConsensus());\n \n     int64_t nTime2 = GetTimeMicros(); nTimeForks += nTime2 - nTime1;\n     LogPrint(BCLog::BENCH, \"    - Fork checks: %.2fms [%.2fs (%.2fms/blk)]\\n\", MILLI * (nTime2 - nTime1), nTimeForks * MICRO, nTimeForks * MILLI / nBlocksTotal);\n@@ -1990,7 +1990,7 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n     int64_t nTime3 = GetTimeMicros(); nTimeConnect += nTime3 - nTime2;\n     LogPrint(BCLog::BENCH, \"      - Connect %u transactions: %.2fms (%.3fms/tx, %.3fms/txin) [%.2fs (%.2fms/blk)]\\n\", (unsigned)block.vtx.size(), MILLI * (nTime3 - nTime2), MILLI * (nTime3 - nTime2) / block.vtx.size(), nInputs <= 1 ? 0 : MILLI * (nTime3 - nTime2) / (nInputs-1), nTimeConnect * MICRO, nTimeConnect * MILLI / nBlocksTotal);\n \n-    CAmount blockReward = nFees + GetBlockSubsidy(pindex->nHeight, chainparams.GetConsensus());\n+    CAmount blockReward = nFees + GetBlockSubsidy(pindex->nHeight, m_params.GetConsensus());\n     if (block.vtx[0]->GetValueOut() > blockReward) {\n         LogPrintf(\"ERROR: ConnectBlock(): coinbase pays too much (actual=%d vs limit=%d)\\n\", block.vtx[0]->GetValueOut(), blockReward);\n         return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"bad-cb-amount\");\n@@ -2006,8 +2006,9 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n     if (fJustCheck)\n         return true;\n \n-    if (!WriteUndoDataForBlock(blockundo, state, pindex, chainparams))\n+    if (!WriteUndoDataForBlock(blockundo, state, pindex, m_params)) {\n         return false;\n+    }\n \n     if (!pindex->IsValid(BLOCK_VALID_SCRIPTS)) {\n         pindex->RaiseValidity(BLOCK_VALID_SCRIPTS);\n@@ -2060,7 +2061,6 @@ CoinsCacheSizeState CChainState::GetCoinsCacheSizeState(\n }\n \n bool CChainState::FlushStateToDisk(\n-    const CChainParams& chainparams,\n     BlockValidationState &state,\n     FlushStateMode mode,\n     int nManualPruneHeight)\n@@ -2097,7 +2097,7 @@ bool CChainState::FlushStateToDisk(\n             } else {\n                 LOG_TIME_MILLIS_WITH_CATEGORY(\"find files to prune\", BCLog::BENCH);\n \n-                m_blockman.FindFilesToPrune(setFilesToPrune, chainparams.PruneAfterHeight(), m_chain.Height(), last_prune, IsInitialBlockDownload());\n+                m_blockman.FindFilesToPrune(setFilesToPrune, m_params.PruneAfterHeight(), m_chain.Height(), last_prune, IsInitialBlockDownload());\n                 fCheckForPruning = false;\n             }\n             if (!setFilesToPrune.empty()) {\n@@ -2200,7 +2200,7 @@ bool CChainState::FlushStateToDisk(\n void CChainState::ForceFlushStateToDisk()\n {\n     BlockValidationState state;\n-    if (!this->FlushStateToDisk(m_params, state, FlushStateMode::ALWAYS)) {\n+    if (!this->FlushStateToDisk(state, FlushStateMode::ALWAYS)) {\n         LogPrintf(\"%s: failed to flush state (%s)\\n\", __func__, state.ToString());\n     }\n }\n@@ -2209,7 +2209,7 @@ void CChainState::PruneAndFlush()\n {\n     BlockValidationState state;\n     fCheckForPruning = true;\n-    if (!this->FlushStateToDisk(m_params, state, FlushStateMode::NONE)) {\n+    if (!this->FlushStateToDisk(state, FlushStateMode::NONE)) {\n         LogPrintf(\"%s: failed to flush state (%s)\\n\", __func__, state.ToString());\n     }\n }\n@@ -2278,7 +2278,7 @@ static void UpdateTip(CTxMemPool& mempool, const CBlockIndex* pindexNew, const C\n   * disconnectpool (note that the caller is responsible for mempool consistency\n   * in any case).\n   */\n-bool CChainState::DisconnectTip(BlockValidationState& state, const CChainParams& chainparams, DisconnectedBlockTransactions* disconnectpool)\n+bool CChainState::DisconnectTip(BlockValidationState& state, DisconnectedBlockTransactions* disconnectpool)\n {\n     AssertLockHeld(cs_main);\n     AssertLockHeld(m_mempool.cs);\n@@ -2288,8 +2288,9 @@ bool CChainState::DisconnectTip(BlockValidationState& state, const CChainParams&\n     // Read block from disk.\n     std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();\n     CBlock& block = *pblock;\n-    if (!ReadBlockFromDisk(block, pindexDelete, chainparams.GetConsensus()))\n+    if (!ReadBlockFromDisk(block, pindexDelete, m_params.GetConsensus())) {\n         return error(\"DisconnectTip(): Failed to read block\");\n+    }\n     // Apply the block atomically to the chain state.\n     int64_t nStart = GetTimeMicros();\n     {\n@@ -2302,8 +2303,9 @@ bool CChainState::DisconnectTip(BlockValidationState& state, const CChainParams&\n     }\n     LogPrint(BCLog::BENCH, \"- Disconnect block: %.2fms\\n\", (GetTimeMicros() - nStart) * MILLI);\n     // Write the chain state to disk, if necessary.\n-    if (!FlushStateToDisk(chainparams, state, FlushStateMode::IF_NEEDED))\n+    if (!FlushStateToDisk(state, FlushStateMode::IF_NEEDED)) {\n         return false;\n+    }\n \n     if (disconnectpool) {\n         // Save transactions to re-add to mempool at end of reorg\n@@ -2320,7 +2322,7 @@ bool CChainState::DisconnectTip(BlockValidationState& state, const CChainParams&\n \n     m_chain.SetTip(pindexDelete->pprev);\n \n-    UpdateTip(m_mempool, pindexDelete->pprev, chainparams, *this);\n+    UpdateTip(m_mempool, pindexDelete->pprev, m_params, *this);\n     // Let wallets know transactions went from 1-confirmed to\n     // 0-confirmed or conflicted:\n     GetMainSignals().BlockDisconnected(pblock, pindexDelete);\n@@ -2379,7 +2381,7 @@ class ConnectTrace {\n  *\n  * The block is added to connectTrace if connection succeeds.\n  */\n-bool CChainState::ConnectTip(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions &disconnectpool)\n+bool CChainState::ConnectTip(BlockValidationState& state, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions& disconnectpool)\n {\n     AssertLockHeld(cs_main);\n     AssertLockHeld(m_mempool.cs);\n@@ -2390,8 +2392,9 @@ bool CChainState::ConnectTip(BlockValidationState& state, const CChainParams& ch\n     std::shared_ptr<const CBlock> pthisBlock;\n     if (!pblock) {\n         std::shared_ptr<CBlock> pblockNew = std::make_shared<CBlock>();\n-        if (!ReadBlockFromDisk(*pblockNew, pindexNew, chainparams.GetConsensus()))\n+        if (!ReadBlockFromDisk(*pblockNew, pindexNew, m_params.GetConsensus())) {\n             return AbortNode(state, \"Failed to read block\");\n+        }\n         pthisBlock = pblockNew;\n     } else {\n         pthisBlock = pblock;\n@@ -2403,7 +2406,7 @@ bool CChainState::ConnectTip(BlockValidationState& state, const CChainParams& ch\n     LogPrint(BCLog::BENCH, \"  - Load block from disk: %.2fms [%.2fs]\\n\", (nTime2 - nTime1) * MILLI, nTimeReadFromDisk * MICRO);\n     {\n         CCoinsViewCache view(&CoinsTip());\n-        bool rv = ConnectBlock(blockConnecting, state, pindexNew, view, chainparams);\n+        bool rv = ConnectBlock(blockConnecting, state, pindexNew, view);\n         GetMainSignals().BlockChecked(blockConnecting, state);\n         if (!rv) {\n             if (state.IsInvalid())\n@@ -2419,16 +2422,17 @@ bool CChainState::ConnectTip(BlockValidationState& state, const CChainParams& ch\n     int64_t nTime4 = GetTimeMicros(); nTimeFlush += nTime4 - nTime3;\n     LogPrint(BCLog::BENCH, \"  - Flush: %.2fms [%.2fs (%.2fms/blk)]\\n\", (nTime4 - nTime3) * MILLI, nTimeFlush * MICRO, nTimeFlush * MILLI / nBlocksTotal);\n     // Write the chain state to disk, if necessary.\n-    if (!FlushStateToDisk(chainparams, state, FlushStateMode::IF_NEEDED))\n+    if (!FlushStateToDisk(state, FlushStateMode::IF_NEEDED)) {\n         return false;\n+    }\n     int64_t nTime5 = GetTimeMicros(); nTimeChainState += nTime5 - nTime4;\n     LogPrint(BCLog::BENCH, \"  - Writing chainstate: %.2fms [%.2fs (%.2fms/blk)]\\n\", (nTime5 - nTime4) * MILLI, nTimeChainState * MICRO, nTimeChainState * MILLI / nBlocksTotal);\n     // Remove conflicting transactions from the mempool.;\n     m_mempool.removeForBlock(blockConnecting.vtx, pindexNew->nHeight);\n     disconnectpool.removeForBlock(blockConnecting.vtx);\n     // Update m_chain & related variables.\n     m_chain.SetTip(pindexNew);\n-    UpdateTip(m_mempool, pindexNew, chainparams, *this);\n+    UpdateTip(m_mempool, pindexNew, m_params, *this);\n \n     int64_t nTime6 = GetTimeMicros(); nTimePostConnect += nTime6 - nTime5; nTimeTotal += nTime6 - nTime1;\n     LogPrint(BCLog::BENCH, \"  - Connect postprocess: %.2fms [%.2fs (%.2fms/blk)]\\n\", (nTime6 - nTime5) * MILLI, nTimePostConnect * MICRO, nTimePostConnect * MILLI / nBlocksTotal);\n@@ -2515,7 +2519,7 @@ void CChainState::PruneBlockIndexCandidates() {\n  *\n  * @returns true unless a system error occurred\n  */\n-bool CChainState::ActivateBestChainStep(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace)\n+bool CChainState::ActivateBestChainStep(BlockValidationState& state, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace)\n {\n     AssertLockHeld(cs_main);\n     AssertLockHeld(m_mempool.cs);\n@@ -2527,7 +2531,7 @@ bool CChainState::ActivateBestChainStep(BlockValidationState& state, const CChai\n     bool fBlocksDisconnected = false;\n     DisconnectedBlockTransactions disconnectpool;\n     while (m_chain.Tip() && m_chain.Tip() != pindexFork) {\n-        if (!DisconnectTip(state, chainparams, &disconnectpool)) {\n+        if (!DisconnectTip(state, &disconnectpool)) {\n             // This is likely a fatal error, but keep the mempool consistent,\n             // just in case. Only remove from the mempool in this case.\n             UpdateMempoolForReorg(*this, m_mempool, disconnectpool, false);\n@@ -2560,7 +2564,7 @@ bool CChainState::ActivateBestChainStep(BlockValidationState& state, const CChai\n \n         // Connect new blocks.\n         for (CBlockIndex* pindexConnect : reverse_iterate(vpindexToConnect)) {\n-            if (!ConnectTip(state, chainparams, pindexConnect, pindexConnect == pindexMostWork ? pblock : std::shared_ptr<const CBlock>(), connectTrace, disconnectpool)) {\n+            if (!ConnectTip(state, pindexConnect, pindexConnect == pindexMostWork ? pblock : std::shared_ptr<const CBlock>(), connectTrace, disconnectpool)) {\n                 if (state.IsInvalid()) {\n                     // The block violates a consensus rule.\n                     if (state.GetResult() != BlockValidationResult::BLOCK_MUTATED) {\n@@ -2637,7 +2641,8 @@ static void LimitValidationInterfaceQueue() LOCKS_EXCLUDED(cs_main) {\n     }\n }\n \n-bool CChainState::ActivateBestChain(BlockValidationState &state, const CChainParams& chainparams, std::shared_ptr<const CBlock> pblock) {\n+bool CChainState::ActivateBestChain(BlockValidationState& state, std::shared_ptr<const CBlock> pblock)\n+{\n     // Note that while we're often called here from ProcessNewBlock, this is\n     // far from a guarantee. Things in the P2P/RPC will often end up calling\n     // us in the middle of ProcessNewBlock - do not assume pblock is set\n@@ -2683,7 +2688,7 @@ bool CChainState::ActivateBestChain(BlockValidationState &state, const CChainPar\n \n                 bool fInvalidFound = false;\n                 std::shared_ptr<const CBlock> nullBlockPtr;\n-                if (!ActivateBestChainStep(state, chainparams, pindexMostWork, pblock && pblock->GetHash() == pindexMostWork->GetBlockHash() ? pblock : nullBlockPtr, fInvalidFound, connectTrace)) {\n+                if (!ActivateBestChainStep(state, pindexMostWork, pblock && pblock->GetHash() == pindexMostWork->GetBlockHash() ? pblock : nullBlockPtr, fInvalidFound, connectTrace)) {\n                     // A system error occurred\n                     return false;\n                 }\n@@ -2725,17 +2730,17 @@ bool CChainState::ActivateBestChain(BlockValidationState &state, const CChainPar\n         // that the best block hash is non-null.\n         if (ShutdownRequested()) break;\n     } while (pindexNewTip != pindexMostWork);\n-    CheckBlockIndex(chainparams.GetConsensus());\n+    CheckBlockIndex();\n \n     // Write changes periodically to disk, after relay.\n-    if (!FlushStateToDisk(chainparams, state, FlushStateMode::PERIODIC)) {\n+    if (!FlushStateToDisk(state, FlushStateMode::PERIODIC)) {\n         return false;\n     }\n \n     return true;\n }\n \n-bool CChainState::PreciousBlock(BlockValidationState& state, const CChainParams& params, CBlockIndex *pindex)\n+bool CChainState::PreciousBlock(BlockValidationState& state, CBlockIndex* pindex)\n {\n     {\n         LOCK(cs_main);\n@@ -2761,10 +2766,10 @@ bool CChainState::PreciousBlock(BlockValidationState& state, const CChainParams&\n         }\n     }\n \n-    return ActivateBestChain(state, params, std::shared_ptr<const CBlock>());\n+    return ActivateBestChain(state, std::shared_ptr<const CBlock>());\n }\n \n-bool CChainState::InvalidateBlock(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex *pindex)\n+bool CChainState::InvalidateBlock(BlockValidationState& state, CBlockIndex* pindex)\n {\n     // Genesis block can't be invalidated\n     assert(pindex);\n@@ -2822,7 +2827,7 @@ bool CChainState::InvalidateBlock(BlockValidationState& state, const CChainParam\n         // ActivateBestChain considers blocks already in m_chain\n         // unconditionally valid already, so force disconnect away from it.\n         DisconnectedBlockTransactions disconnectpool;\n-        bool ret = DisconnectTip(state, chainparams, &disconnectpool);\n+        bool ret = DisconnectTip(state, &disconnectpool);\n         // DisconnectTip will add transactions to disconnectpool.\n         // Adjust the mempool to be consistent with the new tip, adding\n         // transactions back to the mempool if disconnecting was successful,\n@@ -2864,7 +2869,7 @@ bool CChainState::InvalidateBlock(BlockValidationState& state, const CChainParam\n         to_mark_failed = invalid_walk_tip;\n     }\n \n-    CheckBlockIndex(chainparams.GetConsensus());\n+    CheckBlockIndex();\n \n     {\n         LOCK(cs_main);\n@@ -2975,15 +2980,15 @@ CBlockIndex* BlockManager::AddToBlockIndex(const CBlockHeader& block)\n }\n \n /** Mark a block as having its data received and checked (up to BLOCK_VALID_TRANSACTIONS). */\n-void CChainState::ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pindexNew, const FlatFilePos& pos, const Consensus::Params& consensusParams)\n+void CChainState::ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pindexNew, const FlatFilePos& pos)\n {\n     pindexNew->nTx = block.vtx.size();\n     pindexNew->nChainTx = 0;\n     pindexNew->nFile = pos.nFile;\n     pindexNew->nDataPos = pos.nPos;\n     pindexNew->nUndoPos = 0;\n     pindexNew->nStatus |= BLOCK_HAVE_DATA;\n-    if (IsWitnessEnabled(pindexNew->pprev, consensusParams)) {\n+    if (IsWitnessEnabled(pindexNew->pprev, m_params.GetConsensus())) {\n         pindexNew->nStatus |= BLOCK_OPT_WITNESS;\n     }\n     pindexNew->RaiseValidity(BLOCK_VALID_TRANSACTIONS);\n@@ -3400,7 +3405,7 @@ bool ChainstateManager::ProcessNewBlockHeaders(const std::vector<CBlockHeader>&\n             CBlockIndex *pindex = nullptr; // Use a temp pindex instead of ppindex to avoid a const_cast\n             bool accepted = m_blockman.AcceptBlockHeader(\n                 header, state, chainparams, &pindex);\n-            ActiveChainstate().CheckBlockIndex(chainparams.GetConsensus());\n+            ActiveChainstate().CheckBlockIndex();\n \n             if (!accepted) {\n                 return false;\n@@ -3419,7 +3424,7 @@ bool ChainstateManager::ProcessNewBlockHeaders(const std::vector<CBlockHeader>&\n }\n \n /** Store block on disk. If dbp is non-nullptr, the file is known to already reside on disk */\n-bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex, bool fRequested, const FlatFilePos* dbp, bool* fNewBlock)\n+bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockValidationState& state, CBlockIndex** ppindex, bool fRequested, const FlatFilePos* dbp, bool* fNewBlock)\n {\n     const CBlock& block = *pblock;\n \n@@ -3429,8 +3434,8 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, Block\n     CBlockIndex *pindexDummy = nullptr;\n     CBlockIndex *&pindex = ppindex ? *ppindex : pindexDummy;\n \n-    bool accepted_header = m_blockman.AcceptBlockHeader(block, state, chainparams, &pindex);\n-    CheckBlockIndex(chainparams.GetConsensus());\n+    bool accepted_header = m_blockman.AcceptBlockHeader(block, state, m_params, &pindex);\n+    CheckBlockIndex();\n \n     if (!accepted_header)\n         return false;\n@@ -3467,8 +3472,8 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, Block\n         if (pindex->nChainWork < nMinimumChainWork) return true;\n     }\n \n-    if (!CheckBlock(block, state, chainparams.GetConsensus()) ||\n-        !ContextualCheckBlock(block, state, chainparams.GetConsensus(), pindex->pprev)) {\n+    if (!CheckBlock(block, state, m_params.GetConsensus()) ||\n+        !ContextualCheckBlock(block, state, m_params.GetConsensus(), pindex->pprev)) {\n         if (state.IsInvalid() && state.GetResult() != BlockValidationResult::BLOCK_MUTATED) {\n             pindex->nStatus |= BLOCK_FAILED_VALID;\n             setDirtyBlockIndex.insert(pindex);\n@@ -3484,19 +3489,19 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, Block\n     // Write block to history file\n     if (fNewBlock) *fNewBlock = true;\n     try {\n-        FlatFilePos blockPos = SaveBlockToDisk(block, pindex->nHeight, m_chain, chainparams, dbp);\n+        FlatFilePos blockPos = SaveBlockToDisk(block, pindex->nHeight, m_chain, m_params, dbp);\n         if (blockPos.IsNull()) {\n             state.Error(strprintf(\"%s: Failed to find position to write new block to disk\", __func__));\n             return false;\n         }\n-        ReceivedBlockTransactions(block, pindex, blockPos, chainparams.GetConsensus());\n+        ReceivedBlockTransactions(block, pindex, blockPos);\n     } catch (const std::runtime_error& e) {\n         return AbortNode(state, std::string(\"System error: \") + e.what());\n     }\n \n-    FlushStateToDisk(chainparams, state, FlushStateMode::NONE);\n+    FlushStateToDisk(state, FlushStateMode::NONE);\n \n-    CheckBlockIndex(chainparams.GetConsensus());\n+    CheckBlockIndex();\n \n     return true;\n }\n@@ -3522,7 +3527,7 @@ bool ChainstateManager::ProcessNewBlock(const CChainParams& chainparams, const s\n         bool ret = CheckBlock(*block, state, chainparams.GetConsensus());\n         if (ret) {\n             // Store to disk\n-            ret = ActiveChainstate().AcceptBlock(block, state, chainparams, &pindex, force_processing, nullptr, new_block);\n+            ret = ActiveChainstate().AcceptBlock(block, state, &pindex, force_processing, nullptr, new_block);\n         }\n         if (!ret) {\n             GetMainSignals().BlockChecked(*block, state);\n@@ -3533,8 +3538,9 @@ bool ChainstateManager::ProcessNewBlock(const CChainParams& chainparams, const s\n     NotifyHeaderTip(ActiveChainstate());\n \n     BlockValidationState state; // Only used to report errors, not invalidity - ignore it\n-    if (!ActiveChainstate().ActivateBestChain(state, chainparams, block))\n+    if (!ActiveChainstate().ActivateBestChain(state, block)) {\n         return error(\"%s: ActivateBestChain failed (%s)\", __func__, state.ToString());\n+    }\n \n     return true;\n }\n@@ -3563,8 +3569,9 @@ bool TestBlockValidity(BlockValidationState& state,\n         return error(\"%s: Consensus::CheckBlock: %s\", __func__, state.ToString());\n     if (!ContextualCheckBlock(block, state, chainparams.GetConsensus(), pindexPrev))\n         return error(\"%s: Consensus::ContextualCheckBlock: %s\", __func__, state.ToString());\n-    if (!chainstate.ConnectBlock(block, state, &indexDummy, viewNew, chainparams, true))\n+    if (!chainstate.ConnectBlock(block, state, &indexDummy, viewNew, true)) {\n         return false;\n+    }\n     assert(state.IsValid());\n \n     return true;\n@@ -3635,9 +3642,8 @@ void BlockManager::FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nM\n void PruneBlockFilesManual(CChainState& active_chainstate, int nManualPruneHeight)\n {\n     BlockValidationState state;\n-    const CChainParams& chainparams = Params();\n     if (!active_chainstate.FlushStateToDisk(\n-            chainparams, state, FlushStateMode::NONE, nManualPruneHeight)) {\n+            state, FlushStateMode::NONE, nManualPruneHeight)) {\n         LogPrintf(\"%s: failed to flush state (%s)\\n\", __func__, state.ToString());\n     }\n }\n@@ -3787,10 +3793,10 @@ void BlockManager::Unload() {\n     m_block_index.clear();\n }\n \n-bool CChainState::LoadBlockIndexDB(const CChainParams& chainparams)\n+bool CChainState::LoadBlockIndexDB()\n {\n     if (!m_blockman.LoadBlockIndex(\n-            chainparams.GetConsensus(), *pblocktree,\n+            m_params.GetConsensus(), *pblocktree,\n             setBlockIndexCandidates)) {\n         return false;\n     }\n@@ -3850,7 +3856,7 @@ void CChainState::LoadMempool(const ArgsManager& args)\n     m_mempool.SetIsLoaded(!ShutdownRequested());\n }\n \n-bool CChainState::LoadChainTip(const CChainParams& chainparams)\n+bool CChainState::LoadChainTip()\n {\n     AssertLockHeld(cs_main);\n     const CCoinsViewCache& coins_cache = CoinsTip();\n@@ -3871,10 +3877,10 @@ bool CChainState::LoadChainTip(const CChainParams& chainparams)\n \n     tip = m_chain.Tip();\n     LogPrintf(\"Loaded best chain: hashBestChain=%s height=%d date=%s progress=%f\\n\",\n-        tip->GetBlockHash().ToString(),\n-        m_chain.Height(),\n-        FormatISO8601DateTime(tip->GetBlockTime()),\n-        GuessVerificationProgress(chainparams.TxData(), tip));\n+              tip->GetBlockHash().ToString(),\n+              m_chain.Height(),\n+              FormatISO8601DateTime(tip->GetBlockTime()),\n+              GuessVerificationProgress(m_params.TxData(), tip));\n     return true;\n }\n \n@@ -3985,8 +3991,9 @@ bool CVerifyDB::VerifyDB(\n             CBlock block;\n             if (!ReadBlockFromDisk(block, pindex, chainparams.GetConsensus()))\n                 return error(\"VerifyDB(): *** ReadBlockFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n-            if (!chainstate.ConnectBlock(block, state, pindex, coins, chainparams))\n+            if (!chainstate.ConnectBlock(block, state, pindex, coins)) {\n                 return error(\"VerifyDB(): *** found unconnectable block at %d, hash=%s (%s)\", pindex->nHeight, pindex->GetBlockHash().ToString(), state.ToString());\n+            }\n             if (ShutdownRequested()) return true;\n         }\n     }\n@@ -3998,11 +4005,11 @@ bool CVerifyDB::VerifyDB(\n }\n \n /** Apply the effects of a block on the utxo cache, ignoring that it may already have been applied. */\n-bool CChainState::RollforwardBlock(const CBlockIndex* pindex, CCoinsViewCache& inputs, const CChainParams& params)\n+bool CChainState::RollforwardBlock(const CBlockIndex* pindex, CCoinsViewCache& inputs)\n {\n     // TODO: merge with ConnectBlock\n     CBlock block;\n-    if (!ReadBlockFromDisk(block, pindex, params.GetConsensus())) {\n+    if (!ReadBlockFromDisk(block, pindex, m_params.GetConsensus())) {\n         return error(\"ReplayBlock(): ReadBlockFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n     }\n \n@@ -4018,7 +4025,7 @@ bool CChainState::RollforwardBlock(const CBlockIndex* pindex, CCoinsViewCache& i\n     return true;\n }\n \n-bool CChainState::ReplayBlocks(const CChainParams& params)\n+bool CChainState::ReplayBlocks()\n {\n     LOCK(cs_main);\n \n@@ -4054,7 +4061,7 @@ bool CChainState::ReplayBlocks(const CChainParams& params)\n     while (pindexOld != pindexFork) {\n         if (pindexOld->nHeight > 0) { // Never disconnect the genesis block.\n             CBlock block;\n-            if (!ReadBlockFromDisk(block, pindexOld, params.GetConsensus())) {\n+            if (!ReadBlockFromDisk(block, pindexOld, m_params.GetConsensus())) {\n                 return error(\"RollbackBlock(): ReadBlockFromDisk() failed at %d, hash=%s\", pindexOld->nHeight, pindexOld->GetBlockHash().ToString());\n             }\n             LogPrintf(\"Rolling back %s (%i)\\n\", pindexOld->GetBlockHash().ToString(), pindexOld->nHeight);\n@@ -4076,7 +4083,7 @@ bool CChainState::ReplayBlocks(const CChainParams& params)\n         const CBlockIndex* pindex = pindexNew->GetAncestor(nHeight);\n         LogPrintf(\"Rolling forward %s (%i)\\n\", pindex->GetBlockHash().ToString(), nHeight);\n         uiInterface.ShowProgress(_(\"Replaying blocks\u2026\").translated, (int) ((nHeight - nForkHeight) * 100.0 / (pindexNew->nHeight - nForkHeight)) , false);\n-        if (!RollforwardBlock(pindex, cache, params)) return false;\n+        if (!RollforwardBlock(pindex, cache)) return false;\n     }\n \n     cache.SetBestBlock(pindexNew->GetBlockHash());\n@@ -4085,13 +4092,13 @@ bool CChainState::ReplayBlocks(const CChainParams& params)\n     return true;\n }\n \n-bool CChainState::NeedsRedownload(const CChainParams& params) const\n+bool CChainState::NeedsRedownload() const\n {\n     AssertLockHeld(cs_main);\n \n-    // At and above params.SegwitHeight, segwit consensus rules must be validated\n+    // At and above m_params.SegwitHeight, segwit consensus rules must be validated\n     CBlockIndex* block{m_chain.Tip()};\n-    const int segwit_height{params.GetConsensus().SegwitHeight};\n+    const int segwit_height{m_params.GetConsensus().SegwitHeight};\n \n     while (block != nullptr && block->nHeight >= segwit_height) {\n         if (!(block->nStatus & BLOCK_OPT_WITNESS)) {\n@@ -4130,13 +4137,13 @@ void UnloadBlockIndex(CTxMemPool* mempool, ChainstateManager& chainman)\n     fHavePruned = false;\n }\n \n-bool ChainstateManager::LoadBlockIndex(const CChainParams& chainparams)\n+bool ChainstateManager::LoadBlockIndex()\n {\n     AssertLockHeld(cs_main);\n     // Load block index from databases\n     bool needs_init = fReindex;\n     if (!fReindex) {\n-        bool ret = ActiveChainstate().LoadBlockIndexDB(chainparams);\n+        bool ret = ActiveChainstate().LoadBlockIndexDB();\n         if (!ret) return false;\n         needs_init = m_blockman.m_block_index.empty();\n     }\n@@ -4153,32 +4160,32 @@ bool ChainstateManager::LoadBlockIndex(const CChainParams& chainparams)\n     return true;\n }\n \n-bool CChainState::LoadGenesisBlock(const CChainParams& chainparams)\n+bool CChainState::LoadGenesisBlock()\n {\n     LOCK(cs_main);\n \n     // Check whether we're already initialized by checking for genesis in\n     // m_blockman.m_block_index. Note that we can't use m_chain here, since it is\n     // set based on the coins db, not the block index db, which is the only\n     // thing loaded at this point.\n-    if (m_blockman.m_block_index.count(chainparams.GenesisBlock().GetHash()))\n+    if (m_blockman.m_block_index.count(m_params.GenesisBlock().GetHash()))\n         return true;\n \n     try {\n-        const CBlock& block = chainparams.GenesisBlock();\n-        FlatFilePos blockPos = SaveBlockToDisk(block, 0, m_chain, chainparams, nullptr);\n+        const CBlock& block = m_params.GenesisBlock();\n+        FlatFilePos blockPos = SaveBlockToDisk(block, 0, m_chain, m_params, nullptr);\n         if (blockPos.IsNull())\n             return error(\"%s: writing genesis block to disk failed\", __func__);\n         CBlockIndex *pindex = m_blockman.AddToBlockIndex(block);\n-        ReceivedBlockTransactions(block, pindex, blockPos, chainparams.GetConsensus());\n+        ReceivedBlockTransactions(block, pindex, blockPos);\n     } catch (const std::runtime_error& e) {\n         return error(\"%s: failed to write genesis block: %s\", __func__, e.what());\n     }\n \n     return true;\n }\n \n-void CChainState::LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, FlatFilePos* dbp)\n+void CChainState::LoadExternalBlockFile(FILE* fileIn, FlatFilePos* dbp)\n {\n     // Map of disk positions for blocks with unknown parent (only used for reindex)\n     static std::multimap<uint256, FlatFilePos> mapBlocksUnknownParent;\n@@ -4199,11 +4206,12 @@ void CChainState::LoadExternalBlockFile(const CChainParams& chainparams, FILE* f\n             try {\n                 // locate a header\n                 unsigned char buf[CMessageHeader::MESSAGE_START_SIZE];\n-                blkdat.FindByte(chainparams.MessageStart()[0]);\n+                blkdat.FindByte(m_params.MessageStart()[0]);\n                 nRewind = blkdat.GetPos()+1;\n                 blkdat >> buf;\n-                if (memcmp(buf, chainparams.MessageStart(), CMessageHeader::MESSAGE_START_SIZE))\n+                if (memcmp(buf, m_params.MessageStart(), CMessageHeader::MESSAGE_START_SIZE)) {\n                     continue;\n+                }\n                 // read size\n                 blkdat >> nSize;\n                 if (nSize < 80 || nSize > MAX_BLOCK_SERIALIZED_SIZE)\n@@ -4227,7 +4235,7 @@ void CChainState::LoadExternalBlockFile(const CChainParams& chainparams, FILE* f\n                 {\n                     LOCK(cs_main);\n                     // detect out of order blocks, and store them for later\n-                    if (hash != chainparams.GetConsensus().hashGenesisBlock && !m_blockman.LookupBlockIndex(block.hashPrevBlock)) {\n+                    if (hash != m_params.GetConsensus().hashGenesisBlock && !m_blockman.LookupBlockIndex(block.hashPrevBlock)) {\n                         LogPrint(BCLog::REINDEX, \"%s: Out of order block %s, parent %s not known\\n\", __func__, hash.ToString(),\n                                 block.hashPrevBlock.ToString());\n                         if (dbp)\n@@ -4239,21 +4247,21 @@ void CChainState::LoadExternalBlockFile(const CChainParams& chainparams, FILE* f\n                     CBlockIndex* pindex = m_blockman.LookupBlockIndex(hash);\n                     if (!pindex || (pindex->nStatus & BLOCK_HAVE_DATA) == 0) {\n                       BlockValidationState state;\n-                      if (AcceptBlock(pblock, state, chainparams, nullptr, true, dbp, nullptr)) {\n+                      if (AcceptBlock(pblock, state, nullptr, true, dbp, nullptr)) {\n                           nLoaded++;\n                       }\n                       if (state.IsError()) {\n                           break;\n                       }\n-                    } else if (hash != chainparams.GetConsensus().hashGenesisBlock && pindex->nHeight % 1000 == 0) {\n-                      LogPrint(BCLog::REINDEX, \"Block Import: already had block %s at height %d\\n\", hash.ToString(), pindex->nHeight);\n+                    } else if (hash != m_params.GetConsensus().hashGenesisBlock && pindex->nHeight % 1000 == 0) {\n+                        LogPrint(BCLog::REINDEX, \"Block Import: already had block %s at height %d\\n\", hash.ToString(), pindex->nHeight);\n                     }\n                 }\n \n                 // Activate the genesis block so normal node progress can continue\n-                if (hash == chainparams.GetConsensus().hashGenesisBlock) {\n+                if (hash == m_params.GetConsensus().hashGenesisBlock) {\n                     BlockValidationState state;\n-                    if (!ActivateBestChain(state, chainparams, nullptr)) {\n+                    if (!ActivateBestChain(state, nullptr)) {\n                         break;\n                     }\n                 }\n@@ -4270,14 +4278,12 @@ void CChainState::LoadExternalBlockFile(const CChainParams& chainparams, FILE* f\n                     while (range.first != range.second) {\n                         std::multimap<uint256, FlatFilePos>::iterator it = range.first;\n                         std::shared_ptr<CBlock> pblockrecursive = std::make_shared<CBlock>();\n-                        if (ReadBlockFromDisk(*pblockrecursive, it->second, chainparams.GetConsensus()))\n-                        {\n+                        if (ReadBlockFromDisk(*pblockrecursive, it->second, m_params.GetConsensus())) {\n                             LogPrint(BCLog::REINDEX, \"%s: Processing out of order child %s of %s\\n\", __func__, pblockrecursive->GetHash().ToString(),\n                                     head.ToString());\n                             LOCK(cs_main);\n                             BlockValidationState dummy;\n-                            if (AcceptBlock(pblockrecursive, dummy, chainparams, nullptr, true, &it->second, nullptr))\n-                            {\n+                            if (AcceptBlock(pblockrecursive, dummy, nullptr, true, &it->second, nullptr)) {\n                                 nLoaded++;\n                                 queue.push_back(pblockrecursive->GetHash());\n                             }\n@@ -4297,7 +4303,7 @@ void CChainState::LoadExternalBlockFile(const CChainParams& chainparams, FILE* f\n     LogPrintf(\"Loaded %i blocks from external file in %dms\\n\", nLoaded, GetTimeMillis() - nStart);\n }\n \n-void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n+void CChainState::CheckBlockIndex()\n {\n     if (!fCheckBlockIndex) {\n         return;\n@@ -4351,7 +4357,7 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n         // Begin: actual consistency checks.\n         if (pindex->pprev == nullptr) {\n             // Genesis block checks.\n-            assert(pindex->GetBlockHash() == consensusParams.hashGenesisBlock); // Genesis block's hash must match.\n+            assert(pindex->GetBlockHash() == m_params.GetConsensus().hashGenesisBlock); // Genesis block's hash must match.\n             assert(pindex == m_chain.Genesis()); // The current active chain's genesis block must be this block.\n         }\n         if (!pindex->HaveTxsDownloaded()) assert(pindex->nSequenceId <= 0); // nSequenceId can't be set positive for blocks that aren't linked (negative is used for preciousblock)\n@@ -4511,10 +4517,10 @@ bool CChainState::ResizeCoinsCaches(size_t coinstip_size, size_t coinsdb_size)\n \n     if (coinstip_size > old_coinstip_size) {\n         // Likely no need to flush if cache sizes have grown.\n-        ret = FlushStateToDisk(m_params, state, FlushStateMode::IF_NEEDED);\n+        ret = FlushStateToDisk(state, FlushStateMode::IF_NEEDED);\n     } else {\n         // Otherwise, flush state to disk and deallocate the in-memory coins map.\n-        ret = FlushStateToDisk(m_params, state, FlushStateMode::ALWAYS);\n+        ret = FlushStateToDisk(state, FlushStateMode::ALWAYS);\n         CoinsTip().ReallocateCache();\n     }\n     return ret;\n@@ -4814,7 +4820,7 @@ bool ChainstateManager::ActivateSnapshot(\n         LOCK(::cs_main);\n         assert(!m_snapshot_chainstate);\n         m_snapshot_chainstate.swap(snapshot_chainstate);\n-        const bool chaintip_loaded = m_snapshot_chainstate->LoadChainTip(::Params());\n+        const bool chaintip_loaded = m_snapshot_chainstate->LoadChainTip();\n         assert(chaintip_loaded);\n \n         m_active_chainstate = m_snapshot_chainstate.get();"
      },
      {
        "sha": "fc702b7183086cefc0a1208e5184167029c8dd24",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 19,
        "deletions": 21,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0d9211ef87a682573aaae932c0c440acbcb8a8/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0d9211ef87a682573aaae932c0c440acbcb8a8/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=fa0d9211ef87a682573aaae932c0c440acbcb8a8",
        "patch": "@@ -682,7 +682,7 @@ class CChainState\n         EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n \n     /** Import blocks from an external file */\n-    void LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, FlatFilePos* dbp = nullptr);\n+    void LoadExternalBlockFile(FILE* fileIn, FlatFilePos* dbp = nullptr);\n \n     /**\n      * Update the on-disk chain state.\n@@ -696,8 +696,7 @@ class CChainState\n      * @returns true unless a system error occurred\n      */\n     bool FlushStateToDisk(\n-        const CChainParams& chainparams,\n-        BlockValidationState &state,\n+        BlockValidationState& state,\n         FlushStateMode mode,\n         int nManualPruneHeight = 0);\n \n@@ -725,37 +724,36 @@ class CChainState\n      */\n     bool ActivateBestChain(\n         BlockValidationState& state,\n-        const CChainParams& chainparams,\n         std::shared_ptr<const CBlock> pblock = nullptr) LOCKS_EXCLUDED(cs_main);\n \n-    bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex, bool fRequested, const FlatFilePos* dbp, bool* fNewBlock) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockValidationState& state, CBlockIndex** ppindex, bool fRequested, const FlatFilePos* dbp, bool* fNewBlock) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     // Block (dis)connection on a given view:\n     DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex* pindex, CCoinsViewCache& view);\n     bool ConnectBlock(const CBlock& block, BlockValidationState& state, CBlockIndex* pindex,\n-                      CCoinsViewCache& view, const CChainParams& chainparams, bool fJustCheck = false) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+                      CCoinsViewCache& view, bool fJustCheck = false) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     // Apply the effects of a block disconnection on the UTXO set.\n-    bool DisconnectTip(BlockValidationState& state, const CChainParams& chainparams, DisconnectedBlockTransactions* disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_mempool.cs);\n+    bool DisconnectTip(BlockValidationState& state, DisconnectedBlockTransactions* disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_mempool.cs);\n \n     // Manual block validity manipulation:\n     /** Mark a block as precious and reorganize.\n      *\n      * May not be called in a validationinterface callback.\n      */\n-    bool PreciousBlock(BlockValidationState& state, const CChainParams& params, CBlockIndex* pindex) LOCKS_EXCLUDED(cs_main);\n+    bool PreciousBlock(BlockValidationState& state, CBlockIndex* pindex) LOCKS_EXCLUDED(cs_main);\n     /** Mark a block as invalid. */\n-    bool InvalidateBlock(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindex) LOCKS_EXCLUDED(cs_main);\n+    bool InvalidateBlock(BlockValidationState& state, CBlockIndex* pindex) LOCKS_EXCLUDED(cs_main);\n     /** Remove invalidity status from a block and its descendants. */\n     void ResetBlockFailureFlags(CBlockIndex* pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     /** Replay blocks that aren't fully applied to the database. */\n-    bool ReplayBlocks(const CChainParams& params);\n+    bool ReplayBlocks();\n \n     /** Whether the chain state needs to be redownloaded due to lack of witness data */\n-    [[nodiscard]] bool NeedsRedownload(const CChainParams& params) const EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    [[nodiscard]] bool NeedsRedownload() const EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     /** Ensures we have a genesis block in the block tree, possibly writing one to disk. */\n-    bool LoadGenesisBlock(const CChainParams& chainparams);\n+    bool LoadGenesisBlock();\n \n     void PruneBlockIndexCandidates();\n \n@@ -769,13 +767,13 @@ class CChainState\n      *\n      * By default this only executes fully when using the Regtest chain; see: fCheckBlockIndex.\n      */\n-    void CheckBlockIndex(const Consensus::Params& consensusParams);\n+    void CheckBlockIndex();\n \n     /** Load the persisted mempool from disk */\n     void LoadMempool(const ArgsManager& args);\n \n     /** Update the chain tip based on database information, i.e. CoinsTip()'s best block. */\n-    bool LoadChainTip(const CChainParams& chainparams) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool LoadChainTip() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     //! Dictates whether we need to flush the cache to disk or not.\n     //!\n@@ -791,19 +789,19 @@ class CChainState\n     std::string ToString() EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n \n private:\n-    bool ActivateBestChainStep(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_mempool.cs);\n-    bool ConnectTip(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions& disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_mempool.cs);\n+    bool ActivateBestChainStep(BlockValidationState& state, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_mempool.cs);\n+    bool ConnectTip(BlockValidationState& state, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions& disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_mempool.cs);\n \n-    void InvalidBlockFound(CBlockIndex *pindex, const BlockValidationState &state) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    void InvalidBlockFound(CBlockIndex* pindex, const BlockValidationState& state) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     CBlockIndex* FindMostWorkChain() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-    void ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pindexNew, const FlatFilePos& pos, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    void ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pindexNew, const FlatFilePos& pos) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n-    bool RollforwardBlock(const CBlockIndex* pindex, CCoinsViewCache& inputs, const CChainParams& params) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool RollforwardBlock(const CBlockIndex* pindex, CCoinsViewCache& inputs) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     void CheckForkWarningConditions() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     void InvalidChainFound(CBlockIndex* pindexNew) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n-    bool LoadBlockIndexDB(const CChainParams& chainparams) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool LoadBlockIndexDB() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     friend ChainstateManager;\n };\n@@ -1004,7 +1002,7 @@ class ChainstateManager\n     bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& block, BlockValidationState& state, const CChainParams& chainparams, const CBlockIndex** ppindex = nullptr) LOCKS_EXCLUDED(cs_main);\n \n     //! Load the block tree and coins database from disk, initializing state if we're running with -reindex\n-    bool LoadBlockIndex(const CChainParams& chainparams) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool LoadBlockIndex() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     //! Unload block index and chain data before shutdown.\n     void Unload() EXCLUSIVE_LOCKS_REQUIRED(::cs_main);"
      }
    ]
  }
]