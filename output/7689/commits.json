[
  {
    "sha": "a545127fbccef4ee674d18d43732ce00ba97f782",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNTQ1MTI3ZmJjY2VmNGVlNjc0ZDE4ZDQzNzMyY2UwMGJhOTdmNzgy",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-05-11T17:36:38Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-05-11T17:36:38Z"
      },
      "message": "Squashed 'src/crypto/ctaes/' content from commit cd3c3ac\n\ngit-subtree-dir: src/crypto/ctaes\ngit-subtree-split: cd3c3ac31fac41cc253bf5780b55ecd8d7368545",
      "tree": {
        "sha": "a0c8e75d42b565fdecd0617aec69c7e3d6c79232",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a0c8e75d42b565fdecd0617aec69c7e3d6c79232"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a545127fbccef4ee674d18d43732ce00ba97f782",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a545127fbccef4ee674d18d43732ce00ba97f782",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a545127fbccef4ee674d18d43732ce00ba97f782",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a545127fbccef4ee674d18d43732ce00ba97f782/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [],
    "stats": {
      "total": 939,
      "additions": 939,
      "deletions": 0
    },
    "files": [
      {
        "sha": "415b202a2a54eb92e6283f4c6b3e40667cedc341",
        "filename": "COPYING",
        "status": "added",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a545127fbccef4ee674d18d43732ce00ba97f782/COPYING",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a545127fbccef4ee674d18d43732ce00ba97f782/COPYING",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/COPYING?ref=a545127fbccef4ee674d18d43732ce00ba97f782",
        "patch": "@@ -0,0 +1,21 @@\n+The MIT License (MIT)\n+\n+Copyright (c) 2016 Pieter Wuille\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in\n+all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+THE SOFTWARE."
      },
      {
        "sha": "0e7fe1775153e2f14f976fa8826d5f73927cc6e1",
        "filename": "README.md",
        "status": "added",
        "additions": 41,
        "deletions": 0,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a545127fbccef4ee674d18d43732ce00ba97f782/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a545127fbccef4ee674d18d43732ce00ba97f782/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/README.md?ref=a545127fbccef4ee674d18d43732ce00ba97f782",
        "patch": "@@ -0,0 +1,41 @@\n+ctaes\n+=====\n+\n+Simple C module for constant-time AES encryption and decryption.\n+\n+Features:\n+* Simple, pure C code without any dependencies.\n+* No tables or data-dependent branches whatsoever, but using bit sliced approach from https://eprint.iacr.org/2009/129.pdf.\n+* Very small object code: slightly over 4k of executable code when compiled with -Os.\n+* Slower than implementations based on precomputed tables or specialized instructions, but can do ~15 MB/s on modern CPUs.\n+\n+Performance\n+-----------\n+\n+Compiled with GCC 5.3.1 with -O3, on an Intel(R) Core(TM) i7-4800MQ CPU, numbers in CPU cycles:\n+\n+| Algorithm | Key schedule | Encryption per byte | Decryption per byte |\n+| --------- | ------------:| -------------------:| -------------------:|\n+| AES-128   |         2.8k |                 154 |                 161 |\n+| AES-192   |         3.1k |                 169 |                 181 |\n+| AES-256   |         4.0k |                 191 |                 203 |\n+\n+Build steps\n+-----------\n+\n+Object code:\n+\n+    $ gcc -O3 ctaes.c -c -o ctaes.o\n+\n+Tests:\n+\n+    $ gcc -O3 ctaes.c test.c -o test\n+\n+Benchmark:\n+\n+    $ gcc -O3 ctaes.c bench.c -o bench\n+\n+Review\n+------\n+\n+Results of a formal review of the code can be found in http://bitcoin.sipa.be/ctaes/review.zip"
      },
      {
        "sha": "a86df496c830083be2d4e007137897900e201a0f",
        "filename": "bench.c",
        "status": "added",
        "additions": 170,
        "deletions": 0,
        "changes": 170,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a545127fbccef4ee674d18d43732ce00ba97f782/bench.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a545127fbccef4ee674d18d43732ce00ba97f782/bench.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/bench.c?ref=a545127fbccef4ee674d18d43732ce00ba97f782",
        "patch": "@@ -0,0 +1,170 @@\n+#include <stdio.h>\n+#include <math.h>\n+#include \"sys/time.h\"\n+\n+#include \"ctaes.h\"\n+\n+static double gettimedouble(void) {\n+    struct timeval tv;\n+    gettimeofday(&tv, NULL);\n+    return tv.tv_usec * 0.000001 + tv.tv_sec;\n+}\n+\n+static void print_number(double x) {\n+    double y = x;\n+    int c = 0;\n+    if (y < 0.0) {\n+        y = -y;\n+    }\n+    while (y < 100.0) {\n+        y *= 10.0;\n+        c++;\n+    }\n+    printf(\"%.*f\", c, x);\n+}\n+\n+static void run_benchmark(char *name, void (*benchmark)(void*), void (*setup)(void*), void (*teardown)(void*), void* data, int count, int iter) {\n+    int i;\n+    double min = HUGE_VAL;\n+    double sum = 0.0;\n+    double max = 0.0;\n+    for (i = 0; i < count; i++) {\n+        double begin, total;\n+        if (setup != NULL) {\n+            setup(data);\n+        }\n+        begin = gettimedouble();\n+        benchmark(data);\n+        total = gettimedouble() - begin;\n+        if (teardown != NULL) {\n+            teardown(data);\n+        }\n+        if (total < min) {\n+            min = total;\n+        }\n+        if (total > max) {\n+            max = total;\n+        }\n+        sum += total;\n+    }\n+    printf(\"%s: min \", name);\n+    print_number(min * 1000000000.0 / iter);\n+    printf(\"ns / avg \");\n+    print_number((sum / count) * 1000000000.0 / iter);\n+    printf(\"ns / max \");\n+    print_number(max * 1000000000.0 / iter);\n+    printf(\"ns\\n\");\n+}\n+\n+static void bench_AES128_init(void* data) {\n+    AES128_ctx* ctx = (AES128_ctx*)data;\n+    int i;\n+    for (i = 0; i < 50000; i++) {\n+        AES128_init(ctx, (unsigned char*)ctx);\n+    }\n+}\n+\n+static void bench_AES128_encrypt_setup(void* data) {\n+    AES128_ctx* ctx = (AES128_ctx*)data;\n+    static const unsigned char key[16] = {0};\n+    AES128_init(ctx, key);\n+}\n+\n+static void bench_AES128_encrypt(void* data) {\n+    const AES128_ctx* ctx = (const AES128_ctx*)data;\n+    unsigned char scratch[16] = {0};\n+    int i;\n+    for (i = 0; i < 4000000 / 16; i++) {\n+        AES128_encrypt(ctx, 1, scratch, scratch);\n+    }\n+}\n+\n+static void bench_AES128_decrypt(void* data) {\n+    const AES128_ctx* ctx = (const AES128_ctx*)data;\n+    unsigned char scratch[16] = {0};\n+    int i;\n+    for (i = 0; i < 4000000 / 16; i++) {\n+        AES128_decrypt(ctx, 1, scratch, scratch);\n+    }\n+}\n+\n+static void bench_AES192_init(void* data) {\n+    AES192_ctx* ctx = (AES192_ctx*)data;\n+    int i;\n+    for (i = 0; i < 50000; i++) {\n+        AES192_init(ctx, (unsigned char*)ctx);\n+    }\n+}\n+\n+static void bench_AES192_encrypt_setup(void* data) {\n+    AES192_ctx* ctx = (AES192_ctx*)data;\n+    static const unsigned char key[16] = {0};\n+    AES192_init(ctx, key);\n+}\n+\n+static void bench_AES192_encrypt(void* data) {\n+    const AES192_ctx* ctx = (const AES192_ctx*)data;\n+    unsigned char scratch[16] = {0};\n+    int i;\n+    for (i = 0; i < 4000000 / 16; i++) {\n+        AES192_encrypt(ctx, 1, scratch, scratch);\n+    }\n+}\n+\n+static void bench_AES192_decrypt(void* data) {\n+    const AES192_ctx* ctx = (const AES192_ctx*)data;\n+    unsigned char scratch[16] = {0};\n+    int i;\n+    for (i = 0; i < 4000000 / 16; i++) {\n+        AES192_decrypt(ctx, 1, scratch, scratch);\n+    }\n+}\n+\n+static void bench_AES256_init(void* data) {\n+    AES256_ctx* ctx = (AES256_ctx*)data;\n+    int i;\n+    for (i = 0; i < 50000; i++) {\n+        AES256_init(ctx, (unsigned char*)ctx);\n+    }\n+}\n+\n+\n+static void bench_AES256_encrypt_setup(void* data) {\n+    AES256_ctx* ctx = (AES256_ctx*)data;\n+    static const unsigned char key[16] = {0};\n+    AES256_init(ctx, key);\n+}\n+\n+static void bench_AES256_encrypt(void* data) {\n+    const AES256_ctx* ctx = (const AES256_ctx*)data;\n+    unsigned char scratch[16] = {0};\n+    int i;\n+    for (i = 0; i < 4000000 / 16; i++) {\n+        AES256_encrypt(ctx, 1, scratch, scratch);\n+    }\n+}\n+\n+static void bench_AES256_decrypt(void* data) {\n+    const AES256_ctx* ctx = (const AES256_ctx*)data;\n+    unsigned char scratch[16] = {0};\n+    int i;\n+    for (i = 0; i < 4000000 / 16; i++) {\n+        AES256_decrypt(ctx, 1, scratch, scratch);\n+    }\n+}\n+\n+int main(void) {\n+    AES128_ctx ctx128;\n+    AES192_ctx ctx192;\n+    AES256_ctx ctx256;\n+    run_benchmark(\"aes128_init\", bench_AES128_init, NULL, NULL, &ctx128, 20, 50000);\n+    run_benchmark(\"aes128_encrypt_byte\", bench_AES128_encrypt, bench_AES128_encrypt_setup, NULL, &ctx128, 20, 4000000);\n+    run_benchmark(\"aes128_decrypt_byte\", bench_AES128_decrypt, bench_AES128_encrypt_setup, NULL, &ctx128, 20, 4000000);\n+    run_benchmark(\"aes192_init\", bench_AES192_init, NULL, NULL, &ctx192, 20, 50000);\n+    run_benchmark(\"aes192_encrypt_byte\", bench_AES192_encrypt, bench_AES192_encrypt_setup, NULL, &ctx192, 20, 4000000);\n+    run_benchmark(\"aes192_decrypt_byte\", bench_AES192_decrypt, bench_AES192_encrypt_setup, NULL, &ctx192, 20, 4000000);\n+    run_benchmark(\"aes256_init\", bench_AES256_init, NULL, NULL, &ctx256, 20, 50000);\n+    run_benchmark(\"aes256_encrypt_byte\", bench_AES256_encrypt, bench_AES256_encrypt_setup, NULL, &ctx256, 20, 4000000);\n+    run_benchmark(\"aes256_decrypt_byte\", bench_AES256_decrypt, bench_AES256_encrypt_setup, NULL, &ctx256, 20, 4000000);\n+    return 0;\n+}"
      },
      {
        "sha": "2389fc0bb254f70c0be4863fa8cc2273210b9442",
        "filename": "ctaes.c",
        "status": "added",
        "additions": 556,
        "deletions": 0,
        "changes": 556,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a545127fbccef4ee674d18d43732ce00ba97f782/ctaes.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a545127fbccef4ee674d18d43732ce00ba97f782/ctaes.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ctaes.c?ref=a545127fbccef4ee674d18d43732ce00ba97f782",
        "patch": "@@ -0,0 +1,556 @@\n+ /*********************************************************************\n+ * Copyright (c) 2016 Pieter Wuille                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* Constant time, unoptimized, concise, plain C, AES implementation\n+ * Based On:\n+ *   Emilia Kasper and Peter Schwabe, Faster and Timing-Attack Resistant AES-GCM\n+ *   http://www.iacr.org/archive/ches2009/57470001/57470001.pdf\n+ * But using 8 16-bit integers representing a single AES state rather than 8 128-bit\n+ * integers representing 8 AES states.\n+ */\n+\n+#include \"ctaes.h\"\n+\n+/* Slice variable slice_i contains the i'th bit of the 16 state variables in this order:\n+ *  0  1  2  3\n+ *  4  5  6  7\n+ *  8  9 10 11\n+ * 12 13 14 15\n+ */\n+\n+/** Convert a byte to sliced form, storing it corresponding to given row and column in s */\n+static void LoadByte(AES_state* s, unsigned char byte, int r, int c) {\n+    int i;\n+    for (i = 0; i < 8; i++) {\n+        s->slice[i] |= (byte & 1) << (r * 4 + c);\n+        byte >>= 1;\n+    }\n+}\n+\n+/** Load 16 bytes of data into 8 sliced integers */\n+static void LoadBytes(AES_state *s, const unsigned char* data16) {\n+    int c;\n+    for (c = 0; c < 4; c++) {\n+        int r;\n+        for (r = 0; r < 4; r++) {\n+            LoadByte(s, *(data16++), r, c);\n+        }\n+    }\n+}\n+\n+/** Convert 8 sliced integers into 16 bytes of data */\n+static void SaveBytes(unsigned char* data16, const AES_state *s) {\n+    int c;\n+    for (c = 0; c < 4; c++) {\n+        int r;\n+        for (r = 0; r < 4; r++) {\n+            int b;\n+            uint8_t v = 0;\n+            for (b = 0; b < 8; b++) {\n+                v |= ((s->slice[b] >> (r * 4 + c)) & 1) << b;\n+            }\n+            *(data16++) = v;\n+        }\n+    }\n+}\n+\n+/* S-box implementation based on the gate logic from:\n+ *   Joan Boyar and Rene Peralta, A depth-16 circuit for the AES S-box.\n+ *   https://eprint.iacr.org/2011/332.pdf\n+*/\n+static void SubBytes(AES_state *s, int inv) {\n+    /* Load the bit slices */\n+    uint16_t U0 = s->slice[7], U1 = s->slice[6], U2 = s->slice[5], U3 = s->slice[4];\n+    uint16_t U4 = s->slice[3], U5 = s->slice[2], U6 = s->slice[1], U7 = s->slice[0];\n+\n+    uint16_t T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16;\n+    uint16_t T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, D;\n+    uint16_t M1, M6, M11, M13, M15, M20, M21, M22, M23, M25, M37, M38, M39, M40;\n+    uint16_t M41, M42, M43, M44, M45, M46, M47, M48, M49, M50, M51, M52, M53, M54;\n+    uint16_t M55, M56, M57, M58, M59, M60, M61, M62, M63;\n+\n+    if (inv) {\n+        uint16_t R5, R13, R17, R18, R19;\n+        /* Undo linear postprocessing */\n+        T23 = U0 ^ U3;\n+        T22 = ~(U1 ^ U3);\n+        T2 = ~(U0 ^ U1);\n+        T1 = U3 ^ U4;\n+        T24 = ~(U4 ^ U7);\n+        R5 = U6 ^ U7;\n+        T8 = ~(U1 ^ T23);\n+        T19 = T22 ^ R5;\n+        T9 = ~(U7 ^ T1);\n+        T10 = T2 ^ T24;\n+        T13 = T2 ^ R5;\n+        T3 = T1 ^ R5;\n+        T25 = ~(U2 ^ T1);\n+        R13 = U1 ^ U6;\n+        T17 = ~(U2 ^ T19);\n+        T20 = T24 ^ R13;\n+        T4 = U4 ^ T8;\n+        R17 = ~(U2 ^ U5);\n+        R18 = ~(U5 ^ U6);\n+        R19 = ~(U2 ^ U4);\n+        D = U0 ^ R17;\n+        T6 = T22 ^ R17;\n+        T16 = R13 ^ R19;\n+        T27 = T1 ^ R18;\n+        T15 = T10 ^ T27;\n+        T14 = T10 ^ R18;\n+        T26 = T3 ^ T16;\n+    } else {\n+        /* Linear preprocessing. */\n+        T1 = U0 ^ U3;\n+        T2 = U0 ^ U5;\n+        T3 = U0 ^ U6;\n+        T4 = U3 ^ U5;\n+        T5 = U4 ^ U6;\n+        T6 = T1 ^ T5;\n+        T7 = U1 ^ U2;\n+        T8 = U7 ^ T6;\n+        T9 = U7 ^ T7;\n+        T10 = T6 ^ T7;\n+        T11 = U1 ^ U5;\n+        T12 = U2 ^ U5;\n+        T13 = T3 ^ T4;\n+        T14 = T6 ^ T11;\n+        T15 = T5 ^ T11;\n+        T16 = T5 ^ T12;\n+        T17 = T9 ^ T16;\n+        T18 = U3 ^ U7;\n+        T19 = T7 ^ T18;\n+        T20 = T1 ^ T19;\n+        T21 = U6 ^ U7;\n+        T22 = T7 ^ T21;\n+        T23 = T2 ^ T22;\n+        T24 = T2 ^ T10;\n+        T25 = T20 ^ T17;\n+        T26 = T3 ^ T16;\n+        T27 = T1 ^ T12;\n+        D = U7;\n+    }\n+\n+    /* Non-linear transformation (identical to the code in SubBytes) */\n+    M1 = T13 & T6;\n+    M6 = T3 & T16;\n+    M11 = T1 & T15;\n+    M13 = (T4 & T27) ^ M11;\n+    M15 = (T2 & T10) ^ M11;\n+    M20 = T14 ^ M1 ^ (T23 & T8) ^ M13;\n+    M21 = (T19 & D) ^ M1 ^ T24 ^ M15;\n+    M22 = T26 ^ M6 ^ (T22 & T9) ^ M13;\n+    M23 = (T20 & T17) ^ M6 ^ M15 ^ T25;\n+    M25 = M22 & M20;\n+    M37 = M21 ^ ((M20 ^ M21) & (M23 ^ M25));\n+    M38 = M20 ^ M25 ^ (M21 | (M20 & M23));\n+    M39 = M23 ^ ((M22 ^ M23) & (M21 ^ M25));\n+    M40 = M22 ^ M25 ^ (M23 | (M21 & M22));\n+    M41 = M38 ^ M40;\n+    M42 = M37 ^ M39;\n+    M43 = M37 ^ M38;\n+    M44 = M39 ^ M40;\n+    M45 = M42 ^ M41;\n+    M46 = M44 & T6;\n+    M47 = M40 & T8;\n+    M48 = M39 & D;\n+    M49 = M43 & T16;\n+    M50 = M38 & T9;\n+    M51 = M37 & T17;\n+    M52 = M42 & T15;\n+    M53 = M45 & T27;\n+    M54 = M41 & T10;\n+    M55 = M44 & T13;\n+    M56 = M40 & T23;\n+    M57 = M39 & T19;\n+    M58 = M43 & T3;\n+    M59 = M38 & T22;\n+    M60 = M37 & T20;\n+    M61 = M42 & T1;\n+    M62 = M45 & T4;\n+    M63 = M41 & T2;\n+\n+    if (inv){\n+        /* Undo linear preprocessing */\n+        uint16_t P0 = M52 ^ M61;\n+        uint16_t P1 = M58 ^ M59;\n+        uint16_t P2 = M54 ^ M62;\n+        uint16_t P3 = M47 ^ M50;\n+        uint16_t P4 = M48 ^ M56;\n+        uint16_t P5 = M46 ^ M51;\n+        uint16_t P6 = M49 ^ M60;\n+        uint16_t P7 = P0 ^ P1;\n+        uint16_t P8 = M50 ^ M53;\n+        uint16_t P9 = M55 ^ M63;\n+        uint16_t P10 = M57 ^ P4;\n+        uint16_t P11 = P0 ^ P3;\n+        uint16_t P12 = M46 ^ M48;\n+        uint16_t P13 = M49 ^ M51;\n+        uint16_t P14 = M49 ^ M62;\n+        uint16_t P15 = M54 ^ M59;\n+        uint16_t P16 = M57 ^ M61;\n+        uint16_t P17 = M58 ^ P2;\n+        uint16_t P18 = M63 ^ P5;\n+        uint16_t P19 = P2 ^ P3;\n+        uint16_t P20 = P4 ^ P6;\n+        uint16_t P22 = P2 ^ P7;\n+        uint16_t P23 = P7 ^ P8;\n+        uint16_t P24 = P5 ^ P7;\n+        uint16_t P25 = P6 ^ P10;\n+        uint16_t P26 = P9 ^ P11;\n+        uint16_t P27 = P10 ^ P18;\n+        uint16_t P28 = P11 ^ P25;\n+        uint16_t P29 = P15 ^ P20;\n+        s->slice[7] = P13 ^ P22;\n+        s->slice[6] = P26 ^ P29;\n+        s->slice[5] = P17 ^ P28;\n+        s->slice[4] = P12 ^ P22;\n+        s->slice[3] = P23 ^ P27;\n+        s->slice[2] = P19 ^ P24;\n+        s->slice[1] = P14 ^ P23;\n+        s->slice[0] = P9 ^ P16;\n+    } else {\n+        /* Linear postprocessing */\n+        uint16_t L0 = M61 ^ M62;\n+        uint16_t L1 = M50 ^ M56;\n+        uint16_t L2 = M46 ^ M48;\n+        uint16_t L3 = M47 ^ M55;\n+        uint16_t L4 = M54 ^ M58;\n+        uint16_t L5 = M49 ^ M61;\n+        uint16_t L6 = M62 ^ L5;\n+        uint16_t L7 = M46 ^ L3;\n+        uint16_t L8 = M51 ^ M59;\n+        uint16_t L9 = M52 ^ M53;\n+        uint16_t L10 = M53 ^ L4;\n+        uint16_t L11 = M60 ^ L2;\n+        uint16_t L12 = M48 ^ M51;\n+        uint16_t L13 = M50 ^ L0;\n+        uint16_t L14 = M52 ^ M61;\n+        uint16_t L15 = M55 ^ L1;\n+        uint16_t L16 = M56 ^ L0;\n+        uint16_t L17 = M57 ^ L1;\n+        uint16_t L18 = M58 ^ L8;\n+        uint16_t L19 = M63 ^ L4;\n+        uint16_t L20 = L0 ^ L1;\n+        uint16_t L21 = L1 ^ L7;\n+        uint16_t L22 = L3 ^ L12;\n+        uint16_t L23 = L18 ^ L2;\n+        uint16_t L24 = L15 ^ L9;\n+        uint16_t L25 = L6 ^ L10;\n+        uint16_t L26 = L7 ^ L9;\n+        uint16_t L27 = L8 ^ L10;\n+        uint16_t L28 = L11 ^ L14;\n+        uint16_t L29 = L11 ^ L17;\n+        s->slice[7] = L6 ^ L24;\n+        s->slice[6] = ~(L16 ^ L26);\n+        s->slice[5] = ~(L19 ^ L28);\n+        s->slice[4] = L6 ^ L21;\n+        s->slice[3] = L20 ^ L22;\n+        s->slice[2] = L25 ^ L29;\n+        s->slice[1] = ~(L13 ^ L27);\n+        s->slice[0] = ~(L6 ^ L23);\n+    }\n+}\n+\n+#define BIT_RANGE(from,to) (((1 << ((to) - (from))) - 1) << (from))\n+\n+#define BIT_RANGE_LEFT(x,from,to,shift) (((x) & BIT_RANGE((from), (to))) << (shift))\n+#define BIT_RANGE_RIGHT(x,from,to,shift) (((x) & BIT_RANGE((from), (to))) >> (shift))\n+\n+static void ShiftRows(AES_state* s) {\n+    int i;\n+    for (i = 0; i < 8; i++) {\n+        uint16_t v = s->slice[i];\n+        s->slice[i] =\n+            (v & BIT_RANGE(0, 4)) |\n+            BIT_RANGE_LEFT(v, 4, 5, 3) | BIT_RANGE_RIGHT(v, 5, 8, 1) |\n+            BIT_RANGE_LEFT(v, 8, 10, 2) | BIT_RANGE_RIGHT(v, 10, 12, 2) |\n+            BIT_RANGE_LEFT(v, 12, 15, 1) | BIT_RANGE_RIGHT(v, 15, 16, 3);\n+    }\n+}\n+\n+static void InvShiftRows(AES_state* s) {\n+    int i;\n+    for (i = 0; i < 8; i++) {\n+        uint16_t v = s->slice[i];\n+        s->slice[i] =\n+            (v & BIT_RANGE(0, 4)) |\n+            BIT_RANGE_LEFT(v, 4, 7, 1) | BIT_RANGE_RIGHT(v, 7, 8, 3) |\n+            BIT_RANGE_LEFT(v, 8, 10, 2) | BIT_RANGE_RIGHT(v, 10, 12, 2) |\n+            BIT_RANGE_LEFT(v, 12, 13, 3) | BIT_RANGE_RIGHT(v, 13, 16, 1);\n+    }\n+}\n+\n+#define ROT(x,b) (((x) >> ((b) * 4)) | ((x) << ((4-(b)) * 4)))\n+\n+static void MixColumns(AES_state* s, int inv) {\n+    /* The MixColumns transform treats the bytes of the columns of the state as\n+     * coefficients of a 3rd degree polynomial over GF(2^8) and multiplies them\n+     * by the fixed polynomial a(x) = {03}x^3 + {01}x^2 + {01}x + {02}, modulo\n+     * x^4 + {01}.\n+     *\n+     * In the inverse transform, we multiply by the inverse of a(x),\n+     * a^-1(x) = {0b}x^3 + {0d}x^2 + {09}x + {0e}. This is equal to\n+     * a(x) * ({04}x^2 + {05}), so we can reuse the forward transform's code\n+     * (found in OpenSSL's bsaes-x86_64.pl, attributed to Jussi Kivilinna)\n+     *\n+     * In the bitsliced representation, a multiplication of every column by x\n+     * mod x^4 + 1 is simply a right rotation.\n+     */\n+\n+    /* Shared for both directions is a multiplication by a(x), which can be\n+     * rewritten as (x^3 + x^2 + x) + {02}*(x^3 + {01}).\n+     *\n+     * First compute s into the s? variables, (x^3 + {01}) * s into the s?_01\n+     * variables and (x^3 + x^2 + x)*s into the s?_123 variables.\n+     */\n+    uint16_t s0 = s->slice[0], s1 = s->slice[1], s2 = s->slice[2], s3 = s->slice[3];\n+    uint16_t s4 = s->slice[4], s5 = s->slice[5], s6 = s->slice[6], s7 = s->slice[7];\n+    uint16_t s0_01 = s0 ^ ROT(s0, 1), s0_123 = ROT(s0_01, 1) ^ ROT(s0, 3);\n+    uint16_t s1_01 = s1 ^ ROT(s1, 1), s1_123 = ROT(s1_01, 1) ^ ROT(s1, 3);\n+    uint16_t s2_01 = s2 ^ ROT(s2, 1), s2_123 = ROT(s2_01, 1) ^ ROT(s2, 3);\n+    uint16_t s3_01 = s3 ^ ROT(s3, 1), s3_123 = ROT(s3_01, 1) ^ ROT(s3, 3);\n+    uint16_t s4_01 = s4 ^ ROT(s4, 1), s4_123 = ROT(s4_01, 1) ^ ROT(s4, 3);\n+    uint16_t s5_01 = s5 ^ ROT(s5, 1), s5_123 = ROT(s5_01, 1) ^ ROT(s5, 3);\n+    uint16_t s6_01 = s6 ^ ROT(s6, 1), s6_123 = ROT(s6_01, 1) ^ ROT(s6, 3);\n+    uint16_t s7_01 = s7 ^ ROT(s7, 1), s7_123 = ROT(s7_01, 1) ^ ROT(s7, 3);\n+    /* Now compute s = s?_123 + {02} * s?_01. */\n+    s->slice[0] = s7_01 ^ s0_123;\n+    s->slice[1] = s7_01 ^ s0_01 ^ s1_123;\n+    s->slice[2] = s1_01 ^ s2_123;\n+    s->slice[3] = s7_01 ^ s2_01 ^ s3_123;\n+    s->slice[4] = s7_01 ^ s3_01 ^ s4_123;\n+    s->slice[5] = s4_01 ^ s5_123;\n+    s->slice[6] = s5_01 ^ s6_123;\n+    s->slice[7] = s6_01 ^ s7_123;\n+    if (inv) {\n+        /* In the reverse direction, we further need to multiply by\n+         * {04}x^2 + {05}, which can be written as {04} * (x^2 + {01}) + {01}.\n+         *\n+         * First compute (x^2 + {01}) * s into the t?_02 variables: */\n+        uint16_t t0_02 = s->slice[0] ^ ROT(s->slice[0], 2);\n+        uint16_t t1_02 = s->slice[1] ^ ROT(s->slice[1], 2);\n+        uint16_t t2_02 = s->slice[2] ^ ROT(s->slice[2], 2);\n+        uint16_t t3_02 = s->slice[3] ^ ROT(s->slice[3], 2);\n+        uint16_t t4_02 = s->slice[4] ^ ROT(s->slice[4], 2);\n+        uint16_t t5_02 = s->slice[5] ^ ROT(s->slice[5], 2);\n+        uint16_t t6_02 = s->slice[6] ^ ROT(s->slice[6], 2);\n+        uint16_t t7_02 = s->slice[7] ^ ROT(s->slice[7], 2);\n+        /* And then update s += {04} * t?_02 */\n+        s->slice[0] ^= t6_02;\n+        s->slice[1] ^= t6_02 ^ t7_02;\n+        s->slice[2] ^= t0_02 ^ t7_02;\n+        s->slice[3] ^= t1_02 ^ t6_02;\n+        s->slice[4] ^= t2_02 ^ t6_02 ^ t7_02;\n+        s->slice[5] ^= t3_02 ^ t7_02;\n+        s->slice[6] ^= t4_02;\n+        s->slice[7] ^= t5_02;\n+    }\n+}\n+\n+static void AddRoundKey(AES_state* s, const AES_state* round) {\n+    int b;\n+    for (b = 0; b < 8; b++) {\n+        s->slice[b] ^= round->slice[b];\n+    }\n+}\n+\n+/** column_0(s) = column_c(a) */\n+static void GetOneColumn(AES_state* s, const AES_state* a, int c) {\n+    int b;\n+    for (b = 0; b < 8; b++) {\n+        s->slice[b] = (a->slice[b] >> c) & 0x1111;\n+    }\n+}\n+\n+/** column_c1(r) |= (column_0(s) ^= column_c2(a)) */\n+static void KeySetupColumnMix(AES_state* s, AES_state* r, const AES_state* a, int c1, int c2) {\n+    int b;\n+    for (b = 0; b < 8; b++) {\n+        r->slice[b] |= ((s->slice[b] ^= ((a->slice[b] >> c2) & 0x1111)) & 0x1111) << c1;\n+    }\n+}\n+\n+/** Rotate the rows in s one position upwards, and xor in r */\n+static void KeySetupTransform(AES_state* s, const AES_state* r) {\n+    int b;\n+    for (b = 0; b < 8; b++) {\n+        s->slice[b] = ((s->slice[b] >> 4) | (s->slice[b] << 12)) ^ r->slice[b];\n+    }\n+}\n+\n+/* Multiply the cells in s by x, as polynomials over GF(2) mod x^8 + x^4 + x^3 + x + 1 */\n+static void MultX(AES_state* s) {\n+    uint16_t top = s->slice[7];\n+    s->slice[7] = s->slice[6];\n+    s->slice[6] = s->slice[5];\n+    s->slice[5] = s->slice[4];\n+    s->slice[4] = s->slice[3] ^ top;\n+    s->slice[3] = s->slice[2] ^ top;\n+    s->slice[2] = s->slice[1];\n+    s->slice[1] = s->slice[0] ^ top;\n+    s->slice[0] = top;\n+}\n+\n+/** Expand the cipher key into the key schedule.\n+ *\n+ *  state must be a pointer to an array of size nrounds + 1.\n+ *  key must be a pointer to 4 * nkeywords bytes.\n+ *\n+ *  AES128 uses nkeywords = 4, nrounds = 10\n+ *  AES192 uses nkeywords = 6, nrounds = 12\n+ *  AES256 uses nkeywords = 8, nrounds = 14\n+ */\n+static void AES_setup(AES_state* rounds, const uint8_t* key, int nkeywords, int nrounds)\n+{\n+    int i;\n+\n+    /* The one-byte round constant */\n+    AES_state rcon = {{1,0,0,0,0,0,0,0}};\n+    /* The number of the word being generated, modulo nkeywords */\n+    int pos = 0;\n+    /* The column representing the word currently being processed */\n+    AES_state column;\n+\n+    for (i = 0; i < nrounds + 1; i++) {\n+        int b;\n+        for (b = 0; b < 8; b++) {\n+            rounds[i].slice[b] = 0;\n+        }\n+    }\n+\n+    /* The first nkeywords round columns are just taken from the key directly. */\n+    for (i = 0; i < nkeywords; i++) {\n+        int r;\n+        for (r = 0; r < 4; r++) {\n+            LoadByte(&rounds[i >> 2], *(key++), r, i & 3);\n+        }\n+    }\n+\n+    GetOneColumn(&column, &rounds[(nkeywords - 1) >> 2], (nkeywords - 1) & 3);\n+\n+    for (i = nkeywords; i < 4 * (nrounds + 1); i++) {\n+        /* Transform column */\n+        if (pos == 0) {\n+            SubBytes(&column, 0);\n+            KeySetupTransform(&column, &rcon);\n+            MultX(&rcon);\n+        } else if (nkeywords > 6 && pos == 4) {\n+            SubBytes(&column, 0);\n+        }\n+        if (++pos == nkeywords) pos = 0;\n+        KeySetupColumnMix(&column, &rounds[i >> 2], &rounds[(i - nkeywords) >> 2], i & 3, (i - nkeywords) & 3);\n+    }\n+}\n+\n+static void AES_encrypt(const AES_state* rounds, int nrounds, unsigned char* cipher16, const unsigned char* plain16) {\n+    AES_state s = {{0}};\n+    int round;\n+\n+    LoadBytes(&s, plain16);\n+    AddRoundKey(&s, rounds++);\n+\n+    for (round = 1; round < nrounds; round++) {\n+        SubBytes(&s, 0);\n+        ShiftRows(&s);\n+        MixColumns(&s, 0);\n+        AddRoundKey(&s, rounds++);\n+    }\n+\n+    SubBytes(&s, 0);\n+    ShiftRows(&s);\n+    AddRoundKey(&s, rounds);\n+\n+    SaveBytes(cipher16, &s);\n+}\n+\n+static void AES_decrypt(const AES_state* rounds, int nrounds, unsigned char* plain16, const unsigned char* cipher16) {\n+    /* Most AES decryption implementations use the alternate scheme\n+     * (the Equivalent Inverse Cipher), which looks more like encryption, but\n+     * needs different round constants. We can't reuse any code here anyway, so\n+     * don't bother. */\n+    AES_state s = {{0}};\n+    int round;\n+\n+    rounds += nrounds;\n+\n+    LoadBytes(&s, cipher16);\n+    AddRoundKey(&s, rounds--);\n+\n+    for (round = 1; round < nrounds; round++) {\n+        InvShiftRows(&s);\n+        SubBytes(&s, 1);\n+        AddRoundKey(&s, rounds--);\n+        MixColumns(&s, 1);\n+    }\n+\n+    InvShiftRows(&s);\n+    SubBytes(&s, 1);\n+    AddRoundKey(&s, rounds);\n+\n+    SaveBytes(plain16, &s);\n+}\n+\n+void AES128_init(AES128_ctx* ctx, const unsigned char* key16) {\n+    AES_setup(ctx->rk, key16, 4, 10);\n+}\n+\n+void AES128_encrypt(const AES128_ctx* ctx, size_t blocks, unsigned char* cipher16, const unsigned char* plain16) {\n+    while (blocks--) {\n+        AES_encrypt(ctx->rk, 10, cipher16, plain16);\n+        cipher16 += 16;\n+        plain16 += 16;\n+    }\n+}\n+\n+void AES128_decrypt(const AES128_ctx* ctx, size_t blocks, unsigned char* plain16, const unsigned char* cipher16) {\n+    while (blocks--) {\n+        AES_decrypt(ctx->rk, 10, plain16, cipher16);\n+        cipher16 += 16;\n+        plain16 += 16;\n+    }\n+}\n+\n+void AES192_init(AES192_ctx* ctx, const unsigned char* key24) {\n+    AES_setup(ctx->rk, key24, 6, 12);\n+}\n+\n+void AES192_encrypt(const AES192_ctx* ctx, size_t blocks, unsigned char* cipher16, const unsigned char* plain16) {\n+    while (blocks--) {\n+        AES_encrypt(ctx->rk, 12, cipher16, plain16);\n+        cipher16 += 16;\n+        plain16 += 16;\n+    }\n+\n+}\n+\n+void AES192_decrypt(const AES192_ctx* ctx, size_t blocks, unsigned char* plain16, const unsigned char* cipher16) {\n+    while (blocks--) {\n+        AES_decrypt(ctx->rk, 12, plain16, cipher16);\n+        cipher16 += 16;\n+        plain16 += 16;\n+    }\n+}\n+\n+void AES256_init(AES256_ctx* ctx, const unsigned char* key32) {\n+    AES_setup(ctx->rk, key32, 8, 14);\n+}\n+\n+void AES256_encrypt(const AES256_ctx* ctx, size_t blocks, unsigned char* cipher16, const unsigned char* plain16) {\n+    while (blocks--) {\n+        AES_encrypt(ctx->rk, 14, cipher16, plain16);\n+        cipher16 += 16;\n+        plain16 += 16;\n+    }\n+}\n+\n+void AES256_decrypt(const AES256_ctx* ctx, size_t blocks, unsigned char* plain16, const unsigned char* cipher16) {\n+    while (blocks--) {\n+        AES_decrypt(ctx->rk, 14, plain16, cipher16);\n+        cipher16 += 16;\n+        plain16 += 16;\n+    }\n+}"
      },
      {
        "sha": "2f0af042160536beda0f35da4e76b98cd654fc9b",
        "filename": "ctaes.h",
        "status": "added",
        "additions": 41,
        "deletions": 0,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a545127fbccef4ee674d18d43732ce00ba97f782/ctaes.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a545127fbccef4ee674d18d43732ce00ba97f782/ctaes.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ctaes.h?ref=a545127fbccef4ee674d18d43732ce00ba97f782",
        "patch": "@@ -0,0 +1,41 @@\n+ /*********************************************************************\n+ * Copyright (c) 2016 Pieter Wuille                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _CTAES_H_\n+#define _CTAES_H_ 1\n+\n+#include <stdint.h>\n+#include <stdlib.h>\n+\n+typedef struct {\n+    uint16_t slice[8];\n+} AES_state;\n+\n+typedef struct {\n+    AES_state rk[11];\n+} AES128_ctx;\n+\n+typedef struct {\n+    AES_state rk[13];\n+} AES192_ctx;\n+\n+typedef struct {\n+    AES_state rk[15];\n+} AES256_ctx;\n+\n+void AES128_init(AES128_ctx* ctx, const unsigned char* key16);\n+void AES128_encrypt(const AES128_ctx* ctx, size_t blocks, unsigned char* cipher16, const unsigned char* plain16);\n+void AES128_decrypt(const AES128_ctx* ctx, size_t blocks, unsigned char* plain16, const unsigned char* cipher16);\n+\n+void AES192_init(AES192_ctx* ctx, const unsigned char* key24);\n+void AES192_encrypt(const AES192_ctx* ctx, size_t blocks, unsigned char* cipher16, const unsigned char* plain16);\n+void AES192_decrypt(const AES192_ctx* ctx, size_t blocks, unsigned char* plain16, const unsigned char* cipher16);\n+\n+void AES256_init(AES256_ctx* ctx, const unsigned char* key32);\n+void AES256_encrypt(const AES256_ctx* ctx, size_t blocks, unsigned char* cipher16, const unsigned char* plain16);\n+void AES256_decrypt(const AES256_ctx* ctx, size_t blocks, unsigned char* plain16, const unsigned char* cipher16);\n+\n+#endif"
      },
      {
        "sha": "fce1696acdc2db618cc88c288b190a567d8f9e1c",
        "filename": "test.c",
        "status": "added",
        "additions": 110,
        "deletions": 0,
        "changes": 110,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a545127fbccef4ee674d18d43732ce00ba97f782/test.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a545127fbccef4ee674d18d43732ce00ba97f782/test.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test.c?ref=a545127fbccef4ee674d18d43732ce00ba97f782",
        "patch": "@@ -0,0 +1,110 @@\n+ /*********************************************************************\n+ * Copyright (c) 2016 Pieter Wuille                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include \"ctaes.h\"\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <assert.h>\n+\n+typedef struct {\n+    int keysize;\n+    const char* key;\n+    const char* plain;\n+    const char* cipher;\n+} ctaes_test;\n+\n+static const ctaes_test ctaes_tests[] = {\n+    /* AES test vectors from FIPS 197. */\n+    {128, \"000102030405060708090a0b0c0d0e0f\", \"00112233445566778899aabbccddeeff\", \"69c4e0d86a7b0430d8cdb78070b4c55a\"},\n+    {192, \"000102030405060708090a0b0c0d0e0f1011121314151617\", \"00112233445566778899aabbccddeeff\", \"dda97ca4864cdfe06eaf70a0ec0d7191\"},\n+    {256, \"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\", \"00112233445566778899aabbccddeeff\", \"8ea2b7ca516745bfeafc49904b496089\"},\n+\n+    /* AES-ECB test vectors from NIST sp800-38a. */\n+    {128, \"2b7e151628aed2a6abf7158809cf4f3c\", \"6bc1bee22e409f96e93d7e117393172a\", \"3ad77bb40d7a3660a89ecaf32466ef97\"},\n+    {128, \"2b7e151628aed2a6abf7158809cf4f3c\", \"ae2d8a571e03ac9c9eb76fac45af8e51\", \"f5d3d58503b9699de785895a96fdbaaf\"},\n+    {128, \"2b7e151628aed2a6abf7158809cf4f3c\", \"30c81c46a35ce411e5fbc1191a0a52ef\", \"43b1cd7f598ece23881b00e3ed030688\"},\n+    {128, \"2b7e151628aed2a6abf7158809cf4f3c\", \"f69f2445df4f9b17ad2b417be66c3710\", \"7b0c785e27e8ad3f8223207104725dd4\"},\n+    {192, \"8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\", \"6bc1bee22e409f96e93d7e117393172a\", \"bd334f1d6e45f25ff712a214571fa5cc\"},\n+    {192, \"8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\", \"ae2d8a571e03ac9c9eb76fac45af8e51\", \"974104846d0ad3ad7734ecb3ecee4eef\"},\n+    {192, \"8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\", \"30c81c46a35ce411e5fbc1191a0a52ef\", \"ef7afd2270e2e60adce0ba2face6444e\"},\n+    {192, \"8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\", \"f69f2445df4f9b17ad2b417be66c3710\", \"9a4b41ba738d6c72fb16691603c18e0e\"},\n+    {256, \"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\", \"6bc1bee22e409f96e93d7e117393172a\", \"f3eed1bdb5d2a03c064b5a7e3db181f8\"},\n+    {256, \"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\", \"ae2d8a571e03ac9c9eb76fac45af8e51\", \"591ccb10d410ed26dc5ba74a31362870\"},\n+    {256, \"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\", \"30c81c46a35ce411e5fbc1191a0a52ef\", \"b6ed21b99ca6f4f9f153e7b1beafed1d\"},\n+    {256, \"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\", \"f69f2445df4f9b17ad2b417be66c3710\", \"23304b7a39f9f3ff067d8d8f9e24ecc7\"}\n+};\n+\n+static void from_hex(unsigned char* data, int len, const char* hex) {\n+    int p;\n+    for (p = 0; p < len; p++) {\n+        int v = 0;\n+        int n;\n+        for (n = 0; n < 2; n++) {\n+            assert((*hex >= '0' && *hex <= '9') || (*hex >= 'a' && *hex <= 'f'));\n+            if (*hex >= '0' && *hex <= '9') {\n+                v |= (*hex - '0') << (4 * (1 - n));\n+            } else {\n+                v |= (*hex - 'a' + 10) << (4 * (1 - n));\n+            }\n+            hex++;\n+        }\n+        *(data++) = v;\n+    }\n+    assert(*hex == 0);\n+}\n+\n+int main(void) {\n+    int i;\n+    int fail = 0;\n+    for (i = 0; i < sizeof(ctaes_tests) / sizeof(ctaes_tests[0]); i++) {\n+        unsigned char key[32], plain[16], cipher[16], ciphered[16], deciphered[16];\n+        const ctaes_test* test = &ctaes_tests[i];\n+        assert(test->keysize == 128 || test->keysize == 192 || test->keysize == 256);\n+        from_hex(plain, 16, test->plain);\n+        from_hex(cipher, 16, test->cipher);\n+        switch (test->keysize) {\n+            case 128: {\n+                AES128_ctx ctx;\n+                from_hex(key, 16, test->key);\n+                AES128_init(&ctx, key);\n+                AES128_encrypt(&ctx, 1, ciphered, plain);\n+                AES128_decrypt(&ctx, 1, deciphered, cipher);\n+                break;\n+            }\n+            case 192: {\n+                AES192_ctx ctx;\n+                from_hex(key, 24, test->key);\n+                AES192_init(&ctx, key);\n+                AES192_encrypt(&ctx, 1, ciphered, plain);\n+                AES192_decrypt(&ctx, 1, deciphered, cipher);\n+                break;\n+            }\n+            case 256: {\n+                AES256_ctx ctx;\n+                from_hex(key, 32, test->key);\n+                AES256_init(&ctx, key);\n+                AES256_encrypt(&ctx, 1, ciphered, plain);\n+                AES256_decrypt(&ctx, 1, deciphered, cipher);\n+                break;\n+            }\n+        }\n+        if (memcmp(cipher, ciphered, 16)) {\n+            fprintf(stderr, \"E(key=\\\"%s\\\", plain=\\\"%s\\\") != \\\"%s\\\"\\n\", test->key, test->plain, test->cipher);\n+            fail++;\n+        }\n+        if (memcmp(plain, deciphered, 16)) {\n+            fprintf(stderr, \"D(key=\\\"%s\\\", cipher=\\\"%s\\\") != \\\"%s\\\"\\n\", test->key, test->cipher, test->plain);\n+            fail++;\n+        }\n+    }\n+    if (fail == 0) {\n+        fprintf(stderr, \"All tests succesful\\n\");\n+    } else {\n+        fprintf(stderr, \"%i tests failed\\n\", fail);\n+    }\n+    return (fail != 0);\n+}"
      }
    ]
  },
  {
    "sha": "cd2be4419e9d8c6445fecc877b50198dc918a81f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjZDJiZTQ0MTllOWQ4YzY0NDVmZWNjODc3YjUwMTk4ZGM5MThhODFm",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-05-11T17:36:38Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-05-11T17:37:02Z"
      },
      "message": "Merge commit 'a545127fbccef4ee674d18d43732ce00ba97f782' as 'src/crypto/ctaes'",
      "tree": {
        "sha": "4e490121ea95decee565f00e97110cfc560cabd7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4e490121ea95decee565f00e97110cfc560cabd7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cd2be4419e9d8c6445fecc877b50198dc918a81f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXM23CAAoJENuhpnN5oakx13cQAMZoFYIz7XFQ0rdFpjkPPRXc\n5mk15o93WyER97KHubgXR38K3KRkpHUgjt0IyiQ6nYanxwnJ4NU714zX7bsFrUWA\n8/d8FhX+PKwNUIf4ZLt+qVOB8HdOzcp+qxEgCklBm93HS+ywfzjLlIZQY0F7lcmh\n9oCQkjU6S0eRPxJBcUR1TcL0hShcaV8Ip/vEy/8AoW5n9DzESEfAo1j9VLgr8a2m\ndCGdN4CAeIe0q+rUdTHn2SP8HteWOXvYNe25Ps7beh10qJ7+7NGzNJqU4Pekxs3R\n6kCrQ2klF5u3Ya1MY1qxusxMQ1BNkDwR5EDnvLB0geG6We4EO3I8cMEjAqdeUIl4\noJRuNm7/H+kdr0Tz4vaDJ5EfPajqxe/zwXw6RQKT4YZbhp0NRrm5oxBDbjHDrCEQ\nqlZIdO2JPyyrVBZWBbRKoDYJxJHt7SHHNwpsfU2wbHuXjLZPx/UBF3qw3/ZhLM49\nxh2cRYdoUgfiXqyZiU4u5/iMA+xqnZdhBWwTb9oxa5oU/UJIkMQV9GGt5Lfif0js\nUWkB8qySxzDNI9VT9ed+nZSisV9UESne7+g+OSMsuInaV6WkHlcK3f8at8SUccoH\nTCUUuHc8D5tXhTmsSsVIYO+9i/AzPtBRS8XvMGcZJMaElBdc8vrUNNhbKdVU5xfl\nnBj7YFg2Hlazn+SGY5YR\n=GTCk\n-----END PGP SIGNATURE-----",
        "payload": "tree 4e490121ea95decee565f00e97110cfc560cabd7\nparent 423ca302a3ee87000530da3c105f269b8fabece7\nparent a545127fbccef4ee674d18d43732ce00ba97f782\nauthor Pieter Wuille <pieter.wuille@gmail.com> 1462988198 +0200\ncommitter Pieter Wuille <pieter.wuille@gmail.com> 1462988222 +0200\n\nMerge commit 'a545127fbccef4ee674d18d43732ce00ba97f782' as 'src/crypto/ctaes'\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cd2be4419e9d8c6445fecc877b50198dc918a81f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cd2be4419e9d8c6445fecc877b50198dc918a81f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cd2be4419e9d8c6445fecc877b50198dc918a81f/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "423ca302a3ee87000530da3c105f269b8fabece7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/423ca302a3ee87000530da3c105f269b8fabece7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/423ca302a3ee87000530da3c105f269b8fabece7"
      },
      {
        "sha": "a545127fbccef4ee674d18d43732ce00ba97f782",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a545127fbccef4ee674d18d43732ce00ba97f782",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a545127fbccef4ee674d18d43732ce00ba97f782"
      }
    ],
    "stats": {
      "total": 939,
      "additions": 939,
      "deletions": 0
    },
    "files": [
      {
        "sha": "415b202a2a54eb92e6283f4c6b3e40667cedc341",
        "filename": "src/crypto/ctaes/COPYING",
        "status": "added",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cd2be4419e9d8c6445fecc877b50198dc918a81f/src/crypto/ctaes/COPYING",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cd2be4419e9d8c6445fecc877b50198dc918a81f/src/crypto/ctaes/COPYING",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/ctaes/COPYING?ref=cd2be4419e9d8c6445fecc877b50198dc918a81f",
        "patch": "@@ -0,0 +1,21 @@\n+The MIT License (MIT)\n+\n+Copyright (c) 2016 Pieter Wuille\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in\n+all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+THE SOFTWARE."
      },
      {
        "sha": "0e7fe1775153e2f14f976fa8826d5f73927cc6e1",
        "filename": "src/crypto/ctaes/README.md",
        "status": "added",
        "additions": 41,
        "deletions": 0,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cd2be4419e9d8c6445fecc877b50198dc918a81f/src/crypto/ctaes/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cd2be4419e9d8c6445fecc877b50198dc918a81f/src/crypto/ctaes/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/ctaes/README.md?ref=cd2be4419e9d8c6445fecc877b50198dc918a81f",
        "patch": "@@ -0,0 +1,41 @@\n+ctaes\n+=====\n+\n+Simple C module for constant-time AES encryption and decryption.\n+\n+Features:\n+* Simple, pure C code without any dependencies.\n+* No tables or data-dependent branches whatsoever, but using bit sliced approach from https://eprint.iacr.org/2009/129.pdf.\n+* Very small object code: slightly over 4k of executable code when compiled with -Os.\n+* Slower than implementations based on precomputed tables or specialized instructions, but can do ~15 MB/s on modern CPUs.\n+\n+Performance\n+-----------\n+\n+Compiled with GCC 5.3.1 with -O3, on an Intel(R) Core(TM) i7-4800MQ CPU, numbers in CPU cycles:\n+\n+| Algorithm | Key schedule | Encryption per byte | Decryption per byte |\n+| --------- | ------------:| -------------------:| -------------------:|\n+| AES-128   |         2.8k |                 154 |                 161 |\n+| AES-192   |         3.1k |                 169 |                 181 |\n+| AES-256   |         4.0k |                 191 |                 203 |\n+\n+Build steps\n+-----------\n+\n+Object code:\n+\n+    $ gcc -O3 ctaes.c -c -o ctaes.o\n+\n+Tests:\n+\n+    $ gcc -O3 ctaes.c test.c -o test\n+\n+Benchmark:\n+\n+    $ gcc -O3 ctaes.c bench.c -o bench\n+\n+Review\n+------\n+\n+Results of a formal review of the code can be found in http://bitcoin.sipa.be/ctaes/review.zip"
      },
      {
        "sha": "a86df496c830083be2d4e007137897900e201a0f",
        "filename": "src/crypto/ctaes/bench.c",
        "status": "added",
        "additions": 170,
        "deletions": 0,
        "changes": 170,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cd2be4419e9d8c6445fecc877b50198dc918a81f/src/crypto/ctaes/bench.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cd2be4419e9d8c6445fecc877b50198dc918a81f/src/crypto/ctaes/bench.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/ctaes/bench.c?ref=cd2be4419e9d8c6445fecc877b50198dc918a81f",
        "patch": "@@ -0,0 +1,170 @@\n+#include <stdio.h>\n+#include <math.h>\n+#include \"sys/time.h\"\n+\n+#include \"ctaes.h\"\n+\n+static double gettimedouble(void) {\n+    struct timeval tv;\n+    gettimeofday(&tv, NULL);\n+    return tv.tv_usec * 0.000001 + tv.tv_sec;\n+}\n+\n+static void print_number(double x) {\n+    double y = x;\n+    int c = 0;\n+    if (y < 0.0) {\n+        y = -y;\n+    }\n+    while (y < 100.0) {\n+        y *= 10.0;\n+        c++;\n+    }\n+    printf(\"%.*f\", c, x);\n+}\n+\n+static void run_benchmark(char *name, void (*benchmark)(void*), void (*setup)(void*), void (*teardown)(void*), void* data, int count, int iter) {\n+    int i;\n+    double min = HUGE_VAL;\n+    double sum = 0.0;\n+    double max = 0.0;\n+    for (i = 0; i < count; i++) {\n+        double begin, total;\n+        if (setup != NULL) {\n+            setup(data);\n+        }\n+        begin = gettimedouble();\n+        benchmark(data);\n+        total = gettimedouble() - begin;\n+        if (teardown != NULL) {\n+            teardown(data);\n+        }\n+        if (total < min) {\n+            min = total;\n+        }\n+        if (total > max) {\n+            max = total;\n+        }\n+        sum += total;\n+    }\n+    printf(\"%s: min \", name);\n+    print_number(min * 1000000000.0 / iter);\n+    printf(\"ns / avg \");\n+    print_number((sum / count) * 1000000000.0 / iter);\n+    printf(\"ns / max \");\n+    print_number(max * 1000000000.0 / iter);\n+    printf(\"ns\\n\");\n+}\n+\n+static void bench_AES128_init(void* data) {\n+    AES128_ctx* ctx = (AES128_ctx*)data;\n+    int i;\n+    for (i = 0; i < 50000; i++) {\n+        AES128_init(ctx, (unsigned char*)ctx);\n+    }\n+}\n+\n+static void bench_AES128_encrypt_setup(void* data) {\n+    AES128_ctx* ctx = (AES128_ctx*)data;\n+    static const unsigned char key[16] = {0};\n+    AES128_init(ctx, key);\n+}\n+\n+static void bench_AES128_encrypt(void* data) {\n+    const AES128_ctx* ctx = (const AES128_ctx*)data;\n+    unsigned char scratch[16] = {0};\n+    int i;\n+    for (i = 0; i < 4000000 / 16; i++) {\n+        AES128_encrypt(ctx, 1, scratch, scratch);\n+    }\n+}\n+\n+static void bench_AES128_decrypt(void* data) {\n+    const AES128_ctx* ctx = (const AES128_ctx*)data;\n+    unsigned char scratch[16] = {0};\n+    int i;\n+    for (i = 0; i < 4000000 / 16; i++) {\n+        AES128_decrypt(ctx, 1, scratch, scratch);\n+    }\n+}\n+\n+static void bench_AES192_init(void* data) {\n+    AES192_ctx* ctx = (AES192_ctx*)data;\n+    int i;\n+    for (i = 0; i < 50000; i++) {\n+        AES192_init(ctx, (unsigned char*)ctx);\n+    }\n+}\n+\n+static void bench_AES192_encrypt_setup(void* data) {\n+    AES192_ctx* ctx = (AES192_ctx*)data;\n+    static const unsigned char key[16] = {0};\n+    AES192_init(ctx, key);\n+}\n+\n+static void bench_AES192_encrypt(void* data) {\n+    const AES192_ctx* ctx = (const AES192_ctx*)data;\n+    unsigned char scratch[16] = {0};\n+    int i;\n+    for (i = 0; i < 4000000 / 16; i++) {\n+        AES192_encrypt(ctx, 1, scratch, scratch);\n+    }\n+}\n+\n+static void bench_AES192_decrypt(void* data) {\n+    const AES192_ctx* ctx = (const AES192_ctx*)data;\n+    unsigned char scratch[16] = {0};\n+    int i;\n+    for (i = 0; i < 4000000 / 16; i++) {\n+        AES192_decrypt(ctx, 1, scratch, scratch);\n+    }\n+}\n+\n+static void bench_AES256_init(void* data) {\n+    AES256_ctx* ctx = (AES256_ctx*)data;\n+    int i;\n+    for (i = 0; i < 50000; i++) {\n+        AES256_init(ctx, (unsigned char*)ctx);\n+    }\n+}\n+\n+\n+static void bench_AES256_encrypt_setup(void* data) {\n+    AES256_ctx* ctx = (AES256_ctx*)data;\n+    static const unsigned char key[16] = {0};\n+    AES256_init(ctx, key);\n+}\n+\n+static void bench_AES256_encrypt(void* data) {\n+    const AES256_ctx* ctx = (const AES256_ctx*)data;\n+    unsigned char scratch[16] = {0};\n+    int i;\n+    for (i = 0; i < 4000000 / 16; i++) {\n+        AES256_encrypt(ctx, 1, scratch, scratch);\n+    }\n+}\n+\n+static void bench_AES256_decrypt(void* data) {\n+    const AES256_ctx* ctx = (const AES256_ctx*)data;\n+    unsigned char scratch[16] = {0};\n+    int i;\n+    for (i = 0; i < 4000000 / 16; i++) {\n+        AES256_decrypt(ctx, 1, scratch, scratch);\n+    }\n+}\n+\n+int main(void) {\n+    AES128_ctx ctx128;\n+    AES192_ctx ctx192;\n+    AES256_ctx ctx256;\n+    run_benchmark(\"aes128_init\", bench_AES128_init, NULL, NULL, &ctx128, 20, 50000);\n+    run_benchmark(\"aes128_encrypt_byte\", bench_AES128_encrypt, bench_AES128_encrypt_setup, NULL, &ctx128, 20, 4000000);\n+    run_benchmark(\"aes128_decrypt_byte\", bench_AES128_decrypt, bench_AES128_encrypt_setup, NULL, &ctx128, 20, 4000000);\n+    run_benchmark(\"aes192_init\", bench_AES192_init, NULL, NULL, &ctx192, 20, 50000);\n+    run_benchmark(\"aes192_encrypt_byte\", bench_AES192_encrypt, bench_AES192_encrypt_setup, NULL, &ctx192, 20, 4000000);\n+    run_benchmark(\"aes192_decrypt_byte\", bench_AES192_decrypt, bench_AES192_encrypt_setup, NULL, &ctx192, 20, 4000000);\n+    run_benchmark(\"aes256_init\", bench_AES256_init, NULL, NULL, &ctx256, 20, 50000);\n+    run_benchmark(\"aes256_encrypt_byte\", bench_AES256_encrypt, bench_AES256_encrypt_setup, NULL, &ctx256, 20, 4000000);\n+    run_benchmark(\"aes256_decrypt_byte\", bench_AES256_decrypt, bench_AES256_encrypt_setup, NULL, &ctx256, 20, 4000000);\n+    return 0;\n+}"
      },
      {
        "sha": "2389fc0bb254f70c0be4863fa8cc2273210b9442",
        "filename": "src/crypto/ctaes/ctaes.c",
        "status": "added",
        "additions": 556,
        "deletions": 0,
        "changes": 556,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cd2be4419e9d8c6445fecc877b50198dc918a81f/src/crypto/ctaes/ctaes.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cd2be4419e9d8c6445fecc877b50198dc918a81f/src/crypto/ctaes/ctaes.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/ctaes/ctaes.c?ref=cd2be4419e9d8c6445fecc877b50198dc918a81f",
        "patch": "@@ -0,0 +1,556 @@\n+ /*********************************************************************\n+ * Copyright (c) 2016 Pieter Wuille                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+/* Constant time, unoptimized, concise, plain C, AES implementation\n+ * Based On:\n+ *   Emilia Kasper and Peter Schwabe, Faster and Timing-Attack Resistant AES-GCM\n+ *   http://www.iacr.org/archive/ches2009/57470001/57470001.pdf\n+ * But using 8 16-bit integers representing a single AES state rather than 8 128-bit\n+ * integers representing 8 AES states.\n+ */\n+\n+#include \"ctaes.h\"\n+\n+/* Slice variable slice_i contains the i'th bit of the 16 state variables in this order:\n+ *  0  1  2  3\n+ *  4  5  6  7\n+ *  8  9 10 11\n+ * 12 13 14 15\n+ */\n+\n+/** Convert a byte to sliced form, storing it corresponding to given row and column in s */\n+static void LoadByte(AES_state* s, unsigned char byte, int r, int c) {\n+    int i;\n+    for (i = 0; i < 8; i++) {\n+        s->slice[i] |= (byte & 1) << (r * 4 + c);\n+        byte >>= 1;\n+    }\n+}\n+\n+/** Load 16 bytes of data into 8 sliced integers */\n+static void LoadBytes(AES_state *s, const unsigned char* data16) {\n+    int c;\n+    for (c = 0; c < 4; c++) {\n+        int r;\n+        for (r = 0; r < 4; r++) {\n+            LoadByte(s, *(data16++), r, c);\n+        }\n+    }\n+}\n+\n+/** Convert 8 sliced integers into 16 bytes of data */\n+static void SaveBytes(unsigned char* data16, const AES_state *s) {\n+    int c;\n+    for (c = 0; c < 4; c++) {\n+        int r;\n+        for (r = 0; r < 4; r++) {\n+            int b;\n+            uint8_t v = 0;\n+            for (b = 0; b < 8; b++) {\n+                v |= ((s->slice[b] >> (r * 4 + c)) & 1) << b;\n+            }\n+            *(data16++) = v;\n+        }\n+    }\n+}\n+\n+/* S-box implementation based on the gate logic from:\n+ *   Joan Boyar and Rene Peralta, A depth-16 circuit for the AES S-box.\n+ *   https://eprint.iacr.org/2011/332.pdf\n+*/\n+static void SubBytes(AES_state *s, int inv) {\n+    /* Load the bit slices */\n+    uint16_t U0 = s->slice[7], U1 = s->slice[6], U2 = s->slice[5], U3 = s->slice[4];\n+    uint16_t U4 = s->slice[3], U5 = s->slice[2], U6 = s->slice[1], U7 = s->slice[0];\n+\n+    uint16_t T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16;\n+    uint16_t T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, D;\n+    uint16_t M1, M6, M11, M13, M15, M20, M21, M22, M23, M25, M37, M38, M39, M40;\n+    uint16_t M41, M42, M43, M44, M45, M46, M47, M48, M49, M50, M51, M52, M53, M54;\n+    uint16_t M55, M56, M57, M58, M59, M60, M61, M62, M63;\n+\n+    if (inv) {\n+        uint16_t R5, R13, R17, R18, R19;\n+        /* Undo linear postprocessing */\n+        T23 = U0 ^ U3;\n+        T22 = ~(U1 ^ U3);\n+        T2 = ~(U0 ^ U1);\n+        T1 = U3 ^ U4;\n+        T24 = ~(U4 ^ U7);\n+        R5 = U6 ^ U7;\n+        T8 = ~(U1 ^ T23);\n+        T19 = T22 ^ R5;\n+        T9 = ~(U7 ^ T1);\n+        T10 = T2 ^ T24;\n+        T13 = T2 ^ R5;\n+        T3 = T1 ^ R5;\n+        T25 = ~(U2 ^ T1);\n+        R13 = U1 ^ U6;\n+        T17 = ~(U2 ^ T19);\n+        T20 = T24 ^ R13;\n+        T4 = U4 ^ T8;\n+        R17 = ~(U2 ^ U5);\n+        R18 = ~(U5 ^ U6);\n+        R19 = ~(U2 ^ U4);\n+        D = U0 ^ R17;\n+        T6 = T22 ^ R17;\n+        T16 = R13 ^ R19;\n+        T27 = T1 ^ R18;\n+        T15 = T10 ^ T27;\n+        T14 = T10 ^ R18;\n+        T26 = T3 ^ T16;\n+    } else {\n+        /* Linear preprocessing. */\n+        T1 = U0 ^ U3;\n+        T2 = U0 ^ U5;\n+        T3 = U0 ^ U6;\n+        T4 = U3 ^ U5;\n+        T5 = U4 ^ U6;\n+        T6 = T1 ^ T5;\n+        T7 = U1 ^ U2;\n+        T8 = U7 ^ T6;\n+        T9 = U7 ^ T7;\n+        T10 = T6 ^ T7;\n+        T11 = U1 ^ U5;\n+        T12 = U2 ^ U5;\n+        T13 = T3 ^ T4;\n+        T14 = T6 ^ T11;\n+        T15 = T5 ^ T11;\n+        T16 = T5 ^ T12;\n+        T17 = T9 ^ T16;\n+        T18 = U3 ^ U7;\n+        T19 = T7 ^ T18;\n+        T20 = T1 ^ T19;\n+        T21 = U6 ^ U7;\n+        T22 = T7 ^ T21;\n+        T23 = T2 ^ T22;\n+        T24 = T2 ^ T10;\n+        T25 = T20 ^ T17;\n+        T26 = T3 ^ T16;\n+        T27 = T1 ^ T12;\n+        D = U7;\n+    }\n+\n+    /* Non-linear transformation (identical to the code in SubBytes) */\n+    M1 = T13 & T6;\n+    M6 = T3 & T16;\n+    M11 = T1 & T15;\n+    M13 = (T4 & T27) ^ M11;\n+    M15 = (T2 & T10) ^ M11;\n+    M20 = T14 ^ M1 ^ (T23 & T8) ^ M13;\n+    M21 = (T19 & D) ^ M1 ^ T24 ^ M15;\n+    M22 = T26 ^ M6 ^ (T22 & T9) ^ M13;\n+    M23 = (T20 & T17) ^ M6 ^ M15 ^ T25;\n+    M25 = M22 & M20;\n+    M37 = M21 ^ ((M20 ^ M21) & (M23 ^ M25));\n+    M38 = M20 ^ M25 ^ (M21 | (M20 & M23));\n+    M39 = M23 ^ ((M22 ^ M23) & (M21 ^ M25));\n+    M40 = M22 ^ M25 ^ (M23 | (M21 & M22));\n+    M41 = M38 ^ M40;\n+    M42 = M37 ^ M39;\n+    M43 = M37 ^ M38;\n+    M44 = M39 ^ M40;\n+    M45 = M42 ^ M41;\n+    M46 = M44 & T6;\n+    M47 = M40 & T8;\n+    M48 = M39 & D;\n+    M49 = M43 & T16;\n+    M50 = M38 & T9;\n+    M51 = M37 & T17;\n+    M52 = M42 & T15;\n+    M53 = M45 & T27;\n+    M54 = M41 & T10;\n+    M55 = M44 & T13;\n+    M56 = M40 & T23;\n+    M57 = M39 & T19;\n+    M58 = M43 & T3;\n+    M59 = M38 & T22;\n+    M60 = M37 & T20;\n+    M61 = M42 & T1;\n+    M62 = M45 & T4;\n+    M63 = M41 & T2;\n+\n+    if (inv){\n+        /* Undo linear preprocessing */\n+        uint16_t P0 = M52 ^ M61;\n+        uint16_t P1 = M58 ^ M59;\n+        uint16_t P2 = M54 ^ M62;\n+        uint16_t P3 = M47 ^ M50;\n+        uint16_t P4 = M48 ^ M56;\n+        uint16_t P5 = M46 ^ M51;\n+        uint16_t P6 = M49 ^ M60;\n+        uint16_t P7 = P0 ^ P1;\n+        uint16_t P8 = M50 ^ M53;\n+        uint16_t P9 = M55 ^ M63;\n+        uint16_t P10 = M57 ^ P4;\n+        uint16_t P11 = P0 ^ P3;\n+        uint16_t P12 = M46 ^ M48;\n+        uint16_t P13 = M49 ^ M51;\n+        uint16_t P14 = M49 ^ M62;\n+        uint16_t P15 = M54 ^ M59;\n+        uint16_t P16 = M57 ^ M61;\n+        uint16_t P17 = M58 ^ P2;\n+        uint16_t P18 = M63 ^ P5;\n+        uint16_t P19 = P2 ^ P3;\n+        uint16_t P20 = P4 ^ P6;\n+        uint16_t P22 = P2 ^ P7;\n+        uint16_t P23 = P7 ^ P8;\n+        uint16_t P24 = P5 ^ P7;\n+        uint16_t P25 = P6 ^ P10;\n+        uint16_t P26 = P9 ^ P11;\n+        uint16_t P27 = P10 ^ P18;\n+        uint16_t P28 = P11 ^ P25;\n+        uint16_t P29 = P15 ^ P20;\n+        s->slice[7] = P13 ^ P22;\n+        s->slice[6] = P26 ^ P29;\n+        s->slice[5] = P17 ^ P28;\n+        s->slice[4] = P12 ^ P22;\n+        s->slice[3] = P23 ^ P27;\n+        s->slice[2] = P19 ^ P24;\n+        s->slice[1] = P14 ^ P23;\n+        s->slice[0] = P9 ^ P16;\n+    } else {\n+        /* Linear postprocessing */\n+        uint16_t L0 = M61 ^ M62;\n+        uint16_t L1 = M50 ^ M56;\n+        uint16_t L2 = M46 ^ M48;\n+        uint16_t L3 = M47 ^ M55;\n+        uint16_t L4 = M54 ^ M58;\n+        uint16_t L5 = M49 ^ M61;\n+        uint16_t L6 = M62 ^ L5;\n+        uint16_t L7 = M46 ^ L3;\n+        uint16_t L8 = M51 ^ M59;\n+        uint16_t L9 = M52 ^ M53;\n+        uint16_t L10 = M53 ^ L4;\n+        uint16_t L11 = M60 ^ L2;\n+        uint16_t L12 = M48 ^ M51;\n+        uint16_t L13 = M50 ^ L0;\n+        uint16_t L14 = M52 ^ M61;\n+        uint16_t L15 = M55 ^ L1;\n+        uint16_t L16 = M56 ^ L0;\n+        uint16_t L17 = M57 ^ L1;\n+        uint16_t L18 = M58 ^ L8;\n+        uint16_t L19 = M63 ^ L4;\n+        uint16_t L20 = L0 ^ L1;\n+        uint16_t L21 = L1 ^ L7;\n+        uint16_t L22 = L3 ^ L12;\n+        uint16_t L23 = L18 ^ L2;\n+        uint16_t L24 = L15 ^ L9;\n+        uint16_t L25 = L6 ^ L10;\n+        uint16_t L26 = L7 ^ L9;\n+        uint16_t L27 = L8 ^ L10;\n+        uint16_t L28 = L11 ^ L14;\n+        uint16_t L29 = L11 ^ L17;\n+        s->slice[7] = L6 ^ L24;\n+        s->slice[6] = ~(L16 ^ L26);\n+        s->slice[5] = ~(L19 ^ L28);\n+        s->slice[4] = L6 ^ L21;\n+        s->slice[3] = L20 ^ L22;\n+        s->slice[2] = L25 ^ L29;\n+        s->slice[1] = ~(L13 ^ L27);\n+        s->slice[0] = ~(L6 ^ L23);\n+    }\n+}\n+\n+#define BIT_RANGE(from,to) (((1 << ((to) - (from))) - 1) << (from))\n+\n+#define BIT_RANGE_LEFT(x,from,to,shift) (((x) & BIT_RANGE((from), (to))) << (shift))\n+#define BIT_RANGE_RIGHT(x,from,to,shift) (((x) & BIT_RANGE((from), (to))) >> (shift))\n+\n+static void ShiftRows(AES_state* s) {\n+    int i;\n+    for (i = 0; i < 8; i++) {\n+        uint16_t v = s->slice[i];\n+        s->slice[i] =\n+            (v & BIT_RANGE(0, 4)) |\n+            BIT_RANGE_LEFT(v, 4, 5, 3) | BIT_RANGE_RIGHT(v, 5, 8, 1) |\n+            BIT_RANGE_LEFT(v, 8, 10, 2) | BIT_RANGE_RIGHT(v, 10, 12, 2) |\n+            BIT_RANGE_LEFT(v, 12, 15, 1) | BIT_RANGE_RIGHT(v, 15, 16, 3);\n+    }\n+}\n+\n+static void InvShiftRows(AES_state* s) {\n+    int i;\n+    for (i = 0; i < 8; i++) {\n+        uint16_t v = s->slice[i];\n+        s->slice[i] =\n+            (v & BIT_RANGE(0, 4)) |\n+            BIT_RANGE_LEFT(v, 4, 7, 1) | BIT_RANGE_RIGHT(v, 7, 8, 3) |\n+            BIT_RANGE_LEFT(v, 8, 10, 2) | BIT_RANGE_RIGHT(v, 10, 12, 2) |\n+            BIT_RANGE_LEFT(v, 12, 13, 3) | BIT_RANGE_RIGHT(v, 13, 16, 1);\n+    }\n+}\n+\n+#define ROT(x,b) (((x) >> ((b) * 4)) | ((x) << ((4-(b)) * 4)))\n+\n+static void MixColumns(AES_state* s, int inv) {\n+    /* The MixColumns transform treats the bytes of the columns of the state as\n+     * coefficients of a 3rd degree polynomial over GF(2^8) and multiplies them\n+     * by the fixed polynomial a(x) = {03}x^3 + {01}x^2 + {01}x + {02}, modulo\n+     * x^4 + {01}.\n+     *\n+     * In the inverse transform, we multiply by the inverse of a(x),\n+     * a^-1(x) = {0b}x^3 + {0d}x^2 + {09}x + {0e}. This is equal to\n+     * a(x) * ({04}x^2 + {05}), so we can reuse the forward transform's code\n+     * (found in OpenSSL's bsaes-x86_64.pl, attributed to Jussi Kivilinna)\n+     *\n+     * In the bitsliced representation, a multiplication of every column by x\n+     * mod x^4 + 1 is simply a right rotation.\n+     */\n+\n+    /* Shared for both directions is a multiplication by a(x), which can be\n+     * rewritten as (x^3 + x^2 + x) + {02}*(x^3 + {01}).\n+     *\n+     * First compute s into the s? variables, (x^3 + {01}) * s into the s?_01\n+     * variables and (x^3 + x^2 + x)*s into the s?_123 variables.\n+     */\n+    uint16_t s0 = s->slice[0], s1 = s->slice[1], s2 = s->slice[2], s3 = s->slice[3];\n+    uint16_t s4 = s->slice[4], s5 = s->slice[5], s6 = s->slice[6], s7 = s->slice[7];\n+    uint16_t s0_01 = s0 ^ ROT(s0, 1), s0_123 = ROT(s0_01, 1) ^ ROT(s0, 3);\n+    uint16_t s1_01 = s1 ^ ROT(s1, 1), s1_123 = ROT(s1_01, 1) ^ ROT(s1, 3);\n+    uint16_t s2_01 = s2 ^ ROT(s2, 1), s2_123 = ROT(s2_01, 1) ^ ROT(s2, 3);\n+    uint16_t s3_01 = s3 ^ ROT(s3, 1), s3_123 = ROT(s3_01, 1) ^ ROT(s3, 3);\n+    uint16_t s4_01 = s4 ^ ROT(s4, 1), s4_123 = ROT(s4_01, 1) ^ ROT(s4, 3);\n+    uint16_t s5_01 = s5 ^ ROT(s5, 1), s5_123 = ROT(s5_01, 1) ^ ROT(s5, 3);\n+    uint16_t s6_01 = s6 ^ ROT(s6, 1), s6_123 = ROT(s6_01, 1) ^ ROT(s6, 3);\n+    uint16_t s7_01 = s7 ^ ROT(s7, 1), s7_123 = ROT(s7_01, 1) ^ ROT(s7, 3);\n+    /* Now compute s = s?_123 + {02} * s?_01. */\n+    s->slice[0] = s7_01 ^ s0_123;\n+    s->slice[1] = s7_01 ^ s0_01 ^ s1_123;\n+    s->slice[2] = s1_01 ^ s2_123;\n+    s->slice[3] = s7_01 ^ s2_01 ^ s3_123;\n+    s->slice[4] = s7_01 ^ s3_01 ^ s4_123;\n+    s->slice[5] = s4_01 ^ s5_123;\n+    s->slice[6] = s5_01 ^ s6_123;\n+    s->slice[7] = s6_01 ^ s7_123;\n+    if (inv) {\n+        /* In the reverse direction, we further need to multiply by\n+         * {04}x^2 + {05}, which can be written as {04} * (x^2 + {01}) + {01}.\n+         *\n+         * First compute (x^2 + {01}) * s into the t?_02 variables: */\n+        uint16_t t0_02 = s->slice[0] ^ ROT(s->slice[0], 2);\n+        uint16_t t1_02 = s->slice[1] ^ ROT(s->slice[1], 2);\n+        uint16_t t2_02 = s->slice[2] ^ ROT(s->slice[2], 2);\n+        uint16_t t3_02 = s->slice[3] ^ ROT(s->slice[3], 2);\n+        uint16_t t4_02 = s->slice[4] ^ ROT(s->slice[4], 2);\n+        uint16_t t5_02 = s->slice[5] ^ ROT(s->slice[5], 2);\n+        uint16_t t6_02 = s->slice[6] ^ ROT(s->slice[6], 2);\n+        uint16_t t7_02 = s->slice[7] ^ ROT(s->slice[7], 2);\n+        /* And then update s += {04} * t?_02 */\n+        s->slice[0] ^= t6_02;\n+        s->slice[1] ^= t6_02 ^ t7_02;\n+        s->slice[2] ^= t0_02 ^ t7_02;\n+        s->slice[3] ^= t1_02 ^ t6_02;\n+        s->slice[4] ^= t2_02 ^ t6_02 ^ t7_02;\n+        s->slice[5] ^= t3_02 ^ t7_02;\n+        s->slice[6] ^= t4_02;\n+        s->slice[7] ^= t5_02;\n+    }\n+}\n+\n+static void AddRoundKey(AES_state* s, const AES_state* round) {\n+    int b;\n+    for (b = 0; b < 8; b++) {\n+        s->slice[b] ^= round->slice[b];\n+    }\n+}\n+\n+/** column_0(s) = column_c(a) */\n+static void GetOneColumn(AES_state* s, const AES_state* a, int c) {\n+    int b;\n+    for (b = 0; b < 8; b++) {\n+        s->slice[b] = (a->slice[b] >> c) & 0x1111;\n+    }\n+}\n+\n+/** column_c1(r) |= (column_0(s) ^= column_c2(a)) */\n+static void KeySetupColumnMix(AES_state* s, AES_state* r, const AES_state* a, int c1, int c2) {\n+    int b;\n+    for (b = 0; b < 8; b++) {\n+        r->slice[b] |= ((s->slice[b] ^= ((a->slice[b] >> c2) & 0x1111)) & 0x1111) << c1;\n+    }\n+}\n+\n+/** Rotate the rows in s one position upwards, and xor in r */\n+static void KeySetupTransform(AES_state* s, const AES_state* r) {\n+    int b;\n+    for (b = 0; b < 8; b++) {\n+        s->slice[b] = ((s->slice[b] >> 4) | (s->slice[b] << 12)) ^ r->slice[b];\n+    }\n+}\n+\n+/* Multiply the cells in s by x, as polynomials over GF(2) mod x^8 + x^4 + x^3 + x + 1 */\n+static void MultX(AES_state* s) {\n+    uint16_t top = s->slice[7];\n+    s->slice[7] = s->slice[6];\n+    s->slice[6] = s->slice[5];\n+    s->slice[5] = s->slice[4];\n+    s->slice[4] = s->slice[3] ^ top;\n+    s->slice[3] = s->slice[2] ^ top;\n+    s->slice[2] = s->slice[1];\n+    s->slice[1] = s->slice[0] ^ top;\n+    s->slice[0] = top;\n+}\n+\n+/** Expand the cipher key into the key schedule.\n+ *\n+ *  state must be a pointer to an array of size nrounds + 1.\n+ *  key must be a pointer to 4 * nkeywords bytes.\n+ *\n+ *  AES128 uses nkeywords = 4, nrounds = 10\n+ *  AES192 uses nkeywords = 6, nrounds = 12\n+ *  AES256 uses nkeywords = 8, nrounds = 14\n+ */\n+static void AES_setup(AES_state* rounds, const uint8_t* key, int nkeywords, int nrounds)\n+{\n+    int i;\n+\n+    /* The one-byte round constant */\n+    AES_state rcon = {{1,0,0,0,0,0,0,0}};\n+    /* The number of the word being generated, modulo nkeywords */\n+    int pos = 0;\n+    /* The column representing the word currently being processed */\n+    AES_state column;\n+\n+    for (i = 0; i < nrounds + 1; i++) {\n+        int b;\n+        for (b = 0; b < 8; b++) {\n+            rounds[i].slice[b] = 0;\n+        }\n+    }\n+\n+    /* The first nkeywords round columns are just taken from the key directly. */\n+    for (i = 0; i < nkeywords; i++) {\n+        int r;\n+        for (r = 0; r < 4; r++) {\n+            LoadByte(&rounds[i >> 2], *(key++), r, i & 3);\n+        }\n+    }\n+\n+    GetOneColumn(&column, &rounds[(nkeywords - 1) >> 2], (nkeywords - 1) & 3);\n+\n+    for (i = nkeywords; i < 4 * (nrounds + 1); i++) {\n+        /* Transform column */\n+        if (pos == 0) {\n+            SubBytes(&column, 0);\n+            KeySetupTransform(&column, &rcon);\n+            MultX(&rcon);\n+        } else if (nkeywords > 6 && pos == 4) {\n+            SubBytes(&column, 0);\n+        }\n+        if (++pos == nkeywords) pos = 0;\n+        KeySetupColumnMix(&column, &rounds[i >> 2], &rounds[(i - nkeywords) >> 2], i & 3, (i - nkeywords) & 3);\n+    }\n+}\n+\n+static void AES_encrypt(const AES_state* rounds, int nrounds, unsigned char* cipher16, const unsigned char* plain16) {\n+    AES_state s = {{0}};\n+    int round;\n+\n+    LoadBytes(&s, plain16);\n+    AddRoundKey(&s, rounds++);\n+\n+    for (round = 1; round < nrounds; round++) {\n+        SubBytes(&s, 0);\n+        ShiftRows(&s);\n+        MixColumns(&s, 0);\n+        AddRoundKey(&s, rounds++);\n+    }\n+\n+    SubBytes(&s, 0);\n+    ShiftRows(&s);\n+    AddRoundKey(&s, rounds);\n+\n+    SaveBytes(cipher16, &s);\n+}\n+\n+static void AES_decrypt(const AES_state* rounds, int nrounds, unsigned char* plain16, const unsigned char* cipher16) {\n+    /* Most AES decryption implementations use the alternate scheme\n+     * (the Equivalent Inverse Cipher), which looks more like encryption, but\n+     * needs different round constants. We can't reuse any code here anyway, so\n+     * don't bother. */\n+    AES_state s = {{0}};\n+    int round;\n+\n+    rounds += nrounds;\n+\n+    LoadBytes(&s, cipher16);\n+    AddRoundKey(&s, rounds--);\n+\n+    for (round = 1; round < nrounds; round++) {\n+        InvShiftRows(&s);\n+        SubBytes(&s, 1);\n+        AddRoundKey(&s, rounds--);\n+        MixColumns(&s, 1);\n+    }\n+\n+    InvShiftRows(&s);\n+    SubBytes(&s, 1);\n+    AddRoundKey(&s, rounds);\n+\n+    SaveBytes(plain16, &s);\n+}\n+\n+void AES128_init(AES128_ctx* ctx, const unsigned char* key16) {\n+    AES_setup(ctx->rk, key16, 4, 10);\n+}\n+\n+void AES128_encrypt(const AES128_ctx* ctx, size_t blocks, unsigned char* cipher16, const unsigned char* plain16) {\n+    while (blocks--) {\n+        AES_encrypt(ctx->rk, 10, cipher16, plain16);\n+        cipher16 += 16;\n+        plain16 += 16;\n+    }\n+}\n+\n+void AES128_decrypt(const AES128_ctx* ctx, size_t blocks, unsigned char* plain16, const unsigned char* cipher16) {\n+    while (blocks--) {\n+        AES_decrypt(ctx->rk, 10, plain16, cipher16);\n+        cipher16 += 16;\n+        plain16 += 16;\n+    }\n+}\n+\n+void AES192_init(AES192_ctx* ctx, const unsigned char* key24) {\n+    AES_setup(ctx->rk, key24, 6, 12);\n+}\n+\n+void AES192_encrypt(const AES192_ctx* ctx, size_t blocks, unsigned char* cipher16, const unsigned char* plain16) {\n+    while (blocks--) {\n+        AES_encrypt(ctx->rk, 12, cipher16, plain16);\n+        cipher16 += 16;\n+        plain16 += 16;\n+    }\n+\n+}\n+\n+void AES192_decrypt(const AES192_ctx* ctx, size_t blocks, unsigned char* plain16, const unsigned char* cipher16) {\n+    while (blocks--) {\n+        AES_decrypt(ctx->rk, 12, plain16, cipher16);\n+        cipher16 += 16;\n+        plain16 += 16;\n+    }\n+}\n+\n+void AES256_init(AES256_ctx* ctx, const unsigned char* key32) {\n+    AES_setup(ctx->rk, key32, 8, 14);\n+}\n+\n+void AES256_encrypt(const AES256_ctx* ctx, size_t blocks, unsigned char* cipher16, const unsigned char* plain16) {\n+    while (blocks--) {\n+        AES_encrypt(ctx->rk, 14, cipher16, plain16);\n+        cipher16 += 16;\n+        plain16 += 16;\n+    }\n+}\n+\n+void AES256_decrypt(const AES256_ctx* ctx, size_t blocks, unsigned char* plain16, const unsigned char* cipher16) {\n+    while (blocks--) {\n+        AES_decrypt(ctx->rk, 14, plain16, cipher16);\n+        cipher16 += 16;\n+        plain16 += 16;\n+    }\n+}"
      },
      {
        "sha": "2f0af042160536beda0f35da4e76b98cd654fc9b",
        "filename": "src/crypto/ctaes/ctaes.h",
        "status": "added",
        "additions": 41,
        "deletions": 0,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cd2be4419e9d8c6445fecc877b50198dc918a81f/src/crypto/ctaes/ctaes.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cd2be4419e9d8c6445fecc877b50198dc918a81f/src/crypto/ctaes/ctaes.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/ctaes/ctaes.h?ref=cd2be4419e9d8c6445fecc877b50198dc918a81f",
        "patch": "@@ -0,0 +1,41 @@\n+ /*********************************************************************\n+ * Copyright (c) 2016 Pieter Wuille                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _CTAES_H_\n+#define _CTAES_H_ 1\n+\n+#include <stdint.h>\n+#include <stdlib.h>\n+\n+typedef struct {\n+    uint16_t slice[8];\n+} AES_state;\n+\n+typedef struct {\n+    AES_state rk[11];\n+} AES128_ctx;\n+\n+typedef struct {\n+    AES_state rk[13];\n+} AES192_ctx;\n+\n+typedef struct {\n+    AES_state rk[15];\n+} AES256_ctx;\n+\n+void AES128_init(AES128_ctx* ctx, const unsigned char* key16);\n+void AES128_encrypt(const AES128_ctx* ctx, size_t blocks, unsigned char* cipher16, const unsigned char* plain16);\n+void AES128_decrypt(const AES128_ctx* ctx, size_t blocks, unsigned char* plain16, const unsigned char* cipher16);\n+\n+void AES192_init(AES192_ctx* ctx, const unsigned char* key24);\n+void AES192_encrypt(const AES192_ctx* ctx, size_t blocks, unsigned char* cipher16, const unsigned char* plain16);\n+void AES192_decrypt(const AES192_ctx* ctx, size_t blocks, unsigned char* plain16, const unsigned char* cipher16);\n+\n+void AES256_init(AES256_ctx* ctx, const unsigned char* key32);\n+void AES256_encrypt(const AES256_ctx* ctx, size_t blocks, unsigned char* cipher16, const unsigned char* plain16);\n+void AES256_decrypt(const AES256_ctx* ctx, size_t blocks, unsigned char* plain16, const unsigned char* cipher16);\n+\n+#endif"
      },
      {
        "sha": "fce1696acdc2db618cc88c288b190a567d8f9e1c",
        "filename": "src/crypto/ctaes/test.c",
        "status": "added",
        "additions": 110,
        "deletions": 0,
        "changes": 110,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cd2be4419e9d8c6445fecc877b50198dc918a81f/src/crypto/ctaes/test.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cd2be4419e9d8c6445fecc877b50198dc918a81f/src/crypto/ctaes/test.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/ctaes/test.c?ref=cd2be4419e9d8c6445fecc877b50198dc918a81f",
        "patch": "@@ -0,0 +1,110 @@\n+ /*********************************************************************\n+ * Copyright (c) 2016 Pieter Wuille                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include \"ctaes.h\"\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <assert.h>\n+\n+typedef struct {\n+    int keysize;\n+    const char* key;\n+    const char* plain;\n+    const char* cipher;\n+} ctaes_test;\n+\n+static const ctaes_test ctaes_tests[] = {\n+    /* AES test vectors from FIPS 197. */\n+    {128, \"000102030405060708090a0b0c0d0e0f\", \"00112233445566778899aabbccddeeff\", \"69c4e0d86a7b0430d8cdb78070b4c55a\"},\n+    {192, \"000102030405060708090a0b0c0d0e0f1011121314151617\", \"00112233445566778899aabbccddeeff\", \"dda97ca4864cdfe06eaf70a0ec0d7191\"},\n+    {256, \"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\", \"00112233445566778899aabbccddeeff\", \"8ea2b7ca516745bfeafc49904b496089\"},\n+\n+    /* AES-ECB test vectors from NIST sp800-38a. */\n+    {128, \"2b7e151628aed2a6abf7158809cf4f3c\", \"6bc1bee22e409f96e93d7e117393172a\", \"3ad77bb40d7a3660a89ecaf32466ef97\"},\n+    {128, \"2b7e151628aed2a6abf7158809cf4f3c\", \"ae2d8a571e03ac9c9eb76fac45af8e51\", \"f5d3d58503b9699de785895a96fdbaaf\"},\n+    {128, \"2b7e151628aed2a6abf7158809cf4f3c\", \"30c81c46a35ce411e5fbc1191a0a52ef\", \"43b1cd7f598ece23881b00e3ed030688\"},\n+    {128, \"2b7e151628aed2a6abf7158809cf4f3c\", \"f69f2445df4f9b17ad2b417be66c3710\", \"7b0c785e27e8ad3f8223207104725dd4\"},\n+    {192, \"8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\", \"6bc1bee22e409f96e93d7e117393172a\", \"bd334f1d6e45f25ff712a214571fa5cc\"},\n+    {192, \"8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\", \"ae2d8a571e03ac9c9eb76fac45af8e51\", \"974104846d0ad3ad7734ecb3ecee4eef\"},\n+    {192, \"8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\", \"30c81c46a35ce411e5fbc1191a0a52ef\", \"ef7afd2270e2e60adce0ba2face6444e\"},\n+    {192, \"8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\", \"f69f2445df4f9b17ad2b417be66c3710\", \"9a4b41ba738d6c72fb16691603c18e0e\"},\n+    {256, \"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\", \"6bc1bee22e409f96e93d7e117393172a\", \"f3eed1bdb5d2a03c064b5a7e3db181f8\"},\n+    {256, \"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\", \"ae2d8a571e03ac9c9eb76fac45af8e51\", \"591ccb10d410ed26dc5ba74a31362870\"},\n+    {256, \"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\", \"30c81c46a35ce411e5fbc1191a0a52ef\", \"b6ed21b99ca6f4f9f153e7b1beafed1d\"},\n+    {256, \"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\", \"f69f2445df4f9b17ad2b417be66c3710\", \"23304b7a39f9f3ff067d8d8f9e24ecc7\"}\n+};\n+\n+static void from_hex(unsigned char* data, int len, const char* hex) {\n+    int p;\n+    for (p = 0; p < len; p++) {\n+        int v = 0;\n+        int n;\n+        for (n = 0; n < 2; n++) {\n+            assert((*hex >= '0' && *hex <= '9') || (*hex >= 'a' && *hex <= 'f'));\n+            if (*hex >= '0' && *hex <= '9') {\n+                v |= (*hex - '0') << (4 * (1 - n));\n+            } else {\n+                v |= (*hex - 'a' + 10) << (4 * (1 - n));\n+            }\n+            hex++;\n+        }\n+        *(data++) = v;\n+    }\n+    assert(*hex == 0);\n+}\n+\n+int main(void) {\n+    int i;\n+    int fail = 0;\n+    for (i = 0; i < sizeof(ctaes_tests) / sizeof(ctaes_tests[0]); i++) {\n+        unsigned char key[32], plain[16], cipher[16], ciphered[16], deciphered[16];\n+        const ctaes_test* test = &ctaes_tests[i];\n+        assert(test->keysize == 128 || test->keysize == 192 || test->keysize == 256);\n+        from_hex(plain, 16, test->plain);\n+        from_hex(cipher, 16, test->cipher);\n+        switch (test->keysize) {\n+            case 128: {\n+                AES128_ctx ctx;\n+                from_hex(key, 16, test->key);\n+                AES128_init(&ctx, key);\n+                AES128_encrypt(&ctx, 1, ciphered, plain);\n+                AES128_decrypt(&ctx, 1, deciphered, cipher);\n+                break;\n+            }\n+            case 192: {\n+                AES192_ctx ctx;\n+                from_hex(key, 24, test->key);\n+                AES192_init(&ctx, key);\n+                AES192_encrypt(&ctx, 1, ciphered, plain);\n+                AES192_decrypt(&ctx, 1, deciphered, cipher);\n+                break;\n+            }\n+            case 256: {\n+                AES256_ctx ctx;\n+                from_hex(key, 32, test->key);\n+                AES256_init(&ctx, key);\n+                AES256_encrypt(&ctx, 1, ciphered, plain);\n+                AES256_decrypt(&ctx, 1, deciphered, cipher);\n+                break;\n+            }\n+        }\n+        if (memcmp(cipher, ciphered, 16)) {\n+            fprintf(stderr, \"E(key=\\\"%s\\\", plain=\\\"%s\\\") != \\\"%s\\\"\\n\", test->key, test->plain, test->cipher);\n+            fail++;\n+        }\n+        if (memcmp(plain, deciphered, 16)) {\n+            fprintf(stderr, \"D(key=\\\"%s\\\", cipher=\\\"%s\\\") != \\\"%s\\\"\\n\", test->key, test->cipher, test->plain);\n+            fail++;\n+        }\n+    }\n+    if (fail == 0) {\n+        fprintf(stderr, \"All tests succesful\\n\");\n+    } else {\n+        fprintf(stderr, \"%i tests failed\\n\", fail);\n+    }\n+    return (fail != 0);\n+}"
      }
    ]
  },
  {
    "sha": "6bec172eb95e195847bb6dd6d4e62ada79c98c6d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2YmVjMTcyZWI5NWUxOTU4NDdiYjZkZDZkNGU2MmFkYTc5Yzk4YzZk",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-03-30T13:37:41Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-05-13T08:22:54Z"
      },
      "message": "Add ctaes-based constant time AES implementation",
      "tree": {
        "sha": "741f48e6f1aeaa04652605d732a6ee8ae4b248ae",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/741f48e6f1aeaa04652605d732a6ee8ae4b248ae"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6bec172eb95e195847bb6dd6d4e62ada79c98c6d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6bec172eb95e195847bb6dd6d4e62ada79c98c6d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6bec172eb95e195847bb6dd6d4e62ada79c98c6d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6bec172eb95e195847bb6dd6d4e62ada79c98c6d/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cd2be4419e9d8c6445fecc877b50198dc918a81f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cd2be4419e9d8c6445fecc877b50198dc918a81f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cd2be4419e9d8c6445fecc877b50198dc918a81f"
      }
    ],
    "stats": {
      "total": 199,
      "additions": 198,
      "deletions": 1
    },
    "files": [
      {
        "sha": "0ab0d66ac21cb013493b6f7ea05ae84e0deb7264",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bec172eb95e195847bb6dd6d4e62ada79c98c6d/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bec172eb95e195847bb6dd6d4e62ada79c98c6d/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=6bec172eb95e195847bb6dd6d4e62ada79c98c6d",
        "patch": "@@ -225,6 +225,8 @@ libbitcoin_wallet_a_SOURCES = \\\n crypto_libbitcoin_crypto_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_CONFIG_INCLUDES)\n crypto_libbitcoin_crypto_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n crypto_libbitcoin_crypto_a_SOURCES = \\\n+  crypto/aes.cpp \\\n+  crypto/aes.h \\\n   crypto/common.h \\\n   crypto/hmac_sha256.cpp \\\n   crypto/hmac_sha256.h \\\n@@ -434,7 +436,7 @@ CLEANFILES += zmq/*.gcda zmq/*.gcno\n \n DISTCLEANFILES = obj/build.h\n \n-EXTRA_DIST = leveldb\n+EXTRA_DIST = leveldb crypto/ctaes\n \n clean-local:\n \t-$(MAKE) -C leveldb clean"
      },
      {
        "sha": "035abd75bdbdcf9781b6b4b3ab4e4e64ac25c8dd",
        "filename": "src/crypto/aes.cpp",
        "status": "added",
        "additions": 73,
        "deletions": 0,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bec172eb95e195847bb6dd6d4e62ada79c98c6d/src/crypto/aes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bec172eb95e195847bb6dd6d4e62ada79c98c6d/src/crypto/aes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/aes.cpp?ref=6bec172eb95e195847bb6dd6d4e62ada79c98c6d",
        "patch": "@@ -0,0 +1,73 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"aes.h\"\n+#include \"crypto/common.h\"\n+\n+#include <assert.h>\n+#include <string.h>\n+\n+extern \"C\" {\n+#include \"crypto/ctaes/ctaes.c\"\n+}\n+\n+AES128Encrypt::AES128Encrypt(const unsigned char key[16])\n+{\n+    AES128_init(&ctx, key);\n+}\n+\n+AES128Encrypt::~AES128Encrypt()\n+{\n+    memset(&ctx, 0, sizeof(ctx));\n+}\n+\n+void AES128Encrypt::Encrypt(unsigned char ciphertext[16], const unsigned char plaintext[16]) const\n+{\n+    AES128_encrypt(&ctx, 1, ciphertext, plaintext);\n+}\n+\n+AES128Decrypt::AES128Decrypt(const unsigned char key[16])\n+{\n+    AES128_init(&ctx, key);\n+}\n+\n+AES128Decrypt::~AES128Decrypt()\n+{\n+    memset(&ctx, 0, sizeof(ctx));\n+}\n+\n+void AES128Decrypt::Decrypt(unsigned char plaintext[16], const unsigned char ciphertext[16]) const\n+{\n+    AES128_decrypt(&ctx, 1, plaintext, ciphertext);\n+}\n+\n+AES256Encrypt::AES256Encrypt(const unsigned char key[32])\n+{\n+    AES256_init(&ctx, key);\n+}\n+\n+AES256Encrypt::~AES256Encrypt()\n+{\n+    memset(&ctx, 0, sizeof(ctx));\n+}\n+\n+void AES256Encrypt::Encrypt(unsigned char ciphertext[16], const unsigned char plaintext[16]) const\n+{\n+    AES256_encrypt(&ctx, 1, ciphertext, plaintext);\n+}\n+\n+AES256Decrypt::AES256Decrypt(const unsigned char key[32])\n+{\n+    AES256_init(&ctx, key);\n+}\n+\n+AES256Decrypt::~AES256Decrypt()\n+{\n+    memset(&ctx, 0, sizeof(ctx));\n+}\n+\n+void AES256Decrypt::Decrypt(unsigned char plaintext[16], const unsigned char ciphertext[16]) const\n+{\n+    AES256_decrypt(&ctx, 1, plaintext, ciphertext);\n+}"
      },
      {
        "sha": "4bf17a33eae55d3109d32247d967a6c0cf02104e",
        "filename": "src/crypto/aes.h",
        "status": "added",
        "additions": 66,
        "deletions": 0,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bec172eb95e195847bb6dd6d4e62ada79c98c6d/src/crypto/aes.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bec172eb95e195847bb6dd6d4e62ada79c98c6d/src/crypto/aes.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/aes.h?ref=6bec172eb95e195847bb6dd6d4e62ada79c98c6d",
        "patch": "@@ -0,0 +1,66 @@\n+// Copyright (c) 2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+//\n+// C++ wrapper around ctaes, a constant-time AES implementation\n+\n+#ifndef BITCOIN_CRYPTO_AES_H\n+#define BITCOIN_CRYPTO_AES_H\n+\n+extern \"C\" {\n+#include \"crypto/ctaes/ctaes.h\"\n+}\n+\n+static const int AES_BLOCKSIZE = 16;\n+static const int AES128_KEYSIZE = 16;\n+static const int AES256_KEYSIZE = 32;\n+\n+/** An encryption class for AES-128. */\n+class AES128Encrypt\n+{\n+private:\n+    AES128_ctx ctx;\n+\n+public:\n+    AES128Encrypt(const unsigned char key[16]);\n+    ~AES128Encrypt();\n+    void Encrypt(unsigned char ciphertext[16], const unsigned char plaintext[16]) const;\n+};\n+\n+/** A decryption class for AES-128. */\n+class AES128Decrypt\n+{\n+private:\n+    AES128_ctx ctx;\n+\n+public:\n+    AES128Decrypt(const unsigned char key[16]);\n+    ~AES128Decrypt();\n+    void Decrypt(unsigned char plaintext[16], const unsigned char ciphertext[16]) const;\n+};\n+\n+/** An encryption class for AES-256. */\n+class AES256Encrypt\n+{\n+private:\n+    AES256_ctx ctx;\n+\n+public:\n+    AES256Encrypt(const unsigned char key[32]);\n+    ~AES256Encrypt();\n+    void Encrypt(unsigned char ciphertext[16], const unsigned char plaintext[16]) const;\n+};\n+\n+/** A decryption class for AES-256. */\n+class AES256Decrypt\n+{\n+private:\n+    AES256_ctx ctx;\n+\n+public:\n+    AES256Decrypt(const unsigned char key[32]);\n+    ~AES256Decrypt();\n+    void Decrypt(unsigned char plaintext[16], const unsigned char ciphertext[16]) const;\n+};\n+\n+#endif // BITCOIN_CRYPTO_AES_H"
      },
      {
        "sha": "3fc9855d6ab6339c06f279589e4f6f3d7c605966",
        "filename": "src/test/crypto_tests.cpp",
        "status": "modified",
        "additions": 56,
        "deletions": 0,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bec172eb95e195847bb6dd6d4e62ada79c98c6d/src/test/crypto_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bec172eb95e195847bb6dd6d4e62ada79c98c6d/src/test/crypto_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/crypto_tests.cpp?ref=6bec172eb95e195847bb6dd6d4e62ada79c98c6d",
        "patch": "@@ -2,6 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include \"crypto/aes.h\"\n #include \"crypto/ripemd160.h\"\n #include \"crypto/sha1.h\"\n #include \"crypto/sha256.h\"\n@@ -63,6 +64,45 @@ void TestHMACSHA512(const std::string &hexkey, const std::string &hexin, const s\n     TestVector(CHMAC_SHA512(&key[0], key.size()), ParseHex(hexin), ParseHex(hexout));\n }\n \n+void TestAES128(const std::string &hexkey, const std::string &hexin, const std::string &hexout)\n+{\n+    std::vector<unsigned char> key = ParseHex(hexkey);\n+    std::vector<unsigned char> in = ParseHex(hexin);\n+    std::vector<unsigned char> correctout = ParseHex(hexout);\n+    std::vector<unsigned char> buf, buf2;\n+\n+    assert(key.size() == 16);\n+    assert(in.size() == 16);\n+    assert(correctout.size() == 16);\n+    AES128Encrypt enc(&key[0]);\n+    buf.resize(correctout.size());\n+    buf2.resize(correctout.size());\n+    enc.Encrypt(&buf[0], &in[0]);\n+    BOOST_CHECK_EQUAL(HexStr(buf), HexStr(correctout));\n+    AES128Decrypt dec(&key[0]);\n+    dec.Decrypt(&buf2[0], &buf[0]);\n+    BOOST_CHECK_EQUAL(HexStr(buf2), HexStr(in));\n+}\n+\n+void TestAES256(const std::string &hexkey, const std::string &hexin, const std::string &hexout)\n+{\n+    std::vector<unsigned char> key = ParseHex(hexkey);\n+    std::vector<unsigned char> in = ParseHex(hexin);\n+    std::vector<unsigned char> correctout = ParseHex(hexout);\n+    std::vector<unsigned char> buf;\n+\n+    assert(key.size() == 32);\n+    assert(in.size() == 16);\n+    assert(correctout.size() == 16);\n+    AES256Encrypt enc(&key[0]);\n+    buf.resize(correctout.size());\n+    enc.Encrypt(&buf[0], &in[0]);\n+    BOOST_CHECK(buf == correctout);\n+    AES256Decrypt dec(&key[0]);\n+    dec.Decrypt(&buf[0], &buf[0]);\n+    BOOST_CHECK(buf == in);\n+}\n+\n std::string LongTestString(void) {\n     std::string ret;\n     for (int i=0; i<200000; i++) {\n@@ -248,4 +288,20 @@ BOOST_AUTO_TEST_CASE(hmac_sha512_testvectors) {\n                    \"b6022cac3c4982b10d5eeb55c3e4de15134676fb6de0446065c97440fa8c6a58\");\n }\n \n+BOOST_AUTO_TEST_CASE(aes_testvectors) {\n+    // AES test vectors from FIPS 197.\n+    TestAES128(\"000102030405060708090a0b0c0d0e0f\", \"00112233445566778899aabbccddeeff\", \"69c4e0d86a7b0430d8cdb78070b4c55a\");\n+    TestAES256(\"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\", \"00112233445566778899aabbccddeeff\", \"8ea2b7ca516745bfeafc49904b496089\");\n+\n+    // AES-ECB test vectors from NIST sp800-38a.\n+    TestAES128(\"2b7e151628aed2a6abf7158809cf4f3c\", \"6bc1bee22e409f96e93d7e117393172a\", \"3ad77bb40d7a3660a89ecaf32466ef97\");\n+    TestAES128(\"2b7e151628aed2a6abf7158809cf4f3c\", \"ae2d8a571e03ac9c9eb76fac45af8e51\", \"f5d3d58503b9699de785895a96fdbaaf\");\n+    TestAES128(\"2b7e151628aed2a6abf7158809cf4f3c\", \"30c81c46a35ce411e5fbc1191a0a52ef\", \"43b1cd7f598ece23881b00e3ed030688\");\n+    TestAES128(\"2b7e151628aed2a6abf7158809cf4f3c\", \"f69f2445df4f9b17ad2b417be66c3710\", \"7b0c785e27e8ad3f8223207104725dd4\");\n+    TestAES256(\"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\", \"6bc1bee22e409f96e93d7e117393172a\", \"f3eed1bdb5d2a03c064b5a7e3db181f8\");\n+    TestAES256(\"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\", \"ae2d8a571e03ac9c9eb76fac45af8e51\", \"591ccb10d410ed26dc5ba74a31362870\");\n+    TestAES256(\"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\", \"30c81c46a35ce411e5fbc1191a0a52ef\", \"b6ed21b99ca6f4f9f153e7b1beafed1d\");\n+    TestAES256(\"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\", \"f69f2445df4f9b17ad2b417be66c3710\", \"23304b7a39f9f3ff067d8d8f9e24ecc7\");\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "27a212dcb4fe842ead77d01b98f2c1a58ecca609",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyN2EyMTJkY2I0ZmU4NDJlYWQ3N2QwMWI5OGYyYzFhNThlY2NhNjA5",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2015-03-20T04:49:13Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-05-13T08:23:03Z"
      },
      "message": "crypto: add AES 128/256 CBC classes\n\nThe output should always match openssl's, even for failed operations. Even for\na decrypt with broken padding, the output is always deterministic (and attemtps\nto be constant-time).",
      "tree": {
        "sha": "4f1afa080592b352e84fc52d5871034cac5b5cf8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4f1afa080592b352e84fc52d5871034cac5b5cf8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/27a212dcb4fe842ead77d01b98f2c1a58ecca609",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/27a212dcb4fe842ead77d01b98f2c1a58ecca609",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/27a212dcb4fe842ead77d01b98f2c1a58ecca609",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/27a212dcb4fe842ead77d01b98f2c1a58ecca609/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6bec172eb95e195847bb6dd6d4e62ada79c98c6d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6bec172eb95e195847bb6dd6d4e62ada79c98c6d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6bec172eb95e195847bb6dd6d4e62ada79c98c6d"
      }
    ],
    "stats": {
      "total": 196,
      "additions": 196,
      "deletions": 0
    },
    "files": [
      {
        "sha": "1d469d0fb4622c3072227d2c41ef46618a502bb8",
        "filename": "src/crypto/aes.cpp",
        "status": "modified",
        "additions": 144,
        "deletions": 0,
        "changes": 144,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27a212dcb4fe842ead77d01b98f2c1a58ecca609/src/crypto/aes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27a212dcb4fe842ead77d01b98f2c1a58ecca609/src/crypto/aes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/aes.cpp?ref=27a212dcb4fe842ead77d01b98f2c1a58ecca609",
        "patch": "@@ -71,3 +71,147 @@ void AES256Decrypt::Decrypt(unsigned char plaintext[16], const unsigned char cip\n {\n     AES256_decrypt(&ctx, 1, plaintext, ciphertext);\n }\n+\n+\n+template <typename T>\n+static int CBCEncrypt(const T& enc, const unsigned char iv[AES_BLOCKSIZE], const unsigned char* data, int size, bool pad, unsigned char* out)\n+{\n+    int written = 0;\n+    int padsize = size % AES_BLOCKSIZE;\n+    unsigned char mixed[AES_BLOCKSIZE];\n+\n+    if (!data || !size || !out)\n+        return 0;\n+\n+    if (!pad && padsize != 0)\n+        return 0;\n+\n+    memcpy(mixed, iv, AES_BLOCKSIZE);\n+\n+    // Write all but the last block\n+    while (written + AES_BLOCKSIZE <= size) {\n+        for (int i = 0; i != AES_BLOCKSIZE; i++)\n+            mixed[i] ^= *data++;\n+        enc.Encrypt(out + written, mixed);\n+        memcpy(mixed, out + written, AES_BLOCKSIZE);\n+        written += AES_BLOCKSIZE;\n+    }\n+    if (pad) {\n+        // For all that remains, pad each byte with the value of the remaining\n+        // space. If there is none, pad by a full block.\n+        for (int i = 0; i != padsize; i++)\n+            mixed[i] ^= *data++;\n+        for (int i = padsize; i != AES_BLOCKSIZE; i++)\n+            mixed[i] ^= AES_BLOCKSIZE - padsize;\n+        enc.Encrypt(out + written, mixed);\n+        written += AES_BLOCKSIZE;\n+    }\n+    return written;\n+}\n+\n+template <typename T>\n+static int CBCDecrypt(const T& dec, const unsigned char iv[AES_BLOCKSIZE], const unsigned char* data, int size, bool pad, unsigned char* out)\n+{\n+    unsigned char padsize = 0;\n+    int written = 0;\n+    bool fail = false;\n+    const unsigned char* prev = iv;\n+\n+    if (!data || !size || !out)\n+        return 0;\n+\n+    if (size % AES_BLOCKSIZE != 0)\n+        return 0;\n+\n+    // Decrypt all data. Padding will be checked in the output.\n+    while (written != size) {\n+        dec.Decrypt(out, data + written);\n+        for (int i = 0; i != AES_BLOCKSIZE; i++)\n+            *out++ ^= prev[i];\n+        prev = data + written;\n+        written += AES_BLOCKSIZE;\n+    }\n+\n+    // When decrypting padding, attempt to run in constant-time\n+    if (pad) {\n+        // If used, padding size is the value of the last decrypted byte. For\n+        // it to be valid, It must be between 1 and AES_BLOCKSIZE.\n+        padsize = *--out;\n+        fail = !padsize | (padsize > AES_BLOCKSIZE);\n+\n+        // If not well-formed, treat it as though there's no padding.\n+        padsize *= !fail;\n+\n+        // All padding must equal the last byte otherwise it's not well-formed\n+        for (int i = AES_BLOCKSIZE; i != 0; i--)\n+            fail |= ((i > AES_BLOCKSIZE - padsize) & (*out-- != padsize));\n+\n+        written -= padsize;\n+    }\n+    return written * !fail;\n+}\n+\n+AES256CBCEncrypt::AES256CBCEncrypt(const unsigned char key[AES256_KEYSIZE], const unsigned char ivIn[AES_BLOCKSIZE], bool padIn)\n+    : enc(key), pad(padIn)\n+{\n+    memcpy(iv, ivIn, AES_BLOCKSIZE);\n+}\n+\n+int AES256CBCEncrypt::Encrypt(const unsigned char* data, int size, unsigned char* out) const\n+{\n+    return CBCEncrypt(enc, iv, data, size, pad, out);\n+}\n+\n+AES256CBCEncrypt::~AES256CBCEncrypt()\n+{\n+    memset(iv, 0, sizeof(iv));\n+}\n+\n+AES256CBCDecrypt::AES256CBCDecrypt(const unsigned char key[AES256_KEYSIZE], const unsigned char ivIn[AES_BLOCKSIZE], bool padIn)\n+    : dec(key), pad(padIn)\n+{\n+    memcpy(iv, ivIn, AES_BLOCKSIZE);\n+}\n+\n+\n+int AES256CBCDecrypt::Decrypt(const unsigned char* data, int size, unsigned char* out) const\n+{\n+    return CBCDecrypt(dec, iv, data, size, pad, out);\n+}\n+\n+AES256CBCDecrypt::~AES256CBCDecrypt()\n+{\n+    memset(iv, 0, sizeof(iv));\n+}\n+\n+AES128CBCEncrypt::AES128CBCEncrypt(const unsigned char key[AES128_KEYSIZE], const unsigned char ivIn[AES_BLOCKSIZE], bool padIn)\n+    : enc(key), pad(padIn)\n+{\n+    memcpy(iv, ivIn, AES_BLOCKSIZE);\n+}\n+\n+AES128CBCEncrypt::~AES128CBCEncrypt()\n+{\n+    memset(iv, 0, AES_BLOCKSIZE);\n+}\n+\n+int AES128CBCEncrypt::Encrypt(const unsigned char* data, int size, unsigned char* out) const\n+{\n+    return CBCEncrypt(enc, iv, data, size, pad, out);\n+}\n+\n+AES128CBCDecrypt::AES128CBCDecrypt(const unsigned char key[AES128_KEYSIZE], const unsigned char ivIn[AES_BLOCKSIZE], bool padIn)\n+    : dec(key), pad(padIn)\n+{\n+    memcpy(iv, ivIn, AES_BLOCKSIZE);\n+}\n+\n+AES128CBCDecrypt::~AES128CBCDecrypt()\n+{\n+    memset(iv, 0, AES_BLOCKSIZE);\n+}\n+\n+int AES128CBCDecrypt::Decrypt(const unsigned char* data, int size, unsigned char* out) const\n+{\n+    return CBCDecrypt(dec, iv, data, size, pad, out);\n+}"
      },
      {
        "sha": "8cae357c1287e6af0b21e891a3e7f7d685364547",
        "filename": "src/crypto/aes.h",
        "status": "modified",
        "additions": 52,
        "deletions": 0,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27a212dcb4fe842ead77d01b98f2c1a58ecca609/src/crypto/aes.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27a212dcb4fe842ead77d01b98f2c1a58ecca609/src/crypto/aes.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/aes.h?ref=27a212dcb4fe842ead77d01b98f2c1a58ecca609",
        "patch": "@@ -63,4 +63,56 @@ class AES256Decrypt\n     void Decrypt(unsigned char plaintext[16], const unsigned char ciphertext[16]) const;\n };\n \n+class AES256CBCEncrypt\n+{\n+public:\n+    AES256CBCEncrypt(const unsigned char key[AES256_KEYSIZE], const unsigned char ivIn[AES_BLOCKSIZE], bool padIn);\n+    ~AES256CBCEncrypt();\n+    int Encrypt(const unsigned char* data, int size, unsigned char* out) const;\n+\n+private:\n+    const AES256Encrypt enc;\n+    const bool pad;\n+    unsigned char iv[AES_BLOCKSIZE];\n+};\n+\n+class AES256CBCDecrypt\n+{\n+public:\n+    AES256CBCDecrypt(const unsigned char key[AES256_KEYSIZE], const unsigned char ivIn[AES_BLOCKSIZE], bool padIn);\n+    ~AES256CBCDecrypt();\n+    int Decrypt(const unsigned char* data, int size, unsigned char* out) const;\n+\n+private:\n+    const AES256Decrypt dec;\n+    const bool pad;\n+    unsigned char iv[AES_BLOCKSIZE];\n+};\n+\n+class AES128CBCEncrypt\n+{\n+public:\n+    AES128CBCEncrypt(const unsigned char key[AES128_KEYSIZE], const unsigned char ivIn[AES_BLOCKSIZE], bool padIn);\n+    ~AES128CBCEncrypt();\n+    int Encrypt(const unsigned char* data, int size, unsigned char* out) const;\n+\n+private:\n+    const AES128Encrypt enc;\n+    const bool pad;\n+    unsigned char iv[AES_BLOCKSIZE];\n+};\n+\n+class AES128CBCDecrypt\n+{\n+public:\n+    AES128CBCDecrypt(const unsigned char key[AES128_KEYSIZE], const unsigned char ivIn[AES_BLOCKSIZE], bool padIn);\n+    ~AES128CBCDecrypt();\n+    int Decrypt(const unsigned char* data, int size, unsigned char* out) const;\n+\n+private:\n+    const AES128Decrypt dec;\n+    const bool pad;\n+    unsigned char iv[AES_BLOCKSIZE];\n+};\n+\n #endif // BITCOIN_CRYPTO_AES_H"
      }
    ]
  },
  {
    "sha": "daa384120a63542257d4ca73047d775f16fac654",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkYWEzODQxMjBhNjM1NDIyNTdkNGNhNzMwNDdkNzc1ZjE2ZmFjNjU0",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2015-03-20T04:52:58Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-05-13T08:23:03Z"
      },
      "message": "crypto: add aes cbc tests",
      "tree": {
        "sha": "6e540b13644134832d894e7d983fd793ebd92ffd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6e540b13644134832d894e7d983fd793ebd92ffd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/daa384120a63542257d4ca73047d775f16fac654",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/daa384120a63542257d4ca73047d775f16fac654",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/daa384120a63542257d4ca73047d775f16fac654",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/daa384120a63542257d4ca73047d775f16fac654/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "27a212dcb4fe842ead77d01b98f2c1a58ecca609",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/27a212dcb4fe842ead77d01b98f2c1a58ecca609",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/27a212dcb4fe842ead77d01b98f2c1a58ecca609"
      }
    ],
    "stats": {
      "total": 135,
      "additions": 135,
      "deletions": 0
    },
    "files": [
      {
        "sha": "58a62ee02262d489e801cf10cd3da90bf60fd1c3",
        "filename": "src/test/crypto_tests.cpp",
        "status": "modified",
        "additions": 135,
        "deletions": 0,
        "changes": 135,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/daa384120a63542257d4ca73047d775f16fac654/src/test/crypto_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/daa384120a63542257d4ca73047d775f16fac654/src/test/crypto_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/crypto_tests.cpp?ref=daa384120a63542257d4ca73047d775f16fac654",
        "patch": "@@ -17,6 +17,8 @@\n \n #include <boost/assign/list_of.hpp>\n #include <boost/test/unit_test.hpp>\n+#include <openssl/aes.h>\n+#include <openssl/evp.h>\n \n BOOST_FIXTURE_TEST_SUITE(crypto_tests, BasicTestingSetup)\n \n@@ -103,6 +105,88 @@ void TestAES256(const std::string &hexkey, const std::string &hexin, const std::\n     BOOST_CHECK(buf == in);\n }\n \n+void TestAES128CBC(const std::string &hexkey, const std::string &hexiv, bool pad, const std::string &hexin, const std::string &hexout)\n+{\n+    std::vector<unsigned char> key = ParseHex(hexkey);\n+    std::vector<unsigned char> iv = ParseHex(hexiv);\n+    std::vector<unsigned char> in = ParseHex(hexin);\n+    std::vector<unsigned char> correctout = ParseHex(hexout);\n+    std::vector<unsigned char> realout(in.size() + AES_BLOCKSIZE);\n+\n+    // Encrypt the plaintext and verify that it equals the cipher\n+    AES128CBCEncrypt enc(&key[0], &iv[0], pad);\n+    int size = enc.Encrypt(&in[0], in.size(), &realout[0]);\n+    realout.resize(size);\n+    BOOST_CHECK(realout.size() == correctout.size());\n+    BOOST_CHECK_MESSAGE(realout == correctout, HexStr(realout) + std::string(\" != \") + hexout);\n+\n+    // Decrypt the cipher and verify that it equals the plaintext\n+    std::vector<unsigned char> decrypted(correctout.size());\n+    AES128CBCDecrypt dec(&key[0], &iv[0], pad);\n+    size = dec.Decrypt(&correctout[0], correctout.size(), &decrypted[0]);\n+    decrypted.resize(size);\n+    BOOST_CHECK(decrypted.size() == in.size());\n+    BOOST_CHECK_MESSAGE(decrypted == in, HexStr(decrypted) + std::string(\" != \") + hexin);\n+\n+    // Encrypt and re-decrypt substrings of the plaintext and verify that they equal each-other\n+    for(std::vector<unsigned char>::iterator i(in.begin()); i != in.end(); ++i)\n+    {\n+        std::vector<unsigned char> sub(i, in.end());\n+        std::vector<unsigned char> subout(sub.size() + AES_BLOCKSIZE);\n+        int size = enc.Encrypt(&sub[0], sub.size(), &subout[0]);\n+        if (size != 0)\n+        {\n+            subout.resize(size);\n+            std::vector<unsigned char> subdecrypted(subout.size());\n+            size = dec.Decrypt(&subout[0], subout.size(), &subdecrypted[0]);\n+            subdecrypted.resize(size);\n+            BOOST_CHECK(decrypted.size() == in.size());\n+            BOOST_CHECK_MESSAGE(subdecrypted == sub, HexStr(subdecrypted) + std::string(\" != \") + HexStr(sub));\n+        }\n+    }\n+}\n+\n+void TestAES256CBC(const std::string &hexkey, const std::string &hexiv, bool pad, const std::string &hexin, const std::string &hexout)\n+{\n+    std::vector<unsigned char> key = ParseHex(hexkey);\n+    std::vector<unsigned char> iv = ParseHex(hexiv);\n+    std::vector<unsigned char> in = ParseHex(hexin);\n+    std::vector<unsigned char> correctout = ParseHex(hexout);\n+    std::vector<unsigned char> realout(in.size() + AES_BLOCKSIZE);\n+\n+    // Encrypt the plaintext and verify that it equals the cipher\n+    AES256CBCEncrypt enc(&key[0], &iv[0], pad);\n+    int size = enc.Encrypt(&in[0], in.size(), &realout[0]);\n+    realout.resize(size);\n+    BOOST_CHECK(realout.size() == correctout.size());\n+    BOOST_CHECK_MESSAGE(realout == correctout, HexStr(realout) + std::string(\" != \") + hexout);\n+\n+    // Decrypt the cipher and verify that it equals the plaintext\n+    std::vector<unsigned char> decrypted(correctout.size());\n+    AES256CBCDecrypt dec(&key[0], &iv[0], pad);\n+    size = dec.Decrypt(&correctout[0], correctout.size(), &decrypted[0]);\n+    decrypted.resize(size);\n+    BOOST_CHECK(decrypted.size() == in.size());\n+    BOOST_CHECK_MESSAGE(decrypted == in, HexStr(decrypted) + std::string(\" != \") + hexin);\n+\n+    // Encrypt and re-decrypt substrings of the plaintext and verify that they equal each-other\n+    for(std::vector<unsigned char>::iterator i(in.begin()); i != in.end(); ++i)\n+    {\n+        std::vector<unsigned char> sub(i, in.end());\n+        std::vector<unsigned char> subout(sub.size() + AES_BLOCKSIZE);\n+        int size = enc.Encrypt(&sub[0], sub.size(), &subout[0]);\n+        if (size != 0)\n+        {\n+            subout.resize(size);\n+            std::vector<unsigned char> subdecrypted(subout.size());\n+            size = dec.Decrypt(&subout[0], subout.size(), &subdecrypted[0]);\n+            subdecrypted.resize(size);\n+            BOOST_CHECK(decrypted.size() == in.size());\n+            BOOST_CHECK_MESSAGE(subdecrypted == sub, HexStr(subdecrypted) + std::string(\" != \") + HexStr(sub));\n+        }\n+    }\n+}\n+\n std::string LongTestString(void) {\n     std::string ret;\n     for (int i=0; i<200000; i++) {\n@@ -304,4 +388,55 @@ BOOST_AUTO_TEST_CASE(aes_testvectors) {\n     TestAES256(\"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\", \"f69f2445df4f9b17ad2b417be66c3710\", \"23304b7a39f9f3ff067d8d8f9e24ecc7\");\n }\n \n+BOOST_AUTO_TEST_CASE(aes_cbc_testvectors) {\n+\n+    // NIST AES CBC 128-bit encryption test-vectors\n+    TestAES128CBC(\"2b7e151628aed2a6abf7158809cf4f3c\", \"000102030405060708090A0B0C0D0E0F\", false, \\\n+                  \"6bc1bee22e409f96e93d7e117393172a\", \"7649abac8119b246cee98e9b12e9197d\");\n+    TestAES128CBC(\"2b7e151628aed2a6abf7158809cf4f3c\", \"7649ABAC8119B246CEE98E9B12E9197D\", false, \\\n+                  \"ae2d8a571e03ac9c9eb76fac45af8e51\", \"5086cb9b507219ee95db113a917678b2\");\n+    TestAES128CBC(\"2b7e151628aed2a6abf7158809cf4f3c\", \"5086cb9b507219ee95db113a917678b2\", false, \\\n+                  \"30c81c46a35ce411e5fbc1191a0a52ef\", \"73bed6b8e3c1743b7116e69e22229516\");\n+    TestAES128CBC(\"2b7e151628aed2a6abf7158809cf4f3c\", \"73bed6b8e3c1743b7116e69e22229516\", false, \\\n+                  \"f69f2445df4f9b17ad2b417be66c3710\", \"3ff1caa1681fac09120eca307586e1a7\");\n+\n+    // The same vectors with padding enabled\n+    TestAES128CBC(\"2b7e151628aed2a6abf7158809cf4f3c\", \"000102030405060708090A0B0C0D0E0F\", true, \\\n+                  \"6bc1bee22e409f96e93d7e117393172a\", \"7649abac8119b246cee98e9b12e9197d8964e0b149c10b7b682e6e39aaeb731c\");\n+    TestAES128CBC(\"2b7e151628aed2a6abf7158809cf4f3c\", \"7649ABAC8119B246CEE98E9B12E9197D\", true, \\\n+                  \"ae2d8a571e03ac9c9eb76fac45af8e51\", \"5086cb9b507219ee95db113a917678b255e21d7100b988ffec32feeafaf23538\");\n+    TestAES128CBC(\"2b7e151628aed2a6abf7158809cf4f3c\", \"5086cb9b507219ee95db113a917678b2\", true, \\\n+                  \"30c81c46a35ce411e5fbc1191a0a52ef\", \"73bed6b8e3c1743b7116e69e22229516f6eccda327bf8e5ec43718b0039adceb\");\n+    TestAES128CBC(\"2b7e151628aed2a6abf7158809cf4f3c\", \"73bed6b8e3c1743b7116e69e22229516\", true, \\\n+                  \"f69f2445df4f9b17ad2b417be66c3710\", \"3ff1caa1681fac09120eca307586e1a78cb82807230e1321d3fae00d18cc2012\");\n+\n+    // NIST AES CBC 256-bit encryption test-vectors\n+    TestAES256CBC(\"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\", \\\n+                  \"000102030405060708090A0B0C0D0E0F\", false, \"6bc1bee22e409f96e93d7e117393172a\", \\\n+                  \"f58c4c04d6e5f1ba779eabfb5f7bfbd6\");\n+    TestAES256CBC(\"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\", \\\n+                  \"F58C4C04D6E5F1BA779EABFB5F7BFBD6\", false, \"ae2d8a571e03ac9c9eb76fac45af8e51\", \\\n+                  \"9cfc4e967edb808d679f777bc6702c7d\");\n+    TestAES256CBC(\"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\", \\\n+                  \"9CFC4E967EDB808D679F777BC6702C7D\", false, \"30c81c46a35ce411e5fbc1191a0a52ef\",\n+                  \"39f23369a9d9bacfa530e26304231461\");\n+    TestAES256CBC(\"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\", \\\n+                  \"39F23369A9D9BACFA530E26304231461\", false, \"f69f2445df4f9b17ad2b417be66c3710\", \\\n+                  \"b2eb05e2c39be9fcda6c19078c6a9d1b\");\n+\n+    // The same vectors with padding enabled\n+    TestAES256CBC(\"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\", \\\n+                  \"000102030405060708090A0B0C0D0E0F\", true, \"6bc1bee22e409f96e93d7e117393172a\", \\\n+                  \"f58c4c04d6e5f1ba779eabfb5f7bfbd6485a5c81519cf378fa36d42b8547edc0\");\n+    TestAES256CBC(\"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\", \\\n+                  \"F58C4C04D6E5F1BA779EABFB5F7BFBD6\", true, \"ae2d8a571e03ac9c9eb76fac45af8e51\", \\\n+                  \"9cfc4e967edb808d679f777bc6702c7d3a3aa5e0213db1a9901f9036cf5102d2\");\n+    TestAES256CBC(\"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\", \\\n+                  \"9CFC4E967EDB808D679F777BC6702C7D\", true, \"30c81c46a35ce411e5fbc1191a0a52ef\",\n+                  \"39f23369a9d9bacfa530e263042314612f8da707643c90a6f732b3de1d3f5cee\");\n+    TestAES256CBC(\"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4\", \\\n+                  \"39F23369A9D9BACFA530E26304231461\", true, \"f69f2445df4f9b17ad2b417be66c3710\", \\\n+                  \"b2eb05e2c39be9fcda6c19078c6a9d1b3f461796d6b0d6b2e0c2a72b4d80e644\");\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "1c391a5866e1342617b51041afebee2215e9a30c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxYzM5MWE1ODY2ZTEzNDI2MTdiNTEwNDFhZmViZWUyMjE1ZTlhMzBj",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2015-03-20T05:05:47Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-05-13T08:23:03Z"
      },
      "message": "crypter: fix the stored initialization vector size\n\nAES IV's are 16bytes, not 32. This was harmless but confusing.\n\nAdd WALLET_CRYPTO_IV_SIZE to make its usage explicit.",
      "tree": {
        "sha": "6edb45995b9cbd64d8b275ba200243d7d8ae91c0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6edb45995b9cbd64d8b275ba200243d7d8ae91c0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1c391a5866e1342617b51041afebee2215e9a30c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1c391a5866e1342617b51041afebee2215e9a30c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1c391a5866e1342617b51041afebee2215e9a30c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1c391a5866e1342617b51041afebee2215e9a30c/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "daa384120a63542257d4ca73047d775f16fac654",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/daa384120a63542257d4ca73047d775f16fac654",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/daa384120a63542257d4ca73047d775f16fac654"
      }
    ],
    "stats": {
      "total": 13,
      "additions": 7,
      "deletions": 6
    },
    "files": [
      {
        "sha": "8f555579fa3b5d94864ccf0408a64a8b8bfcd62a",
        "filename": "src/wallet/crypter.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1c391a5866e1342617b51041afebee2215e9a30c/src/wallet/crypter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1c391a5866e1342617b51041afebee2215e9a30c/src/wallet/crypter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/crypter.cpp?ref=1c391a5866e1342617b51041afebee2215e9a30c",
        "patch": "@@ -37,7 +37,7 @@ bool CCrypter::SetKeyFromPassphrase(const SecureString& strKeyData, const std::v\n \n bool CCrypter::SetKey(const CKeyingMaterial& chNewKey, const std::vector<unsigned char>& chNewIV)\n {\n-    if (chNewKey.size() != WALLET_CRYPTO_KEY_SIZE || chNewIV.size() != WALLET_CRYPTO_KEY_SIZE)\n+    if (chNewKey.size() != WALLET_CRYPTO_KEY_SIZE || chNewIV.size() != WALLET_CRYPTO_IV_SIZE)\n         return false;\n \n     memcpy(&chKey[0], &chNewKey[0], sizeof chKey);\n@@ -105,8 +105,8 @@ bool CCrypter::Decrypt(const std::vector<unsigned char>& vchCiphertext, CKeyingM\n static bool EncryptSecret(const CKeyingMaterial& vMasterKey, const CKeyingMaterial &vchPlaintext, const uint256& nIV, std::vector<unsigned char> &vchCiphertext)\n {\n     CCrypter cKeyCrypter;\n-    std::vector<unsigned char> chIV(WALLET_CRYPTO_KEY_SIZE);\n-    memcpy(&chIV[0], &nIV, WALLET_CRYPTO_KEY_SIZE);\n+    std::vector<unsigned char> chIV(WALLET_CRYPTO_IV_SIZE);\n+    memcpy(&chIV[0], &nIV, WALLET_CRYPTO_IV_SIZE);\n     if(!cKeyCrypter.SetKey(vMasterKey, chIV))\n         return false;\n     return cKeyCrypter.Encrypt(*((const CKeyingMaterial*)&vchPlaintext), vchCiphertext);\n@@ -115,8 +115,8 @@ static bool EncryptSecret(const CKeyingMaterial& vMasterKey, const CKeyingMateri\n static bool DecryptSecret(const CKeyingMaterial& vMasterKey, const std::vector<unsigned char>& vchCiphertext, const uint256& nIV, CKeyingMaterial& vchPlaintext)\n {\n     CCrypter cKeyCrypter;\n-    std::vector<unsigned char> chIV(WALLET_CRYPTO_KEY_SIZE);\n-    memcpy(&chIV[0], &nIV, WALLET_CRYPTO_KEY_SIZE);\n+    std::vector<unsigned char> chIV(WALLET_CRYPTO_IV_SIZE);\n+    memcpy(&chIV[0], &nIV, WALLET_CRYPTO_IV_SIZE);\n     if(!cKeyCrypter.SetKey(vMasterKey, chIV))\n         return false;\n     return cKeyCrypter.Decrypt(vchCiphertext, *((CKeyingMaterial*)&vchPlaintext));"
      },
      {
        "sha": "b4727ac8ac0903ab6b18946a718fe074b0cbd5c1",
        "filename": "src/wallet/crypter.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1c391a5866e1342617b51041afebee2215e9a30c/src/wallet/crypter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1c391a5866e1342617b51041afebee2215e9a30c/src/wallet/crypter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/crypter.h?ref=1c391a5866e1342617b51041afebee2215e9a30c",
        "patch": "@@ -13,6 +13,7 @@ class uint256;\n \n const unsigned int WALLET_CRYPTO_KEY_SIZE = 32;\n const unsigned int WALLET_CRYPTO_SALT_SIZE = 8;\n+const unsigned int WALLET_CRYPTO_IV_SIZE = 16;\n \n /**\n  * Private key encryption is done based on a CMasterKey,\n@@ -71,7 +72,7 @@ class CCrypter\n {\n private:\n     unsigned char chKey[WALLET_CRYPTO_KEY_SIZE];\n-    unsigned char chIV[WALLET_CRYPTO_KEY_SIZE];\n+    unsigned char chIV[WALLET_CRYPTO_IV_SIZE];\n     bool fKeySet;\n \n public:"
      }
    ]
  },
  {
    "sha": "fb96831c1ff767cd86099f66127fa4dc1ec6e277",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYjk2ODMxYzFmZjc2N2NkODYwOTlmNjYxMjdmYTRkYzFlYzZlMjc3",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2015-03-26T21:37:29Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-05-13T08:23:04Z"
      },
      "message": "crypter: constify encrypt/decrypt\n\nThis makes CCrypter easier to pass aroundf for tests",
      "tree": {
        "sha": "ccd4d39752e118650a065401440e98bd09bf9a62",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ccd4d39752e118650a065401440e98bd09bf9a62"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fb96831c1ff767cd86099f66127fa4dc1ec6e277",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fb96831c1ff767cd86099f66127fa4dc1ec6e277",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fb96831c1ff767cd86099f66127fa4dc1ec6e277",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fb96831c1ff767cd86099f66127fa4dc1ec6e277/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1c391a5866e1342617b51041afebee2215e9a30c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1c391a5866e1342617b51041afebee2215e9a30c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1c391a5866e1342617b51041afebee2215e9a30c"
      }
    ],
    "stats": {
      "total": 8,
      "additions": 4,
      "deletions": 4
    },
    "files": [
      {
        "sha": "e37a9c4c85d4e70a0d81ad0a579e063d9b7ecd48",
        "filename": "src/wallet/crypter.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fb96831c1ff767cd86099f66127fa4dc1ec6e277/src/wallet/crypter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fb96831c1ff767cd86099f66127fa4dc1ec6e277/src/wallet/crypter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/crypter.cpp?ref=fb96831c1ff767cd86099f66127fa4dc1ec6e277",
        "patch": "@@ -47,7 +47,7 @@ bool CCrypter::SetKey(const CKeyingMaterial& chNewKey, const std::vector<unsigne\n     return true;\n }\n \n-bool CCrypter::Encrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned char> &vchCiphertext)\n+bool CCrypter::Encrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned char> &vchCiphertext) const\n {\n     if (!fKeySet)\n         return false;\n@@ -74,7 +74,7 @@ bool CCrypter::Encrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned\n     return true;\n }\n \n-bool CCrypter::Decrypt(const std::vector<unsigned char>& vchCiphertext, CKeyingMaterial& vchPlaintext)\n+bool CCrypter::Decrypt(const std::vector<unsigned char>& vchCiphertext, CKeyingMaterial& vchPlaintext) const\n {\n     if (!fKeySet)\n         return false;"
      },
      {
        "sha": "3457d40ffd029bf4d931f4e404d0397a73c11857",
        "filename": "src/wallet/crypter.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fb96831c1ff767cd86099f66127fa4dc1ec6e277/src/wallet/crypter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fb96831c1ff767cd86099f66127fa4dc1ec6e277/src/wallet/crypter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/crypter.h?ref=fb96831c1ff767cd86099f66127fa4dc1ec6e277",
        "patch": "@@ -77,8 +77,8 @@ class CCrypter\n \n public:\n     bool SetKeyFromPassphrase(const SecureString &strKeyData, const std::vector<unsigned char>& chSalt, const unsigned int nRounds, const unsigned int nDerivationMethod);\n-    bool Encrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned char> &vchCiphertext);\n-    bool Decrypt(const std::vector<unsigned char>& vchCiphertext, CKeyingMaterial& vchPlaintext);\n+    bool Encrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned char> &vchCiphertext) const;\n+    bool Decrypt(const std::vector<unsigned char>& vchCiphertext, CKeyingMaterial& vchPlaintext) const;\n     bool SetKey(const CKeyingMaterial& chNewKey, const std::vector<unsigned char>& chNewIV);\n \n     void CleanKey()"
      }
    ]
  },
  {
    "sha": "9049cde4d962862f507f9ddf1c0dbd49ea04be51",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MDQ5Y2RlNGQ5NjI4NjJmNTA3ZjlkZGYxYzBkYmQ0OWVhMDRiZTUx",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2015-03-20T05:10:30Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-05-13T08:23:04Z"
      },
      "message": "crypter: hook up the new aes cbc classes",
      "tree": {
        "sha": "20b57c1f88f8d374b4277bc2852036c61f9ccc4e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/20b57c1f88f8d374b4277bc2852036c61f9ccc4e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9049cde4d962862f507f9ddf1c0dbd49ea04be51",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9049cde4d962862f507f9ddf1c0dbd49ea04be51",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9049cde4d962862f507f9ddf1c0dbd49ea04be51",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9049cde4d962862f507f9ddf1c0dbd49ea04be51/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fb96831c1ff767cd86099f66127fa4dc1ec6e277",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fb96831c1ff767cd86099f66127fa4dc1ec6e277",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fb96831c1ff767cd86099f66127fa4dc1ec6e277"
      }
    ],
    "stats": {
      "total": 45,
      "additions": 14,
      "deletions": 31
    },
    "files": [
      {
        "sha": "0a19139a3172afc5ff2316375f4347f725f7506c",
        "filename": "src/wallet/crypter.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 31,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9049cde4d962862f507f9ddf1c0dbd49ea04be51/src/wallet/crypter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9049cde4d962862f507f9ddf1c0dbd49ea04be51/src/wallet/crypter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/crypter.cpp?ref=9049cde4d962862f507f9ddf1c0dbd49ea04be51",
        "patch": "@@ -4,6 +4,7 @@\n \n #include \"crypter.h\"\n \n+#include \"crypto/aes.h\"\n #include \"script/script.h\"\n #include \"script/standard.h\"\n #include \"util.h\"\n@@ -53,24 +54,15 @@ bool CCrypter::Encrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned\n         return false;\n \n     // max ciphertext len for a n bytes of plaintext is\n-    // n + AES_BLOCK_SIZE - 1 bytes\n-    int nLen = vchPlaintext.size();\n-    int nCLen = nLen + AES_BLOCK_SIZE, nFLen = 0;\n-    vchCiphertext = std::vector<unsigned char> (nCLen);\n+    // n + AES_BLOCKSIZE bytes\n+    vchCiphertext.resize(vchPlaintext.size() + AES_BLOCKSIZE);\n \n-    EVP_CIPHER_CTX ctx;\n-\n-    bool fOk = true;\n-\n-    EVP_CIPHER_CTX_init(&ctx);\n-    if (fOk) fOk = EVP_EncryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV) != 0;\n-    if (fOk) fOk = EVP_EncryptUpdate(&ctx, &vchCiphertext[0], &nCLen, &vchPlaintext[0], nLen) != 0;\n-    if (fOk) fOk = EVP_EncryptFinal_ex(&ctx, (&vchCiphertext[0]) + nCLen, &nFLen) != 0;\n-    EVP_CIPHER_CTX_cleanup(&ctx);\n-\n-    if (!fOk) return false;\n+    AES256CBCEncrypt enc(chKey, chIV, true);\n+    size_t nLen = enc.Encrypt(&vchPlaintext[0], vchPlaintext.size(), &vchCiphertext[0]);\n+    if(nLen < vchPlaintext.size())\n+        return false;\n+    vchCiphertext.resize(nLen);\n \n-    vchCiphertext.resize(nCLen + nFLen);\n     return true;\n }\n \n@@ -81,23 +73,14 @@ bool CCrypter::Decrypt(const std::vector<unsigned char>& vchCiphertext, CKeyingM\n \n     // plaintext will always be equal to or lesser than length of ciphertext\n     int nLen = vchCiphertext.size();\n-    int nPLen = nLen, nFLen = 0;\n-\n-    vchPlaintext = CKeyingMaterial(nPLen);\n \n-    EVP_CIPHER_CTX ctx;\n+    vchPlaintext.resize(nLen);\n \n-    bool fOk = true;\n-\n-    EVP_CIPHER_CTX_init(&ctx);\n-    if (fOk) fOk = EVP_DecryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV) != 0;\n-    if (fOk) fOk = EVP_DecryptUpdate(&ctx, &vchPlaintext[0], &nPLen, &vchCiphertext[0], nLen) != 0;\n-    if (fOk) fOk = EVP_DecryptFinal_ex(&ctx, (&vchPlaintext[0]) + nPLen, &nFLen) != 0;\n-    EVP_CIPHER_CTX_cleanup(&ctx);\n-\n-    if (!fOk) return false;\n-\n-    vchPlaintext.resize(nPLen + nFLen);\n+    AES256CBCDecrypt dec(chKey, chIV, true);\n+    nLen = dec.Decrypt(&vchCiphertext[0], vchCiphertext.size(), &vchPlaintext[0]);\n+    if(nLen == 0)\n+        return false;\n+    vchPlaintext.resize(nLen);\n     return true;\n }\n "
      }
    ]
  },
  {
    "sha": "976f9ec2645242032d34ab68a60d963f2ac586d8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NzZmOWVjMjY0NTI0MjAzMmQzNGFiNjhhNjBkOTYzZjJhYzU4NmQ4",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2015-03-20T05:24:12Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-05-13T08:23:04Z"
      },
      "message": "crypter: add a BytesToKey clone to replace the use of openssl\n\nBytesToKeySHA512AES should be functionally identical to EVP_BytesToKey, but\ndrops the dependency on openssl.",
      "tree": {
        "sha": "b5c5f3607fe10057dbc6a1385b5a08e7b6d9cbb2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b5c5f3607fe10057dbc6a1385b5a08e7b6d9cbb2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/976f9ec2645242032d34ab68a60d963f2ac586d8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/976f9ec2645242032d34ab68a60d963f2ac586d8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/976f9ec2645242032d34ab68a60d963f2ac586d8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/976f9ec2645242032d34ab68a60d963f2ac586d8/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9049cde4d962862f507f9ddf1c0dbd49ea04be51",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9049cde4d962862f507f9ddf1c0dbd49ea04be51",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9049cde4d962862f507f9ddf1c0dbd49ea04be51"
      }
    ],
    "stats": {
      "total": 35,
      "additions": 31,
      "deletions": 4
    },
    "files": [
      {
        "sha": "190f8ecf2ab49a4d1e0f53b4a8b96b7c4d983afb",
        "filename": "src/wallet/crypter.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 4,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/976f9ec2645242032d34ab68a60d963f2ac586d8/src/wallet/crypter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/976f9ec2645242032d34ab68a60d963f2ac586d8/src/wallet/crypter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/crypter.cpp?ref=976f9ec2645242032d34ab68a60d963f2ac586d8",
        "patch": "@@ -5,15 +5,41 @@\n #include \"crypter.h\"\n \n #include \"crypto/aes.h\"\n+#include \"crypto/sha512.h\"\n #include \"script/script.h\"\n #include \"script/standard.h\"\n #include \"util.h\"\n \n #include <string>\n #include <vector>\n #include <boost/foreach.hpp>\n-#include <openssl/aes.h>\n-#include <openssl/evp.h>\n+\n+int CCrypter::BytesToKeySHA512AES(const std::vector<unsigned char>& chSalt, const SecureString& strKeyData, int count, unsigned char *key,unsigned char *iv) const\n+{\n+    // This mimics the behavior of openssl's EVP_BytesToKey with an aes256cbc\n+    // cipher and sha512 message digest. Because sha512's output size (64b) is\n+    // greater than the aes256 block size (16b) + aes256 key size (32b),\n+    // there's no need to process more than once (D_0).\n+\n+    if(!count || !key || !iv)\n+        return 0;\n+\n+    unsigned char buf[CSHA512::OUTPUT_SIZE];\n+    CSHA512 di;\n+\n+    di.Write((const unsigned char*)strKeyData.c_str(), strKeyData.size());\n+    if(chSalt.size())\n+        di.Write(&chSalt[0], chSalt.size());\n+    di.Finalize(buf);\n+\n+    for(int i = 0; i != count - 1; i++)\n+        di.Reset().Write(buf, sizeof(buf)).Finalize(buf);\n+\n+    memcpy(key, buf, WALLET_CRYPTO_KEY_SIZE);\n+    memcpy(iv, buf + WALLET_CRYPTO_KEY_SIZE, WALLET_CRYPTO_IV_SIZE);\n+    memory_cleanse(buf, sizeof(buf));\n+    return WALLET_CRYPTO_KEY_SIZE;\n+}\n \n bool CCrypter::SetKeyFromPassphrase(const SecureString& strKeyData, const std::vector<unsigned char>& chSalt, const unsigned int nRounds, const unsigned int nDerivationMethod)\n {\n@@ -22,8 +48,7 @@ bool CCrypter::SetKeyFromPassphrase(const SecureString& strKeyData, const std::v\n \n     int i = 0;\n     if (nDerivationMethod == 0)\n-        i = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha512(), &chSalt[0],\n-                          (unsigned char *)&strKeyData[0], strKeyData.size(), nRounds, chKey, chIV);\n+        i = BytesToKeySHA512AES(chSalt, strKeyData, nRounds, chKey, chIV);\n \n     if (i != (int)WALLET_CRYPTO_KEY_SIZE)\n     {"
      },
      {
        "sha": "16f2ba622069c3c4b0a5080ba489c77f35bc3b50",
        "filename": "src/wallet/crypter.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/976f9ec2645242032d34ab68a60d963f2ac586d8/src/wallet/crypter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/976f9ec2645242032d34ab68a60d963f2ac586d8/src/wallet/crypter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/crypter.h?ref=976f9ec2645242032d34ab68a60d963f2ac586d8",
        "patch": "@@ -75,6 +75,8 @@ class CCrypter\n     unsigned char chIV[WALLET_CRYPTO_IV_SIZE];\n     bool fKeySet;\n \n+    int BytesToKeySHA512AES(const std::vector<unsigned char>& chSalt, const SecureString& strKeyData, int count, unsigned char *key,unsigned char *iv) const;\n+\n public:\n     bool SetKeyFromPassphrase(const SecureString &strKeyData, const std::vector<unsigned char>& chSalt, const unsigned int nRounds, const unsigned int nDerivationMethod);\n     bool Encrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned char> &vchCiphertext) const;"
      }
    ]
  },
  {
    "sha": "0a36b9af281e31b080ca0835eec7704097527bda",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowYTM2YjlhZjI4MWUzMWIwODBjYTA4MzVlZWM3NzA0MDk3NTI3YmRh",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2015-03-26T23:15:28Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-05-13T08:23:04Z"
      },
      "message": "crypter: shuffle Makefile so that crypto can be used by the wallet\n\nWallet must come before crypto, otherwise linking fails on some platforms.\n\nIncludes a tangentially-related general cleanup rather than making the Makefile\nsloppier.",
      "tree": {
        "sha": "b7ab5c403e0564b517f2b3552c5815ce2b2260ce",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b7ab5c403e0564b517f2b3552c5815ce2b2260ce"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0a36b9af281e31b080ca0835eec7704097527bda",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0a36b9af281e31b080ca0835eec7704097527bda",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0a36b9af281e31b080ca0835eec7704097527bda",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0a36b9af281e31b080ca0835eec7704097527bda/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "976f9ec2645242032d34ab68a60d963f2ac586d8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/976f9ec2645242032d34ab68a60d963f2ac586d8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/976f9ec2645242032d34ab68a60d963f2ac586d8"
      }
    ],
    "stats": {
      "total": 55,
      "additions": 23,
      "deletions": 32
    },
    "files": [
      {
        "sha": "31917f1350e46cc73b5599b46e1c5fecc102205e",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 23,
        "deletions": 32,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a36b9af281e31b080ca0835eec7704097527bda/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a36b9af281e31b080ca0835eec7704097527bda/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=0a36b9af281e31b080ca0835eec7704097527bda",
        "patch": "@@ -15,13 +15,12 @@ LIBUNIVALUE = $(UNIVALUE_LIBS)\n endif\n \n BITCOIN_CONFIG_INCLUDES=-I$(builddir)/config\n-BITCOIN_INCLUDES=-I$(builddir) -I$(builddir)/obj $(BOOST_CPPFLAGS) $(LEVELDB_CPPFLAGS) $(CRYPTO_CFLAGS) $(SSL_CFLAGS)\n+BITCOIN_INCLUDES=-I$(builddir) -I$(builddir)/obj $(BDB_CPPFLAGS) $(BOOST_CPPFLAGS) $(LEVELDB_CPPFLAGS) $(CRYPTO_CFLAGS) $(SSL_CFLAGS)\n \n BITCOIN_INCLUDES += -I$(srcdir)/secp256k1/include\n BITCOIN_INCLUDES += $(UNIVALUE_CFLAGS)\n \n LIBBITCOIN_SERVER=libbitcoin_server.a\n-LIBBITCOIN_WALLET=libbitcoin_wallet.a\n LIBBITCOIN_COMMON=libbitcoin_common.a\n LIBBITCOIN_CONSENSUS=libbitcoin_consensus.a\n LIBBITCOIN_CLI=libbitcoin_cli.a\n@@ -30,32 +29,32 @@ LIBBITCOIN_CRYPTO=crypto/libbitcoin_crypto.a\n LIBBITCOINQT=qt/libbitcoinqt.a\n LIBSECP256K1=secp256k1/libsecp256k1.la\n \n+if ENABLE_ZMQ\n+LIBBITCOIN_ZMQ=libbitcoin_zmq.a\n+endif\n+if BUILD_BITCOIN_LIBS\n+LIBBITCOINCONSENSUS=libbitcoinconsensus.la\n+endif\n+if ENABLE_WALLET\n+LIBBITCOIN_WALLET=libbitcoin_wallet.a\n+endif\n+\n $(LIBSECP256K1): $(wildcard secp256k1/src/*) $(wildcard secp256k1/include/*)\n \t$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C $(@D) $(@F)\n \n # Make is not made aware of per-object dependencies to avoid limiting building parallelization\n # But to build the less dependent modules first, we manually select their order here:\n EXTRA_LIBRARIES += \\\n-  crypto/libbitcoin_crypto.a \\\n-  libbitcoin_util.a \\\n-  libbitcoin_common.a \\\n-  libbitcoin_consensus.a \\\n-  libbitcoin_server.a \\\n-  libbitcoin_cli.a\n-if ENABLE_WALLET\n-BITCOIN_INCLUDES += $(BDB_CPPFLAGS)\n-EXTRA_LIBRARIES += libbitcoin_wallet.a\n-endif\n-if ENABLE_ZMQ\n-EXTRA_LIBRARIES += libbitcoin_zmq.a\n-endif\n+  $(LIBBITCOIN_CRYPTO) \\\n+  $(LIBBITCOIN_UTIL) \\\n+  $(LIBBITCOIN_COMMON) \\\n+  $(LIBBITCOIN_CONSENSUS) \\\n+  $(LIBBITCOIN_SERVER) \\\n+  $(LIBBITCOIN_CLI) \\\n+  $(LIBBITCOIN_WALLET) \\\n+  $(LIBBITCOIN_ZMQ)\n \n-if BUILD_BITCOIN_LIBS\n-lib_LTLIBRARIES = libbitcoinconsensus.la\n-LIBBITCOINCONSENSUS=libbitcoinconsensus.la\n-else\n-LIBBITCOINCONSENSUS=\n-endif\n+lib_LTLIBRARIES = $(LIBBITCOINCONSENSUS)\n \n bin_PROGRAMS =\n TESTS =\n@@ -196,8 +195,6 @@ libbitcoin_server_a_SOURCES = \\\n   $(BITCOIN_CORE_H)\n \n if ENABLE_ZMQ\n-LIBBITCOIN_ZMQ=libbitcoin_zmq.a\n-\n libbitcoin_zmq_a_CPPFLAGS = $(BITCOIN_INCLUDES) $(ZMQ_CFLAGS)\n libbitcoin_zmq_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_zmq_a_SOURCES = \\\n@@ -347,21 +344,15 @@ bitcoind_LDADD = \\\n   $(LIBBITCOIN_COMMON) \\\n   $(LIBUNIVALUE) \\\n   $(LIBBITCOIN_UTIL) \\\n+  $(LIBBITCOIN_WALLET) \\\n+  $(LIBBITCOIN_ZMQ) \\\n   $(LIBBITCOIN_CONSENSUS) \\\n   $(LIBBITCOIN_CRYPTO) \\\n   $(LIBLEVELDB) \\\n   $(LIBMEMENV) \\\n   $(LIBSECP256K1)\n \n-if ENABLE_ZMQ\n-bitcoind_LDADD += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)\n-endif\n-\n-if ENABLE_WALLET\n-bitcoind_LDADD += libbitcoin_wallet.a\n-endif\n-\n-bitcoind_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS)\n+bitcoind_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(ZMQ_LIBS)\n \n # bitcoin-cli binary #\n bitcoin_cli_SOURCES = bitcoin-cli.cpp"
      }
    ]
  },
  {
    "sha": "34ed64a404fb6da691f67f00f47c4dd748e3e428",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNGVkNjRhNDA0ZmI2ZGE2OTFmNjdmMDBmNDdjNGRkNzQ4ZTNlNDI4",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2015-03-20T05:27:50Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-05-13T08:23:04Z"
      },
      "message": "crypter: add tests for crypter\n\nVerify that results correct (match known values), consistent (encrypt->decrypt\nmatches the original), and compatible with the previous openssl implementation.\n\nAlso check that failed encrypts/decrypts fail the exact same way as openssl.",
      "tree": {
        "sha": "30eff0657636b64b806ac9d426b5ebe1ccc8b285",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/30eff0657636b64b806ac9d426b5ebe1ccc8b285"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/34ed64a404fb6da691f67f00f47c4dd748e3e428",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/34ed64a404fb6da691f67f00f47c4dd748e3e428",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/34ed64a404fb6da691f67f00f47c4dd748e3e428",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/34ed64a404fb6da691f67f00f47c4dd748e3e428/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0a36b9af281e31b080ca0835eec7704097527bda",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0a36b9af281e31b080ca0835eec7704097527bda",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0a36b9af281e31b080ca0835eec7704097527bda"
      }
    ],
    "stats": {
      "total": 237,
      "additions": 237,
      "deletions": 0
    },
    "files": [
      {
        "sha": "d443b6d34aff1bc0197e0e43a48379eac5f20c6a",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/34ed64a404fb6da691f67f00f47c4dd748e3e428/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/34ed64a404fb6da691f67f00f47c4dd748e3e428/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=34ed64a404fb6da691f67f00f47c4dd748e3e428",
        "patch": "@@ -94,6 +94,7 @@ BITCOIN_TESTS += \\\n   wallet/test/wallet_test_fixture.h \\\n   wallet/test/accounting_tests.cpp \\\n   wallet/test/wallet_tests.cpp \\\n+  wallet/test/crypto_tests.cpp \\\n   wallet/test/rpc_wallet_tests.cpp\n endif\n "
      },
      {
        "sha": "5d0a4a3305b8c9689b93c08066be495f3f66a6c0",
        "filename": "src/wallet/crypter.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/34ed64a404fb6da691f67f00f47c4dd748e3e428/src/wallet/crypter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/34ed64a404fb6da691f67f00f47c4dd748e3e428/src/wallet/crypter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/crypter.h?ref=34ed64a404fb6da691f67f00f47c4dd748e3e428",
        "patch": "@@ -67,9 +67,15 @@ class CMasterKey\n \n typedef std::vector<unsigned char, secure_allocator<unsigned char> > CKeyingMaterial;\n \n+namespace wallet_crypto\n+{\n+    class TestCrypter;\n+}\n+\n /** Encryption/decryption context with key information */\n class CCrypter\n {\n+friend class wallet_crypto::TestCrypter; // for test access to chKey/chIV\n private:\n     unsigned char chKey[WALLET_CRYPTO_KEY_SIZE];\n     unsigned char chIV[WALLET_CRYPTO_IV_SIZE];"
      },
      {
        "sha": "05387f5f2b5e6b011e259011a132c1efc8578d31",
        "filename": "src/wallet/test/crypto_tests.cpp",
        "status": "added",
        "additions": 230,
        "deletions": 0,
        "changes": 230,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/34ed64a404fb6da691f67f00f47c4dd748e3e428/src/wallet/test/crypto_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/34ed64a404fb6da691f67f00f47c4dd748e3e428/src/wallet/test/crypto_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/crypto_tests.cpp?ref=34ed64a404fb6da691f67f00f47c4dd748e3e428",
        "patch": "@@ -0,0 +1,230 @@\n+// Copyright (c) 2014 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"random.h\"\n+#include \"utilstrencodings.h\"\n+#include \"test/test_bitcoin.h\"\n+#include \"wallet/crypter.h\"\n+\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <openssl/aes.h>\n+#include <openssl/evp.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(wallet_crypto, BasicTestingSetup)\n+\n+bool OldSetKeyFromPassphrase(const SecureString& strKeyData, const std::vector<unsigned char>& chSalt, const unsigned int nRounds, const unsigned int nDerivationMethod, unsigned char* chKey, unsigned char* chIV)\n+{\n+    if (nRounds < 1 || chSalt.size() != WALLET_CRYPTO_SALT_SIZE)\n+        return false;\n+\n+    int i = 0;\n+    if (nDerivationMethod == 0)\n+        i = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha512(), &chSalt[0],\n+                          (unsigned char *)&strKeyData[0], strKeyData.size(), nRounds, chKey, chIV);\n+\n+    if (i != (int)WALLET_CRYPTO_KEY_SIZE)\n+    {\n+        memory_cleanse(chKey, sizeof(chKey));\n+        memory_cleanse(chIV, sizeof(chIV));\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool OldEncrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned char> &vchCiphertext, const unsigned char chKey[32], const unsigned char chIV[16])\n+{\n+    // max ciphertext len for a n bytes of plaintext is\n+    // n + AES_BLOCK_SIZE - 1 bytes\n+    int nLen = vchPlaintext.size();\n+    int nCLen = nLen + AES_BLOCK_SIZE, nFLen = 0;\n+    vchCiphertext = std::vector<unsigned char> (nCLen);\n+\n+    EVP_CIPHER_CTX ctx;\n+\n+    bool fOk = true;\n+\n+    EVP_CIPHER_CTX_init(&ctx);\n+    if (fOk) fOk = EVP_EncryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV) != 0;\n+    if (fOk) fOk = EVP_EncryptUpdate(&ctx, &vchCiphertext[0], &nCLen, &vchPlaintext[0], nLen) != 0;\n+    if (fOk) fOk = EVP_EncryptFinal_ex(&ctx, (&vchCiphertext[0]) + nCLen, &nFLen) != 0;\n+    EVP_CIPHER_CTX_cleanup(&ctx);\n+\n+    if (!fOk) return false;\n+\n+    vchCiphertext.resize(nCLen + nFLen);\n+    return true;\n+}\n+\n+bool OldDecrypt(const std::vector<unsigned char>& vchCiphertext, CKeyingMaterial& vchPlaintext, const unsigned char chKey[32], const unsigned char chIV[16])\n+{\n+    // plaintext will always be equal to or lesser than length of ciphertext\n+    int nLen = vchCiphertext.size();\n+    int nPLen = nLen, nFLen = 0;\n+\n+    vchPlaintext = CKeyingMaterial(nPLen);\n+\n+    EVP_CIPHER_CTX ctx;\n+\n+    bool fOk = true;\n+\n+    EVP_CIPHER_CTX_init(&ctx);\n+    if (fOk) fOk = EVP_DecryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV) != 0;\n+    if (fOk) fOk = EVP_DecryptUpdate(&ctx, &vchPlaintext[0], &nPLen, &vchCiphertext[0], nLen) != 0;\n+    if (fOk) fOk = EVP_DecryptFinal_ex(&ctx, (&vchPlaintext[0]) + nPLen, &nFLen) != 0;\n+    EVP_CIPHER_CTX_cleanup(&ctx);\n+\n+    if (!fOk) return false;\n+\n+    vchPlaintext.resize(nPLen + nFLen);\n+    return true;\n+}\n+\n+class TestCrypter\n+{\n+public:\n+static void TestPassphraseSingle(const std::vector<unsigned char>& vchSalt, const SecureString& passphrase, uint32_t rounds,\n+                 const std::vector<unsigned char>& correctKey = std::vector<unsigned char>(),\n+                 const std::vector<unsigned char>& correctIV=std::vector<unsigned char>())\n+{\n+    unsigned char chKey[WALLET_CRYPTO_KEY_SIZE];\n+    unsigned char chIV[WALLET_CRYPTO_IV_SIZE];\n+\n+    CCrypter crypt;\n+    crypt.SetKeyFromPassphrase(passphrase, vchSalt, rounds, 0);\n+\n+    OldSetKeyFromPassphrase(passphrase, vchSalt, rounds, 0, chKey, chIV);\n+\n+    BOOST_CHECK_MESSAGE(memcmp(chKey, crypt.chKey, sizeof(chKey)) == 0, \\\n+        HexStr(chKey, chKey+sizeof(chKey)) + std::string(\" != \") + HexStr(crypt.chKey, crypt.chKey + (sizeof crypt.chKey)));\n+    BOOST_CHECK_MESSAGE(memcmp(chIV, crypt.chIV, sizeof(chIV)) == 0, \\\n+        HexStr(chIV, chIV+sizeof(chIV)) + std::string(\" != \") + HexStr(crypt.chIV, crypt.chIV + (sizeof crypt.chIV)));\n+\n+    if(!correctKey.empty())\n+        BOOST_CHECK_MESSAGE(memcmp(chKey, &correctKey[0], sizeof(chKey)) == 0, \\\n+            HexStr(chKey, chKey+sizeof(chKey)) + std::string(\" != \") + HexStr(correctKey.begin(), correctKey.end()));\n+    if(!correctIV.empty())\n+        BOOST_CHECK_MESSAGE(memcmp(chIV, &correctIV[0], sizeof(chIV)) == 0,\n+            HexStr(chIV, chIV+sizeof(chIV)) + std::string(\" != \") + HexStr(correctIV.begin(), correctIV.end()));\n+}\n+\n+static void TestPassphrase(const std::vector<unsigned char>& vchSalt, const SecureString& passphrase, uint32_t rounds,\n+                 const std::vector<unsigned char>& correctKey = std::vector<unsigned char>(),\n+                 const std::vector<unsigned char>& correctIV=std::vector<unsigned char>())\n+{\n+    TestPassphraseSingle(vchSalt, passphrase, rounds, correctKey, correctIV);\n+    for(SecureString::const_iterator i(passphrase.begin()); i != passphrase.end(); ++i)\n+        TestPassphraseSingle(vchSalt, SecureString(i, passphrase.end()), rounds);\n+}\n+\n+\n+static void TestDecrypt(const CCrypter& crypt, const std::vector<unsigned char>& vchCiphertext, \\\n+                        const std::vector<unsigned char>& vchPlaintext = std::vector<unsigned char>())\n+{\n+    CKeyingMaterial vchDecrypted1;\n+    CKeyingMaterial vchDecrypted2;\n+    int result1, result2;\n+    result1 = crypt.Decrypt(vchCiphertext, vchDecrypted1);\n+    result2 = OldDecrypt(vchCiphertext, vchDecrypted2, crypt.chKey, crypt.chIV);\n+    BOOST_CHECK(result1 == result2);\n+\n+    // These two should be equal. However, OpenSSL 1.0.1j introduced a change\n+    // that would zero all padding except for the last byte for failed decrypts.\n+    // This behavior was reverted for 1.0.1k.\n+    if (vchDecrypted1 != vchDecrypted2 && vchDecrypted1.size() >= AES_BLOCK_SIZE && SSLeay() == 0x100010afL)\n+    {\n+        for(CKeyingMaterial::iterator it = vchDecrypted1.end() - AES_BLOCK_SIZE; it != vchDecrypted1.end() - 1; it++)\n+            *it = 0;\n+    }\n+\n+    BOOST_CHECK_MESSAGE(vchDecrypted1 == vchDecrypted2, HexStr(vchDecrypted1.begin(), vchDecrypted1.end()) + \" != \" + HexStr(vchDecrypted2.begin(), vchDecrypted2.end()));\n+\n+    if (vchPlaintext.size())\n+        BOOST_CHECK(CKeyingMaterial(vchPlaintext.begin(), vchPlaintext.end()) == vchDecrypted2);\n+}\n+\n+static void TestEncryptSingle(const CCrypter& crypt, const CKeyingMaterial& vchPlaintext,\n+                       const std::vector<unsigned char>& vchCiphertextCorrect = std::vector<unsigned char>())\n+{\n+    std::vector<unsigned char> vchCiphertext1;\n+    std::vector<unsigned char> vchCiphertext2;\n+    int result1 = crypt.Encrypt(vchPlaintext, vchCiphertext1);\n+\n+    int result2 = OldEncrypt(vchPlaintext, vchCiphertext2, crypt.chKey, crypt.chIV);\n+    BOOST_CHECK(result1 == result2);\n+    BOOST_CHECK(vchCiphertext1 == vchCiphertext2);\n+\n+    if (!vchCiphertextCorrect.empty())\n+        BOOST_CHECK(vchCiphertext2 == vchCiphertextCorrect);\n+\n+    const std::vector<unsigned char> vchPlaintext2(vchPlaintext.begin(), vchPlaintext.end());\n+\n+    if(vchCiphertext1 == vchCiphertext2)\n+        TestDecrypt(crypt, vchCiphertext1, vchPlaintext2);\n+}\n+\n+static void TestEncrypt(const CCrypter& crypt, const std::vector<unsigned char>& vchPlaintextIn, \\\n+                       const std::vector<unsigned char>& vchCiphertextCorrect = std::vector<unsigned char>())\n+{\n+    TestEncryptSingle(crypt, CKeyingMaterial(vchPlaintextIn.begin(), vchPlaintextIn.end()), vchCiphertextCorrect);\n+    for(std::vector<unsigned char>::const_iterator i(vchPlaintextIn.begin()); i != vchPlaintextIn.end(); ++i)\n+        TestEncryptSingle(crypt, CKeyingMaterial(i, vchPlaintextIn.end()));\n+}\n+\n+};\n+\n+BOOST_AUTO_TEST_CASE(passphrase) {\n+    // These are expensive.\n+\n+    TestCrypter::TestPassphrase(ParseHex(\"0000deadbeef0000\"), \"test\", 25000, \\\n+                                ParseHex(\"fc7aba077ad5f4c3a0988d8daa4810d0d4a0e3bcb53af662998898f33df0556a\"), \\\n+                                ParseHex(\"cf2f2691526dd1aa220896fb8bf7c369\"));\n+\n+    std::string hash(GetRandHash().ToString());\n+    std::vector<unsigned char> vchSalt(8);\n+    GetRandBytes(&vchSalt[0], vchSalt.size());\n+    uint32_t rounds = insecure_rand();\n+    if (rounds > 30000)\n+        rounds = 30000;\n+    TestCrypter::TestPassphrase(vchSalt, SecureString(hash.begin(), hash.end()), rounds);\n+}\n+\n+BOOST_AUTO_TEST_CASE(encrypt) {\n+    std::vector<unsigned char> vchSalt = ParseHex(\"0000deadbeef0000\");\n+    BOOST_CHECK(vchSalt.size() == WALLET_CRYPTO_SALT_SIZE);\n+    CCrypter crypt;\n+    crypt.SetKeyFromPassphrase(\"passphrase\", vchSalt, 25000, 0);\n+    TestCrypter::TestEncrypt(crypt, ParseHex(\"22bcade09ac03ff6386914359cfe885cfeb5f77ff0d670f102f619687453b29d\"));\n+\n+    for (int i = 0; i != 100; i++)\n+    {\n+        uint256 hash(GetRandHash());\n+        TestCrypter::TestEncrypt(crypt, std::vector<unsigned char>(hash.begin(), hash.end()));\n+    }\n+\n+}\n+\n+BOOST_AUTO_TEST_CASE(decrypt) {\n+    std::vector<unsigned char> vchSalt = ParseHex(\"0000deadbeef0000\");\n+    BOOST_CHECK(vchSalt.size() == WALLET_CRYPTO_SALT_SIZE);\n+    CCrypter crypt;\n+    crypt.SetKeyFromPassphrase(\"passphrase\", vchSalt, 25000, 0);\n+\n+    // Some corner cases the came up while testing\n+    TestCrypter::TestDecrypt(crypt,ParseHex(\"795643ce39d736088367822cdc50535ec6f103715e3e48f4f3b1a60a08ef59ca\"));\n+    TestCrypter::TestDecrypt(crypt,ParseHex(\"de096f4a8f9bd97db012aa9d90d74de8cdea779c3ee8bc7633d8b5d6da703486\"));\n+    TestCrypter::TestDecrypt(crypt,ParseHex(\"32d0a8974e3afd9c6c3ebf4d66aa4e6419f8c173de25947f98cf8b7ace49449c\"));\n+    TestCrypter::TestDecrypt(crypt,ParseHex(\"e7c055cca2faa78cb9ac22c9357a90b4778ded9b2cc220a14cea49f931e596ea\"));\n+    TestCrypter::TestDecrypt(crypt,ParseHex(\"b88efddd668a6801d19516d6830da4ae9811988ccbaf40df8fbb72f3f4d335fd\"));\n+    TestCrypter::TestDecrypt(crypt,ParseHex(\"8cae76aa6a43694e961ebcb28c8ca8f8540b84153d72865e8561ddd93fa7bfa9\"));\n+\n+    for (int i = 0; i != 100; i++)\n+    {\n+        uint256 hash(GetRandHash());\n+        TestCrypter::TestDecrypt(crypt, std::vector<unsigned char>(hash.begin(), hash.end()));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "723779c6504453cfb5ccdacf864e7e2f09bb6c32",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3MjM3NzljNjUwNDQ1M2NmYjVjY2RhY2Y4NjRlN2UyZjA5YmI2YzMy",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-05-27T18:14:44Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-05-27T18:14:44Z"
      },
      "message": "build: Enumerate ctaes rather than globbing",
      "tree": {
        "sha": "4926612bc1bf2c09a9d57763b3d9bf0bf6995ae0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4926612bc1bf2c09a9d57763b3d9bf0bf6995ae0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/723779c6504453cfb5ccdacf864e7e2f09bb6c32",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/723779c6504453cfb5ccdacf864e7e2f09bb6c32",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/723779c6504453cfb5ccdacf864e7e2f09bb6c32",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/723779c6504453cfb5ccdacf864e7e2f09bb6c32/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "34ed64a404fb6da691f67f00f47c4dd748e3e428",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/34ed64a404fb6da691f67f00f47c4dd748e3e428",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/34ed64a404fb6da691f67f00f47c4dd748e3e428"
      }
    ],
    "stats": {
      "total": 8,
      "additions": 7,
      "deletions": 1
    },
    "files": [
      {
        "sha": "cb8a99fe9aedb236b0d77a86e702b9f704ad96f3",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/723779c6504453cfb5ccdacf864e7e2f09bb6c32/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/723779c6504453cfb5ccdacf864e7e2f09bb6c32/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=723779c6504453cfb5ccdacf864e7e2f09bb6c32",
        "patch": "@@ -410,6 +410,12 @@ libbitcoinconsensus_la_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n endif\n #\n \n+CTAES_DIST =  crypto/ctaes/bench.c\n+CTAES_DIST += crypto/ctaes/ctaes.c\n+CTAES_DIST += crypto/ctaes/ctaes.h\n+CTAES_DIST += crypto/ctaes/README.md\n+CTAES_DIST += crypto/ctaes/test.c\n+\n CLEANFILES = leveldb/libleveldb.a leveldb/libmemenv.a\n CLEANFILES += $(EXTRA_LIBRARIES)\n CLEANFILES += *.gcda *.gcno\n@@ -427,7 +433,7 @@ CLEANFILES += zmq/*.gcda zmq/*.gcno\n \n DISTCLEANFILES = obj/build.h\n \n-EXTRA_DIST = leveldb crypto/ctaes\n+EXTRA_DIST = leveldb $(CTAES_DIST)\n \n clean-local:\n \t-$(MAKE) -C leveldb clean"
      }
    ]
  }
]