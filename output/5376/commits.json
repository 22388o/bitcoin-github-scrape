[
  {
    "sha": "8a5c9513ba24c2cb0e0889474e32f108a29d087b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YTVjOTUxM2JhMjRjMmNiMGUwODg5NDc0ZTMyZjEwOGEyOWQwODdi",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2014-11-26T13:17:33Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2014-11-27T13:06:45Z"
      },
      "message": "[REST] make selection of output-format mandatory, support dot url syntax\n\n1. Remove the default format (binary) because `rest/block/<hash>/Hex` would end up delivering binary data.\n2. List available formats when chosen format was not found (reduces need for documentation)\n3. Change url syntax to dot extension like format chosing (like `rest/tx/<hash>.json`",
      "tree": {
        "sha": "51d9922c86641ba015001231da2f24d5bfb75208",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/51d9922c86641ba015001231da2f24d5bfb75208"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8a5c9513ba24c2cb0e0889474e32f108a29d087b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8a5c9513ba24c2cb0e0889474e32f108a29d087b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8a5c9513ba24c2cb0e0889474e32f108a29d087b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8a5c9513ba24c2cb0e0889474e32f108a29d087b/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "108b19f7ef7f9d0bf6c6794bf2be9a12b4cb6400",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/108b19f7ef7f9d0bf6c6794bf2be9a12b4cb6400",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/108b19f7ef7f9d0bf6c6794bf2be9a12b4cb6400"
      }
    ],
    "stats": {
      "total": 89,
      "additions": 57,
      "deletions": 32
    },
    "files": [
      {
        "sha": "27551c92955246cbd9cec42f9c4de055370fa8e8",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 57,
        "deletions": 32,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8a5c9513ba24c2cb0e0889474e32f108a29d087b/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8a5c9513ba24c2cb0e0889474e32f108a29d087b/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=8a5c9513ba24c2cb0e0889474e32f108a29d087b",
        "patch": "@@ -18,21 +18,24 @@ using namespace std;\n using namespace json_spirit;\n \n enum RetFormat {\n+    RF_UNDEF,\n     RF_BINARY,\n     RF_HEX,\n     RF_JSON,\n };\n \n static const struct {\n     enum RetFormat rf;\n-    const char *name;\n+    const char* name;\n } rf_names[] = {\n-    { RF_BINARY, \"binary\" },            // default, if match not found\n-    { RF_HEX, \"hex\" },\n-    { RF_JSON, \"json\" },\n+      {RF_UNDEF, \"\"},\n+      {RF_BINARY, \"bin\"},\n+      {RF_HEX, \"hex\"},\n+      {RF_JSON, \"json\"},\n };\n \n-class RestErr {\n+class RestErr\n+{\n public:\n     enum HTTPStatusCode status;\n     string message;\n@@ -49,15 +52,34 @@ static RestErr RESTERR(enum HTTPStatusCode status, string message)\n     return re;\n }\n \n-static enum RetFormat ParseDataFormat(const string& format)\n+static enum RetFormat ParseDataFormat(vector<string>& params, const string strReq)\n {\n-    for (unsigned int i = 0; i < ARRAYLEN(rf_names); i++)\n-        if (format == rf_names[i].name)\n-            return rf_names[i].rf;\n+    boost::split(params, strReq, boost::is_any_of(\".\"));\n+    if (params.size() > 1) {\n+        for (unsigned int i = 0; i < ARRAYLEN(rf_names); i++)\n+            if (params[1] == rf_names[i].name)\n+                return rf_names[i].rf;\n+    }\n \n     return rf_names[0].rf;\n }\n \n+static string AvailableDataFormatsString()\n+{\n+    string formats = \"\";\n+    for (unsigned int i = 0; i < ARRAYLEN(rf_names); i++)\n+        if (strlen(rf_names[i].name) > 0) {\n+            formats.append(\".\");\n+            formats.append(rf_names[i].name);\n+            formats.append(\", \");\n+        }\n+\n+    if (formats.length() > 0)\n+        return formats.substr(0, formats.length() - 2);\n+\n+    return formats;\n+}\n+\n static bool ParseHashStr(const string& strReq, uint256& v)\n {\n     if (!IsHex(strReq) || (strReq.size() != 64))\n@@ -67,15 +89,13 @@ static bool ParseHashStr(const string& strReq, uint256& v)\n     return true;\n }\n \n-static bool rest_block(AcceptedConnection *conn,\n+static bool rest_block(AcceptedConnection* conn,\n                        string& strReq,\n                        map<string, string>& mapHeaders,\n                        bool fRun)\n {\n     vector<string> params;\n-    boost::split(params, strReq, boost::is_any_of(\"/\"));\n-\n-    enum RetFormat rf = ParseDataFormat(params.size() > 1 ? params[1] : string(\"\"));\n+    enum RetFormat rf = ParseDataFormat(params, strReq);\n \n     string hashStr = params[0];\n     uint256 hash;\n@@ -105,7 +125,7 @@ static bool rest_block(AcceptedConnection *conn,\n     }\n \n     case RF_HEX: {\n-        string strHex = HexStr(ssBlock.begin(), ssBlock.end()) + \"\\n\";;\n+        string strHex = HexStr(ssBlock.begin(), ssBlock.end()) + \"\\n\";\n         conn->stream() << HTTPReply(HTTP_OK, strHex, fRun, false, \"text/plain\") << std::flush;\n         return true;\n     }\n@@ -115,22 +135,24 @@ static bool rest_block(AcceptedConnection *conn,\n         string strJSON = write_string(Value(objBlock), false) + \"\\n\";\n         conn->stream() << HTTPReply(HTTP_OK, strJSON, fRun) << std::flush;\n         return true;\n-     }\n+    }\n+\n+    default: {\n+        throw RESTERR(HTTP_NOT_FOUND, \"output format not found (available: \" + AvailableDataFormatsString() + \")\");\n+    }\n     }\n \n     // not reached\n-    return true;     // continue to process further HTTP reqs on this cxn\n+    return true; // continue to process further HTTP reqs on this cxn\n }\n \n-static bool rest_tx(AcceptedConnection *conn,\n+static bool rest_tx(AcceptedConnection* conn,\n                     string& strReq,\n                     map<string, string>& mapHeaders,\n                     bool fRun)\n {\n     vector<string> params;\n-    boost::split(params, strReq, boost::is_any_of(\"/\"));\n-\n-    enum RetFormat rf = ParseDataFormat(params.size() > 1 ? params[1] : string(\"\"));\n+    enum RetFormat rf = ParseDataFormat(params, strReq);\n \n     string hashStr = params[0];\n     uint256 hash;\n@@ -153,7 +175,7 @@ static bool rest_tx(AcceptedConnection *conn,\n     }\n \n     case RF_HEX: {\n-        string strHex = HexStr(ssTx.begin(), ssTx.end()) + \"\\n\";;\n+        string strHex = HexStr(ssTx.begin(), ssTx.end()) + \"\\n\";\n         conn->stream() << HTTPReply(HTTP_OK, strHex, fRun, false, \"text/plain\") << std::flush;\n         return true;\n     }\n@@ -165,42 +187,45 @@ static bool rest_tx(AcceptedConnection *conn,\n         conn->stream() << HTTPReply(HTTP_OK, strJSON, fRun) << std::flush;\n         return true;\n     }\n+\n+    default: {\n+        throw RESTERR(HTTP_NOT_FOUND, \"output format not found (available: \" + AvailableDataFormatsString() + \")\");\n+    }\n     }\n \n     // not reached\n-    return true;     // continue to process further HTTP reqs on this cxn\n+    return true; // continue to process further HTTP reqs on this cxn\n }\n \n static const struct {\n-    const char *prefix;\n-    bool (*handler)(AcceptedConnection *conn,\n+    const char* prefix;\n+    bool (*handler)(AcceptedConnection* conn,\n                     string& strURI,\n                     map<string, string>& mapHeaders,\n                     bool fRun);\n } uri_prefixes[] = {\n-    { \"/rest/tx/\", rest_tx },\n-    { \"/rest/block/\", rest_block },\n+      {\"/rest/tx/\", rest_tx},\n+      {\"/rest/block/\", rest_block},\n };\n \n-bool HTTPReq_REST(AcceptedConnection *conn,\n+bool HTTPReq_REST(AcceptedConnection* conn,\n                   string& strURI,\n                   map<string, string>& mapHeaders,\n                   bool fRun)\n {\n     try {\n         std::string statusmessage;\n-        if(RPCIsInWarmup(&statusmessage))\n-            throw RESTERR(HTTP_SERVICE_UNAVAILABLE, \"Service temporarily unavailable: \"+statusmessage);\n-        \n+        if (RPCIsInWarmup(&statusmessage))\n+            throw RESTERR(HTTP_SERVICE_UNAVAILABLE, \"Service temporarily unavailable: \" + statusmessage);\n+\n         for (unsigned int i = 0; i < ARRAYLEN(uri_prefixes); i++) {\n             unsigned int plen = strlen(uri_prefixes[i].prefix);\n             if (strURI.substr(0, plen) == uri_prefixes[i].prefix) {\n                 string strReq = strURI.substr(plen);\n                 return uri_prefixes[i].handler(conn, strReq, mapHeaders, fRun);\n             }\n         }\n-    }\n-    catch (RestErr& re) {\n+    } catch (RestErr& re) {\n         conn->stream() << HTTPReply(re.status, re.message + \"\\r\\n\", false, false, \"text/plain\") << std::flush;\n         return false;\n     }"
      }
    ]
  }
]