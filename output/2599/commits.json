[
  {
    "sha": "a9d9f0f5f72ab1f9ebc2f76bfe3b7921fa2826d7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphOWQ5ZjBmNWY3MmFiMWY5ZWJjMmY3NmJmZTNiNzkyMWZhMjgyNmQ3",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-04-30T16:42:01Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-05-01T18:56:50Z"
      },
      "message": "Do not kill connections on recv buffer overflow\n\nInstead of killing a connection when the receive buffer overflows,\njust temporarily halt receiving before that happens. Also, no\nmatter what, always allow at least one full message in the receive\nbuffer (otherwise blocks larger than the configured buffer size\nwould pause indefinitely).",
      "tree": {
        "sha": "3ff31649fefa8ec471a3c97a408d7cb96c86d740",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3ff31649fefa8ec471a3c97a408d7cb96c86d740"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a9d9f0f5f72ab1f9ebc2f76bfe3b7921fa2826d7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a9d9f0f5f72ab1f9ebc2f76bfe3b7921fa2826d7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a9d9f0f5f72ab1f9ebc2f76bfe3b7921fa2826d7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a9d9f0f5f72ab1f9ebc2f76bfe3b7921fa2826d7/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1c621e70bee7575cdf31a08c42eeee3db2b7fdbf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1c621e70bee7575cdf31a08c42eeee3db2b7fdbf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1c621e70bee7575cdf31a08c42eeee3db2b7fdbf"
      }
    ],
    "stats": {
      "total": 45,
      "additions": 30,
      "deletions": 15
    },
    "files": [
      {
        "sha": "54ed1d9b51609f76f725b69ef1a537f73b4e4dc4",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 15,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a9d9f0f5f72ab1f9ebc2f76bfe3b7921fa2826d7/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a9d9f0f5f72ab1f9ebc2f76bfe3b7921fa2826d7/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=a9d9f0f5f72ab1f9ebc2f76bfe3b7921fa2826d7",
        "patch": "@@ -841,19 +841,39 @@ void ThreadSocketHandler()\n             {\n                 if (pnode->hSocket == INVALID_SOCKET)\n                     continue;\n+                FD_SET(pnode->hSocket, &fdsetError);\n+                hSocketMax = max(hSocketMax, pnode->hSocket);\n+                have_fds = true;\n+\n+                // Implement the following logic:\n+                // * If there is data to send, select() for sending data. As this only\n+                //   happens when optimistic write failed, we choose to first drain the\n+                //   write buffer in this case before receiving more. This avoids\n+                //   needlessly queueing received data, if the remote peer is not themselves\n+                //   receiving data. This means properly utilizing TCP flow control signalling.\n+                // * Otherwise, if there is no (complete) message in the receive buffer,\n+                //   or there is space left in the buffer, select() for receiving data.\n+                // * (if neither of the above applies, there is certainly one message\n+                //   in the receiver buffer ready to be processed).\n+                // Together, that means that at least one of the following is always possible,\n+                // so we don't deadlock:\n+                // * We send some data.\n+                // * We wait for data to be received (and disconnect after timeout).\n+                // * We process a message in the buffer (message handler thread).\n                 {\n                     TRY_LOCK(pnode->cs_vSend, lockSend);\n-                    if (lockSend) {\n-                        // do not read, if draining write queue\n-                        if (!pnode->vSendMsg.empty())\n-                            FD_SET(pnode->hSocket, &fdsetSend);\n-                        else\n-                            FD_SET(pnode->hSocket, &fdsetRecv);\n-                        FD_SET(pnode->hSocket, &fdsetError);\n-                        hSocketMax = max(hSocketMax, pnode->hSocket);\n-                        have_fds = true;\n+                    if (lockSend && !pnode->vSendMsg.empty()) {\n+                        FD_SET(pnode->hSocket, &fdsetSend);\n+                        continue;\n                     }\n                 }\n+                {\n+                    TRY_LOCK(pnode->cs_vRecvMsg, lockRecv);\n+                    if (lockRecv && (\n+                        pnode->vRecvMsg.empty() || !pnode->vRecvMsg.front().complete() ||\n+                        pnode->GetTotalRecvSize() <= ReceiveFloodSize()))\n+                        FD_SET(pnode->hSocket, &fdsetRecv);\n+                }\n             }\n         }\n \n@@ -959,12 +979,7 @@ void ThreadSocketHandler()\n                 TRY_LOCK(pnode->cs_vRecvMsg, lockRecv);\n                 if (lockRecv)\n                 {\n-                    if (pnode->GetTotalRecvSize() > ReceiveFloodSize()) {\n-                        if (!pnode->fDisconnect)\n-                            printf(\"socket recv flood control disconnect (%u bytes)\\n\", pnode->GetTotalRecvSize());\n-                        pnode->CloseSocketDisconnect();\n-                    }\n-                    else {\n+                    {\n                         // typical socket buffer is 8K-64K\n                         char pchBuf[0x10000];\n                         int nBytes = recv(pnode->hSocket, pchBuf, sizeof(pchBuf), MSG_DONTWAIT);"
      }
    ]
  }
]