[
  {
    "sha": "c60fd71a65e841efe187992f46c583a704cc37f5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNjBmZDcxYTY1ZTg0MWVmZTE4Nzk5MmY0NmM1ODNhNzA0Y2MzN2Y1",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2017-10-11T12:55:14Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-10-26T17:43:53Z"
      },
      "message": "Disconnecting from bad outbound peers in IBD\n\nWhen in IBD, we'd like to use all our outbound peers to help us\nsync the chain.  Disconnect any outbound peers whose headers have\ninsufficient work.",
      "tree": {
        "sha": "7129e0925746456f86cb4242acfbbc1d1f549abc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7129e0925746456f86cb4242acfbbc1d1f549abc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c60fd71a65e841efe187992f46c583a704cc37f5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c60fd71a65e841efe187992f46c583a704cc37f5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c60fd71a65e841efe187992f46c583a704cc37f5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c60fd71a65e841efe187992f46c583a704cc37f5/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "326a5652e0d25fdb60c337ef4f1c98a63e0748f0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/326a5652e0d25fdb60c337ef4f1c98a63e0748f0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/326a5652e0d25fdb60c337ef4f1c98a63e0748f0"
      }
    ],
    "stats": {
      "total": 26,
      "additions": 26,
      "deletions": 0
    },
    "files": [
      {
        "sha": "8551e845582b799ab18a097b8b3b357fd481c31a",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c60fd71a65e841efe187992f46c583a704cc37f5/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c60fd71a65e841efe187992f46c583a704cc37f5/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=c60fd71a65e841efe187992f46c583a704cc37f5",
        "patch": "@@ -2383,6 +2383,24 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 }\n             }\n         }\n+        // If we're in IBD, we want outbound peers that will serve us a useful\n+        // chain. Disconnect peers that are on chains with insufficient work.\n+        if (IsInitialBlockDownload() && nCount != MAX_HEADERS_RESULTS) {\n+            // When nCount < MAX_HEADERS_RESULTS, we know we have no more\n+            // headers to fetch from this peer.\n+            if (nodestate->pindexBestKnownBlock && nodestate->pindexBestKnownBlock->nChainWork < nMinimumChainWork) {\n+                // This peer has too little work on their headers chain to help\n+                // us sync -- disconnect if using an outbound slot (unless\n+                // whitelisted or addnode).\n+                // Note: We compare their tip to nMinimumChainWork (rather than\n+                // chainActive.Tip()) because we won't start block download\n+                // until we have a headers chain that has at least\n+                // nMinimumChainWork, even if a peer has a chain past our tip,\n+                if (!(pfrom->fInbound || pfrom->fWhitelisted || pfrom->m_manual_connection)) {\n+                    pfrom->fDisconnect = true;\n+                }\n+            }\n+        }\n         }\n     }\n "
      },
      {
        "sha": "35cd7ad1418079f70692a6a7c4c759f92b7808f5",
        "filename": "test/functional/minchainwork.py",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c60fd71a65e841efe187992f46c583a704cc37f5/test/functional/minchainwork.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c60fd71a65e841efe187992f46c583a704cc37f5/test/functional/minchainwork.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/minchainwork.py?ref=c60fd71a65e841efe187992f46c583a704cc37f5",
        "patch": "@@ -27,6 +27,7 @@ class MinimumChainWorkTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.setup_clean_chain = True\n         self.num_nodes = 3\n+\n         self.extra_args = [[], [\"-minimumchainwork=0x65\"], [\"-minimumchainwork=0x65\"]]\n         self.node_min_work = [0, 101, 101]\n \n@@ -74,6 +75,13 @@ def run_test(self):\n         self.nodes[0].generate(1)\n \n         self.log.info(\"Verifying nodes are all synced\")\n+\n+        # Because nodes in regtest are all manual connections (eg using\n+        # addnode), node1 should not have disconnected node0. If not for that,\n+        # we'd expect node1 to have disconnected node0 for serving an\n+        # insufficient work chain, in which case we'd need to reconnect them to\n+        # continue the test.\n+\n         self.sync_all()\n         self.log.info(\"Blockcounts: %s\", [n.getblockcount() for n in self.nodes])\n "
      }
    ]
  },
  {
    "sha": "5a6d00c6defc587e22c93e63029fdd538ce8858d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1YTZkMDBjNmRlZmM1ODdlMjJjOTNlNjMwMjlmZGQ1MzhjZTg4NThk",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-10-12T17:55:43Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-10-26T17:43:53Z"
      },
      "message": "Permit disconnection of outbound peers on bad/slow chains\n\nCurrently we have no rotation of outbound peers.  If an outbound peer\nstops serving us blocks, or is on a consensus-incompatible chain with\nless work than our tip (but otherwise valid headers), then we will never\ndisconnect that peer, even though that peer is using one of our 8\noutbound connection slots.  Because we rely on our outbound peers to\nfind an honest node in order to reach consensus, allowing an\nincompatible peer to occupy one of those slots is undesirable,\nparticularly if it is possible for all such slots to be occupied by such\npeers.\n\nProtect against this by always checking to see if a peer's best known\nblock has less work than our tip, and if so, set a 20 minute timeout --\nif the peer is still not known to have caught up to a chain with as much\nwork as ours after 20 minutes, then send a single getheaders message,\nwait 2 more minutes, and if a better header hasn't been received by then,\ndisconnect that peer.\n\nNote:\n\n- we do not require that our peer sync to the same tip as ours, just an\nequal or greater work tip.  (Doing otherwise would risk partitioning the\nnetwork in the event of a chain split, and is also unnecessary.)\n\n- we pick 4 of our outbound peers and do not subject them to this logic,\nto be more conservative. We don't wish to permit temporary network\nissues (or an attacker) to excessively disrupt network topology.",
      "tree": {
        "sha": "d265b9667143005dda2f82a0415bdc4585c7cff6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d265b9667143005dda2f82a0415bdc4585c7cff6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5a6d00c6defc587e22c93e63029fdd538ce8858d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5a6d00c6defc587e22c93e63029fdd538ce8858d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5a6d00c6defc587e22c93e63029fdd538ce8858d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5a6d00c6defc587e22c93e63029fdd538ce8858d/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c60fd71a65e841efe187992f46c583a704cc37f5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c60fd71a65e841efe187992f46c583a704cc37f5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c60fd71a65e841efe187992f46c583a704cc37f5"
      }
    ],
    "stats": {
      "total": 121,
      "additions": 120,
      "deletions": 1
    },
    "files": [
      {
        "sha": "f83a20102e5a0af51efd3b23d3ffc514f806c2f9",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 112,
        "deletions": 1,
        "changes": 113,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5a6d00c6defc587e22c93e63029fdd538ce8858d/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5a6d00c6defc587e22c93e63029fdd538ce8858d/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=5a6d00c6defc587e22c93e63029fdd538ce8858d",
        "patch": "@@ -124,6 +124,9 @@ namespace {\n     /** Number of peers from which we're downloading blocks. */\n     int nPeersWithValidatedDownloads = 0;\n \n+    /** Number of outbound peers with m_chain_sync.m_protect. */\n+    int g_outbound_peers_with_protect_from_disconnect = 0;\n+\n     /** Relay map, protected by cs_main. */\n     typedef std::map<uint256, CTransactionRef> MapRelay;\n     MapRelay mapRelay;\n@@ -201,6 +204,33 @@ struct CNodeState {\n      */\n     bool fSupportsDesiredCmpctVersion;\n \n+    /** State used to enforce CHAIN_SYNC_TIMEOUT\n+      * Only in effect for outbound, non-manual connections, with\n+      * m_protect == false\n+      * Algorithm: if a peer's best known block has less work than our tip,\n+      * set a timeout CHAIN_SYNC_TIMEOUT seconds in the future:\n+      *   - If at timeout their best known block now has more work than our tip\n+      *     when the timeout was set, then either reset the timeout or clear it\n+      *     (after comparing against our current tip's work)\n+      *   - If at timeout their best known block still has less work than our\n+      *     tip did when the timeout was set, then send a getheaders message,\n+      *     and set a shorter timeout, HEADERS_RESPONSE_TIME seconds in future.\n+      *     If their best known block is still behind when that new timeout is\n+      *     reached, disconnect.\n+      */\n+    struct ChainSyncTimeoutState {\n+        //! A timeout used for checking whether our peer has sufficiently synced\n+        int64_t m_timeout;\n+        //! A header with the work we require on our peer's chain\n+        const CBlockIndex * m_work_header;\n+        //! After timeout is reached, set to true after sending getheaders\n+        bool m_sent_getheaders;\n+        //! Whether this peer is protected from disconnection due to a bad/slow chain\n+        bool m_protect;\n+    };\n+\n+    ChainSyncTimeoutState m_chain_sync;\n+\n     CNodeState(CAddress addrIn, std::string addrNameIn) : address(addrIn), name(addrNameIn) {\n         fCurrentlyConnected = false;\n         nMisbehavior = 0;\n@@ -223,6 +253,7 @@ struct CNodeState {\n         fHaveWitness = false;\n         fWantsCmpctWitness = false;\n         fSupportsDesiredCmpctVersion = false;\n+        m_chain_sync = { 0, nullptr, false, false };\n     }\n };\n \n@@ -502,6 +533,13 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n \n } // namespace\n \n+// Returns true for outbound peers, excluding manual connections, feelers, and\n+// one-shots\n+bool IsOutboundDisconnectionCandidate(const CNode *node)\n+{\n+    return !(node->fInbound || node->m_manual_connection || node->fFeeler || node->fOneShot);\n+}\n+\n void PeerLogicValidation::InitializeNode(CNode *pnode) {\n     CAddress addr = pnode->addr;\n     std::string addrName = pnode->GetAddrName();\n@@ -534,6 +572,8 @@ void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTim\n     nPreferredDownload -= state->fPreferredDownload;\n     nPeersWithValidatedDownloads -= (state->nBlocksInFlightValidHeaders != 0);\n     assert(nPeersWithValidatedDownloads >= 0);\n+    g_outbound_peers_with_protect_from_disconnect -= state->m_chain_sync.m_protect;\n+    assert(g_outbound_peers_with_protect_from_disconnect >= 0);\n \n     mapNodeState.erase(nodeid);\n \n@@ -542,6 +582,7 @@ void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTim\n         assert(mapBlocksInFlight.empty());\n         assert(nPreferredDownload == 0);\n         assert(nPeersWithValidatedDownloads == 0);\n+        assert(g_outbound_peers_with_protect_from_disconnect == 0);\n     }\n     LogPrint(BCLog::NET, \"Cleared nodestate for peer=%d\\n\", nodeid);\n }\n@@ -2324,6 +2365,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         assert(pindexLast);\n         UpdateBlockAvailability(pfrom->GetId(), pindexLast->GetBlockHash());\n \n+        // From here, pindexBestKnownBlock should be guaranteed to be non-null,\n+        // because it is set in UpdateBlockAvailability. Some nullptr checks\n+        // are still present, however, as belt-and-suspenders.\n+\n         if (nCount == MAX_HEADERS_RESULTS) {\n             // Headers message had its maximum size; the peer may have more headers.\n             // TODO: optimize: if pindexLast is an ancestor of chainActive.Tip or pindexBestHeader, continue\n@@ -2396,11 +2441,22 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // chainActive.Tip()) because we won't start block download\n                 // until we have a headers chain that has at least\n                 // nMinimumChainWork, even if a peer has a chain past our tip,\n-                if (!(pfrom->fInbound || pfrom->fWhitelisted || pfrom->m_manual_connection)) {\n+                // as an anti-DoS measure.\n+                if (IsOutboundDisconnectionCandidate(pfrom)) {\n+                    LogPrintf(\"Disconnecting outbound peer %d -- headers chain has insufficient work\\n\", pfrom->GetId());\n                     pfrom->fDisconnect = true;\n                 }\n             }\n         }\n+\n+        if (!pfrom->fDisconnect && IsOutboundDisconnectionCandidate(pfrom) && nodestate->pindexBestKnownBlock != nullptr) {\n+            // If this is an outbound peer, check to see if we should protect\n+            // it from the bad/lagging chain logic.\n+            if (g_outbound_peers_with_protect_from_disconnect < MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT && nodestate->pindexBestKnownBlock->nChainWork >= chainActive.Tip()->nChainWork && !nodestate->m_chain_sync.m_protect) {\n+                nodestate->m_chain_sync.m_protect = true;\n+                ++g_outbound_peers_with_protect_from_disconnect;\n+            }\n+        }\n         }\n     }\n \n@@ -2799,6 +2855,58 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     return fMoreWork;\n }\n \n+void PeerLogicValidation::ConsiderEviction(CNode *pto, int64_t time_in_seconds)\n+{\n+    AssertLockHeld(cs_main);\n+\n+    CNodeState &state = *State(pto->GetId());\n+    const CNetMsgMaker msgMaker(pto->GetSendVersion());\n+\n+    if (!state.m_chain_sync.m_protect && IsOutboundDisconnectionCandidate(pto) && state.fSyncStarted) {\n+        // This is an outbound peer subject to disconnection if they don't\n+        // announce a block with as much work as the current tip within\n+        // CHAIN_SYNC_TIMEOUT + HEADERS_RESPONSE_TIME seconds (note: if\n+        // their chain has more work than ours, we should sync to it,\n+        // unless it's invalid, in which case we should find that out and\n+        // disconnect from them elsewhere).\n+        if (state.pindexBestKnownBlock != nullptr && state.pindexBestKnownBlock->nChainWork >= chainActive.Tip()->nChainWork) {\n+            if (state.m_chain_sync.m_timeout != 0) {\n+                state.m_chain_sync.m_timeout = 0;\n+                state.m_chain_sync.m_work_header = nullptr;\n+                state.m_chain_sync.m_sent_getheaders = false;\n+            }\n+        } else if (state.m_chain_sync.m_timeout == 0 || (state.m_chain_sync.m_work_header != nullptr && state.pindexBestKnownBlock != nullptr && state.pindexBestKnownBlock->nChainWork >= state.m_chain_sync.m_work_header->nChainWork)) {\n+            // Our best block known by this peer is behind our tip, and we're either noticing\n+            // that for the first time, OR this peer was able to catch up to some earlier point\n+            // where we checked against our tip.\n+            // Either way, set a new timeout based on current tip.\n+            state.m_chain_sync.m_timeout = time_in_seconds + CHAIN_SYNC_TIMEOUT;\n+            state.m_chain_sync.m_work_header = chainActive.Tip();\n+            state.m_chain_sync.m_sent_getheaders = false;\n+        } else if (state.m_chain_sync.m_timeout > 0 && time_in_seconds > state.m_chain_sync.m_timeout) {\n+            // No evidence yet that our peer has synced to a chain with work equal to that\n+            // of our tip, when we first detected it was behind. Send a single getheaders\n+            // message to give the peer a chance to update us.\n+            if (state.m_chain_sync.m_sent_getheaders) {\n+                // They've run out of time to catch up!\n+                LogPrintf(\"Disconnecting outbound peer %d for old chain, best known block = %s\\n\", pto->GetId(), state.pindexBestKnownBlock != nullptr ? state.pindexBestKnownBlock->GetBlockHash().ToString() : \"<none>\");\n+                pto->fDisconnect = true;\n+            } else {\n+                LogPrint(BCLog::NET, \"sending getheaders to outbound peer=%d to verify chain work (current best known block:%s, benchmark blockhash: %s)\\n\", pto->GetId(), state.pindexBestKnownBlock != nullptr ? state.pindexBestKnownBlock->GetBlockHash().ToString() : \"<none>\", state.m_chain_sync.m_work_header->GetBlockHash().ToString());\n+                connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(state.m_chain_sync.m_work_header->pprev), uint256()));\n+                state.m_chain_sync.m_sent_getheaders = true;\n+                constexpr int64_t HEADERS_RESPONSE_TIME = 120; // 2 minutes\n+                // Bump the timeout to allow a response, which could clear the timeout\n+                // (if the response shows the peer has synced), reset the timeout (if\n+                // the peer syncs to the required work but not to our tip), or result\n+                // in disconnect (if we advance to the timeout and pindexBestKnownBlock\n+                // has not sufficiently progressed)\n+                state.m_chain_sync.m_timeout = time_in_seconds + HEADERS_RESPONSE_TIME;\n+            }\n+        }\n+    }\n+}\n+\n class CompareInvMempoolOrder\n {\n     CTxMemPool *mp;\n@@ -3265,6 +3373,9 @@ bool PeerLogicValidation::SendMessages(CNode* pto, std::atomic<bool>& interruptM\n             }\n         }\n \n+        // Check that outbound peers have reasonable chains\n+        // GetTime() is used by this anti-DoS logic so we can test this using mocktime\n+        ConsiderEviction(pto, GetTime());\n \n         //\n         // Message: getdata (blocks)"
      },
      {
        "sha": "656324bba0c4cc327455eed03793ca8ef8007129",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5a6d00c6defc587e22c93e63029fdd538ce8858d/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5a6d00c6defc587e22c93e63029fdd538ce8858d/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=5a6d00c6defc587e22c93e63029fdd538ce8858d",
        "patch": "@@ -21,6 +21,12 @@ static const unsigned int DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN = 100;\n  *  Timeout = base + per_header * (expected number of headers) */\n static constexpr int64_t HEADERS_DOWNLOAD_TIMEOUT_BASE = 15 * 60 * 1000000; // 15 minutes\n static constexpr int64_t HEADERS_DOWNLOAD_TIMEOUT_PER_HEADER = 1000; // 1ms/header\n+/** Protect at least this many outbound peers from disconnection due to slow/\n+ * behind headers chain.\n+ */\n+static constexpr int32_t MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT = 4;\n+/** Timeout for (unprotected) outbound peers to sync to our chainwork, in seconds */\n+static constexpr int64_t CHAIN_SYNC_TIMEOUT = 20 * 60; // 20 minutes\n \n class PeerLogicValidation : public CValidationInterface, public NetEventsInterface {\n private:\n@@ -47,6 +53,8 @@ class PeerLogicValidation : public CValidationInterface, public NetEventsInterfa\n     * @return                      True if there is more work to be done\n     */\n     bool SendMessages(CNode* pto, std::atomic<bool>& interrupt) override;\n+\n+    void ConsiderEviction(CNode *pto, int64_t time_in_seconds);\n };\n \n struct CNodeStateStats {"
      }
    ]
  },
  {
    "sha": "e065249c014a070a8799b2ff947af5b8f012c5c1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMDY1MjQ5YzAxNGEwNzBhODc5OWIyZmY5NDdhZjViOGYwMTJjNWMx",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-10-19T15:42:47Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-10-26T17:51:06Z"
      },
      "message": "Add unit test for outbound peer eviction",
      "tree": {
        "sha": "0e617c0c0739930397504b217077837a6e4d83a0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0e617c0c0739930397504b217077837a6e4d83a0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e065249c014a070a8799b2ff947af5b8f012c5c1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e065249c014a070a8799b2ff947af5b8f012c5c1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e065249c014a070a8799b2ff947af5b8f012c5c1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e065249c014a070a8799b2ff947af5b8f012c5c1/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5a6d00c6defc587e22c93e63029fdd538ce8858d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5a6d00c6defc587e22c93e63029fdd538ce8858d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5a6d00c6defc587e22c93e63029fdd538ce8858d"
      }
    ],
    "stats": {
      "total": 55,
      "additions": 55,
      "deletions": 0
    },
    "files": [
      {
        "sha": "7bcf304833f175596968cec2f3a6cb0dc30f21ca",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 55,
        "deletions": 0,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e065249c014a070a8799b2ff947af5b8f012c5c1/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e065249c014a070a8799b2ff947af5b8f012c5c1/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=e065249c014a070a8799b2ff947af5b8f012c5c1",
        "patch": "@@ -42,6 +42,51 @@ static NodeId id = 0;\n \n BOOST_FIXTURE_TEST_SUITE(DoS_tests, TestingSetup)\n \n+// Test eviction of an outbound peer whose chain never advances\n+// Mock a node connection, and use mocktime to simulate a peer\n+// which never sends any headers messages.  PeerLogic should\n+// decide to evict that outbound peer, after the appropriate timeouts.\n+// Note that we protect 4 outbound nodes from being subject to\n+// this logic; this test takes advantage of that protection only\n+// being applied to nodes which send headers with sufficient\n+// work.\n+BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n+{\n+    std::atomic<bool> interruptDummy(false);\n+\n+    // Mock an outbound peer\n+    CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n+    CNode dummyNode1(id++, ServiceFlags(NODE_NETWORK|NODE_WITNESS), 0, INVALID_SOCKET, addr1, 0, 0, CAddress(), \"\", /*fInboundIn=*/ false);\n+    dummyNode1.SetSendVersion(PROTOCOL_VERSION);\n+\n+    peerLogic->InitializeNode(&dummyNode1);\n+    dummyNode1.nVersion = 1;\n+    dummyNode1.fSuccessfullyConnected = true;\n+\n+    // This test requires that we have a chain with non-zero work.\n+    BOOST_CHECK(chainActive.Tip() != nullptr);\n+    BOOST_CHECK(chainActive.Tip()->nChainWork > 0);\n+\n+    // Test starts here\n+    peerLogic->SendMessages(&dummyNode1, interruptDummy); // should result in getheaders\n+    BOOST_CHECK(dummyNode1.vSendMsg.size() > 0);\n+    dummyNode1.vSendMsg.clear();\n+\n+    int64_t nStartTime = GetTime();\n+    // Wait 21 minutes\n+    SetMockTime(nStartTime+21*60);\n+    peerLogic->SendMessages(&dummyNode1, interruptDummy); // should result in getheaders\n+    BOOST_CHECK(dummyNode1.vSendMsg.size() > 0);\n+    // Wait 3 more minutes\n+    SetMockTime(nStartTime+24*60);\n+    peerLogic->SendMessages(&dummyNode1, interruptDummy); // should result in disconnect\n+    BOOST_CHECK(dummyNode1.fDisconnect == true);\n+    SetMockTime(0);\n+\n+    bool dummy;\n+    peerLogic->FinalizeNode(dummyNode1.GetId(), dummy);\n+}\n+\n BOOST_AUTO_TEST_CASE(DoS_banning)\n {\n     std::atomic<bool> interruptDummy(false);\n@@ -71,6 +116,10 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     Misbehaving(dummyNode2.GetId(), 50);\n     peerLogic->SendMessages(&dummyNode2, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr2));\n+\n+    bool dummy;\n+    peerLogic->FinalizeNode(dummyNode1.GetId(), dummy);\n+    peerLogic->FinalizeNode(dummyNode2.GetId(), dummy);\n }\n \n BOOST_AUTO_TEST_CASE(DoS_banscore)\n@@ -95,6 +144,9 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n     peerLogic->SendMessages(&dummyNode1, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr1));\n     gArgs.ForceSetArg(\"-banscore\", std::to_string(DEFAULT_BANSCORE_THRESHOLD));\n+\n+    bool dummy;\n+    peerLogic->FinalizeNode(dummyNode1.GetId(), dummy);\n }\n \n BOOST_AUTO_TEST_CASE(DoS_bantime)\n@@ -121,6 +173,9 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n \n     SetMockTime(nStartTime+60*60*24+1);\n     BOOST_CHECK(!connman->IsBanned(addr));\n+\n+    bool dummy;\n+    peerLogic->FinalizeNode(dummyNode.GetId(), dummy);\n }\n \n CTransactionRef RandomOrphan()"
      }
    ]
  }
]