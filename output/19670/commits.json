[
  {
    "sha": "752e6ad5336d5af0db9fe16d24c0c6aa25b74a3f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3NTJlNmFkNTMzNmQ1YWYwZGI5ZmUxNmQyNGMwYzZhYTI1Yjc0YTNm",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2020-08-05T18:31:50Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2020-09-02T13:21:33Z"
      },
      "message": "Protect localhost and block-relay-only peers from eviction\n\nOnion peers are disadvantaged under our eviction criteria, so prevent eventual\neviction of them in the presence of contention for inbound slots by reserving\nsome slots for localhost peers (sorted by longest uptime).\n\nBlock-relay-only connections exist as a protection against eclipse attacks, by\ncreating a path for block propagation that may be unknown to adversaries.\nProtect against inbound peer connection slot attacks from disconnecting such\npeers by attempting to protect up to 8 peers that are not relaying transactions\nbut appear to be full-nodes, sorted by recency of last delivered block.\n\nThanks to gmaxwell for suggesting these strategies.",
      "tree": {
        "sha": "517f0dbe10c38b3ed16e44a164cb2b8cfbe00bc0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/517f0dbe10c38b3ed16e44a164cb2b8cfbe00bc0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/752e6ad5336d5af0db9fe16d24c0c6aa25b74a3f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/752e6ad5336d5af0db9fe16d24c0c6aa25b74a3f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/752e6ad5336d5af0db9fe16d24c0c6aa25b74a3f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/752e6ad5336d5af0db9fe16d24c0c6aa25b74a3f/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c157a50694545090cb1c7e69123fe4709bd5a279",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c157a50694545090cb1c7e69123fe4709bd5a279",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c157a50694545090cb1c7e69123fe4709bd5a279"
      }
    ],
    "stats": {
      "total": 38,
      "additions": 36,
      "deletions": 2
    },
    "files": [
      {
        "sha": "347da142a5652c340ad3eac655f4ec271e4a0cdb",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 2,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/752e6ad5336d5af0db9fe16d24c0c6aa25b74a3f/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/752e6ad5336d5af0db9fe16d24c0c6aa25b74a3f/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=752e6ad5336d5af0db9fe16d24c0c6aa25b74a3f",
        "patch": "@@ -816,6 +816,7 @@ struct NodeEvictionCandidate\n     CAddress addr;\n     uint64_t nKeyedNetGroup;\n     bool prefer_evict;\n+    bool m_is_local;\n };\n \n static bool ReverseCompareNodeMinPingTime(const NodeEvictionCandidate &a, const NodeEvictionCandidate &b)\n@@ -828,6 +829,12 @@ static bool ReverseCompareNodeTimeConnected(const NodeEvictionCandidate &a, cons\n     return a.nTimeConnected > b.nTimeConnected;\n }\n \n+static bool CompareLocalHostTimeConnected(const NodeEvictionCandidate &a, const NodeEvictionCandidate &b)\n+{\n+    if (a.m_is_local != b.m_is_local) return b.m_is_local;\n+    return a.nTimeConnected > b.nTimeConnected;\n+}\n+\n static bool CompareNetGroupKeyed(const NodeEvictionCandidate &a, const NodeEvictionCandidate &b) {\n     return a.nKeyedNetGroup < b.nKeyedNetGroup;\n }\n@@ -849,6 +856,14 @@ static bool CompareNodeTXTime(const NodeEvictionCandidate &a, const NodeEviction\n     return a.nTimeConnected > b.nTimeConnected;\n }\n \n+// Pick out the potential block-relay only peers, and sort them by last block time.\n+static bool CompareNodeBlockRelayOnlyTime(const NodeEvictionCandidate &a, const NodeEvictionCandidate &b)\n+{\n+    if (a.fRelayTxes != b.fRelayTxes) return a.fRelayTxes;\n+    if (a.nLastBlockTime != b.nLastBlockTime) return a.nLastBlockTime < b.nLastBlockTime;\n+    if (a.fRelevantServices != b.fRelevantServices) return b.fRelevantServices;\n+    return a.nTimeConnected > b.nTimeConnected;\n+}\n \n //! Sort an array by the specified comparator, then erase the last K elements.\n template<typename T, typename Comparator>\n@@ -891,7 +906,7 @@ bool CConnman::AttemptToEvictConnection()\n                                                node->nLastBlockTime, node->nLastTXTime,\n                                                HasAllDesirableServiceFlags(node->nServices),\n                                                peer_relay_txes, peer_filter_not_null, node->addr, node->nKeyedNetGroup,\n-                                               node->m_prefer_evict};\n+                                               node->m_prefer_evict, node->addr.IsLocal()};\n             vEvictionCandidates.push_back(candidate);\n         }\n     }\n@@ -907,12 +922,31 @@ bool CConnman::AttemptToEvictConnection()\n     // Protect 4 nodes that most recently sent us novel transactions accepted into our mempool.\n     // An attacker cannot manipulate this metric without performing useful work.\n     EraseLastKElements(vEvictionCandidates, CompareNodeTXTime, 4);\n+    // Protect up to 8 non-tx-relay peers that have sent us novel blocks.\n+    std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), CompareNodeBlockRelayOnlyTime);\n+    size_t erase_size = std::min(size_t(8), vEvictionCandidates.size());\n+    vEvictionCandidates.erase(std::remove_if(vEvictionCandidates.end() - erase_size, vEvictionCandidates.end(), [](NodeEvictionCandidate const &n) { return !n.fRelayTxes && n.fRelevantServices; }), vEvictionCandidates.end());\n+\n     // Protect 4 nodes that most recently sent us novel blocks.\n     // An attacker cannot manipulate this metric without performing useful work.\n     EraseLastKElements(vEvictionCandidates, CompareNodeBlockTime, 4);\n+\n     // Protect the half of the remaining nodes which have been connected the longest.\n     // This replicates the non-eviction implicit behavior, and precludes attacks that start later.\n-    EraseLastKElements(vEvictionCandidates, ReverseCompareNodeTimeConnected, vEvictionCandidates.size() / 2);\n+    // Reserve half of these protected spots for localhost peers, even if\n+    // they're not longest-uptime overall. This helps protect tor peers, which\n+    // tend to be otherwise disadvantaged under our eviction criteria.\n+    size_t initial_size = vEvictionCandidates.size();\n+    size_t total_protect_size = initial_size / 2;\n+\n+    // Pick out up to 1/4 peers that are localhost, sorted by longest uptime.\n+    std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), CompareLocalHostTimeConnected);\n+    size_t local_erase_size = total_protect_size / 2;\n+    vEvictionCandidates.erase(std::remove_if(vEvictionCandidates.end() - local_erase_size, vEvictionCandidates.end(), [](NodeEvictionCandidate const &n) { return n.m_is_local; }), vEvictionCandidates.end());\n+    // Calculate how many we removed, and update our total number of peers that\n+    // we want to protect based on uptime accordingly.\n+    total_protect_size -= initial_size - vEvictionCandidates.size();\n+    EraseLastKElements(vEvictionCandidates, ReverseCompareNodeTimeConnected, total_protect_size);\n \n     if (vEvictionCandidates.empty()) return false;\n "
      }
    ]
  }
]