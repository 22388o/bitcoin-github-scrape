sdaftuar,2020-08-05 19:00:07,"This should fix #19500, but I need to figure out how to test this...",https://github.com/bitcoin/bitcoin/pull/19670#issuecomment-669408329,669408329,
practicalswift,2020-08-06 08:49:28,Concept ACK (modulo proper testing of course :)),https://github.com/bitcoin/bitcoin/pull/19670#issuecomment-669800157,669800157,
naumenkogs,2020-08-06 10:21:05,Concept ACK.,https://github.com/bitcoin/bitcoin/pull/19670#issuecomment-669844501,669844501,
instagibbs,2020-08-06 15:47:57,@wtogami ,https://github.com/bitcoin/bitcoin/pull/19670#issuecomment-670011410,670011410,
sdaftuar,2020-08-06 16:18:33,"Updated to fix two bugs I discovered, and I did some light manual testing and verified that this seems to now do what is intended.",https://github.com/bitcoin/bitcoin/pull/19670#issuecomment-670029755,670029755,
ghost,2020-08-06 22:47:11,@sdaftuar I've boldly copied all the changes to `net.cpp` and recompiled/rebuild `bitcoind` (0.20.0). I will report back if it solves my issue but that will take some time (a few weeks or longer).,https://github.com/bitcoin/bitcoin/pull/19670#issuecomment-670228200,670228200,
gmaxwell,2020-08-14 02:12:06,ACK ec4ee3fd7e9d0a8572c5e29404820bf5899b203a,https://github.com/bitcoin/bitcoin/pull/19670#issuecomment-673844477,673844477,
sdaftuar,2020-08-28 21:40:53,Anything left here?  From #19500 it seems this fixes the user's issue.,https://github.com/bitcoin/bitcoin/pull/19670#issuecomment-683158811,683158811,
naumenkogs,2020-09-01 07:50:57,ACK ec4ee3f,https://github.com/bitcoin/bitcoin/pull/19670#issuecomment-684525794,684525794,
DrahtBot,2020-09-01 19:01:03,<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nNo conflicts as of last run.,https://github.com/bitcoin/bitcoin/pull/19670#issuecomment-685071090,685071090,
laanwj,2020-09-03 14:43:29,"I think this strategy makes sense.\nCode review ACK 752e6ad5336d5af0db9fe16d24c0c6aa25b74a3f\n",https://github.com/bitcoin/bitcoin/pull/19670#issuecomment-686541063,686541063,
sdaftuar,2020-08-05 20:45:11,"@gmaxwell I should get rid of this `n.nLastBlockTime > 0` right?  So that we'll always protect up to 8 non-tx-relay peers, even if they haven't managed to be first to send us a block.  But perhaps I should only protect them if `fRelevantServices` is true, so that non-full nodes do not get protected here?",https://github.com/bitcoin/bitcoin/pull/19670#discussion_r465993080,465993080,src/net.cpp
gmaxwell,2020-08-05 21:12:38,I think requring fRelevantServices makes sense.  I think it's not import to require that they sent a block-- helping them stay connected so long as they (claim they) could might help keep them around long enough to successfully do so.,https://github.com/bitcoin/bitcoin/pull/19670#discussion_r466007029,466007029,src/net.cpp
sdaftuar,2020-08-06 01:01:38,"Fixed, thanks.",https://github.com/bitcoin/bitcoin/pull/19670#discussion_r466085368,466085368,src/net.cpp
jnewbery,2020-08-06 10:20:37,"If this PR was built on top of #19316, you could test directly for block-relay-only peers. I think that'd be a cleaner implementation.",https://github.com/bitcoin/bitcoin/pull/19670#discussion_r466313982,466313982,src/net.cpp
sdaftuar,2020-08-06 11:41:25,"We donâ€™t currently have a way in our codebase to know that an inbound peer is blocks-only; that is a concept we can only know for outbound peers. We can infer it for inbound peers, as this PR does, but the right way to do this in the future would be to negotiate it at startup, so both sides know that a connection will stay blocks only.\n\nI believe that PR is only cleaning things up for outbound",https://github.com/bitcoin/bitcoin/pull/19670#discussion_r466352570,466352570,src/net.cpp
ariard,2020-08-06 12:06:53,"`nLastBlockTime` is updated at `ProcessNewBlock` return if the process block is new to us and connecting on our best chain, among other yardsticks. An attacker-controlled inbound connection by always being the fastest to announce block to us can trump other honest block-relay-only inbound to prevent update of their `nLastBlockTime`. I think assuming a malicious peer can be always the fastest is re",https://github.com/bitcoin/bitcoin/pull/19670#discussion_r466364701,466364701,src/net.cpp
jnewbery,2020-08-06 12:51:03,"Yes, you're right. 19316 only changes things for outbound peers.",https://github.com/bitcoin/bitcoin/pull/19670#discussion_r466388318,466388318,src/net.cpp
sdaftuar,2020-08-06 13:50:05,"You're right about the code and behavior -- an adversary that is trying to be well-behaved by being the first to deliver blocks to us, from 8 different block-relay peers, can indeed take over this protection -- but randomly choosing among block-relay-only peers is not helpful protection.  If we choose randomly each time, an attacker can game that by merely spamming us with inbound connections unti",https://github.com/bitcoin/bitcoin/pull/19670#discussion_r466426527,466426527,src/net.cpp
sdaftuar,2020-08-06 13:56:49,"> So maybe a poor criteria would be one where an attacker does useful work for us once and then can misbehave but still take over most or all of our protected spots. I don't think that's what is happening here (arguably, earliest connection time has the risk of an attacker being able to take it over, eventually -- but the first sort is on most-recently-gave-us-a-block, so an attacker would have to",https://github.com/bitcoin/bitcoin/pull/19670#discussion_r466431403,466431403,src/net.cpp
sdaftuar,2020-08-06 15:50:31,"I discovered that doing `IsLocal(node->addr)` is different from `node->addr.IsLocal()`, and the latter appears to be correct, but if someone can confirm that this captures the right idea I'd appreciate it. ",https://github.com/bitcoin/bitcoin/pull/19670#discussion_r466511844,466511844,src/net.cpp
ariard,2020-08-06 16:54:47,"Yes, after writing this, I realized thinking further that my counter-proposal wasn't worthy it. As you hinted, analyzing eviction as a serie of interdependent events means sooner or latter, an attacker still has a high-chance of success.\n\n>  If we make a mistake and include peers that happen to also be adversaries because they're acting like good peers, that's no worse than if we didn't add th",https://github.com/bitcoin/bitcoin/pull/19670#discussion_r466551170,466551170,src/net.cpp
gmaxwell,2020-08-06 20:40:49,"@ariaid There are, unfortunately, a lot of ""nodes"" that just connect and don't do anything useful.   Reserving slots for zombies that don't even once do something useful isn't very helpful.  Unfortunately the software doesn't really have that much criteria for deciding usefulness and most things you could imagine could be easily faked.  One advantage of favouring many peers that have recently sent",https://github.com/bitcoin/bitcoin/pull/19670#discussion_r466673825,466673825,src/net.cpp
dongcarl,2020-08-06 21:01:41,"Somewhat confusingly:\n\n- `node->addr.IsLocal()` returns true only if `node->addr` is IPv[46] and is in the loopback address ranges\n- `IsLocal(node->addr)` checks whether or not `node->addr` resides in `mapLocalHost`, which tracks our view of addresses we might be referred to externally\n\nSo in this case, I believe your use of `node->addr.IsLocal()` is correct.",https://github.com/bitcoin/bitcoin/pull/19670#discussion_r466684163,466684163,src/net.cpp
gmaxwell,2020-08-06 21:08:57,Yes. addr.IsLocal() is right. IsLocal() ought to be renamed to  IsProbablyMyAddress. :),https://github.com/bitcoin/bitcoin/pull/19670#discussion_r466687565,466687565,src/net.cpp
ariard,2020-08-07 23:43:27,"@gmaxwell thanks for your explanation, I would push your model a bit further, beyond types of peers/goodness, you can classify goodness criterias between themselves, with regards to hardness assumptions on attackers. Some are good-behavioral monitoring (block-delivery, stable connections, ...), other costly-topological-identifier (asmap, net-address), other non-observable ones (netgroup sort, you ",https://github.com/bitcoin/bitcoin/pull/19670#discussion_r467329274,467329274,src/net.cpp
gmaxwell,2020-08-14 02:11:22,"> other non-observable ones (netgroup sort, you could imagine peer nonce sort).\n\nNot sure if it was clear, but the motivation for netgroup diverse peers was also along the lines of trying to restore topology diversity.\n\nMany criteria-- latency, block relay, and tx relay all somewhat favor peers that are geographically close.  So you don't want a situation where most nodes are just incestuo",https://github.com/bitcoin/bitcoin/pull/19670#discussion_r470371927,470371927,src/net.cpp
ariard,2020-08-19 17:26:46,"If you have to modify,  you might change to non-tx-relay peers/`CompareNonTxRelayPeers` as comment above the sort is referring to.",https://github.com/bitcoin/bitcoin/pull/19670#discussion_r473202940,473202940,src/net.cpp
ariard,2020-08-19 17:56:40,You can write it as `size_t total_protect_size = initial_size / 2 - (initial_size - vEvictionCandidates.size())` and thus save one line above. I found this equation expressing better that up to 1/2 remaining peers are protected in function of effectively protected localhost.,https://github.com/bitcoin/bitcoin/pull/19670#discussion_r473220014,473220014,src/net.cpp
sdaftuar,2020-08-28 21:40:24,"I think the way I wrote it makes sense, so not inclined to change this (seems like mostly style and not actually any more or less confusing?).",https://github.com/bitcoin/bitcoin/pull/19670#discussion_r479546414,479546414,src/net.cpp
naumenkogs,2020-09-01 07:48:10,"Considering how easy it is to be the first to announce a block and then launch a rotation right after, I'm not very positive abound this solution.\n\nI acknowledge that finding these criteria is hard though. \nI would suggest ""take all no-tx nodes announced a block within a day, and save the most long-living connections among them"".\n\nIt would still protect from completely fake nodes (no blo",https://github.com/bitcoin/bitcoin/pull/19670#discussion_r480935119,480935119,src/net.cpp
