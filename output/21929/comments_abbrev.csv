MarcoFalke,2021-05-12 15:18:57,"@elichai on *32-bit* you can reproduce this yourself in a few seconds:\n\n```\n$ FUZZ=integer ./src/test/fuzz/fuzz  \nINFO: Seed: 2184836021\nINFO: Loaded 1 modules   (187658 inline 8-bit counters): 187658 [0x584f7ee8, 0x58525bf2), \nINFO: Loaded 1 PC tables (187658 PCs): 187658 [0x58525bf4,0x58694444), \nINFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 by",https://github.com/bitcoin/bitcoin/pull/21929#issuecomment-839858828,839858828,
practicalswift,2021-05-12 21:07:27,"> Hopefully fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=34118\n\nThat URL is not publicly accessible. I think you forgot to make it public :)",https://github.com/bitcoin/bitcoin/pull/21929#issuecomment-840097634,840097634,
MarcoFalke,2021-05-13 07:26:46,"I don't plan to make them public, but instead try to include all relevant information in the pull request itself. A bot will make them public the day after they are fixed.",https://github.com/bitcoin/bitcoin/pull/21929#issuecomment-840375745,840375745,
practicalswift,2021-05-14 08:37:23,"What is the reason that the input file `crash-09ffc420318e63eb4fbb19dffcb8cf4e499f7e5a` triggers the assertion failure under 32-bit only? IIRC the `integer` harness reads fixed width integer types only.\n\nFWIW:\n\n```\n$ uname -o -i\nx86_64 GNU/Linux\n$ echo -n 'CgEAAAP/CgEAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoB9QAAAAAAAAAAAAAAAP+b//8AAH4AAP//AAAAAAAAAAA=' | base64 -d > crash-09ffc42",https://github.com/bitcoin/bitcoin/pull/21929#issuecomment-841102383,841102383,
MarcoFalke,2021-05-14 09:06:51,"> What is the reason that the input file crash-09ffc420318e63eb4fbb19dffcb8cf4e499f7e5a triggers the assertion failure under 32-bit only?\n\nI have no idea, while it might be interesting to know, this isn't relevant to this pull.\n\n* The code paths test code that isn't used in production\n* The code paths test the *wrong* round-trip way\n* There is no reason to believe that *any* bit array ",https://github.com/bitcoin/bitcoin/pull/21929#issuecomment-841117670,841117670,
MarcoFalke,2021-05-14 09:13:14,For example `4288413440` and `4292607744` both represent a float of `-nan`. I have no idea if any or none representations are invalid.,https://github.com/bitcoin/bitcoin/pull/21929#issuecomment-841121170,841121170,
laanwj,2021-05-14 10:12:30,"Though it is somehow surprising to see here (this does nothing with the value, just memcpying), FPU operations are not guaranteed to keep the bit pattern the same. Even if that is just loading a value and storing it again.\n\nTo be honest I wish we could get rid of floating point in the serialization code completely.\n\nAnyhow, ACK fae814c9a6c8ce4822f1fc6b88cfbbde7cc2d49c",https://github.com/bitcoin/bitcoin/pull/21929#issuecomment-841151075,841151075,
practicalswift,2021-05-16 18:48:49,"Post-merge ACK fae814c9a6c8ce4822f1fc6b88cfbbde7cc2d49c\n\nI'd love to understand exactly why the assertion failure is 32-bit only but so far I've been unsuccessful at recreating this issue locally which rules out any in-depth practical investigation.",https://github.com/bitcoin/bitcoin/pull/21929#issuecomment-841859860,841859860,
MarcoFalke,2021-05-16 19:10:39,"This is trivial to reproduce locally:\n\n\n```\n$ cat 1.cpp\n\n#include <cstring>\n#include <iostream>\n\nint main() {\n  uint32_t a{4288413440};\n  float b;\n  std::memcpy(&b, &a, sizeof(a));\n  float c = b;\n  uint32_t d;\n  std::memcpy(&d, &c, sizeof(c));\n  std::cout << b << std::endl;\n  std::cout << a << std::endl;\n  std::cout << d << std::endl;\n}\n\n\n\n$ g++ -m32  ",https://github.com/bitcoin/bitcoin/pull/21929#issuecomment-841862942,841862942,
sipa,2021-05-16 19:13:05,Is it just NaNs that get changed? Because that's not unexpected. For non-NaN it would surprise me ,https://github.com/bitcoin/bitcoin/pull/21929#issuecomment-841863248,841863248,
MarcoFalke,2021-05-16 19:16:21,"I should have printed in order. It is \n\n* `4288413440` -> `-nan` -> `4292607744` (32-bit)\n* `4288413440` -> `-nan` -> `4288413440` (64-bit)",https://github.com/bitcoin/bitcoin/pull/21929#issuecomment-841863720,841863720,
sipa,2021-05-16 19:20:48,"@MarcoFalke This may be a result of 32-bit code using 387 instructions, and 64-bit code using SSE instructions for floating point. They may not behave identically.\n\nIf you're really curious, you could try compiling with -mfpmath=387 in 64-bit mode, or with -mfpath=sse -msse ib 32-bit mode.",https://github.com/bitcoin/bitcoin/pull/21929#issuecomment-841864360,841864360,
practicalswift,2021-05-16 19:29:29,"Thanks @MarcoFalke. I didn't catch that the assertion failure was `g++ -O0` only (in addition to `-m32`).\n\nFWIW:\n\n```\n$ for C in g++ clang++; do\n    for M in 32 64; do\n      for O in 0 1 2 3; do\n        echo ""$C -m${M} -O${O}: ""\n        $C -m${M} -O${O} 1.cpp -o exe\n        ./exe\n        echo\n      done\n    done\n  done\ng++ -m32 -O0:\n-nan\n4288413440\n4292607744\n",https://github.com/bitcoin/bitcoin/pull/21929#issuecomment-841865452,841865452,
MarcoFalke,2021-05-16 19:30:30,"```\n$ g++ -m64 -mfpmath=387  1.cpp -o exe && ./exe \n-nan\n4288413440\n4292607744\n\n\n$ g++ -m32 -mfpmath=sse   1.cpp -o exe && ./exe \ncc1plus: warning: SSE instruction set disabled, using 387 arithmetics\n-nan\n4288413440\n4292607744\n\n\n$ clang++ -m32 -mfpmath=sse   1.cpp -o exe && ./exe \n-nan\n4288413440\n4288413440\n\n",https://github.com/bitcoin/bitcoin/pull/21929#issuecomment-841865586,841865586,
practicalswift,2021-05-16 20:09:01,"Assertion failures:\n\n```\ng++ -m32 -O0 -mfpmath=387: Assertion `ser_float_to_uint32(ser_uint32_to_float(u32)) == u32' failed.\ng++ -m32 -O0 -mfpmath=sse: Assertion `ser_float_to_uint32(ser_uint32_to_float(u32)) == u32' failed.\ng++ -m64 -O0 -mfpmath=387: Assertion `ser_float_to_uint32(ser_uint32_to_float(u32)) == u32' failed.\nclang++ -m32 -O0 -mfpmath=387 -mno-sse: Assertion `ser_float_to",https://github.com/bitcoin/bitcoin/pull/21929#issuecomment-841870670,841870670,
