[
  {
    "sha": "fac3e22b18cd29053bc17065fd75db7b84ba6f40",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYWMzZTIyYjE4Y2QyOTA1M2JjMTcwNjVmZDc1ZGI3Yjg0YmE2ZjQw",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-08-24T19:26:42Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-08-31T14:27:19Z"
      },
      "message": "qa: Read reject reasons from debug log, not p2p messages",
      "tree": {
        "sha": "e1d3be9941db440e645c8fbd9f270fea2a80a90a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e1d3be9941db440e645c8fbd9f270fea2a80a90a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fac3e22b18cd29053bc17065fd75db7b84ba6f40",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGcBAABCgAGBQJbiVBHAAoJEM4rdWl+aaVIOKML/2w3PYxm56q0yzUWDD6y+9SD\n048xjM+QnpECY4iO2FxIuMWACpQ/6MK6kVaqRd+PR3EvLghgdFS/Ipw12GyAAUNW\ndbzn47zrBkZmHmUPck5gu8WPMkiKcm0byXYEmm4MZiuCpWl+WG5aQKqQs1R+oqjp\nVOYSbxNrW4rYUagt/Ryq+YFR6zPPjm7uBfQmMbdevdDagUZb0CJEGvIK+okmZfjn\nJ3TWqDJGI4AyPvYgvSQnPhTWr+NnwTS8JtUhwjLZ8ms5BNoc830x8lwOaj2QNQUa\nEIsIQKJeI+/U2R1uXrgQ9fhNfBRH9jFukrk+PW6bTgUffaU5+6Qa0J1fO/w8H955\nAqqbtq0UoVuBOTu4xeAQscal6wKqrJTy+gP8oax3diwx+Kggo1QhrQwTb7f9egs6\nlCE0EcrK8iAaLo3zm2Vquhi0bZfER0ZC/r/8SDzRz3J512hAxDxeODUZvpcZyBq7\nunyeYP+neiN1gyJDsqd4Nnpd6X/QPO8ZNDuwil1X2w==\n=dT0y\n-----END PGP SIGNATURE-----",
        "payload": "tree e1d3be9941db440e645c8fbd9f270fea2a80a90a\nparent b012bbe358311cc4a73300ccca41b64272250277\nauthor MarcoFalke <falke.marco@gmail.com> 1535138802 -0400\ncommitter MarcoFalke <falke.marco@gmail.com> 1535725639 -0400\n\nqa: Read reject reasons from debug log, not p2p messages\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fac3e22b18cd29053bc17065fd75db7b84ba6f40",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fac3e22b18cd29053bc17065fd75db7b84ba6f40",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fac3e22b18cd29053bc17065fd75db7b84ba6f40/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b012bbe358311cc4a73300ccca41b64272250277",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b012bbe358311cc4a73300ccca41b64272250277",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b012bbe358311cc4a73300ccca41b64272250277"
      }
    ],
    "stats": {
      "total": 329,
      "additions": 138,
      "deletions": 191
    },
    "files": [
      {
        "sha": "40b5c2758037dad235a178cec8258d9321bb77f3",
        "filename": "test/functional/feature_block.py",
        "status": "modified",
        "additions": 40,
        "deletions": 40,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac3e22b18cd29053bc17065fd75db7b84ba6f40/test/functional/feature_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac3e22b18cd29053bc17065fd75db7b84ba6f40/test/functional/feature_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_block.py?ref=fac3e22b18cd29053bc17065fd75db7b84ba6f40",
        "patch": "@@ -169,7 +169,7 @@ def run_test(self):\n         self.log.info(\"Reject a block where the miner creates too much coinbase reward\")\n         self.move_tip(6)\n         b9 = self.next_block(9, spend=out[4], additional_coinbase_value=1)\n-        self.sync_blocks([b9], success=False, reject_code=16, reject_reason=b'bad-cb-amount', reconnect=True)\n+        self.sync_blocks([b9], success=False, reject_reason='bad-cb-amount', reconnect=True)\n \n         # Create a fork that ends in a block with too much fee (the one that causes the reorg)\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -181,7 +181,7 @@ def run_test(self):\n         self.sync_blocks([b10], False)\n \n         b11 = self.next_block(11, spend=out[4], additional_coinbase_value=1)\n-        self.sync_blocks([b11], success=False, reject_code=16, reject_reason=b'bad-cb-amount', reconnect=True)\n+        self.sync_blocks([b11], success=False, reject_reason='bad-cb-amount', reconnect=True)\n \n         # Try again, but with a valid fork first\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -194,7 +194,7 @@ def run_test(self):\n         b13 = self.next_block(13, spend=out[4])\n         self.save_spendable_output()\n         b14 = self.next_block(14, spend=out[5], additional_coinbase_value=1)\n-        self.sync_blocks([b12, b13, b14], success=False, reject_code=16, reject_reason=b'bad-cb-amount', reconnect=True)\n+        self.sync_blocks([b12, b13, b14], success=False, reject_reason='bad-cb-amount', reconnect=True)\n \n         # New tip should be b13.\n         assert_equal(node.getbestblockhash(), b13.hash)\n@@ -213,7 +213,7 @@ def run_test(self):\n         self.log.info(\"Reject a block with too many checksigs\")\n         too_many_checksigs = CScript([OP_CHECKSIG] * (MAX_BLOCK_SIGOPS))\n         b16 = self.next_block(16, spend=out[6], script=too_many_checksigs)\n-        self.sync_blocks([b16], success=False, reject_code=16, reject_reason=b'bad-blk-sigops', reconnect=True)\n+        self.sync_blocks([b16], success=False, reject_reason='bad-blk-sigops', reconnect=True)\n \n         # Attempt to spend a transaction created on a different fork\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -222,7 +222,7 @@ def run_test(self):\n         self.log.info(\"Reject a block with a spend from a re-org'ed out tx\")\n         self.move_tip(15)\n         b17 = self.next_block(17, spend=txout_b3)\n-        self.sync_blocks([b17], success=False, reject_code=16, reject_reason=b'bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b17], success=False, reject_reason='bad-txns-inputs-missingorspent', reconnect=True)\n \n         # Attempt to spend a transaction created on a different fork (on a fork this time)\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -235,7 +235,7 @@ def run_test(self):\n         self.sync_blocks([b18], False)\n \n         b19 = self.next_block(19, spend=out[6])\n-        self.sync_blocks([b19], success=False, reject_code=16, reject_reason=b'bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b19], success=False, reject_reason='bad-txns-inputs-missingorspent', reconnect=True)\n \n         # Attempt to spend a coinbase at depth too low\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -244,7 +244,7 @@ def run_test(self):\n         self.log.info(\"Reject a block spending an immature coinbase.\")\n         self.move_tip(15)\n         b20 = self.next_block(20, spend=out[7])\n-        self.sync_blocks([b20], success=False, reject_code=16, reject_reason=b'bad-txns-premature-spend-of-coinbase')\n+        self.sync_blocks([b20], success=False, reject_reason='bad-txns-premature-spend-of-coinbase')\n \n         # Attempt to spend a coinbase at depth too low (on a fork this time)\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -257,7 +257,7 @@ def run_test(self):\n         self.sync_blocks([b21], False)\n \n         b22 = self.next_block(22, spend=out[5])\n-        self.sync_blocks([b22], success=False, reject_code=16, reject_reason=b'bad-txns-premature-spend-of-coinbase')\n+        self.sync_blocks([b22], success=False, reject_reason='bad-txns-premature-spend-of-coinbase')\n \n         # Create a block on either side of MAX_BLOCK_BASE_SIZE and make sure its accepted/rejected\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -286,7 +286,7 @@ def run_test(self):\n         tx.vout = [CTxOut(0, script_output)]\n         b24 = self.update_block(24, [tx])\n         assert_equal(len(b24.serialize()), MAX_BLOCK_BASE_SIZE + 1)\n-        self.sync_blocks([b24], success=False, reject_code=16, reject_reason=b'bad-blk-length', reconnect=True)\n+        self.sync_blocks([b24], success=False, reject_reason='bad-blk-length', reconnect=True)\n \n         b25 = self.next_block(25, spend=out[7])\n         self.sync_blocks([b25], False)\n@@ -304,7 +304,7 @@ def run_test(self):\n         # update_block causes the merkle root to get updated, even with no new\n         # transactions, and updates the required state.\n         b26 = self.update_block(26, [])\n-        self.sync_blocks([b26], success=False, reject_code=16, reject_reason=b'bad-cb-length', reconnect=True)\n+        self.sync_blocks([b26], success=False, reject_reason='bad-cb-length', reconnect=True)\n \n         # Extend the b26 chain to make sure bitcoind isn't accepting b26\n         b27 = self.next_block(27, spend=out[7])\n@@ -316,7 +316,7 @@ def run_test(self):\n         b28.vtx[0].vin[0].scriptSig = b'\\x00' * 101\n         b28.vtx[0].rehash()\n         b28 = self.update_block(28, [])\n-        self.sync_blocks([b28], success=False, reject_code=16, reject_reason=b'bad-cb-length', reconnect=True)\n+        self.sync_blocks([b28], success=False, reject_reason='bad-cb-length', reconnect=True)\n \n         # Extend the b28 chain to make sure bitcoind isn't accepting b28\n         b29 = self.next_block(29, spend=out[7])\n@@ -352,7 +352,7 @@ def run_test(self):\n         too_many_multisigs = CScript([OP_CHECKMULTISIG] * (MAX_BLOCK_SIGOPS // 20))\n         b32 = self.next_block(32, spend=out[9], script=too_many_multisigs)\n         assert_equal(get_legacy_sigopcount_block(b32), MAX_BLOCK_SIGOPS + 1)\n-        self.sync_blocks([b32], success=False, reject_code=16, reject_reason=b'bad-blk-sigops', reconnect=True)\n+        self.sync_blocks([b32], success=False, reject_reason='bad-blk-sigops', reconnect=True)\n \n         # CHECKMULTISIGVERIFY\n         self.log.info(\"Accept a block with the max number of OP_CHECKMULTISIGVERIFY sigops\")\n@@ -365,7 +365,7 @@ def run_test(self):\n         self.log.info(\"Reject a block with too many OP_CHECKMULTISIGVERIFY sigops\")\n         too_many_multisigs = CScript([OP_CHECKMULTISIGVERIFY] * (MAX_BLOCK_SIGOPS // 20))\n         b34 = self.next_block(34, spend=out[10], script=too_many_multisigs)\n-        self.sync_blocks([b34], success=False, reject_code=16, reject_reason=b'bad-blk-sigops', reconnect=True)\n+        self.sync_blocks([b34], success=False, reject_reason='bad-blk-sigops', reconnect=True)\n \n         # CHECKSIGVERIFY\n         self.log.info(\"Accept a block with the max number of OP_CHECKSIGVERIFY sigops\")\n@@ -378,7 +378,7 @@ def run_test(self):\n         self.log.info(\"Reject a block with too many OP_CHECKSIGVERIFY sigops\")\n         too_many_checksigs = CScript([OP_CHECKSIGVERIFY] * (MAX_BLOCK_SIGOPS))\n         b36 = self.next_block(36, spend=out[11], script=too_many_checksigs)\n-        self.sync_blocks([b36], success=False, reject_code=16, reject_reason=b'bad-blk-sigops', reconnect=True)\n+        self.sync_blocks([b36], success=False, reject_reason='bad-blk-sigops', reconnect=True)\n \n         # Check spending of a transaction in a block which failed to connect\n         #\n@@ -395,12 +395,12 @@ def run_test(self):\n         txout_b37 = b37.vtx[1]\n         tx = self.create_and_sign_transaction(out[11], 0)\n         b37 = self.update_block(37, [tx])\n-        self.sync_blocks([b37], success=False, reject_code=16, reject_reason=b'bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b37], success=False, reject_reason='bad-txns-inputs-missingorspent', reconnect=True)\n \n         # attempt to spend b37's first non-coinbase tx, at which point b37 was still considered valid\n         self.move_tip(35)\n         b38 = self.next_block(38, spend=txout_b37)\n-        self.sync_blocks([b38], success=False, reject_code=16, reject_reason=b'bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b38], success=False, reject_reason='bad-txns-inputs-missingorspent', reconnect=True)\n \n         # Check P2SH SigOp counting\n         #\n@@ -492,7 +492,7 @@ def run_test(self):\n         tx.rehash()\n         new_txs.append(tx)\n         self.update_block(40, new_txs)\n-        self.sync_blocks([b40], success=False, reject_code=16, reject_reason=b'bad-blk-sigops', reconnect=True)\n+        self.sync_blocks([b40], success=False, reject_reason='bad-blk-sigops', reconnect=True)\n \n         # same as b40, but one less sigop\n         self.log.info(\"Accept a block with the max number of P2SH sigops\")\n@@ -555,7 +555,7 @@ def run_test(self):\n         self.block_heights[b45.sha256] = self.block_heights[self.tip.sha256] + 1\n         self.tip = b45\n         self.blocks[45] = b45\n-        self.sync_blocks([b45], success=False, reject_code=16, reject_reason=b'bad-cb-missing', reconnect=True)\n+        self.sync_blocks([b45], success=False, reject_reason='bad-cb-missing', reconnect=True)\n \n         self.log.info(\"Reject a block with no transactions\")\n         self.move_tip(44)\n@@ -570,7 +570,7 @@ def run_test(self):\n         self.tip = b46\n         assert 46 not in self.blocks\n         self.blocks[46] = b46\n-        self.sync_blocks([b46], success=False, reject_code=16, reject_reason=b'bad-blk-length', reconnect=True)\n+        self.sync_blocks([b46], success=False, reject_reason='bad-blk-length', reconnect=True)\n \n         self.log.info(\"Reject a block with invalid work\")\n         self.move_tip(44)\n@@ -593,7 +593,7 @@ def run_test(self):\n         b49 = self.next_block(49)\n         b49.hashMerkleRoot += 1\n         b49.solve()\n-        self.sync_blocks([b49], success=False, reject_code=16, reject_reason=b'bad-txnmrklroot', reconnect=True)\n+        self.sync_blocks([b49], success=False, reject_reason='bad-txnmrklroot', reconnect=True)\n \n         self.log.info(\"Reject a block with incorrect POW limit\")\n         self.move_tip(44)\n@@ -607,15 +607,15 @@ def run_test(self):\n         b51 = self.next_block(51)\n         cb2 = create_coinbase(51, self.coinbase_pubkey)\n         b51 = self.update_block(51, [cb2])\n-        self.sync_blocks([b51], success=False, reject_code=16, reject_reason=b'bad-cb-multiple', reconnect=True)\n+        self.sync_blocks([b51], success=False, reject_reason='bad-cb-multiple', reconnect=True)\n \n         self.log.info(\"Reject a block with duplicate transactions\")\n         # Note: txns have to be in the right position in the merkle tree to trigger this error\n         self.move_tip(44)\n         b52 = self.next_block(52, spend=out[15])\n         tx = self.create_tx(b52.vtx[1], 0, 1)\n         b52 = self.update_block(52, [tx, tx])\n-        self.sync_blocks([b52], success=False, reject_code=16, reject_reason=b'bad-txns-duplicate', reconnect=True)\n+        self.sync_blocks([b52], success=False, reject_reason='bad-txns-duplicate', reconnect=True)\n \n         # Test block timestamps\n         #  -> b31 (8) -> b33 (9) -> b35 (10) -> b39 (11) -> b42 (12) -> b43 (13) -> b53 (14) -> b55 (15)\n@@ -682,7 +682,7 @@ def run_test(self):\n         assert_equal(len(b56.vtx), 3)\n         b56 = self.update_block(56, [tx1])\n         assert_equal(b56.hash, b57.hash)\n-        self.sync_blocks([b56], success=False, reject_code=16, reject_reason=b'bad-txns-duplicate', reconnect=True)\n+        self.sync_blocks([b56], success=False, reject_reason='bad-txns-duplicate', reconnect=True)\n \n         # b57p2 - a good block with 6 tx'es, don't submit until end\n         self.move_tip(55)\n@@ -702,7 +702,7 @@ def run_test(self):\n         assert_equal(b56p2.hash, b57p2.hash)\n         assert_equal(len(b56p2.vtx), 6)\n         b56p2 = self.update_block(\"b56p2\", [tx3, tx4])\n-        self.sync_blocks([b56p2], success=False, reject_code=16, reject_reason=b'bad-txns-duplicate', reconnect=True)\n+        self.sync_blocks([b56p2], success=False, reject_reason='bad-txns-duplicate', reconnect=True)\n \n         self.move_tip(\"57p2\")\n         self.sync_blocks([b57p2], True)\n@@ -727,15 +727,15 @@ def run_test(self):\n         tx.vout.append(CTxOut(0, b\"\"))\n         tx.calc_sha256()\n         b58 = self.update_block(58, [tx])\n-        self.sync_blocks([b58], success=False, reject_code=16, reject_reason=b'bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b58], success=False, reject_reason='bad-txns-inputs-missingorspent', reconnect=True)\n \n         # tx with output value > input value\n         self.log.info(\"Reject a block with a transaction with outputs > inputs\")\n         self.move_tip(57)\n         b59 = self.next_block(59)\n         tx = self.create_and_sign_transaction(out[17], 51 * COIN)\n         b59 = self.update_block(59, [tx])\n-        self.sync_blocks([b59], success=False, reject_code=16, reject_reason=b'bad-txns-in-belowout', reconnect=True)\n+        self.sync_blocks([b59], success=False, reject_reason='bad-txns-in-belowout', reconnect=True)\n \n         # reset to good chain\n         self.move_tip(57)\n@@ -759,7 +759,7 @@ def run_test(self):\n         b61.vtx[0].rehash()\n         b61 = self.update_block(61, [])\n         assert_equal(b60.vtx[0].serialize(), b61.vtx[0].serialize())\n-        self.sync_blocks([b61], success=False, reject_code=16, reject_reason=b'bad-txns-BIP30', reconnect=True)\n+        self.sync_blocks([b61], success=False, reject_reason='bad-txns-BIP30', reconnect=True)\n \n         # Test tx.isFinal is properly rejected (not an exhaustive tx.isFinal test, that should be in data-driven transaction tests)\n         #\n@@ -776,7 +776,7 @@ def run_test(self):\n         assert(tx.vin[0].nSequence < 0xffffffff)\n         tx.calc_sha256()\n         b62 = self.update_block(62, [tx])\n-        self.sync_blocks([b62], success=False, reject_code=16, reject_reason=b'bad-txns-nonfinal')\n+        self.sync_blocks([b62], success=False, reject_reason='bad-txns-nonfinal')\n \n         # Test a non-final coinbase is also rejected\n         #\n@@ -790,7 +790,7 @@ def run_test(self):\n         b63.vtx[0].vin[0].nSequence = 0xDEADBEEF\n         b63.vtx[0].rehash()\n         b63 = self.update_block(63, [])\n-        self.sync_blocks([b63], success=False, reject_code=16, reject_reason=b'bad-txns-nonfinal')\n+        self.sync_blocks([b63], success=False, reject_reason='bad-txns-nonfinal')\n \n         #  This checks that a block with a bloated VARINT between the block_header and the array of tx such that\n         #  the block is > MAX_BLOCK_BASE_SIZE with the bloated varint, but <= MAX_BLOCK_BASE_SIZE without the bloated varint,\n@@ -824,7 +824,7 @@ def run_test(self):\n         tx.vin.append(CTxIn(COutPoint(b64a.vtx[1].sha256, 0)))\n         b64a = self.update_block(\"64a\", [tx])\n         assert_equal(len(b64a.serialize()), MAX_BLOCK_BASE_SIZE + 8)\n-        self.sync_blocks([b64a], success=False, reject_code=1, reject_reason=b'error parsing message')\n+        self.sync_blocks([b64a], success=False, reject_reason='non-canonical ReadCompactSize(): iostream error')\n \n         # bitcoind doesn't disconnect us for sending a bloated block, but if we subsequently\n         # resend the header message, it won't send us the getdata message again. Just\n@@ -866,7 +866,7 @@ def run_test(self):\n         tx1 = self.create_and_sign_transaction(out[20], out[20].vout[0].nValue)\n         tx2 = self.create_and_sign_transaction(tx1, 1)\n         b66 = self.update_block(66, [tx2, tx1])\n-        self.sync_blocks([b66], success=False, reject_code=16, reject_reason=b'bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b66], success=False, reject_reason='bad-txns-inputs-missingorspent', reconnect=True)\n \n         # Attempt to double-spend a transaction created in a block\n         #\n@@ -881,7 +881,7 @@ def run_test(self):\n         tx2 = self.create_and_sign_transaction(tx1, 1)\n         tx3 = self.create_and_sign_transaction(tx1, 2)\n         b67 = self.update_block(67, [tx1, tx2, tx3])\n-        self.sync_blocks([b67], success=False, reject_code=16, reject_reason=b'bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b67], success=False, reject_reason='bad-txns-inputs-missingorspent', reconnect=True)\n \n         # More tests of block subsidy\n         #\n@@ -900,7 +900,7 @@ def run_test(self):\n         b68 = self.next_block(68, additional_coinbase_value=10)\n         tx = self.create_and_sign_transaction(out[20], out[20].vout[0].nValue - 9)\n         b68 = self.update_block(68, [tx])\n-        self.sync_blocks([b68], success=False, reject_code=16, reject_reason=b'bad-cb-amount', reconnect=True)\n+        self.sync_blocks([b68], success=False, reject_reason='bad-cb-amount', reconnect=True)\n \n         self.log.info(\"Accept a block claiming the correct subsidy in the coinbase transaction\")\n         self.move_tip(65)\n@@ -924,7 +924,7 @@ def run_test(self):\n         tx.vin.append(CTxIn(COutPoint(bogus_tx.sha256, 0), b\"\", 0xffffffff))\n         tx.vout.append(CTxOut(1, b\"\"))\n         b70 = self.update_block(70, [tx])\n-        self.sync_blocks([b70], success=False, reject_code=16, reject_reason=b'bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b70], success=False, reject_reason='bad-txns-inputs-missingorspent', reconnect=True)\n \n         # Test accepting an invalid block which has the same hash as a valid one (via merkle tree tricks)\n         #\n@@ -949,7 +949,7 @@ def run_test(self):\n         assert_equal(b72.sha256, b71.sha256)\n \n         self.move_tip(71)\n-        self.sync_blocks([b71], success=False, reject_code=16, reject_reason=b'bad-txns-duplicate', reconnect=True)\n+        self.sync_blocks([b71], success=False, reject_reason='bad-txns-duplicate', reconnect=True)\n \n         self.move_tip(72)\n         self.sync_blocks([b72], True)\n@@ -987,7 +987,7 @@ def run_test(self):\n         tx = self.create_and_sign_transaction(out[22], 1, CScript(a))\n         b73 = self.update_block(73, [tx])\n         assert_equal(get_legacy_sigopcount_block(b73), MAX_BLOCK_SIGOPS + 1)\n-        self.sync_blocks([b73], success=False, reject_code=16, reject_reason=b'bad-blk-sigops', reconnect=True)\n+        self.sync_blocks([b73], success=False, reject_reason='bad-blk-sigops', reconnect=True)\n \n         # b74/75 - if we push an invalid script element, all prevous sigops are counted,\n         #          but sigops after the element are not counted.\n@@ -1011,7 +1011,7 @@ def run_test(self):\n         a[MAX_BLOCK_SIGOPS + 4] = 0xff\n         tx = self.create_and_sign_transaction(out[22], 1, CScript(a))\n         b74 = self.update_block(74, [tx])\n-        self.sync_blocks([b74], success=False, reject_code=16, reject_reason=b'bad-blk-sigops', reconnect=True)\n+        self.sync_blocks([b74], success=False, reject_reason='bad-blk-sigops', reconnect=True)\n \n         self.move_tip(72)\n         b75 = self.next_block(75)\n@@ -1160,7 +1160,7 @@ def run_test(self):\n         b89a = self.next_block(\"89a\", spend=out[32])\n         tx = self.create_tx(tx1, 0, 0, CScript([OP_TRUE]))\n         b89a = self.update_block(\"89a\", [tx])\n-        self.sync_blocks([b89a], success=False, reject_code=16, reject_reason=b'bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b89a], success=False, reject_reason='bad-txns-inputs-missingorspent', reconnect=True)\n \n         self.log.info(\"Test a re-org of one week's worth of blocks (1088 blocks)\")\n \n@@ -1309,11 +1309,11 @@ def reconnect_p2p(self):\n         self.nodes[0].disconnect_p2ps()\n         self.bootstrap_p2p()\n \n-    def sync_blocks(self, blocks, success=True, reject_code=None, reject_reason=None, request_block=True, reconnect=False, timeout=60):\n+    def sync_blocks(self, blocks, success=True, reject_reason=None, request_block=True, reconnect=False, timeout=60):\n         \"\"\"Sends blocks to test node. Syncs and verifies that tip has advanced to most recent block.\n \n         Call with success = False if the tip shouldn't advance to the most recent block.\"\"\"\n-        self.nodes[0].p2p.send_blocks_and_test(blocks, self.nodes[0], success=success, reject_code=reject_code, reject_reason=reject_reason, request_block=request_block, timeout=timeout)\n+        self.nodes[0].p2p.send_blocks_and_test(blocks, self.nodes[0], success=success, reject_reason=reject_reason, request_block=request_block, timeout=timeout, expect_disconnect=reconnect)\n \n         if reconnect:\n             self.reconnect_p2p()"
      },
      {
        "sha": "615b0f8a4aac93a46b1d0494862875bffb6e1ac0",
        "filename": "test/functional/feature_cltv.py",
        "status": "modified",
        "additions": 16,
        "deletions": 23,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac3e22b18cd29053bc17065fd75db7b84ba6f40/test/functional/feature_cltv.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac3e22b18cd29053bc17065fd75db7b84ba6f40/test/functional/feature_cltv.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_cltv.py?ref=fac3e22b18cd29053bc17065fd75db7b84ba6f40",
        "patch": "@@ -10,10 +10,14 @@\n \n from test_framework.blocktools import create_coinbase, create_block, create_transaction\n from test_framework.messages import CTransaction, msg_block, ToHex\n-from test_framework.mininode import mininode_lock, P2PInterface\n+from test_framework.mininode import P2PInterface\n from test_framework.script import CScript, OP_1NEGATE, OP_CHECKLOCKTIMEVERIFY, OP_DROP, CScriptNum\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, bytes_to_hex_str, hex_str_to_bytes, wait_until\n+from test_framework.util import (\n+    assert_equal,\n+    bytes_to_hex_str,\n+    hex_str_to_bytes,\n+)\n \n from io import BytesIO\n \n@@ -51,10 +55,11 @@ def cltv_validate(node, tx, height):\n                                   list(CScript(new_tx.vin[0].scriptSig)))\n     return new_tx\n \n+\n class BIP65Test(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 1\n-        self.extra_args = [['-whitelist=127.0.0.1']]\n+        self.extra_args = [['-whitelist=127.0.0.1', '-par=1']]  # Use only one script thread to get the exact reject reason for testing\n         self.setup_clean_chain = True\n \n     def run_test(self):\n@@ -88,15 +93,11 @@ def run_test(self):\n         block = create_block(tip, create_coinbase(CLTV_HEIGHT), block_time)\n         block.nVersion = 3\n         block.solve()\n-        self.nodes[0].p2p.send_and_ping(msg_block(block))\n-        assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n \n-        wait_until(lambda: \"reject\" in self.nodes[0].p2p.last_message.keys(), lock=mininode_lock)\n-        with mininode_lock:\n-            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].code, REJECT_OBSOLETE)\n-            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].reason, b'bad-version(0x00000003)')\n-            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].data, block.sha256)\n-            del self.nodes[0].p2p.last_message[\"reject\"]\n+        with self.nodes[0].assert_debug_log(expected_msgs=['{}, bad-version(0x00000003)'.format(block.hash)]):\n+            self.nodes[0].p2p.send_and_ping(msg_block(block))\n+            assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n+            self.nodes[0].p2p.sync_with_ping()\n \n         self.log.info(\"Test that invalid-according-to-cltv transactions cannot appear in a block\")\n         block.nVersion = 4\n@@ -118,18 +119,10 @@ def run_test(self):\n         block.hashMerkleRoot = block.calc_merkle_root()\n         block.solve()\n \n-        self.nodes[0].p2p.send_and_ping(msg_block(block))\n-        assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n-\n-        wait_until(lambda: \"reject\" in self.nodes[0].p2p.last_message.keys(), lock=mininode_lock)\n-        with mininode_lock:\n-            assert self.nodes[0].p2p.last_message[\"reject\"].code in [REJECT_INVALID, REJECT_NONSTANDARD]\n-            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].data, block.sha256)\n-            if self.nodes[0].p2p.last_message[\"reject\"].code == REJECT_INVALID:\n-                # Generic rejection when a block is invalid\n-                assert_equal(self.nodes[0].p2p.last_message[\"reject\"].reason, b'block-validation-failed')\n-            else:\n-                assert b'Negative locktime' in self.nodes[0].p2p.last_message[\"reject\"].reason\n+        with self.nodes[0].assert_debug_log(expected_msgs=['CheckInputs on {} failed with non-mandatory-script-verify-flag (Negative locktime)'.format(block.vtx[-1].hash)]):\n+            self.nodes[0].p2p.send_and_ping(msg_block(block))\n+            assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n+            self.nodes[0].p2p.sync_with_ping()\n \n         self.log.info(\"Test that a version 4 block with a valid-according-to-CLTV transaction is accepted\")\n         spendtx = cltv_validate(self.nodes[0], spendtx, CLTV_HEIGHT - 1)"
      },
      {
        "sha": "302cfe4266187873cd423a2149f6e02ae0fd2d50",
        "filename": "test/functional/feature_csv_activation.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac3e22b18cd29053bc17065fd75db7b84ba6f40/test/functional/feature_csv_activation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac3e22b18cd29053bc17065fd75db7b84ba6f40/test/functional/feature_csv_activation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_csv_activation.py?ref=fac3e22b18cd29053bc17065fd75db7b84ba6f40",
        "patch": "@@ -165,11 +165,11 @@ def create_test_block(self, txs, version=536870912):\n         block.solve()\n         return block\n \n-    def sync_blocks(self, blocks, success=True, reject_code=None, reject_reason=None, request_block=True):\n+    def sync_blocks(self, blocks, success=True):\n         \"\"\"Sends blocks to test node. Syncs and verifies that tip has advanced to most recent block.\n \n         Call with success = False if the tip shouldn't advance to the most recent block.\"\"\"\n-        self.nodes[0].p2p.send_blocks_and_test(blocks, self.nodes[0], success=success, reject_code=reject_code, reject_reason=reject_reason, request_block=request_block)\n+        self.nodes[0].p2p.send_blocks_and_test(blocks, self.nodes[0], success=success)\n \n     def run_test(self):\n         self.nodes[0].add_p2p_connection(P2PDataStore())"
      },
      {
        "sha": "6072c5c17810c0536679615016291fc40eb974c8",
        "filename": "test/functional/feature_dersig.py",
        "status": "modified",
        "additions": 15,
        "deletions": 22,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac3e22b18cd29053bc17065fd75db7b84ba6f40/test/functional/feature_dersig.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac3e22b18cd29053bc17065fd75db7b84ba6f40/test/functional/feature_dersig.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_dersig.py?ref=fac3e22b18cd29053bc17065fd75db7b84ba6f40",
        "patch": "@@ -12,7 +12,11 @@\n from test_framework.mininode import mininode_lock, P2PInterface\n from test_framework.script import CScript\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, bytes_to_hex_str, wait_until\n+from test_framework.util import (\n+    assert_equal,\n+    bytes_to_hex_str,\n+    wait_until,\n+)\n \n DERSIG_HEIGHT = 1251\n \n@@ -42,7 +46,7 @@ def unDERify(tx):\n class BIP66Test(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 1\n-        self.extra_args = [['-whitelist=127.0.0.1']]\n+        self.extra_args = [['-whitelist=127.0.0.1', '-par=1', '-enablebip61']]  # Use only one script thread to get the exact reject reason for testing\n         self.setup_clean_chain = True\n \n     def run_test(self):\n@@ -78,15 +82,11 @@ def run_test(self):\n         block.nVersion = 2\n         block.rehash()\n         block.solve()\n-        self.nodes[0].p2p.send_and_ping(msg_block(block))\n-        assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n \n-        wait_until(lambda: \"reject\" in self.nodes[0].p2p.last_message.keys(), lock=mininode_lock)\n-        with mininode_lock:\n-            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].code, REJECT_OBSOLETE)\n-            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].reason, b'bad-version(0x00000002)')\n-            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].data, block.sha256)\n-            del self.nodes[0].p2p.last_message[\"reject\"]\n+        with self.nodes[0].assert_debug_log(expected_msgs=['{}, bad-version(0x00000002)'.format(block.hash)]):\n+            self.nodes[0].p2p.send_and_ping(msg_block(block))\n+            assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n+            self.nodes[0].p2p.sync_with_ping()\n \n         self.log.info(\"Test that transactions with non-DER signatures cannot appear in a block\")\n         block.nVersion = 3\n@@ -109,23 +109,16 @@ def run_test(self):\n         block.rehash()\n         block.solve()\n \n-        self.nodes[0].p2p.send_and_ping(msg_block(block))\n-        assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n+        with self.nodes[0].assert_debug_log(expected_msgs=['CheckInputs on {} failed with non-mandatory-script-verify-flag (Non-canonical DER signature)'.format(block.vtx[-1].hash)]):\n+            self.nodes[0].p2p.send_and_ping(msg_block(block))\n+            assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n+            self.nodes[0].p2p.sync_with_ping()\n \n         wait_until(lambda: \"reject\" in self.nodes[0].p2p.last_message.keys(), lock=mininode_lock)\n         with mininode_lock:\n-            # We can receive different reject messages depending on whether\n-            # bitcoind is running with multiple script check threads. If script\n-            # check threads are not in use, then transaction script validation\n-            # happens sequentially, and bitcoind produces more specific reject\n-            # reasons.\n             assert self.nodes[0].p2p.last_message[\"reject\"].code in [REJECT_INVALID, REJECT_NONSTANDARD]\n             assert_equal(self.nodes[0].p2p.last_message[\"reject\"].data, block.sha256)\n-            if self.nodes[0].p2p.last_message[\"reject\"].code == REJECT_INVALID:\n-                # Generic rejection when a block is invalid\n-                assert_equal(self.nodes[0].p2p.last_message[\"reject\"].reason, b'block-validation-failed')\n-            else:\n-                assert b'Non-canonical DER signature' in self.nodes[0].p2p.last_message[\"reject\"].reason\n+            assert b'Non-canonical DER signature' in self.nodes[0].p2p.last_message[\"reject\"].reason\n \n         self.log.info(\"Test that a version 3 block with a DERSIG-compliant transaction is accepted\")\n         block.vtx[1] = create_transaction(self.nodes[0], self.coinbase_txids[1], self.nodeaddress, amount=1.0)"
      },
      {
        "sha": "b3f4d721f9a6826da142ac78c783c3940bf97af8",
        "filename": "test/functional/p2p_invalid_block.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac3e22b18cd29053bc17065fd75db7b84ba6f40/test/functional/p2p_invalid_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac3e22b18cd29053bc17065fd75db7b84ba6f40/test/functional/p2p_invalid_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_block.py?ref=fac3e22b18cd29053bc17065fd75db7b84ba6f40",
        "patch": "@@ -79,7 +79,7 @@ def run_test(self):\n         assert_equal(orig_hash, block2.rehash())\n         assert(block2_orig.vtx != block2.vtx)\n \n-        node.p2p.send_blocks_and_test([block2], node, success=False, request_block=False, reject_code=16, reject_reason=b'bad-txns-duplicate')\n+        node.p2p.send_blocks_and_test([block2], node, success=False, request_block=False, reject_reason='bad-txns-duplicate')\n \n         self.log.info(\"Test very broken block.\")\n \n@@ -92,7 +92,7 @@ def run_test(self):\n         block3.rehash()\n         block3.solve()\n \n-        node.p2p.send_blocks_and_test([block3], node, success=False, request_block=False, reject_code=16, reject_reason=b'bad-cb-amount')\n+        node.p2p.send_blocks_and_test([block3], node, success=False, request_block=False, reject_reason='bad-cb-amount')\n \n if __name__ == '__main__':\n     InvalidBlockRequestTest().main()"
      },
      {
        "sha": "be0290edfdf992bd94aa76a0763e39aa02bcd8f9",
        "filename": "test/functional/p2p_invalid_tx.py",
        "status": "modified",
        "additions": 2,
        "deletions": 13,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac3e22b18cd29053bc17065fd75db7b84ba6f40/test/functional/p2p_invalid_tx.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac3e22b18cd29053bc17065fd75db7b84ba6f40/test/functional/p2p_invalid_tx.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_tx.py?ref=fac3e22b18cd29053bc17065fd75db7b84ba6f40",
        "patch": "@@ -116,7 +116,8 @@ def run_test(self):\n         assert_equal(2, len(node.getpeerinfo()))  # p2ps[1] is still connected\n \n         self.log.info('Send the withhold tx ... ')\n-        node.p2p.send_txs_and_test([tx_withhold], node, success=True)\n+        with node.assert_debug_log(expected_msgs=[\"bad-txns-in-belowout\"]):\n+            node.p2p.send_txs_and_test([tx_withhold], node, success=True)\n \n         # Transactions that should end up in the mempool\n         expected_mempool = {\n@@ -134,18 +135,6 @@ def run_test(self):\n         wait_until(lambda: 1 == len(node.getpeerinfo()), timeout=12)  # p2ps[1] is no longer connected\n         assert_equal(expected_mempool, set(node.getrawmempool()))\n \n-        # restart node with sending BIP61 messages disabled, check that it disconnects without sending the reject message\n-        self.log.info('Test a transaction that is rejected, with BIP61 disabled')\n-        self.restart_node(0, ['-enablebip61=0', '-persistmempool=0'])\n-        self.reconnect_p2p(num_connections=1)\n-        with node.assert_debug_log(expected_msgs=[\n-                \"{} from peer=0 was not accepted: mandatory-script-verify-flag-failed (Invalid OP_IF construction) (code 16)\".format(tx1.hash),\n-                \"disconnecting peer=0\",\n-        ]):\n-            node.p2p.send_txs_and_test([tx1], node, success=False, expect_disconnect=True)\n-        # send_txs_and_test will have waited for disconnect, so we can safely check that no reject has been received\n-        assert_equal(node.p2p.reject_code_received, None)\n-\n \n if __name__ == '__main__':\n     InvalidTxRequestTest().main()"
      },
      {
        "sha": "51c57e88e04444ca2594ebb910154b5e460fee8d",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 27,
        "deletions": 41,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac3e22b18cd29053bc17065fd75db7b84ba6f40/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac3e22b18cd29053bc17065fd75db7b84ba6f40/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=fac3e22b18cd29053bc17065fd75db7b84ba6f40",
        "patch": "@@ -41,7 +41,6 @@\n from test_framework.mininode import (\n     P2PInterface,\n     mininode_lock,\n-    wait_until,\n )\n from test_framework.script import (\n     CScript,\n@@ -124,32 +123,23 @@ def test_transaction_acceptance(node, p2p, tx, with_witness, accepted, reason=No\n \n     - Submit the transaction over the p2p interface\n     - use the getrawmempool rpc to check for acceptance.\"\"\"\n-    tx_message = msg_tx(tx)\n-    if with_witness:\n-        tx_message = msg_witness_tx(tx)\n-    p2p.send_message(tx_message)\n-    p2p.sync_with_ping()\n-    assert_equal(tx.hash in node.getrawmempool(), accepted)\n-    if (reason is not None and not accepted):\n-        # Check the rejection reason as well.\n-        with mininode_lock:\n-            assert_equal(p2p.last_message[\"reject\"].reason, reason)\n+    reason = [reason] if reason else []\n+    with node.assert_debug_log(expected_msgs=reason):\n+        p2p.send_message(msg_witness_tx(tx) if with_witness else msg_tx(tx))\n+        p2p.sync_with_ping()\n+        assert_equal(tx.hash in node.getrawmempool(), accepted)\n \n def test_witness_block(node, p2p, block, accepted, with_witness=True, reason=None):\n     \"\"\"Send a block to the node and check that it's accepted\n \n     - Submit the block over the p2p interface\n     - use the getbestblockhash rpc to check for acceptance.\"\"\"\n-    if with_witness:\n-        p2p.send_message(msg_witness_block(block))\n-    else:\n-        p2p.send_message(msg_block(block))\n-    p2p.sync_with_ping()\n-    assert_equal(node.getbestblockhash() == block.hash, accepted)\n-    if (reason is not None and not accepted):\n-        # Check the rejection reason as well.\n-        with mininode_lock:\n-            assert_equal(p2p.last_message[\"reject\"].reason, reason)\n+    reason = [reason] if reason else []\n+    with node.assert_debug_log(expected_msgs=reason):\n+        p2p.send_message(msg_witness_block(block) if with_witness else msg_block(block))\n+        p2p.sync_with_ping()\n+        assert_equal(node.getbestblockhash() == block.hash, accepted)\n+\n \n class TestP2PConn(P2PInterface):\n     def __init__(self):\n@@ -349,8 +339,7 @@ def test_unnecessary_witness_before_segwit_activation(self):\n         self.update_witness_block_with_transactions(block, [tx])\n         # Sending witness data before activation is not allowed (anti-spam\n         # rule).\n-        test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n-        wait_until(lambda: 'reject' in self.test_node.last_message and self.test_node.last_message[\"reject\"].reason ==  b\"unexpected-witness\")\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False, reason='unexpected-witness')\n \n         # But it should not be permanently marked bad...\n         # Resend without witness information.\n@@ -497,7 +486,7 @@ def test_v0_outputs_arent_spendable(self):\n         self.update_witness_block_with_transactions(block, [tx])\n         # Verify that segwit isn't activated. A block serialized with witness\n         # should be rejected prior to activation.\n-        test_witness_block(self.nodes[0], self.test_node, block, accepted=False, with_witness=True, reason=b'unexpected-witness')\n+        test_witness_block(self.nodes[0], self.test_node, block, accepted=False, with_witness=True, reason='unexpected-witness')\n         # Now send the block without witness. It should be accepted\n         test_witness_block(self.nodes[0], self.test_node, block, accepted=True, with_witness=False)\n \n@@ -523,7 +512,7 @@ def test_v0_outputs_arent_spendable(self):\n \n             # When the block is serialized with a witness, the block will be rejected because witness\n             # data isn't allowed in blocks that don't commit to witness data.\n-            test_witness_block(self.nodes[0], self.test_node, block, accepted=False, with_witness=True, reason=b'unexpected-witness')\n+            test_witness_block(self.nodes[0], self.test_node, block, accepted=False, with_witness=True, reason='unexpected-witness')\n \n             # When the block is serialized without witness, validation fails because the transaction is\n             # invalid (transactions are always validated with SCRIPT_VERIFY_WITNESS so a segwit v0 transaction\n@@ -1343,9 +1332,9 @@ def test_tx_relay_after_segwit_activation(self):\n \n         # Node will not be blinded to the transaction\n         self.std_node.announce_tx_and_wait_for_getdata(tx3)\n-        test_transaction_acceptance(self.nodes[1], self.std_node, tx3, True, False, b'tx-size')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, tx3, True, False, 'tx-size')\n         self.std_node.announce_tx_and_wait_for_getdata(tx3)\n-        test_transaction_acceptance(self.nodes[1], self.std_node, tx3, True, False, b'tx-size')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, tx3, True, False, 'tx-size')\n \n         # Remove witness stuffing, instead add extra witness push on stack\n         tx3.vout[0] = CTxOut(tx2.vout[0].nValue - 1000, CScript([OP_TRUE, OP_DROP] * 15 + [OP_TRUE]))\n@@ -1454,10 +1443,7 @@ def test_segwit_versions(self):\n         tx3.rehash()\n         # Spending a higher version witness output is not allowed by policy,\n         # even with fRequireStandard=false.\n-        test_transaction_acceptance(self.nodes[0], self.test_node, tx3, with_witness=True, accepted=False)\n-        self.test_node.sync_with_ping()\n-        with mininode_lock:\n-            assert(b\"reserved for soft-fork upgrades\" in self.test_node.last_message[\"reject\"].reason)\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx3, with_witness=True, accepted=False, reason=\"reserved for soft-fork upgrades\")\n \n         # Building a block with the transaction must be valid, however.\n         block = self.build_next_block()\n@@ -1551,7 +1537,7 @@ def test_uncompressed_pubkey(self):\n         tx2.rehash()\n \n         # Should fail policy test.\n-        test_transaction_acceptance(self.nodes[0], self.test_node, tx2, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx2, True, False, 'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n         # But passes consensus.\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx2])\n@@ -1571,7 +1557,7 @@ def test_uncompressed_pubkey(self):\n         sign_p2pk_witness_input(witness_program, tx3, 0, SIGHASH_ALL, tx2.vout[0].nValue, key)\n \n         # Should fail policy test.\n-        test_transaction_acceptance(self.nodes[0], self.test_node, tx3, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx3, True, False, 'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n         # But passes consensus.\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx3])\n@@ -1588,7 +1574,7 @@ def test_uncompressed_pubkey(self):\n         sign_p2pk_witness_input(witness_program, tx4, 0, SIGHASH_ALL, tx3.vout[0].nValue, key)\n \n         # Should fail policy test.\n-        test_transaction_acceptance(self.nodes[0], self.test_node, tx4, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n+        test_transaction_acceptance(self.nodes[0], self.test_node, tx4, True, False, 'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx4])\n         test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n@@ -1825,7 +1811,7 @@ def test_non_standard_witness_blinding(self):\n         tx2.rehash()\n         # This will be rejected due to a policy check:\n         # No witness is allowed, since it is not a witness program but a p2sh program\n-        test_transaction_acceptance(self.nodes[1], self.std_node, tx2, True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, tx2, True, False, 'bad-witness-nonstandard')\n \n         # If we send without witness, it should be accepted.\n         test_transaction_acceptance(self.nodes[1], self.std_node, tx2, False, True)\n@@ -1897,13 +1883,13 @@ def test_non_standard_witness(self):\n         # Testing native P2WSH\n         # Witness stack size, excluding witnessScript, over 100 is non-standard\n         p2wsh_txs[0].wit.vtxinwit[0].scriptWitness.stack = [pad] * 101 + [scripts[0]]\n-        test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[0], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[0], True, False, 'bad-witness-nonstandard')\n         # Non-standard nodes should accept\n         test_transaction_acceptance(self.nodes[0], self.test_node, p2wsh_txs[0], True, True)\n \n         # Stack element size over 80 bytes is non-standard\n         p2wsh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 81] * 100 + [scripts[1]]\n-        test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[1], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[1], True, False, 'bad-witness-nonstandard')\n         # Non-standard nodes should accept\n         test_transaction_acceptance(self.nodes[0], self.test_node, p2wsh_txs[1], True, True)\n         # Standard nodes should accept if element size is not over 80 bytes\n@@ -1917,24 +1903,24 @@ def test_non_standard_witness(self):\n \n         # witnessScript size at 3601 bytes is non-standard\n         p2wsh_txs[3].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, pad, scripts[3]]\n-        test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[3], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2wsh_txs[3], True, False, 'bad-witness-nonstandard')\n         # Non-standard nodes should accept\n         test_transaction_acceptance(self.nodes[0], self.test_node, p2wsh_txs[3], True, True)\n \n         # Repeating the same tests with P2SH-P2WSH\n         p2sh_txs[0].wit.vtxinwit[0].scriptWitness.stack = [pad] * 101 + [scripts[0]]\n-        test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[0], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[0], True, False, 'bad-witness-nonstandard')\n         test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_txs[0], True, True)\n         p2sh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 81] * 100 + [scripts[1]]\n-        test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[1], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[1], True, False, 'bad-witness-nonstandard')\n         test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_txs[1], True, True)\n         p2sh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 80] * 100 + [scripts[1]]\n         test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[1], True, True)\n         p2sh_txs[2].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, scripts[2]]\n         test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_txs[2], True, True)\n         test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[2], True, True)\n         p2sh_txs[3].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, pad, scripts[3]]\n-        test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[3], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[3], True, False, 'bad-witness-nonstandard')\n         test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_txs[3], True, True)\n \n         self.nodes[0].generate(1)  # Mine and clean up the mempool of non-standard node"
      },
      {
        "sha": "f8caa572505f358952ddad91d3f6dc9b05951a27",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 34,
        "deletions": 48,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac3e22b18cd29053bc17065fd75db7b84ba6f40/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac3e22b18cd29053bc17065fd75db7b84ba6f40/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=fac3e22b18cd29053bc17065fd75db7b84ba6f40",
        "patch": "@@ -425,8 +425,6 @@ class P2PDataStore(P2PInterface):\n \n     def __init__(self):\n         super().__init__()\n-        self.reject_code_received = None\n-        self.reject_reason_received = None\n         # store of blocks. key is block hash, value is a CBlock object\n         self.block_store = {}\n         self.last_block_hash = ''\n@@ -477,12 +475,7 @@ def on_getheaders(self, message):\n         if response is not None:\n             self.send_message(response)\n \n-    def on_reject(self, message):\n-        \"\"\"Store reject reason and code for testing.\"\"\"\n-        self.reject_code_received = message.code\n-        self.reject_reason_received = message.reason\n-\n-    def send_blocks_and_test(self, blocks, node, *, success=True, request_block=True, reject_code=None, reject_reason=None, timeout=60):\n+    def send_blocks_and_test(self, blocks, node, *, success=True, request_block=True, reject_reason=None, expect_disconnect=False, timeout=60):\n         \"\"\"Send blocks to test node and test whether the tip advances.\n \n          - add all blocks to our block_store\n@@ -492,66 +485,59 @@ def send_blocks_and_test(self, blocks, node, *, success=True, request_block=True\n            ensure that any getdata messages are responded to\n          - if success is True: assert that the node's tip advances to the most recent block\n          - if success is False: assert that the node's tip doesn't advance\n-         - if reject_code and reject_reason are set: assert that the correct reject message is received\"\"\"\n+         - if reject_reason is set: assert that the correct reject message is logged\"\"\"\n \n         with mininode_lock:\n-            self.reject_code_received = None\n-            self.reject_reason_received = None\n-\n             for block in blocks:\n                 self.block_store[block.sha256] = block\n                 self.last_block_hash = block.sha256\n \n-        self.send_message(msg_headers([CBlockHeader(blocks[-1])]))\n+        reject_reason = [reject_reason] if reject_reason else []\n+        with node.assert_debug_log(expected_msgs=reject_reason):\n+            self.send_message(msg_headers([CBlockHeader(blocks[-1])]))\n \n-        if request_block:\n-            wait_until(lambda: blocks[-1].sha256 in self.getdata_requests, timeout=timeout, lock=mininode_lock)\n+            if request_block:\n+                wait_until(lambda: blocks[-1].sha256 in self.getdata_requests, timeout=timeout, lock=mininode_lock)\n \n-        if success:\n-            wait_until(lambda: node.getbestblockhash() == blocks[-1].hash, timeout=timeout)\n-        else:\n-            assert node.getbestblockhash() != blocks[-1].hash\n+            if expect_disconnect:\n+                self.wait_for_disconnect()\n+            else:\n+                self.sync_with_ping()\n \n-        if reject_code is not None:\n-            wait_until(lambda: self.reject_code_received == reject_code, lock=mininode_lock)\n-        if reject_reason is not None:\n-            wait_until(lambda: self.reject_reason_received == reject_reason, lock=mininode_lock)\n+            if success:\n+                wait_until(lambda: node.getbestblockhash() == blocks[-1].hash, timeout=timeout)\n+            else:\n+                assert node.getbestblockhash() != blocks[-1].hash\n \n-    def send_txs_and_test(self, txs, node, *, success=True, expect_disconnect=False, reject_code=None, reject_reason=None):\n+    def send_txs_and_test(self, txs, node, *, success=True, expect_disconnect=False, reject_reason=None):\n         \"\"\"Send txs to test node and test whether they're accepted to the mempool.\n \n          - add all txs to our tx_store\n          - send tx messages for all txs\n          - if success is True/False: assert that the txs are/are not accepted to the mempool\n          - if expect_disconnect is True: Skip the sync with ping\n-         - if reject_code and reject_reason are set: assert that the correct reject message is received.\"\"\"\n+         - if reject_reason is set: assert that the correct reject message is logged.\"\"\"\n \n         with mininode_lock:\n-            self.reject_code_received = None\n-            self.reject_reason_received = None\n-\n             for tx in txs:\n                 self.tx_store[tx.sha256] = tx\n \n-        for tx in txs:\n-            self.send_message(msg_tx(tx))\n-\n-        if expect_disconnect:\n-            self.wait_for_disconnect()\n-        else:\n-            self.sync_with_ping()\n-\n-        raw_mempool = node.getrawmempool()\n-        if success:\n-            # Check that all txs are now in the mempool\n-            for tx in txs:\n-                assert tx.hash in raw_mempool, \"{} not found in mempool\".format(tx.hash)\n-        else:\n-            # Check that none of the txs are now in the mempool\n+        reject_reason = [reject_reason] if reject_reason else []\n+        with node.assert_debug_log(expected_msgs=reject_reason):\n             for tx in txs:\n-                assert tx.hash not in raw_mempool, \"{} tx found in mempool\".format(tx.hash)\n+                self.send_message(msg_tx(tx))\n \n-        if reject_code is not None:\n-            wait_until(lambda: self.reject_code_received == reject_code, lock=mininode_lock)\n-        if reject_reason is not None:\n-            wait_until(lambda: self.reject_reason_received == reject_reason, lock=mininode_lock)\n+            if expect_disconnect:\n+                self.wait_for_disconnect()\n+            else:\n+                self.sync_with_ping()\n+\n+            raw_mempool = node.getrawmempool()\n+            if success:\n+                # Check that all txs are now in the mempool\n+                for tx in txs:\n+                    assert tx.hash in raw_mempool, \"{} not found in mempool\".format(tx.hash)\n+            else:\n+                # Check that none of the txs are now in the mempool\n+                for tx in txs:\n+                    assert tx.hash not in raw_mempool, \"{} tx found in mempool\".format(tx.hash)"
      }
    ]
  }
]