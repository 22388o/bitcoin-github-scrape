[
  {
    "sha": "7e4758aca4a99b5671d3ed0737876bd9f96dea11",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZTQ3NThhY2E0YTk5YjU2NzFkM2VkMDczNzg3NmJkOWY5NmRlYTEx",
    "commit": {
      "author": {
        "name": "jtimon",
        "email": "jtimon@blockstream.io",
        "date": "2014-08-28T18:32:52Z"
      },
      "committer": {
        "name": "Jorge Tim\u00f3n",
        "email": "jtimon@jtimon.cc",
        "date": "2015-07-04T10:04:53Z"
      },
      "message": "Miner: Refactor: Create GenerateProof(CBlockHeader*) from ScanHash(const CBlockHeader*, uint32_t&, uint256*) and use it in regtest\n\nAlso, stop using multiple threads for mining in with regtest",
      "tree": {
        "sha": "5295c6d04a671da461748a0d37729290bea2aefd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5295c6d04a671da461748a0d37729290bea2aefd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7e4758aca4a99b5671d3ed0737876bd9f96dea11",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7e4758aca4a99b5671d3ed0737876bd9f96dea11",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7e4758aca4a99b5671d3ed0737876bd9f96dea11",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7e4758aca4a99b5671d3ed0737876bd9f96dea11/comments",
    "author": {
      "login": "jtimon",
      "id": 1008458,
      "node_id": "MDQ6VXNlcjEwMDg0NTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1008458?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtimon",
      "html_url": "https://github.com/jtimon",
      "followers_url": "https://api.github.com/users/jtimon/followers",
      "following_url": "https://api.github.com/users/jtimon/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtimon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtimon/subscriptions",
      "organizations_url": "https://api.github.com/users/jtimon/orgs",
      "repos_url": "https://api.github.com/users/jtimon/repos",
      "events_url": "https://api.github.com/users/jtimon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtimon/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jtimon",
      "id": 1008458,
      "node_id": "MDQ6VXNlcjEwMDg0NTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1008458?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtimon",
      "html_url": "https://github.com/jtimon",
      "followers_url": "https://api.github.com/users/jtimon/followers",
      "following_url": "https://api.github.com/users/jtimon/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtimon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtimon/subscriptions",
      "organizations_url": "https://api.github.com/users/jtimon/orgs",
      "repos_url": "https://api.github.com/users/jtimon/repos",
      "events_url": "https://api.github.com/users/jtimon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtimon/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d0a10c1959176eb40c0ec47a56de00820c59066d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0a10c1959176eb40c0ec47a56de00820c59066d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d0a10c1959176eb40c0ec47a56de00820c59066d"
      }
    ],
    "stats": {
      "total": 93,
      "additions": 35,
      "deletions": 58
    },
    "files": [
      {
        "sha": "260d241ca994bfed2735b218d21d662619a9afa7",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 51,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7e4758aca4a99b5671d3ed0737876bd9f96dea11/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7e4758aca4a99b5671d3ed0737876bd9f96dea11/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=7e4758aca4a99b5671d3ed0737876bd9f96dea11",
        "patch": "@@ -365,35 +365,28 @@ void IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int&\n // Internal miner\n //\n \n-//\n-// ScanHash scans nonces looking for a hash with at least some zero bits.\n-// The nonce is usually preserved between calls, but periodically or if the\n-// nonce is 0xffff0000 or above, the block is rebuilt and nNonce starts over at\n-// zero.\n-//\n-bool static ScanHash(const CBlockHeader *pblock, uint32_t& nNonce, uint256 *phash)\n+bool GenerateProof(CBlockHeader* pblock, const Consensus::Params& chainparams)\n {\n     // Write the first 76 bytes of the block header to a double-SHA256 state.\n+    uint256 hash;\n     CHash256 hasher;\n     CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n     ss << *pblock;\n     assert(ss.size() == 80);\n     hasher.Write((unsigned char*)&ss[0], 76);\n \n     while (true) {\n-        nNonce++;\n+        pblock->nNonce++;\n \n         // Write the last 4 bytes of the block header (the nonce) to a copy of\n         // the double-SHA256 state, and compute the result.\n-        CHash256(hasher).Write((unsigned char*)&nNonce, 4).Finalize((unsigned char*)phash);\n+        CHash256(hasher).Write((unsigned char*)&pblock->nNonce, 4).Finalize((unsigned char*)&hash);\n \n-        // Return the nonce if the hash has at least some zero bits,\n-        // caller will check if it has enough to reach the target\n-        if (((uint16_t*)phash)[15] == 0)\n+        if (CheckProofOfWork(hash, pblock->nBits, chainparams))\n             return true;\n \n         // If nothing found after trying for a while, return -1\n-        if ((nNonce & 0xfff) == 0)\n+        if ((pblock->nNonce & 0xfff) == 0)\n             return false;\n     }\n }\n@@ -475,61 +468,39 @@ void static BitcoinMiner(const CChainParams& chainparams)\n             // Search\n             //\n             int64_t nStart = GetTime();\n-            arith_uint256 hashTarget = arith_uint256().SetCompact(pblock->nBits);\n-            uint256 hash;\n-            uint32_t nNonce = 0;\n-            while (true) {\n+            pblock->nNonce = 0;\n+            for (int i=0; i < 1000; i++) {\n                 // Check if something found\n-                if (ScanHash(pblock, nNonce, &hash))\n+                if (GenerateProof(pblock, chainparams.GetConsensus()))\n                 {\n-                    if (UintToArith256(hash) <= hashTarget)\n-                    {\n-                        // Found a solution\n-                        pblock->nNonce = nNonce;\n-                        assert(hash == pblock->GetHash());\n-\n                         SetThreadPriority(THREAD_PRIORITY_NORMAL);\n-                        LogPrintf(\"BitcoinMiner:\\n\");\n-                        LogPrintf(\"proof-of-work found  \\n  hash: %s  \\ntarget: %s\\n\", hash.GetHex(), hashTarget.GetHex());\n+                        LogPrintf(\"BitcoinMiner:\\n proof-of-work found\\n\");\n                         ProcessBlockFound(pblock, chainparams);\n                         SetThreadPriority(THREAD_PRIORITY_LOWEST);\n                         coinbaseScript->KeepScript();\n \n                         // In regression test mode, stop mining after a block is found.\n                         if (chainparams.MineBlocksOnDemand())\n-                            throw boost::thread_interrupted();\n-\n+                            return;\n                         break;\n-                    }\n                 }\n \n                 // Check for stop or if block needs to be rebuilt\n                 boost::this_thread::interruption_point();\n                 // Regtest mode doesn't require peers\n                 if (vNodes.empty() && chainparams.MiningRequiresPeers())\n                     break;\n-                if (nNonce >= 0xffff0000)\n-                    break;\n+                // periodically or after 1000 iterations, the block is rebuilt and nNonce starts over at zero.\n                 if (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && GetTime() - nStart > 60)\n                     break;\n                 if (pindexPrev != chainActive.Tip())\n                     break;\n \n                 // Update nTime every few seconds\n                 UpdateTime(pblock, chainparams.GetConsensus(), pindexPrev);\n-                if (chainparams.GetConsensus().fPowAllowMinDifficultyBlocks)\n-                {\n-                    // Changing pblock->nTime can change work required on testnet:\n-                    hashTarget.SetCompact(pblock->nBits);\n-                }\n             }\n         }\n     }\n-    catch (const boost::thread_interrupted&)\n-    {\n-        LogPrintf(\"BitcoinMiner terminated\\n\");\n-        throw;\n-    }\n     catch (const std::runtime_error &e)\n     {\n         LogPrintf(\"BitcoinMiner runtime error: %s\\n\", e.what());\n@@ -549,17 +520,21 @@ void GenerateBitcoins(bool fGenerate, int nThreads, const CChainParams& chainpar\n             nThreads = GetNumCores();\n     }\n \n-    if (minerThreads != NULL)\n-    {\n-        minerThreads->interrupt_all();\n-        delete minerThreads;\n-        minerThreads = NULL;\n-    }\n-\n     if (nThreads == 0 || !fGenerate)\n         return;\n \n-    minerThreads = new boost::thread_group();\n-    for (int i = 0; i < nThreads; i++)\n-        minerThreads->create_thread(boost::bind(&BitcoinMiner, boost::cref(chainparams)));\n+    if (chainparams.MineBlocksOnDemand()) {\n+        for (int i = 0; i < nThreads; i++)\n+            BitcoinMiner(chainparams);\n+    } else {\n+        if (minerThreads != NULL) {\n+            minerThreads->interrupt_all();\n+            delete minerThreads;\n+            minerThreads = NULL;\n+        }\n+\n+        minerThreads = new boost::thread_group();\n+        for (int i = 0; i < nThreads; i++)\n+            minerThreads->create_thread(boost::bind(&BitcoinMiner, boost::cref(chainparams)));\n+    }\n }"
      },
      {
        "sha": "ca13dad9cdacca84260fd1a85ebaabd557bd5e48",
        "filename": "src/miner.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7e4758aca4a99b5671d3ed0737876bd9f96dea11/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7e4758aca4a99b5671d3ed0737876bd9f96dea11/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=7e4758aca4a99b5671d3ed0737876bd9f96dea11",
        "patch": "@@ -6,6 +6,7 @@\n #ifndef BITCOIN_MINER_H\n #define BITCOIN_MINER_H\n \n+#include \"consensus/params.h\"\n #include \"primitives/block.h\"\n \n #include <stdint.h>\n@@ -24,6 +25,12 @@ struct CBlockTemplate\n     std::vector<int64_t> vTxSigOps;\n };\n \n+/**\n+ * Scans nonces looking for a hash with at least some zero bits.\n+ * If it finds and the block passes CheckProofOfWork, returns\n+ * true. Otherwise it returns false after some tries.\n+ */\n+bool GenerateProof(CBlockHeader* pblock, const Consensus::Params& params);\n /** Run the miner threads */\n void GenerateBitcoins(bool fGenerate, int nThreads, const CChainParams& chainparams);\n /** Generate a new block, without valid proof-of-work */"
      },
      {
        "sha": "c29cada4e81c3a5490d6ed39aa5ba20fba06c8ec",
        "filename": "src/rpcmining.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 7,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7e4758aca4a99b5671d3ed0737876bd9f96dea11/src/rpcmining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7e4758aca4a99b5671d3ed0737876bd9f96dea11/src/rpcmining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcmining.cpp?ref=7e4758aca4a99b5671d3ed0737876bd9f96dea11",
        "patch": "@@ -153,15 +153,10 @@ UniValue generate(const UniValue& params, bool fHelp)\n         if (!pblocktemplate.get())\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"Couldn't create new block\");\n         CBlock *pblock = &pblocktemplate->block;\n-        {\n+        do {\n             LOCK(cs_main);\n             IncrementExtraNonce(pblock, chainActive.Tip(), nExtraNonce);\n-        }\n-        while (!CheckProofOfWork(pblock->GetHash(), pblock->nBits, Params().GetConsensus())) {\n-            // Yes, there is a chance every nonce could fail to satisfy the -regtest\n-            // target -- 1 in 2^(2^32). That ain't gonna happen.\n-            ++pblock->nNonce;\n-        }\n+        } while (!GenerateProof(pblock, Params().GetConsensus()));\n         CValidationState state;\n         if (!ProcessNewBlock(state, NULL, pblock, true, NULL))\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"ProcessNewBlock, block not accepted\");"
      }
    ]
  }
]