[
  {
    "sha": "a04aac493fd564894166d58ed4cdfd9ad4f561cb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphMDRhYWM0OTNmZDU2NDg5NDE2NmQ1OGVkNGNkZmQ5YWQ0ZjU2MWNi",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-03-08T20:48:42Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-03-08T20:54:21Z"
      },
      "message": "validation: Remove extraneous LoadGenesisBlock function prototype\n\nLeftover from last bundle.",
      "tree": {
        "sha": "216045260747bc9cd214a8a3635efc732af0fde1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/216045260747bc9cd214a8a3635efc732af0fde1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a04aac493fd564894166d58ed4cdfd9ad4f561cb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a04aac493fd564894166d58ed4cdfd9ad4f561cb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a04aac493fd564894166d58ed4cdfd9ad4f561cb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a04aac493fd564894166d58ed4cdfd9ad4f561cb/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2067f9e5e89113f514e5d895dcdfa8e73d63c118",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2067f9e5e89113f514e5d895dcdfa8e73d63c118",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2067f9e5e89113f514e5d895dcdfa8e73d63c118"
      }
    ],
    "stats": {
      "total": 3,
      "additions": 1,
      "deletions": 2
    },
    "files": [
      {
        "sha": "512b3062191cb0cc9d8e05877ca59fae708629dc",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a04aac493fd564894166d58ed4cdfd9ad4f561cb/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a04aac493fd564894166d58ed4cdfd9ad4f561cb/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=a04aac493fd564894166d58ed4cdfd9ad4f561cb",
        "patch": "@@ -148,8 +148,6 @@ extern const std::vector<std::string> CHECKLEVEL_DOC;\n FILE* OpenBlockFile(const FlatFilePos &pos, bool fReadOnly = false);\n /** Translation to a filesystem path */\n fs::path GetBlockPosFilename(const FlatFilePos &pos);\n-/** Ensures we have a genesis block in the block tree, possibly writing one to disk. */\n-bool LoadGenesisBlock(const CChainParams& chainparams);\n /** Unload database information */\n void UnloadBlockIndex(CTxMemPool* mempool, ChainstateManager& chainman);\n /** Run instances of script checking worker threads */\n@@ -725,6 +723,7 @@ class CChainState\n     /** Replay blocks that aren't fully applied to the database. */\n     bool ReplayBlocks(const CChainParams& params);\n     bool RewindBlockIndex(const CChainParams& params) LOCKS_EXCLUDED(cs_main);\n+    /** Ensures we have a genesis block in the block tree, possibly writing one to disk. */\n     bool LoadGenesisBlock(const CChainParams& chainparams);\n \n     void PruneBlockIndexCandidates();"
      }
    ]
  },
  {
    "sha": "d0de61b764fc7e9c670b69d8210705da296dd245",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMGRlNjFiNzY0ZmM3ZTljNjcwYjY5ZDgyMTA3MDVkYTI5NmRkMjQ1",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2020-11-05T00:25:46Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-03-08T20:54:31Z"
      },
      "message": "miner: Pass in chainstate to BlockAssembler::CreateNewBlock",
      "tree": {
        "sha": "f77ba3e226caf128dd2cf2a826d87c6ce812376e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f77ba3e226caf128dd2cf2a826d87c6ce812376e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d0de61b764fc7e9c670b69d8210705da296dd245",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0de61b764fc7e9c670b69d8210705da296dd245",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d0de61b764fc7e9c670b69d8210705da296dd245",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0de61b764fc7e9c670b69d8210705da296dd245/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a04aac493fd564894166d58ed4cdfd9ad4f561cb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a04aac493fd564894166d58ed4cdfd9ad4f561cb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a04aac493fd564894166d58ed4cdfd9ad4f561cb"
      }
    ],
    "stats": {
      "total": 12,
      "additions": 10,
      "deletions": 2
    },
    "files": [
      {
        "sha": "e0e5ad41feebc43432c5bcad5c308f3479881794",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 2,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0de61b764fc7e9c670b69d8210705da296dd245/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0de61b764fc7e9c670b69d8210705da296dd245/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=d0de61b764fc7e9c670b69d8210705da296dd245",
        "patch": "@@ -100,6 +100,11 @@ Optional<int64_t> BlockAssembler::m_last_block_num_txs{nullopt};\n Optional<int64_t> BlockAssembler::m_last_block_weight{nullopt};\n \n std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn)\n+{\n+    return CreateNewBlock(::ChainstateActive(), scriptPubKeyIn);\n+}\n+\n+std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(CChainState& chainstate, const CScript& scriptPubKeyIn)\n {\n     int64_t nTimeStart = GetTimeMicros();\n \n@@ -117,7 +122,8 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc\n     pblocktemplate->vTxSigOpsCost.push_back(-1); // updated at end\n \n     LOCK2(cs_main, m_mempool.cs);\n-    CBlockIndex* pindexPrev = ::ChainActive().Tip();\n+    assert(std::addressof(*::ChainActive().Tip()) == std::addressof(*chainstate.m_chain.Tip()));\n+    CBlockIndex* pindexPrev = chainstate.m_chain.Tip();\n     assert(pindexPrev != nullptr);\n     nHeight = pindexPrev->nHeight + 1;\n \n@@ -176,7 +182,8 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc\n     pblocktemplate->vTxSigOpsCost[0] = WITNESS_SCALE_FACTOR * GetLegacySigOpCount(*pblock->vtx[0]);\n \n     BlockValidationState state;\n-    if (!TestBlockValidity(state, chainparams, ::ChainstateActive(), *pblock, pindexPrev, false, false)) {\n+    assert(std::addressof(::ChainstateActive()) == std::addressof(chainstate));\n+    if (!TestBlockValidity(state, chainparams, chainstate, *pblock, pindexPrev, false, false)) {\n         throw std::runtime_error(strprintf(\"%s: TestBlockValidity failed: %s\", __func__, state.ToString()));\n     }\n     int64_t nTime2 = GetTimeMicros();"
      },
      {
        "sha": "95f267e491a2ec1247bb2033bdfd98d24ec2c352",
        "filename": "src/miner.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0de61b764fc7e9c670b69d8210705da296dd245/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0de61b764fc7e9c670b69d8210705da296dd245/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=d0de61b764fc7e9c670b69d8210705da296dd245",
        "patch": "@@ -159,6 +159,7 @@ class BlockAssembler\n \n     /** Construct a new block template with coinbase to scriptPubKeyIn */\n     std::unique_ptr<CBlockTemplate> CreateNewBlock(const CScript& scriptPubKeyIn);\n+    std::unique_ptr<CBlockTemplate> CreateNewBlock(CChainState& chainstate, const CScript& scriptPubKeyIn);\n \n     static Optional<int64_t> m_last_block_num_txs;\n     static Optional<int64_t> m_last_block_weight;"
      }
    ]
  },
  {
    "sha": "46b7f29340acb399fbd2378508a204d8d8ee8fca",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NmI3ZjI5MzQwYWNiMzk5ZmJkMjM3ODUwOGEyMDRkOGQ4ZWU4ZmNh",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2020-11-05T00:34:22Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-03-08T20:54:31Z"
      },
      "message": "scripted-diff: Invoke CreateNewBlock with chainstate\n\n-BEGIN VERIFY SCRIPT-\nfind_regex='(\\.|->)CreateNewBlock\\(' \\\n    && git grep -l -E \"$find_regex\" -- src \\\n        | grep -v '^src/miner\\.\\(cpp\\|h\\)$' \\\n        | xargs sed -i -E 's@'\"$find_regex\"'@\\0::ChainstateActive(), @g'\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "e17aa955131cdeaea851e9b0d435a6ea7165e208",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e17aa955131cdeaea851e9b0d435a6ea7165e208"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/46b7f29340acb399fbd2378508a204d8d8ee8fca",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/46b7f29340acb399fbd2378508a204d8d8ee8fca",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/46b7f29340acb399fbd2378508a204d8d8ee8fca",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/46b7f29340acb399fbd2378508a204d8d8ee8fca/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d0de61b764fc7e9c670b69d8210705da296dd245",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0de61b764fc7e9c670b69d8210705da296dd245",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d0de61b764fc7e9c670b69d8210705da296dd245"
      }
    ],
    "stats": {
      "total": 54,
      "additions": 27,
      "deletions": 27
    },
    "files": [
      {
        "sha": "1f3bf4d016854f20b85fe87db247b8b3fff00132",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46b7f29340acb399fbd2378508a204d8d8ee8fca/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46b7f29340acb399fbd2378508a204d8d8ee8fca/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=46b7f29340acb399fbd2378508a204d8d8ee8fca",
        "patch": "@@ -150,7 +150,7 @@ static UniValue generateBlocks(ChainstateManager& chainman, const CTxMemPool& me\n     UniValue blockHashes(UniValue::VARR);\n     while (nHeight < nHeightEnd && !ShutdownRequested())\n     {\n-        std::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(mempool, Params()).CreateNewBlock(coinbase_script));\n+        std::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(mempool, Params()).CreateNewBlock(::ChainstateActive(), coinbase_script));\n         if (!pblocktemplate.get())\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"Couldn't create new block\");\n         CBlock *pblock = &pblocktemplate->block;\n@@ -358,7 +358,7 @@ static RPCHelpMan generateblock()\n         LOCK(cs_main);\n \n         CTxMemPool empty_mempool;\n-        std::unique_ptr<CBlockTemplate> blocktemplate(BlockAssembler(empty_mempool, chainparams).CreateNewBlock(coinbase_script));\n+        std::unique_ptr<CBlockTemplate> blocktemplate(BlockAssembler(empty_mempool, chainparams).CreateNewBlock(::ChainstateActive(), coinbase_script));\n         if (!blocktemplate) {\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"Couldn't create new block\");\n         }\n@@ -747,7 +747,7 @@ static RPCHelpMan getblocktemplate()\n \n         // Create new block\n         CScript scriptDummy = CScript() << OP_TRUE;\n-        pblocktemplate = BlockAssembler(mempool, Params()).CreateNewBlock(scriptDummy);\n+        pblocktemplate = BlockAssembler(mempool, Params()).CreateNewBlock(::ChainstateActive(), scriptDummy);\n         if (!pblocktemplate)\n             throw JSONRPCError(RPC_OUT_OF_MEMORY, \"Out of memory\");\n "
      },
      {
        "sha": "04da10715f3298a368d620cb19d9d3bf47fabad8",
        "filename": "src/test/blockfilter_index_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46b7f29340acb399fbd2378508a204d8d8ee8fca/src/test/blockfilter_index_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46b7f29340acb399fbd2378508a204d8d8ee8fca/src/test/blockfilter_index_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/blockfilter_index_tests.cpp?ref=46b7f29340acb399fbd2378508a204d8d8ee8fca",
        "patch": "@@ -62,7 +62,7 @@ CBlock BuildChainTestingSetup::CreateBlock(const CBlockIndex* prev,\n     const CScript& scriptPubKey)\n {\n     const CChainParams& chainparams = Params();\n-    std::unique_ptr<CBlockTemplate> pblocktemplate = BlockAssembler(*m_node.mempool, chainparams).CreateNewBlock(scriptPubKey);\n+    std::unique_ptr<CBlockTemplate> pblocktemplate = BlockAssembler(*m_node.mempool, chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey);\n     CBlock& block = pblocktemplate->block;\n     block.hashPrevBlock = prev->GetBlockHash();\n     block.nTime = prev->nTime + 1;"
      },
      {
        "sha": "9acd17c463193ebcdc8dcea26fbd8877ab46c263",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 19,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46b7f29340acb399fbd2378508a204d8d8ee8fca/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46b7f29340acb399fbd2378508a204d8d8ee8fca/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=46b7f29340acb399fbd2378508a204d8d8ee8fca",
        "patch": "@@ -122,7 +122,7 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     uint256 hashHighFeeTx = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(50000).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));\n \n-    std::unique_ptr<CBlockTemplate> pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);\n+    std::unique_ptr<CBlockTemplate> pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey);\n     BOOST_REQUIRE_EQUAL(pblocktemplate->block.vtx.size(), 4U);\n     BOOST_CHECK(pblocktemplate->block.vtx[1]->GetHash() == hashParentTx);\n     BOOST_CHECK(pblocktemplate->block.vtx[2]->GetHash() == hashHighFeeTx);\n@@ -143,7 +143,7 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     tx.vout[0].nValue = 5000000000LL - 1000 - 50000 - feeToUse;\n     uint256 hashLowFeeTx = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(feeToUse).FromTx(tx));\n-    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);\n+    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey);\n     // Verify that the free tx and the low fee tx didn't get selected\n     for (size_t i=0; i<pblocktemplate->block.vtx.size(); ++i) {\n         BOOST_CHECK(pblocktemplate->block.vtx[i]->GetHash() != hashFreeTx);\n@@ -157,7 +157,7 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     tx.vout[0].nValue -= 2; // Now we should be just over the min relay fee\n     hashLowFeeTx = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(feeToUse+2).FromTx(tx));\n-    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);\n+    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey);\n     BOOST_REQUIRE_EQUAL(pblocktemplate->block.vtx.size(), 6U);\n     BOOST_CHECK(pblocktemplate->block.vtx[4]->GetHash() == hashFreeTx);\n     BOOST_CHECK(pblocktemplate->block.vtx[5]->GetHash() == hashLowFeeTx);\n@@ -179,7 +179,7 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     tx.vout[0].nValue = 5000000000LL - 100000000 - feeToUse;\n     uint256 hashLowFeeTx2 = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(feeToUse).SpendsCoinbase(false).FromTx(tx));\n-    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);\n+    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey);\n \n     // Verify that this tx isn't selected.\n     for (size_t i=0; i<pblocktemplate->block.vtx.size(); ++i) {\n@@ -192,7 +192,7 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     tx.vin[0].prevout.n = 1;\n     tx.vout[0].nValue = 100000000 - 10000; // 10k satoshi fee\n     m_node.mempool->addUnchecked(entry.Fee(10000).FromTx(tx));\n-    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);\n+    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey);\n     BOOST_REQUIRE_EQUAL(pblocktemplate->block.vtx.size(), 9U);\n     BOOST_CHECK(pblocktemplate->block.vtx[8]->GetHash() == hashLowFeeTx2);\n }\n@@ -215,7 +215,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     fCheckpointsEnabled = false;\n \n     // Simple block creation, nothing special yet:\n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));\n \n     // We can't make transactions until we have inputs\n     // Therefore, load 110 blocks :)\n@@ -252,7 +252,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     LOCK(m_node.mempool->cs);\n \n     // Just to make sure we can still make simple blocks\n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));\n \n     const CAmount BLOCKSUBSIDY = 50*COIN;\n     const CAmount LOWFEE = CENT;\n@@ -277,7 +277,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         tx.vin[0].prevout.hash = hash;\n     }\n \n-    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"bad-blk-sigops\"));\n+    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey), std::runtime_error, HasReason(\"bad-blk-sigops\"));\n     m_node.mempool->clear();\n \n     tx.vin[0].prevout.hash = txFirst[0]->GetHash();\n@@ -291,7 +291,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).SigOpsCost(80).FromTx(tx));\n         tx.vin[0].prevout.hash = hash;\n     }\n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));\n     m_node.mempool->clear();\n \n     // block size > limit\n@@ -311,13 +311,13 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).FromTx(tx));\n         tx.vin[0].prevout.hash = hash;\n     }\n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));\n     m_node.mempool->clear();\n \n     // orphan in *m_node.mempool, template creation fails\n     hash = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).FromTx(tx));\n-    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"bad-txns-inputs-missingorspent\"));\n+    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey), std::runtime_error, HasReason(\"bad-txns-inputs-missingorspent\"));\n     m_node.mempool->clear();\n \n     // child with higher feerate than parent\n@@ -334,7 +334,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vout[0].nValue = tx.vout[0].nValue+BLOCKSUBSIDY-HIGHERFEE; //First txn output + fresh coinbase - new txn fee\n     hash = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(HIGHERFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));\n     m_node.mempool->clear();\n \n     // coinbase in *m_node.mempool, template creation fails\n@@ -346,7 +346,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     // give it a fee so it'll get mined\n     m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));\n     // Should throw bad-cb-multiple\n-    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"bad-cb-multiple\"));\n+    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey), std::runtime_error, HasReason(\"bad-cb-multiple\"));\n     m_node.mempool->clear();\n \n     // double spend txn pair in *m_node.mempool, template creation fails\n@@ -359,7 +359,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vout[0].scriptPubKey = CScript() << OP_2;\n     hash = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(HIGHFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n-    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"bad-txns-inputs-missingorspent\"));\n+    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey), std::runtime_error, HasReason(\"bad-txns-inputs-missingorspent\"));\n     m_node.mempool->clear();\n \n     // subsidy changing\n@@ -375,7 +375,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         next->BuildSkip();\n         ::ChainActive().SetTip(next);\n     }\n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));\n     // Extend to a 210000-long block chain.\n     while (::ChainActive().Tip()->nHeight < 210000) {\n         CBlockIndex* prev = ::ChainActive().Tip();\n@@ -387,7 +387,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         next->BuildSkip();\n         ::ChainActive().SetTip(next);\n     }\n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));\n \n     // invalid p2sh txn in *m_node.mempool, template creation fails\n     tx.vin[0].prevout.hash = txFirst[0]->GetHash();\n@@ -404,7 +404,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     hash = tx.GetHash();\n     m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));\n     // Should throw block-validation-failed\n-    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"block-validation-failed\"));\n+    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey), std::runtime_error, HasReason(\"block-validation-failed\"));\n     m_node.mempool->clear();\n \n     // Delete the dummy blocks again.\n@@ -492,7 +492,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vin[0].nSequence = CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG | 1;\n     BOOST_CHECK(!TestSequenceLocks(CTransaction(tx), flags)); // Sequence locks fail\n \n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));\n \n     // None of the of the absolute height/time locked tx should have made\n     // it into the template because we still check IsFinalTx in CreateNewBlock,\n@@ -505,7 +505,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     ::ChainActive().Tip()->nHeight++;\n     SetMockTime(::ChainActive().Tip()->GetMedianTimePast() + 1);\n \n-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));\n     BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 5U);\n \n     ::ChainActive().Tip()->nHeight--;"
      },
      {
        "sha": "ba1edba0ae3288d80dbca47d3aaf2a20fbd41e17",
        "filename": "src/test/util/mining.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46b7f29340acb399fbd2378508a204d8d8ee8fca/src/test/util/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46b7f29340acb399fbd2378508a204d8d8ee8fca/src/test/util/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/mining.cpp?ref=46b7f29340acb399fbd2378508a204d8d8ee8fca",
        "patch": "@@ -42,7 +42,7 @@ std::shared_ptr<CBlock> PrepareBlock(const NodeContext& node, const CScript& coi\n {\n     auto block = std::make_shared<CBlock>(\n         BlockAssembler{*Assert(node.mempool), Params()}\n-            .CreateNewBlock(coinbase_scriptPubKey)\n+            .CreateNewBlock(::ChainstateActive(), coinbase_scriptPubKey)\n             ->block);\n \n     LOCK(cs_main);"
      },
      {
        "sha": "50c80b7dc6ac027a94cbfc5273a194cc4baa7fbf",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46b7f29340acb399fbd2378508a204d8d8ee8fca/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46b7f29340acb399fbd2378508a204d8d8ee8fca/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=46b7f29340acb399fbd2378508a204d8d8ee8fca",
        "patch": "@@ -245,7 +245,7 @@ CBlock TestChain100Setup::CreateAndProcessBlock(const std::vector<CMutableTransa\n {\n     const CChainParams& chainparams = Params();\n     CTxMemPool empty_pool;\n-    CBlock block = BlockAssembler(empty_pool, chainparams).CreateNewBlock(scriptPubKey)->block;\n+    CBlock block = BlockAssembler(empty_pool, chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey)->block;\n \n     Assert(block.vtx.size() == 1);\n     for (const CMutableTransaction& tx : txns) {"
      },
      {
        "sha": "f3fc83078f9ac2b2fae4f138ec0e16b00d59e0e5",
        "filename": "src/test/validation_block_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46b7f29340acb399fbd2378508a204d8d8ee8fca/src/test/validation_block_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46b7f29340acb399fbd2378508a204d8d8ee8fca/src/test/validation_block_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_block_tests.cpp?ref=46b7f29340acb399fbd2378508a204d8d8ee8fca",
        "patch": "@@ -63,7 +63,7 @@ std::shared_ptr<CBlock> MinerTestingSetup::Block(const uint256& prev_hash)\n     static int i = 0;\n     static uint64_t time = Params().GenesisBlock().nTime;\n \n-    auto ptemplate = BlockAssembler(*m_node.mempool, Params()).CreateNewBlock(CScript{} << i++ << OP_TRUE);\n+    auto ptemplate = BlockAssembler(*m_node.mempool, Params()).CreateNewBlock(::ChainstateActive(), CScript{} << i++ << OP_TRUE);\n     auto pblock = std::make_shared<CBlock>(ptemplate->block);\n     pblock->hashPrevBlock = prev_hash;\n     pblock->nTime = ++time;\n@@ -325,7 +325,7 @@ BOOST_AUTO_TEST_CASE(witness_commitment_index)\n {\n     CScript pubKey;\n     pubKey << 1 << OP_TRUE;\n-    auto ptemplate = BlockAssembler(*m_node.mempool, Params()).CreateNewBlock(pubKey);\n+    auto ptemplate = BlockAssembler(*m_node.mempool, Params()).CreateNewBlock(::ChainstateActive(), pubKey);\n     CBlock pblock = ptemplate->block;\n \n     CTxOut witness;"
      }
    ]
  },
  {
    "sha": "2afcf24408b4453e4418ebfb326b141f6ea8647c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyYWZjZjI0NDA4YjQ0NTNlNDQxOGViZmIzMjZiMTQxZjZlYTg2NDdj",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2020-12-18T20:46:16Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-03-08T20:54:31Z"
      },
      "message": "miner: Remove old CreateNewBlock w/o chainstate param",
      "tree": {
        "sha": "5806ddfdacae5b9764c2859d35386122a77e5f17",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5806ddfdacae5b9764c2859d35386122a77e5f17"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2afcf24408b4453e4418ebfb326b141f6ea8647c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2afcf24408b4453e4418ebfb326b141f6ea8647c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2afcf24408b4453e4418ebfb326b141f6ea8647c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2afcf24408b4453e4418ebfb326b141f6ea8647c/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "46b7f29340acb399fbd2378508a204d8d8ee8fca",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/46b7f29340acb399fbd2378508a204d8d8ee8fca",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/46b7f29340acb399fbd2378508a204d8d8ee8fca"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 0,
      "deletions": 6
    },
    "files": [
      {
        "sha": "444edb697637d2bba56f47a2028658dab4d39815",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2afcf24408b4453e4418ebfb326b141f6ea8647c/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2afcf24408b4453e4418ebfb326b141f6ea8647c/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=2afcf24408b4453e4418ebfb326b141f6ea8647c",
        "patch": "@@ -99,11 +99,6 @@ void BlockAssembler::resetBlock()\n Optional<int64_t> BlockAssembler::m_last_block_num_txs{nullopt};\n Optional<int64_t> BlockAssembler::m_last_block_weight{nullopt};\n \n-std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn)\n-{\n-    return CreateNewBlock(::ChainstateActive(), scriptPubKeyIn);\n-}\n-\n std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(CChainState& chainstate, const CScript& scriptPubKeyIn)\n {\n     int64_t nTimeStart = GetTimeMicros();"
      },
      {
        "sha": "9cbec35cc5e023db8a53884d7c88eb6a050d98c8",
        "filename": "src/miner.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2afcf24408b4453e4418ebfb326b141f6ea8647c/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2afcf24408b4453e4418ebfb326b141f6ea8647c/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=2afcf24408b4453e4418ebfb326b141f6ea8647c",
        "patch": "@@ -158,7 +158,6 @@ class BlockAssembler\n     explicit BlockAssembler(const CTxMemPool& mempool, const CChainParams& params, const Options& options);\n \n     /** Construct a new block template with coinbase to scriptPubKeyIn */\n-    std::unique_ptr<CBlockTemplate> CreateNewBlock(const CScript& scriptPubKeyIn);\n     std::unique_ptr<CBlockTemplate> CreateNewBlock(CChainState& chainstate, const CScript& scriptPubKeyIn);\n \n     static Optional<int64_t> m_last_block_num_txs;"
      }
    ]
  },
  {
    "sha": "2c3ba006930a5bbbf5a33bd530f3c1b2c4103c74",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyYzNiYTAwNjkzMGE1YmJiZjVhMzNiZDUzMGYzYzFiMmM0MTAzYzc0",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2020-10-06T18:20:25Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-03-08T20:54:31Z"
      },
      "message": "miner: Pass in blockman to ::RegenerateCommitments\n\nREQUIRES ATTENTION",
      "tree": {
        "sha": "5bd37554891daf021b07b7cbda15e49d30295e13",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5bd37554891daf021b07b7cbda15e49d30295e13"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2c3ba006930a5bbbf5a33bd530f3c1b2c4103c74",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2c3ba006930a5bbbf5a33bd530f3c1b2c4103c74",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2c3ba006930a5bbbf5a33bd530f3c1b2c4103c74",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2c3ba006930a5bbbf5a33bd530f3c1b2c4103c74/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2afcf24408b4453e4418ebfb326b141f6ea8647c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2afcf24408b4453e4418ebfb326b141f6ea8647c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2afcf24408b4453e4418ebfb326b141f6ea8647c"
      }
    ],
    "stats": {
      "total": 10,
      "additions": 5,
      "deletions": 5
    },
    "files": [
      {
        "sha": "fbaef0f22450dccdcdc0394727a2b6e2c86dc7d5",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2c3ba006930a5bbbf5a33bd530f3c1b2c4103c74/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2c3ba006930a5bbbf5a33bd530f3c1b2c4103c74/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=2c3ba006930a5bbbf5a33bd530f3c1b2c4103c74",
        "patch": "@@ -39,13 +39,13 @@ int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParam\n     return nNewTime - nOldTime;\n }\n \n-void RegenerateCommitments(CBlock& block)\n+void RegenerateCommitments(CBlock& block, BlockManager& blockman)\n {\n     CMutableTransaction tx{*block.vtx.at(0)};\n     tx.vout.erase(tx.vout.begin() + GetWitnessCommitmentIndex(block));\n     block.vtx.at(0) = MakeTransactionRef(tx);\n \n-    GenerateCoinbaseCommitment(block, WITH_LOCK(cs_main, return g_chainman.m_blockman.LookupBlockIndex(block.hashPrevBlock)), Params().GetConsensus());\n+    GenerateCoinbaseCommitment(block, WITH_LOCK(::cs_main, assert(std::addressof(g_chainman.m_blockman) == std::addressof(blockman)); return blockman.LookupBlockIndex(block.hashPrevBlock)), Params().GetConsensus());\n \n     block.hashMerkleRoot = BlockMerkleRoot(block);\n }"
      },
      {
        "sha": "a67fec6dd89ee163b6e84c359f67490abeba2685",
        "filename": "src/miner.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2c3ba006930a5bbbf5a33bd530f3c1b2c4103c74/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2c3ba006930a5bbbf5a33bd530f3c1b2c4103c74/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=2c3ba006930a5bbbf5a33bd530f3c1b2c4103c74",
        "patch": "@@ -202,6 +202,6 @@ void IncrementExtraNonce(CBlock* pblock, const CBlockIndex* pindexPrev, unsigned\n int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev);\n \n /** Update an old GenerateCoinbaseCommitment from CreateNewBlock after the block txs have changed */\n-void RegenerateCommitments(CBlock& block);\n+void RegenerateCommitments(CBlock& block, BlockManager& blockman);\n \n #endif // BITCOIN_MINER_H"
      },
      {
        "sha": "62b9d1138cad3176aab32ac973e072858a65eb85",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2c3ba006930a5bbbf5a33bd530f3c1b2c4103c74/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2c3ba006930a5bbbf5a33bd530f3c1b2c4103c74/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=2c3ba006930a5bbbf5a33bd530f3c1b2c4103c74",
        "patch": "@@ -369,7 +369,7 @@ static RPCHelpMan generateblock()\n \n     // Add transactions\n     block.vtx.insert(block.vtx.end(), txs.begin(), txs.end());\n-    RegenerateCommitments(block);\n+    RegenerateCommitments(block, WITH_LOCK(::cs_main, return std::ref(g_chainman.m_blockman)));\n \n     {\n         LOCK(cs_main);"
      },
      {
        "sha": "f2174cd0840f7455bf6f38f30c1ce3e6abf4e0d5",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2c3ba006930a5bbbf5a33bd530f3c1b2c4103c74/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2c3ba006930a5bbbf5a33bd530f3c1b2c4103c74/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=2c3ba006930a5bbbf5a33bd530f3c1b2c4103c74",
        "patch": "@@ -251,7 +251,7 @@ CBlock TestChain100Setup::CreateAndProcessBlock(const std::vector<CMutableTransa\n     for (const CMutableTransaction& tx : txns) {\n         block.vtx.push_back(MakeTransactionRef(tx));\n     }\n-    RegenerateCommitments(block);\n+    RegenerateCommitments(block, WITH_LOCK(::cs_main, return std::ref(g_chainman.m_blockman)));\n \n     while (!CheckProofOfWork(block.GetHash(), block.nBits, chainparams.GetConsensus())) ++block.nNonce;\n "
      }
    ]
  },
  {
    "sha": "106bcd4f390137904b5579cfef023fb8a5c8b4b5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMDZiY2Q0ZjM5MDEzNzkwNGI1NTc5Y2ZlZjAyM2ZiOGE1YzhiNGI1",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2020-09-01T20:15:57Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-03-08T20:54:31Z"
      },
      "message": "node/coinstats: Pass in BlockManager to GetUTXOStats",
      "tree": {
        "sha": "7b3e55d2067e347877b4e7ae469ec2d51b1694cb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7b3e55d2067e347877b4e7ae469ec2d51b1694cb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/106bcd4f390137904b5579cfef023fb8a5c8b4b5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/106bcd4f390137904b5579cfef023fb8a5c8b4b5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/106bcd4f390137904b5579cfef023fb8a5c8b4b5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/106bcd4f390137904b5579cfef023fb8a5c8b4b5/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2c3ba006930a5bbbf5a33bd530f3c1b2c4103c74",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2c3ba006930a5bbbf5a33bd530f3c1b2c4103c74",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2c3ba006930a5bbbf5a33bd530f3c1b2c4103c74"
      }
    ],
    "stats": {
      "total": 26,
      "additions": 14,
      "deletions": 12
    },
    "files": [
      {
        "sha": "88bdba595321c9ec6f28f372b39a2b2e913c2cb4",
        "filename": "src/node/coinstats.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 6,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/106bcd4f390137904b5579cfef023fb8a5c8b4b5/src/node/coinstats.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/106bcd4f390137904b5579cfef023fb8a5c8b4b5/src/node/coinstats.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/coinstats.cpp?ref=106bcd4f390137904b5579cfef023fb8a5c8b4b5",
        "patch": "@@ -83,7 +83,7 @@ static void ApplyStats(CCoinsStats& stats, T& hash_obj, const uint256& hash, con\n \n //! Calculate statistics about the unspent transaction output set\n template <typename T>\n-static bool GetUTXOStats(CCoinsView* view, CCoinsStats& stats, T hash_obj, const std::function<void()>& interruption_point)\n+static bool GetUTXOStats(CCoinsView* view, BlockManager& blockman, CCoinsStats& stats, T hash_obj, const std::function<void()>& interruption_point)\n {\n     stats = CCoinsStats();\n     std::unique_ptr<CCoinsViewCursor> pcursor(view->Cursor());\n@@ -92,7 +92,8 @@ static bool GetUTXOStats(CCoinsView* view, CCoinsStats& stats, T hash_obj, const\n     stats.hashBlock = pcursor->GetBestBlock();\n     {\n         LOCK(cs_main);\n-        stats.nHeight = g_chainman.m_blockman.LookupBlockIndex(stats.hashBlock)->nHeight;\n+        assert(std::addressof(g_chainman.m_blockman) == std::addressof(blockman));\n+        stats.nHeight = blockman.LookupBlockIndex(stats.hashBlock)->nHeight;\n     }\n \n     PrepareHash(hash_obj, stats);\n@@ -126,19 +127,19 @@ static bool GetUTXOStats(CCoinsView* view, CCoinsStats& stats, T hash_obj, const\n     return true;\n }\n \n-bool GetUTXOStats(CCoinsView* view, CCoinsStats& stats, CoinStatsHashType hash_type, const std::function<void()>& interruption_point)\n+bool GetUTXOStats(CCoinsView* view, BlockManager& blockman, CCoinsStats& stats, CoinStatsHashType hash_type, const std::function<void()>& interruption_point)\n {\n     switch (hash_type) {\n     case(CoinStatsHashType::HASH_SERIALIZED): {\n         CHashWriter ss(SER_GETHASH, PROTOCOL_VERSION);\n-        return GetUTXOStats(view, stats, ss, interruption_point);\n+        return GetUTXOStats(view, blockman, stats, ss, interruption_point);\n     }\n     case(CoinStatsHashType::MUHASH): {\n         MuHash3072 muhash;\n-        return GetUTXOStats(view, stats, muhash, interruption_point);\n+        return GetUTXOStats(view, blockman, stats, muhash, interruption_point);\n     }\n     case(CoinStatsHashType::NONE): {\n-        return GetUTXOStats(view, stats, nullptr, interruption_point);\n+        return GetUTXOStats(view, blockman, stats, nullptr, interruption_point);\n     }\n     } // no default case, so the compiler can warn about missing cases\n     assert(false);"
      },
      {
        "sha": "83f228aa7ee47e93d2e11d58f54f35785e85303d",
        "filename": "src/node/coinstats.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/106bcd4f390137904b5579cfef023fb8a5c8b4b5/src/node/coinstats.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/106bcd4f390137904b5579cfef023fb8a5c8b4b5/src/node/coinstats.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/coinstats.h?ref=106bcd4f390137904b5579cfef023fb8a5c8b4b5",
        "patch": "@@ -8,6 +8,7 @@\n \n #include <amount.h>\n #include <uint256.h>\n+#include <validation.h>\n \n #include <cstdint>\n #include <functional>\n@@ -36,6 +37,6 @@ struct CCoinsStats\n };\n \n //! Calculate statistics about the unspent transaction output set\n-bool GetUTXOStats(CCoinsView* view, CCoinsStats& stats, const CoinStatsHashType hash_type, const std::function<void()>& interruption_point = {});\n+bool GetUTXOStats(CCoinsView* view, BlockManager& blockman, CCoinsStats& stats, const CoinStatsHashType hash_type, const std::function<void()>& interruption_point = {});\n \n #endif // BITCOIN_NODE_COINSTATS_H"
      },
      {
        "sha": "99182a376724566389387b1662037fa5fa047d6e",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/106bcd4f390137904b5579cfef023fb8a5c8b4b5/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/106bcd4f390137904b5579cfef023fb8a5c8b4b5/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=106bcd4f390137904b5579cfef023fb8a5c8b4b5",
        "patch": "@@ -1073,9 +1073,9 @@ static RPCHelpMan gettxoutsetinfo()\n \n     const CoinStatsHashType hash_type{request.params[0].isNull() ? CoinStatsHashType::HASH_SERIALIZED : ParseHashType(request.params[0].get_str())};\n \n-    CCoinsView* coins_view = WITH_LOCK(cs_main, return &ChainstateActive().CoinsDB());\n+    CCoinsView* coins_view = WITH_LOCK(::cs_main, return &::ChainstateActive().CoinsDB());\n     NodeContext& node = EnsureNodeContext(request.context);\n-    if (GetUTXOStats(coins_view, stats, hash_type, node.rpc_interruption_point)) {\n+    if (GetUTXOStats(coins_view, WITH_LOCK(::cs_main, return std::ref(g_chainman.m_blockman)), stats, hash_type, node.rpc_interruption_point)) {\n         ret.pushKV(\"height\", (int64_t)stats.nHeight);\n         ret.pushKV(\"bestblock\", stats.hashBlock.GetHex());\n         ret.pushKV(\"transactions\", (int64_t)stats.nTransactions);\n@@ -2444,7 +2444,7 @@ UniValue CreateUTXOSnapshot(NodeContext& node, CChainState& chainstate, CAutoFil\n \n         chainstate.ForceFlushStateToDisk();\n \n-        if (!GetUTXOStats(&chainstate.CoinsDB(), stats, CoinStatsHashType::NONE, node.rpc_interruption_point)) {\n+        if (!GetUTXOStats(&chainstate.CoinsDB(), chainstate.m_blockman, stats, CoinStatsHashType::NONE, node.rpc_interruption_point)) {\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"Unable to read UTXO set\");\n         }\n "
      },
      {
        "sha": "d951bda20f2e5a8149061d6641d46a5e711e3314",
        "filename": "src/test/fuzz/coins_view.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/106bcd4f390137904b5579cfef023fb8a5c8b4b5/src/test/fuzz/coins_view.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/106bcd4f390137904b5579cfef023fb8a5c8b4b5/src/test/fuzz/coins_view.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/coins_view.cpp?ref=106bcd4f390137904b5579cfef023fb8a5c8b4b5",
        "patch": "@@ -264,7 +264,7 @@ FUZZ_TARGET_INIT(coins_view, initialize_coins_view)\n                 CCoinsStats stats;\n                 bool expected_code_path = false;\n                 try {\n-                    (void)GetUTXOStats(&coins_view_cache, stats, CoinStatsHashType::HASH_SERIALIZED);\n+                    (void)GetUTXOStats(&coins_view_cache, WITH_LOCK(::cs_main, return std::ref(g_chainman.m_blockman)), stats, CoinStatsHashType::HASH_SERIALIZED);\n                 } catch (const std::logic_error&) {\n                     expected_code_path = true;\n                 }"
      },
      {
        "sha": "0c3aeced9337ee28413b9c79e7cbd6a3328e3634",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/106bcd4f390137904b5579cfef023fb8a5c8b4b5/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/106bcd4f390137904b5579cfef023fb8a5c8b4b5/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=106bcd4f390137904b5579cfef023fb8a5c8b4b5",
        "patch": "@@ -5425,7 +5425,7 @@ bool ChainstateManager::PopulateAndValidateSnapshot(\n     // about the snapshot_chainstate.\n     CCoinsViewDB* snapshot_coinsdb = WITH_LOCK(::cs_main, return &snapshot_chainstate.CoinsDB());\n \n-    if (!GetUTXOStats(snapshot_coinsdb, stats, CoinStatsHashType::HASH_SERIALIZED, breakpoint_fnc)) {\n+    if (!GetUTXOStats(snapshot_coinsdb, WITH_LOCK(::cs_main, return std::ref(m_blockman)), stats, CoinStatsHashType::HASH_SERIALIZED, breakpoint_fnc)) {\n         LogPrintf(\"[snapshot] failed to generate coins stats\\n\");\n         return false;\n     }"
      }
    ]
  },
  {
    "sha": "4cde4a701b8856ac4ec9721b0226dbbfc52a71c3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0Y2RlNGE3MDFiODg1NmFjNGVjOTcyMWIwMjI2ZGJiZmM1MmE3MWMz",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2020-10-14T18:12:04Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-03-08T20:54:31Z"
      },
      "message": "node: Use existing NodeContext",
      "tree": {
        "sha": "204dde198486050f7523d89415d89accf4d05f12",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/204dde198486050f7523d89415d89accf4d05f12"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4cde4a701b8856ac4ec9721b0226dbbfc52a71c3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4cde4a701b8856ac4ec9721b0226dbbfc52a71c3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4cde4a701b8856ac4ec9721b0226dbbfc52a71c3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4cde4a701b8856ac4ec9721b0226dbbfc52a71c3/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "106bcd4f390137904b5579cfef023fb8a5c8b4b5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/106bcd4f390137904b5579cfef023fb8a5c8b4b5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/106bcd4f390137904b5579cfef023fb8a5c8b4b5"
      }
    ],
    "stats": {
      "total": 10,
      "additions": 6,
      "deletions": 4
    },
    "files": [
      {
        "sha": "263dcff6570b86f6c193d647ff2b93b3c0458209",
        "filename": "src/node/coin.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4cde4a701b8856ac4ec9721b0226dbbfc52a71c3/src/node/coin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4cde4a701b8856ac4ec9721b0226dbbfc52a71c3/src/node/coin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/coin.cpp?ref=4cde4a701b8856ac4ec9721b0226dbbfc52a71c3",
        "patch": "@@ -12,7 +12,8 @@ void FindCoins(const NodeContext& node, std::map<COutPoint, Coin>& coins)\n {\n     assert(node.mempool);\n     LOCK2(cs_main, node.mempool->cs);\n-    CCoinsViewCache& chain_view = ::ChainstateActive().CoinsTip();\n+    assert(std::addressof(::ChainstateActive()) == std::addressof(node.chainman->ActiveChainstate()));\n+    CCoinsViewCache& chain_view = node.chainman->ActiveChainstate().CoinsTip();\n     CCoinsViewMemPool mempool_view(&chain_view, *node.mempool);\n     for (auto& coin : coins) {\n         if (!mempool_view.GetCoin(coin.first, coin.second)) {"
      },
      {
        "sha": "97763f4fa2cca7e8ec04b62c5fac825e81d0b140",
        "filename": "src/node/transaction.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4cde4a701b8856ac4ec9721b0226dbbfc52a71c3/src/node/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4cde4a701b8856ac4ec9721b0226dbbfc52a71c3/src/node/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/transaction.cpp?ref=4cde4a701b8856ac4ec9721b0226dbbfc52a71c3",
        "patch": "@@ -39,9 +39,10 @@ TransactionError BroadcastTransaction(NodeContext& node, const CTransactionRef t\n \n     { // cs_main scope\n     LOCK(cs_main);\n+    assert(std::addressof(::ChainstateActive()) == std::addressof(node.chainman->ActiveChainstate()));\n     // If the transaction is already confirmed in the chain, don't do anything\n     // and return early.\n-    CCoinsViewCache &view = ::ChainstateActive().CoinsTip();\n+    CCoinsViewCache &view = node.chainman->ActiveChainstate().CoinsTip();\n     for (size_t o = 0; o < tx->vout.size(); o++) {\n         const Coin& existingCoin = view.AccessCoin(COutPoint(hashTx, o));\n         // IsSpent doesn't mean the coin is spent, it means the output doesn't exist.\n@@ -53,7 +54,7 @@ TransactionError BroadcastTransaction(NodeContext& node, const CTransactionRef t\n         if (max_tx_fee > 0) {\n             // First, call ATMP with test_accept and check the fee. If ATMP\n             // fails here, return error immediately.\n-            const MempoolAcceptResult result = AcceptToMemoryPool(::ChainstateActive(), *node.mempool, tx, false /* bypass_limits */,\n+            const MempoolAcceptResult result = AcceptToMemoryPool(node.chainman->ActiveChainstate(), *node.mempool, tx, false /* bypass_limits */,\n                                                                   true /* test_accept */);\n             if (result.m_result_type != MempoolAcceptResult::ResultType::VALID) {\n                 return HandleATMPError(result.m_state, err_string);\n@@ -62,7 +63,7 @@ TransactionError BroadcastTransaction(NodeContext& node, const CTransactionRef t\n             }\n         }\n         // Try to submit the transaction to the mempool.\n-        const MempoolAcceptResult result = AcceptToMemoryPool(::ChainstateActive(), *node.mempool, tx, false /* bypass_limits */,\n+        const MempoolAcceptResult result = AcceptToMemoryPool(node.chainman->ActiveChainstate(), *node.mempool, tx, false /* bypass_limits */,\n                                                               false /* test_accept */);\n         if (result.m_result_type != MempoolAcceptResult::ResultType::VALID) {\n             return HandleATMPError(result.m_state, err_string);"
      }
    ]
  },
  {
    "sha": "8a1d580b2156268e3ab30f902b3fc9aa87bd2819",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YTFkNTgwYjIxNTYyNjhlM2FiMzBmOTAyYjNmYzlhYTg3YmQyODE5",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2020-12-18T19:24:55Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-03-08T20:54:31Z"
      },
      "message": "node/ifaces: NodeImpl: Use existing NodeContext member",
      "tree": {
        "sha": "a641c0473ffa75118a58d0291256718b46863a0f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a641c0473ffa75118a58d0291256718b46863a0f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8a1d580b2156268e3ab30f902b3fc9aa87bd2819",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8a1d580b2156268e3ab30f902b3fc9aa87bd2819",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8a1d580b2156268e3ab30f902b3fc9aa87bd2819",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8a1d580b2156268e3ab30f902b3fc9aa87bd2819/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4cde4a701b8856ac4ec9721b0226dbbfc52a71c3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4cde4a701b8856ac4ec9721b0226dbbfc52a71c3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4cde4a701b8856ac4ec9721b0226dbbfc52a71c3"
      }
    ],
    "stats": {
      "total": 22,
      "additions": 15,
      "deletions": 7
    },
    "files": [
      {
        "sha": "fd0c4dc2e0ac04e7f5ea6bb5d9d66cf0a8a1e28e",
        "filename": "src/node/interfaces.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 7,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8a1d580b2156268e3ab30f902b3fc9aa87bd2819/src/node/interfaces.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8a1d580b2156268e3ab30f902b3fc9aa87bd2819/src/node/interfaces.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/interfaces.cpp?ref=8a1d580b2156268e3ab30f902b3fc9aa87bd2819",
        "patch": "@@ -182,18 +182,21 @@ class NodeImpl : public Node\n     int getNumBlocks() override\n     {\n         LOCK(::cs_main);\n-        return ::ChainActive().Height();\n+        assert(std::addressof(::ChainActive()) == std::addressof(m_context->chainman->ActiveChain()));\n+        return m_context->chainman->ActiveChain().Height();\n     }\n     uint256 getBestBlockHash() override\n     {\n-        const CBlockIndex* tip = WITH_LOCK(::cs_main, return ::ChainActive().Tip());\n+        assert(std::addressof(::ChainActive()) == std::addressof(m_context->chainman->ActiveChain()));\n+        const CBlockIndex* tip = WITH_LOCK(::cs_main, return m_context->chainman->ActiveChain().Tip());\n         return tip ? tip->GetBlockHash() : Params().GenesisBlock().GetHash();\n     }\n     int64_t getLastBlockTime() override\n     {\n         LOCK(::cs_main);\n-        if (::ChainActive().Tip()) {\n-            return ::ChainActive().Tip()->GetBlockTime();\n+        assert(std::addressof(::ChainActive()) == std::addressof(m_context->chainman->ActiveChain()));\n+        if (m_context->chainman->ActiveChain().Tip()) {\n+            return m_context->chainman->ActiveChain().Tip()->GetBlockTime();\n         }\n         return Params().GenesisBlock().GetBlockTime(); // Genesis block's time of current network\n     }\n@@ -202,11 +205,15 @@ class NodeImpl : public Node\n         const CBlockIndex* tip;\n         {\n             LOCK(::cs_main);\n-            tip = ::ChainActive().Tip();\n+            assert(std::addressof(::ChainActive()) == std::addressof(m_context->chainman->ActiveChain()));\n+            tip = m_context->chainman->ActiveChain().Tip();\n         }\n         return GuessVerificationProgress(Params().TxData(), tip);\n     }\n-    bool isInitialBlockDownload() override { return ::ChainstateActive().IsInitialBlockDownload(); }\n+    bool isInitialBlockDownload() override {\n+        assert(std::addressof(::ChainstateActive()) == std::addressof(m_context->chainman->ActiveChainstate()));\n+        return m_context->chainman->ActiveChainstate().IsInitialBlockDownload();\n+    }\n     bool getReindex() override { return ::fReindex; }\n     bool getImporting() override { return ::fImporting; }\n     void setNetworkActive(bool active) override\n@@ -231,7 +238,8 @@ class NodeImpl : public Node\n     bool getUnspentOutput(const COutPoint& output, Coin& coin) override\n     {\n         LOCK(::cs_main);\n-        return ::ChainstateActive().CoinsTip().GetCoin(output, coin);\n+        assert(std::addressof(::ChainstateActive()) == std::addressof(m_context->chainman->ActiveChainstate()));\n+        return m_context->chainman->ActiveChainstate().CoinsTip().GetCoin(output, coin);\n     }\n     WalletClient& walletClient() override\n     {"
      }
    ]
  },
  {
    "sha": "91c5b68acd12cf7c2b4888d54d8fdd21837b2817",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MWM1YjY4YWNkMTJjZjdjMmI0ODg4ZDU0ZDhmZGQyMTgzN2IyODE3",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2020-12-18T19:30:28Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-03-08T20:54:31Z"
      },
      "message": "node/ifaces: ChainImpl: Use existing NodeContext member",
      "tree": {
        "sha": "c09064e0cb1beb05712ba5c84fb6e04b72b4e1af",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c09064e0cb1beb05712ba5c84fb6e04b72b4e1af"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/91c5b68acd12cf7c2b4888d54d8fdd21837b2817",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/91c5b68acd12cf7c2b4888d54d8fdd21837b2817",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/91c5b68acd12cf7c2b4888d54d8fdd21837b2817",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/91c5b68acd12cf7c2b4888d54d8fdd21837b2817/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8a1d580b2156268e3ab30f902b3fc9aa87bd2819",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8a1d580b2156268e3ab30f902b3fc9aa87bd2819",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8a1d580b2156268e3ab30f902b3fc9aa87bd2819"
      }
    ],
    "stats": {
      "total": 35,
      "additions": 24,
      "deletions": 11
    },
    "files": [
      {
        "sha": "e4b99b7dc237cd8e714fd59fd185caefa23bf507",
        "filename": "src/node/interfaces.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 11,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/91c5b68acd12cf7c2b4888d54d8fdd21837b2817/src/node/interfaces.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/91c5b68acd12cf7c2b4888d54d8fdd21837b2817/src/node/interfaces.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/interfaces.cpp?ref=91c5b68acd12cf7c2b4888d54d8fdd21837b2817",
        "patch": "@@ -449,13 +449,15 @@ class ChainImpl : public Chain\n     bool checkFinalTx(const CTransaction& tx) override\n     {\n         LOCK(cs_main);\n-        return CheckFinalTx(::ChainActive().Tip(), tx);\n+        assert(std::addressof(::ChainActive()) == std::addressof(m_node.chainman->ActiveChain()));\n+        return CheckFinalTx(m_node.chainman->ActiveChain().Tip(), tx);\n     }\n     Optional<int> findLocatorFork(const CBlockLocator& locator) override\n     {\n         LOCK(cs_main);\n         const CChain& active = Assert(m_node.chainman)->ActiveChain();\n-        if (CBlockIndex* fork = g_chainman.m_blockman.FindForkInGlobalIndex(active, locator)) {\n+        assert(std::addressof(g_chainman) == std::addressof(*m_node.chainman));\n+        if (CBlockIndex* fork = m_node.chainman->m_blockman.FindForkInGlobalIndex(active, locator)) {\n             return fork->nHeight;\n         }\n         return nullopt;\n@@ -464,7 +466,8 @@ class ChainImpl : public Chain\n     {\n         WAIT_LOCK(cs_main, lock);\n         const CChain& active = Assert(m_node.chainman)->ActiveChain();\n-        return FillBlock(g_chainman.m_blockman.LookupBlockIndex(hash), block, lock, active);\n+        assert(std::addressof(g_chainman) == std::addressof(*m_node.chainman));\n+        return FillBlock(m_node.chainman->m_blockman.LookupBlockIndex(hash), block, lock, active);\n     }\n     bool findFirstBlockWithTimeAndHeight(int64_t min_time, int min_height, const FoundBlock& block) override\n     {\n@@ -476,7 +479,8 @@ class ChainImpl : public Chain\n     {\n         WAIT_LOCK(cs_main, lock);\n         const CChain& active = Assert(m_node.chainman)->ActiveChain();\n-        if (const CBlockIndex* block = g_chainman.m_blockman.LookupBlockIndex(block_hash)) {\n+        assert(std::addressof(g_chainman) == std::addressof(*m_node.chainman));\n+        if (const CBlockIndex* block = m_node.chainman->m_blockman.LookupBlockIndex(block_hash)) {\n             if (const CBlockIndex* ancestor = block->GetAncestor(ancestor_height)) {\n                 return FillBlock(ancestor, ancestor_out, lock, active);\n             }\n@@ -487,17 +491,21 @@ class ChainImpl : public Chain\n     {\n         WAIT_LOCK(cs_main, lock);\n         const CChain& active = Assert(m_node.chainman)->ActiveChain();\n-        const CBlockIndex* block = g_chainman.m_blockman.LookupBlockIndex(block_hash);\n-        const CBlockIndex* ancestor = g_chainman.m_blockman.LookupBlockIndex(ancestor_hash);\n+        assert(std::addressof(g_chainman) == std::addressof(*m_node.chainman));\n+        const CBlockIndex* block = m_node.chainman->m_blockman.LookupBlockIndex(block_hash);\n+        assert(std::addressof(g_chainman) == std::addressof(*m_node.chainman));\n+        const CBlockIndex* ancestor = m_node.chainman->m_blockman.LookupBlockIndex(ancestor_hash);\n         if (block && ancestor && block->GetAncestor(ancestor->nHeight) != ancestor) ancestor = nullptr;\n         return FillBlock(ancestor, ancestor_out, lock, active);\n     }\n     bool findCommonAncestor(const uint256& block_hash1, const uint256& block_hash2, const FoundBlock& ancestor_out, const FoundBlock& block1_out, const FoundBlock& block2_out) override\n     {\n         WAIT_LOCK(cs_main, lock);\n         const CChain& active = Assert(m_node.chainman)->ActiveChain();\n-        const CBlockIndex* block1 = g_chainman.m_blockman.LookupBlockIndex(block_hash1);\n-        const CBlockIndex* block2 = g_chainman.m_blockman.LookupBlockIndex(block_hash2);\n+        assert(std::addressof(g_chainman) == std::addressof(*m_node.chainman));\n+        const CBlockIndex* block1 = m_node.chainman->m_blockman.LookupBlockIndex(block_hash1);\n+        assert(std::addressof(g_chainman) == std::addressof(*m_node.chainman));\n+        const CBlockIndex* block2 = m_node.chainman->m_blockman.LookupBlockIndex(block_hash2);\n         const CBlockIndex* ancestor = block1 && block2 ? LastCommonAncestor(block1, block2) : nullptr;\n         // Using & instead of && below to avoid short circuiting and leaving\n         // output uninitialized.\n@@ -507,7 +515,8 @@ class ChainImpl : public Chain\n     double guessVerificationProgress(const uint256& block_hash) override\n     {\n         LOCK(cs_main);\n-        return GuessVerificationProgress(Params().TxData(), g_chainman.m_blockman.LookupBlockIndex(block_hash));\n+        assert(std::addressof(g_chainman) == std::addressof(*m_node.chainman));\n+        return GuessVerificationProgress(Params().TxData(), m_node.chainman->m_blockman.LookupBlockIndex(block_hash));\n     }\n     bool hasBlocks(const uint256& block_hash, int min_height, Optional<int> max_height) override\n     {\n@@ -519,7 +528,8 @@ class ChainImpl : public Chain\n         // used to limit the range, and passing min_height that's too low or\n         // max_height that's too high will not crash or change the result.\n         LOCK(::cs_main);\n-        if (CBlockIndex* block = g_chainman.m_blockman.LookupBlockIndex(block_hash)) {\n+        assert(std::addressof(g_chainman) == std::addressof(*m_node.chainman));\n+        if (CBlockIndex* block = m_node.chainman->m_blockman.LookupBlockIndex(block_hash)) {\n             if (max_height && block->nHeight >= *max_height) block = block->GetAncestor(*max_height);\n             for (; block->nStatus & BLOCK_HAVE_DATA; block = block->pprev) {\n                 // Check pprev to not segfault if min_height is too low\n@@ -603,7 +613,10 @@ class ChainImpl : public Chain\n         return ::fHavePruned;\n     }\n     bool isReadyToBroadcast() override { return !::fImporting && !::fReindex && !isInitialBlockDownload(); }\n-    bool isInitialBlockDownload() override { return ::ChainstateActive().IsInitialBlockDownload(); }\n+    bool isInitialBlockDownload() override {\n+        assert(std::addressof(::ChainstateActive()) == std::addressof(m_node.chainman->ActiveChainstate()));\n+        return m_node.chainman->ActiveChainstate().IsInitialBlockDownload();\n+    }\n     bool shutdownRequested() override { return ShutdownRequested(); }\n     int64_t getAdjustedTime() override { return GetAdjustedTime(); }\n     void initMessage(const std::string& message) override { ::uiInterface.InitMessage(message); }"
      }
    ]
  },
  {
    "sha": "021a04a46915468e7508a6ef44e7fbab1426343d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMjFhMDRhNDY5MTU0NjhlNzUwOGE2ZWY0NGU3ZmJhYjE0MjYzNDNk",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2020-09-22T16:43:18Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-03-08T20:54:31Z"
      },
      "message": "net_processing: Move some static functions to PeerManager\n\n- BlockRequestAllowed\n- AlreadyHaveBlock\n- ProcessGetBlockData\n- PrepareBlockFilterRequest\n- ProcessGetCFilters\n- ProcessGetCFHeaders\n- ProcessGetCFCheckPt\n\nMoved out of anonymous namespace:\n- ProcessBlockAvailability\n- UpdateBlockAvailability\n- CanDirectFetch",
      "tree": {
        "sha": "f4c85618b1fc6c6b354d6325ef5366f91ffc964b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f4c85618b1fc6c6b354d6325ef5366f91ffc964b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/021a04a46915468e7508a6ef44e7fbab1426343d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/021a04a46915468e7508a6ef44e7fbab1426343d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/021a04a46915468e7508a6ef44e7fbab1426343d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/021a04a46915468e7508a6ef44e7fbab1426343d/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "91c5b68acd12cf7c2b4888d54d8fdd21837b2817",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/91c5b68acd12cf7c2b4888d54d8fdd21837b2817",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/91c5b68acd12cf7c2b4888d54d8fdd21837b2817"
      }
    ],
    "stats": {
      "total": 105,
      "additions": 61,
      "deletions": 44
    },
    "files": [
      {
        "sha": "b1a7b970240a0a8683588a1c5d78bb76ee6e85f0",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 61,
        "deletions": 44,
        "changes": 105,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/021a04a46915468e7508a6ef44e7fbab1426343d/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/021a04a46915468e7508a6ef44e7fbab1426343d/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=021a04a46915468e7508a6ef44e7fbab1426343d",
        "patch": "@@ -472,6 +472,24 @@ class PeerManagerImpl final : public PeerManager\n     std::vector<std::pair<uint256, CTransactionRef>> vExtraTxnForCompact GUARDED_BY(g_cs_orphans);\n     /** Offset into vExtraTxnForCompact to insert the next tx */\n     size_t vExtraTxnForCompactIt GUARDED_BY(g_cs_orphans) = 0;\n+\n+    void ProcessBlockAvailability(NodeId nodeid) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool CanDirectFetch(const Consensus::Params &consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool BlockRequestAllowed(const CBlockIndex* pindex, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool AlreadyHaveBlock(const uint256& block_hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    void ProcessGetBlockData(CNode& pfrom, Peer& peer, const CChainParams& chainparams, const CInv& inv, CConnman& connman);\n+    bool PrepareBlockFilterRequest(CNode& peer, const CChainParams& chain_params,\n+                                   BlockFilterType filter_type, uint32_t start_height,\n+                                   const uint256& stop_hash, uint32_t max_height_diff,\n+                                   const CBlockIndex*& stop_index,\n+                                   BlockFilterIndex*& filter_index);\n+    void ProcessGetCFilters(CNode& peer, CDataStream& vRecv, const CChainParams& chain_params,\n+                                   CConnman& connman);\n+    void ProcessGetCFHeaders(CNode& peer, CDataStream& vRecv, const CChainParams& chain_params,\n+                                    CConnman& connman);\n+    void ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv, const CChainParams& chain_params,\n+                                    CConnman& connman);\n };\n } // namespace\n \n@@ -684,41 +702,6 @@ bool PeerManagerImpl::MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, co\n     return true;\n }\n \n-/** Check whether the last unknown block a peer advertised is not yet known. */\n-static void ProcessBlockAvailability(NodeId nodeid) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n-    CNodeState *state = State(nodeid);\n-    assert(state != nullptr);\n-\n-    if (!state->hashLastUnknownBlock.IsNull()) {\n-        const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(state->hashLastUnknownBlock);\n-        if (pindex && pindex->nChainWork > 0) {\n-            if (state->pindexBestKnownBlock == nullptr || pindex->nChainWork >= state->pindexBestKnownBlock->nChainWork) {\n-                state->pindexBestKnownBlock = pindex;\n-            }\n-            state->hashLastUnknownBlock.SetNull();\n-        }\n-    }\n-}\n-\n-/** Update tracking information about which blocks a peer is assumed to have. */\n-static void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n-    CNodeState *state = State(nodeid);\n-    assert(state != nullptr);\n-\n-    ProcessBlockAvailability(nodeid);\n-\n-    const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(hash);\n-    if (pindex && pindex->nChainWork > 0) {\n-        // An actually better block was announced.\n-        if (state->pindexBestKnownBlock == nullptr || pindex->nChainWork >= state->pindexBestKnownBlock->nChainWork) {\n-            state->pindexBestKnownBlock = pindex;\n-        }\n-    } else {\n-        // An unknown block was announced; just assume that the latest one is the best one.\n-        state->hashLastUnknownBlock = hash;\n-    }\n-}\n-\n void PeerManagerImpl::MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid)\n {\n     AssertLockHeld(cs_main);\n@@ -768,7 +751,7 @@ bool PeerManagerImpl::TipMayBeStale()\n     return m_last_tip_update < GetTime() - consensusParams.nPowTargetSpacing * 3 && mapBlocksInFlight.empty();\n }\n \n-static bool CanDirectFetch(const Consensus::Params &consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+bool PeerManagerImpl::CanDirectFetch(const Consensus::Params &consensusParams)\n {\n     return ::ChainActive().Tip()->GetBlockTime() > GetAdjustedTime() - consensusParams.nPowTargetSpacing * 20;\n }\n@@ -782,6 +765,41 @@ static bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex) EXCLUSIV\n     return false;\n }\n \n+/** Check whether the last unknown block a peer advertised is not yet known. */\n+void PeerManagerImpl::ProcessBlockAvailability(NodeId nodeid) {\n+    CNodeState *state = State(nodeid);\n+    assert(state != nullptr);\n+\n+    if (!state->hashLastUnknownBlock.IsNull()) {\n+        const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(state->hashLastUnknownBlock);\n+        if (pindex && pindex->nChainWork > 0) {\n+            if (state->pindexBestKnownBlock == nullptr || pindex->nChainWork >= state->pindexBestKnownBlock->nChainWork) {\n+                state->pindexBestKnownBlock = pindex;\n+            }\n+            state->hashLastUnknownBlock.SetNull();\n+        }\n+    }\n+}\n+\n+/** Update tracking information about which blocks a peer is assumed to have. */\n+void PeerManagerImpl::UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n+    CNodeState *state = State(nodeid);\n+    assert(state != nullptr);\n+\n+    ProcessBlockAvailability(nodeid);\n+\n+    const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(hash);\n+    if (pindex && pindex->nChainWork > 0) {\n+        // An actually better block was announced.\n+        if (state->pindexBestKnownBlock == nullptr || pindex->nChainWork >= state->pindexBestKnownBlock->nChainWork) {\n+            state->pindexBestKnownBlock = pindex;\n+        }\n+    } else {\n+        // An unknown block was announced; just assume that the latest one is the best one.\n+        state->hashLastUnknownBlock = hash;\n+    }\n+}\n+\n void PeerManagerImpl::FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller)\n {\n     if (count == 0)\n@@ -1200,7 +1218,7 @@ bool PeerManagerImpl::MaybePunishNodeForTx(NodeId nodeid, const TxValidationStat\n // active chain if they are no more than a month older (both in time, and in\n // best equivalent proof of work) than the best header chain we know about and\n // we fully-validated them at some point.\n-static bool BlockRequestAllowed(const CBlockIndex* pindex, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+bool PeerManagerImpl::BlockRequestAllowed(const CBlockIndex* pindex, const Consensus::Params& consensusParams)\n {\n     AssertLockHeld(cs_main);\n     if (::ChainActive().Contains(pindex)) return true;\n@@ -1454,7 +1472,7 @@ bool PeerManagerImpl::AlreadyHaveTx(const GenTxid& gtxid)\n     return recentRejects->contains(hash) || m_mempool.exists(gtxid);\n }\n \n-bool static AlreadyHaveBlock(const uint256& block_hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+bool PeerManagerImpl::AlreadyHaveBlock(const uint256& block_hash)\n {\n     return g_chainman.m_blockman.LookupBlockIndex(block_hash) != nullptr;\n }\n@@ -1535,7 +1553,7 @@ static void RelayAddress(const CNode& originator,\n     connman.ForEachNodeThen(std::move(sortfunc), std::move(pushfunc));\n }\n \n-void static ProcessGetBlockData(CNode& pfrom, Peer& peer, const CChainParams& chainparams, const CInv& inv, CConnman& connman)\n+void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CChainParams& chainparams, const CInv& inv, CConnman& connman)\n {\n     bool send = false;\n     std::shared_ptr<const CBlock> a_recent_block;\n@@ -2118,7 +2136,7 @@ void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n  * @param[out]  filter_index    The filter index, if the request can be serviced.\n  * @return                      True if the request can be serviced.\n  */\n-static bool PrepareBlockFilterRequest(CNode& peer, const CChainParams& chain_params,\n+bool PeerManagerImpl::PrepareBlockFilterRequest(CNode& peer, const CChainParams& chain_params,\n                                       BlockFilterType filter_type, uint32_t start_height,\n                                       const uint256& stop_hash, uint32_t max_height_diff,\n                                       const CBlockIndex*& stop_index,\n@@ -2181,7 +2199,7 @@ static bool PrepareBlockFilterRequest(CNode& peer, const CChainParams& chain_par\n  * @param[in]   chain_params    Chain parameters\n  * @param[in]   connman         Pointer to the connection manager\n  */\n-static void ProcessGetCFilters(CNode& peer, CDataStream& vRecv, const CChainParams& chain_params,\n+void PeerManagerImpl::ProcessGetCFilters(CNode& peer, CDataStream& vRecv, const CChainParams& chain_params,\n                                CConnman& connman)\n {\n     uint8_t filter_type_ser;\n@@ -2223,7 +2241,7 @@ static void ProcessGetCFilters(CNode& peer, CDataStream& vRecv, const CChainPara\n  * @param[in]   chain_params    Chain parameters\n  * @param[in]   connman         Pointer to the connection manager\n  */\n-static void ProcessGetCFHeaders(CNode& peer, CDataStream& vRecv, const CChainParams& chain_params,\n+void PeerManagerImpl::ProcessGetCFHeaders(CNode& peer, CDataStream& vRecv, const CChainParams& chain_params,\n                                 CConnman& connman)\n {\n     uint8_t filter_type_ser;\n@@ -2278,7 +2296,7 @@ static void ProcessGetCFHeaders(CNode& peer, CDataStream& vRecv, const CChainPar\n  * @param[in]   chain_params    Chain parameters\n  * @param[in]   connman         Pointer to the connection manager\n  */\n-static void ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv, const CChainParams& chain_params,\n+void PeerManagerImpl::ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv, const CChainParams& chain_params,\n                                 CConnman& connman)\n {\n     uint8_t filter_type_ser;\n@@ -4747,4 +4765,3 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n     } // release cs_main\n     return true;\n }\n-"
      }
    ]
  },
  {
    "sha": "272d993e759e7fcfe883b84e9a2a3be3c75177ec",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNzJkOTkzZTc1OWU3ZmNmZTg4M2I4NGU5YTJhM2JlM2M3NTE3N2Vj",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2020-10-14T18:24:29Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-03-08T20:54:31Z"
      },
      "message": "scripted-diff: net_processing: Use existing chainman\n\n-BEGIN VERIFY SCRIPT-\nsed -i -E \\\n    -e 's/g_chainman/m_chainman/g' \\\n    -e 's@([^:])(Chain(state|)Active)@\\1::\\2@g' \\\n    -e 's@::Chain(state|)Active\\(\\)@m_chainman.ActiveChain\\1()@g' \\\n    -- src/net_processing.cpp\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "06005f33b01eff1f8c60b62afe9ca8cf4472f293",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/06005f33b01eff1f8c60b62afe9ca8cf4472f293"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/272d993e759e7fcfe883b84e9a2a3be3c75177ec",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/272d993e759e7fcfe883b84e9a2a3be3c75177ec",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/272d993e759e7fcfe883b84e9a2a3be3c75177ec",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/272d993e759e7fcfe883b84e9a2a3be3c75177ec/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "021a04a46915468e7508a6ef44e7fbab1426343d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/021a04a46915468e7508a6ef44e7fbab1426343d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/021a04a46915468e7508a6ef44e7fbab1426343d"
      }
    ],
    "stats": {
      "total": 140,
      "additions": 70,
      "deletions": 70
    },
    "files": [
      {
        "sha": "f7fa67bb75f5891aa14f53b821464ce3b6d1d231",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 70,
        "deletions": 70,
        "changes": 140,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/272d993e759e7fcfe883b84e9a2a3be3c75177ec/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/272d993e759e7fcfe883b84e9a2a3be3c75177ec/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=272d993e759e7fcfe883b84e9a2a3be3c75177ec",
        "patch": "@@ -753,7 +753,7 @@ bool PeerManagerImpl::TipMayBeStale()\n \n bool PeerManagerImpl::CanDirectFetch(const Consensus::Params &consensusParams)\n {\n-    return ::ChainActive().Tip()->GetBlockTime() > GetAdjustedTime() - consensusParams.nPowTargetSpacing * 20;\n+    return m_chainman.ActiveChain().Tip()->GetBlockTime() > GetAdjustedTime() - consensusParams.nPowTargetSpacing * 20;\n }\n \n static bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n@@ -771,7 +771,7 @@ void PeerManagerImpl::ProcessBlockAvailability(NodeId nodeid) {\n     assert(state != nullptr);\n \n     if (!state->hashLastUnknownBlock.IsNull()) {\n-        const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(state->hashLastUnknownBlock);\n+        const CBlockIndex* pindex = m_chainman.m_blockman.LookupBlockIndex(state->hashLastUnknownBlock);\n         if (pindex && pindex->nChainWork > 0) {\n             if (state->pindexBestKnownBlock == nullptr || pindex->nChainWork >= state->pindexBestKnownBlock->nChainWork) {\n                 state->pindexBestKnownBlock = pindex;\n@@ -788,7 +788,7 @@ void PeerManagerImpl::UpdateBlockAvailability(NodeId nodeid, const uint256 &hash\n \n     ProcessBlockAvailability(nodeid);\n \n-    const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(hash);\n+    const CBlockIndex* pindex = m_chainman.m_blockman.LookupBlockIndex(hash);\n     if (pindex && pindex->nChainWork > 0) {\n         // An actually better block was announced.\n         if (state->pindexBestKnownBlock == nullptr || pindex->nChainWork >= state->pindexBestKnownBlock->nChainWork) {\n@@ -812,15 +812,15 @@ void PeerManagerImpl::FindNextBlocksToDownload(NodeId nodeid, unsigned int count\n     // Make sure pindexBestKnownBlock is up to date, we'll need it.\n     ProcessBlockAvailability(nodeid);\n \n-    if (state->pindexBestKnownBlock == nullptr || state->pindexBestKnownBlock->nChainWork < ::ChainActive().Tip()->nChainWork || state->pindexBestKnownBlock->nChainWork < nMinimumChainWork) {\n+    if (state->pindexBestKnownBlock == nullptr || state->pindexBestKnownBlock->nChainWork < m_chainman.ActiveChain().Tip()->nChainWork || state->pindexBestKnownBlock->nChainWork < nMinimumChainWork) {\n         // This peer has nothing interesting.\n         return;\n     }\n \n     if (state->pindexLastCommonBlock == nullptr) {\n         // Bootstrap quickly by guessing a parent of our best tip is the forking point.\n         // Guessing wrong in either direction is not a problem.\n-        state->pindexLastCommonBlock = ::ChainActive()[std::min(state->pindexBestKnownBlock->nHeight, ::ChainActive().Height())];\n+        state->pindexLastCommonBlock = m_chainman.ActiveChain()[std::min(state->pindexBestKnownBlock->nHeight, m_chainman.ActiveChain().Height())];\n     }\n \n     // If the peer reorganized, our previous pindexLastCommonBlock may not be an ancestor\n@@ -863,7 +863,7 @@ void PeerManagerImpl::FindNextBlocksToDownload(NodeId nodeid, unsigned int count\n                 // We wouldn't download this block or its descendants from this peer.\n                 return;\n             }\n-            if (pindex->nStatus & BLOCK_HAVE_DATA || ::ChainActive().Contains(pindex)) {\n+            if (pindex->nStatus & BLOCK_HAVE_DATA || m_chainman.ActiveChain().Contains(pindex)) {\n                 if (pindex->HaveTxsDownloaded())\n                     state->pindexLastCommonBlock = pindex;\n             } else if (mapBlocksInFlight.count(pindex->GetBlockHash()) == 0) {\n@@ -1221,7 +1221,7 @@ bool PeerManagerImpl::MaybePunishNodeForTx(NodeId nodeid, const TxValidationStat\n bool PeerManagerImpl::BlockRequestAllowed(const CBlockIndex* pindex, const Consensus::Params& consensusParams)\n {\n     AssertLockHeld(cs_main);\n-    if (::ChainActive().Contains(pindex)) return true;\n+    if (m_chainman.ActiveChain().Contains(pindex)) return true;\n     return pindex->IsValid(BLOCK_VALID_SCRIPTS) && (pindexBestHeader != nullptr) &&\n         (pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() < STALE_RELAY_AGE_LIMIT) &&\n         (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, consensusParams) < STALE_RELAY_AGE_LIMIT);\n@@ -1370,7 +1370,7 @@ void PeerManagerImpl::NewPoWValidBlock(const CBlockIndex *pindex, const std::sha\n \n /**\n  * Update our best height and announce any block hashes which weren't previously\n- * in ::ChainActive() to our peers.\n+ * in m_chainman.ActiveChain() to our peers.\n  */\n void PeerManagerImpl::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload)\n {\n@@ -1432,7 +1432,7 @@ void PeerManagerImpl::BlockChecked(const CBlock& block, const BlockValidationSta\n     //    the tip yet so we have no way to check this directly here. Instead we\n     //    just check that there are currently no other blocks in flight.\n     else if (state.IsValid() &&\n-             !::ChainstateActive().IsInitialBlockDownload() &&\n+             !m_chainman.ActiveChainstate().IsInitialBlockDownload() &&\n              mapBlocksInFlight.count(hash) == mapBlocksInFlight.size()) {\n         if (it != mapBlockSource.end()) {\n             MaybeSetPeerAsAnnouncingHeaderAndIDs(it->second.first);\n@@ -1451,12 +1451,12 @@ void PeerManagerImpl::BlockChecked(const CBlock& block, const BlockValidationSta\n bool PeerManagerImpl::AlreadyHaveTx(const GenTxid& gtxid)\n {\n     assert(recentRejects);\n-    if (::ChainActive().Tip()->GetBlockHash() != hashRecentRejectsChainTip) {\n+    if (m_chainman.ActiveChain().Tip()->GetBlockHash() != hashRecentRejectsChainTip) {\n         // If the chain tip has changed previously rejected transactions\n         // might be now valid, e.g. due to a nLockTime'd tx becoming valid,\n         // or a double-spend. Reset the rejects filter and give those\n         // txs a second chance.\n-        hashRecentRejectsChainTip = ::ChainActive().Tip()->GetBlockHash();\n+        hashRecentRejectsChainTip = m_chainman.ActiveChain().Tip()->GetBlockHash();\n         recentRejects->reset();\n     }\n \n@@ -1474,7 +1474,7 @@ bool PeerManagerImpl::AlreadyHaveTx(const GenTxid& gtxid)\n \n bool PeerManagerImpl::AlreadyHaveBlock(const uint256& block_hash)\n {\n-    return g_chainman.m_blockman.LookupBlockIndex(block_hash) != nullptr;\n+    return m_chainman.m_blockman.LookupBlockIndex(block_hash) != nullptr;\n }\n \n void PeerManagerImpl::SendPings()\n@@ -1570,7 +1570,7 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CChain\n     bool need_activate_chain = false;\n     {\n         LOCK(cs_main);\n-        const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(inv.hash);\n+        const CBlockIndex* pindex = m_chainman.m_blockman.LookupBlockIndex(inv.hash);\n         if (pindex) {\n             if (pindex->HaveTxsDownloaded() && !pindex->IsValid(BLOCK_VALID_SCRIPTS) &&\n                     pindex->IsValid(BLOCK_VALID_TREE)) {\n@@ -1585,13 +1585,13 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CChain\n     } // release cs_main before calling ActivateBestChain\n     if (need_activate_chain) {\n         BlockValidationState state;\n-        if (!::ChainstateActive().ActivateBestChain(state, chainparams, a_recent_block)) {\n+        if (!m_chainman.ActiveChainstate().ActivateBestChain(state, chainparams, a_recent_block)) {\n             LogPrint(BCLog::NET, \"failed to activate chain (%s)\\n\", state.ToString());\n         }\n     }\n \n     LOCK(cs_main);\n-    const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(inv.hash);\n+    const CBlockIndex* pindex = m_chainman.m_blockman.LookupBlockIndex(inv.hash);\n     if (pindex) {\n         send = BlockRequestAllowed(pindex, consensusParams);\n         if (!send) {\n@@ -1613,7 +1613,7 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CChain\n     }\n     // Avoid leaking prune-height by never sending blocks below the NODE_NETWORK_LIMITED threshold\n     if (send && !pfrom.HasPermission(PF_NOBAN) && (\n-            (((pfrom.GetLocalServices() & NODE_NETWORK_LIMITED) == NODE_NETWORK_LIMITED) && ((pfrom.GetLocalServices() & NODE_NETWORK) != NODE_NETWORK) && (::ChainActive().Tip()->nHeight - pindex->nHeight > (int)NODE_NETWORK_LIMITED_MIN_BLOCKS + 2 /* add two blocks buffer extension for possible races */) )\n+            (((pfrom.GetLocalServices() & NODE_NETWORK_LIMITED) == NODE_NETWORK_LIMITED) && ((pfrom.GetLocalServices() & NODE_NETWORK) != NODE_NETWORK) && (m_chainman.ActiveChain().Tip()->nHeight - pindex->nHeight > (int)NODE_NETWORK_LIMITED_MIN_BLOCKS + 2 /* add two blocks buffer extension for possible races */) )\n        )) {\n         LogPrint(BCLog::NET, \"Ignore block request below NODE_NETWORK_LIMITED threshold from peer=%d\\n\", pfrom.GetId());\n \n@@ -1680,7 +1680,7 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CChain\n                 // instead we respond with the full, non-compact block.\n                 bool fPeerWantsWitness = State(pfrom.GetId())->fWantsCmpctWitness;\n                 int nSendFlags = fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n-                if (CanDirectFetch(consensusParams) && pindex->nHeight >= ::ChainActive().Height() - MAX_CMPCTBLOCK_DEPTH) {\n+                if (CanDirectFetch(consensusParams) && pindex->nHeight >= m_chainman.ActiveChain().Height() - MAX_CMPCTBLOCK_DEPTH) {\n                     if ((fPeerWantsWitness || !fWitnessesPresentInARecentCompactBlock) && a_recent_compact_block && a_recent_compact_block->header.GetHash() == pindex->GetBlockHash()) {\n                         connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block));\n                     } else {\n@@ -1701,7 +1701,7 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CChain\n                 // and we want it right after the last block so they don't\n                 // wait for other stuff first.\n                 std::vector<CInv> vInv;\n-                vInv.push_back(CInv(MSG_BLOCK, ::ChainActive().Tip()->GetBlockHash()));\n+                vInv.push_back(CInv(MSG_BLOCK, m_chainman.ActiveChain().Tip()->GetBlockHash()));\n                 connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::INV, vInv));\n                 peer.m_continuation_block.SetNull();\n             }\n@@ -1880,9 +1880,9 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n         //   don't connect before giving DoS points\n         // - Once a headers message is received that is valid and does connect,\n         //   nUnconnectingHeaders gets reset back to 0.\n-        if (!g_chainman.m_blockman.LookupBlockIndex(headers[0].hashPrevBlock) && nCount < MAX_BLOCKS_TO_ANNOUNCE) {\n+        if (!m_chainman.m_blockman.LookupBlockIndex(headers[0].hashPrevBlock) && nCount < MAX_BLOCKS_TO_ANNOUNCE) {\n             nodestate->nUnconnectingHeaders++;\n-            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexBestHeader), uint256()));\n+            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, m_chainman.ActiveChain().GetLocator(pindexBestHeader), uint256()));\n             LogPrint(BCLog::NET, \"received header %s: missing prev block %s, sending getheaders (%d) to end (peer=%d, nUnconnectingHeaders=%d)\\n\",\n                     headers[0].GetHash().ToString(),\n                     headers[0].hashPrevBlock.ToString(),\n@@ -1910,7 +1910,7 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n \n         // If we don't have the last header, then they'll have given us\n         // something new (if these headers are valid).\n-        if (!g_chainman.m_blockman.LookupBlockIndex(hashLastBlock)) {\n+        if (!m_chainman.m_blockman.LookupBlockIndex(hashLastBlock)) {\n             received_new_header = true;\n         }\n     }\n@@ -1938,27 +1938,27 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n         // because it is set in UpdateBlockAvailability. Some nullptr checks\n         // are still present, however, as belt-and-suspenders.\n \n-        if (received_new_header && pindexLast->nChainWork > ::ChainActive().Tip()->nChainWork) {\n+        if (received_new_header && pindexLast->nChainWork > m_chainman.ActiveChain().Tip()->nChainWork) {\n             nodestate->m_last_block_announcement = GetTime();\n         }\n \n         if (nCount == MAX_HEADERS_RESULTS) {\n             // Headers message had its maximum size; the peer may have more headers.\n-            // TODO: optimize: if pindexLast is an ancestor of ::ChainActive().Tip or pindexBestHeader, continue\n+            // TODO: optimize: if pindexLast is an ancestor of m_chainman.ActiveChain().Tip or pindexBestHeader, continue\n             // from there instead.\n             LogPrint(BCLog::NET, \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\",\n                                  pindexLast->nHeight, pfrom.GetId(), peer.m_starting_height);\n-            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexLast), uint256()));\n+            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, m_chainman.ActiveChain().GetLocator(pindexLast), uint256()));\n         }\n \n         bool fCanDirectFetch = CanDirectFetch(m_chainparams.GetConsensus());\n         // If this set of headers is valid and ends in a block with at least as\n         // much work as our tip, download as much as possible.\n-        if (fCanDirectFetch && pindexLast->IsValid(BLOCK_VALID_TREE) && ::ChainActive().Tip()->nChainWork <= pindexLast->nChainWork) {\n+        if (fCanDirectFetch && pindexLast->IsValid(BLOCK_VALID_TREE) && m_chainman.ActiveChain().Tip()->nChainWork <= pindexLast->nChainWork) {\n             std::vector<const CBlockIndex*> vToFetch;\n             const CBlockIndex *pindexWalk = pindexLast;\n             // Calculate all the blocks we'd need to switch to pindexLast, up to a limit.\n-            while (pindexWalk && !::ChainActive().Contains(pindexWalk) && vToFetch.size() <= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+            while (pindexWalk && !m_chainman.ActiveChain().Contains(pindexWalk) && vToFetch.size() <= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n                 if (!(pindexWalk->nStatus & BLOCK_HAVE_DATA) &&\n                         !mapBlocksInFlight.count(pindexWalk->GetBlockHash()) &&\n                         (!IsWitnessEnabled(pindexWalk->pprev, m_chainparams.GetConsensus()) || State(pfrom.GetId())->fHaveWitness)) {\n@@ -1971,7 +1971,7 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n             // very large reorg at a time we think we're close to caught up to\n             // the main chain -- this shouldn't really happen.  Bail out on the\n             // direct fetch and rely on parallel download instead.\n-            if (!::ChainActive().Contains(pindexWalk)) {\n+            if (!m_chainman.ActiveChain().Contains(pindexWalk)) {\n                 LogPrint(BCLog::NET, \"Large reorg, won't direct fetch to %s (%d)\\n\",\n                         pindexLast->GetBlockHash().ToString(),\n                         pindexLast->nHeight);\n@@ -2004,15 +2004,15 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n         }\n         // If we're in IBD, we want outbound peers that will serve us a useful\n         // chain. Disconnect peers that are on chains with insufficient work.\n-        if (::ChainstateActive().IsInitialBlockDownload() && nCount != MAX_HEADERS_RESULTS) {\n+        if (m_chainman.ActiveChainstate().IsInitialBlockDownload() && nCount != MAX_HEADERS_RESULTS) {\n             // When nCount < MAX_HEADERS_RESULTS, we know we have no more\n             // headers to fetch from this peer.\n             if (nodestate->pindexBestKnownBlock && nodestate->pindexBestKnownBlock->nChainWork < nMinimumChainWork) {\n                 // This peer has too little work on their headers chain to help\n                 // us sync -- disconnect if it is an outbound disconnection\n                 // candidate.\n                 // Note: We compare their tip to nMinimumChainWork (rather than\n-                // ::ChainActive().Tip()) because we won't start block download\n+                // m_chainman.ActiveChain().Tip()) because we won't start block download\n                 // until we have a headers chain that has at least\n                 // nMinimumChainWork, even if a peer has a chain past our tip,\n                 // as an anti-DoS measure.\n@@ -2029,7 +2029,7 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n         // thus always subject to eviction under the bad/lagging chain logic.\n         // See ChainSyncTimeoutState.\n         if (!pfrom.fDisconnect && pfrom.IsFullOutboundConn() && nodestate->pindexBestKnownBlock != nullptr) {\n-            if (m_outbound_peers_with_protect_from_disconnect < MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT && nodestate->pindexBestKnownBlock->nChainWork >= ::ChainActive().Tip()->nChainWork && !nodestate->m_chain_sync.m_protect) {\n+            if (m_outbound_peers_with_protect_from_disconnect < MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT && nodestate->pindexBestKnownBlock->nChainWork >= m_chainman.ActiveChain().Tip()->nChainWork && !nodestate->m_chain_sync.m_protect) {\n                 LogPrint(BCLog::NET, \"Protecting outbound peer=%d from eviction\\n\", pfrom.GetId());\n                 nodestate->m_chain_sync.m_protect = true;\n                 ++m_outbound_peers_with_protect_from_disconnect;\n@@ -2060,7 +2060,7 @@ void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n         const auto [porphanTx, from_peer] = m_orphanage.GetTx(orphanHash);\n         if (porphanTx == nullptr) continue;\n \n-        const MempoolAcceptResult result = AcceptToMemoryPool(::ChainstateActive(), m_mempool, porphanTx, false /* bypass_limits */);\n+        const MempoolAcceptResult result = AcceptToMemoryPool(m_chainman.ActiveChainstate(), m_mempool, porphanTx, false /* bypass_limits */);\n         const TxValidationState& state = result.m_state;\n \n         if (result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n@@ -2154,7 +2154,7 @@ bool PeerManagerImpl::PrepareBlockFilterRequest(CNode& peer, const CChainParams&\n \n     {\n         LOCK(cs_main);\n-        stop_index = g_chainman.m_blockman.LookupBlockIndex(stop_hash);\n+        stop_index = m_chainman.m_blockman.LookupBlockIndex(stop_hash);\n \n         // Check that the stop block exists and the peer would be allowed to fetch it.\n         if (!stop_index || !BlockRequestAllowed(stop_index, chain_params.GetConsensus())) {\n@@ -2479,7 +2479,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             //\n             // We skip this for block-relay-only peers to avoid potentially leaking\n             // information about our block-relay-only connections via address relay.\n-            if (fListen && !::ChainstateActive().IsInitialBlockDownload())\n+            if (fListen && !m_chainman.ActiveChainstate().IsInitialBlockDownload())\n             {\n                 CAddress addr = GetLocalAddress(&pfrom.addr, pfrom.GetLocalServices());\n                 FastRandomContext insecure_rand;\n@@ -2796,7 +2796,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         }\n \n         if (best_block != nullptr) {\n-            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexBestHeader), *best_block));\n+            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, m_chainman.ActiveChain().GetLocator(pindexBestHeader), *best_block));\n             LogPrint(BCLog::NET, \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, best_block->ToString(), pfrom.GetId());\n         }\n \n@@ -2852,22 +2852,22 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 a_recent_block = most_recent_block;\n             }\n             BlockValidationState state;\n-            if (!::ChainstateActive().ActivateBestChain(state, m_chainparams, a_recent_block)) {\n+            if (!m_chainman.ActiveChainstate().ActivateBestChain(state, m_chainparams, a_recent_block)) {\n                 LogPrint(BCLog::NET, \"failed to activate chain (%s)\\n\", state.ToString());\n             }\n         }\n \n         LOCK(cs_main);\n \n         // Find the last block the caller has in the main chain\n-        const CBlockIndex* pindex = g_chainman.m_blockman.FindForkInGlobalIndex(::ChainActive(), locator);\n+        const CBlockIndex* pindex = m_chainman.m_blockman.FindForkInGlobalIndex(m_chainman.ActiveChain(), locator);\n \n         // Send the rest of the chain\n         if (pindex)\n-            pindex = ::ChainActive().Next(pindex);\n+            pindex = m_chainman.ActiveChain().Next(pindex);\n         int nLimit = 500;\n         LogPrint(BCLog::NET, \"getblocks %d to %s limit %d from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), nLimit, pfrom.GetId());\n-        for (; pindex; pindex = ::ChainActive().Next(pindex))\n+        for (; pindex; pindex = m_chainman.ActiveChain().Next(pindex))\n         {\n             if (pindex->GetBlockHash() == hashStop)\n             {\n@@ -2877,7 +2877,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // If pruning, don't inv blocks unless we have on disk and are likely to still have\n             // for some reasonable time window (1 hour) that block relay might require.\n             const int nPrunedBlocksLikelyToHave = MIN_BLOCKS_TO_KEEP - 3600 / m_chainparams.GetConsensus().nPowTargetSpacing;\n-            if (fPruneMode && (!(pindex->nStatus & BLOCK_HAVE_DATA) || pindex->nHeight <= ::ChainActive().Tip()->nHeight - nPrunedBlocksLikelyToHave))\n+            if (fPruneMode && (!(pindex->nStatus & BLOCK_HAVE_DATA) || pindex->nHeight <= m_chainman.ActiveChain().Tip()->nHeight - nPrunedBlocksLikelyToHave))\n             {\n                 LogPrint(BCLog::NET, \" getblocks stopping, pruned or too old block at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());\n                 break;\n@@ -2913,13 +2913,13 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         {\n             LOCK(cs_main);\n \n-            const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(req.blockhash);\n+            const CBlockIndex* pindex = m_chainman.m_blockman.LookupBlockIndex(req.blockhash);\n             if (!pindex || !(pindex->nStatus & BLOCK_HAVE_DATA)) {\n                 LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block we don't have\\n\", pfrom.GetId());\n                 return;\n             }\n \n-            if (pindex->nHeight >= ::ChainActive().Height() - MAX_BLOCKTXN_DEPTH) {\n+            if (pindex->nHeight >= m_chainman.ActiveChain().Height() - MAX_BLOCKTXN_DEPTH) {\n                 CBlock block;\n                 bool ret = ReadBlockFromDisk(block, pindex, m_chainparams.GetConsensus());\n                 assert(ret);\n@@ -2957,7 +2957,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         }\n \n         LOCK(cs_main);\n-        if (::ChainstateActive().IsInitialBlockDownload() && !pfrom.HasPermission(PF_DOWNLOAD)) {\n+        if (m_chainman.ActiveChainstate().IsInitialBlockDownload() && !pfrom.HasPermission(PF_DOWNLOAD)) {\n             LogPrint(BCLog::NET, \"Ignoring getheaders from peer=%d because node is in initial block download\\n\", pfrom.GetId());\n             return;\n         }\n@@ -2967,7 +2967,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         if (locator.IsNull())\n         {\n             // If locator is null, return the hashStop block\n-            pindex = g_chainman.m_blockman.LookupBlockIndex(hashStop);\n+            pindex = m_chainman.m_blockman.LookupBlockIndex(hashStop);\n             if (!pindex) {\n                 return;\n             }\n@@ -2980,23 +2980,23 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         else\n         {\n             // Find the last block the caller has in the main chain\n-            pindex = g_chainman.m_blockman.FindForkInGlobalIndex(::ChainActive(), locator);\n+            pindex = m_chainman.m_blockman.FindForkInGlobalIndex(m_chainman.ActiveChain(), locator);\n             if (pindex)\n-                pindex = ::ChainActive().Next(pindex);\n+                pindex = m_chainman.ActiveChain().Next(pindex);\n         }\n \n         // we must use CBlocks, as CBlockHeaders won't include the 0x00 nTx count at the end\n         std::vector<CBlock> vHeaders;\n         int nLimit = MAX_HEADERS_RESULTS;\n         LogPrint(BCLog::NET, \"getheaders %d to %s from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), pfrom.GetId());\n-        for (; pindex; pindex = ::ChainActive().Next(pindex))\n+        for (; pindex; pindex = m_chainman.ActiveChain().Next(pindex))\n         {\n             vHeaders.push_back(pindex->GetBlockHeader());\n             if (--nLimit <= 0 || pindex->GetBlockHash() == hashStop)\n                 break;\n         }\n-        // pindex can be nullptr either if we sent ::ChainActive().Tip() OR\n-        // if our peer has ::ChainActive().Tip() (and thus we are sending an empty\n+        // pindex can be nullptr either if we sent m_chainman.ActiveChain().Tip() OR\n+        // if our peer has m_chainman.ActiveChain().Tip() (and thus we are sending an empty\n         // headers message). In both cases it's safe to update\n         // pindexBestHeaderSent to be our tip.\n         //\n@@ -3007,7 +3007,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         // without the new block. By resetting the BestHeaderSent, we ensure we\n         // will re-announce the new block via headers (or compact blocks again)\n         // in the SendMessages logic.\n-        nodestate->pindexBestHeaderSent = pindex ? pindex : ::ChainActive().Tip();\n+        nodestate->pindexBestHeaderSent = pindex ? pindex : m_chainman.ActiveChain().Tip();\n         m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n         return;\n     }\n@@ -3075,7 +3075,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             return;\n         }\n \n-        const MempoolAcceptResult result = AcceptToMemoryPool(::ChainstateActive(), m_mempool, ptx, false /* bypass_limits */);\n+        const MempoolAcceptResult result = AcceptToMemoryPool(m_chainman.ActiveChainstate(), m_mempool, ptx, false /* bypass_limits */);\n         const TxValidationState& state = result.m_state;\n \n         if (result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n@@ -3240,14 +3240,14 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         {\n         LOCK(cs_main);\n \n-        if (!g_chainman.m_blockman.LookupBlockIndex(cmpctblock.header.hashPrevBlock)) {\n+        if (!m_chainman.m_blockman.LookupBlockIndex(cmpctblock.header.hashPrevBlock)) {\n             // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n-            if (!::ChainstateActive().IsInitialBlockDownload())\n-                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexBestHeader), uint256()));\n+            if (!m_chainman.ActiveChainstate().IsInitialBlockDownload())\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, m_chainman.ActiveChain().GetLocator(pindexBestHeader), uint256()));\n             return;\n         }\n \n-        if (!g_chainman.m_blockman.LookupBlockIndex(cmpctblock.header.GetHash())) {\n+        if (!m_chainman.m_blockman.LookupBlockIndex(cmpctblock.header.GetHash())) {\n             received_new_header = true;\n         }\n         }\n@@ -3287,7 +3287,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n         // If this was a new header with more work than our tip, update the\n         // peer's last block announcement time\n-        if (received_new_header && pindex->nChainWork > ::ChainActive().Tip()->nChainWork) {\n+        if (received_new_header && pindex->nChainWork > m_chainman.ActiveChain().Tip()->nChainWork) {\n             nodestate->m_last_block_announcement = GetTime();\n         }\n \n@@ -3297,7 +3297,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         if (pindex->nStatus & BLOCK_HAVE_DATA) // Nothing to do here\n             return;\n \n-        if (pindex->nChainWork <= ::ChainActive().Tip()->nChainWork || // We know something better\n+        if (pindex->nChainWork <= m_chainman.ActiveChain().Tip()->nChainWork || // We know something better\n                 pindex->nTx != 0) { // We had this block at some point, but pruned it\n             if (fAlreadyInFlight) {\n                 // We requested this block for some reason, but our mempool will probably be useless\n@@ -3321,7 +3321,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n         // We want to be a bit conservative just to be extra careful about DoS\n         // possibilities in compact block processing...\n-        if (pindex->nHeight <= ::ChainActive().Height() + 2) {\n+        if (pindex->nHeight <= m_chainman.ActiveChain().Height() + 2) {\n             if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n                  (fAlreadyInFlight && blockInFlightIt->second.first == pfrom.GetId())) {\n                 std::list<QueuedBlock>::iterator* queuedBlockIt = nullptr;\n@@ -3969,7 +3969,7 @@ void PeerManagerImpl::ConsiderEviction(CNode& pto, int64_t time_in_seconds)\n         // their chain has more work than ours, we should sync to it,\n         // unless it's invalid, in which case we should find that out and\n         // disconnect from them elsewhere).\n-        if (state.pindexBestKnownBlock != nullptr && state.pindexBestKnownBlock->nChainWork >= ::ChainActive().Tip()->nChainWork) {\n+        if (state.pindexBestKnownBlock != nullptr && state.pindexBestKnownBlock->nChainWork >= m_chainman.ActiveChain().Tip()->nChainWork) {\n             if (state.m_chain_sync.m_timeout != 0) {\n                 state.m_chain_sync.m_timeout = 0;\n                 state.m_chain_sync.m_work_header = nullptr;\n@@ -3981,7 +3981,7 @@ void PeerManagerImpl::ConsiderEviction(CNode& pto, int64_t time_in_seconds)\n             // where we checked against our tip.\n             // Either way, set a new timeout based on current tip.\n             state.m_chain_sync.m_timeout = time_in_seconds + CHAIN_SYNC_TIMEOUT;\n-            state.m_chain_sync.m_work_header = ::ChainActive().Tip();\n+            state.m_chain_sync.m_work_header = m_chainman.ActiveChain().Tip();\n             state.m_chain_sync.m_sent_getheaders = false;\n         } else if (state.m_chain_sync.m_timeout > 0 && time_in_seconds > state.m_chain_sync.m_timeout) {\n             // No evidence yet that our peer has synced to a chain with work equal to that\n@@ -3994,7 +3994,7 @@ void PeerManagerImpl::ConsiderEviction(CNode& pto, int64_t time_in_seconds)\n             } else {\n                 assert(state.m_chain_sync.m_work_header);\n                 LogPrint(BCLog::NET, \"sending getheaders to outbound peer=%d to verify chain work (current best known block:%s, benchmark blockhash: %s)\\n\", pto.GetId(), state.pindexBestKnownBlock != nullptr ? state.pindexBestKnownBlock->GetBlockHash().ToString() : \"<none>\", state.m_chain_sync.m_work_header->GetBlockHash().ToString());\n-                m_connman.PushMessage(&pto, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(state.m_chain_sync.m_work_header->pprev), uint256()));\n+                m_connman.PushMessage(&pto, msgMaker.Make(NetMsgType::GETHEADERS, m_chainman.ActiveChain().GetLocator(state.m_chain_sync.m_work_header->pprev), uint256()));\n                 state.m_chain_sync.m_sent_getheaders = true;\n                 constexpr int64_t HEADERS_RESPONSE_TIME = 120; // 2 minutes\n                 // Bump the timeout to allow a response, which could clear the timeout\n@@ -4231,7 +4231,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n         auto current_time = GetTime<std::chrono::microseconds>();\n \n         if (fListen && pto->RelayAddrsWithConn() &&\n-            !::ChainstateActive().IsInitialBlockDownload() &&\n+            !m_chainman.ActiveChainstate().IsInitialBlockDownload() &&\n             pto->m_next_local_addr_send < current_time) {\n             // If we've sent before, clear the bloom filter for the peer, so that our\n             // self-announcement will actually go out.\n@@ -4292,7 +4292,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n \n         // Start block sync\n         if (pindexBestHeader == nullptr)\n-            pindexBestHeader = ::ChainActive().Tip();\n+            pindexBestHeader = m_chainman.ActiveChain().Tip();\n         bool fFetch = state.fPreferredDownload || (nPreferredDownload == 0 && !pto->fClient && !pto->IsAddrFetchConn()); // Download if this is a nice peer, or we have no nice peers and this one might do.\n         if (!state.fSyncStarted && !pto->fClient && !fImporting && !fReindex) {\n             // Only actively request headers from a single peer, unless we're close to today.\n@@ -4317,7 +4317,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                 if (pindexStart->pprev)\n                     pindexStart = pindexStart->pprev;\n                 LogPrint(BCLog::NET, \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->GetId(), peer->m_starting_height);\n-                m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexStart), uint256()));\n+                m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, m_chainman.ActiveChain().GetLocator(pindexStart), uint256()));\n             }\n         }\n \n@@ -4344,11 +4344,11 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                 bool fFoundStartingHeader = false;\n                 // Try to find first header that our peer doesn't have, and\n                 // then send all headers past that one.  If we come across any\n-                // headers that aren't on ::ChainActive(), give up.\n+                // headers that aren't on m_chainman.ActiveChain(), give up.\n                 for (const uint256& hash : peer->m_blocks_for_headers_relay) {\n-                    const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(hash);\n+                    const CBlockIndex* pindex = m_chainman.m_blockman.LookupBlockIndex(hash);\n                     assert(pindex);\n-                    if (::ChainActive()[pindex->nHeight] != pindex) {\n+                    if (m_chainman.ActiveChain()[pindex->nHeight] != pindex) {\n                         // Bail out if we reorged away from this block\n                         fRevertToInv = true;\n                         break;\n@@ -4438,15 +4438,15 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                 // in the past.\n                 if (!peer->m_blocks_for_headers_relay.empty()) {\n                     const uint256& hashToAnnounce = peer->m_blocks_for_headers_relay.back();\n-                    const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(hashToAnnounce);\n+                    const CBlockIndex* pindex = m_chainman.m_blockman.LookupBlockIndex(hashToAnnounce);\n                     assert(pindex);\n \n                     // Warn if we're announcing a block that is not on the main chain.\n                     // This should be very rare and could be optimized out.\n                     // Just log for now.\n-                    if (::ChainActive()[pindex->nHeight] != pindex) {\n+                    if (m_chainman.ActiveChain()[pindex->nHeight] != pindex) {\n                         LogPrint(BCLog::NET, \"Announcing block %s not on main chain (tip=%s)\\n\",\n-                            hashToAnnounce.ToString(), ::ChainActive().Tip()->GetBlockHash().ToString());\n+                            hashToAnnounce.ToString(), m_chainman.ActiveChain().Tip()->GetBlockHash().ToString());\n                     }\n \n                     // If the peer's chain has this block, don't inv it back.\n@@ -4676,7 +4676,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n         // Message: getdata (blocks)\n         //\n         std::vector<CInv> vGetData;\n-        if (!pto->fClient && ((fFetch && !pto->m_limited_node) || !::ChainstateActive().IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+        if (!pto->fClient && ((fFetch && !pto->m_limited_node) || !m_chainman.ActiveChainstate().IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n             std::vector<const CBlockIndex*> vToDownload;\n             NodeId staller = -1;\n             FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller);"
      }
    ]
  },
  {
    "sha": "a67983cd6d8e61565da4e03f3ba401d0148fe195",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNjc5ODNjZDZkOGU2MTU2NWRhNGUwM2YzYmE0MDFkMDE0OGZlMTk1",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2020-10-15T17:07:25Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-03-08T20:54:31Z"
      },
      "message": "net_processing: Add review-only assertion to PeerManager",
      "tree": {
        "sha": "b6d6c1d0e4e26afcf9746d3f5a87596e41bbf519",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b6d6c1d0e4e26afcf9746d3f5a87596e41bbf519"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a67983cd6d8e61565da4e03f3ba401d0148fe195",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a67983cd6d8e61565da4e03f3ba401d0148fe195",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a67983cd6d8e61565da4e03f3ba401d0148fe195",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a67983cd6d8e61565da4e03f3ba401d0148fe195/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "272d993e759e7fcfe883b84e9a2a3be3c75177ec",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/272d993e759e7fcfe883b84e9a2a3be3c75177ec",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/272d993e759e7fcfe883b84e9a2a3be3c75177ec"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 1,
      "deletions": 0
    },
    "files": [
      {
        "sha": "d1f0d0f5efacde7ed29465a02760b26ec10b4a7a",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a67983cd6d8e61565da4e03f3ba401d0148fe195/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a67983cd6d8e61565da4e03f3ba401d0148fe195/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=a67983cd6d8e61565da4e03f3ba401d0148fe195",
        "patch": "@@ -1245,6 +1245,7 @@ PeerManagerImpl::PeerManagerImpl(const CChainParams& chainparams, CConnman& conn\n       m_stale_tip_check_time(0),\n       m_ignore_incoming_txs(ignore_incoming_txs)\n {\n+    assert(std::addressof(g_chainman) == std::addressof(m_chainman));\n     // Initialize global variables that cannot be constructed at startup.\n     recentRejects.reset(new CRollingBloomFilter(120000, 0.000001));\n "
      }
    ]
  }
]