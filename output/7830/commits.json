[
  {
    "sha": "e1c9383edc81c67e6c7b8794a649d06d538747b9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMWM5MzgzZWRjODFjNjdlNmM3Yjg3OTRhNjQ5ZDA2ZDUzODc0N2I5",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2016-04-06T19:12:35Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2016-04-06T19:12:35Z"
      },
      "message": "[LightWallet] [copy] src/wallet",
      "tree": {
        "sha": "89dac11e7a3b6ba137601a272e2c8b984c4a1c7c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/89dac11e7a3b6ba137601a272e2c8b984c4a1c7c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e1c9383edc81c67e6c7b8794a649d06d538747b9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "expired_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXBV+xAAoJECnUvLZBb1PswtMP+gIqW2bUuzzhq9yUfLkvVO95\nQ2/OLu53TOwl0QrZIig3oRWusSYZDYAkOUSMWF6ZaWWNDbIsdHjQpKoYXYee+Dhu\nCgxpSEbrOrKF7IRUN9CXgrGoNEpV7hw9t3yjOBVqfXvR+a35yoGgLir8v6VSwKf+\nwn8GFst44NO3IQwQu+/zFUWdajth74+UYe1ierLtt4u8fbZX/cAZnztTiwblaVOl\nKfpNHDplkaV51wZoyj/knxAhJOjttxKTMPzsLMFIAJX0GJnVm6tTH+NmCMEHXe1e\nni5zoVmSiWmEUFwUIzqNFCyhrcS+2L1s/eOSP4zmWXSeIpxMAwr/AgSASfJSK4R0\nmdqfvaymWsRGqkk+wgMIBGghN8mBuzVgCKxYBNWreL4MgT6t7jyXkG8A7L4TQ1v3\nswEDflkDQEoUb2FOuPb/1PXSVTGvIfXTXdNpN+BJDKqdOUu7wkN9f9PKYZhB1FmO\n00rbxvGiULsJfaK88N05kfgXDKjt397cvbbMsyf0Zbf4cG8/6m1HfDmqcecMtd1i\npHvaT70rWY/vRUmIX1Y8bqUekn1jePXn0Zwx6270i9QocnmoOcMf0ZI3Qafa5p0+\n0djtXhRWJe2TozEFRX4NLCtAN+6jmZXNnTOghSbsTsfWMUklZycL9Yvym5LsuzfE\n9Ne47h90j356fGteOEUO\n=Zkn3\n-----END PGP SIGNATURE-----",
        "payload": "tree 89dac11e7a3b6ba137601a272e2c8b984c4a1c7c\nparent 3bc71e1572cbe2e1f85bd487c77a63c46cf4b5bb\nauthor Jonas Schnelli <dev@jonasschnelli.ch> 1459969955 +0200\ncommitter Jonas Schnelli <dev@jonasschnelli.ch> 1459969955 +0200\n\n[LightWallet] [copy] src/wallet\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e1c9383edc81c67e6c7b8794a649d06d538747b9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e1c9383edc81c67e6c7b8794a649d06d538747b9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e1c9383edc81c67e6c7b8794a649d06d538747b9/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3bc71e1572cbe2e1f85bd487c77a63c46cf4b5bb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3bc71e1572cbe2e1f85bd487c77a63c46cf4b5bb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3bc71e1572cbe2e1f85bd487c77a63c46cf4b5bb"
      }
    ],
    "stats": {
      "total": 10430,
      "additions": 10430,
      "deletions": 0
    },
    "files": [
      {
        "sha": "95aa4c25931648d45166886ad860ddf9ced0f313",
        "filename": "src/lightwallet/crypter.cpp",
        "status": "added",
        "additions": 294,
        "deletions": 0,
        "changes": 294,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e1c9383edc81c67e6c7b8794a649d06d538747b9/src/lightwallet/crypter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e1c9383edc81c67e6c7b8794a649d06d538747b9/src/lightwallet/crypter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/crypter.cpp?ref=e1c9383edc81c67e6c7b8794a649d06d538747b9",
        "patch": "@@ -0,0 +1,294 @@\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"crypter.h\"\n+\n+#include \"script/script.h\"\n+#include \"script/standard.h\"\n+#include \"util.h\"\n+\n+#include <string>\n+#include <vector>\n+#include <boost/foreach.hpp>\n+#include <openssl/aes.h>\n+#include <openssl/evp.h>\n+\n+bool CCrypter::SetKeyFromPassphrase(const SecureString& strKeyData, const std::vector<unsigned char>& chSalt, const unsigned int nRounds, const unsigned int nDerivationMethod)\n+{\n+    if (nRounds < 1 || chSalt.size() != WALLET_CRYPTO_SALT_SIZE)\n+        return false;\n+\n+    int i = 0;\n+    if (nDerivationMethod == 0)\n+        i = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha512(), &chSalt[0],\n+                          (unsigned char *)&strKeyData[0], strKeyData.size(), nRounds, chKey, chIV);\n+\n+    if (i != (int)WALLET_CRYPTO_KEY_SIZE)\n+    {\n+        memory_cleanse(chKey, sizeof(chKey));\n+        memory_cleanse(chIV, sizeof(chIV));\n+        return false;\n+    }\n+\n+    fKeySet = true;\n+    return true;\n+}\n+\n+bool CCrypter::SetKey(const CKeyingMaterial& chNewKey, const std::vector<unsigned char>& chNewIV)\n+{\n+    if (chNewKey.size() != WALLET_CRYPTO_KEY_SIZE || chNewIV.size() != WALLET_CRYPTO_KEY_SIZE)\n+        return false;\n+\n+    memcpy(&chKey[0], &chNewKey[0], sizeof chKey);\n+    memcpy(&chIV[0], &chNewIV[0], sizeof chIV);\n+\n+    fKeySet = true;\n+    return true;\n+}\n+\n+bool CCrypter::Encrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned char> &vchCiphertext)\n+{\n+    if (!fKeySet)\n+        return false;\n+\n+    // max ciphertext len for a n bytes of plaintext is\n+    // n + AES_BLOCK_SIZE - 1 bytes\n+    int nLen = vchPlaintext.size();\n+    int nCLen = nLen + AES_BLOCK_SIZE, nFLen = 0;\n+    vchCiphertext = std::vector<unsigned char> (nCLen);\n+\n+    EVP_CIPHER_CTX ctx;\n+\n+    bool fOk = true;\n+\n+    EVP_CIPHER_CTX_init(&ctx);\n+    if (fOk) fOk = EVP_EncryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV) != 0;\n+    if (fOk) fOk = EVP_EncryptUpdate(&ctx, &vchCiphertext[0], &nCLen, &vchPlaintext[0], nLen) != 0;\n+    if (fOk) fOk = EVP_EncryptFinal_ex(&ctx, (&vchCiphertext[0]) + nCLen, &nFLen) != 0;\n+    EVP_CIPHER_CTX_cleanup(&ctx);\n+\n+    if (!fOk) return false;\n+\n+    vchCiphertext.resize(nCLen + nFLen);\n+    return true;\n+}\n+\n+bool CCrypter::Decrypt(const std::vector<unsigned char>& vchCiphertext, CKeyingMaterial& vchPlaintext)\n+{\n+    if (!fKeySet)\n+        return false;\n+\n+    // plaintext will always be equal to or lesser than length of ciphertext\n+    int nLen = vchCiphertext.size();\n+    int nPLen = nLen, nFLen = 0;\n+\n+    vchPlaintext = CKeyingMaterial(nPLen);\n+\n+    EVP_CIPHER_CTX ctx;\n+\n+    bool fOk = true;\n+\n+    EVP_CIPHER_CTX_init(&ctx);\n+    if (fOk) fOk = EVP_DecryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV) != 0;\n+    if (fOk) fOk = EVP_DecryptUpdate(&ctx, &vchPlaintext[0], &nPLen, &vchCiphertext[0], nLen) != 0;\n+    if (fOk) fOk = EVP_DecryptFinal_ex(&ctx, (&vchPlaintext[0]) + nPLen, &nFLen) != 0;\n+    EVP_CIPHER_CTX_cleanup(&ctx);\n+\n+    if (!fOk) return false;\n+\n+    vchPlaintext.resize(nPLen + nFLen);\n+    return true;\n+}\n+\n+\n+static bool EncryptSecret(const CKeyingMaterial& vMasterKey, const CKeyingMaterial &vchPlaintext, const uint256& nIV, std::vector<unsigned char> &vchCiphertext)\n+{\n+    CCrypter cKeyCrypter;\n+    std::vector<unsigned char> chIV(WALLET_CRYPTO_KEY_SIZE);\n+    memcpy(&chIV[0], &nIV, WALLET_CRYPTO_KEY_SIZE);\n+    if(!cKeyCrypter.SetKey(vMasterKey, chIV))\n+        return false;\n+    return cKeyCrypter.Encrypt(*((const CKeyingMaterial*)&vchPlaintext), vchCiphertext);\n+}\n+\n+static bool DecryptSecret(const CKeyingMaterial& vMasterKey, const std::vector<unsigned char>& vchCiphertext, const uint256& nIV, CKeyingMaterial& vchPlaintext)\n+{\n+    CCrypter cKeyCrypter;\n+    std::vector<unsigned char> chIV(WALLET_CRYPTO_KEY_SIZE);\n+    memcpy(&chIV[0], &nIV, WALLET_CRYPTO_KEY_SIZE);\n+    if(!cKeyCrypter.SetKey(vMasterKey, chIV))\n+        return false;\n+    return cKeyCrypter.Decrypt(vchCiphertext, *((CKeyingMaterial*)&vchPlaintext));\n+}\n+\n+static bool DecryptKey(const CKeyingMaterial& vMasterKey, const std::vector<unsigned char>& vchCryptedSecret, const CPubKey& vchPubKey, CKey& key)\n+{\n+    CKeyingMaterial vchSecret;\n+    if(!DecryptSecret(vMasterKey, vchCryptedSecret, vchPubKey.GetHash(), vchSecret))\n+        return false;\n+\n+    if (vchSecret.size() != 32)\n+        return false;\n+\n+    key.Set(vchSecret.begin(), vchSecret.end(), vchPubKey.IsCompressed());\n+    return key.VerifyPubKey(vchPubKey);\n+}\n+\n+bool CCryptoKeyStore::SetCrypted()\n+{\n+    LOCK(cs_KeyStore);\n+    if (fUseCrypto)\n+        return true;\n+    if (!mapKeys.empty())\n+        return false;\n+    fUseCrypto = true;\n+    return true;\n+}\n+\n+bool CCryptoKeyStore::Lock()\n+{\n+    if (!SetCrypted())\n+        return false;\n+\n+    {\n+        LOCK(cs_KeyStore);\n+        vMasterKey.clear();\n+    }\n+\n+    NotifyStatusChanged(this);\n+    return true;\n+}\n+\n+bool CCryptoKeyStore::Unlock(const CKeyingMaterial& vMasterKeyIn)\n+{\n+    {\n+        LOCK(cs_KeyStore);\n+        if (!SetCrypted())\n+            return false;\n+\n+        bool keyPass = false;\n+        bool keyFail = false;\n+        CryptedKeyMap::const_iterator mi = mapCryptedKeys.begin();\n+        for (; mi != mapCryptedKeys.end(); ++mi)\n+        {\n+            const CPubKey &vchPubKey = (*mi).second.first;\n+            const std::vector<unsigned char> &vchCryptedSecret = (*mi).second.second;\n+            CKey key;\n+            if (!DecryptKey(vMasterKeyIn, vchCryptedSecret, vchPubKey, key))\n+            {\n+                keyFail = true;\n+                break;\n+            }\n+            keyPass = true;\n+            if (fDecryptionThoroughlyChecked)\n+                break;\n+        }\n+        if (keyPass && keyFail)\n+        {\n+            LogPrintf(\"The wallet is probably corrupted: Some keys decrypt but not all.\\n\");\n+            assert(false);\n+        }\n+        if (keyFail || !keyPass)\n+            return false;\n+        vMasterKey = vMasterKeyIn;\n+        fDecryptionThoroughlyChecked = true;\n+    }\n+    NotifyStatusChanged(this);\n+    return true;\n+}\n+\n+bool CCryptoKeyStore::AddKeyPubKey(const CKey& key, const CPubKey &pubkey)\n+{\n+    {\n+        LOCK(cs_KeyStore);\n+        if (!IsCrypted())\n+            return CBasicKeyStore::AddKeyPubKey(key, pubkey);\n+\n+        if (IsLocked())\n+            return false;\n+\n+        std::vector<unsigned char> vchCryptedSecret;\n+        CKeyingMaterial vchSecret(key.begin(), key.end());\n+        if (!EncryptSecret(vMasterKey, vchSecret, pubkey.GetHash(), vchCryptedSecret))\n+            return false;\n+\n+        if (!AddCryptedKey(pubkey, vchCryptedSecret))\n+            return false;\n+    }\n+    return true;\n+}\n+\n+\n+bool CCryptoKeyStore::AddCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret)\n+{\n+    {\n+        LOCK(cs_KeyStore);\n+        if (!SetCrypted())\n+            return false;\n+\n+        mapCryptedKeys[vchPubKey.GetID()] = make_pair(vchPubKey, vchCryptedSecret);\n+    }\n+    return true;\n+}\n+\n+bool CCryptoKeyStore::GetKey(const CKeyID &address, CKey& keyOut) const\n+{\n+    {\n+        LOCK(cs_KeyStore);\n+        if (!IsCrypted())\n+            return CBasicKeyStore::GetKey(address, keyOut);\n+\n+        CryptedKeyMap::const_iterator mi = mapCryptedKeys.find(address);\n+        if (mi != mapCryptedKeys.end())\n+        {\n+            const CPubKey &vchPubKey = (*mi).second.first;\n+            const std::vector<unsigned char> &vchCryptedSecret = (*mi).second.second;\n+            return DecryptKey(vMasterKey, vchCryptedSecret, vchPubKey, keyOut);\n+        }\n+    }\n+    return false;\n+}\n+\n+bool CCryptoKeyStore::GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const\n+{\n+    {\n+        LOCK(cs_KeyStore);\n+        if (!IsCrypted())\n+            return CBasicKeyStore::GetPubKey(address, vchPubKeyOut);\n+\n+        CryptedKeyMap::const_iterator mi = mapCryptedKeys.find(address);\n+        if (mi != mapCryptedKeys.end())\n+        {\n+            vchPubKeyOut = (*mi).second.first;\n+            return true;\n+        }\n+        // Check for watch-only pubkeys\n+        return CBasicKeyStore::GetPubKey(address, vchPubKeyOut);\n+    }\n+    return false;\n+}\n+\n+bool CCryptoKeyStore::EncryptKeys(CKeyingMaterial& vMasterKeyIn)\n+{\n+    {\n+        LOCK(cs_KeyStore);\n+        if (!mapCryptedKeys.empty() || IsCrypted())\n+            return false;\n+\n+        fUseCrypto = true;\n+        BOOST_FOREACH(KeyMap::value_type& mKey, mapKeys)\n+        {\n+            const CKey &key = mKey.second;\n+            CPubKey vchPubKey = key.GetPubKey();\n+            CKeyingMaterial vchSecret(key.begin(), key.end());\n+            std::vector<unsigned char> vchCryptedSecret;\n+            if (!EncryptSecret(vMasterKeyIn, vchSecret, vchPubKey.GetHash(), vchCryptedSecret))\n+                return false;\n+            if (!AddCryptedKey(vchPubKey, vchCryptedSecret))\n+                return false;\n+        }\n+        mapKeys.clear();\n+    }\n+    return true;\n+}"
      },
      {
        "sha": "eb06a7866a96c740dff09119dae530be9d1cbb96",
        "filename": "src/lightwallet/crypter.h",
        "status": "added",
        "additions": 196,
        "deletions": 0,
        "changes": 196,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e1c9383edc81c67e6c7b8794a649d06d538747b9/src/lightwallet/crypter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e1c9383edc81c67e6c7b8794a649d06d538747b9/src/lightwallet/crypter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/crypter.h?ref=e1c9383edc81c67e6c7b8794a649d06d538747b9",
        "patch": "@@ -0,0 +1,196 @@\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_WALLET_CRYPTER_H\n+#define BITCOIN_WALLET_CRYPTER_H\n+\n+#include \"keystore.h\"\n+#include \"serialize.h\"\n+#include \"support/allocators/secure.h\"\n+\n+class uint256;\n+\n+const unsigned int WALLET_CRYPTO_KEY_SIZE = 32;\n+const unsigned int WALLET_CRYPTO_SALT_SIZE = 8;\n+\n+/**\n+ * Private key encryption is done based on a CMasterKey,\n+ * which holds a salt and random encryption key.\n+ * \n+ * CMasterKeys are encrypted using AES-256-CBC using a key\n+ * derived using derivation method nDerivationMethod\n+ * (0 == EVP_sha512()) and derivation iterations nDeriveIterations.\n+ * vchOtherDerivationParameters is provided for alternative algorithms\n+ * which may require more parameters (such as scrypt).\n+ * \n+ * Wallet Private Keys are then encrypted using AES-256-CBC\n+ * with the double-sha256 of the public key as the IV, and the\n+ * master key's key as the encryption key (see keystore.[ch]).\n+ */\n+\n+/** Master key for wallet encryption */\n+class CMasterKey\n+{\n+public:\n+    std::vector<unsigned char> vchCryptedKey;\n+    std::vector<unsigned char> vchSalt;\n+    //! 0 = EVP_sha512()\n+    //! 1 = scrypt()\n+    unsigned int nDerivationMethod;\n+    unsigned int nDeriveIterations;\n+    //! Use this for more parameters to key derivation,\n+    //! such as the various parameters to scrypt\n+    std::vector<unsigned char> vchOtherDerivationParameters;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(vchCryptedKey);\n+        READWRITE(vchSalt);\n+        READWRITE(nDerivationMethod);\n+        READWRITE(nDeriveIterations);\n+        READWRITE(vchOtherDerivationParameters);\n+    }\n+\n+    CMasterKey()\n+    {\n+        // 25000 rounds is just under 0.1 seconds on a 1.86 GHz Pentium M\n+        // ie slightly lower than the lowest hardware we need bother supporting\n+        nDeriveIterations = 25000;\n+        nDerivationMethod = 0;\n+        vchOtherDerivationParameters = std::vector<unsigned char>(0);\n+    }\n+};\n+\n+typedef std::vector<unsigned char, secure_allocator<unsigned char> > CKeyingMaterial;\n+\n+/** Encryption/decryption context with key information */\n+class CCrypter\n+{\n+private:\n+    unsigned char chKey[WALLET_CRYPTO_KEY_SIZE];\n+    unsigned char chIV[WALLET_CRYPTO_KEY_SIZE];\n+    bool fKeySet;\n+\n+public:\n+    bool SetKeyFromPassphrase(const SecureString &strKeyData, const std::vector<unsigned char>& chSalt, const unsigned int nRounds, const unsigned int nDerivationMethod);\n+    bool Encrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned char> &vchCiphertext);\n+    bool Decrypt(const std::vector<unsigned char>& vchCiphertext, CKeyingMaterial& vchPlaintext);\n+    bool SetKey(const CKeyingMaterial& chNewKey, const std::vector<unsigned char>& chNewIV);\n+\n+    void CleanKey()\n+    {\n+        memory_cleanse(chKey, sizeof(chKey));\n+        memory_cleanse(chIV, sizeof(chIV));\n+        fKeySet = false;\n+    }\n+\n+    CCrypter()\n+    {\n+        fKeySet = false;\n+\n+        // Try to keep the key data out of swap (and be a bit over-careful to keep the IV that we don't even use out of swap)\n+        // Note that this does nothing about suspend-to-disk (which will put all our key data on disk)\n+        // Note as well that at no point in this program is any attempt made to prevent stealing of keys by reading the memory of the running process.\n+        LockedPageManager::Instance().LockRange(&chKey[0], sizeof chKey);\n+        LockedPageManager::Instance().LockRange(&chIV[0], sizeof chIV);\n+    }\n+\n+    ~CCrypter()\n+    {\n+        CleanKey();\n+\n+        LockedPageManager::Instance().UnlockRange(&chKey[0], sizeof chKey);\n+        LockedPageManager::Instance().UnlockRange(&chIV[0], sizeof chIV);\n+    }\n+};\n+\n+/** Keystore which keeps the private keys encrypted.\n+ * It derives from the basic key store, which is used if no encryption is active.\n+ */\n+class CCryptoKeyStore : public CBasicKeyStore\n+{\n+private:\n+    CryptedKeyMap mapCryptedKeys;\n+\n+    CKeyingMaterial vMasterKey;\n+\n+    //! if fUseCrypto is true, mapKeys must be empty\n+    //! if fUseCrypto is false, vMasterKey must be empty\n+    bool fUseCrypto;\n+\n+    //! keeps track of whether Unlock has run a thorough check before\n+    bool fDecryptionThoroughlyChecked;\n+\n+protected:\n+    bool SetCrypted();\n+\n+    //! will encrypt previously unencrypted keys\n+    bool EncryptKeys(CKeyingMaterial& vMasterKeyIn);\n+\n+    bool Unlock(const CKeyingMaterial& vMasterKeyIn);\n+\n+public:\n+    CCryptoKeyStore() : fUseCrypto(false), fDecryptionThoroughlyChecked(false)\n+    {\n+    }\n+\n+    bool IsCrypted() const\n+    {\n+        return fUseCrypto;\n+    }\n+\n+    bool IsLocked() const\n+    {\n+        if (!IsCrypted())\n+            return false;\n+        bool result;\n+        {\n+            LOCK(cs_KeyStore);\n+            result = vMasterKey.empty();\n+        }\n+        return result;\n+    }\n+\n+    bool Lock();\n+\n+    virtual bool AddCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret);\n+    bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey);\n+    bool HaveKey(const CKeyID &address) const\n+    {\n+        {\n+            LOCK(cs_KeyStore);\n+            if (!IsCrypted())\n+                return CBasicKeyStore::HaveKey(address);\n+            return mapCryptedKeys.count(address) > 0;\n+        }\n+        return false;\n+    }\n+    bool GetKey(const CKeyID &address, CKey& keyOut) const;\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const;\n+    void GetKeys(std::set<CKeyID> &setAddress) const\n+    {\n+        if (!IsCrypted())\n+        {\n+            CBasicKeyStore::GetKeys(setAddress);\n+            return;\n+        }\n+        setAddress.clear();\n+        CryptedKeyMap::const_iterator mi = mapCryptedKeys.begin();\n+        while (mi != mapCryptedKeys.end())\n+        {\n+            setAddress.insert((*mi).first);\n+            mi++;\n+        }\n+    }\n+\n+    /**\n+     * Wallet status (encrypted, locked) changed.\n+     * Note: Called without locks held.\n+     */\n+    boost::signals2::signal<void (CCryptoKeyStore* wallet)> NotifyStatusChanged;\n+};\n+\n+#endif // BITCOIN_WALLET_CRYPTER_H"
      },
      {
        "sha": "c906785e9e2ebf7bff0bb129491b40687da7df70",
        "filename": "src/lightwallet/db.cpp",
        "status": "added",
        "additions": 478,
        "deletions": 0,
        "changes": 478,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e1c9383edc81c67e6c7b8794a649d06d538747b9/src/lightwallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e1c9383edc81c67e6c7b8794a649d06d538747b9/src/lightwallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/db.cpp?ref=e1c9383edc81c67e6c7b8794a649d06d538747b9",
        "patch": "@@ -0,0 +1,478 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"db.h\"\n+\n+#include \"addrman.h\"\n+#include \"hash.h\"\n+#include \"protocol.h\"\n+#include \"util.h\"\n+#include \"utilstrencodings.h\"\n+\n+#include <stdint.h>\n+\n+#ifndef WIN32\n+#include <sys/stat.h>\n+#endif\n+\n+#include <boost/filesystem.hpp>\n+#include <boost/thread.hpp>\n+#include <boost/version.hpp>\n+\n+using namespace std;\n+\n+\n+unsigned int nWalletDBUpdated;\n+\n+\n+//\n+// CDB\n+//\n+\n+CDBEnv bitdb;\n+\n+void CDBEnv::EnvShutdown()\n+{\n+    if (!fDbEnvInit)\n+        return;\n+\n+    fDbEnvInit = false;\n+    int ret = dbenv->close(0);\n+    if (ret != 0)\n+        LogPrintf(\"CDBEnv::EnvShutdown: Error %d shutting down database environment: %s\\n\", ret, DbEnv::strerror(ret));\n+    if (!fMockDb)\n+        DbEnv(0).remove(strPath.c_str(), 0);\n+}\n+\n+void CDBEnv::Reset()\n+{\n+    delete dbenv;\n+    dbenv = new DbEnv(DB_CXX_NO_EXCEPTIONS);\n+    fDbEnvInit = false;\n+    fMockDb = false;\n+}\n+\n+CDBEnv::CDBEnv() : dbenv(NULL)\n+{\n+    Reset();\n+}\n+\n+CDBEnv::~CDBEnv()\n+{\n+    EnvShutdown();\n+    delete dbenv;\n+    dbenv = NULL;\n+}\n+\n+void CDBEnv::Close()\n+{\n+    EnvShutdown();\n+}\n+\n+bool CDBEnv::Open(const boost::filesystem::path& pathIn)\n+{\n+    if (fDbEnvInit)\n+        return true;\n+\n+    boost::this_thread::interruption_point();\n+\n+    strPath = pathIn.string();\n+    boost::filesystem::path pathLogDir = pathIn / \"database\";\n+    TryCreateDirectory(pathLogDir);\n+    boost::filesystem::path pathErrorFile = pathIn / \"db.log\";\n+    LogPrintf(\"CDBEnv::Open: LogDir=%s ErrorFile=%s\\n\", pathLogDir.string(), pathErrorFile.string());\n+\n+    unsigned int nEnvFlags = 0;\n+    if (GetBoolArg(\"-privdb\", DEFAULT_WALLET_PRIVDB))\n+        nEnvFlags |= DB_PRIVATE;\n+\n+    dbenv->set_lg_dir(pathLogDir.string().c_str());\n+    dbenv->set_cachesize(0, 0x100000, 1); // 1 MiB should be enough for just the wallet\n+    dbenv->set_lg_bsize(0x10000);\n+    dbenv->set_lg_max(1048576);\n+    dbenv->set_lk_max_locks(40000);\n+    dbenv->set_lk_max_objects(40000);\n+    dbenv->set_errfile(fopen(pathErrorFile.string().c_str(), \"a\")); /// debug\n+    dbenv->set_flags(DB_AUTO_COMMIT, 1);\n+    dbenv->set_flags(DB_TXN_WRITE_NOSYNC, 1);\n+    dbenv->log_set_config(DB_LOG_AUTO_REMOVE, 1);\n+    int ret = dbenv->open(strPath.c_str(),\n+                         DB_CREATE |\n+                             DB_INIT_LOCK |\n+                             DB_INIT_LOG |\n+                             DB_INIT_MPOOL |\n+                             DB_INIT_TXN |\n+                             DB_THREAD |\n+                             DB_RECOVER |\n+                             nEnvFlags,\n+                         S_IRUSR | S_IWUSR);\n+    if (ret != 0)\n+        return error(\"CDBEnv::Open: Error %d opening database environment: %s\\n\", ret, DbEnv::strerror(ret));\n+\n+    fDbEnvInit = true;\n+    fMockDb = false;\n+    return true;\n+}\n+\n+void CDBEnv::MakeMock()\n+{\n+    if (fDbEnvInit)\n+        throw runtime_error(\"CDBEnv::MakeMock: Already initialized\");\n+\n+    boost::this_thread::interruption_point();\n+\n+    LogPrint(\"db\", \"CDBEnv::MakeMock\\n\");\n+\n+    dbenv->set_cachesize(1, 0, 1);\n+    dbenv->set_lg_bsize(10485760 * 4);\n+    dbenv->set_lg_max(10485760);\n+    dbenv->set_lk_max_locks(10000);\n+    dbenv->set_lk_max_objects(10000);\n+    dbenv->set_flags(DB_AUTO_COMMIT, 1);\n+    dbenv->log_set_config(DB_LOG_IN_MEMORY, 1);\n+    int ret = dbenv->open(NULL,\n+                         DB_CREATE |\n+                             DB_INIT_LOCK |\n+                             DB_INIT_LOG |\n+                             DB_INIT_MPOOL |\n+                             DB_INIT_TXN |\n+                             DB_THREAD |\n+                             DB_PRIVATE,\n+                         S_IRUSR | S_IWUSR);\n+    if (ret > 0)\n+        throw runtime_error(strprintf(\"CDBEnv::MakeMock: Error %d opening database environment.\", ret));\n+\n+    fDbEnvInit = true;\n+    fMockDb = true;\n+}\n+\n+CDBEnv::VerifyResult CDBEnv::Verify(const std::string& strFile, bool (*recoverFunc)(CDBEnv& dbenv, const std::string& strFile))\n+{\n+    LOCK(cs_db);\n+    assert(mapFileUseCount.count(strFile) == 0);\n+\n+    Db db(dbenv, 0);\n+    int result = db.verify(strFile.c_str(), NULL, NULL, 0);\n+    if (result == 0)\n+        return VERIFY_OK;\n+    else if (recoverFunc == NULL)\n+        return RECOVER_FAIL;\n+\n+    // Try to recover:\n+    bool fRecovered = (*recoverFunc)(*this, strFile);\n+    return (fRecovered ? RECOVER_OK : RECOVER_FAIL);\n+}\n+\n+/* End of headers, beginning of key/value data */\n+static const char *HEADER_END = \"HEADER=END\";\n+/* End of key/value data */\n+static const char *DATA_END = \"DATA=END\";\n+\n+bool CDBEnv::Salvage(const std::string& strFile, bool fAggressive, std::vector<CDBEnv::KeyValPair>& vResult)\n+{\n+    LOCK(cs_db);\n+    assert(mapFileUseCount.count(strFile) == 0);\n+\n+    u_int32_t flags = DB_SALVAGE;\n+    if (fAggressive)\n+        flags |= DB_AGGRESSIVE;\n+\n+    stringstream strDump;\n+\n+    Db db(dbenv, 0);\n+    int result = db.verify(strFile.c_str(), NULL, &strDump, flags);\n+    if (result == DB_VERIFY_BAD) {\n+        LogPrintf(\"CDBEnv::Salvage: Database salvage found errors, all data may not be recoverable.\\n\");\n+        if (!fAggressive) {\n+            LogPrintf(\"CDBEnv::Salvage: Rerun with aggressive mode to ignore errors and continue.\\n\");\n+            return false;\n+        }\n+    }\n+    if (result != 0 && result != DB_VERIFY_BAD) {\n+        LogPrintf(\"CDBEnv::Salvage: Database salvage failed with result %d.\\n\", result);\n+        return false;\n+    }\n+\n+    // Format of bdb dump is ascii lines:\n+    // header lines...\n+    // HEADER=END\n+    //  hexadecimal key\n+    //  hexadecimal value\n+    //  ... repeated\n+    // DATA=END\n+\n+    string strLine;\n+    while (!strDump.eof() && strLine != HEADER_END)\n+        getline(strDump, strLine); // Skip past header\n+\n+    std::string keyHex, valueHex;\n+    while (!strDump.eof() && keyHex != DATA_END) {\n+        getline(strDump, keyHex);\n+        if (keyHex != DATA_END) {\n+            if (strDump.eof())\n+                break;\n+            getline(strDump, valueHex);\n+            if (valueHex == DATA_END) {\n+                LogPrintf(\"CDBEnv::Salvage: WARNING: Number of keys in data does not match number of values.\\n\");\n+                break;\n+            }\n+            vResult.push_back(make_pair(ParseHex(keyHex), ParseHex(valueHex)));\n+        }\n+    }\n+\n+    if (keyHex != DATA_END) {\n+        LogPrintf(\"CDBEnv::Salvage: WARNING: Unexpected end of file while reading salvage output.\\n\");\n+        return false;\n+    }\n+\n+    return (result == 0);\n+}\n+\n+\n+void CDBEnv::CheckpointLSN(const std::string& strFile)\n+{\n+    dbenv->txn_checkpoint(0, 0, 0);\n+    if (fMockDb)\n+        return;\n+    dbenv->lsn_reset(strFile.c_str(), 0);\n+}\n+\n+\n+CDB::CDB(const std::string& strFilename, const char* pszMode, bool fFlushOnCloseIn) : pdb(NULL), activeTxn(NULL)\n+{\n+    int ret;\n+    fReadOnly = (!strchr(pszMode, '+') && !strchr(pszMode, 'w'));\n+    fFlushOnClose = fFlushOnCloseIn;\n+    if (strFilename.empty())\n+        return;\n+\n+    bool fCreate = strchr(pszMode, 'c') != NULL;\n+    unsigned int nFlags = DB_THREAD;\n+    if (fCreate)\n+        nFlags |= DB_CREATE;\n+\n+    {\n+        LOCK(bitdb.cs_db);\n+        if (!bitdb.Open(GetDataDir()))\n+            throw runtime_error(\"CDB: Failed to open database environment.\");\n+\n+        strFile = strFilename;\n+        ++bitdb.mapFileUseCount[strFile];\n+        pdb = bitdb.mapDb[strFile];\n+        if (pdb == NULL) {\n+            pdb = new Db(bitdb.dbenv, 0);\n+\n+            bool fMockDb = bitdb.IsMock();\n+            if (fMockDb) {\n+                DbMpoolFile* mpf = pdb->get_mpf();\n+                ret = mpf->set_flags(DB_MPOOL_NOFILE, 1);\n+                if (ret != 0)\n+                    throw runtime_error(strprintf(\"CDB: Failed to configure for no temp file backing for database %s\", strFile));\n+            }\n+\n+            ret = pdb->open(NULL,                               // Txn pointer\n+                            fMockDb ? NULL : strFile.c_str(),   // Filename\n+                            fMockDb ? strFile.c_str() : \"main\", // Logical db name\n+                            DB_BTREE,                           // Database type\n+                            nFlags,                             // Flags\n+                            0);\n+\n+            if (ret != 0) {\n+                delete pdb;\n+                pdb = NULL;\n+                --bitdb.mapFileUseCount[strFile];\n+                strFile = \"\";\n+                throw runtime_error(strprintf(\"CDB: Error %d, can't open database %s\", ret, strFile));\n+            }\n+\n+            if (fCreate && !Exists(string(\"version\"))) {\n+                bool fTmp = fReadOnly;\n+                fReadOnly = false;\n+                WriteVersion(CLIENT_VERSION);\n+                fReadOnly = fTmp;\n+            }\n+\n+            bitdb.mapDb[strFile] = pdb;\n+        }\n+    }\n+}\n+\n+void CDB::Flush()\n+{\n+    if (activeTxn)\n+        return;\n+\n+    // Flush database activity from memory pool to disk log\n+    unsigned int nMinutes = 0;\n+    if (fReadOnly)\n+        nMinutes = 1;\n+\n+    bitdb.dbenv->txn_checkpoint(nMinutes ? GetArg(\"-dblogsize\", DEFAULT_WALLET_DBLOGSIZE) * 1024 : 0, nMinutes, 0);\n+}\n+\n+void CDB::Close()\n+{\n+    if (!pdb)\n+        return;\n+    if (activeTxn)\n+        activeTxn->abort();\n+    activeTxn = NULL;\n+    pdb = NULL;\n+\n+    if (fFlushOnClose)\n+        Flush();\n+\n+    {\n+        LOCK(bitdb.cs_db);\n+        --bitdb.mapFileUseCount[strFile];\n+    }\n+}\n+\n+void CDBEnv::CloseDb(const string& strFile)\n+{\n+    {\n+        LOCK(cs_db);\n+        if (mapDb[strFile] != NULL) {\n+            // Close the database handle\n+            Db* pdb = mapDb[strFile];\n+            pdb->close(0);\n+            delete pdb;\n+            mapDb[strFile] = NULL;\n+        }\n+    }\n+}\n+\n+bool CDBEnv::RemoveDb(const string& strFile)\n+{\n+    this->CloseDb(strFile);\n+\n+    LOCK(cs_db);\n+    int rc = dbenv->dbremove(NULL, strFile.c_str(), NULL, DB_AUTO_COMMIT);\n+    return (rc == 0);\n+}\n+\n+bool CDB::Rewrite(const string& strFile, const char* pszSkip)\n+{\n+    while (true) {\n+        {\n+            LOCK(bitdb.cs_db);\n+            if (!bitdb.mapFileUseCount.count(strFile) || bitdb.mapFileUseCount[strFile] == 0) {\n+                // Flush log data to the dat file\n+                bitdb.CloseDb(strFile);\n+                bitdb.CheckpointLSN(strFile);\n+                bitdb.mapFileUseCount.erase(strFile);\n+\n+                bool fSuccess = true;\n+                LogPrintf(\"CDB::Rewrite: Rewriting %s...\\n\", strFile);\n+                string strFileRes = strFile + \".rewrite\";\n+                { // surround usage of db with extra {}\n+                    CDB db(strFile.c_str(), \"r\");\n+                    Db* pdbCopy = new Db(bitdb.dbenv, 0);\n+\n+                    int ret = pdbCopy->open(NULL,               // Txn pointer\n+                                            strFileRes.c_str(), // Filename\n+                                            \"main\",             // Logical db name\n+                                            DB_BTREE,           // Database type\n+                                            DB_CREATE,          // Flags\n+                                            0);\n+                    if (ret > 0) {\n+                        LogPrintf(\"CDB::Rewrite: Can't create database file %s\\n\", strFileRes);\n+                        fSuccess = false;\n+                    }\n+\n+                    Dbc* pcursor = db.GetCursor();\n+                    if (pcursor)\n+                        while (fSuccess) {\n+                            CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+                            CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n+                            int ret = db.ReadAtCursor(pcursor, ssKey, ssValue, DB_NEXT);\n+                            if (ret == DB_NOTFOUND) {\n+                                pcursor->close();\n+                                break;\n+                            } else if (ret != 0) {\n+                                pcursor->close();\n+                                fSuccess = false;\n+                                break;\n+                            }\n+                            if (pszSkip &&\n+                                strncmp(&ssKey[0], pszSkip, std::min(ssKey.size(), strlen(pszSkip))) == 0)\n+                                continue;\n+                            if (strncmp(&ssKey[0], \"\\x07version\", 8) == 0) {\n+                                // Update version:\n+                                ssValue.clear();\n+                                ssValue << CLIENT_VERSION;\n+                            }\n+                            Dbt datKey(&ssKey[0], ssKey.size());\n+                            Dbt datValue(&ssValue[0], ssValue.size());\n+                            int ret2 = pdbCopy->put(NULL, &datKey, &datValue, DB_NOOVERWRITE);\n+                            if (ret2 > 0)\n+                                fSuccess = false;\n+                        }\n+                    if (fSuccess) {\n+                        db.Close();\n+                        bitdb.CloseDb(strFile);\n+                        if (pdbCopy->close(0))\n+                            fSuccess = false;\n+                        delete pdbCopy;\n+                    }\n+                }\n+                if (fSuccess) {\n+                    Db dbA(bitdb.dbenv, 0);\n+                    if (dbA.remove(strFile.c_str(), NULL, 0))\n+                        fSuccess = false;\n+                    Db dbB(bitdb.dbenv, 0);\n+                    if (dbB.rename(strFileRes.c_str(), NULL, strFile.c_str(), 0))\n+                        fSuccess = false;\n+                }\n+                if (!fSuccess)\n+                    LogPrintf(\"CDB::Rewrite: Failed to rewrite database file %s\\n\", strFileRes);\n+                return fSuccess;\n+            }\n+        }\n+        MilliSleep(100);\n+    }\n+    return false;\n+}\n+\n+\n+void CDBEnv::Flush(bool fShutdown)\n+{\n+    int64_t nStart = GetTimeMillis();\n+    // Flush log data to the actual data file on all files that are not in use\n+    LogPrint(\"db\", \"CDBEnv::Flush: Flush(%s)%s\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" database not started\");\n+    if (!fDbEnvInit)\n+        return;\n+    {\n+        LOCK(cs_db);\n+        map<string, int>::iterator mi = mapFileUseCount.begin();\n+        while (mi != mapFileUseCount.end()) {\n+            string strFile = (*mi).first;\n+            int nRefCount = (*mi).second;\n+            LogPrint(\"db\", \"CDBEnv::Flush: Flushing %s (refcount = %d)...\\n\", strFile, nRefCount);\n+            if (nRefCount == 0) {\n+                // Move log data to the dat file\n+                CloseDb(strFile);\n+                LogPrint(\"db\", \"CDBEnv::Flush: %s checkpoint\\n\", strFile);\n+                dbenv->txn_checkpoint(0, 0, 0);\n+                LogPrint(\"db\", \"CDBEnv::Flush: %s detach\\n\", strFile);\n+                if (!fMockDb)\n+                    dbenv->lsn_reset(strFile.c_str(), 0);\n+                LogPrint(\"db\", \"CDBEnv::Flush: %s closed\\n\", strFile);\n+                mapFileUseCount.erase(mi++);\n+            } else\n+                mi++;\n+        }\n+        LogPrint(\"db\", \"CDBEnv::Flush: Flush(%s)%s took %15dms\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" database not started\", GetTimeMillis() - nStart);\n+        if (fShutdown) {\n+            char** listp;\n+            if (mapFileUseCount.empty()) {\n+                dbenv->log_archive(&listp, DB_ARCH_REMOVE);\n+                Close();\n+                if (!fMockDb)\n+                    boost::filesystem::remove_all(boost::filesystem::path(strPath) / \"database\");\n+            }\n+        }\n+    }\n+}"
      },
      {
        "sha": "01b8c71a04bbbeb4bd195df8267b37a22222e141",
        "filename": "src/lightwallet/db.h",
        "status": "added",
        "additions": 312,
        "deletions": 0,
        "changes": 312,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e1c9383edc81c67e6c7b8794a649d06d538747b9/src/lightwallet/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e1c9383edc81c67e6c7b8794a649d06d538747b9/src/lightwallet/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/db.h?ref=e1c9383edc81c67e6c7b8794a649d06d538747b9",
        "patch": "@@ -0,0 +1,312 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_WALLET_DB_H\n+#define BITCOIN_WALLET_DB_H\n+\n+#include \"clientversion.h\"\n+#include \"serialize.h\"\n+#include \"streams.h\"\n+#include \"sync.h\"\n+#include \"version.h\"\n+\n+#include <map>\n+#include <string>\n+#include <vector>\n+\n+#include <boost/filesystem/path.hpp>\n+\n+#include <db_cxx.h>\n+\n+static const unsigned int DEFAULT_WALLET_DBLOGSIZE = 100;\n+static const bool DEFAULT_WALLET_PRIVDB = true;\n+\n+extern unsigned int nWalletDBUpdated;\n+\n+class CDBEnv\n+{\n+private:\n+    bool fDbEnvInit;\n+    bool fMockDb;\n+    // Don't change into boost::filesystem::path, as that can result in\n+    // shutdown problems/crashes caused by a static initialized internal pointer.\n+    std::string strPath;\n+\n+    void EnvShutdown();\n+\n+public:\n+    mutable CCriticalSection cs_db;\n+    DbEnv *dbenv;\n+    std::map<std::string, int> mapFileUseCount;\n+    std::map<std::string, Db*> mapDb;\n+\n+    CDBEnv();\n+    ~CDBEnv();\n+    void Reset();\n+\n+    void MakeMock();\n+    bool IsMock() { return fMockDb; }\n+\n+    /**\n+     * Verify that database file strFile is OK. If it is not,\n+     * call the callback to try to recover.\n+     * This must be called BEFORE strFile is opened.\n+     * Returns true if strFile is OK.\n+     */\n+    enum VerifyResult { VERIFY_OK,\n+                        RECOVER_OK,\n+                        RECOVER_FAIL };\n+    VerifyResult Verify(const std::string& strFile, bool (*recoverFunc)(CDBEnv& dbenv, const std::string& strFile));\n+    /**\n+     * Salvage data from a file that Verify says is bad.\n+     * fAggressive sets the DB_AGGRESSIVE flag (see berkeley DB->verify() method documentation).\n+     * Appends binary key/value pairs to vResult, returns true if successful.\n+     * NOTE: reads the entire database into memory, so cannot be used\n+     * for huge databases.\n+     */\n+    typedef std::pair<std::vector<unsigned char>, std::vector<unsigned char> > KeyValPair;\n+    bool Salvage(const std::string& strFile, bool fAggressive, std::vector<KeyValPair>& vResult);\n+\n+    bool Open(const boost::filesystem::path& path);\n+    void Close();\n+    void Flush(bool fShutdown);\n+    void CheckpointLSN(const std::string& strFile);\n+\n+    void CloseDb(const std::string& strFile);\n+    bool RemoveDb(const std::string& strFile);\n+\n+    DbTxn* TxnBegin(int flags = DB_TXN_WRITE_NOSYNC)\n+    {\n+        DbTxn* ptxn = NULL;\n+        int ret = dbenv->txn_begin(NULL, &ptxn, flags);\n+        if (!ptxn || ret != 0)\n+            return NULL;\n+        return ptxn;\n+    }\n+};\n+\n+extern CDBEnv bitdb;\n+\n+\n+/** RAII class that provides access to a Berkeley database */\n+class CDB\n+{\n+protected:\n+    Db* pdb;\n+    std::string strFile;\n+    DbTxn* activeTxn;\n+    bool fReadOnly;\n+    bool fFlushOnClose;\n+\n+    explicit CDB(const std::string& strFilename, const char* pszMode = \"r+\", bool fFlushOnCloseIn=true);\n+    ~CDB() { Close(); }\n+\n+public:\n+    void Flush();\n+    void Close();\n+\n+private:\n+    CDB(const CDB&);\n+    void operator=(const CDB&);\n+\n+protected:\n+    template <typename K, typename T>\n+    bool Read(const K& key, T& value)\n+    {\n+        if (!pdb)\n+            return false;\n+\n+        // Key\n+        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+        ssKey.reserve(1000);\n+        ssKey << key;\n+        Dbt datKey(&ssKey[0], ssKey.size());\n+\n+        // Read\n+        Dbt datValue;\n+        datValue.set_flags(DB_DBT_MALLOC);\n+        int ret = pdb->get(activeTxn, &datKey, &datValue, 0);\n+        memset(datKey.get_data(), 0, datKey.get_size());\n+        if (datValue.get_data() == NULL)\n+            return false;\n+\n+        // Unserialize value\n+        try {\n+            CDataStream ssValue((char*)datValue.get_data(), (char*)datValue.get_data() + datValue.get_size(), SER_DISK, CLIENT_VERSION);\n+            ssValue >> value;\n+        } catch (const std::exception&) {\n+            return false;\n+        }\n+\n+        // Clear and free memory\n+        memset(datValue.get_data(), 0, datValue.get_size());\n+        free(datValue.get_data());\n+        return (ret == 0);\n+    }\n+\n+    template <typename K, typename T>\n+    bool Write(const K& key, const T& value, bool fOverwrite = true)\n+    {\n+        if (!pdb)\n+            return false;\n+        if (fReadOnly)\n+            assert(!\"Write called on database in read-only mode\");\n+\n+        // Key\n+        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+        ssKey.reserve(1000);\n+        ssKey << key;\n+        Dbt datKey(&ssKey[0], ssKey.size());\n+\n+        // Value\n+        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n+        ssValue.reserve(10000);\n+        ssValue << value;\n+        Dbt datValue(&ssValue[0], ssValue.size());\n+\n+        // Write\n+        int ret = pdb->put(activeTxn, &datKey, &datValue, (fOverwrite ? 0 : DB_NOOVERWRITE));\n+\n+        // Clear memory in case it was a private key\n+        memset(datKey.get_data(), 0, datKey.get_size());\n+        memset(datValue.get_data(), 0, datValue.get_size());\n+        return (ret == 0);\n+    }\n+\n+    template <typename K>\n+    bool Erase(const K& key)\n+    {\n+        if (!pdb)\n+            return false;\n+        if (fReadOnly)\n+            assert(!\"Erase called on database in read-only mode\");\n+\n+        // Key\n+        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+        ssKey.reserve(1000);\n+        ssKey << key;\n+        Dbt datKey(&ssKey[0], ssKey.size());\n+\n+        // Erase\n+        int ret = pdb->del(activeTxn, &datKey, 0);\n+\n+        // Clear memory\n+        memset(datKey.get_data(), 0, datKey.get_size());\n+        return (ret == 0 || ret == DB_NOTFOUND);\n+    }\n+\n+    template <typename K>\n+    bool Exists(const K& key)\n+    {\n+        if (!pdb)\n+            return false;\n+\n+        // Key\n+        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+        ssKey.reserve(1000);\n+        ssKey << key;\n+        Dbt datKey(&ssKey[0], ssKey.size());\n+\n+        // Exists\n+        int ret = pdb->exists(activeTxn, &datKey, 0);\n+\n+        // Clear memory\n+        memset(datKey.get_data(), 0, datKey.get_size());\n+        return (ret == 0);\n+    }\n+\n+    Dbc* GetCursor()\n+    {\n+        if (!pdb)\n+            return NULL;\n+        Dbc* pcursor = NULL;\n+        int ret = pdb->cursor(NULL, &pcursor, 0);\n+        if (ret != 0)\n+            return NULL;\n+        return pcursor;\n+    }\n+\n+    int ReadAtCursor(Dbc* pcursor, CDataStream& ssKey, CDataStream& ssValue, unsigned int fFlags = DB_NEXT)\n+    {\n+        // Read at cursor\n+        Dbt datKey;\n+        if (fFlags == DB_SET || fFlags == DB_SET_RANGE || fFlags == DB_GET_BOTH || fFlags == DB_GET_BOTH_RANGE) {\n+            datKey.set_data(&ssKey[0]);\n+            datKey.set_size(ssKey.size());\n+        }\n+        Dbt datValue;\n+        if (fFlags == DB_GET_BOTH || fFlags == DB_GET_BOTH_RANGE) {\n+            datValue.set_data(&ssValue[0]);\n+            datValue.set_size(ssValue.size());\n+        }\n+        datKey.set_flags(DB_DBT_MALLOC);\n+        datValue.set_flags(DB_DBT_MALLOC);\n+        int ret = pcursor->get(&datKey, &datValue, fFlags);\n+        if (ret != 0)\n+            return ret;\n+        else if (datKey.get_data() == NULL || datValue.get_data() == NULL)\n+            return 99999;\n+\n+        // Convert to streams\n+        ssKey.SetType(SER_DISK);\n+        ssKey.clear();\n+        ssKey.write((char*)datKey.get_data(), datKey.get_size());\n+        ssValue.SetType(SER_DISK);\n+        ssValue.clear();\n+        ssValue.write((char*)datValue.get_data(), datValue.get_size());\n+\n+        // Clear and free memory\n+        memset(datKey.get_data(), 0, datKey.get_size());\n+        memset(datValue.get_data(), 0, datValue.get_size());\n+        free(datKey.get_data());\n+        free(datValue.get_data());\n+        return 0;\n+    }\n+\n+public:\n+    bool TxnBegin()\n+    {\n+        if (!pdb || activeTxn)\n+            return false;\n+        DbTxn* ptxn = bitdb.TxnBegin();\n+        if (!ptxn)\n+            return false;\n+        activeTxn = ptxn;\n+        return true;\n+    }\n+\n+    bool TxnCommit()\n+    {\n+        if (!pdb || !activeTxn)\n+            return false;\n+        int ret = activeTxn->commit(0);\n+        activeTxn = NULL;\n+        return (ret == 0);\n+    }\n+\n+    bool TxnAbort()\n+    {\n+        if (!pdb || !activeTxn)\n+            return false;\n+        int ret = activeTxn->abort();\n+        activeTxn = NULL;\n+        return (ret == 0);\n+    }\n+\n+    bool ReadVersion(int& nVersion)\n+    {\n+        nVersion = 0;\n+        return Read(std::string(\"version\"), nVersion);\n+    }\n+\n+    bool WriteVersion(int nVersion)\n+    {\n+        return Write(std::string(\"version\"), nVersion);\n+    }\n+\n+    bool static Rewrite(const std::string& strFile, const char* pszSkip = NULL);\n+};\n+\n+#endif // BITCOIN_WALLET_DB_H"
      },
      {
        "sha": "bb40cf724536a464fec3a0121f9b97372e5e3de1",
        "filename": "src/lightwallet/rpcdump.cpp",
        "status": "added",
        "additions": 617,
        "deletions": 0,
        "changes": 617,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e1c9383edc81c67e6c7b8794a649d06d538747b9/src/lightwallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e1c9383edc81c67e6c7b8794a649d06d538747b9/src/lightwallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/rpcdump.cpp?ref=e1c9383edc81c67e6c7b8794a649d06d538747b9",
        "patch": "@@ -0,0 +1,617 @@\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"base58.h\"\n+#include \"chain.h\"\n+#include \"rpc/server.h\"\n+#include \"init.h\"\n+#include \"main.h\"\n+#include \"script/script.h\"\n+#include \"script/standard.h\"\n+#include \"sync.h\"\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"wallet.h\"\n+#include \"merkleblock.h\"\n+#include \"core_io.h\"\n+\n+#include <fstream>\n+#include <stdint.h>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/date_time/posix_time/posix_time.hpp>\n+\n+#include <univalue.h>\n+\n+#include <boost/foreach.hpp>\n+\n+using namespace std;\n+\n+void EnsureWalletIsUnlocked();\n+bool EnsureWalletIsAvailable(bool avoidException);\n+\n+std::string static EncodeDumpTime(int64_t nTime) {\n+    return DateTimeStrFormat(\"%Y-%m-%dT%H:%M:%SZ\", nTime);\n+}\n+\n+int64_t static DecodeDumpTime(const std::string &str) {\n+    static const boost::posix_time::ptime epoch = boost::posix_time::from_time_t(0);\n+    static const std::locale loc(std::locale::classic(),\n+        new boost::posix_time::time_input_facet(\"%Y-%m-%dT%H:%M:%SZ\"));\n+    std::istringstream iss(str);\n+    iss.imbue(loc);\n+    boost::posix_time::ptime ptime(boost::date_time::not_a_date_time);\n+    iss >> ptime;\n+    if (ptime.is_not_a_date_time())\n+        return 0;\n+    return (ptime - epoch).total_seconds();\n+}\n+\n+std::string static EncodeDumpString(const std::string &str) {\n+    std::stringstream ret;\n+    BOOST_FOREACH(unsigned char c, str) {\n+        if (c <= 32 || c >= 128 || c == '%') {\n+            ret << '%' << HexStr(&c, &c + 1);\n+        } else {\n+            ret << c;\n+        }\n+    }\n+    return ret.str();\n+}\n+\n+std::string DecodeDumpString(const std::string &str) {\n+    std::stringstream ret;\n+    for (unsigned int pos = 0; pos < str.length(); pos++) {\n+        unsigned char c = str[pos];\n+        if (c == '%' && pos+2 < str.length()) {\n+            c = (((str[pos+1]>>6)*9+((str[pos+1]-'0')&15)) << 4) | \n+                ((str[pos+2]>>6)*9+((str[pos+2]-'0')&15));\n+            pos += 2;\n+        }\n+        ret << c;\n+    }\n+    return ret.str();\n+}\n+\n+UniValue importprivkey(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+    \n+    if (fHelp || params.size() < 1 || params.size() > 3)\n+        throw runtime_error(\n+            \"importprivkey \\\"bitcoinprivkey\\\" ( \\\"label\\\" rescan )\\n\"\n+            \"\\nAdds a private key (as returned by dumpprivkey) to your wallet.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"bitcoinprivkey\\\"   (string, required) The private key (see dumpprivkey)\\n\"\n+            \"2. \\\"label\\\"            (string, optional, default=\\\"\\\") An optional label\\n\"\n+            \"3. rescan               (boolean, optional, default=true) Rescan the wallet for transactions\\n\"\n+            \"\\nNote: This call can take minutes to complete if rescan is true.\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nDump a private key\\n\"\n+            + HelpExampleCli(\"dumpprivkey\", \"\\\"myaddress\\\"\") +\n+            \"\\nImport the private key with rescan\\n\"\n+            + HelpExampleCli(\"importprivkey\", \"\\\"mykey\\\"\") +\n+            \"\\nImport using a label and without rescan\\n\"\n+            + HelpExampleCli(\"importprivkey\", \"\\\"mykey\\\" \\\"testing\\\" false\") +\n+            \"\\nAs a JSON-RPC call\\n\"\n+            + HelpExampleRpc(\"importprivkey\", \"\\\"mykey\\\", \\\"testing\\\", false\")\n+        );\n+\n+\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+\n+    EnsureWalletIsUnlocked();\n+\n+    string strSecret = params[0].get_str();\n+    string strLabel = \"\";\n+    if (params.size() > 1)\n+        strLabel = params[1].get_str();\n+\n+    // Whether to perform rescan after import\n+    bool fRescan = true;\n+    if (params.size() > 2)\n+        fRescan = params[2].get_bool();\n+\n+    if (fRescan && fPruneMode)\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Rescan is disabled in pruned mode\");\n+\n+    CBitcoinSecret vchSecret;\n+    bool fGood = vchSecret.SetString(strSecret);\n+\n+    if (!fGood) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+\n+    CKey key = vchSecret.GetKey();\n+    if (!key.IsValid()) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+\n+    CPubKey pubkey = key.GetPubKey();\n+    assert(key.VerifyPubKey(pubkey));\n+    CKeyID vchAddress = pubkey.GetID();\n+    {\n+        pwalletMain->MarkDirty();\n+        pwalletMain->SetAddressBook(vchAddress, strLabel, \"receive\");\n+\n+        // Don't throw error in case a key is already there\n+        if (pwalletMain->HaveKey(vchAddress))\n+            return NullUniValue;\n+\n+        pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = 1;\n+\n+        if (!pwalletMain->AddKeyPubKey(key, pubkey))\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+\n+        // whenever a key is imported, we need to scan the whole chain\n+        pwalletMain->nTimeFirstKey = 1; // 0 would be considered 'no value'\n+\n+        if (fRescan) {\n+            pwalletMain->ScanForWalletTransactions(chainActive.Genesis(), true);\n+        }\n+    }\n+\n+    return NullUniValue;\n+}\n+\n+void ImportAddress(const CBitcoinAddress& address, const string& strLabel);\n+void ImportScript(const CScript& script, const string& strLabel, bool isRedeemScript)\n+{\n+    if (!isRedeemScript && ::IsMine(*pwalletMain, script) == ISMINE_SPENDABLE)\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+\n+    pwalletMain->MarkDirty();\n+\n+    if (!pwalletMain->HaveWatchOnly(script) && !pwalletMain->AddWatchOnly(script))\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+    if (isRedeemScript) {\n+        if (!pwalletMain->HaveCScript(script) && !pwalletMain->AddCScript(script))\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        ImportAddress(CBitcoinAddress(CScriptID(script)), strLabel);\n+    }\n+}\n+\n+void ImportAddress(const CBitcoinAddress& address, const string& strLabel)\n+{\n+    CScript script = GetScriptForDestination(address.Get());\n+    ImportScript(script, strLabel, false);\n+    // add to address book or update label\n+    if (address.IsValid())\n+        pwalletMain->SetAddressBook(address.Get(), strLabel, \"receive\");\n+}\n+\n+UniValue importaddress(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+    \n+    if (fHelp || params.size() < 1 || params.size() > 4)\n+        throw runtime_error(\n+            \"importaddress \\\"address\\\" ( \\\"label\\\" rescan p2sh )\\n\"\n+            \"\\nAdds a script (in hex) or address that can be watched as if it were in your wallet but cannot be used to spend.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"script\\\"           (string, required) The hex-encoded script (or address)\\n\"\n+            \"2. \\\"label\\\"            (string, optional, default=\\\"\\\") An optional label\\n\"\n+            \"3. rescan               (boolean, optional, default=true) Rescan the wallet for transactions\\n\"\n+            \"4. p2sh                 (boolean, optional, default=false) Add the P2SH version of the script as well\\n\"\n+            \"\\nNote: This call can take minutes to complete if rescan is true.\\n\"\n+            \"If you have the full public key, you should call importpubkey instead of this.\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nImport a script with rescan\\n\"\n+            + HelpExampleCli(\"importaddress\", \"\\\"myscript\\\"\") +\n+            \"\\nImport using a label without rescan\\n\"\n+            + HelpExampleCli(\"importaddress\", \"\\\"myscript\\\" \\\"testing\\\" false\") +\n+            \"\\nAs a JSON-RPC call\\n\"\n+            + HelpExampleRpc(\"importaddress\", \"\\\"myscript\\\", \\\"testing\\\", false\")\n+        );\n+\n+\n+    string strLabel = \"\";\n+    if (params.size() > 1)\n+        strLabel = params[1].get_str();\n+\n+    // Whether to perform rescan after import\n+    bool fRescan = true;\n+    if (params.size() > 2)\n+        fRescan = params[2].get_bool();\n+\n+    if (fRescan && fPruneMode)\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Rescan is disabled in pruned mode\");\n+\n+    // Whether to import a p2sh version, too\n+    bool fP2SH = false;\n+    if (params.size() > 3)\n+        fP2SH = params[3].get_bool();\n+\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+\n+    CBitcoinAddress address(params[0].get_str());\n+    if (address.IsValid()) {\n+        if (fP2SH)\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Cannot use the p2sh flag with an address - use a script instead\");\n+        ImportAddress(address, strLabel);\n+    } else if (IsHex(params[0].get_str())) {\n+        std::vector<unsigned char> data(ParseHex(params[0].get_str()));\n+        ImportScript(CScript(data.begin(), data.end()), strLabel, fP2SH);\n+    } else {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address or script\");\n+    }\n+\n+    if (fRescan)\n+    {\n+        pwalletMain->ScanForWalletTransactions(chainActive.Genesis(), true);\n+        pwalletMain->ReacceptWalletTransactions();\n+    }\n+\n+    return NullUniValue;\n+}\n+\n+UniValue importprunedfunds(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+            \"importprunedfunds\\n\"\n+            \"\\nImports funds without rescan. Corresponding address or script must previously be included in wallet. Aimed towards pruned wallets. The end-user is responsible to import additional transactions that subsequently spend the imported outputs or rescan after the point in the blockchain the transaction is included.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"rawtransaction\\\" (string, required) A raw transaction in hex funding an already-existing address in wallet\\n\"\n+            \"2. \\\"txoutproof\\\"     (string, required) The hex output from gettxoutproof that contains the transaction\\n\"\n+            \"3. \\\"label\\\"          (string, optional) An optional label\\n\"\n+        );\n+\n+    CTransaction tx;\n+    if (!DecodeHexTx(tx, params[0].get_str()))\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n+    uint256 hashTx = tx.GetHash();\n+    CWalletTx wtx(pwalletMain,tx);\n+\n+    CDataStream ssMB(ParseHexV(params[1], \"proof\"), SER_NETWORK, PROTOCOL_VERSION);\n+    CMerkleBlock merkleBlock;\n+    ssMB >> merkleBlock;\n+\n+    string strLabel = \"\";\n+    if (params.size() == 3)\n+        strLabel = params[2].get_str();\n+\n+    //Search partial merkle tree in proof for our transaction and index in valid block\n+    vector<uint256> vMatch;\n+    vector<unsigned int> vIndex;\n+    unsigned int txnIndex = 0;\n+    if (merkleBlock.txn.ExtractMatches(vMatch, vIndex) == merkleBlock.header.hashMerkleRoot) {\n+\n+        LOCK(cs_main);\n+\n+        if (!mapBlockIndex.count(merkleBlock.header.GetHash()) || !chainActive.Contains(mapBlockIndex[merkleBlock.header.GetHash()]))\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found in chain\");\n+\n+        vector<uint256>::const_iterator it;\n+        if ((it = std::find(vMatch.begin(), vMatch.end(), hashTx))==vMatch.end()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction given doesn't exist in proof\");\n+        }\n+\n+        txnIndex = vIndex[it - vMatch.begin()];\n+    }\n+    else {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Something wrong with merkleblock\");\n+    }\n+\n+    wtx.nIndex = txnIndex;\n+    wtx.hashBlock = merkleBlock.header.GetHash();\n+\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+\n+    if (pwalletMain->IsMine(tx)) {\n+        CWalletDB walletdb(pwalletMain->strWalletFile, \"r+\", false);\n+        pwalletMain->AddToWallet(wtx, false, &walletdb);\n+        return NullUniValue;\n+    }\n+\n+    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No addresses in wallet correspond to included transaction\");\n+}\n+\n+UniValue removeprunedfunds(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\n+            \"removeprunedfunds \\\"txid\\\"\\n\"\n+            \"\\nDeletes the specified transaction from the wallet. Meant for use with pruned wallets and as a companion to importprunedfunds. This will effect wallet balances.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txid\\\"           (string, required) The hex-encoded id of the transaction you are deleting\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"removeprunedfunds\", \"\\\"a8d0c0184dde994a09ec054286f1ce581bebf46446a512166eae7628734ea0a5\\\"\") +\n+            \"\\nAs a JSON-RPC call\\n\"\n+            + HelpExampleRpc(\"removprunedfunds\", \"\\\"a8d0c0184dde994a09ec054286f1ce581bebf46446a512166eae7628734ea0a5\\\"\")\n+        );\n+\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    vector<uint256> vHash;\n+    vHash.push_back(hash);\n+    vector<uint256> vHashOut;\n+\n+    if(pwalletMain->ZapSelectTx(vHash, vHashOut) != DB_LOAD_OK) {\n+        throw JSONRPCError(RPC_INTERNAL_ERROR, \"Could not properly delete the transaction.\");\n+    }\n+\n+    if(vHashOut.empty()) {\n+        throw JSONRPCError(RPC_INTERNAL_ERROR, \"Transaction does not exist in wallet.\");\n+    }\n+\n+    ThreadFlushWalletDB(pwalletMain->strWalletFile);\n+\n+    return NullUniValue;\n+}\n+\n+UniValue importpubkey(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 1 || params.size() > 4)\n+        throw runtime_error(\n+            \"importpubkey \\\"pubkey\\\" ( \\\"label\\\" rescan )\\n\"\n+            \"\\nAdds a public key (in hex) that can be watched as if it were in your wallet but cannot be used to spend.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"pubkey\\\"           (string, required) The hex-encoded public key\\n\"\n+            \"2. \\\"label\\\"            (string, optional, default=\\\"\\\") An optional label\\n\"\n+            \"3. rescan               (boolean, optional, default=true) Rescan the wallet for transactions\\n\"\n+            \"\\nNote: This call can take minutes to complete if rescan is true.\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nImport a public key with rescan\\n\"\n+            + HelpExampleCli(\"importpubkey\", \"\\\"mypubkey\\\"\") +\n+            \"\\nImport using a label without rescan\\n\"\n+            + HelpExampleCli(\"importpubkey\", \"\\\"mypubkey\\\" \\\"testing\\\" false\") +\n+            \"\\nAs a JSON-RPC call\\n\"\n+            + HelpExampleRpc(\"importpubkey\", \"\\\"mypubkey\\\", \\\"testing\\\", false\")\n+        );\n+\n+\n+    string strLabel = \"\";\n+    if (params.size() > 1)\n+        strLabel = params[1].get_str();\n+\n+    // Whether to perform rescan after import\n+    bool fRescan = true;\n+    if (params.size() > 2)\n+        fRescan = params[2].get_bool();\n+\n+    if (fRescan && fPruneMode)\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Rescan is disabled in pruned mode\");\n+\n+    if (!IsHex(params[0].get_str()))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+    std::vector<unsigned char> data(ParseHex(params[0].get_str()));\n+    CPubKey pubKey(data.begin(), data.end());\n+    if (!pubKey.IsFullyValid())\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n+\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+\n+    ImportAddress(CBitcoinAddress(pubKey.GetID()), strLabel);\n+    ImportScript(GetScriptForRawPubKey(pubKey), strLabel, false);\n+\n+    if (fRescan)\n+    {\n+        pwalletMain->ScanForWalletTransactions(chainActive.Genesis(), true);\n+        pwalletMain->ReacceptWalletTransactions();\n+    }\n+\n+    return NullUniValue;\n+}\n+\n+\n+UniValue importwallet(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+    \n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\n+            \"importwallet \\\"filename\\\"\\n\"\n+            \"\\nImports keys from a wallet dump file (see dumpwallet).\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"filename\\\"    (string, required) The wallet file\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nDump the wallet\\n\"\n+            + HelpExampleCli(\"dumpwallet\", \"\\\"test\\\"\") +\n+            \"\\nImport the wallet\\n\"\n+            + HelpExampleCli(\"importwallet\", \"\\\"test\\\"\") +\n+            \"\\nImport using the json rpc call\\n\"\n+            + HelpExampleRpc(\"importwallet\", \"\\\"test\\\"\")\n+        );\n+\n+    if (fPruneMode)\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Importing wallets is disabled in pruned mode\");\n+\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+\n+    EnsureWalletIsUnlocked();\n+\n+    ifstream file;\n+    file.open(params[0].get_str().c_str(), std::ios::in | std::ios::ate);\n+    if (!file.is_open())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot open wallet dump file\");\n+\n+    int64_t nTimeBegin = chainActive.Tip()->GetBlockTime();\n+\n+    bool fGood = true;\n+\n+    int64_t nFilesize = std::max((int64_t)1, (int64_t)file.tellg());\n+    file.seekg(0, file.beg);\n+\n+    pwalletMain->ShowProgress(_(\"Importing...\"), 0); // show progress dialog in GUI\n+    while (file.good()) {\n+        pwalletMain->ShowProgress(\"\", std::max(1, std::min(99, (int)(((double)file.tellg() / (double)nFilesize) * 100))));\n+        std::string line;\n+        std::getline(file, line);\n+        if (line.empty() || line[0] == '#')\n+            continue;\n+\n+        std::vector<std::string> vstr;\n+        boost::split(vstr, line, boost::is_any_of(\" \"));\n+        if (vstr.size() < 2)\n+            continue;\n+        CBitcoinSecret vchSecret;\n+        if (!vchSecret.SetString(vstr[0]))\n+            continue;\n+        CKey key = vchSecret.GetKey();\n+        CPubKey pubkey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubkey));\n+        CKeyID keyid = pubkey.GetID();\n+        if (pwalletMain->HaveKey(keyid)) {\n+            LogPrintf(\"Skipping import of %s (key already present)\\n\", CBitcoinAddress(keyid).ToString());\n+            continue;\n+        }\n+        int64_t nTime = DecodeDumpTime(vstr[1]);\n+        std::string strLabel;\n+        bool fLabel = true;\n+        for (unsigned int nStr = 2; nStr < vstr.size(); nStr++) {\n+            if (boost::algorithm::starts_with(vstr[nStr], \"#\"))\n+                break;\n+            if (vstr[nStr] == \"change=1\")\n+                fLabel = false;\n+            if (vstr[nStr] == \"reserve=1\")\n+                fLabel = false;\n+            if (boost::algorithm::starts_with(vstr[nStr], \"label=\")) {\n+                strLabel = DecodeDumpString(vstr[nStr].substr(6));\n+                fLabel = true;\n+            }\n+        }\n+        LogPrintf(\"Importing %s...\\n\", CBitcoinAddress(keyid).ToString());\n+        if (!pwalletMain->AddKeyPubKey(key, pubkey)) {\n+            fGood = false;\n+            continue;\n+        }\n+        pwalletMain->mapKeyMetadata[keyid].nCreateTime = nTime;\n+        if (fLabel)\n+            pwalletMain->SetAddressBook(keyid, strLabel, \"receive\");\n+        nTimeBegin = std::min(nTimeBegin, nTime);\n+    }\n+    file.close();\n+    pwalletMain->ShowProgress(\"\", 100); // hide progress dialog in GUI\n+\n+    CBlockIndex *pindex = chainActive.Tip();\n+    while (pindex && pindex->pprev && pindex->GetBlockTime() > nTimeBegin - 7200)\n+        pindex = pindex->pprev;\n+\n+    if (!pwalletMain->nTimeFirstKey || nTimeBegin < pwalletMain->nTimeFirstKey)\n+        pwalletMain->nTimeFirstKey = nTimeBegin;\n+\n+    LogPrintf(\"Rescanning last %i blocks\\n\", chainActive.Height() - pindex->nHeight + 1);\n+    pwalletMain->ScanForWalletTransactions(pindex);\n+    pwalletMain->MarkDirty();\n+\n+    if (!fGood)\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding some keys to wallet\");\n+\n+    return NullUniValue;\n+}\n+\n+UniValue dumpprivkey(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+    \n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\n+            \"dumpprivkey \\\"bitcoinaddress\\\"\\n\"\n+            \"\\nReveals the private key corresponding to 'bitcoinaddress'.\\n\"\n+            \"Then the importprivkey can be used with this output\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"bitcoinaddress\\\"   (string, required) The bitcoin address for the private key\\n\"\n+            \"\\nResult:\\n\"\n+            \"\\\"key\\\"                (string) The private key\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"dumpprivkey\", \"\\\"myaddress\\\"\")\n+            + HelpExampleCli(\"importprivkey\", \"\\\"mykey\\\"\")\n+            + HelpExampleRpc(\"dumpprivkey\", \"\\\"myaddress\\\"\")\n+        );\n+\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+\n+    EnsureWalletIsUnlocked();\n+\n+    string strAddress = params[0].get_str();\n+    CBitcoinAddress address;\n+    if (!address.SetString(strAddress))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n+    CKeyID keyID;\n+    if (!address.GetKeyID(keyID))\n+        throw JSONRPCError(RPC_TYPE_ERROR, \"Address does not refer to a key\");\n+    CKey vchSecret;\n+    if (!pwalletMain->GetKey(keyID, vchSecret))\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Private key for address \" + strAddress + \" is not known\");\n+    return CBitcoinSecret(vchSecret).ToString();\n+}\n+\n+\n+UniValue dumpwallet(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+    \n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\n+            \"dumpwallet \\\"filename\\\"\\n\"\n+            \"\\nDumps all wallet keys in a human-readable format.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"filename\\\"    (string, required) The filename\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"dumpwallet\", \"\\\"test\\\"\")\n+            + HelpExampleRpc(\"dumpwallet\", \"\\\"test\\\"\")\n+        );\n+\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+\n+    EnsureWalletIsUnlocked();\n+\n+    ofstream file;\n+    file.open(params[0].get_str().c_str());\n+    if (!file.is_open())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot open wallet dump file\");\n+\n+    std::map<CKeyID, int64_t> mapKeyBirth;\n+    std::set<CKeyID> setKeyPool;\n+    pwalletMain->GetKeyBirthTimes(mapKeyBirth);\n+    pwalletMain->GetAllReserveKeys(setKeyPool);\n+\n+    // sort time/key pairs\n+    std::vector<std::pair<int64_t, CKeyID> > vKeyBirth;\n+    for (std::map<CKeyID, int64_t>::const_iterator it = mapKeyBirth.begin(); it != mapKeyBirth.end(); it++) {\n+        vKeyBirth.push_back(std::make_pair(it->second, it->first));\n+    }\n+    mapKeyBirth.clear();\n+    std::sort(vKeyBirth.begin(), vKeyBirth.end());\n+\n+    // produce output\n+    file << strprintf(\"# Wallet dump created by Bitcoin %s (%s)\\n\", CLIENT_BUILD, CLIENT_DATE);\n+    file << strprintf(\"# * Created on %s\\n\", EncodeDumpTime(GetTime()));\n+    file << strprintf(\"# * Best block at time of backup was %i (%s),\\n\", chainActive.Height(), chainActive.Tip()->GetBlockHash().ToString());\n+    file << strprintf(\"#   mined on %s\\n\", EncodeDumpTime(chainActive.Tip()->GetBlockTime()));\n+    file << \"\\n\";\n+    for (std::vector<std::pair<int64_t, CKeyID> >::const_iterator it = vKeyBirth.begin(); it != vKeyBirth.end(); it++) {\n+        const CKeyID &keyid = it->second;\n+        std::string strTime = EncodeDumpTime(it->first);\n+        std::string strAddr = CBitcoinAddress(keyid).ToString();\n+        CKey key;\n+        if (pwalletMain->GetKey(keyid, key)) {\n+            if (pwalletMain->mapAddressBook.count(keyid)) {\n+                file << strprintf(\"%s %s label=%s # addr=%s\\n\", CBitcoinSecret(key).ToString(), strTime, EncodeDumpString(pwalletMain->mapAddressBook[keyid].name), strAddr);\n+            } else if (setKeyPool.count(keyid)) {\n+                file << strprintf(\"%s %s reserve=1 # addr=%s\\n\", CBitcoinSecret(key).ToString(), strTime, strAddr);\n+            } else {\n+                file << strprintf(\"%s %s change=1 # addr=%s\\n\", CBitcoinSecret(key).ToString(), strTime, strAddr);\n+            }\n+        }\n+    }\n+    file << \"\\n\";\n+    file << \"# End of dump\\n\";\n+    file.close();\n+    return NullUniValue;\n+}"
      },
      {
        "sha": "61c9846e114b3616801b78ba74398ab48f50ac0d",
        "filename": "src/lightwallet/rpcwallet.cpp",
        "status": "added",
        "additions": 2566,
        "deletions": 0,
        "changes": 2566,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e1c9383edc81c67e6c7b8794a649d06d538747b9/src/lightwallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e1c9383edc81c67e6c7b8794a649d06d538747b9/src/lightwallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/rpcwallet.cpp?ref=e1c9383edc81c67e6c7b8794a649d06d538747b9"
      },
      {
        "sha": "a5de7e2de1456312bb61c9594fb9bd609cfa4b50",
        "filename": "src/lightwallet/rpcwallet.h",
        "status": "added",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e1c9383edc81c67e6c7b8794a649d06d538747b9/src/lightwallet/rpcwallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e1c9383edc81c67e6c7b8794a649d06d538747b9/src/lightwallet/rpcwallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/rpcwallet.h?ref=e1c9383edc81c67e6c7b8794a649d06d538747b9",
        "patch": "@@ -0,0 +1,12 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_WALLET_RPCWALLET_H\n+#define BITCOIN_WALLET_RPCWALLET_H\n+\n+class CRPCTable;\n+\n+void RegisterWalletRPCCommands(CRPCTable &tableRPC);\n+\n+#endif //BITCOIN_WALLET_RPCWALLET_H"
      },
      {
        "sha": "e84d5880261c4c0cfa1287654c29e25f38e6795c",
        "filename": "src/lightwallet/test/wallet_tests.cpp",
        "status": "added",
        "additions": 364,
        "deletions": 0,
        "changes": 364,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e1c9383edc81c67e6c7b8794a649d06d538747b9/src/lightwallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e1c9383edc81c67e6c7b8794a649d06d538747b9/src/lightwallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/test/wallet_tests.cpp?ref=e1c9383edc81c67e6c7b8794a649d06d538747b9",
        "patch": "@@ -0,0 +1,364 @@\n+// Copyright (c) 2012-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"wallet/wallet.h\"\n+\n+#include <set>\n+#include <stdint.h>\n+#include <utility>\n+#include <vector>\n+\n+#include \"test/test_bitcoin.h\"\n+\n+#include <boost/foreach.hpp>\n+#include <boost/test/unit_test.hpp>\n+\n+// how many times to run all the tests to have a chance to catch errors that only show up with particular random shuffles\n+#define RUN_TESTS 100\n+\n+// some tests fail 1% of the time due to bad luck.\n+// we repeat those tests this many times and only complain if all iterations of the test fail\n+#define RANDOM_REPEATS 5\n+\n+using namespace std;\n+\n+typedef set<pair<const CWalletTx*,unsigned int> > CoinSet;\n+\n+BOOST_FIXTURE_TEST_SUITE(wallet_tests, TestingSetup)\n+\n+static CWallet wallet;\n+static vector<COutput> vCoins;\n+\n+static void add_coin(const CAmount& nValue, int nAge = 6*24, bool fIsFromMe = false, int nInput=0)\n+{\n+    static int nextLockTime = 0;\n+    CMutableTransaction tx;\n+    tx.nLockTime = nextLockTime++;        // so all transactions get different hashes\n+    tx.vout.resize(nInput+1);\n+    tx.vout[nInput].nValue = nValue;\n+    if (fIsFromMe) {\n+        // IsFromMe() returns (GetDebit() > 0), and GetDebit() is 0 if vin.empty(),\n+        // so stop vin being empty, and cache a non-zero Debit to fake out IsFromMe()\n+        tx.vin.resize(1);\n+    }\n+    CWalletTx* wtx = new CWalletTx(&wallet, tx);\n+    if (fIsFromMe)\n+    {\n+        wtx->fDebitCached = true;\n+        wtx->nDebitCached = 1;\n+    }\n+    COutput output(wtx, nInput, nAge, true);\n+    vCoins.push_back(output);\n+}\n+\n+static void empty_wallet(void)\n+{\n+    BOOST_FOREACH(COutput output, vCoins)\n+        delete output.tx;\n+    vCoins.clear();\n+}\n+\n+static bool equal_sets(CoinSet a, CoinSet b)\n+{\n+    pair<CoinSet::iterator, CoinSet::iterator> ret = mismatch(a.begin(), a.end(), b.begin());\n+    return ret.first == a.end() && ret.second == b.end();\n+}\n+\n+BOOST_AUTO_TEST_CASE(coin_selection_tests)\n+{\n+    CoinSet setCoinsRet, setCoinsRet2;\n+    CAmount nValueRet;\n+\n+    LOCK(wallet.cs_wallet);\n+\n+    // test multiple times to allow for differences in the shuffle order\n+    for (int i = 0; i < RUN_TESTS; i++)\n+    {\n+        empty_wallet();\n+\n+        // with an empty wallet we can't even pay one cent\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf( 1 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+\n+        add_coin(1*CENT, 4);        // add a new 1 cent coin\n+\n+        // with a new 1 cent coin, we still can't find a mature 1 cent\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf( 1 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+\n+        // but we can find a new 1 cent\n+        BOOST_CHECK( wallet.SelectCoinsMinConf( 1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);\n+\n+        add_coin(2*CENT);           // add a mature 2 cent coin\n+\n+        // we can't make 3 cents of mature coins\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf( 3 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+\n+        // we can make 3 cents of new  coins\n+        BOOST_CHECK( wallet.SelectCoinsMinConf( 3 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 3 * CENT);\n+\n+        add_coin(5*CENT);           // add a mature 5 cent coin,\n+        add_coin(10*CENT, 3, true); // a new 10 cent coin sent from one of our own addresses\n+        add_coin(20*CENT);          // and a mature 20 cent coin\n+\n+        // now we have new: 1+10=11 (of which 10 was self-sent), and mature: 2+5+20=27.  total = 38\n+\n+        // we can't make 38 cents only if we disallow new coins:\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf(38 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+        // we can't even make 37 cents if we don't allow new coins even if they're from us\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf(38 * CENT, 6, 6, vCoins, setCoinsRet, nValueRet));\n+        // but we can make 37 cents if we accept new coins from ourself\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(37 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 37 * CENT);\n+        // and we can make 38 cents if we accept all new coins\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(38 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 38 * CENT);\n+\n+        // try making 34 cents from 1,2,5,10,20 - we can't do it exactly\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(34 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 35 * CENT);       // but 35 cents is closest\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);     // the best should be 20+10+5.  it's incredibly unlikely the 1 or 2 got included (but possible)\n+\n+        // when we try making 7 cents, the smaller coins (1,2,5) are enough.  We should see just 2+5\n+        BOOST_CHECK( wallet.SelectCoinsMinConf( 7 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 7 * CENT);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n+\n+        // when we try making 8 cents, the smaller coins (1,2,5) are exactly enough.\n+        BOOST_CHECK( wallet.SelectCoinsMinConf( 8 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(nValueRet == 8 * CENT);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n+\n+        // when we try making 9 cents, no subset of smaller coins is enough, and we get the next bigger coin (10)\n+        BOOST_CHECK( wallet.SelectCoinsMinConf( 9 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 10 * CENT);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n+\n+        // now clear out the wallet and start again to test choosing between subsets of smaller coins and the next biggest coin\n+        empty_wallet();\n+\n+        add_coin( 6*CENT);\n+        add_coin( 7*CENT);\n+        add_coin( 8*CENT);\n+        add_coin(20*CENT);\n+        add_coin(30*CENT); // now we have 6+7+8+20+30 = 71 cents total\n+\n+        // check that we have 71 and not 72\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(71 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf(72 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+\n+        // now try making 16 cents.  the best smaller coins can do is 6+7+8 = 21; not as good at the next biggest coin, 20\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(16 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 20 * CENT); // we should get 20 in one coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n+\n+        add_coin( 5*CENT); // now we have 5+6+7+8+20+30 = 75 cents total\n+\n+        // now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, better than the next biggest coin, 20\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(16 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 18 * CENT); // we should get 18 in 3 coins\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n+\n+        add_coin( 18*CENT); // now we have 5+6+7+8+18+20+30\n+\n+        // and now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, the same as the next biggest coin, 18\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(16 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 18 * CENT);  // we should get 18 in 1 coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U); // because in the event of a tie, the biggest coin wins\n+\n+        // now try making 11 cents.  we should get 5+6\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(11 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 11 * CENT);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n+\n+        // check that the smallest bigger coin is used\n+        add_coin( 1*COIN);\n+        add_coin( 2*COIN);\n+        add_coin( 3*COIN);\n+        add_coin( 4*COIN); // now we have 5+6+7+8+18+20+30+100+200+300+400 = 1094 cents\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(95 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * COIN);  // we should get 1 BTC in 1 coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n+\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(195 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 2 * COIN);  // we should get 2 BTC in 1 coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n+\n+        // empty the wallet and start again, now with fractions of a cent, to test small change avoidance\n+\n+        empty_wallet();\n+        add_coin(0.1*MIN_CHANGE);\n+        add_coin(0.2*MIN_CHANGE);\n+        add_coin(0.3*MIN_CHANGE);\n+        add_coin(0.4*MIN_CHANGE);\n+        add_coin(0.5*MIN_CHANGE);\n+\n+        // try making 1 * MIN_CHANGE from the 1.5 * MIN_CHANGE\n+        // we'll get change smaller than MIN_CHANGE whatever happens, so can expect MIN_CHANGE exactly\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(MIN_CHANGE, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE);\n+\n+        // but if we add a bigger coin, small change is avoided\n+        add_coin(1111*MIN_CHANGE);\n+\n+        // try making 1 from 0.1 + 0.2 + 0.3 + 0.4 + 0.5 + 1111 = 1112.5\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(1 * MIN_CHANGE, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * MIN_CHANGE); // we should get the exact amount\n+\n+        // if we add more small coins:\n+        add_coin(0.6*MIN_CHANGE);\n+        add_coin(0.7*MIN_CHANGE);\n+\n+        // and try again to make 1.0 * MIN_CHANGE\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(1 * MIN_CHANGE, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * MIN_CHANGE); // we should get the exact amount\n+\n+        // run the 'mtgox' test (see http://blockexplorer.com/tx/29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf)\n+        // they tried to consolidate 10 50k coins into one 500k coin, and ended up with 50k in change\n+        empty_wallet();\n+        for (int i = 0; i < 20; i++)\n+            add_coin(50000 * COIN);\n+\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(500000 * COIN, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 500000 * COIN); // we should get the exact amount\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 10U); // in ten coins\n+\n+        // if there's not enough in the smaller coins to make at least 1 * MIN_CHANGE change (0.5+0.6+0.7 < 1.0+1.0),\n+        // we need to try finding an exact subset anyway\n+\n+        // sometimes it will fail, and so we use the next biggest coin:\n+        empty_wallet();\n+        add_coin(0.5 * MIN_CHANGE);\n+        add_coin(0.6 * MIN_CHANGE);\n+        add_coin(0.7 * MIN_CHANGE);\n+        add_coin(1111 * MIN_CHANGE);\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(1 * MIN_CHANGE, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1111 * MIN_CHANGE); // we get the bigger coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n+\n+        // but sometimes it's possible, and we use an exact subset (0.4 + 0.6 = 1.0)\n+        empty_wallet();\n+        add_coin(0.4 * MIN_CHANGE);\n+        add_coin(0.6 * MIN_CHANGE);\n+        add_coin(0.8 * MIN_CHANGE);\n+        add_coin(1111 * MIN_CHANGE);\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(MIN_CHANGE, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE);   // we should get the exact amount\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U); // in two coins 0.4+0.6\n+\n+        // test avoiding small change\n+        empty_wallet();\n+        add_coin(0.05 * MIN_CHANGE);\n+        add_coin(1    * MIN_CHANGE);\n+        add_coin(100  * MIN_CHANGE);\n+\n+        // trying to make 100.01 from these three coins\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(100.01 * MIN_CHANGE, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 101.05 * MIN_CHANGE);   // we should get all coins\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n+\n+        // but if we try to make 99.9, we should take the bigger of the two small coins to avoid small change\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(99.9 * MIN_CHANGE, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 101 * MIN_CHANGE);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n+\n+        // test with many inputs\n+        for (CAmount amt=1500; amt < COIN; amt*=10) {\n+             empty_wallet();\n+             // Create 676 inputs (= MAX_STANDARD_TX_SIZE / 148 bytes per input)\n+             for (uint16_t j = 0; j < 676; j++)\n+                 add_coin(amt);\n+             BOOST_CHECK(wallet.SelectCoinsMinConf(2000, 1, 1, vCoins, setCoinsRet, nValueRet));\n+             if (amt - 2000 < MIN_CHANGE) {\n+                 // needs more than one input:\n+                 uint16_t returnSize = std::ceil((2000.0 + MIN_CHANGE)/amt);\n+                 CAmount returnValue = amt * returnSize;\n+                 BOOST_CHECK_EQUAL(nValueRet, returnValue);\n+                 BOOST_CHECK_EQUAL(setCoinsRet.size(), returnSize);\n+             } else {\n+                 // one input is sufficient:\n+                 BOOST_CHECK_EQUAL(nValueRet, amt);\n+                 BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n+             }\n+        }\n+\n+        // test randomness\n+        {\n+            empty_wallet();\n+            for (int i2 = 0; i2 < 100; i2++)\n+                add_coin(COIN);\n+\n+            // picking 50 from 100 coins doesn't depend on the shuffle,\n+            // but does depend on randomness in the stochastic approximation code\n+            BOOST_CHECK(wallet.SelectCoinsMinConf(50 * COIN, 1, 6, vCoins, setCoinsRet , nValueRet));\n+            BOOST_CHECK(wallet.SelectCoinsMinConf(50 * COIN, 1, 6, vCoins, setCoinsRet2, nValueRet));\n+            BOOST_CHECK(!equal_sets(setCoinsRet, setCoinsRet2));\n+\n+            int fails = 0;\n+            for (int i = 0; i < RANDOM_REPEATS; i++)\n+            {\n+                // selecting 1 from 100 identical coins depends on the shuffle; this test will fail 1% of the time\n+                // run the test RANDOM_REPEATS times and only complain if all of them fail\n+                BOOST_CHECK(wallet.SelectCoinsMinConf(COIN, 1, 6, vCoins, setCoinsRet , nValueRet));\n+                BOOST_CHECK(wallet.SelectCoinsMinConf(COIN, 1, 6, vCoins, setCoinsRet2, nValueRet));\n+                if (equal_sets(setCoinsRet, setCoinsRet2))\n+                    fails++;\n+            }\n+            BOOST_CHECK_NE(fails, RANDOM_REPEATS);\n+\n+            // add 75 cents in small change.  not enough to make 90 cents,\n+            // then try making 90 cents.  there are multiple competing \"smallest bigger\" coins,\n+            // one of which should be picked at random\n+            add_coin( 5*CENT); add_coin(10*CENT); add_coin(15*CENT); add_coin(20*CENT); add_coin(25*CENT);\n+\n+            fails = 0;\n+            for (int i = 0; i < RANDOM_REPEATS; i++)\n+            {\n+                // selecting 1 from 100 identical coins depends on the shuffle; this test will fail 1% of the time\n+                // run the test RANDOM_REPEATS times and only complain if all of them fail\n+                BOOST_CHECK(wallet.SelectCoinsMinConf(90*CENT, 1, 6, vCoins, setCoinsRet , nValueRet));\n+                BOOST_CHECK(wallet.SelectCoinsMinConf(90*CENT, 1, 6, vCoins, setCoinsRet2, nValueRet));\n+                if (equal_sets(setCoinsRet, setCoinsRet2))\n+                    fails++;\n+            }\n+            BOOST_CHECK_NE(fails, RANDOM_REPEATS);\n+        }\n+    }\n+    empty_wallet();\n+}\n+\n+BOOST_AUTO_TEST_CASE(ApproximateBestSubset)\n+{\n+    CoinSet setCoinsRet;\n+    CAmount nValueRet;\n+\n+    LOCK(wallet.cs_wallet);\n+\n+    empty_wallet();\n+\n+    // Test vValue sort order\n+    for (int i = 0; i < 1000; i++)\n+        add_coin(1000 * COIN);\n+    add_coin(3 * COIN);\n+\n+    BOOST_CHECK(wallet.SelectCoinsMinConf(1003 * COIN, 1, 6, vCoins, setCoinsRet, nValueRet));\n+    BOOST_CHECK_EQUAL(nValueRet, 1003 * COIN);\n+    BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n+\n+    empty_wallet();\n+\n+    // Test trimming\n+    for (int i = 0; i < 100; i++)\n+        add_coin(10 * COIN);\n+    for (int i = 0; i < 100; i++)\n+        add_coin(1000 * COIN);\n+\n+    BOOST_CHECK(wallet.SelectCoinsMinConf(100001 * COIN, 1, 6, vCoins, setCoinsRet, nValueRet));\n+    // We need all 100 larger coins and exactly one small coin.\n+    // Superfluous small coins must be trimmed from the set:\n+    BOOST_CHECK_EQUAL(nValueRet, 100010 * COIN);\n+    BOOST_CHECK_EQUAL(setCoinsRet.size(), 101);\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "e8c946671044c2aa20151863e9f5d45b109f1dc5",
        "filename": "src/lightwallet/wallet.cpp",
        "status": "added",
        "additions": 3327,
        "deletions": 0,
        "changes": 3327,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e1c9383edc81c67e6c7b8794a649d06d538747b9/src/lightwallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e1c9383edc81c67e6c7b8794a649d06d538747b9/src/lightwallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/wallet.cpp?ref=e1c9383edc81c67e6c7b8794a649d06d538747b9"
      },
      {
        "sha": "96d5d4e1e015b366e3377086a817801e1d9d8e0a",
        "filename": "src/lightwallet/wallet.h",
        "status": "added",
        "additions": 943,
        "deletions": 0,
        "changes": 943,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e1c9383edc81c67e6c7b8794a649d06d538747b9/src/lightwallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e1c9383edc81c67e6c7b8794a649d06d538747b9/src/lightwallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/wallet.h?ref=e1c9383edc81c67e6c7b8794a649d06d538747b9",
        "patch": "@@ -0,0 +1,943 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_WALLET_WALLET_H\n+#define BITCOIN_WALLET_WALLET_H\n+\n+#include \"amount.h\"\n+#include \"streams.h\"\n+#include \"tinyformat.h\"\n+#include \"ui_interface.h\"\n+#include \"utilstrencodings.h\"\n+#include \"validationinterface.h\"\n+#include \"wallet/crypter.h\"\n+#include \"wallet/wallet_ismine.h\"\n+#include \"wallet/walletdb.h\"\n+#include \"wallet/rpcwallet.h\"\n+\n+#include <algorithm>\n+#include <map>\n+#include <set>\n+#include <stdexcept>\n+#include <stdint.h>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include <boost/shared_ptr.hpp>\n+\n+extern CWallet* pwalletMain;\n+\n+/**\n+ * Settings\n+ */\n+extern CFeeRate payTxFee;\n+extern unsigned int nTxConfirmTarget;\n+extern bool bSpendZeroConfChange;\n+extern bool fSendFreeTransactions;\n+\n+static const unsigned int DEFAULT_KEYPOOL_SIZE = 100;\n+//! -paytxfee default\n+static const CAmount DEFAULT_TRANSACTION_FEE = 0;\n+//! -fallbackfee default\n+static const CAmount DEFAULT_FALLBACK_FEE = 20000;\n+//! -mintxfee default\n+static const CAmount DEFAULT_TRANSACTION_MINFEE = 1000;\n+//! minimum change amount\n+static const CAmount MIN_CHANGE = CENT;\n+//! Default for -spendzeroconfchange\n+static const bool DEFAULT_SPEND_ZEROCONF_CHANGE = true;\n+//! Default for -sendfreetransactions\n+static const bool DEFAULT_SEND_FREE_TRANSACTIONS = false;\n+//! -txconfirmtarget default\n+static const unsigned int DEFAULT_TX_CONFIRM_TARGET = 2;\n+//! Largest (in bytes) free transaction we're willing to create\n+static const unsigned int MAX_FREE_TRANSACTION_CREATE_SIZE = 1000;\n+static const bool DEFAULT_WALLETBROADCAST = true;\n+\n+extern const char * DEFAULT_WALLET_DAT;\n+\n+class CBlockIndex;\n+class CCoinControl;\n+class COutput;\n+class CReserveKey;\n+class CScript;\n+class CTxMemPool;\n+class CWalletTx;\n+\n+/** (client) version numbers for particular wallet features */\n+enum WalletFeature\n+{\n+    FEATURE_BASE = 10500, // the earliest version new wallets supports (only useful for getinfo's clientversion output)\n+\n+    FEATURE_WALLETCRYPT = 40000, // wallet encryption\n+    FEATURE_COMPRPUBKEY = 60000, // compressed public keys\n+\n+    FEATURE_LATEST = 60000\n+};\n+\n+\n+/** A key pool entry */\n+class CKeyPool\n+{\n+public:\n+    int64_t nTime;\n+    CPubKey vchPubKey;\n+\n+    CKeyPool();\n+    CKeyPool(const CPubKey& vchPubKeyIn);\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        if (!(nType & SER_GETHASH))\n+            READWRITE(nVersion);\n+        READWRITE(nTime);\n+        READWRITE(vchPubKey);\n+    }\n+};\n+\n+/** Address book data */\n+class CAddressBookData\n+{\n+public:\n+    std::string name;\n+    std::string purpose;\n+\n+    CAddressBookData()\n+    {\n+        purpose = \"unknown\";\n+    }\n+\n+    typedef std::map<std::string, std::string> StringMap;\n+    StringMap destdata;\n+};\n+\n+struct CRecipient\n+{\n+    CScript scriptPubKey;\n+    CAmount nAmount;\n+    bool fSubtractFeeFromAmount;\n+};\n+\n+typedef std::map<std::string, std::string> mapValue_t;\n+\n+\n+static void ReadOrderPos(int64_t& nOrderPos, mapValue_t& mapValue)\n+{\n+    if (!mapValue.count(\"n\"))\n+    {\n+        nOrderPos = -1; // TODO: calculate elsewhere\n+        return;\n+    }\n+    nOrderPos = atoi64(mapValue[\"n\"].c_str());\n+}\n+\n+\n+static void WriteOrderPos(const int64_t& nOrderPos, mapValue_t& mapValue)\n+{\n+    if (nOrderPos == -1)\n+        return;\n+    mapValue[\"n\"] = i64tostr(nOrderPos);\n+}\n+\n+struct COutputEntry\n+{\n+    CTxDestination destination;\n+    CAmount amount;\n+    int vout;\n+};\n+\n+/** A transaction with a merkle branch linking it to the block chain. */\n+class CMerkleTx : public CTransaction\n+{\n+private:\n+  /** Constant used in hashBlock to indicate tx has been abandoned */\n+    static const uint256 ABANDON_HASH;\n+\n+public:\n+    uint256 hashBlock;\n+\n+    /* An nIndex == -1 means that hashBlock (in nonzero) refers to the earliest\n+     * block in the chain we know this or any in-wallet dependency conflicts\n+     * with. Older clients interpret nIndex == -1 as unconfirmed for backward\n+     * compatibility.\n+     */\n+    int nIndex;\n+\n+    CMerkleTx()\n+    {\n+        Init();\n+    }\n+\n+    CMerkleTx(const CTransaction& txIn) : CTransaction(txIn)\n+    {\n+        Init();\n+    }\n+\n+    void Init()\n+    {\n+        hashBlock = uint256();\n+        nIndex = -1;\n+    }\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        std::vector<uint256> vMerkleBranch; // For compatibility with older versions.\n+        READWRITE(*(CTransaction*)this);\n+        nVersion = this->nVersion;\n+        READWRITE(hashBlock);\n+        READWRITE(vMerkleBranch);\n+        READWRITE(nIndex);\n+    }\n+\n+    int SetMerkleBranch(const CBlock& block);\n+\n+    /**\n+     * Return depth of transaction in blockchain:\n+     * <0  : conflicts with a transaction this deep in the blockchain\n+     *  0  : in memory pool, waiting to be included in a block\n+     * >=1 : this many blocks deep in the main chain\n+     */\n+    int GetDepthInMainChain(const CBlockIndex* &pindexRet) const;\n+    int GetDepthInMainChain() const { const CBlockIndex *pindexRet; return GetDepthInMainChain(pindexRet); }\n+    bool IsInMainChain() const { const CBlockIndex *pindexRet; return GetDepthInMainChain(pindexRet) > 0; }\n+    int GetBlocksToMaturity() const;\n+    /** Pass this transaction to the mempool. Fails if absolute fee exceeds absurd fee. */\n+    bool AcceptToMemoryPool(bool fLimitFree, const CAmount nAbsurdFee);\n+    bool hashUnset() const { return (hashBlock.IsNull() || hashBlock == ABANDON_HASH); }\n+    bool isAbandoned() const { return (hashBlock == ABANDON_HASH); }\n+    void setAbandoned() { hashBlock = ABANDON_HASH; }\n+};\n+\n+/** \n+ * A transaction with a bunch of additional info that only the owner cares about.\n+ * It includes any unrecorded transactions needed to link it back to the block chain.\n+ */\n+class CWalletTx : public CMerkleTx\n+{\n+private:\n+    const CWallet* pwallet;\n+\n+public:\n+    mapValue_t mapValue;\n+    std::vector<std::pair<std::string, std::string> > vOrderForm;\n+    unsigned int fTimeReceivedIsTxTime;\n+    unsigned int nTimeReceived; //!< time received by this node\n+    unsigned int nTimeSmart;\n+    char fFromMe;\n+    std::string strFromAccount;\n+    int64_t nOrderPos; //!< position in ordered transaction list\n+\n+    // memory only\n+    mutable bool fDebitCached;\n+    mutable bool fCreditCached;\n+    mutable bool fImmatureCreditCached;\n+    mutable bool fAvailableCreditCached;\n+    mutable bool fWatchDebitCached;\n+    mutable bool fWatchCreditCached;\n+    mutable bool fImmatureWatchCreditCached;\n+    mutable bool fAvailableWatchCreditCached;\n+    mutable bool fChangeCached;\n+    mutable CAmount nDebitCached;\n+    mutable CAmount nCreditCached;\n+    mutable CAmount nImmatureCreditCached;\n+    mutable CAmount nAvailableCreditCached;\n+    mutable CAmount nWatchDebitCached;\n+    mutable CAmount nWatchCreditCached;\n+    mutable CAmount nImmatureWatchCreditCached;\n+    mutable CAmount nAvailableWatchCreditCached;\n+    mutable CAmount nChangeCached;\n+\n+    CWalletTx()\n+    {\n+        Init(NULL);\n+    }\n+\n+    CWalletTx(const CWallet* pwalletIn)\n+    {\n+        Init(pwalletIn);\n+    }\n+\n+    CWalletTx(const CWallet* pwalletIn, const CMerkleTx& txIn) : CMerkleTx(txIn)\n+    {\n+        Init(pwalletIn);\n+    }\n+\n+    CWalletTx(const CWallet* pwalletIn, const CTransaction& txIn) : CMerkleTx(txIn)\n+    {\n+        Init(pwalletIn);\n+    }\n+\n+    void Init(const CWallet* pwalletIn)\n+    {\n+        pwallet = pwalletIn;\n+        mapValue.clear();\n+        vOrderForm.clear();\n+        fTimeReceivedIsTxTime = false;\n+        nTimeReceived = 0;\n+        nTimeSmart = 0;\n+        fFromMe = false;\n+        strFromAccount.clear();\n+        fDebitCached = false;\n+        fCreditCached = false;\n+        fImmatureCreditCached = false;\n+        fAvailableCreditCached = false;\n+        fWatchDebitCached = false;\n+        fWatchCreditCached = false;\n+        fImmatureWatchCreditCached = false;\n+        fAvailableWatchCreditCached = false;\n+        fChangeCached = false;\n+        nDebitCached = 0;\n+        nCreditCached = 0;\n+        nImmatureCreditCached = 0;\n+        nAvailableCreditCached = 0;\n+        nWatchDebitCached = 0;\n+        nWatchCreditCached = 0;\n+        nAvailableWatchCreditCached = 0;\n+        nImmatureWatchCreditCached = 0;\n+        nChangeCached = 0;\n+        nOrderPos = -1;\n+    }\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        if (ser_action.ForRead())\n+            Init(NULL);\n+        char fSpent = false;\n+\n+        if (!ser_action.ForRead())\n+        {\n+            mapValue[\"fromaccount\"] = strFromAccount;\n+\n+            WriteOrderPos(nOrderPos, mapValue);\n+\n+            if (nTimeSmart)\n+                mapValue[\"timesmart\"] = strprintf(\"%u\", nTimeSmart);\n+        }\n+\n+        READWRITE(*(CMerkleTx*)this);\n+        std::vector<CMerkleTx> vUnused; //!< Used to be vtxPrev\n+        READWRITE(vUnused);\n+        READWRITE(mapValue);\n+        READWRITE(vOrderForm);\n+        READWRITE(fTimeReceivedIsTxTime);\n+        READWRITE(nTimeReceived);\n+        READWRITE(fFromMe);\n+        READWRITE(fSpent);\n+\n+        if (ser_action.ForRead())\n+        {\n+            strFromAccount = mapValue[\"fromaccount\"];\n+\n+            ReadOrderPos(nOrderPos, mapValue);\n+\n+            nTimeSmart = mapValue.count(\"timesmart\") ? (unsigned int)atoi64(mapValue[\"timesmart\"]) : 0;\n+        }\n+\n+        mapValue.erase(\"fromaccount\");\n+        mapValue.erase(\"version\");\n+        mapValue.erase(\"spent\");\n+        mapValue.erase(\"n\");\n+        mapValue.erase(\"timesmart\");\n+    }\n+\n+    //! make sure balances are recalculated\n+    void MarkDirty()\n+    {\n+        fCreditCached = false;\n+        fAvailableCreditCached = false;\n+        fWatchDebitCached = false;\n+        fWatchCreditCached = false;\n+        fAvailableWatchCreditCached = false;\n+        fImmatureWatchCreditCached = false;\n+        fDebitCached = false;\n+        fChangeCached = false;\n+    }\n+\n+    void BindWallet(CWallet *pwalletIn)\n+    {\n+        pwallet = pwalletIn;\n+        MarkDirty();\n+    }\n+\n+    //! filter decides which addresses will count towards the debit\n+    CAmount GetDebit(const isminefilter& filter) const;\n+    CAmount GetCredit(const isminefilter& filter) const;\n+    CAmount GetImmatureCredit(bool fUseCache=true) const;\n+    CAmount GetAvailableCredit(bool fUseCache=true) const;\n+    CAmount GetImmatureWatchOnlyCredit(const bool& fUseCache=true) const;\n+    CAmount GetAvailableWatchOnlyCredit(const bool& fUseCache=true) const;\n+    CAmount GetChange() const;\n+\n+    void GetAmounts(std::list<COutputEntry>& listReceived,\n+                    std::list<COutputEntry>& listSent, CAmount& nFee, std::string& strSentAccount, const isminefilter& filter) const;\n+\n+    void GetAccountAmounts(const std::string& strAccount, CAmount& nReceived,\n+                           CAmount& nSent, CAmount& nFee, const isminefilter& filter) const;\n+\n+    bool IsFromMe(const isminefilter& filter) const\n+    {\n+        return (GetDebit(filter) > 0);\n+    }\n+\n+    // True if only scriptSigs are different\n+    bool IsEquivalentTo(const CWalletTx& tx) const;\n+\n+    bool InMempool() const;\n+    bool IsTrusted() const;\n+\n+    bool WriteToDisk(CWalletDB *pwalletdb);\n+\n+    int64_t GetTxTime() const;\n+    int GetRequestCount() const;\n+\n+    bool RelayWalletTransaction();\n+\n+    std::set<uint256> GetConflicts() const;\n+};\n+\n+\n+\n+\n+class COutput\n+{\n+public:\n+    const CWalletTx *tx;\n+    int i;\n+    int nDepth;\n+    bool fSpendable;\n+\n+    COutput(const CWalletTx *txIn, int iIn, int nDepthIn, bool fSpendableIn)\n+    {\n+        tx = txIn; i = iIn; nDepth = nDepthIn; fSpendable = fSpendableIn;\n+    }\n+\n+    std::string ToString() const;\n+};\n+\n+\n+\n+\n+/** Private key that includes an expiration date in case it never gets used. */\n+class CWalletKey\n+{\n+public:\n+    CPrivKey vchPrivKey;\n+    int64_t nTimeCreated;\n+    int64_t nTimeExpires;\n+    std::string strComment;\n+    //! todo: add something to note what created it (user, getnewaddress, change)\n+    //!   maybe should have a map<string, string> property map\n+\n+    CWalletKey(int64_t nExpires=0);\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        if (!(nType & SER_GETHASH))\n+            READWRITE(nVersion);\n+        READWRITE(vchPrivKey);\n+        READWRITE(nTimeCreated);\n+        READWRITE(nTimeExpires);\n+        READWRITE(LIMITED_STRING(strComment, 65536));\n+    }\n+};\n+\n+/**\n+ * Internal transfers.\n+ * Database key is acentry<account><counter>.\n+ */\n+class CAccountingEntry\n+{\n+public:\n+    std::string strAccount;\n+    CAmount nCreditDebit;\n+    int64_t nTime;\n+    std::string strOtherAccount;\n+    std::string strComment;\n+    mapValue_t mapValue;\n+    int64_t nOrderPos; //!< position in ordered transaction list\n+    uint64_t nEntryNo;\n+\n+    CAccountingEntry()\n+    {\n+        SetNull();\n+    }\n+\n+    void SetNull()\n+    {\n+        nCreditDebit = 0;\n+        nTime = 0;\n+        strAccount.clear();\n+        strOtherAccount.clear();\n+        strComment.clear();\n+        nOrderPos = -1;\n+        nEntryNo = 0;\n+    }\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        if (!(nType & SER_GETHASH))\n+            READWRITE(nVersion);\n+        //! Note: strAccount is serialized as part of the key, not here.\n+        READWRITE(nCreditDebit);\n+        READWRITE(nTime);\n+        READWRITE(LIMITED_STRING(strOtherAccount, 65536));\n+\n+        if (!ser_action.ForRead())\n+        {\n+            WriteOrderPos(nOrderPos, mapValue);\n+\n+            if (!(mapValue.empty() && _ssExtra.empty()))\n+            {\n+                CDataStream ss(nType, nVersion);\n+                ss.insert(ss.begin(), '\\0');\n+                ss << mapValue;\n+                ss.insert(ss.end(), _ssExtra.begin(), _ssExtra.end());\n+                strComment.append(ss.str());\n+            }\n+        }\n+\n+        READWRITE(LIMITED_STRING(strComment, 65536));\n+\n+        size_t nSepPos = strComment.find(\"\\0\", 0, 1);\n+        if (ser_action.ForRead())\n+        {\n+            mapValue.clear();\n+            if (std::string::npos != nSepPos)\n+            {\n+                CDataStream ss(std::vector<char>(strComment.begin() + nSepPos + 1, strComment.end()), nType, nVersion);\n+                ss >> mapValue;\n+                _ssExtra = std::vector<char>(ss.begin(), ss.end());\n+            }\n+            ReadOrderPos(nOrderPos, mapValue);\n+        }\n+        if (std::string::npos != nSepPos)\n+            strComment.erase(nSepPos);\n+\n+        mapValue.erase(\"n\");\n+    }\n+\n+private:\n+    std::vector<char> _ssExtra;\n+};\n+\n+\n+/** \n+ * A CWallet is an extension of a keystore, which also maintains a set of transactions and balances,\n+ * and provides the ability to create new transactions.\n+ */\n+class CWallet : public CCryptoKeyStore, public CValidationInterface\n+{\n+private:\n+    /**\n+     * Select a set of coins such that nValueRet >= nTargetValue and at least\n+     * all coins from coinControl are selected; Never select unconfirmed coins\n+     * if they are not ours\n+     */\n+    bool SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet, const CCoinControl *coinControl = NULL) const;\n+\n+    CWalletDB *pwalletdbEncryption;\n+\n+    //! the current wallet version: clients below this version are not able to load the wallet\n+    int nWalletVersion;\n+\n+    //! the maximum wallet format version: memory-only variable that specifies to what version this wallet may be upgraded\n+    int nWalletMaxVersion;\n+\n+    int64_t nNextResend;\n+    int64_t nLastResend;\n+    bool fBroadcastTransactions;\n+\n+    /**\n+     * Used to keep track of spent outpoints, and\n+     * detect and report conflicts (double-spends or\n+     * mutated transactions where the mutant gets mined).\n+     */\n+    typedef std::multimap<COutPoint, uint256> TxSpends;\n+    TxSpends mapTxSpends;\n+    void AddToSpends(const COutPoint& outpoint, const uint256& wtxid);\n+    void AddToSpends(const uint256& wtxid);\n+\n+    /* Mark a transaction (and its in-wallet descendants) as conflicting with a particular block. */\n+    void MarkConflicted(const uint256& hashBlock, const uint256& hashTx);\n+\n+    void SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator>);\n+\n+public:\n+    /*\n+     * Main wallet lock.\n+     * This lock protects all the fields added by CWallet\n+     *   except for:\n+     *      fFileBacked (immutable after instantiation)\n+     *      strWalletFile (immutable after instantiation)\n+     */\n+    mutable CCriticalSection cs_wallet;\n+\n+    bool fFileBacked;\n+    std::string strWalletFile;\n+\n+    std::set<int64_t> setKeyPool;\n+    std::map<CKeyID, CKeyMetadata> mapKeyMetadata;\n+\n+    typedef std::map<unsigned int, CMasterKey> MasterKeyMap;\n+    MasterKeyMap mapMasterKeys;\n+    unsigned int nMasterKeyMaxID;\n+\n+    CWallet()\n+    {\n+        SetNull();\n+    }\n+\n+    CWallet(const std::string& strWalletFileIn)\n+    {\n+        SetNull();\n+\n+        strWalletFile = strWalletFileIn;\n+        fFileBacked = true;\n+    }\n+\n+    ~CWallet()\n+    {\n+        delete pwalletdbEncryption;\n+        pwalletdbEncryption = NULL;\n+    }\n+\n+    void SetNull()\n+    {\n+        nWalletVersion = FEATURE_BASE;\n+        nWalletMaxVersion = FEATURE_BASE;\n+        fFileBacked = false;\n+        nMasterKeyMaxID = 0;\n+        pwalletdbEncryption = NULL;\n+        nOrderPosNext = 0;\n+        nNextResend = 0;\n+        nLastResend = 0;\n+        nTimeFirstKey = 0;\n+        fBroadcastTransactions = false;\n+    }\n+\n+    std::map<uint256, CWalletTx> mapWallet;\n+    std::list<CAccountingEntry> laccentries;\n+\n+    typedef std::pair<CWalletTx*, CAccountingEntry*> TxPair;\n+    typedef std::multimap<int64_t, TxPair > TxItems;\n+    TxItems wtxOrdered;\n+\n+    int64_t nOrderPosNext;\n+    std::map<uint256, int> mapRequestCount;\n+\n+    std::map<CTxDestination, CAddressBookData> mapAddressBook;\n+\n+    CPubKey vchDefaultKey;\n+\n+    std::set<COutPoint> setLockedCoins;\n+\n+    int64_t nTimeFirstKey;\n+\n+    const CWalletTx* GetWalletTx(const uint256& hash) const;\n+\n+    //! check whether we are allowed to upgrade (or already support) to the named feature\n+    bool CanSupportFeature(enum WalletFeature wf) { AssertLockHeld(cs_wallet); return nWalletMaxVersion >= wf; }\n+\n+    /**\n+     * populate vCoins with vector of available COutputs.\n+     */\n+    void AvailableCoins(std::vector<COutput>& vCoins, bool fOnlyConfirmed=true, const CCoinControl *coinControl = NULL, bool fIncludeZeroValue=false) const;\n+\n+    /**\n+     * Shuffle and select coins until nTargetValue is reached while avoiding\n+     * small change; This method is stochastic for some inputs and upon\n+     * completion the coin set and corresponding actual target value is\n+     * assembled\n+     */\n+    bool SelectCoinsMinConf(const CAmount& nTargetValue, int nConfMine, int nConfTheirs, std::vector<COutput> vCoins, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet) const;\n+\n+    bool IsSpent(const uint256& hash, unsigned int n) const;\n+\n+    bool IsLockedCoin(uint256 hash, unsigned int n) const;\n+    void LockCoin(COutPoint& output);\n+    void UnlockCoin(COutPoint& output);\n+    void UnlockAllCoins();\n+    void ListLockedCoins(std::vector<COutPoint>& vOutpts);\n+\n+    /**\n+     * keystore implementation\n+     * Generate a new key\n+     */\n+    CPubKey GenerateNewKey();\n+    //! Adds a key to the store, and saves it to disk.\n+    bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey);\n+    //! Adds a key to the store, without saving it to disk (used by LoadWallet)\n+    bool LoadKey(const CKey& key, const CPubKey &pubkey) { return CCryptoKeyStore::AddKeyPubKey(key, pubkey); }\n+    //! Load metadata (used by LoadWallet)\n+    bool LoadKeyMetadata(const CPubKey &pubkey, const CKeyMetadata &metadata);\n+\n+    bool LoadMinVersion(int nVersion) { AssertLockHeld(cs_wallet); nWalletVersion = nVersion; nWalletMaxVersion = std::max(nWalletMaxVersion, nVersion); return true; }\n+\n+    //! Adds an encrypted key to the store, and saves it to disk.\n+    bool AddCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret);\n+    //! Adds an encrypted key to the store, without saving it to disk (used by LoadWallet)\n+    bool LoadCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret);\n+    bool AddCScript(const CScript& redeemScript);\n+    bool LoadCScript(const CScript& redeemScript);\n+\n+    //! Adds a destination data tuple to the store, and saves it to disk\n+    bool AddDestData(const CTxDestination &dest, const std::string &key, const std::string &value);\n+    //! Erases a destination data tuple in the store and on disk\n+    bool EraseDestData(const CTxDestination &dest, const std::string &key);\n+    //! Adds a destination data tuple to the store, without saving it to disk\n+    bool LoadDestData(const CTxDestination &dest, const std::string &key, const std::string &value);\n+    //! Look up a destination data tuple in the store, return true if found false otherwise\n+    bool GetDestData(const CTxDestination &dest, const std::string &key, std::string *value) const;\n+\n+    //! Adds a watch-only address to the store, and saves it to disk.\n+    bool AddWatchOnly(const CScript &dest);\n+    bool RemoveWatchOnly(const CScript &dest);\n+    //! Adds a watch-only address to the store, without saving it to disk (used by LoadWallet)\n+    bool LoadWatchOnly(const CScript &dest);\n+\n+    bool Unlock(const SecureString& strWalletPassphrase);\n+    bool ChangeWalletPassphrase(const SecureString& strOldWalletPassphrase, const SecureString& strNewWalletPassphrase);\n+    bool EncryptWallet(const SecureString& strWalletPassphrase);\n+\n+    void GetKeyBirthTimes(std::map<CKeyID, int64_t> &mapKeyBirth) const;\n+\n+    /** \n+     * Increment the next transaction order id\n+     * @return next transaction order id\n+     */\n+    int64_t IncOrderPosNext(CWalletDB *pwalletdb = NULL);\n+\n+    void MarkDirty();\n+    bool AddToWallet(const CWalletTx& wtxIn, bool fFromLoadWallet, CWalletDB* pwalletdb);\n+    void SyncTransaction(const CTransaction& tx, const CBlockIndex *pindex, const CBlock* pblock);\n+    bool AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pblock, bool fUpdate);\n+    int ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate = false);\n+    void ReacceptWalletTransactions();\n+    void ResendWalletTransactions(int64_t nBestBlockTime);\n+    std::vector<uint256> ResendWalletTransactionsBefore(int64_t nTime);\n+    CAmount GetBalance() const;\n+    CAmount GetUnconfirmedBalance() const;\n+    CAmount GetImmatureBalance() const;\n+    CAmount GetWatchOnlyBalance() const;\n+    CAmount GetUnconfirmedWatchOnlyBalance() const;\n+    CAmount GetImmatureWatchOnlyBalance() const;\n+\n+    /**\n+     * Insert additional inputs into the transaction by\n+     * calling CreateTransaction();\n+     */\n+    bool FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nChangePosRet, std::string& strFailReason, bool includeWatching);\n+\n+    /**\n+     * Create a new transaction paying the recipients with a set of coins\n+     * selected by SelectCoins(); Also create the change output, when needed\n+     */\n+    bool CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, CAmount& nFeeRet, int& nChangePosRet,\n+                           std::string& strFailReason, const CCoinControl *coinControl = NULL, bool sign = true);\n+    bool CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey);\n+\n+    bool AddAccountingEntry(const CAccountingEntry&, CWalletDB & pwalletdb);\n+\n+    static CFeeRate minTxFee;\n+    static CFeeRate fallbackFee;\n+    /**\n+     * Estimate the minimum fee considering user set parameters\n+     * and the required fee\n+     */\n+    static CAmount GetMinimumFee(unsigned int nTxBytes, unsigned int nConfirmTarget, const CTxMemPool& pool);\n+    /**\n+     * Return the minimum required fee taking into account the\n+     * floating relay fee and user set minimum transaction fee\n+     */\n+    static CAmount GetRequiredFee(unsigned int nTxBytes);\n+\n+    bool NewKeyPool();\n+    bool TopUpKeyPool(unsigned int kpSize = 0);\n+    void ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool);\n+    void KeepKey(int64_t nIndex);\n+    void ReturnKey(int64_t nIndex);\n+    bool GetKeyFromPool(CPubKey &key);\n+    int64_t GetOldestKeyPoolTime();\n+    void GetAllReserveKeys(std::set<CKeyID>& setAddress) const;\n+\n+    std::set< std::set<CTxDestination> > GetAddressGroupings();\n+    std::map<CTxDestination, CAmount> GetAddressBalances();\n+\n+    std::set<CTxDestination> GetAccountAddresses(const std::string& strAccount) const;\n+\n+    isminetype IsMine(const CTxIn& txin) const;\n+    CAmount GetDebit(const CTxIn& txin, const isminefilter& filter) const;\n+    isminetype IsMine(const CTxOut& txout) const;\n+    CAmount GetCredit(const CTxOut& txout, const isminefilter& filter) const;\n+    bool IsChange(const CTxOut& txout) const;\n+    CAmount GetChange(const CTxOut& txout) const;\n+    bool IsMine(const CTransaction& tx) const;\n+    /** should probably be renamed to IsRelevantToMe */\n+    bool IsFromMe(const CTransaction& tx) const;\n+    CAmount GetDebit(const CTransaction& tx, const isminefilter& filter) const;\n+    CAmount GetCredit(const CTransaction& tx, const isminefilter& filter) const;\n+    CAmount GetChange(const CTransaction& tx) const;\n+    void SetBestChain(const CBlockLocator& loc);\n+\n+    DBErrors LoadWallet(bool& fFirstRunRet);\n+    DBErrors ZapWalletTx(std::vector<CWalletTx>& vWtx);\n+    DBErrors ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256>& vHashOut);\n+\n+    bool SetAddressBook(const CTxDestination& address, const std::string& strName, const std::string& purpose);\n+\n+    bool DelAddressBook(const CTxDestination& address);\n+\n+    void UpdatedTransaction(const uint256 &hashTx);\n+\n+    void Inventory(const uint256 &hash)\n+    {\n+        {\n+            LOCK(cs_wallet);\n+            std::map<uint256, int>::iterator mi = mapRequestCount.find(hash);\n+            if (mi != mapRequestCount.end())\n+                (*mi).second++;\n+        }\n+    }\n+\n+    void GetScriptForMining(boost::shared_ptr<CReserveScript> &script);\n+    void ResetRequestCount(const uint256 &hash)\n+    {\n+        LOCK(cs_wallet);\n+        mapRequestCount[hash] = 0;\n+    };\n+    \n+    unsigned int GetKeyPoolSize()\n+    {\n+        AssertLockHeld(cs_wallet); // setKeyPool\n+        return setKeyPool.size();\n+    }\n+\n+    bool SetDefaultKey(const CPubKey &vchPubKey);\n+\n+    //! signify that a particular wallet feature is now used. this may change nWalletVersion and nWalletMaxVersion if those are lower\n+    bool SetMinVersion(enum WalletFeature, CWalletDB* pwalletdbIn = NULL, bool fExplicit = false);\n+\n+    //! change which version we're allowed to upgrade to (note that this does not immediately imply upgrading to that format)\n+    bool SetMaxVersion(int nVersion);\n+\n+    //! get the current wallet format (the oldest client version guaranteed to understand this wallet)\n+    int GetVersion() { LOCK(cs_wallet); return nWalletVersion; }\n+\n+    //! Get wallet transactions that conflict with given transaction (spend same outputs)\n+    std::set<uint256> GetConflicts(const uint256& txid) const;\n+\n+    //! Flush wallet (bitdb flush)\n+    void Flush(bool shutdown=false);\n+\n+    //! Verify the wallet database and perform salvage if required\n+    static bool Verify();\n+    \n+    /** \n+     * Address book entry changed.\n+     * @note called with lock cs_wallet held.\n+     */\n+    boost::signals2::signal<void (CWallet *wallet, const CTxDestination\n+            &address, const std::string &label, bool isMine,\n+            const std::string &purpose,\n+            ChangeType status)> NotifyAddressBookChanged;\n+\n+    /** \n+     * Wallet transaction added, removed or updated.\n+     * @note called with lock cs_wallet held.\n+     */\n+    boost::signals2::signal<void (CWallet *wallet, const uint256 &hashTx,\n+            ChangeType status)> NotifyTransactionChanged;\n+\n+    /** Show progress e.g. for rescan */\n+    boost::signals2::signal<void (const std::string &title, int nProgress)> ShowProgress;\n+\n+    /** Watch-only address added */\n+    boost::signals2::signal<void (bool fHaveWatchOnly)> NotifyWatchonlyChanged;\n+\n+    /** Inquire whether this wallet broadcasts transactions. */\n+    bool GetBroadcastTransactions() const { return fBroadcastTransactions; }\n+    /** Set whether this wallet broadcasts transactions. */\n+    void SetBroadcastTransactions(bool broadcast) { fBroadcastTransactions = broadcast; }\n+\n+    /* Mark a transaction (and it in-wallet descendants) as abandoned so its inputs may be respent. */\n+    bool AbandonTransaction(const uint256& hashTx);\n+\n+    /* Returns the wallets help message */\n+    static std::string GetWalletHelpString(bool showDebug);\n+\n+    /* Initializes the wallet, returns a new CWallet instance or a null pointer in case of an error */\n+    static bool InitLoadWallet();\n+\n+    /* Wallets parameter interaction */\n+    static bool ParameterInteraction();\n+};\n+\n+/** A key allocated from the key pool. */\n+class CReserveKey : public CReserveScript\n+{\n+protected:\n+    CWallet* pwallet;\n+    int64_t nIndex;\n+    CPubKey vchPubKey;\n+public:\n+    CReserveKey(CWallet* pwalletIn)\n+    {\n+        nIndex = -1;\n+        pwallet = pwalletIn;\n+    }\n+\n+    ~CReserveKey()\n+    {\n+        ReturnKey();\n+    }\n+\n+    void ReturnKey();\n+    bool GetReservedKey(CPubKey &pubkey);\n+    void KeepKey();\n+    void KeepScript() { KeepKey(); }\n+};\n+\n+\n+/** \n+ * Account information.\n+ * Stored in wallet with key \"acc\"+string account name.\n+ */\n+class CAccount\n+{\n+public:\n+    CPubKey vchPubKey;\n+\n+    CAccount()\n+    {\n+        SetNull();\n+    }\n+\n+    void SetNull()\n+    {\n+        vchPubKey = CPubKey();\n+    }\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        if (!(nType & SER_GETHASH))\n+            READWRITE(nVersion);\n+        READWRITE(vchPubKey);\n+    }\n+};\n+\n+#endif // BITCOIN_WALLET_WALLET_H"
      },
      {
        "sha": "ebda5cc53df76dc5d610f06712af774ff9c7b952",
        "filename": "src/lightwallet/wallet_ismine.cpp",
        "status": "added",
        "additions": 95,
        "deletions": 0,
        "changes": 95,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e1c9383edc81c67e6c7b8794a649d06d538747b9/src/lightwallet/wallet_ismine.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e1c9383edc81c67e6c7b8794a649d06d538747b9/src/lightwallet/wallet_ismine.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/wallet_ismine.cpp?ref=e1c9383edc81c67e6c7b8794a649d06d538747b9",
        "patch": "@@ -0,0 +1,95 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"wallet_ismine.h\"\n+\n+#include \"key.h\"\n+#include \"keystore.h\"\n+#include \"script/script.h\"\n+#include \"script/standard.h\"\n+#include \"script/sign.h\"\n+\n+#include <boost/foreach.hpp>\n+\n+using namespace std;\n+\n+typedef vector<unsigned char> valtype;\n+\n+unsigned int HaveKeys(const vector<valtype>& pubkeys, const CKeyStore& keystore)\n+{\n+    unsigned int nResult = 0;\n+    BOOST_FOREACH(const valtype& pubkey, pubkeys)\n+    {\n+        CKeyID keyID = CPubKey(pubkey).GetID();\n+        if (keystore.HaveKey(keyID))\n+            ++nResult;\n+    }\n+    return nResult;\n+}\n+\n+isminetype IsMine(const CKeyStore &keystore, const CTxDestination& dest)\n+{\n+    CScript script = GetScriptForDestination(dest);\n+    return IsMine(keystore, script);\n+}\n+\n+isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n+{\n+    vector<valtype> vSolutions;\n+    txnouttype whichType;\n+    if (!Solver(scriptPubKey, whichType, vSolutions)) {\n+        if (keystore.HaveWatchOnly(scriptPubKey))\n+            return ISMINE_WATCH_UNSOLVABLE;\n+        return ISMINE_NO;\n+    }\n+\n+    CKeyID keyID;\n+    switch (whichType)\n+    {\n+    case TX_NONSTANDARD:\n+    case TX_NULL_DATA:\n+        break;\n+    case TX_PUBKEY:\n+        keyID = CPubKey(vSolutions[0]).GetID();\n+        if (keystore.HaveKey(keyID))\n+            return ISMINE_SPENDABLE;\n+        break;\n+    case TX_PUBKEYHASH:\n+        keyID = CKeyID(uint160(vSolutions[0]));\n+        if (keystore.HaveKey(keyID))\n+            return ISMINE_SPENDABLE;\n+        break;\n+    case TX_SCRIPTHASH:\n+    {\n+        CScriptID scriptID = CScriptID(uint160(vSolutions[0]));\n+        CScript subscript;\n+        if (keystore.GetCScript(scriptID, subscript)) {\n+            isminetype ret = IsMine(keystore, subscript);\n+            if (ret == ISMINE_SPENDABLE)\n+                return ret;\n+        }\n+        break;\n+    }\n+    case TX_MULTISIG:\n+    {\n+        // Only consider transactions \"mine\" if we own ALL the\n+        // keys involved. Multi-signature transactions that are\n+        // partially owned (somebody else has a key that can spend\n+        // them) enable spend-out-from-under-you attacks, especially\n+        // in shared-wallet situations.\n+        vector<valtype> keys(vSolutions.begin()+1, vSolutions.begin()+vSolutions.size()-1);\n+        if (HaveKeys(keys, keystore) == keys.size())\n+            return ISMINE_SPENDABLE;\n+        break;\n+    }\n+    }\n+\n+    if (keystore.HaveWatchOnly(scriptPubKey)) {\n+        // TODO: This could be optimized some by doing some work after the above solver\n+        CScript scriptSig;\n+        return ProduceSignature(DummySignatureCreator(&keystore), scriptPubKey, scriptSig) ? ISMINE_WATCH_SOLVABLE : ISMINE_WATCH_UNSOLVABLE;\n+    }\n+    return ISMINE_NO;\n+}"
      },
      {
        "sha": "51afd1b1402cb4ad9aebe202271d7665d90f1de7",
        "filename": "src/lightwallet/wallet_ismine.h",
        "status": "added",
        "additions": 34,
        "deletions": 0,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e1c9383edc81c67e6c7b8794a649d06d538747b9/src/lightwallet/wallet_ismine.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e1c9383edc81c67e6c7b8794a649d06d538747b9/src/lightwallet/wallet_ismine.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/wallet_ismine.h?ref=e1c9383edc81c67e6c7b8794a649d06d538747b9",
        "patch": "@@ -0,0 +1,34 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_WALLET_WALLET_ISMINE_H\n+#define BITCOIN_WALLET_WALLET_ISMINE_H\n+\n+#include \"script/standard.h\"\n+\n+#include <stdint.h>\n+\n+class CKeyStore;\n+class CScript;\n+\n+/** IsMine() return codes */\n+enum isminetype\n+{\n+    ISMINE_NO = 0,\n+    //! Indicates that we don't know how to create a scriptSig that would solve this if we were given the appropriate private keys\n+    ISMINE_WATCH_UNSOLVABLE = 1,\n+    //! Indicates that we know how to create a scriptSig that would solve this if we were given the appropriate private keys\n+    ISMINE_WATCH_SOLVABLE = 2,\n+    ISMINE_WATCH_ONLY = ISMINE_WATCH_SOLVABLE | ISMINE_WATCH_UNSOLVABLE,\n+    ISMINE_SPENDABLE = 4,\n+    ISMINE_ALL = ISMINE_WATCH_ONLY | ISMINE_SPENDABLE\n+};\n+/** used for bitflags of isminetype */\n+typedef uint8_t isminefilter;\n+\n+isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey);\n+isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest);\n+\n+#endif // BITCOIN_WALLET_WALLET_ISMINE_H"
      },
      {
        "sha": "f2b5408e92b5d7f9d4c3e75f626a035e92b3b48e",
        "filename": "src/lightwallet/walletdb.cpp",
        "status": "added",
        "additions": 1045,
        "deletions": 0,
        "changes": 1045,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e1c9383edc81c67e6c7b8794a649d06d538747b9/src/lightwallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e1c9383edc81c67e6c7b8794a649d06d538747b9/src/lightwallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/walletdb.cpp?ref=e1c9383edc81c67e6c7b8794a649d06d538747b9",
        "patch": "@@ -0,0 +1,1045 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"wallet/walletdb.h\"\n+\n+#include \"base58.h\"\n+#include \"consensus/validation.h\"\n+#include \"main.h\" // For CheckTransaction\n+#include \"protocol.h\"\n+#include \"serialize.h\"\n+#include \"sync.h\"\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"wallet/wallet.h\"\n+\n+#include <boost/version.hpp>\n+#include <boost/filesystem.hpp>\n+#include <boost/foreach.hpp>\n+#include <boost/scoped_ptr.hpp>\n+#include <boost/thread.hpp>\n+\n+using namespace std;\n+\n+static uint64_t nAccountingEntryNumber = 0;\n+\n+//\n+// CWalletDB\n+//\n+\n+bool CWalletDB::WriteName(const string& strAddress, const string& strName)\n+{\n+    nWalletDBUpdated++;\n+    return Write(make_pair(string(\"name\"), strAddress), strName);\n+}\n+\n+bool CWalletDB::EraseName(const string& strAddress)\n+{\n+    // This should only be used for sending addresses, never for receiving addresses,\n+    // receiving addresses must always have an address book entry if they're not change return.\n+    nWalletDBUpdated++;\n+    return Erase(make_pair(string(\"name\"), strAddress));\n+}\n+\n+bool CWalletDB::WritePurpose(const string& strAddress, const string& strPurpose)\n+{\n+    nWalletDBUpdated++;\n+    return Write(make_pair(string(\"purpose\"), strAddress), strPurpose);\n+}\n+\n+bool CWalletDB::ErasePurpose(const string& strPurpose)\n+{\n+    nWalletDBUpdated++;\n+    return Erase(make_pair(string(\"purpose\"), strPurpose));\n+}\n+\n+bool CWalletDB::WriteTx(uint256 hash, const CWalletTx& wtx)\n+{\n+    nWalletDBUpdated++;\n+    return Write(std::make_pair(std::string(\"tx\"), hash), wtx);\n+}\n+\n+bool CWalletDB::EraseTx(uint256 hash)\n+{\n+    nWalletDBUpdated++;\n+    return Erase(std::make_pair(std::string(\"tx\"), hash));\n+}\n+\n+bool CWalletDB::WriteKey(const CPubKey& vchPubKey, const CPrivKey& vchPrivKey, const CKeyMetadata& keyMeta)\n+{\n+    nWalletDBUpdated++;\n+\n+    if (!Write(std::make_pair(std::string(\"keymeta\"), vchPubKey),\n+               keyMeta, false))\n+        return false;\n+\n+    // hash pubkey/privkey to accelerate wallet load\n+    std::vector<unsigned char> vchKey;\n+    vchKey.reserve(vchPubKey.size() + vchPrivKey.size());\n+    vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end());\n+    vchKey.insert(vchKey.end(), vchPrivKey.begin(), vchPrivKey.end());\n+\n+    return Write(std::make_pair(std::string(\"key\"), vchPubKey), std::make_pair(vchPrivKey, Hash(vchKey.begin(), vchKey.end())), false);\n+}\n+\n+bool CWalletDB::WriteCryptedKey(const CPubKey& vchPubKey,\n+                                const std::vector<unsigned char>& vchCryptedSecret,\n+                                const CKeyMetadata &keyMeta)\n+{\n+    const bool fEraseUnencryptedKey = true;\n+    nWalletDBUpdated++;\n+\n+    if (!Write(std::make_pair(std::string(\"keymeta\"), vchPubKey),\n+            keyMeta))\n+        return false;\n+\n+    if (!Write(std::make_pair(std::string(\"ckey\"), vchPubKey), vchCryptedSecret, false))\n+        return false;\n+    if (fEraseUnencryptedKey)\n+    {\n+        Erase(std::make_pair(std::string(\"key\"), vchPubKey));\n+        Erase(std::make_pair(std::string(\"wkey\"), vchPubKey));\n+    }\n+    return true;\n+}\n+\n+bool CWalletDB::WriteMasterKey(unsigned int nID, const CMasterKey& kMasterKey)\n+{\n+    nWalletDBUpdated++;\n+    return Write(std::make_pair(std::string(\"mkey\"), nID), kMasterKey, true);\n+}\n+\n+bool CWalletDB::WriteCScript(const uint160& hash, const CScript& redeemScript)\n+{\n+    nWalletDBUpdated++;\n+    return Write(std::make_pair(std::string(\"cscript\"), hash), *(const CScriptBase*)(&redeemScript), false);\n+}\n+\n+bool CWalletDB::WriteWatchOnly(const CScript &dest)\n+{\n+    nWalletDBUpdated++;\n+    return Write(std::make_pair(std::string(\"watchs\"), *(const CScriptBase*)(&dest)), '1');\n+}\n+\n+bool CWalletDB::EraseWatchOnly(const CScript &dest)\n+{\n+    nWalletDBUpdated++;\n+    return Erase(std::make_pair(std::string(\"watchs\"), *(const CScriptBase*)(&dest)));\n+}\n+\n+bool CWalletDB::WriteBestBlock(const CBlockLocator& locator)\n+{\n+    nWalletDBUpdated++;\n+    Write(std::string(\"bestblock\"), CBlockLocator()); // Write empty block locator so versions that require a merkle branch automatically rescan\n+    return Write(std::string(\"bestblock_nomerkle\"), locator);\n+}\n+\n+bool CWalletDB::ReadBestBlock(CBlockLocator& locator)\n+{\n+    if (Read(std::string(\"bestblock\"), locator) && !locator.vHave.empty()) return true;\n+    return Read(std::string(\"bestblock_nomerkle\"), locator);\n+}\n+\n+bool CWalletDB::WriteOrderPosNext(int64_t nOrderPosNext)\n+{\n+    nWalletDBUpdated++;\n+    return Write(std::string(\"orderposnext\"), nOrderPosNext);\n+}\n+\n+bool CWalletDB::WriteDefaultKey(const CPubKey& vchPubKey)\n+{\n+    nWalletDBUpdated++;\n+    return Write(std::string(\"defaultkey\"), vchPubKey);\n+}\n+\n+bool CWalletDB::ReadPool(int64_t nPool, CKeyPool& keypool)\n+{\n+    return Read(std::make_pair(std::string(\"pool\"), nPool), keypool);\n+}\n+\n+bool CWalletDB::WritePool(int64_t nPool, const CKeyPool& keypool)\n+{\n+    nWalletDBUpdated++;\n+    return Write(std::make_pair(std::string(\"pool\"), nPool), keypool);\n+}\n+\n+bool CWalletDB::ErasePool(int64_t nPool)\n+{\n+    nWalletDBUpdated++;\n+    return Erase(std::make_pair(std::string(\"pool\"), nPool));\n+}\n+\n+bool CWalletDB::WriteMinVersion(int nVersion)\n+{\n+    return Write(std::string(\"minversion\"), nVersion);\n+}\n+\n+bool CWalletDB::ReadAccount(const string& strAccount, CAccount& account)\n+{\n+    account.SetNull();\n+    return Read(make_pair(string(\"acc\"), strAccount), account);\n+}\n+\n+bool CWalletDB::WriteAccount(const string& strAccount, const CAccount& account)\n+{\n+    return Write(make_pair(string(\"acc\"), strAccount), account);\n+}\n+\n+bool CWalletDB::WriteAccountingEntry(const uint64_t nAccEntryNum, const CAccountingEntry& acentry)\n+{\n+    return Write(std::make_pair(std::string(\"acentry\"), std::make_pair(acentry.strAccount, nAccEntryNum)), acentry);\n+}\n+\n+bool CWalletDB::WriteAccountingEntry_Backend(const CAccountingEntry& acentry)\n+{\n+    return WriteAccountingEntry(++nAccountingEntryNumber, acentry);\n+}\n+\n+CAmount CWalletDB::GetAccountCreditDebit(const string& strAccount)\n+{\n+    list<CAccountingEntry> entries;\n+    ListAccountCreditDebit(strAccount, entries);\n+\n+    CAmount nCreditDebit = 0;\n+    BOOST_FOREACH (const CAccountingEntry& entry, entries)\n+        nCreditDebit += entry.nCreditDebit;\n+\n+    return nCreditDebit;\n+}\n+\n+void CWalletDB::ListAccountCreditDebit(const string& strAccount, list<CAccountingEntry>& entries)\n+{\n+    bool fAllAccounts = (strAccount == \"*\");\n+\n+    Dbc* pcursor = GetCursor();\n+    if (!pcursor)\n+        throw runtime_error(\"CWalletDB::ListAccountCreditDebit(): cannot create DB cursor\");\n+    unsigned int fFlags = DB_SET_RANGE;\n+    while (true)\n+    {\n+        // Read next record\n+        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+        if (fFlags == DB_SET_RANGE)\n+            ssKey << std::make_pair(std::string(\"acentry\"), std::make_pair((fAllAccounts ? string(\"\") : strAccount), uint64_t(0)));\n+        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n+        int ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n+        fFlags = DB_NEXT;\n+        if (ret == DB_NOTFOUND)\n+            break;\n+        else if (ret != 0)\n+        {\n+            pcursor->close();\n+            throw runtime_error(\"CWalletDB::ListAccountCreditDebit(): error scanning DB\");\n+        }\n+\n+        // Unserialize\n+        string strType;\n+        ssKey >> strType;\n+        if (strType != \"acentry\")\n+            break;\n+        CAccountingEntry acentry;\n+        ssKey >> acentry.strAccount;\n+        if (!fAllAccounts && acentry.strAccount != strAccount)\n+            break;\n+\n+        ssValue >> acentry;\n+        ssKey >> acentry.nEntryNo;\n+        entries.push_back(acentry);\n+    }\n+\n+    pcursor->close();\n+}\n+\n+DBErrors CWalletDB::ReorderTransactions(CWallet* pwallet)\n+{\n+    LOCK(pwallet->cs_wallet);\n+    // Old wallets didn't have any defined order for transactions\n+    // Probably a bad idea to change the output of this\n+\n+    // First: get all CWalletTx and CAccountingEntry into a sorted-by-time multimap.\n+    typedef pair<CWalletTx*, CAccountingEntry*> TxPair;\n+    typedef multimap<int64_t, TxPair > TxItems;\n+    TxItems txByTime;\n+\n+    for (map<uint256, CWalletTx>::iterator it = pwallet->mapWallet.begin(); it != pwallet->mapWallet.end(); ++it)\n+    {\n+        CWalletTx* wtx = &((*it).second);\n+        txByTime.insert(make_pair(wtx->nTimeReceived, TxPair(wtx, (CAccountingEntry*)0)));\n+    }\n+    list<CAccountingEntry> acentries;\n+    ListAccountCreditDebit(\"\", acentries);\n+    BOOST_FOREACH(CAccountingEntry& entry, acentries)\n+    {\n+        txByTime.insert(make_pair(entry.nTime, TxPair((CWalletTx*)0, &entry)));\n+    }\n+\n+    int64_t& nOrderPosNext = pwallet->nOrderPosNext;\n+    nOrderPosNext = 0;\n+    std::vector<int64_t> nOrderPosOffsets;\n+    for (TxItems::iterator it = txByTime.begin(); it != txByTime.end(); ++it)\n+    {\n+        CWalletTx *const pwtx = (*it).second.first;\n+        CAccountingEntry *const pacentry = (*it).second.second;\n+        int64_t& nOrderPos = (pwtx != 0) ? pwtx->nOrderPos : pacentry->nOrderPos;\n+\n+        if (nOrderPos == -1)\n+        {\n+            nOrderPos = nOrderPosNext++;\n+            nOrderPosOffsets.push_back(nOrderPos);\n+\n+            if (pwtx)\n+            {\n+                if (!WriteTx(pwtx->GetHash(), *pwtx))\n+                    return DB_LOAD_FAIL;\n+            }\n+            else\n+                if (!WriteAccountingEntry(pacentry->nEntryNo, *pacentry))\n+                    return DB_LOAD_FAIL;\n+        }\n+        else\n+        {\n+            int64_t nOrderPosOff = 0;\n+            BOOST_FOREACH(const int64_t& nOffsetStart, nOrderPosOffsets)\n+            {\n+                if (nOrderPos >= nOffsetStart)\n+                    ++nOrderPosOff;\n+            }\n+            nOrderPos += nOrderPosOff;\n+            nOrderPosNext = std::max(nOrderPosNext, nOrderPos + 1);\n+\n+            if (!nOrderPosOff)\n+                continue;\n+\n+            // Since we're changing the order, write it back\n+            if (pwtx)\n+            {\n+                if (!WriteTx(pwtx->GetHash(), *pwtx))\n+                    return DB_LOAD_FAIL;\n+            }\n+            else\n+                if (!WriteAccountingEntry(pacentry->nEntryNo, *pacentry))\n+                    return DB_LOAD_FAIL;\n+        }\n+    }\n+    WriteOrderPosNext(nOrderPosNext);\n+\n+    return DB_LOAD_OK;\n+}\n+\n+class CWalletScanState {\n+public:\n+    unsigned int nKeys;\n+    unsigned int nCKeys;\n+    unsigned int nKeyMeta;\n+    bool fIsEncrypted;\n+    bool fAnyUnordered;\n+    int nFileVersion;\n+    vector<uint256> vWalletUpgrade;\n+\n+    CWalletScanState() {\n+        nKeys = nCKeys = nKeyMeta = 0;\n+        fIsEncrypted = false;\n+        fAnyUnordered = false;\n+        nFileVersion = 0;\n+    }\n+};\n+\n+bool\n+ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n+             CWalletScanState &wss, string& strType, string& strErr)\n+{\n+    try {\n+        // Unserialize\n+        // Taking advantage of the fact that pair serialization\n+        // is just the two items serialized one after the other\n+        ssKey >> strType;\n+        if (strType == \"name\")\n+        {\n+            string strAddress;\n+            ssKey >> strAddress;\n+            ssValue >> pwallet->mapAddressBook[CBitcoinAddress(strAddress).Get()].name;\n+        }\n+        else if (strType == \"purpose\")\n+        {\n+            string strAddress;\n+            ssKey >> strAddress;\n+            ssValue >> pwallet->mapAddressBook[CBitcoinAddress(strAddress).Get()].purpose;\n+        }\n+        else if (strType == \"tx\")\n+        {\n+            uint256 hash;\n+            ssKey >> hash;\n+            CWalletTx wtx;\n+            ssValue >> wtx;\n+            CValidationState state;\n+            if (!(CheckTransaction(wtx, state) && (wtx.GetHash() == hash) && state.IsValid()))\n+                return false;\n+\n+            // Undo serialize changes in 31600\n+            if (31404 <= wtx.fTimeReceivedIsTxTime && wtx.fTimeReceivedIsTxTime <= 31703)\n+            {\n+                if (!ssValue.empty())\n+                {\n+                    char fTmp;\n+                    char fUnused;\n+                    ssValue >> fTmp >> fUnused >> wtx.strFromAccount;\n+                    strErr = strprintf(\"LoadWallet() upgrading tx ver=%d %d '%s' %s\",\n+                                       wtx.fTimeReceivedIsTxTime, fTmp, wtx.strFromAccount, hash.ToString());\n+                    wtx.fTimeReceivedIsTxTime = fTmp;\n+                }\n+                else\n+                {\n+                    strErr = strprintf(\"LoadWallet() repairing tx ver=%d %s\", wtx.fTimeReceivedIsTxTime, hash.ToString());\n+                    wtx.fTimeReceivedIsTxTime = 0;\n+                }\n+                wss.vWalletUpgrade.push_back(hash);\n+            }\n+\n+            if (wtx.nOrderPos == -1)\n+                wss.fAnyUnordered = true;\n+\n+            pwallet->AddToWallet(wtx, true, NULL);\n+        }\n+        else if (strType == \"acentry\")\n+        {\n+            string strAccount;\n+            ssKey >> strAccount;\n+            uint64_t nNumber;\n+            ssKey >> nNumber;\n+            if (nNumber > nAccountingEntryNumber)\n+                nAccountingEntryNumber = nNumber;\n+\n+            if (!wss.fAnyUnordered)\n+            {\n+                CAccountingEntry acentry;\n+                ssValue >> acentry;\n+                if (acentry.nOrderPos == -1)\n+                    wss.fAnyUnordered = true;\n+            }\n+        }\n+        else if (strType == \"watchs\")\n+        {\n+            CScript script;\n+            ssKey >> *(CScriptBase*)(&script);\n+            char fYes;\n+            ssValue >> fYes;\n+            if (fYes == '1')\n+                pwallet->LoadWatchOnly(script);\n+\n+            // Watch-only addresses have no birthday information for now,\n+            // so set the wallet birthday to the beginning of time.\n+            pwallet->nTimeFirstKey = 1;\n+        }\n+        else if (strType == \"key\" || strType == \"wkey\")\n+        {\n+            CPubKey vchPubKey;\n+            ssKey >> vchPubKey;\n+            if (!vchPubKey.IsValid())\n+            {\n+                strErr = \"Error reading wallet database: CPubKey corrupt\";\n+                return false;\n+            }\n+            CKey key;\n+            CPrivKey pkey;\n+            uint256 hash;\n+\n+            if (strType == \"key\")\n+            {\n+                wss.nKeys++;\n+                ssValue >> pkey;\n+            } else {\n+                CWalletKey wkey;\n+                ssValue >> wkey;\n+                pkey = wkey.vchPrivKey;\n+            }\n+\n+            // Old wallets store keys as \"key\" [pubkey] => [privkey]\n+            // ... which was slow for wallets with lots of keys, because the public key is re-derived from the private key\n+            // using EC operations as a checksum.\n+            // Newer wallets store keys as \"key\"[pubkey] => [privkey][hash(pubkey,privkey)], which is much faster while\n+            // remaining backwards-compatible.\n+            try\n+            {\n+                ssValue >> hash;\n+            }\n+            catch (...) {}\n+\n+            bool fSkipCheck = false;\n+\n+            if (!hash.IsNull())\n+            {\n+                // hash pubkey/privkey to accelerate wallet load\n+                std::vector<unsigned char> vchKey;\n+                vchKey.reserve(vchPubKey.size() + pkey.size());\n+                vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end());\n+                vchKey.insert(vchKey.end(), pkey.begin(), pkey.end());\n+\n+                if (Hash(vchKey.begin(), vchKey.end()) != hash)\n+                {\n+                    strErr = \"Error reading wallet database: CPubKey/CPrivKey corrupt\";\n+                    return false;\n+                }\n+\n+                fSkipCheck = true;\n+            }\n+\n+            if (!key.Load(pkey, vchPubKey, fSkipCheck))\n+            {\n+                strErr = \"Error reading wallet database: CPrivKey corrupt\";\n+                return false;\n+            }\n+            if (!pwallet->LoadKey(key, vchPubKey))\n+            {\n+                strErr = \"Error reading wallet database: LoadKey failed\";\n+                return false;\n+            }\n+        }\n+        else if (strType == \"mkey\")\n+        {\n+            unsigned int nID;\n+            ssKey >> nID;\n+            CMasterKey kMasterKey;\n+            ssValue >> kMasterKey;\n+            if(pwallet->mapMasterKeys.count(nID) != 0)\n+            {\n+                strErr = strprintf(\"Error reading wallet database: duplicate CMasterKey id %u\", nID);\n+                return false;\n+            }\n+            pwallet->mapMasterKeys[nID] = kMasterKey;\n+            if (pwallet->nMasterKeyMaxID < nID)\n+                pwallet->nMasterKeyMaxID = nID;\n+        }\n+        else if (strType == \"ckey\")\n+        {\n+            CPubKey vchPubKey;\n+            ssKey >> vchPubKey;\n+            if (!vchPubKey.IsValid())\n+            {\n+                strErr = \"Error reading wallet database: CPubKey corrupt\";\n+                return false;\n+            }\n+            vector<unsigned char> vchPrivKey;\n+            ssValue >> vchPrivKey;\n+            wss.nCKeys++;\n+\n+            if (!pwallet->LoadCryptedKey(vchPubKey, vchPrivKey))\n+            {\n+                strErr = \"Error reading wallet database: LoadCryptedKey failed\";\n+                return false;\n+            }\n+            wss.fIsEncrypted = true;\n+        }\n+        else if (strType == \"keymeta\")\n+        {\n+            CPubKey vchPubKey;\n+            ssKey >> vchPubKey;\n+            CKeyMetadata keyMeta;\n+            ssValue >> keyMeta;\n+            wss.nKeyMeta++;\n+\n+            pwallet->LoadKeyMetadata(vchPubKey, keyMeta);\n+\n+            // find earliest key creation time, as wallet birthday\n+            if (!pwallet->nTimeFirstKey ||\n+                (keyMeta.nCreateTime < pwallet->nTimeFirstKey))\n+                pwallet->nTimeFirstKey = keyMeta.nCreateTime;\n+        }\n+        else if (strType == \"defaultkey\")\n+        {\n+            ssValue >> pwallet->vchDefaultKey;\n+        }\n+        else if (strType == \"pool\")\n+        {\n+            int64_t nIndex;\n+            ssKey >> nIndex;\n+            CKeyPool keypool;\n+            ssValue >> keypool;\n+            pwallet->setKeyPool.insert(nIndex);\n+\n+            // If no metadata exists yet, create a default with the pool key's\n+            // creation time. Note that this may be overwritten by actually\n+            // stored metadata for that key later, which is fine.\n+            CKeyID keyid = keypool.vchPubKey.GetID();\n+            if (pwallet->mapKeyMetadata.count(keyid) == 0)\n+                pwallet->mapKeyMetadata[keyid] = CKeyMetadata(keypool.nTime);\n+        }\n+        else if (strType == \"version\")\n+        {\n+            ssValue >> wss.nFileVersion;\n+            if (wss.nFileVersion == 10300)\n+                wss.nFileVersion = 300;\n+        }\n+        else if (strType == \"cscript\")\n+        {\n+            uint160 hash;\n+            ssKey >> hash;\n+            CScript script;\n+            ssValue >> *(CScriptBase*)(&script);\n+            if (!pwallet->LoadCScript(script))\n+            {\n+                strErr = \"Error reading wallet database: LoadCScript failed\";\n+                return false;\n+            }\n+        }\n+        else if (strType == \"orderposnext\")\n+        {\n+            ssValue >> pwallet->nOrderPosNext;\n+        }\n+        else if (strType == \"destdata\")\n+        {\n+            std::string strAddress, strKey, strValue;\n+            ssKey >> strAddress;\n+            ssKey >> strKey;\n+            ssValue >> strValue;\n+            if (!pwallet->LoadDestData(CBitcoinAddress(strAddress).Get(), strKey, strValue))\n+            {\n+                strErr = \"Error reading wallet database: LoadDestData failed\";\n+                return false;\n+            }\n+        }\n+    } catch (...)\n+    {\n+        return false;\n+    }\n+    return true;\n+}\n+\n+static bool IsKeyType(string strType)\n+{\n+    return (strType== \"key\" || strType == \"wkey\" ||\n+            strType == \"mkey\" || strType == \"ckey\");\n+}\n+\n+DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n+{\n+    pwallet->vchDefaultKey = CPubKey();\n+    CWalletScanState wss;\n+    bool fNoncriticalErrors = false;\n+    DBErrors result = DB_LOAD_OK;\n+\n+    try {\n+        LOCK(pwallet->cs_wallet);\n+        int nMinVersion = 0;\n+        if (Read((string)\"minversion\", nMinVersion))\n+        {\n+            if (nMinVersion > CLIENT_VERSION)\n+                return DB_TOO_NEW;\n+            pwallet->LoadMinVersion(nMinVersion);\n+        }\n+\n+        // Get cursor\n+        Dbc* pcursor = GetCursor();\n+        if (!pcursor)\n+        {\n+            LogPrintf(\"Error getting wallet database cursor\\n\");\n+            return DB_CORRUPT;\n+        }\n+\n+        while (true)\n+        {\n+            // Read next record\n+            CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+            CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n+            int ret = ReadAtCursor(pcursor, ssKey, ssValue);\n+            if (ret == DB_NOTFOUND)\n+                break;\n+            else if (ret != 0)\n+            {\n+                LogPrintf(\"Error reading next record from wallet database\\n\");\n+                return DB_CORRUPT;\n+            }\n+\n+            // Try to be tolerant of single corrupt records:\n+            string strType, strErr;\n+            if (!ReadKeyValue(pwallet, ssKey, ssValue, wss, strType, strErr))\n+            {\n+                // losing keys is considered a catastrophic error, anything else\n+                // we assume the user can live with:\n+                if (IsKeyType(strType))\n+                    result = DB_CORRUPT;\n+                else\n+                {\n+                    // Leave other errors alone, if we try to fix them we might make things worse.\n+                    fNoncriticalErrors = true; // ... but do warn the user there is something wrong.\n+                    if (strType == \"tx\")\n+                        // Rescan if there is a bad transaction record:\n+                        SoftSetBoolArg(\"-rescan\", true);\n+                }\n+            }\n+            if (!strErr.empty())\n+                LogPrintf(\"%s\\n\", strErr);\n+        }\n+        pcursor->close();\n+    }\n+    catch (const boost::thread_interrupted&) {\n+        throw;\n+    }\n+    catch (...) {\n+        result = DB_CORRUPT;\n+    }\n+\n+    if (fNoncriticalErrors && result == DB_LOAD_OK)\n+        result = DB_NONCRITICAL_ERROR;\n+\n+    // Any wallet corruption at all: skip any rewriting or\n+    // upgrading, we don't want to make it worse.\n+    if (result != DB_LOAD_OK)\n+        return result;\n+\n+    LogPrintf(\"nFileVersion = %d\\n\", wss.nFileVersion);\n+\n+    LogPrintf(\"Keys: %u plaintext, %u encrypted, %u w/ metadata, %u total\\n\",\n+           wss.nKeys, wss.nCKeys, wss.nKeyMeta, wss.nKeys + wss.nCKeys);\n+\n+    // nTimeFirstKey is only reliable if all keys have metadata\n+    if ((wss.nKeys + wss.nCKeys) != wss.nKeyMeta)\n+        pwallet->nTimeFirstKey = 1; // 0 would be considered 'no value'\n+\n+    BOOST_FOREACH(uint256 hash, wss.vWalletUpgrade)\n+        WriteTx(hash, pwallet->mapWallet[hash]);\n+\n+    // Rewrite encrypted wallets of versions 0.4.0 and 0.5.0rc:\n+    if (wss.fIsEncrypted && (wss.nFileVersion == 40000 || wss.nFileVersion == 50000))\n+        return DB_NEED_REWRITE;\n+\n+    if (wss.nFileVersion < CLIENT_VERSION) // Update\n+        WriteVersion(CLIENT_VERSION);\n+\n+    if (wss.fAnyUnordered)\n+        result = ReorderTransactions(pwallet);\n+\n+    pwallet->laccentries.clear();\n+    ListAccountCreditDebit(\"*\", pwallet->laccentries);\n+    BOOST_FOREACH(CAccountingEntry& entry, pwallet->laccentries) {\n+        pwallet->wtxOrdered.insert(make_pair(entry.nOrderPos, CWallet::TxPair((CWalletTx*)0, &entry)));\n+    }\n+\n+    return result;\n+}\n+\n+DBErrors CWalletDB::FindWalletTx(CWallet* pwallet, vector<uint256>& vTxHash, vector<CWalletTx>& vWtx)\n+{\n+    pwallet->vchDefaultKey = CPubKey();\n+    bool fNoncriticalErrors = false;\n+    DBErrors result = DB_LOAD_OK;\n+\n+    try {\n+        LOCK(pwallet->cs_wallet);\n+        int nMinVersion = 0;\n+        if (Read((string)\"minversion\", nMinVersion))\n+        {\n+            if (nMinVersion > CLIENT_VERSION)\n+                return DB_TOO_NEW;\n+            pwallet->LoadMinVersion(nMinVersion);\n+        }\n+\n+        // Get cursor\n+        Dbc* pcursor = GetCursor();\n+        if (!pcursor)\n+        {\n+            LogPrintf(\"Error getting wallet database cursor\\n\");\n+            return DB_CORRUPT;\n+        }\n+\n+        while (true)\n+        {\n+            // Read next record\n+            CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+            CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n+            int ret = ReadAtCursor(pcursor, ssKey, ssValue);\n+            if (ret == DB_NOTFOUND)\n+                break;\n+            else if (ret != 0)\n+            {\n+                LogPrintf(\"Error reading next record from wallet database\\n\");\n+                return DB_CORRUPT;\n+            }\n+\n+            string strType;\n+            ssKey >> strType;\n+            if (strType == \"tx\") {\n+                uint256 hash;\n+                ssKey >> hash;\n+\n+                CWalletTx wtx;\n+                ssValue >> wtx;\n+\n+                vTxHash.push_back(hash);\n+                vWtx.push_back(wtx);\n+            }\n+        }\n+        pcursor->close();\n+    }\n+    catch (const boost::thread_interrupted&) {\n+        throw;\n+    }\n+    catch (...) {\n+        result = DB_CORRUPT;\n+    }\n+\n+    if (fNoncriticalErrors && result == DB_LOAD_OK)\n+        result = DB_NONCRITICAL_ERROR;\n+\n+    return result;\n+}\n+\n+DBErrors CWalletDB::ZapSelectTx(CWallet* pwallet, vector<uint256>& vTxHashIn, vector<uint256>& vTxHashOut)\n+{\n+    // build list of wallet TXs and hashes\n+    vector<uint256> vTxHash;\n+    vector<CWalletTx> vWtx;\n+    DBErrors err = FindWalletTx(pwallet, vTxHash, vWtx);\n+    if (err != DB_LOAD_OK) {\n+        return err;\n+    }\n+\n+    std::sort(vTxHash.begin(), vTxHash.end());\n+    std::sort(vTxHashIn.begin(), vTxHashIn.end());\n+\n+    // erase each matching wallet TX\n+    bool delerror = false;\n+    vector<uint256>::iterator it = vTxHashIn.begin();\n+    BOOST_FOREACH (uint256 hash, vTxHash) {\n+        while (it < vTxHashIn.end() && (*it) < hash) {\n+            it++;\n+        }\n+        if (it == vTxHashIn.end()) {\n+            break;\n+        }\n+        else if ((*it) == hash) {\n+            pwallet->mapWallet.erase(hash);\n+            if(!EraseTx(hash)) {\n+                LogPrint(\"db\", \"Transaction was found for deletion but returned database error: %s\\n\", hash.GetHex());\n+                delerror = true;\n+            }\n+            vTxHashOut.push_back(hash);\n+        }\n+    }\n+\n+    if (delerror) {\n+        return DB_CORRUPT;\n+    }\n+    return DB_LOAD_OK;\n+}\n+\n+DBErrors CWalletDB::ZapWalletTx(CWallet* pwallet, vector<CWalletTx>& vWtx)\n+{\n+    // build list of wallet TXs\n+    vector<uint256> vTxHash;\n+    DBErrors err = FindWalletTx(pwallet, vTxHash, vWtx);\n+    if (err != DB_LOAD_OK)\n+        return err;\n+\n+    // erase each wallet TX\n+    BOOST_FOREACH (uint256& hash, vTxHash) {\n+        if (!EraseTx(hash))\n+            return DB_CORRUPT;\n+    }\n+\n+    return DB_LOAD_OK;\n+}\n+\n+void ThreadFlushWalletDB(const string& strFile)\n+{\n+    // Make this thread recognisable as the wallet flushing thread\n+    RenameThread(\"bitcoin-wallet\");\n+\n+    static bool fOneThread;\n+    if (fOneThread)\n+        return;\n+    fOneThread = true;\n+    if (!GetBoolArg(\"-flushwallet\", DEFAULT_FLUSHWALLET))\n+        return;\n+\n+    unsigned int nLastSeen = nWalletDBUpdated;\n+    unsigned int nLastFlushed = nWalletDBUpdated;\n+    int64_t nLastWalletUpdate = GetTime();\n+    while (true)\n+    {\n+        MilliSleep(500);\n+\n+        if (nLastSeen != nWalletDBUpdated)\n+        {\n+            nLastSeen = nWalletDBUpdated;\n+            nLastWalletUpdate = GetTime();\n+        }\n+\n+        if (nLastFlushed != nWalletDBUpdated && GetTime() - nLastWalletUpdate >= 2)\n+        {\n+            TRY_LOCK(bitdb.cs_db,lockDb);\n+            if (lockDb)\n+            {\n+                // Don't do this if any databases are in use\n+                int nRefCount = 0;\n+                map<string, int>::iterator mi = bitdb.mapFileUseCount.begin();\n+                while (mi != bitdb.mapFileUseCount.end())\n+                {\n+                    nRefCount += (*mi).second;\n+                    mi++;\n+                }\n+\n+                if (nRefCount == 0)\n+                {\n+                    boost::this_thread::interruption_point();\n+                    map<string, int>::iterator mi = bitdb.mapFileUseCount.find(strFile);\n+                    if (mi != bitdb.mapFileUseCount.end())\n+                    {\n+                        LogPrint(\"db\", \"Flushing %s\\n\", strFile);\n+                        nLastFlushed = nWalletDBUpdated;\n+                        int64_t nStart = GetTimeMillis();\n+\n+                        // Flush wallet file so it's self contained\n+                        bitdb.CloseDb(strFile);\n+                        bitdb.CheckpointLSN(strFile);\n+\n+                        bitdb.mapFileUseCount.erase(mi++);\n+                        LogPrint(\"db\", \"Flushed %s %dms\\n\", strFile, GetTimeMillis() - nStart);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+bool BackupWallet(const CWallet& wallet, const string& strDest)\n+{\n+    if (!wallet.fFileBacked)\n+        return false;\n+    while (true)\n+    {\n+        {\n+            LOCK(bitdb.cs_db);\n+            if (!bitdb.mapFileUseCount.count(wallet.strWalletFile) || bitdb.mapFileUseCount[wallet.strWalletFile] == 0)\n+            {\n+                // Flush log data to the dat file\n+                bitdb.CloseDb(wallet.strWalletFile);\n+                bitdb.CheckpointLSN(wallet.strWalletFile);\n+                bitdb.mapFileUseCount.erase(wallet.strWalletFile);\n+\n+                // Copy wallet file\n+                boost::filesystem::path pathSrc = GetDataDir() / wallet.strWalletFile;\n+                boost::filesystem::path pathDest(strDest);\n+                if (boost::filesystem::is_directory(pathDest))\n+                    pathDest /= wallet.strWalletFile;\n+\n+                try {\n+#if BOOST_VERSION >= 104000\n+                    boost::filesystem::copy_file(pathSrc, pathDest, boost::filesystem::copy_option::overwrite_if_exists);\n+#else\n+                    boost::filesystem::copy_file(pathSrc, pathDest);\n+#endif\n+                    LogPrintf(\"copied %s to %s\\n\", wallet.strWalletFile, pathDest.string());\n+                    return true;\n+                } catch (const boost::filesystem::filesystem_error& e) {\n+                    LogPrintf(\"error copying %s to %s - %s\\n\", wallet.strWalletFile, pathDest.string(), e.what());\n+                    return false;\n+                }\n+            }\n+        }\n+        MilliSleep(100);\n+    }\n+    return false;\n+}\n+\n+//\n+// Try to (very carefully!) recover wallet file if there is a problem.\n+//\n+bool CWalletDB::Recover(CDBEnv& dbenv, const std::string& filename, bool fOnlyKeys)\n+{\n+    // Recovery procedure:\n+    // move wallet file to wallet.timestamp.bak\n+    // Call Salvage with fAggressive=true to\n+    // get as much data as possible.\n+    // Rewrite salvaged data to fresh wallet file\n+    // Set -rescan so any missing transactions will be\n+    // found.\n+    int64_t now = GetTime();\n+    std::string newFilename = strprintf(\"wallet.%d.bak\", now);\n+\n+    int result = dbenv.dbenv->dbrename(NULL, filename.c_str(), NULL,\n+                                       newFilename.c_str(), DB_AUTO_COMMIT);\n+    if (result == 0)\n+        LogPrintf(\"Renamed %s to %s\\n\", filename, newFilename);\n+    else\n+    {\n+        LogPrintf(\"Failed to rename %s to %s\\n\", filename, newFilename);\n+        return false;\n+    }\n+\n+    std::vector<CDBEnv::KeyValPair> salvagedData;\n+    bool fSuccess = dbenv.Salvage(newFilename, true, salvagedData);\n+    if (salvagedData.empty())\n+    {\n+        LogPrintf(\"Salvage(aggressive) found no records in %s.\\n\", newFilename);\n+        return false;\n+    }\n+    LogPrintf(\"Salvage(aggressive) found %u records\\n\", salvagedData.size());\n+\n+    boost::scoped_ptr<Db> pdbCopy(new Db(dbenv.dbenv, 0));\n+    int ret = pdbCopy->open(NULL,               // Txn pointer\n+                            filename.c_str(),   // Filename\n+                            \"main\",             // Logical db name\n+                            DB_BTREE,           // Database type\n+                            DB_CREATE,          // Flags\n+                            0);\n+    if (ret > 0)\n+    {\n+        LogPrintf(\"Cannot create database file %s\\n\", filename);\n+        return false;\n+    }\n+    CWallet dummyWallet;\n+    CWalletScanState wss;\n+\n+    DbTxn* ptxn = dbenv.TxnBegin();\n+    BOOST_FOREACH(CDBEnv::KeyValPair& row, salvagedData)\n+    {\n+        if (fOnlyKeys)\n+        {\n+            CDataStream ssKey(row.first, SER_DISK, CLIENT_VERSION);\n+            CDataStream ssValue(row.second, SER_DISK, CLIENT_VERSION);\n+            string strType, strErr;\n+            bool fReadOK;\n+            {\n+                // Required in LoadKeyMetadata():\n+                LOCK(dummyWallet.cs_wallet);\n+                fReadOK = ReadKeyValue(&dummyWallet, ssKey, ssValue,\n+                                        wss, strType, strErr);\n+            }\n+            if (!IsKeyType(strType))\n+                continue;\n+            if (!fReadOK)\n+            {\n+                LogPrintf(\"WARNING: CWalletDB::Recover skipping %s: %s\\n\", strType, strErr);\n+                continue;\n+            }\n+        }\n+        Dbt datKey(&row.first[0], row.first.size());\n+        Dbt datValue(&row.second[0], row.second.size());\n+        int ret2 = pdbCopy->put(ptxn, &datKey, &datValue, DB_NOOVERWRITE);\n+        if (ret2 > 0)\n+            fSuccess = false;\n+    }\n+    ptxn->commit(0);\n+    pdbCopy->close(0);\n+\n+    return fSuccess;\n+}\n+\n+bool CWalletDB::Recover(CDBEnv& dbenv, const std::string& filename)\n+{\n+    return CWalletDB::Recover(dbenv, filename, false);\n+}\n+\n+bool CWalletDB::WriteDestData(const std::string &address, const std::string &key, const std::string &value)\n+{\n+    nWalletDBUpdated++;\n+    return Write(std::make_pair(std::string(\"destdata\"), std::make_pair(address, key)), value);\n+}\n+\n+bool CWalletDB::EraseDestData(const std::string &address, const std::string &key)\n+{\n+    nWalletDBUpdated++;\n+    return Erase(std::make_pair(std::string(\"destdata\"), std::make_pair(address, key)));\n+}"
      },
      {
        "sha": "fe6c366343599368c7892313ca63523111fba98c",
        "filename": "src/lightwallet/walletdb.h",
        "status": "added",
        "additions": 147,
        "deletions": 0,
        "changes": 147,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e1c9383edc81c67e6c7b8794a649d06d538747b9/src/lightwallet/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e1c9383edc81c67e6c7b8794a649d06d538747b9/src/lightwallet/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/walletdb.h?ref=e1c9383edc81c67e6c7b8794a649d06d538747b9",
        "patch": "@@ -0,0 +1,147 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_WALLET_WALLETDB_H\n+#define BITCOIN_WALLET_WALLETDB_H\n+\n+#include \"amount.h\"\n+#include \"wallet/db.h\"\n+#include \"key.h\"\n+\n+#include <list>\n+#include <stdint.h>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+static const bool DEFAULT_FLUSHWALLET = true;\n+\n+class CAccount;\n+class CAccountingEntry;\n+struct CBlockLocator;\n+class CKeyPool;\n+class CMasterKey;\n+class CScript;\n+class CWallet;\n+class CWalletTx;\n+class uint160;\n+class uint256;\n+\n+/** Error statuses for the wallet database */\n+enum DBErrors\n+{\n+    DB_LOAD_OK,\n+    DB_CORRUPT,\n+    DB_NONCRITICAL_ERROR,\n+    DB_TOO_NEW,\n+    DB_LOAD_FAIL,\n+    DB_NEED_REWRITE\n+};\n+\n+class CKeyMetadata\n+{\n+public:\n+    static const int CURRENT_VERSION=1;\n+    int nVersion;\n+    int64_t nCreateTime; // 0 means unknown\n+\n+    CKeyMetadata()\n+    {\n+        SetNull();\n+    }\n+    CKeyMetadata(int64_t nCreateTime_)\n+    {\n+        nVersion = CKeyMetadata::CURRENT_VERSION;\n+        nCreateTime = nCreateTime_;\n+    }\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(this->nVersion);\n+        nVersion = this->nVersion;\n+        READWRITE(nCreateTime);\n+    }\n+\n+    void SetNull()\n+    {\n+        nVersion = CKeyMetadata::CURRENT_VERSION;\n+        nCreateTime = 0;\n+    }\n+};\n+\n+/** Access to the wallet database */\n+class CWalletDB : public CDB\n+{\n+public:\n+    CWalletDB(const std::string& strFilename, const char* pszMode = \"r+\", bool fFlushOnClose = true) : CDB(strFilename, pszMode, fFlushOnClose)\n+    {\n+    }\n+\n+    bool WriteName(const std::string& strAddress, const std::string& strName);\n+    bool EraseName(const std::string& strAddress);\n+\n+    bool WritePurpose(const std::string& strAddress, const std::string& purpose);\n+    bool ErasePurpose(const std::string& strAddress);\n+\n+    bool WriteTx(uint256 hash, const CWalletTx& wtx);\n+    bool EraseTx(uint256 hash);\n+\n+    bool WriteKey(const CPubKey& vchPubKey, const CPrivKey& vchPrivKey, const CKeyMetadata &keyMeta);\n+    bool WriteCryptedKey(const CPubKey& vchPubKey, const std::vector<unsigned char>& vchCryptedSecret, const CKeyMetadata &keyMeta);\n+    bool WriteMasterKey(unsigned int nID, const CMasterKey& kMasterKey);\n+\n+    bool WriteCScript(const uint160& hash, const CScript& redeemScript);\n+\n+    bool WriteWatchOnly(const CScript &script);\n+    bool EraseWatchOnly(const CScript &script);\n+\n+    bool WriteBestBlock(const CBlockLocator& locator);\n+    bool ReadBestBlock(CBlockLocator& locator);\n+\n+    bool WriteOrderPosNext(int64_t nOrderPosNext);\n+\n+    bool WriteDefaultKey(const CPubKey& vchPubKey);\n+\n+    bool ReadPool(int64_t nPool, CKeyPool& keypool);\n+    bool WritePool(int64_t nPool, const CKeyPool& keypool);\n+    bool ErasePool(int64_t nPool);\n+\n+    bool WriteMinVersion(int nVersion);\n+\n+    /// This writes directly to the database, and will not update the CWallet's cached accounting entries!\n+    /// Use wallet.AddAccountingEntry instead, to write *and* update its caches.\n+    bool WriteAccountingEntry_Backend(const CAccountingEntry& acentry);\n+    bool ReadAccount(const std::string& strAccount, CAccount& account);\n+    bool WriteAccount(const std::string& strAccount, const CAccount& account);\n+\n+    /// Write destination data key,value tuple to database\n+    bool WriteDestData(const std::string &address, const std::string &key, const std::string &value);\n+    /// Erase destination data tuple from wallet database\n+    bool EraseDestData(const std::string &address, const std::string &key);\n+\n+    CAmount GetAccountCreditDebit(const std::string& strAccount);\n+    void ListAccountCreditDebit(const std::string& strAccount, std::list<CAccountingEntry>& acentries);\n+\n+    DBErrors ReorderTransactions(CWallet* pwallet);\n+    DBErrors LoadWallet(CWallet* pwallet);\n+    DBErrors FindWalletTx(CWallet* pwallet, std::vector<uint256>& vTxHash, std::vector<CWalletTx>& vWtx);\n+    DBErrors ZapWalletTx(CWallet* pwallet, std::vector<CWalletTx>& vWtx);\n+    DBErrors ZapSelectTx(CWallet* pwallet, std::vector<uint256>& vHashIn, std::vector<uint256>& vHashOut);\n+    static bool Recover(CDBEnv& dbenv, const std::string& filename, bool fOnlyKeys);\n+    static bool Recover(CDBEnv& dbenv, const std::string& filename);\n+\n+private:\n+    CWalletDB(const CWalletDB&);\n+    void operator=(const CWalletDB&);\n+\n+    bool WriteAccountingEntry(const uint64_t nAccEntryNum, const CAccountingEntry& acentry);\n+};\n+\n+bool BackupWallet(const CWallet& wallet, const std::string& strDest);\n+void ThreadFlushWalletDB(const std::string& strFile);\n+\n+#endif // BITCOIN_WALLET_WALLETDB_H"
      }
    ]
  },
  {
    "sha": "b2ad6a8a932719ddefb640df8b16e060fcffbffe",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMmFkNmE4YTkzMjcxOWRkZWZiNjQwZGY4YjE2ZTA2MGZjZmZiZmZl",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2016-04-06T19:11:13Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2016-04-06T19:14:42Z"
      },
      "message": "[LightWallet] add namespace protection",
      "tree": {
        "sha": "71d39e02d53295e99b4641c345e56b456ec2cd02",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/71d39e02d53295e99b4641c345e56b456ec2cd02"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b2ad6a8a932719ddefb640df8b16e060fcffbffe",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "expired_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXBWAjAAoJECnUvLZBb1Ps65MQAJLr8/0ocOfYwwHn2cz/+lWB\nB4B7F0VFt9gnqTvraDvQMv5ZgjGlzIIWnEMS5o1yW6WcSRT1aOx7hXBAKzBJNJta\nI90I95k4CpEZsiS3M92+BggivixrNRk3T6EnM3TK9wZAle1VDsNKKbhbLzIfyap6\nTRUjGf5u4cPh+WSRZdJn6GVEGSxuP6K/ZwW429JTv5WG45RfMNJq6pEiRcj4fVwY\natMqE2sQ9A7BA/WfSDLt6NTXflTAq2klQpHBD8IzkwBxvs+mNP5qs0tcD319PLvT\nim/tH8Q23g/m6kdpUoma06hVBo0IJAd+az2lh4Ke2oEsV2f55J3LQLpiFs3AIDPx\n/pNJtNwf9RkmSmtUZGXLj3Uh4TAy0USGUQWjSpzykTFE18Ft6TQt9rFVtYni5axA\nJp6aKA/L0CY9+sP0keCE9AIeF1Q6ZQDbvcK4oEkli3GrpiNw0hLPFz42QDgnd8er\nHit4Z60kUOkKxrkqRfNjXWbq3H50CT13I2hMi2dKnQJULoGSz12NW8XtKMMO7qt3\npZU5y+KP85NIMPSjemrQkrl4q8FiKeQQ+73XhvV4GmGyh+Mt4m09JYSlRwqB2PTb\nVPw+U97Fprp9hecq181tG4vbIGFjMielKUFRxvfvN5jYwRx55IDgerT3M67FGVZN\noFUwfEpz+PfO3aYgHRWE\n=Rcw4\n-----END PGP SIGNATURE-----",
        "payload": "tree 71d39e02d53295e99b4641c345e56b456ec2cd02\nparent e1c9383edc81c67e6c7b8794a649d06d538747b9\nauthor Jonas Schnelli <dev@jonasschnelli.ch> 1459969873 +0200\ncommitter Jonas Schnelli <dev@jonasschnelli.ch> 1459970082 +0200\n\n[LightWallet] add namespace protection\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b2ad6a8a932719ddefb640df8b16e060fcffbffe",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b2ad6a8a932719ddefb640df8b16e060fcffbffe",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b2ad6a8a932719ddefb640df8b16e060fcffbffe/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e1c9383edc81c67e6c7b8794a649d06d538747b9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e1c9383edc81c67e6c7b8794a649d06d538747b9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e1c9383edc81c67e6c7b8794a649d06d538747b9"
      }
    ],
    "stats": {
      "total": 519,
      "additions": 461,
      "deletions": 58
    },
    "files": [
      {
        "sha": "6d04a42b9380be3ead580c5fd1bf809eedd4d7c8",
        "filename": "src/lightwallet/crypter.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2ad6a8a932719ddefb640df8b16e060fcffbffe/src/lightwallet/crypter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2ad6a8a932719ddefb640df8b16e060fcffbffe/src/lightwallet/crypter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/crypter.cpp?ref=b2ad6a8a932719ddefb640df8b16e060fcffbffe",
        "patch": "@@ -14,6 +14,8 @@\n #include <openssl/aes.h>\n #include <openssl/evp.h>\n \n+namespace Lightwallet {\n+\n bool CCrypter::SetKeyFromPassphrase(const SecureString& strKeyData, const std::vector<unsigned char>& chSalt, const unsigned int nRounds, const unsigned int nDerivationMethod)\n {\n     if (nRounds < 1 || chSalt.size() != WALLET_CRYPTO_SALT_SIZE)\n@@ -292,3 +294,5 @@ bool CCryptoKeyStore::EncryptKeys(CKeyingMaterial& vMasterKeyIn)\n     }\n     return true;\n }\n+\n+} //end Lightwallet namespace\n\\ No newline at end of file"
      },
      {
        "sha": "e3be9e7fc138e5ad12ecdaa5352a76b6ae2ba1a4",
        "filename": "src/lightwallet/crypter.h",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2ad6a8a932719ddefb640df8b16e060fcffbffe/src/lightwallet/crypter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2ad6a8a932719ddefb640df8b16e060fcffbffe/src/lightwallet/crypter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/crypter.h?ref=b2ad6a8a932719ddefb640df8b16e060fcffbffe",
        "patch": "@@ -2,15 +2,17 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#ifndef BITCOIN_WALLET_CRYPTER_H\n-#define BITCOIN_WALLET_CRYPTER_H\n+#ifndef BITCOIN_LIGHTWALLET_CRYPTER_H\n+#define BITCOIN_LIGHTWALLET_CRYPTER_H\n \n #include \"keystore.h\"\n #include \"serialize.h\"\n #include \"support/allocators/secure.h\"\n \n class uint256;\n \n+namespace Lightwallet {\n+\n const unsigned int WALLET_CRYPTO_KEY_SIZE = 32;\n const unsigned int WALLET_CRYPTO_SALT_SIZE = 8;\n \n@@ -192,5 +194,5 @@ class CCryptoKeyStore : public CBasicKeyStore\n      */\n     boost::signals2::signal<void (CCryptoKeyStore* wallet)> NotifyStatusChanged;\n };\n-\n-#endif // BITCOIN_WALLET_CRYPTER_H\n+} // end Lightwallet namespace\n+#endif // BITCOIN_LIGHTWALLET_CRYPTER_H"
      },
      {
        "sha": "6df95b350f56965ff4263ecfce08027d2d9d8931",
        "filename": "src/lightwallet/db.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2ad6a8a932719ddefb640df8b16e060fcffbffe/src/lightwallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2ad6a8a932719ddefb640df8b16e060fcffbffe/src/lightwallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/db.cpp?ref=b2ad6a8a932719ddefb640df8b16e060fcffbffe",
        "patch": "@@ -24,6 +24,8 @@\n using namespace std;\n \n \n+namespace Lightwallet {\n+\n unsigned int nWalletDBUpdated;\n \n \n@@ -476,3 +478,4 @@ void CDBEnv::Flush(bool fShutdown)\n         }\n     }\n }\n+}\n\\ No newline at end of file"
      },
      {
        "sha": "403c7f3bd8ab232b3ef6623d522c0ea5c6c5ed9c",
        "filename": "src/lightwallet/db.h",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2ad6a8a932719ddefb640df8b16e060fcffbffe/src/lightwallet/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2ad6a8a932719ddefb640df8b16e060fcffbffe/src/lightwallet/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/db.h?ref=b2ad6a8a932719ddefb640df8b16e060fcffbffe",
        "patch": "@@ -3,8 +3,8 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#ifndef BITCOIN_WALLET_DB_H\n-#define BITCOIN_WALLET_DB_H\n+#ifndef BITCOIN_LIGHTWALLET_DB_H\n+#define BITCOIN_LIGHTWALLET_DB_H\n \n #include \"clientversion.h\"\n #include \"serialize.h\"\n@@ -20,6 +20,8 @@\n \n #include <db_cxx.h>\n \n+namespace Lightwallet {\n+\n static const unsigned int DEFAULT_WALLET_DBLOGSIZE = 100;\n static const bool DEFAULT_WALLET_PRIVDB = true;\n \n@@ -308,5 +310,6 @@ class CDB\n \n     bool static Rewrite(const std::string& strFile, const char* pszSkip = NULL);\n };\n+}\n \n-#endif // BITCOIN_WALLET_DB_H\n+#endif // BITCOIN_LIGHTWALLET_DB_H"
      },
      {
        "sha": "ba78fea59ba8e7d5aec433fff306cc7fc02f129f",
        "filename": "src/lightwallet/rpcdump.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2ad6a8a932719ddefb640df8b16e060fcffbffe/src/lightwallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2ad6a8a932719ddefb640df8b16e060fcffbffe/src/lightwallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/rpcdump.cpp?ref=b2ad6a8a932719ddefb640df8b16e060fcffbffe",
        "patch": "@@ -12,7 +12,7 @@\n #include \"sync.h\"\n #include \"util.h\"\n #include \"utiltime.h\"\n-#include \"wallet.h\"\n+#include \"lightwallet/wallet.h\"\n #include \"merkleblock.h\"\n #include \"core_io.h\"\n \n@@ -26,6 +26,8 @@\n \n #include <boost/foreach.hpp>\n \n+namespace Lightwallet {\n+\n using namespace std;\n \n void EnsureWalletIsUnlocked();\n@@ -155,7 +157,7 @@ UniValue importprivkey(const UniValue& params, bool fHelp)\n void ImportAddress(const CBitcoinAddress& address, const string& strLabel);\n void ImportScript(const CScript& script, const string& strLabel, bool isRedeemScript)\n {\n-    if (!isRedeemScript && ::IsMine(*pwalletMain, script) == ISMINE_SPENDABLE)\n+    if (!isRedeemScript && Lightwallet::IsMine(*pwalletMain, script) == ISMINE_SPENDABLE)\n         throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n \n     pwalletMain->MarkDirty();\n@@ -615,3 +617,4 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)\n     file.close();\n     return NullUniValue;\n }\n+}\n\\ No newline at end of file"
      },
      {
        "sha": "79678e5696ca3bb7f88d9a6fa0a6c86862a8acba",
        "filename": "src/lightwallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 5,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2ad6a8a932719ddefb640df8b16e060fcffbffe/src/lightwallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2ad6a8a932719ddefb640df8b16e060fcffbffe/src/lightwallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/rpcwallet.cpp?ref=b2ad6a8a932719ddefb640df8b16e060fcffbffe",
        "patch": "@@ -16,15 +16,17 @@\n #include \"timedata.h\"\n #include \"util.h\"\n #include \"utilmoneystr.h\"\n-#include \"wallet.h\"\n-#include \"walletdb.h\"\n+#include \"lightwallet/wallet.h\"\n+#include \"lightwallet/walletdb.h\"\n \n #include <stdint.h>\n \n #include <boost/assign/list_of.hpp>\n \n #include <univalue.h>\n \n+namespace Lightwallet {\n+\n using namespace std;\n \n int64_t nWalletUnlockTime;\n@@ -1334,7 +1336,7 @@ void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDe\n         BOOST_FOREACH(const COutputEntry& s, listSent)\n         {\n             UniValue entry(UniValue::VOBJ);\n-            if(involvesWatchonly || (::IsMine(*pwalletMain, s.destination) & ISMINE_WATCH_ONLY))\n+            if(involvesWatchonly || (Lightwallet::IsMine(*pwalletMain, s.destination) & ISMINE_WATCH_ONLY))\n                 entry.push_back(Pair(\"involvesWatchonly\", true));\n             entry.push_back(Pair(\"account\", strSentAccount));\n             MaybePushAddress(entry, s.destination);\n@@ -1362,7 +1364,7 @@ void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDe\n             if (fAllAccounts || (account == strAccount))\n             {\n                 UniValue entry(UniValue::VOBJ);\n-                if(involvesWatchonly || (::IsMine(*pwalletMain, r.destination) & ISMINE_WATCH_ONLY))\n+                if(involvesWatchonly || (Lightwallet::IsMine(*pwalletMain, r.destination) & ISMINE_WATCH_ONLY))\n                     entry.push_back(Pair(\"involvesWatchonly\", true));\n                 entry.push_back(Pair(\"account\", account));\n                 MaybePushAddress(entry, r.destination);\n@@ -2562,5 +2564,6 @@ static const CRPCCommand commands[] =\n void RegisterWalletRPCCommands(CRPCTable &tableRPC)\n {\n     for (unsigned int vcidx = 0; vcidx < ARRAYLEN(commands); vcidx++)\n-        tableRPC.appendCommand(commands[vcidx].name, &commands[vcidx]);\n+        ::tableRPC.appendCommand(commands[vcidx].name, &commands[vcidx]);\n }\n+}\n\\ No newline at end of file"
      },
      {
        "sha": "2c5bc1bb9398278a3b8894933f168d36fe5ac856",
        "filename": "src/lightwallet/rpcwallet.h",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2ad6a8a932719ddefb640df8b16e060fcffbffe/src/lightwallet/rpcwallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2ad6a8a932719ddefb640df8b16e060fcffbffe/src/lightwallet/rpcwallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/rpcwallet.h?ref=b2ad6a8a932719ddefb640df8b16e060fcffbffe",
        "patch": "@@ -2,11 +2,12 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#ifndef BITCOIN_WALLET_RPCWALLET_H\n-#define BITCOIN_WALLET_RPCWALLET_H\n+#ifndef BITCOIN_LIGHTWALLET_RPCWALLET_H\n+#define BITCOIN_LIGHTWALLET_RPCWALLET_H\n \n+namespace Lightwallet {\n class CRPCTable;\n \n void RegisterWalletRPCCommands(CRPCTable &tableRPC);\n-\n-#endif //BITCOIN_WALLET_RPCWALLET_H\n+}\n+#endif //BITCOIN_LIGHTWALLET_RPCWALLET_H"
      },
      {
        "sha": "6aaac27e8f4de72b409afe632b2151e550730999",
        "filename": "src/lightwallet/test/lightwallet_tests.cpp",
        "status": "added",
        "additions": 367,
        "deletions": 0,
        "changes": 367,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2ad6a8a932719ddefb640df8b16e060fcffbffe/src/lightwallet/test/lightwallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2ad6a8a932719ddefb640df8b16e060fcffbffe/src/lightwallet/test/lightwallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/test/lightwallet_tests.cpp?ref=b2ad6a8a932719ddefb640df8b16e060fcffbffe",
        "patch": "@@ -0,0 +1,367 @@\n+// Copyright (c) 2012-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"wallet/wallet.h\"\n+\n+#include <set>\n+#include <stdint.h>\n+#include <utility>\n+#include <vector>\n+\n+#include \"test/test_bitcoin.h\"\n+\n+#include <boost/foreach.hpp>\n+#include <boost/test/unit_test.hpp>\n+\n+// how many times to run all the tests to have a chance to catch errors that only show up with particular random shuffles\n+#define RUN_TESTS 100\n+\n+// some tests fail 1% of the time due to bad luck.\n+// we repeat those tests this many times and only complain if all iterations of the test fail\n+#define RANDOM_REPEATS 5\n+\n+namespace Lightwallet {\n+\n+using namespace std;\n+\n+typedef set<pair<const CWalletTx*,unsigned int> > CoinSet;\n+\n+BOOST_FIXTURE_TEST_SUITE(lightwallet_tests, TestingSetup)\n+\n+static CWallet wallet;\n+static vector<COutput> vCoins;\n+\n+static void add_coin(const CAmount& nValue, int nAge = 6*24, bool fIsFromMe = false, int nInput=0)\n+{\n+    static int nextLockTime = 0;\n+    CMutableTransaction tx;\n+    tx.nLockTime = nextLockTime++;        // so all transactions get different hashes\n+    tx.vout.resize(nInput+1);\n+    tx.vout[nInput].nValue = nValue;\n+    if (fIsFromMe) {\n+        // IsFromMe() returns (GetDebit() > 0), and GetDebit() is 0 if vin.empty(),\n+        // so stop vin being empty, and cache a non-zero Debit to fake out IsFromMe()\n+        tx.vin.resize(1);\n+    }\n+    CWalletTx* wtx = new CWalletTx(&wallet, tx);\n+    if (fIsFromMe)\n+    {\n+        wtx->fDebitCached = true;\n+        wtx->nDebitCached = 1;\n+    }\n+    COutput output(wtx, nInput, nAge, true);\n+    vCoins.push_back(output);\n+}\n+\n+static void empty_wallet(void)\n+{\n+    BOOST_FOREACH(COutput output, vCoins)\n+        delete output.tx;\n+    vCoins.clear();\n+}\n+\n+static bool equal_sets(CoinSet a, CoinSet b)\n+{\n+    pair<CoinSet::iterator, CoinSet::iterator> ret = mismatch(a.begin(), a.end(), b.begin());\n+    return ret.first == a.end() && ret.second == b.end();\n+}\n+\n+BOOST_AUTO_TEST_CASE(coin_selection_tests)\n+{\n+    CoinSet setCoinsRet, setCoinsRet2;\n+    CAmount nValueRet;\n+\n+    LOCK(wallet.cs_wallet);\n+\n+    // test multiple times to allow for differences in the shuffle order\n+    for (int i = 0; i < RUN_TESTS; i++)\n+    {\n+        empty_wallet();\n+\n+        // with an empty wallet we can't even pay one cent\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf( 1 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+\n+        add_coin(1*CENT, 4);        // add a new 1 cent coin\n+\n+        // with a new 1 cent coin, we still can't find a mature 1 cent\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf( 1 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+\n+        // but we can find a new 1 cent\n+        BOOST_CHECK( wallet.SelectCoinsMinConf( 1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);\n+\n+        add_coin(2*CENT);           // add a mature 2 cent coin\n+\n+        // we can't make 3 cents of mature coins\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf( 3 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+\n+        // we can make 3 cents of new  coins\n+        BOOST_CHECK( wallet.SelectCoinsMinConf( 3 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 3 * CENT);\n+\n+        add_coin(5*CENT);           // add a mature 5 cent coin,\n+        add_coin(10*CENT, 3, true); // a new 10 cent coin sent from one of our own addresses\n+        add_coin(20*CENT);          // and a mature 20 cent coin\n+\n+        // now we have new: 1+10=11 (of which 10 was self-sent), and mature: 2+5+20=27.  total = 38\n+\n+        // we can't make 38 cents only if we disallow new coins:\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf(38 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+        // we can't even make 37 cents if we don't allow new coins even if they're from us\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf(38 * CENT, 6, 6, vCoins, setCoinsRet, nValueRet));\n+        // but we can make 37 cents if we accept new coins from ourself\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(37 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 37 * CENT);\n+        // and we can make 38 cents if we accept all new coins\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(38 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 38 * CENT);\n+\n+        // try making 34 cents from 1,2,5,10,20 - we can't do it exactly\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(34 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 35 * CENT);       // but 35 cents is closest\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);     // the best should be 20+10+5.  it's incredibly unlikely the 1 or 2 got included (but possible)\n+\n+        // when we try making 7 cents, the smaller coins (1,2,5) are enough.  We should see just 2+5\n+        BOOST_CHECK( wallet.SelectCoinsMinConf( 7 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 7 * CENT);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n+\n+        // when we try making 8 cents, the smaller coins (1,2,5) are exactly enough.\n+        BOOST_CHECK( wallet.SelectCoinsMinConf( 8 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(nValueRet == 8 * CENT);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n+\n+        // when we try making 9 cents, no subset of smaller coins is enough, and we get the next bigger coin (10)\n+        BOOST_CHECK( wallet.SelectCoinsMinConf( 9 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 10 * CENT);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n+\n+        // now clear out the wallet and start again to test choosing between subsets of smaller coins and the next biggest coin\n+        empty_wallet();\n+\n+        add_coin( 6*CENT);\n+        add_coin( 7*CENT);\n+        add_coin( 8*CENT);\n+        add_coin(20*CENT);\n+        add_coin(30*CENT); // now we have 6+7+8+20+30 = 71 cents total\n+\n+        // check that we have 71 and not 72\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(71 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf(72 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+\n+        // now try making 16 cents.  the best smaller coins can do is 6+7+8 = 21; not as good at the next biggest coin, 20\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(16 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 20 * CENT); // we should get 20 in one coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n+\n+        add_coin( 5*CENT); // now we have 5+6+7+8+20+30 = 75 cents total\n+\n+        // now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, better than the next biggest coin, 20\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(16 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 18 * CENT); // we should get 18 in 3 coins\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n+\n+        add_coin( 18*CENT); // now we have 5+6+7+8+18+20+30\n+\n+        // and now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, the same as the next biggest coin, 18\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(16 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 18 * CENT);  // we should get 18 in 1 coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U); // because in the event of a tie, the biggest coin wins\n+\n+        // now try making 11 cents.  we should get 5+6\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(11 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 11 * CENT);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n+\n+        // check that the smallest bigger coin is used\n+        add_coin( 1*COIN);\n+        add_coin( 2*COIN);\n+        add_coin( 3*COIN);\n+        add_coin( 4*COIN); // now we have 5+6+7+8+18+20+30+100+200+300+400 = 1094 cents\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(95 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * COIN);  // we should get 1 BTC in 1 coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n+\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(195 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 2 * COIN);  // we should get 2 BTC in 1 coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n+\n+        // empty the wallet and start again, now with fractions of a cent, to test small change avoidance\n+\n+        empty_wallet();\n+        add_coin(0.1*MIN_CHANGE);\n+        add_coin(0.2*MIN_CHANGE);\n+        add_coin(0.3*MIN_CHANGE);\n+        add_coin(0.4*MIN_CHANGE);\n+        add_coin(0.5*MIN_CHANGE);\n+\n+        // try making 1 * MIN_CHANGE from the 1.5 * MIN_CHANGE\n+        // we'll get change smaller than MIN_CHANGE whatever happens, so can expect MIN_CHANGE exactly\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(MIN_CHANGE, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE);\n+\n+        // but if we add a bigger coin, small change is avoided\n+        add_coin(1111*MIN_CHANGE);\n+\n+        // try making 1 from 0.1 + 0.2 + 0.3 + 0.4 + 0.5 + 1111 = 1112.5\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(1 * MIN_CHANGE, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * MIN_CHANGE); // we should get the exact amount\n+\n+        // if we add more small coins:\n+        add_coin(0.6*MIN_CHANGE);\n+        add_coin(0.7*MIN_CHANGE);\n+\n+        // and try again to make 1.0 * MIN_CHANGE\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(1 * MIN_CHANGE, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * MIN_CHANGE); // we should get the exact amount\n+\n+        // run the 'mtgox' test (see http://blockexplorer.com/tx/29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf)\n+        // they tried to consolidate 10 50k coins into one 500k coin, and ended up with 50k in change\n+        empty_wallet();\n+        for (int i = 0; i < 20; i++)\n+            add_coin(50000 * COIN);\n+\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(500000 * COIN, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 500000 * COIN); // we should get the exact amount\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 10U); // in ten coins\n+\n+        // if there's not enough in the smaller coins to make at least 1 * MIN_CHANGE change (0.5+0.6+0.7 < 1.0+1.0),\n+        // we need to try finding an exact subset anyway\n+\n+        // sometimes it will fail, and so we use the next biggest coin:\n+        empty_wallet();\n+        add_coin(0.5 * MIN_CHANGE);\n+        add_coin(0.6 * MIN_CHANGE);\n+        add_coin(0.7 * MIN_CHANGE);\n+        add_coin(1111 * MIN_CHANGE);\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(1 * MIN_CHANGE, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1111 * MIN_CHANGE); // we get the bigger coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n+\n+        // but sometimes it's possible, and we use an exact subset (0.4 + 0.6 = 1.0)\n+        empty_wallet();\n+        add_coin(0.4 * MIN_CHANGE);\n+        add_coin(0.6 * MIN_CHANGE);\n+        add_coin(0.8 * MIN_CHANGE);\n+        add_coin(1111 * MIN_CHANGE);\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(MIN_CHANGE, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE);   // we should get the exact amount\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U); // in two coins 0.4+0.6\n+\n+        // test avoiding small change\n+        empty_wallet();\n+        add_coin(0.05 * MIN_CHANGE);\n+        add_coin(1    * MIN_CHANGE);\n+        add_coin(100  * MIN_CHANGE);\n+\n+        // trying to make 100.01 from these three coins\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(100.01 * MIN_CHANGE, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 101.05 * MIN_CHANGE);   // we should get all coins\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n+\n+        // but if we try to make 99.9, we should take the bigger of the two small coins to avoid small change\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(99.9 * MIN_CHANGE, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 101 * MIN_CHANGE);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n+\n+        // test with many inputs\n+        for (CAmount amt=1500; amt < COIN; amt*=10) {\n+             empty_wallet();\n+             // Create 676 inputs (= MAX_STANDARD_TX_SIZE / 148 bytes per input)\n+             for (uint16_t j = 0; j < 676; j++)\n+                 add_coin(amt);\n+             BOOST_CHECK(wallet.SelectCoinsMinConf(2000, 1, 1, vCoins, setCoinsRet, nValueRet));\n+             if (amt - 2000 < MIN_CHANGE) {\n+                 // needs more than one input:\n+                 uint16_t returnSize = std::ceil((2000.0 + MIN_CHANGE)/amt);\n+                 CAmount returnValue = amt * returnSize;\n+                 BOOST_CHECK_EQUAL(nValueRet, returnValue);\n+                 BOOST_CHECK_EQUAL(setCoinsRet.size(), returnSize);\n+             } else {\n+                 // one input is sufficient:\n+                 BOOST_CHECK_EQUAL(nValueRet, amt);\n+                 BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n+             }\n+        }\n+\n+        // test randomness\n+        {\n+            empty_wallet();\n+            for (int i2 = 0; i2 < 100; i2++)\n+                add_coin(COIN);\n+\n+            // picking 50 from 100 coins doesn't depend on the shuffle,\n+            // but does depend on randomness in the stochastic approximation code\n+            BOOST_CHECK(wallet.SelectCoinsMinConf(50 * COIN, 1, 6, vCoins, setCoinsRet , nValueRet));\n+            BOOST_CHECK(wallet.SelectCoinsMinConf(50 * COIN, 1, 6, vCoins, setCoinsRet2, nValueRet));\n+            BOOST_CHECK(!equal_sets(setCoinsRet, setCoinsRet2));\n+\n+            int fails = 0;\n+            for (int i = 0; i < RANDOM_REPEATS; i++)\n+            {\n+                // selecting 1 from 100 identical coins depends on the shuffle; this test will fail 1% of the time\n+                // run the test RANDOM_REPEATS times and only complain if all of them fail\n+                BOOST_CHECK(wallet.SelectCoinsMinConf(COIN, 1, 6, vCoins, setCoinsRet , nValueRet));\n+                BOOST_CHECK(wallet.SelectCoinsMinConf(COIN, 1, 6, vCoins, setCoinsRet2, nValueRet));\n+                if (equal_sets(setCoinsRet, setCoinsRet2))\n+                    fails++;\n+            }\n+            BOOST_CHECK_NE(fails, RANDOM_REPEATS);\n+\n+            // add 75 cents in small change.  not enough to make 90 cents,\n+            // then try making 90 cents.  there are multiple competing \"smallest bigger\" coins,\n+            // one of which should be picked at random\n+            add_coin( 5*CENT); add_coin(10*CENT); add_coin(15*CENT); add_coin(20*CENT); add_coin(25*CENT);\n+\n+            fails = 0;\n+            for (int i = 0; i < RANDOM_REPEATS; i++)\n+            {\n+                // selecting 1 from 100 identical coins depends on the shuffle; this test will fail 1% of the time\n+                // run the test RANDOM_REPEATS times and only complain if all of them fail\n+                BOOST_CHECK(wallet.SelectCoinsMinConf(90*CENT, 1, 6, vCoins, setCoinsRet , nValueRet));\n+                BOOST_CHECK(wallet.SelectCoinsMinConf(90*CENT, 1, 6, vCoins, setCoinsRet2, nValueRet));\n+                if (equal_sets(setCoinsRet, setCoinsRet2))\n+                    fails++;\n+            }\n+            BOOST_CHECK_NE(fails, RANDOM_REPEATS);\n+        }\n+    }\n+    empty_wallet();\n+}\n+\n+BOOST_AUTO_TEST_CASE(ApproximateBestSubset)\n+{\n+    CoinSet setCoinsRet;\n+    CAmount nValueRet;\n+\n+    LOCK(wallet.cs_wallet);\n+\n+    empty_wallet();\n+\n+    // Test vValue sort order\n+    for (int i = 0; i < 1000; i++)\n+        add_coin(1000 * COIN);\n+    add_coin(3 * COIN);\n+\n+    BOOST_CHECK(wallet.SelectCoinsMinConf(1003 * COIN, 1, 6, vCoins, setCoinsRet, nValueRet));\n+    BOOST_CHECK_EQUAL(nValueRet, 1003 * COIN);\n+    BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n+\n+    empty_wallet();\n+\n+    // Test trimming\n+    for (int i = 0; i < 100; i++)\n+        add_coin(10 * COIN);\n+    for (int i = 0; i < 100; i++)\n+        add_coin(1000 * COIN);\n+\n+    BOOST_CHECK(wallet.SelectCoinsMinConf(100001 * COIN, 1, 6, vCoins, setCoinsRet, nValueRet));\n+    // We need all 100 larger coins and exactly one small coin.\n+    // Superfluous small coins must be trimmed from the set:\n+    BOOST_CHECK_EQUAL(nValueRet, 100010 * COIN);\n+    BOOST_CHECK_EQUAL(setCoinsRet.size(), 101);\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()\n+}\n\\ No newline at end of file"
      },
      {
        "sha": "9a55f72141d89394a1adb78e85b681845201735b",
        "filename": "src/lightwallet/wallet.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2ad6a8a932719ddefb640df8b16e060fcffbffe/src/lightwallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2ad6a8a932719ddefb640df8b16e060fcffbffe/src/lightwallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/wallet.cpp?ref=b2ad6a8a932719ddefb640df8b16e060fcffbffe",
        "patch": "@@ -3,7 +3,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include \"wallet/wallet.h\"\n+#include \"lightwallet/wallet.h\"\n \n #include \"base58.h\"\n #include \"checkpoints.h\"\n@@ -31,6 +31,7 @@\n #include <boost/filesystem.hpp>\n #include <boost/thread.hpp>\n \n+namespace Lightwallet {\n using namespace std;\n \n CWallet* pwalletMain = NULL;\n@@ -977,7 +978,7 @@ CAmount CWallet::GetDebit(const CTxIn &txin, const isminefilter& filter) const\n \n isminetype CWallet::IsMine(const CTxOut& txout) const\n {\n-    return ::IsMine(*this, txout.scriptPubKey);\n+    return Lightwallet::IsMine(*this, txout.scriptPubKey);\n }\n \n CAmount CWallet::GetCredit(const CTxOut& txout, const isminefilter& filter) const\n@@ -996,7 +997,7 @@ bool CWallet::IsChange(const CTxOut& txout) const\n     // a better way of identifying which outputs are 'the send' and which are\n     // 'the change' will need to be implemented (maybe extend CWalletTx to remember\n     // which output, if any, was change).\n-    if (::IsMine(*this, txout.scriptPubKey))\n+    if (Lightwallet::IsMine(*this, txout.scriptPubKey))\n     {\n         CTxDestination address;\n         if (!ExtractDestination(txout.scriptPubKey, address))\n@@ -2372,8 +2373,6 @@ DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n         return nLoadWalletRet;\n     fFirstRunRet = !vchDefaultKey.IsValid();\n \n-    uiInterface.LoadWallet(this);\n-\n     return DB_LOAD_OK;\n }\n \n@@ -2438,7 +2437,7 @@ bool CWallet::SetAddressBook(const CTxDestination& address, const string& strNam\n         if (!strPurpose.empty()) /* update purpose only if requested */\n             mapAddressBook[address].purpose = strPurpose;\n     }\n-    NotifyAddressBookChanged(this, address, strName, ::IsMine(*this, address) != ISMINE_NO,\n+    NotifyAddressBookChanged(this, address, strName, Lightwallet::IsMine(*this, address) != ISMINE_NO,\n                              strPurpose, (fUpdated ? CT_UPDATED : CT_NEW) );\n     if (!fFileBacked)\n         return false;\n@@ -2464,7 +2463,7 @@ bool CWallet::DelAddressBook(const CTxDestination& address)\n         mapAddressBook.erase(address);\n     }\n \n-    NotifyAddressBookChanged(this, address, \"\", ::IsMine(*this, address) != ISMINE_NO, \"\", CT_DELETED);\n+    NotifyAddressBookChanged(this, address, \"\", Lightwallet::IsMine(*this, address) != ISMINE_NO, \"\", CT_DELETED);\n \n     if (!fFileBacked)\n         return false;\n@@ -3008,7 +3007,7 @@ bool CWallet::GetDestData(const CTxDestination &dest, const std::string &key, st\n \n std::string CWallet::GetWalletHelpString(bool showDebug)\n {\n-    std::string strUsage = HelpMessageGroup(_(\"Wallet options:\"));\n+    std::string strUsage = HelpMessageGroup(_(\"LightWallet options:\"));\n     strUsage += HelpMessageOpt(\"-disablewallet\", _(\"Do not load the wallet and disable wallet RPC calls\"));\n     strUsage += HelpMessageOpt(\"-keypool=<n>\", strprintf(_(\"Set key pool size to <n> (default: %u)\"), DEFAULT_KEYPOOL_SIZE));\n     strUsage += HelpMessageOpt(\"-fallbackfee=<amt>\", strprintf(_(\"A fee rate (in %s/kB) that will be used when fee estimation has insufficient data (default: %s)\"),\n@@ -3325,3 +3324,4 @@ bool CMerkleTx::AcceptToMemoryPool(bool fLimitFree, CAmount nAbsurdFee)\n     CValidationState state;\n     return ::AcceptToMemoryPool(mempool, state, *this, fLimitFree, NULL, NULL, false, nAbsurdFee);\n }\n+}\n\\ No newline at end of file"
      },
      {
        "sha": "da35f486ef630bbc7ede67a4b2943f83eafd4544",
        "filename": "src/lightwallet/wallet.h",
        "status": "modified",
        "additions": 15,
        "deletions": 13,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2ad6a8a932719ddefb640df8b16e060fcffbffe/src/lightwallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2ad6a8a932719ddefb640df8b16e060fcffbffe/src/lightwallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/wallet.h?ref=b2ad6a8a932719ddefb640df8b16e060fcffbffe",
        "patch": "@@ -3,19 +3,19 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#ifndef BITCOIN_WALLET_WALLET_H\n-#define BITCOIN_WALLET_WALLET_H\n+#ifndef BITCOIN_LIGHTWALLET_WALLET_H\n+#define BITCOIN_LIGHTWALLET_WALLET_H\n \n #include \"amount.h\"\n #include \"streams.h\"\n #include \"tinyformat.h\"\n #include \"ui_interface.h\"\n #include \"utilstrencodings.h\"\n #include \"validationinterface.h\"\n-#include \"wallet/crypter.h\"\n-#include \"wallet/wallet_ismine.h\"\n-#include \"wallet/walletdb.h\"\n-#include \"wallet/rpcwallet.h\"\n+#include \"lightwallet/crypter.h\"\n+#include \"lightwallet/wallet_ismine.h\"\n+#include \"lightwallet/walletdb.h\"\n+#include \"lightwallet/rpcwallet.h\"\n \n #include <algorithm>\n #include <map>\n@@ -28,6 +28,13 @@\n \n #include <boost/shared_ptr.hpp>\n \n+class CBlockIndex;\n+class CCoinControl;\n+class COutput;\n+class CScript;\n+class CTxMemPool;\n+\n+namespace Lightwallet {\n extern CWallet* pwalletMain;\n \n /**\n@@ -59,12 +66,7 @@ static const bool DEFAULT_WALLETBROADCAST = true;\n \n extern const char * DEFAULT_WALLET_DAT;\n \n-class CBlockIndex;\n-class CCoinControl;\n-class COutput;\n class CReserveKey;\n-class CScript;\n-class CTxMemPool;\n class CWalletTx;\n \n /** (client) version numbers for particular wallet features */\n@@ -939,5 +941,5 @@ class CAccount\n         READWRITE(vchPubKey);\n     }\n };\n-\n-#endif // BITCOIN_WALLET_WALLET_H\n+}\n+#endif // BITCOIN_LIGHTWALLET_WALLET_H"
      },
      {
        "sha": "9c638c59146d08b44c6f6fb817cac9e2b6dbe189",
        "filename": "src/lightwallet/wallet_ismine.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2ad6a8a932719ddefb640df8b16e060fcffbffe/src/lightwallet/wallet_ismine.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2ad6a8a932719ddefb640df8b16e060fcffbffe/src/lightwallet/wallet_ismine.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/wallet_ismine.cpp?ref=b2ad6a8a932719ddefb640df8b16e060fcffbffe",
        "patch": "@@ -13,8 +13,12 @@\n \n #include <boost/foreach.hpp>\n \n+\n+\n using namespace std;\n \n+namespace Lightwallet {\n+\n typedef vector<unsigned char> valtype;\n \n unsigned int HaveKeys(const vector<valtype>& pubkeys, const CKeyStore& keystore)\n@@ -93,3 +97,4 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n     }\n     return ISMINE_NO;\n }\n+}\n\\ No newline at end of file"
      },
      {
        "sha": "708d96c798bb694686d25bbde332e104bbb80cb4",
        "filename": "src/lightwallet/wallet_ismine.h",
        "status": "modified",
        "additions": 8,
        "deletions": 5,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2ad6a8a932719ddefb640df8b16e060fcffbffe/src/lightwallet/wallet_ismine.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2ad6a8a932719ddefb640df8b16e060fcffbffe/src/lightwallet/wallet_ismine.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/wallet_ismine.h?ref=b2ad6a8a932719ddefb640df8b16e060fcffbffe",
        "patch": "@@ -3,8 +3,8 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#ifndef BITCOIN_WALLET_WALLET_ISMINE_H\n-#define BITCOIN_WALLET_WALLET_ISMINE_H\n+#ifndef BITCOIN_LIGHTWALLET_WALLET_ISMINE_H\n+#define BITCOIN_LIGHTWALLET_WALLET_ISMINE_H\n \n #include \"script/standard.h\"\n \n@@ -13,6 +13,8 @@\n class CKeyStore;\n class CScript;\n \n+namespace Lightwallet {\n+\n /** IsMine() return codes */\n enum isminetype\n {\n@@ -28,7 +30,8 @@ enum isminetype\n /** used for bitflags of isminetype */\n typedef uint8_t isminefilter;\n \n-isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey);\n-isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest);\n+isminetype IsMine(const ::CKeyStore& keystore, const ::CScript& scriptPubKey);\n+isminetype IsMine(const ::CKeyStore& keystore, const ::CTxDestination& dest);\n \n-#endif // BITCOIN_WALLET_WALLET_ISMINE_H\n+#endif // BITCOIN_LIGHTWALLET_WALLET_ISMINE_H\n+}\n\\ No newline at end of file"
      },
      {
        "sha": "64121c14989264997d2173b76180ecc52581ec7a",
        "filename": "src/lightwallet/walletdb.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2ad6a8a932719ddefb640df8b16e060fcffbffe/src/lightwallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2ad6a8a932719ddefb640df8b16e060fcffbffe/src/lightwallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/walletdb.cpp?ref=b2ad6a8a932719ddefb640df8b16e060fcffbffe",
        "patch": "@@ -3,7 +3,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include \"wallet/walletdb.h\"\n+#include \"lightwallet/walletdb.h\"\n \n #include \"base58.h\"\n #include \"consensus/validation.h\"\n@@ -13,14 +13,16 @@\n #include \"sync.h\"\n #include \"util.h\"\n #include \"utiltime.h\"\n-#include \"wallet/wallet.h\"\n+#include \"lightwallet/wallet.h\"\n \n #include <boost/version.hpp>\n #include <boost/filesystem.hpp>\n #include <boost/foreach.hpp>\n #include <boost/scoped_ptr.hpp>\n #include <boost/thread.hpp>\n \n+namespace Lightwallet {\n+\n using namespace std;\n \n static uint64_t nAccountingEntryNumber = 0;\n@@ -1043,3 +1045,4 @@ bool CWalletDB::EraseDestData(const std::string &address, const std::string &key\n     nWalletDBUpdated++;\n     return Erase(std::make_pair(std::string(\"destdata\"), std::make_pair(address, key)));\n }\n+}"
      },
      {
        "sha": "c25ba5f8e5db88c752d1325f489539d49ebe3759",
        "filename": "src/lightwallet/walletdb.h",
        "status": "modified",
        "additions": 16,
        "deletions": 12,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2ad6a8a932719ddefb640df8b16e060fcffbffe/src/lightwallet/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2ad6a8a932719ddefb640df8b16e060fcffbffe/src/lightwallet/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/walletdb.h?ref=b2ad6a8a932719ddefb640df8b16e060fcffbffe",
        "patch": "@@ -3,11 +3,11 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#ifndef BITCOIN_WALLET_WALLETDB_H\n-#define BITCOIN_WALLET_WALLETDB_H\n+#ifndef BITCOIN_LIGHTWALLET_WALLETDB_H\n+#define BITCOIN_LIGHTWALLET_WALLETDB_H\n \n #include \"amount.h\"\n-#include \"wallet/db.h\"\n+#include \"lightwallet/db.h\"\n #include \"key.h\"\n \n #include <list>\n@@ -16,18 +16,22 @@\n #include <utility>\n #include <vector>\n \n-static const bool DEFAULT_FLUSHWALLET = true;\n+struct CBlockLocator;\n+class CScript;\n+\n+class uint160;\n+class uint256;\n+\n+namespace Lightwallet {\n \n class CAccount;\n class CAccountingEntry;\n-struct CBlockLocator;\n-class CKeyPool;\n-class CMasterKey;\n-class CScript;\n class CWallet;\n class CWalletTx;\n-class uint160;\n-class uint256;\n+class CKeyPool;\n+class CMasterKey;\n+\n+static const bool DEFAULT_FLUSHWALLET = true;\n \n /** Error statuses for the wallet database */\n enum DBErrors\n@@ -143,5 +147,5 @@ class CWalletDB : public CDB\n \n bool BackupWallet(const CWallet& wallet, const std::string& strDest);\n void ThreadFlushWalletDB(const std::string& strFile);\n-\n-#endif // BITCOIN_WALLET_WALLETDB_H\n+}\n+#endif // BITCOIN_LIGHTWALLET_WALLETDB_H"
      }
    ]
  },
  {
    "sha": "2f12e473d51c847409693f9c6e1ed291a1a74707",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyZjEyZTQ3M2Q1MWM4NDc0MDk2OTNmOWM2ZTFlZDI5MWExYTc0NzA3",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2016-04-06T19:11:32Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2016-04-06T19:14:57Z"
      },
      "message": "[LightWallet] add LightWallet compile option",
      "tree": {
        "sha": "a6d5e1a8ef431ea583a574c0050a79da233ab18e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a6d5e1a8ef431ea583a574c0050a79da233ab18e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2f12e473d51c847409693f9c6e1ed291a1a74707",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "expired_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXBWAyAAoJECnUvLZBb1PskW0P/RzzMmtZVllfvAW/h4iOgLS/\nZixQdR8lA3RXFJEC4WRxiHCOQPqpbB7pN5b1HoKBKXeDUA6w8aowxe7m2Kj9X7UU\nhbakBhpna+wZfzfIhYE57Di3Mr2xf+6F8lXDTxd5QchMOR4b9CR1c5fnM9VVbp/h\n+dqt1Oh8khMbv3hYtROm74QScMmsDH0bjBACW1XFQ4+4zlelzTH8PpCsRv67DVD/\nVId3EwNs1n5BH2ykA2hBnnXv/d0MhQuOaC+JwNxEecyuBG2Z8y9SkJWl7goaBUUm\n4Wc5qIQOCFu4l4awkbQcB38O77gOvYD+tfdqzreaHtRnyooDUTJCa6QAu+Jfj3O6\np1DNm0c6FZXbpOyHIY0aUtzOE2LSbDQotYqGHjPmaP5BMHhD6eZ+DRq0+kcuauoj\nxzv24rUVZ6k8/BTpFqOgHTuOsYJEbd6s9aP74AAB6uSeI7LkMYUi3oLRmkYGNOl5\nT29iYof5ghv3tQxxCBKfo5Hl+6uPI9Q2d27XQjQjjgyHorwTbQbUst7DihFi+Ygd\n2B30fuEmuv5XNDpIDaMRzgHgErMi+ffyO83p2VGWxX7FLhww/sW9HdbZb76HLrYx\nW0dCXhElPWVrdvclhzn+wnqyA7PSNuaHr9Pj1fTEOwnw58JB1qvgpp3PIA9bh/aa\nMNy5VCiZcJzxDdd8VQHa\n=+5yj\n-----END PGP SIGNATURE-----",
        "payload": "tree a6d5e1a8ef431ea583a574c0050a79da233ab18e\nparent b2ad6a8a932719ddefb640df8b16e060fcffbffe\nauthor Jonas Schnelli <dev@jonasschnelli.ch> 1459969892 +0200\ncommitter Jonas Schnelli <dev@jonasschnelli.ch> 1459970097 +0200\n\n[LightWallet] add LightWallet compile option\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f12e473d51c847409693f9c6e1ed291a1a74707",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2f12e473d51c847409693f9c6e1ed291a1a74707",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f12e473d51c847409693f9c6e1ed291a1a74707/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b2ad6a8a932719ddefb640df8b16e060fcffbffe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b2ad6a8a932719ddefb640df8b16e060fcffbffe",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b2ad6a8a932719ddefb640df8b16e060fcffbffe"
      }
    ],
    "stats": {
      "total": 63,
      "additions": 63,
      "deletions": 0
    },
    "files": [
      {
        "sha": "3a4ddea1e34a42016bea44ecd974fb8846b9895d",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f12e473d51c847409693f9c6e1ed291a1a74707/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f12e473d51c847409693f9c6e1ed291a1a74707/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=2f12e473d51c847409693f9c6e1ed291a1a74707",
        "patch": "@@ -81,6 +81,13 @@ AC_ARG_ENABLE([wallet],\n   [enable_wallet=$enableval],\n   [enable_wallet=yes])\n \n+# Enable wallet\n+AC_ARG_ENABLE([lightwallet],\n+  [AS_HELP_STRING([--enable-lightwallet],\n+  [enable lightwallet (disabled by default)])],\n+  [enable_lightwallet=$enableval],\n+  [enable_lightwallet=no])\n+\t\n AC_ARG_WITH([miniupnpc],\n   [AS_HELP_STRING([--with-miniupnpc],\n   [enable UPNP (default is yes if libminiupnpc is found)])],\n@@ -896,6 +903,16 @@ else\n   AC_MSG_RESULT(no)\n fi\n \n+dnl enable lightwallet\n+AC_MSG_CHECKING([if lightwallet should be enabled])\n+if test x$enable_lightwallet != xno; then\n+  AC_MSG_RESULT(yes)\n+  AC_DEFINE_UNQUOTED([ENABLE_LIGHTWALLET],[1],[Define to 1 to enable lightwallet functions])\n+\n+else\n+  AC_MSG_RESULT(no)\n+fi\n+\n dnl enable upnp support\n AC_MSG_CHECKING([whether to build with support for UPnP])\n if test x$have_miniupnpc = xno; then\n@@ -989,6 +1006,7 @@ AM_CONDITIONAL([TARGET_DARWIN], [test x$TARGET_OS = xdarwin])\n AM_CONDITIONAL([BUILD_DARWIN], [test x$BUILD_OS = xdarwin])\n AM_CONDITIONAL([TARGET_WINDOWS], [test x$TARGET_OS = xwindows])\n AM_CONDITIONAL([ENABLE_WALLET],[test x$enable_wallet = xyes])\n+AM_CONDITIONAL([ENABLE_LIGHTWALLET],[test x$enable_lightwallet = xyes])\n AM_CONDITIONAL([ENABLE_TESTS],[test x$BUILD_TEST = xyes])\n AM_CONDITIONAL([ENABLE_QT],[test x$bitcoin_enable_qt = xyes])\n AM_CONDITIONAL([ENABLE_QT_TESTS],[test x$BUILD_TEST_QT = xyes])"
      },
      {
        "sha": "2c478b370627ddf34d41413b9d563cb7e9bd9263",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 32,
        "deletions": 0,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f12e473d51c847409693f9c6e1ed291a1a74707/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f12e473d51c847409693f9c6e1ed291a1a74707/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=2f12e473d51c847409693f9c6e1ed291a1a74707",
        "patch": "@@ -36,6 +36,7 @@ BITCOIN_INCLUDES += $(UNIVALUE_CFLAGS)\n \n LIBBITCOIN_SERVER=libbitcoin_server.a\n LIBBITCOIN_WALLET=libbitcoin_wallet.a\n+LIBBITCOIN_LIGHTWALLET=libbitcoin_lightwallet.a\n LIBBITCOIN_COMMON=libbitcoin_common.a\n LIBBITCOIN_CONSENSUS=libbitcoin_consensus.a\n LIBBITCOIN_CLI=libbitcoin_cli.a\n@@ -60,6 +61,10 @@ if ENABLE_WALLET\n BITCOIN_INCLUDES += $(BDB_CPPFLAGS)\n EXTRA_LIBRARIES += libbitcoin_wallet.a\n endif\n+if ENABLE_LIGHTWALLET\n+BITCOIN_INCLUDES += $(BDB_CPPFLAGS)\n+EXTRA_LIBRARIES += libbitcoin_lightwallet.a\n+endif\n if ENABLE_ZMQ\n EXTRA_LIBRARIES += libbitcoin_zmq.a\n endif\n@@ -112,6 +117,12 @@ BITCOIN_CORE_H = \\\n   key.h \\\n   keystore.h \\\n   dbwrapper.h \\\n+  lightwallet/crypter.h \\\n+  lightwallet/db.h \\\n+  lightwallet/rpcwallet.h \\\n+  lightwallet/wallet.h \\\n+  lightwallet/wallet_ismine.h \\\n+  lightwallet/walletdb.h \\\n   limitedmap.h \\\n   main.h \\\n   memusage.h \\\n@@ -234,6 +245,21 @@ libbitcoin_wallet_a_SOURCES = \\\n   policy/rbf.cpp \\\n   $(BITCOIN_CORE_H)\n \n+# wallet: shared between bitcoind and bitcoin-qt, but only linked\n+# when wallet enabled\n+libbitcoin_lightwallet_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n+libbitcoin_lightwallet_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+libbitcoin_lightwallet_a_SOURCES = \\\n+  lightwallet/crypter.cpp \\\n+  lightwallet/db.cpp \\\n+  lightwallet/rpcdump.cpp \\\n+  lightwallet/rpcwallet.cpp \\\n+  lightwallet/wallet.cpp \\\n+  lightwallet/wallet_ismine.cpp \\\n+  lightwallet/walletdb.cpp \\\n+  policy/rbf.cpp \\\n+  $(BITCOIN_CORE_H)\n+\t\n # crypto primitives library\n crypto_libbitcoin_crypto_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_CONFIG_INCLUDES)\n crypto_libbitcoin_crypto_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n@@ -372,6 +398,10 @@ if ENABLE_WALLET\n bitcoind_LDADD += libbitcoin_wallet.a\n endif\n \n+if ENABLE_LIGHTWALLET\n+bitcoind_LDADD += libbitcoin_lightwallet.a\n+endif\n+\n bitcoind_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS)\n \n # bitcoin-cli binary #\n@@ -443,6 +473,8 @@ CLEANFILES += support/*.gcda support/*.gcno\n CLEANFILES += univalue/*.gcda univalue/*.gcno\n CLEANFILES += wallet/*.gcda wallet/*.gcno\n CLEANFILES += wallet/test/*.gcda wallet/test/*.gcno\n+CLEANFILES += lightwallet/*.gcda lightwallet/*.gcno\n+CLEANFILES += lightwallet/test/*.gcda lightwallet/test/*.gcno\n CLEANFILES += zmq/*.gcda zmq/*.gcno\n \n DISTCLEANFILES = obj/build.h"
      },
      {
        "sha": "f86f032b830fbefe0e38399135e6aeb817a6060a",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f12e473d51c847409693f9c6e1ed291a1a74707/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f12e473d51c847409693f9c6e1ed291a1a74707/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=2f12e473d51c847409693f9c6e1ed291a1a74707",
        "patch": "@@ -96,6 +96,11 @@ BITCOIN_TESTS += \\\n   test/rpc_wallet_tests.cpp\n endif\n \n+if ENABLE_LIGHTWALLET\n+BITCOIN_TESTS += \\\n+  lightwallet/test/lightwallet_tests.cpp\n+endif\n+\n test_test_bitcoin_SOURCES = $(BITCOIN_TESTS) $(JSON_TEST_FILES) $(RAW_TEST_FILES)\n test_test_bitcoin_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -I$(builddir)/test/ $(TESTDEFS)\n test_test_bitcoin_LDADD = $(LIBBITCOIN_SERVER) $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) $(LIBMEMENV) \\"
      },
      {
        "sha": "6f0adbf32df20aee88e80b746681b68f232f272a",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f12e473d51c847409693f9c6e1ed291a1a74707/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f12e473d51c847409693f9c6e1ed291a1a74707/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=2f12e473d51c847409693f9c6e1ed291a1a74707",
        "patch": "@@ -41,6 +41,11 @@\n #include \"wallet/wallet.h\"\n #include \"wallet/walletdb.h\"\n #endif\n+#ifdef ENABLE_LIGHTWALLET\n+#include \"lightwallet/db.h\"\n+#include \"lightwallet/wallet.h\"\n+#include \"lightwallet/walletdb.h\"\n+#endif\n #include <stdint.h>\n #include <stdio.h>\n \n@@ -393,6 +398,9 @@ std::string HelpMessage(HelpMessageMode mode)\n #ifdef ENABLE_WALLET\n     strUsage += CWallet::GetWalletHelpString(showDebug);\n #endif\n+#ifdef ENABLE_LIGHTWALLET\n+    strUsage += Lightwallet::CWallet::GetWalletHelpString(showDebug);\n+#endif\n \n #if ENABLE_ZMQ\n     strUsage += HelpMessageGroup(_(\"ZeroMQ notification options:\"));"
      }
    ]
  },
  {
    "sha": "72d473e33db1e9866670162b8556ada6dc20f9ad",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3MmQ0NzNlMzNkYjFlOTg2NjY3MDE2MmI4NTU2YWRhNmRjMjBmOWFk",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2016-04-13T08:48:26Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2016-04-13T08:48:26Z"
      },
      "message": "[RPC] refactor RPC call handling, allow flexible endpoint registering",
      "tree": {
        "sha": "cf6f1c1a8bf014325318ccd22a665b6c2bf27f6c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cf6f1c1a8bf014325318ccd22a665b6c2bf27f6c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/72d473e33db1e9866670162b8556ada6dc20f9ad",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "expired_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXDggFAAoJECnUvLZBb1PsL20P/2CMusttXQpSYtCwLe0XZGm8\nBtT5ZYVGnhzWmJJtqjcdy5sCEzhljWNe2xJDhhXUTCxwI2OqpsVfEI47bL4lXhzH\nIC9gvNc17u2njk3ZzUPJjBTciNDCpVeQChJZxNRuD6tLg3zRDZGbEXkvn/gD5kkv\nhZKREQZCBMvWMa41xTMonafDtUkmTpggaJV92vtxozxB95o9yC7PzqRf+5iq+xrx\nk6vs8zBzYS5siisgOKq8XZn5yxssAb5TjvERFYLkPTXjSQ1xY69Y2+Iw0eTKb6iW\nIMEcR0o47b46gMtSQxba8SJkYu3n7PhqMTh2guXRjW3JkUltRTd9XOD75K02v8b1\nhbexO2SgA6Z1R2S5QbkZRK3BgrPXX2vJ4LG2ThxfFbAePagxQ1imLfyoT3ubBqYp\nB1Re6vVaze4h8qiRjTT2VRChAyawa0tGfIhZF0r2YG3kICKcEgtFLFhJ7y6DHMC5\nJaQugh5Bwb7RSYoh/jxr2FuTs0ROacIAXYn3COIUtDhdm7xYRXBsYwm+pEYkLCgZ\n/jEqSuJl6e3mQypYagjr8L6LeDsqUZTA09pcS7T3OugzzFSvLEng0wJex5CTZgM4\noQvRm1uSf0ksP0uPlKcFo7GselfEqmso7sZ2my2hvAOKSj381xUi02HWKZcJAzbT\nPHsPr0a/8BCE3vfwLRc4\n=uxpB\n-----END PGP SIGNATURE-----",
        "payload": "tree cf6f1c1a8bf014325318ccd22a665b6c2bf27f6c\nparent 2f12e473d51c847409693f9c6e1ed291a1a74707\nauthor Jonas Schnelli <dev@jonasschnelli.ch> 1460537306 +0200\ncommitter Jonas Schnelli <dev@jonasschnelli.ch> 1460537306 +0200\n\n[RPC] refactor RPC call handling, allow flexible endpoint registering\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/72d473e33db1e9866670162b8556ada6dc20f9ad",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/72d473e33db1e9866670162b8556ada6dc20f9ad",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/72d473e33db1e9866670162b8556ada6dc20f9ad/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2f12e473d51c847409693f9c6e1ed291a1a74707",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f12e473d51c847409693f9c6e1ed291a1a74707",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2f12e473d51c847409693f9c6e1ed291a1a74707"
      }
    ],
    "stats": {
      "total": 25,
      "additions": 21,
      "deletions": 4
    },
    "files": [
      {
        "sha": "81123d67bb708120720590eef17966e62696da3c",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/72d473e33db1e9866670162b8556ada6dc20f9ad/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/72d473e33db1e9866670162b8556ada6dc20f9ad/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=72d473e33db1e9866670162b8556ada6dc20f9ad",
        "patch": "@@ -192,7 +192,7 @@ UniValue CallRPC(const string& strMethod, const UniValue& params)\n     assert(output_buffer);\n     evbuffer_add(output_buffer, strRequest.data(), strRequest.size());\n \n-    int r = evhttp_make_request(evcon, req, EVHTTP_REQ_POST, \"/\");\n+    int r = evhttp_make_request(evcon, req, EVHTTP_REQ_POST, GetArg(\"-endpoint\", \"/\").c_str());\n     if (r != 0) {\n         evhttp_connection_free(evcon);\n         event_base_free(base);"
      },
      {
        "sha": "e016ea0ed0fc57c23eb1e17834398cb0f49415ee",
        "filename": "src/httprpc.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 3,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/72d473e33db1e9866670162b8556ada6dc20f9ad/src/httprpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/72d473e33db1e9866670162b8556ada6dc20f9ad/src/httprpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httprpc.cpp?ref=72d473e33db1e9866670162b8556ada6dc20f9ad",
        "patch": "@@ -66,7 +66,7 @@ static std::string strRPCUserColonPass;\n /* Stored RPC timer interface (for unregistration) */\n static HTTPRPCTimerInterface* httpRPCTimerInterface = 0;\n \n-static void JSONErrorReply(HTTPRequest* req, const UniValue& objError, const UniValue& id)\n+void JSONErrorReply(HTTPRequest* req, const UniValue& objError, const UniValue& id)\n {\n     // Send error reply from json-rpc error object\n     int nStatus = HTTP_INTERNAL_SERVER_ERROR;\n@@ -127,7 +127,7 @@ static bool multiUserAuthorized(std::string strUserPass)\n     return false;\n }\n \n-static bool RPCAuthorized(const std::string& strAuth)\n+bool RPCAuthorized(const std::string& strAuth)\n {\n     if (strRPCUserColonPass.empty()) // Belt-and-suspenders measure if InitRPCAuthentication was not called\n         return false;\n@@ -144,7 +144,7 @@ static bool RPCAuthorized(const std::string& strAuth)\n     return multiUserAuthorized(strUserPass);\n }\n \n-static bool HTTPReq_JSONRPC(HTTPRequest* req, const std::string &)\n+bool HTTPReq_HandleAuth(HTTPRequest* req)\n {\n     // JSONRPC handles only POST\n     if (req->GetRequestMethod() != HTTPRequest::POST) {\n@@ -171,6 +171,13 @@ static bool HTTPReq_JSONRPC(HTTPRequest* req, const std::string &)\n         req->WriteReply(HTTP_UNAUTHORIZED);\n         return false;\n     }\n+    return true;\n+}\n+\n+static bool HTTPReq_JSONRPC(HTTPRequest* req, const std::string &)\n+{\n+    if(!HTTPReq_HandleAuth(req))\n+        return false;\n \n     JSONRequest jreq;\n     try {"
      },
      {
        "sha": "8e2b8ac6541441d7b680f9bc53d1d650fff3910c",
        "filename": "src/httprpc.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/72d473e33db1e9866670162b8556ada6dc20f9ad/src/httprpc.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/72d473e33db1e9866670162b8556ada6dc20f9ad/src/httprpc.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httprpc.h?ref=72d473e33db1e9866670162b8556ada6dc20f9ad",
        "patch": "@@ -9,6 +9,7 @@\n #include <map>\n \n class HTTPRequest;\n+class UniValue;\n \n /** Start HTTP RPC subsystem.\n  * Precondition; HTTP and RPC has been started.\n@@ -34,4 +35,13 @@ void InterruptREST();\n  */\n void StopREST();\n \n+/** Handles authentication, checks httpbase-auth header.\n+ * Write authorize header if required.\n+ * Responses true/false and populates the HTTPRequest\n+ */\n+bool HTTPReq_HandleAuth(HTTPRequest* req);\n+\n+/** populates HTTPRequest with the UniValue objError and the JSONRPC request id */\n+void JSONErrorReply(HTTPRequest* req, const UniValue& objError, const UniValue& id);\n+\n #endif"
      }
    ]
  },
  {
    "sha": "25401239600e5f285424a165177e39f750faa974",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNTQwMTIzOTYwMGU1ZjI4NTQyNGExNjUxNzdlMzlmNzUwZmFhOTc0",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2016-04-06T19:39:27Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2016-04-13T08:49:16Z"
      },
      "message": "[LightWallet] run LightWallet in parallel to standard wallet",
      "tree": {
        "sha": "b2c874063251c9fa4a7f16ce785ae2b73fbab68d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b2c874063251c9fa4a7f16ce785ae2b73fbab68d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/25401239600e5f285424a165177e39f750faa974",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "expired_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXDggMAAoJECnUvLZBb1PsAScQAJ7lABbz3JnV00Ux1mtGDJuy\npg+gKC3qRUZMy1lFn/3TYcnzvN+xteuwk2DZyl3kgcgoZZ6niqU++S1AcBCvK+7o\nf60eFi9+T7VM+ACgca5cSyuXiqsKHfOoIo3qwKd/v+9M9WiMvZxzQwwf9UYppJal\n41OCE+KoG4/oUt6P9IoFG09jlKpN9CHZRv6qbvq1NzIYVXQROOdUifxLaBJ12/yT\niPqUVIQ0dhWS05mRzrou7m5XlPyYYRl2Y8mv2AkdCoAk+aur8jG9s28lGxugvJME\nbA+UkOTasMjbcsJAKMtp2ChCHbhs3Zo8xiSUelb1GVdSryrmWfBPEfGEgbg+YWGm\nSgXJ2dcvxvIx5UU4AVRoIMTktcdkPKxxWy4w3mzagsTho58njKoCv3EwvyoD3SRW\nxok8ZVfWpcHWzF4FnZaI6yeJxshIf7umPL/TYodo8rlnUDW8Mc9HLiy3UXPrFZow\niz2Guz0Ci3emqnprzL6+QpLR56XcGw9k/KXsxjz/Jp1yJla4sr0LtFuVXbAC2ivK\npEFGuvnrVWH/E9SWzcfeY62mMkKp17miMEI5wLRk/ti+GZaWpD1xqqlTkVWrkXEB\nWgzUxadRvqu2hcI6sEyBmVcpvUe5qCbXCste2jbR7GqYL640YuXFv2mwgfsuRLL4\nRaWVQy9E8UbYY/0a9umR\n=lDue\n-----END PGP SIGNATURE-----",
        "payload": "tree b2c874063251c9fa4a7f16ce785ae2b73fbab68d\nparent 72d473e33db1e9866670162b8556ada6dc20f9ad\nauthor Jonas Schnelli <dev@jonasschnelli.ch> 1459971567 +0200\ncommitter Jonas Schnelli <dev@jonasschnelli.ch> 1460537356 +0200\n\n[LightWallet] run LightWallet in parallel to standard wallet\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/25401239600e5f285424a165177e39f750faa974",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/25401239600e5f285424a165177e39f750faa974",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/25401239600e5f285424a165177e39f750faa974/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "72d473e33db1e9866670162b8556ada6dc20f9ad",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/72d473e33db1e9866670162b8556ada6dc20f9ad",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/72d473e33db1e9866670162b8556ada6dc20f9ad"
      }
    ],
    "stats": {
      "total": 438,
      "additions": 236,
      "deletions": 202
    },
    "files": [
      {
        "sha": "1b4deed460ea0b9dc33e6df801c06ad3acef09b5",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 2,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/25401239600e5f285424a165177e39f750faa974/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/25401239600e5f285424a165177e39f750faa974/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=25401239600e5f285424a165177e39f750faa974",
        "patch": "@@ -927,6 +927,11 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n     if (!fDisableWallet)\n         RegisterWalletRPCCommands(tableRPC);\n #endif\n+#ifdef ENABLE_LIGHTWALLET\n+    bool fDisableLightWallet = GetBoolArg(\"-disablelightwallet\", false);\n+    if (!fDisableLightWallet)\n+        Lightwallet::RegisterWalletRPCCommands(tableRPC);\n+#endif\n \n     nConnectTimeout = GetArg(\"-timeout\", DEFAULT_CONNECT_TIMEOUT);\n     if (nConnectTimeout <= 0)\n@@ -956,6 +961,10 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n     if (!CWallet::ParameterInteraction())\n         return false;\n #endif // ENABLE_WALLET\n+#ifdef ENABLE_LIGHTWALLET\n+    if (!Lightwallet::CWallet::ParameterInteraction())\n+        return false;\n+#endif // ENABLE_LIGHTWALLET\n \n     fIsBareMultisigStd = GetBoolArg(\"-permitbaremultisig\", DEFAULT_PERMIT_BAREMULTISIG);\n     fAcceptDatacarrier = GetBoolArg(\"-datacarrier\", DEFAULT_ACCEPT_DATACARRIER);\n@@ -1054,6 +1063,12 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n             return false;\n     } // (!fDisableWallet)\n #endif // ENABLE_WALLET\n+#ifdef ENABLE_LIGHTWALLET\n+    if (!fDisableLightWallet) {\n+        if (!Lightwallet::CWallet::Verify())\n+            return false;\n+    }\n+#endif // ENABLE_LIGHTWALLET\n     // ********************************************************* Step 6: network initialization\n \n     RegisterNodeSignals(GetNodeSignals());\n@@ -1366,10 +1381,21 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n         if (!pwalletMain)\n             return false;\n     }\n-#else // ENABLE_WALLET\n-    LogPrintf(\"No wallet support compiled in!\\n\");\n #endif // !ENABLE_WALLET\n+#ifdef ENABLE_LIGHTWALLET\n+    if (fDisableLightWallet) {\n+        Lightwallet::pwalletMain = NULL;\n+        LogPrintf(\"LightWallet disabled!\\n\");\n+    } else {\n+        Lightwallet::CWallet::InitLoadWallet();\n+        if (!Lightwallet::pwalletMain)\n+            return false;\n+    }\n+#endif // ENABLE_LIGHTWALLET\n \n+#if !defined(ENABLE_WALLET) && !defined(ENABLE_LIGHTWALLET)\n+    LogPrintf(\"No wallet support compiled in!\\n\");\n+#endif\n     // ********************************************************* Step 9: data directory maintenance\n \n     // if pruning, unset the service bit and perform the initial blockstore prune\n@@ -1451,6 +1477,15 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n         threadGroup.create_thread(boost::bind(&ThreadFlushWalletDB, boost::ref(pwalletMain->strWalletFile)));\n     }\n #endif\n+#ifdef ENABLE_LIGHTWALLET\n+    if (Lightwallet::pwalletMain) {\n+        // Add wallet transactions that aren't already in a block to mapTransactions\n+        Lightwallet::pwalletMain->ReacceptWalletTransactions();\n+\n+        // Run a thread to flush wallet periodically\n+        threadGroup.create_thread(boost::bind(&Lightwallet::ThreadFlushWalletDB, boost::ref(Lightwallet::pwalletMain->strWalletFile)));\n+    }\n+#endif\n \n     return !fRequestShutdown;\n }"
      },
      {
        "sha": "7d0ace9cd2707b3b99c739d2476a68bc473db2e5",
        "filename": "src/lightwallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 196,
        "deletions": 196,
        "changes": 392,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/25401239600e5f285424a165177e39f750faa974/src/lightwallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/25401239600e5f285424a165177e39f750faa974/src/lightwallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/rpcwallet.cpp?ref=25401239600e5f285424a165177e39f750faa974",
        "patch": "@@ -25,6 +25,9 @@\n \n #include <univalue.h>\n \n+// Defined in rpc/misc.cpp\n+extern CScript _createmultisig_redeemScript(const UniValue& params);\n+\n namespace Lightwallet {\n \n using namespace std;\n@@ -34,14 +37,14 @@ static CCriticalSection cs_nWalletUnlockTime;\n \n std::string HelpRequiringPassphrase()\n {\n-    return pwalletMain && pwalletMain->IsCrypted()\n+    return Lightwallet::pwalletMain && Lightwallet::pwalletMain->IsCrypted()\n         ? \"\\nRequires wallet passphrase to be set with walletpassphrase call.\"\n         : \"\";\n }\n \n bool EnsureWalletIsAvailable(bool avoidException)\n {\n-    if (!pwalletMain)\n+    if (!Lightwallet::pwalletMain)\n     {\n         if (!avoidException)\n             throw JSONRPCError(RPC_METHOD_NOT_FOUND, \"Method not found (disabled)\");\n@@ -53,7 +56,7 @@ bool EnsureWalletIsAvailable(bool avoidException)\n \n void EnsureWalletIsUnlocked()\n {\n-    if (pwalletMain->IsLocked())\n+    if (Lightwallet::pwalletMain->IsLocked())\n         throw JSONRPCError(RPC_WALLET_UNLOCK_NEEDED, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n }\n \n@@ -128,31 +131,31 @@ UniValue getnewaddress(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"getnewaddress\", \"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     // Parse the account first so we don't generate a key if there's an error\n     string strAccount;\n     if (params.size() > 0)\n         strAccount = AccountFromValue(params[0]);\n \n-    if (!pwalletMain->IsLocked())\n-        pwalletMain->TopUpKeyPool();\n+    if (!Lightwallet::pwalletMain->IsLocked())\n+        Lightwallet::pwalletMain->TopUpKeyPool();\n \n     // Generate a new key that is added to wallet\n     CPubKey newKey;\n-    if (!pwalletMain->GetKeyFromPool(newKey))\n+    if (!Lightwallet::pwalletMain->GetKeyFromPool(newKey))\n         throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, \"Error: Keypool ran out, please call keypoolrefill first\");\n     CKeyID keyID = newKey.GetID();\n \n-    pwalletMain->SetAddressBook(keyID, strAccount, \"receive\");\n+    Lightwallet::pwalletMain->SetAddressBook(keyID, strAccount, \"receive\");\n \n     return CBitcoinAddress(keyID).ToString();\n }\n \n \n CBitcoinAddress GetAccountAddress(string strAccount, bool bForceNew=false)\n {\n-    CWalletDB walletdb(pwalletMain->strWalletFile);\n+    CWalletDB walletdb(Lightwallet::pwalletMain->strWalletFile);\n \n     CAccount account;\n     walletdb.ReadAccount(strAccount, account);\n@@ -163,8 +166,8 @@ CBitcoinAddress GetAccountAddress(string strAccount, bool bForceNew=false)\n         else {\n             // Check if the current key has been used\n             CScript scriptPubKey = GetScriptForDestination(account.vchPubKey.GetID());\n-            for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin();\n-                 it != pwalletMain->mapWallet.end() && account.vchPubKey.IsValid();\n+            for (map<uint256, CWalletTx>::iterator it = Lightwallet::pwalletMain->mapWallet.begin();\n+                 it != Lightwallet::pwalletMain->mapWallet.end() && account.vchPubKey.IsValid();\n                  ++it)\n                 BOOST_FOREACH(const CTxOut& txout, (*it).second.vout)\n                     if (txout.scriptPubKey == scriptPubKey) {\n@@ -176,10 +179,10 @@ CBitcoinAddress GetAccountAddress(string strAccount, bool bForceNew=false)\n \n     // Generate a new key\n     if (bForceNew) {\n-        if (!pwalletMain->GetKeyFromPool(account.vchPubKey))\n+        if (!Lightwallet::pwalletMain->GetKeyFromPool(account.vchPubKey))\n             throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, \"Error: Keypool ran out, please call keypoolrefill first\");\n \n-        pwalletMain->SetAddressBook(account.vchPubKey.GetID(), strAccount, \"receive\");\n+        Lightwallet::pwalletMain->SetAddressBook(account.vchPubKey.GetID(), strAccount, \"receive\");\n         walletdb.WriteAccount(strAccount, account);\n     }\n \n@@ -206,7 +209,7 @@ UniValue getaccountaddress(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"getaccountaddress\", \"\\\"myaccount\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     // Parse the account first so we don't generate a key if there's an error\n     string strAccount = AccountFromValue(params[0]);\n@@ -235,12 +238,12 @@ UniValue getrawchangeaddress(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"getrawchangeaddress\", \"\")\n        );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n-    if (!pwalletMain->IsLocked())\n-        pwalletMain->TopUpKeyPool();\n+    if (!Lightwallet::pwalletMain->IsLocked())\n+        Lightwallet::pwalletMain->TopUpKeyPool();\n \n-    CReserveKey reservekey(pwalletMain);\n+    CReserveKey reservekey(Lightwallet::pwalletMain);\n     CPubKey vchPubKey;\n     if (!reservekey.GetReservedKey(vchPubKey))\n         throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, \"Error: Keypool ran out, please call keypoolrefill first\");\n@@ -270,7 +273,7 @@ UniValue setaccount(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"setaccount\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\", \\\"tabby\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     CBitcoinAddress address(params[0].get_str());\n     if (!address.IsValid())\n@@ -281,16 +284,16 @@ UniValue setaccount(const UniValue& params, bool fHelp)\n         strAccount = AccountFromValue(params[1]);\n \n     // Only add the account if the address is yours.\n-    if (IsMine(*pwalletMain, address.Get()))\n+    if (IsMine(*Lightwallet::pwalletMain, address.Get()))\n     {\n         // Detect when changing the account of an address that is the 'unused current key' of another account:\n-        if (pwalletMain->mapAddressBook.count(address.Get()))\n+        if (Lightwallet::pwalletMain->mapAddressBook.count(address.Get()))\n         {\n-            string strOldAccount = pwalletMain->mapAddressBook[address.Get()].name;\n+            string strOldAccount = Lightwallet::pwalletMain->mapAddressBook[address.Get()].name;\n             if (address == GetAccountAddress(strOldAccount))\n                 GetAccountAddress(strOldAccount, true);\n         }\n-        pwalletMain->SetAddressBook(address.Get(), strAccount, \"receive\");\n+        Lightwallet::pwalletMain->SetAddressBook(address.Get(), strAccount, \"receive\");\n     }\n     else\n         throw JSONRPCError(RPC_MISC_ERROR, \"setaccount can only be used with own address\");\n@@ -317,15 +320,15 @@ UniValue getaccount(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"getaccount\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     CBitcoinAddress address(params[0].get_str());\n     if (!address.IsValid())\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n \n     string strAccount;\n-    map<CTxDestination, CAddressBookData>::iterator mi = pwalletMain->mapAddressBook.find(address.Get());\n-    if (mi != pwalletMain->mapAddressBook.end() && !(*mi).second.name.empty())\n+    map<CTxDestination, CAddressBookData>::iterator mi = Lightwallet::pwalletMain->mapAddressBook.find(address.Get());\n+    if (mi != Lightwallet::pwalletMain->mapAddressBook.end() && !(*mi).second.name.empty())\n         strAccount = (*mi).second.name;\n     return strAccount;\n }\n@@ -352,13 +355,13 @@ UniValue getaddressesbyaccount(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"getaddressesbyaccount\", \"\\\"tabby\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     string strAccount = AccountFromValue(params[0]);\n \n     // Find all addresses that have the given account\n     UniValue ret(UniValue::VARR);\n-    BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, CAddressBookData)& item, pwalletMain->mapAddressBook)\n+    BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, CAddressBookData)& item, Lightwallet::pwalletMain->mapAddressBook)\n     {\n         const CBitcoinAddress& address = item.first;\n         const string& strName = item.second.name;\n@@ -370,7 +373,7 @@ UniValue getaddressesbyaccount(const UniValue& params, bool fHelp)\n \n static void SendMoney(const CTxDestination &address, CAmount nValue, bool fSubtractFeeFromAmount, CWalletTx& wtxNew)\n {\n-    CAmount curBalance = pwalletMain->GetBalance();\n+    CAmount curBalance = Lightwallet::pwalletMain->GetBalance();\n \n     // Check amount\n     if (nValue <= 0)\n@@ -383,19 +386,19 @@ static void SendMoney(const CTxDestination &address, CAmount nValue, bool fSubtr\n     CScript scriptPubKey = GetScriptForDestination(address);\n \n     // Create and send the transaction\n-    CReserveKey reservekey(pwalletMain);\n+    CReserveKey reservekey(Lightwallet::pwalletMain);\n     CAmount nFeeRequired;\n     std::string strError;\n     vector<CRecipient> vecSend;\n     int nChangePosRet = -1;\n     CRecipient recipient = {scriptPubKey, nValue, fSubtractFeeFromAmount};\n     vecSend.push_back(recipient);\n-    if (!pwalletMain->CreateTransaction(vecSend, wtxNew, reservekey, nFeeRequired, nChangePosRet, strError)) {\n-        if (!fSubtractFeeFromAmount && nValue + nFeeRequired > pwalletMain->GetBalance())\n+    if (!Lightwallet::pwalletMain->CreateTransaction(vecSend, wtxNew, reservekey, nFeeRequired, nChangePosRet, strError)) {\n+        if (!fSubtractFeeFromAmount && nValue + nFeeRequired > Lightwallet::pwalletMain->GetBalance())\n             strError = strprintf(\"Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds!\", FormatMoney(nFeeRequired));\n         throw JSONRPCError(RPC_WALLET_ERROR, strError);\n     }\n-    if (!pwalletMain->CommitTransaction(wtxNew, reservekey))\n+    if (!Lightwallet::pwalletMain->CommitTransaction(wtxNew, reservekey))\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Error: The transaction was rejected! This might happen if some of the coins in your wallet were already spent, such as if you used a copy of the wallet and coins were spent in the copy but not marked as spent here.\");\n }\n \n@@ -428,7 +431,7 @@ UniValue sendtoaddress(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"sendtoaddress\", \"\\\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\\\", 0.1, \\\"donation\\\", \\\"seans outpost\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     CBitcoinAddress address(params[0].get_str());\n     if (!address.IsValid())\n@@ -485,11 +488,11 @@ UniValue listaddressgroupings(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"listaddressgroupings\", \"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     UniValue jsonGroupings(UniValue::VARR);\n-    map<CTxDestination, CAmount> balances = pwalletMain->GetAddressBalances();\n-    BOOST_FOREACH(set<CTxDestination> grouping, pwalletMain->GetAddressGroupings())\n+    map<CTxDestination, CAmount> balances = Lightwallet::pwalletMain->GetAddressBalances();\n+    BOOST_FOREACH(set<CTxDestination> grouping, Lightwallet::pwalletMain->GetAddressGroupings())\n     {\n         UniValue jsonGrouping(UniValue::VARR);\n         BOOST_FOREACH(CTxDestination address, grouping)\n@@ -498,8 +501,8 @@ UniValue listaddressgroupings(const UniValue& params, bool fHelp)\n             addressInfo.push_back(CBitcoinAddress(address).ToString());\n             addressInfo.push_back(ValueFromAmount(balances[address]));\n             {\n-                if (pwalletMain->mapAddressBook.find(CBitcoinAddress(address).Get()) != pwalletMain->mapAddressBook.end())\n-                    addressInfo.push_back(pwalletMain->mapAddressBook.find(CBitcoinAddress(address).Get())->second.name);\n+                if (Lightwallet::pwalletMain->mapAddressBook.find(CBitcoinAddress(address).Get()) != Lightwallet::pwalletMain->mapAddressBook.end())\n+                    addressInfo.push_back(Lightwallet::pwalletMain->mapAddressBook.find(CBitcoinAddress(address).Get())->second.name);\n             }\n             jsonGrouping.push_back(addressInfo);\n         }\n@@ -534,7 +537,7 @@ UniValue signmessage(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"signmessage\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\", \\\"my message\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     EnsureWalletIsUnlocked();\n \n@@ -550,7 +553,7 @@ UniValue signmessage(const UniValue& params, bool fHelp)\n         throw JSONRPCError(RPC_TYPE_ERROR, \"Address does not refer to key\");\n \n     CKey key;\n-    if (!pwalletMain->GetKey(keyID, key))\n+    if (!Lightwallet::pwalletMain->GetKey(keyID, key))\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Private key not available\");\n \n     CHashWriter ss(SER_GETHASH, 0);\n@@ -589,14 +592,14 @@ UniValue getreceivedbyaddress(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"getreceivedbyaddress\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\", 6\")\n        );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     // Bitcoin address\n     CBitcoinAddress address = CBitcoinAddress(params[0].get_str());\n     if (!address.IsValid())\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n     CScript scriptPubKey = GetScriptForDestination(address.Get());\n-    if (!IsMine(*pwalletMain,scriptPubKey))\n+    if (!IsMine(*Lightwallet::pwalletMain,scriptPubKey))\n         return (double)0.0;\n \n     // Minimum confirmations\n@@ -606,7 +609,7 @@ UniValue getreceivedbyaddress(const UniValue& params, bool fHelp)\n \n     // Tally\n     CAmount nAmount = 0;\n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n+    for (map<uint256, CWalletTx>::iterator it = Lightwallet::pwalletMain->mapWallet.begin(); it != Lightwallet::pwalletMain->mapWallet.end(); ++it)\n     {\n         const CWalletTx& wtx = (*it).second;\n         if (wtx.IsCoinBase() || !CheckFinalTx(wtx))\n@@ -647,7 +650,7 @@ UniValue getreceivedbyaccount(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"getreceivedbyaccount\", \"\\\"tabby\\\", 6\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     // Minimum confirmations\n     int nMinDepth = 1;\n@@ -656,11 +659,11 @@ UniValue getreceivedbyaccount(const UniValue& params, bool fHelp)\n \n     // Get the set of pub keys assigned to account\n     string strAccount = AccountFromValue(params[0]);\n-    set<CTxDestination> setAddress = pwalletMain->GetAccountAddresses(strAccount);\n+    set<CTxDestination> setAddress = Lightwallet::pwalletMain->GetAccountAddresses(strAccount);\n \n     // Tally\n     CAmount nAmount = 0;\n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n+    for (map<uint256, CWalletTx>::iterator it = Lightwallet::pwalletMain->mapWallet.begin(); it != Lightwallet::pwalletMain->mapWallet.end(); ++it)\n     {\n         const CWalletTx& wtx = (*it).second;\n         if (wtx.IsCoinBase() || !CheckFinalTx(wtx))\n@@ -669,7 +672,7 @@ UniValue getreceivedbyaccount(const UniValue& params, bool fHelp)\n         BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n         {\n             CTxDestination address;\n-            if (ExtractDestination(txout.scriptPubKey, address) && IsMine(*pwalletMain, address) && setAddress.count(address))\n+            if (ExtractDestination(txout.scriptPubKey, address) && IsMine(*Lightwallet::pwalletMain, address) && setAddress.count(address))\n                 if (wtx.GetDepthInMainChain() >= nMinDepth)\n                     nAmount += txout.nValue;\n         }\n@@ -684,7 +687,7 @@ CAmount GetAccountBalance(CWalletDB& walletdb, const string& strAccount, int nMi\n     CAmount nBalance = 0;\n \n     // Tally wallet transactions\n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n+    for (map<uint256, CWalletTx>::iterator it = Lightwallet::pwalletMain->mapWallet.begin(); it != Lightwallet::pwalletMain->mapWallet.end(); ++it)\n     {\n         const CWalletTx& wtx = (*it).second;\n         if (!CheckFinalTx(wtx) || wtx.GetBlocksToMaturity() > 0 || wtx.GetDepthInMainChain() < 0)\n@@ -706,7 +709,7 @@ CAmount GetAccountBalance(CWalletDB& walletdb, const string& strAccount, int nMi\n \n CAmount GetAccountBalance(const string& strAccount, int nMinDepth, const isminefilter& filter)\n {\n-    CWalletDB walletdb(pwalletMain->strWalletFile);\n+    CWalletDB walletdb(Lightwallet::pwalletMain->strWalletFile);\n     return GetAccountBalance(walletdb, strAccount, nMinDepth, filter);\n }\n \n@@ -738,10 +741,10 @@ UniValue getbalance(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"getbalance\", \"\\\"*\\\", 6\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     if (params.size() == 0)\n-        return  ValueFromAmount(pwalletMain->GetBalance());\n+        return  ValueFromAmount(Lightwallet::pwalletMain->GetBalance());\n \n     int nMinDepth = 1;\n     if (params.size() > 1)\n@@ -756,7 +759,7 @@ UniValue getbalance(const UniValue& params, bool fHelp)\n         // (GetBalance() sums up all unspent TxOuts)\n         // getbalance and \"getbalance * 1 true\" should return the same number\n         CAmount nBalance = 0;\n-        for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n+        for (map<uint256, CWalletTx>::iterator it = Lightwallet::pwalletMain->mapWallet.begin(); it != Lightwallet::pwalletMain->mapWallet.end(); ++it)\n         {\n             const CWalletTx& wtx = (*it).second;\n             if (!CheckFinalTx(wtx) || wtx.GetBlocksToMaturity() > 0 || wtx.GetDepthInMainChain() < 0)\n@@ -796,9 +799,9 @@ UniValue getunconfirmedbalance(const UniValue &params, bool fHelp)\n                 \"getunconfirmedbalance\\n\"\n                 \"Returns the server's total unconfirmed balance\\n\");\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n-    return ValueFromAmount(pwalletMain->GetUnconfirmedBalance());\n+    return ValueFromAmount(Lightwallet::pwalletMain->GetUnconfirmedBalance());\n }\n \n \n@@ -828,7 +831,7 @@ UniValue movecmd(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"move\", \"\\\"timotei\\\", \\\"akiko\\\", 0.01, 6, \\\"happy birthday!\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     string strFrom = AccountFromValue(params[0]);\n     string strTo = AccountFromValue(params[1]);\n@@ -842,31 +845,31 @@ UniValue movecmd(const UniValue& params, bool fHelp)\n     if (params.size() > 4)\n         strComment = params[4].get_str();\n \n-    CWalletDB walletdb(pwalletMain->strWalletFile);\n+    CWalletDB walletdb(Lightwallet::pwalletMain->strWalletFile);\n     if (!walletdb.TxnBegin())\n         throw JSONRPCError(RPC_DATABASE_ERROR, \"database error\");\n \n     int64_t nNow = GetAdjustedTime();\n \n     // Debit\n     CAccountingEntry debit;\n-    debit.nOrderPos = pwalletMain->IncOrderPosNext(&walletdb);\n+    debit.nOrderPos = Lightwallet::pwalletMain->IncOrderPosNext(&walletdb);\n     debit.strAccount = strFrom;\n     debit.nCreditDebit = -nAmount;\n     debit.nTime = nNow;\n     debit.strOtherAccount = strTo;\n     debit.strComment = strComment;\n-    pwalletMain->AddAccountingEntry(debit, walletdb);\n+    Lightwallet::pwalletMain->AddAccountingEntry(debit, walletdb);\n \n     // Credit\n     CAccountingEntry credit;\n-    credit.nOrderPos = pwalletMain->IncOrderPosNext(&walletdb);\n+    credit.nOrderPos = Lightwallet::pwalletMain->IncOrderPosNext(&walletdb);\n     credit.strAccount = strTo;\n     credit.nCreditDebit = nAmount;\n     credit.nTime = nNow;\n     credit.strOtherAccount = strFrom;\n     credit.strComment = strComment;\n-    pwalletMain->AddAccountingEntry(credit, walletdb);\n+    Lightwallet::pwalletMain->AddAccountingEntry(credit, walletdb);\n \n     if (!walletdb.TxnCommit())\n         throw JSONRPCError(RPC_DATABASE_ERROR, \"database error\");\n@@ -906,7 +909,7 @@ UniValue sendfrom(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"sendfrom\", \"\\\"tabby\\\", \\\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\\\", 0.01, 6, \\\"donation\\\", \\\"seans outpost\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     string strAccount = AccountFromValue(params[0]);\n     CBitcoinAddress address(params[1].get_str());\n@@ -980,7 +983,7 @@ UniValue sendmany(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"sendmany\", \"\\\"\\\", \\\"{\\\\\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\\\\\":0.01,\\\\\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\\\\\":0.02}\\\", 6, \\\"testing\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     string strAccount = AccountFromValue(params[0]);\n     UniValue sendTo = params[1].get_obj();\n@@ -1037,22 +1040,19 @@ UniValue sendmany(const UniValue& params, bool fHelp)\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Account has insufficient funds\");\n \n     // Send\n-    CReserveKey keyChange(pwalletMain);\n+    CReserveKey keyChange(Lightwallet::pwalletMain);\n     CAmount nFeeRequired = 0;\n     int nChangePosRet = -1;\n     string strFailReason;\n-    bool fCreated = pwalletMain->CreateTransaction(vecSend, wtx, keyChange, nFeeRequired, nChangePosRet, strFailReason);\n+    bool fCreated = Lightwallet::pwalletMain->CreateTransaction(vecSend, wtx, keyChange, nFeeRequired, nChangePosRet, strFailReason);\n     if (!fCreated)\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, strFailReason);\n-    if (!pwalletMain->CommitTransaction(wtx, keyChange))\n+    if (!Lightwallet::pwalletMain->CommitTransaction(wtx, keyChange))\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Transaction commit failed\");\n \n     return wtx.GetHash().GetHex();\n }\n \n-// Defined in rpc/misc.cpp\n-extern CScript _createmultisig_redeemScript(const UniValue& params);\n-\n UniValue addmultisigaddress(const UniValue& params, bool fHelp)\n {\n     if (!EnsureWalletIsAvailable(fHelp))\n@@ -1086,7 +1086,7 @@ UniValue addmultisigaddress(const UniValue& params, bool fHelp)\n         throw runtime_error(msg);\n     }\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     string strAccount;\n     if (params.size() > 2)\n@@ -1095,9 +1095,9 @@ UniValue addmultisigaddress(const UniValue& params, bool fHelp)\n     // Construct using pay-to-script-hash:\n     CScript inner = _createmultisig_redeemScript(params);\n     CScriptID innerID(inner);\n-    pwalletMain->AddCScript(inner);\n+    Lightwallet::pwalletMain->AddCScript(inner);\n \n-    pwalletMain->SetAddressBook(innerID, strAccount, \"send\");\n+    Lightwallet::pwalletMain->SetAddressBook(innerID, strAccount, \"send\");\n     return CBitcoinAddress(innerID).ToString();\n }\n \n@@ -1135,7 +1135,7 @@ UniValue ListReceived(const UniValue& params, bool fByAccounts)\n \n     // Tally\n     map<CBitcoinAddress, tallyitem> mapTally;\n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n+    for (map<uint256, CWalletTx>::iterator it = Lightwallet::pwalletMain->mapWallet.begin(); it != Lightwallet::pwalletMain->mapWallet.end(); ++it)\n     {\n         const CWalletTx& wtx = (*it).second;\n \n@@ -1152,7 +1152,7 @@ UniValue ListReceived(const UniValue& params, bool fByAccounts)\n             if (!ExtractDestination(txout.scriptPubKey, address))\n                 continue;\n \n-            isminefilter mine = IsMine(*pwalletMain, address);\n+            isminefilter mine = IsMine(*Lightwallet::pwalletMain, address);\n             if(!(mine & filter))\n                 continue;\n \n@@ -1168,7 +1168,7 @@ UniValue ListReceived(const UniValue& params, bool fByAccounts)\n     // Reply\n     UniValue ret(UniValue::VARR);\n     map<string, tallyitem> mapAccountTally;\n-    BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, CAddressBookData)& item, pwalletMain->mapAddressBook)\n+    BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, CAddressBookData)& item, Lightwallet::pwalletMain->mapAddressBook)\n     {\n         const CBitcoinAddress& address = item.first;\n         const string& strAccount = item.second.name;\n@@ -1269,7 +1269,7 @@ UniValue listreceivedbyaddress(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"listreceivedbyaddress\", \"6, true, true\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     return ListReceived(params, false);\n }\n@@ -1306,7 +1306,7 @@ UniValue listreceivedbyaccount(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"listreceivedbyaccount\", \"6, true, true\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     return ListReceived(params, true);\n }\n@@ -1336,14 +1336,14 @@ void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDe\n         BOOST_FOREACH(const COutputEntry& s, listSent)\n         {\n             UniValue entry(UniValue::VOBJ);\n-            if(involvesWatchonly || (Lightwallet::IsMine(*pwalletMain, s.destination) & ISMINE_WATCH_ONLY))\n+            if(involvesWatchonly || (Lightwallet::IsMine(*Lightwallet::pwalletMain, s.destination) & ISMINE_WATCH_ONLY))\n                 entry.push_back(Pair(\"involvesWatchonly\", true));\n             entry.push_back(Pair(\"account\", strSentAccount));\n             MaybePushAddress(entry, s.destination);\n             entry.push_back(Pair(\"category\", \"send\"));\n             entry.push_back(Pair(\"amount\", ValueFromAmount(-s.amount)));\n-            if (pwalletMain->mapAddressBook.count(s.destination))\n-                entry.push_back(Pair(\"label\", pwalletMain->mapAddressBook[s.destination].name));\n+            if (Lightwallet::pwalletMain->mapAddressBook.count(s.destination))\n+                entry.push_back(Pair(\"label\", Lightwallet::pwalletMain->mapAddressBook[s.destination].name));\n             entry.push_back(Pair(\"vout\", s.vout));\n             entry.push_back(Pair(\"fee\", ValueFromAmount(-nFee)));\n             if (fLong)\n@@ -1359,12 +1359,12 @@ void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDe\n         BOOST_FOREACH(const COutputEntry& r, listReceived)\n         {\n             string account;\n-            if (pwalletMain->mapAddressBook.count(r.destination))\n-                account = pwalletMain->mapAddressBook[r.destination].name;\n+            if (Lightwallet::pwalletMain->mapAddressBook.count(r.destination))\n+                account = Lightwallet::pwalletMain->mapAddressBook[r.destination].name;\n             if (fAllAccounts || (account == strAccount))\n             {\n                 UniValue entry(UniValue::VOBJ);\n-                if(involvesWatchonly || (Lightwallet::IsMine(*pwalletMain, r.destination) & ISMINE_WATCH_ONLY))\n+                if(involvesWatchonly || (Lightwallet::IsMine(*Lightwallet::pwalletMain, r.destination) & ISMINE_WATCH_ONLY))\n                     entry.push_back(Pair(\"involvesWatchonly\", true));\n                 entry.push_back(Pair(\"account\", account));\n                 MaybePushAddress(entry, r.destination);\n@@ -1382,7 +1382,7 @@ void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDe\n                     entry.push_back(Pair(\"category\", \"receive\"));\n                 }\n                 entry.push_back(Pair(\"amount\", ValueFromAmount(r.amount)));\n-                if (pwalletMain->mapAddressBook.count(r.destination))\n+                if (Lightwallet::pwalletMain->mapAddressBook.count(r.destination))\n                     entry.push_back(Pair(\"label\", account));\n                 entry.push_back(Pair(\"vout\", r.vout));\n                 if (fLong)\n@@ -1474,7 +1474,7 @@ UniValue listtransactions(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"listtransactions\", \"\\\"*\\\", 20, 100\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     string strAccount = \"*\";\n     if (params.size() > 0)\n@@ -1497,7 +1497,7 @@ UniValue listtransactions(const UniValue& params, bool fHelp)\n \n     UniValue ret(UniValue::VARR);\n \n-    const CWallet::TxItems & txOrdered = pwalletMain->wtxOrdered;\n+    const CWallet::TxItems & txOrdered = Lightwallet::pwalletMain->wtxOrdered;\n \n     // iterate backwards until we have nCount items to return:\n     for (CWallet::TxItems::const_reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n@@ -1565,7 +1565,7 @@ UniValue listaccounts(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"listaccounts\", \"6\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     int nMinDepth = 1;\n     if (params.size() > 0)\n@@ -1576,12 +1576,12 @@ UniValue listaccounts(const UniValue& params, bool fHelp)\n             includeWatchonly = includeWatchonly | ISMINE_WATCH_ONLY;\n \n     map<string, CAmount> mapAccountBalances;\n-    BOOST_FOREACH(const PAIRTYPE(CTxDestination, CAddressBookData)& entry, pwalletMain->mapAddressBook) {\n-        if (IsMine(*pwalletMain, entry.first) & includeWatchonly) // This address belongs to me\n+    BOOST_FOREACH(const PAIRTYPE(CTxDestination, CAddressBookData)& entry, Lightwallet::pwalletMain->mapAddressBook) {\n+        if (IsMine(*Lightwallet::pwalletMain, entry.first) & includeWatchonly) // This address belongs to me\n             mapAccountBalances[entry.second.name] = 0;\n     }\n \n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n+    for (map<uint256, CWalletTx>::iterator it = Lightwallet::pwalletMain->mapWallet.begin(); it != Lightwallet::pwalletMain->mapWallet.end(); ++it)\n     {\n         const CWalletTx& wtx = (*it).second;\n         CAmount nFee;\n@@ -1598,14 +1598,14 @@ UniValue listaccounts(const UniValue& params, bool fHelp)\n         if (nDepth >= nMinDepth)\n         {\n             BOOST_FOREACH(const COutputEntry& r, listReceived)\n-                if (pwalletMain->mapAddressBook.count(r.destination))\n-                    mapAccountBalances[pwalletMain->mapAddressBook[r.destination].name] += r.amount;\n+                if (Lightwallet::pwalletMain->mapAddressBook.count(r.destination))\n+                    mapAccountBalances[Lightwallet::pwalletMain->mapAddressBook[r.destination].name] += r.amount;\n                 else\n                     mapAccountBalances[\"\"] += r.amount;\n         }\n     }\n \n-    const list<CAccountingEntry> & acentries = pwalletMain->laccentries;\n+    const list<CAccountingEntry> & acentries = Lightwallet::pwalletMain->laccentries;\n     BOOST_FOREACH(const CAccountingEntry& entry, acentries)\n         mapAccountBalances[entry.strAccount] += entry.nCreditDebit;\n \n@@ -1658,7 +1658,7 @@ UniValue listsinceblock(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"listsinceblock\", \"\\\"000000000000000bacf66f7497b7dc45ef753ee9a7d38571037cdb1a57f663ad\\\", 6\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     CBlockIndex *pindex = NULL;\n     int target_confirms = 1;\n@@ -1690,7 +1690,7 @@ UniValue listsinceblock(const UniValue& params, bool fHelp)\n \n     UniValue transactions(UniValue::VARR);\n \n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); it++)\n+    for (map<uint256, CWalletTx>::iterator it = Lightwallet::pwalletMain->mapWallet.begin(); it != Lightwallet::pwalletMain->mapWallet.end(); it++)\n     {\n         CWalletTx tx = (*it).second;\n \n@@ -1752,7 +1752,7 @@ UniValue gettransaction(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"gettransaction\", \"\\\"1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     uint256 hash;\n     hash.SetHex(params[0].get_str());\n@@ -1763,9 +1763,9 @@ UniValue gettransaction(const UniValue& params, bool fHelp)\n             filter = filter | ISMINE_WATCH_ONLY;\n \n     UniValue entry(UniValue::VOBJ);\n-    if (!pwalletMain->mapWallet.count(hash))\n+    if (!Lightwallet::pwalletMain->mapWallet.count(hash))\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n-    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+    const CWalletTx& wtx = Lightwallet::pwalletMain->mapWallet[hash];\n \n     CAmount nCredit = wtx.GetCredit(filter);\n     CAmount nDebit = wtx.GetDebit(filter);\n@@ -1809,14 +1809,14 @@ UniValue abandontransaction(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"abandontransaction\", \"\\\"1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     uint256 hash;\n     hash.SetHex(params[0].get_str());\n \n-    if (!pwalletMain->mapWallet.count(hash))\n+    if (!Lightwallet::pwalletMain->mapWallet.count(hash))\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n-    if (!pwalletMain->AbandonTransaction(hash))\n+    if (!Lightwallet::pwalletMain->AbandonTransaction(hash))\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction not eligible for abandonment\");\n \n     return NullUniValue;\n@@ -1839,10 +1839,10 @@ UniValue backupwallet(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"backupwallet\", \"\\\"backup.dat\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     string strDest = params[0].get_str();\n-    if (!BackupWallet(*pwalletMain, strDest))\n+    if (!BackupWallet(*Lightwallet::pwalletMain, strDest))\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Error: Wallet backup failed!\");\n \n     return NullUniValue;\n@@ -1866,7 +1866,7 @@ UniValue keypoolrefill(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"keypoolrefill\", \"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     // 0 is interpreted by TopUpKeyPool() as the default keypool size given by -keypool\n     unsigned int kpSize = 0;\n@@ -1877,9 +1877,9 @@ UniValue keypoolrefill(const UniValue& params, bool fHelp)\n     }\n \n     EnsureWalletIsUnlocked();\n-    pwalletMain->TopUpKeyPool(kpSize);\n+    Lightwallet::pwalletMain->TopUpKeyPool(kpSize);\n \n-    if (pwalletMain->GetKeyPoolSize() < kpSize)\n+    if (Lightwallet::pwalletMain->GetKeyPoolSize() < kpSize)\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Error refreshing keypool.\");\n \n     return NullUniValue;\n@@ -1898,7 +1898,7 @@ UniValue walletpassphrase(const UniValue& params, bool fHelp)\n     if (!EnsureWalletIsAvailable(fHelp))\n         return NullUniValue;\n \n-    if (pwalletMain->IsCrypted() && (fHelp || params.size() != 2))\n+    if (Lightwallet::pwalletMain->IsCrypted() && (fHelp || params.size() != 2))\n         throw runtime_error(\n             \"walletpassphrase \\\"passphrase\\\" timeout\\n\"\n             \"\\nStores the wallet decryption key in memory for 'timeout' seconds.\\n\"\n@@ -1918,11 +1918,11 @@ UniValue walletpassphrase(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"walletpassphrase\", \"\\\"my pass phrase\\\", 60\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     if (fHelp)\n         return true;\n-    if (!pwalletMain->IsCrypted())\n+    if (!Lightwallet::pwalletMain->IsCrypted())\n         throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an unencrypted wallet, but walletpassphrase was called.\");\n \n     // Note that the walletpassphrase is stored in params[0] which is not mlock()ed\n@@ -1934,20 +1934,20 @@ UniValue walletpassphrase(const UniValue& params, bool fHelp)\n \n     if (strWalletPass.length() > 0)\n     {\n-        if (!pwalletMain->Unlock(strWalletPass))\n+        if (!Lightwallet::pwalletMain->Unlock(strWalletPass))\n             throw JSONRPCError(RPC_WALLET_PASSPHRASE_INCORRECT, \"Error: The wallet passphrase entered was incorrect.\");\n     }\n     else\n         throw runtime_error(\n             \"walletpassphrase <passphrase> <timeout>\\n\"\n             \"Stores the wallet decryption key in memory for <timeout> seconds.\");\n \n-    pwalletMain->TopUpKeyPool();\n+    Lightwallet::pwalletMain->TopUpKeyPool();\n \n     int64_t nSleepTime = params[1].get_int64();\n     LOCK(cs_nWalletUnlockTime);\n     nWalletUnlockTime = GetTime() + nSleepTime;\n-    RPCRunLater(\"lockwallet\", boost::bind(LockWallet, pwalletMain), nSleepTime);\n+    RPCRunLater(\"lockwallet\", boost::bind(LockWallet, Lightwallet::pwalletMain), nSleepTime);\n \n     return NullUniValue;\n }\n@@ -1958,7 +1958,7 @@ UniValue walletpassphrasechange(const UniValue& params, bool fHelp)\n     if (!EnsureWalletIsAvailable(fHelp))\n         return NullUniValue;\n \n-    if (pwalletMain->IsCrypted() && (fHelp || params.size() != 2))\n+    if (Lightwallet::pwalletMain->IsCrypted() && (fHelp || params.size() != 2))\n         throw runtime_error(\n             \"walletpassphrasechange \\\"oldpassphrase\\\" \\\"newpassphrase\\\"\\n\"\n             \"\\nChanges the wallet passphrase from 'oldpassphrase' to 'newpassphrase'.\\n\"\n@@ -1970,11 +1970,11 @@ UniValue walletpassphrasechange(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"walletpassphrasechange\", \"\\\"old one\\\", \\\"new one\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     if (fHelp)\n         return true;\n-    if (!pwalletMain->IsCrypted())\n+    if (!Lightwallet::pwalletMain->IsCrypted())\n         throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an unencrypted wallet, but walletpassphrasechange was called.\");\n \n     // TODO: get rid of these .c_str() calls by implementing SecureString::operator=(std::string)\n@@ -1992,7 +1992,7 @@ UniValue walletpassphrasechange(const UniValue& params, bool fHelp)\n             \"walletpassphrasechange <oldpassphrase> <newpassphrase>\\n\"\n             \"Changes the wallet passphrase from <oldpassphrase> to <newpassphrase>.\");\n \n-    if (!pwalletMain->ChangeWalletPassphrase(strOldWalletPass, strNewWalletPass))\n+    if (!Lightwallet::pwalletMain->ChangeWalletPassphrase(strOldWalletPass, strNewWalletPass))\n         throw JSONRPCError(RPC_WALLET_PASSPHRASE_INCORRECT, \"Error: The wallet passphrase entered was incorrect.\");\n \n     return NullUniValue;\n@@ -2004,7 +2004,7 @@ UniValue walletlock(const UniValue& params, bool fHelp)\n     if (!EnsureWalletIsAvailable(fHelp))\n         return NullUniValue;\n \n-    if (pwalletMain->IsCrypted() && (fHelp || params.size() != 0))\n+    if (Lightwallet::pwalletMain->IsCrypted() && (fHelp || params.size() != 0))\n         throw runtime_error(\n             \"walletlock\\n\"\n             \"\\nRemoves the wallet encryption key from memory, locking the wallet.\\n\"\n@@ -2021,16 +2021,16 @@ UniValue walletlock(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"walletlock\", \"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     if (fHelp)\n         return true;\n-    if (!pwalletMain->IsCrypted())\n+    if (!Lightwallet::pwalletMain->IsCrypted())\n         throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an unencrypted wallet, but walletlock was called.\");\n \n     {\n         LOCK(cs_nWalletUnlockTime);\n-        pwalletMain->Lock();\n+        Lightwallet::pwalletMain->Lock();\n         nWalletUnlockTime = 0;\n     }\n \n@@ -2043,7 +2043,7 @@ UniValue encryptwallet(const UniValue& params, bool fHelp)\n     if (!EnsureWalletIsAvailable(fHelp))\n         return NullUniValue;\n \n-    if (!pwalletMain->IsCrypted() && (fHelp || params.size() != 1))\n+    if (!Lightwallet::pwalletMain->IsCrypted() && (fHelp || params.size() != 1))\n         throw runtime_error(\n             \"encryptwallet \\\"passphrase\\\"\\n\"\n             \"\\nEncrypts the wallet with 'passphrase'. This is for first time encryption.\\n\"\n@@ -2067,11 +2067,11 @@ UniValue encryptwallet(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"encryptwallet\", \"\\\"my pass phrase\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     if (fHelp)\n         return true;\n-    if (pwalletMain->IsCrypted())\n+    if (Lightwallet::pwalletMain->IsCrypted())\n         throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an encrypted wallet, but encryptwallet was called.\");\n \n     // TODO: get rid of this .c_str() by implementing SecureString::operator=(std::string)\n@@ -2085,7 +2085,7 @@ UniValue encryptwallet(const UniValue& params, bool fHelp)\n             \"encryptwallet <passphrase>\\n\"\n             \"Encrypts the wallet with <passphrase>.\");\n \n-    if (!pwalletMain->EncryptWallet(strWalletPass))\n+    if (!Lightwallet::pwalletMain->EncryptWallet(strWalletPass))\n         throw JSONRPCError(RPC_WALLET_ENCRYPTION_FAILED, \"Error: Failed to encrypt the wallet.\");\n \n     // BDB seems to have a bad habit of writing old data into\n@@ -2137,7 +2137,7 @@ UniValue lockunspent(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"lockunspent\", \"false, \\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"a08e6907dbbd3d809776dbfc5d82e371b764ed838b5655e72f463568df1aadf0\\\\\\\",\\\\\\\"vout\\\\\\\":1}]\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     if (params.size() == 1)\n         RPCTypeCheck(params, boost::assign::list_of(UniValue::VBOOL));\n@@ -2148,7 +2148,7 @@ UniValue lockunspent(const UniValue& params, bool fHelp)\n \n     if (params.size() == 1) {\n         if (fUnlock)\n-            pwalletMain->UnlockAllCoins();\n+            Lightwallet::pwalletMain->UnlockAllCoins();\n         return true;\n     }\n \n@@ -2172,9 +2172,9 @@ UniValue lockunspent(const UniValue& params, bool fHelp)\n         COutPoint outpt(uint256S(txid), nOutput);\n \n         if (fUnlock)\n-            pwalletMain->UnlockCoin(outpt);\n+            Lightwallet::pwalletMain->UnlockCoin(outpt);\n         else\n-            pwalletMain->LockCoin(outpt);\n+            Lightwallet::pwalletMain->LockCoin(outpt);\n     }\n \n     return true;\n@@ -2211,10 +2211,10 @@ UniValue listlockunspent(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"listlockunspent\", \"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     vector<COutPoint> vOutpts;\n-    pwalletMain->ListLockedCoins(vOutpts);\n+    Lightwallet::pwalletMain->ListLockedCoins(vOutpts);\n \n     UniValue ret(UniValue::VARR);\n \n@@ -2247,7 +2247,7 @@ UniValue settxfee(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"settxfee\", \"0.00001\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     // Amount\n     CAmount nAmount = AmountFromValue(params[0]);\n@@ -2282,17 +2282,17 @@ UniValue getwalletinfo(const UniValue& params, bool fHelp)\n             + HelpExampleRpc(\"getwalletinfo\", \"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n     UniValue obj(UniValue::VOBJ);\n-    obj.push_back(Pair(\"walletversion\", pwalletMain->GetVersion()));\n-    obj.push_back(Pair(\"balance\",       ValueFromAmount(pwalletMain->GetBalance())));\n-    obj.push_back(Pair(\"unconfirmed_balance\", ValueFromAmount(pwalletMain->GetUnconfirmedBalance())));\n-    obj.push_back(Pair(\"immature_balance\",    ValueFromAmount(pwalletMain->GetImmatureBalance())));\n-    obj.push_back(Pair(\"txcount\",       (int)pwalletMain->mapWallet.size()));\n-    obj.push_back(Pair(\"keypoololdest\", pwalletMain->GetOldestKeyPoolTime()));\n-    obj.push_back(Pair(\"keypoolsize\",   (int)pwalletMain->GetKeyPoolSize()));\n-    if (pwalletMain->IsCrypted())\n+    obj.push_back(Pair(\"walletversion\", Lightwallet::pwalletMain->GetVersion()));\n+    obj.push_back(Pair(\"balance\",       ValueFromAmount(Lightwallet::pwalletMain->GetBalance())));\n+    obj.push_back(Pair(\"unconfirmed_balance\", ValueFromAmount(Lightwallet::pwalletMain->GetUnconfirmedBalance())));\n+    obj.push_back(Pair(\"immature_balance\",    ValueFromAmount(Lightwallet::pwalletMain->GetImmatureBalance())));\n+    obj.push_back(Pair(\"txcount\",       (int)Lightwallet::pwalletMain->mapWallet.size()));\n+    obj.push_back(Pair(\"keypoololdest\", Lightwallet::pwalletMain->GetOldestKeyPoolTime()));\n+    obj.push_back(Pair(\"keypoolsize\",   (int)Lightwallet::pwalletMain->GetKeyPoolSize()));\n+    if (Lightwallet::pwalletMain->IsCrypted())\n         obj.push_back(Pair(\"unlocked_until\", nWalletUnlockTime));\n     obj.push_back(Pair(\"paytxfee\",      ValueFromAmount(payTxFee.GetFeePerK())));\n     return obj;\n@@ -2312,9 +2312,9 @@ UniValue resendwallettransactions(const UniValue& params, bool fHelp)\n             \"Returns array of transaction ids that were re-broadcast.\\n\"\n             );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n-    std::vector<uint256> txids = pwalletMain->ResendWalletTransactionsBefore(GetTime());\n+    std::vector<uint256> txids = Lightwallet::pwalletMain->ResendWalletTransactionsBefore(GetTime());\n     UniValue result(UniValue::VARR);\n     BOOST_FOREACH(const uint256& txid, txids)\n     {\n@@ -2390,9 +2390,9 @@ UniValue listunspent(const UniValue& params, bool fHelp)\n \n     UniValue results(UniValue::VARR);\n     vector<COutput> vecOutputs;\n-    assert(pwalletMain != NULL);\n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n-    pwalletMain->AvailableCoins(vecOutputs, false, NULL, true);\n+    assert(Lightwallet::pwalletMain != NULL);\n+    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n+    Lightwallet::pwalletMain->AvailableCoins(vecOutputs, false, NULL, true);\n     BOOST_FOREACH(const COutput& out, vecOutputs) {\n         if (out.nDepth < nMinDepth || out.nDepth > nMaxDepth)\n             continue;\n@@ -2414,16 +2414,16 @@ UniValue listunspent(const UniValue& params, bool fHelp)\n         CTxDestination address;\n         if (ExtractDestination(out.tx->vout[out.i].scriptPubKey, address)) {\n             entry.push_back(Pair(\"address\", CBitcoinAddress(address).ToString()));\n-            if (pwalletMain->mapAddressBook.count(address))\n-                entry.push_back(Pair(\"account\", pwalletMain->mapAddressBook[address].name));\n+            if (Lightwallet::pwalletMain->mapAddressBook.count(address))\n+                entry.push_back(Pair(\"account\", Lightwallet::pwalletMain->mapAddressBook[address].name));\n         }\n         entry.push_back(Pair(\"scriptPubKey\", HexStr(pk.begin(), pk.end())));\n         if (pk.IsPayToScriptHash()) {\n             CTxDestination address;\n             if (ExtractDestination(pk, address)) {\n                 const CScriptID& hash = boost::get<CScriptID>(address);\n                 CScript redeemScript;\n-                if (pwalletMain->GetCScript(hash, redeemScript))\n+                if (Lightwallet::pwalletMain->GetCScript(hash, redeemScript))\n                     entry.push_back(Pair(\"redeemScript\", HexStr(redeemScript.begin(), redeemScript.end())));\n             }\n         }\n@@ -2491,7 +2491,7 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     CAmount nFee;\n     string strFailReason;\n     int nChangePos = -1;\n-    if(!pwalletMain->FundTransaction(tx, nFee, nChangePos, strFailReason, includeWatching))\n+    if(!Lightwallet::pwalletMain->FundTransaction(tx, nFee, nChangePos, strFailReason, includeWatching))\n         throw JSONRPCError(RPC_INTERNAL_ERROR, strFailReason);\n \n     UniValue result(UniValue::VOBJ);\n@@ -2512,53 +2512,53 @@ extern UniValue importprunedfunds(const UniValue& params, bool fHelp);\n extern UniValue removeprunedfunds(const UniValue& params, bool fHelp);\n \n static const CRPCCommand commands[] =\n-{ //  category              name                        actor (function)           okSafeMode\n-    //  --------------------- ------------------------    -----------------------    ----------\n-    { \"rawtransactions\",    \"fundrawtransaction\",       &fundrawtransaction,       false },\n-    { \"hidden\",             \"resendwallettransactions\", &resendwallettransactions, true  },\n-    { \"wallet\",             \"abandontransaction\",       &abandontransaction,       false },\n-    { \"wallet\",             \"addmultisigaddress\",       &addmultisigaddress,       true  },\n-    { \"wallet\",             \"backupwallet\",             &backupwallet,             true  },\n-    { \"wallet\",             \"dumpprivkey\",              &dumpprivkey,              true  },\n-    { \"wallet\",             \"dumpwallet\",               &dumpwallet,               true  },\n-    { \"wallet\",             \"encryptwallet\",            &encryptwallet,            true  },\n-    { \"wallet\",             \"getaccountaddress\",        &getaccountaddress,        true  },\n-    { \"wallet\",             \"getaccount\",               &getaccount,               true  },\n-    { \"wallet\",             \"getaddressesbyaccount\",    &getaddressesbyaccount,    true  },\n-    { \"wallet\",             \"getbalance\",               &getbalance,               false },\n-    { \"wallet\",             \"getnewaddress\",            &getnewaddress,            true  },\n-    { \"wallet\",             \"getrawchangeaddress\",      &getrawchangeaddress,      true  },\n-    { \"wallet\",             \"getreceivedbyaccount\",     &getreceivedbyaccount,     false },\n-    { \"wallet\",             \"getreceivedbyaddress\",     &getreceivedbyaddress,     false },\n-    { \"wallet\",             \"gettransaction\",           &gettransaction,           false },\n-    { \"wallet\",             \"getunconfirmedbalance\",    &getunconfirmedbalance,    false },\n-    { \"wallet\",             \"getwalletinfo\",            &getwalletinfo,            false },\n-    { \"wallet\",             \"importprivkey\",            &importprivkey,            true  },\n-    { \"wallet\",             \"importwallet\",             &importwallet,             true  },\n-    { \"wallet\",             \"importaddress\",            &importaddress,            true  },\n-    { \"wallet\",             \"importprunedfunds\",        &importprunedfunds,        true  },\n-    { \"wallet\",             \"importpubkey\",             &importpubkey,             true  },\n-    { \"wallet\",             \"keypoolrefill\",            &keypoolrefill,            true  },\n-    { \"wallet\",             \"listaccounts\",             &listaccounts,             false },\n-    { \"wallet\",             \"listaddressgroupings\",     &listaddressgroupings,     false },\n-    { \"wallet\",             \"listlockunspent\",          &listlockunspent,          false },\n-    { \"wallet\",             \"listreceivedbyaccount\",    &listreceivedbyaccount,    false },\n-    { \"wallet\",             \"listreceivedbyaddress\",    &listreceivedbyaddress,    false },\n-    { \"wallet\",             \"listsinceblock\",           &listsinceblock,           false },\n-    { \"wallet\",             \"listtransactions\",         &listtransactions,         false },\n-    { \"wallet\",             \"listunspent\",              &listunspent,              false },\n-    { \"wallet\",             \"lockunspent\",              &lockunspent,              true  },\n-    { \"wallet\",             \"move\",                     &movecmd,                  false },\n-    { \"wallet\",             \"sendfrom\",                 &sendfrom,                 false },\n-    { \"wallet\",             \"sendmany\",                 &sendmany,                 false },\n-    { \"wallet\",             \"sendtoaddress\",            &sendtoaddress,            false },\n-    { \"wallet\",             \"setaccount\",               &setaccount,               true  },\n-    { \"wallet\",             \"settxfee\",                 &settxfee,                 true  },\n-    { \"wallet\",             \"signmessage\",              &signmessage,              true  },\n-    { \"wallet\",             \"walletlock\",               &walletlock,               true  },\n-    { \"wallet\",             \"walletpassphrasechange\",   &walletpassphrasechange,   true  },\n-    { \"wallet\",             \"walletpassphrase\",         &walletpassphrase,         true  },\n-    { \"wallet\",             \"removeprunedfunds\",        &removeprunedfunds,        true  },\n+{ //  category                   name                               actor (function)           okSafeMode\n+    //  ------------------------ ------------------------           -----------------------    ----------\n+    { \"rawtransactions\",         \"wallet_fundrawtransaction\",       &fundrawtransaction,       false },\n+    { \"hidden\",                  \"wallet_resendwallettransactions\", &resendwallettransactions, true  },\n+    { \"lightwallet\",             \"wallet_abandontransaction\",       &abandontransaction,       false },\n+    { \"lightwallet\",             \"wallet_addmultisigaddress\",       &addmultisigaddress,       true  },\n+    { \"lightwallet\",             \"wallet_backupwallet\",             &backupwallet,             true  },\n+    { \"lightwallet\",             \"wallet_dumpprivkey\",              &dumpprivkey,              true  },\n+    { \"lightwallet\",             \"wallet_dumpwallet\",               &dumpwallet,               true  },\n+    { \"lightwallet\",             \"wallet_encryptwallet\",            &encryptwallet,            true  },\n+    { \"lightwallet\",             \"wallet_getaccountaddress\",        &getaccountaddress,        true  },\n+    { \"lightwallet\",             \"wallet_getaccount\",               &getaccount,               true  },\n+    { \"lightwallet\",             \"wallet_getaddressesbyaccount\",    &getaddressesbyaccount,    true  },\n+    { \"lightwallet\",             \"wallet_getbalance\",               &getbalance,               false },\n+    { \"lightwallet\",             \"wallet_getnewaddress\",            &getnewaddress,            true  },\n+    { \"lightwallet\",             \"wallet_getrawchangeaddress\",      &getrawchangeaddress,      true  },\n+    { \"lightwallet\",             \"wallet_getreceivedbyaccount\",     &getreceivedbyaccount,     false },\n+    { \"lightwallet\",             \"wallet_getreceivedbyaddress\",     &getreceivedbyaddress,     false },\n+    { \"lightwallet\",             \"wallet_gettransaction\",           &gettransaction,           false },\n+    { \"lightwallet\",             \"wallet_getunconfirmedbalance\",    &getunconfirmedbalance,    false },\n+    { \"lightwallet\",             \"wallet_getwalletinfo\",            &getwalletinfo,            false },\n+    { \"lightwallet\",             \"wallet_importprivkey\",            &importprivkey,            true  },\n+    { \"lightwallet\",             \"wallet_importwallet\",             &importwallet,             true  },\n+    { \"lightwallet\",             \"wallet_importaddress\",            &importaddress,            true  },\n+    { \"lightwallet\",             \"wallet_importprunedfunds\",        &importprunedfunds,        true  },\n+    { \"lightwallet\",             \"wallet_importpubkey\",             &importpubkey,             true  },\n+    { \"lightwallet\",             \"wallet_keypoolrefill\",            &keypoolrefill,            true  },\n+    { \"lightwallet\",             \"wallet_listaccounts\",             &listaccounts,             false },\n+    { \"lightwallet\",             \"wallet_listaddressgroupings\",     &listaddressgroupings,     false },\n+    { \"lightwallet\",             \"wallet_listlockunspent\",          &listlockunspent,          false },\n+    { \"lightwallet\",             \"wallet_listreceivedbyaccount\",    &listreceivedbyaccount,    false },\n+    { \"lightwallet\",             \"wallet_listreceivedbyaddress\",    &listreceivedbyaddress,    false },\n+    { \"lightwallet\",             \"wallet_listsinceblock\",           &listsinceblock,           false },\n+    { \"lightwallet\",             \"wallet_listtransactions\",         &listtransactions,         false },\n+    { \"lightwallet\",             \"wallet_listunspent\",              &listunspent,              false },\n+    { \"lightwallet\",             \"wallet_lockunspent\",              &lockunspent,              true  },\n+    { \"lightwallet\",             \"wallet_move\",                     &movecmd,                  false },\n+    { \"lightwallet\",             \"wallet_sendfrom\",                 &sendfrom,                 false },\n+    { \"lightwallet\",             \"wallet_sendmany\",                 &sendmany,                 false },\n+    { \"lightwallet\",             \"wallet_sendtoaddress\",            &sendtoaddress,            false },\n+    { \"lightwallet\",             \"wallet_setaccount\",               &setaccount,               true  },\n+    { \"lightwallet\",             \"wallet_settxfee\",                 &settxfee,                 true  },\n+    { \"lightwallet\",             \"wallet_signmessage\",              &signmessage,              true  },\n+    { \"lightwallet\",             \"wallet_walletlock\",               &walletlock,               true  },\n+    { \"lightwallet\",             \"wallet_walletpassphrasechange\",   &walletpassphrasechange,   true  },\n+    { \"lightwallet\",             \"wallet_walletpassphrase\",         &walletpassphrase,         true  },\n+    { \"lightwallet\",             \"wallet_removeprunedfunds\",        &removeprunedfunds,        true  },\n };\n \n void RegisterWalletRPCCommands(CRPCTable &tableRPC)"
      },
      {
        "sha": "f2f88b7ea2d1e17906d45bf2cea42786a55eba64",
        "filename": "src/lightwallet/rpcwallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/25401239600e5f285424a165177e39f750faa974/src/lightwallet/rpcwallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/25401239600e5f285424a165177e39f750faa974/src/lightwallet/rpcwallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/rpcwallet.h?ref=25401239600e5f285424a165177e39f750faa974",
        "patch": "@@ -5,9 +5,8 @@\n #ifndef BITCOIN_LIGHTWALLET_RPCWALLET_H\n #define BITCOIN_LIGHTWALLET_RPCWALLET_H\n \n-namespace Lightwallet {\n class CRPCTable;\n-\n+namespace Lightwallet {\n void RegisterWalletRPCCommands(CRPCTable &tableRPC);\n }\n #endif //BITCOIN_LIGHTWALLET_RPCWALLET_H"
      },
      {
        "sha": "9aea7ae158c4d09075a0ec231bf9f4205c741ecd",
        "filename": "src/lightwallet/wallet.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/25401239600e5f285424a165177e39f750faa974/src/lightwallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/25401239600e5f285424a165177e39f750faa974/src/lightwallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/wallet.cpp?ref=25401239600e5f285424a165177e39f750faa974",
        "patch": "@@ -41,7 +41,7 @@ unsigned int nTxConfirmTarget = DEFAULT_TX_CONFIRM_TARGET;\n bool bSpendZeroConfChange = DEFAULT_SPEND_ZEROCONF_CHANGE;\n bool fSendFreeTransactions = DEFAULT_SEND_FREE_TRANSACTIONS;\n \n-const char * DEFAULT_WALLET_DAT = \"wallet.dat\";\n+const char * DEFAULT_WALLET_DAT = \"lightwallet.dat\";\n \n /**\n  * Fees smaller than this (in satoshi) are considered zero fee (for transaction creation)\n@@ -3008,7 +3008,7 @@ bool CWallet::GetDestData(const CTxDestination &dest, const std::string &key, st\n std::string CWallet::GetWalletHelpString(bool showDebug)\n {\n     std::string strUsage = HelpMessageGroup(_(\"LightWallet options:\"));\n-    strUsage += HelpMessageOpt(\"-disablewallet\", _(\"Do not load the wallet and disable wallet RPC calls\"));\n+    strUsage += HelpMessageOpt(\"-disablelightwallet\", _(\"Do not load the lightwallet and disable lightwallet RPC calls\"));\n     strUsage += HelpMessageOpt(\"-keypool=<n>\", strprintf(_(\"Set key pool size to <n> (default: %u)\"), DEFAULT_KEYPOOL_SIZE));\n     strUsage += HelpMessageOpt(\"-fallbackfee=<amt>\", strprintf(_(\"A fee rate (in %s/kB) that will be used when fee estimation has insufficient data (default: %s)\"),\n                                                                CURRENCY_UNIT, FormatMoney(DEFAULT_FALLBACK_FEE)));"
      }
    ]
  },
  {
    "sha": "9b9de57317eb47d1124de6df972076decdfceebd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YjlkZTU3MzE3ZWI0N2QxMTI0ZGU2ZGY5NzIwNzZkZWNkZmNlZWJk",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2016-04-07T08:31:26Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2016-04-13T08:49:16Z"
      },
      "message": "[LightWallet] remove accounts entirely",
      "tree": {
        "sha": "a3f71454d7710b7d242fa1bc4fb498189511e844",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a3f71454d7710b7d242fa1bc4fb498189511e844"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9b9de57317eb47d1124de6df972076decdfceebd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "expired_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXDggMAAoJECnUvLZBb1PsqhMQALpeFCuctnuGtTV7Y3PXV3qv\n5pJ9ZSXrQVLBHHvQ4Xjmtf21AeSMQbovOleQcRHO87ueLSXGYadeQ4pxK7FBvzcT\nJe+G5lNs03AcCF6olFUJw4Rl6ERQ2CBjdg15GQMvi3b4UiPlrQp2KvfCQm6x3fe8\naOr+mhqs5CWfKoEaBp/fPsF1dAn0KrTF6qfQFdhGFMEGSHEY0xaYZHIADt8zT75Z\n5p6SGhLRgU/GOpjL3mhJOw20dFj2AS8sIQPPdTwPIN+XOmvIkwTtiuCeFOgWaLLZ\nyWEaVh7B6TNTDGC2iAJjTdP3Dls8H9uwCM3gpP+07wXnkQSz0163drvFKP7Mlwfp\nZpQ6MI0vWBo5D6KV82EHM6tFoILL8n8xVv6yFgsRInQ5Ej+10m/6qCALtUD05EeZ\n/MVstYpIGpktGGPx9E8ekTsGfqUZA0TGWY7N+hsjoFUNBPXqYsh4N+rWUUOlVog1\npAP2fdSc7vLTiD/JrxxnAlTNxTF7iGOwr188thml1RxPuJ/4ZI9fTE1+kxGggDfj\nIqi4qNd6nloBf965GRZyGu/Y9hPdnwbB96c5rg3bmW9beVA/rNl9Ge8XTkQ0iIv8\nrdNVsyujpWXIXaWVPdQelTYrjpLDX/fl5TwhkTd4ix5KsEYjVnlSuquqNoIFbsj2\nBKVGG+dreQ8gTH6i1B1d\n=HrGs\n-----END PGP SIGNATURE-----",
        "payload": "tree a3f71454d7710b7d242fa1bc4fb498189511e844\nparent 25401239600e5f285424a165177e39f750faa974\nauthor Jonas Schnelli <dev@jonasschnelli.ch> 1460017886 +0200\ncommitter Jonas Schnelli <dev@jonasschnelli.ch> 1460537356 +0200\n\n[LightWallet] remove accounts entirely\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9b9de57317eb47d1124de6df972076decdfceebd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9b9de57317eb47d1124de6df972076decdfceebd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9b9de57317eb47d1124de6df972076decdfceebd/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "25401239600e5f285424a165177e39f750faa974",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/25401239600e5f285424a165177e39f750faa974",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/25401239600e5f285424a165177e39f750faa974"
      }
    ],
    "stats": {
      "total": 1402,
      "additions": 276,
      "deletions": 1126
    },
    "files": [
      {
        "sha": "9d40e5f05c6d0c037f47093dfe2def1ca0a1c18b",
        "filename": "src/lightwallet/rpcdump.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9b9de57317eb47d1124de6df972076decdfceebd/src/lightwallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9b9de57317eb47d1124de6df972076decdfceebd/src/lightwallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/rpcdump.cpp?ref=9b9de57317eb47d1124de6df972076decdfceebd",
        "patch": "@@ -604,7 +604,7 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)\n         CKey key;\n         if (pwalletMain->GetKey(keyid, key)) {\n             if (pwalletMain->mapAddressBook.count(keyid)) {\n-                file << strprintf(\"%s %s label=%s # addr=%s\\n\", CBitcoinSecret(key).ToString(), strTime, EncodeDumpString(pwalletMain->mapAddressBook[keyid].name), strAddr);\n+                file << strprintf(\"%s %s label=%s # addr=%s\\n\", CBitcoinSecret(key).ToString(), strTime, EncodeDumpString(pwalletMain->mapAddressBook[keyid].label), strAddr);\n             } else if (setKeyPool.count(keyid)) {\n                 file << strprintf(\"%s %s reserve=1 # addr=%s\\n\", CBitcoinSecret(key).ToString(), strTime, strAddr);\n             } else {"
      },
      {
        "sha": "e256adfd5bf905f3bfd097fca0cbf3887f6f416a",
        "filename": "src/lightwallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 240,
        "deletions": 760,
        "changes": 1000,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9b9de57317eb47d1124de6df972076decdfceebd/src/lightwallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9b9de57317eb47d1124de6df972076decdfceebd/src/lightwallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/rpcwallet.cpp?ref=9b9de57317eb47d1124de6df972076decdfceebd",
        "patch": "@@ -35,6 +35,16 @@ using namespace std;\n int64_t nWalletUnlockTime;\n static CCriticalSection cs_nWalletUnlockTime;\n \n+UniValue getObjFromParam(const UniValue &param)\n+{\n+    if (param.isStr())\n+    {\n+        UniValue newObj;\n+        newObj.read(param.get_str());\n+        return newObj;\n+    }\n+    return param;\n+}\n std::string HelpRequiringPassphrase()\n {\n     return Lightwallet::pwalletMain && Lightwallet::pwalletMain->IsCrypted()\n@@ -103,12 +113,12 @@ void WalletTxToJSON(const CWalletTx& wtx, UniValue& entry)\n         entry.push_back(Pair(item.first, item.second));\n }\n \n-string AccountFromValue(const UniValue& value)\n+string LabelFromValue(const UniValue& value)\n {\n-    string strAccount = value.get_str();\n-    if (strAccount == \"*\")\n-        throw JSONRPCError(RPC_WALLET_INVALID_ACCOUNT_NAME, \"Invalid account name\");\n-    return strAccount;\n+    string strLabel = value.get_str();\n+    if (strLabel == \"*\")\n+        throw JSONRPCError(RPC_WALLET_INVALID_ACCOUNT_NAME, \"Invalid label\");\n+    return strLabel;\n }\n \n UniValue getnewaddress(const UniValue& params, bool fHelp)\n@@ -118,12 +128,10 @@ UniValue getnewaddress(const UniValue& params, bool fHelp)\n \n     if (fHelp || params.size() > 1)\n         throw runtime_error(\n-            \"getnewaddress ( \\\"account\\\" )\\n\"\n+            \"getnewaddress ( \\\"label\\\" )\\n\"\n             \"\\nReturns a new Bitcoin address for receiving payments.\\n\"\n-            \"If 'account' is specified (DEPRECATED), it is added to the address book \\n\"\n-            \"so payments received with the address will be credited to 'account'.\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. \\\"account\\\"        (string, optional) DEPRECATED. The account name for the address to be linked to. If not provided, the default account \\\"\\\" is used. It can also be set to the empty string \\\"\\\" to represent the default account. The account does not need to exist, it will be created if there is no account by the given name.\\n\"\n+            \"1. \\\"label\\\"        (string, optional) The label for the address to be added to.\\n\"\n             \"\\nResult:\\n\"\n             \"\\\"bitcoinaddress\\\"    (string) The new bitcoin address\\n\"\n             \"\\nExamples:\\n\"\n@@ -133,10 +141,10 @@ UniValue getnewaddress(const UniValue& params, bool fHelp)\n \n     LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n-    // Parse the account first so we don't generate a key if there's an error\n-    string strAccount;\n+    // Parse the label first so we don't generate a key if there's an error\n+    string strLabel;\n     if (params.size() > 0)\n-        strAccount = AccountFromValue(params[0]);\n+        strLabel = LabelFromValue(params[0]);\n \n     if (!Lightwallet::pwalletMain->IsLocked())\n         Lightwallet::pwalletMain->TopUpKeyPool();\n@@ -147,80 +155,12 @@ UniValue getnewaddress(const UniValue& params, bool fHelp)\n         throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, \"Error: Keypool ran out, please call keypoolrefill first\");\n     CKeyID keyID = newKey.GetID();\n \n-    Lightwallet::pwalletMain->SetAddressBook(keyID, strAccount, \"receive\");\n+    Lightwallet::pwalletMain->SetAddressBook(keyID, strLabel, \"receive\");\n \n     return CBitcoinAddress(keyID).ToString();\n }\n \n \n-CBitcoinAddress GetAccountAddress(string strAccount, bool bForceNew=false)\n-{\n-    CWalletDB walletdb(Lightwallet::pwalletMain->strWalletFile);\n-\n-    CAccount account;\n-    walletdb.ReadAccount(strAccount, account);\n-\n-    if (!bForceNew) {\n-        if (!account.vchPubKey.IsValid())\n-            bForceNew = true;\n-        else {\n-            // Check if the current key has been used\n-            CScript scriptPubKey = GetScriptForDestination(account.vchPubKey.GetID());\n-            for (map<uint256, CWalletTx>::iterator it = Lightwallet::pwalletMain->mapWallet.begin();\n-                 it != Lightwallet::pwalletMain->mapWallet.end() && account.vchPubKey.IsValid();\n-                 ++it)\n-                BOOST_FOREACH(const CTxOut& txout, (*it).second.vout)\n-                    if (txout.scriptPubKey == scriptPubKey) {\n-                        bForceNew = true;\n-                        break;\n-                    }\n-        }\n-    }\n-\n-    // Generate a new key\n-    if (bForceNew) {\n-        if (!Lightwallet::pwalletMain->GetKeyFromPool(account.vchPubKey))\n-            throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, \"Error: Keypool ran out, please call keypoolrefill first\");\n-\n-        Lightwallet::pwalletMain->SetAddressBook(account.vchPubKey.GetID(), strAccount, \"receive\");\n-        walletdb.WriteAccount(strAccount, account);\n-    }\n-\n-    return CBitcoinAddress(account.vchPubKey.GetID());\n-}\n-\n-UniValue getaccountaddress(const UniValue& params, bool fHelp)\n-{\n-    if (!EnsureWalletIsAvailable(fHelp))\n-        return NullUniValue;\n-\n-    if (fHelp || params.size() != 1)\n-        throw runtime_error(\n-            \"getaccountaddress \\\"account\\\"\\n\"\n-            \"\\nDEPRECATED. Returns the current Bitcoin address for receiving payments to this account.\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"account\\\"       (string, required) The account name for the address. It can also be set to the empty string \\\"\\\" to represent the default account. The account does not need to exist, it will be created and a new address created  if there is no account by the given name.\\n\"\n-            \"\\nResult:\\n\"\n-            \"\\\"bitcoinaddress\\\"   (string) The account bitcoin address\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getaccountaddress\", \"\")\n-            + HelpExampleCli(\"getaccountaddress\", \"\\\"\\\"\")\n-            + HelpExampleCli(\"getaccountaddress\", \"\\\"myaccount\\\"\")\n-            + HelpExampleRpc(\"getaccountaddress\", \"\\\"myaccount\\\"\")\n-        );\n-\n-    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n-\n-    // Parse the account first so we don't generate a key if there's an error\n-    string strAccount = AccountFromValue(params[0]);\n-\n-    UniValue ret(UniValue::VSTR);\n-\n-    ret = GetAccountAddress(strAccount).ToString();\n-    return ret;\n-}\n-\n-\n UniValue getrawchangeaddress(const UniValue& params, bool fHelp)\n {\n     if (!EnsureWalletIsAvailable(fHelp))\n@@ -256,210 +196,129 @@ UniValue getrawchangeaddress(const UniValue& params, bool fHelp)\n }\n \n \n-UniValue setaccount(const UniValue& params, bool fHelp)\n+UniValue setlabel(const UniValue& params, bool fHelp)\n {\n     if (!EnsureWalletIsAvailable(fHelp))\n         return NullUniValue;\n \n     if (fHelp || params.size() < 1 || params.size() > 2)\n         throw runtime_error(\n-            \"setaccount \\\"bitcoinaddress\\\" \\\"account\\\"\\n\"\n-            \"\\nDEPRECATED. Sets the account associated with the given address.\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"bitcoinaddress\\\"  (string, required) The bitcoin address to be associated with an account.\\n\"\n-            \"2. \\\"account\\\"         (string, required) The account to assign the address to.\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"setaccount\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\" \\\"tabby\\\"\")\n-            + HelpExampleRpc(\"setaccount\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\", \\\"tabby\\\"\")\n-        );\n+                            \"setlabel \\\"bitcoinaddress\\\" \\\"label\\\"\\n\"\n+                            \"\\nSets the label associated with the given address.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"bitcoinaddress\\\"  (string, required) The bitcoin address to be associated with an label.\\n\"\n+                            \"2. \\\"label\\\"           (string, required) The label to assign to the address.\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"setlabel\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\" \\\"tabby\\\"\")\n+                            + HelpExampleRpc(\"setlabel\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\", \\\"tabby\\\"\")\n+                            );\n \n-    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n \n     CBitcoinAddress address(params[0].get_str());\n     if (!address.IsValid())\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n \n-    string strAccount;\n+    string strLabel;\n     if (params.size() > 1)\n-        strAccount = AccountFromValue(params[1]);\n-\n-    // Only add the account if the address is yours.\n-    if (IsMine(*Lightwallet::pwalletMain, address.Get()))\n-    {\n-        // Detect when changing the account of an address that is the 'unused current key' of another account:\n-        if (Lightwallet::pwalletMain->mapAddressBook.count(address.Get()))\n-        {\n-            string strOldAccount = Lightwallet::pwalletMain->mapAddressBook[address.Get()].name;\n-            if (address == GetAccountAddress(strOldAccount))\n-                GetAccountAddress(strOldAccount, true);\n-        }\n-        Lightwallet::pwalletMain->SetAddressBook(address.Get(), strAccount, \"receive\");\n-    }\n-    else\n-        throw JSONRPCError(RPC_MISC_ERROR, \"setaccount can only be used with own address\");\n+        strLabel = LabelFromValue(params[1]);\n \n+    pwalletMain->SetAddressBook(address.Get(), strLabel, IsMine(*pwalletMain, address.Get()) ? \"receive\" : \"send\");\n+    \n     return NullUniValue;\n }\n \n+/** Convert CAddressBookData to JSON record.\n+ * The verbosity of the output is configurable based on the command.\n+ */\n+static UniValue AddressBookDataToJSON(const CAddressBookData& data, bool verbose)\n+{\n+    UniValue ret(UniValue::VOBJ);\n+    if (verbose)\n+        ret.push_back(Pair(\"label\", data.label));\n+    ret.push_back(Pair(\"purpose\", data.purpose));\n+    if (verbose) {\n+        UniValue ddata(UniValue::VOBJ);\n+        BOOST_FOREACH(const PAIRTYPE(std::string, std::string) &item, data.destdata)\n+        ddata.push_back(Pair(item.first, item.second));\n+        ret.push_back(Pair(\"destdata\", ddata));\n+    }\n+    return ret;\n+}\n \n-UniValue getaccount(const UniValue& params, bool fHelp)\n+UniValue getlabel(const UniValue& params, bool fHelp)\n {\n     if (!EnsureWalletIsAvailable(fHelp))\n         return NullUniValue;\n \n     if (fHelp || params.size() != 1)\n         throw runtime_error(\n-            \"getaccount \\\"bitcoinaddress\\\"\\n\"\n-            \"\\nDEPRECATED. Returns the account associated with the given address.\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"bitcoinaddress\\\"  (string, required) The bitcoin address for account lookup.\\n\"\n-            \"\\nResult:\\n\"\n-            \"\\\"accountname\\\"        (string) the account address\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getaccount\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\"\")\n-            + HelpExampleRpc(\"getaccount\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\"\")\n-        );\n+                            \"getlabel \\\"bitcoinaddress\\\"\\n\"\n+                            \"\\nReturns the label associated with the given address.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"bitcoinaddress\\\"  (string, required) The bitcoin address for label lookup.\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  { (json object with information about address)\\n\"\n+                            \"    \\\"name\\\": \\\"labelname\\\" (string) The label\\n\"\n+                            \"    \\\"purpose\\\": \\\"string\\\" (string) Purpose of address (\\\"send\\\" for sending address, \\\"receive\\\" for receiving address)\\n\"\n+                            \"  },...\\n\"\n+                            \"  Result is null if there is no record for this address.\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"getlabel\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\"\")\n+                            + HelpExampleRpc(\"getlabel\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\"\")\n+                            );\n \n-    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n \n     CBitcoinAddress address(params[0].get_str());\n     if (!address.IsValid())\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n-\n-    string strAccount;\n-    map<CTxDestination, CAddressBookData>::iterator mi = Lightwallet::pwalletMain->mapAddressBook.find(address.Get());\n-    if (mi != Lightwallet::pwalletMain->mapAddressBook.end() && !(*mi).second.name.empty())\n-        strAccount = (*mi).second.name;\n-    return strAccount;\n+    \n+    map<CTxDestination, CAddressBookData>::iterator mi = pwalletMain->mapAddressBook.find(address.Get());\n+    if (mi != pwalletMain->mapAddressBook.end())\n+        return AddressBookDataToJSON((*mi).second, true);\n+    return NullUniValue;\n }\n \n \n-UniValue getaddressesbyaccount(const UniValue& params, bool fHelp)\n+UniValue getaddressesbylabel(const UniValue& params, bool fHelp)\n {\n     if (!EnsureWalletIsAvailable(fHelp))\n         return NullUniValue;\n \n-    if (fHelp || params.size() != 1)\n+    if (fHelp || params.size() > 1)\n         throw runtime_error(\n-            \"getaddressesbyaccount \\\"account\\\"\\n\"\n-            \"\\nDEPRECATED. Returns the list of addresses for the given account.\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"account\\\"  (string, required) The account name.\\n\"\n-            \"\\nResult:\\n\"\n-            \"[                     (json array of string)\\n\"\n-            \"  \\\"bitcoinaddress\\\"  (string) a bitcoin address associated with the given account\\n\"\n-            \"  ,...\\n\"\n-            \"]\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getaddressesbyaccount\", \"\\\"tabby\\\"\")\n-            + HelpExampleRpc(\"getaddressesbyaccount\", \"\\\"tabby\\\"\")\n-        );\n+                            \"getaddressesbylabel \\\"label\\\"\\n\"\n+                            \"\\nReturns the list of addresses assigned the specified label.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"label\\\"  (string, required) The label.\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{ (json object with addresses as keys)\\n\"\n+                            \"  \\\"bitcoinaddress\\\": { (json object with information about address)\\n\"\n+                            \"    \\\"purpose\\\": \\\"string\\\" (string)  Purpose of address (\\\"send\\\" for sending address, \\\"receive\\\" for receiving address)\\n\"\n+                            \"  },...\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"getaddressesbylabel\", \"\\\"tabby\\\"\")\n+                            + HelpExampleRpc(\"getaddressesbylabel\", \"\\\"tabby\\\"\")\n+                            );\n \n-    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n \n-    string strAccount = AccountFromValue(params[0]);\n+    string strLabel;\n+    if (params.size() > 0)\n+        strLabel = LabelFromValue(params[0]);\n \n-    // Find all addresses that have the given account\n-    UniValue ret(UniValue::VARR);\n-    BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, CAddressBookData)& item, Lightwallet::pwalletMain->mapAddressBook)\n+    // Find all addresses that have the given label\n+    UniValue ret(UniValue::VOBJ);\n+    BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, CAddressBookData)& item, pwalletMain->mapAddressBook)\n     {\n-        const CBitcoinAddress& address = item.first;\n-        const string& strName = item.second.name;\n-        if (strName == strAccount)\n-            ret.push_back(address.ToString());\n+        if (strLabel.empty() || item.second.label == strLabel)\n+            ret.push_back(Pair(item.first.ToString(), AddressBookDataToJSON(item.second, true)));\n     }\n     return ret;\n }\n \n-static void SendMoney(const CTxDestination &address, CAmount nValue, bool fSubtractFeeFromAmount, CWalletTx& wtxNew)\n-{\n-    CAmount curBalance = Lightwallet::pwalletMain->GetBalance();\n-\n-    // Check amount\n-    if (nValue <= 0)\n-        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid amount\");\n-\n-    if (nValue > curBalance)\n-        throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Insufficient funds\");\n-\n-    // Parse Bitcoin address\n-    CScript scriptPubKey = GetScriptForDestination(address);\n-\n-    // Create and send the transaction\n-    CReserveKey reservekey(Lightwallet::pwalletMain);\n-    CAmount nFeeRequired;\n-    std::string strError;\n-    vector<CRecipient> vecSend;\n-    int nChangePosRet = -1;\n-    CRecipient recipient = {scriptPubKey, nValue, fSubtractFeeFromAmount};\n-    vecSend.push_back(recipient);\n-    if (!Lightwallet::pwalletMain->CreateTransaction(vecSend, wtxNew, reservekey, nFeeRequired, nChangePosRet, strError)) {\n-        if (!fSubtractFeeFromAmount && nValue + nFeeRequired > Lightwallet::pwalletMain->GetBalance())\n-            strError = strprintf(\"Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds!\", FormatMoney(nFeeRequired));\n-        throw JSONRPCError(RPC_WALLET_ERROR, strError);\n-    }\n-    if (!Lightwallet::pwalletMain->CommitTransaction(wtxNew, reservekey))\n-        throw JSONRPCError(RPC_WALLET_ERROR, \"Error: The transaction was rejected! This might happen if some of the coins in your wallet were already spent, such as if you used a copy of the wallet and coins were spent in the copy but not marked as spent here.\");\n-}\n-\n-UniValue sendtoaddress(const UniValue& params, bool fHelp)\n-{\n-    if (!EnsureWalletIsAvailable(fHelp))\n-        return NullUniValue;\n-\n-    if (fHelp || params.size() < 2 || params.size() > 5)\n-        throw runtime_error(\n-            \"sendtoaddress \\\"bitcoinaddress\\\" amount ( \\\"comment\\\" \\\"comment-to\\\" subtractfeefromamount )\\n\"\n-            \"\\nSend an amount to a given address.\\n\"\n-            + HelpRequiringPassphrase() +\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"bitcoinaddress\\\"  (string, required) The bitcoin address to send to.\\n\"\n-            \"2. \\\"amount\\\"      (numeric or string, required) The amount in \" + CURRENCY_UNIT + \" to send. eg 0.1\\n\"\n-            \"3. \\\"comment\\\"     (string, optional) A comment used to store what the transaction is for. \\n\"\n-            \"                             This is not part of the transaction, just kept in your wallet.\\n\"\n-            \"4. \\\"comment-to\\\"  (string, optional) A comment to store the name of the person or organization \\n\"\n-            \"                             to which you're sending the transaction. This is not part of the \\n\"\n-            \"                             transaction, just kept in your wallet.\\n\"\n-            \"5. subtractfeefromamount  (boolean, optional, default=false) The fee will be deducted from the amount being sent.\\n\"\n-            \"                             The recipient will receive less bitcoins than you enter in the amount field.\\n\"\n-            \"\\nResult:\\n\"\n-            \"\\\"transactionid\\\"  (string) The transaction id.\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"sendtoaddress\", \"\\\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\\\" 0.1\")\n-            + HelpExampleCli(\"sendtoaddress\", \"\\\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\\\" 0.1 \\\"donation\\\" \\\"seans outpost\\\"\")\n-            + HelpExampleCli(\"sendtoaddress\", \"\\\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\\\" 0.1 \\\"\\\" \\\"\\\" true\")\n-            + HelpExampleRpc(\"sendtoaddress\", \"\\\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\\\", 0.1, \\\"donation\\\", \\\"seans outpost\\\"\")\n-        );\n-\n-    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n-\n-    CBitcoinAddress address(params[0].get_str());\n-    if (!address.IsValid())\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n-\n-    // Amount\n-    CAmount nAmount = AmountFromValue(params[1]);\n-    if (nAmount <= 0)\n-        throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid amount for send\");\n-\n-    // Wallet comments\n-    CWalletTx wtx;\n-    if (params.size() > 2 && !params[2].isNull() && !params[2].get_str().empty())\n-        wtx.mapValue[\"comment\"] = params[2].get_str();\n-    if (params.size() > 3 && !params[3].isNull() && !params[3].get_str().empty())\n-        wtx.mapValue[\"to\"]      = params[3].get_str();\n-\n-    bool fSubtractFeeFromAmount = false;\n-    if (params.size() > 4)\n-        fSubtractFeeFromAmount = params[4].get_bool();\n-\n-    EnsureWalletIsUnlocked();\n-\n-    SendMoney(address.Get(), nAmount, fSubtractFeeFromAmount, wtx);\n-\n-    return wtx.GetHash().GetHex();\n-}\n-\n UniValue listaddressgroupings(const UniValue& params, bool fHelp)\n {\n     if (!EnsureWalletIsAvailable(fHelp))\n@@ -477,7 +336,7 @@ UniValue listaddressgroupings(const UniValue& params, bool fHelp)\n             \"    [\\n\"\n             \"      \\\"bitcoinaddress\\\",     (string) The bitcoin address\\n\"\n             \"      amount,                 (numeric) The amount in \" + CURRENCY_UNIT + \"\\n\"\n-            \"      \\\"account\\\"             (string, optional) The account (DEPRECATED)\\n\"\n+            \"      \\\"label\\\"               (string, optional) The label\\n\"\n             \"    ]\\n\"\n             \"    ,...\\n\"\n             \"  ]\\n\"\n@@ -502,7 +361,7 @@ UniValue listaddressgroupings(const UniValue& params, bool fHelp)\n             addressInfo.push_back(ValueFromAmount(balances[address]));\n             {\n                 if (Lightwallet::pwalletMain->mapAddressBook.find(CBitcoinAddress(address).Get()) != Lightwallet::pwalletMain->mapAddressBook.end())\n-                    addressInfo.push_back(Lightwallet::pwalletMain->mapAddressBook.find(CBitcoinAddress(address).Get())->second.name);\n+                    addressInfo.push_back(Lightwallet::pwalletMain->mapAddressBook.find(CBitcoinAddress(address).Get())->second.label);\n             }\n             jsonGrouping.push_back(addressInfo);\n         }\n@@ -625,113 +484,19 @@ UniValue getreceivedbyaddress(const UniValue& params, bool fHelp)\n }\n \n \n-UniValue getreceivedbyaccount(const UniValue& params, bool fHelp)\n-{\n-    if (!EnsureWalletIsAvailable(fHelp))\n-        return NullUniValue;\n-\n-    if (fHelp || params.size() < 1 || params.size() > 2)\n-        throw runtime_error(\n-            \"getreceivedbyaccount \\\"account\\\" ( minconf )\\n\"\n-            \"\\nDEPRECATED. Returns the total amount received by addresses with <account> in transactions with at least [minconf] confirmations.\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"account\\\"      (string, required) The selected account, may be the default account using \\\"\\\".\\n\"\n-            \"2. minconf          (numeric, optional, default=1) Only include transactions confirmed at least this many times.\\n\"\n-            \"\\nResult:\\n\"\n-            \"amount              (numeric) The total amount in \" + CURRENCY_UNIT + \" received for this account.\\n\"\n-            \"\\nExamples:\\n\"\n-            \"\\nAmount received by the default account with at least 1 confirmation\\n\"\n-            + HelpExampleCli(\"getreceivedbyaccount\", \"\\\"\\\"\") +\n-            \"\\nAmount received at the tabby account including unconfirmed amounts with zero confirmations\\n\"\n-            + HelpExampleCli(\"getreceivedbyaccount\", \"\\\"tabby\\\" 0\") +\n-            \"\\nThe amount with at least 6 confirmation, very safe\\n\"\n-            + HelpExampleCli(\"getreceivedbyaccount\", \"\\\"tabby\\\" 6\") +\n-            \"\\nAs a json rpc call\\n\"\n-            + HelpExampleRpc(\"getreceivedbyaccount\", \"\\\"tabby\\\", 6\")\n-        );\n-\n-    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n-\n-    // Minimum confirmations\n-    int nMinDepth = 1;\n-    if (params.size() > 1)\n-        nMinDepth = params[1].get_int();\n-\n-    // Get the set of pub keys assigned to account\n-    string strAccount = AccountFromValue(params[0]);\n-    set<CTxDestination> setAddress = Lightwallet::pwalletMain->GetAccountAddresses(strAccount);\n-\n-    // Tally\n-    CAmount nAmount = 0;\n-    for (map<uint256, CWalletTx>::iterator it = Lightwallet::pwalletMain->mapWallet.begin(); it != Lightwallet::pwalletMain->mapWallet.end(); ++it)\n-    {\n-        const CWalletTx& wtx = (*it).second;\n-        if (wtx.IsCoinBase() || !CheckFinalTx(wtx))\n-            continue;\n-\n-        BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n-        {\n-            CTxDestination address;\n-            if (ExtractDestination(txout.scriptPubKey, address) && IsMine(*Lightwallet::pwalletMain, address) && setAddress.count(address))\n-                if (wtx.GetDepthInMainChain() >= nMinDepth)\n-                    nAmount += txout.nValue;\n-        }\n-    }\n-\n-    return (double)nAmount / (double)COIN;\n-}\n-\n-\n-CAmount GetAccountBalance(CWalletDB& walletdb, const string& strAccount, int nMinDepth, const isminefilter& filter)\n-{\n-    CAmount nBalance = 0;\n-\n-    // Tally wallet transactions\n-    for (map<uint256, CWalletTx>::iterator it = Lightwallet::pwalletMain->mapWallet.begin(); it != Lightwallet::pwalletMain->mapWallet.end(); ++it)\n-    {\n-        const CWalletTx& wtx = (*it).second;\n-        if (!CheckFinalTx(wtx) || wtx.GetBlocksToMaturity() > 0 || wtx.GetDepthInMainChain() < 0)\n-            continue;\n-\n-        CAmount nReceived, nSent, nFee;\n-        wtx.GetAccountAmounts(strAccount, nReceived, nSent, nFee, filter);\n-\n-        if (nReceived != 0 && wtx.GetDepthInMainChain() >= nMinDepth)\n-            nBalance += nReceived;\n-        nBalance -= nSent + nFee;\n-    }\n-\n-    // Tally internal accounting entries\n-    nBalance += walletdb.GetAccountCreditDebit(strAccount);\n-\n-    return nBalance;\n-}\n-\n-CAmount GetAccountBalance(const string& strAccount, int nMinDepth, const isminefilter& filter)\n-{\n-    CWalletDB walletdb(Lightwallet::pwalletMain->strWalletFile);\n-    return GetAccountBalance(walletdb, strAccount, nMinDepth, filter);\n-}\n-\n-\n UniValue getbalance(const UniValue& params, bool fHelp)\n {\n     if (!EnsureWalletIsAvailable(fHelp))\n         return NullUniValue;\n \n     if (fHelp || params.size() > 3)\n         throw runtime_error(\n-            \"getbalance ( \\\"account\\\" minconf includeWatchonly )\\n\"\n-            \"\\nIf account is not specified, returns the server's total available balance.\\n\"\n-            \"If account is specified (DEPRECATED), returns the balance in the account.\\n\"\n-            \"Note that the account \\\"\\\" is not the same as leaving the parameter out.\\n\"\n-            \"The server total may be different to the balance in the default \\\"\\\" account.\\n\"\n+            \"getbalance ( minconf includeWatchonly )\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. \\\"account\\\"      (string, optional) DEPRECATED. The selected account, or \\\"*\\\" for entire wallet. It may be the default account using \\\"\\\".\\n\"\n-            \"2. minconf          (numeric, optional, default=1) Only include transactions confirmed at least this many times.\\n\"\n-            \"3. includeWatchonly (bool, optional, default=false) Also include balance in watchonly addresses (see 'importaddress')\\n\"\n+            \"1. minconf          (numeric, optional, default=1) Only include transactions confirmed at least this many times.\\n\"\n+            \"2. includeWatchonly (bool, optional, default=false) Also include balance in watchonly addresses (see 'importaddress')\\n\"\n             \"\\nResult:\\n\"\n-            \"amount              (numeric) The total amount in \" + CURRENCY_UNIT + \" received for this account.\\n\"\n+            \"amount              (numeric) The total amount in \" + CURRENCY_UNIT + \".\\n\"\n             \"\\nExamples:\\n\"\n             \"\\nThe total amount in the wallet\\n\"\n             + HelpExampleCli(\"getbalance\", \"\") +\n@@ -747,46 +512,37 @@ UniValue getbalance(const UniValue& params, bool fHelp)\n         return  ValueFromAmount(Lightwallet::pwalletMain->GetBalance());\n \n     int nMinDepth = 1;\n-    if (params.size() > 1)\n-        nMinDepth = params[1].get_int();\n+    if (params.size() > 0)\n+        nMinDepth = params[0].get_int();\n     isminefilter filter = ISMINE_SPENDABLE;\n-    if(params.size() > 2)\n-        if(params[2].get_bool())\n+    if(params.size() > 1)\n+        if(params[1].get_bool())\n             filter = filter | ISMINE_WATCH_ONLY;\n \n-    if (params[0].get_str() == \"*\") {\n-        // Calculate total balance a different way from GetBalance()\n-        // (GetBalance() sums up all unspent TxOuts)\n-        // getbalance and \"getbalance * 1 true\" should return the same number\n-        CAmount nBalance = 0;\n-        for (map<uint256, CWalletTx>::iterator it = Lightwallet::pwalletMain->mapWallet.begin(); it != Lightwallet::pwalletMain->mapWallet.end(); ++it)\n-        {\n-            const CWalletTx& wtx = (*it).second;\n-            if (!CheckFinalTx(wtx) || wtx.GetBlocksToMaturity() > 0 || wtx.GetDepthInMainChain() < 0)\n-                continue;\n+    // Calculate total balance a different way from GetBalance()\n+    // (GetBalance() sums up all unspent TxOuts)\n+    // getbalance and \"getbalance * 1 true\" should return the same number\n+    CAmount nBalance = 0;\n+    for (map<uint256, CWalletTx>::iterator it = Lightwallet::pwalletMain->mapWallet.begin(); it != Lightwallet::pwalletMain->mapWallet.end(); ++it)\n+    {\n+        const CWalletTx& wtx = (*it).second;\n+        if (!CheckFinalTx(wtx) || wtx.GetBlocksToMaturity() > 0 || wtx.GetDepthInMainChain() < 0)\n+            continue;\n \n-            CAmount allFee;\n-            string strSentAccount;\n-            list<COutputEntry> listReceived;\n-            list<COutputEntry> listSent;\n-            wtx.GetAmounts(listReceived, listSent, allFee, strSentAccount, filter);\n-            if (wtx.GetDepthInMainChain() >= nMinDepth)\n-            {\n-                BOOST_FOREACH(const COutputEntry& r, listReceived)\n-                    nBalance += r.amount;\n-            }\n-            BOOST_FOREACH(const COutputEntry& s, listSent)\n-                nBalance -= s.amount;\n-            nBalance -= allFee;\n+        CAmount allFee;\n+        list<COutputEntry> listReceived;\n+        list<COutputEntry> listSent;\n+        wtx.GetAmounts(listReceived, listSent, allFee, filter);\n+        if (wtx.GetDepthInMainChain() >= nMinDepth)\n+        {\n+            BOOST_FOREACH(const COutputEntry& r, listReceived)\n+                nBalance += r.amount;\n         }\n-        return  ValueFromAmount(nBalance);\n+        BOOST_FOREACH(const COutputEntry& s, listSent)\n+            nBalance -= s.amount;\n+        nBalance -= allFee;\n     }\n-\n-    string strAccount = AccountFromValue(params[0]);\n-\n-    CAmount nBalance = GetAccountBalance(strAccount, nMinDepth, filter);\n-\n-    return ValueFromAmount(nBalance);\n+    return  ValueFromAmount(nBalance);\n }\n \n UniValue getunconfirmedbalance(const UniValue &params, bool fHelp)\n@@ -804,164 +560,25 @@ UniValue getunconfirmedbalance(const UniValue &params, bool fHelp)\n     return ValueFromAmount(Lightwallet::pwalletMain->GetUnconfirmedBalance());\n }\n \n-\n-UniValue movecmd(const UniValue& params, bool fHelp)\n-{\n-    if (!EnsureWalletIsAvailable(fHelp))\n-        return NullUniValue;\n-\n-    if (fHelp || params.size() < 3 || params.size() > 5)\n-        throw runtime_error(\n-            \"move \\\"fromaccount\\\" \\\"toaccount\\\" amount ( minconf \\\"comment\\\" )\\n\"\n-            \"\\nDEPRECATED. Move a specified amount from one account in your wallet to another.\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"fromaccount\\\"   (string, required) The name of the account to move funds from. May be the default account using \\\"\\\".\\n\"\n-            \"2. \\\"toaccount\\\"     (string, required) The name of the account to move funds to. May be the default account using \\\"\\\".\\n\"\n-            \"3. amount            (numeric) Quantity of \" + CURRENCY_UNIT + \" to move between accounts.\\n\"\n-            \"4. minconf           (numeric, optional, default=1) Only use funds with at least this many confirmations.\\n\"\n-            \"5. \\\"comment\\\"       (string, optional) An optional comment, stored in the wallet only.\\n\"\n-            \"\\nResult:\\n\"\n-            \"true|false           (boolean) true if successful.\\n\"\n-            \"\\nExamples:\\n\"\n-            \"\\nMove 0.01 \" + CURRENCY_UNIT + \" from the default account to the account named tabby\\n\"\n-            + HelpExampleCli(\"move\", \"\\\"\\\" \\\"tabby\\\" 0.01\") +\n-            \"\\nMove 0.01 \" + CURRENCY_UNIT + \" timotei to akiko with a comment and funds have 6 confirmations\\n\"\n-            + HelpExampleCli(\"move\", \"\\\"timotei\\\" \\\"akiko\\\" 0.01 6 \\\"happy birthday!\\\"\") +\n-            \"\\nAs a json rpc call\\n\"\n-            + HelpExampleRpc(\"move\", \"\\\"timotei\\\", \\\"akiko\\\", 0.01, 6, \\\"happy birthday!\\\"\")\n-        );\n-\n-    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n-\n-    string strFrom = AccountFromValue(params[0]);\n-    string strTo = AccountFromValue(params[1]);\n-    CAmount nAmount = AmountFromValue(params[2]);\n-    if (nAmount <= 0)\n-        throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid amount for send\");\n-    if (params.size() > 3)\n-        // unused parameter, used to be nMinDepth, keep type-checking it though\n-        (void)params[3].get_int();\n-    string strComment;\n-    if (params.size() > 4)\n-        strComment = params[4].get_str();\n-\n-    CWalletDB walletdb(Lightwallet::pwalletMain->strWalletFile);\n-    if (!walletdb.TxnBegin())\n-        throw JSONRPCError(RPC_DATABASE_ERROR, \"database error\");\n-\n-    int64_t nNow = GetAdjustedTime();\n-\n-    // Debit\n-    CAccountingEntry debit;\n-    debit.nOrderPos = Lightwallet::pwalletMain->IncOrderPosNext(&walletdb);\n-    debit.strAccount = strFrom;\n-    debit.nCreditDebit = -nAmount;\n-    debit.nTime = nNow;\n-    debit.strOtherAccount = strTo;\n-    debit.strComment = strComment;\n-    Lightwallet::pwalletMain->AddAccountingEntry(debit, walletdb);\n-\n-    // Credit\n-    CAccountingEntry credit;\n-    credit.nOrderPos = Lightwallet::pwalletMain->IncOrderPosNext(&walletdb);\n-    credit.strAccount = strTo;\n-    credit.nCreditDebit = nAmount;\n-    credit.nTime = nNow;\n-    credit.strOtherAccount = strFrom;\n-    credit.strComment = strComment;\n-    Lightwallet::pwalletMain->AddAccountingEntry(credit, walletdb);\n-\n-    if (!walletdb.TxnCommit())\n-        throw JSONRPCError(RPC_DATABASE_ERROR, \"database error\");\n-\n-    return true;\n-}\n-\n-\n-UniValue sendfrom(const UniValue& params, bool fHelp)\n+UniValue sendto(const UniValue& params, bool fHelp)\n {\n     if (!EnsureWalletIsAvailable(fHelp))\n         return NullUniValue;\n \n-    if (fHelp || params.size() < 3 || params.size() > 6)\n+    if (fHelp || params.size() < 1 || params.size() > 4)\n         throw runtime_error(\n-            \"sendfrom \\\"fromaccount\\\" \\\"tobitcoinaddress\\\" amount ( minconf \\\"comment\\\" \\\"comment-to\\\" )\\n\"\n-            \"\\nDEPRECATED (use sendtoaddress). Sent an amount from an account to a bitcoin address.\"\n-            + HelpRequiringPassphrase() + \"\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"fromaccount\\\"       (string, required) The name of the account to send funds from. May be the default account using \\\"\\\".\\n\"\n-            \"2. \\\"tobitcoinaddress\\\"  (string, required) The bitcoin address to send funds to.\\n\"\n-            \"3. amount                (numeric or string, required) The amount in \" + CURRENCY_UNIT + \" (transaction fee is added on top).\\n\"\n-            \"4. minconf               (numeric, optional, default=1) Only use funds with at least this many confirmations.\\n\"\n-            \"5. \\\"comment\\\"           (string, optional) A comment used to store what the transaction is for. \\n\"\n-            \"                                     This is not part of the transaction, just kept in your wallet.\\n\"\n-            \"6. \\\"comment-to\\\"        (string, optional) An optional comment to store the name of the person or organization \\n\"\n-            \"                                     to which you're sending the transaction. This is not part of the transaction, \\n\"\n-            \"                                     it is just kept in your wallet.\\n\"\n-            \"\\nResult:\\n\"\n-            \"\\\"transactionid\\\"        (string) The transaction id.\\n\"\n-            \"\\nExamples:\\n\"\n-            \"\\nSend 0.01 \" + CURRENCY_UNIT + \" from the default account to the address, must have at least 1 confirmation\\n\"\n-            + HelpExampleCli(\"sendfrom\", \"\\\"\\\" \\\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\\\" 0.01\") +\n-            \"\\nSend 0.01 from the tabby account to the given address, funds must have at least 6 confirmations\\n\"\n-            + HelpExampleCli(\"sendfrom\", \"\\\"tabby\\\" \\\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\\\" 0.01 6 \\\"donation\\\" \\\"seans outpost\\\"\") +\n-            \"\\nAs a json rpc call\\n\"\n-            + HelpExampleRpc(\"sendfrom\", \"\\\"tabby\\\", \\\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\\\", 0.01, 6, \\\"donation\\\", \\\"seans outpost\\\"\")\n-        );\n-\n-    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n-\n-    string strAccount = AccountFromValue(params[0]);\n-    CBitcoinAddress address(params[1].get_str());\n-    if (!address.IsValid())\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n-    CAmount nAmount = AmountFromValue(params[2]);\n-    if (nAmount <= 0)\n-        throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid amount for send\");\n-    int nMinDepth = 1;\n-    if (params.size() > 3)\n-        nMinDepth = params[3].get_int();\n-\n-    CWalletTx wtx;\n-    wtx.strFromAccount = strAccount;\n-    if (params.size() > 4 && !params[4].isNull() && !params[4].get_str().empty())\n-        wtx.mapValue[\"comment\"] = params[4].get_str();\n-    if (params.size() > 5 && !params[5].isNull() && !params[5].get_str().empty())\n-        wtx.mapValue[\"to\"]      = params[5].get_str();\n-\n-    EnsureWalletIsUnlocked();\n-\n-    // Check funds\n-    CAmount nBalance = GetAccountBalance(strAccount, nMinDepth, ISMINE_SPENDABLE);\n-    if (nAmount > nBalance)\n-        throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Account has insufficient funds\");\n-\n-    SendMoney(address.Get(), nAmount, false, wtx);\n-\n-    return wtx.GetHash().GetHex();\n-}\n-\n-\n-UniValue sendmany(const UniValue& params, bool fHelp)\n-{\n-    if (!EnsureWalletIsAvailable(fHelp))\n-        return NullUniValue;\n-\n-    if (fHelp || params.size() < 2 || params.size() > 5)\n-        throw runtime_error(\n-            \"sendmany \\\"fromaccount\\\" {\\\"address\\\":amount,...} ( minconf \\\"comment\\\" [\\\"address\\\",...] )\\n\"\n+            \"sendto {\\\"address\\\":amount,...} ( minconf \\\"comment\\\" [\\\"address\\\",...] )\\n\"\n             \"\\nSend multiple times. Amounts are double-precision floating point numbers.\"\n             + HelpRequiringPassphrase() + \"\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. \\\"fromaccount\\\"         (string, required) DEPRECATED. The account to send the funds from. Should be \\\"\\\" for the default account\\n\"\n-            \"2. \\\"amounts\\\"             (string, required) A json object with addresses and amounts\\n\"\n+            \"1. \\\"amounts\\\"             (string, required) A json object with addresses and amounts\\n\"\n             \"    {\\n\"\n             \"      \\\"address\\\":amount   (numeric or string) The bitcoin address is the key, the numeric amount (can be string) in \" + CURRENCY_UNIT + \" is the value\\n\"\n             \"      ,...\\n\"\n             \"    }\\n\"\n-            \"3. minconf                 (numeric, optional, default=1) Only use the balance confirmed at least this many times.\\n\"\n-            \"4. \\\"comment\\\"             (string, optional) A comment\\n\"\n-            \"5. subtractfeefromamount   (string, optional) A json array with addresses.\\n\"\n+            \"2. minconf                 (numeric, optional, default=1) Only use the balance confirmed at least this many times.\\n\"\n+            \"3. \\\"comment\\\"             (string, optional) A comment\\n\"\n+            \"4. subtractfeefromamount   (string, optional) A json array with addresses.\\n\"\n             \"                           The fee will be equally deducted from the amount of each selected address.\\n\"\n             \"                           Those recipients will receive less bitcoins than you enter in their corresponding amount field.\\n\"\n             \"                           If no addresses are specified here, the sender pays the fee.\\n\"\n@@ -974,31 +591,29 @@ UniValue sendmany(const UniValue& params, bool fHelp)\n             \"                                    the number of addresses.\\n\"\n             \"\\nExamples:\\n\"\n             \"\\nSend two amounts to two different addresses:\\n\"\n-            + HelpExampleCli(\"sendmany\", \"\\\"\\\" \\\"{\\\\\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\\\\\":0.01,\\\\\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\\\\\":0.02}\\\"\") +\n+            + HelpExampleCli(\"sendto\", \"\\\"\\\" \\\"{\\\\\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\\\\\":0.01,\\\\\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\\\\\":0.02}\\\"\") +\n             \"\\nSend two amounts to two different addresses setting the confirmation and comment:\\n\"\n-            + HelpExampleCli(\"sendmany\", \"\\\"\\\" \\\"{\\\\\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\\\\\":0.01,\\\\\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\\\\\":0.02}\\\" 6 \\\"testing\\\"\") +\n+            + HelpExampleCli(\"sendto\", \"\\\"\\\" \\\"{\\\\\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\\\\\":0.01,\\\\\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\\\\\":0.02}\\\" 6 \\\"testing\\\"\") +\n             \"\\nSend two amounts to two different addresses, subtract fee from amount:\\n\"\n-            + HelpExampleCli(\"sendmany\", \"\\\"\\\" \\\"{\\\\\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\\\\\":0.01,\\\\\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\\\\\":0.02}\\\" 1 \\\"\\\" \\\"[\\\\\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\\\\\",\\\\\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\\\\\"]\\\"\") +\n+            + HelpExampleCli(\"sendto\", \"\\\"\\\" \\\"{\\\\\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\\\\\":0.01,\\\\\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\\\\\":0.02}\\\" 1 \\\"\\\" \\\"[\\\\\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\\\\\",\\\\\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\\\\\"]\\\"\") +\n             \"\\nAs a json rpc call\\n\"\n-            + HelpExampleRpc(\"sendmany\", \"\\\"\\\", \\\"{\\\\\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\\\\\":0.01,\\\\\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\\\\\":0.02}\\\", 6, \\\"testing\\\"\")\n+            + HelpExampleRpc(\"sendto\", \"\\\"\\\", \\\"{\\\\\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\\\\\":0.01,\\\\\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\\\\\":0.02}\\\", 6, \\\"testing\\\"\")\n         );\n \n     LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n-    string strAccount = AccountFromValue(params[0]);\n-    UniValue sendTo = params[1].get_obj();\n+    UniValue sendTo = getObjFromParam(params[0]);\n     int nMinDepth = 1;\n-    if (params.size() > 2)\n-        nMinDepth = params[2].get_int();\n+    if (params.size() > 1)\n+        nMinDepth = params[1].get_int();\n \n     CWalletTx wtx;\n-    wtx.strFromAccount = strAccount;\n-    if (params.size() > 3 && !params[3].isNull() && !params[3].get_str().empty())\n-        wtx.mapValue[\"comment\"] = params[3].get_str();\n+    if (params.size() > 2 && !params[2].isNull() && !params[2].get_str().empty())\n+        wtx.mapValue[\"comment\"] = params[2].get_str();\n \n     UniValue subtractFeeFromAmount(UniValue::VARR);\n-    if (params.size() > 4)\n-        subtractFeeFromAmount = params[4].get_array();\n+    if (params.size() > 3)\n+        subtractFeeFromAmount = params[3].get_array();\n \n     set<CBitcoinAddress> setAddress;\n     vector<CRecipient> vecSend;\n@@ -1035,9 +650,9 @@ UniValue sendmany(const UniValue& params, bool fHelp)\n     EnsureWalletIsUnlocked();\n \n     // Check funds\n-    CAmount nBalance = GetAccountBalance(strAccount, nMinDepth, ISMINE_SPENDABLE);\n+    CAmount nBalance = Lightwallet::pwalletMain->GetBalance();\n     if (totalAmount > nBalance)\n-        throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Account has insufficient funds\");\n+        throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Insufficient funds\");\n \n     // Send\n     CReserveKey keyChange(Lightwallet::pwalletMain);\n@@ -1060,10 +675,9 @@ UniValue addmultisigaddress(const UniValue& params, bool fHelp)\n \n     if (fHelp || params.size() < 2 || params.size() > 3)\n     {\n-        string msg = \"addmultisigaddress nrequired [\\\"key\\\",...] ( \\\"account\\\" )\\n\"\n+        string msg = \"addmultisigaddress nrequired [\\\"key\\\",...] ( \\\"label\\\" )\\n\"\n             \"\\nAdd a nrequired-to-sign multisignature address to the wallet.\\n\"\n             \"Each key is a Bitcoin address or hex-encoded public key.\\n\"\n-            \"If 'account' is specified (DEPRECATED), assign address to that account.\\n\"\n \n             \"\\nArguments:\\n\"\n             \"1. nrequired        (numeric, required) The number of required signatures out of the n keys or addresses.\\n\"\n@@ -1072,7 +686,7 @@ UniValue addmultisigaddress(const UniValue& params, bool fHelp)\n             \"       \\\"address\\\"  (string) bitcoin address or hex-encoded public key\\n\"\n             \"       ...,\\n\"\n             \"     ]\\n\"\n-            \"3. \\\"account\\\"      (string, optional) DEPRECATED. An account to assign the addresses to.\\n\"\n+            \"3. \\\"label\\\"        (string, optional) An label to assign the addresses to.\\n\"\n \n             \"\\nResult:\\n\"\n             \"\\\"bitcoinaddress\\\"  (string) A bitcoin address associated with the keys.\\n\"\n@@ -1088,16 +702,16 @@ UniValue addmultisigaddress(const UniValue& params, bool fHelp)\n \n     LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n-    string strAccount;\n+    string strLabel;\n     if (params.size() > 2)\n-        strAccount = AccountFromValue(params[2]);\n+        strLabel = LabelFromValue(params[2]);\n \n     // Construct using pay-to-script-hash:\n     CScript inner = _createmultisig_redeemScript(params);\n     CScriptID innerID(inner);\n     Lightwallet::pwalletMain->AddCScript(inner);\n \n-    Lightwallet::pwalletMain->SetAddressBook(innerID, strAccount, \"send\");\n+    Lightwallet::pwalletMain->SetAddressBook(innerID, strLabel, \"receive\");\n     return CBitcoinAddress(innerID).ToString();\n }\n \n@@ -1116,14 +730,14 @@ struct tallyitem\n     }\n };\n \n-UniValue ListReceived(const UniValue& params, bool fByAccounts)\n+UniValue ListReceived(const UniValue& params)\n {\n     // Minimum confirmations\n     int nMinDepth = 1;\n     if (params.size() > 0)\n         nMinDepth = params[0].get_int();\n \n-    // Whether to include empty accounts\n+    // Whether to include \"empty\" addresses\n     bool fIncludeEmpty = false;\n     if (params.size() > 1)\n         fIncludeEmpty = params[1].get_bool();\n@@ -1167,11 +781,11 @@ UniValue ListReceived(const UniValue& params, bool fByAccounts)\n \n     // Reply\n     UniValue ret(UniValue::VARR);\n-    map<string, tallyitem> mapAccountTally;\n+    map<string, tallyitem> mapLabelTally;\n     BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, CAddressBookData)& item, Lightwallet::pwalletMain->mapAddressBook)\n     {\n         const CBitcoinAddress& address = item.first;\n-        const string& strAccount = item.second.name;\n+        const string& strLabel = item.second.label;\n         map<CBitcoinAddress, tallyitem>::iterator it = mapTally.find(address);\n         if (it == mapTally.end() && !fIncludeEmpty)\n             continue;\n@@ -1186,51 +800,23 @@ UniValue ListReceived(const UniValue& params, bool fByAccounts)\n             fIsWatchonly = (*it).second.fIsWatchonly;\n         }\n \n-        if (fByAccounts)\n-        {\n-            tallyitem& item = mapAccountTally[strAccount];\n-            item.nAmount += nAmount;\n-            item.nConf = min(item.nConf, nConf);\n-            item.fIsWatchonly = fIsWatchonly;\n-        }\n-        else\n+        UniValue obj(UniValue::VOBJ);\n+        if(fIsWatchonly)\n+            obj.push_back(Pair(\"involvesWatchonly\", true));\n+        obj.push_back(Pair(\"address\",       address.ToString()));\n+        obj.push_back(Pair(\"label\",         strLabel));\n+        obj.push_back(Pair(\"amount\",        ValueFromAmount(nAmount)));\n+        obj.push_back(Pair(\"confirmations\", (nConf == std::numeric_limits<int>::max() ? 0 : nConf)));\n+        UniValue transactions(UniValue::VARR);\n+        if (it != mapTally.end())\n         {\n-            UniValue obj(UniValue::VOBJ);\n-            if(fIsWatchonly)\n-                obj.push_back(Pair(\"involvesWatchonly\", true));\n-            obj.push_back(Pair(\"address\",       address.ToString()));\n-            obj.push_back(Pair(\"account\",       strAccount));\n-            obj.push_back(Pair(\"amount\",        ValueFromAmount(nAmount)));\n-            obj.push_back(Pair(\"confirmations\", (nConf == std::numeric_limits<int>::max() ? 0 : nConf)));\n-            if (!fByAccounts)\n-                obj.push_back(Pair(\"label\", strAccount));\n-            UniValue transactions(UniValue::VARR);\n-            if (it != mapTally.end())\n+            BOOST_FOREACH(const uint256& item, (*it).second.txids)\n             {\n-                BOOST_FOREACH(const uint256& item, (*it).second.txids)\n-                {\n-                    transactions.push_back(item.GetHex());\n-                }\n+                transactions.push_back(item.GetHex());\n             }\n-            obj.push_back(Pair(\"txids\", transactions));\n-            ret.push_back(obj);\n-        }\n-    }\n-\n-    if (fByAccounts)\n-    {\n-        for (map<string, tallyitem>::iterator it = mapAccountTally.begin(); it != mapAccountTally.end(); ++it)\n-        {\n-            CAmount nAmount = (*it).second.nAmount;\n-            int nConf = (*it).second.nConf;\n-            UniValue obj(UniValue::VOBJ);\n-            if((*it).second.fIsWatchonly)\n-                obj.push_back(Pair(\"involvesWatchonly\", true));\n-            obj.push_back(Pair(\"account\",       (*it).first));\n-            obj.push_back(Pair(\"amount\",        ValueFromAmount(nAmount)));\n-            obj.push_back(Pair(\"confirmations\", (nConf == std::numeric_limits<int>::max() ? 0 : nConf)));\n-            ret.push_back(obj);\n         }\n+        obj.push_back(Pair(\"txids\", transactions));\n+        ret.push_back(obj);\n     }\n \n     return ret;\n@@ -1255,7 +841,7 @@ UniValue listreceivedbyaddress(const UniValue& params, bool fHelp)\n             \"  {\\n\"\n             \"    \\\"involvesWatchonly\\\" : true,        (bool) Only returned if imported addresses were involved in transaction\\n\"\n             \"    \\\"address\\\" : \\\"receivingaddress\\\",  (string) The receiving address\\n\"\n-            \"    \\\"account\\\" : \\\"accountname\\\",       (string) DEPRECATED. The account of the receiving address. The default account is \\\"\\\".\\n\"\n+            \"    \\\"label\\\" :   \\\"label\\\",             (string) The label of the receiving address. The default label is \\\"\\\".\\n\"\n             \"    \\\"amount\\\" : x.xxx,                  (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n             \"    \\\"confirmations\\\" : n,               (numeric) The number of confirmations of the most recent transaction included\\n\"\n             \"    \\\"label\\\" : \\\"label\\\"                (string) A comment for the address/transaction, if any\\n\"\n@@ -1271,45 +857,9 @@ UniValue listreceivedbyaddress(const UniValue& params, bool fHelp)\n \n     LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n-    return ListReceived(params, false);\n+    return ListReceived(params);\n }\n \n-UniValue listreceivedbyaccount(const UniValue& params, bool fHelp)\n-{\n-    if (!EnsureWalletIsAvailable(fHelp))\n-        return NullUniValue;\n-\n-    if (fHelp || params.size() > 3)\n-        throw runtime_error(\n-            \"listreceivedbyaccount ( minconf includeempty includeWatchonly)\\n\"\n-            \"\\nDEPRECATED. List balances by account.\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. minconf      (numeric, optional, default=1) The minimum number of confirmations before payments are included.\\n\"\n-            \"2. includeempty (bool, optional, default=false) Whether to include accounts that haven't received any payments.\\n\"\n-            \"3. includeWatchonly (bool, optional, default=false) Whether to include watchonly addresses (see 'importaddress').\\n\"\n-\n-            \"\\nResult:\\n\"\n-            \"[\\n\"\n-            \"  {\\n\"\n-            \"    \\\"involvesWatchonly\\\" : true,   (bool) Only returned if imported addresses were involved in transaction\\n\"\n-            \"    \\\"account\\\" : \\\"accountname\\\",  (string) The account name of the receiving account\\n\"\n-            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount received by addresses with this account\\n\"\n-            \"    \\\"confirmations\\\" : n,          (numeric) The number of confirmations of the most recent transaction included\\n\"\n-            \"    \\\"label\\\" : \\\"label\\\"           (string) A comment for the address/transaction, if any\\n\"\n-            \"  }\\n\"\n-            \"  ,...\\n\"\n-            \"]\\n\"\n-\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"listreceivedbyaccount\", \"\")\n-            + HelpExampleCli(\"listreceivedbyaccount\", \"6 true\")\n-            + HelpExampleRpc(\"listreceivedbyaccount\", \"6, true, true\")\n-        );\n-\n-    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n-\n-    return ListReceived(params, true);\n-}\n \n static void MaybePushAddress(UniValue & entry, const CTxDestination &dest)\n {\n@@ -1318,32 +868,34 @@ static void MaybePushAddress(UniValue & entry, const CTxDestination &dest)\n         entry.push_back(Pair(\"address\", addr.ToString()));\n }\n \n-void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDepth, bool fLong, UniValue& ret, const isminefilter& filter)\n+void ListTransactions(const CWalletTx& wtx, const string& strLabelFilter, int nMinDepth, bool fLong, UniValue& ret, const isminefilter& filter)\n {\n     CAmount nFee;\n-    string strSentAccount;\n     list<COutputEntry> listReceived;\n     list<COutputEntry> listSent;\n \n-    wtx.GetAmounts(listReceived, listSent, nFee, strSentAccount, filter);\n+    wtx.GetAmounts(listReceived, listSent, nFee, filter);\n \n-    bool fAllAccounts = (strAccount == string(\"*\"));\n+    bool fAllLabels = (strLabelFilter == string(\"*\"));\n     bool involvesWatchonly = wtx.IsFromMe(ISMINE_WATCH_ONLY);\n \n     // Sent\n-    if ((!listSent.empty() || nFee != 0) && (fAllAccounts || strAccount == strSentAccount))\n+    if ((!listSent.empty() || nFee != 0))\n     {\n         BOOST_FOREACH(const COutputEntry& s, listSent)\n         {\n+            // simple label filter\n+            string label = Lightwallet::pwalletMain->mapAddressBook[s.destination].label;\n+            if (!fAllLabels && !strLabelFilter.empty() && label != strLabelFilter)\n+                continue;\n+\n             UniValue entry(UniValue::VOBJ);\n             if(involvesWatchonly || (Lightwallet::IsMine(*Lightwallet::pwalletMain, s.destination) & ISMINE_WATCH_ONLY))\n                 entry.push_back(Pair(\"involvesWatchonly\", true));\n-            entry.push_back(Pair(\"account\", strSentAccount));\n+            entry.push_back(Pair(\"label\", label));\n             MaybePushAddress(entry, s.destination);\n             entry.push_back(Pair(\"category\", \"send\"));\n             entry.push_back(Pair(\"amount\", ValueFromAmount(-s.amount)));\n-            if (Lightwallet::pwalletMain->mapAddressBook.count(s.destination))\n-                entry.push_back(Pair(\"label\", Lightwallet::pwalletMain->mapAddressBook[s.destination].name));\n             entry.push_back(Pair(\"vout\", s.vout));\n             entry.push_back(Pair(\"fee\", ValueFromAmount(-nFee)));\n             if (fLong)\n@@ -1358,15 +910,15 @@ void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDe\n     {\n         BOOST_FOREACH(const COutputEntry& r, listReceived)\n         {\n-            string account;\n+            string label;\n             if (Lightwallet::pwalletMain->mapAddressBook.count(r.destination))\n-                account = Lightwallet::pwalletMain->mapAddressBook[r.destination].name;\n-            if (fAllAccounts || (account == strAccount))\n+                label = Lightwallet::pwalletMain->mapAddressBook[r.destination].label;\n+            if (fAllLabels || (label == strLabelFilter))\n             {\n                 UniValue entry(UniValue::VOBJ);\n                 if(involvesWatchonly || (Lightwallet::IsMine(*Lightwallet::pwalletMain, r.destination) & ISMINE_WATCH_ONLY))\n                     entry.push_back(Pair(\"involvesWatchonly\", true));\n-                entry.push_back(Pair(\"account\", account));\n+                entry.push_back(Pair(\"label\", label));\n                 MaybePushAddress(entry, r.destination);\n                 if (wtx.IsCoinBase())\n                 {\n@@ -1382,8 +934,6 @@ void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDe\n                     entry.push_back(Pair(\"category\", \"receive\"));\n                 }\n                 entry.push_back(Pair(\"amount\", ValueFromAmount(r.amount)));\n-                if (Lightwallet::pwalletMain->mapAddressBook.count(r.destination))\n-                    entry.push_back(Pair(\"label\", account));\n                 entry.push_back(Pair(\"vout\", r.vout));\n                 if (fLong)\n                     WalletTxToJSON(wtx, entry);\n@@ -1393,48 +943,27 @@ void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDe\n     }\n }\n \n-void AcentryToJSON(const CAccountingEntry& acentry, const string& strAccount, UniValue& ret)\n-{\n-    bool fAllAccounts = (strAccount == string(\"*\"));\n-\n-    if (fAllAccounts || acentry.strAccount == strAccount)\n-    {\n-        UniValue entry(UniValue::VOBJ);\n-        entry.push_back(Pair(\"account\", acentry.strAccount));\n-        entry.push_back(Pair(\"category\", \"move\"));\n-        entry.push_back(Pair(\"time\", acentry.nTime));\n-        entry.push_back(Pair(\"amount\", ValueFromAmount(acentry.nCreditDebit)));\n-        entry.push_back(Pair(\"otheraccount\", acentry.strOtherAccount));\n-        entry.push_back(Pair(\"comment\", acentry.strComment));\n-        ret.push_back(entry);\n-    }\n-}\n-\n UniValue listtransactions(const UniValue& params, bool fHelp)\n {\n     if (!EnsureWalletIsAvailable(fHelp))\n         return NullUniValue;\n \n     if (fHelp || params.size() > 4)\n         throw runtime_error(\n-            \"listtransactions ( \\\"account\\\" count from includeWatchonly)\\n\"\n-            \"\\nReturns up to 'count' most recent transactions skipping the first 'from' transactions for account 'account'.\\n\"\n+            \"listtransactions ( \\\"label-filter\\\" count from includeWatchonly)\\n\"\n+            \"\\nReturns up to 'count' most recent transactions skipping the first 'from' transactions with an alernative 'label-filter' (defaul is * = all labels).\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. \\\"account\\\"    (string, optional) DEPRECATED. The account name. Should be \\\"*\\\".\\n\"\n-            \"2. count          (numeric, optional, default=10) The number of transactions to return\\n\"\n-            \"3. from           (numeric, optional, default=0) The number of transactions to skip\\n\"\n-            \"4. includeWatchonly (bool, optional, default=false) Include transactions to watchonly addresses (see 'importaddress')\\n\"\n+            \"1. \\\"label-query\\\"      (string, optional) The label query. Default is \\\"*\\\".\\n\"\n+            \"2. count              (numeric, optional, default=10) The number of transactions to return\\n\"\n+            \"3. from               (numeric, optional, default=0) The number of transactions to skip\\n\"\n+            \"4. includeWatchonly   (bool, optional, default=false) Include transactions to watchonly addresses (see 'importaddress')\\n\"\n             \"\\nResult:\\n\"\n             \"[\\n\"\n             \"  {\\n\"\n-            \"    \\\"account\\\":\\\"accountname\\\",       (string) DEPRECATED. The account name associated with the transaction. \\n\"\n-            \"                                                It will be \\\"\\\" for the default account.\\n\"\n+            \"    \\\"label\\\":\\\"label\\\",               (string) The label that is associated with the transaction. \\n\"\n             \"    \\\"address\\\":\\\"bitcoinaddress\\\",    (string) The bitcoin address of the transaction. Not present for \\n\"\n             \"                                                move transactions (category = move).\\n\"\n-            \"    \\\"category\\\":\\\"send|receive|move\\\", (string) The transaction category. 'move' is a local (off blockchain)\\n\"\n-            \"                                                transaction between accounts, and not associated with an address,\\n\"\n-            \"                                                transaction id or block. 'send' and 'receive' transactions are \\n\"\n-            \"                                                associated with an address, transaction id and block details\\n\"\n+            \"    \\\"category\\\":\\\"send|receive\\\",     (string) The transaction category.\\n\"\n             \"    \\\"amount\\\": x.xxx,          (numeric) The amount in \" + CURRENCY_UNIT + \". This is negative for the 'send' category, and for the\\n\"\n             \"                                         'move' category for moves outbound. It is positive for the 'receive' category,\\n\"\n             \"                                         and for the 'move' category for inbound funds.\\n\"\n@@ -1457,9 +986,6 @@ UniValue listtransactions(const UniValue& params, bool fHelp)\n             \"                                          for 'send' and 'receive' category of transactions.\\n\"\n             \"    \\\"comment\\\": \\\"...\\\",       (string) If a comment is associated with the transaction.\\n\"\n             \"    \\\"label\\\": \\\"label\\\"        (string) A comment for the address/transaction, if any\\n\"\n-            \"    \\\"otheraccount\\\": \\\"accountname\\\",  (string) For the 'move' category of transactions, the account the funds came \\n\"\n-            \"                                          from (for receiving funds, positive amounts), or went to (for sending funds,\\n\"\n-            \"                                          negative amounts).\\n\"\n             \"    \\\"bip125-replaceable\\\": \\\"yes|no|unknown\\\"  (string) Whether this transaction could be replaced due to BIP125 (replace-by-fee);\\n\"\n             \"                                                     may be unknown for unconfirmed transactions not in the mempool\\n\"\n             \"  }\\n\"\n@@ -1476,9 +1002,9 @@ UniValue listtransactions(const UniValue& params, bool fHelp)\n \n     LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n \n-    string strAccount = \"*\";\n+    string strLabel = \"*\";\n     if (params.size() > 0)\n-        strAccount = params[0].get_str();\n+        strLabel = params[0].get_str();\n     int nCount = 10;\n     if (params.size() > 1)\n         nCount = params[1].get_int();\n@@ -1502,17 +1028,13 @@ UniValue listtransactions(const UniValue& params, bool fHelp)\n     // iterate backwards until we have nCount items to return:\n     for (CWallet::TxItems::const_reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n     {\n-        CWalletTx *const pwtx = (*it).second.first;\n+        CWalletTx *const pwtx = (*it).second;\n         if (pwtx != 0)\n-            ListTransactions(*pwtx, strAccount, 0, true, ret, filter);\n-        CAccountingEntry *const pacentry = (*it).second.second;\n-        if (pacentry != 0)\n-            AcentryToJSON(*pacentry, strAccount, ret);\n+            ListTransactions(*pwtx, strLabel, 0, true, ret, filter);\n \n         if ((int)ret.size() >= (nCount+nFrom)) break;\n     }\n     // ret is newest to oldest\n-\n     if (nFrom > (int)ret.size())\n         nFrom = ret.size();\n     if ((nFrom + nCount) > (int)ret.size())\n@@ -1537,82 +1059,48 @@ UniValue listtransactions(const UniValue& params, bool fHelp)\n     return ret;\n }\n \n-UniValue listaccounts(const UniValue& params, bool fHelp)\n+UniValue listlabels(const UniValue& params, bool fHelp)\n {\n     if (!EnsureWalletIsAvailable(fHelp))\n         return NullUniValue;\n \n-    if (fHelp || params.size() > 2)\n+    if (fHelp || params.size() > 1)\n         throw runtime_error(\n-            \"listaccounts ( minconf includeWatchonly)\\n\"\n-            \"\\nDEPRECATED. Returns Object that has account names as keys, account balances as values.\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. minconf          (numeric, optional, default=1) Only include transactions with at least this many confirmations\\n\"\n-            \"2. includeWatchonly (bool, optional, default=false) Include balances in watchonly addresses (see 'importaddress')\\n\"\n-            \"\\nResult:\\n\"\n-            \"{                      (json object where keys are account names, and values are numeric balances\\n\"\n-            \"  \\\"account\\\": x.xxx,  (numeric) The property name is the account name, and the value is the total balance for the account.\\n\"\n-            \"  ...\\n\"\n-            \"}\\n\"\n-            \"\\nExamples:\\n\"\n-            \"\\nList account balances where there at least 1 confirmation\\n\"\n-            + HelpExampleCli(\"listaccounts\", \"\") +\n-            \"\\nList account balances including zero confirmation transactions\\n\"\n-            + HelpExampleCli(\"listaccounts\", \"0\") +\n-            \"\\nList account balances for 6 or more confirmations\\n\"\n-            + HelpExampleCli(\"listaccounts\", \"6\") +\n-            \"\\nAs json rpc call\\n\"\n-            + HelpExampleRpc(\"listaccounts\", \"6\")\n-        );\n+                            \"listlabels ( \\\"purpose\\\" )\\n\"\n+                            \"\\nReturns the list of all labels, or labels that are assigned to addresses with a specific purpose.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"purpose\\\"  (string, optional) Address purpose to list labels for ('send','receive'). An empty string is the same as not providing this argument.\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"[                      (json array of string)\\n\"\n+                            \"  \\\"label\\\",  (string) Label name\\n\"\n+                            \"  ...\\n\"\n+                            \"]\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nList all labels\\n\"\n+                            + HelpExampleCli(\"listlabels\", \"\") +\n+                            \"\\nList labels that have receiving addresses\\n\"\n+                            + HelpExampleCli(\"listlabels\", \"receive\") +\n+                            \"\\nList labels that have sending addresses\\n\"\n+                            + HelpExampleCli(\"listlabels\", \"send\") +\n+                            \"\\nAs json rpc call\\n\"\n+                            + HelpExampleRpc(\"listlabels\", \"receive\")\n+                            );\n \n-    LOCK2(cs_main, Lightwallet::pwalletMain->cs_wallet);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n \n-    int nMinDepth = 1;\n+    std::string purpose;\n     if (params.size() > 0)\n-        nMinDepth = params[0].get_int();\n-    isminefilter includeWatchonly = ISMINE_SPENDABLE;\n-    if(params.size() > 1)\n-        if(params[1].get_bool())\n-            includeWatchonly = includeWatchonly | ISMINE_WATCH_ONLY;\n-\n-    map<string, CAmount> mapAccountBalances;\n-    BOOST_FOREACH(const PAIRTYPE(CTxDestination, CAddressBookData)& entry, Lightwallet::pwalletMain->mapAddressBook) {\n-        if (IsMine(*Lightwallet::pwalletMain, entry.first) & includeWatchonly) // This address belongs to me\n-            mapAccountBalances[entry.second.name] = 0;\n-    }\n-\n-    for (map<uint256, CWalletTx>::iterator it = Lightwallet::pwalletMain->mapWallet.begin(); it != Lightwallet::pwalletMain->mapWallet.end(); ++it)\n-    {\n-        const CWalletTx& wtx = (*it).second;\n-        CAmount nFee;\n-        string strSentAccount;\n-        list<COutputEntry> listReceived;\n-        list<COutputEntry> listSent;\n-        int nDepth = wtx.GetDepthInMainChain();\n-        if (wtx.GetBlocksToMaturity() > 0 || nDepth < 0)\n-            continue;\n-        wtx.GetAmounts(listReceived, listSent, nFee, strSentAccount, includeWatchonly);\n-        mapAccountBalances[strSentAccount] -= nFee;\n-        BOOST_FOREACH(const COutputEntry& s, listSent)\n-            mapAccountBalances[strSentAccount] -= s.amount;\n-        if (nDepth >= nMinDepth)\n-        {\n-            BOOST_FOREACH(const COutputEntry& r, listReceived)\n-                if (Lightwallet::pwalletMain->mapAddressBook.count(r.destination))\n-                    mapAccountBalances[Lightwallet::pwalletMain->mapAddressBook[r.destination].name] += r.amount;\n-                else\n-                    mapAccountBalances[\"\"] += r.amount;\n-        }\n-    }\n-\n-    const list<CAccountingEntry> & acentries = Lightwallet::pwalletMain->laccentries;\n-    BOOST_FOREACH(const CAccountingEntry& entry, acentries)\n-        mapAccountBalances[entry.strAccount] += entry.nCreditDebit;\n-\n-    UniValue ret(UniValue::VOBJ);\n-    BOOST_FOREACH(const PAIRTYPE(string, CAmount)& accountBalance, mapAccountBalances) {\n-        ret.push_back(Pair(accountBalance.first, ValueFromAmount(accountBalance.second)));\n+        purpose = params[0].get_str();\n+    \n+    std::set<std::string> setLabels;\n+    BOOST_FOREACH(const PAIRTYPE(CTxDestination, CAddressBookData)& entry, pwalletMain->mapAddressBook) {\n+        if (purpose.empty() || entry.second.purpose == purpose)\n+            setLabels.insert(entry.second.label);\n     }\n+    UniValue ret(UniValue::VARR);\n+    BOOST_FOREACH(const std::string &name, setLabels)\n+    ret.push_back(name);\n+    \n     return ret;\n }\n \n@@ -1632,7 +1120,6 @@ UniValue listsinceblock(const UniValue& params, bool fHelp)\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"transactions\\\": [\\n\"\n-            \"    \\\"account\\\":\\\"accountname\\\",       (string) DEPRECATED. The account name associated with the transaction. Will be \\\"\\\" for the default account.\\n\"\n             \"    \\\"address\\\":\\\"bitcoinaddress\\\",    (string) The bitcoin address of the transaction. Not present for move transactions (category = move).\\n\"\n             \"    \\\"category\\\":\\\"send|receive\\\",     (string) The transaction category. 'send' has negative amounts, 'receive' has positive amounts.\\n\"\n             \"    \\\"amount\\\": x.xxx,          (numeric) The amount in \" + CURRENCY_UNIT + \". This is negative for the 'send' category, and for the 'move' category for moves \\n\"\n@@ -1734,7 +1221,6 @@ UniValue gettransaction(const UniValue& params, bool fHelp)\n             \"                                                   may be unknown for unconfirmed transactions not in the mempool\\n\"\n             \"  \\\"details\\\" : [\\n\"\n             \"    {\\n\"\n-            \"      \\\"account\\\" : \\\"accountname\\\",  (string) DEPRECATED. The account name involved in the transaction, can be \\\"\\\" for the default account.\\n\"\n             \"      \\\"address\\\" : \\\"bitcoinaddress\\\",   (string) The bitcoin address involved in the transaction\\n\"\n             \"      \\\"category\\\" : \\\"send|receive\\\",    (string) The category, either 'send' or 'receive'\\n\"\n             \"      \\\"amount\\\" : x.xxx,                 (numeric) The amount in \" + CURRENCY_UNIT + \"\\n\"\n@@ -2350,7 +1836,7 @@ UniValue listunspent(const UniValue& params, bool fHelp)\n             \"    \\\"txid\\\" : \\\"txid\\\",        (string) the transaction id \\n\"\n             \"    \\\"vout\\\" : n,               (numeric) the vout value\\n\"\n             \"    \\\"address\\\" : \\\"address\\\",  (string) the bitcoin address\\n\"\n-            \"    \\\"account\\\" : \\\"account\\\",  (string) DEPRECATED. The associated account, or \\\"\\\" for the default account\\n\"\n+            \"    \\\"label\\\" : \\\"label\\\",      (string) The label associated to the address\\n\"\n             \"    \\\"scriptPubKey\\\" : \\\"key\\\", (string) the script key\\n\"\n             \"    \\\"amount\\\" : x.xxx,         (numeric) the transaction amount in \" + CURRENCY_UNIT + \"\\n\"\n             \"    \\\"confirmations\\\" : n       (numeric) The number of confirmations\\n\"\n@@ -2415,7 +1901,7 @@ UniValue listunspent(const UniValue& params, bool fHelp)\n         if (ExtractDestination(out.tx->vout[out.i].scriptPubKey, address)) {\n             entry.push_back(Pair(\"address\", CBitcoinAddress(address).ToString()));\n             if (Lightwallet::pwalletMain->mapAddressBook.count(address))\n-                entry.push_back(Pair(\"account\", Lightwallet::pwalletMain->mapAddressBook[address].name));\n+                entry.push_back(Pair(\"label\", Lightwallet::pwalletMain->mapAddressBook[address].label));\n         }\n         entry.push_back(Pair(\"scriptPubKey\", HexStr(pk.begin(), pk.end())));\n         if (pk.IsPayToScriptHash()) {\n@@ -2522,13 +2008,11 @@ static const CRPCCommand commands[] =\n     { \"lightwallet\",             \"wallet_dumpprivkey\",              &dumpprivkey,              true  },\n     { \"lightwallet\",             \"wallet_dumpwallet\",               &dumpwallet,               true  },\n     { \"lightwallet\",             \"wallet_encryptwallet\",            &encryptwallet,            true  },\n-    { \"lightwallet\",             \"wallet_getaccountaddress\",        &getaccountaddress,        true  },\n-    { \"lightwallet\",             \"wallet_getaccount\",               &getaccount,               true  },\n-    { \"lightwallet\",             \"wallet_getaddressesbyaccount\",    &getaddressesbyaccount,    true  },\n+    { \"lightwallet\",             \"wallet_getlabel\",                 &getlabel,                 true  },\n+    { \"lightwallet\",             \"wallet_getaddressesbylabel\",      &getaddressesbylabel,      true  },\n     { \"lightwallet\",             \"wallet_getbalance\",               &getbalance,               false },\n     { \"lightwallet\",             \"wallet_getnewaddress\",            &getnewaddress,            true  },\n     { \"lightwallet\",             \"wallet_getrawchangeaddress\",      &getrawchangeaddress,      true  },\n-    { \"lightwallet\",             \"wallet_getreceivedbyaccount\",     &getreceivedbyaccount,     false },\n     { \"lightwallet\",             \"wallet_getreceivedbyaddress\",     &getreceivedbyaddress,     false },\n     { \"lightwallet\",             \"wallet_gettransaction\",           &gettransaction,           false },\n     { \"lightwallet\",             \"wallet_getunconfirmedbalance\",    &getunconfirmedbalance,    false },\n@@ -2539,20 +2023,16 @@ static const CRPCCommand commands[] =\n     { \"lightwallet\",             \"wallet_importprunedfunds\",        &importprunedfunds,        true  },\n     { \"lightwallet\",             \"wallet_importpubkey\",             &importpubkey,             true  },\n     { \"lightwallet\",             \"wallet_keypoolrefill\",            &keypoolrefill,            true  },\n-    { \"lightwallet\",             \"wallet_listaccounts\",             &listaccounts,             false },\n+    { \"lightwallet\",             \"wallet_listlabels\",               &listlabels,               false },\n     { \"lightwallet\",             \"wallet_listaddressgroupings\",     &listaddressgroupings,     false },\n     { \"lightwallet\",             \"wallet_listlockunspent\",          &listlockunspent,          false },\n-    { \"lightwallet\",             \"wallet_listreceivedbyaccount\",    &listreceivedbyaccount,    false },\n     { \"lightwallet\",             \"wallet_listreceivedbyaddress\",    &listreceivedbyaddress,    false },\n     { \"lightwallet\",             \"wallet_listsinceblock\",           &listsinceblock,           false },\n     { \"lightwallet\",             \"wallet_listtransactions\",         &listtransactions,         false },\n     { \"lightwallet\",             \"wallet_listunspent\",              &listunspent,              false },\n     { \"lightwallet\",             \"wallet_lockunspent\",              &lockunspent,              true  },\n-    { \"lightwallet\",             \"wallet_move\",                     &movecmd,                  false },\n-    { \"lightwallet\",             \"wallet_sendfrom\",                 &sendfrom,                 false },\n-    { \"lightwallet\",             \"wallet_sendmany\",                 &sendmany,                 false },\n-    { \"lightwallet\",             \"wallet_sendtoaddress\",            &sendtoaddress,            false },\n-    { \"lightwallet\",             \"wallet_setaccount\",               &setaccount,               true  },\n+    { \"lightwallet\",             \"wallet_sendto\",                   &sendto,                   false },\n+    { \"lightwallet\",             \"wallet_setlabel\",                 &setlabel,                 true  },\n     { \"lightwallet\",             \"wallet_settxfee\",                 &settxfee,                 true  },\n     { \"lightwallet\",             \"wallet_signmessage\",              &signmessage,              true  },\n     { \"lightwallet\",             \"wallet_walletlock\",               &walletlock,               true  },"
      },
      {
        "sha": "814d70799dfd36a6f5cc6662df20f1c3db92eb70",
        "filename": "src/lightwallet/wallet.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 71,
        "changes": 85,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9b9de57317eb47d1124de6df972076decdfceebd/src/lightwallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9b9de57317eb47d1124de6df972076decdfceebd/src/lightwallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/wallet.cpp?ref=9b9de57317eb47d1124de6df972076decdfceebd",
        "patch": "@@ -468,7 +468,6 @@ void CWallet::SyncMetaData(pair<TxSpends::iterator, TxSpends::iterator> range)\n         // nTimeReceived not copied on purpose\n         copyTo->nTimeSmart = copyFrom->nTimeSmart;\n         copyTo->fFromMe = copyFrom->fFromMe;\n-        copyTo->strFromAccount = copyFrom->strFromAccount;\n         // nOrderPos not copied on purpose\n         // cached members not copied on purpose\n     }\n@@ -641,7 +640,7 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn, bool fFromLoadWallet, CWalletD\n         mapWallet[hash] = wtxIn;\n         CWalletTx& wtx = mapWallet[hash];\n         wtx.BindWallet(this);\n-        wtxOrdered.insert(make_pair(wtx.nOrderPos, TxPair(&wtx, (CAccountingEntry*)0)));\n+        wtxOrdered.insert(make_pair(wtx.nOrderPos, &wtx));\n         AddToSpends(hash);\n         BOOST_FOREACH(const CTxIn& txin, wtx.vin) {\n             if (mapWallet.count(txin.prevout.hash)) {\n@@ -664,7 +663,7 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn, bool fFromLoadWallet, CWalletD\n         {\n             wtx.nTimeReceived = GetAdjustedTime();\n             wtx.nOrderPos = IncOrderPosNext(pwalletdb);\n-            wtxOrdered.insert(make_pair(wtx.nOrderPos, TxPair(&wtx, (CAccountingEntry*)0)));\n+            wtxOrdered.insert(make_pair(wtx.nOrderPos, &wtx));\n \n             wtx.nTimeSmart = wtx.nTimeReceived;\n             if (!wtxIn.hashUnset())\n@@ -679,19 +678,12 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn, bool fFromLoadWallet, CWalletD\n                         const TxItems & txOrdered = wtxOrdered;\n                         for (TxItems::const_reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n                         {\n-                            CWalletTx *const pwtx = (*it).second.first;\n+                            CWalletTx *const pwtx = (*it).second;\n                             if (pwtx == &wtx)\n                                 continue;\n-                            CAccountingEntry *const pacentry = (*it).second.second;\n-                            int64_t nSmartTime;\n-                            if (pwtx)\n-                            {\n-                                nSmartTime = pwtx->nTimeSmart;\n-                                if (!nSmartTime)\n-                                    nSmartTime = pwtx->nTimeReceived;\n-                            }\n-                            else\n-                                nSmartTime = pacentry->nTime;\n+                            int64_t nSmartTime = pwtx->nTimeSmart;\n+                            if (!nSmartTime)\n+                                nSmartTime = pwtx->nTimeReceived;\n                             if (nSmartTime <= latestTolerated)\n                             {\n                                 latestEntry = nSmartTime;\n@@ -1112,12 +1104,11 @@ int CWalletTx::GetRequestCount() const\n }\n \n void CWalletTx::GetAmounts(list<COutputEntry>& listReceived,\n-                           list<COutputEntry>& listSent, CAmount& nFee, string& strSentAccount, const isminefilter& filter) const\n+                           list<COutputEntry>& listSent, CAmount& nFee, const isminefilter& filter) const\n {\n     nFee = 0;\n     listReceived.clear();\n     listSent.clear();\n-    strSentAccount = strFromAccount;\n \n     // Compute fee:\n     CAmount nDebit = GetDebit(filter);\n@@ -1167,41 +1158,6 @@ void CWalletTx::GetAmounts(list<COutputEntry>& listReceived,\n \n }\n \n-void CWalletTx::GetAccountAmounts(const string& strAccount, CAmount& nReceived,\n-                                  CAmount& nSent, CAmount& nFee, const isminefilter& filter) const\n-{\n-    nReceived = nSent = nFee = 0;\n-\n-    CAmount allFee;\n-    string strSentAccount;\n-    list<COutputEntry> listReceived;\n-    list<COutputEntry> listSent;\n-    GetAmounts(listReceived, listSent, allFee, strSentAccount, filter);\n-\n-    if (strAccount == strSentAccount)\n-    {\n-        BOOST_FOREACH(const COutputEntry& s, listSent)\n-            nSent += s.amount;\n-        nFee = allFee;\n-    }\n-    {\n-        LOCK(pwallet->cs_wallet);\n-        BOOST_FOREACH(const COutputEntry& r, listReceived)\n-        {\n-            if (pwallet->mapAddressBook.count(r.destination))\n-            {\n-                map<CTxDestination, CAddressBookData>::const_iterator mi = pwallet->mapAddressBook.find(r.destination);\n-                if (mi != pwallet->mapAddressBook.end() && (*mi).second.name == strAccount)\n-                    nReceived += r.amount;\n-            }\n-            else if (strAccount.empty())\n-            {\n-                nReceived += r.amount;\n-            }\n-        }\n-    }\n-}\n-\n \n bool CWalletTx::WriteToDisk(CWalletDB *pwalletdb)\n {\n@@ -2311,18 +2267,6 @@ bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n     return true;\n }\n \n-bool CWallet::AddAccountingEntry(const CAccountingEntry& acentry, CWalletDB & pwalletdb)\n-{\n-    if (!pwalletdb.WriteAccountingEntry_Backend(acentry))\n-        return false;\n-\n-    laccentries.push_back(acentry);\n-    CAccountingEntry & entry = laccentries.back();\n-    wtxOrdered.insert(make_pair(entry.nOrderPos, TxPair((CWalletTx*)0, &entry)));\n-\n-    return true;\n-}\n-\n CAmount CWallet::GetRequiredFee(unsigned int nTxBytes)\n {\n     return std::max(minTxFee.GetFee(nTxBytes), ::minRelayTxFee.GetFee(nTxBytes));\n@@ -2426,24 +2370,24 @@ DBErrors CWallet::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n }\n \n \n-bool CWallet::SetAddressBook(const CTxDestination& address, const string& strName, const string& strPurpose)\n+bool CWallet::SetAddressBook(const CTxDestination& address, const string& strLabel, const string& strPurpose)\n {\n     bool fUpdated = false;\n     {\n         LOCK(cs_wallet); // mapAddressBook\n         std::map<CTxDestination, CAddressBookData>::iterator mi = mapAddressBook.find(address);\n         fUpdated = mi != mapAddressBook.end();\n-        mapAddressBook[address].name = strName;\n+        mapAddressBook[address].label = strLabel;\n         if (!strPurpose.empty()) /* update purpose only if requested */\n             mapAddressBook[address].purpose = strPurpose;\n     }\n-    NotifyAddressBookChanged(this, address, strName, Lightwallet::IsMine(*this, address) != ISMINE_NO,\n+    NotifyAddressBookChanged(this, address, strLabel, Lightwallet::IsMine(*this, address) != ISMINE_NO,\n                              strPurpose, (fUpdated ? CT_UPDATED : CT_NEW) );\n     if (!fFileBacked)\n         return false;\n     if (!strPurpose.empty() && !CWalletDB(strWalletFile).WritePurpose(CBitcoinAddress(address).ToString(), strPurpose))\n         return false;\n-    return CWalletDB(strWalletFile).WriteName(CBitcoinAddress(address).ToString(), strName);\n+    return CWalletDB(strWalletFile).WriteLabel(CBitcoinAddress(address).ToString(), strLabel);\n }\n \n bool CWallet::DelAddressBook(const CTxDestination& address)\n@@ -2752,15 +2696,15 @@ set< set<CTxDestination> > CWallet::GetAddressGroupings()\n     return ret;\n }\n \n-std::set<CTxDestination> CWallet::GetAccountAddresses(const std::string& strAccount) const\n+std::set<CTxDestination> CWallet::GetAddressesWithLabel(const std::string& strLabel) const\n {\n     LOCK(cs_wallet);\n     set<CTxDestination> result;\n     BOOST_FOREACH(const PAIRTYPE(CTxDestination, CAddressBookData)& item, mapAddressBook)\n     {\n         const CTxDestination& address = item.first;\n-        const string& strName = item.second.name;\n-        if (strName == strAccount)\n+        const string& curLabel = item.second.label;\n+        if (curLabel == strLabel)\n             result.insert(address);\n     }\n     return result;\n@@ -3178,7 +3122,6 @@ bool CWallet::InitLoadWallet()\n                     copyTo->nTimeReceived = copyFrom->nTimeReceived;\n                     copyTo->nTimeSmart = copyFrom->nTimeSmart;\n                     copyTo->fFromMe = copyFrom->fFromMe;\n-                    copyTo->strFromAccount = copyFrom->strFromAccount;\n                     copyTo->nOrderPos = copyFrom->nOrderPos;\n                     copyTo->WriteToDisk(&walletdb);\n                 }"
      },
      {
        "sha": "96f6397f40defb3b1a519d4d1a90aeb6c42a57a8",
        "filename": "src/lightwallet/wallet.h",
        "status": "modified",
        "additions": 4,
        "deletions": 127,
        "changes": 131,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9b9de57317eb47d1124de6df972076decdfceebd/src/lightwallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9b9de57317eb47d1124de6df972076decdfceebd/src/lightwallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/wallet.h?ref=9b9de57317eb47d1124de6df972076decdfceebd",
        "patch": "@@ -106,7 +106,7 @@ class CKeyPool\n class CAddressBookData\n {\n public:\n-    std::string name;\n+    std::string label;\n     std::string purpose;\n \n     CAddressBookData()\n@@ -233,7 +233,6 @@ class CWalletTx : public CMerkleTx\n     unsigned int nTimeReceived; //!< time received by this node\n     unsigned int nTimeSmart;\n     char fFromMe;\n-    std::string strFromAccount;\n     int64_t nOrderPos; //!< position in ordered transaction list\n \n     // memory only\n@@ -285,7 +284,6 @@ class CWalletTx : public CMerkleTx\n         nTimeReceived = 0;\n         nTimeSmart = 0;\n         fFromMe = false;\n-        strFromAccount.clear();\n         fDebitCached = false;\n         fCreditCached = false;\n         fImmatureCreditCached = false;\n@@ -317,8 +315,6 @@ class CWalletTx : public CMerkleTx\n \n         if (!ser_action.ForRead())\n         {\n-            mapValue[\"fromaccount\"] = strFromAccount;\n-\n             WriteOrderPos(nOrderPos, mapValue);\n \n             if (nTimeSmart)\n@@ -337,14 +333,11 @@ class CWalletTx : public CMerkleTx\n \n         if (ser_action.ForRead())\n         {\n-            strFromAccount = mapValue[\"fromaccount\"];\n-\n             ReadOrderPos(nOrderPos, mapValue);\n \n             nTimeSmart = mapValue.count(\"timesmart\") ? (unsigned int)atoi64(mapValue[\"timesmart\"]) : 0;\n         }\n \n-        mapValue.erase(\"fromaccount\");\n         mapValue.erase(\"version\");\n         mapValue.erase(\"spent\");\n         mapValue.erase(\"n\");\n@@ -380,10 +373,8 @@ class CWalletTx : public CMerkleTx\n     CAmount GetChange() const;\n \n     void GetAmounts(std::list<COutputEntry>& listReceived,\n-                    std::list<COutputEntry>& listSent, CAmount& nFee, std::string& strSentAccount, const isminefilter& filter) const;\n+                    std::list<COutputEntry>& listSent, CAmount& nFee, const isminefilter& filter) const;\n \n-    void GetAccountAmounts(const std::string& strAccount, CAmount& nReceived,\n-                           CAmount& nSent, CAmount& nFee, const isminefilter& filter) const;\n \n     bool IsFromMe(const isminefilter& filter) const\n     {\n@@ -454,87 +445,6 @@ class CWalletKey\n     }\n };\n \n-/**\n- * Internal transfers.\n- * Database key is acentry<account><counter>.\n- */\n-class CAccountingEntry\n-{\n-public:\n-    std::string strAccount;\n-    CAmount nCreditDebit;\n-    int64_t nTime;\n-    std::string strOtherAccount;\n-    std::string strComment;\n-    mapValue_t mapValue;\n-    int64_t nOrderPos; //!< position in ordered transaction list\n-    uint64_t nEntryNo;\n-\n-    CAccountingEntry()\n-    {\n-        SetNull();\n-    }\n-\n-    void SetNull()\n-    {\n-        nCreditDebit = 0;\n-        nTime = 0;\n-        strAccount.clear();\n-        strOtherAccount.clear();\n-        strComment.clear();\n-        nOrderPos = -1;\n-        nEntryNo = 0;\n-    }\n-\n-    ADD_SERIALIZE_METHODS;\n-\n-    template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n-        if (!(nType & SER_GETHASH))\n-            READWRITE(nVersion);\n-        //! Note: strAccount is serialized as part of the key, not here.\n-        READWRITE(nCreditDebit);\n-        READWRITE(nTime);\n-        READWRITE(LIMITED_STRING(strOtherAccount, 65536));\n-\n-        if (!ser_action.ForRead())\n-        {\n-            WriteOrderPos(nOrderPos, mapValue);\n-\n-            if (!(mapValue.empty() && _ssExtra.empty()))\n-            {\n-                CDataStream ss(nType, nVersion);\n-                ss.insert(ss.begin(), '\\0');\n-                ss << mapValue;\n-                ss.insert(ss.end(), _ssExtra.begin(), _ssExtra.end());\n-                strComment.append(ss.str());\n-            }\n-        }\n-\n-        READWRITE(LIMITED_STRING(strComment, 65536));\n-\n-        size_t nSepPos = strComment.find(\"\\0\", 0, 1);\n-        if (ser_action.ForRead())\n-        {\n-            mapValue.clear();\n-            if (std::string::npos != nSepPos)\n-            {\n-                CDataStream ss(std::vector<char>(strComment.begin() + nSepPos + 1, strComment.end()), nType, nVersion);\n-                ss >> mapValue;\n-                _ssExtra = std::vector<char>(ss.begin(), ss.end());\n-            }\n-            ReadOrderPos(nOrderPos, mapValue);\n-        }\n-        if (std::string::npos != nSepPos)\n-            strComment.erase(nSepPos);\n-\n-        mapValue.erase(\"n\");\n-    }\n-\n-private:\n-    std::vector<char> _ssExtra;\n-};\n-\n \n /** \n  * A CWallet is an extension of a keystore, which also maintains a set of transactions and balances,\n@@ -631,10 +541,7 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     }\n \n     std::map<uint256, CWalletTx> mapWallet;\n-    std::list<CAccountingEntry> laccentries;\n-\n-    typedef std::pair<CWalletTx*, CAccountingEntry*> TxPair;\n-    typedef std::multimap<int64_t, TxPair > TxItems;\n+    typedef std::multimap<int64_t, CWalletTx *> TxItems;\n     TxItems wtxOrdered;\n \n     int64_t nOrderPosNext;\n@@ -751,7 +658,6 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n                            std::string& strFailReason, const CCoinControl *coinControl = NULL, bool sign = true);\n     bool CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey);\n \n-    bool AddAccountingEntry(const CAccountingEntry&, CWalletDB & pwalletdb);\n \n     static CFeeRate minTxFee;\n     static CFeeRate fallbackFee;\n@@ -778,7 +684,7 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     std::set< std::set<CTxDestination> > GetAddressGroupings();\n     std::map<CTxDestination, CAmount> GetAddressBalances();\n \n-    std::set<CTxDestination> GetAccountAddresses(const std::string& strAccount) const;\n+    std::set<CTxDestination> GetAddressesWithLabel(const std::string& strLabel) const;\n \n     isminetype IsMine(const CTxIn& txin) const;\n     CAmount GetDebit(const CTxIn& txin, const isminefilter& filter) const;\n@@ -912,34 +818,5 @@ class CReserveKey : public CReserveScript\n     void KeepScript() { KeepKey(); }\n };\n \n-\n-/** \n- * Account information.\n- * Stored in wallet with key \"acc\"+string account name.\n- */\n-class CAccount\n-{\n-public:\n-    CPubKey vchPubKey;\n-\n-    CAccount()\n-    {\n-        SetNull();\n-    }\n-\n-    void SetNull()\n-    {\n-        vchPubKey = CPubKey();\n-    }\n-\n-    ADD_SERIALIZE_METHODS;\n-\n-    template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n-        if (!(nType & SER_GETHASH))\n-            READWRITE(nVersion);\n-        READWRITE(vchPubKey);\n-    }\n-};\n }\n #endif // BITCOIN_LIGHTWALLET_WALLET_H"
      },
      {
        "sha": "11c43dde71a67a61c77e9d729eeb36ad0e595731",
        "filename": "src/lightwallet/walletdb.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 154,
        "changes": 170,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9b9de57317eb47d1124de6df972076decdfceebd/src/lightwallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9b9de57317eb47d1124de6df972076decdfceebd/src/lightwallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/walletdb.cpp?ref=9b9de57317eb47d1124de6df972076decdfceebd",
        "patch": "@@ -25,16 +25,14 @@ namespace Lightwallet {\n \n using namespace std;\n \n-static uint64_t nAccountingEntryNumber = 0;\n-\n //\n // CWalletDB\n //\n \n-bool CWalletDB::WriteName(const string& strAddress, const string& strName)\n+bool CWalletDB::WriteLabel(const string& strAddress, const string& strName)\n {\n     nWalletDBUpdated++;\n-    return Write(make_pair(string(\"name\"), strAddress), strName);\n+    return Write(make_pair(string(\"label\"), strAddress), strName);\n }\n \n bool CWalletDB::EraseName(const string& strAddress)\n@@ -178,127 +176,40 @@ bool CWalletDB::WriteMinVersion(int nVersion)\n     return Write(std::string(\"minversion\"), nVersion);\n }\n \n-bool CWalletDB::ReadAccount(const string& strAccount, CAccount& account)\n-{\n-    account.SetNull();\n-    return Read(make_pair(string(\"acc\"), strAccount), account);\n-}\n-\n-bool CWalletDB::WriteAccount(const string& strAccount, const CAccount& account)\n-{\n-    return Write(make_pair(string(\"acc\"), strAccount), account);\n-}\n-\n-bool CWalletDB::WriteAccountingEntry(const uint64_t nAccEntryNum, const CAccountingEntry& acentry)\n-{\n-    return Write(std::make_pair(std::string(\"acentry\"), std::make_pair(acentry.strAccount, nAccEntryNum)), acentry);\n-}\n-\n-bool CWalletDB::WriteAccountingEntry_Backend(const CAccountingEntry& acentry)\n-{\n-    return WriteAccountingEntry(++nAccountingEntryNumber, acentry);\n-}\n-\n-CAmount CWalletDB::GetAccountCreditDebit(const string& strAccount)\n-{\n-    list<CAccountingEntry> entries;\n-    ListAccountCreditDebit(strAccount, entries);\n-\n-    CAmount nCreditDebit = 0;\n-    BOOST_FOREACH (const CAccountingEntry& entry, entries)\n-        nCreditDebit += entry.nCreditDebit;\n-\n-    return nCreditDebit;\n-}\n-\n-void CWalletDB::ListAccountCreditDebit(const string& strAccount, list<CAccountingEntry>& entries)\n-{\n-    bool fAllAccounts = (strAccount == \"*\");\n-\n-    Dbc* pcursor = GetCursor();\n-    if (!pcursor)\n-        throw runtime_error(\"CWalletDB::ListAccountCreditDebit(): cannot create DB cursor\");\n-    unsigned int fFlags = DB_SET_RANGE;\n-    while (true)\n-    {\n-        // Read next record\n-        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n-        if (fFlags == DB_SET_RANGE)\n-            ssKey << std::make_pair(std::string(\"acentry\"), std::make_pair((fAllAccounts ? string(\"\") : strAccount), uint64_t(0)));\n-        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n-        int ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n-        fFlags = DB_NEXT;\n-        if (ret == DB_NOTFOUND)\n-            break;\n-        else if (ret != 0)\n-        {\n-            pcursor->close();\n-            throw runtime_error(\"CWalletDB::ListAccountCreditDebit(): error scanning DB\");\n-        }\n-\n-        // Unserialize\n-        string strType;\n-        ssKey >> strType;\n-        if (strType != \"acentry\")\n-            break;\n-        CAccountingEntry acentry;\n-        ssKey >> acentry.strAccount;\n-        if (!fAllAccounts && acentry.strAccount != strAccount)\n-            break;\n-\n-        ssValue >> acentry;\n-        ssKey >> acentry.nEntryNo;\n-        entries.push_back(acentry);\n-    }\n-\n-    pcursor->close();\n-}\n-\n DBErrors CWalletDB::ReorderTransactions(CWallet* pwallet)\n {\n     LOCK(pwallet->cs_wallet);\n     // Old wallets didn't have any defined order for transactions\n     // Probably a bad idea to change the output of this\n \n-    // First: get all CWalletTx and CAccountingEntry into a sorted-by-time multimap.\n-    typedef pair<CWalletTx*, CAccountingEntry*> TxPair;\n-    typedef multimap<int64_t, TxPair > TxItems;\n+    // First: get all CWalletTx into a sorted-by-time multimap.\n+    typedef multimap<int64_t, CWalletTx * > TxItems;\n     TxItems txByTime;\n \n     for (map<uint256, CWalletTx>::iterator it = pwallet->mapWallet.begin(); it != pwallet->mapWallet.end(); ++it)\n     {\n         CWalletTx* wtx = &((*it).second);\n-        txByTime.insert(make_pair(wtx->nTimeReceived, TxPair(wtx, (CAccountingEntry*)0)));\n-    }\n-    list<CAccountingEntry> acentries;\n-    ListAccountCreditDebit(\"\", acentries);\n-    BOOST_FOREACH(CAccountingEntry& entry, acentries)\n-    {\n-        txByTime.insert(make_pair(entry.nTime, TxPair((CWalletTx*)0, &entry)));\n+        txByTime.insert(make_pair(wtx->nTimeReceived, wtx));\n     }\n \n     int64_t& nOrderPosNext = pwallet->nOrderPosNext;\n     nOrderPosNext = 0;\n     std::vector<int64_t> nOrderPosOffsets;\n     for (TxItems::iterator it = txByTime.begin(); it != txByTime.end(); ++it)\n     {\n-        CWalletTx *const pwtx = (*it).second.first;\n-        CAccountingEntry *const pacentry = (*it).second.second;\n-        int64_t& nOrderPos = (pwtx != 0) ? pwtx->nOrderPos : pacentry->nOrderPos;\n+        CWalletTx *const pwtx = (*it).second;\n+        if (!pwtx)\n+            continue;\n+\n+        int64_t& nOrderPos = pwtx->nOrderPos;\n \n         if (nOrderPos == -1)\n         {\n             nOrderPos = nOrderPosNext++;\n             nOrderPosOffsets.push_back(nOrderPos);\n \n-            if (pwtx)\n-            {\n-                if (!WriteTx(pwtx->GetHash(), *pwtx))\n-                    return DB_LOAD_FAIL;\n-            }\n-            else\n-                if (!WriteAccountingEntry(pacentry->nEntryNo, *pacentry))\n-                    return DB_LOAD_FAIL;\n+            if (!WriteTx(pwtx->GetHash(), *pwtx))\n+                return DB_LOAD_FAIL;\n         }\n         else\n         {\n@@ -315,14 +226,8 @@ DBErrors CWalletDB::ReorderTransactions(CWallet* pwallet)\n                 continue;\n \n             // Since we're changing the order, write it back\n-            if (pwtx)\n-            {\n-                if (!WriteTx(pwtx->GetHash(), *pwtx))\n-                    return DB_LOAD_FAIL;\n-            }\n-            else\n-                if (!WriteAccountingEntry(pacentry->nEntryNo, *pacentry))\n-                    return DB_LOAD_FAIL;\n+            if (!WriteTx(pwtx->GetHash(), *pwtx))\n+                return DB_LOAD_FAIL;\n         }\n     }\n     WriteOrderPosNext(nOrderPosNext);\n@@ -357,11 +262,11 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n         // Taking advantage of the fact that pair serialization\n         // is just the two items serialized one after the other\n         ssKey >> strType;\n-        if (strType == \"name\")\n+        if (strType == \"label\")\n         {\n             string strAddress;\n             ssKey >> strAddress;\n-            ssValue >> pwallet->mapAddressBook[CBitcoinAddress(strAddress).Get()].name;\n+            ssValue >> pwallet->mapAddressBook[CBitcoinAddress(strAddress).Get()].label;\n         }\n         else if (strType == \"purpose\")\n         {\n@@ -379,48 +284,11 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n             if (!(CheckTransaction(wtx, state) && (wtx.GetHash() == hash) && state.IsValid()))\n                 return false;\n \n-            // Undo serialize changes in 31600\n-            if (31404 <= wtx.fTimeReceivedIsTxTime && wtx.fTimeReceivedIsTxTime <= 31703)\n-            {\n-                if (!ssValue.empty())\n-                {\n-                    char fTmp;\n-                    char fUnused;\n-                    ssValue >> fTmp >> fUnused >> wtx.strFromAccount;\n-                    strErr = strprintf(\"LoadWallet() upgrading tx ver=%d %d '%s' %s\",\n-                                       wtx.fTimeReceivedIsTxTime, fTmp, wtx.strFromAccount, hash.ToString());\n-                    wtx.fTimeReceivedIsTxTime = fTmp;\n-                }\n-                else\n-                {\n-                    strErr = strprintf(\"LoadWallet() repairing tx ver=%d %s\", wtx.fTimeReceivedIsTxTime, hash.ToString());\n-                    wtx.fTimeReceivedIsTxTime = 0;\n-                }\n-                wss.vWalletUpgrade.push_back(hash);\n-            }\n-\n             if (wtx.nOrderPos == -1)\n                 wss.fAnyUnordered = true;\n \n             pwallet->AddToWallet(wtx, true, NULL);\n         }\n-        else if (strType == \"acentry\")\n-        {\n-            string strAccount;\n-            ssKey >> strAccount;\n-            uint64_t nNumber;\n-            ssKey >> nNumber;\n-            if (nNumber > nAccountingEntryNumber)\n-                nAccountingEntryNumber = nNumber;\n-\n-            if (!wss.fAnyUnordered)\n-            {\n-                CAccountingEntry acentry;\n-                ssValue >> acentry;\n-                if (acentry.nOrderPos == -1)\n-                    wss.fAnyUnordered = true;\n-            }\n-        }\n         else if (strType == \"watchs\")\n         {\n             CScript script;\n@@ -712,12 +580,6 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n     if (wss.fAnyUnordered)\n         result = ReorderTransactions(pwallet);\n \n-    pwallet->laccentries.clear();\n-    ListAccountCreditDebit(\"*\", pwallet->laccentries);\n-    BOOST_FOREACH(CAccountingEntry& entry, pwallet->laccentries) {\n-        pwallet->wtxOrdered.insert(make_pair(entry.nOrderPos, CWallet::TxPair((CWalletTx*)0, &entry)));\n-    }\n-\n     return result;\n }\n "
      },
      {
        "sha": "8aaa42c6771932a0789ce3d74735a5ce0f28e1da",
        "filename": "src/lightwallet/walletdb.h",
        "status": "modified",
        "additions": 1,
        "deletions": 13,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9b9de57317eb47d1124de6df972076decdfceebd/src/lightwallet/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9b9de57317eb47d1124de6df972076decdfceebd/src/lightwallet/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/walletdb.h?ref=9b9de57317eb47d1124de6df972076decdfceebd",
        "patch": "@@ -24,8 +24,6 @@ class uint256;\n \n namespace Lightwallet {\n \n-class CAccount;\n-class CAccountingEntry;\n class CWallet;\n class CWalletTx;\n class CKeyPool;\n@@ -85,7 +83,7 @@ class CWalletDB : public CDB\n     {\n     }\n \n-    bool WriteName(const std::string& strAddress, const std::string& strName);\n+    bool WriteLabel(const std::string& strAddress, const std::string& strLabel);\n     bool EraseName(const std::string& strAddress);\n \n     bool WritePurpose(const std::string& strAddress, const std::string& purpose);\n@@ -116,19 +114,11 @@ class CWalletDB : public CDB\n \n     bool WriteMinVersion(int nVersion);\n \n-    /// This writes directly to the database, and will not update the CWallet's cached accounting entries!\n-    /// Use wallet.AddAccountingEntry instead, to write *and* update its caches.\n-    bool WriteAccountingEntry_Backend(const CAccountingEntry& acentry);\n-    bool ReadAccount(const std::string& strAccount, CAccount& account);\n-    bool WriteAccount(const std::string& strAccount, const CAccount& account);\n-\n     /// Write destination data key,value tuple to database\n     bool WriteDestData(const std::string &address, const std::string &key, const std::string &value);\n     /// Erase destination data tuple from wallet database\n     bool EraseDestData(const std::string &address, const std::string &key);\n \n-    CAmount GetAccountCreditDebit(const std::string& strAccount);\n-    void ListAccountCreditDebit(const std::string& strAccount, std::list<CAccountingEntry>& acentries);\n \n     DBErrors ReorderTransactions(CWallet* pwallet);\n     DBErrors LoadWallet(CWallet* pwallet);\n@@ -141,8 +131,6 @@ class CWalletDB : public CDB\n private:\n     CWalletDB(const CWalletDB&);\n     void operator=(const CWalletDB&);\n-\n-    bool WriteAccountingEntry(const uint64_t nAccEntryNum, const CAccountingEntry& acentry);\n };\n \n bool BackupWallet(const CWallet& wallet, const std::string& strDest);"
      }
    ]
  },
  {
    "sha": "5a367319ced9abd9cf1c75ab64abaf5ddeaa4543",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1YTM2NzMxOWNlZDlhYmQ5Y2YxYzc1YWI2NGFiYWY1ZGRlYWE0NTQz",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2016-04-07T08:55:35Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2016-04-13T08:49:17Z"
      },
      "message": "[Lightwallet] remove version detection and backward-comp. fixes",
      "tree": {
        "sha": "44c5120a4c13af951b6e125b864b21114c964df4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/44c5120a4c13af951b6e125b864b21114c964df4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5a367319ced9abd9cf1c75ab64abaf5ddeaa4543",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "expired_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXDggNAAoJECnUvLZBb1PsTIsQAIaNCW3Mwg8I84X2Jnbsrvjj\nTvHy6nNPA5pj+zmhc8ZdSNQxvyAqbPbu6Qsr41tEQMct5aCq1Atd6kUEaeGlpIvU\nAssfMr/mDRN+wN/AyWEqiXuX2MWjs4d8CAT6Q8bDRIAf5SycyXW7WE28QtHu5Tqx\n79Suaml9Mf0OMBCR0nluFMTPqeVYjvaTn5THBdx/VzE9s+iKp/IbdqfZWQe6ajrs\nt5lu3biJ3b7vr0Q02bT+9dbOdR+mKC1RVhdzU+eHmV7m6Ga75TkC0n/hgt29CvkV\nBny4aap+XWhs2zTjedimFyaNX9ksKupKrH4IhlnAK1AIuQTTXb8K/ALG27a0QuXJ\nlQSUhTg5f8vjRCQq9fwiaYgbso2G7wD0mhXiNAWZOI1wISSv8IW9ozfdnCWSzKpf\nEYQ1qWIOI9AAJeX/ZsHzWfBu0yjWMNhCmRSgplUjugDxeZFOaheCgMKtkUTWNrPG\nT8Yytt5z1m1qbh2V515fdLCwU/SXidfKBbDB87kWQrJTUlCiCfUDIbB4/z2btGQp\neaztmQx53FgvlEgLEBIwACJlGXKNxOr8kW0IfdbHeDBX+5DOo1lunRkByiq5ocu9\nE2cDV7x6SqEpgNvtkIwhUDgkGFt3g2fdgABSaYGjNNNgtau748ls5fL3Zq/3/a+C\ngfORSk1JlB8DiWqkkdTx\n=DavV\n-----END PGP SIGNATURE-----",
        "payload": "tree 44c5120a4c13af951b6e125b864b21114c964df4\nparent 9b9de57317eb47d1124de6df972076decdfceebd\nauthor Jonas Schnelli <dev@jonasschnelli.ch> 1460019335 +0200\ncommitter Jonas Schnelli <dev@jonasschnelli.ch> 1460537357 +0200\n\n[Lightwallet] remove version detection and backward-comp. fixes\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5a367319ced9abd9cf1c75ab64abaf5ddeaa4543",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5a367319ced9abd9cf1c75ab64abaf5ddeaa4543",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5a367319ced9abd9cf1c75ab64abaf5ddeaa4543/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9b9de57317eb47d1124de6df972076decdfceebd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9b9de57317eb47d1124de6df972076decdfceebd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9b9de57317eb47d1124de6df972076decdfceebd"
      }
    ],
    "stats": {
      "total": 41,
      "additions": 6,
      "deletions": 35
    },
    "files": [
      {
        "sha": "d1d7d66c17a2747112be2f11eadc72ff8da7ff70",
        "filename": "src/lightwallet/wallet.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 11,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5a367319ced9abd9cf1c75ab64abaf5ddeaa4543/src/lightwallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5a367319ced9abd9cf1c75ab64abaf5ddeaa4543/src/lightwallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/wallet.cpp?ref=5a367319ced9abd9cf1c75ab64abaf5ddeaa4543",
        "patch": "@@ -88,14 +88,9 @@ const CWalletTx* CWallet::GetWalletTx(const uint256& hash) const\n CPubKey CWallet::GenerateNewKey()\n {\n     AssertLockHeld(cs_wallet); // mapKeyMetadata\n-    bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets\n \n     CKey secret;\n-    secret.MakeNewKey(fCompressed);\n-\n-    // Compressed public keys were introduced in version 0.6.0\n-    if (fCompressed)\n-        SetMinVersion(FEATURE_COMPRPUBKEY);\n+    secret.MakeNewKey(true);\n \n     CPubKey pubkey = secret.GetPubKey();\n     assert(secret.VerifyPubKey(pubkey));\n@@ -317,8 +312,7 @@ bool CWallet::SetMinVersion(enum WalletFeature nVersion, CWalletDB* pwalletdbIn,\n     if (fFileBacked)\n     {\n         CWalletDB* pwalletdb = pwalletdbIn ? pwalletdbIn : new CWalletDB(strWalletFile);\n-        if (nWalletVersion > 40000)\n-            pwalletdb->WriteMinVersion(nWalletVersion);\n+        pwalletdb->WriteMinVersion(nWalletVersion);\n         if (!pwalletdbIn)\n             delete pwalletdb;\n     }\n@@ -579,9 +573,6 @@ bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n             assert(false);\n         }\n \n-        // Encryption was introduced in version 0.4.0\n-        SetMinVersion(FEATURE_WALLETCRYPT, pwalletdbEncryption, true);\n-\n         if (fFileBacked)\n         {\n             if (!pwalletdbEncryption->TxnCommit()) {"
      },
      {
        "sha": "dd28c7824331f4a21c24df858aeefcdae9ae0687",
        "filename": "src/lightwallet/wallet.h",
        "status": "modified",
        "additions": 2,
        "deletions": 6,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5a367319ced9abd9cf1c75ab64abaf5ddeaa4543/src/lightwallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5a367319ced9abd9cf1c75ab64abaf5ddeaa4543/src/lightwallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/wallet.h?ref=5a367319ced9abd9cf1c75ab64abaf5ddeaa4543",
        "patch": "@@ -72,12 +72,8 @@ class CWalletTx;\n /** (client) version numbers for particular wallet features */\n enum WalletFeature\n {\n-    FEATURE_BASE = 10500, // the earliest version new wallets supports (only useful for getinfo's clientversion output)\n-\n-    FEATURE_WALLETCRYPT = 40000, // wallet encryption\n-    FEATURE_COMPRPUBKEY = 60000, // compressed public keys\n-\n-    FEATURE_LATEST = 60000\n+    FEATURE_BASE = 10000,\n+    FEATURE_LATEST = 10000\n };\n \n "
      },
      {
        "sha": "d95e6c066a65cf1ccecac4defe65e1072ef38fce",
        "filename": "src/lightwallet/walletdb.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 18,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5a367319ced9abd9cf1c75ab64abaf5ddeaa4543/src/lightwallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5a367319ced9abd9cf1c75ab64abaf5ddeaa4543/src/lightwallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/lightwallet/walletdb.cpp?ref=5a367319ced9abd9cf1c75ab64abaf5ddeaa4543",
        "patch": "@@ -324,17 +324,7 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n                 ssValue >> wkey;\n                 pkey = wkey.vchPrivKey;\n             }\n-\n-            // Old wallets store keys as \"key\" [pubkey] => [privkey]\n-            // ... which was slow for wallets with lots of keys, because the public key is re-derived from the private key\n-            // using EC operations as a checksum.\n-            // Newer wallets store keys as \"key\"[pubkey] => [privkey][hash(pubkey,privkey)], which is much faster while\n-            // remaining backwards-compatible.\n-            try\n-            {\n-                ssValue >> hash;\n-            }\n-            catch (...) {}\n+            ssValue >> hash;\n \n             bool fSkipCheck = false;\n \n@@ -438,8 +428,6 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n         else if (strType == \"version\")\n         {\n             ssValue >> wss.nFileVersion;\n-            if (wss.nFileVersion == 10300)\n-                wss.nFileVersion = 300;\n         }\n         else if (strType == \"cscript\")\n         {\n@@ -570,11 +558,7 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n     BOOST_FOREACH(uint256 hash, wss.vWalletUpgrade)\n         WriteTx(hash, pwallet->mapWallet[hash]);\n \n-    // Rewrite encrypted wallets of versions 0.4.0 and 0.5.0rc:\n-    if (wss.fIsEncrypted && (wss.nFileVersion == 40000 || wss.nFileVersion == 50000))\n-        return DB_NEED_REWRITE;\n-\n-    if (wss.nFileVersion < CLIENT_VERSION) // Update\n+    if (wss.nFileVersion < CLIENT_VERSION)\n         WriteVersion(CLIENT_VERSION);\n \n     if (wss.fAnyUnordered)"
      }
    ]
  }
]