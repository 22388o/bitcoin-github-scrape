[
  {
    "sha": "319b11607f8592d7ef67ec82fa73545ad7430974",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozMTliMTE2MDdmODU5MmQ3ZWY2N2VjODJmYTczNTQ1YWQ3NDMwOTc0",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2013-08-27T05:51:57Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2013-11-04T01:27:02Z"
      },
      "message": "Refactor: CTxMempool class to its own txmempool.{cpp,h}",
      "tree": {
        "sha": "35a62a9d0df1c0bb9157e8cc85ab086c01c55217",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/35a62a9d0df1c0bb9157e8cc85ab086c01c55217"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/319b11607f8592d7ef67ec82fa73545ad7430974",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/319b11607f8592d7ef67ec82fa73545ad7430974",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/319b11607f8592d7ef67ec82fa73545ad7430974",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/319b11607f8592d7ef67ec82fa73545ad7430974/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "39b4f0d7ddc964b789876d15d888c3b29022939e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/39b4f0d7ddc964b789876d15d888c3b29022939e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/39b4f0d7ddc964b789876d15d888c3b29022939e"
      }
    ],
    "stats": {
      "total": 563,
      "additions": 317,
      "deletions": 246
    },
    "files": [
      {
        "sha": "508063d5e214ef1132cb264ed6dc46c81dab2ab1",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/319b11607f8592d7ef67ec82fa73545ad7430974/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/319b11607f8592d7ef67ec82fa73545ad7430974/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=319b11607f8592d7ef67ec82fa73545ad7430974",
        "patch": "@@ -17,7 +17,7 @@ BITCOIN_CORE_H = addrman.h alert.h allocators.h base58.h bignum.h \\\n   clientversion.h compat.h core.h crypter.h db.h hash.h init.h \\\n   key.h keystore.h leveldb.h limitedmap.h main.h miner.h mruset.h \\\n   netbase.h net.h protocol.h script.h serialize.h sync.h threadsafety.h \\\n-  txdb.h ui_interface.h uint256.h util.h version.h walletdb.h wallet.h\n+  txdb.h txmempool.h ui_interface.h uint256.h util.h version.h walletdb.h wallet.h\n \n JSON_H = json/json_spirit.h json/json_spirit_error_position.h \\\n   json/json_spirit_reader.h json/json_spirit_reader_template.h \\\n@@ -36,7 +36,7 @@ libbitcoin_a_SOURCES = addrman.cpp alert.cpp allocators.cpp bitcoinrpc.cpp bloom\n   init.cpp key.cpp keystore.cpp leveldb.cpp main.cpp miner.cpp \\\n   netbase.cpp net.cpp noui.cpp protocol.cpp rpcblockchain.cpp rpcdump.cpp \\\n   rpcmining.cpp rpcnet.cpp rpcrawtransaction.cpp rpcwallet.cpp script.cpp \\\n-  sync.cpp txdb.cpp util.cpp version.cpp wallet.cpp walletdb.cpp $(JSON_H) \\\n+  sync.cpp txdb.cpp txmempool.cpp util.cpp version.cpp wallet.cpp walletdb.cpp $(JSON_H) \\\n   $(BITCOIN_CORE_H)\n \n nodist_libbitcoin_a_SOURCES = $(top_srcdir)/src/obj/build.h"
      },
      {
        "sha": "6e2f609fcfc77c342fa82e97ef9be31381a48ad7",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/319b11607f8592d7ef67ec82fa73545ad7430974/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/319b11607f8592d7ef67ec82fa73545ad7430974/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=319b11607f8592d7ef67ec82fa73545ad7430974",
        "patch": "@@ -4,6 +4,7 @@\n #ifndef CHECKQUEUE_H\n #define CHECKQUEUE_H\n \n+#include <boost/foreach.hpp>\n #include <boost/thread/mutex.hpp>\n #include <boost/thread/locks.hpp>\n #include <boost/thread/condition_variable.hpp>"
      },
      {
        "sha": "a803598f32e6f5f6ed5a99c3ec7e91f5df585686",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/319b11607f8592d7ef67ec82fa73545ad7430974/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/319b11607f8592d7ef67ec82fa73545ad7430974/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=319b11607f8592d7ef67ec82fa73545ad7430974",
        "patch": "@@ -106,7 +106,7 @@ void Shutdown()\n     if (!lockShutdown) return;\n \n     RenameThread(\"bitcoin-shutoff\");\n-    nTransactionsUpdated++;\n+    mempool.AddTransactionsUpdated(1);\n     StopRPCThreads();\n     ShutdownRPCMining();\n     if (pwalletMain)\n@@ -478,7 +478,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n         InitWarning(_(\"Warning: Deprecated argument -debugnet ignored, use -debug=net\"));\n \n     fBenchmark = GetBoolArg(\"-benchmark\", false);\n-    mempool.fChecks = GetBoolArg(\"-checkmempool\", RegTest());\n+    mempool.setSanityCheck(GetBoolArg(\"-checkmempool\", RegTest()));\n     Checkpoints::fEnabled = GetBoolArg(\"-checkpoints\", true);\n \n     // -par=0 means autodetect, but nScriptCheckThreads==0 means no concurrency"
      },
      {
        "sha": "01d1b07df441bd351b8a57a9a835eba65ca43b7e",
        "filename": "src/limitedmap.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/319b11607f8592d7ef67ec82fa73545ad7430974/src/limitedmap.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/319b11607f8592d7ef67ec82fa73545ad7430974/src/limitedmap.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/limitedmap.h?ref=319b11607f8592d7ef67ec82fa73545ad7430974",
        "patch": "@@ -4,6 +4,7 @@\n #ifndef BITCOIN_LIMITEDMAP_H\n #define BITCOIN_LIMITEDMAP_H\n \n+#include <assert.h> // TODO: remove\n #include <map>\n #include <deque>\n "
      },
      {
        "sha": "ecb9711664e0628bafa2812265525a33a6757bb4",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 67,
        "deletions": 191,
        "changes": 258,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/319b11607f8592d7ef67ec82fa73545ad7430974/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/319b11607f8592d7ef67ec82fa73545ad7430974/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=319b11607f8592d7ef67ec82fa73545ad7430974",
        "patch": "@@ -3,18 +3,20 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include <boost/algorithm/string/replace.hpp>\n+#include <boost/filesystem.hpp>\n+#include <boost/filesystem/fstream.hpp>\n+\n #include \"alert.h\"\n+#include \"chainparams.h\"\n #include \"checkpoints.h\"\n+#include \"checkqueue.h\"\n #include \"db.h\"\n-#include \"txdb.h\"\n-#include \"net.h\"\n #include \"init.h\"\n+#include \"net.h\"\n+#include \"txdb.h\"\n+#include \"txmempool.h\"\n #include \"ui_interface.h\"\n-#include \"checkqueue.h\"\n-#include \"chainparams.h\"\n-#include <boost/algorithm/string/replace.hpp>\n-#include <boost/filesystem.hpp>\n-#include <boost/filesystem/fstream.hpp>\n \n using namespace std;\n using namespace boost;\n@@ -29,7 +31,6 @@ set<CWallet*> setpwalletRegistered;\n CCriticalSection cs_main;\n \n CTxMemPool mempool;\n-unsigned int nTransactionsUpdated = 0;\n \n map<uint256, CBlockIndex*> mapBlockIndex;\n CChain chainActive;\n@@ -319,15 +320,24 @@ unsigned int CCoinsViewCache::GetCacheSize() {\n     return cacheCoins.size();\n }\n \n+/** Helper; lookup from tip (used calling mempool.check()\n+    NOTE: code calling this MUST hold the cs_main lock so\n+    another thread doesn't modify pcoinsTip. When we switch\n+    to C++11 this should be replaced by lambda expressions...\n+ **/\n+static CCoins &LookupFromTip(const uint256& hash) {\n+    return pcoinsTip->GetCoins(hash);\n+}\n+\n /** CCoinsView that brings transactions from a memorypool into view.\n     It does not check for spendings by memory pool transactions. */\n CCoinsViewMemPool::CCoinsViewMemPool(CCoinsView &baseIn, CTxMemPool &mempoolIn) : CCoinsViewBacked(baseIn), mempool(mempoolIn) { }\n \n bool CCoinsViewMemPool::GetCoins(const uint256 &txid, CCoins &coins) {\n     if (base->GetCoins(txid, coins))\n         return true;\n-    if (mempool.exists(txid)) {\n-        const CTransaction &tx = mempool.lookup(txid);\n+    CTransaction tx;\n+    if (mempool.lookup(txid, tx)) {\n         coins = CCoins(tx, MEMPOOL_HEIGHT);\n         return true;\n     }\n@@ -734,85 +744,69 @@ int64 GetMinFee(const CTransaction& tx, bool fAllowFree, enum GetMinFee_mode mod\n     return nMinFee;\n }\n \n-void CTxMemPool::pruneSpent(const uint256 &hashTx, CCoins &coins)\n-{\n-    LOCK(cs);\n-\n-    std::map<COutPoint, CInPoint>::iterator it = mapNextTx.lower_bound(COutPoint(hashTx, 0));\n-\n-    // iterate over all COutPoints in mapNextTx whose hash equals the provided hashTx\n-    while (it != mapNextTx.end() && it->first.hash == hashTx) {\n-        coins.Spend(it->first.n); // and remove those outputs from coins\n-        it++;\n-    }\n-}\n \n-bool CTxMemPool::accept(CValidationState &state, const CTransaction &tx, bool fLimitFree,\n+bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransaction &tx, bool fLimitFree,\n                         bool* pfMissingInputs, bool fRejectInsaneFee)\n {\n     if (pfMissingInputs)\n         *pfMissingInputs = false;\n \n     if (!CheckTransaction(tx, state))\n-        return error(\"CTxMemPool::accept() : CheckTransaction failed\");\n+        return error(\"AcceptToMemoryPool: : CheckTransaction failed\");\n \n     // Coinbase is only valid in a block, not as a loose transaction\n     if (tx.IsCoinBase())\n-        return state.DoS(100, error(\"CTxMemPool::accept() : coinbase as individual tx\"));\n-\n-    // To help v0.1.5 clients who would see it as a negative number\n-    if ((int64)tx.nLockTime > std::numeric_limits<int>::max())\n-        return error(\"CTxMemPool::accept() : not accepting nLockTime beyond 2038 yet\");\n+        return state.DoS(100, error(\"AcceptToMemoryPool: : coinbase as individual tx\"));\n \n     // Rather not work on nonstandard transactions (unless -testnet/-regtest)\n     string reason;\n     if (Params().NetworkID() == CChainParams::MAIN && !IsStandardTx(tx, reason))\n-        return error(\"CTxMemPool::accept() : nonstandard transaction: %s\",\n+        return error(\"AcceptToMemoryPool: : nonstandard transaction: %s\",\n                      reason.c_str());\n \n     // is it already in the memory pool?\n     uint256 hash = tx.GetHash();\n-    {\n-        LOCK(cs);\n-        if (mapTx.count(hash))\n-            return false;\n-    }\n+    if (pool.exists(hash))\n+        return false;\n \n     // Check for conflicts with in-memory transactions\n     CTransaction* ptxOld = NULL;\n+    {\n+    LOCK(pool.cs); // protect pool.mapNextTx\n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n     {\n         COutPoint outpoint = tx.vin[i].prevout;\n-        if (mapNextTx.count(outpoint))\n+        if (pool.mapNextTx.count(outpoint))\n         {\n             // Disable replacement feature for now\n             return false;\n \n             // Allow replacing with a newer version of the same transaction\n             if (i != 0)\n                 return false;\n-            ptxOld = mapNextTx[outpoint].ptx;\n+            ptxOld = pool.mapNextTx[outpoint].ptx;\n             if (IsFinalTx(*ptxOld))\n                 return false;\n             if (!tx.IsNewerThan(*ptxOld))\n                 return false;\n             for (unsigned int i = 0; i < tx.vin.size(); i++)\n             {\n                 COutPoint outpoint = tx.vin[i].prevout;\n-                if (!mapNextTx.count(outpoint) || mapNextTx[outpoint].ptx != ptxOld)\n+                if (!pool.mapNextTx.count(outpoint) || pool.mapNextTx[outpoint].ptx != ptxOld)\n                     return false;\n             }\n             break;\n         }\n     }\n+    }\n \n     {\n         CCoinsView dummy;\n         CCoinsViewCache view(dummy);\n \n         {\n-        LOCK(cs);\n-        CCoinsViewMemPool viewMemPool(*pcoinsTip, *this);\n+        LOCK(pool.cs);\n+        CCoinsViewMemPool viewMemPool(*pcoinsTip, pool);\n         view.SetBackend(viewMemPool);\n \n         // do we already have it?\n@@ -832,7 +826,7 @@ bool CTxMemPool::accept(CValidationState &state, const CTransaction &tx, bool fL\n \n         // are the actual inputs available?\n         if (!view.HaveInputs(tx))\n-            return state.Invalid(error(\"CTxMemPool::accept() : inputs already spent\"));\n+            return state.Invalid(error(\"AcceptToMemoryPool: : inputs already spent\"));\n \n         // Bring the best block into scope\n         view.GetBestBlock();\n@@ -843,7 +837,7 @@ bool CTxMemPool::accept(CValidationState &state, const CTransaction &tx, bool fL\n \n         // Check for non-standard pay-to-script-hash in inputs\n         if (Params().NetworkID() == CChainParams::MAIN && !AreInputsStandard(tx, view))\n-            return error(\"CTxMemPool::accept() : nonstandard transaction input\");\n+            return error(\"AcceptToMemoryPool: : nonstandard transaction input\");\n \n         // Note: if you modify this code to accept non-standard transactions, then\n         // you should add code here to check that the transaction does a\n@@ -855,7 +849,7 @@ bool CTxMemPool::accept(CValidationState &state, const CTransaction &tx, bool fL\n         // Don't accept it if it can't get into a block\n         int64 txMinFee = GetMinFee(tx, true, GMF_RELAY);\n         if (fLimitFree && nFees < txMinFee)\n-            return error(\"CTxMemPool::accept() : not enough fees %s, %\"PRI64d\" < %\"PRI64d,\n+            return error(\"AcceptToMemoryPool: : not enough fees %s, %\"PRI64d\" < %\"PRI64d,\n                          hash.ToString().c_str(),\n                          nFees, txMinFee);\n \n@@ -864,46 +858,45 @@ bool CTxMemPool::accept(CValidationState &state, const CTransaction &tx, bool fL\n         // be annoying or make others' transactions take longer to confirm.\n         if (fLimitFree && nFees < CTransaction::nMinRelayTxFee)\n         {\n+            static CCriticalSection csFreeLimiter;\n             static double dFreeCount;\n             static int64 nLastTime;\n             int64 nNow = GetTime();\n \n-            LOCK(cs);\n+            LOCK(csFreeLimiter);\n \n             // Use an exponentially decaying ~10-minute window:\n             dFreeCount *= pow(1.0 - 1.0/600.0, (double)(nNow - nLastTime));\n             nLastTime = nNow;\n             // -limitfreerelay unit is thousand-bytes-per-minute\n             // At default rate it would take over a month to fill 1GB\n             if (dFreeCount >= GetArg(\"-limitfreerelay\", 15)*10*1000)\n-                return error(\"CTxMemPool::accept() : free transaction rejected by rate limiter\");\n-            if (fDebug)\n-                LogPrint(\"mempool\", \"Rate limit dFreeCount: %g => %g\\n\", dFreeCount, dFreeCount+nSize);\n+                return error(\"AcceptToMemoryPool: : free transaction rejected by rate limiter\");\n+            LogPrint(\"mempool\", \"Rate limit dFreeCount: %g => %g\\n\", dFreeCount, dFreeCount+nSize);\n             dFreeCount += nSize;\n         }\n \n         if (fRejectInsaneFee && nFees > CTransaction::nMinRelayTxFee * 10000)\n-            return error(\"CTxMemPool::accept() : insane fees %s, %\"PRI64d\" > %\"PRI64d,\n+            return error(\"AcceptToMemoryPool: : insane fees %s, %\"PRI64d\" > %\"PRI64d,\n                          hash.ToString().c_str(),\n                          nFees, CTransaction::nMinRelayTxFee * 10000);\n \n         // Check against previous transactions\n         // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n         if (!CheckInputs(tx, state, view, true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC))\n         {\n-            return error(\"CTxMemPool::accept() : ConnectInputs failed %s\", hash.ToString().c_str());\n+            return error(\"AcceptToMemoryPool: : ConnectInputs failed %s\", hash.ToString().c_str());\n         }\n     }\n \n     // Store transaction in memory\n     {\n-        LOCK(cs);\n         if (ptxOld)\n         {\n-            LogPrint(\"mempool\", \"CTxMemPool::accept() : replacing tx %s with new version\\n\", ptxOld->GetHash().ToString().c_str());\n-            remove(*ptxOld);\n+            LogPrint(\"mempool\", \"AcceptToMemoryPool: : replacing tx %s with new version\\n\", ptxOld->GetHash().ToString().c_str());\n+            pool.remove(*ptxOld);\n         }\n-        addUnchecked(hash, tx);\n+        pool.addUnchecked(hash, tx);\n     }\n \n     ///// are we sure this is ok when loading transactions or restoring block txes\n@@ -912,125 +905,12 @@ bool CTxMemPool::accept(CValidationState &state, const CTransaction &tx, bool fL\n         g_signals.EraseTransaction(ptxOld->GetHash());\n     g_signals.SyncTransaction(hash, tx, NULL);\n \n-    LogPrint(\"mempool\", \"CTxMemPool::accept() : accepted %s (poolsz %\"PRIszu\")\\n\",\n-           hash.ToString().c_str(),\n-           mapTx.size());\n-    return true;\n-}\n-\n-\n-bool CTxMemPool::addUnchecked(const uint256& hash, const CTransaction &tx)\n-{\n-    // Add to memory pool without checking anything.  Don't call this directly,\n-    // call CTxMemPool::accept to properly check the transaction first.\n-    {\n-        mapTx[hash] = tx;\n-        for (unsigned int i = 0; i < tx.vin.size(); i++)\n-            mapNextTx[tx.vin[i].prevout] = CInPoint(&mapTx[hash], i);\n-        nTransactionsUpdated++;\n-    }\n-    return true;\n-}\n-\n-\n-bool CTxMemPool::remove(const CTransaction &tx, bool fRecursive)\n-{\n-    // Remove transaction from memory pool\n-    {\n-        LOCK(cs);\n-        uint256 hash = tx.GetHash();\n-        if (fRecursive) {\n-            for (unsigned int i = 0; i < tx.vout.size(); i++) {\n-                std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(COutPoint(hash, i));\n-                if (it != mapNextTx.end())\n-                    remove(*it->second.ptx, true);\n-            }\n-        }\n-        if (mapTx.count(hash))\n-        {\n-            BOOST_FOREACH(const CTxIn& txin, tx.vin)\n-                mapNextTx.erase(txin.prevout);\n-            mapTx.erase(hash);\n-            nTransactionsUpdated++;\n-        }\n-    }\n-    return true;\n-}\n-\n-bool CTxMemPool::removeConflicts(const CTransaction &tx)\n-{\n-    // Remove transactions which depend on inputs of tx, recursively\n-    LOCK(cs);\n-    BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n-        std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(txin.prevout);\n-        if (it != mapNextTx.end()) {\n-            const CTransaction &txConflict = *it->second.ptx;\n-            if (txConflict != tx)\n-                remove(txConflict, true);\n-        }\n-    }\n+    LogPrint(\"mempool\", \"AcceptToMemoryPool: : accepted %s (poolsz %\"PRIszu\")\\n\",\n+             hash.ToString().c_str(),\n+             pool.mapTx.size());\n     return true;\n }\n \n-void CTxMemPool::clear()\n-{\n-    LOCK(cs);\n-    mapTx.clear();\n-    mapNextTx.clear();\n-    ++nTransactionsUpdated;\n-}\n-\n-bool CTxMemPool::fChecks = false;\n-\n-void CTxMemPool::check(CCoinsViewCache *pcoins) const\n-{\n-    if (!fChecks)\n-        return;\n-\n-    LogPrintf(\"Checking mempool with %u transactions and %u inputs\\n\", (unsigned int)mapTx.size(), (unsigned int)mapNextTx.size());\n-\n-    LOCK(cs);\n-    for (std::map<uint256, CTransaction>::const_iterator it = mapTx.begin(); it != mapTx.end(); it++) {\n-        unsigned int i = 0;\n-        BOOST_FOREACH(const CTxIn &txin, it->second.vin) {\n-            // Check that every mempool transaction's inputs refer to available coins, or other mempool tx's.\n-            std::map<uint256, CTransaction>::const_iterator it2 = mapTx.find(txin.prevout.hash);\n-            if (it2 != mapTx.end()) {\n-                assert(it2->second.vout.size() > txin.prevout.n && !it2->second.vout[txin.prevout.n].IsNull());\n-            } else {\n-                CCoins &coins = pcoins->GetCoins(txin.prevout.hash);\n-                assert(coins.IsAvailable(txin.prevout.n));\n-            }\n-            // Check whether its inputs are marked in mapNextTx.\n-            std::map<COutPoint, CInPoint>::const_iterator it3 = mapNextTx.find(txin.prevout);\n-            assert(it3 != mapNextTx.end());\n-            assert(it3->second.ptx == &it->second);\n-            assert(it3->second.n == i);\n-            i++;\n-        }\n-    }\n-    for (std::map<COutPoint, CInPoint>::const_iterator it = mapNextTx.begin(); it != mapNextTx.end(); it++) {\n-        uint256 hash = it->second.ptx->GetHash();\n-        std::map<uint256, CTransaction>::const_iterator it2 = mapTx.find(hash);\n-        assert(it2 != mapTx.end());\n-        assert(&it2->second == it->second.ptx);\n-        assert(it2->second.vin.size() > it->second.n);\n-        assert(it->first == it->second.ptx->vin[it->second.n].prevout);\n-    }\n-}\n-\n-void CTxMemPool::queryHashes(std::vector<uint256>& vtxid)\n-{\n-    vtxid.clear();\n-\n-    LOCK(cs);\n-    vtxid.reserve(mapTx.size());\n-    for (map<uint256, CTransaction>::iterator mi = mapTx.begin(); mi != mapTx.end(); ++mi)\n-        vtxid.push_back((*mi).first);\n-}\n-\n-\n-\n \n int CMerkleTx::GetDepthInMainChain(CBlockIndex* &pindexRet) const\n {\n@@ -1069,7 +949,7 @@ int CMerkleTx::GetBlocksToMaturity() const\n bool CMerkleTx::AcceptToMemoryPool(bool fLimitFree)\n {\n     CValidationState state;\n-    return mempool.accept(state, *this, fLimitFree, NULL);\n+    return ::AcceptToMemoryPool(mempool, state, *this, fLimitFree, NULL);\n }\n \n \n@@ -1080,10 +960,8 @@ bool GetTransaction(const uint256 &hash, CTransaction &txOut, uint256 &hashBlock\n     {\n         LOCK(cs_main);\n         {\n-            LOCK(mempool.cs);\n-            if (mempool.exists(hash))\n+            if (mempool.lookup(hash, txOut))\n             {\n-                txOut = mempool.lookup(hash);\n                 return true;\n             }\n         }\n@@ -1959,7 +1837,7 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n \n bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n {\n-    mempool.check(pcoinsTip);\n+    mempool.check(&LookupFromTip);\n \n     // All modifications to the coin state will be done in this cache.\n     // Only when all have succeeded, we push it to pcoinsTip.\n@@ -2072,7 +1950,7 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n     BOOST_FOREACH(CTransaction& tx, vResurrect) {\n         // ignore validation errors in resurrected transactions\n         CValidationState stateDummy;\n-        if (!mempool.accept(stateDummy, tx, false, NULL))\n+        if (!AcceptToMemoryPool(mempool,stateDummy, tx, false, NULL))\n             mempool.remove(tx, true);\n     }\n \n@@ -2082,15 +1960,15 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n         mempool.removeConflicts(tx);\n     }\n \n-    mempool.check(pcoinsTip);\n+    mempool.check(&LookupFromTip);\n \n     // Update best block in wallet (so we can detect restored wallets)\n     if ((pindexNew->nHeight % 20160) == 0 || (!fIsInitialDownload && (pindexNew->nHeight % 144) == 0))\n         g_signals.SetBestChain(chainActive.GetLocator(pindexNew));\n \n     // New best block\n     nTimeBestReceived = GetTime();\n-    nTransactionsUpdated++;\n+    mempool.AddTransactionsUpdated(1);\n     LogPrintf(\"SetBestChain: new best=%s  height=%d  log2_work=%.8g  tx=%lu  date=%s progress=%f\\n\",\n       chainActive.Tip()->GetBlockHash().ToString().c_str(), chainActive.Height(), log(chainActive.Tip()->nChainWork.getdouble())/log(2.0), (unsigned long)pindexNew->nChainTx,\n       DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()).c_str(),\n@@ -3170,10 +3048,7 @@ bool static AlreadyHave(const CInv& inv)\n     case MSG_TX:\n         {\n             bool txInMap = false;\n-            {\n-                LOCK(mempool.cs);\n-                txInMap = mempool.exists(inv.hash);\n-            }\n+            txInMap = mempool.exists(inv.hash);\n             return txInMap || mapOrphanTransactions.count(inv.hash) ||\n                 pcoinsTip->HaveCoins(inv.hash);\n         }\n@@ -3264,9 +3139,8 @@ void static ProcessGetData(CNode* pfrom)\n                     }\n                 }\n                 if (!pushed && inv.type == MSG_TX) {\n-                    LOCK(mempool.cs);\n-                    if (mempool.exists(inv.hash)) {\n-                        CTransaction tx = mempool.lookup(inv.hash);\n+                    CTransaction tx;\n+                    if (mempool.lookup(inv.hash, tx)) {\n                         CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n                         ss.reserve(1000);\n                         ss << tx;\n@@ -3658,9 +3532,9 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n         bool fMissingInputs = false;\n         CValidationState state;\n-        if (mempool.accept(state, tx, true, &fMissingInputs))\n+        if (AcceptToMemoryPool(mempool, state, tx, true, &fMissingInputs))\n         {\n-            mempool.check(pcoinsTip);\n+            mempool.check(&LookupFromTip);\n             RelayTransaction(tx, inv.hash);\n             mapAlreadyAskedFor.erase(inv);\n             vWorkQueue.push_back(inv.hash);\n@@ -3682,7 +3556,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                     // anyone relaying LegitTxX banned)\n                     CValidationState stateDummy;\n \n-                    if (mempool.accept(stateDummy, orphanTx, true, &fMissingInputs2))\n+                    if (AcceptToMemoryPool(mempool, stateDummy, orphanTx, true, &fMissingInputs2))\n                     {\n                         LogPrint(\"mempool\", \"   accepted orphan tx %s\\n\", orphanHash.ToString().c_str());\n                         RelayTransaction(orphanTx, orphanHash);\n@@ -3696,7 +3570,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                         vEraseQueue.push_back(orphanHash);\n                         LogPrint(\"mempool\", \"   removed orphan tx %s\\n\", orphanHash.ToString().c_str());\n                     }\n-                    mempool.check(pcoinsTip);\n+                    mempool.check(&LookupFromTip);\n                 }\n             }\n \n@@ -3753,15 +3627,17 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n     else if (strCommand == \"mempool\")\n     {\n-        LOCK(cs_main);\n+        LOCK2(cs_main, pfrom->cs_filter);\n \n         std::vector<uint256> vtxid;\n-        LOCK2(mempool.cs, pfrom->cs_filter);\n         mempool.queryHashes(vtxid);\n         vector<CInv> vInv;\n         BOOST_FOREACH(uint256& hash, vtxid) {\n             CInv inv(MSG_TX, hash);\n-            if ((pfrom->pfilter && pfrom->pfilter->IsRelevantAndUpdate(mempool.lookup(hash), hash)) ||\n+            CTransaction tx;\n+            bool fInMemPool = mempool.lookup(hash, tx);\n+            if (!fInMemPool) continue; // another thread removed since queryHashes, maybe...\n+            if ((pfrom->pfilter && pfrom->pfilter->IsRelevantAndUpdate(tx, hash)) ||\n                (!pfrom->pfilter))\n                 vInv.push_back(inv);\n             if (vInv.size() == MAX_INV_SZ) {"
      },
      {
        "sha": "80972330f3a7e1ecfc2737f0bb3b5fa7b181a3ba",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 8,
        "deletions": 44,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/319b11607f8592d7ef67ec82fa73545ad7430974/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/319b11607f8592d7ef67ec82fa73545ad7430974/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=319b11607f8592d7ef67ec82fa73545ad7430974",
        "patch": "@@ -12,19 +12,19 @@\n #include \"core.h\"\n #include \"bignum.h\"\n #include \"sync.h\"\n+#include \"txmempool.h\"\n #include \"net.h\"\n #include \"script.h\"\n \n #include <list>\n \n class CBlock;\n class CBlockIndex;\n-class CKeyItem;\n-class CReserveKey;\n-\n-class CAddress;\n class CInv;\n+class CKeyItem;\n class CNode;\n+class CReserveKey;\n+class CWallet;\n \n /** The maximum allowed size for a serialized block, in bytes (network rule) */\n static const unsigned int MAX_BLOCK_SIZE = 1000000;\n@@ -70,8 +70,8 @@ extern CScript COINBASE_FLAGS;\n \n \n extern CCriticalSection cs_main;\n+extern CTxMemPool mempool;\n extern std::map<uint256, CBlockIndex*> mapBlockIndex;\n-extern unsigned int nTransactionsUpdated;\n extern uint64 nLastBlockTx;\n extern uint64 nLastBlockSize;\n extern const std::string strMessageMagic;\n@@ -175,7 +175,9 @@ bool VerifySignature(const CCoins& txFrom, const CTransaction& txTo, unsigned in\n /** Abort with a message */\n bool AbortNode(const std::string &msg);\n \n-\n+/** (try to) add transaction to memory pool **/\n+bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransaction &tx, bool fLimitFree,\n+                        bool* pfMissingInputs, bool fRejectInsaneFee=false);\n \n \n \n@@ -1029,44 +1031,6 @@ extern CChain chainActive;\n \n \n \n-\n-\n-class CTxMemPool\n-{\n-public:\n-    static bool fChecks;\n-    mutable CCriticalSection cs;\n-    std::map<uint256, CTransaction> mapTx;\n-    std::map<COutPoint, CInPoint> mapNextTx;\n-\n-    bool accept(CValidationState &state, const CTransaction &tx, bool fLimitFree, bool* pfMissingInputs, bool fRejectInsaneFee = false);\n-    bool addUnchecked(const uint256& hash, const CTransaction &tx);\n-    bool remove(const CTransaction &tx, bool fRecursive = false);\n-    bool removeConflicts(const CTransaction &tx);\n-    void clear();\n-    void queryHashes(std::vector<uint256>& vtxid);\n-    void pruneSpent(const uint256& hash, CCoins &coins);\n-    void check(CCoinsViewCache *pcoins) const;\n-\n-    unsigned long size()\n-    {\n-        LOCK(cs);\n-        return mapTx.size();\n-    }\n-\n-    bool exists(uint256 hash)\n-    {\n-        return (mapTx.count(hash) != 0);\n-    }\n-\n-    CTransaction& lookup(uint256 hash)\n-    {\n-        return mapTx[hash];\n-    }\n-};\n-\n-extern CTxMemPool mempool;\n-\n struct CCoinsStats\n {\n     int nHeight;"
      },
      {
        "sha": "b03f915dc96aab12a6fbd4342788f9c959e27b1c",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/319b11607f8592d7ef67ec82fa73545ad7430974/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/319b11607f8592d7ef67ec82fa73545ad7430974/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=319b11607f8592d7ef67ec82fa73545ad7430974",
        "patch": "@@ -521,7 +521,7 @@ void static BitcoinMiner(CWallet *pwallet)\n         //\n         // Create new block\n         //\n-        unsigned int nTransactionsUpdatedLast = nTransactionsUpdated;\n+        unsigned int nTransactionsUpdatedLast = mempool.GetTransactionsUpdated();\n         CBlockIndex* pindexPrev = chainActive.Tip();\n \n         auto_ptr<CBlockTemplate> pblocktemplate(CreateNewBlockWithKey(reservekey));\n@@ -623,7 +623,7 @@ void static BitcoinMiner(CWallet *pwallet)\n                 break;\n             if (nBlockNonce >= 0xffff0000)\n                 break;\n-            if (nTransactionsUpdated != nTransactionsUpdatedLast && GetTime() - nStart > 60)\n+            if (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && GetTime() - nStart > 60)\n                 break;\n             if (pindexPrev != chainActive.Tip())\n                 break;"
      },
      {
        "sha": "d91f26e20a1d9f79bbad1dc0ebd075d3ecc4a191",
        "filename": "src/rpcmining.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/319b11607f8592d7ef67ec82fa73545ad7430974/src/rpcmining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/319b11607f8592d7ef67ec82fa73545ad7430974/src/rpcmining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcmining.cpp?ref=319b11607f8592d7ef67ec82fa73545ad7430974",
        "patch": "@@ -190,7 +190,7 @@ Value getwork(const Array& params, bool fHelp)\n         static int64 nStart;\n         static CBlockTemplate* pblocktemplate;\n         if (pindexPrev != chainActive.Tip() ||\n-            (nTransactionsUpdated != nTransactionsUpdatedLast && GetTime() - nStart > 60))\n+            (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && GetTime() - nStart > 60))\n         {\n             if (pindexPrev != chainActive.Tip())\n             {\n@@ -205,7 +205,7 @@ Value getwork(const Array& params, bool fHelp)\n             pindexPrev = NULL;\n \n             // Store the pindexBest used before CreateNewBlock, to avoid races\n-            nTransactionsUpdatedLast = nTransactionsUpdated;\n+            nTransactionsUpdatedLast = mempool.GetTransactionsUpdated();\n             CBlockIndex* pindexPrevNew = chainActive.Tip();\n             nStart = GetTime();\n \n@@ -326,13 +326,13 @@ Value getblocktemplate(const Array& params, bool fHelp)\n     static int64 nStart;\n     static CBlockTemplate* pblocktemplate;\n     if (pindexPrev != chainActive.Tip() ||\n-        (nTransactionsUpdated != nTransactionsUpdatedLast && GetTime() - nStart > 5))\n+        (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && GetTime() - nStart > 5))\n     {\n         // Clear pindexPrev so future calls make a new block, despite any failures from here on\n         pindexPrev = NULL;\n \n         // Store the pindexBest used before CreateNewBlock, to avoid races\n-        nTransactionsUpdatedLast = nTransactionsUpdated;\n+        nTransactionsUpdatedLast = mempool.GetTransactionsUpdated();\n         CBlockIndex* pindexPrevNew = chainActive.Tip();\n         nStart = GetTime();\n "
      },
      {
        "sha": "4771094e1ffe9c763a212d23a8b628296fc60a8b",
        "filename": "src/rpcrawtransaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/319b11607f8592d7ef67ec82fa73545ad7430974/src/rpcrawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/319b11607f8592d7ef67ec82fa73545ad7430974/src/rpcrawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcrawtransaction.cpp?ref=319b11607f8592d7ef67ec82fa73545ad7430974",
        "patch": "@@ -550,7 +550,7 @@ Value sendrawtransaction(const Array& params, bool fHelp)\n         if (!fHave) {\n             // push to local node\n             CValidationState state;\n-            if (!mempool.accept(state, tx, false, NULL, !fOverrideFees))\n+            if (!AcceptToMemoryPool(mempool, state, tx, false, NULL, !fOverrideFees))\n                 throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX rejected\"); // TODO: report validation state\n         }\n     }"
      },
      {
        "sha": "975955a45834d6ba05fd629eaefc74c6d24ebd8f",
        "filename": "src/txmempool.cpp",
        "status": "added",
        "additions": 162,
        "deletions": 0,
        "changes": 162,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/319b11607f8592d7ef67ec82fa73545ad7430974/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/319b11607f8592d7ef67ec82fa73545ad7430974/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=319b11607f8592d7ef67ec82fa73545ad7430974",
        "patch": "@@ -0,0 +1,162 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2013 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"core.h\"\n+#include \"txmempool.h\"\n+\n+using namespace std;\n+\n+CTxMemPool::CTxMemPool()\n+{\n+    // Sanity checks off by default for performance, because otherwise\n+    // accepting transactions becomes O(N^2) where N is the number\n+    // of transactions in the pool\n+    fSanityCheck = false;\n+}\n+\n+void CTxMemPool::pruneSpent(const uint256 &hashTx, CCoins &coins)\n+{\n+    LOCK(cs);\n+\n+    std::map<COutPoint, CInPoint>::iterator it = mapNextTx.lower_bound(COutPoint(hashTx, 0));\n+\n+    // iterate over all COutPoints in mapNextTx whose hash equals the provided hashTx\n+    while (it != mapNextTx.end() && it->first.hash == hashTx) {\n+        coins.Spend(it->first.n); // and remove those outputs from coins\n+        it++;\n+    }\n+}\n+\n+unsigned int CTxMemPool::GetTransactionsUpdated() const\n+{\n+    LOCK(cs);\n+    return nTransactionsUpdated;\n+}\n+\n+void CTxMemPool::AddTransactionsUpdated(unsigned int n)\n+{\n+    LOCK(cs);\n+    nTransactionsUpdated += n;\n+}\n+\n+\n+bool CTxMemPool::addUnchecked(const uint256& hash, const CTransaction &tx)\n+{\n+    // Add to memory pool without checking anything.\n+    // Used by main.cpp AcceptToMemoryPool(), which DOES do\n+    // all the appropriate checks.\n+    LOCK(cs);\n+    {\n+        mapTx[hash] = tx;\n+        for (unsigned int i = 0; i < tx.vin.size(); i++)\n+            mapNextTx[tx.vin[i].prevout] = CInPoint(&mapTx[hash], i);\n+        nTransactionsUpdated++;\n+    }\n+    return true;\n+}\n+\n+\n+bool CTxMemPool::remove(const CTransaction &tx, bool fRecursive)\n+{\n+    // Remove transaction from memory pool\n+    {\n+        LOCK(cs);\n+        uint256 hash = tx.GetHash();\n+        if (fRecursive) {\n+            for (unsigned int i = 0; i < tx.vout.size(); i++) {\n+                std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(COutPoint(hash, i));\n+                if (it != mapNextTx.end())\n+                    remove(*it->second.ptx, true);\n+            }\n+        }\n+        if (mapTx.count(hash))\n+        {\n+            BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+                mapNextTx.erase(txin.prevout);\n+            mapTx.erase(hash);\n+            nTransactionsUpdated++;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool CTxMemPool::removeConflicts(const CTransaction &tx)\n+{\n+    // Remove transactions which depend on inputs of tx, recursively\n+    LOCK(cs);\n+    BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n+        std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(txin.prevout);\n+        if (it != mapNextTx.end()) {\n+            const CTransaction &txConflict = *it->second.ptx;\n+            if (txConflict != tx)\n+                remove(txConflict, true);\n+        }\n+    }\n+    return true;\n+}\n+\n+void CTxMemPool::clear()\n+{\n+    LOCK(cs);\n+    mapTx.clear();\n+    mapNextTx.clear();\n+    ++nTransactionsUpdated;\n+}\n+\n+void CTxMemPool::check(CTxMemPool::CoinLookupFunc fnLookup) const\n+{\n+    if (!fSanityCheck)\n+        return;\n+\n+    LogPrint(\"mempool\", \"Checking mempool with %u transactions and %u inputs\\n\", (unsigned int)mapTx.size(), (unsigned int)mapNextTx.size());\n+\n+    LOCK(cs);\n+    for (std::map<uint256, CTransaction>::const_iterator it = mapTx.begin(); it != mapTx.end(); it++) {\n+        unsigned int i = 0;\n+        BOOST_FOREACH(const CTxIn &txin, it->second.vin) {\n+            // Check that every mempool transaction's inputs refer to available coins, or other mempool tx's.\n+            std::map<uint256, CTransaction>::const_iterator it2 = mapTx.find(txin.prevout.hash);\n+            if (it2 != mapTx.end()) {\n+                assert(it2->second.vout.size() > txin.prevout.n && !it2->second.vout[txin.prevout.n].IsNull());\n+            } else {\n+                CCoins &coins = (*fnLookup)(txin.prevout.hash);\n+                assert(coins.IsAvailable(txin.prevout.n));\n+            }\n+            // Check whether its inputs are marked in mapNextTx.\n+            std::map<COutPoint, CInPoint>::const_iterator it3 = mapNextTx.find(txin.prevout);\n+            assert(it3 != mapNextTx.end());\n+            assert(it3->second.ptx == &it->second);\n+            assert(it3->second.n == i);\n+            i++;\n+        }\n+    }\n+    for (std::map<COutPoint, CInPoint>::const_iterator it = mapNextTx.begin(); it != mapNextTx.end(); it++) {\n+        uint256 hash = it->second.ptx->GetHash();\n+        std::map<uint256, CTransaction>::const_iterator it2 = mapTx.find(hash);\n+        assert(it2 != mapTx.end());\n+        assert(&it2->second == it->second.ptx);\n+        assert(it2->second.vin.size() > it->second.n);\n+        assert(it->first == it->second.ptx->vin[it->second.n].prevout);\n+    }\n+}\n+\n+void CTxMemPool::queryHashes(std::vector<uint256>& vtxid)\n+{\n+    vtxid.clear();\n+\n+    LOCK(cs);\n+    vtxid.reserve(mapTx.size());\n+    for (map<uint256, CTransaction>::iterator mi = mapTx.begin(); mi != mapTx.end(); ++mi)\n+        vtxid.push_back((*mi).first);\n+}\n+\n+bool CTxMemPool::lookup(uint256 hash, CTransaction& result) const\n+{\n+    LOCK(cs);\n+    std::map<uint256, CTransaction>::const_iterator i = mapTx.find(hash);\n+    if (i == mapTx.end()) return false;\n+    result = i->second;\n+    return true;\n+}"
      },
      {
        "sha": "1b555d99f4d072ebd32e1ad61fdab42f5df38b48",
        "filename": "src/txmempool.h",
        "status": "added",
        "additions": 67,
        "deletions": 0,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/319b11607f8592d7ef67ec82fa73545ad7430974/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/319b11607f8592d7ef67ec82fa73545ad7430974/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=319b11607f8592d7ef67ec82fa73545ad7430974",
        "patch": "@@ -0,0 +1,67 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2013 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef BITCOIN_TXMEMPOOL_H\n+#define BITCOIN_TXMEMPOOL_H\n+\n+#include \"core.h\"\n+\n+/*\n+ * CTxMemPool stores valid-according-to-the-current-best-chain\n+ * transactions that may be included in the next block.\n+ *\n+ * Transactions are added when they are seen on the network\n+ * (or created by the local node), but not all transactions seen\n+ * are added to the pool: if a new transaction double-spends\n+ * an input of a transaction in the pool, it is dropped,\n+ * as are non-standard transactions.\n+ */\n+class CTxMemPool\n+{\n+private:\n+    bool fSanityCheck; // Normally false, true if -checkmempool or -regtest\n+    unsigned int nTransactionsUpdated;\n+\n+public:\n+    mutable CCriticalSection cs;\n+    std::map<uint256, CTransaction> mapTx;\n+    std::map<COutPoint, CInPoint> mapNextTx;\n+\n+    CTxMemPool();\n+\n+    /*\n+     * If sanity-checking is turned on, check makes sure the pool is\n+     * consistent (does not contain two transactions that spend the same inputs,\n+     * all inputs are in the mapNextTx array). If sanity-checking is turned off,\n+     * check does nothing.\n+     */\n+    typedef CCoins& (*CoinLookupFunc)(const uint256&);\n+    void check(CoinLookupFunc fnLookup) const;\n+    void setSanityCheck(bool _fSanityCheck) { fSanityCheck = _fSanityCheck; }\n+\n+    bool addUnchecked(const uint256& hash, const CTransaction &tx);\n+    bool remove(const CTransaction &tx, bool fRecursive = false);\n+    bool removeConflicts(const CTransaction &tx);\n+    void clear();\n+    void queryHashes(std::vector<uint256>& vtxid);\n+    void pruneSpent(const uint256& hash, CCoins &coins);\n+    unsigned int GetTransactionsUpdated() const;\n+    void AddTransactionsUpdated(unsigned int n);\n+\n+    unsigned long size()\n+    {\n+        LOCK(cs);\n+        return mapTx.size();\n+    }\n+\n+    bool exists(uint256 hash)\n+    {\n+        LOCK(cs);\n+        return (mapTx.count(hash) != 0);\n+    }\n+\n+    bool lookup(uint256 hash, CTransaction& result) const;\n+};\n+\n+#endif /* BITCOIN_TXMEMPOOL_H */"
      }
    ]
  }
]