[
  {
    "sha": "b6198514c80ce0f0c65fa750a00cdfb5552bed98",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNjE5ODUxNGM4MGNlMGYwYzY1ZmE3NTBhMDBjZGZiNTU1MmJlZDk4",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "j@rubin.io",
        "date": "2019-05-07T00:34:52Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "j@rubin.io",
        "date": "2019-05-07T00:36:16Z"
      },
      "message": "Refactor: explicit VerifyScript control flow based on pattern matching script types",
      "tree": {
        "sha": "d1384d5c4d0f1de7d7429e5c7de689685bf059fe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d1384d5c4d0f1de7d7429e5c7de689685bf059fe"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b6198514c80ce0f0c65fa750a00cdfb5552bed98",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b6198514c80ce0f0c65fa750a00cdfb5552bed98",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b6198514c80ce0f0c65fa750a00cdfb5552bed98",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b6198514c80ce0f0c65fa750a00cdfb5552bed98/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3632143ebbfdd4888571db800c8ee8d684eec57b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3632143ebbfdd4888571db800c8ee8d684eec57b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3632143ebbfdd4888571db800c8ee8d684eec57b"
      }
    ],
    "stats": {
      "total": 212,
      "additions": 141,
      "deletions": 71
    },
    "files": [
      {
        "sha": "ddb05c2148c5c49633a6e6a6d35d4f7dcee32c63",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 141,
        "deletions": 71,
        "changes": 212,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6198514c80ce0f0c65fa750a00cdfb5552bed98/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6198514c80ce0f0c65fa750a00cdfb5552bed98/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=b6198514c80ce0f0c65fa750a00cdfb5552bed98",
        "patch": "@@ -1475,78 +1475,78 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n     if (witness == nullptr) {\n         witness = &emptyWitness;\n     }\n-    bool hadWitness = false;\n \n     set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR);\n \n     if ((flags & SCRIPT_VERIFY_SIGPUSHONLY) != 0 && !scriptSig.IsPushOnly()) {\n         return set_error(serror, SCRIPT_ERR_SIG_PUSHONLY);\n     }\n \n-    std::vector<std::vector<unsigned char> > stack, stackCopy;\n-    if (!EvalScript(stack, scriptSig, flags, checker, SigVersion::BASE, serror))\n-        // serror is set\n-        return false;\n-    if (flags & SCRIPT_VERIFY_P2SH)\n-        stackCopy = stack;\n-    if (!EvalScript(stack, scriptPubKey, flags, checker, SigVersion::BASE, serror))\n-        // serror is set\n-        return false;\n-    if (stack.empty())\n-        return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n-    if (CastToBool(stack.back()) == false)\n-        return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n+    // TODO: bake flag implication into a flags class rather than assert?\n+\n+    // We can't check for correct unexpected witness data if P2SH was off, so require\n+    // that WITNESS implies P2SH. Otherwise, going from WITNESS->P2SH+WITNESS would be\n+    // possible, which is not a softfork.\n+    if (flags & SCRIPT_VERIFY_WITNESS) {\n+        assert((flags & SCRIPT_VERIFY_P2SH) != 0);\n+    }\n+\n+    // Disallow CLEANSTACK without P2SH, as otherwise a switch CLEANSTACK->P2SH+CLEANSTACK\n+    // would be possible, which is not a softfork (and P2SH should be one).\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK) {\n+        assert((flags & SCRIPT_VERIFY_P2SH) != 0);\n+        assert((flags & SCRIPT_VERIFY_WITNESS) != 0);\n+    }\n \n-    // Bare witness programs\n-    int witnessversion;\n-    std::vector<unsigned char> witnessprogram;\n     if (flags & SCRIPT_VERIFY_WITNESS) {\n-        if (scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) {\n-            hadWitness = true;\n+        int witnessversion;\n+        std::vector<unsigned char> witnessprogram;\n+        // Bare witness programs\n+        if(scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) {\n             if (scriptSig.size() != 0) {\n                 // The scriptSig must be _exactly_ CScript(), otherwise we reintroduce malleability.\n                 return set_error(serror, SCRIPT_ERR_WITNESS_MALLEATED);\n             }\n+            if (CastToBool(witnessprogram) == false)\n+                return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n+\n             if (!VerifyWitnessProgram(*witness, witnessversion, witnessprogram, flags, checker, serror)) {\n                 return false;\n             }\n-            // Bypass the cleanstack check at the end. The actual stack is obviously not clean\n-            // for witness programs.\n-            stack.resize(1);\n+            return set_success(serror);\n         }\n-    }\n-\n-    // Additional validation for spend-to-script-hash transactions:\n-    if ((flags & SCRIPT_VERIFY_P2SH) && scriptPubKey.IsPayToScriptHash())\n-    {\n-        // scriptSig must be literals-only or validation fails\n-        if (!scriptSig.IsPushOnly())\n-            return set_error(serror, SCRIPT_ERR_SIG_PUSHONLY);\n \n-        // Restore stack.\n-        swap(stack, stackCopy);\n+        if (scriptPubKey.IsPayToScriptHash()) {\n+            // scriptSig must be literals-only or validation fails, skip if checked earlier\n+            if (!(flags & SCRIPT_VERIFY_SIGPUSHONLY) && !scriptSig.IsPushOnly())\n+                return set_error(serror, SCRIPT_ERR_SIG_PUSHONLY);\n \n-        // stack cannot be empty here, because if it was the\n-        // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with\n-        // an empty stack and the EvalScript above would return false.\n-        assert(!stack.empty());\n-\n-        const valtype& pubKeySerialized = stack.back();\n-        CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end());\n-        popstack(stack);\n+            std::vector<std::vector<unsigned char> > stack;\n+            if (!EvalScript(stack, scriptSig, flags, checker, SigVersion::BASE, serror))\n+                // serror is set\n+                return false;\n+            {\n+                std::vector<std::vector<unsigned char> > stackCopy = stack;\n+                if (!EvalScript(stackCopy, scriptPubKey, flags, checker, SigVersion::BASE, serror))\n+                    // serror is set\n+                    return false;\n+                // stackCopy cannot be empty because we know it is a PayToScriptHash template\n+                assert(!stackCopy.empty());\n+                if (CastToBool(stackCopy.back()) == false)\n+                    return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n+            }\n \n-        if (!EvalScript(stack, pubKey2, flags, checker, SigVersion::BASE, serror))\n-            // serror is set\n-            return false;\n-        if (stack.empty())\n-            return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n-        if (!CastToBool(stack.back()))\n-            return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n+            // stack cannot be empty here, because if it was the\n+            // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with\n+            // an empty stack and the EvalScript above would return false.\n+            assert(!stack.empty());\n \n-        // P2SH witness program\n-        if (flags & SCRIPT_VERIFY_WITNESS) {\n+            const valtype& pubKeySerialized = stack.back();\n+            CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end());\n+            // P2SH witness program\n             if (pubKey2.IsWitnessProgram(witnessversion, witnessprogram)) {\n-                hadWitness = true;\n+                if (!CastToBool(witnessprogram))\n+                    return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n                 if (scriptSig != CScript() << std::vector<unsigned char>(pubKey2.begin(), pubKey2.end())) {\n                     // The scriptSig must be _exactly_ a single push of the redeemScript. Otherwise we\n                     // reintroduce malleability.\n@@ -1555,36 +1555,106 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n                 if (!VerifyWitnessProgram(*witness, witnessversion, witnessprogram, flags, checker, serror)) {\n                     return false;\n                 }\n-                // Bypass the cleanstack check at the end. The actual stack is obviously not clean\n-                // for witness programs.\n-                stack.resize(1);\n+            } else {\n+                popstack(stack);\n+                if (!EvalScript(stack, pubKey2, flags, checker, SigVersion::BASE, serror))\n+                    // serror is set\n+                    return false;\n+                if (stack.empty())\n+                    return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n+                if (!CastToBool(stack.back()))\n+                    return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n+                // This CLEANSTACK check is only performed after P2SH evaluation,\n+                // as the non-P2SH evaluation of a P2SH script will obviously not result in\n+                // a clean stack (the P2SH inputs remain).\n+                if ((flags & SCRIPT_VERIFY_CLEANSTACK) && stack.size() != 1) {\n+                    return set_error(serror, SCRIPT_ERR_CLEANSTACK);\n+                }\n+                if (!witness->IsNull()) {\n+                    return set_error(serror, SCRIPT_ERR_WITNESS_UNEXPECTED);\n+                }\n             }\n+            return set_success(serror);\n         }\n-    }\n \n-    // The CLEANSTACK check is only performed after potential P2SH evaluation,\n-    // as the non-P2SH evaluation of a P2SH script will obviously not result in\n-    // a clean stack (the P2SH inputs remain). The same holds for witness evaluation.\n-    if ((flags & SCRIPT_VERIFY_CLEANSTACK) != 0) {\n-        // Disallow CLEANSTACK without P2SH, as otherwise a switch CLEANSTACK->P2SH+CLEANSTACK\n-        // would be possible, which is not a softfork (and P2SH should be one).\n-        assert((flags & SCRIPT_VERIFY_P2SH) != 0);\n-        assert((flags & SCRIPT_VERIFY_WITNESS) != 0);\n-        if (stack.size() != 1) {\n-            return set_error(serror, SCRIPT_ERR_CLEANSTACK);\n+        // SCRIPT_VERIFY_WITNESS is set, but the script wasn't a bare or p2sh witness program\n+        // and still had a witness, so fail\n+        if (!witness->IsNull()) {\n+            return set_error(serror, SCRIPT_ERR_WITNESS_UNEXPECTED);\n         }\n+\n+        // Perform Classic Script Verfication\n     }\n \n-    if (flags & SCRIPT_VERIFY_WITNESS) {\n-        // We can't check for correct unexpected witness data if P2SH was off, so require\n-        // that WITNESS implies P2SH. Otherwise, going from WITNESS->P2SH+WITNESS would be\n-        // possible, which is not a softfork.\n-        assert((flags & SCRIPT_VERIFY_P2SH) != 0);\n-        if (!hadWitness && !witness->IsNull()) {\n-            return set_error(serror, SCRIPT_ERR_WITNESS_UNEXPECTED);\n+    if ((flags & SCRIPT_VERIFY_P2SH) && !(flags & SCRIPT_VERIFY_WITNESS)) {\n+        if (scriptPubKey.IsPayToScriptHash()) {\n+            // Additional validation for spend-to-script-hash transactions:\n+            // scriptSig must be literals-only or validation fails, skip if checked earlier\n+            if (!(flags & SCRIPT_VERIFY_SIGPUSHONLY) && !scriptSig.IsPushOnly())\n+                return set_error(serror, SCRIPT_ERR_SIG_PUSHONLY);\n+            std::vector<std::vector<unsigned char> > stack;\n+            if (!EvalScript(stack, scriptSig, flags, checker, SigVersion::BASE, serror))\n+                // serror is set\n+                return false;\n+            {\n+                std::vector<std::vector<unsigned char> > stackCopy = stack;\n+                if (!EvalScript(stackCopy, scriptPubKey, flags, checker, SigVersion::BASE, serror))\n+                    // serror is set\n+                    return false;\n+                // stackCopy cannot be empty because we know it is a PayToScriptHash template\n+                assert(!stackCopy.empty());\n+                if (CastToBool(stackCopy.back()) == false)\n+                    return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n+            }\n+\n+            // stack cannot be empty here, because if it was the\n+            // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with\n+            // an empty stack and the EvalScript above would return false.\n+            assert(!stack.empty());\n+\n+            const valtype& pubKeySerialized = stack.back();\n+            CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end());\n+            popstack(stack);\n+\n+            if (!EvalScript(stack, pubKey2, flags, checker, SigVersion::BASE, serror))\n+                // serror is set\n+                return false;\n+            if (stack.empty())\n+                return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n+            if (!CastToBool(stack.back()))\n+                return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n+            return set_success(serror);\n         }\n+\n+        // Perform Classic Script Verfication\n+    }\n+\n+    // Classic Script Verification:\n+    std::vector<std::vector<unsigned char> > stack;\n+    {\n+        if (!EvalScript(stack, scriptSig, flags, checker, SigVersion::BASE, serror))\n+            // serror is set\n+            return false;\n+        if (!EvalScript(stack, scriptPubKey, flags, checker, SigVersion::BASE, serror))\n+            // serror is set\n+            return false;\n+        if (stack.empty())\n+            return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n+        if (CastToBool(stack.back()) == false)\n+            return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n     }\n \n+    // Postcondition checks for Classic Script if other validation modes\n+    // are enabled\n+    {\n+        // this CLEANSTACK check is only performed after non-P2SH evaluation\n+        // while SCRIPT_VERIFY_P2SH is enabled. The same holds for witness evaluation.\n+        if (flags & SCRIPT_VERIFY_CLEANSTACK) {\n+            if (stack.size() != 1) {\n+                return set_error(serror, SCRIPT_ERR_CLEANSTACK);\n+            }\n+        }\n+    }\n     return set_success(serror);\n }\n "
      }
    ]
  }
]