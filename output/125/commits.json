[
  {
    "sha": "321a16784cbf21aa8fd1a218d1a971cea1bbd010",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozMjFhMTY3ODRjYmYyMWFhOGZkMWEyMThkMWE5NzFjZWExYmJkMDEw",
    "commit": {
      "author": {
        "name": "Jim Hyslop",
        "email": "jhyslop@dreampossible.ca",
        "date": "2011-03-20T04:47:44Z"
      },
      "committer": {
        "name": "Jim Hyslop",
        "email": "jhyslop@dreampossible.ca",
        "date": "2011-03-20T04:47:44Z"
      },
      "message": "Reworked debug logging. Implemented so that it allows backwards\ncompatibility - i.e. there is no immediate need to change all\n'printf' statements.",
      "tree": {
        "sha": "fd6b745bc30f9858e2f469b6561afb372b7c44ac",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fd6b745bc30f9858e2f469b6561afb372b7c44ac"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/321a16784cbf21aa8fd1a218d1a971cea1bbd010",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/321a16784cbf21aa8fd1a218d1a971cea1bbd010",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/321a16784cbf21aa8fd1a218d1a971cea1bbd010",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/321a16784cbf21aa8fd1a218d1a971cea1bbd010/comments",
    "author": {
      "login": "jhyslop",
      "id": 653590,
      "node_id": "MDQ6VXNlcjY1MzU5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/653590?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jhyslop",
      "html_url": "https://github.com/jhyslop",
      "followers_url": "https://api.github.com/users/jhyslop/followers",
      "following_url": "https://api.github.com/users/jhyslop/following{/other_user}",
      "gists_url": "https://api.github.com/users/jhyslop/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jhyslop/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jhyslop/subscriptions",
      "organizations_url": "https://api.github.com/users/jhyslop/orgs",
      "repos_url": "https://api.github.com/users/jhyslop/repos",
      "events_url": "https://api.github.com/users/jhyslop/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jhyslop/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jhyslop",
      "id": 653590,
      "node_id": "MDQ6VXNlcjY1MzU5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/653590?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jhyslop",
      "html_url": "https://github.com/jhyslop",
      "followers_url": "https://api.github.com/users/jhyslop/followers",
      "following_url": "https://api.github.com/users/jhyslop/following{/other_user}",
      "gists_url": "https://api.github.com/users/jhyslop/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jhyslop/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jhyslop/subscriptions",
      "organizations_url": "https://api.github.com/users/jhyslop/orgs",
      "repos_url": "https://api.github.com/users/jhyslop/repos",
      "events_url": "https://api.github.com/users/jhyslop/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jhyslop/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8f58d0dbc8cc05d0969373eb4c0a555931b64245",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8f58d0dbc8cc05d0969373eb4c0a555931b64245",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8f58d0dbc8cc05d0969373eb4c0a555931b64245"
      }
    ],
    "stats": {
      "total": 439,
      "additions": 392,
      "deletions": 47
    },
    "files": [
      {
        "sha": "b5bc3759033ccf7f7c26b59145b283dcd8532ecf",
        "filename": "init.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 1,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/321a16784cbf21aa8fd1a218d1a971cea1bbd010/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/321a16784cbf21aa8fd1a218d1a971cea1bbd010/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/init.cpp?ref=321a16784cbf21aa8fd1a218d1a971cea1bbd010",
        "patch": "@@ -186,7 +186,10 @@ bool AppInit2(int argc, char* argv[])\n             \"  -rpcallowip=<ip> \\t\\t  \" + _(\"Allow JSON-RPC connections from specified IP address\\n\") +\n             \"  -rpcconnect=<ip> \\t  \"   + _(\"Send commands to node running on <ip> (default: 127.0.0.1)\\n\") +\n             \"  -keypool=<n>     \\t  \"   + _(\"Set key pool size to <n> (default: 100)\\n\") +\n-            \"  -rescan          \\t  \"   + _(\"Rescan the block chain for missing wallet transactions\\n\");\n+            \"  -rescan          \\t  \"   + _(\"Rescan the block chain for missing wallet transactions\\n\") +\n+            \"  -loglevel=<level>\\t  \"   + _(\"Set the log verbosity level. Use '-loglevel=?' to get a list of levels (default: Warning)\\n\") +\n+            \"  -logcontexts=<contexts>\\t  \"  + _(\"Set the context(s) to log. Use '-logcontexts=?' to get a list of contexts(default: All)\\n\");\n+    \n \n #ifdef USE_SSL\n         strUsage += string() +\n@@ -212,13 +215,38 @@ bool AppInit2(int argc, char* argv[])\n     }\n \n     fDebug = GetBoolArg(\"-debug\");\n+    if ( fDebug )\n+    {\n+        SetLogVerbosity( VL_Debug );\n+    }\n+\n+    if (mapArgs.count(\"-loglevel\"))\n+    {\n+        SetLogVerbosity(ParseVerbosity(mapArgs[\"-loglevel\"]));\n+    }\n+    if (mapArgs.count(\"-logcontexts\"))\n+    {\n+        SetLogOutput(ParseLogContext(mapArgs[\"-logcontexts\"]));\n+    }\n+    // These output log messages can be used to test context & verbosity\n+    //OutputLogMessageF(LC_Params, VL_Verbose, \"This is a verbose message\\n\");\n+    //OutputLogMessageF(LC_Params, VL_Debug, \"This is a debug message\\n\");\n+    //OutputLogMessageF(LC_Params, VL_Warning, \"This is a warning message\\n\");\n+    //OutputLogMessageF(LC_Params, VL_Error, \"This is an error message\\n\");\n+    //OutputLogMessageF(LC_Params, VL_Critical, \"This is a critical message\\n\");\n+    //OutputLogMessageF(LC_Params, VL_Off, \"This is an off message (yes, I know, that doesn't make sense). Contexts: 0x%08x\\n\", TurnOnLogOutput(LC_NoChange));\n+    OutputLogMessageF(LC_Params|LC_Gen, VL_Debug, \"This message should appear with -logcontexts=Gen, -logcontexts=Params, or -logcontexts=Gen,Params (and -loglevel=debug)\\n\");\n \n     fPrintToConsole = GetBoolArg(\"-printtoconsole\");\n     fPrintToDebugger = GetBoolArg(\"-printtodebugger\");\n \n     fTestNet = GetBoolArg(\"-testnet\");\n     \n     fNoListen = GetBoolArg(\"-nolisten\");\n+    if ( GetBoolArg(\"-printpriority\") )\n+    {\n+        TurnOnLogOutput( LC_Priority );\n+    }\n \n     if (fCommandLine)\n     {"
      },
      {
        "sha": "20f88e51f0eed5ecbfdf14e97974ea2bb988f704",
        "filename": "main.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 10,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/321a16784cbf21aa8fd1a218d1a971cea1bbd010/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/321a16784cbf21aa8fd1a218d1a971cea1bbd010/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/main.cpp?ref=321a16784cbf21aa8fd1a218d1a971cea1bbd010",
        "patch": "@@ -144,7 +144,7 @@ bool AddToWallet(const CWalletTx& wtxIn)\n         }\n \n         //// debug print\n-        printf(\"AddToWallet %s  %s%s\\n\", wtxIn.GetHash().ToString().substr(0,10).c_str(), (fInsertedNew ? \"new\" : \"\"), (fUpdated ? \"update\" : \"\"));\n+        OutputLogMessageF(LC_Wallet, VL_Debug, \"AddToWallet %s  %s%s\\n\", wtxIn.GetHash().ToString().substr(0,10).c_str(), (fInsertedNew ? \"new\" : \"\"), (fUpdated ? \"update\" : \"\"));\n \n         // Write to disk\n         if (fInsertedNew || fUpdated)\n@@ -223,7 +223,7 @@ void WalletUpdateSpent(const COutPoint& prevout)\n             CWalletTx& wtx = (*mi).second;\n             if (!wtx.fSpent && wtx.vout[prevout.n].IsMine())\n             {\n-                printf(\"WalletUpdateSpent found spent coin %sbc %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n+                OutputLogMessageF(LC_Wallet, VL_Debug, \"WalletUpdateSpent found spent coin %sbc %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n                 wtx.fSpent = true;\n                 wtx.WriteToDisk();\n                 vWalletUpdated.push_back(prevout.hash);\n@@ -443,7 +443,7 @@ void CWalletTx::GetAmounts(int64& nGenerated, list<pair<string, int64> >& listRe\n             address = PubKeyToAddress(vchPubKey);\n         else\n         {\n-            printf(\"CWalletTx::GetAmounts: Unknown transaction type found, txid %s\\n\",\n+            OutputLogMessageF(LC_Wallet, VL_Warning, \"CWalletTx::GetAmounts: Unknown transaction type found, txid %s\\n\",\n                    this->GetHash().ToString().c_str());\n             address = \" unknown \";\n         }\n@@ -534,7 +534,7 @@ int CMerkleTx::SetMerkleBranch(const CBlock* pblock)\n         {\n             vMerkleBranch.clear();\n             nIndex = -1;\n-            printf(\"ERROR: SetMerkleBranch() : couldn't find tx in block\\n\");\n+            OutputLogMessageF(LC_Wallet|LC_Transaction, VL_Error, \"ERROR: SetMerkleBranch() : couldn't find tx in block\\n\");\n             return 0;\n         }\n \n@@ -595,7 +595,7 @@ void CWalletTx::AddSupportingTransactions(CTxDB& txdb)\n                 }\n                 else\n                 {\n-                    printf(\"ERROR: AddSupportingTransactions() : unsupported transaction\\n\");\n+                    OutputLogMessageF(LC_Transaction, VL_Error, \"ERROR: AddSupportingTransactions() : unsupported transaction\\n\");\n                     continue;\n                 }\n \n@@ -759,7 +759,7 @@ bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMi\n     {\n         if (ptxOld)\n         {\n-            printf(\"AcceptToMemoryPool() : replacing tx %s with new version\\n\", ptxOld->GetHash().ToString().c_str());\n+            OutputLogMessageF(LC_Transaction, VL_Debug, \"AcceptToMemoryPool() : replacing tx %s with new version\\n\", ptxOld->GetHash().ToString().c_str());\n             ptxOld->RemoveFromMemoryPool();\n         }\n         AddToMemoryPoolUnchecked();\n@@ -770,7 +770,7 @@ bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMi\n     if (ptxOld)\n         EraseFromWallet(ptxOld->GetHash());\n \n-    printf(\"AcceptToMemoryPool(): accepted %s\\n\", hash.ToString().substr(0,10).c_str());\n+    OutputLogMessageF(LC_Transaction, VL_Debug, \"AcceptToMemoryPool(): accepted %s\\n\", hash.ToString().substr(0,10).c_str());\n     return true;\n }\n \n@@ -2218,7 +2218,6 @@ bool ProcessMessages(CNode* pfrom)\n     CDataStream& vRecv = pfrom->vRecv;\n     if (vRecv.empty())\n         return true;\n-    //if (fDebug)\n     //    printf(\"ProcessMessages(%u bytes)\\n\", vRecv.size());\n \n     //\n@@ -2338,8 +2337,7 @@ bool ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n {\n     static map<unsigned int, vector<unsigned char> > mapReuseKey;\n     RandAddSeedPerfmon();\n-    if (fDebug)\n-        printf(\"%s \", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n+    printf(\"%s \", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n     printf(\"received: %s (%d bytes)\\n\", strCommand.c_str(), vRecv.size());\n     if (mapArgs.count(\"-dropmessagestest\") && GetRand(atoi(mapArgs[\"-dropmessagestest\"])) == 0)\n     {"
      },
      {
        "sha": "e82ac61d568aa9fb09602ae470aa3f548479de01",
        "filename": "net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/321a16784cbf21aa8fd1a218d1a971cea1bbd010/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/321a16784cbf21aa8fd1a218d1a971cea1bbd010/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/net.cpp?ref=321a16784cbf21aa8fd1a218d1a971cea1bbd010",
        "patch": "@@ -516,8 +516,7 @@ void CNode::CloseSocketDisconnect()\n     fDisconnect = true;\n     if (hSocket != INVALID_SOCKET)\n     {\n-        if (fDebug)\n-            printf(\"%s \", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n+        printf(\"%s \", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n         printf(\"disconnecting node %s\\n\", addr.ToStringLog().c_str());\n         closesocket(hSocket);\n         hSocket = INVALID_SOCKET;"
      },
      {
        "sha": "b5c48ccbb5cf7c252eb2c48282bdc4c89e46aca9",
        "filename": "net.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/321a16784cbf21aa8fd1a218d1a971cea1bbd010/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/321a16784cbf21aa8fd1a218d1a971cea1bbd010/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/net.h?ref=321a16784cbf21aa8fd1a218d1a971cea1bbd010",
        "patch": "@@ -672,8 +672,7 @@ class CNode\n         nHeaderStart = vSend.size();\n         vSend << CMessageHeader(pszCommand, 0);\n         nMessageStart = vSend.size();\n-        if (fDebug)\n-            printf(\"%s \", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n+        printf(\"%s \", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n         printf(\"sending: %s \", pszCommand);\n     }\n "
      },
      {
        "sha": "b8fa2ef57f076f346bee795abc2ebe0ca60b5c31",
        "filename": "util.cpp",
        "status": "modified",
        "additions": 235,
        "deletions": 24,
        "changes": 259,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/321a16784cbf21aa8fd1a218d1a971cea1bbd010/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/321a16784cbf21aa8fd1a218d1a971cea1bbd010/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/util.cpp?ref=321a16784cbf21aa8fd1a218d1a971cea1bbd010",
        "patch": "@@ -4,7 +4,6 @@\n \n #include \"headers.h\"\n \n-\n map<string, string> mapArgs;\n map<string, vector<string> > mapMultiArgs;\n bool fDebug = false;\n@@ -137,22 +136,223 @@ int GetRandInt(int nMax)\n \n \n \n+////////////////////////////////////////////////////////////////////////////////////////\n+//\n+// Logging Functions\n+//\n \n+namespace\n+{\n+    enumLogContext  currentLogContext = static_cast<enumLogContext>(~LC_Legacy);\n+    enumVerbosityLevel currentVerbosity = VL_Warning;\n+    struct LogContextInfo {\n+        enumLogContext context;\n+        const char * name;\n+        const char * description;\n+    } lgInfo[] =\n+    {\n+       {LC_All,         \"All\",         _(\"Log all contexts\")},\n+       {LC_None,        \"None\",        _(\"Turn off logging (equivalent to setting Log Verbosity to Off)\")},\n+       {LC_Accept,      \"Accept\",      _(\"Processes involving accepting transactions\")},\n+       {LC_Account,     \"Account\",     _(\"Account-related functions\")},\n+       {LC_Alert,       \"Alert\",       _(\"Processing alert messages\")},\n+       {LC_Block,       \"Block\",       _(\"Functions related to processing blocks\")},\n+       {LC_Chain,       \"Chain\",       _(\"Functions related to block chaining\")},\n+       {LC_DB,          \"DB\",          _(\"Database functions\")},\n+       {LC_Gen,         \"Gen\",         _(\"Coin-generation functions\")},\n+       {LC_HashRate,    \"HashRate\",    _(\"The hash generation rate, typically logged every 30 minutes\")},\n+       {LC_IRC,         \"IRC\",         _(\"IRC messages\")},\n+       {LC_Legacy,      \"Legacy\",      _(\"Interim flag, used for messages that pre-date the context schema\")},\n+       {LC_Main,        \"Main\",        _(\"main() \")},\n+       {LC_Message,     \"Message\",     _(\"General message processing\")},\n+       {LC_Net,         \"Net\",         _(\"Network-related messages\")},\n+       {LC_Orphan,      \"Orphan\",      _(\"Messages for orphaned blocks/transactions\")},\n+       {LC_Params,      \"Params\",      _(\"Messages generated during parameter parsing\")},\n+       {LC_Priority,    \"Priority\",    _(\"Log the priority messages (equivalent to the old -printpriority flag)\")},\n+       {LC_RPC,         \"RPC\",         _(\"RPC messages\")},\n+       {LC_Send,        \"Send\",        _(\"Sendmoney messages\")},\n+       {LC_Sha,         \"SHA\",         _(\"Messages output by the SHA functions\")},\n+       {LC_Sys,         \"Sys\",         _(\"System-related messages, e.g. low disk space\")},\n+       {LC_Test,        \"Test\",        _(\"Messages output when specific files are compiled in test mode\")},\n+       {LC_Thread,      \"Thread\",      _(\"Messages related to thread creation & destruction\")},\n+       {LC_Time,        \"Time\",        _(\"Messages related to time and timing\")},\n+       {LC_Transaction, \"Transaction\", _(\"Messages related to transactions & transaction processing\")},\n+       {LC_Util,        \"Util\",        _(\"Messages generated by utility functions\")},\n+       {LC_Wallet,      \"Wallet\",      _(\"Messages related to wallet transactions\")},\n+    };\n+    const int numLogContexts = sizeof(lgInfo)/sizeof(lgInfo[0]);\n+\n+    int OutputLogMessageFInternal(enumLogContext context, enumVerbosityLevel verbosity, const char * pszFormat, va_list arg_ptr);\n+}\n+void SetLogOutput(enumLogContext contextsToLog)\n+{\n+    currentLogContext = contextsToLog;\n+}\n \n+// Returns the new log output mask. Pass LC_NoChange if all you want to do is query the current mask.\n+enumLogContext TurnOnLogOutput(enumLogContext contextsToAdd)\n+{\n+    enumLogContext old = currentLogContext;\n+    currentLogContext = currentLogContext | contextsToAdd;\n+    return old;\n+}\n+\n+// Returns the new log output mask. Pass LC_NoChange if all you want to do is query the current mask.\n+enumLogContext TurnOffLogOutput(enumLogContext contextsToRemove)\n+{\n+    enumLogContext old = currentLogContext;\n+    currentLogContext = static_cast<enumLogContext>(currentLogContext & ~contextsToRemove);\n+    return old;\n+}\n+// Returns the previous log verbosity\n+enumVerbosityLevel SetLogVerbosity(enumVerbosityLevel verbosity)\n+{\n+    enumVerbosityLevel old = currentVerbosity;\n+    currentVerbosity = verbosity;\n+    return old;\n+}\n+bool IsLogVerbosity(enumVerbosityLevel verbosity)\n+{\n+    return verbosity <= currentVerbosity;\n+}\n+\n+enumLogContext ParseLogContext(const std::string & contexts)\n+{\n+    int newLogContexts=0;\n+    if (contexts[0] == '?')\n+    {\n+        // We've been explicitly told to print this info, so temporarily override the verbosity & contexts\n+        enumVerbosityLevel old = SetLogVerbosity(VL_Debug);\n+        enumLogContext oldGrp = currentLogContext;\n+        currentLogContext = LC_Params;\n+        OutputLogMessageF(LC_Params, VL_Debug, \n+             _(\"Note that some log contexts have not yet been implemented. Multiple contexts can be\\n\"\n+               \"specified, separated by any non-alphabetic character (subject to operating\\n\"\n+               \"system constraints).\\n\"\n+               \"For example: -logcontexts=Block,Chaining will log messages that are specified as\\n\"\n+               \"either Block messages or Chaining messages.\\n\"\n+               \"Curently defined log contexts (not case-sensitive):\\n\")\n+           );\n+        for (size_t index=0; index<numLogContexts; ++index)\n+        {\n+            OutputLogMessageF(LC_Params, VL_Debug, \"\\t%s\\t%s\\n\", lgInfo[index].name, lgInfo[index].description);\n+        }\n+        OutputLogMessageF(LC_Params, VL_Debug, _(\"Contexts currently being logged: \"));\n+        string comma=\"\";\n+        for (size_t index=0; index<numLogContexts; ++index)\n+        {\n+            if ( lgInfo[index].context != LC_All && (oldGrp & lgInfo[index].context) != 0)\n+            {\n+                OutputLogMessageF(LC_Params, VL_Debug, \"%s %s\", comma.c_str(), lgInfo[index].name);\n+                comma=\",\";\n+            }\n+        }\n+        OutputLogMessageF(LC_Params, VL_Debug, \"\\n\");\n+        // Restore original settings\n+        SetLogVerbosity(old);\n+        currentLogContext = oldGrp;\n+        // This function is likely called as part of parameter parsing, so return the current\n+        // settings so that we don't mess up the current settings.\n+        newLogContexts = oldGrp;\n+    } else {\n+        const char * letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n+        size_t tokenStart=contexts.find_first_of(letters);\n+        while (tokenStart != string::npos)\n+        {\n+            size_t tokenEnd = contexts.find_first_not_of(letters, tokenStart);\n+            size_t tokenLen = (tokenEnd == string::npos ? contexts.length() : tokenEnd) - tokenStart;\n+            size_t index;\n+            string token = contexts.substr( tokenStart, tokenLen );\n+            for (index=0; index<numLogContexts; ++index)\n+            {\n+                if (strcasecmp(token.c_str(), lgInfo[index].name) == 0)\n+                {\n+                    newLogContexts |= lgInfo[index].context;\n+                    break;\n+                }\n+            }\n+            if ( index == numLogContexts )\n+            {\n+                OutputLogMessageF(LC_Params, VL_Warning, \"Warning: Unrecognized log context '%s' - ignoring it\\n\", token.c_str());\n+            }\n+            tokenStart = contexts.find_first_of(letters, tokenEnd);\n+        }\n+        OutputLogMessageF(LC_Params, VL_Debug, _(\"Contexts parsed: \"));\n+        string comma=\"\";\n+        for (size_t index=0; index<numLogContexts; ++index)\n+        {\n+            if ( lgInfo[index].context != LC_All && (newLogContexts & lgInfo[index].context) != 0)\n+            {\n+                OutputLogMessageF(LC_Params, VL_Debug, \"%s %s\", comma.c_str(), lgInfo[index].name);\n+                comma=\",\";\n+            }\n+        }\n+        OutputLogMessageF(LC_Params, VL_Debug, \"\\n\");\n+    }\n+    return static_cast<enumLogContext>(newLogContexts);\n+}\n+enumVerbosityLevel ParseVerbosity(const std::string & verbosity)\n+{\n+    enumVerbosityLevel newVerbosity=VL_Off;\n \n+    if (isdigit(verbosity[0]))\n+    {\n+        int newLevel = atoi(verbosity.c_str());\n+        if (newLevel<0) newLevel=0;\n+        if (newLevel>VL_Verbose) newLevel=VL_Verbose;\n+        newVerbosity=static_cast<enumVerbosityLevel>(newLevel);\n+    } else {\n+        string lower=verbosity;\n+        for (size_t index=0; index<lower.length(); ++index)\n+        {\n+            if ( isalpha(lower[index]) ) lower[index]=tolower(lower[index]);\n+        }\n+        if ( lower == \"off\" )\n+            newVerbosity=VL_Off;\n+        else if (lower==\"critical\")\n+            newVerbosity=VL_Critical;\n+        else if (lower==\"error\")\n+            newVerbosity=VL_Error;\n+        else if (lower==\"warning\")\n+            newVerbosity=VL_Warning;\n+        else if (lower==\"debug\")\n+            newVerbosity=VL_Debug;\n+        else if (lower==\"verbose\")\n+            newVerbosity=VL_Verbose;\n+        else {\n+            enumVerbosityLevel save = currentVerbosity;\n+            currentVerbosity=VL_Warning;\n+            OutputLogMessageF(LC_Params, VL_Warning, \"Warning: ignoring unrecognized verbosity level '%s'; verbosity level unchanged\\n\", verbosity.c_str());\n+            currentVerbosity=newVerbosity=save;\n+        }\n+    }\n+    OutputLogMessageF(LC_Params, VL_Debug, \"New verbosity level: %d\\n\", newVerbosity);\n+    return newVerbosity;\n+}\n \n \n+int OutputLogMessageF(enumLogContext context, enumVerbosityLevel verbosity, const char* pszFormat, ...)\n+{\n+    va_list arg_ptr;\n+    va_start(arg_ptr, pszFormat);\n+    int ret = OutputLogMessageFInternal(context, verbosity, pszFormat, arg_ptr);\n+    va_end(arg_ptr);\n+    return ret;\n+}\n \n-inline int OutputDebugStringF(const char* pszFormat, ...)\n+namespace{\n+int OutputLogMessageFInternal(enumLogContext context, enumVerbosityLevel verbosity, const char * pszFormat, va_list arg_ptr)\n {\n     int ret = 0;\n+    if (currentVerbosity == VL_Off || !IsLogVerbosity(verbosity) ||\n+        (context & currentLogContext) == 0 )\n+    {\n+        return 0;\n+    }\n     if (fPrintToConsole)\n     {\n         // print to console\n-        va_list arg_ptr;\n-        va_start(arg_ptr, pszFormat);\n         ret = vprintf(pszFormat, arg_ptr);\n-        va_end(arg_ptr);\n     }\n     else\n     {\n@@ -171,10 +371,7 @@ inline int OutputDebugStringF(const char* pszFormat, ...)\n         {\n             //// Debug print useful for profiling\n             //fprintf(fileout, \" %\"PRI64d\" \", GetTimeMillis());\n-            va_list arg_ptr;\n-            va_start(arg_ptr, pszFormat);\n             ret = vfprintf(fileout, pszFormat, arg_ptr);\n-            va_end(arg_ptr);\n         }\n     }\n \n@@ -190,11 +387,8 @@ inline int OutputDebugStringF(const char* pszFormat, ...)\n             static char* pend;\n             if (pend == NULL)\n                 pend = pszBuffer;\n-            va_list arg_ptr;\n-            va_start(arg_ptr, pszFormat);\n             int limit = END(pszBuffer) - pend - 2;\n             int ret = _vsnprintf(pend, limit, pszFormat, arg_ptr);\n-            va_end(arg_ptr);\n             if (ret < 0 || ret >= limit)\n             {\n                 pend = END(pszBuffer) - 2;\n@@ -219,7 +413,19 @@ inline int OutputDebugStringF(const char* pszFormat, ...)\n             pend -= (p1 - pszBuffer);\n         }\n     }\n-#endif\n+#endif // __WXMSW__\n+    return ret;\n+}\n+} // unnamed namespace\n+\n+// Eventually, this function can be removed once all calls to 'printf' have been changed\n+// to 'OutputLogMessageF'.\n+int OutputDebugStringF(const char* pszFormat, ...)\n+{\n+    va_list arg_ptr;\n+    va_start(arg_ptr, pszFormat);\n+    int ret = OutputLogMessageFInternal(LC_Legacy, VL_Debug, pszFormat, arg_ptr);\n+    va_end(arg_ptr);\n     return ret;\n }\n \n@@ -273,23 +479,28 @@ string strprintf(const char* format, ...)\n }\n \n \n-bool error(const char* format, ...)\n+namespace{\n+bool errorInternal(enumLogContext context, const char* format, va_list arg_ptr)\n {\n     char buffer[50000];\n     int limit = sizeof(buffer);\n-    va_list arg_ptr;\n-    va_start(arg_ptr, format);\n     int ret = _vsnprintf(buffer, limit, format, arg_ptr);\n-    va_end(arg_ptr);\n     if (ret < 0 || ret >= limit)\n     {\n         ret = limit - 1;\n         buffer[limit-1] = 0;\n     }\n-    printf(\"ERROR: %s\\n\", buffer);\n+    OutputLogMessageF(context, VL_Error, \"ERROR: %s\\n\", buffer);\n     return false;\n }\n-\n+}\n+bool error(const char* format, ...)\n+{\n+    va_list arg_ptr;\n+    va_start(arg_ptr, format);\n+    bool ret=errorInternal(LC_Legacy, format, arg_ptr);\n+    va_end(arg_ptr);\n+}\n \n void ParseString(const string& str, char c, vector<string>& v)\n {\n@@ -548,18 +759,18 @@ void FormatException(char* pszMessage, std::exception* pex, const char* pszThrea\n             \"UNKNOWN EXCEPTION       \\n%s in %s       \\n\", pszModule, pszThread);\n }\n \n-void LogException(std::exception* pex, const char* pszThread)\n+void LogException(enumLogContext context, std::exception* pex, const char* pszThread)\n {\n     char pszMessage[10000];\n     FormatException(pszMessage, pex, pszThread);\n-    printf(\"\\n%s\", pszMessage);\n+    OutputLogMessageF(context, VL_Error, \"\\n%s\", pszMessage);\n }\n \n-void PrintException(std::exception* pex, const char* pszThread)\n+void PrintException(enumLogContext context, std::exception* pex, const char* pszThread)\n {\n     char pszMessage[10000];\n     FormatException(pszMessage, pex, pszThread);\n-    printf(\"\\n\\n************************\\n%s\\n\", pszMessage);\n+    OutputLogMessageF(context, VL_Error, \"\\n\\n************************\\n%s\\n\", pszMessage);\n     fprintf(stderr, \"\\n\\n************************\\n%s\\n\", pszMessage);\n     strMiscWarning = pszMessage;\n #ifdef GUI\n@@ -580,11 +791,11 @@ void ThreadOneMessageBox(string strMessage)\n     fMessageBoxOpen = false;\n }\n \n-void PrintExceptionContinue(std::exception* pex, const char* pszThread)\n+void PrintExceptionContinue(enumLogContext context, std::exception* pex, const char* pszThread)\n {\n     char pszMessage[10000];\n     FormatException(pszMessage, pex, pszThread);\n-    printf(\"\\n\\n************************\\n%s\\n\", pszMessage);\n+    OutputLogMessageF(context, VL_Error, \"\\n\\n************************\\n%s\\n\", pszMessage);\n     fprintf(stderr, \"\\n\\n************************\\n%s\\n\", pszMessage);\n     strMiscWarning = pszMessage;\n #ifdef GUI"
      },
      {
        "sha": "8ed8e5744d8834a1f353d7079570e1400a926079",
        "filename": "util.h",
        "status": "modified",
        "additions": 118,
        "deletions": 8,
        "changes": 126,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/321a16784cbf21aa8fd1a218d1a971cea1bbd010/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/321a16784cbf21aa8fd1a218d1a971cea1bbd010/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/util.h?ref=321a16784cbf21aa8fd1a218d1a971cea1bbd010",
        "patch": "@@ -24,7 +24,6 @@ typedef unsigned long long  uint64;\n #define UBEGIN(a)           ((unsigned char*)&(a))\n #define UEND(a)             ((unsigned char*)&((&(a))[1]))\n #define ARRAYLEN(array)     (sizeof(array)/sizeof((array)[0]))\n-#define printf              OutputDebugStringF\n \n #ifdef snprintf\n #undef snprintf\n@@ -126,13 +125,93 @@ inline const char* _(const char* psz)\n #endif\n \n \n+// enumLogContext constants can be bitwise-ORed together, both when setting log context\n+// and when calling OutputLogStringF. For example, a particular operation may apply to\n+// both Block and Chaining, so you can call OutputLogStringF(LC_Block|LC_Chaining, <etc.>\n+// This list is not intended to be complete and final. It is merely my\n+// (Jim Hyslop's) first pass at organizing the debug messages. Feel free\n+// to revise, merge, expand, etc. this list. Just keep in mind that there is\n+// no guarantee that an enum can be > 32 bits on all compilers, so don't\n+// add any values > 0x80000000.\n+enum enumLogContext\n+{\n+    LC_NoChange    =          0,\n+    LC_None        =          0,\n+    LC_All         = 0xffffffff,\n+    LC_Accept      = 0x00000001,\n+    LC_Account     = 0x00000002,\n+    LC_Alert       = 0x00000004, \n+    LC_Bitcoin     = 0x00000008,\n+    LC_Block       = 0x00000010,\n+    LC_Chain       = 0x00000020,\n+    LC_Coins       = 0x00000040,\n+    LC_DB          = 0x00000080,\n+    LC_Gen         = 0x00000100,\n+    LC_HashRate    = 0x00000200,\n+    LC_IRC         = 0x00000400,\n+    LC_Main        = 0x00000800,\n+    LC_Message     = 0x00001000,\n+    LC_Net         = 0x00002000,\n+    LC_Orphan      = 0x00004000,\n+    LC_Params      = 0x00008000,\n+    LC_Priority    = 0x00010000,\n+    LC_RPC         = 0x00020000,\n+    LC_Send        = 0x00040000,\n+    LC_Sha         = 0x00080000,\n+    LC_Sys         = 0x00100000,\n+    LC_Test        = 0x00200000,\n+    LC_Thread      = 0x00400000,\n+    LC_Time        = 0x00800000,\n+    LC_Transaction = 0x01000000,\n+    LC_Util        = 0x02000000,\n+    LC_Wallet      = 0x04000000,\n+    LC_TBD1        = 0x08000000,\n+    LC_TBD2        = 0x10000000,\n+    LC_TBD3        = 0x20000000,\n+    LC_TBD4        = 0x40000000,\n+    LC_Legacy      = 0x80000000,\n+};\n \n+enum enumVerbosityLevel\n+{\n+  VL_Off,\n+  VL_Critical,\n+  VL_Error,\n+  VL_Warning,\n+  VL_Info,\n+  VL_Debug,\n+  VL_Verbose\n+};\n \n+// Utility function to make OR-ing the log context enums easier\n+inline enumLogContext operator | (enumLogContext e1, enumLogContext e2 )\n+{\n+    return static_cast<enumLogContext>( (int)e1|(int)e2 );\n+}\n \n+// Returns the new log output mask. Pass LC_NoChange if all you want to do is query the current mask.\n+enumLogContext TurnOnLogOutput(enumLogContext groupsToAdd);\n+// Returns the new log output mask. Pass LC_NoChange if all you want to do is query the current mask.\n+enumLogContext TurnOffLogOutput(enumLogContext groupsToRemove);\n+// Discard current groups, and use these ones instead.\n+void SetLogOutput(enumLogContext groupsToLog);\n+// Returns the previous log verbosity\n+enumVerbosityLevel SetLogVerbosity(enumVerbosityLevel verbosity);\n+bool IsLogVerbosity(enumVerbosityLevel);\n \n+// Utility functions to parse a list of log groups and the verbosity level out of a text\n+// string, which would come from either the command-line or an RPC command (RPC command TODO).\n+enumLogContext ParseLogContext(const std::string & groups);\n+enumVerbosityLevel ParseVerbosity(const std::string & verbosity);\n \n+// Revised function accepting the group and verbosity\n+int OutputLogMessageF(enumLogContext group, enumVerbosityLevel verbosity, const char* pszFormat, ...);\n+// Deprecated function, kept for backwards compatibility. Prefer the overloaded function above.\n+int OutputDebugStringF(const char* pszFormat, ...);\n \n-\n+// This macro is also deprecated. Eventually all instances of 'printf' in the source code should\n+// be changed to OutputDebugStringF\n+#define printf OutputDebugStringF\n \n extern map<string, string> mapArgs;\n extern map<string, vector<string> > mapMultiArgs;\n@@ -150,13 +229,31 @@ extern bool fNoListen;\n \n void RandAddSeed();\n void RandAddSeedPerfmon();\n-int OutputDebugStringF(const char* pszFormat, ...);\n int my_snprintf(char* buffer, size_t limit, const char* format, ...);\n string strprintf(const char* format, ...);\n+\n+// Error and exception logging functions - rewored to use new enumLogContext\n+bool error(enumLogContext logGroup, const char* format, ...);\n+void LogException(enumLogContext group, std::exception* pex, const char* pszThread);\n+void PrintException(enumLogContext group, std::exception* pex, const char* pszThread);\n+void PrintExceptionContinue(enumLogContext group, std::exception* pex, const char* pszThread);\n+// Old functions, retained for backwards compatibility. Prefer the overloaded versions accepting enumLogContext\n+// Note: some of these are declared inline to avoid compiler errors, otherwise we'd need to\n+// put them in a different file.\n bool error(const char* format, ...);\n-void LogException(std::exception* pex, const char* pszThread);\n-void PrintException(std::exception* pex, const char* pszThread);\n-void PrintExceptionContinue(std::exception* pex, const char* pszThread);\n+inline void LogException(std::exception* pex, const char* pszThread)\n+{\n+    LogException(LC_All, pex, pszThread);\n+}\n+inline void PrintException(std::exception* pex, const char* pszThread)\n+{\n+    PrintException(LC_All, pex, pszThread);\n+}\n+inline void PrintExceptionContinue(std::exception* pex, const char* pszThread)\n+{\n+    PrintExceptionContinue(LC_All, pex, pszThread);\n+}\n+\n void ParseString(const string& str, char c, vector<string>& v);\n string FormatMoney(int64 n, bool fPlus=false);\n bool ParseMoney(const string& str, int64& nRet);\n@@ -349,15 +446,28 @@ inline string HexNumStr(const vector<unsigned char>& vch, bool f0x=true)\n     return HexNumStr(vch.begin(), vch.end(), f0x);\n }\n \n+template<typename T>\n+void PrintHex(enumLogContext group, enumVerbosityLevel verbosity, const T pbegin, const T pend, const char* pszFormat=\"%s\", bool fSpaces=true)\n+{\n+    OutputLogMessageF(group, verbosity, pszFormat, HexStr(pbegin, pend, fSpaces).c_str());\n+}\n+\n+// Maintained for backward compatibility. Prefer the overloaded version.\n template<typename T>\n void PrintHex(const T pbegin, const T pend, const char* pszFormat=\"%s\", bool fSpaces=true)\n {\n-    printf(pszFormat, HexStr(pbegin, pend, fSpaces).c_str());\n+    PrintHex(LC_All, VL_Verbose, pbegin, pend, pszFormat, fSpaces);\n+}\n+\n+inline void PrintHex(enumLogContext group, enumVerbosityLevel verbosity, const vector<unsigned char>& vch, const char* pszFormat=\"%s\", bool fSpaces=true)\n+{\n+    OutputLogMessageF(group, verbosity, pszFormat, HexStr(vch, fSpaces).c_str());\n }\n \n+// Maintained for backward compatibility. Prefer the overloaded version.\n inline void PrintHex(const vector<unsigned char>& vch, const char* pszFormat=\"%s\", bool fSpaces=true)\n {\n-    printf(pszFormat, HexStr(vch, fSpaces).c_str());\n+    PrintHex(LC_All, VL_Verbose, vch, pszFormat, fSpaces);\n }\n \n inline int64 GetPerformanceCounter()"
      }
    ]
  }
]