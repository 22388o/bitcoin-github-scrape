[
  {
    "sha": "4955de592c10faebeed97ec25bfe5b3b76b4663b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0OTU1ZGU1OTJjMTBmYWViZWVkOTdlYzI1YmZlNWIzYjc2YjQ2NjNi",
    "commit": {
      "author": {
        "name": "Kosta Zertsekel",
        "email": "zertsekel@gmail.com",
        "date": "2014-09-10T11:35:27Z"
      },
      "committer": {
        "name": "Kosta Zertsekel",
        "email": "zertsekel@gmail.com",
        "date": "2014-09-10T16:12:21Z"
      },
      "message": "Fix coding style with uncrustify\n\nThe purpose of this patch is to propose and discuss the coding style\nfor the Bitcoin Core source code.\n\nThe main idea of this approach is:\n - Love spaces\n - Love newlines '\\n'\n - Love empty lines to delimit the code parts\n - Put curly braces **everywhere** and always on the new line\n\nI believe that this approach produce the code that is especially\neasy to read and understand for the non-pro person diving into\nthe world of Bitcoin.\n\nThe 'uncrustify' 0.59 tool was used to fix the coding style (from official\nUbuntu 14.04 repo).\n\nThe command used to process the files:\n```\nfind . -iname \"*.h\" -o -iname \"*.cc\" -o -iname \"*.cpp\" | sort | grep -v \"src\\/leveldb\\/\" | grep -v \"src\\/json\\/\" | grep -v \"src\\/qt\\/\" | grep -v \"src\\/test\\/\" | xargs -I '{}' uncrustify -c .uncrustify.cfg --no-backup --replace '{}'\n```\n\n - UniversalIndentGUI program may be used to try and test the coding style easily\n\n - 'uncrustify' does not support partial files\n   (as `git clang-format` does, at least I'm not aware of one)",
      "tree": {
        "sha": "8ca9e8ebae448b5b68b35d01e928d02a5bae39ca",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8ca9e8ebae448b5b68b35d01e928d02a5bae39ca"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4955de592c10faebeed97ec25bfe5b3b76b4663b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4955de592c10faebeed97ec25bfe5b3b76b4663b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4955de592c10faebeed97ec25bfe5b3b76b4663b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4955de592c10faebeed97ec25bfe5b3b76b4663b/comments",
    "author": {
      "login": "kostaz",
      "id": 451660,
      "node_id": "MDQ6VXNlcjQ1MTY2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/451660?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kostaz",
      "html_url": "https://github.com/kostaz",
      "followers_url": "https://api.github.com/users/kostaz/followers",
      "following_url": "https://api.github.com/users/kostaz/following{/other_user}",
      "gists_url": "https://api.github.com/users/kostaz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kostaz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kostaz/subscriptions",
      "organizations_url": "https://api.github.com/users/kostaz/orgs",
      "repos_url": "https://api.github.com/users/kostaz/repos",
      "events_url": "https://api.github.com/users/kostaz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kostaz/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kostaz",
      "id": 451660,
      "node_id": "MDQ6VXNlcjQ1MTY2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/451660?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kostaz",
      "html_url": "https://github.com/kostaz",
      "followers_url": "https://api.github.com/users/kostaz/followers",
      "following_url": "https://api.github.com/users/kostaz/following{/other_user}",
      "gists_url": "https://api.github.com/users/kostaz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kostaz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kostaz/subscriptions",
      "organizations_url": "https://api.github.com/users/kostaz/orgs",
      "repos_url": "https://api.github.com/users/kostaz/repos",
      "events_url": "https://api.github.com/users/kostaz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kostaz/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fd1caa0961d9a5ceef0b8b232f278c9c27605d63",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fd1caa0961d9a5ceef0b8b232f278c9c27605d63",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fd1caa0961d9a5ceef0b8b232f278c9c27605d63"
      }
    ],
    "stats": {
      "total": 28017,
      "additions": 20836,
      "deletions": 7181
    },
    "files": [
      {
        "sha": "3d6573c0f18a80a4833d5e311a746c9923400a49",
        "filename": ".uncrustify.cfg",
        "status": "added",
        "additions": 210,
        "deletions": 0,
        "changes": 210,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/.uncrustify.cfg",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/.uncrustify.cfg",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.uncrustify.cfg?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -0,0 +1,210 @@\n+set FOR BOOST_FOREACH\n+tok_split_gte=false\n+utf8_byte=false\n+utf8_force=false\n+indent_cmt_with_tabs=false\n+indent_align_string=true\n+indent_braces=false\n+indent_braces_no_func=false\n+indent_braces_no_class=false\n+indent_braces_no_struct=false\n+indent_brace_parent=false\n+indent_namespace=false\n+indent_extern=false\n+indent_class=true\n+indent_class_colon=false\n+indent_else_if=false\n+indent_var_def_cont=false\n+indent_func_call_param=false\n+indent_func_def_param=false\n+indent_func_proto_param=false\n+indent_func_class_param=false\n+indent_func_ctor_var_param=false\n+indent_template_param=false\n+indent_func_param_double=false\n+indent_relative_single_line_comments=false\n+indent_col1_comment=false\n+indent_access_spec_body=false\n+indent_paren_nl=false\n+indent_comma_paren=false\n+indent_bool_paren=false\n+indent_first_bool_expr=false\n+indent_square_nl=false\n+indent_preserve_sql=false\n+indent_align_assign=false\n+sp_balance_nested_parens=false\n+align_keep_tabs=false\n+align_with_tabs=false\n+align_on_tabstop=false\n+align_number_left=false\n+align_func_params=false\n+align_same_func_call_params=false\n+align_var_def_colon=true\n+align_var_def_attribute=false\n+align_var_def_inline=false\n+align_right_cmt_mix=false\n+align_on_operator=false\n+align_mix_var_proto=false\n+align_single_line_func=false\n+align_single_line_brace=false\n+align_nl_cont=false\n+align_left_shift=false\n+align_oc_decl_colon=false\n+nl_collapse_empty_body=false\n+nl_assign_leave_one_liners=false\n+nl_class_leave_one_liners=false\n+nl_enum_leave_one_liners=false\n+nl_getset_leave_one_liners=false\n+nl_func_leave_one_liners=false\n+nl_if_leave_one_liners=false\n+nl_multi_line_cond=false\n+nl_multi_line_define=false\n+nl_before_case=false\n+nl_after_case=true\n+nl_after_return=true\n+nl_after_semicolon=true\n+nl_after_brace_open=true\n+nl_after_brace_open_cmt=true\n+nl_after_vbrace_open=true\n+nl_after_vbrace_open_empty=false\n+nl_after_brace_close=false\n+nl_after_vbrace_close=false\n+nl_define_macro=false\n+nl_squeeze_ifdef=false\n+nl_ds_struct_enum_cmt=false\n+nl_ds_struct_enum_close_brace=false\n+nl_create_if_one_liner=false\n+nl_create_for_one_liner=false\n+nl_create_while_one_liner=false\n+ls_for_split_full=false\n+ls_func_split_full=false\n+nl_after_multiline_comment=true\n+eat_blanks_after_open_brace=true\n+eat_blanks_before_close_brace=true\n+mod_full_brace_if_chain=false\n+mod_pawn_semicolon=false\n+mod_full_paren_if_bool=false\n+mod_remove_extra_semicolon=false\n+mod_sort_import=false\n+mod_sort_using=false\n+mod_sort_include=false\n+mod_move_case_break=false\n+mod_remove_empty_return=false\n+cmt_indent_multi=true\n+cmt_c_group=false\n+cmt_c_nl_start=false\n+cmt_c_nl_end=false\n+cmt_cpp_group=false\n+cmt_cpp_nl_start=false\n+cmt_cpp_nl_end=false\n+cmt_cpp_to_c=false\n+cmt_star_cont=false\n+cmt_multi_check_last=true\n+cmt_insert_before_preproc=false\n+pp_indent_at_level=false\n+pp_region_indent_code=false\n+pp_if_indent_code=false\n+pp_define_at_level=false\n+input_tab_size=4\n+output_tab_size=4\n+indent_columns=4\n+indent_continue=4\n+sp_num_before_tr_emb_cmt=1\n+align_oc_msg_colon_span=16\n+nl_end_of_file_min=2\n+nl_func_var_def_blk=1\n+code_width=120\n+nl_max=2\n+nl_after_func_body=2\n+nl_after_func_body_class=2\n+nl_after_func_body_one_liner=3\n+nl_after_struct=1\n+nl_after_class=1\n+indent_with_tabs=0\n+sp_arith=force\n+sp_assign=force\n+sp_assign_default=add\n+sp_before_assign=add\n+sp_after_assign=add\n+sp_enum_assign=add\n+sp_enum_before_assign=add\n+sp_enum_after_assign=add\n+sp_pp_concat=add\n+sp_pp_stringify=add\n+sp_bool=add\n+sp_compare=add\n+sp_inside_paren=remove\n+sp_paren_paren=remove\n+sp_paren_brace=add\n+sp_before_ptr_star=remove\n+sp_before_unnamed_ptr_star=remove\n+sp_between_ptr_star=add\n+sp_after_ptr_star=add\n+sp_after_type=remove\n+sp_before_sparen=force\n+sp_inside_sparen=remove\n+sp_after_sparen=add\n+sp_sparen_brace=add\n+sp_after_comma=force\n+sp_before_comma=remove\n+sp_else_brace=force\n+sp_after_oc_scope=force\n+sp_after_oc_colon=remove\n+sp_before_oc_colon=remove\n+sp_after_send_oc_colon=remove\n+sp_before_send_oc_colon=remove\n+sp_after_oc_type=remove\n+sp_before_tr_emb_cmt=add\n+nl_start_of_file=force\n+nl_end_of_file=add\n+nl_fcall_brace=add\n+nl_enum_brace=add\n+nl_struct_brace=add\n+nl_union_brace=add\n+nl_if_brace=add\n+nl_brace_else=add\n+nl_elseif_brace=add\n+nl_else_brace=add\n+nl_else_if=remove\n+nl_brace_finally=add\n+nl_finally_brace=add\n+nl_try_brace=add\n+nl_for_brace=add\n+nl_catch_brace=add\n+nl_brace_catch=add\n+nl_while_brace=add\n+nl_using_brace=add\n+nl_brace_brace=add\n+nl_do_brace=add\n+nl_brace_while=add\n+nl_switch_brace=add\n+nl_case_colon_brace=add\n+nl_namespace_brace=add\n+nl_template_class=add\n+nl_class_brace=add\n+nl_class_init_args=ignore\n+nl_func_type_name=remove\n+nl_func_type_name_class=remove\n+nl_func_scope_name=remove\n+nl_func_proto_type_name=remove\n+nl_func_paren=remove\n+nl_func_def_paren=remove\n+nl_func_decl_start=remove\n+nl_func_def_start=remove\n+nl_func_decl_start_single=remove\n+nl_func_decl_args=remove\n+nl_func_decl_end=remove\n+nl_fdef_brace=add\n+nl_return_expr=remove\n+nl_before_if=add\n+nl_after_if=add\n+nl_before_for=add\n+nl_after_for=add\n+nl_before_while=add\n+nl_after_while=add\n+nl_before_switch=add\n+nl_after_switch=add\n+nl_before_do=add\n+nl_after_do=add\n+mod_full_brace_for=add\n+mod_full_brace_if=add"
      },
      {
        "sha": "b2986a0a1ceaf4d118038cb25d4adf9968fdd48a",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 261,
        "deletions": 52,
        "changes": 313,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -12,6 +12,7 @@ using namespace std;\n int CAddrInfo::GetTriedBucket(const std::vector<unsigned char> &nKey) const\n {\n     CDataStream ss1(SER_GETHASH, 0);\n+\n     std::vector<unsigned char> vchKey = GetKey();\n     ss1 << nKey << vchKey;\n     uint64_t hash1 = Hash(ss1.begin(), ss1.end()).GetLow64();\n@@ -26,6 +27,7 @@ int CAddrInfo::GetTriedBucket(const std::vector<unsigned char> &nKey) const\n int CAddrInfo::GetNewBucket(const std::vector<unsigned char> &nKey, const CNetAddr& src) const\n {\n     CDataStream ss1(SER_GETHASH, 0);\n+\n     std::vector<unsigned char> vchGroupKey = GetGroup();\n     std::vector<unsigned char> vchSourceGroupKey = src.GetGroup();\n     ss1 << nKey << vchGroupKey << vchSourceGroupKey;\n@@ -39,20 +41,30 @@ int CAddrInfo::GetNewBucket(const std::vector<unsigned char> &nKey, const CNetAd\n \n bool CAddrInfo::IsTerrible(int64_t nNow) const\n {\n-    if (nLastTry && nLastTry >= nNow-60) // never remove things tried the last minute\n+    if (nLastTry && nLastTry >= nNow - 60) // never remove things tried the last minute\n+    {\n         return false;\n+    }\n \n-    if (nTime > nNow + 10*60) // came in a flying DeLorean\n+    if (nTime > nNow + 10 * 60) // came in a flying DeLorean\n+    {\n         return true;\n+    }\n \n-    if (nTime==0 || nNow-nTime > ADDRMAN_HORIZON_DAYS*24*60*60) // not seen in recent history\n+    if (nTime == 0 || nNow - nTime > ADDRMAN_HORIZON_DAYS * 24 * 60 * 60) // not seen in recent history\n+    {\n         return true;\n+    }\n \n-    if (nLastSuccess==0 && nAttempts>=ADDRMAN_RETRIES) // tried N times and never a success\n+    if (nLastSuccess == 0 && nAttempts >= ADDRMAN_RETRIES) // tried N times and never a success\n+    {\n         return true;\n+    }\n \n-    if (nNow-nLastSuccess > ADDRMAN_MIN_FAIL_DAYS*24*60*60 && nAttempts>=ADDRMAN_MAX_FAILURES) // N successive failures in the last week\n+    if (nNow - nLastSuccess > ADDRMAN_MIN_FAIL_DAYS * 24 * 60 * 60 && nAttempts >= ADDRMAN_MAX_FAILURES) // N successive failures in the last week\n+    {\n         return true;\n+    }\n \n     return false;\n }\n@@ -64,51 +76,80 @@ double CAddrInfo::GetChance(int64_t nNow) const\n     int64_t nSinceLastSeen = nNow - nTime;\n     int64_t nSinceLastTry = nNow - nLastTry;\n \n-    if (nSinceLastSeen < 0) nSinceLastSeen = 0;\n-    if (nSinceLastTry < 0) nSinceLastTry = 0;\n+    if (nSinceLastSeen < 0)\n+    {\n+        nSinceLastSeen = 0;\n+    }\n+\n+    if (nSinceLastTry < 0)\n+    {\n+        nSinceLastTry = 0;\n+    }\n \n     fChance *= 600.0 / (600.0 + nSinceLastSeen);\n \n     // deprioritize very recent attempts away\n-    if (nSinceLastTry < 60*10)\n+    if (nSinceLastTry < 60 * 10)\n+    {\n         fChance *= 0.01;\n+    }\n \n     // deprioritize 50% after each failed attempt\n-    for (int n=0; n<nAttempts; n++)\n+    for (int n = 0; n < nAttempts; n++)\n+    {\n         fChance /= 1.5;\n+    }\n \n     return fChance;\n }\n \n-CAddrInfo* CAddrMan::Find(const CNetAddr& addr, int *pnId)\n+CAddrInfo* CAddrMan::Find(const CNetAddr& addr, int* pnId)\n {\n     std::map<CNetAddr, int>::iterator it = mapAddr.find(addr);\n+\n     if (it == mapAddr.end())\n+    {\n         return NULL;\n+    }\n+\n     if (pnId)\n+    {\n         *pnId = (*it).second;\n+    }\n+\n     std::map<int, CAddrInfo>::iterator it2 = mapInfo.find((*it).second);\n+\n     if (it2 != mapInfo.end())\n+    {\n         return &(*it2).second;\n+    }\n+\n     return NULL;\n }\n \n-CAddrInfo* CAddrMan::Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId)\n+CAddrInfo* CAddrMan::Create(const CAddress &addr, const CNetAddr &addrSource, int* pnId)\n {\n     int nId = nIdCount++;\n+\n     mapInfo[nId] = CAddrInfo(addr, addrSource);\n     mapAddr[addr] = nId;\n     mapInfo[nId].nRandomPos = vRandom.size();\n     vRandom.push_back(nId);\n+\n     if (pnId)\n+    {\n         *pnId = nId;\n+    }\n+\n     return &mapInfo[nId];\n }\n \n void CAddrMan::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2)\n {\n     if (nRndPos1 == nRndPos2)\n+    {\n         return;\n+    }\n \n     assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());\n \n@@ -133,16 +174,19 @@ int CAddrMan::SelectTried(int nKBucket)\n     // find the least recently tried among them\n     int64_t nOldest = -1;\n     int nOldestPos = -1;\n+\n     for (unsigned int i = 0; i < ADDRMAN_TRIED_ENTRIES_INSPECT_ON_EVICT && i < vTried.size(); i++)\n     {\n         int nPos = GetRandInt(vTried.size() - i) + i;\n         int nTemp = vTried[nPos];\n         vTried[nPos] = vTried[i];\n         vTried[i] = nTemp;\n         assert(nOldest == -1 || mapInfo.count(nTemp) == 1);\n-        if (nOldest == -1 || mapInfo[nTemp].nLastSuccess < mapInfo[nOldest].nLastSuccess) {\n-           nOldest = nTemp;\n-           nOldestPos = nPos;\n+\n+        if (nOldest == -1 || mapInfo[nTemp].nLastSuccess < mapInfo[nOldest].nLastSuccess)\n+        {\n+            nOldest = nTemp;\n+            nOldestPos = nPos;\n         }\n     }\n \n@@ -159,45 +203,57 @@ int CAddrMan::ShrinkNew(int nUBucket)\n     {\n         assert(mapInfo.count(*it));\n         CAddrInfo &info = mapInfo[*it];\n+\n         if (info.IsTerrible())\n         {\n             if (--info.nRefCount == 0)\n             {\n-                SwapRandom(info.nRandomPos, vRandom.size()-1);\n+                SwapRandom(info.nRandomPos, vRandom.size() - 1);\n                 vRandom.pop_back();\n                 mapAddr.erase(info);\n                 mapInfo.erase(*it);\n                 nNew--;\n             }\n+\n             vNew.erase(it);\n             return 0;\n         }\n     }\n \n     // otherwise, select four randomly, and pick the oldest of those to replace\n-    int n[4] = {GetRandInt(vNew.size()), GetRandInt(vNew.size()), GetRandInt(vNew.size()), GetRandInt(vNew.size())};\n+    int n[4] = {\n+        GetRandInt(vNew.size()), GetRandInt(vNew.size()), GetRandInt(vNew.size()), GetRandInt(vNew.size())\n+    };\n     int nI = 0;\n     int nOldest = -1;\n+\n     for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n     {\n         if (nI == n[0] || nI == n[1] || nI == n[2] || nI == n[3])\n         {\n             assert(nOldest == -1 || mapInfo.count(*it) == 1);\n+\n             if (nOldest == -1 || mapInfo[*it].nTime < mapInfo[nOldest].nTime)\n+            {\n                 nOldest = *it;\n+            }\n         }\n+\n         nI++;\n     }\n+\n     assert(mapInfo.count(nOldest) == 1);\n     CAddrInfo &info = mapInfo[nOldest];\n+\n     if (--info.nRefCount == 0)\n     {\n-        SwapRandom(info.nRandomPos, vRandom.size()-1);\n+        SwapRandom(info.nRandomPos, vRandom.size() - 1);\n         vRandom.pop_back();\n         mapAddr.erase(info);\n         mapInfo.erase(nOldest);\n         nNew--;\n     }\n+\n     vNew.erase(nOldest);\n \n     return 1;\n@@ -211,8 +267,11 @@ void CAddrMan::MakeTried(CAddrInfo& info, int nId, int nOrigin)\n     for (std::vector<std::set<int> >::iterator it = vvNew.begin(); it != vvNew.end(); it++)\n     {\n         if ((*it).erase(nId))\n+        {\n             info.nRefCount--;\n+        }\n     }\n+\n     nNew--;\n \n     assert(info.nRefCount == 0);\n@@ -249,10 +308,13 @@ void CAddrMan::MakeTried(CAddrInfo& info, int nId, int nOrigin)\n     {\n         // if so, move it back there\n         vNew.insert(vTried[nPos]);\n-    } else {\n+    }\n+    else\n+    {\n         // otherwise, move it to the new bucket nId came from (there is certainly place there)\n         vvNew[nOrigin].insert(vTried[nPos]);\n     }\n+\n     nNew++;\n \n     vTried[nPos] = nId;\n@@ -264,17 +326,21 @@ void CAddrMan::MakeTried(CAddrInfo& info, int nId, int nOrigin)\n void CAddrMan::Good_(const CService &addr, int64_t nTime)\n {\n     int nId;\n-    CAddrInfo *pinfo = Find(addr, &nId);\n+    CAddrInfo* pinfo = Find(addr, &nId);\n \n     // if not found, bail out\n     if (!pinfo)\n+    {\n         return;\n+    }\n \n     CAddrInfo &info = *pinfo;\n \n     // check whether we are talking about the exact same CService (including same port)\n     if (info != addr)\n+    {\n         return;\n+    }\n \n     // update info\n     info.nLastSuccess = nTime;\n@@ -284,15 +350,19 @@ void CAddrMan::Good_(const CService &addr, int64_t nTime)\n \n     // if it is already in the tried set, don't do anything else\n     if (info.fInTried)\n+    {\n         return;\n+    }\n \n     // find a bucket it is in now\n     int nRnd = GetRandInt(vvNew.size());\n     int nUBucket = -1;\n+\n     for (unsigned int n = 0; n < vvNew.size(); n++)\n     {\n-        int nB = (n+nRnd) % vvNew.size();\n+        int nB = (n + nRnd) % vvNew.size();\n         std::set<int> &vNew = vvNew[nB];\n+\n         if (vNew.count(nId))\n         {\n             nUBucket = nB;\n@@ -302,7 +372,10 @@ void CAddrMan::Good_(const CService &addr, int64_t nTime)\n \n     // if no bucket is found, something bad happened;\n     // TODO: maybe re-add the node, but for now, just bail out\n-    if (nUBucket == -1) return;\n+    if (nUBucket == -1)\n+    {\n+        return;\n+    }\n \n     LogPrint(\"addrman\", \"Moving %s to tried\\n\", addr.ToString());\n \n@@ -313,42 +386,61 @@ void CAddrMan::Good_(const CService &addr, int64_t nTime)\n bool CAddrMan::Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty)\n {\n     if (!addr.IsRoutable())\n+    {\n         return false;\n+    }\n \n     bool fNew = false;\n     int nId;\n-    CAddrInfo *pinfo = Find(addr, &nId);\n+    CAddrInfo* pinfo = Find(addr, &nId);\n \n     if (pinfo)\n     {\n         // periodically update nTime\n         bool fCurrentlyOnline = (GetAdjustedTime() - addr.nTime < 24 * 60 * 60);\n         int64_t nUpdateInterval = (fCurrentlyOnline ? 60 * 60 : 24 * 60 * 60);\n+\n         if (addr.nTime && (!pinfo->nTime || pinfo->nTime < addr.nTime - nUpdateInterval - nTimePenalty))\n+        {\n             pinfo->nTime = max((int64_t)0, addr.nTime - nTimePenalty);\n+        }\n \n         // add services\n         pinfo->nServices |= addr.nServices;\n \n         // do not update if no new information is present\n         if (!addr.nTime || (pinfo->nTime && addr.nTime <= pinfo->nTime))\n+        {\n             return false;\n+        }\n \n         // do not update if the entry was already in the \"tried\" table\n         if (pinfo->fInTried)\n+        {\n             return false;\n+        }\n \n         // do not update if the max reference count is reached\n         if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)\n+        {\n             return false;\n+        }\n \n         // stochastic test: previous nRefCount == N: 2^N times harder to increase it\n         int nFactor = 1;\n-        for (int n=0; n<pinfo->nRefCount; n++)\n+\n+        for (int n = 0; n < pinfo->nRefCount; n++)\n+        {\n             nFactor *= 2;\n+        }\n+\n         if (nFactor > 1 && (GetRandInt(nFactor) != 0))\n+        {\n             return false;\n-    } else {\n+        }\n+    }\n+    else\n+    {\n         pinfo = Create(addr, source, &nId);\n         pinfo->nTime = max((int64_t)0, (int64_t)pinfo->nTime - nTimePenalty);\n         nNew++;\n@@ -357,29 +449,39 @@ bool CAddrMan::Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimeP\n \n     int nUBucket = pinfo->GetNewBucket(nKey, source);\n     std::set<int> &vNew = vvNew[nUBucket];\n+\n     if (!vNew.count(nId))\n     {\n         pinfo->nRefCount++;\n+\n         if (vNew.size() == ADDRMAN_NEW_BUCKET_SIZE)\n+        {\n             ShrinkNew(nUBucket);\n+        }\n+\n         vvNew[nUBucket].insert(nId);\n     }\n+\n     return fNew;\n }\n \n void CAddrMan::Attempt_(const CService &addr, int64_t nTime)\n {\n-    CAddrInfo *pinfo = Find(addr);\n+    CAddrInfo* pinfo = Find(addr);\n \n     // if not found, bail out\n     if (!pinfo)\n+    {\n         return;\n+    }\n \n     CAddrInfo &info = *pinfo;\n \n     // check whether we are talking about the exact same CService (including same port)\n     if (info != addr)\n+    {\n         return;\n+    }\n \n     // update info\n     info.nLastTry = nTime;\n@@ -389,42 +491,69 @@ void CAddrMan::Attempt_(const CService &addr, int64_t nTime)\n CAddress CAddrMan::Select_(int nUnkBias)\n {\n     if (size() == 0)\n+    {\n         return CAddress();\n+    }\n \n     double nCorTried = sqrt(nTried) * (100.0 - nUnkBias);\n     double nCorNew = sqrt(nNew) * nUnkBias;\n-    if ((nCorTried + nCorNew)*GetRandInt(1<<30)/(1<<30) < nCorTried)\n+\n+    if ((nCorTried + nCorNew) * GetRandInt(1 << 30) / (1 << 30) < nCorTried)\n     {\n         // use a tried node\n         double fChanceFactor = 1.0;\n-        while(1)\n+\n+        while (1)\n         {\n             int nKBucket = GetRandInt(vvTried.size());\n             std::vector<int> &vTried = vvTried[nKBucket];\n-            if (vTried.size() == 0) continue;\n+\n+            if (vTried.size() == 0)\n+            {\n+                continue;\n+            }\n+\n             int nPos = GetRandInt(vTried.size());\n             assert(mapInfo.count(vTried[nPos]) == 1);\n             CAddrInfo &info = mapInfo[vTried[nPos]];\n-            if (GetRandInt(1<<30) < fChanceFactor*info.GetChance()*(1<<30))\n+\n+            if (GetRandInt(1 << 30) < fChanceFactor * info.GetChance() * (1 << 30))\n+            {\n                 return info;\n+            }\n+\n             fChanceFactor *= 1.2;\n         }\n-    } else {\n+    }\n+    else\n+    {\n         // use a new node\n         double fChanceFactor = 1.0;\n-        while(1)\n+\n+        while (1)\n         {\n             int nUBucket = GetRandInt(vvNew.size());\n             std::set<int> &vNew = vvNew[nUBucket];\n-            if (vNew.size() == 0) continue;\n+\n+            if (vNew.size() == 0)\n+            {\n+                continue;\n+            }\n+\n             int nPos = GetRandInt(vNew.size());\n             std::set<int>::iterator it = vNew.begin();\n+\n             while (nPos--)\n                 it++;\n+\n             assert(mapInfo.count(*it) == 1);\n             CAddrInfo &info = mapInfo[*it];\n-            if (GetRandInt(1<<30) < fChanceFactor*info.GetChance()*(1<<30))\n+\n+            if (GetRandInt(1 << 30) < fChanceFactor * info.GetChance() * (1 << 30))\n+            {\n                 return info;\n+            }\n+\n             fChanceFactor *= 1.2;\n         }\n     }\n@@ -436,98 +565,178 @@ int CAddrMan::Check_()\n     std::set<int> setTried;\n     std::map<int, int> mapNew;\n \n-    if (vRandom.size() != nTried + nNew) return -7;\n+    if (vRandom.size() != nTried + nNew)\n+    {\n+        return -7;\n+    }\n \n     for (std::map<int, CAddrInfo>::iterator it = mapInfo.begin(); it != mapInfo.end(); it++)\n     {\n         int n = (*it).first;\n         CAddrInfo &info = (*it).second;\n+\n         if (info.fInTried)\n         {\n+            if (!info.nLastSuccess)\n+            {\n+                return -1;\n+            }\n+\n+            if (info.nRefCount)\n+            {\n+                return -2;\n+            }\n \n-            if (!info.nLastSuccess) return -1;\n-            if (info.nRefCount) return -2;\n             setTried.insert(n);\n-        } else {\n-            if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS) return -3;\n-            if (!info.nRefCount) return -4;\n+        }\n+        else\n+        {\n+            if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)\n+            {\n+                return -3;\n+            }\n+\n+            if (!info.nRefCount)\n+            {\n+                return -4;\n+            }\n+\n             mapNew[n] = info.nRefCount;\n         }\n-        if (mapAddr[info] != n) return -5;\n-        if (info.nRandomPos<0 || info.nRandomPos>=vRandom.size() || vRandom[info.nRandomPos] != n) return -14;\n-        if (info.nLastTry < 0) return -6;\n-        if (info.nLastSuccess < 0) return -8;\n+\n+        if (mapAddr[info] != n)\n+        {\n+            return -5;\n+        }\n+\n+        if (info.nRandomPos < 0 || info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)\n+        {\n+            return -14;\n+        }\n+\n+        if (info.nLastTry < 0)\n+        {\n+            return -6;\n+        }\n+\n+        if (info.nLastSuccess < 0)\n+        {\n+            return -8;\n+        }\n+    }\n+\n+    if (setTried.size() != nTried)\n+    {\n+        return -9;\n     }\n \n-    if (setTried.size() != nTried) return -9;\n-    if (mapNew.size() != nNew) return -10;\n+    if (mapNew.size() != nNew)\n+    {\n+        return -10;\n+    }\n \n-    for (int n=0; n<vvTried.size(); n++)\n+    for (int n = 0; n < vvTried.size(); n++)\n     {\n         std::vector<int> &vTried = vvTried[n];\n+\n         for (std::vector<int>::iterator it = vTried.begin(); it != vTried.end(); it++)\n         {\n-            if (!setTried.count(*it)) return -11;\n+            if (!setTried.count(*it))\n+            {\n+                return -11;\n+            }\n+\n             setTried.erase(*it);\n         }\n     }\n \n-    for (int n=0; n<vvNew.size(); n++)\n+    for (int n = 0; n < vvNew.size(); n++)\n     {\n         std::set<int> &vNew = vvNew[n];\n+\n         for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n         {\n-            if (!mapNew.count(*it)) return -12;\n+            if (!mapNew.count(*it))\n+            {\n+                return -12;\n+            }\n+\n             if (--mapNew[*it] == 0)\n+            {\n                 mapNew.erase(*it);\n+            }\n         }\n     }\n \n-    if (setTried.size()) return -13;\n-    if (mapNew.size()) return -15;\n+    if (setTried.size())\n+    {\n+        return -13;\n+    }\n+\n+    if (mapNew.size())\n+    {\n+        return -15;\n+    }\n \n     return 0;\n }\n+\n #endif\n \n void CAddrMan::GetAddr_(std::vector<CAddress> &vAddr)\n {\n     unsigned int nNodes = ADDRMAN_GETADDR_MAX_PCT * vRandom.size() / 100;\n+\n     if (nNodes > ADDRMAN_GETADDR_MAX)\n+    {\n         nNodes = ADDRMAN_GETADDR_MAX;\n+    }\n \n     // gather a list of random nodes, skipping those of low quality\n     for (unsigned int n = 0; n < vRandom.size(); n++)\n     {\n         if (vAddr.size() >= nNodes)\n+        {\n             break;\n+        }\n \n         int nRndPos = GetRandInt(vRandom.size() - n) + n;\n         SwapRandom(n, nRndPos);\n         assert(mapInfo.count(vRandom[n]) == 1);\n \n         const CAddrInfo& ai = mapInfo[vRandom[n]];\n+\n         if (!ai.IsTerrible())\n+        {\n             vAddr.push_back(ai);\n+        }\n     }\n }\n \n void CAddrMan::Connected_(const CService &addr, int64_t nTime)\n {\n-    CAddrInfo *pinfo = Find(addr);\n+    CAddrInfo* pinfo = Find(addr);\n \n     // if not found, bail out\n     if (!pinfo)\n+    {\n         return;\n+    }\n \n     CAddrInfo &info = *pinfo;\n \n     // check whether we are talking about the exact same CService (including same port)\n     if (info != addr)\n+    {\n         return;\n+    }\n \n     // update info\n     int64_t nUpdateInterval = 20 * 60;\n+\n     if (nTime - info.nTime > nUpdateInterval)\n+    {\n         info.nTime = nTime;\n+    }\n }\n+"
      },
      {
        "sha": "8c1f88b68dac9ef6cd390d68f362f65ee2bf7949",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 88,
        "deletions": 28,
        "changes": 116,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -49,7 +49,8 @@ class CAddrInfo : public CAddress\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n         READWRITE(*(CAddress*)this);\n         READWRITE(source);\n         READWRITE(nLastSuccess);\n@@ -93,7 +94,6 @@ class CAddrInfo : public CAddress\n \n     // Calculate the relative chance this entry should be given when selecting nodes to connect to\n     double GetChance(int64_t nNow = GetAdjustedTime()) const;\n-\n };\n \n // Stochastic address manager\n@@ -201,11 +201,11 @@ class CAddrMan\n protected:\n \n     // Find an entry.\n-    CAddrInfo* Find(const CNetAddr& addr, int *pnId = NULL);\n+    CAddrInfo* Find(const CNetAddr& addr, int* pnId = NULL);\n \n     // find an entry, creating it if necessary.\n     // nTime and nServices of found node is updated, if necessary.\n-    CAddrInfo* Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId = NULL);\n+    CAddrInfo* Create(const CAddress &addr, const CNetAddr &addrSource, int* pnId = NULL);\n \n     // Swap two elements in vRandom.\n     void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2);\n@@ -285,29 +285,50 @@ class CAddrMan\n         s << nUBuckets;\n         std::map<int, int> mapUnkIds;\n         int nIds = 0;\n-        for (std::map<int, CAddrInfo>::const_iterator it = mapInfo.begin(); it != mapInfo.end(); it++) {\n-            if (nIds == nNew) break; // this means nNew was wrong, oh ow\n+\n+        for (std::map<int, CAddrInfo>::const_iterator it = mapInfo.begin(); it != mapInfo.end(); it++)\n+        {\n+            if (nIds == nNew)\n+            {\n+                break;               // this means nNew was wrong, oh ow\n+            }\n+\n             mapUnkIds[(*it).first] = nIds;\n             const CAddrInfo &info = (*it).second;\n-            if (info.nRefCount) {\n+\n+            if (info.nRefCount)\n+            {\n                 s << info;\n                 nIds++;\n             }\n         }\n+\n         nIds = 0;\n-        for (std::map<int, CAddrInfo>::const_iterator it = mapInfo.begin(); it != mapInfo.end(); it++) {\n-            if (nIds == nTried) break; // this means nTried was wrong, oh ow\n+\n+        for (std::map<int, CAddrInfo>::const_iterator it = mapInfo.begin(); it != mapInfo.end(); it++)\n+        {\n+            if (nIds == nTried)\n+            {\n+                break;                 // this means nTried was wrong, oh ow\n+            }\n+\n             const CAddrInfo &info = (*it).second;\n-            if (info.fInTried) {\n+\n+            if (info.fInTried)\n+            {\n                 s << info;\n                 nIds++;\n             }\n         }\n-        for (std::vector<std::set<int> >::const_iterator it = vvNew.begin(); it != vvNew.end(); it++) {\n+\n+        for (std::vector<std::set<int> >::const_iterator it = vvNew.begin(); it != vvNew.end(); it++)\n+        {\n             const std::set<int> &vNew = (*it);\n             int nSize = vNew.size();\n             s << nSize;\n-            for (std::set<int>::const_iterator it2 = vNew.begin(); it2 != vNew.end(); it2++) {\n+\n+            for (std::set<int>::const_iterator it2 = vNew.begin(); it2 != vNew.end(); it2++)\n+            {\n                 int nIndex = mapUnkIds[*it2];\n                 s << nIndex;\n             }\n@@ -333,45 +354,63 @@ class CAddrMan\n         vRandom.clear();\n         vvTried = std::vector<std::vector<int> >(ADDRMAN_TRIED_BUCKET_COUNT, std::vector<int>(0));\n         vvNew = std::vector<std::set<int> >(ADDRMAN_NEW_BUCKET_COUNT, std::set<int>());\n-        for (int n = 0; n < nNew; n++) {\n+\n+        for (int n = 0; n < nNew; n++)\n+        {\n             CAddrInfo &info = mapInfo[n];\n             s >> info;\n             mapAddr[info] = n;\n             info.nRandomPos = vRandom.size();\n             vRandom.push_back(n);\n-            if (nUBuckets != ADDRMAN_NEW_BUCKET_COUNT) {\n+\n+            if (nUBuckets != ADDRMAN_NEW_BUCKET_COUNT)\n+            {\n                 vvNew[info.GetNewBucket(nKey)].insert(n);\n                 info.nRefCount++;\n             }\n         }\n+\n         nIdCount = nNew;\n         int nLost = 0;\n-        for (int n = 0; n < nTried; n++) {\n+\n+        for (int n = 0; n < nTried; n++)\n+        {\n             CAddrInfo info;\n             s >> info;\n             std::vector<int> &vTried = vvTried[info.GetTriedBucket(nKey)];\n-            if (vTried.size() < ADDRMAN_TRIED_BUCKET_SIZE) {\n+\n+            if (vTried.size() < ADDRMAN_TRIED_BUCKET_SIZE)\n+            {\n                 info.nRandomPos = vRandom.size();\n                 info.fInTried = true;\n                 vRandom.push_back(nIdCount);\n                 mapInfo[nIdCount] = info;\n                 mapAddr[info] = nIdCount;\n                 vTried.push_back(nIdCount);\n                 nIdCount++;\n-            } else {\n+            }\n+            else\n+            {\n                 nLost++;\n             }\n         }\n+\n         nTried -= nLost;\n-        for (int b = 0; b < nUBuckets; b++) {\n+\n+        for (int b = 0; b < nUBuckets; b++)\n+        {\n             std::set<int> &vNew = vvNew[b];\n             int nSize = 0;\n             s >> nSize;\n-            for (int n = 0; n < nSize; n++) {\n+\n+            for (int n = 0; n < nSize; n++)\n+            {\n                 int nIndex = 0;\n                 s >> nIndex;\n                 CAddrInfo &info = mapInfo[nIndex];\n-                if (nUBuckets == ADDRMAN_NEW_BUCKET_COUNT && info.nRefCount < ADDRMAN_NEW_BUCKETS_PER_ADDRESS) {\n+\n+                if (nUBuckets == ADDRMAN_NEW_BUCKET_COUNT && info.nRefCount < ADDRMAN_NEW_BUCKETS_PER_ADDRESS)\n+                {\n                     info.nRefCount++;\n                     vNew.insert(nIndex);\n                 }\n@@ -384,14 +423,15 @@ class CAddrMan\n         return (CSizeComputer(nType, nVersion) << *this).size();\n     }\n \n-    CAddrMan() : vRandom(0), vvTried(ADDRMAN_TRIED_BUCKET_COUNT, std::vector<int>(0)), vvNew(ADDRMAN_NEW_BUCKET_COUNT, std::set<int>())\n+    CAddrMan() : vRandom(0),\n+        vvTried(ADDRMAN_TRIED_BUCKET_COUNT, std::vector<int>(0)), vvNew(ADDRMAN_NEW_BUCKET_COUNT, std::set<int>())\n     {\n-         nKey.resize(32);\n-         GetRandBytes(&nKey[0], 32);\n+        nKey.resize(32);\n+        GetRandBytes(&nKey[0], 32);\n \n-         nIdCount = 0;\n-         nTried = 0;\n-         nNew = 0;\n+        nIdCount = 0;\n+        nTried = 0;\n+        nNew = 0;\n     }\n \n     // Return the number of (unique) addresses in all tables.\n@@ -407,8 +447,11 @@ class CAddrMan\n         {\n             LOCK(cs);\n             int err;\n-            if ((err=Check_()))\n+\n+            if ((err = Check_()))\n+            {\n                 LogPrintf(\"ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\\n\", err);\n+            }\n         }\n #endif\n     }\n@@ -417,30 +460,45 @@ class CAddrMan\n     bool Add(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty = 0)\n     {\n         bool fRet = false;\n+\n         {\n             LOCK(cs);\n             Check();\n             fRet |= Add_(addr, source, nTimePenalty);\n             Check();\n         }\n+\n         if (fRet)\n-            LogPrint(\"addrman\", \"Added %s from %s: %i tried, %i new\\n\", addr.ToStringIPPort(), source.ToString(), nTried, nNew);\n+        {\n+            LogPrint(\"addrman\", \"Added %s from %s: %i tried, %i new\\n\", addr.ToStringIPPort(),\n+                source.ToString(), nTried, nNew);\n+        }\n+\n         return fRet;\n     }\n \n     // Add multiple addresses.\n     bool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty = 0)\n     {\n         int nAdd = 0;\n+\n         {\n             LOCK(cs);\n             Check();\n+\n             for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++)\n+            {\n                 nAdd += Add_(*it, source, nTimePenalty) ? 1 : 0;\n+            }\n+\n             Check();\n         }\n+\n         if (nAdd)\n+        {\n             LogPrint(\"addrman\", \"Added %i addresses from %s: %i tried, %i new\\n\", nAdd, source.ToString(), nTried, nNew);\n+        }\n+\n         return nAdd > 0;\n     }\n \n@@ -471,6 +529,7 @@ class CAddrMan\n     CAddress Select(int nUnkBias = 50)\n     {\n         CAddress addrRet;\n+\n         {\n             LOCK(cs);\n             Check();\n@@ -506,3 +565,4 @@ class CAddrMan\n };\n \n #endif // _BITCOIN_ADDRMAN\n+"
      },
      {
        "sha": "0d7ecfa11739c40128fb31d3f74f3403a02987c9",
        "filename": "src/alert.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 10,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/alert.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/alert.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/alert.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -47,11 +47,19 @@ void CUnsignedAlert::SetNull()\n std::string CUnsignedAlert::ToString() const\n {\n     std::string strSetCancel;\n-    BOOST_FOREACH(int n, setCancel)\n+\n+    BOOST_FOREACH (int n, setCancel)\n+    {\n         strSetCancel += strprintf(\"%d \", n);\n+    }\n+\n     std::string strSetSubVer;\n-    BOOST_FOREACH(std::string str, setSubVer)\n+\n+    BOOST_FOREACH (std::string str, setSubVer)\n+    {\n         strSetSubVer += \"\\\"\" + str + \"\\\" \";\n+    }\n+\n     return strprintf(\n         \"CAlert(\\n\"\n         \"    nVersion     = %d\\n\"\n@@ -106,16 +114,19 @@ bool CAlert::IsInEffect() const\n bool CAlert::Cancels(const CAlert& alert) const\n {\n     if (!IsInEffect())\n+    {\n         return false; // this was a no-op before 31403\n+    }\n+\n     return (alert.nID <= nCancel || setCancel.count(alert.nID));\n }\n \n bool CAlert::AppliesTo(int nVersion, std::string strSubVerIn) const\n {\n     // TODO: rework for client-version-embedded-in-strSubVer ?\n     return (IsInEffect() &&\n-            nMinVer <= nVersion && nVersion <= nMaxVer &&\n-            (setSubVer.empty() || setSubVer.count(strSubVerIn)));\n+        nMinVer <= nVersion && nVersion <= nMaxVer &&\n+        (setSubVer.empty() || setSubVer.count(strSubVerIn)));\n }\n \n bool CAlert::AppliesToMe() const\n@@ -126,7 +137,10 @@ bool CAlert::AppliesToMe() const\n bool CAlert::RelayTo(CNode* pnode) const\n {\n     if (!IsInEffect())\n+    {\n         return false;\n+    }\n+\n     // returns true if wasn't already contained in the set\n     if (pnode->setKnown.insert(GetHash()).second)\n     {\n@@ -138,14 +152,18 @@ bool CAlert::RelayTo(CNode* pnode) const\n             return true;\n         }\n     }\n+\n     return false;\n }\n \n bool CAlert::CheckSignature() const\n {\n     CPubKey key(Params().AlertKey());\n+\n     if (!key.Verify(Hash(vchMsg.begin(), vchMsg.end()), vchSig))\n+    {\n         return error(\"CAlert::CheckSignature() : verify signature failed\");\n+    }\n \n     // Now unserialize the data\n     CDataStream sMsg(vchMsg, SER_NETWORK, PROTOCOL_VERSION);\n@@ -156,21 +174,30 @@ bool CAlert::CheckSignature() const\n CAlert CAlert::getAlertByHash(const uint256 &hash)\n {\n     CAlert retval;\n+\n     {\n         LOCK(cs_mapAlerts);\n         map<uint256, CAlert>::iterator mi = mapAlerts.find(hash);\n-        if(mi != mapAlerts.end())\n+\n+        if (mi != mapAlerts.end())\n+        {\n             retval = mi->second;\n+        }\n     }\n     return retval;\n }\n \n bool CAlert::ProcessAlert(bool fThread)\n {\n     if (!CheckSignature())\n+    {\n         return false;\n+    }\n+\n     if (!IsInEffect())\n+    {\n         return false;\n+    }\n \n     // alert.nID=max is reserved for if the alert key is\n     // compromised. It must have a pre-defined message,\n@@ -180,26 +207,31 @@ bool CAlert::ProcessAlert(bool fThread)\n     // send an \"everything is OK, don't panic\" version that\n     // cannot be overridden):\n     int maxInt = std::numeric_limits<int>::max();\n+\n     if (nID == maxInt)\n     {\n         if (!(\n                 nExpiration == maxInt &&\n-                nCancel == (maxInt-1) &&\n+                nCancel == (maxInt - 1) &&\n                 nMinVer == 0 &&\n                 nMaxVer == maxInt &&\n                 setSubVer.empty() &&\n                 nPriority == maxInt &&\n                 strStatusBar == \"URGENT: Alert key compromised, upgrade required\"\n                 ))\n+        {\n             return false;\n+        }\n     }\n \n     {\n         LOCK(cs_mapAlerts);\n+\n         // Cancel previous alerts\n-        for (map<uint256, CAlert>::iterator mi = mapAlerts.begin(); mi != mapAlerts.end();)\n+        for (map<uint256, CAlert>::iterator mi = mapAlerts.begin(); mi != mapAlerts.end(); )\n         {\n             const CAlert& alert = (*mi).second;\n+\n             if (Cancels(alert))\n             {\n                 LogPrint(\"alert\", \"cancelling alert %d\\n\", alert.nID);\n@@ -213,13 +245,16 @@ bool CAlert::ProcessAlert(bool fThread)\n                 mapAlerts.erase(mi++);\n             }\n             else\n+            {\n                 mi++;\n+            }\n         }\n \n         // Check if this alert has been cancelled\n-        BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n+        BOOST_FOREACH (PAIRTYPE(const uint256, CAlert) & item, mapAlerts)\n         {\n             const CAlert& alert = item.second;\n+\n             if (alert.Cancels(*this))\n             {\n                 LogPrint(\"alert\", \"alert already cancelled by %d\\n\", alert.nID);\n@@ -229,29 +264,36 @@ bool CAlert::ProcessAlert(bool fThread)\n \n         // Add to mapAlerts\n         mapAlerts.insert(make_pair(GetHash(), *this));\n+\n         // Notify UI and -alertnotify if it applies to me\n-        if(AppliesToMe())\n+        if (AppliesToMe())\n         {\n             uiInterface.NotifyAlertChanged(GetHash(), CT_NEW);\n             std::string strCmd = GetArg(\"-alertnotify\", \"\");\n+\n             if (!strCmd.empty())\n             {\n                 // Alert text should be plain ascii coming from a trusted source, but to\n                 // be safe we first strip anything not in safeChars, then add single quotes around\n                 // the whole string before passing it to the shell:\n                 std::string singleQuote(\"'\");\n                 std::string safeStatus = SanitizeString(strStatusBar);\n-                safeStatus = singleQuote+safeStatus+singleQuote;\n+                safeStatus = singleQuote + safeStatus + singleQuote;\n                 boost::replace_all(strCmd, \"%s\", safeStatus);\n \n                 if (fThread)\n+                {\n                     boost::thread t(runCommand, strCmd); // thread runs free\n+                }\n                 else\n+                {\n                     runCommand(strCmd);\n+                }\n             }\n         }\n     }\n \n     LogPrint(\"alert\", \"accepted alert %d, AppliesToMe()=%d\\n\", nID, AppliesToMe());\n     return true;\n }\n+"
      },
      {
        "sha": "3dd8beefc8189d2dc96ab6264000258165801b10",
        "filename": "src/alert.h",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/alert.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/alert.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/alert.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -49,7 +49,8 @@ class CUnsignedAlert\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n         READWRITE(this->nVersion);\n         nVersion = this->nVersion;\n         READWRITE(nRelayUntil);\n@@ -87,7 +88,8 @@ class CAlert : public CUnsignedAlert\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n         READWRITE(vchMsg);\n         READWRITE(vchSig);\n     }\n@@ -110,3 +112,4 @@ class CAlert : public CUnsignedAlert\n };\n \n #endif // _BITCOINALERT_H_\n+"
      },
      {
        "sha": "83c8285b0882de34b74951504ccdad8c3ff16e18",
        "filename": "src/allocators.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 2,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/allocators.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/allocators.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/allocators.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -31,6 +31,7 @@ boost::once_flag LockedPageManager::init_flag = BOOST_ONCE_INIT;\n static inline size_t GetSystemPageSize()\n {\n     size_t page_size;\n+\n #if defined(WIN32)\n     SYSTEM_INFO sSysInfo;\n     GetSystemInfo(&sSysInfo);\n@@ -43,21 +44,25 @@ static inline size_t GetSystemPageSize()\n     return page_size;\n }\n \n-bool MemoryPageLocker::Lock(const void *addr, size_t len)\n+bool MemoryPageLocker::Lock(const void* addr, size_t len)\n {\n #ifdef WIN32\n     return VirtualLock(const_cast<void*>(addr), len);\n+\n #else\n     return mlock(addr, len) == 0;\n+\n #endif\n }\n \n-bool MemoryPageLocker::Unlock(const void *addr, size_t len)\n+bool MemoryPageLocker::Unlock(const void* addr, size_t len)\n {\n #ifdef WIN32\n     return VirtualUnlock(const_cast<void*>(addr), len);\n+\n #else\n     return munlock(addr, len) == 0;\n+\n #endif\n }\n "
      },
      {
        "sha": "59ee81040e863e80dc3792820f1b4e5f625e2be1",
        "filename": "src/allocators.h",
        "status": "modified",
        "additions": 95,
        "deletions": 39,
        "changes": 134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/allocators.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/allocators.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/allocators.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -25,14 +25,15 @@\n  * small objects that span up to a few pages, mostly smaller than a page. To support large allocations,\n  * something like an interval tree would be the preferred data structure.\n  */\n-template <class Locker> class LockedPageManagerBase\n+template <class Locker>\n+class LockedPageManagerBase\n {\n public:\n-    LockedPageManagerBase(size_t page_size):\n+    LockedPageManagerBase(size_t page_size) :\n         page_size(page_size)\n     {\n         // Determine bitmask for extracting page from address\n-        assert(!(page_size & (page_size-1))); // size must be power of two\n+        assert(!(page_size & (page_size - 1))); // size must be power of two\n         page_mask = ~(page_size - 1);\n     }\n \n@@ -41,19 +42,25 @@ template <class Locker> class LockedPageManagerBase\n         assert(this->GetLockedPageCount() == 0);\n     }\n \n-\n     // For all pages in affected range, increase lock count\n-    void LockRange(void *p, size_t size)\n+    void LockRange(void* p, size_t size)\n     {\n         boost::mutex::scoped_lock lock(mutex);\n-        if(!size) return;\n+\n+        if (!size)\n+        {\n+            return;\n+        }\n+\n         const size_t base_addr = reinterpret_cast<size_t>(p);\n         const size_t start_page = base_addr & page_mask;\n         const size_t end_page = (base_addr + size - 1) & page_mask;\n-        for(size_t page = start_page; page <= end_page; page += page_size)\n+\n+        for (size_t page = start_page; page <= end_page; page += page_size)\n         {\n             Histogram::iterator it = histogram.find(page);\n-            if(it == histogram.end()) // Newly locked page\n+\n+            if (it == histogram.end()) // Newly locked page\n             {\n                 locker.Lock(reinterpret_cast<void*>(page), page_size);\n                 histogram.insert(std::make_pair(page, 1));\n@@ -66,20 +73,27 @@ template <class Locker> class LockedPageManagerBase\n     }\n \n     // For all pages in affected range, decrease lock count\n-    void UnlockRange(void *p, size_t size)\n+    void UnlockRange(void* p, size_t size)\n     {\n         boost::mutex::scoped_lock lock(mutex);\n-        if(!size) return;\n+\n+        if (!size)\n+        {\n+            return;\n+        }\n+\n         const size_t base_addr = reinterpret_cast<size_t>(p);\n         const size_t start_page = base_addr & page_mask;\n         const size_t end_page = (base_addr + size - 1) & page_mask;\n-        for(size_t page = start_page; page <= end_page; page += page_size)\n+\n+        for (size_t page = start_page; page <= end_page; page += page_size)\n         {\n             Histogram::iterator it = histogram.find(page);\n             assert(it != histogram.end()); // Cannot unlock an area that was not locked\n             // Decrease counter for page, when it is zero, the page will be unlocked\n             it->second -= 1;\n-            if(it->second == 0) // Nothing on the page anymore that keeps it locked\n+\n+            if (it->second == 0) // Nothing on the page anymore that keeps it locked\n             {\n                 // Unlock page and remove the count from histogram\n                 locker.Unlock(reinterpret_cast<void*>(page), page_size);\n@@ -92,6 +106,7 @@ template <class Locker> class LockedPageManagerBase\n     int GetLockedPageCount()\n     {\n         boost::mutex::scoped_lock lock(mutex);\n+\n         return histogram.size();\n     }\n \n@@ -100,11 +115,10 @@ template <class Locker> class LockedPageManagerBase\n     boost::mutex mutex;\n     size_t page_size, page_mask;\n     // map of page base address to lock count\n-    typedef std::map<size_t,int> Histogram;\n+    typedef std::map<size_t, int> Histogram;\n     Histogram histogram;\n };\n \n-\n /**\n  * OS-dependent memory page locking/unlocking.\n  * Defined as policy class to make stubbing for test possible.\n@@ -115,11 +129,11 @@ class MemoryPageLocker\n     /** Lock memory pages.\n      * addr and len must be a multiple of the system page size\n      */\n-    bool Lock(const void *addr, size_t len);\n+    bool Lock(const void* addr, size_t len);\n     /** Unlock memory pages.\n      * addr and len must be a multiple of the system page size\n      */\n-    bool Unlock(const void *addr, size_t len);\n+    bool Unlock(const void* addr, size_t len);\n };\n \n /**\n@@ -133,10 +147,10 @@ class MemoryPageLocker\n  * secure_allocator are created. So instead of having LockedPageManager also be\n  * static-initialized, it is created on demand.\n  */\n-class LockedPageManager: public LockedPageManagerBase<MemoryPageLocker>\n+class LockedPageManager : public LockedPageManagerBase<MemoryPageLocker>\n {\n public:\n-    static LockedPageManager& Instance() \n+    static LockedPageManager& Instance()\n     {\n         boost::call_once(LockedPageManager::CreateInstance, LockedPageManager::init_flag);\n         return *LockedPageManager::_instance;\n@@ -153,6 +167,7 @@ class LockedPageManager: public LockedPageManagerBase<MemoryPageLocker>\n         // have a static deinitialization order/problem, but the check in\n         // LockedPageManagerBase's destructor helps us detect if that ever happens.\n         static LockedPageManager instance;\n+\n         LockedPageManager::_instance = &instance;\n     }\n \n@@ -164,11 +179,15 @@ class LockedPageManager: public LockedPageManagerBase<MemoryPageLocker>\n // Functions for directly locking/unlocking memory objects.\n // Intended for non-dynamically allocated structures.\n //\n-template<typename T> void LockObject(const T &t) {\n+template<typename T>\n+void LockObject(const T &t)\n+{\n     LockedPageManager::Instance().LockRange((void*)(&t), sizeof(T));\n }\n \n-template<typename T> void UnlockObject(const T &t) {\n+template<typename T>\n+void UnlockObject(const T &t)\n+{\n     OPENSSL_cleanse((void*)(&t), sizeof(T));\n     LockedPageManager::Instance().UnlockRange((void*)(&t), sizeof(T));\n }\n@@ -183,26 +202,45 @@ struct secure_allocator : public std::allocator<T>\n     // MSVC8 default copy constructor is broken\n     typedef std::allocator<T> base;\n     typedef typename base::size_type size_type;\n-    typedef typename base::difference_type  difference_type;\n+    typedef typename base::difference_type difference_type;\n     typedef typename base::pointer pointer;\n     typedef typename base::const_pointer const_pointer;\n     typedef typename base::reference reference;\n     typedef typename base::const_reference const_reference;\n     typedef typename base::value_type value_type;\n-    secure_allocator() throw() {}\n-    secure_allocator(const secure_allocator& a) throw() : base(a) {}\n-    template <typename U>\n-    secure_allocator(const secure_allocator<U>& a) throw() : base(a) {}\n-    ~secure_allocator() throw() {}\n-    template<typename _Other> struct rebind\n-    { typedef secure_allocator<_Other> other; };\n+    secure_allocator() throw()\n+    {\n+    }\n \n-    T* allocate(std::size_t n, const void *hint = 0)\n+    secure_allocator(const secure_allocator& a) throw() : base(a)\n     {\n-        T *p;\n+    }\n+\n+    template <typename U>secure_allocator(const secure_allocator<U>& a) throw() : base(a)\n+    {\n+    }\n+\n+    ~secure_allocator() throw()\n+    {\n+    }\n+\n+    template<typename _Other>\n+    struct rebind\n+    {\n+        typedef secure_allocator<_Other> other;\n+    };\n+\n+    T* allocate(std::size_t n, const void* hint = 0)\n+    {\n+        T* p;\n+\n         p = std::allocator<T>::allocate(n, hint);\n+\n         if (p != NULL)\n+        {\n             LockedPageManager::Instance().LockRange(p, sizeof(T) * n);\n+        }\n+\n         return p;\n     }\n \n@@ -213,11 +251,11 @@ struct secure_allocator : public std::allocator<T>\n             OPENSSL_cleanse(p, sizeof(T) * n);\n             LockedPageManager::Instance().UnlockRange(p, sizeof(T) * n);\n         }\n+\n         std::allocator<T>::deallocate(p, n);\n     }\n };\n \n-\n //\n // Allocator that clears its contents before deletion.\n //\n@@ -227,24 +265,41 @@ struct zero_after_free_allocator : public std::allocator<T>\n     // MSVC8 default copy constructor is broken\n     typedef std::allocator<T> base;\n     typedef typename base::size_type size_type;\n-    typedef typename base::difference_type  difference_type;\n+    typedef typename base::difference_type difference_type;\n     typedef typename base::pointer pointer;\n     typedef typename base::const_pointer const_pointer;\n     typedef typename base::reference reference;\n     typedef typename base::const_reference const_reference;\n     typedef typename base::value_type value_type;\n-    zero_after_free_allocator() throw() {}\n-    zero_after_free_allocator(const zero_after_free_allocator& a) throw() : base(a) {}\n-    template <typename U>\n-    zero_after_free_allocator(const zero_after_free_allocator<U>& a) throw() : base(a) {}\n-    ~zero_after_free_allocator() throw() {}\n-    template<typename _Other> struct rebind\n-    { typedef zero_after_free_allocator<_Other> other; };\n+    zero_after_free_allocator() throw()\n+    {\n+    }\n+\n+    zero_after_free_allocator(const zero_after_free_allocator& a) throw() : base(a)\n+    {\n+    }\n+\n+    template <typename U>zero_after_free_allocator(const zero_after_free_allocator<U>& a) throw() : base(a)\n+    {\n+    }\n+\n+    ~zero_after_free_allocator() throw()\n+    {\n+    }\n+\n+    template<typename _Other>\n+    struct rebind\n+    {\n+        typedef zero_after_free_allocator<_Other> other;\n+    };\n \n     void deallocate(T* p, std::size_t n)\n     {\n         if (p != NULL)\n+        {\n             OPENSSL_cleanse(p, sizeof(T) * n);\n+        }\n+\n         std::allocator<T>::deallocate(p, n);\n     }\n };\n@@ -253,3 +308,4 @@ struct zero_after_free_allocator : public std::allocator<T>\n typedef std::basic_string<char, std::char_traits<char>, secure_allocator<char> > SecureString;\n \n #endif // BITCOIN_ALLOCATORS_H\n+"
      },
      {
        "sha": "f9d23f3aa4458cbca7ca4cdafa2208e83c65ea0d",
        "filename": "src/base58.cpp",
        "status": "modified",
        "additions": 176,
        "deletions": 52,
        "changes": 228,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/base58.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/base58.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -18,258 +18,382 @@\n /* All alphanumeric characters except for \"0\", \"I\", \"O\", and \"l\" */\n static const char* pszBase58 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n \n-bool DecodeBase58(const char *psz, std::vector<unsigned char>& vch) {\n+bool DecodeBase58(const char* psz, std::vector<unsigned char>& vch)\n+{\n     // Skip leading spaces.\n     while (*psz && isspace(*psz))\n         psz++;\n+\n     // Skip and count leading '1's.\n     int zeroes = 0;\n-    while (*psz == '1') {\n+\n+    while (*psz == '1')\n+    {\n         zeroes++;\n         psz++;\n     }\n+\n     // Allocate enough space in big-endian base256 representation.\n     std::vector<unsigned char> b256(strlen(psz) * 733 / 1000 + 1); // log(58) / log(256), rounded up.\n+\n     // Process the characters.\n-    while (*psz && !isspace(*psz)) {\n+    while (*psz && !isspace(*psz))\n+    {\n         // Decode base58 character\n-        const char *ch = strchr(pszBase58, *psz);\n+        const char* ch = strchr(pszBase58, *psz);\n+\n         if (ch == NULL)\n+        {\n             return false;\n+        }\n+\n         // Apply \"b256 = b256 * 58 + ch\".\n         int carry = ch - pszBase58;\n-        for (std::vector<unsigned char>::reverse_iterator it = b256.rbegin(); it != b256.rend(); it++) {\n+\n+        for (std::vector<unsigned char>::reverse_iterator it = b256.rbegin(); it != b256.rend(); it++)\n+        {\n             carry += 58 * (*it);\n             *it = carry % 256;\n             carry /= 256;\n         }\n+\n         assert(carry == 0);\n         psz++;\n     }\n+\n     // Skip trailing spaces.\n     while (isspace(*psz))\n         psz++;\n+\n     if (*psz != 0)\n+    {\n         return false;\n+    }\n+\n     // Skip leading zeroes in b256.\n     std::vector<unsigned char>::iterator it = b256.begin();\n+\n     while (it != b256.end() && *it == 0)\n         it++;\n+\n     // Copy result into output vector.\n     vch.reserve(zeroes + (b256.end() - it));\n     vch.assign(zeroes, 0x00);\n+\n     while (it != b256.end())\n-      vch.push_back(*(it++));\n+        vch.push_back(*(it++));\n+\n     return true;\n }\n \n-std::string EncodeBase58(const unsigned char* pbegin, const unsigned char* pend) {\n+std::string EncodeBase58(const unsigned char* pbegin, const unsigned char* pend)\n+{\n     // Skip & count leading zeroes.\n     int zeroes = 0;\n-    while (pbegin != pend && *pbegin == 0) {\n+\n+    while (pbegin != pend && *pbegin == 0)\n+    {\n         pbegin++;\n         zeroes++;\n     }\n+\n     // Allocate enough space in big-endian base58 representation.\n     std::vector<unsigned char> b58((pend - pbegin) * 138 / 100 + 1); // log(256) / log(58), rounded up.\n+\n     // Process the bytes.\n-    while (pbegin != pend) {\n+    while (pbegin != pend)\n+    {\n         int carry = *pbegin;\n+\n         // Apply \"b58 = b58 * 256 + ch\".\n-        for (std::vector<unsigned char>::reverse_iterator it = b58.rbegin(); it != b58.rend(); it++) {\n+        for (std::vector<unsigned char>::reverse_iterator it = b58.rbegin(); it != b58.rend(); it++)\n+        {\n             carry += 256 * (*it);\n             *it = carry % 58;\n             carry /= 58;\n         }\n+\n         assert(carry == 0);\n         pbegin++;\n     }\n+\n     // Skip leading zeroes in base58 result.\n     std::vector<unsigned char>::iterator it = b58.begin();\n+\n     while (it != b58.end() && *it == 0)\n         it++;\n+\n     // Translate the result into a string.\n     std::string str;\n     str.reserve(zeroes + (b58.end() - it));\n     str.assign(zeroes, '1');\n+\n     while (it != b58.end())\n         str += pszBase58[*(it++)];\n+\n     return str;\n }\n \n-std::string EncodeBase58(const std::vector<unsigned char>& vch) {\n+std::string EncodeBase58(const std::vector<unsigned char>& vch)\n+{\n     return EncodeBase58(&vch[0], &vch[0] + vch.size());\n }\n \n-bool DecodeBase58(const std::string& str, std::vector<unsigned char>& vchRet) {\n+bool DecodeBase58(const std::string& str, std::vector<unsigned char>& vchRet)\n+{\n     return DecodeBase58(str.c_str(), vchRet);\n }\n \n-std::string EncodeBase58Check(const std::vector<unsigned char>& vchIn) {\n+std::string EncodeBase58Check(const std::vector<unsigned char>& vchIn)\n+{\n     // add 4-byte hash check to the end\n     std::vector<unsigned char> vch(vchIn);\n     uint256 hash = Hash(vch.begin(), vch.end());\n     vch.insert(vch.end(), (unsigned char*)&hash, (unsigned char*)&hash + 4);\n     return EncodeBase58(vch);\n }\n \n-bool DecodeBase58Check(const char* psz, std::vector<unsigned char>& vchRet) {\n+bool DecodeBase58Check(const char* psz, std::vector<unsigned char>& vchRet)\n+{\n     if (!DecodeBase58(psz, vchRet) ||\n         (vchRet.size() < 4))\n     {\n         vchRet.clear();\n         return false;\n     }\n+\n     // re-calculate the checksum, insure it matches the included 4-byte checksum\n-    uint256 hash = Hash(vchRet.begin(), vchRet.end()-4);\n+    uint256 hash = Hash(vchRet.begin(), vchRet.end() - 4);\n+\n     if (memcmp(&hash, &vchRet.end()[-4], 4) != 0)\n     {\n         vchRet.clear();\n         return false;\n     }\n-    vchRet.resize(vchRet.size()-4);\n+\n+    vchRet.resize(vchRet.size() - 4);\n     return true;\n }\n \n-bool DecodeBase58Check(const std::string& str, std::vector<unsigned char>& vchRet) {\n+bool DecodeBase58Check(const std::string& str, std::vector<unsigned char>& vchRet)\n+{\n     return DecodeBase58Check(str.c_str(), vchRet);\n }\n \n-CBase58Data::CBase58Data() {\n+CBase58Data::CBase58Data()\n+{\n     vchVersion.clear();\n     vchData.clear();\n }\n \n-void CBase58Data::SetData(const std::vector<unsigned char> &vchVersionIn, const void* pdata, size_t nSize) {\n+void CBase58Data::SetData(const std::vector<unsigned char> &vchVersionIn, const void* pdata, size_t nSize)\n+{\n     vchVersion = vchVersionIn;\n     vchData.resize(nSize);\n+\n     if (!vchData.empty())\n+    {\n         memcpy(&vchData[0], pdata, nSize);\n+    }\n }\n \n-void CBase58Data::SetData(const std::vector<unsigned char> &vchVersionIn, const unsigned char *pbegin, const unsigned char *pend) {\n+void CBase58Data::SetData(const std::vector<unsigned char> &vchVersionIn, const unsigned char* pbegin,\n+    const unsigned char* pend)\n+{\n     SetData(vchVersionIn, (void*)pbegin, pend - pbegin);\n }\n \n-bool CBase58Data::SetString(const char* psz, unsigned int nVersionBytes) {\n+bool CBase58Data::SetString(const char* psz, unsigned int nVersionBytes)\n+{\n     std::vector<unsigned char> vchTemp;\n     bool rc58 = DecodeBase58Check(psz, vchTemp);\n-    if ((!rc58) || (vchTemp.size() < nVersionBytes)) {\n+\n+    if ((!rc58) || (vchTemp.size() < nVersionBytes))\n+    {\n         vchData.clear();\n         vchVersion.clear();\n         return false;\n     }\n+\n     vchVersion.assign(vchTemp.begin(), vchTemp.begin() + nVersionBytes);\n     vchData.resize(vchTemp.size() - nVersionBytes);\n+\n     if (!vchData.empty())\n+    {\n         memcpy(&vchData[0], &vchTemp[nVersionBytes], vchData.size());\n+    }\n+\n     OPENSSL_cleanse(&vchTemp[0], vchData.size());\n     return true;\n }\n \n-bool CBase58Data::SetString(const std::string& str) {\n+bool CBase58Data::SetString(const std::string& str)\n+{\n     return SetString(str.c_str());\n }\n \n-std::string CBase58Data::ToString() const {\n+std::string CBase58Data::ToString() const\n+{\n     std::vector<unsigned char> vch = vchVersion;\n     vch.insert(vch.end(), vchData.begin(), vchData.end());\n     return EncodeBase58Check(vch);\n }\n \n-int CBase58Data::CompareTo(const CBase58Data& b58) const {\n-    if (vchVersion < b58.vchVersion) return -1;\n-    if (vchVersion > b58.vchVersion) return  1;\n-    if (vchData < b58.vchData)   return -1;\n-    if (vchData > b58.vchData)   return  1;\n+int CBase58Data::CompareTo(const CBase58Data& b58) const\n+{\n+    if (vchVersion < b58.vchVersion)\n+    {\n+        return -1;\n+    }\n+\n+    if (vchVersion > b58.vchVersion)\n+    {\n+        return 1;\n+    }\n+\n+    if (vchData < b58.vchData)\n+    {\n+        return -1;\n+    }\n+\n+    if (vchData > b58.vchData)\n+    {\n+        return 1;\n+    }\n+\n     return 0;\n }\n \n-namespace {\n+namespace\n+{\n+class CBitcoinAddressVisitor : public boost::static_visitor<bool>\n+{\n+private:\n+    CBitcoinAddress* addr;\n+public:\n+    CBitcoinAddressVisitor(CBitcoinAddress* addrIn) : addr(addrIn)\n+    {\n+    }\n \n-    class CBitcoinAddressVisitor : public boost::static_visitor<bool> {\n-    private:\n-        CBitcoinAddress *addr;\n-    public:\n-        CBitcoinAddressVisitor(CBitcoinAddress *addrIn) : addr(addrIn) { }\n+    bool operator()(const CKeyID &id) const\n+    {\n+        return addr->Set(id);\n+    }\n \n-        bool operator()(const CKeyID &id) const { return addr->Set(id); }\n-        bool operator()(const CScriptID &id) const { return addr->Set(id); }\n-        bool operator()(const CNoDestination &no) const { return false; }\n-    };\n+    bool operator()(const CScriptID &id) const\n+    {\n+        return addr->Set(id);\n+    }\n \n+    bool operator()(const CNoDestination &no) const\n+    {\n+        return false;\n+    }\n+};\n } // anon namespace\n \n-bool CBitcoinAddress::Set(const CKeyID &id) {\n+bool CBitcoinAddress::Set(const CKeyID &id)\n+{\n     SetData(Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS), &id, 20);\n     return true;\n }\n \n-bool CBitcoinAddress::Set(const CScriptID &id) {\n+bool CBitcoinAddress::Set(const CScriptID &id)\n+{\n     SetData(Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS), &id, 20);\n     return true;\n }\n \n-bool CBitcoinAddress::Set(const CTxDestination &dest) {\n+bool CBitcoinAddress::Set(const CTxDestination &dest)\n+{\n     return boost::apply_visitor(CBitcoinAddressVisitor(this), dest);\n }\n \n-bool CBitcoinAddress::IsValid() const {\n+bool CBitcoinAddress::IsValid() const\n+{\n     bool fCorrectSize = vchData.size() == 20;\n     bool fKnownVersion = vchVersion == Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS) ||\n-                         vchVersion == Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS);\n+        vchVersion == Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS);\n+\n     return fCorrectSize && fKnownVersion;\n }\n \n-CTxDestination CBitcoinAddress::Get() const {\n+CTxDestination CBitcoinAddress::Get() const\n+{\n     if (!IsValid())\n+    {\n         return CNoDestination();\n+    }\n+\n     uint160 id;\n     memcpy(&id, &vchData[0], 20);\n+\n     if (vchVersion == Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS))\n+    {\n         return CKeyID(id);\n+    }\n     else if (vchVersion == Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS))\n+    {\n         return CScriptID(id);\n+    }\n     else\n+    {\n         return CNoDestination();\n+    }\n }\n \n-bool CBitcoinAddress::GetKeyID(CKeyID &keyID) const {\n+bool CBitcoinAddress::GetKeyID(CKeyID &keyID) const\n+{\n     if (!IsValid() || vchVersion != Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS))\n+    {\n         return false;\n+    }\n+\n     uint160 id;\n     memcpy(&id, &vchData[0], 20);\n     keyID = CKeyID(id);\n     return true;\n }\n \n-bool CBitcoinAddress::IsScript() const {\n+bool CBitcoinAddress::IsScript() const\n+{\n     return IsValid() && vchVersion == Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS);\n }\n \n-void CBitcoinSecret::SetKey(const CKey& vchSecret) {\n+void CBitcoinSecret::SetKey(const CKey& vchSecret)\n+{\n     assert(vchSecret.IsValid());\n     SetData(Params().Base58Prefix(CChainParams::SECRET_KEY), vchSecret.begin(), vchSecret.size());\n+\n     if (vchSecret.IsCompressed())\n+    {\n         vchData.push_back(1);\n+    }\n }\n \n-CKey CBitcoinSecret::GetKey() {\n+CKey CBitcoinSecret::GetKey()\n+{\n     CKey ret;\n+\n     ret.Set(&vchData[0], &vchData[32], vchData.size() > 32 && vchData[32] == 1);\n     return ret;\n }\n \n-bool CBitcoinSecret::IsValid() const {\n+bool CBitcoinSecret::IsValid() const\n+{\n     bool fExpectedFormat = vchData.size() == 32 || (vchData.size() == 33 && vchData[32] == 1);\n     bool fCorrectVersion = vchVersion == Params().Base58Prefix(CChainParams::SECRET_KEY);\n+\n     return fExpectedFormat && fCorrectVersion;\n }\n \n-bool CBitcoinSecret::SetString(const char* pszSecret) {\n+bool CBitcoinSecret::SetString(const char* pszSecret)\n+{\n     return CBase58Data::SetString(pszSecret) && IsValid();\n }\n \n-bool CBitcoinSecret::SetString(const std::string& strSecret) {\n+bool CBitcoinSecret::SetString(const std::string& strSecret)\n+{\n     return SetString(strSecret.c_str());\n }\n+"
      },
      {
        "sha": "fb87a59fd4038c8c48593b8094b0c489864773b2",
        "filename": "src/base58.h",
        "status": "modified",
        "additions": 68,
        "deletions": 19,
        "changes": 87,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/base58.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/base58.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -77,19 +77,38 @@ class CBase58Data\n \n     CBase58Data();\n     void SetData(const std::vector<unsigned char> &vchVersionIn, const void* pdata, size_t nSize);\n-    void SetData(const std::vector<unsigned char> &vchVersionIn, const unsigned char *pbegin, const unsigned char *pend);\n+    void SetData(const std::vector<unsigned char> &vchVersionIn, const unsigned char* pbegin, const unsigned char* pend);\n \n public:\n     bool SetString(const char* psz, unsigned int nVersionBytes = 1);\n     bool SetString(const std::string& str);\n     std::string ToString() const;\n     int CompareTo(const CBase58Data& b58) const;\n \n-    bool operator==(const CBase58Data& b58) const { return CompareTo(b58) == 0; }\n-    bool operator<=(const CBase58Data& b58) const { return CompareTo(b58) <= 0; }\n-    bool operator>=(const CBase58Data& b58) const { return CompareTo(b58) >= 0; }\n-    bool operator< (const CBase58Data& b58) const { return CompareTo(b58) <  0; }\n-    bool operator> (const CBase58Data& b58) const { return CompareTo(b58) >  0; }\n+    bool operator==(const CBase58Data& b58) const\n+    {\n+        return CompareTo(b58) == 0;\n+    }\n+\n+    bool operator<=(const CBase58Data& b58) const\n+    {\n+        return CompareTo(b58) <= 0;\n+    }\n+\n+    bool operator>=(const CBase58Data& b58) const\n+    {\n+        return CompareTo(b58) >= 0;\n+    }\n+\n+    bool operator< (const CBase58Data& b58) const\n+    {\n+        return CompareTo(b58) <  0;\n+    }\n+\n+    bool operator> (const CBase58Data& b58) const\n+    {\n+        return CompareTo(b58) >  0;\n+    }\n };\n \n /** base58-encoded Bitcoin addresses.\n@@ -98,17 +117,32 @@ class CBase58Data\n  * Script-hash-addresses have version 5 (or 196 testnet).\n  * The data vector contains RIPEMD160(SHA256(cscript)), where cscript is the serialized redemption script.\n  */\n-class CBitcoinAddress : public CBase58Data {\n+class CBitcoinAddress : public CBase58Data\n+{\n public:\n     bool Set(const CKeyID &id);\n     bool Set(const CScriptID &id);\n     bool Set(const CTxDestination &dest);\n     bool IsValid() const;\n \n-    CBitcoinAddress() {}\n-    CBitcoinAddress(const CTxDestination &dest) { Set(dest); }\n-    CBitcoinAddress(const std::string& strAddress) { SetString(strAddress); }\n-    CBitcoinAddress(const char* pszAddress) { SetString(pszAddress); }\n+    CBitcoinAddress()\n+    {\n+    }\n+\n+    CBitcoinAddress(const CTxDestination &dest)\n+    {\n+        Set(dest);\n+    }\n+\n+    CBitcoinAddress(const std::string& strAddress)\n+    {\n+        SetString(strAddress);\n+    }\n+\n+    CBitcoinAddress(const char* pszAddress)\n+    {\n+        SetString(pszAddress);\n+    }\n \n     CTxDestination Get() const;\n     bool GetKeyID(CKeyID &keyID) const;\n@@ -127,33 +161,48 @@ class CBitcoinSecret : public CBase58Data\n     bool SetString(const char* pszSecret);\n     bool SetString(const std::string& strSecret);\n \n-    CBitcoinSecret(const CKey& vchSecret) { SetKey(vchSecret); }\n-    CBitcoinSecret() {}\n+    CBitcoinSecret(const CKey& vchSecret)\n+    {\n+        SetKey(vchSecret);\n+    }\n+\n+    CBitcoinSecret()\n+    {\n+    }\n };\n \n-template<typename K, int Size, CChainParams::Base58Type Type> class CBitcoinExtKeyBase : public CBase58Data\n+template<typename K, int Size, CChainParams::Base58Type Type>\n+class CBitcoinExtKeyBase : public CBase58Data\n {\n public:\n-    void SetKey(const K &key) {\n+    void SetKey(const K &key)\n+    {\n         unsigned char vch[Size];\n+\n         key.Encode(vch);\n-        SetData(Params().Base58Prefix(Type), vch, vch+Size);\n+        SetData(Params().Base58Prefix(Type), vch, vch + Size);\n     }\n \n-    K GetKey() {\n+    K GetKey()\n+    {\n         K ret;\n+\n         ret.Decode(&vchData[0], &vchData[Size]);\n         return ret;\n     }\n \n-    CBitcoinExtKeyBase(const K &key) {\n+    CBitcoinExtKeyBase(const K &key)\n+    {\n         SetKey(key);\n     }\n \n-    CBitcoinExtKeyBase() {}\n+    CBitcoinExtKeyBase()\n+    {\n+    }\n };\n \n typedef CBitcoinExtKeyBase<CExtKey, 74, CChainParams::EXT_SECRET_KEY> CBitcoinExtKey;\n typedef CBitcoinExtKeyBase<CExtPubKey, 74, CChainParams::EXT_PUBLIC_KEY> CBitcoinExtPubKey;\n \n #endif // BITCOIN_BASE58_H\n+"
      },
      {
        "sha": "c4afe28ba48190b2dd8178577a620dafecc708b9",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 111,
        "deletions": 35,
        "changes": 146,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -23,15 +23,19 @@ using namespace json_spirit;\n std::string HelpMessageCli()\n {\n     string strUsage;\n+\n     strUsage += _(\"Options:\") + \"\\n\";\n     strUsage += \"  -?                     \" + _(\"This help message\") + \"\\n\";\n     strUsage += \"  -conf=<file>           \" + _(\"Specify configuration file (default: bitcoin.conf)\") + \"\\n\";\n     strUsage += \"  -datadir=<dir>         \" + _(\"Specify data directory\") + \"\\n\";\n     strUsage += \"  -testnet               \" + _(\"Use the test network\") + \"\\n\";\n-    strUsage += \"  -regtest               \" + _(\"Enter regression test mode, which uses a special chain in which blocks can be \"\n-                                                \"solved instantly. This is intended for regression testing tools and app development.\") + \"\\n\";\n+    strUsage += \"  -regtest               \" + _(\n+        \"Enter regression test mode, which uses a special chain in which blocks can be \"\n+        \"solved instantly. This is intended for regression testing tools and app development.\")\n+        + \"\\n\";\n     strUsage += \"  -rpcconnect=<ip>       \" + _(\"Send commands to node running on <ip> (default: 127.0.0.1)\") + \"\\n\";\n-    strUsage += \"  -rpcport=<port>        \" + _(\"Connect to JSON-RPC on <port> (default: 8332 or testnet: 18332)\") + \"\\n\";\n+    strUsage += \"  -rpcport=<port>        \" + _(\"Connect to JSON-RPC on <port> (default: 8332 or testnet: 18332)\") +\n+        \"\\n\";\n     strUsage += \"  -rpcwait               \" + _(\"Wait for RPC server to start\") + \"\\n\";\n     strUsage += \"  -rpcuser=<user>        \" + _(\"Username for JSON-RPC connections\") + \"\\n\";\n     strUsage += \"  -rpcpassword=<pw>      \" + _(\"Password for JSON-RPC connections\") + \"\\n\";\n@@ -52,45 +56,60 @@ static bool AppInitRPC(int argc, char* argv[])\n     // Parameters\n     //\n     ParseParameters(argc, argv);\n-    if (!boost::filesystem::is_directory(GetDataDir(false))) {\n+\n+    if (!boost::filesystem::is_directory(GetDataDir(false)))\n+    {\n         fprintf(stderr, \"Error: Specified data directory \\\"%s\\\" does not exist.\\n\", mapArgs[\"-datadir\"].c_str());\n         return false;\n     }\n-    try {\n+\n+    try\n+    {\n         ReadConfigFile(mapArgs, mapMultiArgs);\n-    } catch(std::exception &e) {\n-        fprintf(stderr,\"Error reading configuration file: %s\\n\", e.what());\n+    }\n+    catch (std::exception &e)\n+    {\n+        fprintf(stderr, \"Error reading configuration file: %s\\n\", e.what());\n         return false;\n     }\n+\n     // Check for -testnet or -regtest parameter (BaseParams() calls are only valid after this clause)\n-    if (!SelectBaseParamsFromCommandLine()) {\n+    if (!SelectBaseParamsFromCommandLine())\n+    {\n         fprintf(stderr, \"Error: Invalid combination of -regtest and -testnet.\\n\");\n         return false;\n     }\n-    if (argc<2 || mapArgs.count(\"-?\") || mapArgs.count(\"-help\") || mapArgs.count(\"-version\")) {\n+\n+    if (argc < 2 || mapArgs.count(\"-?\") || mapArgs.count(\"-help\") || mapArgs.count(\"-version\"))\n+    {\n         std::string strUsage = _(\"Bitcoin Core RPC client version\") + \" \" + FormatFullVersion() + \"\\n\";\n-        if (!mapArgs.count(\"-version\")) {\n+\n+        if (!mapArgs.count(\"-version\"))\n+        {\n             strUsage += \"\\n\" + _(\"Usage:\") + \"\\n\" +\n-                  \"  bitcoin-cli [options] <command> [params]  \" + _(\"Send command to Bitcoin Core\") + \"\\n\" +\n-                  \"  bitcoin-cli [options] help                \" + _(\"List commands\") + \"\\n\" +\n-                  \"  bitcoin-cli [options] help <command>      \" + _(\"Get help for a command\") + \"\\n\";\n+                \"  bitcoin-cli [options] <command> [params]  \" + _(\"Send command to Bitcoin Core\") + \"\\n\" +\n+                \"  bitcoin-cli [options] help                \" + _(\"List commands\") + \"\\n\" +\n+                \"  bitcoin-cli [options] help <command>      \" + _(\"Get help for a command\") + \"\\n\";\n \n             strUsage += \"\\n\" + HelpMessageCli();\n         }\n \n         fprintf(stdout, \"%s\", strUsage.c_str());\n         return false;\n     }\n+\n     return true;\n }\n \n Object CallRPC(const string& strMethod, const Array& params)\n {\n     if (mapArgs[\"-rpcuser\"] == \"\" && mapArgs[\"-rpcpassword\"] == \"\")\n+    {\n         throw runtime_error(strprintf(\n-            _(\"You must set rpcpassword=<password> in the configuration file:\\n%s\\n\"\n-              \"If the file does not exist, create it with owner-readable-only file permissions.\"),\n+                _(\"You must set rpcpassword=<password> in the configuration file:\\n%s\\n\"\n+                  \"If the file does not exist, create it with owner-readable-only file permissions.\"),\n                 GetConfigFile().string().c_str()));\n+    }\n \n     // Connect to localhost\n     bool fUseSSL = GetBoolArg(\"-rpcssl\", false);\n@@ -102,14 +121,26 @@ Object CallRPC(const string& strMethod, const Array& params)\n     iostreams::stream< SSLIOStreamDevice<asio::ip::tcp> > stream(d);\n \n     bool fWait = GetBoolArg(\"-rpcwait\", false); // -rpcwait means try until server has started\n-    do {\n+\n+    do\n+    {\n         bool fConnected = d.connect(GetArg(\"-rpcconnect\", \"127.0.0.1\"), GetArg(\"-rpcport\", itostr(BaseParams().RPCPort())));\n-        if (fConnected) break;\n+\n+        if (fConnected)\n+        {\n+            break;\n+        }\n+\n         if (fWait)\n+        {\n             MilliSleep(1000);\n+        }\n         else\n+        {\n             throw runtime_error(\"couldn't connect to server\");\n-    } while (fWait);\n+        }\n+    }\n+    while (fWait);\n \n     // HTTP basic authentication\n     string strUserPass64 = EncodeBase64(mapArgs[\"-rpcuser\"] + \":\" + mapArgs[\"-rpcpassword\"]);\n@@ -131,37 +162,57 @@ Object CallRPC(const string& strMethod, const Array& params)\n     ReadHTTPMessage(stream, mapHeaders, strReply, nProto, std::numeric_limits<size_t>::max());\n \n     if (nStatus == HTTP_UNAUTHORIZED)\n+    {\n         throw runtime_error(\"incorrect rpcuser or rpcpassword (authorization failed)\");\n-    else if (nStatus >= 400 && nStatus != HTTP_BAD_REQUEST && nStatus != HTTP_NOT_FOUND && nStatus != HTTP_INTERNAL_SERVER_ERROR)\n+    }\n+    else if (nStatus >= 400 && nStatus != HTTP_BAD_REQUEST && nStatus != HTTP_NOT_FOUND && nStatus !=\n+        HTTP_INTERNAL_SERVER_ERROR)\n+    {\n         throw runtime_error(strprintf(\"server returned HTTP error %d\", nStatus));\n+    }\n     else if (strReply.empty())\n+    {\n         throw runtime_error(\"no response from server\");\n+    }\n \n     // Parse reply\n     Value valReply;\n+\n     if (!read_string(strReply, valReply))\n+    {\n         throw runtime_error(\"couldn't parse reply from server\");\n+    }\n+\n     const Object& reply = valReply.get_obj();\n+\n     if (reply.empty())\n+    {\n         throw runtime_error(\"expected reply to have result, error and id properties\");\n+    }\n \n     return reply;\n }\n \n-int CommandLineRPC(int argc, char *argv[])\n+int CommandLineRPC(int argc, char* argv[])\n {\n     string strPrint;\n     int nRet = 0;\n-    try {\n+\n+    try\n+    {\n         // Skip switches\n-        while (argc > 1 && IsSwitchChar(argv[1][0])) {\n+        while (argc > 1 && IsSwitchChar(argv[1][0]))\n+        {\n             argc--;\n             argv++;\n         }\n \n         // Method\n         if (argc < 2)\n+        {\n             throw runtime_error(\"too few parameters\");\n+        }\n+\n         string strMethod = argv[1];\n \n         // Parameters default to strings\n@@ -175,63 +226,88 @@ int CommandLineRPC(int argc, char *argv[])\n         const Value& result = find_value(reply, \"result\");\n         const Value& error  = find_value(reply, \"error\");\n \n-        if (error.type() != null_type) {\n+        if (error.type() != null_type)\n+        {\n             // Error\n             strPrint = \"error: \" + write_string(error, false);\n             int code = find_value(error.get_obj(), \"code\").get_int();\n             nRet = abs(code);\n-        } else {\n+        }\n+        else\n+        {\n             // Result\n             if (result.type() == null_type)\n+            {\n                 strPrint = \"\";\n+            }\n             else if (result.type() == str_type)\n+            {\n                 strPrint = result.get_str();\n+            }\n             else\n+            {\n                 strPrint = write_string(result, true);\n+            }\n         }\n     }\n-    catch (boost::thread_interrupted) {\n+    catch (boost::thread_interrupted)\n+    {\n         throw;\n     }\n-    catch (std::exception& e) {\n+    catch (std::exception& e)\n+    {\n         strPrint = string(\"error: \") + e.what();\n         nRet = EXIT_FAILURE;\n     }\n-    catch (...) {\n+    catch (...)\n+    {\n         PrintExceptionContinue(NULL, \"CommandLineRPC()\");\n         throw;\n     }\n \n-    if (strPrint != \"\") {\n+    if (strPrint != \"\")\n+    {\n         fprintf((nRet == 0 ? stdout : stderr), \"%s\\n\", strPrint.c_str());\n     }\n+\n     return nRet;\n }\n \n int main(int argc, char* argv[])\n {\n     SetupEnvironment();\n \n-    try {\n-        if(!AppInitRPC(argc, argv))\n+    try\n+    {\n+        if (!AppInitRPC(argc, argv))\n+        {\n             return EXIT_FAILURE;\n+        }\n     }\n-    catch (std::exception& e) {\n+    catch (std::exception& e)\n+    {\n         PrintExceptionContinue(&e, \"AppInitRPC()\");\n         return EXIT_FAILURE;\n-    } catch (...) {\n+    }\n+    catch (...)\n+    {\n         PrintExceptionContinue(NULL, \"AppInitRPC()\");\n         return EXIT_FAILURE;\n     }\n \n     int ret = EXIT_FAILURE;\n-    try {\n+    try\n+    {\n         ret = CommandLineRPC(argc, argv);\n     }\n-    catch (std::exception& e) {\n+    catch (std::exception& e)\n+    {\n         PrintExceptionContinue(&e, \"CommandLineRPC()\");\n-    } catch (...) {\n+    }\n+    catch (...)\n+    {\n         PrintExceptionContinue(NULL, \"CommandLineRPC()\");\n     }\n     return ret;\n }\n+"
      },
      {
        "sha": "8af62d41e73b428db48e6cd0ef70bc3a30311510",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 235,
        "deletions": 56,
        "changes": 291,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -22,7 +22,7 @@ using namespace std;\n using namespace boost::assign;\n \n static bool fCreateBlank;\n-static map<string,UniValue> registers;\n+static map<string, UniValue> registers;\n CClientUIInterface uiInterface;\n \n static bool AppInitRawTx(int argc, char* argv[])\n@@ -33,35 +33,36 @@ static bool AppInitRawTx(int argc, char* argv[])\n     ParseParameters(argc, argv);\n \n     // Check for -testnet or -regtest parameter (Params() calls are only valid after this clause)\n-    if (!SelectParamsFromCommandLine()) {\n+    if (!SelectParamsFromCommandLine())\n+    {\n         fprintf(stderr, \"Error: Invalid combination of -regtest and -testnet.\\n\");\n         return false;\n     }\n \n     fCreateBlank = GetBoolArg(\"-create\", false);\n \n-    if (argc<2 || mapArgs.count(\"-?\") || mapArgs.count(\"-help\"))\n+    if (argc < 2 || mapArgs.count(\"-?\") || mapArgs.count(\"-help\"))\n     {\n         // First part of help message is specific to this utility\n         std::string strUsage = _(\"Bitcoin Core bitcoin-tx utility version\") + \" \" + FormatFullVersion() + \"\\n\\n\" +\n             _(\"Usage:\") + \"\\n\" +\n-              \"  bitcoin-tx [options] <hex-tx> [commands]  \" + _(\"Update hex-encoded bitcoin transaction\") + \"\\n\" +\n-              \"  bitcoin-tx [options] -create [commands]   \" + _(\"Create hex-encoded bitcoin transaction\") + \"\\n\" +\n-              \"\\n\";\n+            \"  bitcoin-tx [options] <hex-tx> [commands]  \" + _(\"Update hex-encoded bitcoin transaction\") + \"\\n\" +\n+            \"  bitcoin-tx [options] -create [commands]   \" + _(\"Create hex-encoded bitcoin transaction\") + \"\\n\" +\n+            \"\\n\";\n \n         fprintf(stdout, \"%s\", strUsage.c_str());\n \n         strUsage = _(\"Options:\") + \"\\n\";\n         strUsage += \"  -?                      \" + _(\"This help message\") + \"\\n\";\n         strUsage += \"  -create                 \" + _(\"Create new, empty TX.\") + \"\\n\";\n         strUsage += \"  -json                   \" + _(\"Select JSON output\") + \"\\n\";\n-        strUsage += \"  -regtest                \" + _(\"Enter regression test mode, which uses a special chain in which blocks can be solved instantly.\") + \"\\n\";\n+        strUsage += \"  -regtest                \" + _(\n+            \"Enter regression test mode, which uses a special chain in which blocks can be solved instantly.\") + \"\\n\";\n         strUsage += \"  -testnet                \" + _(\"Use the test network\") + \"\\n\";\n         strUsage += \"\\n\";\n \n         fprintf(stdout, \"%s\", strUsage.c_str());\n \n-\n         strUsage = _(\"Commands:\") + \"\\n\";\n         strUsage += \"  delin=N                \" + _(\"Delete input N from TX\") + \"\\n\";\n         strUsage += \"  delout=N               \" + _(\"Delete output N from TX\") + \"\\n\";\n@@ -86,13 +87,16 @@ static bool AppInitRawTx(int argc, char* argv[])\n \n         return false;\n     }\n+\n     return true;\n }\n \n static void RegisterSetJson(const string& key, const string& rawJson)\n {\n     UniValue val;\n-    if (!val.read(rawJson)) {\n+\n+    if (!val.read(rawJson))\n+    {\n         string strErr = \"Cannot parse JSON for key \" + key;\n         throw runtime_error(strErr);\n     }\n@@ -104,10 +108,13 @@ static void RegisterSet(const string& strInput)\n {\n     // separate NAME:VALUE in string\n     size_t pos = strInput.find(':');\n+\n     if ((pos == string::npos) ||\n         (pos == 0) ||\n         (pos == (strInput.size() - 1)))\n+    {\n         throw runtime_error(\"Register input requires NAME:VALUE\");\n+    }\n \n     string key = strInput.substr(0, pos);\n     string valStr = strInput.substr(pos + 1, string::npos);\n@@ -119,32 +126,43 @@ static void RegisterLoad(const string& strInput)\n {\n     // separate NAME:FILENAME in string\n     size_t pos = strInput.find(':');\n+\n     if ((pos == string::npos) ||\n         (pos == 0) ||\n         (pos == (strInput.size() - 1)))\n+    {\n         throw runtime_error(\"Register load requires NAME:FILENAME\");\n+    }\n \n     string key = strInput.substr(0, pos);\n     string filename = strInput.substr(pos + 1, string::npos);\n \n-    FILE *f = fopen(filename.c_str(), \"r\");\n-    if (!f) {\n+    FILE* f = fopen(filename.c_str(), \"r\");\n+\n+    if (!f)\n+    {\n         string strErr = \"Cannot open file \" + filename;\n         throw runtime_error(strErr);\n     }\n \n     // load file chunks into one big buffer\n     string valStr;\n-    while ((!feof(f)) && (!ferror(f))) {\n+\n+    while ((!feof(f)) && (!ferror(f)))\n+    {\n         char buf[4096];\n         int bread = fread(buf, 1, sizeof(buf), f);\n+\n         if (bread <= 0)\n+        {\n             break;\n+        }\n \n         valStr.insert(valStr.size(), buf, bread);\n     }\n \n-    if (ferror(f)) {\n+    if (ferror(f))\n+    {\n         string strErr = \"Error reading file \" + filename;\n         throw runtime_error(strErr);\n     }\n@@ -158,17 +176,23 @@ static void RegisterLoad(const string& strInput)\n static void MutateTxVersion(CMutableTransaction& tx, const string& cmdVal)\n {\n     int64_t newVersion = atoi64(cmdVal);\n+\n     if (newVersion < 1 || newVersion > CTransaction::CURRENT_VERSION)\n+    {\n         throw runtime_error(\"Invalid TX version requested\");\n+    }\n \n     tx.nVersion = (int) newVersion;\n }\n \n static void MutateTxLocktime(CMutableTransaction& tx, const string& cmdVal)\n {\n     int64_t newLocktime = atoi64(cmdVal);\n+\n     if (newLocktime < 0LL || newLocktime > 0xffffffffLL)\n+    {\n         throw runtime_error(\"Invalid TX locktime requested\");\n+    }\n \n     tx.nLockTime = (unsigned int) newLocktime;\n }\n@@ -177,15 +201,22 @@ static void MutateTxAddInput(CMutableTransaction& tx, const string& strInput)\n {\n     // separate TXID:VOUT in string\n     size_t pos = strInput.find(':');\n+\n     if ((pos == string::npos) ||\n         (pos == 0) ||\n         (pos == (strInput.size() - 1)))\n+    {\n         throw runtime_error(\"TX input missing separator\");\n+    }\n \n     // extract and validate TXID\n     string strTxid = strInput.substr(0, pos);\n+\n     if ((strTxid.size() != 64) || !IsHex(strTxid))\n+    {\n         throw runtime_error(\"invalid TX input txid\");\n+    }\n+\n     uint256 txid(strTxid);\n \n     static const unsigned int minTxOutSz = 9;\n@@ -194,8 +225,11 @@ static void MutateTxAddInput(CMutableTransaction& tx, const string& strInput)\n     // extract and validate vout\n     string strVout = strInput.substr(pos + 1, string::npos);\n     int vout = atoi(strVout);\n+\n     if ((vout < 0) || (vout > (int)maxVout))\n+    {\n         throw runtime_error(\"invalid TX input vout\");\n+    }\n \n     // append to transaction input list\n     CTxIn txin(txid, vout);\n@@ -206,22 +240,31 @@ static void MutateTxAddOutAddr(CMutableTransaction& tx, const string& strInput)\n {\n     // separate VALUE:ADDRESS in string\n     size_t pos = strInput.find(':');\n+\n     if ((pos == string::npos) ||\n         (pos == 0) ||\n         (pos == (strInput.size() - 1)))\n+    {\n         throw runtime_error(\"TX output missing separator\");\n+    }\n \n     // extract and validate VALUE\n     string strValue = strInput.substr(0, pos);\n     int64_t value;\n+\n     if (!ParseMoney(strValue, value))\n+    {\n         throw runtime_error(\"invalid TX output value\");\n+    }\n \n     // extract and validate ADDRESS\n     string strAddr = strInput.substr(pos + 1, string::npos);\n     CBitcoinAddress addr(strAddr);\n+\n     if (!addr.IsValid())\n+    {\n         throw runtime_error(\"invalid TX output address\");\n+    }\n \n     // build standard output script via SetDestination()\n     CScript scriptPubKey;\n@@ -236,16 +279,22 @@ static void MutateTxAddOutScript(CMutableTransaction& tx, const string& strInput\n {\n     // separate VALUE:SCRIPT in string\n     size_t pos = strInput.find(':');\n+\n     if ((pos == string::npos) ||\n         (pos == 0) ||\n         (pos == (strInput.size() - 1)))\n+    {\n         throw runtime_error(\"TX output missing separator\");\n+    }\n \n     // extract and validate VALUE\n     string strValue = strInput.substr(0, pos);\n     int64_t value;\n+\n     if (!ParseMoney(strValue, value))\n+    {\n         throw runtime_error(\"invalid TX output value\");\n+    }\n \n     // extract and validate script\n     string strScript = strInput.substr(pos + 1, string::npos);\n@@ -260,7 +309,9 @@ static void MutateTxDelInput(CMutableTransaction& tx, const string& strInIdx)\n {\n     // parse requested deletion index\n     int inIdx = atoi(strInIdx);\n-    if (inIdx < 0 || inIdx >= (int)tx.vin.size()) {\n+\n+    if (inIdx < 0 || inIdx >= (int)tx.vin.size())\n+    {\n         string strErr = \"Invalid TX input index '\" + strInIdx + \"'\";\n         throw runtime_error(strErr.c_str());\n     }\n@@ -273,7 +324,9 @@ static void MutateTxDelOutput(CMutableTransaction& tx, const string& strOutIdx)\n {\n     // parse requested deletion index\n     int outIdx = atoi(strOutIdx);\n-    if (outIdx < 0 || outIdx >= (int)tx.vout.size()) {\n+\n+    if (outIdx < 0 || outIdx >= (int)tx.vout.size())\n+    {\n         string strErr = \"Invalid TX output index '\" + strOutIdx + \"'\";\n         throw runtime_error(strErr.c_str());\n     }\n@@ -283,24 +336,27 @@ static void MutateTxDelOutput(CMutableTransaction& tx, const string& strOutIdx)\n }\n \n static const unsigned int N_SIGHASH_OPTS = 6;\n-static const struct {\n-    const char *flagStr;\n+static const struct\n+{\n+    const char* flagStr;\n     int flags;\n } sighashOptions[N_SIGHASH_OPTS] = {\n     {\"ALL\", SIGHASH_ALL},\n     {\"NONE\", SIGHASH_NONE},\n     {\"SINGLE\", SIGHASH_SINGLE},\n-    {\"ALL|ANYONECANPAY\", SIGHASH_ALL|SIGHASH_ANYONECANPAY},\n-    {\"NONE|ANYONECANPAY\", SIGHASH_NONE|SIGHASH_ANYONECANPAY},\n-    {\"SINGLE|ANYONECANPAY\", SIGHASH_SINGLE|SIGHASH_ANYONECANPAY},\n+    {\"ALL|ANYONECANPAY\", SIGHASH_ALL | SIGHASH_ANYONECANPAY},\n+    {\"NONE|ANYONECANPAY\", SIGHASH_NONE | SIGHASH_ANYONECANPAY},\n+    {\"SINGLE|ANYONECANPAY\", SIGHASH_SINGLE | SIGHASH_ANYONECANPAY},\n };\n \n static bool findSighashFlags(int& flags, const string& flagStr)\n {\n     flags = 0;\n \n-    for (unsigned int i = 0; i < N_SIGHASH_OPTS; i++) {\n-        if (flagStr == sighashOptions[i].flagStr) {\n+    for (unsigned int i = 0; i < N_SIGHASH_OPTS; i++)\n+    {\n+        if (flagStr == sighashOptions[i].flagStr)\n+        {\n             flags = sighashOptions[i].flags;\n             return true;\n         }\n@@ -309,19 +365,24 @@ static bool findSighashFlags(int& flags, const string& flagStr)\n     return false;\n }\n \n-uint256 ParseHashUO(map<string,UniValue>& o, string strKey)\n+uint256 ParseHashUO(map<string, UniValue>& o, string strKey)\n {\n     if (!o.count(strKey))\n+    {\n         return 0;\n+    }\n+\n     return ParseHashUV(o[strKey], strKey);\n }\n \n-vector<unsigned char> ParseHexUO(map<string,UniValue>& o, string strKey)\n+vector<unsigned char> ParseHexUO(map<string, UniValue>& o, string strKey)\n {\n-    if (!o.count(strKey)) {\n+    if (!o.count(strKey))\n+    {\n         vector<unsigned char> emptyVec;\n         return emptyVec;\n     }\n+\n     return ParseHexUV(o[strKey], strKey);\n }\n \n@@ -330,8 +391,12 @@ static void MutateTxSign(CMutableTransaction& tx, const string& flagStr)\n     int nHashType = SIGHASH_ALL;\n \n     if (flagStr.size() > 0)\n+    {\n         if (!findSighashFlags(nHashType, flagStr))\n+        {\n             throw runtime_error(\"unknown sighash flag/sign option\");\n+        }\n+    }\n \n     vector<CTransaction> txVariants;\n     txVariants.push_back(tx);\n@@ -344,67 +409,101 @@ static void MutateTxSign(CMutableTransaction& tx, const string& flagStr)\n     CCoinsViewCache view(viewDummy);\n \n     if (!registers.count(\"privatekeys\"))\n+    {\n         throw runtime_error(\"privatekeys register variable must be set.\");\n+    }\n+\n     bool fGivenKeys = false;\n     CBasicKeyStore tempKeystore;\n     UniValue keysObj = registers[\"privatekeys\"];\n     fGivenKeys = true;\n \n-    for (unsigned int kidx = 0; kidx < keysObj.count(); kidx++) {\n+    for (unsigned int kidx = 0; kidx < keysObj.count(); kidx++)\n+    {\n         if (!keysObj[kidx].isStr())\n+        {\n             throw runtime_error(\"privatekey not a string\");\n+        }\n+\n         CBitcoinSecret vchSecret;\n         bool fGood = vchSecret.SetString(keysObj[kidx].getValStr());\n+\n         if (!fGood)\n+        {\n             throw runtime_error(\"privatekey not valid\");\n+        }\n \n         CKey key = vchSecret.GetKey();\n         tempKeystore.AddKey(key);\n     }\n \n     // Add previous txouts given in the RPC call:\n     if (!registers.count(\"prevtxs\"))\n+    {\n         throw runtime_error(\"prevtxs register variable must be set.\");\n+    }\n+\n     UniValue prevtxsObj = registers[\"privatekeys\"];\n     {\n-        for (unsigned int previdx = 0; previdx < prevtxsObj.count(); previdx++) {\n+        for (unsigned int previdx = 0; previdx < prevtxsObj.count(); previdx++)\n+        {\n             UniValue prevOut = prevtxsObj[previdx];\n+\n             if (!prevOut.isObject())\n+            {\n                 throw runtime_error(\"expected prevtxs internal object\");\n+            }\n+\n+            map<string,\n+                UniValue::VType> types =\n+                map_list_of(\"txid\", UniValue::VSTR) (\"vout\", UniValue::VNUM) (\"scriptPubKey\", UniValue::VSTR);\n \n-            map<string,UniValue::VType> types = map_list_of(\"txid\", UniValue::VSTR)(\"vout\",UniValue::VNUM)(\"scriptPubKey\",UniValue::VSTR);\n             if (!prevOut.checkObject(types))\n+            {\n                 throw runtime_error(\"prevtxs internal object typecheck fail\");\n+            }\n \n             uint256 txid = ParseHashUV(prevOut, \"txid\");\n \n             int nOut = atoi(prevOut[\"vout\"].getValStr());\n+\n             if (nOut < 0)\n+            {\n                 throw runtime_error(\"vout must be positive\");\n+            }\n \n             vector<unsigned char> pkData(ParseHexUV(prevOut, \"scriptPubKey\"));\n             CScript scriptPubKey(pkData.begin(), pkData.end());\n \n             CCoins coins;\n-            if (view.GetCoins(txid, coins)) {\n-                if (coins.IsAvailable(nOut) && coins.vout[nOut].scriptPubKey != scriptPubKey) {\n+\n+            if (view.GetCoins(txid, coins))\n+            {\n+                if (coins.IsAvailable(nOut) && coins.vout[nOut].scriptPubKey != scriptPubKey)\n+                {\n                     string err(\"Previous output scriptPubKey mismatch:\\n\");\n-                    err = err + coins.vout[nOut].scriptPubKey.ToString() + \"\\nvs:\\n\"+\n+                    err = err + coins.vout[nOut].scriptPubKey.ToString() + \"\\nvs:\\n\" +\n                         scriptPubKey.ToString();\n                     throw runtime_error(err);\n                 }\n+\n                 // what todo if txid is known, but the actual output isn't?\n             }\n+\n             if ((unsigned int)nOut >= coins.vout.size())\n-                coins.vout.resize(nOut+1);\n+            {\n+                coins.vout.resize(nOut + 1);\n+            }\n+\n             coins.vout[nOut].scriptPubKey = scriptPubKey;\n             coins.vout[nOut].nValue = 0; // we don't know the actual output value\n             view.SetCoins(txid, coins);\n \n             // if redeemScript given and private keys given,\n             // add redeemScript to the tempKeystore so it can be signed:\n             if (fGivenKeys && scriptPubKey.IsPayToScriptHash() &&\n-                prevOut.exists(\"redeemScript\")) {\n+                prevOut.exists(\"redeemScript\"))\n+            {\n                 UniValue v = prevOut[\"redeemScript\"];\n                 vector<unsigned char> rsData(ParseHexUV(v, \"redeemScript\"));\n                 CScript redeemScript(rsData.begin(), rsData.end());\n@@ -418,29 +517,41 @@ static void MutateTxSign(CMutableTransaction& tx, const string& flagStr)\n     bool fHashSingle = ((nHashType & ~SIGHASH_ANYONECANPAY) == SIGHASH_SINGLE);\n \n     // Sign what we can:\n-    for (unsigned int i = 0; i < mergedTx.vin.size(); i++) {\n+    for (unsigned int i = 0; i < mergedTx.vin.size(); i++)\n+    {\n         CTxIn& txin = mergedTx.vin[i];\n         const CCoins* coins = view.AccessCoins(txin.prevout.hash);\n-        if (!coins || !coins->IsAvailable(txin.prevout.n)) {\n+\n+        if (!coins || !coins->IsAvailable(txin.prevout.n))\n+        {\n             fComplete = false;\n             continue;\n         }\n+\n         const CScript& prevPubKey = coins->vout[txin.prevout.n].scriptPubKey;\n \n         txin.scriptSig.clear();\n+\n         // Only sign SIGHASH_SINGLE if there's a corresponding output:\n         if (!fHashSingle || (i < mergedTx.vout.size()))\n+        {\n             SignSignature(keystore, prevPubKey, mergedTx, i, nHashType);\n+        }\n \n         // ... and merge in other signatures:\n-        BOOST_FOREACH(const CTransaction& txv, txVariants) {\n+        BOOST_FOREACH (const CTransaction& txv, txVariants)\n+        {\n             txin.scriptSig = CombineSignatures(prevPubKey, mergedTx, i, txin.scriptSig, txv.vin[i].scriptSig);\n         }\n+\n         if (!VerifyScript(txin.scriptSig, prevPubKey, mergedTx, i, STANDARD_SCRIPT_VERIFY_FLAGS, 0))\n+        {\n             fComplete = false;\n+        }\n     }\n \n-    if (fComplete) {\n+    if (fComplete)\n+    {\n         // do nothing... for now\n         // perhaps store this for later optional JSON output\n     }\n@@ -449,41 +560,64 @@ static void MutateTxSign(CMutableTransaction& tx, const string& flagStr)\n }\n \n static void MutateTx(CMutableTransaction& tx, const string& command,\n-                     const string& commandVal)\n+    const string& commandVal)\n {\n     if (command == \"nversion\")\n+    {\n         MutateTxVersion(tx, commandVal);\n+    }\n     else if (command == \"locktime\")\n+    {\n         MutateTxLocktime(tx, commandVal);\n+    }\n \n     else if (command == \"delin\")\n+    {\n         MutateTxDelInput(tx, commandVal);\n+    }\n     else if (command == \"in\")\n+    {\n         MutateTxAddInput(tx, commandVal);\n+    }\n \n     else if (command == \"delout\")\n+    {\n         MutateTxDelOutput(tx, commandVal);\n+    }\n     else if (command == \"outaddr\")\n+    {\n         MutateTxAddOutAddr(tx, commandVal);\n+    }\n     else if (command == \"outscript\")\n+    {\n         MutateTxAddOutScript(tx, commandVal);\n+    }\n \n     else if (command == \"sign\")\n+    {\n         MutateTxSign(tx, commandVal);\n+    }\n \n     else if (command == \"load\")\n+    {\n         RegisterLoad(commandVal);\n+    }\n \n     else if (command == \"set\")\n+    {\n         RegisterSet(commandVal);\n+    }\n \n     else\n+    {\n         throw runtime_error(\"unknown command\");\n+    }\n }\n \n static void OutputTxJSON(const CTransaction& tx)\n {\n     UniValue entry(UniValue::VOBJ);\n+\n     TxToUniv(tx, 0, entry);\n \n     string jsonOutput = entry.write(4);\n@@ -500,25 +634,35 @@ static void OutputTxHex(const CTransaction& tx)\n static void OutputTx(const CTransaction& tx)\n {\n     if (GetBoolArg(\"-json\", false))\n+    {\n         OutputTxJSON(tx);\n+    }\n     else\n+    {\n         OutputTxHex(tx);\n+    }\n }\n \n static string readStdin()\n {\n     char buf[4096];\n     string ret;\n \n-    while (!feof(stdin)) {\n+    while (!feof(stdin))\n+    {\n         size_t bread = fread(buf, 1, sizeof(buf), stdin);\n         ret.append(buf, bread);\n+\n         if (bread < sizeof(buf))\n+        {\n             break;\n+        }\n     }\n \n     if (ferror(stdin))\n+    {\n         throw runtime_error(\"error reading stdin\");\n+    }\n \n     boost::algorithm::trim_right(ret);\n \n@@ -529,43 +673,62 @@ static int CommandLineRawTx(int argc, char* argv[])\n {\n     string strPrint;\n     int nRet = 0;\n-    try {\n+\n+    try\n+    {\n         // Skip switches; Permit common stdin convention \"-\"\n         while (argc > 1 && IsSwitchChar(argv[1][0]) &&\n-               (argv[1][1] != 0)) {\n+            (argv[1][1] != 0))\n+        {\n             argc--;\n             argv++;\n         }\n \n         CTransaction txDecodeTmp;\n         int startArg;\n \n-        if (!fCreateBlank) {\n+        if (!fCreateBlank)\n+        {\n             // require at least one param\n             if (argc < 2)\n+            {\n                 throw runtime_error(\"too few parameters\");\n+            }\n \n             // param: hex-encoded bitcoin transaction\n             string strHexTx(argv[1]);\n+\n             if (strHexTx == \"-\")                 // \"-\" implies standard input\n+            {\n                 strHexTx = readStdin();\n+            }\n \n             if (!DecodeHexTx(txDecodeTmp, strHexTx))\n+            {\n                 throw runtime_error(\"invalid transaction encoding\");\n+            }\n \n             startArg = 2;\n-        } else\n+        }\n+        else\n+        {\n             startArg = 1;\n+        }\n \n         CMutableTransaction tx(txDecodeTmp);\n \n-        for (int i = startArg; i < argc; i++) {\n+        for (int i = startArg; i < argc; i++)\n+        {\n             string arg = argv[i];\n             string key, value;\n             size_t eqpos = arg.find('=');\n+\n             if (eqpos == string::npos)\n+            {\n                 key = arg;\n-            else {\n+            }\n+            else\n+            {\n                 key = arg.substr(0, eqpos);\n                 value = arg.substr(eqpos + 1);\n             }\n@@ -576,48 +739,64 @@ static int CommandLineRawTx(int argc, char* argv[])\n         OutputTx(tx);\n     }\n \n-    catch (boost::thread_interrupted) {\n+    catch (boost::thread_interrupted)\n+    {\n         throw;\n     }\n-    catch (std::exception& e) {\n+    catch (std::exception& e)\n+    {\n         strPrint = string(\"error: \") + e.what();\n         nRet = EXIT_FAILURE;\n     }\n-    catch (...) {\n+    catch (...)\n+    {\n         PrintExceptionContinue(NULL, \"CommandLineRawTx()\");\n         throw;\n     }\n \n-    if (strPrint != \"\") {\n+    if (strPrint != \"\")\n+    {\n         fprintf((nRet == 0 ? stdout : stderr), \"%s\\n\", strPrint.c_str());\n     }\n+\n     return nRet;\n }\n \n int main(int argc, char* argv[])\n {\n     SetupEnvironment();\n \n-    try {\n-        if(!AppInitRawTx(argc, argv))\n+    try\n+    {\n+        if (!AppInitRawTx(argc, argv))\n+        {\n             return EXIT_FAILURE;\n+        }\n     }\n-    catch (std::exception& e) {\n+    catch (std::exception& e)\n+    {\n         PrintExceptionContinue(&e, \"AppInitRawTx()\");\n         return EXIT_FAILURE;\n-    } catch (...) {\n+    }\n+    catch (...)\n+    {\n         PrintExceptionContinue(NULL, \"AppInitRawTx()\");\n         return EXIT_FAILURE;\n     }\n \n     int ret = EXIT_FAILURE;\n-    try {\n+    try\n+    {\n         ret = CommandLineRawTx(argc, argv);\n     }\n-    catch (std::exception& e) {\n+    catch (std::exception& e)\n+    {\n         PrintExceptionContinue(&e, \"CommandLineRawTx()\");\n-    } catch (...) {\n+    }\n+    catch (...)\n+    {\n         PrintExceptionContinue(NULL, \"CommandLineRawTx()\");\n     }\n     return ret;\n }\n+"
      },
      {
        "sha": "19021c6ed1c0ea86e7e877fb20016cfee21f108a",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 39,
        "deletions": 7,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -35,12 +35,14 @@ static bool fDaemon;\n void DetectShutdownThread(boost::thread_group* threadGroup)\n {\n     bool fShutdown = ShutdownRequested();\n+\n     // Tell the main threads to shutdown.\n     while (!fShutdown)\n     {\n         MilliSleep(200);\n         fShutdown = ShutdownRequested();\n     }\n+\n     if (threadGroup)\n     {\n         threadGroup->interrupt_all();\n@@ -58,27 +60,34 @@ bool AppInit(int argc, char* argv[])\n     boost::thread* detectShutdownThread = NULL;\n \n     bool fRet = false;\n+\n     try\n     {\n         //\n         // Parameters\n         //\n         // If Qt is used, parameters/bitcoin.conf are parsed in qt/bitcoin.cpp's main()\n         ParseParameters(argc, argv);\n+\n         if (!boost::filesystem::is_directory(GetDataDir(false)))\n         {\n             fprintf(stderr, \"Error: Specified data directory \\\"%s\\\" does not exist.\\n\", mapArgs[\"-datadir\"].c_str());\n             return false;\n         }\n+\n         try\n         {\n             ReadConfigFile(mapArgs, mapMultiArgs);\n-        } catch(std::exception &e) {\n-            fprintf(stderr,\"Error reading configuration file: %s\\n\", e.what());\n+        }\n+        catch (std::exception &e)\n+        {\n+            fprintf(stderr, \"Error reading configuration file: %s\\n\", e.what());\n             return false;\n         }\n+\n         // Check for -testnet or -regtest parameter (Params() calls are only valid after this clause)\n-        if (!SelectParamsFromCommandLine()) {\n+        if (!SelectParamsFromCommandLine())\n+        {\n             fprintf(stderr, \"Error: Invalid combination of -regtest and -testnet.\\n\");\n             return false;\n         }\n@@ -94,7 +103,7 @@ bool AppInit(int argc, char* argv[])\n             else\n             {\n                 strUsage += \"\\n\" + _(\"Usage:\") + \"\\n\" +\n-                      \"  bitcoind [options]                     \" + _(\"Start Bitcoin Core Daemon\") + \"\\n\";\n+                    \"  bitcoind [options]                     \" + _(\"Start Bitcoin Core Daemon\") + \"\\n\";\n \n                 strUsage += \"\\n\" + HelpMessage(HMM_BITCOIND);\n             }\n@@ -105,55 +114,76 @@ bool AppInit(int argc, char* argv[])\n \n         // Command-line RPC\n         bool fCommandLine = false;\n+\n         for (int i = 1; i < argc; i++)\n+        {\n             if (!IsSwitchChar(argv[i][0]) && !boost::algorithm::istarts_with(argv[i], \"bitcoin:\"))\n+            {\n                 fCommandLine = true;\n+            }\n+        }\n \n         if (fCommandLine)\n         {\n-            fprintf(stderr, \"Error: There is no RPC client functionality in bitcoind anymore. Use the bitcoin-cli utility instead.\\n\");\n+            fprintf(\n+                stderr,\n+                \"Error: There is no RPC client functionality in bitcoind anymore. Use the bitcoin-cli utility instead.\\n\");\n             exit(1);\n         }\n+\n #ifndef WIN32\n         fDaemon = GetBoolArg(\"-daemon\", false);\n+\n         if (fDaemon)\n         {\n             fprintf(stdout, \"Bitcoin server starting\\n\");\n \n             // Daemonize\n             pid_t pid = fork();\n+\n             if (pid < 0)\n             {\n                 fprintf(stderr, \"Error: fork() returned %d errno %d\\n\", pid, errno);\n                 return false;\n             }\n+\n             if (pid > 0) // Parent process, pid is child process id\n             {\n                 CreatePidFile(GetPidFile(), pid);\n                 return true;\n             }\n+\n             // Child process falls through to rest of initialization\n \n             pid_t sid = setsid();\n+\n             if (sid < 0)\n+            {\n                 fprintf(stderr, \"Error: setsid() returned %d errno %d\\n\", sid, errno);\n+            }\n         }\n+\n #endif\n         SoftSetBoolArg(\"-server\", true);\n \n         detectShutdownThread = new boost::thread(boost::bind(&DetectShutdownThread, &threadGroup));\n         fRet = AppInit2(threadGroup);\n     }\n-    catch (std::exception& e) {\n+    catch (std::exception& e)\n+    {\n         PrintExceptionContinue(&e, \"AppInit()\");\n-    } catch (...) {\n+    }\n+    catch (...)\n+    {\n         PrintExceptionContinue(NULL, \"AppInit()\");\n     }\n \n     if (!fRet)\n     {\n         if (detectShutdownThread)\n+        {\n             detectShutdownThread->interrupt();\n+        }\n \n         threadGroup.interrupt_all();\n         // threadGroup.join_all(); was left out intentionally here, because we didn't re-test all of\n@@ -167,6 +197,7 @@ bool AppInit(int argc, char* argv[])\n         delete detectShutdownThread;\n         detectShutdownThread = NULL;\n     }\n+\n     Shutdown();\n \n     return fRet;\n@@ -181,3 +212,4 @@ int main(int argc, char* argv[])\n \n     return (AppInit(argc, argv) ? 0 : 1);\n }\n+"
      },
      {
        "sha": "390263a6db831e2dd46e8f15959e977e0f93f344",
        "filename": "src/bloom.cpp",
        "status": "modified",
        "additions": 62,
        "deletions": 10,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/bloom.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/bloom.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -22,15 +22,15 @@ CBloomFilter::CBloomFilter(unsigned int nElements, double nFPRate, unsigned int\n // The ideal size for a bloom filter with a given number of elements and false positive rate is:\n // - nElements * log(fp rate) / ln(2)^2\n // We ignore filter parameters which will create a bloom filter larger than the protocol limits\n-vData(min((unsigned int)(-1  / LN2SQUARED * nElements * log(nFPRate)), MAX_BLOOM_FILTER_SIZE * 8) / 8),\n+    vData(min((unsigned int)(-1 / LN2SQUARED * nElements * log(nFPRate)), MAX_BLOOM_FILTER_SIZE * 8) / 8),\n // The ideal number of hash functions is filter size * ln(2) / number of elements\n // Again, we ignore filter parameters which will create a bloom filter with more hash functions than the protocol limits\n // See http://en.wikipedia.org/wiki/Bloom_filter for an explanation of these formulas\n-isFull(false),\n-isEmpty(false),\n-nHashFuncs(min((unsigned int)(vData.size() * 8 / nElements * LN2), MAX_HASH_FUNCS)),\n-nTweak(nTweakIn),\n-nFlags(nFlagsIn)\n+    isFull(false),\n+    isEmpty(false),\n+    nHashFuncs(min((unsigned int)(vData.size() * 8 / nElements * LN2), MAX_HASH_FUNCS)),\n+    nTweak(nTweakIn),\n+    nFlags(nFlagsIn)\n {\n }\n \n@@ -43,19 +43,24 @@ inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<\n void CBloomFilter::insert(const vector<unsigned char>& vKey)\n {\n     if (isFull)\n+    {\n         return;\n+    }\n+\n     for (unsigned int i = 0; i < nHashFuncs; i++)\n     {\n         unsigned int nIndex = Hash(i, vKey);\n         // Sets bit nIndex of vData\n         vData[nIndex >> 3] |= (1 << (7 & nIndex));\n     }\n+\n     isEmpty = false;\n }\n \n void CBloomFilter::insert(const COutPoint& outpoint)\n {\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+\n     stream << outpoint;\n     vector<unsigned char> data(stream.begin(), stream.end());\n     insert(data);\n@@ -70,22 +75,33 @@ void CBloomFilter::insert(const uint256& hash)\n bool CBloomFilter::contains(const vector<unsigned char>& vKey) const\n {\n     if (isFull)\n+    {\n         return true;\n+    }\n+\n     if (isEmpty)\n+    {\n         return false;\n+    }\n+\n     for (unsigned int i = 0; i < nHashFuncs; i++)\n     {\n         unsigned int nIndex = Hash(i, vKey);\n+\n         // Checks bit nIndex of vData\n         if (!(vData[nIndex >> 3] & (1 << (7 & nIndex))))\n+        {\n             return false;\n+        }\n     }\n+\n     return true;\n }\n \n bool CBloomFilter::contains(const COutPoint& outpoint) const\n {\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+\n     stream << outpoint;\n     vector<unsigned char> data(stream.begin(), stream.end());\n     return contains(data);\n@@ -99,7 +115,7 @@ bool CBloomFilter::contains(const uint256& hash) const\n \n void CBloomFilter::clear()\n {\n-    vData.assign(vData.size(),0);\n+    vData.assign(vData.size(), 0);\n     isFull = false;\n     isEmpty = true;\n }\n@@ -112,67 +128,100 @@ bool CBloomFilter::IsWithinSizeConstraints() const\n bool CBloomFilter::IsRelevantAndUpdate(const CTransaction& tx)\n {\n     bool fFound = false;\n+\n     // Match if the filter contains the hash of tx\n     //  for finding tx when they appear in a block\n     if (isFull)\n+    {\n         return true;\n+    }\n+\n     if (isEmpty)\n+    {\n         return false;\n+    }\n+\n     const uint256& hash = tx.GetHash();\n+\n     if (contains(hash))\n+    {\n         fFound = true;\n+    }\n \n     for (unsigned int i = 0; i < tx.vout.size(); i++)\n     {\n         const CTxOut& txout = tx.vout[i];\n         // Match if the filter contains any arbitrary script data element in any scriptPubKey in tx\n         // If this matches, also add the specific output that was matched.\n-        // This means clients don't have to update the filter themselves when a new relevant tx \n+        // This means clients don't have to update the filter themselves when a new relevant tx\n         // is discovered in order to find spending transactions, which avoids round-tripping and race conditions.\n         CScript::const_iterator pc = txout.scriptPubKey.begin();\n         vector<unsigned char> data;\n+\n         while (pc < txout.scriptPubKey.end())\n         {\n             opcodetype opcode;\n+\n             if (!txout.scriptPubKey.GetOp(pc, opcode, data))\n+            {\n                 break;\n+            }\n+\n             if (data.size() != 0 && contains(data))\n             {\n                 fFound = true;\n+\n                 if ((nFlags & BLOOM_UPDATE_MASK) == BLOOM_UPDATE_ALL)\n+                {\n                     insert(COutPoint(hash, i));\n+                }\n                 else if ((nFlags & BLOOM_UPDATE_MASK) == BLOOM_UPDATE_P2PUBKEY_ONLY)\n                 {\n                     txnouttype type;\n                     vector<vector<unsigned char> > vSolutions;\n+\n                     if (Solver(txout.scriptPubKey, type, vSolutions) &&\n-                            (type == TX_PUBKEY || type == TX_MULTISIG))\n+                        (type == TX_PUBKEY || type == TX_MULTISIG))\n+                    {\n                         insert(COutPoint(hash, i));\n+                    }\n                 }\n+\n                 break;\n             }\n         }\n     }\n \n     if (fFound)\n+    {\n         return true;\n+    }\n \n-    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+    BOOST_FOREACH (const CTxIn& txin, tx.vin)\n     {\n         // Match if the filter contains an outpoint tx spends\n         if (contains(txin.prevout))\n+        {\n             return true;\n+        }\n \n         // Match if the filter contains any arbitrary script data element in any scriptSig in tx\n         CScript::const_iterator pc = txin.scriptSig.begin();\n         vector<unsigned char> data;\n+\n         while (pc < txin.scriptSig.end())\n         {\n             opcodetype opcode;\n+\n             if (!txin.scriptSig.GetOp(pc, opcode, data))\n+            {\n                 break;\n+            }\n+\n             if (data.size() != 0 && contains(data))\n+            {\n                 return true;\n+            }\n         }\n     }\n \n@@ -183,11 +232,14 @@ void CBloomFilter::UpdateEmptyFull()\n {\n     bool full = true;\n     bool empty = true;\n+\n     for (unsigned int i = 0; i < vData.size(); i++)\n     {\n         full &= vData[i] == 0xff;\n         empty &= vData[i] == 0;\n     }\n+\n     isFull = full;\n     isEmpty = empty;\n }\n+"
      },
      {
        "sha": "bf9b9c9d55c32a9d90c7eaf0c4be744c45a21494",
        "filename": "src/bloom.h",
        "status": "modified",
        "additions": 9,
        "deletions": 5,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/bloom.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/bloom.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -31,11 +31,11 @@ enum bloomflags\n /**\n  * BloomFilter is a probabilistic filter which SPV clients provide\n  * so that we can filter the transactions we sends them.\n- * \n+ *\n  * This allows for significantly more efficient transaction and block downloads.\n- * \n+ *\n  * Because bloom filters are probabilistic, an SPV node can increase the false-\n- * positive rate, making us send them transactions which aren't actually theirs, \n+ * positive rate, making us send them transactions which aren't actually theirs,\n  * allowing clients to trade more bandwidth for more privacy by obfuscating which\n  * keys are owned by them.\n  */\n@@ -60,12 +60,15 @@ class CBloomFilter\n     // It should generally always be a random value (and is largely only exposed for unit testing)\n     // nFlags should be one of the BLOOM_UPDATE_* enums (not _MASK)\n     CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweak, unsigned char nFlagsIn);\n-    CBloomFilter() : isFull(true), isEmpty(false), nHashFuncs(0), nTweak(0), nFlags(0) {}\n+    CBloomFilter() : isFull(true), isEmpty(false), nHashFuncs(0), nTweak(0), nFlags(0)\n+    {\n+    }\n \n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n         READWRITE(vData);\n         READWRITE(nHashFuncs);\n         READWRITE(nTweak);\n@@ -94,3 +97,4 @@ class CBloomFilter\n };\n \n #endif // BITCOIN_BLOOM_H\n+"
      },
      {
        "sha": "abf55e03a3cef46fba90971931b4d0e5aa7c8114",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 55,
        "deletions": 34,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -15,7 +15,8 @@\n using namespace std;\n using namespace boost::assign;\n \n-struct SeedSpec6 {\n+struct SeedSpec6\n+{\n     uint8_t addr[16];\n     uint16_t port;\n };\n@@ -27,13 +28,14 @@ struct SeedSpec6 {\n //\n \n // Convert the pnSeeds6 array into usable address objects.\n-static void convertSeed6(std::vector<CAddress> &vSeedsOut, const SeedSpec6 *data, unsigned int count)\n+static void convertSeed6(std::vector<CAddress> &vSeedsOut, const SeedSpec6* data, unsigned int count)\n {\n     // It'll only connect to one or two seed nodes because once it connects,\n     // it'll get a pile of addresses with newer timestamps.\n     // Seed nodes are given a random 'last seen time' of between one and two\n     // weeks ago.\n-    const int64_t nOneWeek = 7*24*60*60;\n+    const int64_t nOneWeek = 7 * 24 * 60 * 60;\n+\n     for (unsigned int i = 0; i < count; i++)\n     {\n         struct in6_addr ip;\n@@ -44,9 +46,11 @@ static void convertSeed6(std::vector<CAddress> &vSeedsOut, const SeedSpec6 *data\n     }\n }\n \n-class CMainParams : public CChainParams {\n+class CMainParams : public CChainParams\n+{\n public:\n-    CMainParams() {\n+    CMainParams()\n+    {\n         networkID = CBaseChainParams::MAIN;\n         strNetworkID = \"main\";\n         // The message start string is designed to be unlikely to occur in normal data.\n@@ -56,7 +60,8 @@ class CMainParams : public CChainParams {\n         pchMessageStart[1] = 0xbe;\n         pchMessageStart[2] = 0xb4;\n         pchMessageStart[3] = 0xd9;\n-        vAlertPubKey = ParseHex(\"04fc9702847840aaf195de8442ebecedf5b095cdbb9bc716bda9110971b28a49e0ead8564ff0db22209e0374782c093bb899692d524e9d6a6956e7c5ecbcd68284\");\n+        vAlertPubKey = ParseHex(\n+            \"04fc9702847840aaf195de8442ebecedf5b095cdbb9bc716bda9110971b28a49e0ead8564ff0db22209e0374782c093bb899692d524e9d6a6956e7c5ecbcd68284\");\n         nDefaultPort = 8333;\n         bnProofOfWorkLimit = ~uint256(0) >> 32;\n         nSubsidyHalvingInterval = 210000;\n@@ -79,9 +84,12 @@ class CMainParams : public CChainParams {\n         CMutableTransaction txNew;\n         txNew.vin.resize(1);\n         txNew.vout.resize(1);\n-        txNew.vin[0].scriptSig = CScript() << 486604799 << CScriptNum(4) << vector<unsigned char>((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp));\n+        txNew.vin[0].scriptSig = CScript() << 486604799 << CScriptNum(4) << vector<unsigned char>(\n+            (const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp));\n         txNew.vout[0].nValue = 50 * COIN;\n-        txNew.vout[0].scriptPubKey = CScript() << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\") << OP_CHECKSIG;\n+        txNew.vout[0].scriptPubKey = CScript() << ParseHex(\n+            \"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\")\n+            << OP_CHECKSIG;\n         genesis.vtx.push_back(txNew);\n         genesis.hashPrevBlock = 0;\n         genesis.hashMerkleRoot = genesis.BuildMerkleTree();\n@@ -104,8 +112,8 @@ class CMainParams : public CChainParams {\n         base58Prefixes[PUBKEY_ADDRESS] = list_of(0);\n         base58Prefixes[SCRIPT_ADDRESS] = list_of(5);\n         base58Prefixes[SECRET_KEY] =     list_of(128);\n-        base58Prefixes[EXT_PUBLIC_KEY] = list_of(0x04)(0x88)(0xB2)(0x1E);\n-        base58Prefixes[EXT_SECRET_KEY] = list_of(0x04)(0x88)(0xAD)(0xE4);\n+        base58Prefixes[EXT_PUBLIC_KEY] = list_of(0x04) (0x88) (0xB2) (0x1E);\n+        base58Prefixes[EXT_SECRET_KEY] = list_of(0x04) (0x88) (0xAD) (0xE4);\n \n         convertSeed6(vFixedSeeds, pnSeed6_main, ARRAYLEN(pnSeed6_main));\n \n@@ -123,9 +131,11 @@ static CMainParams mainParams;\n // Testnet (v3)\n //\n \n-class CTestNetParams : public CMainParams {\n+class CTestNetParams : public CMainParams\n+{\n public:\n-    CTestNetParams() {\n+    CTestNetParams()\n+    {\n         networkID = CBaseChainParams::TESTNET;\n         strNetworkID = \"test\";\n         // The message start string is designed to be unlikely to occur in normal data.\n@@ -135,7 +145,8 @@ class CTestNetParams : public CMainParams {\n         pchMessageStart[1] = 0x11;\n         pchMessageStart[2] = 0x09;\n         pchMessageStart[3] = 0x07;\n-        vAlertPubKey = ParseHex(\"04302390343f91cc401d56d68b123028bf52e5fca1939df127f63c6467cdf9c8e2c14b61104cf817d0b780da337893ecc4aaff1309e536162dabbdb45200ca2b0a\");\n+        vAlertPubKey = ParseHex(\n+            \"04302390343f91cc401d56d68b123028bf52e5fca1939df127f63c6467cdf9c8e2c14b61104cf817d0b780da337893ecc4aaff1309e536162dabbdb45200ca2b0a\");\n         nDefaultPort = 18333;\n         nEnforceBlockUpgradeMajority = 51;\n         nRejectBlockOutdatedMajority = 75;\n@@ -160,8 +171,8 @@ class CTestNetParams : public CMainParams {\n         base58Prefixes[PUBKEY_ADDRESS] = list_of(111);\n         base58Prefixes[SCRIPT_ADDRESS] = list_of(196);\n         base58Prefixes[SECRET_KEY]     = list_of(239);\n-        base58Prefixes[EXT_PUBLIC_KEY] = list_of(0x04)(0x35)(0x87)(0xCF);\n-        base58Prefixes[EXT_SECRET_KEY] = list_of(0x04)(0x35)(0x83)(0x94);\n+        base58Prefixes[EXT_PUBLIC_KEY] = list_of(0x04) (0x35) (0x87) (0xCF);\n+        base58Prefixes[EXT_SECRET_KEY] = list_of(0x04) (0x35) (0x83) (0x94);\n \n         convertSeed6(vFixedSeeds, pnSeed6_test, ARRAYLEN(pnSeed6_test));\n \n@@ -178,9 +189,11 @@ static CTestNetParams testNetParams;\n //\n // Regression test\n //\n-class CRegTestParams : public CTestNetParams {\n+class CRegTestParams : public CTestNetParams\n+{\n public:\n-    CRegTestParams() {\n+    CRegTestParams()\n+    {\n         networkID = CBaseChainParams::REGTEST;\n         strNetworkID = \"regtest\";\n         pchMessageStart[0] = 0xfa;\n@@ -214,35 +227,43 @@ class CRegTestParams : public CTestNetParams {\n };\n static CRegTestParams regTestParams;\n \n-static CChainParams *pCurrentParams = 0;\n+static CChainParams* pCurrentParams = 0;\n \n-const CChainParams &Params() {\n+const CChainParams &Params()\n+{\n     assert(pCurrentParams);\n     return *pCurrentParams;\n }\n \n-void SelectParams(CBaseChainParams::Network network) {\n+void SelectParams(CBaseChainParams::Network network)\n+{\n     SelectBaseParams(network);\n-    switch (network) {\n-        case CBaseChainParams::MAIN:\n-            pCurrentParams = &mainParams;\n-            break;\n-        case CBaseChainParams::TESTNET:\n-            pCurrentParams = &testNetParams;\n-            break;\n-        case CBaseChainParams::REGTEST:\n-            pCurrentParams = &regTestParams;\n-            break;\n-        default:\n-            assert(false && \"Unimplemented network\");\n-            return;\n+\n+    switch (network)\n+    {\n+    case CBaseChainParams::MAIN:\n+        pCurrentParams = &mainParams;\n+        break;\n+    case CBaseChainParams::TESTNET:\n+        pCurrentParams = &testNetParams;\n+        break;\n+    case CBaseChainParams::REGTEST:\n+        pCurrentParams = &regTestParams;\n+        break;\n+    default:\n+        assert(false && \"Unimplemented network\");\n+        return;\n     }\n }\n \n-bool SelectParamsFromCommandLine() {\n+bool SelectParamsFromCommandLine()\n+{\n     if (!SelectBaseParamsFromCommandLine())\n+    {\n         return false;\n+    }\n \n     SelectParams(BaseParams().NetworkID());\n     return true;\n }\n+"
      },
      {
        "sha": "fee29bee0a1b45fe314ea3b9713ddbbd4f94645a",
        "filename": "src/chainparams.h",
        "status": "modified",
        "additions": 135,
        "deletions": 29,
        "changes": 164,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/chainparams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/chainparams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -15,9 +15,12 @@\n \n typedef unsigned char MessageStartChars[MESSAGE_START_SIZE];\n \n-struct CDNSSeedData {\n+struct CDNSSeedData\n+{\n     std::string name, host;\n-    CDNSSeedData(const std::string &strName, const std::string &strHost) : name(strName), host(strHost) {}\n+    CDNSSeedData(const std::string &strName, const std::string &strHost) : name(strName), host(strHost)\n+    {\n+    }\n };\n \n /**\n@@ -30,7 +33,8 @@ struct CDNSSeedData {\n class CChainParams\n {\n public:\n-    enum Base58Type {\n+    enum Base58Type\n+    {\n         PUBKEY_ADDRESS,\n         SCRIPT_ADDRESS,\n         SECRET_KEY,\n@@ -40,43 +44,144 @@ class CChainParams\n         MAX_BASE58_TYPES\n     };\n \n-    const uint256& HashGenesisBlock() const { return hashGenesisBlock; }\n-    const MessageStartChars& MessageStart() const { return pchMessageStart; }\n-    const std::vector<unsigned char>& AlertKey() const { return vAlertPubKey; }\n-    int GetDefaultPort() const { return nDefaultPort; }\n-    const uint256& ProofOfWorkLimit() const { return bnProofOfWorkLimit; }\n-    int SubsidyHalvingInterval() const { return nSubsidyHalvingInterval; }\n+    const uint256& HashGenesisBlock() const\n+    {\n+        return hashGenesisBlock;\n+    }\n+\n+    const MessageStartChars& MessageStart() const\n+    {\n+        return pchMessageStart;\n+    }\n+\n+    const std::vector<unsigned char>& AlertKey() const\n+    {\n+        return vAlertPubKey;\n+    }\n+\n+    int GetDefaultPort() const\n+    {\n+        return nDefaultPort;\n+    }\n+\n+    const uint256& ProofOfWorkLimit() const\n+    {\n+        return bnProofOfWorkLimit;\n+    }\n+\n+    int SubsidyHalvingInterval() const\n+    {\n+        return nSubsidyHalvingInterval;\n+    }\n+\n     /* Used to check majorities for block version upgrade */\n-    int EnforceBlockUpgradeMajority() const { return nEnforceBlockUpgradeMajority; }\n-    int RejectBlockOutdatedMajority() const { return nRejectBlockOutdatedMajority; }\n-    int ToCheckBlockUpgradeMajority() const { return nToCheckBlockUpgradeMajority; }\n+    int EnforceBlockUpgradeMajority() const\n+    {\n+        return nEnforceBlockUpgradeMajority;\n+    }\n+\n+    int RejectBlockOutdatedMajority() const\n+    {\n+        return nRejectBlockOutdatedMajority;\n+    }\n+\n+    int ToCheckBlockUpgradeMajority() const\n+    {\n+        return nToCheckBlockUpgradeMajority;\n+    }\n \n     /* Used if GenerateBitcoins is called with a negative number of threads */\n-    int DefaultMinerThreads() const { return nMinerThreads; }\n-    const CBlock& GenesisBlock() const { return genesis; }\n-    bool RequireRPCPassword() const { return fRequireRPCPassword; }\n+    int DefaultMinerThreads() const\n+    {\n+        return nMinerThreads;\n+    }\n+\n+    const CBlock& GenesisBlock() const\n+    {\n+        return genesis;\n+    }\n+\n+    bool RequireRPCPassword() const\n+    {\n+        return fRequireRPCPassword;\n+    }\n+\n     /* Make miner wait to have peers to avoid wasting work */\n-    bool MiningRequiresPeers() const { return fMiningRequiresPeers; }\n+    bool MiningRequiresPeers() const\n+    {\n+        return fMiningRequiresPeers;\n+    }\n+\n     /* Default value for -checkmempool argument */\n-    bool DefaultCheckMemPool() const { return fDefaultCheckMemPool; }\n+    bool DefaultCheckMemPool() const\n+    {\n+        return fDefaultCheckMemPool;\n+    }\n+\n     /* Allow mining of a min-difficulty block */\n-    bool AllowMinDifficultyBlocks() const { return fAllowMinDifficultyBlocks; }\n+    bool AllowMinDifficultyBlocks() const\n+    {\n+        return fAllowMinDifficultyBlocks;\n+    }\n+\n     /* Make standard checks */\n-    bool RequireStandard() const { return fRequireStandard; }\n-    int64_t TargetTimespan() const { return nTargetTimespan; }\n-    int64_t TargetSpacing() const { return nTargetSpacing; }\n-    int64_t Interval() const { return nTargetTimespan / nTargetSpacing; }\n+    bool RequireStandard() const\n+    {\n+        return fRequireStandard;\n+    }\n+\n+    int64_t TargetTimespan() const\n+    {\n+        return nTargetTimespan;\n+    }\n+\n+    int64_t TargetSpacing() const\n+    {\n+        return nTargetSpacing;\n+    }\n+\n+    int64_t Interval() const\n+    {\n+        return nTargetTimespan / nTargetSpacing;\n+    }\n+\n     /* Make miner stop after a block is found. In RPC, don't return\n      * until nGenProcLimit blocks are generated */\n-    bool MineBlocksOnDemand() const { return fMineBlocksOnDemand; }\n-    CBaseChainParams::Network NetworkID() const { return networkID; }\n+    bool MineBlocksOnDemand() const\n+    {\n+        return fMineBlocksOnDemand;\n+    }\n+\n+    CBaseChainParams::Network NetworkID() const\n+    {\n+        return networkID;\n+    }\n+\n     /* Return the BIP70 network string (main, test or regtest) */\n-    std::string NetworkIDString() const { return strNetworkID; }\n-    const std::vector<CDNSSeedData>& DNSSeeds() const { return vSeeds; }\n-    const std::vector<unsigned char>& Base58Prefix(Base58Type type) const { return base58Prefixes[type]; }\n-    const std::vector<CAddress>& FixedSeeds() const { return vFixedSeeds; }\n+    std::string NetworkIDString() const\n+    {\n+        return strNetworkID;\n+    }\n+\n+    const std::vector<CDNSSeedData>& DNSSeeds() const\n+    {\n+        return vSeeds;\n+    }\n+\n+    const std::vector<unsigned char>& Base58Prefix(Base58Type type) const\n+    {\n+        return base58Prefixes[type];\n+    }\n+\n+    const std::vector<CAddress>& FixedSeeds() const\n+    {\n+        return vFixedSeeds;\n+    }\n+\n protected:\n-    CChainParams() {}\n+    CChainParams()\n+    {\n+    }\n \n     uint256 hashGenesisBlock;\n     MessageStartChars pchMessageStart;\n@@ -121,3 +226,4 @@ void SelectParams(CBaseChainParams::Network network);\n bool SelectParamsFromCommandLine();\n \n #endif // BITCOIN_CHAIN_PARAMS_H\n+"
      },
      {
        "sha": "3fb5e564ae553ee57bc815cd81ec29393f4f29c7",
        "filename": "src/chainparamsbase.cpp",
        "status": "modified",
        "additions": 47,
        "deletions": 28,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/chainparamsbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/chainparamsbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsbase.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -17,9 +17,11 @@ using namespace boost::assign;\n // Main network\n //\n \n-class CBaseMainParams : public CBaseChainParams {\n+class CBaseMainParams : public CBaseChainParams\n+{\n public:\n-    CBaseMainParams() {\n+    CBaseMainParams()\n+    {\n         networkID = CBaseChainParams::MAIN;\n         nRPCPort = 8332;\n     }\n@@ -29,9 +31,11 @@ static CBaseMainParams mainParams;\n //\n // Testnet (v3)\n //\n-class CBaseTestNetParams : public CBaseMainParams {\n+class CBaseTestNetParams : public CBaseMainParams\n+{\n public:\n-    CBaseTestNetParams() {\n+    CBaseTestNetParams()\n+    {\n         networkID = CBaseChainParams::TESTNET;\n         nRPCPort = 18332;\n         strDataDir = \"testnet3\";\n@@ -42,57 +46,72 @@ static CBaseTestNetParams testNetParams;\n //\n // Regression test\n //\n-class CBaseRegTestParams : public CBaseTestNetParams {\n+class CBaseRegTestParams : public CBaseTestNetParams\n+{\n public:\n-    CBaseRegTestParams() {\n+    CBaseRegTestParams()\n+    {\n         networkID = CBaseChainParams::REGTEST;\n         strDataDir = \"regtest\";\n     }\n };\n static CBaseRegTestParams regTestParams;\n \n-static CBaseChainParams *pCurrentBaseParams = 0;\n+static CBaseChainParams* pCurrentBaseParams = 0;\n \n-const CBaseChainParams &BaseParams() {\n+const CBaseChainParams &BaseParams()\n+{\n     assert(pCurrentBaseParams);\n     return *pCurrentBaseParams;\n }\n \n-void SelectBaseParams(CBaseChainParams::Network network) {\n-    switch (network) {\n-        case CBaseChainParams::MAIN:\n-            pCurrentBaseParams = &mainParams;\n-            break;\n-        case CBaseChainParams::TESTNET:\n-            pCurrentBaseParams = &testNetParams;\n-            break;\n-        case CBaseChainParams::REGTEST:\n-            pCurrentBaseParams = &regTestParams;\n-            break;\n-        default:\n-            assert(false && \"Unimplemented network\");\n-            return;\n+void SelectBaseParams(CBaseChainParams::Network network)\n+{\n+    switch (network)\n+    {\n+    case CBaseChainParams::MAIN:\n+        pCurrentBaseParams = &mainParams;\n+        break;\n+    case CBaseChainParams::TESTNET:\n+        pCurrentBaseParams = &testNetParams;\n+        break;\n+    case CBaseChainParams::REGTEST:\n+        pCurrentBaseParams = &regTestParams;\n+        break;\n+    default:\n+        assert(false && \"Unimplemented network\");\n+        return;\n     }\n }\n \n-bool SelectBaseParamsFromCommandLine() {\n+bool SelectBaseParamsFromCommandLine()\n+{\n     bool fRegTest = GetBoolArg(\"-regtest\", false);\n     bool fTestNet = GetBoolArg(\"-testnet\", false);\n \n-    if (fTestNet && fRegTest) {\n+    if (fTestNet && fRegTest)\n+    {\n         return false;\n     }\n \n-    if (fRegTest) {\n+    if (fRegTest)\n+    {\n         SelectBaseParams(CBaseChainParams::REGTEST);\n-    } else if (fTestNet) {\n+    }\n+    else if (fTestNet)\n+    {\n         SelectBaseParams(CBaseChainParams::TESTNET);\n-    } else {\n+    }\n+    else\n+    {\n         SelectBaseParams(CBaseChainParams::MAIN);\n     }\n+\n     return true;\n }\n \n-bool AreBaseParamsConfigured() {\n+bool AreBaseParamsConfigured()\n+{\n     return pCurrentBaseParams != NULL;\n }\n+"
      },
      {
        "sha": "c4f1f5a36e2cd126f6158e961e7f156867709f68",
        "filename": "src/chainparamsbase.h",
        "status": "modified",
        "additions": 21,
        "deletions": 5,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/chainparamsbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/chainparamsbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsbase.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -15,19 +15,34 @@\n class CBaseChainParams\n {\n public:\n-    enum Network {\n+    enum Network\n+    {\n         MAIN,\n         TESTNET,\n         REGTEST,\n \n         MAX_NETWORK_TYPES\n     };\n \n-    const std::string& DataDir() const { return strDataDir; }\n-    int RPCPort() const { return nRPCPort; }\n-    Network NetworkID() const { return networkID; }\n+    const std::string& DataDir() const\n+    {\n+        return strDataDir;\n+    }\n+\n+    int RPCPort() const\n+    {\n+        return nRPCPort;\n+    }\n+\n+    Network NetworkID() const\n+    {\n+        return networkID;\n+    }\n+\n protected:\n-    CBaseChainParams() {}\n+    CBaseChainParams()\n+    {\n+    }\n \n     int nRPCPort;\n     std::string strDataDir;\n@@ -56,3 +71,4 @@ bool SelectBaseParamsFromCommandLine();\n bool AreBaseParamsConfigured();\n \n #endif // BITCOIN_CHAIN_PARAMS_BASE_H\n+"
      },
      {
        "sha": "09e3111cfe53e2453b9d2555c62d6d88d41e105c",
        "filename": "src/chainparamsseeds.h",
        "status": "modified",
        "additions": 1876,
        "deletions": 625,
        "changes": 2501,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/chainparamsseeds.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/chainparamsseeds.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsseeds.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "f9c477be0a50b1d2b712b85de0bd3c9dc34c90d2",
        "filename": "src/checkpoints.cpp",
        "status": "modified",
        "additions": 153,
        "deletions": 125,
        "changes": 278,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/checkpoints.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/checkpoints.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkpoints.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -12,155 +12,183 @@\n #include <boost/assign/list_of.hpp> // for 'map_list_of()'\n #include <boost/foreach.hpp>\n \n-namespace Checkpoints {\n-\n-    typedef std::map<int, uint256> MapCheckpoints;\n-\n-    // How many times we expect transactions after the last checkpoint to\n-    // be slower. This number is a compromise, as it can't be accurate for\n-    // every system. When reindexing from a fast disk with a slow CPU, it\n-    // can be up to 20, while when downloading from a slow network with a\n-    // fast multicore CPU, it won't be much higher than 1.\n-    static const double SIGCHECK_VERIFICATION_FACTOR = 5.0;\n-\n-    struct CCheckpointData {\n-        const MapCheckpoints *mapCheckpoints;\n-        int64_t nTimeLastCheckpoint;\n-        int64_t nTransactionsLastCheckpoint;\n-        double fTransactionsPerDay;\n-    };\n-\n-    bool fEnabled = true;\n-\n-    // What makes a good checkpoint block?\n-    // + Is surrounded by blocks with reasonable timestamps\n-    //   (no blocks before with a timestamp after, none after with\n-    //    timestamp before)\n-    // + Contains no strange transactions\n-    static MapCheckpoints mapCheckpoints =\n+namespace Checkpoints\n+{\n+typedef std::map<int, uint256> MapCheckpoints;\n+\n+// How many times we expect transactions after the last checkpoint to\n+// be slower. This number is a compromise, as it can't be accurate for\n+// every system. When reindexing from a fast disk with a slow CPU, it\n+// can be up to 20, while when downloading from a slow network with a\n+// fast multicore CPU, it won't be much higher than 1.\n+static const double SIGCHECK_VERIFICATION_FACTOR = 5.0;\n+\n+struct CCheckpointData\n+{\n+    const MapCheckpoints* mapCheckpoints;\n+    int64_t nTimeLastCheckpoint;\n+    int64_t nTransactionsLastCheckpoint;\n+    double fTransactionsPerDay;\n+};\n+\n+bool fEnabled = true;\n+\n+// What makes a good checkpoint block?\n+// + Is surrounded by blocks with reasonable timestamps\n+//   (no blocks before with a timestamp after, none after with\n+//    timestamp before)\n+// + Contains no strange transactions\n+static MapCheckpoints mapCheckpoints =\n         boost::assign::map_list_of\n-        ( 11111, uint256(\"0x0000000069e244f73d78e8fd29ba2fd2ed618bd6fa2ee92559f542fdb26e7c1d\"))\n-        ( 33333, uint256(\"0x000000002dd5588a74784eaa7ab0507a18ad16a236e7b1ce69f00d7ddfb5d0a6\"))\n-        ( 74000, uint256(\"0x0000000000573993a3c9e41ce34471c079dcf5f52a0e824a81e7f953b8661a20\"))\n-        (105000, uint256(\"0x00000000000291ce28027faea320c8d2b054b2e0fe44a773f3eefb151d6bdc97\"))\n-        (134444, uint256(\"0x00000000000005b12ffd4cd315cd34ffd4a594f430ac814c91184a0d42d2b0fe\"))\n-        (168000, uint256(\"0x000000000000099e61ea72015e79632f216fe6cb33d7899acb35b75c8303b763\"))\n-        (193000, uint256(\"0x000000000000059f452a5f7340de6682a977387c17010ff6e6c3bd83ca8b1317\"))\n-        (210000, uint256(\"0x000000000000048b95347e83192f69cf0366076336c639f9b7228e9ba171342e\"))\n-        (216116, uint256(\"0x00000000000001b4f4b433e81ee46494af945cf96014816a4e2370f11b23df4e\"))\n-        (225430, uint256(\"0x00000000000001c108384350f74090433e7fcf79a606b8e797f065b130575932\"))\n-        (250000, uint256(\"0x000000000000003887df1f29024b06fc2200b55f8af8f35453d7be294df2d214\"))\n-        (279000, uint256(\"0x0000000000000001ae8c72a0b0c301f67e3afca10e819efa9041e458e9bd7e40\"))\n-        (295000, uint256(\"0x00000000000000004d9b4ef50f0f9d686fd69db2e03af35a100370c64632a983\"))\n-        ;\n-    static const CCheckpointData data = {\n-        &mapCheckpoints,\n-        1397080064, // * UNIX timestamp of last checkpoint block\n-        36544669,   // * total number of transactions between genesis and last checkpoint\n+            ( 11111, uint256(\"0x0000000069e244f73d78e8fd29ba2fd2ed618bd6fa2ee92559f542fdb26e7c1d\"))\n+            ( 33333, uint256(\"0x000000002dd5588a74784eaa7ab0507a18ad16a236e7b1ce69f00d7ddfb5d0a6\"))\n+            ( 74000, uint256(\"0x0000000000573993a3c9e41ce34471c079dcf5f52a0e824a81e7f953b8661a20\"))\n+            (105000, uint256(\"0x00000000000291ce28027faea320c8d2b054b2e0fe44a773f3eefb151d6bdc97\"))\n+            (134444, uint256(\"0x00000000000005b12ffd4cd315cd34ffd4a594f430ac814c91184a0d42d2b0fe\"))\n+            (168000, uint256(\"0x000000000000099e61ea72015e79632f216fe6cb33d7899acb35b75c8303b763\"))\n+            (193000, uint256(\"0x000000000000059f452a5f7340de6682a977387c17010ff6e6c3bd83ca8b1317\"))\n+            (210000, uint256(\"0x000000000000048b95347e83192f69cf0366076336c639f9b7228e9ba171342e\"))\n+            (216116, uint256(\"0x00000000000001b4f4b433e81ee46494af945cf96014816a4e2370f11b23df4e\"))\n+            (225430, uint256(\"0x00000000000001c108384350f74090433e7fcf79a606b8e797f065b130575932\"))\n+            (250000, uint256(\"0x000000000000003887df1f29024b06fc2200b55f8af8f35453d7be294df2d214\"))\n+            (279000, uint256(\"0x0000000000000001ae8c72a0b0c301f67e3afca10e819efa9041e458e9bd7e40\"))\n+            (295000, uint256(\"0x00000000000000004d9b4ef50f0f9d686fd69db2e03af35a100370c64632a983\"))\n+;\n+static const CCheckpointData data = {\n+    &mapCheckpoints,\n+    1397080064,     // * UNIX timestamp of last checkpoint block\n+    36544669,       // * total number of transactions between genesis and last checkpoint\n                     //   (the tx=... number in the SetBestChain debug.log lines)\n-        60000.0     // * estimated number of transactions per day after checkpoint\n-    };\n+    60000.0         // * estimated number of transactions per day after checkpoint\n+};\n \n-    static MapCheckpoints mapCheckpointsTestnet =\n+static MapCheckpoints mapCheckpointsTestnet =\n         boost::assign::map_list_of\n-        ( 546, uint256(\"000000002a936ca763904c3c35fce2f3556c559c0214345d31b1bcebf76acb70\"))\n-        ;\n-    static const CCheckpointData dataTestnet = {\n-        &mapCheckpointsTestnet,\n-        1337966069,\n-        1488,\n-        300\n-    };\n-\n-    static MapCheckpoints mapCheckpointsRegtest =\n+            ( 546, uint256(\"000000002a936ca763904c3c35fce2f3556c559c0214345d31b1bcebf76acb70\"))\n+;\n+static const CCheckpointData dataTestnet = {\n+    &mapCheckpointsTestnet,\n+    1337966069,\n+    1488,\n+    300\n+};\n+\n+static MapCheckpoints mapCheckpointsRegtest =\n         boost::assign::map_list_of\n-        ( 0, uint256(\"0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\"))\n-        ;\n-    static const CCheckpointData dataRegtest = {\n-        &mapCheckpointsRegtest,\n-        0,\n-        0,\n-        0\n-    };\n-\n-    const CCheckpointData &Checkpoints() {\n-        if (Params().NetworkID() == CBaseChainParams::TESTNET)\n-            return dataTestnet;\n-        else if (Params().NetworkID() == CBaseChainParams::MAIN)\n-            return data;\n-        else\n-            return dataRegtest;\n+            ( 0, uint256(\"0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\"))\n+;\n+static const CCheckpointData dataRegtest = {\n+    &mapCheckpointsRegtest,\n+    0,\n+    0,\n+    0\n+};\n+\n+const CCheckpointData &Checkpoints()\n+{\n+    if (Params().NetworkID() == CBaseChainParams::TESTNET)\n+    {\n+        return dataTestnet;\n+    }\n+    else if (Params().NetworkID() == CBaseChainParams::MAIN)\n+    {\n+        return data;\n     }\n+    else\n+    {\n+        return dataRegtest;\n+    }\n+}\n \n-    bool CheckBlock(int nHeight, const uint256& hash)\n+bool CheckBlock(int nHeight, const uint256& hash)\n+{\n+    if (!fEnabled)\n     {\n-        if (!fEnabled)\n-            return true;\n+        return true;\n+    }\n+\n+    const MapCheckpoints& checkpoints = *Checkpoints().mapCheckpoints;\n \n-        const MapCheckpoints& checkpoints = *Checkpoints().mapCheckpoints;\n+    MapCheckpoints::const_iterator i = checkpoints.find(nHeight);\n \n-        MapCheckpoints::const_iterator i = checkpoints.find(nHeight);\n-        if (i == checkpoints.end()) return true;\n-        return hash == i->second;\n+    if (i == checkpoints.end())\n+    {\n+        return true;\n     }\n \n-    // Guess how far we are in the verification process at the given block index\n-    double GuessVerificationProgress(CBlockIndex *pindex, bool fSigchecks) {\n-        if (pindex==NULL)\n-            return 0.0;\n-\n-        int64_t nNow = time(NULL);\n-\n-        double fSigcheckVerificationFactor = fSigchecks ? SIGCHECK_VERIFICATION_FACTOR : 1.0;\n-        double fWorkBefore = 0.0; // Amount of work done before pindex\n-        double fWorkAfter = 0.0;  // Amount of work left after pindex (estimated)\n-        // Work is defined as: 1.0 per transaction before the last checkpoint, and\n-        // fSigcheckVerificationFactor per transaction after.\n-\n-        const CCheckpointData &data = Checkpoints();\n-\n-        if (pindex->nChainTx <= data.nTransactionsLastCheckpoint) {\n-            double nCheapBefore = pindex->nChainTx;\n-            double nCheapAfter = data.nTransactionsLastCheckpoint - pindex->nChainTx;\n-            double nExpensiveAfter = (nNow - data.nTimeLastCheckpoint)/86400.0*data.fTransactionsPerDay;\n-            fWorkBefore = nCheapBefore;\n-            fWorkAfter = nCheapAfter + nExpensiveAfter*fSigcheckVerificationFactor;\n-        } else {\n-            double nCheapBefore = data.nTransactionsLastCheckpoint;\n-            double nExpensiveBefore = pindex->nChainTx - data.nTransactionsLastCheckpoint;\n-            double nExpensiveAfter = (nNow - pindex->GetBlockTime())/86400.0*data.fTransactionsPerDay;\n-            fWorkBefore = nCheapBefore + nExpensiveBefore*fSigcheckVerificationFactor;\n-            fWorkAfter = nExpensiveAfter*fSigcheckVerificationFactor;\n-        }\n+    return hash == i->second;\n+}\n \n-        return fWorkBefore / (fWorkBefore + fWorkAfter);\n+// Guess how far we are in the verification process at the given block index\n+double GuessVerificationProgress(CBlockIndex* pindex, bool fSigchecks)\n+{\n+    if (pindex == NULL)\n+    {\n+        return 0.0;\n     }\n \n-    int GetTotalBlocksEstimate()\n+    int64_t nNow = time(NULL);\n+\n+    double fSigcheckVerificationFactor = fSigchecks ? SIGCHECK_VERIFICATION_FACTOR : 1.0;\n+    double fWorkBefore = 0.0;     // Amount of work done before pindex\n+    double fWorkAfter = 0.0;      // Amount of work left after pindex (estimated)\n+    // Work is defined as: 1.0 per transaction before the last checkpoint, and\n+    // fSigcheckVerificationFactor per transaction after.\n+\n+    const CCheckpointData &data = Checkpoints();\n+\n+    if (pindex->nChainTx <= data.nTransactionsLastCheckpoint)\n     {\n-        if (!fEnabled)\n-            return 0;\n+        double nCheapBefore = pindex->nChainTx;\n+        double nCheapAfter = data.nTransactionsLastCheckpoint - pindex->nChainTx;\n+        double nExpensiveAfter = (nNow - data.nTimeLastCheckpoint) / 86400.0 * data.fTransactionsPerDay;\n+        fWorkBefore = nCheapBefore;\n+        fWorkAfter = nCheapAfter + nExpensiveAfter * fSigcheckVerificationFactor;\n+    }\n+    else\n+    {\n+        double nCheapBefore = data.nTransactionsLastCheckpoint;\n+        double nExpensiveBefore = pindex->nChainTx - data.nTransactionsLastCheckpoint;\n+        double nExpensiveAfter = (nNow - pindex->GetBlockTime()) / 86400.0 * data.fTransactionsPerDay;\n+        fWorkBefore = nCheapBefore + nExpensiveBefore * fSigcheckVerificationFactor;\n+        fWorkAfter = nExpensiveAfter * fSigcheckVerificationFactor;\n+    }\n \n-        const MapCheckpoints& checkpoints = *Checkpoints().mapCheckpoints;\n+    return fWorkBefore / (fWorkBefore + fWorkAfter);\n+}\n \n-        return checkpoints.rbegin()->first;\n+int GetTotalBlocksEstimate()\n+{\n+    if (!fEnabled)\n+    {\n+        return 0;\n     }\n \n-    CBlockIndex* GetLastCheckpoint()\n+    const MapCheckpoints& checkpoints = *Checkpoints().mapCheckpoints;\n+\n+    return checkpoints.rbegin()->first;\n+}\n+\n+CBlockIndex* GetLastCheckpoint()\n+{\n+    if (!fEnabled)\n     {\n-        if (!fEnabled)\n-            return NULL;\n+        return NULL;\n+    }\n+\n+    const MapCheckpoints& checkpoints = *Checkpoints().mapCheckpoints;\n \n-        const MapCheckpoints& checkpoints = *Checkpoints().mapCheckpoints;\n+    BOOST_REVERSE_FOREACH(const MapCheckpoints::value_type & i, checkpoints)\n+    {\n+        const uint256& hash = i.second;\n+        BlockMap::const_iterator t = mapBlockIndex.find(hash);\n \n-        BOOST_REVERSE_FOREACH(const MapCheckpoints::value_type& i, checkpoints)\n+        if (t != mapBlockIndex.end())\n         {\n-            const uint256& hash = i.second;\n-            BlockMap::const_iterator t = mapBlockIndex.find(hash);\n-            if (t != mapBlockIndex.end())\n-                return t->second;\n+            return t->second;\n         }\n-        return NULL;\n     }\n-\n+    return NULL;\n+}\n } // namespace Checkpoints\n+"
      },
      {
        "sha": "02e59579f410dc52211c8324ca220a5451ee8eec",
        "filename": "src/checkpoints.h",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/checkpoints.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/checkpoints.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkpoints.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -13,21 +13,21 @@ class uint256;\n /** Block-chain checkpoints are compiled-in sanity checks.\n  * They are updated every release or three.\n  */\n-namespace Checkpoints {\n+namespace Checkpoints\n+{\n+// Returns true if block passes checkpoint checks\n+bool CheckBlock(int nHeight, const uint256& hash);\n \n-    // Returns true if block passes checkpoint checks\n-    bool CheckBlock(int nHeight, const uint256& hash);\n+// Return conservative estimate of total number of blocks, 0 if unknown\n+int GetTotalBlocksEstimate();\n \n-    // Return conservative estimate of total number of blocks, 0 if unknown\n-    int GetTotalBlocksEstimate();\n+// Returns last CBlockIndex* in mapBlockIndex that is a checkpoint\n+CBlockIndex* GetLastCheckpoint();\n \n-    // Returns last CBlockIndex* in mapBlockIndex that is a checkpoint\n-    CBlockIndex* GetLastCheckpoint();\n-\n-    double GuessVerificationProgress(CBlockIndex *pindex, bool fSigchecks = true);\n-\n-    extern bool fEnabled;\n+double GuessVerificationProgress(CBlockIndex* pindex, bool fSigchecks = true);\n \n+extern bool fEnabled;\n } //namespace Checkpoints\n \n #endif // BITCOIN_CHECKPOINT_H\n+"
      },
      {
        "sha": "35a42f98132c3f9b3c6e86dff964af1b0b7b197f",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 98,
        "deletions": 36,
        "changes": 134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -13,18 +13,21 @@\n #include <boost/thread/locks.hpp>\n #include <boost/thread/mutex.hpp>\n \n-template<typename T> class CCheckQueueControl;\n+template<typename T>\n+class CCheckQueueControl;\n \n /** Queue for verifications that have to be performed.\n-  * The verifications are represented by a type T, which must provide an\n-  * operator(), returning a bool.\n-  *\n-  * One thread (the master) is assumed to push batches of verifications\n-  * onto the queue, where they are processed by N-1 worker threads. When\n-  * the master is done adding work, it temporarily joins the worker pool\n-  * as an N'th worker, until all jobs are done.\n-  */\n-template<typename T> class CCheckQueue {\n+ * The verifications are represented by a type T, which must provide an\n+ * operator(), returning a bool.\n+ *\n+ * One thread (the master) is assumed to push batches of verifications\n+ * onto the queue, where they are processed by N-1 worker threads. When\n+ * the master is done adding work, it temporarily joins the worker pool\n+ * as an N'th worker, until all jobs are done.\n+ */\n+template<typename T>\n+class CCheckQueue\n+{\n private:\n     // Mutex to protect the inner state\n     boost::mutex mutex;\n@@ -60,95 +63,139 @@ template<typename T> class CCheckQueue {\n     unsigned int nBatchSize;\n \n     // Internal function that does bulk of the verification work.\n-    bool Loop(bool fMaster = false) {\n+    bool Loop(bool fMaster = false)\n+    {\n         boost::condition_variable &cond = fMaster ? condMaster : condWorker;\n+\n         std::vector<T> vChecks;\n         vChecks.reserve(nBatchSize);\n         unsigned int nNow = 0;\n         bool fOk = true;\n-        do {\n+\n+        do\n+        {\n             {\n                 boost::unique_lock<boost::mutex> lock(mutex);\n+\n                 // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n-                if (nNow) {\n+                if (nNow)\n+                {\n                     fAllOk &= fOk;\n                     nTodo -= nNow;\n+\n                     if (nTodo == 0 && !fMaster)\n+                    {\n                         // We processed the last element; inform the master he can exit and return the result\n                         condMaster.notify_one();\n-                } else {\n+                    }\n+                }\n+                else\n+                {\n                     // first iteration\n                     nTotal++;\n                 }\n+\n                 // logically, the do loop starts here\n-                while (queue.empty()) {\n-                    if ((fMaster || fQuit) && nTodo == 0) {\n+                while (queue.empty())\n+                {\n+                    if ((fMaster || fQuit) && nTodo == 0)\n+                    {\n                         nTotal--;\n                         bool fRet = fAllOk;\n+\n                         // reset the status for new work later\n                         if (fMaster)\n+                        {\n                             fAllOk = true;\n+                        }\n+\n                         // return the current status\n                         return fRet;\n                     }\n+\n                     nIdle++;\n                     cond.wait(lock); // wait\n                     nIdle--;\n                 }\n+\n                 // Decide how many work units to process now.\n                 // * Do not try to do everything at once, but aim for increasingly smaller batches so\n                 //   all workers finish approximately simultaneously.\n                 // * Try to account for idle jobs which will instantly start helping.\n                 // * Don't do batches smaller than 1 (duh), or larger than nBatchSize.\n                 nNow = std::max(1U, std::min(nBatchSize, (unsigned int)queue.size() / (nTotal + nIdle + 1)));\n                 vChecks.resize(nNow);\n-                for (unsigned int i = 0; i < nNow; i++) {\n-                     // We want the lock on the mutex to be as short as possible, so swap jobs from the global\n-                     // queue to the local batch vector instead of copying.\n-                     vChecks[i].swap(queue.back());\n-                     queue.pop_back();\n+\n+                for (unsigned int i = 0; i < nNow; i++)\n+                {\n+                    // We want the lock on the mutex to be as short as possible, so swap jobs from the global\n+                    // queue to the local batch vector instead of copying.\n+                    vChecks[i].swap(queue.back());\n+                    queue.pop_back();\n                 }\n+\n                 // Check whether we need to do work at all\n                 fOk = fAllOk;\n             }\n+\n             // execute work\n-            BOOST_FOREACH(T &check, vChecks)\n+            BOOST_FOREACH (T &check, vChecks)\n+            {\n                 if (fOk)\n+                {\n                     fOk = check();\n+                }\n+            }\n+\n             vChecks.clear();\n-        } while(true);\n+        }\n+        while (true);\n     }\n \n public:\n     // Create a new check queue\n     CCheckQueue(unsigned int nBatchSizeIn) :\n-        nIdle(0), nTotal(0), fAllOk(true), nTodo(0), fQuit(false), nBatchSize(nBatchSizeIn) {}\n+        nIdle(0), nTotal(0), fAllOk(true), nTodo(0), fQuit(false), nBatchSize(nBatchSizeIn)\n+    {\n+    }\n \n     // Worker thread\n-    void Thread() {\n+    void Thread()\n+    {\n         Loop();\n     }\n \n     // Wait until execution finishes, and return whether all evaluations where succesful.\n-    bool Wait() {\n+    bool Wait()\n+    {\n         return Loop(true);\n     }\n \n     // Add a batch of checks to the queue\n-    void Add(std::vector<T> &vChecks) {\n+    void Add(std::vector<T> &vChecks)\n+    {\n         boost::unique_lock<boost::mutex> lock(mutex);\n-        BOOST_FOREACH(T &check, vChecks) {\n+\n+        BOOST_FOREACH (T &check, vChecks)\n+        {\n             queue.push_back(T());\n             check.swap(queue.back());\n         }\n+\n         nTodo += vChecks.size();\n+\n         if (vChecks.size() == 1)\n+        {\n             condWorker.notify_one();\n+        }\n         else if (vChecks.size() > 1)\n+        {\n             condWorker.notify_all();\n+        }\n     }\n \n-    ~CCheckQueue() {\n+    ~CCheckQueue()\n+    {\n     }\n \n     friend class CCheckQueueControl<T>;\n@@ -157,38 +204,53 @@ template<typename T> class CCheckQueue {\n /** RAII-style controller object for a CCheckQueue that guarantees the passed\n  *  queue is finished before continuing.\n  */\n-template<typename T> class CCheckQueueControl {\n+template<typename T>\n+class CCheckQueueControl\n+{\n private:\n-    CCheckQueue<T> *pqueue;\n+    CCheckQueue<T>* pqueue;\n     bool fDone;\n \n public:\n-    CCheckQueueControl(CCheckQueue<T> *pqueueIn) : pqueue(pqueueIn), fDone(false) {\n+    CCheckQueueControl(CCheckQueue<T>* pqueueIn) : pqueue(pqueueIn), fDone(false)\n+    {\n         // passed queue is supposed to be unused, or NULL\n-        if (pqueue != NULL) {\n+        if (pqueue != NULL)\n+        {\n             assert(pqueue->nTotal == pqueue->nIdle);\n             assert(pqueue->nTodo == 0);\n             assert(pqueue->fAllOk == true);\n         }\n     }\n \n-    bool Wait() {\n+    bool Wait()\n+    {\n         if (pqueue == NULL)\n+        {\n             return true;\n+        }\n+\n         bool fRet = pqueue->Wait();\n         fDone = true;\n         return fRet;\n     }\n \n-    void Add(std::vector<T> &vChecks) {\n+    void Add(std::vector<T> &vChecks)\n+    {\n         if (pqueue != NULL)\n+        {\n             pqueue->Add(vChecks);\n+        }\n     }\n \n-    ~CCheckQueueControl() {\n+    ~CCheckQueueControl()\n+    {\n         if (!fDone)\n+        {\n             Wait();\n+        }\n     }\n };\n \n #endif // CHECKQUEUE_H\n+"
      },
      {
        "sha": "857beafe89b07dd3bac9112509fbf2100e80cc78",
        "filename": "src/clientversion.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/clientversion.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/clientversion.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/clientversion.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -30,9 +30,10 @@\n // Converts the parameter X to a string after macro replacement on X has been performed.\n // Don't merge these into one macro!\n #define STRINGIZE(X) DO_STRINGIZE(X)\n-#define DO_STRINGIZE(X) #X\n+#define DO_STRINGIZE(X) # X\n \n // Copyright string used in Windows .rc files\n #define COPYRIGHT_STR          \"2009-\" STRINGIZE(COPYRIGHT_YEAR) \" The Bitcoin Core Developers\"\n \n #endif // CLIENTVERSION_H\n+"
      },
      {
        "sha": "fe6a3aa8ddd6fcb142ed8b5e475a66036b510fbb",
        "filename": "src/coincontrol.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/coincontrol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/coincontrol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coincontrol.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -32,6 +32,7 @@ class CCoinControl\n     bool IsSelected(const uint256& hash, unsigned int n) const\n     {\n         COutPoint outpt(hash, n);\n+\n         return (setSelected.count(outpt) > 0);\n     }\n \n@@ -57,7 +58,7 @@ class CCoinControl\n \n private:\n     std::set<COutPoint> setSelected;\n-\n };\n \n #endif // COINCONTROL_H\n+"
      },
      {
        "sha": "3fe94386b18a22338fe3c2013826d954ec4406b3",
        "filename": "src/coins.cpp",
        "status": "modified",
        "additions": 194,
        "deletions": 51,
        "changes": 245,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -11,205 +11,348 @@\n // calculate number of bytes for the bitmask, and its number of non-zero bytes\n // each bit in the bitmask represents the availability of one output, but the\n // availabilities of the first two outputs are encoded separately\n-void CCoins::CalcMaskSize(unsigned int &nBytes, unsigned int &nNonzeroBytes) const {\n+void CCoins::CalcMaskSize(unsigned int &nBytes, unsigned int &nNonzeroBytes) const\n+{\n     unsigned int nLastUsedByte = 0;\n-    for (unsigned int b = 0; 2+b*8 < vout.size(); b++) {\n+\n+    for (unsigned int b = 0; 2 + b * 8 < vout.size(); b++)\n+    {\n         bool fZero = true;\n-        for (unsigned int i = 0; i < 8 && 2+b*8+i < vout.size(); i++) {\n-            if (!vout[2+b*8+i].IsNull()) {\n+\n+        for (unsigned int i = 0; i < 8 && 2 + b * 8 + i < vout.size(); i++)\n+        {\n+            if (!vout[2 + b * 8 + i].IsNull())\n+            {\n                 fZero = false;\n                 continue;\n             }\n         }\n-        if (!fZero) {\n+\n+        if (!fZero)\n+        {\n             nLastUsedByte = b + 1;\n             nNonzeroBytes++;\n         }\n     }\n+\n     nBytes += nLastUsedByte;\n }\n \n-bool CCoins::Spend(const COutPoint &out, CTxInUndo &undo) {\n+bool CCoins::Spend(const COutPoint &out, CTxInUndo &undo)\n+{\n     if (out.n >= vout.size())\n+    {\n         return false;\n+    }\n+\n     if (vout[out.n].IsNull())\n+    {\n         return false;\n+    }\n+\n     undo = CTxInUndo(vout[out.n]);\n     vout[out.n].SetNull();\n     Cleanup();\n-    if (vout.size() == 0) {\n+\n+    if (vout.size() == 0)\n+    {\n         undo.nHeight = nHeight;\n         undo.fCoinBase = fCoinBase;\n         undo.nVersion = this->nVersion;\n     }\n+\n     return true;\n }\n \n-bool CCoins::Spend(int nPos) {\n+bool CCoins::Spend(int nPos)\n+{\n     CTxInUndo undo;\n     COutPoint out(0, nPos);\n+\n     return Spend(out, undo);\n }\n \n+bool CCoinsView::GetCoins(const uint256 &txid, CCoins &coins) const\n+{\n+    return false;\n+}\n+\n+bool CCoinsView::SetCoins(const uint256 &txid, const CCoins &coins)\n+{\n+    return false;\n+}\n+\n+bool CCoinsView::HaveCoins(const uint256 &txid) const\n+{\n+    return false;\n+}\n+\n+uint256 CCoinsView::GetBestBlock() const\n+{\n+    return uint256(0);\n+}\n \n-bool CCoinsView::GetCoins(const uint256 &txid, CCoins &coins) const { return false; }\n-bool CCoinsView::SetCoins(const uint256 &txid, const CCoins &coins) { return false; }\n-bool CCoinsView::HaveCoins(const uint256 &txid) const { return false; }\n-uint256 CCoinsView::GetBestBlock() const { return uint256(0); }\n-bool CCoinsView::SetBestBlock(const uint256 &hashBlock) { return false; }\n-bool CCoinsView::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) { return false; }\n-bool CCoinsView::GetStats(CCoinsStats &stats) const { return false; }\n+bool CCoinsView::SetBestBlock(const uint256 &hashBlock)\n+{\n+    return false;\n+}\n+\n+bool CCoinsView::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock)\n+{\n+    return false;\n+}\n+\n+bool CCoinsView::GetStats(CCoinsStats &stats) const\n+{\n+    return false;\n+}\n+\n+CCoinsViewBacked::CCoinsViewBacked(CCoinsView &viewIn) : base(&viewIn)\n+{\n+}\n+\n+bool CCoinsViewBacked::GetCoins(const uint256 &txid, CCoins &coins) const\n+{\n+    return base->GetCoins(txid, coins);\n+}\n+\n+bool CCoinsViewBacked::SetCoins(const uint256 &txid, const CCoins &coins)\n+{\n+    return base->SetCoins(txid, coins);\n+}\n+\n+bool CCoinsViewBacked::HaveCoins(const uint256 &txid) const\n+{\n+    return base->HaveCoins(txid);\n+}\n+\n+uint256 CCoinsViewBacked::GetBestBlock() const\n+{\n+    return base->GetBestBlock();\n+}\n+\n+bool CCoinsViewBacked::SetBestBlock(const uint256 &hashBlock)\n+{\n+    return base->SetBestBlock(hashBlock);\n+}\n+\n+void CCoinsViewBacked::SetBackend(CCoinsView &viewIn)\n+{\n+    base = &viewIn;\n+}\n \n+bool CCoinsViewBacked::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock)\n+{\n+    return base->BatchWrite(mapCoins, hashBlock);\n+}\n \n-CCoinsViewBacked::CCoinsViewBacked(CCoinsView &viewIn) : base(&viewIn) { }\n-bool CCoinsViewBacked::GetCoins(const uint256 &txid, CCoins &coins) const { return base->GetCoins(txid, coins); }\n-bool CCoinsViewBacked::SetCoins(const uint256 &txid, const CCoins &coins) { return base->SetCoins(txid, coins); }\n-bool CCoinsViewBacked::HaveCoins(const uint256 &txid) const { return base->HaveCoins(txid); }\n-uint256 CCoinsViewBacked::GetBestBlock() const { return base->GetBestBlock(); }\n-bool CCoinsViewBacked::SetBestBlock(const uint256 &hashBlock) { return base->SetBestBlock(hashBlock); }\n-void CCoinsViewBacked::SetBackend(CCoinsView &viewIn) { base = &viewIn; }\n-bool CCoinsViewBacked::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) { return base->BatchWrite(mapCoins, hashBlock); }\n-bool CCoinsViewBacked::GetStats(CCoinsStats &stats) const { return base->GetStats(stats); }\n+bool CCoinsViewBacked::GetStats(CCoinsStats &stats) const\n+{\n+    return base->GetStats(stats);\n+}\n \n-CCoinsKeyHasher::CCoinsKeyHasher() : salt(GetRandHash()) {}\n+CCoinsKeyHasher::CCoinsKeyHasher() : salt(GetRandHash())\n+{\n+}\n \n-CCoinsViewCache::CCoinsViewCache(CCoinsView &baseIn, bool fDummy) : CCoinsViewBacked(baseIn), hashBlock(0) { }\n+CCoinsViewCache::CCoinsViewCache(CCoinsView &baseIn, bool fDummy) : CCoinsViewBacked(baseIn), hashBlock(0)\n+{\n+}\n \n-bool CCoinsViewCache::GetCoins(const uint256 &txid, CCoins &coins) const {\n-    if (cacheCoins.count(txid)) {\n+bool CCoinsViewCache::GetCoins(const uint256 &txid, CCoins &coins) const\n+{\n+    if (cacheCoins.count(txid))\n+    {\n         coins = cacheCoins[txid];\n         return true;\n     }\n-    if (base->GetCoins(txid, coins)) {\n+\n+    if (base->GetCoins(txid, coins))\n+    {\n         cacheCoins[txid] = coins;\n         return true;\n     }\n+\n     return false;\n }\n \n-CCoinsMap::iterator CCoinsViewCache::FetchCoins(const uint256 &txid) {\n+CCoinsMap::iterator CCoinsViewCache::FetchCoins(const uint256 &txid)\n+{\n     CCoinsMap::iterator it = cacheCoins.find(txid);\n+\n     if (it != cacheCoins.end())\n+    {\n         return it;\n+    }\n+\n     CCoins tmp;\n-    if (!base->GetCoins(txid,tmp))\n+\n+    if (!base->GetCoins(txid, tmp))\n+    {\n         return cacheCoins.end();\n+    }\n+\n     CCoinsMap::iterator ret = cacheCoins.insert(it, std::make_pair(txid, CCoins()));\n     tmp.swap(ret->second);\n     return ret;\n }\n \n-CCoinsMap::const_iterator CCoinsViewCache::FetchCoins(const uint256 &txid) const {\n+CCoinsMap::const_iterator CCoinsViewCache::FetchCoins(const uint256 &txid) const\n+{\n     /* Avoid redundant implementation with the const-cast.  */\n     return const_cast<CCoinsViewCache*>(this)->FetchCoins(txid);\n }\n \n-CCoins &CCoinsViewCache::GetCoins(const uint256 &txid) {\n+CCoins &CCoinsViewCache::GetCoins(const uint256 &txid)\n+{\n     CCoinsMap::iterator it = FetchCoins(txid);\n+\n     assert(it != cacheCoins.end());\n     return it->second;\n }\n \n-const CCoins* CCoinsViewCache::AccessCoins(const uint256 &txid) const {\n+const CCoins* CCoinsViewCache::AccessCoins(const uint256 &txid) const\n+{\n     CCoinsMap::const_iterator it = FetchCoins(txid);\n-    if (it == cacheCoins.end()) {\n+\n+    if (it == cacheCoins.end())\n+    {\n         return NULL;\n-    } else {\n+    }\n+    else\n+    {\n         return &it->second;\n     }\n }\n \n-bool CCoinsViewCache::SetCoins(const uint256 &txid, const CCoins &coins) {\n+bool CCoinsViewCache::SetCoins(const uint256 &txid, const CCoins &coins)\n+{\n     cacheCoins[txid] = coins;\n     return true;\n }\n \n-bool CCoinsViewCache::HaveCoins(const uint256 &txid) const {\n+bool CCoinsViewCache::HaveCoins(const uint256 &txid) const\n+{\n     CCoinsMap::const_iterator it = FetchCoins(txid);\n+\n     // We're using vtx.empty() instead of IsPruned here for performance reasons,\n     // as we only care about the case where an transaction was replaced entirely\n     // in a reorganization (which wipes vout entirely, as opposed to spending\n     // which just cleans individual outputs).\n     return (it != cacheCoins.end() && !it->second.vout.empty());\n }\n \n-uint256 CCoinsViewCache::GetBestBlock() const {\n+uint256 CCoinsViewCache::GetBestBlock() const\n+{\n     if (hashBlock == uint256(0))\n+    {\n         hashBlock = base->GetBestBlock();\n+    }\n+\n     return hashBlock;\n }\n \n-bool CCoinsViewCache::SetBestBlock(const uint256 &hashBlockIn) {\n+bool CCoinsViewCache::SetBestBlock(const uint256 &hashBlockIn)\n+{\n     hashBlock = hashBlockIn;\n     return true;\n }\n \n-bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn) {\n-    for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end();) {\n+bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn)\n+{\n+    for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end(); )\n+    {\n         cacheCoins[it->first].swap(it->second);\n         CCoinsMap::iterator itOld = it++;\n         mapCoins.erase(itOld);\n     }\n+\n     hashBlock = hashBlockIn;\n     return true;\n }\n \n-bool CCoinsViewCache::Flush() {\n+bool CCoinsViewCache::Flush()\n+{\n     bool fOk = base->BatchWrite(cacheCoins, hashBlock);\n+\n     cacheCoins.clear();\n     return fOk;\n }\n \n-unsigned int CCoinsViewCache::GetCacheSize() const {\n+unsigned int CCoinsViewCache::GetCacheSize() const\n+{\n     return cacheCoins.size();\n }\n \n const CTxOut &CCoinsViewCache::GetOutputFor(const CTxIn& input) const\n {\n     const CCoins* coins = AccessCoins(input.prevout.hash);\n+\n     assert(coins && coins->IsAvailable(input.prevout.n));\n     return coins->vout[input.prevout.n];\n }\n \n int64_t CCoinsViewCache::GetValueIn(const CTransaction& tx) const\n {\n     if (tx.IsCoinBase())\n+    {\n         return 0;\n+    }\n \n     int64_t nResult = 0;\n+\n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n+    {\n         nResult += GetOutputFor(tx.vin[i]).nValue;\n+    }\n \n     return nResult;\n }\n \n bool CCoinsViewCache::HaveInputs(const CTransaction& tx) const\n {\n-    if (!tx.IsCoinBase()) {\n-        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+    if (!tx.IsCoinBase())\n+    {\n+        for (unsigned int i = 0; i < tx.vin.size(); i++)\n+        {\n             const COutPoint &prevout = tx.vin[i].prevout;\n             const CCoins* coins = AccessCoins(prevout.hash);\n-            if (!coins || !coins->IsAvailable(prevout.n)) {\n+\n+            if (!coins || !coins->IsAvailable(prevout.n))\n+            {\n                 return false;\n             }\n         }\n     }\n+\n     return true;\n }\n \n double CCoinsViewCache::GetPriority(const CTransaction &tx, int nHeight) const\n {\n     if (tx.IsCoinBase())\n+    {\n         return 0.0;\n+    }\n+\n     double dResult = 0.0;\n-    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+\n+    BOOST_FOREACH (const CTxIn& txin, tx.vin)\n     {\n         const CCoins* coins = AccessCoins(txin.prevout.hash);\n         assert(coins);\n-        if (!coins->IsAvailable(txin.prevout.n)) continue;\n-        if (coins->nHeight < nHeight) {\n-            dResult += coins->vout[txin.prevout.n].nValue * (nHeight-coins->nHeight);\n+\n+        if (!coins->IsAvailable(txin.prevout.n))\n+        {\n+            continue;\n+        }\n+\n+        if (coins->nHeight < nHeight)\n+        {\n+            dResult += coins->vout[txin.prevout.n].nValue * (nHeight - coins->nHeight);\n         }\n     }\n+\n     return tx.ComputePriority(dResult);\n }\n+"
      },
      {
        "sha": "e23e1156884a75917699712a53e33541dcf55e7c",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 110,
        "deletions": 38,
        "changes": 148,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -84,111 +84,159 @@ class CCoins\n     int nVersion;\n \n     // construct a CCoins from a CTransaction, at a given height\n-    CCoins(const CTransaction &tx, int nHeightIn) : fCoinBase(tx.IsCoinBase()), vout(tx.vout), nHeight(nHeightIn), nVersion(tx.nVersion) {\n+    CCoins(const CTransaction &tx,\n+        int nHeightIn) : fCoinBase(tx.IsCoinBase()), vout(tx.vout), nHeight(nHeightIn), nVersion(tx.nVersion)\n+    {\n         ClearUnspendable();\n     }\n \n     // empty constructor\n-    CCoins() : fCoinBase(false), vout(0), nHeight(0), nVersion(0) { }\n+    CCoins() : fCoinBase(false), vout(0), nHeight(0), nVersion(0)\n+    {\n+    }\n \n     // remove spent outputs at the end of vout\n-    void Cleanup() {\n+    void Cleanup()\n+    {\n         while (vout.size() > 0 && vout.back().IsNull())\n             vout.pop_back();\n+\n         if (vout.empty())\n+        {\n             std::vector<CTxOut>().swap(vout);\n+        }\n     }\n \n-    void ClearUnspendable() {\n-        BOOST_FOREACH(CTxOut &txout, vout) {\n+    void ClearUnspendable()\n+    {\n+        BOOST_FOREACH (CTxOut &txout, vout)\n+        {\n             if (txout.scriptPubKey.IsUnspendable())\n+            {\n                 txout.SetNull();\n+            }\n         }\n+\n         Cleanup();\n     }\n \n-    void swap(CCoins &to) {\n+    void swap(CCoins &to)\n+    {\n         std::swap(to.fCoinBase, fCoinBase);\n         to.vout.swap(vout);\n         std::swap(to.nHeight, nHeight);\n         std::swap(to.nVersion, nVersion);\n     }\n \n     // equality test\n-    friend bool operator==(const CCoins &a, const CCoins &b) {\n-         // Empty CCoins objects are always equal.\n-         if (a.IsPruned() && b.IsPruned())\n-             return true;\n-         return a.fCoinBase == b.fCoinBase &&\n-                a.nHeight == b.nHeight &&\n-                a.nVersion == b.nVersion &&\n-                a.vout == b.vout;\n+    friend bool operator==(const CCoins &a, const CCoins &b)\n+    {\n+        // Empty CCoins objects are always equal.\n+        if (a.IsPruned() && b.IsPruned())\n+        {\n+            return true;\n+        }\n+\n+        return a.fCoinBase == b.fCoinBase &&\n+               a.nHeight == b.nHeight &&\n+               a.nVersion == b.nVersion &&\n+               a.vout == b.vout;\n     }\n-    friend bool operator!=(const CCoins &a, const CCoins &b) {\n+\n+    friend bool operator!=(const CCoins &a, const CCoins &b)\n+    {\n         return !(a == b);\n     }\n \n     void CalcMaskSize(unsigned int &nBytes, unsigned int &nNonzeroBytes) const;\n \n-    bool IsCoinBase() const {\n+    bool IsCoinBase() const\n+    {\n         return fCoinBase;\n     }\n \n-    unsigned int GetSerializeSize(int nType, int nVersion) const {\n+    unsigned int GetSerializeSize(int nType, int nVersion) const\n+    {\n         unsigned int nSize = 0;\n         unsigned int nMaskSize = 0, nMaskCode = 0;\n+\n         CalcMaskSize(nMaskSize, nMaskCode);\n         bool fFirst = vout.size() > 0 && !vout[0].IsNull();\n         bool fSecond = vout.size() > 1 && !vout[1].IsNull();\n         assert(fFirst || fSecond || nMaskCode);\n-        unsigned int nCode = 8*(nMaskCode - (fFirst || fSecond ? 0 : 1)) + (fCoinBase ? 1 : 0) + (fFirst ? 2 : 0) + (fSecond ? 4 : 0);\n+        unsigned int nCode = 8 *\n+            (nMaskCode - (fFirst || fSecond ? 0 : 1)) + (fCoinBase ? 1 : 0) + (fFirst ? 2 : 0) + (fSecond ? 4 : 0);\n         // version\n         nSize += ::GetSerializeSize(VARINT(this->nVersion), nType, nVersion);\n         // size of header code\n         nSize += ::GetSerializeSize(VARINT(nCode), nType, nVersion);\n         // spentness bitmask\n         nSize += nMaskSize;\n+\n         // txouts themself\n         for (unsigned int i = 0; i < vout.size(); i++)\n+        {\n             if (!vout[i].IsNull())\n+            {\n                 nSize += ::GetSerializeSize(CTxOutCompressor(REF(vout[i])), nType, nVersion);\n+            }\n+        }\n+\n         // height\n         nSize += ::GetSerializeSize(VARINT(nHeight), nType, nVersion);\n         return nSize;\n     }\n \n     template<typename Stream>\n-    void Serialize(Stream &s, int nType, int nVersion) const {\n+    void Serialize(Stream &s, int nType, int nVersion) const\n+    {\n         unsigned int nMaskSize = 0, nMaskCode = 0;\n+\n         CalcMaskSize(nMaskSize, nMaskCode);\n         bool fFirst = vout.size() > 0 && !vout[0].IsNull();\n         bool fSecond = vout.size() > 1 && !vout[1].IsNull();\n         assert(fFirst || fSecond || nMaskCode);\n-        unsigned int nCode = 8*(nMaskCode - (fFirst || fSecond ? 0 : 1)) + (fCoinBase ? 1 : 0) + (fFirst ? 2 : 0) + (fSecond ? 4 : 0);\n+        unsigned int nCode = 8 *\n+            (nMaskCode - (fFirst || fSecond ? 0 : 1)) + (fCoinBase ? 1 : 0) + (fFirst ? 2 : 0) + (fSecond ? 4 : 0);\n         // version\n         ::Serialize(s, VARINT(this->nVersion), nType, nVersion);\n         // header code\n         ::Serialize(s, VARINT(nCode), nType, nVersion);\n+\n         // spentness bitmask\n-        for (unsigned int b = 0; b<nMaskSize; b++) {\n+        for (unsigned int b = 0; b < nMaskSize; b++)\n+        {\n             unsigned char chAvail = 0;\n-            for (unsigned int i = 0; i < 8 && 2+b*8+i < vout.size(); i++)\n-                if (!vout[2+b*8+i].IsNull())\n+\n+            for (unsigned int i = 0; i < 8 && 2 + b * 8 + i < vout.size(); i++)\n+            {\n+                if (!vout[2 + b * 8 + i].IsNull())\n+                {\n                     chAvail |= (1 << i);\n+                }\n+            }\n+\n             ::Serialize(s, chAvail, nType, nVersion);\n         }\n+\n         // txouts themself\n-        for (unsigned int i = 0; i < vout.size(); i++) {\n+        for (unsigned int i = 0; i < vout.size(); i++)\n+        {\n             if (!vout[i].IsNull())\n+            {\n                 ::Serialize(s, CTxOutCompressor(REF(vout[i])), nType, nVersion);\n+            }\n         }\n+\n         // coinbase height\n         ::Serialize(s, VARINT(nHeight), nType, nVersion);\n     }\n \n     template<typename Stream>\n-    void Unserialize(Stream &s, int nType, int nVersion) {\n+    void Unserialize(Stream &s, int nType, int nVersion)\n+    {\n         unsigned int nCode = 0;\n+\n         // version\n         ::Unserialize(s, VARINT(this->nVersion), nType, nVersion);\n         // header code\n@@ -198,23 +246,36 @@ class CCoins\n         vAvail[0] = nCode & 2;\n         vAvail[1] = nCode & 4;\n         unsigned int nMaskCode = (nCode / 8) + ((nCode & 6) != 0 ? 0 : 1);\n+\n         // spentness bitmask\n-        while (nMaskCode > 0) {\n+        while (nMaskCode > 0)\n+        {\n             unsigned char chAvail = 0;\n             ::Unserialize(s, chAvail, nType, nVersion);\n-            for (unsigned int p = 0; p < 8; p++) {\n+\n+            for (unsigned int p = 0; p < 8; p++)\n+            {\n                 bool f = (chAvail & (1 << p)) != 0;\n                 vAvail.push_back(f);\n             }\n+\n             if (chAvail != 0)\n+            {\n                 nMaskCode--;\n+            }\n         }\n+\n         // txouts themself\n         vout.assign(vAvail.size(), CTxOut());\n-        for (unsigned int i = 0; i < vAvail.size(); i++) {\n+\n+        for (unsigned int i = 0; i < vAvail.size(); i++)\n+        {\n             if (vAvail[i])\n+            {\n                 ::Unserialize(s, REF(CTxOutCompressor(vout[i])), nType, nVersion);\n+            }\n         }\n+\n         // coinbase height\n         ::Unserialize(s, VARINT(nHeight), nType, nVersion);\n         Cleanup();\n@@ -227,16 +288,23 @@ class CCoins\n     bool Spend(int nPos);\n \n     // check whether a particular output is still available\n-    bool IsAvailable(unsigned int nPos) const {\n+    bool IsAvailable(unsigned int nPos) const\n+    {\n         return (nPos < vout.size() && !vout[nPos].IsNull());\n     }\n \n     // check whether the entire CCoins is spent\n     // note that only !IsPruned() CCoins can be serialized\n-    bool IsPruned() const {\n-        BOOST_FOREACH(const CTxOut &out, vout)\n+    bool IsPruned() const\n+    {\n+        BOOST_FOREACH (const CTxOut &out, vout)\n+        {\n             if (!out.IsNull())\n+            {\n                 return false;\n+            }\n+        }\n+\n         return true;\n     }\n };\n@@ -251,7 +319,8 @@ class CCoinsKeyHasher\n     // This *must* return size_t. With Boost 1.46 on 32-bit systems the\n     // unordered_map will behave unpredictably if the custom hasher returns a\n     // uint64_t, resulting in failures when syncing the chain (#4634).\n-    size_t operator()(const uint256& key) const {\n+    size_t operator()(const uint256& key) const\n+    {\n         return key.GetHash(salt);\n     }\n };\n@@ -268,10 +337,12 @@ struct CCoinsStats\n     uint256 hashSerialized;\n     int64_t nTotalAmount;\n \n-    CCoinsStats() : nHeight(0), hashBlock(0), nTransactions(0), nTransactionOutputs(0), nSerializedSize(0), hashSerialized(0), nTotalAmount(0) {}\n+    CCoinsStats() : nHeight(0), hashBlock(0), nTransactions(0), nTransactionOutputs(0), nSerializedSize(0),\n+        hashSerialized(0), nTotalAmount(0)\n+    {\n+    }\n };\n \n-\n /** Abstract view on the open txout dataset. */\n class CCoinsView\n {\n@@ -300,15 +371,16 @@ class CCoinsView\n     virtual bool GetStats(CCoinsStats &stats) const;\n \n     // As we use CCoinsViews polymorphically, have a virtual destructor\n-    virtual ~CCoinsView() {}\n+    virtual ~CCoinsView()\n+    {\n+    }\n };\n \n-\n /** CCoinsView backed by another CCoinsView */\n class CCoinsViewBacked : public CCoinsView\n {\n protected:\n-    CCoinsView *base;\n+    CCoinsView* base;\n \n public:\n     CCoinsViewBacked(CCoinsView &viewIn);\n@@ -322,7 +394,6 @@ class CCoinsViewBacked : public CCoinsView\n     bool GetStats(CCoinsStats &stats) const;\n };\n \n-\n /** CCoinsView that adds a memory cache for transactions to another CCoinsView */\n class CCoinsViewCache : public CCoinsViewBacked\n {\n@@ -383,3 +454,4 @@ class CCoinsViewCache : public CCoinsViewBacked\n };\n \n #endif // BITCOIN_COINS_H\n+"
      },
      {
        "sha": "3a646c7a2e1fd87be10bdc4eb511c60a262029ad",
        "filename": "src/compat.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/compat.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/compat.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -85,3 +85,4 @@ typedef u_int SOCKET;\n #endif\n \n #endif // _BITCOIN_COMPAT_H\n+"
      },
      {
        "sha": "b1483f1aa869e178c8d9d58088c378bdfae23b51",
        "filename": "src/compat/glibc_compat.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/compat/glibc_compat.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/compat/glibc_compat.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/glibc_compat.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -22,7 +22,12 @@ extern \"C\" void __chk_fail (void) __attribute__((__noreturn__));\n extern \"C\" FDELT_TYPE __fdelt_warn(FDELT_TYPE a)\n {\n     if (a >= FD_SETSIZE)\n+    {\n         __chk_fail ();\n+    }\n+\n     return a / __NFDBITS;\n }\n+\n extern \"C\" FDELT_TYPE __fdelt_chk(FDELT_TYPE) __attribute__((weak, alias(\"__fdelt_warn\")));\n+"
      },
      {
        "sha": "7f7c6d481225d5950ffbf75de6c582256c72d23d",
        "filename": "src/compat/glibc_sanity.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 6,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/compat/glibc_sanity.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/compat/glibc_sanity.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/glibc_sanity.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -14,10 +14,11 @@\n extern \"C\" void* memcpy(void* a, const void* b, size_t c);\n void* memcpy_int(void* a, const void* b, size_t c)\n {\n-    return memcpy(a,b,c);\n+    return memcpy(a, b, c);\n }\n \n-namespace {\n+namespace\n+{\n // trigger: Use the memcpy_int wrapper which calls our internal memcpy.\n //   A direct call to memcpy may be optimized away by the compiler.\n // test: Fill an array with a sequence of integers. memcpy to a new empty array.\n@@ -28,16 +29,22 @@ bool sanity_test_memcpy()\n {\n     unsigned int memcpy_test[T];\n     unsigned int memcpy_verify[T] = {};\n+\n     for (unsigned int i = 0; i != T; ++i)\n+    {\n         memcpy_test[i] = i;\n+    }\n \n-    memcpy_int(memcpy_verify,memcpy_test,sizeof(memcpy_test));\n+    memcpy_int(memcpy_verify, memcpy_test, sizeof(memcpy_test));\n \n     for (unsigned int i = 0; i != T; ++i)\n     {\n-        if(memcpy_verify[i] != i)\n+        if (memcpy_verify[i] != i)\n+        {\n             return false;\n+        }\n     }\n+\n     return true;\n }\n \n@@ -49,19 +56,25 @@ bool sanity_test_memcpy()\n bool sanity_test_fdelt()\n {\n     fd_set fds;\n+\n     FD_ZERO(&fds);\n     FD_SET(0, &fds);\n-    return FD_ISSET(0,&fds);\n+    return FD_ISSET(0, &fds);\n }\n-#endif\n \n+#endif\n } // anon namespace\n \n bool glibc_sanity_test()\n {\n #if defined(HAVE_SYS_SELECT_H)\n+\n     if (!sanity_test_fdelt())\n+    {\n         return false;\n+    }\n+\n #endif\n     return sanity_test_memcpy<1025>();\n }\n+"
      },
      {
        "sha": "53c7e543ddc992ef41bc8a7d2dc0ba411801b7f6",
        "filename": "src/compat/glibcxx_compat.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 7,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/compat/glibcxx_compat.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/compat/glibcxx_compat.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/glibcxx_compat.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -11,8 +11,8 @@\n #define _GLIBCXX_USE_NOEXCEPT throw()\n #endif\n \n-namespace std {\n-\n+namespace std\n+{\n const char* bad_exception::what() const throw()\n {\n     return \"std::bad_exception\";\n@@ -44,6 +44,7 @@ struct _List_node_base\n     {\n         _List_node_base* const __next_node = _M_next;\n         _List_node_base* const __prev_node = _M_prev;\n+\n         __prev_node->_M_next = __next_node;\n         __next_node->_M_prev = __prev_node;\n     }\n@@ -58,31 +59,43 @@ template ostream& ostream::_M_insert(long);\n template ostream& ostream::_M_insert(double);\n template ostream& ostream::_M_insert(unsigned long);\n template ostream& ostream::_M_insert(const void*);\n-template ostream& __ostream_insert(ostream&, const char*, streamsize);\n+template ostream& __ostream_insert(ostream &, const char*, streamsize);\n template istream& istream::_M_extract(long&);\n template istream& istream::_M_extract(unsigned short&);\n \n-out_of_range::~out_of_range() _GLIBCXX_USE_NOEXCEPT { }\n+out_of_range::~out_of_range() _GLIBCXX_USE_NOEXCEPT\n+{\n+}\n \n-length_error::~length_error() _GLIBCXX_USE_NOEXCEPT { }\n+length_error::~length_error() _GLIBCXX_USE_NOEXCEPT\n+{\n+}\n \n // Used with permission.\n // See: https://github.com/madlib/madlib/commit/c3db418c0d34d6813608f2137fef1012ce03043d\n \n void ctype<char>::_M_widen_init() const\n {\n     char __tmp[sizeof(_M_widen)];\n+\n     for (unsigned __i = 0; __i < sizeof(_M_widen); ++__i)\n+    {\n         __tmp[__i] = __i;\n+    }\n+\n     do_widen(__tmp, __tmp + sizeof(__tmp), _M_widen);\n \n     _M_widen_ok = 1;\n+\n     // Set _M_widen_ok to 2 if memcpy can't be used.\n     for (unsigned __i = 0; __i < sizeof(_M_widen); ++__i)\n-        if (__tmp[__i] != _M_widen[__i]) {\n+    {\n+        if (__tmp[__i] != _M_widen[__i])\n+        {\n             _M_widen_ok = 2;\n             break;\n         }\n+    }\n }\n \n void  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__));\n@@ -91,5 +104,5 @@ void  __throw_out_of_range_fmt(const char* err, ...)\n     // Safe and over-simplified version. Ignore the format and print it as-is.\n     __throw_out_of_range(err);\n }\n+} // namespace std\n \n-}// namespace std"
      },
      {
        "sha": "54392b90b985a6eee43300fb57f07fc5bd3df34f",
        "filename": "src/compat/glibcxx_sanity.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 7,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/compat/glibcxx_sanity.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/compat/glibcxx_sanity.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/glibcxx_sanity.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -6,15 +6,15 @@\n #include <locale>\n #include <stdexcept>\n \n-namespace{\n-\n+namespace\n+{\n // trigger: use ctype<char>::widen to trigger ctype<char>::_M_widen_init().\n // test: convert a char from narrow to wide and back. Verify that the result\n //   matches the original.\n bool sanity_test_widen(char testchar)\n {\n     const std::ctype<char>& test(std::use_facet< std::ctype<char> >(std::locale()));\n-    return test.narrow(test.widen(testchar),'b') == testchar;\n+    return test.narrow(test.widen(testchar), 'b') == testchar;\n }\n \n // trigger: use list::push_back and list::pop_back to trigger _M_hook and\n@@ -24,21 +24,29 @@ bool sanity_test_widen(char testchar)\n bool sanity_test_list(unsigned int size)\n {\n     std::list<unsigned int> test;\n+\n     for (unsigned int i = 0; i != size; ++i)\n-        test.push_back(i+1);\n+    {\n+        test.push_back(i + 1);\n+    }\n \n     if (test.size() != size)\n+    {\n         return false;\n+    }\n \n     while (!test.empty())\n     {\n-        if(test.back() != test.size())\n+        if (test.back() != test.size())\n+        {\n             return false;\n+        }\n+\n         test.pop_back();\n     }\n+\n     return true;\n }\n-\n } // anon namespace\n \n // trigger: string::at(x) on an empty string to trigger __throw_out_of_range_fmt.\n@@ -47,6 +55,7 @@ bool sanity_test_list(unsigned int size)\n bool sanity_test_range_fmt()\n {\n     std::string test;\n+\n     try\n     {\n         test.at(1);\n@@ -55,11 +64,14 @@ bool sanity_test_range_fmt()\n     {\n         return true;\n     }\n-    catch (...){}\n+    catch (...)\n+    {\n+    }\n     return false;\n }\n \n bool glibcxx_sanity_test()\n {\n     return sanity_test_widen('a') && sanity_test_list(100) && sanity_test_range_fmt();\n }\n+"
      },
      {
        "sha": "6fd54cb6eb7bb5861c1d3410e9477277bed06328",
        "filename": "src/compat/sanity.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/compat/sanity.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/compat/sanity.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/sanity.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -9,3 +9,4 @@ bool glibc_sanity_test();\n bool glibcxx_sanity_test();\n \n #endif // BITCON_COMPAT_SANITY_H\n+"
      },
      {
        "sha": "856bf50037037960445f9ba133549b7572f528f1",
        "filename": "src/core.cpp",
        "status": "modified",
        "additions": 133,
        "deletions": 32,
        "changes": 165,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/core.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/core.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -11,7 +11,7 @@\n \n std::string COutPoint::ToString() const\n {\n-    return strprintf(\"COutPoint(%s, %u)\", hash.ToString().substr(0,10), n);\n+    return strprintf(\"COutPoint(%s, %u)\", hash.ToString().substr(0, 10), n);\n }\n \n CTxIn::CTxIn(COutPoint prevoutIn, CScript scriptSigIn, uint32_t nSequenceIn)\n@@ -31,14 +31,24 @@ CTxIn::CTxIn(uint256 hashPrevTx, uint32_t nOut, CScript scriptSigIn, uint32_t nS\n std::string CTxIn::ToString() const\n {\n     std::string str;\n+\n     str += \"CTxIn(\";\n     str += prevout.ToString();\n+\n     if (prevout.IsNull())\n+    {\n         str += strprintf(\", coinbase %s\", HexStr(scriptSig));\n+    }\n     else\n-        str += strprintf(\", scriptSig=%s\", scriptSig.ToString().substr(0,24));\n+    {\n+        str += strprintf(\", scriptSig=%s\", scriptSig.ToString().substr(0, 24));\n+    }\n+\n     if (nSequence != std::numeric_limits<unsigned int>::max())\n+    {\n         str += strprintf(\", nSequence=%u\", nSequence);\n+    }\n+\n     str += \")\";\n     return str;\n }\n@@ -56,23 +66,30 @@ uint256 CTxOut::GetHash() const\n \n std::string CTxOut::ToString() const\n {\n-    return strprintf(\"CTxOut(nValue=%d.%08d, scriptPubKey=%s)\", nValue / COIN, nValue % COIN, scriptPubKey.ToString().substr(0,30));\n+    return strprintf(\"CTxOut(nValue=%d.%08d, scriptPubKey=%s)\", nValue / COIN, nValue % COIN,\n+        scriptPubKey.ToString().substr(0, 30));\n }\n \n CFeeRate::CFeeRate(int64_t nFeePaid, size_t nSize)\n {\n     if (nSize > 0)\n-        nSatoshisPerK = nFeePaid*1000/nSize;\n+    {\n+        nSatoshisPerK = nFeePaid * 1000 / nSize;\n+    }\n     else\n+    {\n         nSatoshisPerK = 0;\n+    }\n }\n \n int64_t CFeeRate::GetFee(size_t nSize) const\n {\n-    int64_t nFee = nSatoshisPerK*nSize / 1000;\n+    int64_t nFee = nSatoshisPerK * nSize / 1000;\n \n     if (nFee == 0 && nSatoshisPerK > 0)\n+    {\n         nFee = nSatoshisPerK;\n+    }\n \n     return nFee;\n }\n@@ -82,8 +99,14 @@ std::string CFeeRate::ToString() const\n     return strprintf(\"%d.%08d BTC/kB\", nSatoshisPerK / COIN, nSatoshisPerK % COIN);\n }\n \n-CMutableTransaction::CMutableTransaction() : nVersion(CTransaction::CURRENT_VERSION), nLockTime(0) {}\n-CMutableTransaction::CMutableTransaction(const CTransaction& tx) : nVersion(tx.nVersion), vin(tx.vin), vout(tx.vout), nLockTime(tx.nLockTime) {}\n+CMutableTransaction::CMutableTransaction() : nVersion(CTransaction::CURRENT_VERSION), nLockTime(0)\n+{\n+}\n+\n+CMutableTransaction::CMutableTransaction(const CTransaction& tx) : nVersion(tx.nVersion), vin(tx.vin), vout(tx.vout),\n+    nLockTime(tx.nLockTime)\n+{\n+}\n \n uint256 CMutableTransaction::GetHash() const\n {\n@@ -95,13 +118,18 @@ void CTransaction::UpdateHash() const\n     *const_cast<uint256*>(&hash) = SerializeHash(*this);\n }\n \n-CTransaction::CTransaction() : hash(0), nVersion(CTransaction::CURRENT_VERSION), vin(), vout(), nLockTime(0) { }\n+CTransaction::CTransaction() : hash(0), nVersion(CTransaction::CURRENT_VERSION), vin(), vout(), nLockTime(0)\n+{\n+}\n \n-CTransaction::CTransaction(const CMutableTransaction &tx) : nVersion(tx.nVersion), vin(tx.vin), vout(tx.vout), nLockTime(tx.nLockTime) {\n+CTransaction::CTransaction(const CMutableTransaction &tx) : nVersion(tx.nVersion), vin(tx.vin), vout(tx.vout),\n+    nLockTime(tx.nLockTime)\n+{\n     UpdateHash();\n }\n \n-CTransaction& CTransaction::operator=(const CTransaction &tx) {\n+CTransaction& CTransaction::operator=(const CTransaction &tx)\n+{\n     *const_cast<int*>(&nVersion) = tx.nVersion;\n     *const_cast<std::vector<CTxIn>*>(&vin) = tx.vin;\n     *const_cast<std::vector<CTxOut>*>(&vout) = tx.vout;\n@@ -113,12 +141,17 @@ CTransaction& CTransaction::operator=(const CTransaction &tx) {\n int64_t CTransaction::GetValueOut() const\n {\n     int64_t nValueOut = 0;\n-    BOOST_FOREACH(const CTxOut& txout, vout)\n+\n+    BOOST_FOREACH (const CTxOut& txout, vout)\n     {\n         nValueOut += txout.nValue;\n+\n         if (!MoneyRange(txout.nValue) || !MoneyRange(nValueOut))\n+        {\n             throw std::runtime_error(\"CTransaction::GetValueOut() : value out of range\");\n+        }\n     }\n+\n     return nValueOut;\n }\n \n@@ -130,30 +163,49 @@ double CTransaction::ComputePriority(double dPriorityInputs, unsigned int nTxSiz\n     // Providing any more cleanup incentive than making additional inputs free would\n     // risk encouraging people to create junk outputs to redeem later.\n     if (nTxSize == 0)\n+    {\n         nTxSize = ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION);\n-    BOOST_FOREACH(const CTxIn& txin, vin)\n+    }\n+\n+    BOOST_FOREACH (const CTxIn& txin, vin)\n     {\n         unsigned int offset = 41U + std::min(110U, (unsigned int)txin.scriptSig.size());\n+\n         if (nTxSize > offset)\n+        {\n             nTxSize -= offset;\n+        }\n     }\n-    if (nTxSize == 0) return 0.0;\n+\n+    if (nTxSize == 0)\n+    {\n+        return 0.0;\n+    }\n+\n     return dPriorityInputs / nTxSize;\n }\n \n std::string CTransaction::ToString() const\n {\n     std::string str;\n+\n     str += strprintf(\"CTransaction(hash=%s, ver=%d, vin.size=%u, vout.size=%u, nLockTime=%u)\\n\",\n-        GetHash().ToString().substr(0,10),\n+        GetHash().ToString().substr(0, 10),\n         nVersion,\n         vin.size(),\n         vout.size(),\n         nLockTime);\n+\n     for (unsigned int i = 0; i < vin.size(); i++)\n+    {\n         str += \"    \" + vin[i].ToString() + \"\\n\";\n+    }\n+\n     for (unsigned int i = 0; i < vout.size(); i++)\n+    {\n         str += \"    \" + vout[i].ToString() + \"\\n\";\n+    }\n+\n     return str;\n }\n \n@@ -169,45 +221,64 @@ std::string CTransaction::ToString() const\n uint64_t CTxOutCompressor::CompressAmount(uint64_t n)\n {\n     if (n == 0)\n+    {\n         return 0;\n+    }\n+\n     int e = 0;\n-    while (((n % 10) == 0) && e < 9) {\n+\n+    while (((n % 10) == 0) && e < 9)\n+    {\n         n /= 10;\n         e++;\n     }\n-    if (e < 9) {\n+\n+    if (e < 9)\n+    {\n         int d = (n % 10);\n         assert(d >= 1 && d <= 9);\n         n /= 10;\n-        return 1 + (n*9 + d - 1)*10 + e;\n-    } else {\n-        return 1 + (n - 1)*10 + 9;\n+        return 1 + (n * 9 + d - 1) * 10 + e;\n+    }\n+    else\n+    {\n+        return 1 + (n - 1) * 10 + 9;\n     }\n }\n \n uint64_t CTxOutCompressor::DecompressAmount(uint64_t x)\n {\n     // x = 0  OR  x = 1+10*(9*n + d - 1) + e  OR  x = 1+10*(n - 1) + 9\n     if (x == 0)\n+    {\n         return 0;\n+    }\n+\n     x--;\n     // x = 10*(9*n + d - 1) + e\n     int e = x % 10;\n     x /= 10;\n     uint64_t n = 0;\n-    if (e < 9) {\n+\n+    if (e < 9)\n+    {\n         // x = 9*n + d - 1\n         int d = (x % 9) + 1;\n         x /= 9;\n         // x = n\n-        n = x*10 + d;\n-    } else {\n-        n = x+1;\n+        n = x * 10 + d;\n+    }\n+    else\n+    {\n+        n = x + 1;\n     }\n-    while (e) {\n+\n+    while (e)\n+    {\n         n *= 10;\n         e--;\n     }\n+\n     return n;\n }\n \n@@ -219,70 +290,100 @@ uint256 CBlockHeader::GetHash() const\n uint256 CBlock::BuildMerkleTree() const\n {\n     vMerkleTree.clear();\n-    BOOST_FOREACH(const CTransaction& tx, vtx)\n+\n+    BOOST_FOREACH (const CTransaction& tx, vtx)\n+    {\n         vMerkleTree.push_back(tx.GetHash());\n+    }\n+\n     int j = 0;\n+\n     for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n     {\n         for (int i = 0; i < nSize; i += 2)\n         {\n-            int i2 = std::min(i+1, nSize-1);\n-            vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n-                                       BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n+            int i2 = std::min(i + 1, nSize - 1);\n+            vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j + i]), END(vMerkleTree[j + i]),\n+                    BEGIN(vMerkleTree[j + i2]), END(vMerkleTree[j + i2])));\n         }\n+\n         j += nSize;\n     }\n+\n     return (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n }\n \n std::vector<uint256> CBlock::GetMerkleBranch(int nIndex) const\n {\n     if (vMerkleTree.empty())\n+    {\n         BuildMerkleTree();\n+    }\n+\n     std::vector<uint256> vMerkleBranch;\n     int j = 0;\n+\n     for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n     {\n-        int i = std::min(nIndex^1, nSize-1);\n-        vMerkleBranch.push_back(vMerkleTree[j+i]);\n+        int i = std::min(nIndex ^ 1, nSize - 1);\n+        vMerkleBranch.push_back(vMerkleTree[j + i]);\n         nIndex >>= 1;\n         j += nSize;\n     }\n+\n     return vMerkleBranch;\n }\n \n uint256 CBlock::CheckMerkleBranch(uint256 hash, const std::vector<uint256>& vMerkleBranch, int nIndex)\n {\n     if (nIndex == -1)\n+    {\n         return 0;\n-    BOOST_FOREACH(const uint256& otherside, vMerkleBranch)\n+    }\n+\n+    BOOST_FOREACH (const uint256& otherside, vMerkleBranch)\n     {\n         if (nIndex & 1)\n+        {\n             hash = Hash(BEGIN(otherside), END(otherside), BEGIN(hash), END(hash));\n+        }\n         else\n+        {\n             hash = Hash(BEGIN(hash), END(hash), BEGIN(otherside), END(otherside));\n+        }\n+\n         nIndex >>= 1;\n     }\n+\n     return hash;\n }\n \n std::string CBlock::ToString() const\n {\n     std::stringstream s;\n-    s << strprintf(\"CBlock(hash=%s, ver=%d, hashPrevBlock=%s, hashMerkleRoot=%s, nTime=%u, nBits=%08x, nNonce=%u, vtx=%u)\\n\",\n+\n+    s << strprintf(\n+        \"CBlock(hash=%s, ver=%d, hashPrevBlock=%s, hashMerkleRoot=%s, nTime=%u, nBits=%08x, nNonce=%u, vtx=%u)\\n\",\n         GetHash().ToString(),\n         nVersion,\n         hashPrevBlock.ToString(),\n         hashMerkleRoot.ToString(),\n         nTime, nBits, nNonce,\n         vtx.size());\n+\n     for (unsigned int i = 0; i < vtx.size(); i++)\n     {\n         s << \"  \" << vtx[i].ToString() << \"\\n\";\n     }\n+\n     s << \"  vMerkleTree: \";\n+\n     for (unsigned int i = 0; i < vMerkleTree.size(); i++)\n+    {\n         s << \" \" << vMerkleTree[i].ToString();\n+    }\n+\n     s << \"\\n\";\n     return s.str();\n }\n+"
      },
      {
        "sha": "3a6e1f4fc2ce00a51a324413854b55ab759fb0aa",
        "filename": "src/core.h",
        "status": "modified",
        "additions": 171,
        "deletions": 60,
        "changes": 231,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/core.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/core.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -20,7 +20,10 @@ static const int64_t CENT = 1000000;\n \n /** No amount larger than this (in satoshi) is valid */\n static const int64_t MAX_MONEY = 21000000 * COIN;\n-inline bool MoneyRange(int64_t nValue) { return (nValue >= 0 && nValue <= MAX_MONEY); }\n+inline bool MoneyRange(int64_t nValue)\n+{\n+    return (nValue >= 0 && nValue <= MAX_MONEY);\n+}\n \n /** An outpoint - a combination of a transaction hash and an index n into its vout */\n class COutPoint\n@@ -29,18 +32,35 @@ class COutPoint\n     uint256 hash;\n     uint32_t n;\n \n-    COutPoint() { SetNull(); }\n-    COutPoint(uint256 hashIn, uint32_t nIn) { hash = hashIn; n = nIn; }\n+    COutPoint()\n+    {\n+        SetNull();\n+    }\n+\n+    COutPoint(uint256 hashIn, uint32_t nIn)\n+    {\n+        hash = hashIn;\n+        n = nIn;\n+    }\n \n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n         READWRITE(FLATDATA(*this));\n     }\n \n-    void SetNull() { hash = 0; n = (uint32_t) -1; }\n-    bool IsNull() const { return (hash == 0 && n == (uint32_t) -1); }\n+    void SetNull()\n+    {\n+        hash = 0;\n+        n = (uint32_t) -1;\n+    }\n+\n+    bool IsNull() const\n+    {\n+        return (hash == 0 && n == (uint32_t) -1);\n+    }\n \n     friend bool operator<(const COutPoint& a, const COutPoint& b)\n     {\n@@ -67,10 +87,27 @@ class CInPoint\n     const CTransaction* ptx;\n     uint32_t n;\n \n-    CInPoint() { SetNull(); }\n-    CInPoint(const CTransaction* ptxIn, uint32_t nIn) { ptx = ptxIn; n = nIn; }\n-    void SetNull() { ptx = NULL; n = (uint32_t) -1; }\n-    bool IsNull() const { return (ptx == NULL && n == (uint32_t) -1); }\n+    CInPoint()\n+    {\n+        SetNull();\n+    }\n+\n+    CInPoint(const CTransaction* ptxIn, uint32_t nIn)\n+    {\n+        ptx = ptxIn;\n+        n = nIn;\n+    }\n+\n+    void SetNull()\n+    {\n+        ptx = NULL;\n+        n = (uint32_t) -1;\n+    }\n+\n+    bool IsNull() const\n+    {\n+        return (ptx == NULL && n == (uint32_t) -1);\n+    }\n };\n \n /** An input of a transaction.  It contains the location of the previous\n@@ -89,13 +126,16 @@ class CTxIn\n         nSequence = std::numeric_limits<unsigned int>::max();\n     }\n \n-    explicit CTxIn(COutPoint prevoutIn, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=std::numeric_limits<unsigned int>::max());\n-    CTxIn(uint256 hashPrevTx, uint32_t nOut, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=std::numeric_limits<uint32_t>::max());\n+    explicit CTxIn(COutPoint prevoutIn, CScript scriptSigIn = CScript(), uint32_t nSequenceIn =\n+            std::numeric_limits<unsigned int>::max());\n+    CTxIn(uint256 hashPrevTx, uint32_t nOut,\n+        CScript scriptSigIn = CScript(), uint32_t nSequenceIn = std::numeric_limits<uint32_t>::max());\n \n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n         READWRITE(prevout);\n         READWRITE(scriptSig);\n         READWRITE(nSequence);\n@@ -109,8 +149,8 @@ class CTxIn\n     friend bool operator==(const CTxIn& a, const CTxIn& b)\n     {\n         return (a.prevout   == b.prevout &&\n-                a.scriptSig == b.scriptSig &&\n-                a.nSequence == b.nSequence);\n+            a.scriptSig == b.scriptSig &&\n+            a.nSequence == b.nSequence);\n     }\n \n     friend bool operator!=(const CTxIn& a, const CTxIn& b)\n@@ -121,8 +161,6 @@ class CTxIn\n     std::string ToString() const;\n };\n \n-\n-\n /** Type-safe wrapper class to for fee rates\n  * (how much to pay based on transaction size)\n  */\n@@ -131,30 +169,62 @@ class CFeeRate\n private:\n     int64_t nSatoshisPerK; // unit is satoshis-per-1,000-bytes\n public:\n-    CFeeRate() : nSatoshisPerK(0) { }\n-    explicit CFeeRate(int64_t _nSatoshisPerK): nSatoshisPerK(_nSatoshisPerK) { }\n+    CFeeRate() : nSatoshisPerK(0)\n+    {\n+    }\n+\n+    explicit CFeeRate(int64_t _nSatoshisPerK) : nSatoshisPerK(_nSatoshisPerK)\n+    {\n+    }\n+\n     CFeeRate(int64_t nFeePaid, size_t nSize);\n-    CFeeRate(const CFeeRate& other) { nSatoshisPerK = other.nSatoshisPerK; }\n+    CFeeRate(const CFeeRate& other)\n+    {\n+        nSatoshisPerK = other.nSatoshisPerK;\n+    }\n \n     int64_t GetFee(size_t size) const; // unit returned is satoshis\n-    int64_t GetFeePerK() const { return GetFee(1000); } // satoshis-per-1000-bytes\n+    int64_t GetFeePerK() const\n+    {\n+        return GetFee(1000);\n+    }                                                   // satoshis-per-1000-bytes\n+\n+    friend bool operator<(const CFeeRate& a, const CFeeRate& b)\n+    {\n+        return a.nSatoshisPerK < b.nSatoshisPerK;\n+    }\n+\n+    friend bool operator>(const CFeeRate& a, const CFeeRate& b)\n+    {\n+        return a.nSatoshisPerK > b.nSatoshisPerK;\n+    }\n+\n+    friend bool operator==(const CFeeRate& a, const CFeeRate& b)\n+    {\n+        return a.nSatoshisPerK == b.nSatoshisPerK;\n+    }\n+\n+    friend bool operator<=(const CFeeRate& a, const CFeeRate& b)\n+    {\n+        return a.nSatoshisPerK <= b.nSatoshisPerK;\n+    }\n+\n+    friend bool operator>=(const CFeeRate& a, const CFeeRate& b)\n+    {\n+        return a.nSatoshisPerK >= b.nSatoshisPerK;\n+    }\n \n-    friend bool operator<(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK < b.nSatoshisPerK; }\n-    friend bool operator>(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK > b.nSatoshisPerK; }\n-    friend bool operator==(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK == b.nSatoshisPerK; }\n-    friend bool operator<=(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK <= b.nSatoshisPerK; }\n-    friend bool operator>=(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK >= b.nSatoshisPerK; }\n     std::string ToString() const;\n \n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n         READWRITE(nSatoshisPerK);\n     }\n };\n \n-\n /** An output of a transaction.  It contains the public key that the next input\n  * must be able to sign with to claim it.\n  */\n@@ -174,7 +244,8 @@ class CTxOut\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n         READWRITE(nValue);\n         READWRITE(scriptPubKey);\n     }\n@@ -200,16 +271,17 @@ class CTxOut\n         // to spend something, then we consider it dust.\n         // A typical txout is 34 bytes big, and will\n         // need a CTxIn of at least 148 bytes to spend:\n-        // so dust is a txout less than 546 satoshis \n+        // so dust is a txout less than 546 satoshis\n         // with default minRelayTxFee.\n-        size_t nSize = GetSerializeSize(SER_DISK,0)+148u;\n-        return (nValue < 3*minRelayTxFee.GetFee(nSize));\n+        size_t nSize = GetSerializeSize(SER_DISK, 0) + 148u;\n+\n+        return (nValue < 3 * minRelayTxFee.GetFee(nSize));\n     }\n \n     friend bool operator==(const CTxOut& a, const CTxOut& b)\n     {\n         return (a.nValue       == b.nValue &&\n-                a.scriptPubKey == b.scriptPubKey);\n+            a.scriptPubKey == b.scriptPubKey);\n     }\n \n     friend bool operator!=(const CTxOut& a, const CTxOut& b)\n@@ -220,7 +292,6 @@ class CTxOut\n     std::string ToString() const;\n };\n \n-\n struct CMutableTransaction;\n \n /** The basic transaction that is broadcasted on the network and contained in\n@@ -234,7 +305,7 @@ class CTransaction\n     void UpdateHash() const;\n \n public:\n-    static const int32_t CURRENT_VERSION=1;\n+    static const int32_t CURRENT_VERSION = 1;\n \n     // The local variables are made const to prevent unintended modification\n     // without updating the cached hash value. However, CTransaction is not\n@@ -257,21 +328,27 @@ class CTransaction\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n         READWRITE(*const_cast<int32_t*>(&this->nVersion));\n         nVersion = this->nVersion;\n         READWRITE(*const_cast<std::vector<CTxIn>*>(&vin));\n         READWRITE(*const_cast<std::vector<CTxOut>*>(&vout));\n         READWRITE(*const_cast<uint32_t*>(&nLockTime));\n+\n         if (ser_action.ForRead())\n+        {\n             UpdateHash();\n+        }\n     }\n \n-    bool IsNull() const {\n+    bool IsNull() const\n+    {\n         return vin.empty() && vout.empty();\n     }\n \n-    const uint256& GetHash() const {\n+    const uint256& GetHash() const\n+    {\n         return hash;\n     }\n \n@@ -281,7 +358,7 @@ class CTransaction\n     // inputs must be known to compute value in.\n \n     // Compute priority, given priority of inputs and (optionally) tx size\n-    double ComputePriority(double dPriorityInputs, unsigned int nTxSize=0) const;\n+    double ComputePriority(double dPriorityInputs, unsigned int nTxSize = 0) const;\n \n     bool IsCoinBase() const\n     {\n@@ -315,7 +392,8 @@ struct CMutableTransaction\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n         READWRITE(this->nVersion);\n         nVersion = this->nVersion;\n         READWRITE(vin);\n@@ -339,20 +417,27 @@ class CTxOutCompressor\n     static uint64_t CompressAmount(uint64_t nAmount);\n     static uint64_t DecompressAmount(uint64_t nAmount);\n \n-    CTxOutCompressor(CTxOut &txoutIn) : txout(txoutIn) { }\n+    CTxOutCompressor(CTxOut &txoutIn) : txout(txoutIn)\n+    {\n+    }\n \n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n-        if (!ser_action.ForRead()) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n+        if (!ser_action.ForRead())\n+        {\n             uint64_t nVal = CompressAmount(txout.nValue);\n             READWRITE(VARINT(nVal));\n-        } else {\n+        }\n+        else\n+        {\n             uint64_t nVal = 0;\n             READWRITE(VARINT(nVal));\n             txout.nValue = DecompressAmount(nVal);\n         }\n+\n         CScriptCompressor cscript(REF(txout.scriptPubKey));\n         READWRITE(cscript);\n     }\n@@ -372,31 +457,49 @@ class CTxInUndo\n     unsigned int nHeight; // if the outpoint was the last unspent: its height\n     int nVersion;         // if the outpoint was the last unspent: its version\n \n-    CTxInUndo() : txout(), fCoinBase(false), nHeight(0), nVersion(0) {}\n-    CTxInUndo(const CTxOut &txoutIn, bool fCoinBaseIn = false, unsigned int nHeightIn = 0, int nVersionIn = 0) : txout(txoutIn), fCoinBase(fCoinBaseIn), nHeight(nHeightIn), nVersion(nVersionIn) { }\n+    CTxInUndo() : txout(), fCoinBase(false), nHeight(0), nVersion(0)\n+    {\n+    }\n+\n+    CTxInUndo(const CTxOut &txoutIn, bool fCoinBaseIn = false, unsigned int nHeightIn = 0, int nVersionIn =\n+            0) : txout(txoutIn), fCoinBase(fCoinBaseIn), nHeight(nHeightIn), nVersion(nVersionIn)\n+    {\n+    }\n \n-    unsigned int GetSerializeSize(int nType, int nVersion) const {\n-        return ::GetSerializeSize(VARINT(nHeight*2+(fCoinBase ? 1 : 0)), nType, nVersion) +\n+    unsigned int GetSerializeSize(int nType, int nVersion) const\n+    {\n+        return ::GetSerializeSize(VARINT(nHeight * 2 + (fCoinBase ? 1 : 0)), nType, nVersion) +\n                (nHeight > 0 ? ::GetSerializeSize(VARINT(this->nVersion), nType, nVersion) : 0) +\n                ::GetSerializeSize(CTxOutCompressor(REF(txout)), nType, nVersion);\n     }\n \n     template<typename Stream>\n-    void Serialize(Stream &s, int nType, int nVersion) const {\n-        ::Serialize(s, VARINT(nHeight*2+(fCoinBase ? 1 : 0)), nType, nVersion);\n+    void Serialize(Stream &s, int nType, int nVersion) const\n+    {\n+        ::Serialize(s, VARINT(nHeight * 2 + (fCoinBase ? 1 : 0)), nType, nVersion);\n+\n         if (nHeight > 0)\n+        {\n             ::Serialize(s, VARINT(this->nVersion), nType, nVersion);\n+        }\n+\n         ::Serialize(s, CTxOutCompressor(REF(txout)), nType, nVersion);\n     }\n \n     template<typename Stream>\n-    void Unserialize(Stream &s, int nType, int nVersion) {\n+    void Unserialize(Stream &s, int nType, int nVersion)\n+    {\n         unsigned int nCode = 0;\n+\n         ::Unserialize(s, VARINT(nCode), nType, nVersion);\n         nHeight = nCode / 2;\n         fCoinBase = nCode & 1;\n+\n         if (nHeight > 0)\n+        {\n             ::Unserialize(s, VARINT(this->nVersion), nType, nVersion);\n+        }\n+\n         ::Unserialize(s, REF(CTxOutCompressor(REF(txout))), nType, nVersion);\n     }\n };\n@@ -411,12 +514,12 @@ class CTxUndo\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n         READWRITE(vprevout);\n     }\n };\n \n-\n /** Nodes collect new transactions into a block, hash them into a hash tree,\n  * and scan through nonce values to make the block's hash satisfy proof-of-work\n  * requirements.  When they solve the proof-of-work, they broadcast the block\n@@ -428,7 +531,7 @@ class CBlockHeader\n {\n public:\n     // header\n-    static const int32_t CURRENT_VERSION=2;\n+    static const int32_t CURRENT_VERSION = 2;\n     int32_t nVersion;\n     uint256 hashPrevBlock;\n     uint256 hashMerkleRoot;\n@@ -444,7 +547,8 @@ class CBlockHeader\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n         READWRITE(this->nVersion);\n         nVersion = this->nVersion;\n         READWRITE(hashPrevBlock);\n@@ -477,7 +581,6 @@ class CBlockHeader\n     }\n };\n \n-\n class CBlock : public CBlockHeader\n {\n public:\n@@ -501,7 +604,8 @@ class CBlock : public CBlockHeader\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n         READWRITE(*(CBlockHeader*)this);\n         READWRITE(vtx);\n     }\n@@ -516,6 +620,7 @@ class CBlock : public CBlockHeader\n     CBlockHeader GetBlockHeader() const\n     {\n         CBlockHeader block;\n+\n         block.nVersion       = nVersion;\n         block.hashPrevBlock  = hashPrevBlock;\n         block.hashMerkleRoot = hashMerkleRoot;\n@@ -532,7 +637,6 @@ class CBlock : public CBlockHeader\n     std::string ToString() const;\n };\n \n-\n /** Describes a place in the block chain to another node such that if the\n  * other node doesn't have the same branch, it can find a recent common trunk.\n  * The further back it is, the further before the fork it may be.\n@@ -541,7 +645,9 @@ struct CBlockLocator\n {\n     std::vector<uint256> vHave;\n \n-    CBlockLocator() {}\n+    CBlockLocator()\n+    {\n+    }\n \n     CBlockLocator(const std::vector<uint256>& vHaveIn)\n     {\n@@ -551,9 +657,13 @@ struct CBlockLocator\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n         if (!(nType & SER_GETHASH))\n+        {\n             READWRITE(nVersion);\n+        }\n+\n         READWRITE(vHave);\n     }\n \n@@ -569,3 +679,4 @@ struct CBlockLocator\n };\n \n #endif // BITCOIN_CORE_H\n+"
      },
      {
        "sha": "10a2b8b73619a52d0fda8136074db7de84b91fb1",
        "filename": "src/core_io.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/core_io.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/core_io.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_io.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -21,8 +21,8 @@ extern std::vector<unsigned char> ParseHexUV(const UniValue& v, const std::strin\n \n // core_write.cpp\n extern std::string EncodeHexTx(const CTransaction& tx);\n-extern void ScriptPubKeyToUniv(const CScript& scriptPubKey,\n-                        UniValue& out, bool fIncludeHex);\n+extern void ScriptPubKeyToUniv(const CScript& scriptPubKey, UniValue& out, bool fIncludeHex);\n extern void TxToUniv(const CTransaction& tx, const uint256& hashBlock, UniValue& entry);\n \n #endif // __BITCOIN_CORE_IO_H__\n+"
      },
      {
        "sha": "7bcacb841951b354330239d53489b939cc3a31e6",
        "filename": "src/core_read.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 8,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/core_read.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/core_read.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_read.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -31,11 +31,17 @@ CScript ParseScript(std::string s)\n         {\n             // Allow OP_RESERVED to get into mapOpNames\n             if (op < OP_NOP && op != OP_RESERVED)\n+            {\n                 continue;\n+            }\n \n             const char* name = GetOpName((opcodetype)op);\n+\n             if (strcmp(name, \"OP_UNKNOWN\") == 0)\n+            {\n                 continue;\n+            }\n+\n             string strName(name);\n             mapOpNames[strName] = (opcodetype)op;\n             // Convenience: OP_ADD and just ADD are both recognized:\n@@ -54,23 +60,23 @@ CScript ParseScript(std::string s)\n             // Empty string, ignore. (boost::split given '' will return one word)\n         }\n         else if (all(*w, is_digit()) ||\n-            (starts_with(*w, \"-\") && all(string(w->begin()+1, w->end()), is_digit())))\n+            (starts_with(*w, \"-\") && all(string(w->begin() + 1, w->end()), is_digit())))\n         {\n             // Number\n             int64_t n = atoi64(*w);\n             result << n;\n         }\n-        else if (starts_with(*w, \"0x\") && (w->begin()+2 != w->end()) && IsHex(string(w->begin()+2, w->end())))\n+        else if (starts_with(*w, \"0x\") && (w->begin() + 2 != w->end()) && IsHex(string(w->begin() + 2, w->end())))\n         {\n             // Raw hex data, inserted NOT pushed onto stack:\n-            std::vector<unsigned char> raw = ParseHex(string(w->begin()+2, w->end()));\n+            std::vector<unsigned char> raw = ParseHex(string(w->begin() + 2, w->end()));\n             result.insert(result.end(), raw.begin(), raw.end());\n         }\n         else if (w->size() >= 2 && starts_with(*w, \"'\") && ends_with(*w, \"'\"))\n         {\n             // Single-quoted string, pushed as data. NOTE: this is poor-man's\n             // parsing, spaces/tabs/newlines in single-quoted strings won't work.\n-            std::vector<unsigned char> value(w->begin()+1, w->end()-1);\n+            std::vector<unsigned char> value(w->begin() + 1, w->end() - 1);\n             result << value;\n         }\n         else if (mapOpNames.count(*w))\n@@ -90,14 +96,18 @@ CScript ParseScript(std::string s)\n bool DecodeHexTx(CTransaction& tx, const std::string& strHexTx)\n {\n     if (!IsHex(strHexTx))\n+    {\n         return false;\n+    }\n \n     vector<unsigned char> txData(ParseHex(strHexTx));\n     CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n-    try {\n+    try\n+    {\n         ssData >> tx;\n     }\n-    catch (std::exception &e) {\n+    catch (std::exception &e)\n+    {\n         return false;\n     }\n \n@@ -107,10 +117,16 @@ bool DecodeHexTx(CTransaction& tx, const std::string& strHexTx)\n uint256 ParseHashUV(const UniValue& v, const string& strName)\n {\n     string strHex;\n+\n     if (v.isStr())\n+    {\n         strHex = v.getValStr();\n+    }\n+\n     if (!IsHex(strHex)) // Note: IsHex(\"\") is false\n-        throw runtime_error(strName+\" must be hexadecimal string (not '\"+strHex+\"')\");\n+    {\n+        throw runtime_error(strName + \" must be hexadecimal string (not '\" + strHex + \"')\");\n+    }\n \n     uint256 result;\n     result.SetHex(strHex);\n@@ -120,9 +136,17 @@ uint256 ParseHashUV(const UniValue& v, const string& strName)\n vector<unsigned char> ParseHexUV(const UniValue& v, const string& strName)\n {\n     string strHex;\n+\n     if (v.isStr())\n+    {\n         strHex = v.getValStr();\n+    }\n+\n     if (!IsHex(strHex))\n-        throw runtime_error(strName+\" must be hexadecimal string (not '\"+strHex+\"')\");\n+    {\n+        throw runtime_error(strName + \" must be hexadecimal string (not '\" + strHex + \"')\");\n+    }\n+\n     return ParseHex(strHex);\n }\n+"
      },
      {
        "sha": "89361e11b69fa2c6dc72262c5b991e4fc712a55f",
        "filename": "src/core_write.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 6,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/core_write.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/core_write.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_write.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -19,22 +19,28 @@ using namespace std;\n string EncodeHexTx(const CTransaction& tx)\n {\n     CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+\n     ssTx << tx;\n     return HexStr(ssTx.begin(), ssTx.end());\n }\n \n void ScriptPubKeyToUniv(const CScript& scriptPubKey,\n-                        UniValue& out, bool fIncludeHex)\n+    UniValue& out, bool fIncludeHex)\n {\n     txnouttype type;\n+\n     vector<CTxDestination> addresses;\n     int nRequired;\n \n     out.pushKV(\"asm\", scriptPubKey.ToString());\n+\n     if (fIncludeHex)\n+    {\n         out.pushKV(\"hex\", HexStr(scriptPubKey.begin(), scriptPubKey.end()));\n+    }\n \n-    if (!ExtractDestinations(scriptPubKey, type, addresses, nRequired)) {\n+    if (!ExtractDestinations(scriptPubKey, type, addresses, nRequired))\n+    {\n         out.pushKV(\"type\", GetTxnOutputType(type));\n         return;\n     }\n@@ -43,8 +49,12 @@ void ScriptPubKeyToUniv(const CScript& scriptPubKey,\n     out.pushKV(\"type\", GetTxnOutputType(type));\n \n     UniValue a(UniValue::VARR);\n-    BOOST_FOREACH(const CTxDestination& addr, addresses)\n+\n+    BOOST_FOREACH (const CTxDestination& addr, addresses)\n+    {\n         a.push_back(CBitcoinAddress(addr).ToString());\n+    }\n+\n     out.pushKV(\"addresses\", a);\n }\n \n@@ -55,25 +65,35 @@ void TxToUniv(const CTransaction& tx, const uint256& hashBlock, UniValue& entry)\n     entry.pushKV(\"locktime\", (int64_t)tx.nLockTime);\n \n     UniValue vin(UniValue::VARR);\n-    BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n+\n+    BOOST_FOREACH (const CTxIn& txin, tx.vin)\n+    {\n         UniValue in(UniValue::VOBJ);\n+\n         if (tx.IsCoinBase())\n+        {\n             in.pushKV(\"coinbase\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end()));\n-        else {\n+        }\n+        else\n+        {\n             in.pushKV(\"txid\", txin.prevout.hash.GetHex());\n             in.pushKV(\"vout\", (int64_t)txin.prevout.n);\n             UniValue o(UniValue::VOBJ);\n             o.pushKV(\"asm\", txin.scriptSig.ToString());\n             o.pushKV(\"hex\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end()));\n             in.pushKV(\"scriptSig\", o);\n         }\n+\n         in.pushKV(\"sequence\", (int64_t)txin.nSequence);\n         vin.push_back(in);\n     }\n+\n     entry.pushKV(\"vin\", vin);\n \n     UniValue vout(UniValue::VARR);\n-    for (unsigned int i = 0; i < tx.vout.size(); i++) {\n+\n+    for (unsigned int i = 0; i < tx.vout.size(); i++)\n+    {\n         const CTxOut& txout = tx.vout[i];\n \n         UniValue out(UniValue::VOBJ);\n@@ -87,8 +107,12 @@ void TxToUniv(const CTransaction& tx, const uint256& hashBlock, UniValue& entry)\n         out.pushKV(\"scriptPubKey\", o);\n         vout.push_back(out);\n     }\n+\n     entry.pushKV(\"vout\", vout);\n \n     if (hashBlock != 0)\n+    {\n         entry.pushKV(\"blockhash\", hashBlock.GetHex());\n+    }\n }\n+"
      },
      {
        "sha": "74c41c08dc28bded7ca2fb7df06fa63a851f377e",
        "filename": "src/crypter.cpp",
        "status": "modified",
        "additions": 140,
        "deletions": 18,
        "changes": 158,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/crypter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/crypter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypter.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -13,15 +13,22 @@\n #include <openssl/aes.h>\n #include <openssl/evp.h>\n \n-bool CCrypter::SetKeyFromPassphrase(const SecureString& strKeyData, const std::vector<unsigned char>& chSalt, const unsigned int nRounds, const unsigned int nDerivationMethod)\n+bool CCrypter::SetKeyFromPassphrase(const SecureString& strKeyData, const std::vector<unsigned char>& chSalt,\n+    const unsigned int nRounds,\n+    const unsigned int nDerivationMethod)\n {\n     if (nRounds < 1 || chSalt.size() != WALLET_CRYPTO_SALT_SIZE)\n+    {\n         return false;\n+    }\n \n     int i = 0;\n+\n     if (nDerivationMethod == 0)\n+    {\n         i = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha512(), &chSalt[0],\n-                          (unsigned char *)&strKeyData[0], strKeyData.size(), nRounds, chKey, chIV);\n+            (unsigned char*)&strKeyData[0], strKeyData.size(), nRounds, chKey, chIV);\n+    }\n \n     if (i != (int)WALLET_CRYPTO_KEY_SIZE)\n     {\n@@ -37,7 +44,9 @@ bool CCrypter::SetKeyFromPassphrase(const SecureString& strKeyData, const std::v\n bool CCrypter::SetKey(const CKeyingMaterial& chNewKey, const std::vector<unsigned char>& chNewIV)\n {\n     if (chNewKey.size() != WALLET_CRYPTO_KEY_SIZE || chNewIV.size() != WALLET_CRYPTO_KEY_SIZE)\n+    {\n         return false;\n+    }\n \n     memcpy(&chKey[0], &chNewKey[0], sizeof chKey);\n     memcpy(&chIV[0], &chNewIV[0], sizeof chIV);\n@@ -49,7 +58,9 @@ bool CCrypter::SetKey(const CKeyingMaterial& chNewKey, const std::vector<unsigne\n bool CCrypter::Encrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned char> &vchCiphertext)\n {\n     if (!fKeySet)\n+    {\n         return false;\n+    }\n \n     // max ciphertext len for a n bytes of plaintext is\n     // n + AES_BLOCK_SIZE - 1 bytes\n@@ -62,12 +73,28 @@ bool CCrypter::Encrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned\n     bool fOk = true;\n \n     EVP_CIPHER_CTX_init(&ctx);\n-    if (fOk) fOk = EVP_EncryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV);\n-    if (fOk) fOk = EVP_EncryptUpdate(&ctx, &vchCiphertext[0], &nCLen, &vchPlaintext[0], nLen);\n-    if (fOk) fOk = EVP_EncryptFinal_ex(&ctx, (&vchCiphertext[0])+nCLen, &nFLen);\n+\n+    if (fOk)\n+    {\n+        fOk = EVP_EncryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV);\n+    }\n+\n+    if (fOk)\n+    {\n+        fOk = EVP_EncryptUpdate(&ctx, &vchCiphertext[0], &nCLen, &vchPlaintext[0], nLen);\n+    }\n+\n+    if (fOk)\n+    {\n+        fOk = EVP_EncryptFinal_ex(&ctx, (&vchCiphertext[0]) + nCLen, &nFLen);\n+    }\n+\n     EVP_CIPHER_CTX_cleanup(&ctx);\n \n-    if (!fOk) return false;\n+    if (!fOk)\n+    {\n+        return false;\n+    }\n \n     vchCiphertext.resize(nCLen + nFLen);\n     return true;\n@@ -76,7 +103,9 @@ bool CCrypter::Encrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned\n bool CCrypter::Decrypt(const std::vector<unsigned char>& vchCiphertext, CKeyingMaterial& vchPlaintext)\n {\n     if (!fKeySet)\n+    {\n         return false;\n+    }\n \n     // plaintext will always be equal to or lesser than length of ciphertext\n     int nLen = vchCiphertext.size();\n@@ -89,53 +118,90 @@ bool CCrypter::Decrypt(const std::vector<unsigned char>& vchCiphertext, CKeyingM\n     bool fOk = true;\n \n     EVP_CIPHER_CTX_init(&ctx);\n-    if (fOk) fOk = EVP_DecryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV);\n-    if (fOk) fOk = EVP_DecryptUpdate(&ctx, &vchPlaintext[0], &nPLen, &vchCiphertext[0], nLen);\n-    if (fOk) fOk = EVP_DecryptFinal_ex(&ctx, (&vchPlaintext[0])+nPLen, &nFLen);\n+\n+    if (fOk)\n+    {\n+        fOk = EVP_DecryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV);\n+    }\n+\n+    if (fOk)\n+    {\n+        fOk = EVP_DecryptUpdate(&ctx, &vchPlaintext[0], &nPLen, &vchCiphertext[0], nLen);\n+    }\n+\n+    if (fOk)\n+    {\n+        fOk = EVP_DecryptFinal_ex(&ctx, (&vchPlaintext[0]) + nPLen, &nFLen);\n+    }\n+\n     EVP_CIPHER_CTX_cleanup(&ctx);\n \n-    if (!fOk) return false;\n+    if (!fOk)\n+    {\n+        return false;\n+    }\n \n     vchPlaintext.resize(nPLen + nFLen);\n     return true;\n }\n \n-\n-bool EncryptSecret(const CKeyingMaterial& vMasterKey, const CKeyingMaterial &vchPlaintext, const uint256& nIV, std::vector<unsigned char> &vchCiphertext)\n+bool EncryptSecret(const CKeyingMaterial& vMasterKey, const CKeyingMaterial &vchPlaintext, const uint256& nIV,\n+    std::vector<unsigned char> &vchCiphertext)\n {\n     CCrypter cKeyCrypter;\n+\n     std::vector<unsigned char> chIV(WALLET_CRYPTO_KEY_SIZE);\n     memcpy(&chIV[0], &nIV, WALLET_CRYPTO_KEY_SIZE);\n-    if(!cKeyCrypter.SetKey(vMasterKey, chIV))\n+\n+    if (!cKeyCrypter.SetKey(vMasterKey, chIV))\n+    {\n         return false;\n+    }\n+\n     return cKeyCrypter.Encrypt(*((const CKeyingMaterial*)&vchPlaintext), vchCiphertext);\n }\n \n-bool DecryptSecret(const CKeyingMaterial& vMasterKey, const std::vector<unsigned char>& vchCiphertext, const uint256& nIV, CKeyingMaterial& vchPlaintext)\n+bool DecryptSecret(const CKeyingMaterial& vMasterKey, const std::vector<unsigned char>& vchCiphertext,\n+    const uint256& nIV,\n+    CKeyingMaterial& vchPlaintext)\n {\n     CCrypter cKeyCrypter;\n+\n     std::vector<unsigned char> chIV(WALLET_CRYPTO_KEY_SIZE);\n     memcpy(&chIV[0], &nIV, WALLET_CRYPTO_KEY_SIZE);\n-    if(!cKeyCrypter.SetKey(vMasterKey, chIV))\n+\n+    if (!cKeyCrypter.SetKey(vMasterKey, chIV))\n+    {\n         return false;\n+    }\n+\n     return cKeyCrypter.Decrypt(vchCiphertext, *((CKeyingMaterial*)&vchPlaintext));\n }\n \n bool CCryptoKeyStore::SetCrypted()\n {\n     LOCK(cs_KeyStore);\n+\n     if (fUseCrypto)\n+    {\n         return true;\n+    }\n+\n     if (!mapKeys.empty())\n+    {\n         return false;\n+    }\n+\n     fUseCrypto = true;\n     return true;\n }\n \n bool CCryptoKeyStore::Lock()\n {\n     if (!SetCrypted())\n+    {\n         return false;\n+    }\n \n     {\n         LOCK(cs_KeyStore);\n@@ -150,45 +216,62 @@ bool CCryptoKeyStore::Unlock(const CKeyingMaterial& vMasterKeyIn)\n {\n     {\n         LOCK(cs_KeyStore);\n+\n         if (!SetCrypted())\n+        {\n             return false;\n+        }\n \n         bool keyPass = false;\n         bool keyFail = false;\n         CryptedKeyMap::const_iterator mi = mapCryptedKeys.begin();\n+\n         for (; mi != mapCryptedKeys.end(); ++mi)\n         {\n             const CPubKey &vchPubKey = (*mi).second.first;\n             const std::vector<unsigned char> &vchCryptedSecret = (*mi).second.second;\n             CKeyingMaterial vchSecret;\n-            if(!DecryptSecret(vMasterKeyIn, vchCryptedSecret, vchPubKey.GetHash(), vchSecret))\n+\n+            if (!DecryptSecret(vMasterKeyIn, vchCryptedSecret, vchPubKey.GetHash(), vchSecret))\n             {\n                 keyFail = true;\n                 break;\n             }\n+\n             if (vchSecret.size() != 32)\n             {\n                 keyFail = true;\n                 break;\n             }\n+\n             CKey key;\n             key.Set(vchSecret.begin(), vchSecret.end(), vchPubKey.IsCompressed());\n+\n             if (key.GetPubKey() != vchPubKey)\n             {\n                 keyFail = true;\n                 break;\n             }\n+\n             keyPass = true;\n+\n             if (fDecryptionThoroughlyChecked)\n+            {\n                 break;\n+            }\n         }\n+\n         if (keyPass && keyFail)\n         {\n             LogPrintf(\"The wallet is probably corrupted: Some keys decrypt but not all.\");\n             assert(false);\n         }\n+\n         if (keyFail || !keyPass)\n+        {\n             return false;\n+        }\n+\n         vMasterKey = vMasterKeyIn;\n         fDecryptionThoroughlyChecked = true;\n     }\n@@ -200,30 +283,42 @@ bool CCryptoKeyStore::AddKeyPubKey(const CKey& key, const CPubKey &pubkey)\n {\n     {\n         LOCK(cs_KeyStore);\n+\n         if (!IsCrypted())\n+        {\n             return CBasicKeyStore::AddKeyPubKey(key, pubkey);\n+        }\n \n         if (IsLocked())\n+        {\n             return false;\n+        }\n \n         std::vector<unsigned char> vchCryptedSecret;\n         CKeyingMaterial vchSecret(key.begin(), key.end());\n+\n         if (!EncryptSecret(vMasterKey, vchSecret, pubkey.GetHash(), vchCryptedSecret))\n+        {\n             return false;\n+        }\n \n         if (!AddCryptedKey(pubkey, vchCryptedSecret))\n+        {\n             return false;\n+        }\n     }\n     return true;\n }\n \n-\n bool CCryptoKeyStore::AddCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret)\n {\n     {\n         LOCK(cs_KeyStore);\n+\n         if (!SetCrypted())\n+        {\n             return false;\n+        }\n \n         mapCryptedKeys[vchPubKey.GetID()] = make_pair(vchPubKey, vchCryptedSecret);\n     }\n@@ -234,19 +329,30 @@ bool CCryptoKeyStore::GetKey(const CKeyID &address, CKey& keyOut) const\n {\n     {\n         LOCK(cs_KeyStore);\n+\n         if (!IsCrypted())\n+        {\n             return CBasicKeyStore::GetKey(address, keyOut);\n+        }\n \n         CryptedKeyMap::const_iterator mi = mapCryptedKeys.find(address);\n+\n         if (mi != mapCryptedKeys.end())\n         {\n             const CPubKey &vchPubKey = (*mi).second.first;\n             const std::vector<unsigned char> &vchCryptedSecret = (*mi).second.second;\n             CKeyingMaterial vchSecret;\n+\n             if (!DecryptSecret(vMasterKey, vchCryptedSecret, vchPubKey.GetHash(), vchSecret))\n+            {\n                 return false;\n+            }\n+\n             if (vchSecret.size() != 32)\n+            {\n                 return false;\n+            }\n+\n             keyOut.Set(vchSecret.begin(), vchSecret.end(), vchPubKey.IsCompressed());\n             return true;\n         }\n@@ -258,10 +364,14 @@ bool CCryptoKeyStore::GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) co\n {\n     {\n         LOCK(cs_KeyStore);\n+\n         if (!IsCrypted())\n+        {\n             return CKeyStore::GetPubKey(address, vchPubKeyOut);\n+        }\n \n         CryptedKeyMap::const_iterator mi = mapCryptedKeys.find(address);\n+\n         if (mi != mapCryptedKeys.end())\n         {\n             vchPubKeyOut = (*mi).second.first;\n@@ -275,22 +385,34 @@ bool CCryptoKeyStore::EncryptKeys(CKeyingMaterial& vMasterKeyIn)\n {\n     {\n         LOCK(cs_KeyStore);\n+\n         if (!mapCryptedKeys.empty() || IsCrypted())\n+        {\n             return false;\n+        }\n \n         fUseCrypto = true;\n-        BOOST_FOREACH(KeyMap::value_type& mKey, mapKeys)\n+\n+        BOOST_FOREACH (KeyMap::value_type& mKey, mapKeys)\n         {\n             const CKey &key = mKey.second;\n             CPubKey vchPubKey = key.GetPubKey();\n             CKeyingMaterial vchSecret(key.begin(), key.end());\n             std::vector<unsigned char> vchCryptedSecret;\n+\n             if (!EncryptSecret(vMasterKeyIn, vchSecret, vchPubKey.GetHash(), vchCryptedSecret))\n+            {\n                 return false;\n+            }\n+\n             if (!AddCryptedKey(vchPubKey, vchCryptedSecret))\n+            {\n                 return false;\n+            }\n         }\n+\n         mapKeys.clear();\n     }\n     return true;\n }\n+"
      },
      {
        "sha": "8669038443599a1d3ea12467af80d21d9ac3c928",
        "filename": "src/crypter.h",
        "status": "modified",
        "additions": 34,
        "deletions": 17,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/crypter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/crypter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypter.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -15,19 +15,19 @@ const unsigned int WALLET_CRYPTO_KEY_SIZE = 32;\n const unsigned int WALLET_CRYPTO_SALT_SIZE = 8;\n \n /*\n-Private key encryption is done based on a CMasterKey,\n-which holds a salt and random encryption key.\n-\n-CMasterKeys are encrypted using AES-256-CBC using a key\n-derived using derivation method nDerivationMethod\n-(0 == EVP_sha512()) and derivation iterations nDeriveIterations.\n-vchOtherDerivationParameters is provided for alternative algorithms\n-which may require more parameters (such as scrypt).\n-\n-Wallet Private Keys are then encrypted using AES-256-CBC\n-with the double-sha256 of the public key as the IV, and the\n-master key's key as the encryption key (see keystore.[ch]).\n-*/\n+   Private key encryption is done based on a CMasterKey,\n+   which holds a salt and random encryption key.\n+\n+   CMasterKeys are encrypted using AES-256-CBC using a key\n+   derived using derivation method nDerivationMethod\n+   (0 == EVP_sha512()) and derivation iterations nDeriveIterations.\n+   vchOtherDerivationParameters is provided for alternative algorithms\n+   which may require more parameters (such as scrypt).\n+\n+   Wallet Private Keys are then encrypted using AES-256-CBC\n+   with the double-sha256 of the public key as the IV, and the\n+   master key's key as the encryption key (see keystore.[ch]).\n+ */\n \n /** Master key for wallet encryption */\n class CMasterKey\n@@ -46,7 +46,8 @@ class CMasterKey\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n         READWRITE(vchCryptedKey);\n         READWRITE(vchSalt);\n         READWRITE(nDerivationMethod);\n@@ -75,7 +76,9 @@ class CCrypter\n     bool fKeySet;\n \n public:\n-    bool SetKeyFromPassphrase(const SecureString &strKeyData, const std::vector<unsigned char>& chSalt, const unsigned int nRounds, const unsigned int nDerivationMethod);\n+    bool SetKeyFromPassphrase(const SecureString &strKeyData, const std::vector<unsigned char>& chSalt,\n+        const unsigned int nRounds,\n+        const unsigned int nDerivationMethod);\n     bool Encrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned char> &vchCiphertext);\n     bool Decrypt(const std::vector<unsigned char>& vchCiphertext, CKeyingMaterial& vchPlaintext);\n     bool SetKey(const CKeyingMaterial& chNewKey, const std::vector<unsigned char>& chNewIV);\n@@ -107,8 +110,11 @@ class CCrypter\n     }\n };\n \n-bool EncryptSecret(const CKeyingMaterial& vMasterKey, const CKeyingMaterial &vchPlaintext, const uint256& nIV, std::vector<unsigned char> &vchCiphertext);\n-bool DecryptSecret(const CKeyingMaterial& vMasterKey, const std::vector<unsigned char>& vchCiphertext, const uint256& nIV, CKeyingMaterial& vchPlaintext);\n+bool EncryptSecret(const CKeyingMaterial& vMasterKey, const CKeyingMaterial &vchPlaintext, const uint256& nIV,\n+    std::vector<unsigned char> &vchCiphertext);\n+bool DecryptSecret(const CKeyingMaterial& vMasterKey, const std::vector<unsigned char>& vchCiphertext,\n+    const uint256& nIV,\n+    CKeyingMaterial& vchPlaintext);\n \n /** Keystore which keeps the private keys encrypted.\n  * It derives from the basic key store, which is used if no encryption is active.\n@@ -148,7 +154,10 @@ class CCryptoKeyStore : public CBasicKeyStore\n     bool IsLocked() const\n     {\n         if (!IsCrypted())\n+        {\n             return false;\n+        }\n+\n         bool result;\n         {\n             LOCK(cs_KeyStore);\n@@ -165,12 +174,17 @@ class CCryptoKeyStore : public CBasicKeyStore\n     {\n         {\n             LOCK(cs_KeyStore);\n+\n             if (!IsCrypted())\n+            {\n                 return CBasicKeyStore::HaveKey(address);\n+            }\n+\n             return mapCryptedKeys.count(address) > 0;\n         }\n         return false;\n     }\n+\n     bool GetKey(const CKeyID &address, CKey& keyOut) const;\n     bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const;\n     void GetKeys(std::set<CKeyID> &setAddress) const\n@@ -180,8 +194,10 @@ class CCryptoKeyStore : public CBasicKeyStore\n             CBasicKeyStore::GetKeys(setAddress);\n             return;\n         }\n+\n         setAddress.clear();\n         CryptedKeyMap::const_iterator mi = mapCryptedKeys.begin();\n+\n         while (mi != mapCryptedKeys.end())\n         {\n             setAddress.insert((*mi).first);\n@@ -196,3 +212,4 @@ class CCryptoKeyStore : public CBasicKeyStore\n };\n \n #endif // __CRYPTER_H__\n+"
      },
      {
        "sha": "11c0c5f3c33fd33e7e0460184859fc4593880a66",
        "filename": "src/crypto/common.h",
        "status": "modified",
        "additions": 53,
        "deletions": 17,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/crypto/common.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/crypto/common.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/common.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -13,81 +13,117 @@\n #include <endian.h>\n #endif\n \n-uint32_t static inline ReadLE32(const unsigned char *ptr) {\n+uint32_t static inline ReadLE32(const unsigned char* ptr)\n+{\n #if HAVE_DECL_LE32TOH == 1\n     return le32toh(*((uint32_t*)ptr));\n+\n #elif !defined(WORDS_BIGENDIAN)\n     return *((uint32_t*)ptr);\n+\n #else\n     return ((uint32_t)ptr[3] << 24 | (uint32_t)ptr[2] << 16 | (uint32_t)ptr[1] << 8 | (uint32_t)ptr[0]);\n+\n #endif\n }\n \n-uint64_t static inline ReadLE64(const unsigned char *ptr) {\n-\n+uint64_t static inline ReadLE64(const unsigned char* ptr)\n+{\n #if HAVE_DECL_LE64TOH == 1\n     return le64toh(*((uint64_t*)ptr));\n+\n #elif !defined(WORDS_BIGENDIAN)\n     return *((uint64_t*)ptr);\n+\n #else\n     return ((uint64_t)ptr[7] << 56 | (uint64_t)ptr[6] << 48 | (uint64_t)ptr[5] << 40 | (uint64_t)ptr[4] << 32 |\n-            (uint64_t)ptr[3] << 24 | (uint64_t)ptr[2] << 16 | (uint64_t)ptr[1] << 8 | (uint64_t)ptr[0]);\n+        (uint64_t)ptr[3] << 24 | (uint64_t)ptr[2] << 16 | (uint64_t)ptr[1] << 8 | (uint64_t)ptr[0]);\n+\n #endif\n }\n \n-void static inline WriteLE32(unsigned char *ptr, uint32_t x) {\n+void static inline WriteLE32(unsigned char* ptr, uint32_t x)\n+{\n #if HAVE_DECL_HTOLE32 == 1\n     *((uint32_t*)ptr) = htole32(x);\n #elif !defined(WORDS_BIGENDIAN)\n     *((uint32_t*)ptr) = x;\n #else\n-    ptr[3] = x >> 24; ptr[2] = x >> 16; ptr[1] = x >> 8; ptr[0] = x;\n+    ptr[3] = x >> 24;\n+    ptr[2] = x >> 16;\n+    ptr[1] = x >> 8;\n+    ptr[0] = x;\n #endif\n }\n \n-void static inline WriteLE64(unsigned char *ptr, uint64_t x) {\n+void static inline WriteLE64(unsigned char* ptr, uint64_t x)\n+{\n #if HAVE_DECL_HTOLE64 == 1\n     *((uint64_t*)ptr) = htole64(x);\n #elif !defined(WORDS_BIGENDIAN)\n     *((uint64_t*)ptr) = x;\n #else\n-    ptr[7] = x >> 56; ptr[6] = x >> 48; ptr[5] = x >> 40; ptr[4] = x >> 32;\n-    ptr[3] = x >> 24; ptr[2] = x >> 16; ptr[1] = x >> 8; ptr[0] = x;\n+    ptr[7] = x >> 56;\n+    ptr[6] = x >> 48;\n+    ptr[5] = x >> 40;\n+    ptr[4] = x >> 32;\n+    ptr[3] = x >> 24;\n+    ptr[2] = x >> 16;\n+    ptr[1] = x >> 8;\n+    ptr[0] = x;\n #endif\n }\n \n-uint32_t static inline ReadBE32(const unsigned char *ptr) {\n+uint32_t static inline ReadBE32(const unsigned char* ptr)\n+{\n #if HAVE_DECL_BE32TOH == 1\n     return be32toh(*((uint32_t*)ptr));\n+\n #else\n     return ((uint32_t)ptr[0] << 24 | (uint32_t)ptr[1] << 16 | (uint32_t)ptr[2] << 8 | (uint32_t)ptr[3]);\n+\n #endif\n }\n \n-uint64_t static inline ReadBE64(const unsigned char *ptr) {\n+uint64_t static inline ReadBE64(const unsigned char* ptr)\n+{\n #if HAVE_DECL_BE64TOH == 1\n     return be64toh(*((uint64_t*)ptr));\n+\n #else\n     return ((uint64_t)ptr[0] << 56 | (uint64_t)ptr[1] << 48 | (uint64_t)ptr[2] << 40 | (uint64_t)ptr[3] << 32 |\n-            (uint64_t)ptr[4] << 24 | (uint64_t)ptr[5] << 16 | (uint64_t)ptr[6] << 8 | (uint64_t)ptr[7]);\n+        (uint64_t)ptr[4] << 24 | (uint64_t)ptr[5] << 16 | (uint64_t)ptr[6] << 8 | (uint64_t)ptr[7]);\n+\n #endif\n }\n \n-void static inline WriteBE32(unsigned char *ptr, uint32_t x) {\n+void static inline WriteBE32(unsigned char* ptr, uint32_t x)\n+{\n #if HAVE_DECL_HTOBE32 == 1\n     *((uint32_t*)ptr) = htobe32(x);\n #else\n-    ptr[0] = x >> 24; ptr[1] = x >> 16; ptr[2] = x >> 8; ptr[3] = x;\n+    ptr[0] = x >> 24;\n+    ptr[1] = x >> 16;\n+    ptr[2] = x >> 8;\n+    ptr[3] = x;\n #endif\n }\n \n-void static inline WriteBE64(unsigned char *ptr, uint64_t x) {\n+void static inline WriteBE64(unsigned char* ptr, uint64_t x)\n+{\n #if HAVE_DECL_HTOBE64 == 1\n     *((uint64_t*)ptr) = htobe64(x);\n #else\n-    ptr[0] = x >> 56; ptr[1] = x >> 48; ptr[2] = x >> 40; ptr[3] = x >> 32;\n-    ptr[4] = x >> 24; ptr[5] = x >> 16; ptr[6] = x >> 8; ptr[7] = x;\n+    ptr[0] = x >> 56;\n+    ptr[1] = x >> 48;\n+    ptr[2] = x >> 40;\n+    ptr[3] = x >> 32;\n+    ptr[4] = x >> 24;\n+    ptr[5] = x >> 16;\n+    ptr[6] = x >> 8;\n+    ptr[7] = x;\n #endif\n }\n \n #endif\n+"
      },
      {
        "sha": "5481c6ae01ba10914854e40bf169b33ab34124dd",
        "filename": "src/crypto/ripemd160.cpp",
        "status": "modified",
        "additions": 288,
        "deletions": 128,
        "changes": 416,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/crypto/ripemd160.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/crypto/ripemd160.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/ripemd160.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -8,197 +8,357 @@\n #include <string.h>\n \n // Internal implementation code.\n-namespace {\n-\n+namespace\n+{\n /// Internal RIPEMD-160 implementation.\n-namespace ripemd160 {\n+namespace ripemd160\n+{\n+uint32_t inline f1(uint32_t x, uint32_t y, uint32_t z)\n+{\n+    return x ^ y ^ z;\n+}\n+\n+uint32_t inline f2(uint32_t x, uint32_t y, uint32_t z)\n+{\n+    return (x & y) | (~x & z);\n+}\n \n-uint32_t inline f1(uint32_t x, uint32_t y, uint32_t z) { return x ^ y ^ z; }\n-uint32_t inline f2(uint32_t x, uint32_t y, uint32_t z) { return (x & y) | (~x & z); }\n-uint32_t inline f3(uint32_t x, uint32_t y, uint32_t z) { return (x | ~y) ^ z; }\n-uint32_t inline f4(uint32_t x, uint32_t y, uint32_t z) { return (x & z) | (y & ~z); }\n-uint32_t inline f5(uint32_t x, uint32_t y, uint32_t z) { return x ^ (y | ~z); }\n+uint32_t inline f3(uint32_t x, uint32_t y, uint32_t z)\n+{\n+    return (x | ~y) ^ z;\n+}\n+\n+uint32_t inline f4(uint32_t x, uint32_t y, uint32_t z)\n+{\n+    return (x & z) | (y & ~z);\n+}\n+\n+uint32_t inline f5(uint32_t x, uint32_t y, uint32_t z)\n+{\n+    return x ^ (y | ~z);\n+}\n \n /** Initialize RIPEMD-160 state. */\n-void inline Initialize(uint32_t *s) {\n+void inline Initialize(uint32_t* s)\n+{\n     s[0] = 0x67452301ul;\n     s[1] = 0xEFCDAB89ul;\n     s[2] = 0x98BADCFEul;\n     s[3] = 0x10325476ul;\n     s[4] = 0xC3D2E1F0ul;\n }\n \n-uint32_t inline rol(uint32_t x, int i) { return (x << i) | (x >> (32-i)); }\n+uint32_t inline rol(uint32_t x, int i)\n+{\n+    return (x << i) | (x >> (32 - i));\n+}\n \n-void inline Round(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t f, uint32_t x, uint32_t k, int r) {\n+void inline Round(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t f, uint32_t x, uint32_t k,\n+            int r)\n+{\n     a = rol(a + f + x + k, r) + e;\n     c = rol(c, 10);\n }\n \n-void inline R11(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f1(b, c, d), x,            0, r); }\n-void inline R21(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f2(b, c, d), x, 0x5A827999ul, r); }\n-void inline R31(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f3(b, c, d), x, 0x6ED9EBA1ul, r); }\n-void inline R41(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f4(b, c, d), x, 0x8F1BBCDCul, r); }\n-void inline R51(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f5(b, c, d), x, 0xA953FD4Eul, r); }\n+void inline R11(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r)\n+{\n+    Round(a, b, c, d, e, f1(b, c, d), x, 0, r);\n+}\n \n-void inline R12(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f5(b, c, d), x, 0x50A28BE6ul, r); }\n-void inline R22(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f4(b, c, d), x, 0x5C4DD124ul, r); }\n-void inline R32(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f3(b, c, d), x, 0x6D703EF3ul, r); }\n-void inline R42(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f2(b, c, d), x, 0x7A6D76E9ul, r); }\n-void inline R52(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f1(b, c, d), x,            0, r); }\n+void inline R21(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r)\n+{\n+    Round(a, b, c, d, e, f2(b, c, d), x, 0x5A827999ul, r);\n+}\n+\n+void inline R31(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r)\n+{\n+    Round(a, b, c, d, e, f3(b, c, d), x, 0x6ED9EBA1ul, r);\n+}\n+\n+void inline R41(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r)\n+{\n+    Round(a, b, c, d, e, f4(b, c, d), x, 0x8F1BBCDCul, r);\n+}\n+\n+void inline R51(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r)\n+{\n+    Round(a, b, c, d, e, f5(b, c, d), x, 0xA953FD4Eul, r);\n+}\n+\n+void inline R12(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r)\n+{\n+    Round(a, b, c, d, e, f5(b, c, d), x, 0x50A28BE6ul, r);\n+}\n+\n+void inline R22(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r)\n+{\n+    Round(a, b, c, d, e, f4(b, c, d), x, 0x5C4DD124ul, r);\n+}\n+\n+void inline R32(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r)\n+{\n+    Round(a, b, c, d, e, f3(b, c, d), x, 0x6D703EF3ul, r);\n+}\n+\n+void inline R42(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r)\n+{\n+    Round(a, b, c, d, e, f2(b, c, d), x, 0x7A6D76E9ul, r);\n+}\n+\n+void inline R52(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r)\n+{\n+    Round(a, b, c, d, e, f1(b, c, d), x, 0, r);\n+}\n \n /** Perform a RIPEMD-160 transformation, processing a 64-byte chunk. */\n-void Transform(uint32_t *s, const unsigned char *chunk) {\n+void Transform(uint32_t* s, const unsigned char* chunk)\n+{\n     uint32_t a1 = s[0], b1 = s[1], c1 = s[2], d1 = s[3], e1 = s[4];\n-    uint32_t a2 = a1  , b2 = b1  , c2 = c1  , d2 = d1  , e2 = e1  ;\n-    uint32_t w0  = ReadLE32(chunk +  0), w1  = ReadLE32(chunk +  4), w2  = ReadLE32(chunk +  8), w3  = ReadLE32(chunk + 12);\n-    uint32_t w4  = ReadLE32(chunk + 16), w5  = ReadLE32(chunk + 20), w6  = ReadLE32(chunk + 24), w7  = ReadLE32(chunk + 28);\n-    uint32_t w8  = ReadLE32(chunk + 32), w9  = ReadLE32(chunk + 36), w10 = ReadLE32(chunk + 40), w11 = ReadLE32(chunk + 44);\n-    uint32_t w12 = ReadLE32(chunk + 48), w13 = ReadLE32(chunk + 52), w14 = ReadLE32(chunk + 56), w15 = ReadLE32(chunk + 60);\n-\n-    R11(a1, b1, c1, d1, e1, w0 , 11); R12(a2, b2, c2, d2, e2, w5 ,  8);\n-    R11(e1, a1, b1, c1, d1, w1 , 14); R12(e2, a2, b2, c2, d2, w14,  9);\n-    R11(d1, e1, a1, b1, c1, w2 , 15); R12(d2, e2, a2, b2, c2, w7 ,  9);\n-    R11(c1, d1, e1, a1, b1, w3 , 12); R12(c2, d2, e2, a2, b2, w0 , 11);\n-    R11(b1, c1, d1, e1, a1, w4 ,  5); R12(b2, c2, d2, e2, a2, w9 , 13);\n-    R11(a1, b1, c1, d1, e1, w5 ,  8); R12(a2, b2, c2, d2, e2, w2 , 15);\n-    R11(e1, a1, b1, c1, d1, w6 ,  7); R12(e2, a2, b2, c2, d2, w11, 15);\n-    R11(d1, e1, a1, b1, c1, w7 ,  9); R12(d2, e2, a2, b2, c2, w4 ,  5);\n-    R11(c1, d1, e1, a1, b1, w8 , 11); R12(c2, d2, e2, a2, b2, w13,  7);\n-    R11(b1, c1, d1, e1, a1, w9 , 13); R12(b2, c2, d2, e2, a2, w6 ,  7);\n-    R11(a1, b1, c1, d1, e1, w10, 14); R12(a2, b2, c2, d2, e2, w15,  8);\n-    R11(e1, a1, b1, c1, d1, w11, 15); R12(e2, a2, b2, c2, d2, w8 , 11);\n-    R11(d1, e1, a1, b1, c1, w12,  6); R12(d2, e2, a2, b2, c2, w1 , 14);\n-    R11(c1, d1, e1, a1, b1, w13,  7); R12(c2, d2, e2, a2, b2, w10, 14);\n-    R11(b1, c1, d1, e1, a1, w14,  9); R12(b2, c2, d2, e2, a2, w3 , 12);\n-    R11(a1, b1, c1, d1, e1, w15,  8); R12(a2, b2, c2, d2, e2, w12,  6);\n-\n-    R21(e1, a1, b1, c1, d1, w7 ,  7); R22(e2, a2, b2, c2, d2, w6 ,  9);\n-    R21(d1, e1, a1, b1, c1, w4 ,  6); R22(d2, e2, a2, b2, c2, w11, 13);\n-    R21(c1, d1, e1, a1, b1, w13,  8); R22(c2, d2, e2, a2, b2, w3 , 15);\n-    R21(b1, c1, d1, e1, a1, w1 , 13); R22(b2, c2, d2, e2, a2, w7 ,  7);\n-    R21(a1, b1, c1, d1, e1, w10, 11); R22(a2, b2, c2, d2, e2, w0 , 12);\n-    R21(e1, a1, b1, c1, d1, w6 ,  9); R22(e2, a2, b2, c2, d2, w13,  8);\n-    R21(d1, e1, a1, b1, c1, w15,  7); R22(d2, e2, a2, b2, c2, w5 ,  9);\n-    R21(c1, d1, e1, a1, b1, w3 , 15); R22(c2, d2, e2, a2, b2, w10, 11);\n-    R21(b1, c1, d1, e1, a1, w12,  7); R22(b2, c2, d2, e2, a2, w14,  7);\n-    R21(a1, b1, c1, d1, e1, w0 , 12); R22(a2, b2, c2, d2, e2, w15,  7);\n-    R21(e1, a1, b1, c1, d1, w9 , 15); R22(e2, a2, b2, c2, d2, w8 , 12);\n-    R21(d1, e1, a1, b1, c1, w5 ,  9); R22(d2, e2, a2, b2, c2, w12,  7);\n-    R21(c1, d1, e1, a1, b1, w2 , 11); R22(c2, d2, e2, a2, b2, w4 ,  6);\n-    R21(b1, c1, d1, e1, a1, w14,  7); R22(b2, c2, d2, e2, a2, w9 , 15);\n-    R21(a1, b1, c1, d1, e1, w11, 13); R22(a2, b2, c2, d2, e2, w1 , 13);\n-    R21(e1, a1, b1, c1, d1, w8 , 12); R22(e2, a2, b2, c2, d2, w2 , 11);\n-\n-    R31(d1, e1, a1, b1, c1, w3 , 11); R32(d2, e2, a2, b2, c2, w15,  9);\n-    R31(c1, d1, e1, a1, b1, w10, 13); R32(c2, d2, e2, a2, b2, w5 ,  7);\n-    R31(b1, c1, d1, e1, a1, w14,  6); R32(b2, c2, d2, e2, a2, w1 , 15);\n-    R31(a1, b1, c1, d1, e1, w4 ,  7); R32(a2, b2, c2, d2, e2, w3 , 11);\n-    R31(e1, a1, b1, c1, d1, w9 , 14); R32(e2, a2, b2, c2, d2, w7 ,  8);\n-    R31(d1, e1, a1, b1, c1, w15,  9); R32(d2, e2, a2, b2, c2, w14,  6);\n-    R31(c1, d1, e1, a1, b1, w8 , 13); R32(c2, d2, e2, a2, b2, w6 ,  6);\n-    R31(b1, c1, d1, e1, a1, w1 , 15); R32(b2, c2, d2, e2, a2, w9 , 14);\n-    R31(a1, b1, c1, d1, e1, w2 , 14); R32(a2, b2, c2, d2, e2, w11, 12);\n-    R31(e1, a1, b1, c1, d1, w7 ,  8); R32(e2, a2, b2, c2, d2, w8 , 13);\n-    R31(d1, e1, a1, b1, c1, w0 , 13); R32(d2, e2, a2, b2, c2, w12,  5);\n-    R31(c1, d1, e1, a1, b1, w6 ,  6); R32(c2, d2, e2, a2, b2, w2 , 14);\n-    R31(b1, c1, d1, e1, a1, w13,  5); R32(b2, c2, d2, e2, a2, w10, 13);\n-    R31(a1, b1, c1, d1, e1, w11, 12); R32(a2, b2, c2, d2, e2, w0 , 13);\n-    R31(e1, a1, b1, c1, d1, w5 ,  7); R32(e2, a2, b2, c2, d2, w4 ,  7);\n-    R31(d1, e1, a1, b1, c1, w12,  5); R32(d2, e2, a2, b2, c2, w13,  5);\n-\n-    R41(c1, d1, e1, a1, b1, w1 , 11); R42(c2, d2, e2, a2, b2, w8 , 15);\n-    R41(b1, c1, d1, e1, a1, w9 , 12); R42(b2, c2, d2, e2, a2, w6 ,  5);\n-    R41(a1, b1, c1, d1, e1, w11, 14); R42(a2, b2, c2, d2, e2, w4 ,  8);\n-    R41(e1, a1, b1, c1, d1, w10, 15); R42(e2, a2, b2, c2, d2, w1 , 11);\n-    R41(d1, e1, a1, b1, c1, w0 , 14); R42(d2, e2, a2, b2, c2, w3 , 14);\n-    R41(c1, d1, e1, a1, b1, w8 , 15); R42(c2, d2, e2, a2, b2, w11, 14);\n-    R41(b1, c1, d1, e1, a1, w12,  9); R42(b2, c2, d2, e2, a2, w15,  6);\n-    R41(a1, b1, c1, d1, e1, w4 ,  8); R42(a2, b2, c2, d2, e2, w0 , 14);\n-    R41(e1, a1, b1, c1, d1, w13,  9); R42(e2, a2, b2, c2, d2, w5 ,  6);\n-    R41(d1, e1, a1, b1, c1, w3 , 14); R42(d2, e2, a2, b2, c2, w12,  9);\n-    R41(c1, d1, e1, a1, b1, w7 ,  5); R42(c2, d2, e2, a2, b2, w2 , 12);\n-    R41(b1, c1, d1, e1, a1, w15,  6); R42(b2, c2, d2, e2, a2, w13,  9);\n-    R41(a1, b1, c1, d1, e1, w14,  8); R42(a2, b2, c2, d2, e2, w9 , 12);\n-    R41(e1, a1, b1, c1, d1, w5 ,  6); R42(e2, a2, b2, c2, d2, w7 ,  5);\n-    R41(d1, e1, a1, b1, c1, w6 ,  5); R42(d2, e2, a2, b2, c2, w10, 15);\n-    R41(c1, d1, e1, a1, b1, w2 , 12); R42(c2, d2, e2, a2, b2, w14,  8);\n-\n-    R51(b1, c1, d1, e1, a1, w4 ,  9); R52(b2, c2, d2, e2, a2, w12,  8);\n-    R51(a1, b1, c1, d1, e1, w0 , 15); R52(a2, b2, c2, d2, e2, w15,  5);\n-    R51(e1, a1, b1, c1, d1, w5 ,  5); R52(e2, a2, b2, c2, d2, w10, 12);\n-    R51(d1, e1, a1, b1, c1, w9 , 11); R52(d2, e2, a2, b2, c2, w4 ,  9);\n-    R51(c1, d1, e1, a1, b1, w7 ,  6); R52(c2, d2, e2, a2, b2, w1 , 12);\n-    R51(b1, c1, d1, e1, a1, w12,  8); R52(b2, c2, d2, e2, a2, w5 ,  5);\n-    R51(a1, b1, c1, d1, e1, w2 , 13); R52(a2, b2, c2, d2, e2, w8 , 14);\n-    R51(e1, a1, b1, c1, d1, w10, 12); R52(e2, a2, b2, c2, d2, w7 ,  6);\n-    R51(d1, e1, a1, b1, c1, w14,  5); R52(d2, e2, a2, b2, c2, w6 ,  8);\n-    R51(c1, d1, e1, a1, b1, w1 , 12); R52(c2, d2, e2, a2, b2, w2 , 13);\n-    R51(b1, c1, d1, e1, a1, w3 , 13); R52(b2, c2, d2, e2, a2, w13,  6);\n-    R51(a1, b1, c1, d1, e1, w8 , 14); R52(a2, b2, c2, d2, e2, w14,  5);\n-    R51(e1, a1, b1, c1, d1, w11, 11); R52(e2, a2, b2, c2, d2, w0 , 15);\n-    R51(d1, e1, a1, b1, c1, w6 ,  8); R52(d2, e2, a2, b2, c2, w3 , 13);\n-    R51(c1, d1, e1, a1, b1, w15,  5); R52(c2, d2, e2, a2, b2, w9 , 11);\n-    R51(b1, c1, d1, e1, a1, w13,  6); R52(b2, c2, d2, e2, a2, w11, 11);\n+    uint32_t a2 = a1, b2 = b1, c2 = c1, d2 = d1, e2 = e1;\n+    uint32_t w0  = ReadLE32(chunk + 0), w1  = ReadLE32(chunk + 4), w2  = ReadLE32(chunk + 8), w3  = ReadLE32(chunk + 12);\n+    uint32_t w4  = ReadLE32(chunk + 16), w5  = ReadLE32(chunk + 20), w6  = ReadLE32(chunk + 24), w7  = ReadLE32(\n+                chunk + 28);\n+    uint32_t w8  = ReadLE32(chunk + 32), w9  = ReadLE32(chunk + 36), w10 = ReadLE32(chunk + 40), w11 = ReadLE32(\n+                chunk + 44);\n+    uint32_t w12 = ReadLE32(chunk + 48), w13 = ReadLE32(chunk + 52), w14 = ReadLE32(chunk + 56), w15 = ReadLE32(\n+                chunk + 60);\n+\n+    R11(a1, b1, c1, d1, e1, w0, 11);\n+    R12(a2, b2, c2, d2, e2, w5, 8);\n+    R11(e1, a1, b1, c1, d1, w1, 14);\n+    R12(e2, a2, b2, c2, d2, w14, 9);\n+    R11(d1, e1, a1, b1, c1, w2, 15);\n+    R12(d2, e2, a2, b2, c2, w7, 9);\n+    R11(c1, d1, e1, a1, b1, w3, 12);\n+    R12(c2, d2, e2, a2, b2, w0, 11);\n+    R11(b1, c1, d1, e1, a1, w4, 5);\n+    R12(b2, c2, d2, e2, a2, w9, 13);\n+    R11(a1, b1, c1, d1, e1, w5, 8);\n+    R12(a2, b2, c2, d2, e2, w2, 15);\n+    R11(e1, a1, b1, c1, d1, w6, 7);\n+    R12(e2, a2, b2, c2, d2, w11, 15);\n+    R11(d1, e1, a1, b1, c1, w7, 9);\n+    R12(d2, e2, a2, b2, c2, w4, 5);\n+    R11(c1, d1, e1, a1, b1, w8, 11);\n+    R12(c2, d2, e2, a2, b2, w13, 7);\n+    R11(b1, c1, d1, e1, a1, w9, 13);\n+    R12(b2, c2, d2, e2, a2, w6, 7);\n+    R11(a1, b1, c1, d1, e1, w10, 14);\n+    R12(a2, b2, c2, d2, e2, w15, 8);\n+    R11(e1, a1, b1, c1, d1, w11, 15);\n+    R12(e2, a2, b2, c2, d2, w8, 11);\n+    R11(d1, e1, a1, b1, c1, w12, 6);\n+    R12(d2, e2, a2, b2, c2, w1, 14);\n+    R11(c1, d1, e1, a1, b1, w13, 7);\n+    R12(c2, d2, e2, a2, b2, w10, 14);\n+    R11(b1, c1, d1, e1, a1, w14, 9);\n+    R12(b2, c2, d2, e2, a2, w3, 12);\n+    R11(a1, b1, c1, d1, e1, w15, 8);\n+    R12(a2, b2, c2, d2, e2, w12, 6);\n+\n+    R21(e1, a1, b1, c1, d1, w7, 7);\n+    R22(e2, a2, b2, c2, d2, w6, 9);\n+    R21(d1, e1, a1, b1, c1, w4, 6);\n+    R22(d2, e2, a2, b2, c2, w11, 13);\n+    R21(c1, d1, e1, a1, b1, w13, 8);\n+    R22(c2, d2, e2, a2, b2, w3, 15);\n+    R21(b1, c1, d1, e1, a1, w1, 13);\n+    R22(b2, c2, d2, e2, a2, w7, 7);\n+    R21(a1, b1, c1, d1, e1, w10, 11);\n+    R22(a2, b2, c2, d2, e2, w0, 12);\n+    R21(e1, a1, b1, c1, d1, w6, 9);\n+    R22(e2, a2, b2, c2, d2, w13, 8);\n+    R21(d1, e1, a1, b1, c1, w15, 7);\n+    R22(d2, e2, a2, b2, c2, w5, 9);\n+    R21(c1, d1, e1, a1, b1, w3, 15);\n+    R22(c2, d2, e2, a2, b2, w10, 11);\n+    R21(b1, c1, d1, e1, a1, w12, 7);\n+    R22(b2, c2, d2, e2, a2, w14, 7);\n+    R21(a1, b1, c1, d1, e1, w0, 12);\n+    R22(a2, b2, c2, d2, e2, w15, 7);\n+    R21(e1, a1, b1, c1, d1, w9, 15);\n+    R22(e2, a2, b2, c2, d2, w8, 12);\n+    R21(d1, e1, a1, b1, c1, w5, 9);\n+    R22(d2, e2, a2, b2, c2, w12, 7);\n+    R21(c1, d1, e1, a1, b1, w2, 11);\n+    R22(c2, d2, e2, a2, b2, w4, 6);\n+    R21(b1, c1, d1, e1, a1, w14, 7);\n+    R22(b2, c2, d2, e2, a2, w9, 15);\n+    R21(a1, b1, c1, d1, e1, w11, 13);\n+    R22(a2, b2, c2, d2, e2, w1, 13);\n+    R21(e1, a1, b1, c1, d1, w8, 12);\n+    R22(e2, a2, b2, c2, d2, w2, 11);\n+\n+    R31(d1, e1, a1, b1, c1, w3, 11);\n+    R32(d2, e2, a2, b2, c2, w15, 9);\n+    R31(c1, d1, e1, a1, b1, w10, 13);\n+    R32(c2, d2, e2, a2, b2, w5, 7);\n+    R31(b1, c1, d1, e1, a1, w14, 6);\n+    R32(b2, c2, d2, e2, a2, w1, 15);\n+    R31(a1, b1, c1, d1, e1, w4, 7);\n+    R32(a2, b2, c2, d2, e2, w3, 11);\n+    R31(e1, a1, b1, c1, d1, w9, 14);\n+    R32(e2, a2, b2, c2, d2, w7, 8);\n+    R31(d1, e1, a1, b1, c1, w15, 9);\n+    R32(d2, e2, a2, b2, c2, w14, 6);\n+    R31(c1, d1, e1, a1, b1, w8, 13);\n+    R32(c2, d2, e2, a2, b2, w6, 6);\n+    R31(b1, c1, d1, e1, a1, w1, 15);\n+    R32(b2, c2, d2, e2, a2, w9, 14);\n+    R31(a1, b1, c1, d1, e1, w2, 14);\n+    R32(a2, b2, c2, d2, e2, w11, 12);\n+    R31(e1, a1, b1, c1, d1, w7, 8);\n+    R32(e2, a2, b2, c2, d2, w8, 13);\n+    R31(d1, e1, a1, b1, c1, w0, 13);\n+    R32(d2, e2, a2, b2, c2, w12, 5);\n+    R31(c1, d1, e1, a1, b1, w6, 6);\n+    R32(c2, d2, e2, a2, b2, w2, 14);\n+    R31(b1, c1, d1, e1, a1, w13, 5);\n+    R32(b2, c2, d2, e2, a2, w10, 13);\n+    R31(a1, b1, c1, d1, e1, w11, 12);\n+    R32(a2, b2, c2, d2, e2, w0, 13);\n+    R31(e1, a1, b1, c1, d1, w5, 7);\n+    R32(e2, a2, b2, c2, d2, w4, 7);\n+    R31(d1, e1, a1, b1, c1, w12, 5);\n+    R32(d2, e2, a2, b2, c2, w13, 5);\n+\n+    R41(c1, d1, e1, a1, b1, w1, 11);\n+    R42(c2, d2, e2, a2, b2, w8, 15);\n+    R41(b1, c1, d1, e1, a1, w9, 12);\n+    R42(b2, c2, d2, e2, a2, w6, 5);\n+    R41(a1, b1, c1, d1, e1, w11, 14);\n+    R42(a2, b2, c2, d2, e2, w4, 8);\n+    R41(e1, a1, b1, c1, d1, w10, 15);\n+    R42(e2, a2, b2, c2, d2, w1, 11);\n+    R41(d1, e1, a1, b1, c1, w0, 14);\n+    R42(d2, e2, a2, b2, c2, w3, 14);\n+    R41(c1, d1, e1, a1, b1, w8, 15);\n+    R42(c2, d2, e2, a2, b2, w11, 14);\n+    R41(b1, c1, d1, e1, a1, w12, 9);\n+    R42(b2, c2, d2, e2, a2, w15, 6);\n+    R41(a1, b1, c1, d1, e1, w4, 8);\n+    R42(a2, b2, c2, d2, e2, w0, 14);\n+    R41(e1, a1, b1, c1, d1, w13, 9);\n+    R42(e2, a2, b2, c2, d2, w5, 6);\n+    R41(d1, e1, a1, b1, c1, w3, 14);\n+    R42(d2, e2, a2, b2, c2, w12, 9);\n+    R41(c1, d1, e1, a1, b1, w7, 5);\n+    R42(c2, d2, e2, a2, b2, w2, 12);\n+    R41(b1, c1, d1, e1, a1, w15, 6);\n+    R42(b2, c2, d2, e2, a2, w13, 9);\n+    R41(a1, b1, c1, d1, e1, w14, 8);\n+    R42(a2, b2, c2, d2, e2, w9, 12);\n+    R41(e1, a1, b1, c1, d1, w5, 6);\n+    R42(e2, a2, b2, c2, d2, w7, 5);\n+    R41(d1, e1, a1, b1, c1, w6, 5);\n+    R42(d2, e2, a2, b2, c2, w10, 15);\n+    R41(c1, d1, e1, a1, b1, w2, 12);\n+    R42(c2, d2, e2, a2, b2, w14, 8);\n+\n+    R51(b1, c1, d1, e1, a1, w4, 9);\n+    R52(b2, c2, d2, e2, a2, w12, 8);\n+    R51(a1, b1, c1, d1, e1, w0, 15);\n+    R52(a2, b2, c2, d2, e2, w15, 5);\n+    R51(e1, a1, b1, c1, d1, w5, 5);\n+    R52(e2, a2, b2, c2, d2, w10, 12);\n+    R51(d1, e1, a1, b1, c1, w9, 11);\n+    R52(d2, e2, a2, b2, c2, w4, 9);\n+    R51(c1, d1, e1, a1, b1, w7, 6);\n+    R52(c2, d2, e2, a2, b2, w1, 12);\n+    R51(b1, c1, d1, e1, a1, w12, 8);\n+    R52(b2, c2, d2, e2, a2, w5, 5);\n+    R51(a1, b1, c1, d1, e1, w2, 13);\n+    R52(a2, b2, c2, d2, e2, w8, 14);\n+    R51(e1, a1, b1, c1, d1, w10, 12);\n+    R52(e2, a2, b2, c2, d2, w7, 6);\n+    R51(d1, e1, a1, b1, c1, w14, 5);\n+    R52(d2, e2, a2, b2, c2, w6, 8);\n+    R51(c1, d1, e1, a1, b1, w1, 12);\n+    R52(c2, d2, e2, a2, b2, w2, 13);\n+    R51(b1, c1, d1, e1, a1, w3, 13);\n+    R52(b2, c2, d2, e2, a2, w13, 6);\n+    R51(a1, b1, c1, d1, e1, w8, 14);\n+    R52(a2, b2, c2, d2, e2, w14, 5);\n+    R51(e1, a1, b1, c1, d1, w11, 11);\n+    R52(e2, a2, b2, c2, d2, w0, 15);\n+    R51(d1, e1, a1, b1, c1, w6, 8);\n+    R52(d2, e2, a2, b2, c2, w3, 13);\n+    R51(c1, d1, e1, a1, b1, w15, 5);\n+    R52(c2, d2, e2, a2, b2, w9, 11);\n+    R51(b1, c1, d1, e1, a1, w13, 6);\n+    R52(b2, c2, d2, e2, a2, w11, 11);\n \n     uint32_t t = s[0];\n     s[0] = s[1] + c1 + d2;\n     s[1] = s[2] + d1 + e2;\n     s[2] = s[3] + e1 + a2;\n     s[3] = s[4] + a1 + b2;\n-    s[4] = t    + b1 + c2;\n+    s[4] = t + b1 + c2;\n }\n-\n }  // namespace ripemd160\n-\n }  // namespace\n \n ////// RIPEMD160\n \n-CRIPEMD160::CRIPEMD160() : bytes(0) {\n+CRIPEMD160::CRIPEMD160() : bytes(0)\n+{\n     ripemd160::Initialize(s);\n }\n \n-CRIPEMD160& CRIPEMD160::Write(const unsigned char *data, size_t len) {\n-    const unsigned char *end = data + len;\n+CRIPEMD160& CRIPEMD160::Write(const unsigned char* data, size_t len)\n+{\n+    const unsigned char* end = data + len;\n     size_t bufsize = bytes % 64;\n-    if (bufsize && bufsize + len >= 64) {\n+\n+    if (bufsize && bufsize + len >= 64)\n+    {\n         // Fill the buffer, and process it.\n         memcpy(buf + bufsize, data, 64 - bufsize);\n         bytes += 64 - bufsize;\n         data += 64 - bufsize;\n         ripemd160::Transform(s, buf);\n         bufsize = 0;\n     }\n-    while (end >= data + 64) {\n+\n+    while (end >= data + 64)\n+    {\n         // Process full chunks directly from the source.\n         ripemd160::Transform(s, data);\n         bytes += 64;\n         data += 64;\n     }\n-    if (end > data) {\n+\n+    if (end > data)\n+    {\n         // Fill the buffer with what remains.\n         memcpy(buf + bufsize, data, end - data);\n         bytes += end - data;\n     }\n+\n     return *this;\n }\n \n-void CRIPEMD160::Finalize(unsigned char hash[OUTPUT_SIZE]) {\n-    static const unsigned char pad[64] = {0x80};\n+void CRIPEMD160::Finalize(unsigned char hash[OUTPUT_SIZE])\n+{\n+    static const unsigned char pad[64] = {\n+        0x80\n+    };\n     unsigned char sizedesc[8];\n+\n     WriteLE64(sizedesc, bytes << 3);\n     Write(pad, 1 + ((119 - (bytes % 64)) % 64));\n     Write(sizedesc, 8);\n     WriteLE32(hash, s[0]);\n-    WriteLE32(hash+4, s[1]);\n-    WriteLE32(hash+8, s[2]);\n-    WriteLE32(hash+12, s[3]);\n-    WriteLE32(hash+16, s[4]);\n+    WriteLE32(hash + 4, s[1]);\n+    WriteLE32(hash + 8, s[2]);\n+    WriteLE32(hash + 12, s[3]);\n+    WriteLE32(hash + 16, s[4]);\n }\n \n-CRIPEMD160& CRIPEMD160::Reset() {\n+CRIPEMD160& CRIPEMD160::Reset()\n+{\n     bytes = 0;\n     ripemd160::Initialize(s);\n     return *this;\n }\n+"
      },
      {
        "sha": "a5941202c0621204b0b7a2efc9984b842741e4c5",
        "filename": "src/crypto/ripemd160.h",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/crypto/ripemd160.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/crypto/ripemd160.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/ripemd160.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -9,7 +9,8 @@\n #include <stdlib.h>\n \n /** A hasher class for RIPEMD-160. */\n-class CRIPEMD160 {\n+class CRIPEMD160\n+{\n private:\n     uint32_t s[5];\n     unsigned char buf[64];\n@@ -19,9 +20,10 @@ class CRIPEMD160 {\n     static const size_t OUTPUT_SIZE = 20;\n \n     CRIPEMD160();\n-    CRIPEMD160& Write(const unsigned char *data, size_t len);\n+    CRIPEMD160& Write(const unsigned char* data, size_t len);\n     void Finalize(unsigned char hash[OUTPUT_SIZE]);\n     CRIPEMD160& Reset();\n };\n \n #endif\n+"
      },
      {
        "sha": "234a842808356869aeae23decf00e0654706ef56",
        "filename": "src/crypto/sha1.cpp",
        "status": "modified",
        "additions": 126,
        "deletions": 96,
        "changes": 222,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/crypto/sha1.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/crypto/sha1.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha1.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -8,26 +8,42 @@\n #include <string.h>\n \n // Internal implementation code.\n-namespace {\n-\n+namespace\n+{\n /// Internal SHA-1 implementation.\n-namespace sha1 {\n-\n+namespace sha1\n+{\n /** One round of SHA-1. */\n void inline Round(uint32_t a, uint32_t &b, uint32_t c, uint32_t d, uint32_t &e,\n-                  uint32_t f, uint32_t k, uint32_t w) {\n+            uint32_t f, uint32_t k, uint32_t w)\n+{\n     e += ((a << 5) | (a >> 27)) + f + k + w;\n     b = (b << 30) | (b >> 2);\n }\n \n-uint32_t inline f1(uint32_t b, uint32_t c, uint32_t d) { return d ^ (b & (c ^ d)); }\n-uint32_t inline f2(uint32_t b, uint32_t c, uint32_t d) { return b ^ c ^ d; }\n-uint32_t inline f3(uint32_t b, uint32_t c, uint32_t d) { return (b & c) | (d & (b | c)); }\n+uint32_t inline f1(uint32_t b, uint32_t c, uint32_t d)\n+{\n+    return d ^ (b & (c ^ d));\n+}\n+\n+uint32_t inline f2(uint32_t b, uint32_t c, uint32_t d)\n+{\n+    return b ^ c ^ d;\n+}\n+\n+uint32_t inline f3(uint32_t b, uint32_t c, uint32_t d)\n+{\n+    return (b & c) | (d & (b | c));\n+}\n \n-uint32_t inline left(uint32_t x) { return (x << 1) | (x >> 31); }\n+uint32_t inline left(uint32_t x)\n+{\n+    return (x << 1) | (x >> 31);\n+}\n \n /** Initialize SHA-1 state. */\n-void inline Initialize(uint32_t *s) {\n+void inline Initialize(uint32_t* s)\n+{\n     s[0] = 0x67452301ul;\n     s[1] = 0xEFCDAB89ul;\n     s[2] = 0x98BADCFEul;\n@@ -41,13 +57,14 @@ const uint32_t k3 = 0x8F1BBCDCul;\n const uint32_t k4 = 0xCA62C1D6ul;\n \n /** Perform a SHA-1 transformation, processing a 64-byte chunk. */\n-void Transform(uint32_t *s, const unsigned char *chunk) {\n+void Transform(uint32_t* s, const unsigned char* chunk)\n+{\n     uint32_t a = s[0], b = s[1], c = s[2], d = s[3], e = s[4];\n     uint32_t w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;\n \n-    Round(a, b, c, d, e, f1(b, c, d), k1, w0  = ReadBE32(chunk +  0));\n-    Round(e, a, b, c, d, f1(a, b, c), k1, w1  = ReadBE32(chunk +  4));\n-    Round(d, e, a, b, c, f1(e, a, b), k1, w2  = ReadBE32(chunk +  8));\n+    Round(a, b, c, d, e, f1(b, c, d), k1, w0  = ReadBE32(chunk + 0));\n+    Round(e, a, b, c, d, f1(a, b, c), k1, w1  = ReadBE32(chunk + 4));\n+    Round(d, e, a, b, c, f1(e, a, b), k1, w2  = ReadBE32(chunk + 8));\n     Round(c, d, e, a, b, f1(d, e, a), k1, w3  = ReadBE32(chunk + 12));\n     Round(b, c, d, e, a, f1(c, d, e), k1, w4  = ReadBE32(chunk + 16));\n     Round(a, b, c, d, e, f1(b, c, d), k1, w5  = ReadBE32(chunk + 20));\n@@ -62,131 +79,144 @@ void Transform(uint32_t *s, const unsigned char *chunk) {\n     Round(b, c, d, e, a, f1(c, d, e), k1, w14 = ReadBE32(chunk + 56));\n     Round(a, b, c, d, e, f1(b, c, d), k1, w15 = ReadBE32(chunk + 60));\n \n-    Round(e, a, b, c, d, f1(a, b, c), k1, w0  = left(w0  ^ w13 ^ w8  ^ w2 ));\n-    Round(d, e, a, b, c, f1(e, a, b), k1, w1  = left(w1  ^ w14 ^ w9  ^ w3 ));\n-    Round(c, d, e, a, b, f1(d, e, a), k1, w2  = left(w2  ^ w15 ^ w10 ^ w4 ));\n-    Round(b, c, d, e, a, f1(c, d, e), k1, w3  = left(w3  ^ w0  ^ w11 ^ w5 ));\n-    Round(a, b, c, d, e, f2(b, c, d), k2, w4  = left(w4  ^ w1  ^ w12 ^ w6 ));\n-    Round(e, a, b, c, d, f2(a, b, c), k2, w5  = left(w5  ^ w2  ^ w13 ^ w7 ));\n-    Round(d, e, a, b, c, f2(e, a, b), k2, w6  = left(w6  ^ w3  ^ w14 ^ w8 ));\n-    Round(c, d, e, a, b, f2(d, e, a), k2, w7  = left(w7  ^ w4  ^ w15 ^ w9 ));\n-    Round(b, c, d, e, a, f2(c, d, e), k2, w8  = left(w8  ^ w5  ^ w0  ^ w10));\n-    Round(a, b, c, d, e, f2(b, c, d), k2, w9  = left(w9  ^ w6  ^ w1  ^ w11));\n-    Round(e, a, b, c, d, f2(a, b, c), k2, w10 = left(w10 ^ w7  ^ w2  ^ w12));\n-    Round(d, e, a, b, c, f2(e, a, b), k2, w11 = left(w11 ^ w8  ^ w3  ^ w13));\n-    Round(c, d, e, a, b, f2(d, e, a), k2, w12 = left(w12 ^ w9  ^ w4  ^ w14));\n-    Round(b, c, d, e, a, f2(c, d, e), k2, w13 = left(w13 ^ w10 ^ w5  ^ w15));\n-    Round(a, b, c, d, e, f2(b, c, d), k2, w14 = left(w14 ^ w11 ^ w6  ^ w0 ));\n-    Round(e, a, b, c, d, f2(a, b, c), k2, w15 = left(w15 ^ w12 ^ w7  ^ w1 ));\n-\n-    Round(d, e, a, b, c, f2(e, a, b), k2, w0  = left(w0  ^ w13 ^ w8  ^ w2 ));\n-    Round(c, d, e, a, b, f2(d, e, a), k2, w1  = left(w1  ^ w14 ^ w9  ^ w3 ));\n-    Round(b, c, d, e, a, f2(c, d, e), k2, w2  = left(w2  ^ w15 ^ w10 ^ w4 ));\n-    Round(a, b, c, d, e, f2(b, c, d), k2, w3  = left(w3  ^ w0  ^ w11 ^ w5 ));\n-    Round(e, a, b, c, d, f2(a, b, c), k2, w4  = left(w4  ^ w1  ^ w12 ^ w6 ));\n-    Round(d, e, a, b, c, f2(e, a, b), k2, w5  = left(w5  ^ w2  ^ w13 ^ w7 ));\n-    Round(c, d, e, a, b, f2(d, e, a), k2, w6  = left(w6  ^ w3  ^ w14 ^ w8 ));\n-    Round(b, c, d, e, a, f2(c, d, e), k2, w7  = left(w7  ^ w4  ^ w15 ^ w9 ));\n-    Round(a, b, c, d, e, f3(b, c, d), k3, w8  = left(w8  ^ w5  ^ w0  ^ w10));\n-    Round(e, a, b, c, d, f3(a, b, c), k3, w9  = left(w9  ^ w6  ^ w1  ^ w11));\n-    Round(d, e, a, b, c, f3(e, a, b), k3, w10 = left(w10 ^ w7  ^ w2  ^ w12));\n-    Round(c, d, e, a, b, f3(d, e, a), k3, w11 = left(w11 ^ w8  ^ w3  ^ w13));\n-    Round(b, c, d, e, a, f3(c, d, e), k3, w12 = left(w12 ^ w9  ^ w4  ^ w14));\n-    Round(a, b, c, d, e, f3(b, c, d), k3, w13 = left(w13 ^ w10 ^ w5  ^ w15));\n-    Round(e, a, b, c, d, f3(a, b, c), k3, w14 = left(w14 ^ w11 ^ w6  ^ w0 ));\n-    Round(d, e, a, b, c, f3(e, a, b), k3, w15 = left(w15 ^ w12 ^ w7  ^ w1 ));\n-\n-    Round(c, d, e, a, b, f3(d, e, a), k3, w0  = left(w0  ^ w13 ^ w8  ^ w2 ));\n-    Round(b, c, d, e, a, f3(c, d, e), k3, w1  = left(w1  ^ w14 ^ w9  ^ w3 ));\n-    Round(a, b, c, d, e, f3(b, c, d), k3, w2  = left(w2  ^ w15 ^ w10 ^ w4 ));\n-    Round(e, a, b, c, d, f3(a, b, c), k3, w3  = left(w3  ^ w0  ^ w11 ^ w5 ));\n-    Round(d, e, a, b, c, f3(e, a, b), k3, w4  = left(w4  ^ w1  ^ w12 ^ w6 ));\n-    Round(c, d, e, a, b, f3(d, e, a), k3, w5  = left(w5  ^ w2  ^ w13 ^ w7 ));\n-    Round(b, c, d, e, a, f3(c, d, e), k3, w6  = left(w6  ^ w3  ^ w14 ^ w8 ));\n-    Round(a, b, c, d, e, f3(b, c, d), k3, w7  = left(w7  ^ w4  ^ w15 ^ w9 ));\n-    Round(e, a, b, c, d, f3(a, b, c), k3, w8  = left(w8  ^ w5  ^ w0  ^ w10));\n-    Round(d, e, a, b, c, f3(e, a, b), k3, w9  = left(w9  ^ w6  ^ w1  ^ w11));\n-    Round(c, d, e, a, b, f3(d, e, a), k3, w10 = left(w10 ^ w7  ^ w2  ^ w12));\n-    Round(b, c, d, e, a, f3(c, d, e), k3, w11 = left(w11 ^ w8  ^ w3  ^ w13));\n-    Round(a, b, c, d, e, f2(b, c, d), k4, w12 = left(w12 ^ w9  ^ w4  ^ w14));\n-    Round(e, a, b, c, d, f2(a, b, c), k4, w13 = left(w13 ^ w10 ^ w5  ^ w15));\n-    Round(d, e, a, b, c, f2(e, a, b), k4, w14 = left(w14 ^ w11 ^ w6  ^ w0 ));\n-    Round(c, d, e, a, b, f2(d, e, a), k4, w15 = left(w15 ^ w12 ^ w7  ^ w1 ));\n-\n-    Round(b, c, d, e, a, f2(c, d, e), k4, w0  = left(w0  ^ w13 ^ w8  ^ w2 ));\n-    Round(a, b, c, d, e, f2(b, c, d), k4, w1  = left(w1  ^ w14 ^ w9  ^ w3 ));\n-    Round(e, a, b, c, d, f2(a, b, c), k4, w2  = left(w2  ^ w15 ^ w10 ^ w4 ));\n-    Round(d, e, a, b, c, f2(e, a, b), k4, w3  = left(w3  ^ w0  ^ w11 ^ w5 ));\n-    Round(c, d, e, a, b, f2(d, e, a), k4, w4  = left(w4  ^ w1  ^ w12 ^ w6 ));\n-    Round(b, c, d, e, a, f2(c, d, e), k4, w5  = left(w5  ^ w2  ^ w13 ^ w7 ));\n-    Round(a, b, c, d, e, f2(b, c, d), k4, w6  = left(w6  ^ w3  ^ w14 ^ w8 ));\n-    Round(e, a, b, c, d, f2(a, b, c), k4, w7  = left(w7  ^ w4  ^ w15 ^ w9 ));\n-    Round(d, e, a, b, c, f2(e, a, b), k4, w8  = left(w8  ^ w5  ^ w0  ^ w10));\n-    Round(c, d, e, a, b, f2(d, e, a), k4, w9  = left(w9  ^ w6  ^ w1  ^ w11));\n-    Round(b, c, d, e, a, f2(c, d, e), k4, w10 = left(w10 ^ w7  ^ w2  ^ w12));\n-    Round(a, b, c, d, e, f2(b, c, d), k4, w11 = left(w11 ^ w8  ^ w3  ^ w13));\n-    Round(e, a, b, c, d, f2(a, b, c), k4, w12 = left(w12 ^ w9  ^ w4  ^ w14));\n-    Round(d, e, a, b, c, f2(e, a, b), k4,       left(w13 ^ w10 ^ w5  ^ w15));\n-    Round(c, d, e, a, b, f2(d, e, a), k4,       left(w14 ^ w11 ^ w6  ^ w0 ));\n-    Round(b, c, d, e, a, f2(c, d, e), k4,       left(w15 ^ w12 ^ w7  ^ w1 ));\n+    Round(e, a, b, c, d, f1(a, b, c), k1, w0  = left(w0 ^ w13 ^ w8 ^ w2 ));\n+    Round(d, e, a, b, c, f1(e, a, b), k1, w1  = left(w1 ^ w14 ^ w9 ^ w3 ));\n+    Round(c, d, e, a, b, f1(d, e, a), k1, w2  = left(w2 ^ w15 ^ w10 ^ w4 ));\n+    Round(b, c, d, e, a, f1(c, d, e), k1, w3  = left(w3 ^ w0 ^ w11 ^ w5 ));\n+    Round(a, b, c, d, e, f2(b, c, d), k2, w4  = left(w4 ^ w1 ^ w12 ^ w6 ));\n+    Round(e, a, b, c, d, f2(a, b, c), k2, w5  = left(w5 ^ w2 ^ w13 ^ w7 ));\n+    Round(d, e, a, b, c, f2(e, a, b), k2, w6  = left(w6 ^ w3 ^ w14 ^ w8 ));\n+    Round(c, d, e, a, b, f2(d, e, a), k2, w7  = left(w7 ^ w4 ^ w15 ^ w9 ));\n+    Round(b, c, d, e, a, f2(c, d, e), k2, w8  = left(w8 ^ w5 ^ w0 ^ w10));\n+    Round(a, b, c, d, e, f2(b, c, d), k2, w9  = left(w9 ^ w6 ^ w1 ^ w11));\n+    Round(e, a, b, c, d, f2(a, b, c), k2, w10 = left(w10 ^ w7 ^ w2 ^ w12));\n+    Round(d, e, a, b, c, f2(e, a, b), k2, w11 = left(w11 ^ w8 ^ w3 ^ w13));\n+    Round(c, d, e, a, b, f2(d, e, a), k2, w12 = left(w12 ^ w9 ^ w4 ^ w14));\n+    Round(b, c, d, e, a, f2(c, d, e), k2, w13 = left(w13 ^ w10 ^ w5 ^ w15));\n+    Round(a, b, c, d, e, f2(b, c, d), k2, w14 = left(w14 ^ w11 ^ w6 ^ w0 ));\n+    Round(e, a, b, c, d, f2(a, b, c), k2, w15 = left(w15 ^ w12 ^ w7 ^ w1 ));\n+\n+    Round(d, e, a, b, c, f2(e, a, b), k2, w0  = left(w0 ^ w13 ^ w8 ^ w2 ));\n+    Round(c, d, e, a, b, f2(d, e, a), k2, w1  = left(w1 ^ w14 ^ w9 ^ w3 ));\n+    Round(b, c, d, e, a, f2(c, d, e), k2, w2  = left(w2 ^ w15 ^ w10 ^ w4 ));\n+    Round(a, b, c, d, e, f2(b, c, d), k2, w3  = left(w3 ^ w0 ^ w11 ^ w5 ));\n+    Round(e, a, b, c, d, f2(a, b, c), k2, w4  = left(w4 ^ w1 ^ w12 ^ w6 ));\n+    Round(d, e, a, b, c, f2(e, a, b), k2, w5  = left(w5 ^ w2 ^ w13 ^ w7 ));\n+    Round(c, d, e, a, b, f2(d, e, a), k2, w6  = left(w6 ^ w3 ^ w14 ^ w8 ));\n+    Round(b, c, d, e, a, f2(c, d, e), k2, w7  = left(w7 ^ w4 ^ w15 ^ w9 ));\n+    Round(a, b, c, d, e, f3(b, c, d), k3, w8  = left(w8 ^ w5 ^ w0 ^ w10));\n+    Round(e, a, b, c, d, f3(a, b, c), k3, w9  = left(w9 ^ w6 ^ w1 ^ w11));\n+    Round(d, e, a, b, c, f3(e, a, b), k3, w10 = left(w10 ^ w7 ^ w2 ^ w12));\n+    Round(c, d, e, a, b, f3(d, e, a), k3, w11 = left(w11 ^ w8 ^ w3 ^ w13));\n+    Round(b, c, d, e, a, f3(c, d, e), k3, w12 = left(w12 ^ w9 ^ w4 ^ w14));\n+    Round(a, b, c, d, e, f3(b, c, d), k3, w13 = left(w13 ^ w10 ^ w5 ^ w15));\n+    Round(e, a, b, c, d, f3(a, b, c), k3, w14 = left(w14 ^ w11 ^ w6 ^ w0 ));\n+    Round(d, e, a, b, c, f3(e, a, b), k3, w15 = left(w15 ^ w12 ^ w7 ^ w1 ));\n+\n+    Round(c, d, e, a, b, f3(d, e, a), k3, w0  = left(w0 ^ w13 ^ w8 ^ w2 ));\n+    Round(b, c, d, e, a, f3(c, d, e), k3, w1  = left(w1 ^ w14 ^ w9 ^ w3 ));\n+    Round(a, b, c, d, e, f3(b, c, d), k3, w2  = left(w2 ^ w15 ^ w10 ^ w4 ));\n+    Round(e, a, b, c, d, f3(a, b, c), k3, w3  = left(w3 ^ w0 ^ w11 ^ w5 ));\n+    Round(d, e, a, b, c, f3(e, a, b), k3, w4  = left(w4 ^ w1 ^ w12 ^ w6 ));\n+    Round(c, d, e, a, b, f3(d, e, a), k3, w5  = left(w5 ^ w2 ^ w13 ^ w7 ));\n+    Round(b, c, d, e, a, f3(c, d, e), k3, w6  = left(w6 ^ w3 ^ w14 ^ w8 ));\n+    Round(a, b, c, d, e, f3(b, c, d), k3, w7  = left(w7 ^ w4 ^ w15 ^ w9 ));\n+    Round(e, a, b, c, d, f3(a, b, c), k3, w8  = left(w8 ^ w5 ^ w0 ^ w10));\n+    Round(d, e, a, b, c, f3(e, a, b), k3, w9  = left(w9 ^ w6 ^ w1 ^ w11));\n+    Round(c, d, e, a, b, f3(d, e, a), k3, w10 = left(w10 ^ w7 ^ w2 ^ w12));\n+    Round(b, c, d, e, a, f3(c, d, e), k3, w11 = left(w11 ^ w8 ^ w3 ^ w13));\n+    Round(a, b, c, d, e, f2(b, c, d), k4, w12 = left(w12 ^ w9 ^ w4 ^ w14));\n+    Round(e, a, b, c, d, f2(a, b, c), k4, w13 = left(w13 ^ w10 ^ w5 ^ w15));\n+    Round(d, e, a, b, c, f2(e, a, b), k4, w14 = left(w14 ^ w11 ^ w6 ^ w0 ));\n+    Round(c, d, e, a, b, f2(d, e, a), k4, w15 = left(w15 ^ w12 ^ w7 ^ w1 ));\n+\n+    Round(b, c, d, e, a, f2(c, d, e), k4, w0  = left(w0 ^ w13 ^ w8 ^ w2 ));\n+    Round(a, b, c, d, e, f2(b, c, d), k4, w1  = left(w1 ^ w14 ^ w9 ^ w3 ));\n+    Round(e, a, b, c, d, f2(a, b, c), k4, w2  = left(w2 ^ w15 ^ w10 ^ w4 ));\n+    Round(d, e, a, b, c, f2(e, a, b), k4, w3  = left(w3 ^ w0 ^ w11 ^ w5 ));\n+    Round(c, d, e, a, b, f2(d, e, a), k4, w4  = left(w4 ^ w1 ^ w12 ^ w6 ));\n+    Round(b, c, d, e, a, f2(c, d, e), k4, w5  = left(w5 ^ w2 ^ w13 ^ w7 ));\n+    Round(a, b, c, d, e, f2(b, c, d), k4, w6  = left(w6 ^ w3 ^ w14 ^ w8 ));\n+    Round(e, a, b, c, d, f2(a, b, c), k4, w7  = left(w7 ^ w4 ^ w15 ^ w9 ));\n+    Round(d, e, a, b, c, f2(e, a, b), k4, w8  = left(w8 ^ w5 ^ w0 ^ w10));\n+    Round(c, d, e, a, b, f2(d, e, a), k4, w9  = left(w9 ^ w6 ^ w1 ^ w11));\n+    Round(b, c, d, e, a, f2(c, d, e), k4, w10 = left(w10 ^ w7 ^ w2 ^ w12));\n+    Round(a, b, c, d, e, f2(b, c, d), k4, w11 = left(w11 ^ w8 ^ w3 ^ w13));\n+    Round(e, a, b, c, d, f2(a, b, c), k4, w12 = left(w12 ^ w9 ^ w4 ^ w14));\n+    Round(d, e, a, b, c, f2(e, a, b), k4, left(w13 ^ w10 ^ w5 ^ w15));\n+    Round(c, d, e, a, b, f2(d, e, a), k4, left(w14 ^ w11 ^ w6 ^ w0 ));\n+    Round(b, c, d, e, a, f2(c, d, e), k4, left(w15 ^ w12 ^ w7 ^ w1 ));\n \n     s[0] += a;\n     s[1] += b;\n     s[2] += c;\n     s[3] += d;\n     s[4] += e;\n }\n-\n }  // namespace sha1\n-\n }  // namespace\n \n ////// SHA1\n \n-CSHA1::CSHA1() : bytes(0) {\n+CSHA1::CSHA1() : bytes(0)\n+{\n     sha1::Initialize(s);\n }\n \n-CSHA1& CSHA1::Write(const unsigned char *data, size_t len) {\n-    const unsigned char *end = data + len;\n+CSHA1& CSHA1::Write(const unsigned char* data, size_t len)\n+{\n+    const unsigned char* end = data + len;\n     size_t bufsize = bytes % 64;\n-    if (bufsize && bufsize + len >= 64) {\n+\n+    if (bufsize && bufsize + len >= 64)\n+    {\n         // Fill the buffer, and process it.\n         memcpy(buf + bufsize, data, 64 - bufsize);\n         bytes += 64 - bufsize;\n         data += 64 - bufsize;\n         sha1::Transform(s, buf);\n         bufsize = 0;\n     }\n-    while (end >= data + 64) {\n+\n+    while (end >= data + 64)\n+    {\n         // Process full chunks directly from the source.\n         sha1::Transform(s, data);\n         bytes += 64;\n         data += 64;\n     }\n-    if (end > data) {\n+\n+    if (end > data)\n+    {\n         // Fill the buffer with what remains.\n         memcpy(buf + bufsize, data, end - data);\n         bytes += end - data;\n     }\n+\n     return *this;\n }\n \n-void CSHA1::Finalize(unsigned char hash[OUTPUT_SIZE]) {\n-    static const unsigned char pad[64] = {0x80};\n+void CSHA1::Finalize(unsigned char hash[OUTPUT_SIZE])\n+{\n+    static const unsigned char pad[64] = {\n+        0x80\n+    };\n     unsigned char sizedesc[8];\n+\n     WriteBE64(sizedesc, bytes << 3);\n     Write(pad, 1 + ((119 - (bytes % 64)) % 64));\n     Write(sizedesc, 8);\n     WriteBE32(hash, s[0]);\n-    WriteBE32(hash+4, s[1]);\n-    WriteBE32(hash+8, s[2]);\n-    WriteBE32(hash+12, s[3]);\n-    WriteBE32(hash+16, s[4]);\n+    WriteBE32(hash + 4, s[1]);\n+    WriteBE32(hash + 8, s[2]);\n+    WriteBE32(hash + 12, s[3]);\n+    WriteBE32(hash + 16, s[4]);\n }\n \n-CSHA1& CSHA1::Reset() {\n+CSHA1& CSHA1::Reset()\n+{\n     bytes = 0;\n     sha1::Initialize(s);\n     return *this;\n }\n+"
      },
      {
        "sha": "59f3ee8c3775f43765aef36e2aa0f661e00a40c2",
        "filename": "src/crypto/sha1.h",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/crypto/sha1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/crypto/sha1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha1.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -9,7 +9,8 @@\n #include <stdlib.h>\n \n /** A hasher class for SHA1. */\n-class CSHA1 {\n+class CSHA1\n+{\n private:\n     uint32_t s[5];\n     unsigned char buf[64];\n@@ -19,9 +20,10 @@ class CSHA1 {\n     static const size_t OUTPUT_SIZE = 20;\n \n     CSHA1();\n-    CSHA1& Write(const unsigned char *data, size_t len);\n+    CSHA1& Write(const unsigned char* data, size_t len);\n     void Finalize(unsigned char hash[OUTPUT_SIZE]);\n     CSHA1& Reset();\n };\n \n #endif\n+"
      },
      {
        "sha": "b63c121723c5ac1c0e3fadb3c30f7af135c60c91",
        "filename": "src/crypto/sha2.cpp",
        "status": "modified",
        "additions": 299,
        "deletions": 205,
        "changes": 504,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/crypto/sha2.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/crypto/sha2.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha2.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -8,30 +8,56 @@\n #include <string.h>\n \n // Internal implementation code.\n-namespace {\n-\n+namespace\n+{\n /// Internal SHA-256 implementation.\n-namespace sha256 {\n+namespace sha256\n+{\n+uint32_t inline Ch(uint32_t x, uint32_t y, uint32_t z)\n+{\n+    return z ^ (x & (y ^ z));\n+}\n+\n+uint32_t inline Maj(uint32_t x, uint32_t y, uint32_t z)\n+{\n+    return (x & y) | (z & (x | y));\n+}\n+\n+uint32_t inline Sigma0(uint32_t x)\n+{\n+    return (x >> 2 | x << 30) ^ (x >> 13 | x << 19) ^ (x >> 22 | x << 10);\n+}\n \n-uint32_t inline Ch(uint32_t x, uint32_t y, uint32_t z) { return z ^ (x & (y ^ z)); }\n-uint32_t inline Maj(uint32_t x, uint32_t y, uint32_t z) { return (x & y) | (z & (x | y)); }\n-uint32_t inline Sigma0(uint32_t x) { return (x >> 2 | x << 30) ^ (x >> 13 | x << 19) ^ (x >> 22 | x << 10); }\n-uint32_t inline Sigma1(uint32_t x) { return (x >> 6 | x << 26) ^ (x >> 11 | x << 21) ^ (x >> 25 | x << 7); }\n-uint32_t inline sigma0(uint32_t x) { return (x >> 7 | x << 25) ^ (x >> 18 | x << 14) ^ (x >> 3); }\n-uint32_t inline sigma1(uint32_t x) { return (x >> 17 | x << 15) ^ (x >> 19 | x << 13) ^ (x >> 10); }\n+uint32_t inline Sigma1(uint32_t x)\n+{\n+    return (x >> 6 | x << 26) ^ (x >> 11 | x << 21) ^ (x >> 25 | x << 7);\n+}\n+\n+uint32_t inline sigma0(uint32_t x)\n+{\n+    return (x >> 7 | x << 25) ^ (x >> 18 | x << 14) ^ (x >> 3);\n+}\n+\n+uint32_t inline sigma1(uint32_t x)\n+{\n+    return (x >> 17 | x << 15) ^ (x >> 19 | x << 13) ^ (x >> 10);\n+}\n \n /** One round of SHA-256. */\n void inline Round(uint32_t a, uint32_t b, uint32_t c, uint32_t &d,\n-                  uint32_t e, uint32_t f, uint32_t g, uint32_t &h,\n-                  uint32_t k, uint32_t w) {\n+            uint32_t e, uint32_t f, uint32_t g, uint32_t &h,\n+            uint32_t k, uint32_t w)\n+{\n     uint32_t t1 = h + Sigma1(e) + Ch(e, f, g) + k + w;\n     uint32_t t2 = Sigma0(a) + Maj(a, b, c);\n+\n     d += t1;\n     h = t1 + t2;\n }\n \n /** Initialize SHA-256 state. */\n-void inline Initialize(uint32_t *s) {\n+void inline Initialize(uint32_t* s)\n+{\n     s[0] = 0x6a09e667ul;\n     s[1] = 0xbb67ae85ul;\n     s[2] = 0x3c6ef372ul;\n@@ -43,77 +69,78 @@ void inline Initialize(uint32_t *s) {\n }\n \n /** Perform one SHA-256 transformation, processing a 64-byte chunk. */\n-void Transform(uint32_t *s, const unsigned char *chunk) {\n+void Transform(uint32_t* s, const unsigned char* chunk)\n+{\n     uint32_t a = s[0], b = s[1], c = s[2], d = s[3], e = s[4], f = s[5], g = s[6], h = s[7];\n     uint32_t w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;\n \n-    Round(a, b, c, d, e, f, g, h, 0x428a2f98,  w0 = ReadBE32(chunk + 0));\n-    Round(h, a, b, c, d, e, f, g, 0x71374491,  w1 = ReadBE32(chunk + 4));\n-    Round(g, h, a, b, c, d, e, f, 0xb5c0fbcf,  w2 = ReadBE32(chunk + 8));\n-    Round(f, g, h, a, b, c, d, e, 0xe9b5dba5,  w3 = ReadBE32(chunk + 12));\n-    Round(e, f, g, h, a, b, c, d, 0x3956c25b,  w4 = ReadBE32(chunk + 16));\n-    Round(d, e, f, g, h, a, b, c, 0x59f111f1,  w5 = ReadBE32(chunk + 20));\n-    Round(c, d, e, f, g, h, a, b, 0x923f82a4,  w6 = ReadBE32(chunk + 24));\n-    Round(b, c, d, e, f, g, h, a, 0xab1c5ed5,  w7 = ReadBE32(chunk + 28));\n-    Round(a, b, c, d, e, f, g, h, 0xd807aa98,  w8 = ReadBE32(chunk + 32));\n-    Round(h, a, b, c, d, e, f, g, 0x12835b01,  w9 = ReadBE32(chunk + 36));\n+    Round(a, b, c, d, e, f, g, h, 0x428a2f98, w0 = ReadBE32(chunk + 0));\n+    Round(h, a, b, c, d, e, f, g, 0x71374491, w1 = ReadBE32(chunk + 4));\n+    Round(g, h, a, b, c, d, e, f, 0xb5c0fbcf, w2 = ReadBE32(chunk + 8));\n+    Round(f, g, h, a, b, c, d, e, 0xe9b5dba5, w3 = ReadBE32(chunk + 12));\n+    Round(e, f, g, h, a, b, c, d, 0x3956c25b, w4 = ReadBE32(chunk + 16));\n+    Round(d, e, f, g, h, a, b, c, 0x59f111f1, w5 = ReadBE32(chunk + 20));\n+    Round(c, d, e, f, g, h, a, b, 0x923f82a4, w6 = ReadBE32(chunk + 24));\n+    Round(b, c, d, e, f, g, h, a, 0xab1c5ed5, w7 = ReadBE32(chunk + 28));\n+    Round(a, b, c, d, e, f, g, h, 0xd807aa98, w8 = ReadBE32(chunk + 32));\n+    Round(h, a, b, c, d, e, f, g, 0x12835b01, w9 = ReadBE32(chunk + 36));\n     Round(g, h, a, b, c, d, e, f, 0x243185be, w10 = ReadBE32(chunk + 40));\n     Round(f, g, h, a, b, c, d, e, 0x550c7dc3, w11 = ReadBE32(chunk + 44));\n     Round(e, f, g, h, a, b, c, d, 0x72be5d74, w12 = ReadBE32(chunk + 48));\n     Round(d, e, f, g, h, a, b, c, 0x80deb1fe, w13 = ReadBE32(chunk + 52));\n     Round(c, d, e, f, g, h, a, b, 0x9bdc06a7, w14 = ReadBE32(chunk + 56));\n     Round(b, c, d, e, f, g, h, a, 0xc19bf174, w15 = ReadBE32(chunk + 60));\n \n-    Round(a, b, c, d, e, f, g, h, 0xe49b69c1,  w0 += sigma1(w14) +  w9 + sigma0( w1));\n-    Round(h, a, b, c, d, e, f, g, 0xefbe4786,  w1 += sigma1(w15) + w10 + sigma0( w2));\n-    Round(g, h, a, b, c, d, e, f, 0x0fc19dc6,  w2 += sigma1( w0) + w11 + sigma0( w3));\n-    Round(f, g, h, a, b, c, d, e, 0x240ca1cc,  w3 += sigma1( w1) + w12 + sigma0( w4));\n-    Round(e, f, g, h, a, b, c, d, 0x2de92c6f,  w4 += sigma1( w2) + w13 + sigma0( w5));\n-    Round(d, e, f, g, h, a, b, c, 0x4a7484aa,  w5 += sigma1( w3) + w14 + sigma0( w6));\n-    Round(c, d, e, f, g, h, a, b, 0x5cb0a9dc,  w6 += sigma1( w4) + w15 + sigma0( w7));\n-    Round(b, c, d, e, f, g, h, a, 0x76f988da,  w7 += sigma1( w5) +  w0 + sigma0( w8));\n-    Round(a, b, c, d, e, f, g, h, 0x983e5152,  w8 += sigma1( w6) +  w1 + sigma0( w9));\n-    Round(h, a, b, c, d, e, f, g, 0xa831c66d,  w9 += sigma1( w7) +  w2 + sigma0(w10));\n-    Round(g, h, a, b, c, d, e, f, 0xb00327c8, w10 += sigma1( w8) +  w3 + sigma0(w11));\n-    Round(f, g, h, a, b, c, d, e, 0xbf597fc7, w11 += sigma1( w9) +  w4 + sigma0(w12));\n-    Round(e, f, g, h, a, b, c, d, 0xc6e00bf3, w12 += sigma1(w10) +  w5 + sigma0(w13));\n-    Round(d, e, f, g, h, a, b, c, 0xd5a79147, w13 += sigma1(w11) +  w6 + sigma0(w14));\n-    Round(c, d, e, f, g, h, a, b, 0x06ca6351, w14 += sigma1(w12) +  w7 + sigma0(w15));\n-    Round(b, c, d, e, f, g, h, a, 0x14292967, w15 += sigma1(w13) +  w8 + sigma0( w0));\n-\n-    Round(a, b, c, d, e, f, g, h, 0x27b70a85,  w0 += sigma1(w14) +  w9 + sigma0( w1));\n-    Round(h, a, b, c, d, e, f, g, 0x2e1b2138,  w1 += sigma1(w15) + w10 + sigma0( w2));\n-    Round(g, h, a, b, c, d, e, f, 0x4d2c6dfc,  w2 += sigma1( w0) + w11 + sigma0( w3));\n-    Round(f, g, h, a, b, c, d, e, 0x53380d13,  w3 += sigma1( w1) + w12 + sigma0( w4));\n-    Round(e, f, g, h, a, b, c, d, 0x650a7354,  w4 += sigma1( w2) + w13 + sigma0( w5));\n-    Round(d, e, f, g, h, a, b, c, 0x766a0abb,  w5 += sigma1( w3) + w14 + sigma0( w6));\n-    Round(c, d, e, f, g, h, a, b, 0x81c2c92e,  w6 += sigma1( w4) + w15 + sigma0( w7));\n-    Round(b, c, d, e, f, g, h, a, 0x92722c85,  w7 += sigma1( w5) +  w0 + sigma0( w8));\n-    Round(a, b, c, d, e, f, g, h, 0xa2bfe8a1,  w8 += sigma1( w6) +  w1 + sigma0( w9));\n-    Round(h, a, b, c, d, e, f, g, 0xa81a664b,  w9 += sigma1( w7) +  w2 + sigma0(w10));\n-    Round(g, h, a, b, c, d, e, f, 0xc24b8b70, w10 += sigma1( w8) +  w3 + sigma0(w11));\n-    Round(f, g, h, a, b, c, d, e, 0xc76c51a3, w11 += sigma1( w9) +  w4 + sigma0(w12));\n-    Round(e, f, g, h, a, b, c, d, 0xd192e819, w12 += sigma1(w10) +  w5 + sigma0(w13));\n-    Round(d, e, f, g, h, a, b, c, 0xd6990624, w13 += sigma1(w11) +  w6 + sigma0(w14));\n-    Round(c, d, e, f, g, h, a, b, 0xf40e3585, w14 += sigma1(w12) +  w7 + sigma0(w15));\n-    Round(b, c, d, e, f, g, h, a, 0x106aa070, w15 += sigma1(w13) +  w8 + sigma0( w0));\n-\n-    Round(a, b, c, d, e, f, g, h, 0x19a4c116,  w0 += sigma1(w14) +  w9 + sigma0( w1));\n-    Round(h, a, b, c, d, e, f, g, 0x1e376c08,  w1 += sigma1(w15) + w10 + sigma0( w2));\n-    Round(g, h, a, b, c, d, e, f, 0x2748774c,  w2 += sigma1( w0) + w11 + sigma0( w3));\n-    Round(f, g, h, a, b, c, d, e, 0x34b0bcb5,  w3 += sigma1( w1) + w12 + sigma0( w4));\n-    Round(e, f, g, h, a, b, c, d, 0x391c0cb3,  w4 += sigma1( w2) + w13 + sigma0( w5));\n-    Round(d, e, f, g, h, a, b, c, 0x4ed8aa4a,  w5 += sigma1( w3) + w14 + sigma0( w6));\n-    Round(c, d, e, f, g, h, a, b, 0x5b9cca4f,  w6 += sigma1( w4) + w15 + sigma0( w7));\n-    Round(b, c, d, e, f, g, h, a, 0x682e6ff3,  w7 += sigma1( w5) +  w0 + sigma0( w8));\n-    Round(a, b, c, d, e, f, g, h, 0x748f82ee,  w8 += sigma1( w6) +  w1 + sigma0( w9));\n-    Round(h, a, b, c, d, e, f, g, 0x78a5636f,  w9 += sigma1( w7) +  w2 + sigma0(w10));\n-    Round(g, h, a, b, c, d, e, f, 0x84c87814, w10 += sigma1( w8) +  w3 + sigma0(w11));\n-    Round(f, g, h, a, b, c, d, e, 0x8cc70208, w11 += sigma1( w9) +  w4 + sigma0(w12));\n-    Round(e, f, g, h, a, b, c, d, 0x90befffa, w12 += sigma1(w10) +  w5 + sigma0(w13));\n-    Round(d, e, f, g, h, a, b, c, 0xa4506ceb, w13 += sigma1(w11) +  w6 + sigma0(w14));\n-    Round(c, d, e, f, g, h, a, b, 0xbef9a3f7, w14  + sigma1(w12) +  w7 + sigma0(w15));\n-    Round(b, c, d, e, f, g, h, a, 0xc67178f2, w15  + sigma1(w13) +  w8 + sigma0( w0));\n+    Round(a, b, c, d, e, f, g, h, 0xe49b69c1, w0 += sigma1(w14) + w9 + sigma0( w1));\n+    Round(h, a, b, c, d, e, f, g, 0xefbe4786, w1 += sigma1(w15) + w10 + sigma0( w2));\n+    Round(g, h, a, b, c, d, e, f, 0x0fc19dc6, w2 += sigma1( w0) + w11 + sigma0( w3));\n+    Round(f, g, h, a, b, c, d, e, 0x240ca1cc, w3 += sigma1( w1) + w12 + sigma0( w4));\n+    Round(e, f, g, h, a, b, c, d, 0x2de92c6f, w4 += sigma1( w2) + w13 + sigma0( w5));\n+    Round(d, e, f, g, h, a, b, c, 0x4a7484aa, w5 += sigma1( w3) + w14 + sigma0( w6));\n+    Round(c, d, e, f, g, h, a, b, 0x5cb0a9dc, w6 += sigma1( w4) + w15 + sigma0( w7));\n+    Round(b, c, d, e, f, g, h, a, 0x76f988da, w7 += sigma1( w5) + w0 + sigma0( w8));\n+    Round(a, b, c, d, e, f, g, h, 0x983e5152, w8 += sigma1( w6) + w1 + sigma0( w9));\n+    Round(h, a, b, c, d, e, f, g, 0xa831c66d, w9 += sigma1( w7) + w2 + sigma0(w10));\n+    Round(g, h, a, b, c, d, e, f, 0xb00327c8, w10 += sigma1( w8) + w3 + sigma0(w11));\n+    Round(f, g, h, a, b, c, d, e, 0xbf597fc7, w11 += sigma1( w9) + w4 + sigma0(w12));\n+    Round(e, f, g, h, a, b, c, d, 0xc6e00bf3, w12 += sigma1(w10) + w5 + sigma0(w13));\n+    Round(d, e, f, g, h, a, b, c, 0xd5a79147, w13 += sigma1(w11) + w6 + sigma0(w14));\n+    Round(c, d, e, f, g, h, a, b, 0x06ca6351, w14 += sigma1(w12) + w7 + sigma0(w15));\n+    Round(b, c, d, e, f, g, h, a, 0x14292967, w15 += sigma1(w13) + w8 + sigma0( w0));\n+\n+    Round(a, b, c, d, e, f, g, h, 0x27b70a85, w0 += sigma1(w14) + w9 + sigma0( w1));\n+    Round(h, a, b, c, d, e, f, g, 0x2e1b2138, w1 += sigma1(w15) + w10 + sigma0( w2));\n+    Round(g, h, a, b, c, d, e, f, 0x4d2c6dfc, w2 += sigma1( w0) + w11 + sigma0( w3));\n+    Round(f, g, h, a, b, c, d, e, 0x53380d13, w3 += sigma1( w1) + w12 + sigma0( w4));\n+    Round(e, f, g, h, a, b, c, d, 0x650a7354, w4 += sigma1( w2) + w13 + sigma0( w5));\n+    Round(d, e, f, g, h, a, b, c, 0x766a0abb, w5 += sigma1( w3) + w14 + sigma0( w6));\n+    Round(c, d, e, f, g, h, a, b, 0x81c2c92e, w6 += sigma1( w4) + w15 + sigma0( w7));\n+    Round(b, c, d, e, f, g, h, a, 0x92722c85, w7 += sigma1( w5) + w0 + sigma0( w8));\n+    Round(a, b, c, d, e, f, g, h, 0xa2bfe8a1, w8 += sigma1( w6) + w1 + sigma0( w9));\n+    Round(h, a, b, c, d, e, f, g, 0xa81a664b, w9 += sigma1( w7) + w2 + sigma0(w10));\n+    Round(g, h, a, b, c, d, e, f, 0xc24b8b70, w10 += sigma1( w8) + w3 + sigma0(w11));\n+    Round(f, g, h, a, b, c, d, e, 0xc76c51a3, w11 += sigma1( w9) + w4 + sigma0(w12));\n+    Round(e, f, g, h, a, b, c, d, 0xd192e819, w12 += sigma1(w10) + w5 + sigma0(w13));\n+    Round(d, e, f, g, h, a, b, c, 0xd6990624, w13 += sigma1(w11) + w6 + sigma0(w14));\n+    Round(c, d, e, f, g, h, a, b, 0xf40e3585, w14 += sigma1(w12) + w7 + sigma0(w15));\n+    Round(b, c, d, e, f, g, h, a, 0x106aa070, w15 += sigma1(w13) + w8 + sigma0( w0));\n+\n+    Round(a, b, c, d, e, f, g, h, 0x19a4c116, w0 += sigma1(w14) + w9 + sigma0( w1));\n+    Round(h, a, b, c, d, e, f, g, 0x1e376c08, w1 += sigma1(w15) + w10 + sigma0( w2));\n+    Round(g, h, a, b, c, d, e, f, 0x2748774c, w2 += sigma1( w0) + w11 + sigma0( w3));\n+    Round(f, g, h, a, b, c, d, e, 0x34b0bcb5, w3 += sigma1( w1) + w12 + sigma0( w4));\n+    Round(e, f, g, h, a, b, c, d, 0x391c0cb3, w4 += sigma1( w2) + w13 + sigma0( w5));\n+    Round(d, e, f, g, h, a, b, c, 0x4ed8aa4a, w5 += sigma1( w3) + w14 + sigma0( w6));\n+    Round(c, d, e, f, g, h, a, b, 0x5b9cca4f, w6 += sigma1( w4) + w15 + sigma0( w7));\n+    Round(b, c, d, e, f, g, h, a, 0x682e6ff3, w7 += sigma1( w5) + w0 + sigma0( w8));\n+    Round(a, b, c, d, e, f, g, h, 0x748f82ee, w8 += sigma1( w6) + w1 + sigma0( w9));\n+    Round(h, a, b, c, d, e, f, g, 0x78a5636f, w9 += sigma1( w7) + w2 + sigma0(w10));\n+    Round(g, h, a, b, c, d, e, f, 0x84c87814, w10 += sigma1( w8) + w3 + sigma0(w11));\n+    Round(f, g, h, a, b, c, d, e, 0x8cc70208, w11 += sigma1( w9) + w4 + sigma0(w12));\n+    Round(e, f, g, h, a, b, c, d, 0x90befffa, w12 += sigma1(w10) + w5 + sigma0(w13));\n+    Round(d, e, f, g, h, a, b, c, 0xa4506ceb, w13 += sigma1(w11) + w6 + sigma0(w14));\n+    Round(c, d, e, f, g, h, a, b, 0xbef9a3f7, w14 + sigma1(w12) + w7 + sigma0(w15));\n+    Round(b, c, d, e, f, g, h, a, 0xc67178f2, w15 + sigma1(w13) + w8 + sigma0( w0));\n \n     s[0] += a;\n     s[1] += b;\n@@ -124,31 +151,56 @@ void Transform(uint32_t *s, const unsigned char *chunk) {\n     s[6] += g;\n     s[7] += h;\n }\n-\n }  // namespace sha256\n \n /// Internal SHA-512 implementation.\n-namespace sha512 {\n+namespace sha512\n+{\n+uint64_t inline Ch(uint64_t x, uint64_t y, uint64_t z)\n+{\n+    return z ^ (x & (y ^ z));\n+}\n+\n+uint64_t inline Maj(uint64_t x, uint64_t y, uint64_t z)\n+{\n+    return (x & y) | (z & (x | y));\n+}\n+\n+uint64_t inline Sigma0(uint64_t x)\n+{\n+    return (x >> 28 | x << 36) ^ (x >> 34 | x << 30) ^ (x >> 39 | x << 25);\n+}\n \n-uint64_t inline Ch(uint64_t x, uint64_t y, uint64_t z) { return z ^ (x & (y ^ z)); }\n-uint64_t inline Maj(uint64_t x, uint64_t y, uint64_t z) { return (x & y) | (z & (x | y)); }\n-uint64_t inline Sigma0(uint64_t x) { return (x >> 28 | x << 36) ^ (x >> 34 | x << 30) ^ (x >> 39 | x << 25); }\n-uint64_t inline Sigma1(uint64_t x) { return (x >> 14 | x << 50) ^ (x >> 18 | x << 46) ^ (x >> 41 | x << 23); }\n-uint64_t inline sigma0(uint64_t x) { return (x >> 1 | x << 63) ^ (x >> 8 | x << 56) ^ (x >> 7); }\n-uint64_t inline sigma1(uint64_t x) { return (x >> 19 | x << 45) ^ (x >> 61 | x << 3) ^ (x >> 6); }\n+uint64_t inline Sigma1(uint64_t x)\n+{\n+    return (x >> 14 | x << 50) ^ (x >> 18 | x << 46) ^ (x >> 41 | x << 23);\n+}\n+\n+uint64_t inline sigma0(uint64_t x)\n+{\n+    return (x >> 1 | x << 63) ^ (x >> 8 | x << 56) ^ (x >> 7);\n+}\n+\n+uint64_t inline sigma1(uint64_t x)\n+{\n+    return (x >> 19 | x << 45) ^ (x >> 61 | x << 3) ^ (x >> 6);\n+}\n \n /** One round of SHA-512. */\n void inline Round(uint64_t a, uint64_t b, uint64_t c, uint64_t &d,\n-                  uint64_t e, uint64_t f, uint64_t g, uint64_t &h,\n-                  uint64_t k, uint64_t w) {\n+            uint64_t e, uint64_t f, uint64_t g, uint64_t &h,\n+            uint64_t k, uint64_t w)\n+{\n     uint64_t t1 = h + Sigma1(e) + Ch(e, f, g) + k + w;\n     uint64_t t2 = Sigma0(a) + Maj(a, b, c);\n+\n     d += t1;\n     h = t1 + t2;\n }\n \n /** Initialize SHA-256 state. */\n-void inline Initialize(uint64_t *s) {\n+void inline Initialize(uint64_t* s)\n+{\n     s[0] = 0x6a09e667f3bcc908ull;\n     s[1] = 0xbb67ae8584caa73bull;\n     s[2] = 0x3c6ef372fe94f82bull;\n@@ -160,94 +212,95 @@ void inline Initialize(uint64_t *s) {\n }\n \n /** Perform one SHA-512 transformation, processing a 128-byte chunk. */\n-void Transform(uint64_t *s, const unsigned char *chunk) {\n+void Transform(uint64_t* s, const unsigned char* chunk)\n+{\n     uint64_t a = s[0], b = s[1], c = s[2], d = s[3], e = s[4], f = s[5], g = s[6], h = s[7];\n     uint64_t w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;\n \n-    Round(a, b, c, d, e, f, g, h, 0x428a2f98d728ae22ull,  w0 = ReadBE64(chunk + 0));\n-    Round(h, a, b, c, d, e, f, g, 0x7137449123ef65cdull,  w1 = ReadBE64(chunk + 8));\n-    Round(g, h, a, b, c, d, e, f, 0xb5c0fbcfec4d3b2full,  w2 = ReadBE64(chunk + 16));\n-    Round(f, g, h, a, b, c, d, e, 0xe9b5dba58189dbbcull,  w3 = ReadBE64(chunk + 24));\n-    Round(e, f, g, h, a, b, c, d, 0x3956c25bf348b538ull,  w4 = ReadBE64(chunk + 32));\n-    Round(d, e, f, g, h, a, b, c, 0x59f111f1b605d019ull,  w5 = ReadBE64(chunk + 40));\n-    Round(c, d, e, f, g, h, a, b, 0x923f82a4af194f9bull,  w6 = ReadBE64(chunk + 48));\n-    Round(b, c, d, e, f, g, h, a, 0xab1c5ed5da6d8118ull,  w7 = ReadBE64(chunk + 56));\n-    Round(a, b, c, d, e, f, g, h, 0xd807aa98a3030242ull,  w8 = ReadBE64(chunk + 64));\n-    Round(h, a, b, c, d, e, f, g, 0x12835b0145706fbeull,  w9 = ReadBE64(chunk + 72));\n+    Round(a, b, c, d, e, f, g, h, 0x428a2f98d728ae22ull, w0 = ReadBE64(chunk + 0));\n+    Round(h, a, b, c, d, e, f, g, 0x7137449123ef65cdull, w1 = ReadBE64(chunk + 8));\n+    Round(g, h, a, b, c, d, e, f, 0xb5c0fbcfec4d3b2full, w2 = ReadBE64(chunk + 16));\n+    Round(f, g, h, a, b, c, d, e, 0xe9b5dba58189dbbcull, w3 = ReadBE64(chunk + 24));\n+    Round(e, f, g, h, a, b, c, d, 0x3956c25bf348b538ull, w4 = ReadBE64(chunk + 32));\n+    Round(d, e, f, g, h, a, b, c, 0x59f111f1b605d019ull, w5 = ReadBE64(chunk + 40));\n+    Round(c, d, e, f, g, h, a, b, 0x923f82a4af194f9bull, w6 = ReadBE64(chunk + 48));\n+    Round(b, c, d, e, f, g, h, a, 0xab1c5ed5da6d8118ull, w7 = ReadBE64(chunk + 56));\n+    Round(a, b, c, d, e, f, g, h, 0xd807aa98a3030242ull, w8 = ReadBE64(chunk + 64));\n+    Round(h, a, b, c, d, e, f, g, 0x12835b0145706fbeull, w9 = ReadBE64(chunk + 72));\n     Round(g, h, a, b, c, d, e, f, 0x243185be4ee4b28cull, w10 = ReadBE64(chunk + 80));\n     Round(f, g, h, a, b, c, d, e, 0x550c7dc3d5ffb4e2ull, w11 = ReadBE64(chunk + 88));\n     Round(e, f, g, h, a, b, c, d, 0x72be5d74f27b896full, w12 = ReadBE64(chunk + 96));\n     Round(d, e, f, g, h, a, b, c, 0x80deb1fe3b1696b1ull, w13 = ReadBE64(chunk + 104));\n     Round(c, d, e, f, g, h, a, b, 0x9bdc06a725c71235ull, w14 = ReadBE64(chunk + 112));\n     Round(b, c, d, e, f, g, h, a, 0xc19bf174cf692694ull, w15 = ReadBE64(chunk + 120));\n \n-    Round(a, b, c, d, e, f, g, h, 0xe49b69c19ef14ad2ull,  w0 += sigma1(w14) +  w9 + sigma0( w1));\n-    Round(h, a, b, c, d, e, f, g, 0xefbe4786384f25e3ull,  w1 += sigma1(w15) + w10 + sigma0( w2));\n-    Round(g, h, a, b, c, d, e, f, 0x0fc19dc68b8cd5b5ull,  w2 += sigma1( w0) + w11 + sigma0( w3));\n-    Round(f, g, h, a, b, c, d, e, 0x240ca1cc77ac9c65ull,  w3 += sigma1( w1) + w12 + sigma0( w4));\n-    Round(e, f, g, h, a, b, c, d, 0x2de92c6f592b0275ull,  w4 += sigma1( w2) + w13 + sigma0( w5));\n-    Round(d, e, f, g, h, a, b, c, 0x4a7484aa6ea6e483ull,  w5 += sigma1( w3) + w14 + sigma0( w6));\n-    Round(c, d, e, f, g, h, a, b, 0x5cb0a9dcbd41fbd4ull,  w6 += sigma1( w4) + w15 + sigma0( w7));\n-    Round(b, c, d, e, f, g, h, a, 0x76f988da831153b5ull,  w7 += sigma1( w5) +  w0 + sigma0( w8));\n-    Round(a, b, c, d, e, f, g, h, 0x983e5152ee66dfabull,  w8 += sigma1( w6) +  w1 + sigma0( w9));\n-    Round(h, a, b, c, d, e, f, g, 0xa831c66d2db43210ull,  w9 += sigma1( w7) +  w2 + sigma0(w10));\n-    Round(g, h, a, b, c, d, e, f, 0xb00327c898fb213full, w10 += sigma1( w8) +  w3 + sigma0(w11));\n-    Round(f, g, h, a, b, c, d, e, 0xbf597fc7beef0ee4ull, w11 += sigma1( w9) +  w4 + sigma0(w12));\n-    Round(e, f, g, h, a, b, c, d, 0xc6e00bf33da88fc2ull, w12 += sigma1(w10) +  w5 + sigma0(w13));\n-    Round(d, e, f, g, h, a, b, c, 0xd5a79147930aa725ull, w13 += sigma1(w11) +  w6 + sigma0(w14));\n-    Round(c, d, e, f, g, h, a, b, 0x06ca6351e003826full, w14 += sigma1(w12) +  w7 + sigma0(w15));\n-    Round(b, c, d, e, f, g, h, a, 0x142929670a0e6e70ull, w15 += sigma1(w13) +  w8 + sigma0( w0));\n-\n-    Round(a, b, c, d, e, f, g, h, 0x27b70a8546d22ffcull,  w0 += sigma1(w14) +  w9 + sigma0( w1));\n-    Round(h, a, b, c, d, e, f, g, 0x2e1b21385c26c926ull,  w1 += sigma1(w15) + w10 + sigma0( w2));\n-    Round(g, h, a, b, c, d, e, f, 0x4d2c6dfc5ac42aedull,  w2 += sigma1( w0) + w11 + sigma0( w3));\n-    Round(f, g, h, a, b, c, d, e, 0x53380d139d95b3dfull,  w3 += sigma1( w1) + w12 + sigma0( w4));\n-    Round(e, f, g, h, a, b, c, d, 0x650a73548baf63deull,  w4 += sigma1( w2) + w13 + sigma0( w5));\n-    Round(d, e, f, g, h, a, b, c, 0x766a0abb3c77b2a8ull,  w5 += sigma1( w3) + w14 + sigma0( w6));\n-    Round(c, d, e, f, g, h, a, b, 0x81c2c92e47edaee6ull,  w6 += sigma1( w4) + w15 + sigma0( w7));\n-    Round(b, c, d, e, f, g, h, a, 0x92722c851482353bull,  w7 += sigma1( w5) +  w0 + sigma0( w8));\n-    Round(a, b, c, d, e, f, g, h, 0xa2bfe8a14cf10364ull,  w8 += sigma1( w6) +  w1 + sigma0( w9));\n-    Round(h, a, b, c, d, e, f, g, 0xa81a664bbc423001ull,  w9 += sigma1( w7) +  w2 + sigma0(w10));\n-    Round(g, h, a, b, c, d, e, f, 0xc24b8b70d0f89791ull, w10 += sigma1( w8) +  w3 + sigma0(w11));\n-    Round(f, g, h, a, b, c, d, e, 0xc76c51a30654be30ull, w11 += sigma1( w9) +  w4 + sigma0(w12));\n-    Round(e, f, g, h, a, b, c, d, 0xd192e819d6ef5218ull, w12 += sigma1(w10) +  w5 + sigma0(w13));\n-    Round(d, e, f, g, h, a, b, c, 0xd69906245565a910ull, w13 += sigma1(w11) +  w6 + sigma0(w14));\n-    Round(c, d, e, f, g, h, a, b, 0xf40e35855771202aull, w14 += sigma1(w12) +  w7 + sigma0(w15));\n-    Round(b, c, d, e, f, g, h, a, 0x106aa07032bbd1b8ull, w15 += sigma1(w13) +  w8 + sigma0( w0));\n-\n-    Round(a, b, c, d, e, f, g, h, 0x19a4c116b8d2d0c8ull,  w0 += sigma1(w14) +  w9 + sigma0( w1));\n-    Round(h, a, b, c, d, e, f, g, 0x1e376c085141ab53ull,  w1 += sigma1(w15) + w10 + sigma0( w2));\n-    Round(g, h, a, b, c, d, e, f, 0x2748774cdf8eeb99ull,  w2 += sigma1( w0) + w11 + sigma0( w3));\n-    Round(f, g, h, a, b, c, d, e, 0x34b0bcb5e19b48a8ull,  w3 += sigma1( w1) + w12 + sigma0( w4));\n-    Round(e, f, g, h, a, b, c, d, 0x391c0cb3c5c95a63ull,  w4 += sigma1( w2) + w13 + sigma0( w5));\n-    Round(d, e, f, g, h, a, b, c, 0x4ed8aa4ae3418acbull,  w5 += sigma1( w3) + w14 + sigma0( w6));\n-    Round(c, d, e, f, g, h, a, b, 0x5b9cca4f7763e373ull,  w6 += sigma1( w4) + w15 + sigma0( w7));\n-    Round(b, c, d, e, f, g, h, a, 0x682e6ff3d6b2b8a3ull,  w7 += sigma1( w5) +  w0 + sigma0( w8));\n-    Round(a, b, c, d, e, f, g, h, 0x748f82ee5defb2fcull,  w8 += sigma1( w6) +  w1 + sigma0( w9));\n-    Round(h, a, b, c, d, e, f, g, 0x78a5636f43172f60ull,  w9 += sigma1( w7) +  w2 + sigma0(w10));\n-    Round(g, h, a, b, c, d, e, f, 0x84c87814a1f0ab72ull, w10 += sigma1( w8) +  w3 + sigma0(w11));\n-    Round(f, g, h, a, b, c, d, e, 0x8cc702081a6439ecull, w11 += sigma1( w9) +  w4 + sigma0(w12));\n-    Round(e, f, g, h, a, b, c, d, 0x90befffa23631e28ull, w12 += sigma1(w10) +  w5 + sigma0(w13));\n-    Round(d, e, f, g, h, a, b, c, 0xa4506cebde82bde9ull, w13 += sigma1(w11) +  w6 + sigma0(w14));\n-    Round(c, d, e, f, g, h, a, b, 0xbef9a3f7b2c67915ull, w14 += sigma1(w12) +  w7 + sigma0(w15));\n-    Round(b, c, d, e, f, g, h, a, 0xc67178f2e372532bull, w15 += sigma1(w13) +  w8 + sigma0( w0));\n-\n-    Round(a, b, c, d, e, f, g, h, 0xca273eceea26619cull,  w0 += sigma1(w14) +  w9 + sigma0( w1));\n-    Round(h, a, b, c, d, e, f, g, 0xd186b8c721c0c207ull,  w1 += sigma1(w15) + w10 + sigma0( w2));\n-    Round(g, h, a, b, c, d, e, f, 0xeada7dd6cde0eb1eull,  w2 += sigma1( w0) + w11 + sigma0( w3));\n-    Round(f, g, h, a, b, c, d, e, 0xf57d4f7fee6ed178ull,  w3 += sigma1( w1) + w12 + sigma0( w4));\n-    Round(e, f, g, h, a, b, c, d, 0x06f067aa72176fbaull,  w4 += sigma1( w2) + w13 + sigma0( w5));\n-    Round(d, e, f, g, h, a, b, c, 0x0a637dc5a2c898a6ull,  w5 += sigma1( w3) + w14 + sigma0( w6));\n-    Round(c, d, e, f, g, h, a, b, 0x113f9804bef90daeull,  w6 += sigma1( w4) + w15 + sigma0( w7));\n-    Round(b, c, d, e, f, g, h, a, 0x1b710b35131c471bull,  w7 += sigma1( w5) +  w0 + sigma0( w8));\n-    Round(a, b, c, d, e, f, g, h, 0x28db77f523047d84ull,  w8 += sigma1( w6) +  w1 + sigma0( w9));\n-    Round(h, a, b, c, d, e, f, g, 0x32caab7b40c72493ull,  w9 += sigma1( w7) +  w2 + sigma0(w10));\n-    Round(g, h, a, b, c, d, e, f, 0x3c9ebe0a15c9bebcull, w10 += sigma1( w8) +  w3 + sigma0(w11));\n-    Round(f, g, h, a, b, c, d, e, 0x431d67c49c100d4cull, w11 += sigma1( w9) +  w4 + sigma0(w12));\n-    Round(e, f, g, h, a, b, c, d, 0x4cc5d4becb3e42b6ull, w12 += sigma1(w10) +  w5 + sigma0(w13));\n-    Round(d, e, f, g, h, a, b, c, 0x597f299cfc657e2aull, w13 += sigma1(w11) +  w6 + sigma0(w14));\n-    Round(c, d, e, f, g, h, a, b, 0x5fcb6fab3ad6faecull, w14 += sigma1(w12) +  w7 + sigma0(w15));\n-    Round(b, c, d, e, f, g, h, a, 0x6c44198c4a475817ull, w15 += sigma1(w13) +  w8 + sigma0( w0));\n+    Round(a, b, c, d, e, f, g, h, 0xe49b69c19ef14ad2ull, w0 += sigma1(w14) + w9 + sigma0( w1));\n+    Round(h, a, b, c, d, e, f, g, 0xefbe4786384f25e3ull, w1 += sigma1(w15) + w10 + sigma0( w2));\n+    Round(g, h, a, b, c, d, e, f, 0x0fc19dc68b8cd5b5ull, w2 += sigma1( w0) + w11 + sigma0( w3));\n+    Round(f, g, h, a, b, c, d, e, 0x240ca1cc77ac9c65ull, w3 += sigma1( w1) + w12 + sigma0( w4));\n+    Round(e, f, g, h, a, b, c, d, 0x2de92c6f592b0275ull, w4 += sigma1( w2) + w13 + sigma0( w5));\n+    Round(d, e, f, g, h, a, b, c, 0x4a7484aa6ea6e483ull, w5 += sigma1( w3) + w14 + sigma0( w6));\n+    Round(c, d, e, f, g, h, a, b, 0x5cb0a9dcbd41fbd4ull, w6 += sigma1( w4) + w15 + sigma0( w7));\n+    Round(b, c, d, e, f, g, h, a, 0x76f988da831153b5ull, w7 += sigma1( w5) + w0 + sigma0( w8));\n+    Round(a, b, c, d, e, f, g, h, 0x983e5152ee66dfabull, w8 += sigma1( w6) + w1 + sigma0( w9));\n+    Round(h, a, b, c, d, e, f, g, 0xa831c66d2db43210ull, w9 += sigma1( w7) + w2 + sigma0(w10));\n+    Round(g, h, a, b, c, d, e, f, 0xb00327c898fb213full, w10 += sigma1( w8) + w3 + sigma0(w11));\n+    Round(f, g, h, a, b, c, d, e, 0xbf597fc7beef0ee4ull, w11 += sigma1( w9) + w4 + sigma0(w12));\n+    Round(e, f, g, h, a, b, c, d, 0xc6e00bf33da88fc2ull, w12 += sigma1(w10) + w5 + sigma0(w13));\n+    Round(d, e, f, g, h, a, b, c, 0xd5a79147930aa725ull, w13 += sigma1(w11) + w6 + sigma0(w14));\n+    Round(c, d, e, f, g, h, a, b, 0x06ca6351e003826full, w14 += sigma1(w12) + w7 + sigma0(w15));\n+    Round(b, c, d, e, f, g, h, a, 0x142929670a0e6e70ull, w15 += sigma1(w13) + w8 + sigma0( w0));\n+\n+    Round(a, b, c, d, e, f, g, h, 0x27b70a8546d22ffcull, w0 += sigma1(w14) + w9 + sigma0( w1));\n+    Round(h, a, b, c, d, e, f, g, 0x2e1b21385c26c926ull, w1 += sigma1(w15) + w10 + sigma0( w2));\n+    Round(g, h, a, b, c, d, e, f, 0x4d2c6dfc5ac42aedull, w2 += sigma1( w0) + w11 + sigma0( w3));\n+    Round(f, g, h, a, b, c, d, e, 0x53380d139d95b3dfull, w3 += sigma1( w1) + w12 + sigma0( w4));\n+    Round(e, f, g, h, a, b, c, d, 0x650a73548baf63deull, w4 += sigma1( w2) + w13 + sigma0( w5));\n+    Round(d, e, f, g, h, a, b, c, 0x766a0abb3c77b2a8ull, w5 += sigma1( w3) + w14 + sigma0( w6));\n+    Round(c, d, e, f, g, h, a, b, 0x81c2c92e47edaee6ull, w6 += sigma1( w4) + w15 + sigma0( w7));\n+    Round(b, c, d, e, f, g, h, a, 0x92722c851482353bull, w7 += sigma1( w5) + w0 + sigma0( w8));\n+    Round(a, b, c, d, e, f, g, h, 0xa2bfe8a14cf10364ull, w8 += sigma1( w6) + w1 + sigma0( w9));\n+    Round(h, a, b, c, d, e, f, g, 0xa81a664bbc423001ull, w9 += sigma1( w7) + w2 + sigma0(w10));\n+    Round(g, h, a, b, c, d, e, f, 0xc24b8b70d0f89791ull, w10 += sigma1( w8) + w3 + sigma0(w11));\n+    Round(f, g, h, a, b, c, d, e, 0xc76c51a30654be30ull, w11 += sigma1( w9) + w4 + sigma0(w12));\n+    Round(e, f, g, h, a, b, c, d, 0xd192e819d6ef5218ull, w12 += sigma1(w10) + w5 + sigma0(w13));\n+    Round(d, e, f, g, h, a, b, c, 0xd69906245565a910ull, w13 += sigma1(w11) + w6 + sigma0(w14));\n+    Round(c, d, e, f, g, h, a, b, 0xf40e35855771202aull, w14 += sigma1(w12) + w7 + sigma0(w15));\n+    Round(b, c, d, e, f, g, h, a, 0x106aa07032bbd1b8ull, w15 += sigma1(w13) + w8 + sigma0( w0));\n+\n+    Round(a, b, c, d, e, f, g, h, 0x19a4c116b8d2d0c8ull, w0 += sigma1(w14) + w9 + sigma0( w1));\n+    Round(h, a, b, c, d, e, f, g, 0x1e376c085141ab53ull, w1 += sigma1(w15) + w10 + sigma0( w2));\n+    Round(g, h, a, b, c, d, e, f, 0x2748774cdf8eeb99ull, w2 += sigma1( w0) + w11 + sigma0( w3));\n+    Round(f, g, h, a, b, c, d, e, 0x34b0bcb5e19b48a8ull, w3 += sigma1( w1) + w12 + sigma0( w4));\n+    Round(e, f, g, h, a, b, c, d, 0x391c0cb3c5c95a63ull, w4 += sigma1( w2) + w13 + sigma0( w5));\n+    Round(d, e, f, g, h, a, b, c, 0x4ed8aa4ae3418acbull, w5 += sigma1( w3) + w14 + sigma0( w6));\n+    Round(c, d, e, f, g, h, a, b, 0x5b9cca4f7763e373ull, w6 += sigma1( w4) + w15 + sigma0( w7));\n+    Round(b, c, d, e, f, g, h, a, 0x682e6ff3d6b2b8a3ull, w7 += sigma1( w5) + w0 + sigma0( w8));\n+    Round(a, b, c, d, e, f, g, h, 0x748f82ee5defb2fcull, w8 += sigma1( w6) + w1 + sigma0( w9));\n+    Round(h, a, b, c, d, e, f, g, 0x78a5636f43172f60ull, w9 += sigma1( w7) + w2 + sigma0(w10));\n+    Round(g, h, a, b, c, d, e, f, 0x84c87814a1f0ab72ull, w10 += sigma1( w8) + w3 + sigma0(w11));\n+    Round(f, g, h, a, b, c, d, e, 0x8cc702081a6439ecull, w11 += sigma1( w9) + w4 + sigma0(w12));\n+    Round(e, f, g, h, a, b, c, d, 0x90befffa23631e28ull, w12 += sigma1(w10) + w5 + sigma0(w13));\n+    Round(d, e, f, g, h, a, b, c, 0xa4506cebde82bde9ull, w13 += sigma1(w11) + w6 + sigma0(w14));\n+    Round(c, d, e, f, g, h, a, b, 0xbef9a3f7b2c67915ull, w14 += sigma1(w12) + w7 + sigma0(w15));\n+    Round(b, c, d, e, f, g, h, a, 0xc67178f2e372532bull, w15 += sigma1(w13) + w8 + sigma0( w0));\n+\n+    Round(a, b, c, d, e, f, g, h, 0xca273eceea26619cull, w0 += sigma1(w14) + w9 + sigma0( w1));\n+    Round(h, a, b, c, d, e, f, g, 0xd186b8c721c0c207ull, w1 += sigma1(w15) + w10 + sigma0( w2));\n+    Round(g, h, a, b, c, d, e, f, 0xeada7dd6cde0eb1eull, w2 += sigma1( w0) + w11 + sigma0( w3));\n+    Round(f, g, h, a, b, c, d, e, 0xf57d4f7fee6ed178ull, w3 += sigma1( w1) + w12 + sigma0( w4));\n+    Round(e, f, g, h, a, b, c, d, 0x06f067aa72176fbaull, w4 += sigma1( w2) + w13 + sigma0( w5));\n+    Round(d, e, f, g, h, a, b, c, 0x0a637dc5a2c898a6ull, w5 += sigma1( w3) + w14 + sigma0( w6));\n+    Round(c, d, e, f, g, h, a, b, 0x113f9804bef90daeull, w6 += sigma1( w4) + w15 + sigma0( w7));\n+    Round(b, c, d, e, f, g, h, a, 0x1b710b35131c471bull, w7 += sigma1( w5) + w0 + sigma0( w8));\n+    Round(a, b, c, d, e, f, g, h, 0x28db77f523047d84ull, w8 += sigma1( w6) + w1 + sigma0( w9));\n+    Round(h, a, b, c, d, e, f, g, 0x32caab7b40c72493ull, w9 += sigma1( w7) + w2 + sigma0(w10));\n+    Round(g, h, a, b, c, d, e, f, 0x3c9ebe0a15c9bebcull, w10 += sigma1( w8) + w3 + sigma0(w11));\n+    Round(f, g, h, a, b, c, d, e, 0x431d67c49c100d4cull, w11 += sigma1( w9) + w4 + sigma0(w12));\n+    Round(e, f, g, h, a, b, c, d, 0x4cc5d4becb3e42b6ull, w12 += sigma1(w10) + w5 + sigma0(w13));\n+    Round(d, e, f, g, h, a, b, c, 0x597f299cfc657e2aull, w13 += sigma1(w11) + w6 + sigma0(w14));\n+    Round(c, d, e, f, g, h, a, b, 0x5fcb6fab3ad6faecull, w14 += sigma1(w12) + w7 + sigma0(w15));\n+    Round(b, c, d, e, f, g, h, a, 0x6c44198c4a475817ull, w15 += sigma1(w13) + w8 + sigma0( w0));\n \n     s[0] += a;\n     s[1] += b;\n@@ -258,141 +311,182 @@ void Transform(uint64_t *s, const unsigned char *chunk) {\n     s[6] += g;\n     s[7] += h;\n }\n-\n }  // namespace sha512\n-\n }  // namespace\n \n-\n ////// SHA-256\n \n-CSHA256::CSHA256() : bytes(0) {\n+CSHA256::CSHA256() : bytes(0)\n+{\n     sha256::Initialize(s);\n }\n \n-CSHA256& CSHA256::Write(const unsigned char *data, size_t len) {\n-    const unsigned char *end = data + len;\n+CSHA256& CSHA256::Write(const unsigned char* data, size_t len)\n+{\n+    const unsigned char* end = data + len;\n     size_t bufsize = bytes % 64;\n-    if (bufsize && bufsize + len >= 64) {\n+\n+    if (bufsize && bufsize + len >= 64)\n+    {\n         // Fill the buffer, and process it.\n         memcpy(buf + bufsize, data, 64 - bufsize);\n         bytes += 64 - bufsize;\n         data += 64 - bufsize;\n         sha256::Transform(s, buf);\n         bufsize = 0;\n     }\n-    while (end >= data + 64) {\n+\n+    while (end >= data + 64)\n+    {\n         // Process full chunks directly from the source.\n         sha256::Transform(s, data);\n         bytes += 64;\n         data += 64;\n     }\n-    if (end > data) {\n+\n+    if (end > data)\n+    {\n         // Fill the buffer with what remains.\n         memcpy(buf + bufsize, data, end - data);\n         bytes += end - data;\n     }\n+\n     return *this;\n }\n \n-void CSHA256::Finalize(unsigned char hash[OUTPUT_SIZE]) {\n-    static const unsigned char pad[64] = {0x80};\n+void CSHA256::Finalize(unsigned char hash[OUTPUT_SIZE])\n+{\n+    static const unsigned char pad[64] = {\n+        0x80\n+    };\n     unsigned char sizedesc[8];\n+\n     WriteBE64(sizedesc, bytes << 3);\n     Write(pad, 1 + ((119 - (bytes % 64)) % 64));\n     Write(sizedesc, 8);\n     WriteBE32(hash, s[0]);\n-    WriteBE32(hash+4, s[1]);\n-    WriteBE32(hash+8, s[2]);\n-    WriteBE32(hash+12, s[3]);\n-    WriteBE32(hash+16, s[4]);\n-    WriteBE32(hash+20, s[5]);\n-    WriteBE32(hash+24, s[6]);\n-    WriteBE32(hash+28, s[7]);\n+    WriteBE32(hash + 4, s[1]);\n+    WriteBE32(hash + 8, s[2]);\n+    WriteBE32(hash + 12, s[3]);\n+    WriteBE32(hash + 16, s[4]);\n+    WriteBE32(hash + 20, s[5]);\n+    WriteBE32(hash + 24, s[6]);\n+    WriteBE32(hash + 28, s[7]);\n }\n \n-CSHA256& CSHA256::Reset() {\n+CSHA256& CSHA256::Reset()\n+{\n     bytes = 0;\n     sha256::Initialize(s);\n     return *this;\n }\n \n ////// SHA-512\n \n-CSHA512::CSHA512() : bytes(0) {\n+CSHA512::CSHA512() : bytes(0)\n+{\n     sha512::Initialize(s);\n }\n \n-CSHA512& CSHA512::Write(const unsigned char *data, size_t len) {\n-    const unsigned char *end = data + len;\n+CSHA512& CSHA512::Write(const unsigned char* data, size_t len)\n+{\n+    const unsigned char* end = data + len;\n     size_t bufsize = bytes % 128;\n-    if (bufsize && bufsize + len >= 128) {\n+\n+    if (bufsize && bufsize + len >= 128)\n+    {\n         // Fill the buffer, and process it.\n         memcpy(buf + bufsize, data, 128 - bufsize);\n         bytes += 128 - bufsize;\n         data += 128 - bufsize;\n         sha512::Transform(s, buf);\n         bufsize = 0;\n     }\n-    while (end >= data + 128) {\n+\n+    while (end >= data + 128)\n+    {\n         // Process full chunks directly from the source.\n         sha512::Transform(s, data);\n         data += 128;\n         bytes += 128;\n     }\n-    if (end > data) {\n+\n+    if (end > data)\n+    {\n         // Fill the buffer with what remains.\n         memcpy(buf + bufsize, data, end - data);\n         bytes += end - data;\n     }\n+\n     return *this;\n }\n \n-void CSHA512::Finalize(unsigned char hash[OUTPUT_SIZE]) {\n-    static const unsigned char pad[128] = {0x80};\n-    unsigned char sizedesc[16] = {0x00};\n-    WriteBE64(sizedesc+8, bytes << 3);\n+void CSHA512::Finalize(unsigned char hash[OUTPUT_SIZE])\n+{\n+    static const unsigned char pad[128] = {\n+        0x80\n+    };\n+    unsigned char sizedesc[16] = {\n+        0x00\n+    };\n+\n+    WriteBE64(sizedesc + 8, bytes << 3);\n     Write(pad, 1 + ((239 - (bytes % 128)) % 128));\n     Write(sizedesc, 16);\n     WriteBE64(hash, s[0]);\n-    WriteBE64(hash+8, s[1]);\n-    WriteBE64(hash+16, s[2]);\n-    WriteBE64(hash+24, s[3]);\n-    WriteBE64(hash+32, s[4]);\n-    WriteBE64(hash+40, s[5]);\n-    WriteBE64(hash+48, s[6]);\n-    WriteBE64(hash+56, s[7]);\n+    WriteBE64(hash + 8, s[1]);\n+    WriteBE64(hash + 16, s[2]);\n+    WriteBE64(hash + 24, s[3]);\n+    WriteBE64(hash + 32, s[4]);\n+    WriteBE64(hash + 40, s[5]);\n+    WriteBE64(hash + 48, s[6]);\n+    WriteBE64(hash + 56, s[7]);\n }\n \n-CSHA512& CSHA512::Reset() {\n+CSHA512& CSHA512::Reset()\n+{\n     bytes = 0;\n     sha512::Initialize(s);\n     return *this;\n }\n \n ////// HMAC-SHA-512\n \n-CHMAC_SHA512::CHMAC_SHA512(const unsigned char *key, size_t keylen) {\n+CHMAC_SHA512::CHMAC_SHA512(const unsigned char* key, size_t keylen)\n+{\n     unsigned char rkey[128];\n-    if (keylen <= 128) {\n+\n+    if (keylen <= 128)\n+    {\n         memcpy(rkey, key, keylen);\n         memset(rkey + keylen, 0, 128 - keylen);\n-    } else {\n+    }\n+    else\n+    {\n         CSHA512().Write(key, keylen).Finalize(rkey);\n         memset(rkey + 64, 0, 64);\n     }\n \n-    for (int n=0; n<128; n++)\n+    for (int n = 0; n < 128; n++)\n+    {\n         rkey[n] ^= 0x5c;\n+    }\n+\n     outer.Write(rkey, 128);\n \n-    for (int n=0; n<128; n++)\n+    for (int n = 0; n < 128; n++)\n+    {\n         rkey[n] ^= 0x5c ^ 0x36;\n+    }\n+\n     inner.Write(rkey, 128);\n }\n \n-void CHMAC_SHA512::Finalize(unsigned char hash[OUTPUT_SIZE]) {\n+void CHMAC_SHA512::Finalize(unsigned char hash[OUTPUT_SIZE])\n+{\n     unsigned char temp[64];\n+\n     inner.Finalize(temp);\n     outer.Write(temp, 64).Finalize(hash);\n }\n+"
      },
      {
        "sha": "b7fcbb520aafd231473654f180a36b528dbace81",
        "filename": "src/crypto/sha2.h",
        "status": "modified",
        "additions": 13,
        "deletions": 7,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/crypto/sha2.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/crypto/sha2.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha2.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -9,7 +9,8 @@\n #include <stdlib.h>\n \n /** A hasher class for SHA-256. */\n-class CSHA256 {\n+class CSHA256\n+{\n private:\n     uint32_t s[8];\n     unsigned char buf[64];\n@@ -19,13 +20,14 @@ class CSHA256 {\n     static const size_t OUTPUT_SIZE = 32;\n \n     CSHA256();\n-    CSHA256& Write(const unsigned char *data, size_t len);\n+    CSHA256& Write(const unsigned char* data, size_t len);\n     void Finalize(unsigned char hash[OUTPUT_SIZE]);\n     CSHA256& Reset();\n };\n \n /** A hasher class for SHA-512. */\n-class CSHA512 {\n+class CSHA512\n+{\n private:\n     uint64_t s[8];\n     unsigned char buf[128];\n@@ -35,26 +37,30 @@ class CSHA512 {\n     static const size_t OUTPUT_SIZE = 64;\n \n     CSHA512();\n-    CSHA512& Write(const unsigned char *data, size_t len);\n+    CSHA512& Write(const unsigned char* data, size_t len);\n     void Finalize(unsigned char hash[OUTPUT_SIZE]);\n     CSHA512& Reset();\n };\n \n /** A hasher class for HMAC-SHA-512. */\n-class CHMAC_SHA512 {\n+class CHMAC_SHA512\n+{\n private:\n     CSHA512 outer;\n     CSHA512 inner;\n \n public:\n     static const size_t OUTPUT_SIZE = 64;\n \n-    CHMAC_SHA512(const unsigned char *key, size_t keylen);\n-    CHMAC_SHA512& Write(const unsigned char *data, size_t len) {\n+    CHMAC_SHA512(const unsigned char* key, size_t keylen);\n+    CHMAC_SHA512& Write(const unsigned char* data, size_t len)\n+    {\n         inner.Write(data, len);\n         return *this;\n     }\n+\n     void Finalize(unsigned char hash[OUTPUT_SIZE]);\n };\n \n #endif\n+"
      },
      {
        "sha": "12b4371282c4bc5bdbd32b3daeea1c27463e3120",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 164,
        "deletions": 47,
        "changes": 211,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -25,11 +25,8 @@\n using namespace std;\n using namespace boost;\n \n-\n unsigned int nWalletDBUpdated;\n \n-\n-\n //\n // CDB\n //\n@@ -39,14 +36,22 @@ CDBEnv bitdb;\n void CDBEnv::EnvShutdown()\n {\n     if (!fDbEnvInit)\n+    {\n         return;\n+    }\n \n     fDbEnvInit = false;\n     int ret = dbenv.close(0);\n+\n     if (ret != 0)\n+    {\n         LogPrintf(\"CDBEnv::EnvShutdown : Error %d shutting down database environment: %s\\n\", ret, DbEnv::strerror(ret));\n+    }\n+\n     if (!fMockDb)\n+    {\n         DbEnv(0).remove(path.string().c_str(), 0);\n+    }\n }\n \n CDBEnv::CDBEnv() : dbenv(DB_CXX_NO_EXCEPTIONS)\n@@ -68,7 +73,9 @@ void CDBEnv::Close()\n bool CDBEnv::Open(const boost::filesystem::path& pathIn)\n {\n     if (fDbEnvInit)\n+    {\n         return true;\n+    }\n \n     boost::this_thread::interruption_point();\n \n@@ -79,8 +86,11 @@ bool CDBEnv::Open(const boost::filesystem::path& pathIn)\n     LogPrintf(\"CDBEnv::Open : LogDir=%s ErrorFile=%s\\n\", pathLogDir.string(), pathErrorFile.string());\n \n     unsigned int nEnvFlags = 0;\n+\n     if (GetBoolArg(\"-privdb\", true))\n+    {\n         nEnvFlags |= DB_PRIVATE;\n+    }\n \n     dbenv.set_lg_dir(pathLogDir.string().c_str());\n     dbenv.set_cachesize(0, 0x100000, 1); // 1 MiB should be enough for just the wallet\n@@ -93,17 +103,20 @@ bool CDBEnv::Open(const boost::filesystem::path& pathIn)\n     dbenv.set_flags(DB_TXN_WRITE_NOSYNC, 1);\n     dbenv.log_set_config(DB_LOG_AUTO_REMOVE, 1);\n     int ret = dbenv.open(path.string().c_str(),\n-                     DB_CREATE     |\n-                     DB_INIT_LOCK  |\n-                     DB_INIT_LOG   |\n-                     DB_INIT_MPOOL |\n-                     DB_INIT_TXN   |\n-                     DB_THREAD     |\n-                     DB_RECOVER    |\n-                     nEnvFlags,\n-                     S_IRUSR | S_IWUSR);\n+        DB_CREATE |\n+        DB_INIT_LOCK |\n+        DB_INIT_LOG |\n+        DB_INIT_MPOOL |\n+        DB_INIT_TXN |\n+        DB_THREAD |\n+        DB_RECOVER |\n+        nEnvFlags,\n+        S_IRUSR | S_IWUSR);\n+\n     if (ret != 0)\n+    {\n         return error(\"CDBEnv::Open : Error %d opening database environment: %s\\n\", ret, DbEnv::strerror(ret));\n+    }\n \n     fDbEnvInit = true;\n     fMockDb = false;\n@@ -113,74 +126,91 @@ bool CDBEnv::Open(const boost::filesystem::path& pathIn)\n void CDBEnv::MakeMock()\n {\n     if (fDbEnvInit)\n+    {\n         throw runtime_error(\"CDBEnv::MakeMock : Already initialized\");\n+    }\n \n     boost::this_thread::interruption_point();\n \n     LogPrint(\"db\", \"CDBEnv::MakeMock\\n\");\n \n     dbenv.set_cachesize(1, 0, 1);\n-    dbenv.set_lg_bsize(10485760*4);\n+    dbenv.set_lg_bsize(10485760 * 4);\n     dbenv.set_lg_max(10485760);\n     dbenv.set_lk_max_locks(10000);\n     dbenv.set_lk_max_objects(10000);\n     dbenv.set_flags(DB_AUTO_COMMIT, 1);\n     dbenv.log_set_config(DB_LOG_IN_MEMORY, 1);\n     int ret = dbenv.open(NULL,\n-                     DB_CREATE     |\n-                     DB_INIT_LOCK  |\n-                     DB_INIT_LOG   |\n-                     DB_INIT_MPOOL |\n-                     DB_INIT_TXN   |\n-                     DB_THREAD     |\n-                     DB_PRIVATE,\n-                     S_IRUSR | S_IWUSR);\n+        DB_CREATE |\n+        DB_INIT_LOCK |\n+        DB_INIT_LOG |\n+        DB_INIT_MPOOL |\n+        DB_INIT_TXN |\n+        DB_THREAD |\n+        DB_PRIVATE,\n+        S_IRUSR | S_IWUSR);\n+\n     if (ret > 0)\n+    {\n         throw runtime_error(strprintf(\"CDBEnv::MakeMock : Error %d opening database environment.\", ret));\n+    }\n \n     fDbEnvInit = true;\n     fMockDb = true;\n }\n \n-CDBEnv::VerifyResult CDBEnv::Verify(std::string strFile, bool (*recoverFunc)(CDBEnv& dbenv, std::string strFile))\n+CDBEnv::VerifyResult CDBEnv::Verify(std::string strFile, bool (* recoverFunc)(CDBEnv& dbenv, std::string strFile))\n {\n     LOCK(cs_db);\n     assert(mapFileUseCount.count(strFile) == 0);\n \n     Db db(&dbenv, 0);\n     int result = db.verify(strFile.c_str(), NULL, NULL, 0);\n+\n     if (result == 0)\n+    {\n         return VERIFY_OK;\n+    }\n     else if (recoverFunc == NULL)\n+    {\n         return RECOVER_FAIL;\n+    }\n \n     // Try to recover:\n     bool fRecovered = (*recoverFunc)(*this, strFile);\n     return (fRecovered ? RECOVER_OK : RECOVER_FAIL);\n }\n \n bool CDBEnv::Salvage(std::string strFile, bool fAggressive,\n-                     std::vector<CDBEnv::KeyValPair >& vResult)\n+    std::vector<CDBEnv::KeyValPair >& vResult)\n {\n     LOCK(cs_db);\n     assert(mapFileUseCount.count(strFile) == 0);\n \n     u_int32_t flags = DB_SALVAGE;\n-    if (fAggressive) flags |= DB_AGGRESSIVE;\n+\n+    if (fAggressive)\n+    {\n+        flags |= DB_AGGRESSIVE;\n+    }\n \n     stringstream strDump;\n \n     Db db(&dbenv, 0);\n     int result = db.verify(strFile.c_str(), NULL, &strDump, flags);\n+\n     if (result == DB_VERIFY_BAD)\n     {\n         LogPrintf(\"CDBEnv::Salvage : Database salvage found errors, all data may not be recoverable.\\n\");\n+\n         if (!fAggressive)\n         {\n             LogPrintf(\"CDBEnv::Salvage : Rerun with aggressive mode to ignore errors and continue.\\n\");\n             return false;\n         }\n     }\n+\n     if (result != 0 && result != DB_VERIFY_BAD)\n     {\n         LogPrintf(\"CDBEnv::Salvage : Database salvage failed with result %d.\\n\", result);\n@@ -196,73 +226,94 @@ bool CDBEnv::Salvage(std::string strFile, bool fAggressive,\n     // DATA=END\n \n     string strLine;\n+\n     while (!strDump.eof() && strLine != \"HEADER=END\")\n-        getline(strDump, strLine); // Skip past header\n+        getline(strDump, strLine);  // Skip past header\n \n     std::string keyHex, valueHex;\n+\n     while (!strDump.eof() && keyHex != \"DATA=END\")\n     {\n         getline(strDump, keyHex);\n+\n         if (keyHex != \"DATA_END\")\n         {\n             getline(strDump, valueHex);\n-            vResult.push_back(make_pair(ParseHex(keyHex),ParseHex(valueHex)));\n+            vResult.push_back(make_pair(ParseHex(keyHex), ParseHex(valueHex)));\n         }\n     }\n \n     return (result == 0);\n }\n \n-\n void CDBEnv::CheckpointLSN(std::string strFile)\n {\n     dbenv.txn_checkpoint(0, 0, 0);\n+\n     if (fMockDb)\n+    {\n         return;\n+    }\n+\n     dbenv.lsn_reset(strFile.c_str(), 0);\n }\n \n-\n-CDB::CDB(const char *pszFile, const char* pszMode) :\n+CDB::CDB(const char* pszFile, const char* pszMode) :\n     pdb(NULL), activeTxn(NULL)\n {\n     int ret;\n+\n     fReadOnly = (!strchr(pszMode, '+') && !strchr(pszMode, 'w'));\n+\n     if (pszFile == NULL)\n+    {\n         return;\n+    }\n \n     bool fCreate = strchr(pszMode, 'c');\n     unsigned int nFlags = DB_THREAD;\n+\n     if (fCreate)\n+    {\n         nFlags |= DB_CREATE;\n+    }\n \n     {\n         LOCK(bitdb.cs_db);\n+\n         if (!bitdb.Open(GetDataDir()))\n+        {\n             throw runtime_error(\"CDB : Failed to open database environment.\");\n+        }\n \n         strFile = pszFile;\n         ++bitdb.mapFileUseCount[strFile];\n         pdb = bitdb.mapDb[strFile];\n+\n         if (pdb == NULL)\n         {\n             pdb = new Db(&bitdb.dbenv, 0);\n \n             bool fMockDb = bitdb.IsMock();\n+\n             if (fMockDb)\n             {\n-                DbMpoolFile*mpf = pdb->get_mpf();\n+                DbMpoolFile* mpf = pdb->get_mpf();\n                 ret = mpf->set_flags(DB_MPOOL_NOFILE, 1);\n+\n                 if (ret != 0)\n-                    throw runtime_error(strprintf(\"CDB : Failed to configure for no temp file backing for database %s\", pszFile));\n+                {\n+                    throw runtime_error(strprintf(\"CDB : Failed to configure for no temp file backing for database %s\",\n+                            pszFile));\n+                }\n             }\n \n             ret = pdb->open(NULL,      // Txn pointer\n-                            fMockDb ? NULL : pszFile,   // Filename\n-                            fMockDb ? pszFile : \"main\", // Logical db name\n-                            DB_BTREE,  // Database type\n-                            nFlags,    // Flags\n-                            0);\n+                fMockDb ? NULL : pszFile,               // Filename\n+                fMockDb ? pszFile : \"main\",             // Logical db name\n+                DB_BTREE,              // Database type\n+                nFlags,                // Flags\n+                0);\n \n             if (ret != 0)\n             {\n@@ -289,22 +340,33 @@ CDB::CDB(const char *pszFile, const char* pszMode) :\n void CDB::Flush()\n {\n     if (activeTxn)\n+    {\n         return;\n+    }\n \n     // Flush database activity from memory pool to disk log\n     unsigned int nMinutes = 0;\n+\n     if (fReadOnly)\n+    {\n         nMinutes = 1;\n+    }\n \n-    bitdb.dbenv.txn_checkpoint(nMinutes ? GetArg(\"-dblogsize\", 100)*1024 : 0, nMinutes, 0);\n+    bitdb.dbenv.txn_checkpoint(nMinutes ? GetArg(\"-dblogsize\", 100) * 1024 : 0, nMinutes, 0);\n }\n \n void CDB::Close()\n {\n     if (!pdb)\n+    {\n         return;\n+    }\n+\n     if (activeTxn)\n+    {\n         activeTxn->abort();\n+    }\n+\n     activeTxn = NULL;\n     pdb = NULL;\n \n@@ -320,6 +382,7 @@ void CDBEnv::CloseDb(const string& strFile)\n {\n     {\n         LOCK(cs_db);\n+\n         if (mapDb[strFile] != NULL)\n         {\n             // Close the database handle\n@@ -346,6 +409,7 @@ bool CDB::Rewrite(const string& strFile, const char* pszSkip)\n     {\n         {\n             LOCK(bitdb.cs_db);\n+\n             if (!bitdb.mapFileUseCount.count(strFile) || bitdb.mapFileUseCount[strFile] == 0)\n             {\n                 // Flush log data to the dat file\n@@ -356,29 +420,34 @@ bool CDB::Rewrite(const string& strFile, const char* pszSkip)\n                 bool fSuccess = true;\n                 LogPrintf(\"CDB::Rewrite : Rewriting %s...\\n\", strFile);\n                 string strFileRes = strFile + \".rewrite\";\n-                { // surround usage of db with extra {}\n+                {\n+                    // surround usage of db with extra {}\n                     CDB db(strFile.c_str(), \"r\");\n                     Db* pdbCopy = new Db(&bitdb.dbenv, 0);\n \n                     int ret = pdbCopy->open(NULL,                 // Txn pointer\n-                                            strFileRes.c_str(),   // Filename\n-                                            \"main\",    // Logical db name\n-                                            DB_BTREE,  // Database type\n-                                            DB_CREATE,    // Flags\n-                                            0);\n+                        strFileRes.c_str(),                       // Filename\n+                        \"main\",                        // Logical db name\n+                        DB_BTREE,                      // Database type\n+                        DB_CREATE,                        // Flags\n+                        0);\n+\n                     if (ret > 0)\n                     {\n                         LogPrintf(\"CDB::Rewrite : Can't create database file %s\\n\", strFileRes);\n                         fSuccess = false;\n                     }\n \n                     Dbc* pcursor = db.GetCursor();\n+\n                     if (pcursor)\n+                    {\n                         while (fSuccess)\n                         {\n                             CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n                             CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n                             int ret = db.ReadAtCursor(pcursor, ssKey, ssValue, DB_NEXT);\n+\n                             if (ret == DB_NOTFOUND)\n                             {\n                                 pcursor->close();\n@@ -390,90 +459,138 @@ bool CDB::Rewrite(const string& strFile, const char* pszSkip)\n                                 fSuccess = false;\n                                 break;\n                             }\n+\n                             if (pszSkip &&\n                                 strncmp(&ssKey[0], pszSkip, std::min(ssKey.size(), strlen(pszSkip))) == 0)\n+                            {\n                                 continue;\n+                            }\n+\n                             if (strncmp(&ssKey[0], \"\\x07version\", 8) == 0)\n                             {\n                                 // Update version:\n                                 ssValue.clear();\n                                 ssValue << CLIENT_VERSION;\n                             }\n+\n                             Dbt datKey(&ssKey[0], ssKey.size());\n                             Dbt datValue(&ssValue[0], ssValue.size());\n                             int ret2 = pdbCopy->put(NULL, &datKey, &datValue, DB_NOOVERWRITE);\n+\n                             if (ret2 > 0)\n+                            {\n                                 fSuccess = false;\n+                            }\n                         }\n+                    }\n+\n                     if (fSuccess)\n                     {\n                         db.Close();\n                         bitdb.CloseDb(strFile);\n+\n                         if (pdbCopy->close(0))\n+                        {\n                             fSuccess = false;\n+                        }\n+\n                         delete pdbCopy;\n                     }\n                 }\n+\n                 if (fSuccess)\n                 {\n                     Db dbA(&bitdb.dbenv, 0);\n+\n                     if (dbA.remove(strFile.c_str(), NULL, 0))\n+                    {\n                         fSuccess = false;\n+                    }\n+\n                     Db dbB(&bitdb.dbenv, 0);\n+\n                     if (dbB.rename(strFileRes.c_str(), NULL, strFile.c_str(), 0))\n+                    {\n                         fSuccess = false;\n+                    }\n                 }\n+\n                 if (!fSuccess)\n+                {\n                     LogPrintf(\"CDB::Rewrite : Failed to rewrite database file %s\\n\", strFileRes);\n+                }\n+\n                 return fSuccess;\n             }\n         }\n         MilliSleep(100);\n     }\n+\n     return false;\n }\n \n-\n void CDBEnv::Flush(bool fShutdown)\n {\n     int64_t nStart = GetTimeMillis();\n+\n     // Flush log data to the actual data file on all files that are not in use\n-    LogPrint(\"db\", \"CDBEnv::Flush : Flush(%s)%s\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" database not started\");\n+    LogPrint(\"db\", \"CDBEnv::Flush : Flush(%s)%s\\n\", fShutdown ? \"true\" : \"false\",\n+        fDbEnvInit ? \"\" : \" database not started\");\n+\n     if (!fDbEnvInit)\n+    {\n         return;\n+    }\n+\n     {\n         LOCK(cs_db);\n         map<string, int>::iterator mi = mapFileUseCount.begin();\n+\n         while (mi != mapFileUseCount.end())\n         {\n             string strFile = (*mi).first;\n             int nRefCount = (*mi).second;\n             LogPrint(\"db\", \"CDBEnv::Flush : Flushing %s (refcount = %d)...\\n\", strFile, nRefCount);\n+\n             if (nRefCount == 0)\n             {\n                 // Move log data to the dat file\n                 CloseDb(strFile);\n                 LogPrint(\"db\", \"CDBEnv::Flush : %s checkpoint\\n\", strFile);\n                 dbenv.txn_checkpoint(0, 0, 0);\n                 LogPrint(\"db\", \"CDBEnv::Flush : %s detach\\n\", strFile);\n+\n                 if (!fMockDb)\n+                {\n                     dbenv.lsn_reset(strFile.c_str(), 0);\n+                }\n+\n                 LogPrint(\"db\", \"CDBEnv::Flush : %s closed\\n\", strFile);\n                 mapFileUseCount.erase(mi++);\n             }\n             else\n+            {\n                 mi++;\n+            }\n         }\n-        LogPrint(\"db\", \"CDBEnv::Flush : Flush(%s)%s took %15dms\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" database not started\", GetTimeMillis() - nStart);\n+\n+        LogPrint(\"db\", \"CDBEnv::Flush : Flush(%s)%s took %15dms\\n\", fShutdown ? \"true\" : \"false\",\n+            fDbEnvInit ? \"\" : \" database not started\",\n+            GetTimeMillis() - nStart);\n+\n         if (fShutdown)\n         {\n-            char** listp;\n+            char* * listp;\n+\n             if (mapFileUseCount.empty())\n             {\n                 dbenv.log_archive(&listp, DB_ARCH_REMOVE);\n                 Close();\n+\n                 if (!fMockDb)\n+                {\n                     boost::filesystem::remove_all(path / \"database\");\n+                }\n             }\n         }\n     }"
      },
      {
        "sha": "243fca80514ff5916240355d377b81d29717313b",
        "filename": "src/db.h",
        "status": "modified",
        "additions": 76,
        "deletions": 14,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -25,7 +25,6 @@ extern unsigned int nWalletDBUpdated;\n \n void ThreadFlushWalletDB(const std::string& strWalletFile);\n \n-\n class CDBEnv\n {\n private:\n@@ -44,16 +43,22 @@ class CDBEnv\n     CDBEnv();\n     ~CDBEnv();\n     void MakeMock();\n-    bool IsMock() { return fMockDb; }\n+    bool IsMock()\n+    {\n+        return fMockDb;\n+    }\n \n     /*\n      * Verify that database file strFile is OK. If it is not,\n      * call the callback to try to recover.\n      * This must be called BEFORE strFile is opened.\n      * Returns true if strFile is OK.\n      */\n-    enum VerifyResult { VERIFY_OK, RECOVER_OK, RECOVER_FAIL };\n-    VerifyResult Verify(std::string strFile, bool (*recoverFunc)(CDBEnv& dbenv, std::string strFile));\n+    enum VerifyResult\n+    {\n+        VERIFY_OK, RECOVER_OK, RECOVER_FAIL\n+    };\n+    VerifyResult Verify(std::string strFile, bool (* recoverFunc)(CDBEnv& dbenv, std::string strFile));\n     /*\n      * Salvage data from a file that Verify says is bad.\n      * fAggressive sets the DB_AGGRESSIVE flag (see berkeley DB->verify() method documentation).\n@@ -72,30 +77,37 @@ class CDBEnv\n     void CloseDb(const std::string& strFile);\n     bool RemoveDb(const std::string& strFile);\n \n-    DbTxn *TxnBegin(int flags=DB_TXN_WRITE_NOSYNC)\n+    DbTxn* TxnBegin(int flags = DB_TXN_WRITE_NOSYNC)\n     {\n         DbTxn* ptxn = NULL;\n         int ret = dbenv.txn_begin(NULL, &ptxn, flags);\n+\n         if (!ptxn || ret != 0)\n+        {\n             return NULL;\n+        }\n+\n         return ptxn;\n     }\n };\n \n extern CDBEnv bitdb;\n \n-\n /** RAII class that provides access to a Berkeley database */\n class CDB\n {\n protected:\n     Db* pdb;\n     std::string strFile;\n-    DbTxn *activeTxn;\n+    DbTxn* activeTxn;\n     bool fReadOnly;\n \n-    explicit CDB(const char* pszFile, const char* pszMode=\"r+\");\n-    ~CDB() { Close(); }\n+    explicit CDB(const char* pszFile, const char* pszMode = \"r+\");\n+    ~CDB()\n+    {\n+        Close();\n+    }\n+\n public:\n     void Flush();\n     void Close();\n@@ -108,7 +120,9 @@ class CDB\n     bool Read(const K& key, T& value)\n     {\n         if (!pdb)\n+        {\n             return false;\n+        }\n \n         // Key\n         CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n@@ -121,15 +135,21 @@ class CDB\n         datValue.set_flags(DB_DBT_MALLOC);\n         int ret = pdb->get(activeTxn, &datKey, &datValue, 0);\n         memset(datKey.get_data(), 0, datKey.get_size());\n+\n         if (datValue.get_data() == NULL)\n+        {\n             return false;\n+        }\n \n         // Unserialize value\n-        try {\n-            CDataStream ssValue((char*)datValue.get_data(), (char*)datValue.get_data() + datValue.get_size(), SER_DISK, CLIENT_VERSION);\n+        try\n+        {\n+            CDataStream ssValue((char*)datValue.get_data(),\n+                (char*)datValue.get_data() + datValue.get_size(), SER_DISK, CLIENT_VERSION);\n             ssValue >> value;\n         }\n-        catch (std::exception &e) {\n+        catch (std::exception &e)\n+        {\n             return false;\n         }\n \n@@ -140,12 +160,17 @@ class CDB\n     }\n \n     template<typename K, typename T>\n-    bool Write(const K& key, const T& value, bool fOverwrite=true)\n+    bool Write(const K& key, const T& value, bool fOverwrite = true)\n     {\n         if (!pdb)\n+        {\n             return false;\n+        }\n+\n         if (fReadOnly)\n+        {\n             assert(!\"Write called on database in read-only mode\");\n+        }\n \n         // Key\n         CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n@@ -172,9 +197,14 @@ class CDB\n     bool Erase(const K& key)\n     {\n         if (!pdb)\n+        {\n             return false;\n+        }\n+\n         if (fReadOnly)\n+        {\n             assert(!\"Erase called on database in read-only mode\");\n+        }\n \n         // Key\n         CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n@@ -194,7 +224,9 @@ class CDB\n     bool Exists(const K& key)\n     {\n         if (!pdb)\n+        {\n             return false;\n+        }\n \n         // Key\n         CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n@@ -213,36 +245,52 @@ class CDB\n     Dbc* GetCursor()\n     {\n         if (!pdb)\n+        {\n             return NULL;\n+        }\n+\n         Dbc* pcursor = NULL;\n         int ret = pdb->cursor(NULL, &pcursor, 0);\n+\n         if (ret != 0)\n+        {\n             return NULL;\n+        }\n+\n         return pcursor;\n     }\n \n-    int ReadAtCursor(Dbc* pcursor, CDataStream& ssKey, CDataStream& ssValue, unsigned int fFlags=DB_NEXT)\n+    int ReadAtCursor(Dbc* pcursor, CDataStream& ssKey, CDataStream& ssValue, unsigned int fFlags = DB_NEXT)\n     {\n         // Read at cursor\n         Dbt datKey;\n+\n         if (fFlags == DB_SET || fFlags == DB_SET_RANGE || fFlags == DB_GET_BOTH || fFlags == DB_GET_BOTH_RANGE)\n         {\n             datKey.set_data(&ssKey[0]);\n             datKey.set_size(ssKey.size());\n         }\n+\n         Dbt datValue;\n+\n         if (fFlags == DB_GET_BOTH || fFlags == DB_GET_BOTH_RANGE)\n         {\n             datValue.set_data(&ssValue[0]);\n             datValue.set_size(ssValue.size());\n         }\n+\n         datKey.set_flags(DB_DBT_MALLOC);\n         datValue.set_flags(DB_DBT_MALLOC);\n         int ret = pcursor->get(&datKey, &datValue, fFlags);\n+\n         if (ret != 0)\n+        {\n             return ret;\n+        }\n         else if (datKey.get_data() == NULL || datValue.get_data() == NULL)\n+        {\n             return 99999;\n+        }\n \n         // Convert to streams\n         ssKey.SetType(SER_DISK);\n@@ -264,18 +312,28 @@ class CDB\n     bool TxnBegin()\n     {\n         if (!pdb || activeTxn)\n+        {\n             return false;\n+        }\n+\n         DbTxn* ptxn = bitdb.TxnBegin();\n+\n         if (!ptxn)\n+        {\n             return false;\n+        }\n+\n         activeTxn = ptxn;\n         return true;\n     }\n \n     bool TxnCommit()\n     {\n         if (!pdb || !activeTxn)\n+        {\n             return false;\n+        }\n+\n         int ret = activeTxn->commit(0);\n         activeTxn = NULL;\n         return (ret == 0);\n@@ -284,7 +342,10 @@ class CDB\n     bool TxnAbort()\n     {\n         if (!pdb || !activeTxn)\n+        {\n             return false;\n+        }\n+\n         int ret = activeTxn->abort();\n         activeTxn = NULL;\n         return (ret == 0);\n@@ -305,3 +366,4 @@ class CDB\n };\n \n #endif // BITCOIN_DB_H\n+"
      },
      {
        "sha": "9fa49fb443a2bd978c7ef5379666c4d5bc8f2155",
        "filename": "src/hash.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 12,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/hash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/hash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -16,34 +16,42 @@ unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char\n \n     //----------\n     // body\n-    const uint32_t * blocks = (const uint32_t *)(&vDataToHash[0] + nblocks*4);\n+    const uint32_t* blocks = (const uint32_t*)(&vDataToHash[0] + nblocks * 4);\n \n-    for(int i = -nblocks; i; i++)\n+    for (int i = -nblocks; i; i++)\n     {\n         uint32_t k1 = blocks[i];\n \n         k1 *= c1;\n-        k1 = ROTL32(k1,15);\n+        k1 = ROTL32(k1, 15);\n         k1 *= c2;\n \n         h1 ^= k1;\n-        h1 = ROTL32(h1,13); \n-        h1 = h1*5+0xe6546b64;\n+        h1 = ROTL32(h1, 13);\n+        h1 = h1 * 5 + 0xe6546b64;\n     }\n \n     //----------\n     // tail\n-    const uint8_t * tail = (const uint8_t*)(&vDataToHash[0] + nblocks*4);\n+    const uint8_t* tail = (const uint8_t*)(&vDataToHash[0] + nblocks * 4);\n \n     uint32_t k1 = 0;\n \n-    switch(vDataToHash.size() & 3)\n+    switch (vDataToHash.size() & 3)\n     {\n-    case 3: k1 ^= tail[2] << 16;\n-    case 2: k1 ^= tail[1] << 8;\n-    case 1: k1 ^= tail[0];\n-            k1 *= c1; k1 = ROTL32(k1,15); k1 *= c2; h1 ^= k1;\n-    };\n+    case 3:\n+        k1 ^= tail[2] << 16;\n+    case 2:\n+        k1 ^= tail[1] << 8;\n+    case 1:\n+        k1 ^= tail[0];\n+        k1 *= c1;\n+        k1 = ROTL32(k1, 15);\n+        k1 *= c2;\n+        h1 ^= k1;\n+    }\n+\n+    ;\n \n     //----------\n     // finalization\n@@ -56,3 +64,4 @@ unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char\n \n     return h1;\n }\n+"
      },
      {
        "sha": "0b60e0d5d07ad27852c9e4469ef295ffc35ac03b",
        "filename": "src/hash.h",
        "status": "modified",
        "additions": 51,
        "deletions": 25,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -15,48 +15,58 @@\n #include <vector>\n \n /** A hasher class for Bitcoin's 256-bit hash (double SHA-256). */\n-class CHash256 {\n+class CHash256\n+{\n private:\n     CSHA256 sha;\n public:\n     static const size_t OUTPUT_SIZE = CSHA256::OUTPUT_SIZE;\n \n-    void Finalize(unsigned char hash[OUTPUT_SIZE]) {\n+    void Finalize(unsigned char hash[OUTPUT_SIZE])\n+    {\n         unsigned char buf[sha.OUTPUT_SIZE];\n+\n         sha.Finalize(buf);\n         sha.Reset().Write(buf, sha.OUTPUT_SIZE).Finalize(hash);\n     }\n \n-    CHash256& Write(const unsigned char *data, size_t len) {\n+    CHash256& Write(const unsigned char* data, size_t len)\n+    {\n         sha.Write(data, len);\n         return *this;\n     }\n \n-    CHash256& Reset() {\n+    CHash256& Reset()\n+    {\n         sha.Reset();\n         return *this;\n     }\n };\n \n /** A hasher class for Bitcoin's 160-bit hash (SHA-256 + RIPEMD-160). */\n-class CHash160 {\n+class CHash160\n+{\n private:\n     CSHA256 sha;\n public:\n     static const size_t OUTPUT_SIZE = CRIPEMD160::OUTPUT_SIZE;\n \n-    void Finalize(unsigned char hash[OUTPUT_SIZE]) {\n+    void Finalize(unsigned char hash[OUTPUT_SIZE])\n+    {\n         unsigned char buf[sha.OUTPUT_SIZE];\n+\n         sha.Finalize(buf);\n         CRIPEMD160().Write(buf, sha.OUTPUT_SIZE).Finalize(hash);\n     }\n \n-    CHash160& Write(const unsigned char *data, size_t len) {\n+    CHash160& Write(const unsigned char* data, size_t len)\n+    {\n         sha.Write(data, len);\n         return *this;\n     }\n \n-    CHash160& Reset() {\n+    CHash160& Reset()\n+    {\n         sha.Reset();\n         return *this;\n     }\n@@ -68,34 +78,41 @@ inline uint256 Hash(const T1 pbegin, const T1 pend)\n {\n     static const unsigned char pblank[1] = {};\n     uint256 result;\n+\n     CHash256().Write(pbegin == pend ? pblank : (const unsigned char*)&pbegin[0], (pend - pbegin) * sizeof(pbegin[0]))\n-              .Finalize((unsigned char*)&result);\n+    .Finalize((unsigned char*)&result);\n     return result;\n }\n \n /** Compute the 256-bit hash of the concatenation of two objects. */\n template<typename T1, typename T2>\n inline uint256 Hash(const T1 p1begin, const T1 p1end,\n-                    const T2 p2begin, const T2 p2end) {\n+    const T2 p2begin, const T2 p2end)\n+{\n     static const unsigned char pblank[1] = {};\n     uint256 result;\n-    CHash256().Write(p1begin == p1end ? pblank : (const unsigned char*)&p1begin[0], (p1end - p1begin) * sizeof(p1begin[0]))\n-              .Write(p2begin == p2end ? pblank : (const unsigned char*)&p2begin[0], (p2end - p2begin) * sizeof(p2begin[0]))\n-              .Finalize((unsigned char*)&result);\n+\n+    CHash256().Write(p1begin == p1end ? pblank : (const unsigned char*)&p1begin[0],\n+        (p1end - p1begin) * sizeof(p1begin[0]))\n+    .Write(p2begin == p2end ? pblank : (const unsigned char*)&p2begin[0], (p2end - p2begin) * sizeof(p2begin[0]))\n+    .Finalize((unsigned char*)&result);\n     return result;\n }\n \n /** Compute the 256-bit hash of the concatenation of three objects. */\n template<typename T1, typename T2, typename T3>\n inline uint256 Hash(const T1 p1begin, const T1 p1end,\n-                    const T2 p2begin, const T2 p2end,\n-                    const T3 p3begin, const T3 p3end) {\n+    const T2 p2begin, const T2 p2end,\n+    const T3 p3begin, const T3 p3end)\n+{\n     static const unsigned char pblank[1] = {};\n     uint256 result;\n-    CHash256().Write(p1begin == p1end ? pblank : (const unsigned char*)&p1begin[0], (p1end - p1begin) * sizeof(p1begin[0]))\n-              .Write(p2begin == p2end ? pblank : (const unsigned char*)&p2begin[0], (p2end - p2begin) * sizeof(p2begin[0]))\n-              .Write(p3begin == p3end ? pblank : (const unsigned char*)&p3begin[0], (p3end - p3begin) * sizeof(p3begin[0]))\n-              .Finalize((unsigned char*)&result);\n+\n+    CHash256().Write(p1begin == p1end ? pblank : (const unsigned char*)&p1begin[0],\n+        (p1end - p1begin) * sizeof(p1begin[0]))\n+    .Write(p2begin == p2end ? pblank : (const unsigned char*)&p2begin[0], (p2end - p2begin) * sizeof(p2begin[0]))\n+    .Write(p3begin == p3end ? pblank : (const unsigned char*)&p3begin[0], (p3end - p3begin) * sizeof(p3begin[0]))\n+    .Finalize((unsigned char*)&result);\n     return result;\n }\n \n@@ -105,8 +122,9 @@ inline uint160 Hash160(const T1 pbegin, const T1 pend)\n {\n     static unsigned char pblank[1] = {};\n     uint160 result;\n+\n     CHash160().Write(pbegin == pend ? pblank : (const unsigned char*)&pbegin[0], (pend - pbegin) * sizeof(pbegin[0]))\n-              .Finalize((unsigned char*)&result);\n+    .Finalize((unsigned char*)&result);\n     return result;\n }\n \n@@ -126,22 +144,28 @@ class CHashWriter\n     int nType;\n     int nVersion;\n \n-    CHashWriter(int nTypeIn, int nVersionIn) : nType(nTypeIn), nVersion(nVersionIn) {}\n+    CHashWriter(int nTypeIn, int nVersionIn) : nType(nTypeIn), nVersion(nVersionIn)\n+    {\n+    }\n \n-    CHashWriter& write(const char *pch, size_t size) {\n+    CHashWriter& write(const char* pch, size_t size)\n+    {\n         ctx.Write((const unsigned char*)pch, size);\n         return (*this);\n     }\n \n     // invalidates the object\n-    uint256 GetHash() {\n+    uint256 GetHash()\n+    {\n         uint256 result;\n+\n         ctx.Finalize((unsigned char*)&result);\n         return result;\n     }\n \n     template<typename T>\n-    CHashWriter& operator<<(const T& obj) {\n+    CHashWriter& operator<<(const T& obj)\n+    {\n         // Serialize to this stream\n         ::Serialize(*this, obj, nType, nVersion);\n         return (*this);\n@@ -150,13 +174,15 @@ class CHashWriter\n \n /** Compute the 256-bit hash of an object's serialization. */\n template<typename T>\n-uint256 SerializeHash(const T& obj, int nType=SER_GETHASH, int nVersion=PROTOCOL_VERSION)\n+uint256 SerializeHash(const T& obj, int nType = SER_GETHASH, int nVersion = PROTOCOL_VERSION)\n {\n     CHashWriter ss(nType, nVersion);\n+\n     ss << obj;\n     return ss.GetHash();\n }\n \n unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char>& vDataToHash);\n \n #endif // BITCOIN_HASH_H\n+"
      },
      {
        "sha": "7f81137d44a6d04e6d529fc0818725298423dd18",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 657,
        "deletions": 162,
        "changes": 819,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -58,14 +58,15 @@ CWallet* pwalletMain;\n #endif\n \n // Used to pass flags to the Bind() function\n-enum BindFlags {\n+enum BindFlags\n+{\n     BF_NONE         = 0,\n     BF_EXPLICIT     = (1U << 0),\n     BF_REPORT_ERROR = (1U << 1),\n     BF_WHITELIST    = (1U << 2),\n };\n \n-static const char* FEE_ESTIMATES_FILENAME=\"fee_estimates.dat\";\n+static const char* FEE_ESTIMATES_FILENAME = \"fee_estimates.dat\";\n CClientUIInterface uiInterface;\n \n //////////////////////////////////////////////////////////////////////////////\n@@ -104,27 +105,35 @@ void StartShutdown()\n {\n     fRequestShutdown = true;\n }\n+\n bool ShutdownRequested()\n {\n     return fRequestShutdown;\n }\n \n-static CCoinsViewDB *pcoinsdbview;\n+static CCoinsViewDB* pcoinsdbview;\n \n void Shutdown()\n {\n     LogPrintf(\"%s: In progress...\\n\", __func__);\n     static CCriticalSection cs_Shutdown;\n     TRY_LOCK(cs_Shutdown, lockShutdown);\n+\n     if (!lockShutdown)\n+    {\n         return;\n+    }\n \n     RenameThread(\"bitcoin-shutoff\");\n     mempool.AddTransactionsUpdated(1);\n     StopRPCThreads();\n #ifdef ENABLE_WALLET\n+\n     if (pwalletMain)\n+    {\n         bitdb.Flush(false);\n+    }\n+\n     GenerateBitcoins(false, NULL, 0);\n #endif\n     StopNode();\n@@ -133,22 +142,38 @@ void Shutdown()\n     {\n         boost::filesystem::path est_path = GetDataDir() / FEE_ESTIMATES_FILENAME;\n         CAutoFile est_fileout(fopen(est_path.string().c_str(), \"wb\"), SER_DISK, CLIENT_VERSION);\n+\n         if (est_fileout)\n+        {\n             mempool.WriteFeeEstimates(est_fileout);\n+        }\n         else\n+        {\n             LogPrintf(\"%s: Failed to write fee estimates to %s\\n\", __func__, est_path.string());\n+        }\n     }\n \n     {\n         LOCK(cs_main);\n #ifdef ENABLE_WALLET\n+\n         if (pwalletMain)\n+        {\n             pwalletMain->SetBestChain(chainActive.GetLocator());\n+        }\n+\n #endif\n+\n         if (pblocktree)\n+        {\n             pblocktree->Flush();\n+        }\n+\n         if (pcoinsTip)\n+        {\n             pcoinsTip->Flush();\n+        }\n+\n         delete pcoinsTip;\n         pcoinsTip = NULL;\n         delete pcoinsdbview;\n@@ -157,14 +182,22 @@ void Shutdown()\n         pblocktree = NULL;\n     }\n #ifdef ENABLE_WALLET\n+\n     if (pwalletMain)\n+    {\n         bitdb.Flush(true);\n+    }\n+\n #endif\n     boost::filesystem::remove(GetPidFile());\n     UnregisterAllWallets();\n #ifdef ENABLE_WALLET\n+\n     if (pwalletMain)\n+    {\n         delete pwalletMain;\n+    }\n+\n #endif\n     LogPrintf(\"%s: done\\n\", __func__);\n }\n@@ -194,166 +227,272 @@ bool static InitWarning(const std::string &str)\n     return true;\n }\n \n-bool static Bind(const CService &addr, unsigned int flags) {\n+bool static Bind(const CService &addr, unsigned int flags)\n+{\n     if (!(flags & BF_EXPLICIT) && IsLimited(addr))\n+    {\n         return false;\n+    }\n+\n     std::string strError;\n-    if (!BindListenPort(addr, strError, flags & BF_WHITELIST)) {\n+\n+    if (!BindListenPort(addr, strError, flags & BF_WHITELIST))\n+    {\n         if (flags & BF_REPORT_ERROR)\n+        {\n             return InitError(strError);\n+        }\n+\n         return false;\n     }\n+\n     return true;\n }\n \n std::string HelpMessage(HelpMessageMode mode)\n {\n     // When adding new options to the categories, please keep and ensure alphabetical ordering.\n     string strUsage = _(\"Options:\") + \"\\n\";\n+\n     strUsage += \"  -?                     \" + _(\"This help message\") + \"\\n\";\n-    strUsage += \"  -alertnotify=<cmd>     \" + _(\"Execute command when a relevant alert is received or we see a really long fork (%s in cmd is replaced by message)\") + \"\\n\";\n-    strUsage += \"  -blocknotify=<cmd>     \" + _(\"Execute command when the best block changes (%s in cmd is replaced by block hash)\") + \"\\n\";\n+    strUsage += \"  -alertnotify=<cmd>     \" + _(\n+        \"Execute command when a relevant alert is received or we see a really long fork (%s in cmd is replaced by message)\")\n+        + \"\\n\";\n+    strUsage += \"  -blocknotify=<cmd>     \" + _(\n+        \"Execute command when the best block changes (%s in cmd is replaced by block hash)\") + \"\\n\";\n     strUsage += \"  -checkblocks=<n>       \" + _(\"How many blocks to check at startup (default: 288, 0 = all)\") + \"\\n\";\n-    strUsage += \"  -checklevel=<n>        \" + _(\"How thorough the block verification of -checkblocks is (0-4, default: 3)\") + \"\\n\";\n+    strUsage += \"  -checklevel=<n>        \" + _(\n+        \"How thorough the block verification of -checkblocks is (0-4, default: 3)\") + \"\\n\";\n     strUsage += \"  -conf=<file>           \" + _(\"Specify configuration file (default: bitcoin.conf)\") + \"\\n\";\n+\n     if (mode == HMM_BITCOIND)\n     {\n #if !defined(WIN32)\n         strUsage += \"  -daemon                \" + _(\"Run in the background as a daemon and accept commands\") + \"\\n\";\n #endif\n     }\n+\n     strUsage += \"  -datadir=<dir>         \" + _(\"Specify data directory\") + \"\\n\";\n-    strUsage += \"  -dbcache=<n>           \" + strprintf(_(\"Set database cache size in megabytes (%d to %d, default: %d)\"), nMinDbCache, nMaxDbCache, nDefaultDbCache) + \"\\n\";\n-    strUsage += \"  -loadblock=<file>      \" + _(\"Imports blocks from external blk000??.dat file\") + \" \" + _(\"on startup\") + \"\\n\";\n-    strUsage += \"  -maxorphanblocks=<n>   \" + strprintf(_(\"Keep at most <n> unconnectable blocks in memory (default: %u)\"), DEFAULT_MAX_ORPHAN_BLOCKS) + \"\\n\";\n-    strUsage += \"  -par=<n>               \" + strprintf(_(\"Set the number of script verification threads (%u to %d, 0 = auto, <0 = leave that many cores free, default: %d)\"), -(int)boost::thread::hardware_concurrency(), MAX_SCRIPTCHECK_THREADS, DEFAULT_SCRIPTCHECK_THREADS) + \"\\n\";\n+    strUsage += \"  -dbcache=<n>           \" +\n+        strprintf(_(\n+            \"Set database cache size in megabytes (%d to %d, default: %d)\"), nMinDbCache, nMaxDbCache,\n+        nDefaultDbCache) + \"\\n\";\n+    strUsage += \"  -loadblock=<file>      \" + _(\"Imports blocks from external blk000??.dat file\") + \" \" + _(\n+        \"on startup\") + \"\\n\";\n+    strUsage += \"  -maxorphanblocks=<n>   \" +\n+        strprintf(_(\"Keep at most <n> unconnectable blocks in memory (default: %u)\"), DEFAULT_MAX_ORPHAN_BLOCKS) + \"\\n\";\n+    strUsage += \"  -par=<n>               \" +\n+        strprintf(_(\n+            \"Set the number of script verification threads (%u to %d, 0 = auto, <0 = leave that many cores free, default: %d)\"),\n+        -(int)boost::thread::hardware_concurrency(), MAX_SCRIPTCHECK_THREADS, DEFAULT_SCRIPTCHECK_THREADS) + \"\\n\";\n     strUsage += \"  -pid=<file>            \" + _(\"Specify pid file (default: bitcoind.pid)\") + \"\\n\";\n-    strUsage += \"  -reindex               \" + _(\"Rebuild block chain index from current blk000??.dat files\") + \" \" + _(\"on startup\") + \"\\n\";\n+    strUsage += \"  -reindex               \" + _(\"Rebuild block chain index from current blk000??.dat files\") + \" \" + _(\n+        \"on startup\") + \"\\n\";\n #if !defined(WIN32)\n-    strUsage += \"  -sysperms              \" + _(\"Create new files with system default permissions, instead of umask 077 (only effective with disabled wallet functionality)\") + \"\\n\";\n+    strUsage += \"  -sysperms              \" + _(\n+        \"Create new files with system default permissions, instead of umask 077 (only effective with disabled wallet functionality)\")\n+        + \"\\n\";\n #endif\n     strUsage += \"  -txindex               \" + _(\"Maintain a full transaction index (default: 0)\") + \"\\n\";\n \n     strUsage += \"\\n\" + _(\"Connection options:\") + \"\\n\";\n-    strUsage += \"  -addnode=<ip>          \" + _(\"Add a node to connect to and attempt to keep the connection open\") + \"\\n\";\n+    strUsage += \"  -addnode=<ip>          \" + _(\"Add a node to connect to and attempt to keep the connection open\") +\n+        \"\\n\";\n     strUsage += \"  -banscore=<n>          \" + _(\"Threshold for disconnecting misbehaving peers (default: 100)\") + \"\\n\";\n-    strUsage += \"  -bantime=<n>           \" + _(\"Number of seconds to keep misbehaving peers from reconnecting (default: 86400)\") + \"\\n\";\n-    strUsage += \"  -bind=<addr>           \" + _(\"Bind to given address and always listen on it. Use [host]:port notation for IPv6\") + \"\\n\";\n+    strUsage += \"  -bantime=<n>           \" + _(\n+        \"Number of seconds to keep misbehaving peers from reconnecting (default: 86400)\") + \"\\n\";\n+    strUsage += \"  -bind=<addr>           \" + _(\n+        \"Bind to given address and always listen on it. Use [host]:port notation for IPv6\") + \"\\n\";\n     strUsage += \"  -connect=<ip>          \" + _(\"Connect only to the specified node(s)\") + \"\\n\";\n-    strUsage += \"  -discover              \" + _(\"Discover own IP address (default: 1 when listening and no -externalip)\") + \"\\n\";\n-    strUsage += \"  -dns                   \" + _(\"Allow DNS lookups for -addnode, -seednode and -connect\") + \" \" + _(\"(default: 1)\") + \"\\n\";\n-    strUsage += \"  -dnsseed               \" + _(\"Query for peer addresses via DNS lookup, if low on addresses (default: 1 unless -connect)\") + \"\\n\";\n+    strUsage += \"  -discover              \" + _(\n+        \"Discover own IP address (default: 1 when listening and no -externalip)\") + \"\\n\";\n+    strUsage += \"  -dns                   \" + _(\"Allow DNS lookups for -addnode, -seednode and -connect\") + \" \" + _(\n+        \"(default: 1)\") + \"\\n\";\n+    strUsage += \"  -dnsseed               \" + _(\n+        \"Query for peer addresses via DNS lookup, if low on addresses (default: 1 unless -connect)\") + \"\\n\";\n     strUsage += \"  -externalip=<ip>       \" + _(\"Specify your own public address\") + \"\\n\";\n     strUsage += \"  -forcednsseed          \" + _(\"Always query for peer addresses via DNS lookup (default: 0)\") + \"\\n\";\n-    strUsage += \"  -listen                \" + _(\"Accept connections from outside (default: 1 if no -proxy or -connect)\") + \"\\n\";\n+    strUsage += \"  -listen                \" +\n+        _(\"Accept connections from outside (default: 1 if no -proxy or -connect)\") + \"\\n\";\n     strUsage += \"  -maxconnections=<n>    \" + _(\"Maintain at most <n> connections to peers (default: 125)\") + \"\\n\";\n-    strUsage += \"  -maxreceivebuffer=<n>  \" + _(\"Maximum per-connection receive buffer, <n>*1000 bytes (default: 5000)\") + \"\\n\";\n-    strUsage += \"  -maxsendbuffer=<n>     \" + _(\"Maximum per-connection send buffer, <n>*1000 bytes (default: 1000)\") + \"\\n\";\n-    strUsage += \"  -onion=<ip:port>       \" + _(\"Use separate SOCKS5 proxy to reach peers via Tor hidden services (default: -proxy)\") + \"\\n\";\n+    strUsage += \"  -maxreceivebuffer=<n>  \" +\n+        _(\"Maximum per-connection receive buffer, <n>*1000 bytes (default: 5000)\") + \"\\n\";\n+    strUsage += \"  -maxsendbuffer=<n>     \" + _(\"Maximum per-connection send buffer, <n>*1000 bytes (default: 1000)\") +\n+        \"\\n\";\n+    strUsage += \"  -onion=<ip:port>       \" + _(\n+        \"Use separate SOCKS5 proxy to reach peers via Tor hidden services (default: -proxy)\") + \"\\n\";\n     strUsage += \"  -onlynet=<net>         \" + _(\"Only connect to nodes in network <net> (ipv4, ipv6 or onion)\") + \"\\n\";\n     strUsage += \"  -permitbaremultisig    \" + _(\"Relay non-P2SH multisig (default: 1)\") + \"\\n\";\n-    strUsage += \"  -port=<port>           \" + _(\"Listen for connections on <port> (default: 8333 or testnet: 18333)\") + \"\\n\";\n+    strUsage += \"  -port=<port>           \" + _(\"Listen for connections on <port> (default: 8333 or testnet: 18333)\") +\n+        \"\\n\";\n     strUsage += \"  -proxy=<ip:port>       \" + _(\"Connect through SOCKS5 proxy\") + \"\\n\";\n     strUsage += \"  -seednode=<ip>         \" + _(\"Connect to a node to retrieve peer addresses, and disconnect\") + \"\\n\";\n     strUsage += \"  -timeout=<n>           \" + _(\"Specify connection timeout in milliseconds (default: 5000)\") + \"\\n\";\n #ifdef USE_UPNP\n #if USE_UPNP\n-    strUsage += \"  -upnp                  \" + _(\"Use UPnP to map the listening port (default: 1 when listening)\") + \"\\n\";\n+    strUsage += \"  -upnp                  \" + _(\"Use UPnP to map the listening port (default: 1 when listening)\") +\n+        \"\\n\";\n #else\n     strUsage += \"  -upnp                  \" + _(\"Use UPnP to map the listening port (default: 0)\") + \"\\n\";\n #endif\n #endif\n-    strUsage += \"  -whitebind=<addr>      \" + _(\"Bind to given address and whitelist peers connecting to it. Use [host]:port notation for IPv6\") + \"\\n\";\n-    strUsage += \"  -whitelist=<netmask>   \" + _(\"Whitelist peers connecting from the given netmask or ip. Can be specified multiple times.\") + \"\\n\";\n-    strUsage += \"                         \" + _(\"Whitelisted peers cannot be DoS banned and their transactions are always relayed, even if they are already in the mempool, useful e.g. for a gateway\") + \"\\n\";\n+    strUsage += \"  -whitebind=<addr>      \" + _(\n+        \"Bind to given address and whitelist peers connecting to it. Use [host]:port notation for IPv6\") + \"\\n\";\n+    strUsage += \"  -whitelist=<netmask>   \" + _(\n+        \"Whitelist peers connecting from the given netmask or ip. Can be specified multiple times.\") + \"\\n\";\n+    strUsage += \"                         \" + _(\n+        \"Whitelisted peers cannot be DoS banned and their transactions are always relayed, even if they are already in the mempool, useful e.g. for a gateway\")\n+        + \"\\n\";\n \n #ifdef ENABLE_WALLET\n     strUsage += \"\\n\" + _(\"Wallet options:\") + \"\\n\";\n     strUsage += \"  -disablewallet         \" + _(\"Do not load the wallet and disable wallet RPC calls\") + \"\\n\";\n     strUsage += \"  -keypool=<n>           \" + _(\"Set key pool size to <n> (default: 100)\") + \"\\n\";\n+\n     if (GetBoolArg(\"-help-debug\", false))\n-        strUsage += \"  -mintxfee=<amt>        \" + strprintf(_(\"Fees (in BTC/Kb) smaller than this are considered zero fee for transaction creation (default: %s)\"), FormatMoney(CWallet::minTxFee.GetFeePerK())) + \"\\n\";\n-    strUsage += \"  -paytxfee=<amt>        \" + strprintf(_(\"Fee (in BTC/kB) to add to transactions you send (default: %s)\"), FormatMoney(payTxFee.GetFeePerK())) + \"\\n\";\n-    strUsage += \"  -rescan                \" + _(\"Rescan the block chain for missing wallet transactions\") + \" \" + _(\"on startup\") + \"\\n\";\n-    strUsage += \"  -respendnotify=<cmd>   \" + _(\"Execute command when a network tx respends wallet tx input (%s=respend TxID, %t=wallet TxID)\") + \"\\n\";\n-    strUsage += \"  -salvagewallet         \" + _(\"Attempt to recover private keys from a corrupt wallet.dat\") + \" \" + _(\"on startup\") + \"\\n\";\n-    strUsage += \"  -spendzeroconfchange   \" + _(\"Spend unconfirmed change when sending transactions (default: 1)\") + \"\\n\";\n-    strUsage += \"  -txconfirmtarget=<n>   \" + _(\"If paytxfee is not set, include enough fee so transactions are confirmed on average within n blocks (default: 1)\") + \"\\n\";\n+    {\n+        strUsage += \"  -mintxfee=<amt>        \" +\n+            strprintf(_(\n+                \"Fees (in BTC/Kb) smaller than this are considered zero fee for transaction creation (default: %s)\"),\n+            FormatMoney(CWallet::minTxFee.GetFeePerK())) + \"\\n\";\n+    }\n+\n+    strUsage += \"  -paytxfee=<amt>        \" +\n+        strprintf(_(\"Fee (in BTC/kB) to add to transactions you send (default: %s)\"),\n+        FormatMoney(payTxFee.GetFeePerK())) + \"\\n\";\n+    strUsage += \"  -rescan                \" + _(\"Rescan the block chain for missing wallet transactions\") + \" \" + _(\n+        \"on startup\") + \"\\n\";\n+    strUsage += \"  -respendnotify=<cmd>   \" + _(\n+        \"Execute command when a network tx respends wallet tx input (%s=respend TxID, %t=wallet TxID)\") + \"\\n\";\n+    strUsage += \"  -salvagewallet         \" + _(\"Attempt to recover private keys from a corrupt wallet.dat\") + \" \" + _(\n+        \"on startup\") + \"\\n\";\n+    strUsage += \"  -spendzeroconfchange   \" + _(\"Spend unconfirmed change when sending transactions (default: 1)\") +\n+        \"\\n\";\n+    strUsage += \"  -txconfirmtarget=<n>   \" + _(\n+        \"If paytxfee is not set, include enough fee so transactions are confirmed on average within n blocks (default: 1)\")\n+        + \"\\n\";\n     strUsage += \"  -upgradewallet         \" + _(\"Upgrade wallet to latest format\") + \" \" + _(\"on startup\") + \"\\n\";\n-    strUsage += \"  -wallet=<file>         \" + _(\"Specify wallet file (within data directory)\") + \" \" + _(\"(default: wallet.dat)\") + \"\\n\";\n-    strUsage += \"  -walletnotify=<cmd>    \" + _(\"Execute command when a wallet transaction changes (%s in cmd is replaced by TxID)\") + \"\\n\";\n-    strUsage += \"  -zapwallettxes=<mode>  \" + _(\"Delete all wallet transactions and only recover those parts of the blockchain through -rescan on startup\") + \"\\n\";\n-    strUsage += \"                         \" + _(\"(default: 1, 1 = keep tx meta data e.g. account owner and payment request information, 2 = drop tx meta data)\") + \"\\n\";\n+    strUsage += \"  -wallet=<file>         \" + _(\"Specify wallet file (within data directory)\") + \" \" + _(\n+        \"(default: wallet.dat)\") + \"\\n\";\n+    strUsage += \"  -walletnotify=<cmd>    \" + _(\n+        \"Execute command when a wallet transaction changes (%s in cmd is replaced by TxID)\") + \"\\n\";\n+    strUsage += \"  -zapwallettxes=<mode>  \" + _(\n+        \"Delete all wallet transactions and only recover those parts of the blockchain through -rescan on startup\") +\n+        \"\\n\";\n+    strUsage += \"                         \" + _(\n+        \"(default: 1, 1 = keep tx meta data e.g. account owner and payment request information, 2 = drop tx meta data)\")\n+        +\n+        \"\\n\";\n #endif\n \n     strUsage += \"\\n\" + _(\"Debugging/Testing options:\") + \"\\n\";\n+\n     if (GetBoolArg(\"-help-debug\", false))\n     {\n-        strUsage += \"  -checkpoints           \" + _(\"Only accept block chain matching built-in checkpoints (default: 1)\") + \"\\n\";\n-        strUsage += \"  -dblogsize=<n>         \" + _(\"Flush database activity from memory pool to disk log every <n> megabytes (default: 100)\") + \"\\n\";\n-        strUsage += \"  -disablesafemode       \" + _(\"Disable safemode, override a real safe mode event (default: 0)\") + \"\\n\";\n+        strUsage += \"  -checkpoints           \" + _(\n+            \"Only accept block chain matching built-in checkpoints (default: 1)\") + \"\\n\";\n+        strUsage += \"  -dblogsize=<n>         \" + _(\n+            \"Flush database activity from memory pool to disk log every <n> megabytes (default: 100)\") + \"\\n\";\n+        strUsage += \"  -disablesafemode       \" + _(\"Disable safemode, override a real safe mode event (default: 0)\") +\n+            \"\\n\";\n         strUsage += \"  -testsafemode          \" + _(\"Force safe mode (default: 0)\") + \"\\n\";\n         strUsage += \"  -dropmessagestest=<n>  \" + _(\"Randomly drop 1 of every <n> network messages\") + \"\\n\";\n         strUsage += \"  -fuzzmessagestest=<n>  \" + _(\"Randomly fuzz 1 of every <n> network messages\") + \"\\n\";\n         strUsage += \"  -flushwallet           \" + _(\"Run a thread to flush wallet periodically (default: 1)\") + \"\\n\";\n-        strUsage += \"  -stopafterblockimport  \" + _(\"Stop running after importing blocks from disk (default: 0)\") + \"\\n\";\n+        strUsage += \"  -stopafterblockimport  \" + _(\"Stop running after importing blocks from disk (default: 0)\") +\n+            \"\\n\";\n     }\n-    strUsage += \"  -debug=<category>      \" + _(\"Output debugging information (default: 0, supplying <category> is optional)\") + \"\\n\";\n-    strUsage += \"                         \" + _(\"If <category> is not supplied, output all debugging information.\") + \"\\n\";\n+\n+    strUsage += \"  -debug=<category>      \" + _(\n+        \"Output debugging information (default: 0, supplying <category> is optional)\") + \"\\n\";\n+    strUsage += \"                         \" + _(\"If <category> is not supplied, output all debugging information.\") +\n+        \"\\n\";\n     strUsage += \"                         \" + _(\"<category> can be:\");\n-    strUsage +=                                 \" addrman, alert, bench, coindb, db, lock, rand, rpc, selectcoins, mempool, net\"; // Don't translate these and qt below\n+    strUsage +=\n+        \" addrman, alert, bench, coindb, db, lock, rand, rpc, selectcoins, mempool, net\";                                         // Don't translate these and qt below\n+\n     if (mode == HMM_BITCOIN_QT)\n+    {\n         strUsage += \", qt\";\n+    }\n+\n     strUsage += \".\\n\";\n #ifdef ENABLE_WALLET\n     strUsage += \"  -gen                   \" + _(\"Generate coins (default: 0)\") + \"\\n\";\n-    strUsage += \"  -genproclimit=<n>      \" + _(\"Set the processor limit for when generation is on (-1 = unlimited, default: -1)\") + \"\\n\";\n+    strUsage += \"  -genproclimit=<n>      \" + _(\n+        \"Set the processor limit for when generation is on (-1 = unlimited, default: -1)\") + \"\\n\";\n #endif\n     strUsage += \"  -help-debug            \" + _(\"Show all debugging options (usage: --help -help-debug)\") + \"\\n\";\n     strUsage += \"  -logips                \" + _(\"Include IP addresses in debug output (default: 0)\") + \"\\n\";\n     strUsage += \"  -logtimestamps         \" + _(\"Prepend debug output with timestamp (default: 1)\") + \"\\n\";\n+\n     if (GetBoolArg(\"-help-debug\", false))\n     {\n-        strUsage += \"  -limitfreerelay=<n>    \" + _(\"Continuously rate-limit free transactions to <n>*1000 bytes per minute (default:15)\") + \"\\n\";\n-        strUsage += \"  -maxsigcachesize=<n>   \" + _(\"Limit size of signature cache to <n> entries (default: 50000)\") + \"\\n\";\n+        strUsage += \"  -limitfreerelay=<n>    \" + _(\n+            \"Continuously rate-limit free transactions to <n>*1000 bytes per minute (default:15)\") + \"\\n\";\n+        strUsage += \"  -maxsigcachesize=<n>   \" + _(\"Limit size of signature cache to <n> entries (default: 50000)\") +\n+            \"\\n\";\n     }\n-    strUsage += \"  -minrelaytxfee=<amt>   \" + strprintf(_(\"Fees (in BTC/Kb) smaller than this are considered zero fee for relaying (default: %s)\"), FormatMoney(::minRelayTxFee.GetFeePerK())) + \"\\n\";\n+\n+    strUsage += \"  -minrelaytxfee=<amt>   \" +\n+        strprintf(_(\"Fees (in BTC/Kb) smaller than this are considered zero fee for relaying (default: %s)\"),\n+        FormatMoney(::minRelayTxFee.GetFeePerK())) + \"\\n\";\n     strUsage += \"  -printtoconsole        \" + _(\"Send trace/debug info to console instead of debug.log file\") + \"\\n\";\n+\n     if (GetBoolArg(\"-help-debug\", false))\n     {\n         strUsage += \"  -printblock=<hash>     \" + _(\"Print block on startup, if found in block index\") + \"\\n\";\n         strUsage += \"  -printblocktree        \" + _(\"Print block tree on startup (default: 0)\") + \"\\n\";\n-        strUsage += \"  -printpriority         \" + _(\"Log transaction priority and fee per kB when mining blocks (default: 0)\") + \"\\n\";\n-        strUsage += \"  -privdb                \" + _(\"Sets the DB_PRIVATE flag in the wallet db environment (default: 1)\") + \"\\n\";\n-        strUsage += \"  -regtest               \" + _(\"Enter regression test mode, which uses a special chain in which blocks can be solved instantly.\") + \"\\n\";\n-        strUsage += \"                         \" + _(\"This is intended for regression testing tools and app development.\") + \"\\n\";\n-        strUsage += \"                         \" + _(\"In this mode -genproclimit controls how many blocks are generated immediately.\") + \"\\n\";\n+        strUsage += \"  -printpriority         \" + _(\n+            \"Log transaction priority and fee per kB when mining blocks (default: 0)\") + \"\\n\";\n+        strUsage += \"  -privdb                \" + _(\n+            \"Sets the DB_PRIVATE flag in the wallet db environment (default: 1)\") + \"\\n\";\n+        strUsage += \"  -regtest               \" + _(\n+            \"Enter regression test mode, which uses a special chain in which blocks can be solved instantly.\") + \"\\n\";\n+        strUsage += \"                         \" + _(\n+            \"This is intended for regression testing tools and app development.\") + \"\\n\";\n+        strUsage += \"                         \" + _(\n+            \"In this mode -genproclimit controls how many blocks are generated immediately.\") + \"\\n\";\n     }\n-    strUsage += \"  -shrinkdebugfile       \" + _(\"Shrink debug.log file on client startup (default: 1 when no -debug)\") + \"\\n\";\n+\n+    strUsage += \"  -shrinkdebugfile       \" +\n+        _(\"Shrink debug.log file on client startup (default: 1 when no -debug)\") + \"\\n\";\n     strUsage += \"  -testnet               \" + _(\"Use the test network\") + \"\\n\";\n \n     strUsage += \"\\n\" + _(\"Node relay options:\") + \"\\n\";\n     strUsage += \"  -datacarrier           \" + _(\"Relay and mine data carrier transactions (default: 1)\") + \"\\n\";\n \n     strUsage += \"\\n\" + _(\"Block creation options:\") + \"\\n\";\n     strUsage += \"  -blockminsize=<n>      \" + _(\"Set minimum block size in bytes (default: 0)\") + \"\\n\";\n-    strUsage += \"  -blockmaxsize=<n>      \" + strprintf(_(\"Set maximum block size in bytes (default: %d)\"), DEFAULT_BLOCK_MAX_SIZE) + \"\\n\";\n-    strUsage += \"  -blockprioritysize=<n> \" + strprintf(_(\"Set maximum size of high-priority/low-fee transactions in bytes (default: %d)\"), DEFAULT_BLOCK_PRIORITY_SIZE) + \"\\n\";\n+    strUsage += \"  -blockmaxsize=<n>      \" + strprintf(_(\n+            \"Set maximum block size in bytes (default: %d)\"), DEFAULT_BLOCK_MAX_SIZE) + \"\\n\";\n+    strUsage += \"  -blockprioritysize=<n> \" +\n+        strprintf(_(\n+            \"Set maximum size of high-priority/low-fee transactions in bytes (default: %d)\"),\n+        DEFAULT_BLOCK_PRIORITY_SIZE) + \"\\n\";\n \n     strUsage += \"\\n\" + _(\"RPC server options:\") + \"\\n\";\n     strUsage += \"  -server                \" + _(\"Accept command line and JSON-RPC commands\") + \"\\n\";\n-    strUsage += \"  -rpcbind=<addr>        \" + _(\"Bind to given address to listen for JSON-RPC connections. Use [host]:port notation for IPv6. This option can be specified multiple times (default: bind to all interfaces)\") + \"\\n\";\n+    strUsage += \"  -rpcbind=<addr>        \" + _(\n+        \"Bind to given address to listen for JSON-RPC connections. Use [host]:port notation for IPv6. This option can be specified multiple times (default: bind to all interfaces)\")\n+        + \"\\n\";\n     strUsage += \"  -rpcuser=<user>        \" + _(\"Username for JSON-RPC connections\") + \"\\n\";\n     strUsage += \"  -rpcpassword=<pw>      \" + _(\"Password for JSON-RPC connections\") + \"\\n\";\n-    strUsage += \"  -rpcport=<port>        \" + _(\"Listen for JSON-RPC connections on <port> (default: 8332 or testnet: 18332)\") + \"\\n\";\n-    strUsage += \"  -rpcallowip=<ip>       \" + _(\"Allow JSON-RPC connections from specified source. Valid for <ip> are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24). This option can be specified multiple times\") + \"\\n\";\n+    strUsage += \"  -rpcport=<port>        \" + _(\n+        \"Listen for JSON-RPC connections on <port> (default: 8332 or testnet: 18332)\") + \"\\n\";\n+    strUsage += \"  -rpcallowip=<ip>       \" + _(\n+        \"Allow JSON-RPC connections from specified source. Valid for <ip> are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24). This option can be specified multiple times\")\n+        + \"\\n\";\n     strUsage += \"  -rpcthreads=<n>        \" + _(\"Set the number of threads to service RPC calls (default: 4)\") + \"\\n\";\n \n     strUsage += \"\\n\" + _(\"RPC SSL options: (see the Bitcoin Wiki for SSL setup instructions)\") + \"\\n\";\n-    strUsage += \"  -rpcssl                                  \" + _(\"Use OpenSSL (https) for JSON-RPC connections\") + \"\\n\";\n-    strUsage += \"  -rpcsslcertificatechainfile=<file.cert>  \" + _(\"Server certificate file (default: server.cert)\") + \"\\n\";\n+    strUsage += \"  -rpcssl                                  \" + _(\"Use OpenSSL (https) for JSON-RPC connections\") +\n+        \"\\n\";\n+    strUsage += \"  -rpcsslcertificatechainfile=<file.cert>  \" + _(\"Server certificate file (default: server.cert)\") +\n+        \"\\n\";\n     strUsage += \"  -rpcsslprivatekeyfile=<file.pem>         \" + _(\"Server private key (default: server.pem)\") + \"\\n\";\n-    strUsage += \"  -rpcsslciphers=<ciphers>                 \" + _(\"Acceptable ciphers (default: TLSv1.2+HIGH:TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!3DES:@STRENGTH)\") + \"\\n\";\n+    strUsage += \"  -rpcsslciphers=<ciphers>                 \" + _(\n+        \"Acceptable ciphers (default: TLSv1.2+HIGH:TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!3DES:@STRENGTH)\") + \"\\n\";\n \n     return strUsage;\n }\n@@ -364,9 +503,13 @@ std::string LicenseInfo()\n            \"\\n\" +\n            FormatParagraph(_(\"This is experimental software.\")) + \"\\n\" +\n            \"\\n\" +\n-           FormatParagraph(_(\"Distributed under the MIT/X11 software license, see the accompanying file COPYING or <http://www.opensource.org/licenses/mit-license.php>.\")) + \"\\n\" +\n+           FormatParagraph(_(\n+            \"Distributed under the MIT/X11 software license, see the accompanying file COPYING or <http://www.opensource.org/licenses/mit-license.php>.\"))\n+           + \"\\n\" +\n            \"\\n\" +\n-           FormatParagraph(_(\"This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit <https://www.openssl.org/> and cryptographic software written by Eric Young and UPnP software written by Thomas Bernard.\")) +\n+           FormatParagraph(_(\n+            \"This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit <https://www.openssl.org/> and cryptographic software written by Eric Young and UPnP software written by Thomas Bernard.\"))\n+           +\n            \"\\n\";\n }\n \n@@ -380,12 +523,14 @@ static void BlockNotifyCallback(const uint256& hashNewTip)\n \n struct CImportingNow\n {\n-    CImportingNow() {\n+    CImportingNow()\n+    {\n         assert(fImporting == false);\n         fImporting = true;\n     }\n \n-    ~CImportingNow() {\n+    ~CImportingNow()\n+    {\n         assert(fImporting == true);\n         fImporting = false;\n     }\n@@ -396,18 +541,26 @@ void ThreadImport(std::vector<boost::filesystem::path> vImportFiles)\n     RenameThread(\"bitcoin-loadblk\");\n \n     // -reindex\n-    if (fReindex) {\n+    if (fReindex)\n+    {\n         CImportingNow imp;\n         int nFile = 0;\n-        while (true) {\n+\n+        while (true)\n+        {\n             CDiskBlockPos pos(nFile, 0);\n-            FILE *file = OpenBlockFile(pos, true);\n+            FILE* file = OpenBlockFile(pos, true);\n+\n             if (!file)\n+            {\n                 break;\n+            }\n+\n             LogPrintf(\"Reindexing block file blk%05u.dat...\\n\", (unsigned int)nFile);\n             LoadExternalBlockFile(file, &pos);\n             nFile++;\n         }\n+\n         pblocktree->WriteReindexing(false);\n         fReindex = false;\n         LogPrintf(\"Reindexing finished\\n\");\n@@ -417,32 +570,44 @@ void ThreadImport(std::vector<boost::filesystem::path> vImportFiles)\n \n     // hardcoded $DATADIR/bootstrap.dat\n     filesystem::path pathBootstrap = GetDataDir() / \"bootstrap.dat\";\n-    if (filesystem::exists(pathBootstrap)) {\n-        FILE *file = fopen(pathBootstrap.string().c_str(), \"rb\");\n-        if (file) {\n+\n+    if (filesystem::exists(pathBootstrap))\n+    {\n+        FILE* file = fopen(pathBootstrap.string().c_str(), \"rb\");\n+\n+        if (file)\n+        {\n             CImportingNow imp;\n             filesystem::path pathBootstrapOld = GetDataDir() / \"bootstrap.dat.old\";\n             LogPrintf(\"Importing bootstrap.dat...\\n\");\n             LoadExternalBlockFile(file);\n             RenameOver(pathBootstrap, pathBootstrapOld);\n-        } else {\n+        }\n+        else\n+        {\n             LogPrintf(\"Warning: Could not open bootstrap file %s\\n\", pathBootstrap.string());\n         }\n     }\n \n     // -loadblock=\n-    BOOST_FOREACH(boost::filesystem::path &path, vImportFiles) {\n-        FILE *file = fopen(path.string().c_str(), \"rb\");\n-        if (file) {\n+    BOOST_FOREACH (boost::filesystem::path &path, vImportFiles)\n+    {\n+        FILE* file = fopen(path.string().c_str(), \"rb\");\n+\n+        if (file)\n+        {\n             CImportingNow imp;\n             LogPrintf(\"Importing blocks file %s...\\n\", path.string());\n             LoadExternalBlockFile(file);\n-        } else {\n+        }\n+        else\n+        {\n             LogPrintf(\"Warning: Could not open blocks file %s\\n\", path.string());\n         }\n     }\n \n-    if (GetBoolArg(\"-stopafterblockimport\", false)) {\n+    if (GetBoolArg(\"-stopafterblockimport\", false))\n+    {\n         LogPrintf(\"Stopping after block import\\n\");\n         StartShutdown();\n     }\n@@ -454,13 +619,17 @@ void ThreadImport(std::vector<boost::filesystem::path> vImportFiles)\n  */\n bool InitSanityCheck(void)\n {\n-    if(!ECC_InitSanityCheck()) {\n+    if (!ECC_InitSanityCheck())\n+    {\n         InitError(\"OpenSSL appears to lack support for elliptic curve cryptography. For more \"\n                   \"information, visit https://en.bitcoin.it/wiki/OpenSSL_and_EC_Libraries\");\n         return false;\n     }\n+\n     if (!glibc_sanity_test() || !glibcxx_sanity_test())\n+    {\n         return false;\n+    }\n \n     return true;\n }\n@@ -489,26 +658,40 @@ bool AppInit2(boost::thread_group& threadGroup)\n     // which is not correct. Can be removed, when GCCs winbase.h is fixed!\n #define PROCESS_DEP_ENABLE 0x00000001\n #endif\n-    typedef BOOL (WINAPI *PSETPROCDEPPOL)(DWORD);\n-    PSETPROCDEPPOL setProcDEPPol = (PSETPROCDEPPOL)GetProcAddress(GetModuleHandleA(\"Kernel32.dll\"), \"SetProcessDEPPolicy\");\n-    if (setProcDEPPol != NULL) setProcDEPPol(PROCESS_DEP_ENABLE);\n+    typedef BOOL (WINAPI * PSETPROCDEPPOL)(DWORD);\n+    PSETPROCDEPPOL setProcDEPPol = (PSETPROCDEPPOL)GetProcAddress(GetModuleHandleA(\n+            \"Kernel32.dll\"), \"SetProcessDEPPolicy\");\n+\n+    if (setProcDEPPol != NULL)\n+    {\n+        setProcDEPPol(PROCESS_DEP_ENABLE);\n+    }\n \n     // Initialize Windows Sockets\n     WSADATA wsadata;\n-    int ret = WSAStartup(MAKEWORD(2,2), &wsadata);\n+    int ret = WSAStartup(MAKEWORD(2, 2), &wsadata);\n+\n     if (ret != NO_ERROR || LOBYTE(wsadata.wVersion ) != 2 || HIBYTE(wsadata.wVersion) != 2)\n     {\n         return InitError(strprintf(\"Error: Winsock library failed to start (WSAStartup returned error %d)\", ret));\n     }\n+\n #endif\n #ifndef WIN32\n \n-    if (GetBoolArg(\"-sysperms\", false)) {\n+    if (GetBoolArg(\"-sysperms\", false))\n+    {\n #ifdef ENABLE_WALLET\n+\n         if (!GetBoolArg(\"-disablewallet\", false))\n+        {\n             return InitError(\"Error: -sysperms is not allowed in combination with enabled wallet functionality\");\n+        }\n+\n #endif\n-    } else {\n+    }\n+    else\n+    {\n         umask(077);\n     }\n \n@@ -535,96 +718,151 @@ bool AppInit2(boost::thread_group& threadGroup)\n \n     // ********************************************************* Step 2: parameter interactions\n \n-    if (mapArgs.count(\"-bind\") || mapArgs.count(\"-whitebind\")) {\n+    if (mapArgs.count(\"-bind\") || mapArgs.count(\"-whitebind\"))\n+    {\n         // when specifying an explicit binding address, you want to listen on it\n         // even when -connect or -proxy is specified\n         if (SoftSetBoolArg(\"-listen\", true))\n+        {\n             LogPrintf(\"AppInit2 : parameter interaction: -bind or -whitebind set -> setting -listen=1\\n\");\n+        }\n     }\n \n-    if (mapArgs.count(\"-connect\") && mapMultiArgs[\"-connect\"].size() > 0) {\n+    if (mapArgs.count(\"-connect\") && mapMultiArgs[\"-connect\"].size() > 0)\n+    {\n         // when only connecting to trusted nodes, do not seed via DNS, or listen by default\n         if (SoftSetBoolArg(\"-dnsseed\", false))\n+        {\n             LogPrintf(\"AppInit2 : parameter interaction: -connect set -> setting -dnsseed=0\\n\");\n+        }\n+\n         if (SoftSetBoolArg(\"-listen\", false))\n+        {\n             LogPrintf(\"AppInit2 : parameter interaction: -connect set -> setting -listen=0\\n\");\n+        }\n     }\n \n-    if (mapArgs.count(\"-proxy\")) {\n+    if (mapArgs.count(\"-proxy\"))\n+    {\n         // to protect privacy, do not listen by default if a default proxy server is specified\n         if (SoftSetBoolArg(\"-listen\", false))\n+        {\n             LogPrintf(\"AppInit2 : parameter interaction: -proxy set -> setting -listen=0\\n\");\n+        }\n     }\n \n-    if (!GetBoolArg(\"-listen\", true)) {\n+    if (!GetBoolArg(\"-listen\", true))\n+    {\n         // do not map ports or try to retrieve public IP when not listening (pointless)\n         if (SoftSetBoolArg(\"-upnp\", false))\n+        {\n             LogPrintf(\"AppInit2 : parameter interaction: -listen=0 -> setting -upnp=0\\n\");\n+        }\n+\n         if (SoftSetBoolArg(\"-discover\", false))\n+        {\n             LogPrintf(\"AppInit2 : parameter interaction: -listen=0 -> setting -discover=0\\n\");\n+        }\n     }\n \n-    if (mapArgs.count(\"-externalip\")) {\n+    if (mapArgs.count(\"-externalip\"))\n+    {\n         // if an explicit public IP is specified, do not try to find others\n         if (SoftSetBoolArg(\"-discover\", false))\n+        {\n             LogPrintf(\"AppInit2 : parameter interaction: -externalip set -> setting -discover=0\\n\");\n+        }\n     }\n \n-    if (GetBoolArg(\"-salvagewallet\", false)) {\n+    if (GetBoolArg(\"-salvagewallet\", false))\n+    {\n         // Rewrite just private keys: rescan to find transactions\n         if (SoftSetBoolArg(\"-rescan\", true))\n+        {\n             LogPrintf(\"AppInit2 : parameter interaction: -salvagewallet=1 -> setting -rescan=1\\n\");\n+        }\n     }\n \n     // -zapwallettx implies a rescan\n-    if (GetBoolArg(\"-zapwallettxes\", false)) {\n+    if (GetBoolArg(\"-zapwallettxes\", false))\n+    {\n         if (SoftSetBoolArg(\"-rescan\", true))\n+        {\n             LogPrintf(\"AppInit2 : parameter interaction: -zapwallettxes=<mode> -> setting -rescan=1\\n\");\n+        }\n     }\n \n     // Make sure enough file descriptors are available\n     int nBind = std::max((int)mapArgs.count(\"-bind\") + (int)mapArgs.count(\"-whitebind\"), 1);\n     nMaxConnections = GetArg(\"-maxconnections\", 125);\n     nMaxConnections = std::max(std::min(nMaxConnections, (int)(FD_SETSIZE - nBind - MIN_CORE_FILEDESCRIPTORS)), 0);\n     int nFD = RaiseFileDescriptorLimit(nMaxConnections + MIN_CORE_FILEDESCRIPTORS);\n+\n     if (nFD < MIN_CORE_FILEDESCRIPTORS)\n+    {\n         return InitError(_(\"Not enough file descriptors available.\"));\n+    }\n+\n     if (nFD - MIN_CORE_FILEDESCRIPTORS < nMaxConnections)\n+    {\n         nMaxConnections = nFD - MIN_CORE_FILEDESCRIPTORS;\n+    }\n \n     // ********************************************************* Step 3: parameter-to-internal-flags\n \n     fDebug = !mapMultiArgs[\"-debug\"].empty();\n     // Special-case: if -debug=0/-nodebug is set, turn off debugging messages\n     const vector<string>& categories = mapMultiArgs[\"-debug\"];\n+\n     if (GetBoolArg(\"-nodebug\", false) || find(categories.begin(), categories.end(), string(\"0\")) != categories.end())\n+    {\n         fDebug = false;\n+    }\n \n     // Check for -debugnet\n     if (GetBoolArg(\"-debugnet\", false))\n+    {\n         InitWarning(_(\"Warning: Unsupported argument -debugnet ignored, use -debug=net.\"));\n+    }\n+\n     // Check for -socks - as this is a privacy risk to continue, exit here\n     if (mapArgs.count(\"-socks\"))\n-        return InitError(_(\"Error: Unsupported argument -socks found. Setting SOCKS version isn't possible anymore, only SOCKS5 proxies are supported.\"));\n+    {\n+        return InitError(_(\n+                \"Error: Unsupported argument -socks found. Setting SOCKS version isn't possible anymore, only SOCKS5 proxies are supported.\"));\n+    }\n+\n     // Check for -tor - as this is a privacy risk to continue, exit here\n     if (GetBoolArg(\"-tor\", false))\n+    {\n         return InitError(_(\"Error: Unsupported argument -tor found, use -onion.\"));\n+    }\n \n     if (GetBoolArg(\"-benchmark\", false))\n+    {\n         InitWarning(_(\"Warning: Unsupported argument -benchmark ignored, use -debug=bench.\"));\n+    }\n \n     // Checkmempool defaults to true in regtest mode\n     mempool.setSanityCheck(GetBoolArg(\"-checkmempool\", Params().DefaultCheckMemPool()));\n     Checkpoints::fEnabled = GetBoolArg(\"-checkpoints\", true);\n \n     // -par=0 means autodetect, but nScriptCheckThreads==0 means no concurrency\n     nScriptCheckThreads = GetArg(\"-par\", DEFAULT_SCRIPTCHECK_THREADS);\n+\n     if (nScriptCheckThreads <= 0)\n+    {\n         nScriptCheckThreads += boost::thread::hardware_concurrency();\n+    }\n+\n     if (nScriptCheckThreads <= 1)\n+    {\n         nScriptCheckThreads = 0;\n+    }\n     else if (nScriptCheckThreads > MAX_SCRIPTCHECK_THREADS)\n+    {\n         nScriptCheckThreads = MAX_SCRIPTCHECK_THREADS;\n+    }\n \n     fServer = GetBoolArg(\"-server\", false);\n     fPrintToConsole = GetBoolArg(\"-printtoconsole\", false);\n@@ -638,15 +876,18 @@ bool AppInit2(boost::thread_group& threadGroup)\n     if (mapArgs.count(\"-timeout\"))\n     {\n         int nNewTimeout = GetArg(\"-timeout\", 5000);\n+\n         if (nNewTimeout > 0 && nNewTimeout < 600000)\n+        {\n             nConnectTimeout = nNewTimeout;\n+        }\n     }\n \n     // Continue to put \"/P2SH/\" in the coinbase to monitor\n     // BIP16 support.\n     // This can be removed eventually...\n     const char* pszP2SH = \"/P2SH/\";\n-    COINBASE_FLAGS << std::vector<unsigned char>(pszP2SH, pszP2SH+strlen(pszP2SH));\n+    COINBASE_FLAGS << std::vector<unsigned char>(pszP2SH, pszP2SH + strlen(pszP2SH));\n \n     // Fee-per-kilobyte amount considered the same as \"free\"\n     // If you are mining, be careful setting this:\n@@ -657,35 +898,57 @@ bool AppInit2(boost::thread_group& threadGroup)\n     if (mapArgs.count(\"-minrelaytxfee\"))\n     {\n         int64_t n = 0;\n+\n         if (ParseMoney(mapArgs[\"-minrelaytxfee\"], n) && n > 0)\n+        {\n             ::minRelayTxFee = CFeeRate(n);\n+        }\n         else\n+        {\n             return InitError(strprintf(_(\"Invalid amount for -minrelaytxfee=<amount>: '%s'\"), mapArgs[\"-minrelaytxfee\"]));\n+        }\n     }\n \n #ifdef ENABLE_WALLET\n+\n     if (mapArgs.count(\"-mintxfee\"))\n     {\n         int64_t n = 0;\n+\n         if (ParseMoney(mapArgs[\"-mintxfee\"], n) && n > 0)\n+        {\n             CWallet::minTxFee = CFeeRate(n);\n+        }\n         else\n+        {\n             return InitError(strprintf(_(\"Invalid amount for -mintxfee=<amount>: '%s'\"), mapArgs[\"-mintxfee\"]));\n+        }\n     }\n+\n     if (mapArgs.count(\"-paytxfee\"))\n     {\n         int64_t nFeePerK = 0;\n+\n         if (!ParseMoney(mapArgs[\"-paytxfee\"], nFeePerK))\n+        {\n             return InitError(strprintf(_(\"Invalid amount for -paytxfee=<amount>: '%s'\"), mapArgs[\"-paytxfee\"]));\n+        }\n+\n         if (nFeePerK > nHighTransactionFeeWarning)\n-            InitWarning(_(\"Warning: -paytxfee is set very high! This is the transaction fee you will pay if you send a transaction.\"));\n+        {\n+            InitWarning(_(\n+                    \"Warning: -paytxfee is set very high! This is the transaction fee you will pay if you send a transaction.\"));\n+        }\n+\n         payTxFee = CFeeRate(nFeePerK, 1000);\n+\n         if (payTxFee < ::minRelayTxFee)\n         {\n             return InitError(strprintf(_(\"Invalid amount for -paytxfee=<amount>: '%s' (must be at least %s)\"),\n-                                       mapArgs[\"-paytxfee\"], ::minRelayTxFee.ToString()));\n+                    mapArgs[\"-paytxfee\"], ::minRelayTxFee.ToString()));\n         }\n     }\n+\n     nTxConfirmTarget = GetArg(\"-txconfirmtarget\", 1);\n     bSpendZeroConfChange = GetArg(\"-spendzeroconfchange\", true);\n \n@@ -697,49 +960,77 @@ bool AppInit2(boost::thread_group& threadGroup)\n     // ********************************************************* Step 4: application initialization: dir lock, daemonize, pidfile, debug log\n     // Sanity check\n     if (!InitSanityCheck())\n+    {\n         return InitError(_(\"Initialization sanity check failed. Bitcoin Core is shutting down.\"));\n+    }\n \n     std::string strDataDir = GetDataDir().string();\n #ifdef ENABLE_WALLET\n+\n     // Wallet file must be a plain filename without a directory\n     if (strWalletFile != boost::filesystem::basename(strWalletFile) + boost::filesystem::extension(strWalletFile))\n+    {\n         return InitError(strprintf(_(\"Wallet %s resides outside data directory %s\"), strWalletFile, strDataDir));\n+    }\n+\n #endif\n     // Make sure only a single Bitcoin process is using the data directory.\n     boost::filesystem::path pathLockFile = GetDataDir() / \".lock\";\n     FILE* file = fopen(pathLockFile.string().c_str(), \"a\"); // empty lock file; created if it doesn't exist.\n-    if (file) fclose(file);\n+\n+    if (file)\n+    {\n+        fclose(file);\n+    }\n+\n     static boost::interprocess::file_lock lock(pathLockFile.string().c_str());\n+\n     if (!lock.try_lock())\n-        return InitError(strprintf(_(\"Cannot obtain a lock on data directory %s. Bitcoin Core is probably already running.\"), strDataDir));\n+    {\n+        return InitError(strprintf(_(\n+                    \"Cannot obtain a lock on data directory %s. Bitcoin Core is probably already running.\"), strDataDir));\n+    }\n \n     if (GetBoolArg(\"-shrinkdebugfile\", !fDebug))\n+    {\n         ShrinkDebugFile();\n+    }\n+\n     LogPrintf(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\");\n     LogPrintf(\"Bitcoin version %s (%s)\\n\", FormatFullVersion(), CLIENT_DATE);\n     LogPrintf(\"Using OpenSSL version %s\\n\", SSLeay_version(SSLEAY_VERSION));\n #ifdef ENABLE_WALLET\n     LogPrintf(\"Using BerkeleyDB version %s\\n\", DbEnv::version(0, 0, 0));\n #endif\n+\n     if (!fLogTimestamps)\n+    {\n         LogPrintf(\"Startup time: %s\\n\", DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", GetTime()));\n+    }\n+\n     LogPrintf(\"Default data directory %s\\n\", GetDefaultDataDir().string());\n     LogPrintf(\"Using data directory %s\\n\", strDataDir);\n     LogPrintf(\"Using config file %s\\n\", GetConfigFile().string());\n     LogPrintf(\"Using at most %i connections (%i file descriptors available)\\n\", nMaxConnections, nFD);\n     std::ostringstream strErrors;\n \n-    if (nScriptCheckThreads) {\n+    if (nScriptCheckThreads)\n+    {\n         LogPrintf(\"Using %u threads for script verification\\n\", nScriptCheckThreads);\n-        for (int i=0; i<nScriptCheckThreads-1; i++)\n+\n+        for (int i = 0; i < nScriptCheckThreads - 1; i++)\n+        {\n             threadGroup.create_thread(&ThreadScriptCheck);\n+        }\n     }\n \n     int64_t nStart;\n \n     // ********************************************************* Step 5: verify wallet database integrity\n #ifdef ENABLE_WALLET\n-    if (!fDisableWallet) {\n+\n+    if (!fDisableWallet)\n+    {\n         LogPrintf(\"Using wallet %s\\n\", strWalletFile);\n         uiInterface.InitMessage(_(\"Verifying wallet...\"));\n \n@@ -748,15 +1039,19 @@ bool AppInit2(boost::thread_group& threadGroup)\n             // try moving the database env out of the way\n             boost::filesystem::path pathDatabase = GetDataDir() / \"database\";\n             boost::filesystem::path pathDatabaseBak = GetDataDir() / strprintf(\"database.%d.bak\", GetTime());\n-            try {\n+            try\n+            {\n                 boost::filesystem::rename(pathDatabase, pathDatabaseBak);\n                 LogPrintf(\"Moved old %s to %s. Retrying.\\n\", pathDatabase.string(), pathDatabaseBak.string());\n-            } catch(boost::filesystem::filesystem_error &error) {\n-                 // failure is ok (well, not really, but it's not worse than what we started with)\n+            }\n+            catch (boost::filesystem::filesystem_error &error)\n+            {\n+                // failure is ok (well, not really, but it's not worse than what we started with)\n             }\n \n             // try again\n-            if (!bitdb.Open(GetDataDir())) {\n+            if (!bitdb.Open(GetDataDir()))\n+            {\n                 // if it still fails, it probably means we can't even create the database env\n                 string msg = strprintf(_(\"Error initializing wallet database environment %s!\"), strDataDir);\n                 return InitError(msg);\n@@ -767,12 +1062,15 @@ bool AppInit2(boost::thread_group& threadGroup)\n         {\n             // Recover readable keypairs:\n             if (!CWalletDB::Recover(bitdb, strWalletFile, true))\n+            {\n                 return false;\n+            }\n         }\n \n         if (filesystem::exists(GetDataDir() / strWalletFile))\n         {\n             CDBEnv::VerifyResult r = bitdb.Verify(strWalletFile, CWalletDB::Recover);\n+\n             if (r == CDBEnv::RECOVER_OK)\n             {\n                 string msg = strprintf(_(\"Warning: wallet.dat corrupt, data salvaged!\"\n@@ -781,64 +1079,107 @@ bool AppInit2(boost::thread_group& threadGroup)\n                                          \" restore from a backup.\"), strDataDir);\n                 InitWarning(msg);\n             }\n+\n             if (r == CDBEnv::RECOVER_FAIL)\n+            {\n                 return InitError(_(\"wallet.dat corrupt, salvage failed\"));\n+            }\n         }\n     } // (!fDisableWallet)\n+\n #endif // ENABLE_WALLET\n-    // ********************************************************* Step 6: network initialization\n+       // ********************************************************* Step 6: network initialization\n \n     RegisterNodeSignals(GetNodeSignals());\n \n-    if (mapArgs.count(\"-onlynet\")) {\n+    if (mapArgs.count(\"-onlynet\"))\n+    {\n         std::set<enum Network> nets;\n-        BOOST_FOREACH(std::string snet, mapMultiArgs[\"-onlynet\"]) {\n+\n+        BOOST_FOREACH (std::string snet, mapMultiArgs[\"-onlynet\"])\n+        {\n             enum Network net = ParseNetwork(snet);\n+\n             if (net == NET_UNROUTABLE)\n+            {\n                 return InitError(strprintf(_(\"Unknown network specified in -onlynet: '%s'\"), snet));\n+            }\n+\n             nets.insert(net);\n         }\n-        for (int n = 0; n < NET_MAX; n++) {\n+\n+        for (int n = 0; n < NET_MAX; n++)\n+        {\n             enum Network net = (enum Network)n;\n+\n             if (!nets.count(net))\n+            {\n                 SetLimited(net);\n+            }\n         }\n     }\n \n-    if (mapArgs.count(\"-whitelist\")) {\n-        BOOST_FOREACH(const std::string& net, mapMultiArgs[\"-whitelist\"]) {\n+    if (mapArgs.count(\"-whitelist\"))\n+    {\n+        BOOST_FOREACH (const std::string& net, mapMultiArgs[\"-whitelist\"])\n+        {\n             CSubNet subnet(net);\n+\n             if (!subnet.IsValid())\n+            {\n                 return InitError(strprintf(_(\"Invalid netmask specified in -whitelist: '%s'\"), net));\n+            }\n+\n             CNode::AddWhitelistedRange(subnet);\n         }\n     }\n \n     CService addrProxy;\n     bool fProxy = false;\n-    if (mapArgs.count(\"-proxy\")) {\n+\n+    if (mapArgs.count(\"-proxy\"))\n+    {\n         addrProxy = CService(mapArgs[\"-proxy\"], 9050);\n+\n         if (!addrProxy.IsValid())\n+        {\n             return InitError(strprintf(_(\"Invalid -proxy address: '%s'\"), mapArgs[\"-proxy\"]));\n+        }\n \n         if (!IsLimited(NET_IPV4))\n+        {\n             SetProxy(NET_IPV4, addrProxy);\n+        }\n+\n         if (!IsLimited(NET_IPV6))\n+        {\n             SetProxy(NET_IPV6, addrProxy);\n+        }\n+\n         SetNameProxy(addrProxy);\n         fProxy = true;\n     }\n \n     // -onion can override normal proxy, -noonion disables tor entirely\n     if (!(mapArgs.count(\"-onion\") && mapArgs[\"-onion\"] == \"0\") &&\n-        (fProxy || mapArgs.count(\"-onion\"))) {\n+        (fProxy || mapArgs.count(\"-onion\")))\n+    {\n         CService addrOnion;\n+\n         if (!mapArgs.count(\"-onion\"))\n+        {\n             addrOnion = addrProxy;\n+        }\n         else\n+        {\n             addrOnion = CService(mapArgs[\"-onion\"], 9050);\n+        }\n+\n         if (!addrOnion.IsValid())\n+        {\n             return InitError(strprintf(_(\"Invalid -onion address: '%s'\"), mapArgs[\"-onion\"]));\n+        }\n+\n         SetProxy(NET_TOR, addrOnion);\n         SetReachable(NET_TOR);\n     }\n@@ -849,70 +1190,111 @@ bool AppInit2(boost::thread_group& threadGroup)\n     fNameLookup = GetBoolArg(\"-dns\", true);\n \n     bool fBound = false;\n-    if (fListen) {\n-        if (mapArgs.count(\"-bind\") || mapArgs.count(\"-whitebind\")) {\n-            BOOST_FOREACH(std::string strBind, mapMultiArgs[\"-bind\"]) {\n+\n+    if (fListen)\n+    {\n+        if (mapArgs.count(\"-bind\") || mapArgs.count(\"-whitebind\"))\n+        {\n+            BOOST_FOREACH (std::string strBind, mapMultiArgs[\"-bind\"])\n+            {\n                 CService addrBind;\n+\n                 if (!Lookup(strBind.c_str(), addrBind, GetListenPort(), false))\n+                {\n                     return InitError(strprintf(_(\"Cannot resolve -bind address: '%s'\"), strBind));\n+                }\n+\n                 fBound |= Bind(addrBind, (BF_EXPLICIT | BF_REPORT_ERROR));\n             }\n-            BOOST_FOREACH(std::string strBind, mapMultiArgs[\"-whitebind\"]) {\n+\n+            BOOST_FOREACH (std::string strBind, mapMultiArgs[\"-whitebind\"])\n+            {\n                 CService addrBind;\n+\n                 if (!Lookup(strBind.c_str(), addrBind, 0, false))\n+                {\n                     return InitError(strprintf(_(\"Cannot resolve -whitebind address: '%s'\"), strBind));\n+                }\n+\n                 if (addrBind.GetPort() == 0)\n+                {\n                     return InitError(strprintf(_(\"Need to specify a port with -whitebind: '%s'\"), strBind));\n+                }\n+\n                 fBound |= Bind(addrBind, (BF_EXPLICIT | BF_REPORT_ERROR | BF_WHITELIST));\n             }\n         }\n-        else {\n+        else\n+        {\n             struct in_addr inaddr_any;\n             inaddr_any.s_addr = INADDR_ANY;\n             fBound |= Bind(CService(in6addr_any, GetListenPort()), BF_NONE);\n             fBound |= Bind(CService(inaddr_any, GetListenPort()), !fBound ? BF_REPORT_ERROR : BF_NONE);\n         }\n+\n         if (!fBound)\n+        {\n             return InitError(_(\"Failed to listen on any port. Use -listen=0 if you want this.\"));\n+        }\n     }\n \n-    if (mapArgs.count(\"-externalip\")) {\n-        BOOST_FOREACH(string strAddr, mapMultiArgs[\"-externalip\"]) {\n+    if (mapArgs.count(\"-externalip\"))\n+    {\n+        BOOST_FOREACH (string strAddr, mapMultiArgs[\"-externalip\"])\n+        {\n             CService addrLocal(strAddr, GetListenPort(), fNameLookup);\n+\n             if (!addrLocal.IsValid())\n+            {\n                 return InitError(strprintf(_(\"Cannot resolve -externalip address: '%s'\"), strAddr));\n+            }\n+\n             AddLocal(CService(strAddr, GetListenPort(), fNameLookup), LOCAL_MANUAL);\n         }\n     }\n \n-    BOOST_FOREACH(string strDest, mapMultiArgs[\"-seednode\"])\n+    BOOST_FOREACH (string strDest, mapMultiArgs[\"-seednode\"])\n+    {\n         AddOneShot(strDest);\n+    }\n \n     // ********************************************************* Step 7: load block chain\n \n     fReindex = GetBoolArg(\"-reindex\", false);\n \n     // Upgrading to 0.8; hard-link the old blknnnn.dat files into /blocks/\n     filesystem::path blocksDir = GetDataDir() / \"blocks\";\n+\n     if (!filesystem::exists(blocksDir))\n     {\n         filesystem::create_directories(blocksDir);\n         bool linked = false;\n-        for (unsigned int i = 1; i < 10000; i++) {\n+\n+        for (unsigned int i = 1; i < 10000; i++)\n+        {\n             filesystem::path source = GetDataDir() / strprintf(\"blk%04u.dat\", i);\n-            if (!filesystem::exists(source)) break;\n-            filesystem::path dest = blocksDir / strprintf(\"blk%05u.dat\", i-1);\n-            try {\n+\n+            if (!filesystem::exists(source))\n+            {\n+                break;\n+            }\n+\n+            filesystem::path dest = blocksDir / strprintf(\"blk%05u.dat\", i - 1);\n+            try\n+            {\n                 filesystem::create_hard_link(source, dest);\n                 LogPrintf(\"Hardlinked %s -> %s\\n\", source.string(), dest.string());\n                 linked = true;\n-            } catch (filesystem::filesystem_error & e) {\n+            }\n+            catch (filesystem::filesystem_error & e)\n+            {\n                 // Note: hardlink creation failing is not a disaster, it just means\n                 // blocks will get re-downloaded from peers.\n                 LogPrintf(\"Error hardlinking blk%04u.dat : %s\\n\", i, e.what());\n                 break;\n             }\n         }\n+\n         if (linked)\n         {\n             fReindex = true;\n@@ -921,28 +1303,43 @@ bool AppInit2(boost::thread_group& threadGroup)\n \n     // cache size calculations\n     size_t nTotalCache = (GetArg(\"-dbcache\", nDefaultDbCache) << 20);\n+\n     if (nTotalCache < (nMinDbCache << 20))\n+    {\n         nTotalCache = (nMinDbCache << 20); // total cache cannot be less than nMinDbCache\n+    }\n     else if (nTotalCache > (nMaxDbCache << 20))\n+    {\n         nTotalCache = (nMaxDbCache << 20); // total cache cannot be greater than nMaxDbCache\n+    }\n+\n     size_t nBlockTreeDBCache = nTotalCache / 8;\n+\n     if (nBlockTreeDBCache > (1 << 21) && !GetBoolArg(\"-txindex\", false))\n+    {\n         nBlockTreeDBCache = (1 << 21); // block tree db cache shouldn't be larger than 2 MiB\n+    }\n+\n     nTotalCache -= nBlockTreeDBCache;\n     size_t nCoinDBCache = nTotalCache / 2; // use half of the remaining cache for coindb cache\n     nTotalCache -= nCoinDBCache;\n     nCoinCacheSize = nTotalCache / 300; // coins in memory require around 300 bytes\n \n     bool fLoaded = false;\n-    while (!fLoaded) {\n+\n+    while (!fLoaded)\n+    {\n         bool fReset = fReindex;\n         std::string strLoadError;\n \n         uiInterface.InitMessage(_(\"Loading block index...\"));\n \n         nStart = GetTimeMillis();\n-        do {\n-            try {\n+\n+        do\n+        {\n+            try\n+            {\n                 UnloadBlockIndex();\n                 delete pcoinsTip;\n                 delete pcoinsdbview;\n@@ -953,59 +1350,83 @@ bool AppInit2(boost::thread_group& threadGroup)\n                 pcoinsTip = new CCoinsViewCache(*pcoinsdbview);\n \n                 if (fReindex)\n+                {\n                     pblocktree->WriteReindexing(true);\n+                }\n \n-                if (!LoadBlockIndex()) {\n+                if (!LoadBlockIndex())\n+                {\n                     strLoadError = _(\"Error loading block database\");\n                     break;\n                 }\n \n                 // If the loaded chain has a wrong genesis, bail out immediately\n                 // (we're likely using a testnet datadir, or the other way around).\n                 if (!mapBlockIndex.empty() && chainActive.Genesis() == NULL)\n+                {\n                     return InitError(_(\"Incorrect or no genesis block found. Wrong datadir for network?\"));\n+                }\n \n                 // Initialize the block index (no-op if non-empty database was already loaded)\n-                if (!InitBlockIndex()) {\n+                if (!InitBlockIndex())\n+                {\n                     strLoadError = _(\"Error initializing block database\");\n                     break;\n                 }\n \n                 // Check for changed -txindex state\n-                if (fTxIndex != GetBoolArg(\"-txindex\", false)) {\n+                if (fTxIndex != GetBoolArg(\"-txindex\", false))\n+                {\n                     strLoadError = _(\"You need to rebuild the database using -reindex to change -txindex\");\n                     break;\n                 }\n \n                 uiInterface.InitMessage(_(\"Verifying blocks...\"));\n+\n                 if (!CVerifyDB().VerifyDB(pcoinsdbview, GetArg(\"-checklevel\", 3),\n-                              GetArg(\"-checkblocks\", 288))) {\n+                        GetArg(\"-checkblocks\", 288)))\n+                {\n                     strLoadError = _(\"Corrupted block database detected\");\n                     break;\n                 }\n-            } catch(std::exception &e) {\n-                if (fDebug) LogPrintf(\"%s\\n\", e.what());\n+            }\n+            catch (std::exception &e)\n+            {\n+                if (fDebug)\n+                {\n+                    LogPrintf(\"%s\\n\", e.what());\n+                }\n+\n                 strLoadError = _(\"Error opening block database\");\n                 break;\n             }\n \n             fLoaded = true;\n-        } while(false);\n+        }\n+        while (false);\n \n-        if (!fLoaded) {\n+        if (!fLoaded)\n+        {\n             // first suggest a reindex\n-            if (!fReset) {\n+            if (!fReset)\n+            {\n                 bool fRet = uiInterface.ThreadSafeMessageBox(\n                     strLoadError + \".\\n\\n\" + _(\"Do you want to rebuild the block database now?\"),\n                     \"\", CClientUIInterface::MSG_ERROR | CClientUIInterface::BTN_ABORT);\n-                if (fRet) {\n+\n+                if (fRet)\n+                {\n                     fReindex = true;\n                     fRequestShutdown = false;\n-                } else {\n+                }\n+                else\n+                {\n                     LogPrintf(\"Aborted block database rebuild. Exiting.\\n\");\n                     return false;\n                 }\n-            } else {\n+            }\n+            else\n+            {\n                 return InitError(strLoadError);\n             }\n         }\n@@ -1019,6 +1440,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n         LogPrintf(\"Shutdown requested. Exiting.\\n\");\n         return false;\n     }\n+\n     LogPrintf(\" block index %15dms\\n\", GetTimeMillis() - nStart);\n \n     if (GetBoolArg(\"-printblockindex\", false) || GetBoolArg(\"-printblocktree\", false))\n@@ -1031,9 +1453,11 @@ bool AppInit2(boost::thread_group& threadGroup)\n     {\n         string strMatch = mapArgs[\"-printblock\"];\n         int nFound = 0;\n+\n         for (BlockMap::iterator mi = mapBlockIndex.begin(); mi != mapBlockIndex.end(); ++mi)\n         {\n             uint256 hash = (*mi).first;\n+\n             if (boost::algorithm::starts_with(hash.ToString(), strMatch))\n             {\n                 CBlockIndex* pindex = (*mi).second;\n@@ -1044,33 +1468,46 @@ bool AppInit2(boost::thread_group& threadGroup)\n                 nFound++;\n             }\n         }\n+\n         if (nFound == 0)\n+        {\n             LogPrintf(\"No blocks matching %s were found\\n\", strMatch);\n+        }\n+\n         return false;\n     }\n \n     boost::filesystem::path est_path = GetDataDir() / FEE_ESTIMATES_FILENAME;\n     CAutoFile est_filein = CAutoFile(fopen(est_path.string().c_str(), \"rb\"), SER_DISK, CLIENT_VERSION);\n+\n     // Allowed to fail as this file IS missing on first startup.\n     if (est_filein)\n+    {\n         mempool.ReadFeeEstimates(est_filein);\n+    }\n \n     // ********************************************************* Step 8: load wallet\n #ifdef ENABLE_WALLET\n-    if (fDisableWallet) {\n+\n+    if (fDisableWallet)\n+    {\n         pwalletMain = NULL;\n         LogPrintf(\"Wallet disabled!\\n\");\n-    } else {\n-\n+    }\n+    else\n+    {\n         // needed to restore wallet transaction meta data after -zapwallettxes\n         std::vector<CWalletTx> vWtx;\n \n-        if (GetBoolArg(\"-zapwallettxes\", false)) {\n+        if (GetBoolArg(\"-zapwallettxes\", false))\n+        {\n             uiInterface.InitMessage(_(\"Zapping all transactions from wallet...\"));\n \n             pwalletMain = new CWallet(strWalletFile);\n             DBErrors nZapWalletRet = pwalletMain->ZapWalletTx(vWtx);\n-            if (nZapWalletRet != DB_LOAD_OK) {\n+\n+            if (nZapWalletRet != DB_LOAD_OK)\n+            {\n                 uiInterface.InitMessage(_(\"Error loading wallet.dat: Wallet corrupted\"));\n                 return false;\n             }\n@@ -1085,41 +1522,55 @@ bool AppInit2(boost::thread_group& threadGroup)\n         bool fFirstRun = true;\n         pwalletMain = new CWallet(strWalletFile);\n         DBErrors nLoadWalletRet = pwalletMain->LoadWallet(fFirstRun);\n+\n         if (nLoadWalletRet != DB_LOAD_OK)\n         {\n             if (nLoadWalletRet == DB_CORRUPT)\n+            {\n                 strErrors << _(\"Error loading wallet.dat: Wallet corrupted\") << \"\\n\";\n+            }\n             else if (nLoadWalletRet == DB_NONCRITICAL_ERROR)\n             {\n                 string msg(_(\"Warning: error reading wallet.dat! All keys read correctly, but transaction data\"\n                              \" or address book entries might be missing or incorrect.\"));\n                 InitWarning(msg);\n             }\n             else if (nLoadWalletRet == DB_TOO_NEW)\n+            {\n                 strErrors << _(\"Error loading wallet.dat: Wallet requires newer version of Bitcoin Core\") << \"\\n\";\n+            }\n             else if (nLoadWalletRet == DB_NEED_REWRITE)\n             {\n                 strErrors << _(\"Wallet needed to be rewritten: restart Bitcoin Core to complete\") << \"\\n\";\n                 LogPrintf(\"%s\", strErrors.str());\n                 return InitError(strErrors.str());\n             }\n             else\n+            {\n                 strErrors << _(\"Error loading wallet.dat\") << \"\\n\";\n+            }\n         }\n \n         if (GetBoolArg(\"-upgradewallet\", fFirstRun))\n         {\n             int nMaxVersion = GetArg(\"-upgradewallet\", 0);\n+\n             if (nMaxVersion == 0) // the -upgradewallet without argument case\n             {\n                 LogPrintf(\"Performing wallet upgrade to %i\\n\", FEATURE_LATEST);\n                 nMaxVersion = CLIENT_VERSION;\n                 pwalletMain->SetMinVersion(FEATURE_LATEST); // permanently upgrade the wallet immediately\n             }\n             else\n+            {\n                 LogPrintf(\"Allowing wallet upgrade up to %i\\n\", nMaxVersion);\n+            }\n+\n             if (nMaxVersion < pwalletMain->GetVersion())\n+            {\n                 strErrors << _(\"Cannot downgrade wallet\") << \"\\n\";\n+            }\n+\n             pwalletMain->SetMaxVersion(nMaxVersion);\n         }\n \n@@ -1129,10 +1580,15 @@ bool AppInit2(boost::thread_group& threadGroup)\n             RandAddSeedPerfmon();\n \n             CPubKey newDefaultKey;\n-            if (pwalletMain->GetKeyFromPool(newDefaultKey)) {\n+\n+            if (pwalletMain->GetKeyFromPool(newDefaultKey))\n+            {\n                 pwalletMain->SetDefaultKey(newDefaultKey);\n+\n                 if (!pwalletMain->SetAddressBook(pwalletMain->vchDefaultKey.GetID(), \"\", \"receive\"))\n+                {\n                     strErrors << _(\"Cannot write default address\") << \"\\n\";\n+                }\n             }\n \n             pwalletMain->SetBestChain(chainActive.GetLocator());\n@@ -1143,22 +1599,32 @@ bool AppInit2(boost::thread_group& threadGroup)\n \n         RegisterWallet(pwalletMain);\n \n-        CBlockIndex *pindexRescan = chainActive.Tip();\n+        CBlockIndex* pindexRescan = chainActive.Tip();\n+\n         if (GetBoolArg(\"-rescan\", false))\n+        {\n             pindexRescan = chainActive.Genesis();\n+        }\n         else\n         {\n             CWalletDB walletdb(strWalletFile);\n             CBlockLocator locator;\n+\n             if (walletdb.ReadBestBlock(locator))\n+            {\n                 pindexRescan = chainActive.FindFork(locator);\n+            }\n             else\n+            {\n                 pindexRescan = chainActive.Genesis();\n+            }\n         }\n+\n         if (chainActive.Tip() && chainActive.Tip() != pindexRescan)\n         {\n             uiInterface.InitMessage(_(\"Rescanning...\"));\n-            LogPrintf(\"Rescanning last %i blocks (from block %i)...\\n\", chainActive.Height() - pindexRescan->nHeight, pindexRescan->nHeight);\n+            LogPrintf(\"Rescanning last %i blocks (from block %i)...\\n\",\n+                chainActive.Height() - pindexRescan->nHeight, pindexRescan->nHeight);\n             nStart = GetTimeMillis();\n             pwalletMain->ScanForWalletTransactions(pindexRescan, true);\n             LogPrintf(\" rescan      %15dms\\n\", GetTimeMillis() - nStart);\n@@ -1168,10 +1634,11 @@ bool AppInit2(boost::thread_group& threadGroup)\n             // Restore wallet transaction metadata after -zapwallettxes=1\n             if (GetBoolArg(\"-zapwallettxes\", false) && GetArg(\"-zapwallettxes\", \"1\") != \"2\")\n             {\n-                BOOST_FOREACH(const CWalletTx& wtxOld, vWtx)\n+                BOOST_FOREACH (const CWalletTx& wtxOld, vWtx)\n                 {\n                     uint256 hash = wtxOld.GetHash();\n                     std::map<uint256, CWalletTx>::iterator mi = pwalletMain->mapWallet.find(hash);\n+\n                     if (mi != pwalletMain->mapWallet.end())\n                     {\n                         const CWalletTx* copyFrom = &wtxOld;\n@@ -1189,25 +1656,35 @@ bool AppInit2(boost::thread_group& threadGroup)\n             }\n         }\n     } // (!fDisableWallet)\n+\n #else // ENABLE_WALLET\n     LogPrintf(\"No wallet compiled in!\\n\");\n #endif // !ENABLE_WALLET\n-    // ********************************************************* Step 9: import blocks\n+       // ********************************************************* Step 9: import blocks\n \n     if (mapArgs.count(\"-blocknotify\"))\n+    {\n         uiInterface.NotifyBlockTip.connect(BlockNotifyCallback);\n+    }\n \n     // scan for better chains in the block chain database, that are not yet connected in the active best chain\n     CValidationState state;\n+\n     if (!ActivateBestChain(state))\n+    {\n         strErrors << \"Failed to connect best block\";\n+    }\n \n     std::vector<boost::filesystem::path> vImportFiles;\n+\n     if (mapArgs.count(\"-loadblock\"))\n     {\n-        BOOST_FOREACH(string strFile, mapMultiArgs[\"-loadblock\"])\n+        BOOST_FOREACH (string strFile, mapMultiArgs[\"-loadblock\"])\n+        {\n             vImportFiles.push_back(strFile);\n+        }\n     }\n+\n     threadGroup.create_thread(boost::bind(&ThreadImport, vImportFiles));\n \n     // ********************************************************* Step 10: load peers\n@@ -1218,55 +1695,73 @@ bool AppInit2(boost::thread_group& threadGroup)\n \n     {\n         CAddrDB adb;\n+\n         if (!adb.Read(addrman))\n+        {\n             LogPrintf(\"Invalid or missing peers.dat; recreating\\n\");\n+        }\n     }\n \n     LogPrintf(\"Loaded %i addresses from peers.dat  %dms\\n\",\n-           addrman.size(), GetTimeMillis() - nStart);\n+        addrman.size(), GetTimeMillis() - nStart);\n \n     // ********************************************************* Step 11: start node\n \n     if (!CheckDiskSpace())\n+    {\n         return false;\n+    }\n \n     if (!strErrors.str().empty())\n+    {\n         return InitError(strErrors.str());\n+    }\n \n     RandAddSeedPerfmon();\n \n     //// debug print\n-    LogPrintf(\"mapBlockIndex.size() = %u\\n\",   mapBlockIndex.size());\n-    LogPrintf(\"nBestHeight = %d\\n\",                   chainActive.Height());\n+    LogPrintf(\"mapBlockIndex.size() = %u\\n\", mapBlockIndex.size());\n+    LogPrintf(\"nBestHeight = %d\\n\", chainActive.Height());\n #ifdef ENABLE_WALLET\n-    LogPrintf(\"setKeyPool.size() = %u\\n\",      pwalletMain ? pwalletMain->setKeyPool.size() : 0);\n-    LogPrintf(\"mapWallet.size() = %u\\n\",       pwalletMain ? pwalletMain->mapWallet.size() : 0);\n-    LogPrintf(\"mapAddressBook.size() = %u\\n\",  pwalletMain ? pwalletMain->mapAddressBook.size() : 0);\n+    LogPrintf(\"setKeyPool.size() = %u\\n\", pwalletMain ? pwalletMain->setKeyPool.size() : 0);\n+    LogPrintf(\"mapWallet.size() = %u\\n\", pwalletMain ? pwalletMain->mapWallet.size() : 0);\n+    LogPrintf(\"mapAddressBook.size() = %u\\n\", pwalletMain ? pwalletMain->mapAddressBook.size() : 0);\n #endif\n \n     StartNode(threadGroup);\n+\n     if (fServer)\n+    {\n         StartRPCThreads();\n+    }\n \n #ifdef ENABLE_WALLET\n+\n     // Generate coins in the background\n     if (pwalletMain)\n+    {\n         GenerateBitcoins(GetBoolArg(\"-gen\", false), pwalletMain, GetArg(\"-genproclimit\", -1));\n+    }\n+\n #endif\n \n     // ********************************************************* Step 12: finished\n \n     uiInterface.InitMessage(_(\"Done loading\"));\n \n #ifdef ENABLE_WALLET\n-    if (pwalletMain) {\n+\n+    if (pwalletMain)\n+    {\n         // Add wallet transactions that aren't already in a block to mapTransactions\n         pwalletMain->ReacceptWalletTransactions();\n \n         // Run a thread to flush wallet periodically\n         threadGroup.create_thread(boost::bind(&ThreadFlushWalletDB, boost::ref(pwalletMain->strWalletFile)));\n     }\n+\n #endif\n \n     return !fRequestShutdown;\n }\n+"
      },
      {
        "sha": "7612d4696981d00080598837d54fbecece277a44",
        "filename": "src/init.h",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/init.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/init.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -10,8 +10,9 @@\n \n class CWallet;\n \n-namespace boost {\n-    class thread_group;\n+namespace boost\n+{\n+class thread_group;\n } // namespace boost\n \n extern CWallet* pwalletMain;\n@@ -34,3 +35,4 @@ std::string HelpMessage(HelpMessageMode mode);\n std::string LicenseInfo();\n \n #endif // BITCOIN_INIT_H\n+"
      },
      {
        "sha": "11f5dc6dab51af941f1de28cac0b89c181b99364",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 568,
        "deletions": 182,
        "changes": 750,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -16,16 +16,20 @@\n #endif\n \n // anonymous namespace with local implementation code (OpenSSL interaction)\n-namespace {\n-\n+namespace\n+{\n #ifdef USE_SECP256K1\n #include <secp256k1.h>\n-class CSecp256k1Init {\n+class CSecp256k1Init\n+{\n public:\n-    CSecp256k1Init() {\n+    CSecp256k1Init()\n+    {\n         secp256k1_start();\n     }\n-    ~CSecp256k1Init() {\n+\n+    ~CSecp256k1Init()\n+    {\n         secp256k1_stop();\n     }\n };\n@@ -34,143 +38,300 @@ static CSecp256k1Init instance_of_csecp256k1;\n #else\n \n // Generate a private key from just the secret parameter\n-int EC_KEY_regenerate_key(EC_KEY *eckey, BIGNUM *priv_key)\n+int EC_KEY_regenerate_key(EC_KEY* eckey, BIGNUM* priv_key)\n {\n     int ok = 0;\n-    BN_CTX *ctx = NULL;\n-    EC_POINT *pub_key = NULL;\n+    BN_CTX* ctx = NULL;\n+    EC_POINT* pub_key = NULL;\n \n-    if (!eckey) return 0;\n+    if (!eckey)\n+    {\n+        return 0;\n+    }\n \n-    const EC_GROUP *group = EC_KEY_get0_group(eckey);\n+    const EC_GROUP* group = EC_KEY_get0_group(eckey);\n \n     if ((ctx = BN_CTX_new()) == NULL)\n+    {\n         goto err;\n+    }\n \n     pub_key = EC_POINT_new(group);\n \n     if (pub_key == NULL)\n+    {\n         goto err;\n+    }\n \n     if (!EC_POINT_mul(group, pub_key, priv_key, NULL, NULL, ctx))\n+    {\n         goto err;\n+    }\n \n-    EC_KEY_set_private_key(eckey,priv_key);\n-    EC_KEY_set_public_key(eckey,pub_key);\n+    EC_KEY_set_private_key(eckey, priv_key);\n+    EC_KEY_set_public_key(eckey, pub_key);\n \n     ok = 1;\n \n err:\n \n     if (pub_key)\n+    {\n         EC_POINT_free(pub_key);\n+    }\n+\n     if (ctx != NULL)\n+    {\n         BN_CTX_free(ctx);\n+    }\n \n     return(ok);\n }\n \n // Perform ECDSA key recovery (see SEC1 4.1.6) for curves over (mod p)-fields\n // recid selects which key is recovered\n // if check is non-zero, additional checks are performed\n-int ECDSA_SIG_recover_key_GFp(EC_KEY *eckey, ECDSA_SIG *ecsig, const unsigned char *msg, int msglen, int recid, int check)\n+int ECDSA_SIG_recover_key_GFp(EC_KEY* eckey, ECDSA_SIG* ecsig, const unsigned char* msg, int msglen, int recid,\n+        int check)\n {\n-    if (!eckey) return 0;\n+    if (!eckey)\n+    {\n+        return 0;\n+    }\n \n     int ret = 0;\n-    BN_CTX *ctx = NULL;\n-\n-    BIGNUM *x = NULL;\n-    BIGNUM *e = NULL;\n-    BIGNUM *order = NULL;\n-    BIGNUM *sor = NULL;\n-    BIGNUM *eor = NULL;\n-    BIGNUM *field = NULL;\n-    EC_POINT *R = NULL;\n-    EC_POINT *O = NULL;\n-    EC_POINT *Q = NULL;\n-    BIGNUM *rr = NULL;\n-    BIGNUM *zero = NULL;\n+    BN_CTX* ctx = NULL;\n+\n+    BIGNUM* x = NULL;\n+    BIGNUM* e = NULL;\n+    BIGNUM* order = NULL;\n+    BIGNUM* sor = NULL;\n+    BIGNUM* eor = NULL;\n+    BIGNUM* field = NULL;\n+    EC_POINT* R = NULL;\n+    EC_POINT* O = NULL;\n+    EC_POINT* Q = NULL;\n+    BIGNUM* rr = NULL;\n+    BIGNUM* zero = NULL;\n     int n = 0;\n     int i = recid / 2;\n \n-    const EC_GROUP *group = EC_KEY_get0_group(eckey);\n-    if ((ctx = BN_CTX_new()) == NULL) { ret = -1; goto err; }\n+    const EC_GROUP* group = EC_KEY_get0_group(eckey);\n+\n+    if ((ctx = BN_CTX_new()) == NULL)\n+    {\n+        ret = -1;\n+        goto err;\n+    }\n+\n     BN_CTX_start(ctx);\n     order = BN_CTX_get(ctx);\n-    if (!EC_GROUP_get_order(group, order, ctx)) { ret = -2; goto err; }\n+\n+    if (!EC_GROUP_get_order(group, order, ctx))\n+    {\n+        ret = -2;\n+        goto err;\n+    }\n+\n     x = BN_CTX_get(ctx);\n-    if (!BN_copy(x, order)) { ret=-1; goto err; }\n-    if (!BN_mul_word(x, i)) { ret=-1; goto err; }\n-    if (!BN_add(x, x, ecsig->r)) { ret=-1; goto err; }\n+\n+    if (!BN_copy(x, order))\n+    {\n+        ret = -1;\n+        goto err;\n+    }\n+\n+    if (!BN_mul_word(x, i))\n+    {\n+        ret = -1;\n+        goto err;\n+    }\n+\n+    if (!BN_add(x, x, ecsig->r))\n+    {\n+        ret = -1;\n+        goto err;\n+    }\n+\n     field = BN_CTX_get(ctx);\n-    if (!EC_GROUP_get_curve_GFp(group, field, NULL, NULL, ctx)) { ret=-2; goto err; }\n-    if (BN_cmp(x, field) >= 0) { ret=0; goto err; }\n-    if ((R = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n-    if (!EC_POINT_set_compressed_coordinates_GFp(group, R, x, recid % 2, ctx)) { ret=0; goto err; }\n+\n+    if (!EC_GROUP_get_curve_GFp(group, field, NULL, NULL, ctx))\n+    {\n+        ret = -2;\n+        goto err;\n+    }\n+\n+    if (BN_cmp(x, field) >= 0)\n+    {\n+        ret = 0;\n+        goto err;\n+    }\n+\n+    if ((R = EC_POINT_new(group)) == NULL)\n+    {\n+        ret = -2;\n+        goto err;\n+    }\n+\n+    if (!EC_POINT_set_compressed_coordinates_GFp(group, R, x, recid % 2, ctx))\n+    {\n+        ret = 0;\n+        goto err;\n+    }\n+\n     if (check)\n     {\n-        if ((O = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n-        if (!EC_POINT_mul(group, O, NULL, R, order, ctx)) { ret=-2; goto err; }\n-        if (!EC_POINT_is_at_infinity(group, O)) { ret = 0; goto err; }\n+        if ((O = EC_POINT_new(group)) == NULL)\n+        {\n+            ret = -2;\n+            goto err;\n+        }\n+\n+        if (!EC_POINT_mul(group, O, NULL, R, order, ctx))\n+        {\n+            ret = -2;\n+            goto err;\n+        }\n+\n+        if (!EC_POINT_is_at_infinity(group, O))\n+        {\n+            ret = 0;\n+            goto err;\n+        }\n+    }\n+\n+    if ((Q = EC_POINT_new(group)) == NULL)\n+    {\n+        ret = -2;\n+        goto err;\n     }\n-    if ((Q = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n+\n     n = EC_GROUP_get_degree(group);\n     e = BN_CTX_get(ctx);\n-    if (!BN_bin2bn(msg, msglen, e)) { ret=-1; goto err; }\n-    if (8*msglen > n) BN_rshift(e, e, 8-(n & 7));\n+\n+    if (!BN_bin2bn(msg, msglen, e))\n+    {\n+        ret = -1;\n+        goto err;\n+    }\n+\n+    if (8 * msglen > n)\n+    {\n+        BN_rshift(e, e, 8 - (n & 7));\n+    }\n+\n     zero = BN_CTX_get(ctx);\n-    if (!BN_zero(zero)) { ret=-1; goto err; }\n-    if (!BN_mod_sub(e, zero, e, order, ctx)) { ret=-1; goto err; }\n+\n+    if (!BN_zero(zero))\n+    {\n+        ret = -1;\n+        goto err;\n+    }\n+\n+    if (!BN_mod_sub(e, zero, e, order, ctx))\n+    {\n+        ret = -1;\n+        goto err;\n+    }\n+\n     rr = BN_CTX_get(ctx);\n-    if (!BN_mod_inverse(rr, ecsig->r, order, ctx)) { ret=-1; goto err; }\n+\n+    if (!BN_mod_inverse(rr, ecsig->r, order, ctx))\n+    {\n+        ret = -1;\n+        goto err;\n+    }\n+\n     sor = BN_CTX_get(ctx);\n-    if (!BN_mod_mul(sor, ecsig->s, rr, order, ctx)) { ret=-1; goto err; }\n+\n+    if (!BN_mod_mul(sor, ecsig->s, rr, order, ctx))\n+    {\n+        ret = -1;\n+        goto err;\n+    }\n+\n     eor = BN_CTX_get(ctx);\n-    if (!BN_mod_mul(eor, e, rr, order, ctx)) { ret=-1; goto err; }\n-    if (!EC_POINT_mul(group, Q, eor, R, sor, ctx)) { ret=-2; goto err; }\n-    if (!EC_KEY_set_public_key(eckey, Q)) { ret=-2; goto err; }\n+\n+    if (!BN_mod_mul(eor, e, rr, order, ctx))\n+    {\n+        ret = -1;\n+        goto err;\n+    }\n+\n+    if (!EC_POINT_mul(group, Q, eor, R, sor, ctx))\n+    {\n+        ret = -2;\n+        goto err;\n+    }\n+\n+    if (!EC_KEY_set_public_key(eckey, Q))\n+    {\n+        ret = -2;\n+        goto err;\n+    }\n \n     ret = 1;\n \n err:\n-    if (ctx) {\n+\n+    if (ctx)\n+    {\n         BN_CTX_end(ctx);\n         BN_CTX_free(ctx);\n     }\n-    if (R != NULL) EC_POINT_free(R);\n-    if (O != NULL) EC_POINT_free(O);\n-    if (Q != NULL) EC_POINT_free(Q);\n+\n+    if (R != NULL)\n+    {\n+        EC_POINT_free(R);\n+    }\n+\n+    if (O != NULL)\n+    {\n+        EC_POINT_free(O);\n+    }\n+\n+    if (Q != NULL)\n+    {\n+        EC_POINT_free(Q);\n+    }\n+\n     return ret;\n }\n \n // RAII Wrapper around OpenSSL's EC_KEY\n-class CECKey {\n+class CECKey\n+{\n private:\n-    EC_KEY *pkey;\n+    EC_KEY* pkey;\n \n public:\n-    CECKey() {\n+    CECKey()\n+    {\n         pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n         assert(pkey != NULL);\n     }\n \n-    ~CECKey() {\n+    ~CECKey()\n+    {\n         EC_KEY_free(pkey);\n     }\n \n-    void GetSecretBytes(unsigned char vch[32]) const {\n-        const BIGNUM *bn = EC_KEY_get0_private_key(pkey);\n+    void GetSecretBytes(unsigned char vch[32]) const\n+    {\n+        const BIGNUM* bn = EC_KEY_get0_private_key(pkey);\n+\n         assert(bn);\n         int nBytes = BN_num_bytes(bn);\n-        int n=BN_bn2bin(bn,&vch[32 - nBytes]);\n+        int n = BN_bn2bin(bn, &vch[32 - nBytes]);\n         assert(n == nBytes);\n         memset(vch, 0, 32 - nBytes);\n     }\n \n-    void SetSecretBytes(const unsigned char vch[32]) {\n+    void SetSecretBytes(const unsigned char vch[32])\n+    {\n         bool ret;\n         BIGNUM bn;\n+\n         BN_init(&bn);\n         ret = BN_bin2bn(vch, 32, &bn);\n         assert(ret);\n@@ -179,7 +340,8 @@ class CECKey {\n         BN_clear_free(&bn);\n     }\n \n-    void GetPrivKey(CPrivKey &privkey, bool fCompressed) {\n+    void GetPrivKey(CPrivKey &privkey, bool fCompressed)\n+    {\n         EC_KEY_set_conv_form(pkey, fCompressed ? POINT_CONVERSION_COMPRESSED : POINT_CONVERSION_UNCOMPRESSED);\n         int nSize = i2d_ECPrivateKey(pkey, NULL);\n         assert(nSize);\n@@ -189,98 +351,136 @@ class CECKey {\n         assert(nSize == nSize2);\n     }\n \n-    bool SetPrivKey(const CPrivKey &privkey, bool fSkipCheck=false) {\n+    bool SetPrivKey(const CPrivKey &privkey, bool fSkipCheck = false)\n+    {\n         const unsigned char* pbegin = &privkey[0];\n-        if (d2i_ECPrivateKey(&pkey, &pbegin, privkey.size())) {\n-            if(fSkipCheck)\n+\n+        if (d2i_ECPrivateKey(&pkey, &pbegin, privkey.size()))\n+        {\n+            if (fSkipCheck)\n+            {\n                 return true;\n+            }\n \n             // d2i_ECPrivateKey returns true if parsing succeeds.\n             // This doesn't necessarily mean the key is valid.\n             if (EC_KEY_check_key(pkey))\n+            {\n                 return true;\n+            }\n         }\n+\n         return false;\n     }\n \n-    void GetPubKey(CPubKey &pubkey, bool fCompressed) {\n+    void GetPubKey(CPubKey &pubkey, bool fCompressed)\n+    {\n         EC_KEY_set_conv_form(pkey, fCompressed ? POINT_CONVERSION_COMPRESSED : POINT_CONVERSION_UNCOMPRESSED);\n         int nSize = i2o_ECPublicKey(pkey, NULL);\n         assert(nSize);\n         assert(nSize <= 65);\n         unsigned char c[65];\n-        unsigned char *pbegin = c;\n+        unsigned char* pbegin = c;\n         int nSize2 = i2o_ECPublicKey(pkey, &pbegin);\n         assert(nSize == nSize2);\n         pubkey.Set(&c[0], &c[nSize]);\n     }\n \n-    bool SetPubKey(const CPubKey &pubkey) {\n+    bool SetPubKey(const CPubKey &pubkey)\n+    {\n         const unsigned char* pbegin = pubkey.begin();\n+\n         return o2i_ECPublicKey(&pkey, &pbegin, pubkey.size());\n     }\n \n-    bool Sign(const uint256 &hash, std::vector<unsigned char>& vchSig) {\n+    bool Sign(const uint256 &hash, std::vector<unsigned char>& vchSig)\n+    {\n         vchSig.clear();\n-        ECDSA_SIG *sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n+        ECDSA_SIG* sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n+\n         if (sig == NULL)\n+        {\n             return false;\n-        BN_CTX *ctx = BN_CTX_new();\n+        }\n+\n+        BN_CTX* ctx = BN_CTX_new();\n         BN_CTX_start(ctx);\n-        const EC_GROUP *group = EC_KEY_get0_group(pkey);\n-        BIGNUM *order = BN_CTX_get(ctx);\n-        BIGNUM *halforder = BN_CTX_get(ctx);\n+        const EC_GROUP* group = EC_KEY_get0_group(pkey);\n+        BIGNUM* order = BN_CTX_get(ctx);\n+        BIGNUM* halforder = BN_CTX_get(ctx);\n         EC_GROUP_get_order(group, order, ctx);\n         BN_rshift1(halforder, order);\n-        if (BN_cmp(sig->s, halforder) > 0) {\n+\n+        if (BN_cmp(sig->s, halforder) > 0)\n+        {\n             // enforce low S values, by negating the value (modulo the order) if above order/2.\n             BN_sub(sig->s, order, sig->s);\n         }\n+\n         BN_CTX_end(ctx);\n         BN_CTX_free(ctx);\n         unsigned int nSize = ECDSA_size(pkey);\n         vchSig.resize(nSize); // Make sure it is big enough\n-        unsigned char *pos = &vchSig[0];\n+        unsigned char* pos = &vchSig[0];\n         nSize = i2d_ECDSA_SIG(sig, &pos);\n         ECDSA_SIG_free(sig);\n         vchSig.resize(nSize); // Shrink to fit actual size\n         return true;\n     }\n \n-    bool Verify(const uint256 &hash, const std::vector<unsigned char>& vchSig) {\n+    bool Verify(const uint256 &hash, const std::vector<unsigned char>& vchSig)\n+    {\n         // -1 = error, 0 = bad sig, 1 = good\n         if (ECDSA_verify(0, (unsigned char*)&hash, sizeof(hash), &vchSig[0], vchSig.size(), pkey) != 1)\n+        {\n             return false;\n+        }\n+\n         return true;\n     }\n \n-    bool SignCompact(const uint256 &hash, unsigned char *p64, int &rec) {\n+    bool SignCompact(const uint256 &hash, unsigned char* p64, int &rec)\n+    {\n         bool fOk = false;\n-        ECDSA_SIG *sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n-        if (sig==NULL)\n+        ECDSA_SIG* sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n+\n+        if (sig == NULL)\n+        {\n             return false;\n+        }\n+\n         memset(p64, 0, 64);\n         int nBitsR = BN_num_bits(sig->r);\n         int nBitsS = BN_num_bits(sig->s);\n-        if (nBitsR <= 256 && nBitsS <= 256) {\n+\n+        if (nBitsR <= 256 && nBitsS <= 256)\n+        {\n             CPubKey pubkey;\n             GetPubKey(pubkey, true);\n-            for (int i=0; i<4; i++) {\n+\n+            for (int i = 0; i < 4; i++)\n+            {\n                 CECKey keyRec;\n-                if (ECDSA_SIG_recover_key_GFp(keyRec.pkey, sig, (unsigned char*)&hash, sizeof(hash), i, 1) == 1) {\n+\n+                if (ECDSA_SIG_recover_key_GFp(keyRec.pkey, sig, (unsigned char*)&hash, sizeof(hash), i, 1) == 1)\n+                {\n                     CPubKey pubkeyRec;\n                     keyRec.GetPubKey(pubkeyRec, true);\n-                    if (pubkeyRec == pubkey) {\n+\n+                    if (pubkeyRec == pubkey)\n+                    {\n                         rec = i;\n                         fOk = true;\n                         break;\n                     }\n                 }\n             }\n+\n             assert(fOk);\n-            BN_bn2bin(sig->r,&p64[32-(nBitsR+7)/8]);\n-            BN_bn2bin(sig->s,&p64[64-(nBitsS+7)/8]);\n+            BN_bn2bin(sig->r, &p64[32 - (nBitsR + 7) / 8]);\n+            BN_bn2bin(sig->s, &p64[64 - (nBitsS + 7) / 8]);\n         }\n+\n         ECDSA_SIG_free(sig);\n         return fOk;\n     }\n@@ -289,62 +489,85 @@ class CECKey {\n     // This is only slightly more CPU intensive than just verifying it.\n     // If this function succeeds, the recovered public key is guaranteed to be valid\n     // (the signature is a valid signature of the given data for that key)\n-    bool Recover(const uint256 &hash, const unsigned char *p64, int rec)\n+    bool Recover(const uint256 &hash, const unsigned char* p64, int rec)\n     {\n-        if (rec<0 || rec>=3)\n+        if (rec < 0 || rec >= 3)\n+        {\n             return false;\n-        ECDSA_SIG *sig = ECDSA_SIG_new();\n-        BN_bin2bn(&p64[0],  32, sig->r);\n+        }\n+\n+        ECDSA_SIG* sig = ECDSA_SIG_new();\n+        BN_bin2bn(&p64[0], 32, sig->r);\n         BN_bin2bn(&p64[32], 32, sig->s);\n         bool ret = ECDSA_SIG_recover_key_GFp(pkey, sig, (unsigned char*)&hash, sizeof(hash), rec, 0) == 1;\n         ECDSA_SIG_free(sig);\n         return ret;\n     }\n \n-    static bool TweakSecret(unsigned char vchSecretOut[32], const unsigned char vchSecretIn[32], const unsigned char vchTweak[32])\n+    static bool TweakSecret(unsigned char vchSecretOut[32], const unsigned char vchSecretIn[32],\n+            const unsigned char vchTweak[32])\n     {\n         bool ret = true;\n-        BN_CTX *ctx = BN_CTX_new();\n+        BN_CTX* ctx = BN_CTX_new();\n+\n         BN_CTX_start(ctx);\n-        BIGNUM *bnSecret = BN_CTX_get(ctx);\n-        BIGNUM *bnTweak = BN_CTX_get(ctx);\n-        BIGNUM *bnOrder = BN_CTX_get(ctx);\n-        EC_GROUP *group = EC_GROUP_new_by_curve_name(NID_secp256k1);\n+        BIGNUM* bnSecret = BN_CTX_get(ctx);\n+        BIGNUM* bnTweak = BN_CTX_get(ctx);\n+        BIGNUM* bnOrder = BN_CTX_get(ctx);\n+        EC_GROUP* group = EC_GROUP_new_by_curve_name(NID_secp256k1);\n         EC_GROUP_get_order(group, bnOrder, ctx); // what a grossly inefficient way to get the (constant) group order...\n         BN_bin2bn(vchTweak, 32, bnTweak);\n+\n         if (BN_cmp(bnTweak, bnOrder) >= 0)\n+        {\n             ret = false; // extremely unlikely\n+        }\n+\n         BN_bin2bn(vchSecretIn, 32, bnSecret);\n         BN_add(bnSecret, bnSecret, bnTweak);\n         BN_nnmod(bnSecret, bnSecret, bnOrder, ctx);\n+\n         if (BN_is_zero(bnSecret))\n+        {\n             ret = false; // ridiculously unlikely\n+        }\n+\n         int nBits = BN_num_bits(bnSecret);\n         memset(vchSecretOut, 0, 32);\n-        BN_bn2bin(bnSecret, &vchSecretOut[32-(nBits+7)/8]);\n+        BN_bn2bin(bnSecret, &vchSecretOut[32 - (nBits + 7) / 8]);\n         EC_GROUP_free(group);\n         BN_CTX_end(ctx);\n         BN_CTX_free(ctx);\n         return ret;\n     }\n \n-    bool TweakPublic(const unsigned char vchTweak[32]) {\n+    bool TweakPublic(const unsigned char vchTweak[32])\n+    {\n         bool ret = true;\n-        BN_CTX *ctx = BN_CTX_new();\n+        BN_CTX* ctx = BN_CTX_new();\n+\n         BN_CTX_start(ctx);\n-        BIGNUM *bnTweak = BN_CTX_get(ctx);\n-        BIGNUM *bnOrder = BN_CTX_get(ctx);\n-        BIGNUM *bnOne = BN_CTX_get(ctx);\n-        const EC_GROUP *group = EC_KEY_get0_group(pkey);\n+        BIGNUM* bnTweak = BN_CTX_get(ctx);\n+        BIGNUM* bnOrder = BN_CTX_get(ctx);\n+        BIGNUM* bnOne = BN_CTX_get(ctx);\n+        const EC_GROUP* group = EC_KEY_get0_group(pkey);\n         EC_GROUP_get_order(group, bnOrder, ctx); // what a grossly inefficient way to get the (constant) group order...\n         BN_bin2bn(vchTweak, 32, bnTweak);\n+\n         if (BN_cmp(bnTweak, bnOrder) >= 0)\n+        {\n             ret = false; // extremely unlikely\n-        EC_POINT *point = EC_POINT_dup(EC_KEY_get0_public_key(pkey), group);\n+        }\n+\n+        EC_POINT* point = EC_POINT_dup(EC_KEY_get0_public_key(pkey), group);\n         BN_one(bnOne);\n         EC_POINT_mul(group, point, bnTweak, point, bnOne, ctx);\n+\n         if (EC_POINT_is_at_infinity(group, point))\n+        {\n             ret = false; // ridiculously unlikely\n+        }\n+\n         EC_KEY_set_public_key(pkey, point);\n         EC_POINT_free(point);\n         BN_CTX_end(ctx);\n@@ -355,85 +578,121 @@ class CECKey {\n \n #endif\n \n-int CompareBigEndian(const unsigned char *c1, size_t c1len, const unsigned char *c2, size_t c2len) {\n-    while (c1len > c2len) {\n+int CompareBigEndian(const unsigned char* c1, size_t c1len, const unsigned char* c2, size_t c2len)\n+{\n+    while (c1len > c2len)\n+    {\n         if (*c1)\n+        {\n             return 1;\n+        }\n+\n         c1++;\n         c1len--;\n     }\n-    while (c2len > c1len) {\n+\n+    while (c2len > c1len)\n+    {\n         if (*c2)\n+        {\n             return -1;\n+        }\n+\n         c2++;\n         c2len--;\n     }\n-    while (c1len > 0) {\n+\n+    while (c1len > 0)\n+    {\n         if (*c1 > *c2)\n+        {\n             return 1;\n+        }\n+\n         if (*c2 > *c1)\n+        {\n             return -1;\n+        }\n+\n         c1++;\n         c2++;\n         c1len--;\n     }\n+\n     return 0;\n }\n \n // Order of secp256k1's generator minus 1.\n const unsigned char vchMaxModOrder[32] = {\n-    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n-    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,\n-    0xBA,0xAE,0xDC,0xE6,0xAF,0x48,0xA0,0x3B,\n-    0xBF,0xD2,0x5E,0x8C,0xD0,0x36,0x41,0x40\n+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,\n+    0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B,\n+    0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x40\n };\n \n // Half of the order of secp256k1's generator minus 1.\n const unsigned char vchMaxModHalfOrder[32] = {\n-    0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n-    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n-    0x5D,0x57,0x6E,0x73,0x57,0xA4,0x50,0x1D,\n-    0xDF,0xE9,0x2F,0x46,0x68,0x1B,0x20,0xA0\n+    0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+    0x5D, 0x57, 0x6E, 0x73, 0x57, 0xA4, 0x50, 0x1D,\n+    0xDF, 0xE9, 0x2F, 0x46, 0x68, 0x1B, 0x20, 0xA0\n };\n \n-const unsigned char vchZero[1] = {0};\n-\n+const unsigned char vchZero[1] = {\n+    0\n+};\n } // anon namespace\n \n-bool CKey::Check(const unsigned char *vch) {\n+bool CKey::Check(const unsigned char* vch)\n+{\n     return CompareBigEndian(vch, 32, vchZero, 0) > 0 &&\n            CompareBigEndian(vch, 32, vchMaxModOrder, 32) <= 0;\n }\n \n-bool CKey::CheckSignatureElement(const unsigned char *vch, int len, bool half) {\n+bool CKey::CheckSignatureElement(const unsigned char* vch, int len, bool half)\n+{\n     return CompareBigEndian(vch, len, vchZero, 0) > 0 &&\n            CompareBigEndian(vch, len, half ? vchMaxModHalfOrder : vchMaxModOrder, 32) <= 0;\n }\n \n-void CKey::MakeNewKey(bool fCompressedIn) {\n-    do {\n+void CKey::MakeNewKey(bool fCompressedIn)\n+{\n+    do\n+    {\n         GetRandBytes(vch, sizeof(vch));\n-    } while (!Check(vch));\n+    }\n+    while (!Check(vch));\n+\n     fValid = true;\n     fCompressed = fCompressedIn;\n }\n \n-bool CKey::SetPrivKey(const CPrivKey &privkey, bool fCompressedIn) {\n+bool CKey::SetPrivKey(const CPrivKey &privkey, bool fCompressedIn)\n+{\n #ifdef USE_SECP256K1\n+\n     if (!secp256k1_ecdsa_privkey_import((unsigned char*)begin(), &privkey[0], privkey.size()))\n+    {\n         return false;\n+    }\n+\n #else\n     CECKey key;\n+\n     if (!key.SetPrivKey(privkey))\n+    {\n         return false;\n+    }\n+\n     key.GetSecretBytes(vch);\n #endif\n     fCompressed = fCompressedIn;\n     fValid = true;\n     return true;\n }\n \n-CPrivKey CKey::GetPrivKey() const {\n+CPrivKey CKey::GetPrivKey() const\n+{\n     assert(fValid);\n     CPrivKey privkey;\n #ifdef USE_SECP256K1\n@@ -450,7 +709,8 @@ CPrivKey CKey::GetPrivKey() const {\n     return privkey;\n }\n \n-CPubKey CKey::GetPubKey() const {\n+CPubKey CKey::GetPubKey() const\n+{\n     assert(fValid);\n     CPubKey pubkey;\n #ifdef USE_SECP256K1\n@@ -467,164 +727,264 @@ CPubKey CKey::GetPubKey() const {\n     return pubkey;\n }\n \n-bool CKey::Sign(const uint256 &hash, std::vector<unsigned char>& vchSig) const {\n+bool CKey::Sign(const uint256 &hash, std::vector<unsigned char>& vchSig) const\n+{\n     if (!fValid)\n+    {\n         return false;\n+    }\n+\n #ifdef USE_SECP256K1\n     vchSig.resize(72);\n     int nSigLen = 72;\n     CKey nonce;\n-    do {\n+\n+    do\n+    {\n         nonce.MakeNewKey(true);\n-        if (secp256k1_ecdsa_sign((const unsigned char*)&hash, 32, (unsigned char*)&vchSig[0], &nSigLen, begin(), nonce.begin()))\n+\n+        if (secp256k1_ecdsa_sign((const unsigned char*)&hash, 32, (unsigned char*)&vchSig[0], &nSigLen, begin(),\n+                nonce.begin()))\n+        {\n             break;\n-    } while(true);\n+        }\n+    }\n+    while (true);\n+\n     vchSig.resize(nSigLen);\n     return true;\n+\n #else\n     CECKey key;\n     key.SetSecretBytes(vch);\n     return key.Sign(hash, vchSig);\n+\n #endif\n }\n \n-bool CKey::SignCompact(const uint256 &hash, std::vector<unsigned char>& vchSig) const {\n+bool CKey::SignCompact(const uint256 &hash, std::vector<unsigned char>& vchSig) const\n+{\n     if (!fValid)\n+    {\n         return false;\n+    }\n+\n     vchSig.resize(65);\n     int rec = -1;\n #ifdef USE_SECP256K1\n     CKey nonce;\n-    do {\n+\n+    do\n+    {\n         nonce.MakeNewKey(true);\n+\n         if (secp256k1_ecdsa_sign_compact((const unsigned char*)&hash, 32, &vchSig[1], begin(), nonce.begin(), &rec))\n+        {\n             break;\n-    } while(true);\n+        }\n+    }\n+    while (true);\n+\n #else\n     CECKey key;\n     key.SetSecretBytes(vch);\n+\n     if (!key.SignCompact(hash, &vchSig[1], rec))\n+    {\n         return false;\n+    }\n+\n #endif\n     assert(rec != -1);\n     vchSig[0] = 27 + rec + (fCompressed ? 4 : 0);\n     return true;\n }\n \n-bool CKey::Load(CPrivKey &privkey, CPubKey &vchPubKey, bool fSkipCheck=false) {\n+bool CKey::Load(CPrivKey &privkey, CPubKey &vchPubKey, bool fSkipCheck = false)\n+{\n #ifdef USE_SECP256K1\n+\n     if (!secp256k1_ecdsa_privkey_import((unsigned char*)begin(), &privkey[0], privkey.size()))\n+    {\n         return false;\n+    }\n+\n #else\n     CECKey key;\n+\n     if (!key.SetPrivKey(privkey, fSkipCheck))\n+    {\n         return false;\n+    }\n+\n     key.GetSecretBytes(vch);\n #endif\n     fCompressed = vchPubKey.IsCompressed();\n     fValid = true;\n \n     if (fSkipCheck)\n+    {\n         return true;\n+    }\n \n     if (GetPubKey() != vchPubKey)\n+    {\n         return false;\n+    }\n \n     return true;\n }\n \n-bool CPubKey::Verify(const uint256 &hash, const std::vector<unsigned char>& vchSig) const {\n+bool CPubKey::Verify(const uint256 &hash, const std::vector<unsigned char>& vchSig) const\n+{\n     if (!IsValid())\n+    {\n         return false;\n+    }\n+\n #ifdef USE_SECP256K1\n+\n     if (secp256k1_ecdsa_verify((const unsigned char*)&hash, 32, &vchSig[0], vchSig.size(), begin(), size()) != 1)\n+    {\n         return false;\n+    }\n+\n #else\n     CECKey key;\n+\n     if (!key.SetPubKey(*this))\n+    {\n         return false;\n+    }\n+\n     if (!key.Verify(hash, vchSig))\n+    {\n         return false;\n+    }\n+\n #endif\n     return true;\n }\n \n-bool CPubKey::RecoverCompact(const uint256 &hash, const std::vector<unsigned char>& vchSig) {\n+bool CPubKey::RecoverCompact(const uint256 &hash, const std::vector<unsigned char>& vchSig)\n+{\n     if (vchSig.size() != 65)\n+    {\n         return false;\n+    }\n+\n     int recid = (vchSig[0] - 27) & 3;\n     bool fComp = (vchSig[0] - 27) & 4;\n #ifdef USE_SECP256K1\n     int pubkeylen = 65;\n-    if (!secp256k1_ecdsa_recover_compact((const unsigned char*)&hash, 32, &vchSig[1], (unsigned char*)begin(), &pubkeylen, fComp, recid))\n+\n+    if (!secp256k1_ecdsa_recover_compact((const unsigned char*)&hash, 32, &vchSig[1], (unsigned char*)begin(),\n+            &pubkeylen, fComp, recid))\n+    {\n         return false;\n+    }\n+\n     assert((int)size() == pubkeylen);\n #else\n     CECKey key;\n+\n     if (!key.Recover(hash, &vchSig[1], recid))\n+    {\n         return false;\n+    }\n+\n     key.GetPubKey(*this, fComp);\n #endif\n     return true;\n }\n \n-bool CPubKey::IsFullyValid() const {\n+bool CPubKey::IsFullyValid() const\n+{\n     if (!IsValid())\n+    {\n         return false;\n+    }\n+\n #ifdef USE_SECP256K1\n+\n     if (!secp256k1_ecdsa_pubkey_verify(begin(), size()))\n+    {\n         return false;\n+    }\n+\n #else\n     CECKey key;\n+\n     if (!key.SetPubKey(*this))\n+    {\n         return false;\n+    }\n+\n #endif\n     return true;\n }\n \n-bool CPubKey::Decompress() {\n+bool CPubKey::Decompress()\n+{\n     if (!IsValid())\n+    {\n         return false;\n+    }\n+\n #ifdef USE_SECP256K1\n     int clen = size();\n     int ret = secp256k1_ecdsa_pubkey_decompress((unsigned char*)begin(), &clen);\n     assert(ret);\n     assert(clen == (int)size());\n #else\n     CECKey key;\n+\n     if (!key.SetPubKey(*this))\n+    {\n         return false;\n+    }\n+\n     key.GetPubKey(*this, false);\n #endif\n     return true;\n }\n \n-void static BIP32Hash(const unsigned char chainCode[32], unsigned int nChild, unsigned char header, const unsigned char data[32], unsigned char output[64]) {\n+void static BIP32Hash(const unsigned char chainCode[32], unsigned int nChild, unsigned char header,\n+    const unsigned char data[32],\n+    unsigned char output[64])\n+{\n     unsigned char num[4];\n+\n     num[0] = (nChild >> 24) & 0xFF;\n     num[1] = (nChild >> 16) & 0xFF;\n-    num[2] = (nChild >>  8) & 0xFF;\n-    num[3] = (nChild >>  0) & 0xFF;\n+    num[2] = (nChild >> 8) & 0xFF;\n+    num[3] = (nChild >> 0) & 0xFF;\n     CHMAC_SHA512(chainCode, 32).Write(&header, 1)\n-                               .Write(data, 32)\n-                               .Write(num, 4)\n-                               .Finalize(output);\n+    .Write(data, 32)\n+    .Write(num, 4)\n+    .Finalize(output);\n }\n \n-bool CKey::Derive(CKey& keyChild, unsigned char ccChild[32], unsigned int nChild, const unsigned char cc[32]) const {\n+bool CKey::Derive(CKey& keyChild, unsigned char ccChild[32], unsigned int nChild, const unsigned char cc[32]) const\n+{\n     assert(IsValid());\n     assert(IsCompressed());\n     unsigned char out[64];\n     LockObject(out);\n-    if ((nChild >> 31) == 0) {\n+\n+    if ((nChild >> 31) == 0)\n+    {\n         CPubKey pubkey = GetPubKey();\n         assert(pubkey.begin() + 33 == pubkey.end());\n-        BIP32Hash(cc, nChild, *pubkey.begin(), pubkey.begin()+1, out);\n-    } else {\n+        BIP32Hash(cc, nChild, *pubkey.begin(), pubkey.begin() + 1, out);\n+    }\n+    else\n+    {\n         assert(begin() + 32 == end());\n         BIP32Hash(cc, nChild, 0, begin(), out);\n     }\n-    memcpy(ccChild, out+32, 32);\n+\n+    memcpy(ccChild, out + 32, 32);\n #ifdef USE_SECP256K1\n     memcpy((unsigned char*)keyChild.begin(), begin(), 32);\n     bool ret = secp256k1_ecdsa_privkey_tweak_add((unsigned char*)keyChild.begin(), out);\n@@ -637,13 +997,15 @@ bool CKey::Derive(CKey& keyChild, unsigned char ccChild[32], unsigned int nChild\n     return ret;\n }\n \n-bool CPubKey::Derive(CPubKey& pubkeyChild, unsigned char ccChild[32], unsigned int nChild, const unsigned char cc[32]) const {\n+bool CPubKey::Derive(CPubKey& pubkeyChild, unsigned char ccChild[32], unsigned int nChild,\n+    const unsigned char cc[32]) const\n+{\n     assert(IsValid());\n     assert((nChild >> 31) == 0);\n     assert(begin() + 33 == end());\n     unsigned char out[64];\n-    BIP32Hash(cc, nChild, *begin(), begin()+1, out);\n-    memcpy(ccChild, out+32, 32);\n+    BIP32Hash(cc, nChild, *begin(), begin() + 1, out);\n+    memcpy(ccChild, out + 32, 32);\n #ifdef USE_SECP256K1\n     pubkeyChild = *this;\n     bool ret = secp256k1_ecdsa_pubkey_tweak_add((unsigned char*)pubkeyChild.begin(), pubkeyChild.size(), out);\n@@ -656,17 +1018,22 @@ bool CPubKey::Derive(CPubKey& pubkeyChild, unsigned char ccChild[32], unsigned i\n     return ret;\n }\n \n-bool CExtKey::Derive(CExtKey &out, unsigned int nChild) const {\n+bool CExtKey::Derive(CExtKey &out, unsigned int nChild) const\n+{\n     out.nDepth = nDepth + 1;\n     CKeyID id = key.GetPubKey().GetID();\n     memcpy(&out.vchFingerprint[0], &id, 4);\n     out.nChild = nChild;\n     return key.Derive(out.key, out.vchChainCode, nChild, vchChainCode);\n }\n \n-void CExtKey::SetMaster(const unsigned char *seed, unsigned int nSeedLen) {\n-    static const unsigned char hashkey[] = {'B','i','t','c','o','i','n',' ','s','e','e','d'};\n+void CExtKey::SetMaster(const unsigned char* seed, unsigned int nSeedLen)\n+{\n+    static const unsigned char hashkey[] = {\n+        'B', 'i', 't', 'c', 'o', 'i', 'n', ' ', 's', 'e', 'e', 'd'\n+    };\n     unsigned char out[64];\n+\n     LockObject(out);\n     CHMAC_SHA512(hashkey, sizeof(hashkey)).Write(seed, nSeedLen).Finalize(out);\n     key.Set(&out[0], &out[32], true);\n@@ -677,8 +1044,10 @@ void CExtKey::SetMaster(const unsigned char *seed, unsigned int nSeedLen) {\n     memset(vchFingerprint, 0, sizeof(vchFingerprint));\n }\n \n-CExtPubKey CExtKey::Neuter() const {\n+CExtPubKey CExtKey::Neuter() const\n+{\n     CExtPubKey ret;\n+\n     ret.nDepth = nDepth;\n     memcpy(&ret.vchFingerprint[0], &vchFingerprint[0], 4);\n     ret.nChild = nChild;\n@@ -687,61 +1056,78 @@ CExtPubKey CExtKey::Neuter() const {\n     return ret;\n }\n \n-void CExtKey::Encode(unsigned char code[74]) const {\n+void CExtKey::Encode(unsigned char code[74]) const\n+{\n     code[0] = nDepth;\n-    memcpy(code+1, vchFingerprint, 4);\n-    code[5] = (nChild >> 24) & 0xFF; code[6] = (nChild >> 16) & 0xFF;\n-    code[7] = (nChild >>  8) & 0xFF; code[8] = (nChild >>  0) & 0xFF;\n-    memcpy(code+9, vchChainCode, 32);\n+    memcpy(code + 1, vchFingerprint, 4);\n+    code[5] = (nChild >> 24) & 0xFF;\n+    code[6] = (nChild >> 16) & 0xFF;\n+    code[7] = (nChild >> 8) & 0xFF;\n+    code[8] = (nChild >> 0) & 0xFF;\n+    memcpy(code + 9, vchChainCode, 32);\n     code[41] = 0;\n     assert(key.size() == 32);\n-    memcpy(code+42, key.begin(), 32);\n+    memcpy(code + 42, key.begin(), 32);\n }\n \n-void CExtKey::Decode(const unsigned char code[74]) {\n+void CExtKey::Decode(const unsigned char code[74])\n+{\n     nDepth = code[0];\n-    memcpy(vchFingerprint, code+1, 4);\n+    memcpy(vchFingerprint, code + 1, 4);\n     nChild = (code[5] << 24) | (code[6] << 16) | (code[7] << 8) | code[8];\n-    memcpy(vchChainCode, code+9, 32);\n-    key.Set(code+42, code+74, true);\n+    memcpy(vchChainCode, code + 9, 32);\n+    key.Set(code + 42, code + 74, true);\n }\n \n-void CExtPubKey::Encode(unsigned char code[74]) const {\n+void CExtPubKey::Encode(unsigned char code[74]) const\n+{\n     code[0] = nDepth;\n-    memcpy(code+1, vchFingerprint, 4);\n-    code[5] = (nChild >> 24) & 0xFF; code[6] = (nChild >> 16) & 0xFF;\n-    code[7] = (nChild >>  8) & 0xFF; code[8] = (nChild >>  0) & 0xFF;\n-    memcpy(code+9, vchChainCode, 32);\n+    memcpy(code + 1, vchFingerprint, 4);\n+    code[5] = (nChild >> 24) & 0xFF;\n+    code[6] = (nChild >> 16) & 0xFF;\n+    code[7] = (nChild >> 8) & 0xFF;\n+    code[8] = (nChild >> 0) & 0xFF;\n+    memcpy(code + 9, vchChainCode, 32);\n     assert(pubkey.size() == 33);\n-    memcpy(code+41, pubkey.begin(), 33);\n+    memcpy(code + 41, pubkey.begin(), 33);\n }\n \n-void CExtPubKey::Decode(const unsigned char code[74]) {\n+void CExtPubKey::Decode(const unsigned char code[74])\n+{\n     nDepth = code[0];\n-    memcpy(vchFingerprint, code+1, 4);\n+    memcpy(vchFingerprint, code + 1, 4);\n     nChild = (code[5] << 24) | (code[6] << 16) | (code[7] << 8) | code[8];\n-    memcpy(vchChainCode, code+9, 32);\n-    pubkey.Set(code+41, code+74);\n+    memcpy(vchChainCode, code + 9, 32);\n+    pubkey.Set(code + 41, code + 74);\n }\n \n-bool CExtPubKey::Derive(CExtPubKey &out, unsigned int nChild) const {\n+bool CExtPubKey::Derive(CExtPubKey &out, unsigned int nChild) const\n+{\n     out.nDepth = nDepth + 1;\n     CKeyID id = pubkey.GetID();\n     memcpy(&out.vchFingerprint[0], &id, 4);\n     out.nChild = nChild;\n     return pubkey.Derive(out.pubkey, out.vchChainCode, nChild, vchChainCode);\n }\n \n-bool ECC_InitSanityCheck() {\n+bool ECC_InitSanityCheck()\n+{\n #ifdef USE_SECP256K1\n     return true;\n+\n #else\n-    EC_KEY *pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n-    if(pkey == NULL)\n+    EC_KEY* pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n+\n+    if (pkey == NULL)\n+    {\n         return false;\n+    }\n+\n     EC_KEY_free(pkey);\n \n     // TODO Is there more EC functionality that could be missing?\n     return true;\n+\n #endif\n }\n+"
      },
      {
        "sha": "1d3c484bfc49fe189733a88dbaa9032c81da1ea3",
        "filename": "src/key.h",
        "status": "modified",
        "additions": 157,
        "deletions": 57,
        "changes": 214,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/key.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/key.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -26,129 +26,194 @@\n class CKeyID : public uint160\n {\n public:\n-    CKeyID() : uint160(0) { }\n-    CKeyID(const uint160 &in) : uint160(in) { }\n+    CKeyID() : uint160(0)\n+    {\n+    }\n+\n+    CKeyID(const uint160 &in) : uint160(in)\n+    {\n+    }\n };\n \n /** A reference to a CScript: the Hash160 of its serialization (see script.h) */\n class CScriptID : public uint160\n {\n public:\n-    CScriptID() : uint160(0) { }\n-    CScriptID(const uint160 &in) : uint160(in) { }\n+    CScriptID() : uint160(0)\n+    {\n+    }\n+\n+    CScriptID(const uint160 &in) : uint160(in)\n+    {\n+    }\n };\n \n /** An encapsulated public key. */\n-class CPubKey {\n+class CPubKey\n+{\n private:\n     // Just store the serialized data.\n     // Its length can very cheaply be computed from the first byte.\n     unsigned char vch[65];\n \n     // Compute the length of a pubkey with a given first byte.\n-    unsigned int static GetLen(unsigned char chHeader) {\n+    unsigned int static GetLen(unsigned char chHeader)\n+    {\n         if (chHeader == 2 || chHeader == 3)\n+        {\n             return 33;\n+        }\n+\n         if (chHeader == 4 || chHeader == 6 || chHeader == 7)\n+        {\n             return 65;\n+        }\n+\n         return 0;\n     }\n \n     // Set this key data to be invalid\n-    void Invalidate() {\n+    void Invalidate()\n+    {\n         vch[0] = 0xFF;\n     }\n \n public:\n     // Construct an invalid public key.\n-    CPubKey() {\n+    CPubKey()\n+    {\n         Invalidate();\n     }\n \n     // Initialize a public key using begin/end iterators to byte data.\n     template<typename T>\n-    void Set(const T pbegin, const T pend) {\n+    void Set(const T pbegin, const T pend)\n+    {\n         int len = pend == pbegin ? 0 : GetLen(pbegin[0]);\n-        if (len && len == (pend-pbegin))\n+\n+        if (len && len == (pend - pbegin))\n+        {\n             memcpy(vch, (unsigned char*)&pbegin[0], len);\n+        }\n         else\n+        {\n             Invalidate();\n+        }\n     }\n \n     // Construct a public key using begin/end iterators to byte data.\n-    template<typename T>\n-    CPubKey(const T pbegin, const T pend) {\n+    template<typename T>CPubKey(const T pbegin, const T pend)\n+    {\n         Set(pbegin, pend);\n     }\n \n     // Construct a public key from a byte vector.\n-    CPubKey(const std::vector<unsigned char> &vch) {\n+    CPubKey(const std::vector<unsigned char> &vch)\n+    {\n         Set(vch.begin(), vch.end());\n     }\n \n     // Simple read-only vector-like interface to the pubkey data.\n-    unsigned int size() const { return GetLen(vch[0]); }\n-    const unsigned char *begin() const { return vch; }\n-    const unsigned char *end() const { return vch+size(); }\n-    const unsigned char &operator[](unsigned int pos) const { return vch[pos]; }\n+    unsigned int size() const\n+    {\n+        return GetLen(vch[0]);\n+    }\n+\n+    const unsigned char* begin() const\n+    {\n+        return vch;\n+    }\n+\n+    const unsigned char* end() const\n+    {\n+        return vch + size();\n+    }\n+\n+    const unsigned char &operator[](unsigned int pos) const\n+    {\n+        return vch[pos];\n+    }\n \n     // Comparator implementation.\n-    friend bool operator==(const CPubKey &a, const CPubKey &b) {\n+    friend bool operator==(const CPubKey &a, const CPubKey &b)\n+    {\n         return a.vch[0] == b.vch[0] &&\n                memcmp(a.vch, b.vch, a.size()) == 0;\n     }\n-    friend bool operator!=(const CPubKey &a, const CPubKey &b) {\n+\n+    friend bool operator!=(const CPubKey &a, const CPubKey &b)\n+    {\n         return !(a == b);\n     }\n-    friend bool operator<(const CPubKey &a, const CPubKey &b) {\n+\n+    friend bool operator<(const CPubKey &a, const CPubKey &b)\n+    {\n         return a.vch[0] < b.vch[0] ||\n                (a.vch[0] == b.vch[0] && memcmp(a.vch, b.vch, a.size()) < 0);\n     }\n \n     // Implement serialization, as if this was a byte vector.\n-    unsigned int GetSerializeSize(int nType, int nVersion) const {\n+    unsigned int GetSerializeSize(int nType, int nVersion) const\n+    {\n         return size() + 1;\n     }\n-    template<typename Stream> void Serialize(Stream &s, int nType, int nVersion) const {\n+\n+    template<typename Stream>\n+    void Serialize(Stream &s, int nType, int nVersion) const\n+    {\n         unsigned int len = size();\n+\n         ::WriteCompactSize(s, len);\n         s.write((char*)vch, len);\n     }\n-    template<typename Stream> void Unserialize(Stream &s, int nType, int nVersion) {\n+\n+    template<typename Stream>\n+    void Unserialize(Stream &s, int nType, int nVersion)\n+    {\n         unsigned int len = ::ReadCompactSize(s);\n-        if (len <= 65) {\n+\n+        if (len <= 65)\n+        {\n             s.read((char*)vch, len);\n-        } else {\n+        }\n+        else\n+        {\n             // invalid pubkey, skip available data\n             char dummy;\n+\n             while (len--)\n                 s.read(&dummy, 1);\n+\n             Invalidate();\n         }\n     }\n \n     // Get the KeyID of this public key (hash of its serialization)\n-    CKeyID GetID() const {\n-        return CKeyID(Hash160(vch, vch+size()));\n+    CKeyID GetID() const\n+    {\n+        return CKeyID(Hash160(vch, vch + size()));\n     }\n \n     // Get the 256-bit hash of this public key.\n-    uint256 GetHash() const {\n-        return Hash(vch, vch+size());\n+    uint256 GetHash() const\n+    {\n+        return Hash(vch, vch + size());\n     }\n \n     // Check syntactic correctness.\n     //\n     // Note that this is consensus critical as CheckSig() calls it!\n-    bool IsValid() const {\n+    bool IsValid() const\n+    {\n         return size() > 0;\n     }\n \n     // fully validate whether this is a valid public key (more expensive than IsValid())\n     bool IsFullyValid() const;\n \n     // Check whether this is a compressed public key.\n-    bool IsCompressed() const {\n+    bool IsCompressed() const\n+    {\n         return size() == 33;\n     }\n \n@@ -163,16 +228,17 @@ class CPubKey {\n     bool Decompress();\n \n     // Derive BIP32 child pubkey.\n-    bool Derive(CPubKey& pubkeyChild, unsigned char ccChild[32], unsigned int nChild, const unsigned char cc[32]) const;\n+    bool Derive(CPubKey & pubkeyChild, unsigned char ccChild[32], unsigned int nChild,\n+        const unsigned char cc[32]) const;\n };\n \n-\n // secure_allocator is defined in allocators.h\n // CPrivKey is a serialized private key, with all parameters included (279 bytes)\n typedef std::vector<unsigned char, secure_allocator<unsigned char> > CPrivKey;\n \n /** An encapsulated private key. */\n-class CKey {\n+class CKey\n+{\n private:\n     // Whether this private key is valid. We check for correctness when modifying the key\n     // data, so fValid should always correspond to the actual state.\n@@ -185,56 +251,83 @@ class CKey {\n     unsigned char vch[32];\n \n     // Check whether the 32-byte array pointed to be vch is valid keydata.\n-    bool static Check(const unsigned char *vch);\n+    bool static Check(const unsigned char* vch);\n public:\n \n     // Construct an invalid private key.\n-    CKey() : fValid(false), fCompressed(false) {\n+    CKey() : fValid(false), fCompressed(false)\n+    {\n         LockObject(vch);\n     }\n \n     // Copy constructor. This is necessary because of memlocking.\n-    CKey(const CKey &secret) : fValid(secret.fValid), fCompressed(secret.fCompressed) {\n+    CKey(const CKey &secret) : fValid(secret.fValid), fCompressed(secret.fCompressed)\n+    {\n         LockObject(vch);\n         memcpy(vch, secret.vch, sizeof(vch));\n     }\n \n     // Destructor (again necessary because of memlocking).\n-    ~CKey() {\n+    ~CKey()\n+    {\n         UnlockObject(vch);\n     }\n \n-    friend bool operator==(const CKey &a, const CKey &b) {\n+    friend bool operator==(const CKey &a, const CKey &b)\n+    {\n         return a.fCompressed == b.fCompressed && a.size() == b.size() &&\n                memcmp(&a.vch[0], &b.vch[0], a.size()) == 0;\n     }\n \n     // Initialize using begin and end iterators to byte data.\n     template<typename T>\n-    void Set(const T pbegin, const T pend, bool fCompressedIn) {\n-        if (pend - pbegin != 32) {\n+    void Set(const T pbegin, const T pend, bool fCompressedIn)\n+    {\n+        if (pend - pbegin != 32)\n+        {\n             fValid = false;\n             return;\n         }\n-        if (Check(&pbegin[0])) {\n+\n+        if (Check(&pbegin[0]))\n+        {\n             memcpy(vch, (unsigned char*)&pbegin[0], 32);\n             fValid = true;\n             fCompressed = fCompressedIn;\n-        } else {\n+        }\n+        else\n+        {\n             fValid = false;\n         }\n     }\n \n     // Simple read-only vector-like interface.\n-    unsigned int size() const { return (fValid ? 32 : 0); }\n-    const unsigned char *begin() const { return vch; }\n-    const unsigned char *end() const { return vch + size(); }\n+    unsigned int size() const\n+    {\n+        return (fValid ? 32 : 0);\n+    }\n+\n+    const unsigned char* begin() const\n+    {\n+        return vch;\n+    }\n+\n+    const unsigned char* end() const\n+    {\n+        return vch + size();\n+    }\n \n     // Check whether this private key is valid.\n-    bool IsValid() const { return fValid; }\n+    bool IsValid() const\n+    {\n+        return fValid;\n+    }\n \n     // Check whether the public key corresponding to this private key is (to be) compressed.\n-    bool IsCompressed() const { return fCompressed; }\n+    bool IsCompressed() const\n+    {\n+        return fCompressed;\n+    }\n \n     // Initialize from a CPrivKey (serialized OpenSSL private key data).\n     bool SetPrivKey(const CPrivKey &vchPrivKey, bool fCompressed);\n@@ -261,24 +354,27 @@ class CKey {\n     bool SignCompact(const uint256 &hash, std::vector<unsigned char>& vchSig) const;\n \n     // Derive BIP32 child key.\n-    bool Derive(CKey& keyChild, unsigned char ccChild[32], unsigned int nChild, const unsigned char cc[32]) const;\n+    bool Derive(CKey & keyChild, unsigned char ccChild[32], unsigned int nChild, const unsigned char cc[32]) const;\n \n     // Load private key and check that public key matches.\n     bool Load(CPrivKey &privkey, CPubKey &vchPubKey, bool fSkipCheck);\n \n     // Check whether an element of a signature (r or s) is valid.\n-    static bool CheckSignatureElement(const unsigned char *vch, int len, bool half);\n+    static bool CheckSignatureElement(const unsigned char* vch, int len, bool half);\n };\n \n-struct CExtPubKey {\n+struct CExtPubKey\n+{\n     unsigned char nDepth;\n     unsigned char vchFingerprint[4];\n     unsigned int nChild;\n     unsigned char vchChainCode[32];\n     CPubKey pubkey;\n \n-    friend bool operator==(const CExtPubKey &a, const CExtPubKey &b) {\n-        return a.nDepth == b.nDepth && memcmp(&a.vchFingerprint[0], &b.vchFingerprint[0], 4) == 0 && a.nChild == b.nChild &&\n+    friend bool operator==(const CExtPubKey &a, const CExtPubKey &b)\n+    {\n+        return a.nDepth == b.nDepth &&\n+               memcmp(&a.vchFingerprint[0], &b.vchFingerprint[0], 4) == 0 && a.nChild == b.nChild &&\n                memcmp(&a.vchChainCode[0], &b.vchChainCode[0], 32) == 0 && a.pubkey == b.pubkey;\n     }\n \n@@ -287,26 +383,30 @@ struct CExtPubKey {\n     bool Derive(CExtPubKey &out, unsigned int nChild) const;\n };\n \n-struct CExtKey {\n+struct CExtKey\n+{\n     unsigned char nDepth;\n     unsigned char vchFingerprint[4];\n     unsigned int nChild;\n     unsigned char vchChainCode[32];\n     CKey key;\n \n-    friend bool operator==(const CExtKey &a, const CExtKey &b) {\n-        return a.nDepth == b.nDepth && memcmp(&a.vchFingerprint[0], &b.vchFingerprint[0], 4) == 0 && a.nChild == b.nChild &&\n+    friend bool operator==(const CExtKey &a, const CExtKey &b)\n+    {\n+        return a.nDepth == b.nDepth &&\n+               memcmp(&a.vchFingerprint[0], &b.vchFingerprint[0], 4) == 0 && a.nChild == b.nChild &&\n                memcmp(&a.vchChainCode[0], &b.vchChainCode[0], 32) == 0 && a.key == b.key;\n     }\n \n     void Encode(unsigned char code[74]) const;\n     void Decode(const unsigned char code[74]);\n     bool Derive(CExtKey &out, unsigned int nChild) const;\n     CExtPubKey Neuter() const;\n-    void SetMaster(const unsigned char *seed, unsigned int nSeedLen);\n+    void SetMaster(const unsigned char* seed, unsigned int nSeedLen);\n };\n \n /** Check that required EC support is available at runtime */\n bool ECC_InitSanityCheck(void);\n \n #endif // BITCOIN_KEY_H\n+"
      },
      {
        "sha": "60d2b6497fe9c9e7d70119220b4e2dbfc8792c6b",
        "filename": "src/keystore.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/keystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/keystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -15,13 +15,18 @@\n bool CKeyStore::GetPubKey(const CKeyID &address, CPubKey &vchPubKeyOut) const\n {\n     CKey key;\n+\n     if (!GetKey(address, key))\n+    {\n         return false;\n+    }\n+\n     vchPubKeyOut = key.GetPubKey();\n     return true;\n }\n \n-bool CKeyStore::AddKey(const CKey &key) {\n+bool CKeyStore::AddKey(const CKey &key)\n+{\n     return AddKeyPubKey(key, key.GetPubKey());\n }\n \n@@ -35,7 +40,9 @@ bool CBasicKeyStore::AddKeyPubKey(const CKey& key, const CPubKey &pubkey)\n bool CBasicKeyStore::AddCScript(const CScript& redeemScript)\n {\n     if (redeemScript.size() > MAX_SCRIPT_ELEMENT_SIZE)\n+    {\n         return error(\"CBasicKeyStore::AddCScript() : redeemScripts > %i bytes are invalid\", MAX_SCRIPT_ELEMENT_SIZE);\n+    }\n \n     LOCK(cs_KeyStore);\n     mapScripts[redeemScript.GetID()] = redeemScript;\n@@ -52,11 +59,13 @@ bool CBasicKeyStore::GetCScript(const CScriptID &hash, CScript& redeemScriptOut)\n {\n     LOCK(cs_KeyStore);\n     ScriptMap::const_iterator mi = mapScripts.find(hash);\n+\n     if (mi != mapScripts.end())\n     {\n         redeemScriptOut = (*mi).second;\n         return true;\n     }\n+\n     return false;\n }\n \n@@ -78,3 +87,4 @@ bool CBasicKeyStore::HaveWatchOnly() const\n     LOCK(cs_KeyStore);\n     return (!setWatchOnly.empty());\n }\n+"
      },
      {
        "sha": "fecee70f4b90baf1d33a1a4267387594d8bedc82",
        "filename": "src/keystore.h",
        "status": "modified",
        "additions": 20,
        "deletions": 11,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/keystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/keystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -21,27 +21,29 @@ class CKeyStore\n     mutable CCriticalSection cs_KeyStore;\n \n public:\n-    virtual ~CKeyStore() {}\n+    virtual ~CKeyStore()\n+    {\n+    }\n \n     // Add a key to the store.\n-    virtual bool AddKeyPubKey(const CKey &key, const CPubKey &pubkey) =0;\n+    virtual bool AddKeyPubKey(const CKey &key, const CPubKey &pubkey) = 0;\n     virtual bool AddKey(const CKey &key);\n \n     // Check whether a key corresponding to a given address is present in the store.\n-    virtual bool HaveKey(const CKeyID &address) const =0;\n-    virtual bool GetKey(const CKeyID &address, CKey& keyOut) const =0;\n-    virtual void GetKeys(std::set<CKeyID> &setAddress) const =0;\n+    virtual bool HaveKey(const CKeyID &address) const = 0;\n+    virtual bool GetKey(const CKeyID &address, CKey& keyOut) const = 0;\n+    virtual void GetKeys(std::set<CKeyID> &setAddress) const = 0;\n     virtual bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const;\n \n     // Support for BIP 0013 : see https://github.com/bitcoin/bips/blob/master/bip-0013.mediawiki\n-    virtual bool AddCScript(const CScript& redeemScript) =0;\n-    virtual bool HaveCScript(const CScriptID &hash) const =0;\n-    virtual bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const =0;\n+    virtual bool AddCScript(const CScript& redeemScript) = 0;\n+    virtual bool HaveCScript(const CScriptID &hash) const = 0;\n+    virtual bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const = 0;\n \n     // Support for Watch-only addresses\n-    virtual bool AddWatchOnly(const CScript &dest) =0;\n-    virtual bool HaveWatchOnly(const CScript &dest) const =0;\n-    virtual bool HaveWatchOnly() const =0;\n+    virtual bool AddWatchOnly(const CScript &dest) = 0;\n+    virtual bool HaveWatchOnly(const CScript &dest) const = 0;\n+    virtual bool HaveWatchOnly() const = 0;\n };\n \n typedef std::map<CKeyID, CKey> KeyMap;\n@@ -61,30 +63,35 @@ class CBasicKeyStore : public CKeyStore\n     bool HaveKey(const CKeyID &address) const\n     {\n         bool result;\n+\n         {\n             LOCK(cs_KeyStore);\n             result = (mapKeys.count(address) > 0);\n         }\n         return result;\n     }\n+\n     void GetKeys(std::set<CKeyID> &setAddress) const\n     {\n         setAddress.clear();\n         {\n             LOCK(cs_KeyStore);\n             KeyMap::const_iterator mi = mapKeys.begin();\n+\n             while (mi != mapKeys.end())\n             {\n                 setAddress.insert((*mi).first);\n                 mi++;\n             }\n         }\n     }\n+\n     bool GetKey(const CKeyID &address, CKey &keyOut) const\n     {\n         {\n             LOCK(cs_KeyStore);\n             KeyMap::const_iterator mi = mapKeys.find(address);\n+\n             if (mi != mapKeys.end())\n             {\n                 keyOut = mi->second;\n@@ -93,6 +100,7 @@ class CBasicKeyStore : public CKeyStore\n         }\n         return false;\n     }\n+\n     virtual bool AddCScript(const CScript& redeemScript);\n     virtual bool HaveCScript(const CScriptID &hash) const;\n     virtual bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const;\n@@ -106,3 +114,4 @@ typedef std::vector<unsigned char, secure_allocator<unsigned char> > CKeyingMate\n typedef std::map<CKeyID, std::pair<CPubKey, std::vector<unsigned char> > > CryptedKeyMap;\n \n #endif // BITCOIN_KEYSTORE_H\n+"
      },
      {
        "sha": "01a0e66b9050763e1c46f165e718761db66c5fb2",
        "filename": "src/leveldbwrapper.cpp",
        "status": "modified",
        "additions": 40,
        "deletions": 9,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/leveldbwrapper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/leveldbwrapper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldbwrapper.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -12,59 +12,87 @@\n #include <leveldb/filter_policy.h>\n #include <memenv.h>\n \n-void HandleError(const leveldb::Status &status) throw(leveldb_error) {\n+void HandleError(const leveldb::Status &status) throw(leveldb_error)\n+{\n     if (status.ok())\n+    {\n         return;\n+    }\n+\n     LogPrintf(\"%s\\n\", status.ToString());\n+\n     if (status.IsCorruption())\n+    {\n         throw leveldb_error(\"Database corrupted\");\n+    }\n+\n     if (status.IsIOError())\n+    {\n         throw leveldb_error(\"Database I/O error\");\n+    }\n+\n     if (status.IsNotFound())\n+    {\n         throw leveldb_error(\"Database entry missing\");\n+    }\n+\n     throw leveldb_error(\"Unknown database error\");\n }\n \n-static leveldb::Options GetOptions(size_t nCacheSize) {\n+static leveldb::Options GetOptions(size_t nCacheSize)\n+{\n     leveldb::Options options;\n+\n     options.block_cache = leveldb::NewLRUCache(nCacheSize / 2);\n     options.write_buffer_size = nCacheSize / 4; // up to two write buffers may be held in memory simultaneously\n     options.filter_policy = leveldb::NewBloomFilterPolicy(10);\n     options.compression = leveldb::kNoCompression;\n     options.max_open_files = 64;\n-    if (leveldb::kMajorVersion > 1 || (leveldb::kMajorVersion == 1 && leveldb::kMinorVersion >= 16)) {\n+\n+    if (leveldb::kMajorVersion > 1 || (leveldb::kMajorVersion == 1 && leveldb::kMinorVersion >= 16))\n+    {\n         // LevelDB versions before 1.16 consider short writes to be corruption. Only trigger error\n         // on corruption in later versions.\n         options.paranoid_checks = true;\n     }\n+\n     return options;\n }\n \n-CLevelDBWrapper::CLevelDBWrapper(const boost::filesystem::path &path, size_t nCacheSize, bool fMemory, bool fWipe) {\n+CLevelDBWrapper::CLevelDBWrapper(const boost::filesystem::path &path, size_t nCacheSize, bool fMemory, bool fWipe)\n+{\n     penv = NULL;\n     readoptions.verify_checksums = true;\n     iteroptions.verify_checksums = true;\n     iteroptions.fill_cache = false;\n     syncoptions.sync = true;\n     options = GetOptions(nCacheSize);\n     options.create_if_missing = true;\n-    if (fMemory) {\n+\n+    if (fMemory)\n+    {\n         penv = leveldb::NewMemEnv(leveldb::Env::Default());\n         options.env = penv;\n-    } else {\n-        if (fWipe) {\n+    }\n+    else\n+    {\n+        if (fWipe)\n+        {\n             LogPrintf(\"Wiping LevelDB in %s\\n\", path.string());\n             leveldb::DestroyDB(path.string(), options);\n         }\n+\n         TryCreateDirectory(path);\n         LogPrintf(\"Opening LevelDB in %s\\n\", path.string());\n     }\n+\n     leveldb::Status status = leveldb::DB::Open(options, path.string(), &pdb);\n     HandleError(status);\n     LogPrintf(\"Opened LevelDB successfully\\n\");\n }\n \n-CLevelDBWrapper::~CLevelDBWrapper() {\n+CLevelDBWrapper::~CLevelDBWrapper()\n+{\n     delete pdb;\n     pdb = NULL;\n     delete options.filter_policy;\n@@ -75,8 +103,11 @@ CLevelDBWrapper::~CLevelDBWrapper() {\n     options.env = NULL;\n }\n \n-bool CLevelDBWrapper::WriteBatch(CLevelDBBatch &batch, bool fSync) throw(leveldb_error) {\n+bool CLevelDBWrapper::WriteBatch(CLevelDBBatch &batch, bool fSync) throw(leveldb_error)\n+{\n     leveldb::Status status = pdb->Write(fSync ? syncoptions : writeoptions, &batch.batch);\n+\n     HandleError(status);\n     return true;\n }\n+"
      },
      {
        "sha": "06b2d105019c49f2ef917e0c56933a9292a5268c",
        "filename": "src/leveldbwrapper.h",
        "status": "modified",
        "additions": 56,
        "deletions": 16,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/leveldbwrapper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/leveldbwrapper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldbwrapper.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -16,7 +16,9 @@\n class leveldb_error : public std::runtime_error\n {\n public:\n-    leveldb_error(const std::string &msg) : std::runtime_error(msg) {}\n+    leveldb_error(const std::string &msg) : std::runtime_error(msg)\n+    {\n+    }\n };\n \n void HandleError(const leveldb::Status &status) throw(leveldb_error);\n@@ -30,8 +32,11 @@ class CLevelDBBatch\n     leveldb::WriteBatch batch;\n \n public:\n-    template<typename K, typename V> void Write(const K& key, const V& value) {\n+    template<typename K, typename V>\n+    void Write(const K& key, const V& value)\n+    {\n         CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+\n         ssKey.reserve(ssKey.GetSerializeSize(key));\n         ssKey << key;\n         leveldb::Slice slKey(&ssKey[0], ssKey.size());\n@@ -44,8 +49,11 @@ class CLevelDBBatch\n         batch.Put(slKey, slValue);\n     }\n \n-    template<typename K> void Erase(const K& key) {\n+    template<typename K>\n+    void Erase(const K& key)\n+    {\n         CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+\n         ssKey.reserve(ssKey.GetSerializeSize(key));\n         ssKey << key;\n         leveldb::Slice slKey(&ssKey[0], ssKey.size());\n@@ -58,7 +66,7 @@ class CLevelDBWrapper\n {\n private:\n     // custom environment this database is using (may be NULL in case of default environment)\n-    leveldb::Env *penv;\n+    leveldb::Env* penv;\n \n     // database options used\n     leveldb::Options options;\n@@ -76,80 +84,112 @@ class CLevelDBWrapper\n     leveldb::WriteOptions syncoptions;\n \n     // the database itself\n-    leveldb::DB *pdb;\n+    leveldb::DB* pdb;\n \n public:\n     CLevelDBWrapper(const boost::filesystem::path &path, size_t nCacheSize, bool fMemory = false, bool fWipe = false);\n     ~CLevelDBWrapper();\n \n-    template<typename K, typename V> bool Read(const K& key, V& value) const throw(leveldb_error) {\n+    template<typename K, typename V>\n+    bool Read(const K& key, V& value) const throw(leveldb_error)\n+    {\n         CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+\n         ssKey.reserve(ssKey.GetSerializeSize(key));\n         ssKey << key;\n         leveldb::Slice slKey(&ssKey[0], ssKey.size());\n \n         std::string strValue;\n         leveldb::Status status = pdb->Get(readoptions, slKey, &strValue);\n-        if (!status.ok()) {\n+\n+        if (!status.ok())\n+        {\n             if (status.IsNotFound())\n+            {\n                 return false;\n+            }\n+\n             LogPrintf(\"LevelDB read failure: %s\\n\", status.ToString());\n             HandleError(status);\n         }\n-        try {\n+\n+        try\n+        {\n             CDataStream ssValue(strValue.data(), strValue.data() + strValue.size(), SER_DISK, CLIENT_VERSION);\n             ssValue >> value;\n-        } catch(std::exception &e) {\n+        }\n+        catch (std::exception &e)\n+        {\n             return false;\n         }\n         return true;\n     }\n \n-    template<typename K, typename V> bool Write(const K& key, const V& value, bool fSync = false) throw(leveldb_error) {\n+    template<typename K, typename V>\n+    bool Write(const K& key, const V& value, bool fSync = false) throw(leveldb_error)\n+    {\n         CLevelDBBatch batch;\n+\n         batch.Write(key, value);\n         return WriteBatch(batch, fSync);\n     }\n \n-    template<typename K> bool Exists(const K& key) const throw(leveldb_error) {\n+    template<typename K>\n+    bool Exists(const K& key) const throw(leveldb_error)\n+    {\n         CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+\n         ssKey.reserve(ssKey.GetSerializeSize(key));\n         ssKey << key;\n         leveldb::Slice slKey(&ssKey[0], ssKey.size());\n \n         std::string strValue;\n         leveldb::Status status = pdb->Get(readoptions, slKey, &strValue);\n-        if (!status.ok()) {\n+\n+        if (!status.ok())\n+        {\n             if (status.IsNotFound())\n+            {\n                 return false;\n+            }\n+\n             LogPrintf(\"LevelDB read failure: %s\\n\", status.ToString());\n             HandleError(status);\n         }\n+\n         return true;\n     }\n \n-    template<typename K> bool Erase(const K& key, bool fSync = false) throw(leveldb_error) {\n+    template<typename K>\n+    bool Erase(const K& key, bool fSync = false) throw(leveldb_error)\n+    {\n         CLevelDBBatch batch;\n+\n         batch.Erase(key);\n         return WriteBatch(batch, fSync);\n     }\n \n     bool WriteBatch(CLevelDBBatch &batch, bool fSync = false) throw(leveldb_error);\n \n     // not available for LevelDB; provide for compatibility with BDB\n-    bool Flush() {\n+    bool Flush()\n+    {\n         return true;\n     }\n \n-    bool Sync() throw(leveldb_error) {\n+    bool Sync() throw(leveldb_error)\n+    {\n         CLevelDBBatch batch;\n+\n         return WriteBatch(batch, true);\n     }\n \n     // not exactly clean encapsulation, but it's easiest for now\n-    leveldb::Iterator *NewIterator() {\n+    leveldb::Iterator* NewIterator()\n+    {\n         return pdb->NewIterator(iteroptions);\n     }\n };\n \n #endif // BITCOIN_LEVELDBWRAPPER_H\n+"
      },
      {
        "sha": "16c7f77b16383999fb2976c87485db838287dee2",
        "filename": "src/limitedmap.h",
        "status": "modified",
        "additions": 68,
        "deletions": 9,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/limitedmap.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/limitedmap.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/limitedmap.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -9,7 +9,8 @@\n #include <map>\n \n /** STL-like map container that only keeps the N elements with the highest value. */\n-template <typename K, typename V> class limitedmap\n+template <typename K, typename V>\n+class limitedmap\n {\n public:\n     typedef K key_type;\n@@ -26,76 +27,134 @@ template <typename K, typename V> class limitedmap\n     size_type nMaxSize;\n \n public:\n-    limitedmap(size_type nMaxSizeIn = 0) { nMaxSize = nMaxSizeIn; }\n-    const_iterator begin() const { return map.begin(); }\n-    const_iterator end() const { return map.end(); }\n-    size_type size() const { return map.size(); }\n-    bool empty() const { return map.empty(); }\n-    const_iterator find(const key_type& k) const { return map.find(k); }\n-    size_type count(const key_type& k) const { return map.count(k); }\n+    limitedmap(size_type nMaxSizeIn = 0)\n+    {\n+        nMaxSize = nMaxSizeIn;\n+    }\n+\n+    const_iterator begin() const\n+    {\n+        return map.begin();\n+    }\n+\n+    const_iterator end() const\n+    {\n+        return map.end();\n+    }\n+\n+    size_type size() const\n+    {\n+        return map.size();\n+    }\n+\n+    bool empty() const\n+    {\n+        return map.empty();\n+    }\n+\n+    const_iterator find(const key_type& k) const\n+    {\n+        return map.find(k);\n+    }\n+\n+    size_type count(const key_type& k) const\n+    {\n+        return map.count(k);\n+    }\n+\n     void insert(const value_type& x)\n     {\n         std::pair<iterator, bool> ret = map.insert(x);\n+\n         if (ret.second)\n         {\n             if (nMaxSize && map.size() == nMaxSize)\n             {\n                 map.erase(rmap.begin()->second);\n                 rmap.erase(rmap.begin());\n             }\n+\n             rmap.insert(make_pair(x.second, ret.first));\n         }\n+\n         return;\n     }\n+\n     void erase(const key_type& k)\n     {\n         iterator itTarget = map.find(k);\n+\n         if (itTarget == map.end())\n+        {\n             return;\n+        }\n+\n         std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n+\n         for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n+        {\n             if (it->second == itTarget)\n             {\n                 rmap.erase(it);\n                 map.erase(itTarget);\n                 return;\n             }\n+        }\n+\n         // Shouldn't ever get here\n         assert(0); //TODO remove me\n         map.erase(itTarget);\n     }\n+\n     void update(const_iterator itIn, const mapped_type& v)\n     {\n         //TODO: When we switch to C++11, use map.erase(itIn, itIn) to get the non-const iterator\n         iterator itTarget = map.find(itIn->first);\n+\n         if (itTarget == map.end())\n+        {\n             return;\n+        }\n+\n         std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n+\n         for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n+        {\n             if (it->second == itTarget)\n             {\n                 rmap.erase(it);\n                 itTarget->second = v;\n                 rmap.insert(make_pair(v, itTarget));\n                 return;\n             }\n+        }\n+\n         // Shouldn't ever get here\n         assert(0); //TODO remove me\n         itTarget->second = v;\n         rmap.insert(make_pair(v, itTarget));\n     }\n-    size_type max_size() const { return nMaxSize; }\n+\n+    size_type max_size() const\n+    {\n+        return nMaxSize;\n+    }\n+\n     size_type max_size(size_type s)\n     {\n         if (s)\n+        {\n             while (map.size() > s)\n             {\n                 map.erase(rmap.begin()->second);\n                 rmap.erase(rmap.begin());\n             }\n+        }\n+\n         nMaxSize = s;\n         return nMaxSize;\n     }\n };\n \n #endif // BITCOIN_LIMITEDMAP_H\n+"
      },
      {
        "sha": "46082bccd68adf1513fb226bd61caaf1a10dc9c1",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 2183,
        "deletions": 719,
        "changes": 2902,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "193f20bf89ea19cd8c6ba241e05aaf05495794e4",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 299,
        "deletions": 154,
        "changes": 453,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -46,13 +46,13 @@ static const unsigned int DEFAULT_BLOCK_PRIORITY_SIZE = 50000;\n /** The maximum size for transactions we're willing to relay/mine */\n static const unsigned int MAX_STANDARD_TX_SIZE = 100000;\n /** The maximum allowed number of signature check operations in a block (network rule) */\n-static const unsigned int MAX_BLOCK_SIGOPS = MAX_BLOCK_SIZE/50;\n+static const unsigned int MAX_BLOCK_SIGOPS = MAX_BLOCK_SIZE / 50;\n /** Maxiumum number of signature check operations in an IsStandard() P2SH script */\n static const unsigned int MAX_P2SH_SIGOPS = 15;\n /** The maximum number of sigops we're willing to relay/mine in a single tx */\n-static const unsigned int MAX_TX_SIGOPS = MAX_BLOCK_SIGOPS/5;\n+static const unsigned int MAX_TX_SIGOPS = MAX_BLOCK_SIGOPS / 5;\n /** The maximum number of orphan transactions kept in memory */\n-static const unsigned int MAX_ORPHAN_TRANSACTIONS = MAX_BLOCK_SIZE/100;\n+static const unsigned int MAX_ORPHAN_TRANSACTIONS = MAX_BLOCK_SIZE / 100;\n /** Default for -maxorphanblocks, maximum number of orphan blocks kept in memory */\n static const unsigned int DEFAULT_MAX_ORPHAN_BLOCKS = 750;\n /** The maximum size of a blk?????.dat file (since 0.8) */\n@@ -86,7 +86,10 @@ static const unsigned char REJECT_CHECKPOINT = 0x43;\n \n struct BlockHasher\n {\n-    size_t operator()(const uint256& hash) const { return hash.GetLow64(); }\n+    size_t operator()(const uint256& hash) const\n+    {\n+        return hash.GetLow64();\n+    }\n };\n \n extern CScript COINBASE_FLAGS;\n@@ -111,7 +114,6 @@ extern CFeeRate minRelayTxFee;\n // Minimum disk space required - used in CheckDiskSpace()\n static const uint64_t nMinDiskSpace = 52428800;\n \n-\n class CBlockTreeDB;\n struct CDiskBlockPos;\n class CTxUndo;\n@@ -139,15 +141,15 @@ void UnregisterNodeSignals(CNodeSignals& nodeSignals);\n void PushGetBlocks(CNode* pnode, CBlockIndex* pindexBegin, uint256 hashEnd);\n \n /** Process an incoming block */\n-bool ProcessBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBlockPos *dbp = NULL);\n+bool ProcessBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBlockPos* dbp = NULL);\n /** Check whether enough disk space is available for an incoming block */\n bool CheckDiskSpace(uint64_t nAdditionalBytes = 0);\n /** Open a block file (blk?????.dat) */\n FILE* OpenBlockFile(const CDiskBlockPos &pos, bool fReadOnly = false);\n /** Open an undo file (rev?????.dat) */\n FILE* OpenUndoFile(const CDiskBlockPos &pos, bool fReadOnly = false);\n /** Import blocks from an external file */\n-bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp = NULL);\n+bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos* dbp = NULL);\n /** Initialize a new block tree database + block data on disk */\n bool InitBlockIndex();\n /** Load the block tree and coins database from disk */\n@@ -169,33 +171,28 @@ std::string GetWarnings(std::string strFor);\n /** Retrieve a transaction (from memory pool, or from disk, if possible) */\n bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock, bool fAllowSlow = false);\n /** Find the best known block, and make it the tip of the block chain */\n-bool ActivateBestChain(CValidationState &state, CBlock *pblock = NULL);\n+bool ActivateBestChain(CValidationState &state, CBlock* pblock = NULL);\n int64_t GetBlockValue(int nHeight, int64_t nFees);\n \n /** Create a new block index entry for a given block hash */\n-CBlockIndex * InsertBlockIndex(uint256 hash);\n+CBlockIndex* InsertBlockIndex(uint256 hash);\n /** Verify a signature */\n-bool VerifySignature(const CCoins& txFrom, const CTransaction& txTo, unsigned int nIn, unsigned int flags, int nHashType);\n+bool VerifySignature(const CCoins& txFrom, const CTransaction& txTo, unsigned int nIn, unsigned int flags,\n+    int nHashType);\n /** Abort with a message */\n bool AbortNode(const std::string &msg);\n /** Get statistics from node state */\n bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats);\n /** Increase a node's misbehavior score. */\n void Misbehaving(NodeId nodeid, int howmuch);\n \n-\n /** (try to) add transaction to memory pool **/\n bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransaction &tx, bool fLimitFree,\n-                        bool* pfMissingInputs, bool fRejectInsaneFee=false);\n-\n-\n-\n-\n-\n-\n-\n+    bool* pfMissingInputs,\n+    bool fRejectInsaneFee = false);\n \n-struct CNodeStateStats {\n+struct CNodeStateStats\n+{\n     int nMisbehavior;\n     int nSyncHeight;\n };\n@@ -208,30 +205,43 @@ struct CDiskBlockPos\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n         READWRITE(VARINT(nFile));\n         READWRITE(VARINT(nPos));\n     }\n \n-    CDiskBlockPos() {\n+    CDiskBlockPos()\n+    {\n         SetNull();\n     }\n \n-    CDiskBlockPos(int nFileIn, unsigned int nPosIn) {\n+    CDiskBlockPos(int nFileIn, unsigned int nPosIn)\n+    {\n         nFile = nFileIn;\n         nPos = nPosIn;\n     }\n \n-    friend bool operator==(const CDiskBlockPos &a, const CDiskBlockPos &b) {\n+    friend bool operator==(const CDiskBlockPos &a, const CDiskBlockPos &b)\n+    {\n         return (a.nFile == b.nFile && a.nPos == b.nPos);\n     }\n \n-    friend bool operator!=(const CDiskBlockPos &a, const CDiskBlockPos &b) {\n+    friend bool operator!=(const CDiskBlockPos &a, const CDiskBlockPos &b)\n+    {\n         return !(a == b);\n     }\n \n-    void SetNull() { nFile = -1; nPos = 0; }\n-    bool IsNull() const { return (nFile == -1); }\n+    void SetNull()\n+    {\n+        nFile = -1;\n+        nPos = 0;\n+    }\n+\n+    bool IsNull() const\n+    {\n+        return (nFile == -1);\n+    }\n };\n \n struct CDiskTxPos : public CDiskBlockPos\n@@ -241,25 +251,29 @@ struct CDiskTxPos : public CDiskBlockPos\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n         READWRITE(*(CDiskBlockPos*)this);\n         READWRITE(VARINT(nTxOffset));\n     }\n \n-    CDiskTxPos(const CDiskBlockPos &blockIn, unsigned int nTxOffsetIn) : CDiskBlockPos(blockIn.nFile, blockIn.nPos), nTxOffset(nTxOffsetIn) {\n+    CDiskTxPos(const CDiskBlockPos &blockIn, unsigned int nTxOffsetIn) : CDiskBlockPos(blockIn.nFile,\n+        blockIn.nPos), nTxOffset(nTxOffsetIn)\n+    {\n     }\n \n-    CDiskTxPos() {\n+    CDiskTxPos()\n+    {\n         SetNull();\n     }\n \n-    void SetNull() {\n+    void SetNull()\n+    {\n         CDiskBlockPos::SetNull();\n         nTxOffset = 0;\n     }\n };\n \n-\n int64_t GetMinRelayFee(const CTransaction& tx, unsigned int nBytes, bool fAllowFree);\n \n //\n@@ -277,13 +291,13 @@ int64_t GetMinRelayFee(const CTransaction& tx, unsigned int nBytes, bool fAllowF\n /** Check for standard transaction types\n     @param[in] mapInputs    Map of previous transactions that have outputs we're spending\n     @return True if all inputs (scriptSigs) use only standard transaction forms\n-*/\n+ */\n bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs);\n \n /** Count ECDSA signature operations the old-fashioned (pre-0.6) way\n     @return number of sigops this transaction's outputs will produce when spent\n     @see CTransaction::FetchInputs\n-*/\n+ */\n unsigned int GetLegacySigOpCount(const CTransaction& tx);\n \n /** Count ECDSA signature operations in pay-to-script-hash inputs.\n@@ -294,13 +308,12 @@ unsigned int GetLegacySigOpCount(const CTransaction& tx);\n  */\n unsigned int GetP2SHSigOpCount(const CTransaction& tx, const CCoinsViewCache& mapInputs);\n \n-\n // Check whether all inputs of this transaction are valid (no double spends, scripts & sigs, amounts)\n // This does not modify the UTXO set. If pvChecks is not NULL, script checks are pushed onto it\n // instead of being performed inline.\n-bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &view, bool fScriptChecks = true,\n-                 unsigned int flags = STANDARD_SCRIPT_VERIFY_FLAGS,\n-                 std::vector<CScriptCheck> *pvChecks = NULL);\n+bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &view, bool fScriptChecks =\n+        true, unsigned int flags = STANDARD_SCRIPT_VERIFY_FLAGS,\n+    std::vector<CScriptCheck>* pvChecks = NULL);\n \n // Apply the effects of this transaction on the UTXO set represented by view\n void UpdateCoins(const CTransaction& tx, CValidationState &state, CCoinsViewCache &inputs, CTxUndo &txundo, int nHeight);\n@@ -310,7 +323,7 @@ bool CheckTransaction(const CTransaction& tx, CValidationState& state);\n \n /** Check for standard transaction types\n     @return True if all outputs (scriptPubKeys) use only standard transaction forms\n-*/\n+ */\n bool IsStandardTx(const CTransaction& tx, std::string& reason);\n \n bool IsFinalTx(const CTransaction &tx, int nBlockHeight = 0, int64_t nBlockTime = 0);\n@@ -324,35 +337,42 @@ class CBlockUndo\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n         READWRITE(vtxundo);\n     }\n \n     bool WriteToDisk(CDiskBlockPos &pos, const uint256 &hashBlock);\n     bool ReadFromDisk(const CDiskBlockPos &pos, const uint256 &hashBlock);\n };\n \n-\n /** Closure representing one script verification\n  *  Note that this stores references to the spending transaction */\n class CScriptCheck\n {\n private:\n     CScript scriptPubKey;\n-    const CTransaction *ptxTo;\n+    const CTransaction* ptxTo;\n     unsigned int nIn;\n     unsigned int nFlags;\n     int nHashType;\n \n public:\n-    CScriptCheck(): ptxTo(0), nIn(0), nFlags(0), nHashType(0) {}\n-    CScriptCheck(const CCoins& txFromIn, const CTransaction& txToIn, unsigned int nInIn, unsigned int nFlagsIn, int nHashTypeIn) :\n+    CScriptCheck() : ptxTo(0), nIn(0), nFlags(0), nHashType(0)\n+    {\n+    }\n+\n+    CScriptCheck(const CCoins& txFromIn, const CTransaction& txToIn, unsigned int nInIn, unsigned int nFlagsIn,\n+        int nHashTypeIn) :\n         scriptPubKey(txFromIn.vout[txToIn.vin[nInIn].prevout.n].scriptPubKey),\n-        ptxTo(&txToIn), nIn(nInIn), nFlags(nFlagsIn), nHashType(nHashTypeIn) { }\n+        ptxTo(&txToIn), nIn(nInIn), nFlags(nFlagsIn), nHashType(nHashTypeIn)\n+    {\n+    }\n \n     bool operator()() const;\n \n-    void swap(CScriptCheck &check) {\n+    void swap(CScriptCheck &check)\n+    {\n         scriptPubKey.swap(check.scriptPubKey);\n         std::swap(ptxTo, check.ptxTo);\n         std::swap(nIn, check.nIn);\n@@ -411,41 +431,57 @@ class CPartialMerkleTree\n     bool fBad;\n \n     // helper function to efficiently calculate the number of nodes at given height in the merkle tree\n-    unsigned int CalcTreeWidth(int height) {\n-        return (nTransactions+(1 << height)-1) >> height;\n+    unsigned int CalcTreeWidth(int height)\n+    {\n+        return (nTransactions + (1 << height) - 1) >> height;\n     }\n \n     // calculate the hash of a node in the merkle tree (at leaf level: the txid's themself)\n     uint256 CalcHash(int height, unsigned int pos, const std::vector<uint256> &vTxid);\n \n     // recursive function that traverses tree nodes, storing the data as bits and hashes\n-    void TraverseAndBuild(int height, unsigned int pos, const std::vector<uint256> &vTxid, const std::vector<bool> &vMatch);\n+    void TraverseAndBuild(int height, unsigned int pos, const std::vector<uint256> &vTxid,\n+        const std::vector<bool> &vMatch);\n \n     // recursive function that traverses tree nodes, consuming the bits and hashes produced by TraverseAndBuild.\n     // it returns the hash of the respective node.\n-    uint256 TraverseAndExtract(int height, unsigned int pos, unsigned int &nBitsUsed, unsigned int &nHashUsed, std::vector<uint256> &vMatch);\n+    uint256 TraverseAndExtract(int height, unsigned int pos, unsigned int &nBitsUsed, unsigned int &nHashUsed,\n+        std::vector<uint256> &vMatch);\n \n public:\n \n     // serialization implementation\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n         READWRITE(nTransactions);\n         READWRITE(vHash);\n         std::vector<unsigned char> vBytes;\n-        if (ser_action.ForRead()) {\n+\n+        if (ser_action.ForRead())\n+        {\n             READWRITE(vBytes);\n             CPartialMerkleTree &us = *(const_cast<CPartialMerkleTree*>(this));\n             us.vBits.resize(vBytes.size() * 8);\n+\n             for (unsigned int p = 0; p < us.vBits.size(); p++)\n+            {\n                 us.vBits[p] = (vBytes[p / 8] & (1 << (p % 8))) != 0;\n+            }\n+\n             us.fBad = false;\n-        } else {\n-            vBytes.resize((vBits.size()+7)/8);\n+        }\n+        else\n+        {\n+            vBytes.resize((vBits.size() + 7) / 8);\n+\n             for (unsigned int p = 0; p < vBits.size(); p++)\n+            {\n                 vBytes[p / 8] |= vBits[p] << (p % 8);\n+            }\n+\n             READWRITE(vBytes);\n         }\n     }\n@@ -460,24 +496,23 @@ class CPartialMerkleTree\n     uint256 ExtractMatches(std::vector<uint256> &vMatch);\n };\n \n-\n-\n /** Functions for disk access for blocks */\n bool WriteBlockToDisk(CBlock& block, CDiskBlockPos& pos);\n bool ReadBlockFromDisk(CBlock& block, const CDiskBlockPos& pos);\n bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex);\n \n-\n /** Functions for validating blocks and updating the block tree */\n \n /** Undo the effects of this block (with given index) on the UTXO set represented by coins.\n  *  In case pfClean is provided, operation will try to be tolerant about errors, and *pfClean\n  *  will be true if no problems were found. Otherwise, the return value will be false in case\n  *  of problems. Note that in any case, coins may be modified. */\n-bool DisconnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, CCoinsViewCache& coins, bool* pfClean = NULL);\n+bool DisconnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, CCoinsViewCache& coins,\n+    bool* pfClean = NULL);\n \n // Apply the effects of this block (with given index) on the UTXO set represented by coins\n-bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, CCoinsViewCache& coins, bool fJustCheck = false);\n+bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, CCoinsViewCache& coins,\n+    bool fJustCheck = false);\n \n // Add this block to the block index, and if necessary, switch the active block chain to this\n bool AddToBlockIndex(CBlock& block, CValidationState& state, const CDiskBlockPos& pos);\n@@ -488,10 +523,8 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW = t\n \n // Store block on disk\n // if dbp is provided, the file is known to already reside on disk\n-bool AcceptBlock(CBlock& block, CValidationState& state, CBlockIndex **pindex, CDiskBlockPos* dbp = NULL);\n-bool AcceptBlockHeader(CBlockHeader& block, CValidationState& state, CBlockIndex **ppindex= NULL);\n-\n-\n+bool AcceptBlock(CBlock& block, CValidationState& state, CBlockIndex* * pindex, CDiskBlockPos* dbp = NULL);\n+bool AcceptBlockHeader(CBlockHeader& block, CValidationState& state, CBlockIndex* * ppindex = NULL);\n \n class CBlockFileInfo\n {\n@@ -507,7 +540,8 @@ class CBlockFileInfo\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n         READWRITE(VARINT(nBlocks));\n         READWRITE(VARINT(nSize));\n         READWRITE(VARINT(nUndoSize));\n@@ -517,45 +551,61 @@ class CBlockFileInfo\n         READWRITE(VARINT(nTimeLast));\n     }\n \n-     void SetNull() {\n-         nBlocks = 0;\n-         nSize = 0;\n-         nUndoSize = 0;\n-         nHeightFirst = 0;\n-         nHeightLast = 0;\n-         nTimeFirst = 0;\n-         nTimeLast = 0;\n-     }\n-\n-     CBlockFileInfo() {\n-         SetNull();\n-     }\n-\n-     std::string ToString() const;\n-\n-     // update statistics (does not update nSize)\n-     void AddBlock(unsigned int nHeightIn, uint64_t nTimeIn) {\n-         if (nBlocks==0 || nHeightFirst > nHeightIn)\n-             nHeightFirst = nHeightIn;\n-         if (nBlocks==0 || nTimeFirst > nTimeIn)\n-             nTimeFirst = nTimeIn;\n-         nBlocks++;\n-         if (nHeightIn > nHeightLast)\n-             nHeightLast = nHeightIn;\n-         if (nTimeIn > nTimeLast)\n-             nTimeLast = nTimeIn;\n-     }\n+    void SetNull()\n+    {\n+        nBlocks = 0;\n+        nSize = 0;\n+        nUndoSize = 0;\n+        nHeightFirst = 0;\n+        nHeightLast = 0;\n+        nTimeFirst = 0;\n+        nTimeLast = 0;\n+    }\n+\n+    CBlockFileInfo()\n+    {\n+        SetNull();\n+    }\n+\n+    std::string ToString() const;\n+\n+    // update statistics (does not update nSize)\n+    void AddBlock(unsigned int nHeightIn, uint64_t nTimeIn)\n+    {\n+        if (nBlocks == 0 || nHeightFirst > nHeightIn)\n+        {\n+            nHeightFirst = nHeightIn;\n+        }\n+\n+        if (nBlocks == 0 || nTimeFirst > nTimeIn)\n+        {\n+            nTimeFirst = nTimeIn;\n+        }\n+\n+        nBlocks++;\n+\n+        if (nHeightIn > nHeightLast)\n+        {\n+            nHeightLast = nHeightIn;\n+        }\n+\n+        if (nTimeIn > nTimeLast)\n+        {\n+            nTimeLast = nTimeIn;\n+        }\n+    }\n };\n \n-enum BlockStatus {\n+enum BlockStatus\n+{\n     BLOCK_VALID_UNKNOWN      =    0,\n     BLOCK_VALID_HEADER       =    1, // parsed, version ok, hash satisfies claimed PoW, 1 <= vtx count <= max, timestamp not in future\n     BLOCK_VALID_TREE         =    2, // parent found, difficulty matches, timestamp >= median previous, checkpoint\n     BLOCK_VALID_TRANSACTIONS =    3, // only first tx is coinbase, 2 <= coinbase input script length <= 100, transactions valid, no duplicate txids, sigops, size, merkle root\n     BLOCK_VALID_CHAIN        =    4, // outputs do not overspend inputs, no double spends, coinbase output ok, immature coinbase spends, BIP30\n     BLOCK_VALID_SCRIPTS      =    5, // scripts/signatures ok\n     BLOCK_VALID_MASK         =   BLOCK_VALID_HEADER | BLOCK_VALID_TREE | BLOCK_VALID_TRANSACTIONS |\n-                                 BLOCK_VALID_CHAIN | BLOCK_VALID_SCRIPTS,\n+        BLOCK_VALID_CHAIN | BLOCK_VALID_SCRIPTS,\n \n     BLOCK_HAVE_DATA          =    8, // full block available in blk*.dat\n     BLOCK_HAVE_UNDO          =   16, // undo data available in rev*.dat\n@@ -656,30 +706,43 @@ class CBlockIndex\n         nNonce         = block.nNonce;\n     }\n \n-    CDiskBlockPos GetBlockPos() const {\n+    CDiskBlockPos GetBlockPos() const\n+    {\n         CDiskBlockPos ret;\n-        if (nStatus & BLOCK_HAVE_DATA) {\n+\n+        if (nStatus & BLOCK_HAVE_DATA)\n+        {\n             ret.nFile = nFile;\n             ret.nPos  = nDataPos;\n         }\n+\n         return ret;\n     }\n \n-    CDiskBlockPos GetUndoPos() const {\n+    CDiskBlockPos GetUndoPos() const\n+    {\n         CDiskBlockPos ret;\n-        if (nStatus & BLOCK_HAVE_UNDO) {\n+\n+        if (nStatus & BLOCK_HAVE_UNDO)\n+        {\n             ret.nFile = nFile;\n             ret.nPos  = nUndoPos;\n         }\n+\n         return ret;\n     }\n \n     CBlockHeader GetBlockHeader() const\n     {\n         CBlockHeader block;\n+\n         block.nVersion       = nVersion;\n+\n         if (pprev)\n+        {\n             block.hashPrevBlock = pprev->GetBlockHash();\n+        }\n+\n         block.hashMerkleRoot = hashMerkleRoot;\n         block.nTime          = nTime;\n         block.nBits          = nBits;\n@@ -702,7 +765,10 @@ class CBlockIndex\n         return GetProofIncrement(nBits);\n     }\n \n-    enum { nMedianTimeSpan=11 };\n+    enum\n+    {\n+        nMedianTimeSpan = 11\n+    };\n \n     int64_t GetMedianTimePast() const\n     {\n@@ -711,20 +777,22 @@ class CBlockIndex\n         int64_t* pend = &pmedian[nMedianTimeSpan];\n \n         const CBlockIndex* pindex = this;\n+\n         for (int i = 0; i < nMedianTimeSpan && pindex; i++, pindex = pindex->pprev)\n+        {\n             *(--pbegin) = pindex->GetBlockTime();\n+        }\n \n         std::sort(pbegin, pend);\n-        return pbegin[(pend - pbegin)/2];\n+        return pbegin[(pend - pbegin) / 2];\n     }\n \n     /**\n      * Returns true if there are nRequired or more blocks of minVersion or above\n-     * in the last Params().ToCheckBlockUpgradeMajority() blocks, starting at pstart \n+     * in the last Params().ToCheckBlockUpgradeMajority() blocks, starting at pstart\n      * and going backwards.\n      */\n-    static bool IsSuperMajority(int minVersion, const CBlockIndex* pstart,\n-                                unsigned int nRequired);\n+    static bool IsSuperMajority(int minVersion, const CBlockIndex* pstart, unsigned int nRequired);\n \n     std::string ToString() const\n     {\n@@ -738,8 +806,12 @@ class CBlockIndex\n     bool IsValid(enum BlockStatus nUpTo = BLOCK_VALID_TRANSACTIONS) const\n     {\n         assert(!(nUpTo & ~BLOCK_VALID_MASK)); // Only validity flags allowed.\n+\n         if (nStatus & BLOCK_FAILED_MASK)\n+        {\n             return false;\n+        }\n+\n         return ((nStatus & BLOCK_VALID_MASK) >= nUpTo);\n     }\n \n@@ -748,12 +820,18 @@ class CBlockIndex\n     bool RaiseValidity(enum BlockStatus nUpTo)\n     {\n         assert(!(nUpTo & ~BLOCK_VALID_MASK)); // Only validity flags allowed.\n+\n         if (nStatus & BLOCK_FAILED_MASK)\n+        {\n             return false;\n-        if ((nStatus & BLOCK_VALID_MASK) < nUpTo) {\n+        }\n+\n+        if ((nStatus & BLOCK_VALID_MASK) < nUpTo)\n+        {\n             nStatus = (nStatus & ~BLOCK_VALID_MASK) | nUpTo;\n             return true;\n         }\n+\n         return false;\n     }\n \n@@ -771,30 +849,44 @@ class CDiskBlockIndex : public CBlockIndex\n public:\n     uint256 hashPrev;\n \n-    CDiskBlockIndex() {\n+    CDiskBlockIndex()\n+    {\n         hashPrev = 0;\n     }\n \n-    explicit CDiskBlockIndex(CBlockIndex* pindex) : CBlockIndex(*pindex) {\n+    explicit CDiskBlockIndex(CBlockIndex* pindex) : CBlockIndex(*pindex)\n+    {\n         hashPrev = (pprev ? pprev->GetBlockHash() : 0);\n     }\n \n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n         if (!(nType & SER_GETHASH))\n+        {\n             READWRITE(VARINT(nVersion));\n+        }\n \n         READWRITE(VARINT(nHeight));\n         READWRITE(VARINT(nStatus));\n         READWRITE(VARINT(nTx));\n+\n         if (nStatus & (BLOCK_HAVE_DATA | BLOCK_HAVE_UNDO))\n+        {\n             READWRITE(VARINT(nFile));\n+        }\n+\n         if (nStatus & BLOCK_HAVE_DATA)\n+        {\n             READWRITE(VARINT(nDataPos));\n+        }\n+\n         if (nStatus & BLOCK_HAVE_UNDO)\n+        {\n             READWRITE(VARINT(nUndoPos));\n+        }\n \n         // block header\n         READWRITE(this->nVersion);\n@@ -808,6 +900,7 @@ class CDiskBlockIndex : public CBlockIndex\n     uint256 GetBlockHash() const\n     {\n         CBlockHeader block;\n+\n         block.nVersion        = nVersion;\n         block.hashPrevBlock   = hashPrev;\n         block.hashMerkleRoot  = hashMerkleRoot;\n@@ -817,10 +910,10 @@ class CDiskBlockIndex : public CBlockIndex\n         return block.GetHash();\n     }\n \n-\n     std::string ToString() const\n     {\n         std::string str = \"CDiskBlockIndex(\";\n+\n         str += CBlockIndex::ToString();\n         str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s)\",\n             GetBlockHash().ToString(),\n@@ -830,9 +923,11 @@ class CDiskBlockIndex : public CBlockIndex\n };\n \n /** Capture information about block/transaction validation */\n-class CValidationState {\n+class CValidationState\n+{\n private:\n-    enum mode_state {\n+    enum mode_state\n+    {\n         MODE_VALID,   // everything ok\n         MODE_INVALID, // network rule violation (DoS value may be set)\n         MODE_ERROR,   // run-time error\n@@ -842,132 +937,185 @@ class CValidationState {\n     unsigned char chRejectCode;\n     bool corruptionPossible;\n public:\n-    CValidationState() : mode(MODE_VALID), nDoS(0), chRejectCode(0), corruptionPossible(false) {}\n+    CValidationState() : mode(MODE_VALID), nDoS(0), chRejectCode(0), corruptionPossible(false)\n+    {\n+    }\n+\n     bool DoS(int level, bool ret = false,\n-             unsigned char chRejectCodeIn=0, std::string strRejectReasonIn=\"\",\n-             bool corruptionIn=false) {\n+        unsigned char chRejectCodeIn = 0, std::string strRejectReasonIn = \"\",\n+        bool corruptionIn = false)\n+    {\n         chRejectCode = chRejectCodeIn;\n         strRejectReason = strRejectReasonIn;\n         corruptionPossible = corruptionIn;\n+\n         if (mode == MODE_ERROR)\n+        {\n             return ret;\n+        }\n+\n         nDoS += level;\n         mode = MODE_INVALID;\n         return ret;\n     }\n+\n     bool Invalid(bool ret = false,\n-                 unsigned char _chRejectCode=0, std::string _strRejectReason=\"\") {\n+        unsigned char _chRejectCode = 0, std::string _strRejectReason = \"\")\n+    {\n         return DoS(0, ret, _chRejectCode, _strRejectReason);\n     }\n-    bool Error(std::string strRejectReasonIn=\"\") {\n+\n+    bool Error(std::string strRejectReasonIn = \"\")\n+    {\n         if (mode == MODE_VALID)\n+        {\n             strRejectReason = strRejectReasonIn;\n+        }\n+\n         mode = MODE_ERROR;\n         return false;\n     }\n-    bool Abort(const std::string &msg) {\n+\n+    bool Abort(const std::string &msg)\n+    {\n         AbortNode(msg);\n         return Error(msg);\n     }\n-    bool IsValid() const {\n+\n+    bool IsValid() const\n+    {\n         return mode == MODE_VALID;\n     }\n-    bool IsInvalid() const {\n+\n+    bool IsInvalid() const\n+    {\n         return mode == MODE_INVALID;\n     }\n-    bool IsError() const {\n+\n+    bool IsError() const\n+    {\n         return mode == MODE_ERROR;\n     }\n-    bool IsInvalid(int &nDoSOut) const {\n-        if (IsInvalid()) {\n+\n+    bool IsInvalid(int &nDoSOut) const\n+    {\n+        if (IsInvalid())\n+        {\n             nDoSOut = nDoS;\n             return true;\n         }\n+\n         return false;\n     }\n-    bool CorruptionPossible() const {\n+\n+    bool CorruptionPossible() const\n+    {\n         return corruptionPossible;\n     }\n-    unsigned char GetRejectCode() const { return chRejectCode; }\n-    std::string GetRejectReason() const { return strRejectReason; }\n+\n+    unsigned char GetRejectCode() const\n+    {\n+        return chRejectCode;\n+    }\n+\n+    std::string GetRejectReason() const\n+    {\n+        return strRejectReason;\n+    }\n };\n \n /** RAII wrapper for VerifyDB: Verify consistency of the block and coin databases */\n-class CVerifyDB {\n+class CVerifyDB\n+{\n public:\n     CVerifyDB();\n     ~CVerifyDB();\n-    bool VerifyDB(CCoinsView *coinsview, int nCheckLevel, int nCheckDepth);\n+    bool VerifyDB(CCoinsView* coinsview, int nCheckLevel, int nCheckDepth);\n };\n \n /** An in-memory indexed chain of blocks. */\n-class CChain {\n+class CChain\n+{\n private:\n     std::vector<CBlockIndex*> vChain;\n \n public:\n     /** Returns the index entry for the genesis block of this chain, or NULL if none. */\n-    CBlockIndex *Genesis() const {\n+    CBlockIndex* Genesis() const\n+    {\n         return vChain.size() > 0 ? vChain[0] : NULL;\n     }\n \n     /** Returns the index entry for the tip of this chain, or NULL if none. */\n-    CBlockIndex *Tip() const {\n+    CBlockIndex* Tip() const\n+    {\n         return vChain.size() > 0 ? vChain[vChain.size() - 1] : NULL;\n     }\n \n     /** Returns the index entry at a particular height in this chain, or NULL if no such height exists. */\n-    CBlockIndex *operator[](int nHeight) const {\n+    CBlockIndex* operator[](int nHeight) const\n+    {\n         if (nHeight < 0 || nHeight >= (int)vChain.size())\n+        {\n             return NULL;\n+        }\n+\n         return vChain[nHeight];\n     }\n \n     /** Compare two chains efficiently. */\n-    friend bool operator==(const CChain &a, const CChain &b) {\n+    friend bool operator==(const CChain &a, const CChain &b)\n+    {\n         return a.vChain.size() == b.vChain.size() &&\n                a.vChain[a.vChain.size() - 1] == b.vChain[b.vChain.size() - 1];\n     }\n \n     /** Efficiently check whether a block is present in this chain. */\n-    bool Contains(const CBlockIndex *pindex) const {\n+    bool Contains(const CBlockIndex* pindex) const\n+    {\n         return (*this)[pindex->nHeight] == pindex;\n     }\n \n     /** Find the successor of a block in this chain, or NULL if the given index is not found or is the tip. */\n-    CBlockIndex *Next(const CBlockIndex *pindex) const {\n+    CBlockIndex* Next(const CBlockIndex* pindex) const\n+    {\n         if (Contains(pindex))\n+        {\n             return (*this)[pindex->nHeight + 1];\n+        }\n         else\n+        {\n             return NULL;\n+        }\n     }\n \n     /** Return the maximal height in the chain. Is equal to chain.Tip() ? chain.Tip()->nHeight : -1. */\n-    int Height() const {\n+    int Height() const\n+    {\n         return vChain.size() - 1;\n     }\n \n     /** Set/initialize a chain with a given tip. Returns the forking point. */\n-    CBlockIndex *SetTip(CBlockIndex *pindex);\n+    CBlockIndex* SetTip(CBlockIndex* pindex);\n \n     /** Return a CBlockLocator that refers to a block in this chain (by default the tip). */\n-    CBlockLocator GetLocator(const CBlockIndex *pindex = NULL) const;\n+    CBlockLocator GetLocator(const CBlockIndex* pindex = NULL) const;\n \n     /** Find the last common block between this chain and a locator. */\n-    CBlockIndex *FindFork(const CBlockLocator &locator) const;\n+    CBlockIndex* FindFork(const CBlockLocator &locator) const;\n \n     /** Find the last common block between this chain and a block index entry. */\n-    const CBlockIndex *FindFork(const CBlockIndex *pindex) const;\n+    const CBlockIndex* FindFork(const CBlockIndex* pindex) const;\n };\n \n /** The currently-connected chain of blocks. */\n extern CChain chainActive;\n \n /** Global variable that points to the active CCoinsView (protected by cs_main) */\n-extern CCoinsViewCache *pcoinsTip;\n+extern CCoinsViewCache* pcoinsTip;\n \n /** Global variable that points to the active block tree (protected by cs_main) */\n-extern CBlockTreeDB *pblocktree;\n+extern CBlockTreeDB* pblocktree;\n \n struct CBlockTemplate\n {\n@@ -976,11 +1124,6 @@ struct CBlockTemplate\n     std::vector<int64_t> vTxSigOps;\n };\n \n-\n-\n-\n-\n-\n /** Used to relay blocks as header + vector<merkle branch>\n  * to filtered nodes.\n  */\n@@ -1004,24 +1147,26 @@ class CMerkleBlock\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n         READWRITE(header);\n         READWRITE(txn);\n     }\n };\n \n-\n-class CWalletInterface {\n+class CWalletInterface\n+{\n protected:\n-    virtual void SyncTransaction(const CTransaction &tx, const CBlock *pblock) =0;\n-    virtual void EraseFromWallet(const uint256 &hash) =0;\n-    virtual void SetBestChain(const CBlockLocator &locator) =0;\n-    virtual void UpdatedTransaction(const uint256 &hash) =0;\n-    virtual void Inventory(const uint256 &hash) =0;\n-    virtual void ResendWalletTransactions() =0;\n+    virtual void SyncTransaction(const CTransaction &tx, const CBlock* pblock) = 0;\n+    virtual void EraseFromWallet(const uint256 &hash) = 0;\n+    virtual void SetBestChain(const CBlockLocator &locator) = 0;\n+    virtual void UpdatedTransaction(const uint256 &hash) = 0;\n+    virtual void Inventory(const uint256 &hash) = 0;\n+    virtual void ResendWalletTransactions() = 0;\n     friend void ::RegisterWallet(CWalletInterface*);\n     friend void ::UnregisterWallet(CWalletInterface*);\n     friend void ::UnregisterAllWallets();\n };\n \n #endif // BITCOIN_MAIN_H\n+"
      },
      {
        "sha": "85afafbb1d3ba466e5b026e53a1b35e955254abe",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 142,
        "deletions": 26,
        "changes": 168,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -56,20 +56,28 @@ class TxPriorityCompare\n     bool byFee;\n \n public:\n-    TxPriorityCompare(bool _byFee) : byFee(_byFee) { }\n+    TxPriorityCompare(bool _byFee) : byFee(_byFee)\n+    {\n+    }\n \n     bool operator()(const TxPriority& a, const TxPriority& b)\n     {\n         if (byFee)\n         {\n             if (a.get<1>() == b.get<1>())\n+            {\n                 return a.get<0>() < b.get<0>();\n+            }\n+\n             return a.get<1>() < b.get<1>();\n         }\n         else\n         {\n             if (a.get<0>() == b.get<0>())\n+            {\n                 return a.get<1>() < b.get<1>();\n+            }\n+\n             return a.get<0>() < b.get<0>();\n         }\n     }\n@@ -79,9 +87,13 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n {\n     // Create new block\n     auto_ptr<CBlockTemplate> pblocktemplate(new CBlockTemplate());\n-    if(!pblocktemplate.get())\n+\n+    if (!pblocktemplate.get())\n+    {\n         return NULL;\n-    CBlock *pblock = &pblocktemplate->block; // pointer for convenience\n+    }\n+\n+    CBlock* pblock = &pblocktemplate->block; // pointer for convenience\n \n     // Create coinbase tx\n     CMutableTransaction txNew;\n@@ -98,7 +110,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n     // Largest block you're willing to create:\n     unsigned int nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n     // Limit to betweeen 1K and MAX_BLOCK_SIZE-1K for sanity:\n-    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));\n+    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE - 1000), nBlockMaxSize));\n \n     // How much of the block should be dedicated to high-priority transactions,\n     // included regardless of the fees they pay\n@@ -126,18 +138,23 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n         // This vector will be sorted into a priority queue:\n         vector<TxPriority> vecPriority;\n         vecPriority.reserve(mempool.mapTx.size());\n+\n         for (map<uint256, CTxMemPoolEntry>::iterator mi = mempool.mapTx.begin();\n-             mi != mempool.mapTx.end(); ++mi)\n+            mi != mempool.mapTx.end(); ++mi)\n         {\n             const CTransaction& tx = mi->second.GetTx();\n+\n             if (tx.IsCoinBase() || !IsFinalTx(tx, pindexPrev->nHeight + 1))\n+            {\n                 continue;\n+            }\n \n             COrphan* porphan = NULL;\n             double dPriority = 0;\n             int64_t nTotalIn = 0;\n             bool fMissingInputs = false;\n-            BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+\n+            BOOST_FOREACH (const CTxIn& txin, tx.vin)\n             {\n                 // Read prev transaction\n                 if (!view.HaveCoins(txin.prevout.hash))\n@@ -148,10 +165,19 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n                     if (!mempool.mapTx.count(txin.prevout.hash))\n                     {\n                         LogPrintf(\"ERROR: mempool transaction missing input\\n\");\n-                        if (fDebug) assert(\"mempool transaction missing input\" == 0);\n+\n+                        if (fDebug)\n+                        {\n+                            assert(\"mempool transaction missing input\" == 0);\n+                        }\n+\n                         fMissingInputs = true;\n+\n                         if (porphan)\n+                        {\n                             vOrphan.pop_back();\n+                        }\n+\n                         break;\n                     }\n \n@@ -162,11 +188,13 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n                         vOrphan.push_back(COrphan(&tx));\n                         porphan = &vOrphan.back();\n                     }\n+\n                     mapDependers[txin.prevout.hash].push_back(porphan);\n                     porphan->setDependsOn.insert(txin.prevout.hash);\n                     nTotalIn += mempool.mapTx[txin.prevout.hash].GetTx().vout[txin.prevout.n].nValue;\n                     continue;\n                 }\n+\n                 const CCoins* coins = view.AccessCoins(txin.prevout.hash);\n                 assert(coins);\n \n@@ -177,7 +205,11 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n \n                 dPriority += (double)nValueIn * nConf;\n             }\n-            if (fMissingInputs) continue;\n+\n+            if (fMissingInputs)\n+            {\n+                continue;\n+            }\n \n             // Priority is sum(valuein * age) / modified_txsize\n             unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n@@ -186,15 +218,17 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n             uint256 hash = tx.GetHash();\n             mempool.ApplyDeltas(hash, dPriority, nTotalIn);\n \n-            CFeeRate feeRate(nTotalIn-tx.GetValueOut(), nTxSize);\n+            CFeeRate feeRate(nTotalIn - tx.GetValueOut(), nTxSize);\n \n             if (porphan)\n             {\n                 porphan->dPriority = dPriority;\n                 porphan->feeRate = feeRate;\n             }\n             else\n+            {\n                 vecPriority.push_back(TxPriority(dPriority, feeRate, &mi->second.GetTx()));\n+            }\n         }\n \n         // Collect transactions into block\n@@ -218,21 +252,31 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n \n             // Size limits\n             unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n+\n             if (nBlockSize + nTxSize >= nBlockMaxSize)\n+            {\n                 continue;\n+            }\n \n             // Legacy limits on sigOps:\n             unsigned int nTxSigOps = GetLegacySigOpCount(tx);\n+\n             if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n+            {\n                 continue;\n+            }\n \n             // Skip free transactions if we're past the minimum block size:\n             const uint256& hash = tx.GetHash();\n             double dPriorityDelta = 0;\n             int64_t nFeeDelta = 0;\n             mempool.ApplyDeltas(hash, dPriorityDelta, nFeeDelta);\n-            if (fSortedByFee && (dPriorityDelta <= 0) && (nFeeDelta <= 0) && (feeRate < ::minRelayTxFee) && (nBlockSize + nTxSize >= nBlockMinSize))\n+\n+            if (fSortedByFee && (dPriorityDelta <= 0) && (nFeeDelta <= 0) && (feeRate < ::minRelayTxFee) &&\n+                (nBlockSize + nTxSize >= nBlockMinSize))\n+            {\n                 continue;\n+            }\n \n             // Prioritise by fee once past the priority size or we run out of high-priority\n             // transactions:\n@@ -245,23 +289,31 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n             }\n \n             if (!view.HaveInputs(tx))\n+            {\n                 continue;\n+            }\n \n-            int64_t nTxFees = view.GetValueIn(tx)-tx.GetValueOut();\n+            int64_t nTxFees = view.GetValueIn(tx) - tx.GetValueOut();\n \n             nTxSigOps += GetP2SHSigOpCount(tx, view);\n+\n             if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n+            {\n                 continue;\n+            }\n \n             // Note that flags: we don't want to set mempool/IsStandard()\n             // policy here, but we still have to ensure that the block we\n             // create only contains transactions that are valid in new blocks.\n             CValidationState state;\n+\n             if (!CheckInputs(tx, state, view, true, MANDATORY_SCRIPT_VERIFY_FLAGS))\n+            {\n                 continue;\n+            }\n \n             CTxUndo txundo;\n-            UpdateCoins(tx, state, view, txundo, pindexPrev->nHeight+1);\n+            UpdateCoins(tx, state, view, txundo, pindexPrev->nHeight + 1);\n \n             // Added\n             pblock->vtx.push_back(tx);\n@@ -281,11 +333,12 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n             // Add transactions that depend on this one to the priority queue\n             if (mapDependers.count(hash))\n             {\n-                BOOST_FOREACH(COrphan* porphan, mapDependers[hash])\n+                BOOST_FOREACH (COrphan* porphan, mapDependers[hash])\n                 {\n                     if (!porphan->setDependsOn.empty())\n                     {\n                         porphan->setDependsOn.erase(hash);\n+\n                         if (porphan->setDependsOn.empty())\n                         {\n                             vecPriority.push_back(TxPriority(porphan->dPriority, porphan->feeRate, porphan->ptx));\n@@ -301,7 +354,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n         LogPrintf(\"CreateNewBlock(): total size %u\\n\", nBlockSize);\n \n         // Compute final coinbase transaction.\n-        txNew.vout[0].nValue = GetBlockValue(pindexPrev->nHeight+1, nFees);\n+        txNew.vout[0].nValue = GetBlockValue(pindexPrev->nHeight + 1, nFees);\n         txNew.vin[0].scriptSig = CScript() << OP_0 << OP_0;\n         pblock->vtx[0] = txNew;\n         pblocktemplate->vTxFees[0] = -nFees;\n@@ -318,8 +371,11 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n         indexDummy.nHeight = pindexPrev->nHeight + 1;\n         CCoinsViewCache viewNew(*pcoinsTip, true);\n         CValidationState state;\n+\n         if (!ConnectBlock(*pblock, state, &indexDummy, viewNew, true))\n+        {\n             throw std::runtime_error(\"CreateNewBlock() : ConnectBlock failed\");\n+        }\n     }\n \n     return pblocktemplate.release();\n@@ -329,13 +385,15 @@ void IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int&\n {\n     // Update nExtraNonce\n     static uint256 hashPrevBlock;\n+\n     if (hashPrevBlock != pblock->hashPrevBlock)\n     {\n         nExtraNonce = 0;\n         hashPrevBlock = pblock->hashPrevBlock;\n     }\n+\n     ++nExtraNonce;\n-    unsigned int nHeight = pindexPrev->nHeight+1; // Height first in coinbase required for block.version=2\n+    unsigned int nHeight = pindexPrev->nHeight + 1; // Height first in coinbase required for block.version=2\n     CMutableTransaction txCoinbase(pblock->vtx[0]);\n     txCoinbase.vin[0].scriptSig = (CScript() << nHeight << CScriptNum(nExtraNonce)) + COINBASE_FLAGS;\n     assert(txCoinbase.vin[0].scriptSig.size() <= 100);\n@@ -358,16 +416,18 @@ int64_t nHPSTimerStart = 0;\n // nonce is 0xffff0000 or above, the block is rebuilt and nNonce starts over at\n // zero.\n //\n-bool static ScanHash(const CBlockHeader *pblock, uint32_t& nNonce, uint256 *phash)\n+bool static ScanHash(const CBlockHeader* pblock, uint32_t& nNonce, uint256* phash)\n {\n     // Write the first 76 bytes of the block header to a double-SHA256 state.\n     CHash256 hasher;\n     CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n+\n     ss << *pblock;\n     assert(ss.size() == 80);\n     hasher.Write((unsigned char*)&ss[0], 76);\n \n-    while (true) {\n+    while (true)\n+    {\n         nNonce++;\n \n         // Write the last 4 bytes of the block header (the nonce) to a copy of\n@@ -377,21 +437,31 @@ bool static ScanHash(const CBlockHeader *pblock, uint32_t& nNonce, uint256 *phas\n         // Return the nonce if the hash has at least some zero bits,\n         // caller will check if it has enough to reach the target\n         if (((uint16_t*)phash)[15] == 0)\n+        {\n             return true;\n+        }\n \n         // If nothing found after trying for a while, return -1\n         if ((nNonce & 0xffff) == 0)\n+        {\n             return false;\n+        }\n+\n         if ((nNonce & 0xfff) == 0)\n+        {\n             boost::this_thread::interruption_point();\n+        }\n     }\n }\n \n CBlockTemplate* CreateNewBlockWithKey(CReserveKey& reservekey)\n {\n     CPubKey pubkey;\n+\n     if (!reservekey.GetReservedKey(pubkey))\n+    {\n         return NULL;\n+    }\n \n     CScript scriptPubKey = CScript() << pubkey << OP_CHECKSIG;\n     return CreateNewBlock(scriptPubKey);\n@@ -405,8 +475,11 @@ bool ProcessBlockFound(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey)\n     // Found a solution\n     {\n         LOCK(cs_main);\n+\n         if (pblock->hashPrevBlock != chainActive.Tip()->GetBlockHash())\n+        {\n             return error(\"BitcoinMiner : generated block is stale\");\n+        }\n     }\n \n     // Remove key from key pool\n@@ -420,13 +493,16 @@ bool ProcessBlockFound(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey)\n \n     // Process this block the same as if we had received it from another node\n     CValidationState state;\n+\n     if (!ProcessBlock(state, NULL, pblock))\n+    {\n         return error(\"BitcoinMiner : ProcessBlock, block not accepted\");\n+    }\n \n     return true;\n }\n \n-void static BitcoinMiner(CWallet *pwallet)\n+void static BitcoinMiner(CWallet* pwallet)\n {\n     LogPrintf(\"BitcoinMiner started\\n\");\n     SetThreadPriority(THREAD_PRIORITY_LOWEST);\n@@ -436,9 +512,12 @@ void static BitcoinMiner(CWallet *pwallet)\n     CReserveKey reservekey(pwallet);\n     unsigned int nExtraNonce = 0;\n \n-    try {\n-        while (true) {\n-            if (Params().MiningRequiresPeers()) {\n+    try\n+    {\n+        while (true)\n+        {\n+            if (Params().MiningRequiresPeers())\n+            {\n                 // Busy-wait for the network to come online so we don't waste time mining\n                 // on an obsolete chain. In regtest mode we expect to fly solo.\n                 while (vNodes.empty())\n@@ -452,12 +531,15 @@ void static BitcoinMiner(CWallet *pwallet)\n             CBlockIndex* pindexPrev = chainActive.Tip();\n \n             auto_ptr<CBlockTemplate> pblocktemplate(CreateNewBlockWithKey(reservekey));\n+\n             if (!pblocktemplate.get())\n             {\n-                LogPrintf(\"Error in BitcoinMiner: Keypool ran out, please call keypoolrefill before restarting the mining thread\\n\");\n+                LogPrintf(\n+                    \"Error in BitcoinMiner: Keypool ran out, please call keypoolrefill before restarting the mining thread\\n\");\n                 return;\n             }\n-            CBlock *pblock = &pblocktemplate->block;\n+\n+            CBlock* pblock = &pblocktemplate->block;\n             IncrementExtraNonce(pblock, pindexPrev, nExtraNonce);\n \n             LogPrintf(\"Running BitcoinMiner with %u transactions in block (%u bytes)\\n\", pblock->vtx.size(),\n@@ -471,7 +553,9 @@ void static BitcoinMiner(CWallet *pwallet)\n             uint256 hash;\n             uint32_t nNonce = 0;\n             uint32_t nOldNonce = 0;\n-            while (true) {\n+\n+            while (true)\n+            {\n                 bool fFound = ScanHash(pblock, nNonce, &hash);\n                 uint32_t nHashesDone = nNonce - nOldNonce;\n                 nOldNonce = nNonce;\n@@ -493,55 +577,76 @@ void static BitcoinMiner(CWallet *pwallet)\n \n                         // In regression test mode, stop mining after a block is found.\n                         if (Params().MineBlocksOnDemand())\n+                        {\n                             throw boost::thread_interrupted();\n+                        }\n \n                         break;\n                     }\n                 }\n \n                 // Meter hashes/sec\n                 static int64_t nHashCounter;\n+\n                 if (nHPSTimerStart == 0)\n                 {\n                     nHPSTimerStart = GetTimeMillis();\n                     nHashCounter = 0;\n                 }\n                 else\n+                {\n                     nHashCounter += nHashesDone;\n+                }\n+\n                 if (GetTimeMillis() - nHPSTimerStart > 4000)\n                 {\n                     static CCriticalSection cs;\n                     {\n                         LOCK(cs);\n+\n                         if (GetTimeMillis() - nHPSTimerStart > 4000)\n                         {\n                             dHashesPerSec = 1000.0 * nHashCounter / (GetTimeMillis() - nHPSTimerStart);\n                             nHPSTimerStart = GetTimeMillis();\n                             nHashCounter = 0;\n                             static int64_t nLogTime;\n+\n                             if (GetTime() - nLogTime > 30 * 60)\n                             {\n                                 nLogTime = GetTime();\n-                                LogPrintf(\"hashmeter %6.0f khash/s\\n\", dHashesPerSec/1000.0);\n+                                LogPrintf(\"hashmeter %6.0f khash/s\\n\", dHashesPerSec / 1000.0);\n                             }\n                         }\n                     }\n                 }\n \n                 // Check for stop or if block needs to be rebuilt\n                 boost::this_thread::interruption_point();\n+\n                 // Regtest mode doesn't require peers\n                 if (vNodes.empty() && Params().MiningRequiresPeers())\n+                {\n                     break;\n+                }\n+\n                 if (nNonce >= 0xffff0000)\n+                {\n                     break;\n+                }\n+\n                 if (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && GetTime() - nStart > 60)\n+                {\n                     break;\n+                }\n+\n                 if (pindexPrev != chainActive.Tip())\n+                {\n                     break;\n+                }\n \n                 // Update nTime every few seconds\n                 UpdateTime(pblock, pindexPrev);\n+\n                 if (Params().AllowMinDifficultyBlocks())\n                 {\n                     // Changing pblock->nTime can change work required on testnet:\n@@ -561,12 +666,17 @@ void GenerateBitcoins(bool fGenerate, CWallet* pwallet, int nThreads)\n {\n     static boost::thread_group* minerThreads = NULL;\n \n-    if (nThreads < 0) {\n+    if (nThreads < 0)\n+    {\n         // In regtest threads defaults to 1\n         if (Params().DefaultMinerThreads())\n+        {\n             nThreads = Params().DefaultMinerThreads();\n+        }\n         else\n+        {\n             nThreads = boost::thread::hardware_concurrency();\n+        }\n     }\n \n     if (minerThreads != NULL)\n@@ -577,11 +687,17 @@ void GenerateBitcoins(bool fGenerate, CWallet* pwallet, int nThreads)\n     }\n \n     if (nThreads == 0 || !fGenerate)\n+    {\n         return;\n+    }\n \n     minerThreads = new boost::thread_group();\n+\n     for (int i = 0; i < nThreads; i++)\n+    {\n         minerThreads->create_thread(boost::bind(&BitcoinMiner, pwallet));\n+    }\n }\n \n #endif // ENABLE_WALLET\n+"
      },
      {
        "sha": "c9d46c067c0c70328872b61cfd573bf340c95c32",
        "filename": "src/miner.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -30,3 +30,4 @@ extern double dHashesPerSec;\n extern int64_t nHPSTimerStart;\n \n #endif // BITCOIN_MINER_H\n+"
      },
      {
        "sha": "47d21ee36e4a09bb19455e46ff4200c58bed17f4",
        "filename": "src/mruset.h",
        "status": "modified",
        "additions": 71,
        "deletions": 13,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/mruset.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/mruset.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/mruset.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -10,7 +10,8 @@\n #include <utility>\n \n /** STL-like set container that only keeps the most recent N elements. */\n-template <typename T> class mruset\n+template <typename T>\n+class mruset\n {\n public:\n     typedef T key_type;\n@@ -25,43 +26,100 @@ template <typename T> class mruset\n     size_type nMaxSize;\n \n public:\n-    mruset(size_type nMaxSizeIn = 0) { nMaxSize = nMaxSizeIn; }\n-    iterator begin() const { return set.begin(); }\n-    iterator end() const { return set.end(); }\n-    size_type size() const { return set.size(); }\n-    bool empty() const { return set.empty(); }\n-    iterator find(const key_type& k) const { return set.find(k); }\n-    size_type count(const key_type& k) const { return set.count(k); }\n-    void clear() { set.clear(); queue.clear(); }\n-    bool inline friend operator==(const mruset<T>& a, const mruset<T>& b) { return a.set == b.set; }\n-    bool inline friend operator==(const mruset<T>& a, const std::set<T>& b) { return a.set == b; }\n-    bool inline friend operator<(const mruset<T>& a, const mruset<T>& b) { return a.set < b.set; }\n+    mruset(size_type nMaxSizeIn = 0)\n+    {\n+        nMaxSize = nMaxSizeIn;\n+    }\n+\n+    iterator begin() const\n+    {\n+        return set.begin();\n+    }\n+\n+    iterator end() const\n+    {\n+        return set.end();\n+    }\n+\n+    size_type size() const\n+    {\n+        return set.size();\n+    }\n+\n+    bool empty() const\n+    {\n+        return set.empty();\n+    }\n+\n+    iterator find(const key_type& k) const\n+    {\n+        return set.find(k);\n+    }\n+\n+    size_type count(const key_type& k) const\n+    {\n+        return set.count(k);\n+    }\n+\n+    void clear()\n+    {\n+        set.clear();\n+        queue.clear();\n+    }\n+\n+    bool inline friend operator==(const mruset<T>& a, const mruset<T>& b)\n+    {\n+        return a.set == b.set;\n+    }\n+\n+    bool inline friend operator==(const mruset<T>& a, const std::set<T>& b)\n+    {\n+        return a.set == b;\n+    }\n+\n+    bool inline friend operator<(const mruset<T>& a, const mruset<T>& b)\n+    {\n+        return a.set < b.set;\n+    }\n+\n     std::pair<iterator, bool> insert(const key_type& x)\n     {\n         std::pair<iterator, bool> ret = set.insert(x);\n+\n         if (ret.second)\n         {\n             if (nMaxSize && queue.size() == nMaxSize)\n             {\n                 set.erase(queue.front());\n                 queue.pop_front();\n             }\n+\n             queue.push_back(x);\n         }\n+\n         return ret;\n     }\n-    size_type max_size() const { return nMaxSize; }\n+\n+    size_type max_size() const\n+    {\n+        return nMaxSize;\n+    }\n+\n     size_type max_size(size_type s)\n     {\n         if (s)\n+        {\n             while (queue.size() > s)\n             {\n                 set.erase(queue.front());\n                 queue.pop_front();\n             }\n+        }\n+\n         nMaxSize = s;\n         return nMaxSize;\n     }\n };\n \n #endif // BITCOIN_MRUSET_H\n+"
      },
      {
        "sha": "9409686e2c2983e14f3e39c08db0306e1ff0eae7",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 775,
        "deletions": 256,
        "changes": 1031,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -51,15 +51,19 @@\n using namespace std;\n using namespace boost;\n \n-namespace {\n-    const int MAX_OUTBOUND_CONNECTIONS = 8;\n+namespace\n+{\n+const int MAX_OUTBOUND_CONNECTIONS = 8;\n \n-    struct ListenSocket {\n-        SOCKET socket;\n-        bool whitelisted;\n+struct ListenSocket\n+{\n+    SOCKET socket;\n+    bool whitelisted;\n \n-        ListenSocket(SOCKET socket, bool whitelisted) : socket(socket), whitelisted(whitelisted) {}\n-    };\n+    ListenSocket(SOCKET socket, bool whitelisted) : socket(socket), whitelisted(whitelisted)\n+    {\n+    }\n+};\n }\n \n //\n@@ -98,11 +102,14 @@ CCriticalSection cs_vAddedNodes;\n NodeId nLastNodeId = 0;\n CCriticalSection cs_nLastNodeId;\n \n-static CSemaphore *semOutbound = NULL;\n+static CSemaphore* semOutbound = NULL;\n \n // Signals for message handling\n static CNodeSignals g_signals;\n-CNodeSignals& GetNodeSignals() { return g_signals; }\n+CNodeSignals& GetNodeSignals()\n+{\n+    return g_signals;\n+}\n \n void AddOneShot(string strDest)\n {\n@@ -116,19 +123,23 @@ unsigned short GetListenPort()\n }\n \n // find 'best' local address for a particular peer\n-bool GetLocal(CService& addr, const CNetAddr *paddrPeer)\n+bool GetLocal(CService& addr, const CNetAddr* paddrPeer)\n {\n     if (!fListen)\n+    {\n         return false;\n+    }\n \n     int nBestScore = -1;\n     int nBestReachability = -1;\n     {\n         LOCK(cs_mapLocalHost);\n+\n         for (map<CNetAddr, LocalServiceInfo>::iterator it = mapLocalHost.begin(); it != mapLocalHost.end(); it++)\n         {\n             int nScore = (*it).second.nScore;\n             int nReachability = (*it).first.GetReachabilityFrom(paddrPeer);\n+\n             if (nReachability > nBestReachability || (nReachability == nBestReachability && nScore > nBestScore))\n             {\n                 addr = CService((*it).first, (*it).second.nPort);\n@@ -141,52 +152,74 @@ bool GetLocal(CService& addr, const CNetAddr *paddrPeer)\n }\n \n // get best local address for a particular peer as a CAddress\n-CAddress GetLocalAddress(const CNetAddr *paddrPeer)\n+CAddress GetLocalAddress(const CNetAddr* paddrPeer)\n {\n-    CAddress ret(CService(\"0.0.0.0\",0),0);\n+    CAddress ret(CService(\"0.0.0.0\", 0), 0);\n     CService addr;\n+\n     if (GetLocal(addr, paddrPeer))\n     {\n         ret = CAddress(addr);\n         ret.nServices = nLocalServices;\n         ret.nTime = GetAdjustedTime();\n     }\n+\n     return ret;\n }\n \n bool RecvLine(SOCKET hSocket, string& strLine)\n {\n     strLine = \"\";\n+\n     while (true)\n     {\n         char c;\n         int nBytes = recv(hSocket, &c, 1, 0);\n+\n         if (nBytes > 0)\n         {\n             if (c == '\\n')\n+            {\n                 continue;\n+            }\n+\n             if (c == '\\r')\n+            {\n                 return true;\n+            }\n+\n             strLine += c;\n+\n             if (strLine.size() >= 9000)\n+            {\n                 return true;\n+            }\n         }\n         else if (nBytes <= 0)\n         {\n             boost::this_thread::interruption_point();\n+\n             if (nBytes < 0)\n             {\n                 int nErr = WSAGetLastError();\n+\n                 if (nErr == WSAEMSGSIZE)\n+                {\n                     continue;\n+                }\n+\n                 if (nErr == WSAEWOULDBLOCK || nErr == WSAEINTR || nErr == WSAEINPROGRESS)\n                 {\n                     MilliSleep(10);\n                     continue;\n                 }\n             }\n+\n             if (!strLine.empty())\n+            {\n                 return true;\n+            }\n+\n             if (nBytes == 0)\n             {\n                 // socket closed\n@@ -209,11 +242,13 @@ bool RecvLine(SOCKET hSocket, string& strLine)\n void static AdvertizeLocal()\n {\n     LOCK(cs_vNodes);\n-    BOOST_FOREACH(CNode* pnode, vNodes)\n+\n+    BOOST_FOREACH (CNode* pnode, vNodes)\n     {\n         if (pnode->fSuccessfullyConnected)\n         {\n             CAddress addrLocal = GetLocalAddress(&pnode->addr);\n+\n             if (addrLocal.IsRoutable() && (CService)addrLocal != (CService)pnode->addrLocal)\n             {\n                 pnode->PushAddress(addrLocal);\n@@ -227,32 +262,44 @@ void SetReachable(enum Network net, bool fFlag)\n {\n     LOCK(cs_mapLocalHost);\n     vfReachable[net] = fFlag;\n+\n     if (net == NET_IPV6 && fFlag)\n+    {\n         vfReachable[NET_IPV4] = true;\n+    }\n }\n \n // learn a new local address\n bool AddLocal(const CService& addr, int nScore)\n {\n     if (!addr.IsRoutable())\n+    {\n         return false;\n+    }\n \n     if (!fDiscover && nScore < LOCAL_MANUAL)\n+    {\n         return false;\n+    }\n \n     if (IsLimited(addr))\n+    {\n         return false;\n+    }\n \n     LogPrintf(\"AddLocal(%s,%i)\\n\", addr.ToString(), nScore);\n \n     {\n         LOCK(cs_mapLocalHost);\n         bool fAlready = mapLocalHost.count(addr) > 0;\n         LocalServiceInfo &info = mapLocalHost[addr];\n-        if (!fAlready || nScore >= info.nScore) {\n+\n+        if (!fAlready || nScore >= info.nScore)\n+        {\n             info.nScore = nScore + (fAlready ? 1 : 0);\n             info.nPort = addr.GetPort();\n         }\n+\n         SetReachable(addr.GetNetwork());\n     }\n \n@@ -270,7 +317,10 @@ bool AddLocal(const CNetAddr &addr, int nScore)\n void SetLimited(enum Network net, bool fLimited)\n {\n     if (net == NET_UNROUTABLE)\n+    {\n         return;\n+    }\n+\n     LOCK(cs_mapLocalHost);\n     vfLimited[net] = fLimited;\n }\n@@ -291,8 +341,12 @@ bool SeenLocal(const CService& addr)\n {\n     {\n         LOCK(cs_mapLocalHost);\n+\n         if (mapLocalHost.count(addr) == 0)\n+        {\n             return false;\n+        }\n+\n         mapLocalHost[addr].nScore++;\n     }\n \n@@ -319,18 +373,23 @@ bool IsReachable(enum Network net)\n bool IsReachable(const CNetAddr& addr)\n {\n     enum Network net = addr.GetNetwork();\n+\n     return IsReachable(net);\n }\n \n bool GetMyExternalIP2(const CService& addrConnect, const char* pszGet, const char* pszKeyword, CNetAddr& ipRet)\n {\n     SOCKET hSocket;\n+\n     if (!ConnectSocket(addrConnect, hSocket))\n+    {\n         return error(\"GetMyExternalIP() : connection to %s failed\", addrConnect.ToString());\n+    }\n \n     send(hSocket, pszGet, strlen(pszGet), MSG_NOSIGNAL);\n \n     string strLine;\n+\n     while (RecvLine(hSocket, strLine))\n     {\n         if (strLine.empty()) // HTTP response is separated from headers by blank line\n@@ -342,28 +401,44 @@ bool GetMyExternalIP2(const CService& addrConnect, const char* pszGet, const cha\n                     CloseSocket(hSocket);\n                     return false;\n                 }\n+\n                 if (pszKeyword == NULL)\n+                {\n                     break;\n+                }\n+\n                 if (strLine.find(pszKeyword) != string::npos)\n                 {\n                     strLine = strLine.substr(strLine.find(pszKeyword) + strlen(pszKeyword));\n                     break;\n                 }\n             }\n+\n             CloseSocket(hSocket);\n+\n             if (strLine.find(\"<\") != string::npos)\n+            {\n                 strLine = strLine.substr(0, strLine.find(\"<\"));\n+            }\n+\n             strLine = strLine.substr(strspn(strLine.c_str(), \" \\t\\n\\r\"));\n-            while (strLine.size() > 0 && isspace(strLine[strLine.size()-1]))\n-                strLine.resize(strLine.size()-1);\n-            CService addr(strLine,0,true);\n+\n+            while (strLine.size() > 0 && isspace(strLine[strLine.size() - 1]))\n+                strLine.resize(strLine.size() - 1);\n+\n+            CService addr(strLine, 0, true);\n             LogPrintf(\"GetMyExternalIP() received [%s] %s\\n\", strLine, addr.ToString());\n+\n             if (!addr.IsValid() || !addr.IsRoutable())\n+            {\n                 return false;\n+            }\n+\n             ipRet.SetIP(addr);\n             return true;\n         }\n     }\n+\n     CloseSocket(hSocket);\n     return error(\"GetMyExternalIP() : connection closed\");\n }\n@@ -375,34 +450,41 @@ bool GetMyExternalIP(CNetAddr& ipRet)\n     const char* pszKeyword;\n \n     for (int nLookup = 0; nLookup <= 1; nLookup++)\n-    for (int nHost = 1; nHost <= 1; nHost++)\n     {\n-        // We should be phasing out our use of sites like these. If we need\n-        // replacements, we should ask for volunteers to put this simple\n-        // php file on their web server that prints the client IP:\n-        //  <?php echo $_SERVER[\"REMOTE_ADDR\"]; ?>\n-        if (nHost == 1)\n+        for (int nHost = 1; nHost <= 1; nHost++)\n         {\n-            addrConnect = CService(\"91.198.22.70\", 80); // checkip.dyndns.org\n-\n-            if (nLookup == 1)\n+            // We should be phasing out our use of sites like these. If we need\n+            // replacements, we should ask for volunteers to put this simple\n+            // php file on their web server that prints the client IP:\n+            //  <?php echo $_SERVER[\"REMOTE_ADDR\"]; ?>\n+            if (nHost == 1)\n             {\n-                CService addrIP(\"checkip.dyndns.org\", 80, true);\n-                if (addrIP.IsValid())\n-                    addrConnect = addrIP;\n-            }\n+                addrConnect = CService(\"91.198.22.70\", 80); // checkip.dyndns.org\n \n-            pszGet = \"GET / HTTP/1.1\\r\\n\"\n-                     \"Host: checkip.dyndns.org\\r\\n\"\n-                     \"User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)\\r\\n\"\n-                     \"Connection: close\\r\\n\"\n-                     \"\\r\\n\";\n+                if (nLookup == 1)\n+                {\n+                    CService addrIP(\"checkip.dyndns.org\", 80, true);\n \n-            pszKeyword = \"Address:\";\n-        }\n+                    if (addrIP.IsValid())\n+                    {\n+                        addrConnect = addrIP;\n+                    }\n+                }\n \n-        if (GetMyExternalIP2(addrConnect, pszGet, pszKeyword, ipRet))\n-            return true;\n+                pszGet = \"GET / HTTP/1.1\\r\\n\"\n+                         \"Host: checkip.dyndns.org\\r\\n\"\n+                         \"User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)\\r\\n\"\n+                         \"Connection: close\\r\\n\"\n+                         \"\\r\\n\";\n+\n+                pszKeyword = \"Address:\";\n+            }\n+\n+            if (GetMyExternalIP2(addrConnect, pszGet, pszKeyword, ipRet))\n+            {\n+                return true;\n+            }\n+        }\n     }\n \n     return false;\n@@ -411,25 +493,19 @@ bool GetMyExternalIP(CNetAddr& ipRet)\n void ThreadGetMyExternalIP()\n {\n     CNetAddr addrLocalHost;\n+\n     if (GetMyExternalIP(addrLocalHost))\n     {\n         LogPrintf(\"GetMyExternalIP() returned %s\\n\", addrLocalHost.ToStringIP());\n         AddLocal(addrLocalHost, LOCAL_HTTP);\n     }\n }\n \n-\n-\n-\n-\n void AddressCurrentlyConnected(const CService& addr)\n {\n     addrman.Connected(addr);\n }\n \n-\n-\n-\n uint64_t CNode::nTotalBytesRecv = 0;\n uint64_t CNode::nTotalBytesSent = 0;\n CCriticalSection CNode::cs_totalBytesRecv;\n@@ -438,38 +514,60 @@ CCriticalSection CNode::cs_totalBytesSent;\n CNode* FindNode(const CNetAddr& ip)\n {\n     LOCK(cs_vNodes);\n-    BOOST_FOREACH(CNode* pnode, vNodes)\n+\n+    BOOST_FOREACH (CNode* pnode, vNodes)\n+    {\n         if ((CNetAddr)pnode->addr == ip)\n+        {\n             return (pnode);\n+        }\n+    }\n+\n     return NULL;\n }\n \n CNode* FindNode(const std::string& addrName)\n {\n     LOCK(cs_vNodes);\n-    BOOST_FOREACH(CNode* pnode, vNodes)\n+\n+    BOOST_FOREACH (CNode* pnode, vNodes)\n+    {\n         if (pnode->addrName == addrName)\n+        {\n             return (pnode);\n+        }\n+    }\n+\n     return NULL;\n }\n \n CNode* FindNode(const CService& addr)\n {\n     LOCK(cs_vNodes);\n-    BOOST_FOREACH(CNode* pnode, vNodes)\n+\n+    BOOST_FOREACH (CNode* pnode, vNodes)\n+    {\n         if ((CService)pnode->addr == addr)\n+        {\n             return (pnode);\n+        }\n+    }\n+\n     return NULL;\n }\n \n-CNode* ConnectNode(CAddress addrConnect, const char *pszDest)\n+CNode* ConnectNode(CAddress addrConnect, const char* pszDest)\n {\n-    if (pszDest == NULL) {\n+    if (pszDest == NULL)\n+    {\n         if (IsLocal(addrConnect))\n+        {\n             return NULL;\n+        }\n \n         // Look for an existing connection\n         CNode* pnode = FindNode((CService)addrConnect);\n+\n         if (pnode)\n         {\n             pnode->AddRef();\n@@ -480,17 +578,22 @@ CNode* ConnectNode(CAddress addrConnect, const char *pszDest)\n     /// debug print\n     LogPrint(\"net\", \"trying connection %s lastseen=%.1fhrs\\n\",\n         pszDest ? pszDest : addrConnect.ToString(),\n-        pszDest ? 0.0 : (double)(GetAdjustedTime() - addrConnect.nTime)/3600.0);\n+        pszDest ? 0.0 : (double)(GetAdjustedTime() - addrConnect.nTime) / 3600.0);\n \n     // Connect\n     SOCKET hSocket;\n-    if (pszDest ? ConnectSocketByName(addrConnect, hSocket, pszDest, Params().GetDefaultPort()) : ConnectSocket(addrConnect, hSocket))\n+\n+    if (pszDest ? ConnectSocketByName(addrConnect, hSocket, pszDest,\n+            Params().GetDefaultPort()) : ConnectSocket(addrConnect, hSocket))\n     {\n         addrman.Attempt(addrConnect);\n \n         // Set to non-blocking\n         if (!SetSocketNonBlocking(hSocket, true))\n-            LogPrintf(\"ConnectNode: Setting socket to non-blocking failed, error %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        {\n+            LogPrintf(\"ConnectNode: Setting socket to non-blocking failed, error %s\\n\",\n+                NetworkErrorString(WSAGetLastError()));\n+        }\n \n         // Add node\n         CNode* pnode = new CNode(hSocket, addrConnect, pszDest ? pszDest : \"\", false);\n@@ -512,6 +615,7 @@ CNode* ConnectNode(CAddress addrConnect, const char *pszDest)\n void CNode::CloseSocketDisconnect()\n {\n     fDisconnect = true;\n+\n     if (hSocket != INVALID_SOCKET)\n     {\n         LogPrint(\"net\", \"disconnecting peer=%d\\n\", id);\n@@ -520,12 +624,17 @@ void CNode::CloseSocketDisconnect()\n \n     // in case this fails, we'll empty the recv buffer when the CNode is deleted\n     TRY_LOCK(cs_vRecvMsg, lockRecv);\n+\n     if (lockRecv)\n+    {\n         vRecvMsg.clear();\n+    }\n \n     // if this was the sync node, we'll need a new one\n     if (this == pnodeSync)\n+    {\n         pnodeSync = NULL;\n+    }\n }\n \n void CNode::PushVersion()\n@@ -534,21 +643,27 @@ void CNode::PushVersion()\n \n     /// when NTP implemented, change to just nTime = GetAdjustedTime()\n     int64_t nTime = (fInbound ? GetAdjustedTime() : GetTime());\n-    CAddress addrYou = (addr.IsRoutable() && !IsProxy(addr) ? addr : CAddress(CService(\"0.0.0.0\",0)));\n+    CAddress addrYou = (addr.IsRoutable() && !IsProxy(addr) ? addr : CAddress(CService(\"0.0.0.0\", 0)));\n     CAddress addrMe = GetLocalAddress(&addr);\n+\n     GetRandBytes((unsigned char*)&nLocalHostNonce, sizeof(nLocalHostNonce));\n+\n     if (fLogIPs)\n-        LogPrint(\"net\", \"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%d\\n\", PROTOCOL_VERSION, nBestHeight, addrMe.ToString(), addrYou.ToString(), id);\n+    {\n+        LogPrint(\"net\", \"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%d\\n\", PROTOCOL_VERSION,\n+            nBestHeight,\n+            addrMe.ToString(), addrYou.ToString(), id);\n+    }\n     else\n-        LogPrint(\"net\", \"send version message: version %d, blocks=%d, us=%s, peer=%d\\n\", PROTOCOL_VERSION, nBestHeight, addrMe.ToString(), id);\n+    {\n+        LogPrint(\"net\", \"send version message: version %d, blocks=%d, us=%s, peer=%d\\n\", PROTOCOL_VERSION, nBestHeight,\n+            addrMe.ToString(), id);\n+    }\n+\n     PushMessage(\"version\", PROTOCOL_VERSION, nLocalServices, nTime, addrYou, addrMe,\n-                nLocalHostNonce, FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, std::vector<string>()), nBestHeight, true);\n+        nLocalHostNonce, FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, std::vector<string>()), nBestHeight, true);\n }\n \n-\n-\n-\n-\n std::map<CNetAddr, int64_t> CNode::setBanned;\n CCriticalSection CNode::cs_setBanned;\n \n@@ -560,43 +675,59 @@ void CNode::ClearBanned()\n bool CNode::IsBanned(CNetAddr ip)\n {\n     bool fResult = false;\n+\n     {\n         LOCK(cs_setBanned);\n         std::map<CNetAddr, int64_t>::iterator i = setBanned.find(ip);\n+\n         if (i != setBanned.end())\n         {\n             int64_t t = (*i).second;\n+\n             if (GetTime() < t)\n+            {\n                 fResult = true;\n+            }\n         }\n     }\n     return fResult;\n }\n \n-bool CNode::Ban(const CNetAddr &addr) {\n-    int64_t banTime = GetTime()+GetArg(\"-bantime\", 60*60*24);  // Default 24-hour ban\n+bool CNode::Ban(const CNetAddr &addr)\n+{\n+    int64_t banTime = GetTime() + GetArg(\"-bantime\", 60 * 60 * 24);  // Default 24-hour ban\n+\n     {\n         LOCK(cs_setBanned);\n+\n         if (setBanned[addr] < banTime)\n+        {\n             setBanned[addr] = banTime;\n+        }\n     }\n     return true;\n }\n \n-\n std::vector<CSubNet> CNode::vWhitelistedRange;\n CCriticalSection CNode::cs_vWhitelistedRange;\n \n-bool CNode::IsWhitelistedRange(const CNetAddr &addr) {\n+bool CNode::IsWhitelistedRange(const CNetAddr &addr)\n+{\n     LOCK(cs_vWhitelistedRange);\n-    BOOST_FOREACH(const CSubNet& subnet, vWhitelistedRange) {\n+\n+    BOOST_FOREACH (const CSubNet& subnet, vWhitelistedRange)\n+    {\n         if (subnet.Match(addr))\n+        {\n             return true;\n+        }\n     }\n+\n     return false;\n }\n \n-void CNode::AddWhitelistedRange(const CSubNet &subnet) {\n+void CNode::AddWhitelistedRange(const CSubNet &subnet)\n+{\n     LOCK(cs_vWhitelistedRange);\n     vWhitelistedRange.push_back(subnet);\n }\n@@ -627,7 +758,9 @@ void CNode::copyStats(CNodeStats &stats)\n     // So, if a ping is taking an unusually long time in flight,\n     // the caller can immediately detect that this is happening.\n     int64_t nPingUsecWait = 0;\n-    if ((0 != nPingNonceSent) && (0 != nPingUsecStart)) {\n+\n+    if ((0 != nPingNonceSent) && (0 != nPingUsecStart))\n+    {\n         nPingUsecWait = GetTimeMicros() - nPingUsecStart;\n     }\n \n@@ -638,41 +771,53 @@ void CNode::copyStats(CNodeStats &stats)\n     // Leave string empty if addrLocal invalid (not filled in yet)\n     stats.addrLocal = addrLocal.IsValid() ? addrLocal.ToString() : \"\";\n }\n+\n #undef X\n \n // requires LOCK(cs_vRecvMsg)\n-bool CNode::ReceiveMsgBytes(const char *pch, unsigned int nBytes)\n+bool CNode::ReceiveMsgBytes(const char* pch, unsigned int nBytes)\n {\n-    while (nBytes > 0) {\n-\n+    while (nBytes > 0)\n+    {\n         // get current incomplete message, or create a new one\n         if (vRecvMsg.empty() ||\n             vRecvMsg.back().complete())\n+        {\n             vRecvMsg.push_back(CNetMessage(SER_NETWORK, nRecvVersion));\n+        }\n \n         CNetMessage& msg = vRecvMsg.back();\n \n         // absorb network data\n         int handled;\n+\n         if (!msg.in_data)\n+        {\n             handled = msg.readHeader(pch, nBytes);\n+        }\n         else\n+        {\n             handled = msg.readData(pch, nBytes);\n+        }\n \n         if (handled < 0)\n-                return false;\n+        {\n+            return false;\n+        }\n \n         pch += handled;\n         nBytes -= handled;\n \n         if (msg.complete())\n+        {\n             msg.nTime = GetTimeMicros();\n+        }\n     }\n \n     return true;\n }\n \n-int CNetMessage::readHeader(const char *pch, unsigned int nBytes)\n+int CNetMessage::readHeader(const char* pch, unsigned int nBytes)\n {\n     // copy data to temporary parsing buffer\n     unsigned int nRemaining = 24 - nHdrPos;\n@@ -683,32 +828,39 @@ int CNetMessage::readHeader(const char *pch, unsigned int nBytes)\n \n     // if header incomplete, exit\n     if (nHdrPos < 24)\n+    {\n         return nCopy;\n+    }\n \n     // deserialize to CMessageHeader\n-    try {\n+    try\n+    {\n         hdrbuf >> hdr;\n     }\n-    catch (std::exception &e) {\n+    catch (std::exception &e)\n+    {\n         return -1;\n     }\n \n     // reject messages larger than MAX_SIZE\n     if (hdr.nMessageSize > MAX_SIZE)\n-            return -1;\n+    {\n+        return -1;\n+    }\n \n     // switch state to reading message data\n     in_data = true;\n \n     return nCopy;\n }\n \n-int CNetMessage::readData(const char *pch, unsigned int nBytes)\n+int CNetMessage::readData(const char* pch, unsigned int nBytes)\n {\n     unsigned int nRemaining = hdr.nMessageSize - nDataPos;\n     unsigned int nCopy = std::min(nRemaining, nBytes);\n \n-    if (vRecv.size() < nDataPos + nCopy) {\n+    if (vRecv.size() < nDataPos + nCopy)\n+    {\n         // Allocate up to 256 KiB ahead, but never more than the total message size.\n         vRecv.resize(std::min(hdr.nMessageSize, nDataPos + nCopy + 256 * 1024));\n     }\n@@ -719,55 +871,62 @@ int CNetMessage::readData(const char *pch, unsigned int nBytes)\n     return nCopy;\n }\n \n-\n-\n-\n-\n-\n-\n-\n-\n // requires LOCK(cs_vSend)\n-void SocketSendData(CNode *pnode)\n+void SocketSendData(CNode* pnode)\n {\n     std::deque<CSerializeData>::iterator it = pnode->vSendMsg.begin();\n \n-    while (it != pnode->vSendMsg.end()) {\n+    while (it != pnode->vSendMsg.end())\n+    {\n         const CSerializeData &data = *it;\n         assert(data.size() > pnode->nSendOffset);\n-        int nBytes = send(pnode->hSocket, &data[pnode->nSendOffset], data.size() - pnode->nSendOffset, MSG_NOSIGNAL | MSG_DONTWAIT);\n-        if (nBytes > 0) {\n+        int nBytes = send(pnode->hSocket, &data[pnode->nSendOffset],\n+            data.size() - pnode->nSendOffset, MSG_NOSIGNAL | MSG_DONTWAIT);\n+\n+        if (nBytes > 0)\n+        {\n             pnode->nLastSend = GetTime();\n             pnode->nSendBytes += nBytes;\n             pnode->nSendOffset += nBytes;\n             pnode->RecordBytesSent(nBytes);\n-            if (pnode->nSendOffset == data.size()) {\n+\n+            if (pnode->nSendOffset == data.size())\n+            {\n                 pnode->nSendOffset = 0;\n                 pnode->nSendSize -= data.size();\n                 it++;\n-            } else {\n+            }\n+            else\n+            {\n                 // could not send full message; stop sending more\n                 break;\n             }\n-        } else {\n-            if (nBytes < 0) {\n+        }\n+        else\n+        {\n+            if (nBytes < 0)\n+            {\n                 // error\n                 int nErr = WSAGetLastError();\n+\n                 if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n                 {\n                     LogPrintf(\"socket send error %s\\n\", NetworkErrorString(nErr));\n                     pnode->CloseSocketDisconnect();\n                 }\n             }\n+\n             // couldn't send anything at all\n             break;\n         }\n     }\n \n-    if (it == pnode->vSendMsg.end()) {\n+    if (it == pnode->vSendMsg.end())\n+    {\n         assert(pnode->nSendOffset == 0);\n         assert(pnode->nSendSize == 0);\n     }\n+\n     pnode->vSendMsg.erase(pnode->vSendMsg.begin(), it);\n }\n \n@@ -776,6 +935,7 @@ static list<CNode*> vNodesDisconnected;\n void ThreadSocketHandler()\n {\n     unsigned int nPrevNodeCount = 0;\n+\n     while (true)\n     {\n         //\n@@ -785,10 +945,12 @@ void ThreadSocketHandler()\n             LOCK(cs_vNodes);\n             // Disconnect unused nodes\n             vector<CNode*> vNodesCopy = vNodes;\n-            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n+\n+            BOOST_FOREACH (CNode* pnode, vNodesCopy)\n             {\n                 if (pnode->fDisconnect ||\n-                    (pnode->GetRefCount() <= 0 && pnode->vRecvMsg.empty() && pnode->nSendSize == 0 && pnode->ssSend.empty()))\n+                    (pnode->GetRefCount() <= 0 && pnode->vRecvMsg.empty() && pnode->nSendSize == 0 &&\n+                        pnode->ssSend.empty()))\n                 {\n                     // remove from vNodes\n                     vNodes.erase(remove(vNodes.begin(), vNodes.end(), pnode), vNodes.end());\n@@ -801,33 +963,43 @@ void ThreadSocketHandler()\n \n                     // hold in disconnected pool until all refs are released\n                     if (pnode->fNetworkNode || pnode->fInbound)\n+                    {\n                         pnode->Release();\n+                    }\n+\n                     vNodesDisconnected.push_back(pnode);\n                 }\n             }\n         }\n         {\n             // Delete disconnected nodes\n             list<CNode*> vNodesDisconnectedCopy = vNodesDisconnected;\n-            BOOST_FOREACH(CNode* pnode, vNodesDisconnectedCopy)\n+\n+            BOOST_FOREACH (CNode* pnode, vNodesDisconnectedCopy)\n             {\n                 // wait until threads are done using it\n                 if (pnode->GetRefCount() <= 0)\n                 {\n                     bool fDelete = false;\n                     {\n                         TRY_LOCK(pnode->cs_vSend, lockSend);\n+\n                         if (lockSend)\n                         {\n                             TRY_LOCK(pnode->cs_vRecvMsg, lockRecv);\n+\n                             if (lockRecv)\n                             {\n                                 TRY_LOCK(pnode->cs_inventory, lockInv);\n+\n                                 if (lockInv)\n+                                {\n                                     fDelete = true;\n+                                }\n                             }\n                         }\n                     }\n+\n                     if (fDelete)\n                     {\n                         vNodesDisconnected.remove(pnode);\n@@ -836,7 +1008,9 @@ void ThreadSocketHandler()\n                 }\n             }\n         }\n-        if(vNodes.size() != nPrevNodeCount) {\n+\n+        if (vNodes.size() != nPrevNodeCount)\n+        {\n             nPrevNodeCount = vNodes.size();\n             uiInterface.NotifyNumConnectionsChanged(nPrevNodeCount);\n         }\n@@ -857,18 +1031,23 @@ void ThreadSocketHandler()\n         SOCKET hSocketMax = 0;\n         bool have_fds = false;\n \n-        BOOST_FOREACH(const ListenSocket& hListenSocket, vhListenSocket) {\n+        BOOST_FOREACH (const ListenSocket& hListenSocket, vhListenSocket)\n+        {\n             FD_SET(hListenSocket.socket, &fdsetRecv);\n             hSocketMax = max(hSocketMax, hListenSocket.socket);\n             have_fds = true;\n         }\n \n         {\n             LOCK(cs_vNodes);\n-            BOOST_FOREACH(CNode* pnode, vNodes)\n+\n+            BOOST_FOREACH (CNode* pnode, vNodes)\n             {\n                 if (pnode->hSocket == INVALID_SOCKET)\n+                {\n                     continue;\n+                }\n+\n                 FD_SET(pnode->hSocket, &fdsetError);\n                 hSocketMax = max(hSocketMax, pnode->hSocket);\n                 have_fds = true;\n@@ -890,23 +1069,28 @@ void ThreadSocketHandler()\n                 // * We process a message in the buffer (message handler thread).\n                 {\n                     TRY_LOCK(pnode->cs_vSend, lockSend);\n-                    if (lockSend && !pnode->vSendMsg.empty()) {\n+\n+                    if (lockSend && !pnode->vSendMsg.empty())\n+                    {\n                         FD_SET(pnode->hSocket, &fdsetSend);\n                         continue;\n                     }\n                 }\n                 {\n                     TRY_LOCK(pnode->cs_vRecvMsg, lockRecv);\n+\n                     if (lockRecv && (\n-                        pnode->vRecvMsg.empty() || !pnode->vRecvMsg.front().complete() ||\n-                        pnode->GetTotalRecvSize() <= ReceiveFloodSize()))\n+                            pnode->vRecvMsg.empty() || !pnode->vRecvMsg.front().complete() ||\n+                            pnode->GetTotalRecvSize() <= ReceiveFloodSize()))\n+                    {\n                         FD_SET(pnode->hSocket, &fdsetRecv);\n+                    }\n                 }\n             }\n         }\n \n         int nSelect = select(have_fds ? hSocketMax + 1 : 0,\n-                             &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n+            &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n         boost::this_thread::interruption_point();\n \n         if (nSelect == SOCKET_ERROR)\n@@ -915,18 +1099,22 @@ void ThreadSocketHandler()\n             {\n                 int nErr = WSAGetLastError();\n                 LogPrintf(\"socket select error %s\\n\", NetworkErrorString(nErr));\n+\n                 for (unsigned int i = 0; i <= hSocketMax; i++)\n+                {\n                     FD_SET(i, &fdsetRecv);\n+                }\n             }\n+\n             FD_ZERO(&fdsetSend);\n             FD_ZERO(&fdsetError);\n-            MilliSleep(timeout.tv_usec/1000);\n+            MilliSleep(timeout.tv_usec / 1000);\n         }\n \n         //\n         // Accept new connections\n         //\n-        BOOST_FOREACH(const ListenSocket& hListenSocket, vhListenSocket)\n+        BOOST_FOREACH (const ListenSocket& hListenSocket, vhListenSocket)\n         {\n             if (hListenSocket.socket != INVALID_SOCKET && FD_ISSET(hListenSocket.socket, &fdsetRecv))\n             {\n@@ -937,22 +1125,34 @@ void ThreadSocketHandler()\n                 int nInbound = 0;\n \n                 if (hSocket != INVALID_SOCKET)\n+                {\n                     if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr))\n+                    {\n                         LogPrintf(\"Warning: Unknown socket family\\n\");\n+                    }\n+                }\n \n                 bool whitelisted = hListenSocket.whitelisted || CNode::IsWhitelistedRange(addr);\n                 {\n                     LOCK(cs_vNodes);\n-                    BOOST_FOREACH(CNode* pnode, vNodes)\n+\n+                    BOOST_FOREACH (CNode* pnode, vNodes)\n+                    {\n                         if (pnode->fInbound)\n+                        {\n                             nInbound++;\n+                        }\n+                    }\n                 }\n \n                 if (hSocket == INVALID_SOCKET)\n                 {\n                     int nErr = WSAGetLastError();\n+\n                     if (nErr != WSAEWOULDBLOCK)\n+                    {\n                         LogPrintf(\"socket error accept failed: %s\\n\", NetworkErrorString(nErr));\n+                    }\n                 }\n                 else if (nInbound >= nMaxConnections - MAX_OUTBOUND_CONNECTIONS)\n                 {\n@@ -984,31 +1184,43 @@ void ThreadSocketHandler()\n         {\n             LOCK(cs_vNodes);\n             vNodesCopy = vNodes;\n-            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n+\n+            BOOST_FOREACH (CNode* pnode, vNodesCopy)\n+            {\n                 pnode->AddRef();\n+            }\n         }\n-        BOOST_FOREACH(CNode* pnode, vNodesCopy)\n+\n+        BOOST_FOREACH (CNode* pnode, vNodesCopy)\n         {\n             boost::this_thread::interruption_point();\n \n             //\n             // Receive\n             //\n             if (pnode->hSocket == INVALID_SOCKET)\n+            {\n                 continue;\n+            }\n+\n             if (FD_ISSET(pnode->hSocket, &fdsetRecv) || FD_ISSET(pnode->hSocket, &fdsetError))\n             {\n                 TRY_LOCK(pnode->cs_vRecvMsg, lockRecv);\n+\n                 if (lockRecv)\n                 {\n                     {\n                         // typical socket buffer is 8K-64K\n                         char pchBuf[0x10000];\n                         int nBytes = recv(pnode->hSocket, pchBuf, sizeof(pchBuf), MSG_DONTWAIT);\n+\n                         if (nBytes > 0)\n                         {\n                             if (!pnode->ReceiveMsgBytes(pchBuf, nBytes))\n+                            {\n                                 pnode->CloseSocketDisconnect();\n+                            }\n+\n                             pnode->nLastRecv = GetTime();\n                             pnode->nRecvBytes += nBytes;\n                             pnode->RecordBytesRecv(nBytes);\n@@ -1017,17 +1229,25 @@ void ThreadSocketHandler()\n                         {\n                             // socket closed gracefully\n                             if (!pnode->fDisconnect)\n+                            {\n                                 LogPrint(\"net\", \"socket closed\\n\");\n+                            }\n+\n                             pnode->CloseSocketDisconnect();\n                         }\n                         else if (nBytes < 0)\n                         {\n                             // error\n                             int nErr = WSAGetLastError();\n-                            if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n+\n+                            if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr !=\n+                                WSAEINPROGRESS)\n                             {\n                                 if (!pnode->fDisconnect)\n+                                {\n                                     LogPrintf(\"socket recv error %s\\n\", NetworkErrorString(nErr));\n+                                }\n+\n                                 pnode->CloseSocketDisconnect();\n                             }\n                         }\n@@ -1039,31 +1259,40 @@ void ThreadSocketHandler()\n             // Send\n             //\n             if (pnode->hSocket == INVALID_SOCKET)\n+            {\n                 continue;\n+            }\n+\n             if (FD_ISSET(pnode->hSocket, &fdsetSend))\n             {\n                 TRY_LOCK(pnode->cs_vSend, lockSend);\n+\n                 if (lockSend)\n+                {\n                     SocketSendData(pnode);\n+                }\n             }\n \n             //\n             // Inactivity checking\n             //\n             int64_t nTime = GetTime();\n+\n             if (nTime - pnode->nTimeConnected > 60)\n             {\n                 if (pnode->nLastRecv == 0 || pnode->nLastSend == 0)\n                 {\n-                    LogPrint(\"net\", \"socket no message in first 60 seconds, %d %d from %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0, pnode->id);\n+                    LogPrint(\"net\", \"socket no message in first 60 seconds, %d %d from %d\\n\", pnode->nLastRecv != 0,\n+                        pnode->nLastSend != 0,\n+                        pnode->id);\n                     pnode->fDisconnect = true;\n                 }\n                 else if (nTime - pnode->nLastSend > TIMEOUT_INTERVAL)\n                 {\n                     LogPrintf(\"socket sending timeout: %is\\n\", nTime - pnode->nLastSend);\n                     pnode->fDisconnect = true;\n                 }\n-                else if (nTime - pnode->nLastRecv > (pnode->nVersion > BIP0031_VERSION ? TIMEOUT_INTERVAL : 90*60))\n+                else if (nTime - pnode->nLastRecv > (pnode->nVersion > BIP0031_VERSION ? TIMEOUT_INTERVAL : 90 * 60))\n                 {\n                     LogPrintf(\"socket receive timeout: %is\\n\", nTime - pnode->nLastRecv);\n                     pnode->fDisconnect = true;\n@@ -1075,29 +1304,25 @@ void ThreadSocketHandler()\n                 }\n             }\n         }\n+\n         {\n             LOCK(cs_vNodes);\n-            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n+\n+            BOOST_FOREACH (CNode* pnode, vNodesCopy)\n+            {\n                 pnode->Release();\n+            }\n         }\n     }\n }\n \n-\n-\n-\n-\n-\n-\n-\n-\n #ifdef USE_UPNP\n void ThreadMapPort()\n {\n     std::string port = strprintf(\"%u\", GetListenPort());\n-    const char * multicastif = 0;\n-    const char * minissdpdpath = 0;\n-    struct UPNPDev * devlist = 0;\n+    const char* multicastif = 0;\n+    const char* minissdpdpath = 0;\n+    struct UPNPDev* devlist = 0;\n     char lanaddr[64];\n \n #ifndef UPNPDISCOVER_SUCCESS\n@@ -1114,61 +1339,83 @@ void ThreadMapPort()\n     int r;\n \n     r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n+\n     if (r == 1)\n     {\n-        if (fDiscover) {\n+        if (fDiscover)\n+        {\n             char externalIPAddress[40];\n             r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n-            if(r != UPNPCOMMAND_SUCCESS)\n+\n+            if (r != UPNPCOMMAND_SUCCESS)\n+            {\n                 LogPrintf(\"UPnP: GetExternalIPAddress() returned %d\\n\", r);\n+            }\n             else\n             {\n-                if(externalIPAddress[0])\n+                if (externalIPAddress[0])\n                 {\n                     LogPrintf(\"UPnP: ExternalIPAddress = %s\\n\", externalIPAddress);\n                     AddLocal(CNetAddr(externalIPAddress), LOCAL_UPNP);\n                 }\n                 else\n+                {\n                     LogPrintf(\"UPnP: GetExternalIPAddress failed.\\n\");\n+                }\n             }\n         }\n \n         string strDesc = \"Bitcoin \" + FormatFullVersion();\n \n-        try {\n-            while (true) {\n+        try\n+        {\n+            while (true)\n+            {\n #ifndef UPNPDISCOVER_SUCCESS\n                 /* miniupnpc 1.5 */\n                 r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n-                                    port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0);\n+                    port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0);\n #else\n                 /* miniupnpc 1.6 */\n                 r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n-                                    port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n+                    port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n #endif\n \n-                if(r!=UPNPCOMMAND_SUCCESS)\n+                if (r != UPNPCOMMAND_SUCCESS)\n+                {\n                     LogPrintf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\",\n                         port, port, lanaddr, r, strupnperror(r));\n+                }\n                 else\n-                    LogPrintf(\"UPnP Port Mapping successful.\\n\");;\n+                {\n+                    LogPrintf(\"UPnP Port Mapping successful.\\n\");\n+                }\n \n-                MilliSleep(20*60*1000); // Refresh every 20 minutes\n+                ;\n+\n+                MilliSleep(20 * 60 * 1000); // Refresh every 20 minutes\n             }\n         }\n         catch (boost::thread_interrupted)\n         {\n             r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n             LogPrintf(\"UPNP_DeletePortMapping() returned : %d\\n\", r);\n-            freeUPNPDevlist(devlist); devlist = 0;\n+            freeUPNPDevlist(devlist);\n+            devlist = 0;\n             FreeUPNPUrls(&urls);\n             throw;\n         }\n-    } else {\n+    }\n+    else\n+    {\n         LogPrintf(\"No valid UPnP IGDs found\\n\");\n-        freeUPNPDevlist(devlist); devlist = 0;\n+        freeUPNPDevlist(devlist);\n+        devlist = 0;\n+\n         if (r != 0)\n+        {\n             FreeUPNPUrls(&urls);\n+        }\n     }\n }\n \n@@ -1178,14 +1425,17 @@ void MapPort(bool fUseUPnP)\n \n     if (fUseUPnP)\n     {\n-        if (upnp_thread) {\n+        if (upnp_thread)\n+        {\n             upnp_thread->interrupt();\n             upnp_thread->join();\n             delete upnp_thread;\n         }\n+\n         upnp_thread = new boost::thread(boost::bind(&TraceThread<void (*)()>, \"upnp\", &ThreadMapPort));\n     }\n-    else if (upnp_thread) {\n+    else if (upnp_thread)\n+    {\n         upnp_thread->interrupt();\n         upnp_thread->join();\n         delete upnp_thread;\n@@ -1198,22 +1448,21 @@ void MapPort(bool)\n {\n     // Intentionally left blank.\n }\n-#endif\n-\n-\n-\n-\n \n+#endif\n \n void ThreadDNSAddressSeed()\n {\n     // goal: only query DNS seeds if address need is acute\n     if ((addrman.size() > 0) &&\n-        (!GetBoolArg(\"-forcednsseed\", false))) {\n+        (!GetBoolArg(\"-forcednsseed\", false)))\n+    {\n         MilliSleep(11 * 1000);\n \n         LOCK(cs_vNodes);\n-        if (vNodes.size() >= 2) {\n+\n+        if (vNodes.size() >= 2)\n+        {\n             LogPrintf(\"P2P peers available. Skipped DNS seeding.\\n\");\n             return;\n         }\n@@ -1224,67 +1473,72 @@ void ThreadDNSAddressSeed()\n \n     LogPrintf(\"Loading addresses from DNS seeds (could take a while)\\n\");\n \n-    BOOST_FOREACH(const CDNSSeedData &seed, vSeeds) {\n-        if (HaveNameProxy()) {\n+    BOOST_FOREACH (const CDNSSeedData &seed, vSeeds)\n+    {\n+        if (HaveNameProxy())\n+        {\n             AddOneShot(seed.host);\n-        } else {\n+        }\n+        else\n+        {\n             vector<CNetAddr> vIPs;\n             vector<CAddress> vAdd;\n+\n             if (LookupHost(seed.host.c_str(), vIPs))\n             {\n-                BOOST_FOREACH(CNetAddr& ip, vIPs)\n+                BOOST_FOREACH (CNetAddr& ip, vIPs)\n                 {\n-                    int nOneDay = 24*3600;\n+                    int nOneDay = 24 * 3600;\n                     CAddress addr = CAddress(CService(ip, Params().GetDefaultPort()));\n-                    addr.nTime = GetTime() - 3*nOneDay - GetRand(4*nOneDay); // use a random age between 3 and 7 days old\n+                    addr.nTime = GetTime() - 3 * nOneDay - GetRand(4 * nOneDay); // use a random age between 3 and 7 days old\n                     vAdd.push_back(addr);\n                     found++;\n                 }\n             }\n+\n             addrman.Add(vAdd, CNetAddr(seed.name, true));\n         }\n     }\n \n     LogPrintf(\"%d addresses found from DNS seeds\\n\", found);\n }\n \n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n void DumpAddresses()\n {\n     int64_t nStart = GetTimeMillis();\n \n     CAddrDB adb;\n+\n     adb.Write(addrman);\n \n     LogPrint(\"net\", \"Flushed %d addresses to peers.dat  %dms\\n\",\n-           addrman.size(), GetTimeMillis() - nStart);\n+        addrman.size(), GetTimeMillis() - nStart);\n }\n \n void static ProcessOneShot()\n {\n     string strDest;\n+\n     {\n         LOCK(cs_vOneShots);\n+\n         if (vOneShots.empty())\n+        {\n             return;\n+        }\n+\n         strDest = vOneShots.front();\n         vOneShots.pop_front();\n     }\n     CAddress addr;\n     CSemaphoreGrant grant(*semOutbound, true);\n-    if (grant) {\n+\n+    if (grant)\n+    {\n         if (!OpenNetworkConnection(addr, &grant, strDest.c_str(), true))\n+        {\n             AddOneShot(strDest);\n+        }\n     }\n }\n \n@@ -1296,21 +1550,25 @@ void ThreadOpenConnections()\n         for (int64_t nLoop = 0;; nLoop++)\n         {\n             ProcessOneShot();\n-            BOOST_FOREACH(string strAddr, mapMultiArgs[\"-connect\"])\n+\n+            BOOST_FOREACH (string strAddr, mapMultiArgs[\"-connect\"])\n             {\n                 CAddress addr;\n                 OpenNetworkConnection(addr, NULL, strAddr.c_str());\n+\n                 for (int i = 0; i < 10 && i < nLoop; i++)\n                 {\n                     MilliSleep(500);\n                 }\n             }\n+\n             MilliSleep(500);\n         }\n     }\n \n     // Initiate network connections\n     int64_t nStart = GetTime();\n+\n     while (true)\n     {\n         ProcessOneShot();\n@@ -1321,9 +1579,12 @@ void ThreadOpenConnections()\n         boost::this_thread::interruption_point();\n \n         // Add seed nodes if DNS seeds are all down (an infrastructure attack?).\n-        if (addrman.size() == 0 && (GetTime() - nStart > 60)) {\n+        if (addrman.size() == 0 && (GetTime() - nStart > 60))\n+        {\n             static bool done = false;\n-            if (!done) {\n+\n+            if (!done)\n+            {\n                 LogPrintf(\"Adding fixed seed nodes as DNS doesn't seem to be available.\\n\");\n                 addrman.Add(Params().FixedSeeds(), CNetAddr(\"127.0.0.1\"));\n                 done = true;\n@@ -1341,8 +1602,11 @@ void ThreadOpenConnections()\n         set<vector<unsigned char> > setConnected;\n         {\n             LOCK(cs_vNodes);\n-            BOOST_FOREACH(CNode* pnode, vNodes) {\n-                if (!pnode->fInbound) {\n+\n+            BOOST_FOREACH (CNode* pnode, vNodes)\n+            {\n+                if (!pnode->fInbound)\n+                {\n                     setConnected.insert(pnode->addr.GetGroup());\n                     nOutbound++;\n                 }\n@@ -1352,39 +1616,53 @@ void ThreadOpenConnections()\n         int64_t nANow = GetAdjustedTime();\n \n         int nTries = 0;\n+\n         while (true)\n         {\n             // use an nUnkBias between 10 (no outgoing connections) and 90 (8 outgoing connections)\n-            CAddress addr = addrman.Select(10 + min(nOutbound,8)*10);\n+            CAddress addr = addrman.Select(10 + min(nOutbound, 8) * 10);\n \n             // if we selected an invalid address, restart\n             if (!addr.IsValid() || setConnected.count(addr.GetGroup()) || IsLocal(addr))\n+            {\n                 break;\n+            }\n \n             // If we didn't find an appropriate destination after trying 100 addresses fetched from addrman,\n             // stop this loop, and let the outer loop run again (which sleeps, adds seed nodes, recalculates\n             // already-connected network ranges, ...) before trying new addrman addresses.\n             nTries++;\n+\n             if (nTries > 100)\n+            {\n                 break;\n+            }\n \n             if (IsLimited(addr))\n+            {\n                 continue;\n+            }\n \n             // only consider very recently tried nodes after 30 failed attempts\n             if (nANow - addr.nLastTry < 600 && nTries < 30)\n+            {\n                 continue;\n+            }\n \n             // do not allow non-default ports, unless after 50 invalid addresses selected already\n             if (addr.GetPort() != Params().GetDefaultPort() && nTries < 50)\n+            {\n                 continue;\n+            }\n \n             addrConnect = addr;\n             break;\n         }\n \n         if (addrConnect.IsValid())\n+        {\n             OpenNetworkConnection(addrConnect, &grant);\n+        }\n     }\n }\n \n@@ -1395,20 +1673,28 @@ void ThreadOpenAddedConnections()\n         vAddedNodes = mapMultiArgs[\"-addnode\"];\n     }\n \n-    if (HaveNameProxy()) {\n-        while(true) {\n+    if (HaveNameProxy())\n+    {\n+        while (true)\n+        {\n             list<string> lAddresses(0);\n             {\n                 LOCK(cs_vAddedNodes);\n-                BOOST_FOREACH(string& strAddNode, vAddedNodes)\n+\n+                BOOST_FOREACH (string& strAddNode, vAddedNodes)\n+                {\n                     lAddresses.push_back(strAddNode);\n+                }\n             }\n-            BOOST_FOREACH(string& strAddNode, lAddresses) {\n+\n+            BOOST_FOREACH (string& strAddNode, lAddresses)\n+            {\n                 CAddress addr;\n                 CSemaphoreGrant grant(*semOutbound);\n                 OpenNetworkConnection(addr, &grant, strAddNode.c_str());\n                 MilliSleep(500);\n             }\n+\n             MilliSleep(120000); // Retry every 2 minutes\n         }\n     }\n@@ -1418,107 +1704,150 @@ void ThreadOpenAddedConnections()\n         list<string> lAddresses(0);\n         {\n             LOCK(cs_vAddedNodes);\n-            BOOST_FOREACH(string& strAddNode, vAddedNodes)\n+\n+            BOOST_FOREACH (string& strAddNode, vAddedNodes)\n+            {\n                 lAddresses.push_back(strAddNode);\n+            }\n         }\n \n         list<vector<CService> > lservAddressesToAdd(0);\n-        BOOST_FOREACH(string& strAddNode, lAddresses)\n+\n+        BOOST_FOREACH (string& strAddNode, lAddresses)\n         {\n             vector<CService> vservNode(0);\n-            if(Lookup(strAddNode.c_str(), vservNode, Params().GetDefaultPort(), fNameLookup, 0))\n+\n+            if (Lookup(strAddNode.c_str(), vservNode, Params().GetDefaultPort(), fNameLookup, 0))\n             {\n                 lservAddressesToAdd.push_back(vservNode);\n                 {\n                     LOCK(cs_setservAddNodeAddresses);\n-                    BOOST_FOREACH(CService& serv, vservNode)\n+\n+                    BOOST_FOREACH (CService& serv, vservNode)\n+                    {\n                         setservAddNodeAddresses.insert(serv);\n+                    }\n                 }\n             }\n         }\n+\n         // Attempt to connect to each IP for each addnode entry until at least one is successful per addnode entry\n         // (keeping in mind that addnode entries can have many IPs if fNameLookup)\n         {\n             LOCK(cs_vNodes);\n-            BOOST_FOREACH(CNode* pnode, vNodes)\n-                for (list<vector<CService> >::iterator it = lservAddressesToAdd.begin(); it != lservAddressesToAdd.end(); it++)\n-                    BOOST_FOREACH(CService& addrNode, *(it))\n+\n+            BOOST_FOREACH (CNode* pnode, vNodes)\n+            {\n+                for (list<vector<CService> >::iterator it = lservAddressesToAdd.begin(); it != lservAddressesToAdd.end();\n+                    it++)\n+                {\n+                    BOOST_FOREACH (CService& addrNode, *(it))\n+                    {\n                         if (pnode->addr == addrNode)\n                         {\n                             it = lservAddressesToAdd.erase(it);\n                             it--;\n                             break;\n                         }\n+                    }\n+                }\n+            }\n         }\n-        BOOST_FOREACH(vector<CService>& vserv, lservAddressesToAdd)\n+\n+        BOOST_FOREACH (vector<CService>& vserv, lservAddressesToAdd)\n         {\n             CSemaphoreGrant grant(*semOutbound);\n             OpenNetworkConnection(CAddress(vserv[i % vserv.size()]), &grant);\n             MilliSleep(500);\n         }\n+\n         MilliSleep(120000); // Retry every 2 minutes\n     }\n }\n \n // if successful, this moves the passed grant to the constructed node\n-bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOutbound, const char *pszDest, bool fOneShot)\n+bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant* grantOutbound, const char* pszDest,\n+    bool fOneShot)\n {\n     //\n     // Initiate outbound network connection\n     //\n     boost::this_thread::interruption_point();\n-    if (!pszDest) {\n+\n+    if (!pszDest)\n+    {\n         if (IsLocal(addrConnect) ||\n             FindNode((CNetAddr)addrConnect) || CNode::IsBanned(addrConnect) ||\n             FindNode(addrConnect.ToStringIPPort()))\n+        {\n             return false;\n-    } else if (FindNode(pszDest))\n+        }\n+    }\n+    else if (FindNode(pszDest))\n+    {\n         return false;\n+    }\n \n     CNode* pnode = ConnectNode(addrConnect, pszDest);\n     boost::this_thread::interruption_point();\n \n     if (!pnode)\n+    {\n         return false;\n+    }\n+\n     if (grantOutbound)\n+    {\n         grantOutbound->MoveTo(pnode->grantOutbound);\n+    }\n+\n     pnode->fNetworkNode = true;\n+\n     if (fOneShot)\n+    {\n         pnode->fOneShot = true;\n+    }\n \n     return true;\n }\n \n-\n // for now, use a very simple selection metric: the node from which we received\n // most recently\n-static int64_t NodeSyncScore(const CNode *pnode) {\n+static int64_t NodeSyncScore(const CNode* pnode)\n+{\n     return pnode->nLastRecv;\n }\n \n-void static StartSync(const vector<CNode*> &vNodes) {\n-    CNode *pnodeNewSync = NULL;\n+void static StartSync(const vector<CNode*> &vNodes)\n+{\n+    CNode* pnodeNewSync = NULL;\n     int64_t nBestScore = 0;\n \n     int nBestHeight = g_signals.GetHeight().get_value_or(0);\n \n     // Iterate over all nodes\n-    BOOST_FOREACH(CNode* pnode, vNodes) {\n+    BOOST_FOREACH (CNode* pnode, vNodes)\n+    {\n         // check preconditions for allowing a sync\n         if (!pnode->fClient && !pnode->fOneShot &&\n             !pnode->fDisconnect && pnode->fSuccessfullyConnected &&\n             (pnode->nStartingHeight > (nBestHeight - 144)) &&\n-            (pnode->nVersion < NOBLKS_VERSION_START || pnode->nVersion >= NOBLKS_VERSION_END)) {\n+            (pnode->nVersion < NOBLKS_VERSION_START || pnode->nVersion >= NOBLKS_VERSION_END))\n+        {\n             // if ok, compare node's score with the best so far\n             int64_t nScore = NodeSyncScore(pnode);\n-            if (pnodeNewSync == NULL || nScore > nBestScore) {\n+\n+            if (pnodeNewSync == NULL || nScore > nBestScore)\n+            {\n                 pnodeNewSync = pnode;\n                 nBestScore = nScore;\n             }\n         }\n     }\n+\n     // if a new sync candidate was found, start sync!\n-    if (pnodeNewSync) {\n+    if (pnodeNewSync)\n+    {\n         pnodeNewSync->fStartSync = true;\n         pnodeSync = pnodeNewSync;\n     }\n@@ -1527,6 +1856,7 @@ void static StartSync(const vector<CNode*> &vNodes) {\n void ThreadMessageHandler()\n {\n     SetThreadPriority(THREAD_PRIORITY_BELOW_NORMAL);\n+\n     while (true)\n     {\n         bool fHaveSyncNode = false;\n@@ -1535,35 +1865,50 @@ void ThreadMessageHandler()\n         {\n             LOCK(cs_vNodes);\n             vNodesCopy = vNodes;\n-            BOOST_FOREACH(CNode* pnode, vNodesCopy) {\n+\n+            BOOST_FOREACH (CNode* pnode, vNodesCopy)\n+            {\n                 pnode->AddRef();\n+\n                 if (pnode == pnodeSync)\n+                {\n                     fHaveSyncNode = true;\n+                }\n             }\n         }\n \n         if (!fHaveSyncNode)\n+        {\n             StartSync(vNodesCopy);\n+        }\n \n         // Poll the connected nodes for messages\n         CNode* pnodeTrickle = NULL;\n+\n         if (!vNodesCopy.empty())\n+        {\n             pnodeTrickle = vNodesCopy[GetRand(vNodesCopy.size())];\n+        }\n \n         bool fSleep = true;\n \n-        BOOST_FOREACH(CNode* pnode, vNodesCopy)\n+        BOOST_FOREACH (CNode* pnode, vNodesCopy)\n         {\n             if (pnode->fDisconnect)\n+            {\n                 continue;\n+            }\n \n             // Receive messages\n             {\n                 TRY_LOCK(pnode->cs_vRecvMsg, lockRecv);\n+\n                 if (lockRecv)\n                 {\n                     if (!g_signals.ProcessMessages(pnode))\n+                    {\n                         pnode->CloseSocketDisconnect();\n+                    }\n \n                     if (pnode->nSendSize < SendBufferSize())\n                     {\n@@ -1579,28 +1924,31 @@ void ThreadMessageHandler()\n             // Send messages\n             {\n                 TRY_LOCK(pnode->cs_vSend, lockSend);\n+\n                 if (lockSend)\n+                {\n                     g_signals.SendMessages(pnode, pnode == pnodeTrickle);\n+                }\n             }\n             boost::this_thread::interruption_point();\n         }\n \n         {\n             LOCK(cs_vNodes);\n-            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n+\n+            BOOST_FOREACH (CNode* pnode, vNodesCopy)\n+            {\n                 pnode->Release();\n+            }\n         }\n \n         if (fSleep)\n+        {\n             MilliSleep(100);\n+        }\n     }\n }\n \n-\n-\n-\n-\n-\n bool BindListenPort(const CService &addrBind, string& strError, bool fWhitelisted)\n {\n     strError = \"\";\n@@ -1609,6 +1957,7 @@ bool BindListenPort(const CService &addrBind, string& strError, bool fWhiteliste\n     // Create socket for listening for incoming connections\n     struct sockaddr_storage sockaddr;\n     socklen_t len = sizeof(sockaddr);\n+\n     if (!addrBind.GetSockAddr((struct sockaddr*)&sockaddr, &len))\n     {\n         strError = strprintf(\"Error: Bind address family for %s not supported\", addrBind.ToString());\n@@ -1617,9 +1966,13 @@ bool BindListenPort(const CService &addrBind, string& strError, bool fWhiteliste\n     }\n \n     SOCKET hListenSocket = socket(((struct sockaddr*)&sockaddr)->sa_family, SOCK_STREAM, IPPROTO_TCP);\n+\n     if (hListenSocket == INVALID_SOCKET)\n     {\n-        strError = strprintf(\"Error: Couldn't open socket for incoming connections (socket returned error %s)\", NetworkErrorString(WSAGetLastError()));\n+        strError =\n+            strprintf(\"Error: Couldn't open socket for incoming connections (socket returned error %s)\",\n+            NetworkErrorString(\n+                WSAGetLastError()));\n         LogPrintf(\"%s\\n\", strError);\n         return false;\n     }\n@@ -1635,15 +1988,19 @@ bool BindListenPort(const CService &addrBind, string& strError, bool fWhiteliste\n #endif\n \n     // Set to non-blocking, incoming connections will also inherit this\n-    if (!SetSocketNonBlocking(hListenSocket, true)) {\n-        strError = strprintf(\"BindListenPort: Setting listening socket to non-blocking failed, error %s\\n\", NetworkErrorString(WSAGetLastError()));\n+    if (!SetSocketNonBlocking(hListenSocket, true))\n+    {\n+        strError =\n+            strprintf(\"BindListenPort: Setting listening socket to non-blocking failed, error %s\\n\", NetworkErrorString(\n+                WSAGetLastError()));\n         LogPrintf(\"%s\\n\", strError);\n         return false;\n     }\n \n     // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n     // and enable it by default or not. Try to enable it, if possible.\n-    if (addrBind.IsIPv6()) {\n+    if (addrBind.IsIPv6())\n+    {\n #ifdef IPV6_V6ONLY\n #ifdef WIN32\n         setsockopt(hListenSocket, IPPROTO_IPV6, IPV6_V6ONLY, (const char*)&nOne, sizeof(int));\n@@ -1660,20 +2017,32 @@ bool BindListenPort(const CService &addrBind, string& strError, bool fWhiteliste\n     if (::bind(hListenSocket, (struct sockaddr*)&sockaddr, len) == SOCKET_ERROR)\n     {\n         int nErr = WSAGetLastError();\n+\n         if (nErr == WSAEADDRINUSE)\n-            strError = strprintf(_(\"Unable to bind to %s on this computer. Bitcoin Core is probably already running.\"), addrBind.ToString());\n+        {\n+            strError = strprintf(_(\n+                    \"Unable to bind to %s on this computer. Bitcoin Core is probably already running.\"),\n+                addrBind.ToString());\n+        }\n         else\n-            strError = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"), addrBind.ToString(), NetworkErrorString(nErr));\n+        {\n+            strError = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"), addrBind.ToString(\n+                    ), NetworkErrorString(nErr));\n+        }\n+\n         LogPrintf(\"%s\\n\", strError);\n         CloseSocket(hListenSocket);\n         return false;\n     }\n+\n     LogPrintf(\"Bound to %s\\n\", addrBind.ToString());\n \n     // Listen for incoming connections\n     if (listen(hListenSocket, SOMAXCONN) == SOCKET_ERROR)\n     {\n-        strError = strprintf(_(\"Error: Listening for incoming connections failed (listen returned error %s)\"), NetworkErrorString(WSAGetLastError()));\n+        strError = strprintf(_(\n+                \"Error: Listening for incoming connections failed (listen returned error %s)\"),\n+            NetworkErrorString(WSAGetLastError()));\n         LogPrintf(\"%s\\n\", strError);\n         CloseSocket(hListenSocket);\n         return false;\n@@ -1682,22 +2051,28 @@ bool BindListenPort(const CService &addrBind, string& strError, bool fWhiteliste\n     vhListenSocket.push_back(ListenSocket(hListenSocket, fWhitelisted));\n \n     if (addrBind.IsRoutable() && fDiscover && !fWhitelisted)\n+    {\n         AddLocal(addrBind, LOCAL_BIND);\n+    }\n \n     return true;\n }\n \n void static Discover(boost::thread_group& threadGroup)\n {\n     if (!fDiscover)\n+    {\n         return;\n+    }\n \n #ifdef WIN32\n     // Get local host IP\n     char pszHostName[1000] = \"\";\n+\n     if (gethostname(pszHostName, sizeof(pszHostName)) != SOCKET_ERROR)\n     {\n         vector<CNetAddr> vaddr;\n+\n         if (LookupHost(pszHostName, vaddr))\n         {\n             BOOST_FOREACH (const CNetAddr &addr, vaddr)\n@@ -1706,51 +2081,82 @@ void static Discover(boost::thread_group& threadGroup)\n             }\n         }\n     }\n+\n #else\n     // Get local host ip\n     struct ifaddrs* myaddrs;\n+\n     if (getifaddrs(&myaddrs) == 0)\n     {\n         for (struct ifaddrs* ifa = myaddrs; ifa != NULL; ifa = ifa->ifa_next)\n         {\n-            if (ifa->ifa_addr == NULL) continue;\n-            if ((ifa->ifa_flags & IFF_UP) == 0) continue;\n-            if (strcmp(ifa->ifa_name, \"lo\") == 0) continue;\n-            if (strcmp(ifa->ifa_name, \"lo0\") == 0) continue;\n+            if (ifa->ifa_addr == NULL)\n+            {\n+                continue;\n+            }\n+\n+            if ((ifa->ifa_flags & IFF_UP) == 0)\n+            {\n+                continue;\n+            }\n+\n+            if (strcmp(ifa->ifa_name, \"lo\") == 0)\n+            {\n+                continue;\n+            }\n+\n+            if (strcmp(ifa->ifa_name, \"lo0\") == 0)\n+            {\n+                continue;\n+            }\n+\n             if (ifa->ifa_addr->sa_family == AF_INET)\n             {\n                 struct sockaddr_in* s4 = (struct sockaddr_in*)(ifa->ifa_addr);\n                 CNetAddr addr(s4->sin_addr);\n+\n                 if (AddLocal(addr, LOCAL_IF))\n+                {\n                     LogPrintf(\"IPv4 %s: %s\\n\", ifa->ifa_name, addr.ToString());\n+                }\n             }\n             else if (ifa->ifa_addr->sa_family == AF_INET6)\n             {\n                 struct sockaddr_in6* s6 = (struct sockaddr_in6*)(ifa->ifa_addr);\n                 CNetAddr addr(s6->sin6_addr);\n+\n                 if (AddLocal(addr, LOCAL_IF))\n+                {\n                     LogPrintf(\"IPv6 %s: %s\\n\", ifa->ifa_name, addr.ToString());\n+                }\n             }\n         }\n+\n         freeifaddrs(myaddrs);\n     }\n+\n #endif\n \n     // Don't use external IPv4 discovery, when -onlynet=\"IPv6\"\n     if (!IsLimited(NET_IPV4))\n+    {\n         threadGroup.create_thread(boost::bind(&TraceThread<void (*)()>, \"ext-ip\", &ThreadGetMyExternalIP));\n+    }\n }\n \n void StartNode(boost::thread_group& threadGroup)\n {\n-    if (semOutbound == NULL) {\n+    if (semOutbound == NULL)\n+    {\n         // initialize semaphore\n         int nMaxOutbound = min(MAX_OUTBOUND_CONNECTIONS, nMaxConnections);\n         semOutbound = new CSemaphore(nMaxOutbound);\n     }\n \n     if (pnodeLocalHost == NULL)\n+    {\n         pnodeLocalHost = new CNode(INVALID_SOCKET, CAddress(CService(\"127.0.0.1\", 0), nLocalServices));\n+    }\n \n     Discover(threadGroup);\n \n@@ -1759,9 +2165,13 @@ void StartNode(boost::thread_group& threadGroup)\n     //\n \n     if (!GetBoolArg(\"-dnsseed\", true))\n+    {\n         LogPrintf(\"DNS seeding disabled\\n\");\n+    }\n     else\n+    {\n         threadGroup.create_thread(boost::bind(&TraceThread<void (*)()>, \"dnsseed\", &ThreadDNSAddressSeed));\n+    }\n \n     // Map ports with UPnP\n     MapPort(GetBoolArg(\"-upnp\", DEFAULT_UPNP));\n@@ -1779,16 +2189,23 @@ void StartNode(boost::thread_group& threadGroup)\n     threadGroup.create_thread(boost::bind(&TraceThread<void (*)()>, \"msghand\", &ThreadMessageHandler));\n \n     // Dump network addresses\n-    threadGroup.create_thread(boost::bind(&LoopForever<void (*)()>, \"dumpaddr\", &DumpAddresses, DUMP_ADDRESSES_INTERVAL * 1000));\n+    threadGroup.create_thread(boost::bind(&LoopForever<void (*)()>, \"dumpaddr\", &DumpAddresses,\n+            DUMP_ADDRESSES_INTERVAL * 1000));\n }\n \n bool StopNode()\n {\n     LogPrintf(\"StopNode()\\n\");\n     MapPort(false);\n+\n     if (semOutbound)\n-        for (int i=0; i<MAX_OUTBOUND_CONNECTIONS; i++)\n+    {\n+        for (int i = 0; i < MAX_OUTBOUND_CONNECTIONS; i++)\n+        {\n             semOutbound->post();\n+        }\n+    }\n+\n     DumpAddresses();\n \n     return true;\n@@ -1797,24 +2214,43 @@ bool StopNode()\n class CNetCleanup\n {\n public:\n-    CNetCleanup() {}\n+    CNetCleanup()\n+    {\n+    }\n \n     ~CNetCleanup()\n     {\n         // Close sockets\n-        BOOST_FOREACH(CNode* pnode, vNodes)\n+        BOOST_FOREACH (CNode* pnode, vNodes)\n+        {\n             if (pnode->hSocket != INVALID_SOCKET)\n+            {\n                 CloseSocket(pnode->hSocket);\n-        BOOST_FOREACH(ListenSocket& hListenSocket, vhListenSocket)\n+            }\n+        }\n+\n+        BOOST_FOREACH (ListenSocket& hListenSocket, vhListenSocket)\n+        {\n             if (hListenSocket.socket != INVALID_SOCKET)\n+            {\n                 if (!CloseSocket(hListenSocket.socket))\n+                {\n                     LogPrintf(\"CloseSocket(hListenSocket) failed with error %s\\n\", NetworkErrorString(WSAGetLastError()));\n+                }\n+            }\n+        }\n \n         // clean up some globals (to help leak detection)\n-        BOOST_FOREACH(CNode *pnode, vNodes)\n+        BOOST_FOREACH (CNode* pnode, vNodes)\n+        {\n             delete pnode;\n-        BOOST_FOREACH(CNode *pnode, vNodesDisconnected)\n+        }\n+\n+        BOOST_FOREACH (CNode* pnode, vNodesDisconnected)\n+        {\n             delete pnode;\n+        }\n+\n         vNodes.clear();\n         vNodesDisconnected.clear();\n         vhListenSocket.clear();\n@@ -1831,15 +2267,10 @@ class CNetCleanup\n }\n instance_of_cnetcleanup;\n \n-\n-\n-\n-\n-\n-\n void RelayTransaction(const CTransaction& tx)\n {\n     CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n+\n     ss.reserve(10000);\n     ss << tx;\n     RelayTransaction(tx, ss);\n@@ -1848,8 +2279,10 @@ void RelayTransaction(const CTransaction& tx)\n void RelayTransaction(const CTransaction& tx, const CDataStream& ss)\n {\n     CInv inv(MSG_TX, tx.GetHash());\n+\n     {\n         LOCK(cs_mapRelay);\n+\n         // Expire old relay messages\n         while (!vRelayExpiration.empty() && vRelayExpiration.front().first < GetTime())\n         {\n@@ -1862,17 +2295,27 @@ void RelayTransaction(const CTransaction& tx, const CDataStream& ss)\n         vRelayExpiration.push_back(std::make_pair(GetTime() + 15 * 60, inv));\n     }\n     LOCK(cs_vNodes);\n-    BOOST_FOREACH(CNode* pnode, vNodes)\n+\n+    BOOST_FOREACH (CNode* pnode, vNodes)\n     {\n-        if(!pnode->fRelayTxes)\n+        if (!pnode->fRelayTxes)\n+        {\n             continue;\n+        }\n+\n         LOCK(pnode->cs_filter);\n+\n         if (pnode->pfilter)\n         {\n             if (pnode->pfilter->IsRelevantAndUpdate(tx))\n+            {\n                 pnode->PushInventory(inv);\n-        } else\n+            }\n+        }\n+        else\n+        {\n             pnode->PushInventory(inv);\n+        }\n     }\n }\n \n@@ -1902,34 +2345,48 @@ uint64_t CNode::GetTotalBytesSent()\n \n void CNode::Fuzz(int nChance)\n {\n-    if (!fSuccessfullyConnected) return; // Don't fuzz initial handshake\n-    if (GetRand(nChance) != 0) return; // Fuzz 1 of every nChance messages\n+    if (!fSuccessfullyConnected)\n+    {\n+        return;                          // Don't fuzz initial handshake\n+    }\n+\n+    if (GetRand(nChance) != 0)\n+    {\n+        return;                        // Fuzz 1 of every nChance messages\n+    }\n \n     switch (GetRand(3))\n     {\n     case 0:\n+\n         // xor a random byte with a random value:\n-        if (!ssSend.empty()) {\n+        if (!ssSend.empty())\n+        {\n             CDataStream::size_type pos = GetRand(ssSend.size());\n             ssSend[pos] ^= (unsigned char)(GetRand(256));\n         }\n+\n         break;\n     case 1:\n+\n         // delete a random byte:\n-        if (!ssSend.empty()) {\n+        if (!ssSend.empty())\n+        {\n             CDataStream::size_type pos = GetRand(ssSend.size());\n-            ssSend.erase(ssSend.begin()+pos);\n+            ssSend.erase(ssSend.begin() + pos);\n         }\n+\n         break;\n     case 2:\n         // insert a random byte at a random position\n-        {\n-            CDataStream::size_type pos = GetRand(ssSend.size());\n-            char ch = (char)GetRand(256);\n-            ssSend.insert(ssSend.begin()+pos, ch);\n-        }\n-        break;\n+    {\n+        CDataStream::size_type pos = GetRand(ssSend.size());\n+        char ch = (char)GetRand(256);\n+        ssSend.insert(ssSend.begin() + pos, ch);\n+    }\n+    break;\n     }\n+\n     // Chance of more than one change half the time:\n     // (more changes exponentially less likely):\n     Fuzz(2);\n@@ -1948,6 +2405,7 @@ bool CAddrDB::Write(const CAddrMan& addr)\n {\n     // Generate random temporary filename\n     unsigned short randv = 0;\n+\n     GetRandBytes((unsigned char*)&randv, sizeof(randv));\n     std::string tmpfn = strprintf(\"peers.dat.%04x\", randv);\n \n@@ -1960,52 +2418,68 @@ bool CAddrDB::Write(const CAddrMan& addr)\n \n     // open temp output file, and associate with CAutoFile\n     boost::filesystem::path pathTmp = GetDataDir() / tmpfn;\n-    FILE *file = fopen(pathTmp.string().c_str(), \"wb\");\n+    FILE* file = fopen(pathTmp.string().c_str(), \"wb\");\n     CAutoFile fileout = CAutoFile(file, SER_DISK, CLIENT_VERSION);\n+\n     if (!fileout)\n+    {\n         return error(\"%s : Failed to open file %s\", __func__, pathTmp.string());\n+    }\n \n     // Write and commit header, data\n-    try {\n+    try\n+    {\n         fileout << ssPeers;\n     }\n-    catch (std::exception &e) {\n+    catch (std::exception &e)\n+    {\n         return error(\"%s : Serialize or I/O error - %s\", __func__, e.what());\n     }\n     FileCommit(fileout);\n     fileout.fclose();\n \n     // replace existing peers.dat, if any, with new peers.dat.XXXX\n     if (!RenameOver(pathTmp, pathAddr))\n+    {\n         return error(\"%s : Rename-into-place failed\", __func__);\n+    }\n \n     return true;\n }\n \n bool CAddrDB::Read(CAddrMan& addr)\n {\n     // open input file, and associate with CAutoFile\n-    FILE *file = fopen(pathAddr.string().c_str(), \"rb\");\n+    FILE* file = fopen(pathAddr.string().c_str(), \"rb\");\n     CAutoFile filein = CAutoFile(file, SER_DISK, CLIENT_VERSION);\n+\n     if (!filein)\n+    {\n         return error(\"%s : Failed to open file %s\", __func__, pathAddr.string());\n+    }\n \n     // use file size to size memory buffer\n     int fileSize = boost::filesystem::file_size(pathAddr);\n     int dataSize = fileSize - sizeof(uint256);\n+\n     // Don't try to resize to a negative number if file is small\n     if (dataSize < 0)\n+    {\n         dataSize = 0;\n+    }\n+\n     vector<unsigned char> vchData;\n     vchData.resize(dataSize);\n     uint256 hashIn;\n \n     // read data and checksum from file\n-    try {\n-        filein.read((char *)&vchData[0], dataSize);\n+    try\n+    {\n+        filein.read((char*)&vchData[0], dataSize);\n         filein >> hashIn;\n     }\n-    catch (std::exception &e) {\n+    catch (std::exception &e)\n+    {\n         return error(\"%s : Deserialize or I/O error - %s\", __func__, e.what());\n     }\n     filein.fclose();\n@@ -2014,32 +2488,47 @@ bool CAddrDB::Read(CAddrMan& addr)\n \n     // verify stored checksum matches input data\n     uint256 hashTmp = Hash(ssPeers.begin(), ssPeers.end());\n+\n     if (hashIn != hashTmp)\n+    {\n         return error(\"%s : Checksum mismatch, data corrupted\", __func__);\n+    }\n \n     unsigned char pchMsgTmp[4];\n-    try {\n+    try\n+    {\n         // de-serialize file header (network specific magic number) and ..\n         ssPeers >> FLATDATA(pchMsgTmp);\n \n         // ... verify the network matches ours\n         if (memcmp(pchMsgTmp, Params().MessageStart(), sizeof(pchMsgTmp)))\n+        {\n             return error(\"%s : Invalid network magic number\", __func__);\n+        }\n \n         // de-serialize address data into one CAddrMan object\n         ssPeers >> addr;\n     }\n-    catch (std::exception &e) {\n+    catch (std::exception &e)\n+    {\n         return error(\"%s : Deserialize or I/O error - %s\", __func__, e.what());\n     }\n \n     return true;\n }\n \n-unsigned int ReceiveFloodSize() { return 1000*GetArg(\"-maxreceivebuffer\", 5*1000); }\n-unsigned int SendBufferSize() { return 1000*GetArg(\"-maxsendbuffer\", 1*1000); }\n+unsigned int ReceiveFloodSize()\n+{\n+    return 1000 * GetArg(\"-maxreceivebuffer\", 5 * 1000);\n+}\n+\n+unsigned int SendBufferSize()\n+{\n+    return 1000 * GetArg(\"-maxsendbuffer\", 1 * 1000);\n+}\n \n-CNode::CNode(SOCKET hSocketIn, CAddress addrIn, std::string addrNameIn, bool fInboundIn) : ssSend(SER_NETWORK, INIT_PROTO_VERSION), setAddrKnown(5000)\n+CNode::CNode(SOCKET hSocketIn, CAddress addrIn, std::string addrNameIn, bool fInboundIn) : ssSend(SER_NETWORK,\n+    INIT_PROTO_VERSION), setAddrKnown(5000)\n {\n     nServices = 0;\n     hSocket = hSocketIn;\n@@ -2083,13 +2572,19 @@ CNode::CNode(SOCKET hSocketIn, CAddress addrIn, std::string addrNameIn, bool fIn\n     }\n \n     if (fLogIPs)\n+    {\n         LogPrint(\"net\", \"Added connection to %s peer=%d\\n\", addrName, id);\n+    }\n     else\n+    {\n         LogPrint(\"net\", \"Added connection peer=%d\\n\", id);\n+    }\n \n     // Be shy and don't send version until we hear\n     if (hSocket != INVALID_SOCKET && !fInbound)\n+    {\n         PushVersion();\n+    }\n \n     GetNodeSignals().InitializeNode(GetId(), this);\n }\n@@ -2099,7 +2594,9 @@ CNode::~CNode()\n     CloseSocket(hSocket);\n \n     if (pfilter)\n+    {\n         delete pfilter;\n+    }\n \n     GetNodeSignals().FinalizeNode(GetId());\n }\n@@ -2109,12 +2606,20 @@ void CNode::AskFor(const CInv& inv)\n     // We're using mapAskFor as a priority queue,\n     // the key is the earliest time the request can be sent\n     int64_t nRequestTime;\n+\n     limitedmap<CInv, int64_t>::const_iterator it = mapAlreadyAskedFor.find(inv);\n+\n     if (it != mapAlreadyAskedFor.end())\n+    {\n         nRequestTime = it->second;\n+    }\n     else\n+    {\n         nRequestTime = 0;\n-    LogPrint(\"net\", \"askfor %s  %d (%s) peer=%d\\n\", inv.ToString(), nRequestTime, DateTimeStrFormat(\"%H:%M:%S\", nRequestTime/1000000), id);\n+    }\n+\n+    LogPrint(\"net\", \"askfor %s  %d (%s) peer=%d\\n\", inv.ToString(), nRequestTime,\n+        DateTimeStrFormat(\"%H:%M:%S\", nRequestTime / 1000000), id);\n \n     // Make sure not to reuse time indexes to keep things in the same order\n     int64_t nNow = GetTimeMicros() - 1000000;\n@@ -2125,10 +2630,16 @@ void CNode::AskFor(const CInv& inv)\n \n     // Each retry is 2 minutes after the last\n     nRequestTime = std::max(nRequestTime + 2 * 60 * 1000000, nNow);\n+\n     if (it != mapAlreadyAskedFor.end())\n+    {\n         mapAlreadyAskedFor.update(it, nRequestTime);\n+    }\n     else\n+    {\n         mapAlreadyAskedFor.insert(std::make_pair(inv, nRequestTime));\n+    }\n+\n     mapAskFor.insert(std::make_pair(nRequestTime, inv));\n }\n \n@@ -2160,11 +2671,16 @@ void CNode::EndMessage() UNLOCK_FUNCTION(cs_vSend)\n         AbortMessage();\n         return;\n     }\n+\n     if (mapArgs.count(\"-fuzzmessagestest\"))\n+    {\n         Fuzz(GetArg(\"-fuzzmessagestest\", 10));\n+    }\n \n     if (ssSend.size() == 0)\n+    {\n         return;\n+    }\n \n     // Set the size\n     unsigned int nSize = ssSend.size() - CMessageHeader::HEADER_SIZE;\n@@ -2185,7 +2701,10 @@ void CNode::EndMessage() UNLOCK_FUNCTION(cs_vSend)\n \n     // If write queue empty, attempt \"optimistic write\"\n     if (it == vSendMsg.begin())\n+    {\n         SocketSendData(this);\n+    }\n \n     LEAVE_CRITICAL_SECTION(cs_vSend);\n }\n+"
      },
      {
        "sha": "1854e19e785ddd18c7ea85a524450c4724de700c",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 55,
        "deletions": 40,
        "changes": 95,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -33,8 +33,9 @@ class CAddrMan;\n class CBlockIndex;\n class CNode;\n \n-namespace boost {\n-    class thread_group;\n+namespace boost\n+{\n+class thread_group;\n } // namespace boost\n \n /** Time between pings automatically sent out for latency probing and keepalive (in seconds). */\n@@ -62,14 +63,16 @@ void AddressCurrentlyConnected(const CService& addr);\n CNode* FindNode(const CNetAddr& ip);\n CNode* FindNode(const std::string& addrName);\n CNode* FindNode(const CService& ip);\n-CNode* ConnectNode(CAddress addrConnect, const char *pszDest = NULL);\n-bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOutbound = NULL, const char *strDest = NULL, bool fOneShot = false);\n+CNode* ConnectNode(CAddress addrConnect, const char* pszDest = NULL);\n+bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant* grantOutbound = NULL, const char* strDest =\n+        NULL,\n+    bool fOneShot = false);\n void MapPort(bool fUseUPnP);\n unsigned short GetListenPort();\n bool BindListenPort(const CService &bindAddr, std::string& strError, bool fWhitelisted = false);\n void StartNode(boost::thread_group& threadGroup);\n bool StopNode();\n-void SocketSendData(CNode *pnode);\n+void SocketSendData(CNode* pnode);\n \n typedef int NodeId;\n \n@@ -83,10 +86,8 @@ struct CNodeSignals\n     boost::signals2::signal<void (NodeId)> FinalizeNode;\n };\n \n-\n CNodeSignals& GetNodeSignals();\n \n-\n enum\n {\n     LOCAL_NONE,   // unknown\n@@ -106,12 +107,11 @@ bool AddLocal(const CService& addr, int nScore = LOCAL_NONE);\n bool AddLocal(const CNetAddr& addr, int nScore = LOCAL_NONE);\n bool SeenLocal(const CService& addr);\n bool IsLocal(const CService& addr);\n-bool GetLocal(CService &addr, const CNetAddr *paddrPeer = NULL);\n+bool GetLocal(CService &addr, const CNetAddr* paddrPeer = NULL);\n bool IsReachable(enum Network net);\n bool IsReachable(const CNetAddr &addr);\n void SetReachable(enum Network net, bool fFlag = true);\n-CAddress GetLocalAddress(const CNetAddr *paddrPeer = NULL);\n-\n+CAddress GetLocalAddress(const CNetAddr* paddrPeer = NULL);\n \n extern bool fDiscover;\n extern bool fListen;\n@@ -133,7 +133,8 @@ extern CCriticalSection cs_vAddedNodes;\n extern NodeId nLastNodeId;\n extern CCriticalSection cs_nLastNodeId;\n \n-struct LocalServiceInfo {\n+struct LocalServiceInfo\n+{\n     int nScore;\n     int nPort;\n };\n@@ -163,10 +164,8 @@ class CNodeStats\n     std::string addrLocal;\n };\n \n-\n-\n-\n-class CNetMessage {\n+class CNetMessage\n+{\n public:\n     bool in_data;                   // parsing header (false) or data (true)\n \n@@ -179,7 +178,8 @@ class CNetMessage {\n \n     int64_t nTime;                  // time (in microseconds) of message receipt.\n \n-    CNetMessage(int nTypeIn, int nVersionIn) : hdrbuf(nTypeIn, nVersionIn), vRecv(nTypeIn, nVersionIn) {\n+    CNetMessage(int nTypeIn, int nVersionIn) : hdrbuf(nTypeIn, nVersionIn), vRecv(nTypeIn, nVersionIn)\n+    {\n         hdrbuf.resize(24);\n         in_data = false;\n         nHdrPos = 0;\n@@ -190,7 +190,10 @@ class CNetMessage {\n     bool complete() const\n     {\n         if (!in_data)\n+        {\n             return false;\n+        }\n+\n         return (hdr.nMessageSize == nDataPos);\n     }\n \n@@ -200,14 +203,10 @@ class CNetMessage {\n         vRecv.SetVersion(nVersionIn);\n     }\n \n-    int readHeader(const char *pch, unsigned int nBytes);\n-    int readData(const char *pch, unsigned int nBytes);\n+    int readHeader(const char* pch, unsigned int nBytes);\n+    int readData(const char* pch, unsigned int nBytes);\n };\n \n-\n-\n-\n-\n /** Information about a peer */\n class CNode\n {\n@@ -301,7 +300,7 @@ class CNode\n     // Whether a ping is requested.\n     bool fPingQueued;\n \n-    CNode(SOCKET hSocketIn, CAddress addrIn, std::string addrNameIn = \"\", bool fInboundIn=false);\n+    CNode(SOCKET hSocketIn, CAddress addrIn, std::string addrNameIn = \"\", bool fInboundIn = false);\n     ~CNode();\n \n private:\n@@ -316,8 +315,9 @@ class CNode\n \n public:\n \n-    NodeId GetId() const {\n-      return id;\n+    NodeId GetId() const\n+    {\n+        return id;\n     }\n \n     int GetRefCount()\n@@ -330,20 +330,27 @@ class CNode\n     unsigned int GetTotalRecvSize()\n     {\n         unsigned int total = 0;\n-        BOOST_FOREACH(const CNetMessage &msg, vRecvMsg)\n+\n+        BOOST_FOREACH (const CNetMessage &msg, vRecvMsg)\n+        {\n             total += msg.vRecv.size() + 24;\n+        }\n+\n         return total;\n     }\n \n     // requires LOCK(cs_vRecvMsg)\n-    bool ReceiveMsgBytes(const char *pch, unsigned int nBytes);\n+    bool ReceiveMsgBytes(const char* pch, unsigned int nBytes);\n \n     // requires LOCK(cs_vRecvMsg)\n     void SetRecvVersion(int nVersionIn)\n     {\n         nRecvVersion = nVersionIn;\n-        BOOST_FOREACH(CNetMessage &msg, vRecvMsg)\n+\n+        BOOST_FOREACH (CNetMessage &msg, vRecvMsg)\n+        {\n             msg.SetVersion(nVersionIn);\n+        }\n     }\n \n     CNode* AddRef()\n@@ -357,8 +364,6 @@ class CNode\n         nRefCount--;\n     }\n \n-\n-\n     void AddAddressKnown(const CAddress& addr)\n     {\n         setAddrKnown.insert(addr);\n@@ -370,10 +375,11 @@ class CNode\n         // SendMessages will filter it again for knowns that were added\n         // after addresses were pushed.\n         if (addr.IsValid() && !setAddrKnown.count(addr))\n+        {\n             vAddrToSend.push_back(addr);\n+        }\n     }\n \n-\n     void AddInventoryKnown(const CInv& inv)\n     {\n         {\n@@ -386,8 +392,11 @@ class CNode\n     {\n         {\n             LOCK(cs_inventory);\n+\n             if (!setInventoryKnown.count(inv))\n+            {\n                 vInventoryToSend.push_back(inv);\n+            }\n         }\n     }\n \n@@ -404,7 +413,6 @@ class CNode\n \n     void PushVersion();\n \n-\n     void PushMessage(const char* pszCommand)\n     {\n         try\n@@ -500,7 +508,8 @@ class CNode\n     }\n \n     template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>\n-    void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5, const T6& a6)\n+    void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5,\n+        const T6& a6)\n     {\n         try\n         {\n@@ -516,7 +525,9 @@ class CNode\n     }\n \n     template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>\n-    void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5, const T6& a6, const T7& a7)\n+    void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5,\n+        const T6& a6,\n+        const T7& a7)\n     {\n         try\n         {\n@@ -532,7 +543,9 @@ class CNode\n     }\n \n     template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>\n-    void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5, const T6& a6, const T7& a7, const T8& a8)\n+    void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5,\n+        const T6& a6, const T7& a7,\n+        const T8& a8)\n     {\n         try\n         {\n@@ -547,8 +560,11 @@ class CNode\n         }\n     }\n \n-    template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>\n-    void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5, const T6& a6, const T7& a7, const T8& a8, const T9& a9)\n+    template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8,\n+        typename T9>\n+    void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5,\n+        const T6& a6, const T7& a7, const T8& a8,\n+        const T9& a9)\n     {\n         try\n         {\n@@ -564,7 +580,7 @@ class CNode\n     }\n \n     bool IsSubscribed(unsigned int nChannel);\n-    void Subscribe(unsigned int nChannel, unsigned int nHops=0);\n+    void Subscribe(unsigned int nChannel, unsigned int nHops = 0);\n     void CancelSubscribe(unsigned int nChannel);\n     void CloseSocketDisconnect();\n \n@@ -598,8 +614,6 @@ class CNode\n     static uint64_t GetTotalBytesSent();\n };\n \n-\n-\n class CTransaction;\n void RelayTransaction(const CTransaction& tx);\n void RelayTransaction(const CTransaction& tx, const CDataStream& ss);\n@@ -616,3 +630,4 @@ class CAddrDB\n };\n \n #endif // BITCOIN_NET_H\n+"
      },
      {
        "sha": "d4f58ada4f987eb36551b7bfeaf842a60e940036",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 582,
        "deletions": 173,
        "changes": 755,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b",
        "patch": "@@ -43,52 +43,88 @@ static CCriticalSection cs_proxyInfos;\n int nConnectTimeout = 5000;\n bool fNameLookup = false;\n \n-static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n+static const unsigned char pchIPv4[12] = {\n+0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff\n+};\n \n-enum Network ParseNetwork(std::string net) {\n+enum Network ParseNetwork(std::string net)\n+{\n     boost::to_lower(net);\n-    if (net == \"ipv4\") return NET_IPV4;\n-    if (net == \"ipv6\") return NET_IPV6;\n-    if (net == \"tor\" || net == \"onion\")  return NET_TOR;\n+\n+    if (net == \"ipv4\")\n+    {\n+        return NET_IPV4;\n+    }\n+\n+    if (net == \"ipv6\")\n+    {\n+        return NET_IPV6;\n+    }\n+\n+    if (net == \"tor\" || net == \"onion\")\n+    {\n+        return NET_TOR;\n+    }\n+\n     return NET_UNROUTABLE;\n }\n \n-std::string GetNetworkName(enum Network net) {\n-    switch(net)\n+std::string GetNetworkName(enum Network net)\n+{\n+    switch (net)\n     {\n-    case NET_IPV4: return \"ipv4\";\n-    case NET_IPV6: return \"ipv6\";\n-    case NET_TOR: return \"onion\";\n-    default: return \"\";\n+    case NET_IPV4:\n+        return \"ipv4\";\n+\n+    case NET_IPV6:\n+        return \"ipv6\";\n+\n+    case NET_TOR:\n+        return \"onion\";\n+\n+    default:\n+        return \"\";\n     }\n }\n \n-void SplitHostPort(std::string in, int &portOut, std::string &hostOut) {\n+void SplitHostPort(std::string in, int &portOut, std::string &hostOut)\n+{\n     size_t colon = in.find_last_of(':');\n     // if a : is found, and it either follows a [...], or no other : is in the string, treat it as port separator\n     bool fHaveColon = colon != in.npos;\n-    bool fBracketed = fHaveColon && (in[0]=='[' && in[colon-1]==']'); // if there is a colon, and in[0]=='[', colon is not 0, so in[colon-1] is safe\n-    bool fMultiColon = fHaveColon && (in.find_last_of(':',colon-1) != in.npos);\n-    if (fHaveColon && (colon==0 || fBracketed || !fMultiColon)) {\n+    bool fBracketed = fHaveColon && (in[0] == '[' && in[colon - 1] == ']'); // if there is a colon, and in[0]=='[', colon is not 0, so in[colon-1] is safe\n+    bool fMultiColon = fHaveColon && (in.find_last_of(':', colon - 1) != in.npos);\n+\n+    if (fHaveColon && (colon == 0 || fBracketed || !fMultiColon))\n+    {\n         int32_t n;\n-        if (ParseInt32(in.substr(colon + 1), &n) && n > 0 && n < 0x10000) {\n+\n+        if (ParseInt32(in.substr(colon + 1), &n) && n > 0 && n < 0x10000)\n+        {\n             in = in.substr(0, colon);\n             portOut = n;\n         }\n     }\n-    if (in.size()>0 && in[0] == '[' && in[in.size()-1] == ']')\n-        hostOut = in.substr(1, in.size()-2);\n+\n+    if (in.size() > 0 && in[0] == '[' && in[in.size() - 1] == ']')\n+    {\n+        hostOut = in.substr(1, in.size() - 2);\n+    }\n     else\n+    {\n         hostOut = in;\n+    }\n }\n \n-bool static LookupIntern(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n+bool static LookupIntern(const char* pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n {\n     vIP.clear();\n \n     {\n         CNetAddr addr;\n-        if (addr.SetSpecial(std::string(pszName))) {\n+\n+        if (addr.SetSpecial(std::string(pszName)))\n+        {\n             vIP.push_back(addr);\n             return true;\n         }\n@@ -97,22 +133,30 @@ bool static LookupIntern(const char *pszName, std::vector<CNetAddr>& vIP, unsign\n #ifdef HAVE_GETADDRINFO_A\n     struct in_addr ipv4_addr;\n #ifdef HAVE_INET_PTON\n-    if (inet_pton(AF_INET, pszName, &ipv4_addr) > 0) {\n+\n+    if (inet_pton(AF_INET, pszName, &ipv4_addr) > 0)\n+    {\n         vIP.push_back(CNetAddr(ipv4_addr));\n         return true;\n     }\n \n     struct in6_addr ipv6_addr;\n-    if (inet_pton(AF_INET6, pszName, &ipv6_addr) > 0) {\n+\n+    if (inet_pton(AF_INET6, pszName, &ipv6_addr) > 0)\n+    {\n         vIP.push_back(CNetAddr(ipv6_addr));\n         return true;\n     }\n+\n #else\n     ipv4_addr.s_addr = inet_addr(pszName);\n-    if (ipv4_addr.s_addr != INADDR_NONE) {\n+\n+    if (ipv4_addr.s_addr != INADDR_NONE)\n+    {\n         vIP.push_back(CNetAddr(ipv4_addr));\n         return true;\n     }\n+\n #endif\n #endif\n \n@@ -127,36 +171,51 @@ bool static LookupIntern(const char *pszName, std::vector<CNetAddr>& vIP, unsign\n     aiHint.ai_flags = fAllowLookup ? AI_ADDRCONFIG : AI_NUMERICHOST;\n #endif\n \n-    struct addrinfo *aiRes = NULL;\n+    struct addrinfo* aiRes = NULL;\n #ifdef HAVE_GETADDRINFO_A\n-    struct gaicb gcb, *query = &gcb;\n+    struct gaicb gcb, * query = &gcb;\n     memset(query, 0, sizeof(struct gaicb));\n     gcb.ar_name = pszName;\n     gcb.ar_request = &aiHint;\n     int nErr = getaddrinfo_a(GAI_NOWAIT, &query, 1, NULL);\n+\n     if (nErr)\n+    {\n         return false;\n+    }\n \n-    do {\n+    do\n+    {\n         // Should set the timeout limit to a resonable value to avoid\n         // generating unnecessary checking call during the polling loop,\n         // while it can still response to stop request quick enough.\n         // 2 seconds looks fine in our situation.\n-        struct timespec ts = { 2, 0 };\n+        struct timespec ts = {\n+            2, 0\n+        };\n         gai_suspend(&query, 1, &ts);\n         boost::this_thread::interruption_point();\n \n         nErr = gai_error(query);\n+\n         if (0 == nErr)\n+        {\n             aiRes = query->ar_result;\n-    } while (nErr == EAI_INPROGRESS);\n+        }\n+    }\n+    while (nErr == EAI_INPROGRESS);\n+\n #else\n     int nErr = getaddrinfo(pszName, NULL, &aiHint, &aiRes);\n #endif\n+\n     if (nErr)\n+    {\n         return false;\n+    }\n+\n+    struct addrinfo* aiTrav = aiRes;\n \n-    struct addrinfo *aiTrav = aiRes;\n     while (aiTrav != NULL && (nMaxSolutions == 0 || vIP.size() < nMaxSolutions))\n     {\n         if (aiTrav->ai_family == AF_INET)\n@@ -179,11 +238,15 @@ bool static LookupIntern(const char *pszName, std::vector<CNetAddr>& vIP, unsign\n     return (vIP.size() > 0);\n }\n \n-bool LookupHost(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n+bool LookupHost(const char* pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n {\n     std::string strHost(pszName);\n+\n     if (strHost.empty())\n+    {\n         return false;\n+    }\n+\n     if (boost::algorithm::starts_with(strHost, \"[\") && boost::algorithm::ends_with(strHost, \"]\"))\n     {\n         strHost = strHost.substr(1, strHost.size() - 2);\n@@ -192,139 +255,201 @@ bool LookupHost(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nM\n     return LookupIntern(strHost.c_str(), vIP, nMaxSolutions, fAllowLookup);\n }\n \n-bool Lookup(const char *pszName, std::vector<CService>& vAddr, int portDefault, bool fAllowLookup, unsigned int nMaxSolutions)\n+bool Lookup(const char* pszName, std::vector<CService>& vAddr, int portDefault, bool fAllowLookup,\n+    unsigned int nMaxSolutions)\n {\n     if (pszName[0] == 0)\n+    {\n         return false;\n+    }\n+\n     int port = portDefault;\n     std::string hostname = \"\";\n     SplitHostPort(std::string(pszName), port, hostname);\n \n     std::vector<CNetAddr> vIP;\n     bool fRet = LookupIntern(hostname.c_str(), vIP, nMaxSolutions, fAllowLookup);\n+\n     if (!fRet)\n+    {\n         return false;\n+    }\n+\n     vAddr.resize(vIP.size());\n+\n     for (unsigned int i = 0; i < vIP.size(); i++)\n+    {\n         vAddr[i] = CService(vIP[i], port);\n+    }\n+\n     return true;\n }\n \n-bool Lookup(const char *pszName, CService& addr, int portDefault, bool fAllowLookup)\n+bool Lookup(const char* pszName, CService& addr, int portDefault, bool fAllowLookup)\n {\n     std::vector<CService> vService;\n     bool fRet = Lookup(pszName, vService, portDefault, fAllowLookup, 1);\n+\n     if (!fRet)\n+    {\n         return false;\n+    }\n+\n     addr = vService[0];\n     return true;\n }\n \n-bool LookupNumeric(const char *pszName, CService& addr, int portDefault)\n+bool LookupNumeric(const char* pszName, CService& addr, int portDefault)\n {\n     return Lookup(pszName, addr, portDefault, false);\n }\n \n bool static Socks5(string strDest, int port, SOCKET& hSocket)\n {\n     LogPrintf(\"SOCKS5 connecting %s\\n\", strDest);\n+\n     if (strDest.size() > 255)\n     {\n         CloseSocket(hSocket);\n         return error(\"Hostname too long\");\n     }\n+\n     char pszSocks5Init[] = \"\\5\\1\\0\";\n     ssize_t nSize = sizeof(pszSocks5Init) - 1;\n \n     ssize_t ret = send(hSocket, pszSocks5Init, nSize, MSG_NOSIGNAL);\n+\n     if (ret != nSize)\n     {\n         CloseSocket(hSocket);\n         return error(\"Error sending to proxy\");\n     }\n+\n     char pchRet1[2];\n+\n     if (recv(hSocket, pchRet1, 2, 0) != 2)\n     {\n         CloseSocket(hSocket);\n         return error(\"Error reading proxy response\");\n     }\n+\n     if (pchRet1[0] != 0x05 || pchRet1[1] != 0x00)\n     {\n         CloseSocket(hSocket);\n         return error(\"Proxy failed to initialize\");\n     }\n+\n     string strSocks5(\"\\5\\1\");\n-    strSocks5 += '\\000'; strSocks5 += '\\003';\n+    strSocks5 += '\\000';\n+    strSocks5 += '\\003';\n     strSocks5 += static_cast<char>(std::min((int)strDest.size(), 255));\n     strSocks5 += strDest;\n     strSocks5 += static_cast<char>((port >> 8) & 0xFF);\n     strSocks5 += static_cast<char>((port >> 0) & 0xFF);\n     ret = send(hSocket, strSocks5.data(), strSocks5.size(), MSG_NOSIGNAL);\n+\n     if (ret != (ssize_t)strSocks5.size())\n     {\n         CloseSocket(hSocket);\n         return error(\"Error sending to proxy\");\n     }\n+\n     char pchRet2[4];\n+\n     if (recv(hSocket, pchRet2, 4, 0) != 4)\n     {\n         CloseSocket(hSocket);\n         return error(\"Error reading proxy response\");\n     }\n+\n     if (pchRet2[0] != 0x05)\n     {\n         CloseSocket(hSocket);\n         return error(\"Proxy failed to accept request\");\n     }\n+\n     if (pchRet2[1] != 0x00)\n     {\n         CloseSocket(hSocket);\n+\n         switch (pchRet2[1])\n         {\n-            case 0x01: return error(\"Proxy error: general failure\");\n-            case 0x02: return error(\"Proxy error: connection not allowed\");\n-            case 0x03: return error(\"Proxy error: network unreachable\");\n-            case 0x04: return error(\"Proxy error: host unreachable\");\n-            case 0x05: return error(\"Proxy error: connection refused\");\n-            case 0x06: return error(\"Proxy error: TTL expired\");\n-            case 0x07: return error(\"Proxy error: protocol error\");\n-            case 0x08: return error(\"Proxy error: address type not supported\");\n-            default:   return error(\"Proxy error: unknown\");\n+        case 0x01:\n+            return error(\"Proxy error: general failure\");\n+\n+        case 0x02:\n+            return error(\"Proxy error: connection not allowed\");\n+\n+        case 0x03:\n+            return error(\"Proxy error: network unreachable\");\n+\n+        case 0x04:\n+            return error(\"Proxy error: host unreachable\");\n+\n+        case 0x05:\n+            return error(\"Proxy error: connection refused\");\n+\n+        case 0x06:\n+            return error(\"Proxy error: TTL expired\");\n+\n+        case 0x07:\n+            return error(\"Proxy error: protocol error\");\n+\n+        case 0x08:\n+            return error(\"Proxy error: address type not supported\");\n+\n+        default:\n+            return error(\"Proxy error: unknown\");\n         }\n     }\n+\n     if (pchRet2[2] != 0x00)\n     {\n         CloseSocket(hSocket);\n         return error(\"Error: malformed proxy response\");\n     }\n+\n     char pchRet3[256];\n+\n     switch (pchRet2[3])\n     {\n-        case 0x01: ret = recv(hSocket, pchRet3, 4, 0) != 4; break;\n-        case 0x04: ret = recv(hSocket, pchRet3, 16, 0) != 16; break;\n-        case 0x03:\n+    case 0x01:\n+        ret = recv(hSocket, pchRet3, 4, 0) != 4;\n+        break;\n+    case 0x04:\n+        ret = recv(hSocket, pchRet3, 16, 0) != 16;\n+        break;\n+    case 0x03:\n+    {\n+        ret = recv(hSocket, pchRet3, 1, 0) != 1;\n+\n+        if (ret)\n         {\n-            ret = recv(hSocket, pchRet3, 1, 0) != 1;\n-            if (ret) {\n-                CloseSocket(hSocket);\n-                return error(\"Error reading from proxy\");\n-            }\n-            int nRecv = pchRet3[0];\n-            ret = recv(hSocket, pchRet3, nRecv, 0) != nRecv;\n-            break;\n+            CloseSocket(hSocket);\n+            return error(\"Error reading from proxy\");\n         }\n-        default: CloseSocket(hSocket); return error(\"Error: malformed proxy response\");\n+\n+        int nRecv = pchRet3[0];\n+        ret = recv(hSocket, pchRet3, nRecv, 0) != nRecv;\n+        break;\n+    }\n+    default:\n+        CloseSocket(hSocket);\n+        return error(\"Error: malformed proxy response\");\n     }\n+\n     if (ret)\n     {\n         CloseSocket(hSocket);\n         return error(\"Error reading from proxy\");\n     }\n+\n     if (recv(hSocket, pchRet3, 2, 0) != 2)\n     {\n         CloseSocket(hSocket);\n         return error(\"Error reading from proxy\");\n     }\n+\n     LogPrintf(\"SOCKS5 connected %s\\n\", strDest);\n     return true;\n }\n@@ -335,14 +460,19 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n \n     struct sockaddr_storage sockaddr;\n     socklen_t len = sizeof(sockaddr);\n-    if (!addrConnect.GetSockAddr((struct sockaddr*)&sockaddr, &len)) {\n+\n+    if (!addrConnect.GetSockAddr((struct sockaddr*)&sockaddr, &len))\n+    {\n         LogPrintf(\"Cannot connect to %s: unsupported network\\n\", addrConnect.ToString());\n         return false;\n     }\n \n     SOCKET hSocket = socket(((struct sockaddr*)&sockaddr)->sa_family, SOCK_STREAM, IPPROTO_TCP);\n+\n     if (hSocket == INVALID_SOCKET)\n+    {\n         return false;\n+    }\n \n #ifdef SO_NOSIGPIPE\n     int set = 1;\n@@ -352,11 +482,15 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n \n     // Set to non-blocking\n     if (!SetSocketNonBlocking(hSocket, true))\n-        return error(\"ConnectSocketDirectly: Setting socket to non-blocking failed, error %s\\n\", NetworkErrorString(WSAGetLastError()));\n+    {\n+        return error(\"ConnectSocketDirectly: Setting socket to non-blocking failed, error %s\\n\",\n+            NetworkErrorString(WSAGetLastError()));\n+    }\n \n     if (connect(hSocket, (struct sockaddr*)&sockaddr, len) == SOCKET_ERROR)\n     {\n         int nErr = WSAGetLastError();\n+\n         // WSAEINVAL is here because some legacy version of winsock uses it\n         if (nErr == WSAEINPROGRESS || nErr == WSAEWOULDBLOCK || nErr == WSAEINVAL)\n         {\n@@ -368,36 +502,45 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n             FD_ZERO(&fdset);\n             FD_SET(hSocket, &fdset);\n             int nRet = select(hSocket + 1, NULL, &fdset, NULL, &timeout);\n+\n             if (nRet == 0)\n             {\n                 LogPrint(\"net\", \"connection to %s timeout\\n\", addrConnect.ToString());\n                 CloseSocket(hSocket);\n                 return false;\n             }\n+\n             if (nRet == SOCKET_ERROR)\n             {\n                 LogPrintf(\"select() for %s failed: %s\\n\", addrConnect.ToString(), NetworkErrorString(WSAGetLastError()));\n                 CloseSocket(hSocket);\n                 return false;\n             }\n+\n             socklen_t nRetSize = sizeof(nRet);\n #ifdef WIN32\n+\n             if (getsockopt(hSocket, SOL_SOCKET, SO_ERROR, (char*)(&nRet), &nRetSize) == SOCKET_ERROR)\n #else\n+\n             if (getsockopt(hSocket, SOL_SOCKET, SO_ERROR, &nRet, &nRetSize) == SOCKET_ERROR)\n #endif\n             {\n-                LogPrintf(\"getsockopt() for %s failed: %s\\n\", addrConnect.ToString(), NetworkErrorString(WSAGetLastError()));\n+                LogPrintf(\"getsockopt() for %s failed: %s\\n\", addrConnect.ToString(),\n+                    NetworkErrorString(WSAGetLastError()));\n                 CloseSocket(hSocket);\n                 return false;\n             }\n+\n             if (nRet != 0)\n             {\n-                LogPrintf(\"connect() to %s failed after select(): %s\\n\", addrConnect.ToString(), NetworkErrorString(nRet));\n+                LogPrintf(\"connect() to %s failed after select(): %s\\n\", addrConnect.ToString(),\n+                    NetworkErrorString(nRet));\n                 CloseSocket(hSocket);\n                 return false;\n             }\n         }\n+\n #ifdef WIN32\n         else if (WSAGetLastError() != WSAEISCONN)\n #else\n@@ -413,84 +556,122 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n     // This is required when using SOCKS5 proxy!\n     // CNode::ConnectNode turns the socket back to non-blocking.\n     if (!SetSocketNonBlocking(hSocket, false))\n-        return error(\"ConnectSocketDirectly: Setting socket to blocking failed, error %s\\n\", NetworkErrorString(WSAGetLastError()));\n+    {\n+        return error(\"ConnectSocketDirectly: Setting socket to blocking failed, error %s\\n\",\n+            NetworkErrorString(WSAGetLastError()));\n+    }\n \n     hSocketRet = hSocket;\n     return true;\n }\n \n-bool SetProxy(enum Network net, CService addrProxy) {\n+bool SetProxy(enum Network net, CService addrProxy)\n+{\n     assert(net >= 0 && net < NET_MAX);\n+\n     if (!addrProxy.IsValid())\n+    {\n         return false;\n+    }\n+\n     LOCK(cs_proxyInfos);\n     proxyInfo[net] = addrProxy;\n     return true;\n }\n \n-bool GetProxy(enum Network net, proxyType &proxyInfoOut) {\n+bool GetProxy(enum Network net, proxyType &proxyInfoOut)\n+{\n     assert(net >= 0 && net < NET_MAX);\n     LOCK(cs_proxyInfos);\n+\n     if (!proxyInfo[net].IsValid())\n+    {\n         return false;\n+    }\n+\n     proxyInfoOut = proxyInfo[net];\n     return true;\n }\n \n-bool SetNameProxy(CService addrProxy) {\n+bool SetNameProxy(CService addrProxy)\n+{\n     if (!addrProxy.IsValid())\n+    {\n         return false;\n+    }\n+\n     LOCK(cs_proxyInfos);\n     nameProxy = addrProxy;\n     return true;\n }\n \n-bool GetNameProxy(CService &nameProxyOut) {\n+bool GetNameProxy(CService &nameProxyOut)\n+{\n     LOCK(cs_proxyInfos);\n-    if(!nameProxy.IsValid())\n+\n+    if (!nameProxy.IsValid())\n+    {\n         return false;\n+    }\n+\n     nameProxyOut = nameProxy;\n     return true;\n }\n \n-bool HaveNameProxy() {\n+bool HaveNameProxy()\n+{\n     LOCK(cs_proxyInfos);\n     return nameProxy.IsValid();\n }\n \n-bool IsProxy(const CNetAddr &addr) {\n+bool IsProxy(const CNetAddr &addr)\n+{\n     LOCK(cs_proxyInfos);\n-    for (int i = 0; i < NET_MAX; i++) {\n+\n+    for (int i = 0; i < NET_MAX; i++)\n+    {\n         if (addr == (CNetAddr)proxyInfo[i])\n+        {\n             return true;\n+        }\n     }\n+\n     return false;\n }\n \n bool ConnectSocket(const CService &addrDest, SOCKET& hSocketRet, int nTimeout)\n {\n     proxyType proxy;\n+\n     // no proxy needed (none set for target network)\n     if (!GetProxy(addrDest.GetNetwork(), proxy))\n+    {\n         return ConnectSocketDirectly(addrDest, hSocketRet, nTimeout);\n+    }\n \n     SOCKET hSocket = INVALID_SOCKET;\n \n     // first connect to proxy server\n     if (!ConnectSocketDirectly(proxy, hSocket, nTimeout))\n+    {\n         return false;\n+    }\n+\n     // do socks negotiation\n     if (!Socks5(addrDest.ToStringIP(), addrDest.GetPort(), hSocket))\n+    {\n         return false;\n+    }\n \n     hSocketRet = hSocket;\n     return true;\n }\n \n-bool ConnectSocketByName(CService &addr, SOCKET& hSocketRet, const char *pszDest, int portDefault, int nTimeout)\n+bool ConnectSocketByName(CService &addr, SOCKET& hSocketRet, const char* pszDest, int portDefault, int nTimeout)\n {\n     string strDest;\n     int port = portDefault;\n+\n     SplitHostPort(string(pszDest), port, strDest);\n \n     SOCKET hSocket = INVALID_SOCKET;\n@@ -499,21 +680,31 @@ bool ConnectSocketByName(CService &addr, SOCKET& hSocketRet, const char *pszDest\n     GetNameProxy(nameProxy);\n \n     CService addrResolved(CNetAddr(strDest, fNameLookup && !HaveNameProxy()), port);\n-    if (addrResolved.IsValid()) {\n+\n+    if (addrResolved.IsValid())\n+    {\n         addr = addrResolved;\n         return ConnectSocket(addr, hSocketRet, nTimeout);\n     }\n \n     addr = CService(\"0.0.0.0:0\");\n \n     if (!HaveNameProxy())\n+    {\n         return false;\n+    }\n+\n     // first connect to name proxy server\n     if (!ConnectSocketDirectly(nameProxy, hSocket, nTimeout))\n+    {\n         return false;\n+    }\n+\n     // do socks negotiation\n     if (!Socks5(strDest, (unsigned short)port, hSocket))\n+    {\n         return false;\n+    }\n \n     hSocketRet = hSocket;\n     return true;\n@@ -529,35 +720,47 @@ void CNetAddr::SetIP(const CNetAddr& ipIn)\n     memcpy(ip, ipIn.ip, sizeof(ip));\n }\n \n-void CNetAddr::SetRaw(Network network, const uint8_t *ip_in)\n+void CNetAddr::SetRaw(Network network, const uint8_t* ip_in)\n {\n-    switch(network)\n+    switch (network)\n     {\n-        case NET_IPV4:\n-            memcpy(ip, pchIPv4, 12);\n-            memcpy(ip+12, ip_in, 4);\n-            break;\n-        case NET_IPV6:\n-            memcpy(ip, ip_in, 16);\n-            break;\n-        default:\n-            assert(!\"invalid network\");\n+    case NET_IPV4:\n+        memcpy(ip, pchIPv4, 12);\n+        memcpy(ip + 12, ip_in, 4);\n+        break;\n+    case NET_IPV6:\n+        memcpy(ip, ip_in, 16);\n+        break;\n+    default:\n+        assert(!\"invalid network\");\n     }\n }\n \n-static const unsigned char pchOnionCat[] = {0xFD,0x87,0xD8,0x7E,0xEB,0x43};\n+static const unsigned char pchOnionCat[] = {\n+    0xFD, 0x87, 0xD8, 0x7E, 0xEB, 0x43\n+};\n \n bool CNetAddr::SetSpecial(const std::string &strName)\n {\n-    if (strName.size()>6 && strName.substr(strName.size() - 6, 6) == \".onion\") {\n+    if (strName.size() > 6 && strName.substr(strName.size() - 6, 6) == \".onion\")\n+    {\n         std::vector<unsigned char> vchAddr = DecodeBase32(strName.substr(0, strName.size() - 6).c_str());\n-        if (vchAddr.size() != 16-sizeof(pchOnionCat))\n+\n+        if (vchAddr.size() != 16 - sizeof(pchOnionCat))\n+        {\n             return false;\n+        }\n+\n         memcpy(ip, pchOnionCat, sizeof(pchOnionCat));\n-        for (unsigned int i=0; i<16-sizeof(pchOnionCat); i++)\n+\n+        for (unsigned int i = 0; i < 16 - sizeof(pchOnionCat); i++)\n+        {\n             ip[i + sizeof(pchOnionCat)] = vchAddr[i];\n+        }\n+\n         return true;\n     }\n+\n     return false;\n }\n \n@@ -576,25 +779,31 @@ CNetAddr::CNetAddr(const struct in6_addr& ipv6Addr)\n     SetRaw(NET_IPV6, (const uint8_t*)&ipv6Addr);\n }\n \n-CNetAddr::CNetAddr(const char *pszIp, bool fAllowLookup)\n+CNetAddr::CNetAddr(const char* pszIp, bool fAllowLookup)\n {\n     Init();\n     std::vector<CNetAddr> vIP;\n+\n     if (LookupHost(pszIp, vIP, 1, fAllowLookup))\n+    {\n         *this = vIP[0];\n+    }\n }\n \n CNetAddr::CNetAddr(const std::string &strIp, bool fAllowLookup)\n {\n     Init();\n     std::vector<CNetAddr> vIP;\n+\n     if (LookupHost(strIp.c_str(), vIP, 1, fAllowLookup))\n+    {\n         *this = vIP[0];\n+    }\n }\n \n unsigned int CNetAddr::GetByte(int n) const\n {\n-    return ip[15-n];\n+    return ip[15 - n];\n }\n \n bool CNetAddr::IsIPv4() const\n@@ -632,7 +841,10 @@ bool CNetAddr::IsRFC3964() const\n \n bool CNetAddr::IsRFC6052() const\n {\n-    static const unsigned char pchRFC6052[] = {0,0x64,0xFF,0x9B,0,0,0,0,0,0,0,0};\n+    static const unsigned char pchRFC6052[] = {\n+        0, 0x64, 0xFF, 0x9B, 0, 0, 0, 0, 0, 0, 0, 0\n+    };\n+\n     return (memcmp(ip, pchRFC6052, sizeof(pchRFC6052)) == 0);\n }\n \n@@ -643,7 +855,10 @@ bool CNetAddr::IsRFC4380() const\n \n bool CNetAddr::IsRFC4862() const\n {\n-    static const unsigned char pchRFC4862[] = {0xFE,0x80,0,0,0,0,0,0};\n+    static const unsigned char pchRFC4862[] = {\n+        0xFE, 0x80, 0, 0, 0, 0, 0, 0\n+    };\n+\n     return (memcmp(ip, pchRFC4862, sizeof(pchRFC4862)) == 0);\n }\n \n@@ -654,7 +869,10 @@ bool CNetAddr::IsRFC4193() const\n \n bool CNetAddr::IsRFC6145() const\n {\n-    static const unsigned char pchRFC6145[] = {0,0,0,0,0,0,0,0,0xFF,0xFF,0,0};\n+    static const unsigned char pchRFC6145[] = {\n+        0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF, 0, 0\n+    };\n+\n     return (memcmp(ip, pchRFC6145, sizeof(pchRFC6145)) == 0);\n }\n \n@@ -671,20 +889,27 @@ bool CNetAddr::IsTor() const\n bool CNetAddr::IsLocal() const\n {\n     // IPv4 loopback\n-   if (IsIPv4() && (GetByte(3) == 127 || GetByte(3) == 0))\n-       return true;\n+    if (IsIPv4() && (GetByte(3) == 127 || GetByte(3) == 0))\n+    {\n+        return true;\n+    }\n \n-   // IPv6 loopback (::1/128)\n-   static const unsigned char pchLocal[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};\n-   if (memcmp(ip, pchLocal, 16) == 0)\n-       return true;\n+    // IPv6 loopback (::1/128)\n+    static const unsigned char pchLocal[16] = {\n+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1\n+    };\n \n-   return false;\n+    if (memcmp(ip, pchLocal, 16) == 0)\n+    {\n+        return true;\n+    }\n+\n+    return false;\n }\n \n bool CNetAddr::IsMulticast() const\n {\n-    return    (IsIPv4() && (GetByte(3) & 0xF0) == 0xE0)\n+    return (IsIPv4() && (GetByte(3) & 0xF0) == 0xE0)\n            || (GetByte(15) == 0xFF);\n }\n \n@@ -696,73 +921,106 @@ bool CNetAddr::IsValid() const\n     // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n     // so if the first length field is garbled, it reads the second batch\n     // of addr misaligned by 3 bytes.\n-    if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n+    if (memcmp(ip, pchIPv4 + 3, sizeof(pchIPv4) - 3) == 0)\n+    {\n         return false;\n+    }\n \n     // unspecified IPv6 address (::/128)\n     unsigned char ipNone[16] = {};\n+\n     if (memcmp(ip, ipNone, 16) == 0)\n+    {\n         return false;\n+    }\n \n     // documentation IPv6 address\n     if (IsRFC3849())\n+    {\n         return false;\n+    }\n \n     if (IsIPv4())\n     {\n         // INADDR_NONE\n         uint32_t ipNone = INADDR_NONE;\n-        if (memcmp(ip+12, &ipNone, 4) == 0)\n+\n+        if (memcmp(ip + 12, &ipNone, 4) == 0)\n+        {\n             return false;\n+        }\n \n         // 0\n         ipNone = 0;\n-        if (memcmp(ip+12, &ipNone, 4) == 0)\n+\n+        if (memcmp(ip + 12, &ipNone, 4) == 0)\n+        {\n             return false;\n+        }\n     }\n \n     return true;\n }\n \n bool CNetAddr::IsRoutable() const\n {\n-    return IsValid() && !(IsRFC1918() || IsRFC3927() || IsRFC4862() || (IsRFC4193() && !IsTor()) || IsRFC4843() || IsLocal());\n+    return IsValid() &&\n+           !(IsRFC1918() || IsRFC3927() || IsRFC4862() || (IsRFC4193() && !IsTor()) || IsRFC4843() || IsLocal());\n }\n \n enum Network CNetAddr::GetNetwork() const\n {\n     if (!IsRoutable())\n+    {\n         return NET_UNROUTABLE;\n+    }\n \n     if (IsIPv4())\n+    {\n         return NET_IPV4;\n+    }\n \n     if (IsTor())\n+    {\n         return NET_TOR;\n+    }\n \n     return NET_IPV6;\n }\n \n std::string CNetAddr::ToStringIP() const\n {\n     if (IsTor())\n+    {\n         return EncodeBase32(&ip[6], 10) + \".onion\";\n+    }\n+\n     CService serv(*this, 0);\n     struct sockaddr_storage sockaddr;\n     socklen_t socklen = sizeof(sockaddr);\n-    if (serv.GetSockAddr((struct sockaddr*)&sockaddr, &socklen)) {\n+\n+    if (serv.GetSockAddr((struct sockaddr*)&sockaddr, &socklen))\n+    {\n         char name[1025] = \"\";\n+\n         if (!getnameinfo((const struct sockaddr*)&sockaddr, socklen, name, sizeof(name), NULL, 0, NI_NUMERICHOST))\n+        {\n             return std::string(name);\n+        }\n     }\n+\n     if (IsIPv4())\n+    {\n         return strprintf(\"%u.%u.%u.%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0));\n+    }\n     else\n+    {\n         return strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n-                         GetByte(15) << 8 | GetByte(14), GetByte(13) << 8 | GetByte(12),\n-                         GetByte(11) << 8 | GetByte(10), GetByte(9) << 8 | GetByte(8),\n-                         GetByte(7) << 8 | GetByte(6), GetByte(5) << 8 | GetByte(4),\n-                         GetByte(3) << 8 | GetByte(2), GetByte(1) << 8 | GetByte(0));\n+            GetByte(15) << 8 | GetByte(14), GetByte(13) << 8 | GetByte(12),\n+            GetByte(11) << 8 | GetByte(10), GetByte(9) << 8 | GetByte(8),\n+            GetByte(7) << 8 | GetByte(6), GetByte(5) << 8 | GetByte(4),\n+            GetByte(3) << 8 | GetByte(2), GetByte(1) << 8 | GetByte(0));\n+    }\n }\n \n std::string CNetAddr::ToString() const\n@@ -788,8 +1046,11 @@ bool operator<(const CNetAddr& a, const CNetAddr& b)\n bool CNetAddr::GetInAddr(struct in_addr* pipv4Addr) const\n {\n     if (!IsIPv4())\n+    {\n         return false;\n-    memcpy(pipv4Addr, ip+12, 4);\n+    }\n+\n+    memcpy(pipv4Addr, ip + 12, 4);\n     return true;\n }\n \n@@ -850,20 +1111,28 @@ std::vector<unsigned char> CNetAddr::GetGroup() const\n     }\n     // for he.net, use /36 groups\n     else if (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x04 && GetByte(12) == 0x70)\n+    {\n         nBits = 36;\n+    }\n     // for the rest of the IPv6 network, use /32 groups\n     else\n+    {\n         nBits = 32;\n+    }\n \n     vchRet.push_back(nClass);\n+\n     while (nBits >= 8)\n     {\n         vchRet.push_back(GetByte(15 - nStartByte));\n         nStartByte++;\n         nBits -= 8;\n     }\n+\n     if (nBits > 0)\n+    {\n         vchRet.push_back(GetByte(15 - nStartByte) | ((1 << nBits) - 1));\n+    }\n \n     return vchRet;\n }\n@@ -872,6 +1141,7 @@ uint64_t CNetAddr::GetHash() const\n {\n     uint256 hash = Hash(&ip[0], &ip[16]);\n     uint64_t nRet;\n+\n     memcpy(&nRet, &hash, sizeof(nRet));\n     return nRet;\n }\n@@ -880,19 +1150,26 @@ uint64_t CNetAddr::GetHash() const\n // and only used in GetReachabilityFrom\n static const int NET_UNKNOWN = NET_MAX + 0;\n static const int NET_TEREDO  = NET_MAX + 1;\n-int static GetExtNetwork(const CNetAddr *addr)\n+int static GetExtNetwork(const CNetAddr* addr)\n {\n     if (addr == NULL)\n+    {\n         return NET_UNKNOWN;\n+    }\n+\n     if (addr->IsRFC4380())\n+    {\n         return NET_TEREDO;\n+    }\n+\n     return addr->GetNetwork();\n }\n \n /** Calculates a metric for how reachable (*this) is from a given partner */\n-int CNetAddr::GetReachabilityFrom(const CNetAddr *paddrPartner) const\n+int CNetAddr::GetReachabilityFrom(const CNetAddr* paddrPartner) const\n {\n-    enum Reachability {\n+    enum Reachability\n+    {\n         REACH_UNREACHABLE,\n         REACH_DEFAULT,\n         REACH_TEREDO,\n@@ -903,47 +1180,95 @@ int CNetAddr::GetReachabilityFrom(const CNetAddr *paddrPartner) const\n     };\n \n     if (!IsRoutable())\n+    {\n         return REACH_UNREACHABLE;\n+    }\n \n     int ourNet = GetExtNetwork(this);\n     int theirNet = GetExtNetwork(paddrPartner);\n     bool fTunnel = IsRFC3964() || IsRFC6052() || IsRFC6145();\n \n-    switch(theirNet) {\n+    switch (theirNet)\n+    {\n     case NET_IPV4:\n-        switch(ourNet) {\n-        default:       return REACH_DEFAULT;\n-        case NET_IPV4: return REACH_IPV4;\n+\n+        switch (ourNet)\n+        {\n+        default:\n+            return REACH_DEFAULT;\n+\n+        case NET_IPV4:\n+            return REACH_IPV4;\n         }\n+\n     case NET_IPV6:\n-        switch(ourNet) {\n-        default:         return REACH_DEFAULT;\n-        case NET_TEREDO: return REACH_TEREDO;\n-        case NET_IPV4:   return REACH_IPV4;\n-        case NET_IPV6:   return fTunnel ? REACH_IPV6_WEAK : REACH_IPV6_STRONG; // only prefer giving our IPv6 address if it's not tunnelled\n+\n+        switch (ourNet)\n+        {\n+        default:\n+            return REACH_DEFAULT;\n+\n+        case NET_TEREDO:\n+            return REACH_TEREDO;\n+\n+        case NET_IPV4:\n+            return REACH_IPV4;\n+\n+        case NET_IPV6:\n+            return fTunnel ? REACH_IPV6_WEAK : REACH_IPV6_STRONG;              // only prefer giving our IPv6 address if it's not tunnelled\n         }\n+\n     case NET_TOR:\n-        switch(ourNet) {\n-        default:         return REACH_DEFAULT;\n-        case NET_IPV4:   return REACH_IPV4; // Tor users can connect to IPv4 as well\n-        case NET_TOR:    return REACH_PRIVATE;\n+\n+        switch (ourNet)\n+        {\n+        default:\n+            return REACH_DEFAULT;\n+\n+        case NET_IPV4:\n+            return REACH_IPV4;              // Tor users can connect to IPv4 as well\n+\n+        case NET_TOR:\n+            return REACH_PRIVATE;\n         }\n+\n     case NET_TEREDO:\n-        switch(ourNet) {\n-        default:          return REACH_DEFAULT;\n-        case NET_TEREDO:  return REACH_TEREDO;\n-        case NET_IPV6:    return REACH_IPV6_WEAK;\n-        case NET_IPV4:    return REACH_IPV4;\n+\n+        switch (ourNet)\n+        {\n+        default:\n+            return REACH_DEFAULT;\n+\n+        case NET_TEREDO:\n+            return REACH_TEREDO;\n+\n+        case NET_IPV6:\n+            return REACH_IPV6_WEAK;\n+\n+        case NET_IPV4:\n+            return REACH_IPV4;\n         }\n+\n     case NET_UNKNOWN:\n     case NET_UNROUTABLE:\n     default:\n-        switch(ourNet) {\n-        default:          return REACH_DEFAULT;\n-        case NET_TEREDO:  return REACH_TEREDO;\n-        case NET_IPV6:    return REACH_IPV6_WEAK;\n-        case NET_IPV4:    return REACH_IPV4;\n-        case NET_TOR:     return REACH_PRIVATE; // either from Tor, or don't care about our address\n+\n+        switch (ourNet)\n+        {\n+        default:\n+            return REACH_DEFAULT;\n+\n+        case NET_TEREDO:\n+            return REACH_TEREDO;\n+\n+        case NET_IPV6:\n+            return REACH_IPV6_WEAK;\n+\n+        case NET_IPV4:\n+            return REACH_IPV4;\n+\n+        case NET_TOR:\n+            return REACH_PRIVATE;               // either from Tor, or don't care about our address\n         }\n     }\n }\n@@ -977,53 +1302,68 @@ CService::CService(const struct sockaddr_in& addr) : CNetAddr(addr.sin_addr), po\n \n CService::CService(const struct sockaddr_in6 &addr) : CNetAddr(addr.sin6_addr), port(ntohs(addr.sin6_port))\n {\n-   assert(addr.sin6_family == AF_INET6);\n+    assert(addr.sin6_family == AF_INET6);\n }\n \n-bool CService::SetSockAddr(const struct sockaddr *paddr)\n+bool CService::SetSockAddr(const struct sockaddr* paddr)\n {\n-    switch (paddr->sa_family) {\n+    switch (paddr->sa_family)\n+    {\n     case AF_INET:\n         *this = CService(*(const struct sockaddr_in*)paddr);\n         return true;\n+\n     case AF_INET6:\n         *this = CService(*(const struct sockaddr_in6*)paddr);\n         return true;\n+\n     default:\n         return false;\n     }\n }\n \n-CService::CService(const char *pszIpPort, bool fAllowLookup)\n+CService::CService(const char* pszIpPort, bool fAllowLookup)\n {\n     Init();\n     CService ip;\n+\n     if (Lookup(pszIpPort, ip, 0, fAllowLookup))\n+    {\n         *this = ip;\n+    }\n }\n \n-CService::CService(const char *pszIpPort, int portDefault, bool fAllowLookup)\n+CService::CService(const char* pszIpPort, int portDefault, bool fAllowLookup)\n {\n     Init();\n     CService ip;\n+\n     if (Lookup(pszIpPort, ip, portDefault, fAllowLookup))\n+    {\n         *this = ip;\n+    }\n }\n \n CService::CService(const std::string &strIpPort, bool fAllowLookup)\n {\n     Init();\n     CService ip;\n+\n     if (Lookup(strIpPort.c_str(), ip, 0, fAllowLookup))\n+    {\n         *this = ip;\n+    }\n }\n \n CService::CService(const std::string &strIpPort, int portDefault, bool fAllowLookup)\n {\n     Init();\n     CService ip;\n+\n     if (Lookup(strIpPort.c_str(), ip, portDefault, fAllowLookup))\n+    {\n         *this = ip;\n+    }\n }\n \n unsigned short CService::GetPort() const\n@@ -1046,43 +1386,61 @@ bool operator<(const CService& a, const CService& b)\n     return (CNetAddr)a < (CNetAddr)b || ((CNetAddr)a == (CNetAddr)b && a.port < b.port);\n }\n \n-bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n+bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t* addrlen) const\n {\n-    if (IsIPv4()) {\n+    if (IsIPv4())\n+    {\n         if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n+        {\n             return false;\n+        }\n+\n         *addrlen = sizeof(struct sockaddr_in);\n-        struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n+        struct sockaddr_in* paddrin = (struct sockaddr_in*)paddr;\n         memset(paddrin, 0, *addrlen);\n+\n         if (!GetInAddr(&paddrin->sin_addr))\n+        {\n             return false;\n+        }\n+\n         paddrin->sin_family = AF_INET;\n         paddrin->sin_port = htons(port);\n         return true;\n     }\n-    if (IsIPv6()) {\n+\n+    if (IsIPv6())\n+    {\n         if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n+        {\n             return false;\n+        }\n+\n         *addrlen = sizeof(struct sockaddr_in6);\n-        struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n+        struct sockaddr_in6* paddrin6 = (struct sockaddr_in6*)paddr;\n         memset(paddrin6, 0, *addrlen);\n+\n         if (!GetIn6Addr(&paddrin6->sin6_addr))\n+        {\n             return false;\n+        }\n+\n         paddrin6->sin6_family = AF_INET6;\n         paddrin6->sin6_port = htons(port);\n         return true;\n     }\n+\n     return false;\n }\n \n std::vector<unsigned char> CService::GetKey() const\n {\n-     std::vector<unsigned char> vKey;\n-     vKey.resize(18);\n-     memcpy(&vKey[0], ip, 16);\n-     vKey[16] = port / 0x100;\n-     vKey[17] = port & 0x0FF;\n-     return vKey;\n+    std::vector<unsigned char> vKey;\n+    vKey.resize(18);\n+    memcpy(&vKey[0], ip, 16);\n+    vKey[16] = port / 0x100;\n+    vKey[17] = port & 0x0FF;\n+    return vKey;\n }\n \n std::string CService::ToStringPort() const\n@@ -1092,9 +1450,12 @@ std::string CService::ToStringPort() const\n \n std::string CService::ToStringIPPort() const\n {\n-    if (IsIPv4() || IsTor()) {\n+    if (IsIPv4() || IsTor())\n+    {\n         return ToStringIP() + \":\" + ToStringPort();\n-    } else {\n+    }\n+    else\n+    {\n         return \"[\" + ToStringIP() + \"]:\" + ToStringPort();\n     }\n }\n@@ -1109,7 +1470,7 @@ void CService::SetPort(unsigned short portIn)\n     port = portIn;\n }\n \n-CSubNet::CSubNet():\n+CSubNet::CSubNet() :\n     valid(false)\n {\n     memset(netmask, 0, sizeof(netmask));\n@@ -1118,30 +1479,37 @@ CSubNet::CSubNet():\n CSubNet::CSubNet(const std::string &strSubnet, bool fAllowLookup)\n {\n     size_t slash = strSubnet.find_last_of('/');\n+\n     std::vector<CNetAddr> vIP;\n \n     valid = true;\n     // Default to /32 (IPv4) or /128 (IPv6), i.e. match single address\n     memset(netmask, 255, sizeof(netmask));\n \n     std::string strAddress = strSubnet.substr(0, slash);\n+\n     if (LookupHost(strAddress.c_str(), vIP, 1, fAllowLookup))\n     {\n         network = vIP[0];\n+\n         if (slash != strSubnet.npos)\n         {\n             std::string strNetmask = strSubnet.substr(slash + 1);\n             int32_t n;\n             // IPv4 addresses start at offset 12, and first 12 bytes must match, so just offset n\n             int noffset = network.IsIPv4() ? (12 * 8) : 0;\n+\n             if (ParseInt32(strNetmask, &n)) // If valid number, assume /24 symtex\n             {\n-                if(n >= 0 && n <= (128 - noffset)) // Only valid if in range of bits of address\n+                if (n >= 0 && n <= (128 - noffset)) // Only valid if in range of bits of address\n                 {\n                     n += noffset;\n+\n                     // Clear bits [n..127]\n                     for (; n < 128; ++n)\n-                        netmask[n>>3] &= ~(1<<(n&7));\n+                    {\n+                        netmask[n >> 3] &= ~(1 << (n & 7));\n+                    }\n                 }\n                 else\n                 {\n@@ -1156,8 +1524,11 @@ CSubNet::CSubNet(const std::string &strSubnet, bool fAllowLookup)\n                     // Copy only the *last* four bytes in case of IPv4, the rest of the mask should stay 1's as\n                     // we don't want pchIPv4 to be part of the mask.\n                     int asize = network.IsIPv4() ? 4 : 16;\n-                    for(int x=0; x<asize; ++x)\n-                        netmask[15-x] = vIP[0].GetByte(x);\n+\n+                    for (int x = 0; x < asize; ++x)\n+                    {\n+                        netmask[15 - x] = vIP[0].GetByte(x);\n+                    }\n                 }\n                 else\n                 {\n@@ -1175,24 +1546,38 @@ CSubNet::CSubNet(const std::string &strSubnet, bool fAllowLookup)\n bool CSubNet::Match(const CNetAddr &addr) const\n {\n     if (!valid || !addr.IsValid())\n+    {\n         return false;\n-    for(int x=0; x<16; ++x)\n-        if ((addr.GetByte(x) & netmask[15-x]) != network.GetByte(x))\n+    }\n+\n+    for (int x = 0; x < 16; ++x)\n+    {\n+        if ((addr.GetByte(x) & netmask[15 - x]) != network.GetByte(x))\n+        {\n             return false;\n+        }\n+    }\n+\n     return true;\n }\n \n std::string CSubNet::ToString() const\n {\n     std::string strNetmask;\n+\n     if (network.IsIPv4())\n+    {\n         strNetmask = strprintf(\"%u.%u.%u.%u\", netmask[12], netmask[13], netmask[14], netmask[15]);\n+    }\n     else\n+    {\n         strNetmask = strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n-                         netmask[0] << 8 | netmask[1], netmask[2] << 8 | netmask[3],\n-                         netmask[4] << 8 | netmask[5], netmask[6] << 8 | netmask[7],\n-                         netmask[8] << 8 | netmask[9], netmask[10] << 8 | netmask[11],\n-                         netmask[12] << 8 | netmask[13], netmask[14] << 8 | netmask[15]);\n+            netmask[0] << 8 | netmask[1], netmask[2] << 8 | netmask[3],\n+            netmask[4] << 8 | netmask[5], netmask[6] << 8 | netmask[7],\n+            netmask[8] << 8 | netmask[9], netmask[10] << 8 | netmask[11],\n+            netmask[12] << 8 | netmask[13], netmask[14] << 8 | netmask[15]);\n+    }\n+\n     return network.ToString() + \"/\" + strNetmask;\n }\n \n@@ -1208,15 +1593,17 @@ bool operator==(const CSubNet& a, const CSubNet& b)\n \n bool operator!=(const CSubNet& a, const CSubNet& b)\n {\n-    return !(a==b);\n+    return !(a == b);\n }\n \n #ifdef WIN32\n std::string NetworkErrorString(int err)\n {\n     char buf[256];\n+\n     buf[0] = 0;\n-    if(FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,\n+\n+    if (FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,\n             NULL, err, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n             buf, sizeof(buf), NULL))\n     {\n@@ -1227,28 +1614,38 @@ std::string NetworkErrorString(int err)\n         return strprintf(\"Unknown error (%d)\", err);\n     }\n }\n+\n #else\n std::string NetworkErrorString(int err)\n {\n     char buf[256];\n-    const char *s = buf;\n+    const char* s = buf;\n+\n     buf[0] = 0;\n     /* Too bad there are two incompatible implementations of the\n      * thread-safe strerror. */\n #ifdef STRERROR_R_CHAR_P /* GNU variant can return a pointer outside the passed buffer */\n     s = strerror_r(err, buf, sizeof(buf));\n #else /* POSIX variant always returns message in buffer */\n+\n     if (strerror_r(err, buf, sizeof(buf)))\n+    {\n         buf[0] = 0;\n+    }\n+\n #endif\n     return strprintf(\"%s (%d)\", s, err);\n }\n+\n #endif\n \n bool CloseSocket(SOCKET& hSocket)\n {\n     if (hSocket == INVALID_SOCKET)\n+    {\n         return false;\n+    }\n+\n #ifdef WIN32\n     int ret = closesocket(hSocket);\n #else\n@@ -1260,24 +1657,35 @@ bool CloseSocket(SOCKET& hSocket)\n \n bool SetSocketNonBlocking(SOCKET& hSocket, bool fNonBlocking)\n {\n-    if (fNonBlocking) {\n+    if (fNonBlocking)\n+    {\n #ifdef WIN32\n         u_long nOne = 1;\n-        if (ioctlsocket(hSocket, FIONBIO, &nOne) == SOCKET_ERROR) {\n+\n+        if (ioctlsocket(hSocket, FIONBIO, &nOne) == SOCKET_ERROR)\n+        {\n #else\n         int fFlags = fcntl(hSocket, F_GETFL, 0);\n-        if (fcntl(hSocket, F_SETFL, fFlags | O_NONBLOCK) == SOCKET_ERROR) {\n+\n+        if (fcntl(hSocket, F_SETFL, fFlags | O_NONBLOCK) == SOCKET_ERROR)\n+        {\n #endif\n             CloseSocket(hSocket);\n             return false;\n         }\n-    } else {\n+    }\n+    else\n+    {\n #ifdef WIN32\n         u_long nZero = 0;\n-        if (ioctlsocket(hSocket, FIONBIO, &nZero) == SOCKET_ERROR) {\n+\n+        if (ioctlsocket(hSocket, FIONBIO, &nZero) == SOCKET_ERROR)\n+        {\n #else\n         int fFlags = fcntl(hSocket, F_GETFL, 0);\n-        if (fcntl(hSocket, F_SETFL, fFlags & ~O_NONBLOCK) == SOCKET_ERROR) {\n+\n+        if (fcntl(hSocket, F_SETFL, fFlags & ~O_NONBLOCK) == SOCKET_ERROR)\n+        {\n #endif\n             CloseSocket(hSocket);\n             return false;\n@@ -1286,3 +1694,4 @@ bool SetSocketNonBlocking(SOCKET& hSocket, bool fNonBlocking)\n \n     return true;\n }\n+"
      },
      {
        "sha": "f42eca47c0493cfee69fc9cf64295ebf052a7516",
        "filename": "src/netbase.h",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "1d5692b922227b1da65dbc0a37b28ee2667f1aff",
        "filename": "src/noui.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/noui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/noui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/noui.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "4e69d864260ee70746ef0ebcb7a84527f4195d11",
        "filename": "src/noui.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/noui.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/noui.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/noui.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "2771c1ad8760fb53672850258834002cbb8f9791",
        "filename": "src/pow.cpp",
        "status": "modified",
        "additions": 56,
        "deletions": 12,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/pow.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/pow.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "3585545832eddc6cada28aa26ccd9d21cf43b5b8",
        "filename": "src/pow.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/pow.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/pow.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "c679ef83ee0572402b6c5037191a5773588430a1",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 3,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "09ef8beb556e30b72c89a8936060bde1bde683b3",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 83,
        "deletions": 69,
        "changes": 152,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "ea543d39429b8eb7ad1404bdb64cd6ad933d9419",
        "filename": "src/random.cpp",
        "status": "modified",
        "additions": 51,
        "deletions": 14,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/random.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/random.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "918fa4ee2918e1b91b5794ef9b5f4cbbb69ec9bf",
        "filename": "src/random.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/random.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/random.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "ea43b3b20e537b8cabaed105491628ddd872ac3e",
        "filename": "src/rpcblockchain.cpp",
        "status": "modified",
        "additions": 141,
        "deletions": 36,
        "changes": 177,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/rpcblockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/rpcblockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcblockchain.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "ef1ee1baa624d78d3375d243a3e5c77decf8910b",
        "filename": "src/rpcclient.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 7,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/rpcclient.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/rpcclient.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcclient.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "a153465fb519e19698b7413f99bc2540b06bf327",
        "filename": "src/rpcclient.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/rpcclient.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/rpcclient.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcclient.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "c89b55e313e64540371bdc3b43481e7dcd90a338",
        "filename": "src/rpcdump.cpp",
        "status": "modified",
        "additions": 179,
        "deletions": 37,
        "changes": 216,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcdump.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "45d6c95065ac7fcff20c571d8c4e5f7eaea83d14",
        "filename": "src/rpcmining.cpp",
        "status": "modified",
        "additions": 143,
        "deletions": 37,
        "changes": 180,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/rpcmining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/rpcmining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcmining.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "bf95da5b12349b57b89701419b9e7e8187ee22ec",
        "filename": "src/rpcmisc.cpp",
        "status": "modified",
        "additions": 140,
        "deletions": 52,
        "changes": 192,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/rpcmisc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/rpcmisc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcmisc.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "d8da3c12c3aad19948432b97b926758d8d5f1164",
        "filename": "src/rpcnet.cpp",
        "status": "modified",
        "additions": 109,
        "deletions": 30,
        "changes": 139,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/rpcnet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/rpcnet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcnet.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "a4d87ed81730c93b7d8ba65328583e293af840b6",
        "filename": "src/rpcprotocol.cpp",
        "status": "modified",
        "additions": 129,
        "deletions": 51,
        "changes": 180,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/rpcprotocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/rpcprotocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcprotocol.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "778113b4ee6f90a7421f3bdb4e7cf3cd473ae8fb",
        "filename": "src/rpcprotocol.h",
        "status": "modified",
        "additions": 57,
        "deletions": 30,
        "changes": 87,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/rpcprotocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/rpcprotocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcprotocol.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "00910c581cb2cddf4421f472dd2ab2630dff5af2",
        "filename": "src/rpcrawtransaction.cpp",
        "status": "modified",
        "additions": 277,
        "deletions": 79,
        "changes": 356,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/rpcrawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/rpcrawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcrawtransaction.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "cc27084897b3cca5aa5f04659bc9d240f38b5379",
        "filename": "src/rpcserver.cpp",
        "status": "modified",
        "additions": 460,
        "deletions": 209,
        "changes": 669,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/rpcserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/rpcserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcserver.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "6d28ff9f692c86b0323563d749ebd497da31d492",
        "filename": "src/rpcserver.h",
        "status": "modified",
        "additions": 18,
        "deletions": 15,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/rpcserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/rpcserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcserver.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "d504ef501ada8ea8671f65b6d5bf6b80e401ad3b",
        "filename": "src/rpcwallet.cpp",
        "status": "modified",
        "additions": 762,
        "deletions": 211,
        "changes": 973,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcwallet.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "d07fdf2fed16806efea5e2f7102894a3162dfb1f",
        "filename": "src/script/compressor.cpp",
        "status": "modified",
        "additions": 48,
        "deletions": 11,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/script/compressor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/script/compressor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/compressor.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "b0fa72583906023909603c4880074cd108c1458a",
        "filename": "src/script/compressor.h",
        "status": "modified",
        "additions": 23,
        "deletions": 6,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/script/compressor.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/script/compressor.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/compressor.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "2acbb0193421e21766ca33e069f06813ef67ef86",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 493,
        "deletions": 80,
        "changes": 573,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "de471659aebc103ae7f6c2ce15ca38d89d85621c",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 10,
        "deletions": 3,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "8316fe0a8c4f924db046371c23124656b10b77a9",
        "filename": "src/script/script.cpp",
        "status": "modified",
        "additions": 398,
        "deletions": 122,
        "changes": 520,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/script/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/script/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "f04e4e5914768e5534d1ea42d72f2ec91761b045",
        "filename": "src/script/script.h",
        "status": "modified",
        "additions": 261,
        "deletions": 60,
        "changes": 321,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "abb50af2f9e01dd73ede9d138d2fce833c8a1332",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 93,
        "deletions": 21,
        "changes": 114,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "b88ba041399e13bc28857a46a791d6ef720d31ed",
        "filename": "src/script/sign.h",
        "status": "modified",
        "additions": 7,
        "deletions": 3,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "5f157f73e2f636b71620a29f5a13e050b0ebd43f",
        "filename": "src/script/standard.cpp",
        "status": "modified",
        "additions": 99,
        "deletions": 16,
        "changes": 115,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/script/standard.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/script/standard.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "f68faa9e39af92e08b3aad9fde11ef97fbe3c338",
        "filename": "src/script/standard.h",
        "status": "modified",
        "additions": 7,
        "deletions": 4,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/script/standard.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/script/standard.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "de789657a008e2e228921eac0d625be750c895db",
        "filename": "src/serialize.h",
        "status": "modified",
        "additions": 804,
        "deletions": 233,
        "changes": 1037,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/serialize.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/serialize.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/serialize.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "a0f8f5d2a2ce278119acfa82530fce61f69bc86c",
        "filename": "src/sync.cpp",
        "status": "modified",
        "additions": 66,
        "deletions": 18,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/sync.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/sync.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "c295b3d48f42d1407bf4915da3fb1c95fcc40f62",
        "filename": "src/sync.h",
        "status": "modified",
        "additions": 98,
        "deletions": 42,
        "changes": 140,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/sync.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/sync.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "7c5bee76e70867e423536e88d9fa9b13a158c2e4",
        "filename": "src/threadsafety.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/threadsafety.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/threadsafety.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/threadsafety.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "c23e88105ab6afe474e1e420861ad74077e8564a",
        "filename": "src/timedata.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 7,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/timedata.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/timedata.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "154e96598a83f1231d9919e784cf42dfe7706a31",
        "filename": "src/timedata.h",
        "status": "modified",
        "additions": 12,
        "deletions": 7,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/timedata.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/timedata.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "0dd22560f44b9099817914545b24a0a1243dd1d0",
        "filename": "src/tinyformat.h",
        "status": "modified",
        "additions": 537,
        "deletions": 419,
        "changes": 956,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/tinyformat.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/tinyformat.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tinyformat.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "62d94ff01c558efb6710490b0adf45f03b39a436",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 116,
        "deletions": 40,
        "changes": 156,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "65afc17ffa82c0461b1999a82fcb39412361d5c4",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "f5f2739b9836ba78c396b55bdd8d8b03f4f0fe36",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 225,
        "deletions": 72,
        "changes": 297,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "c6c8e14df3371f963d5e65505b6bb82eaa9bd5fe",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 33,
        "deletions": 10,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "c90f6a648aebff4b1df9df354558b7f6dd33fda0",
        "filename": "src/ui_interface.h",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/ui_interface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/ui_interface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ui_interface.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "0283654e35e00d53c0baf8d06a408b55bba6dc42",
        "filename": "src/uint256.cpp",
        "status": "modified",
        "additions": 186,
        "deletions": 61,
        "changes": 247,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/uint256.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/uint256.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/uint256.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "8b7ef0429f2d3f78eb7d2561d2117cf39e08bda8",
        "filename": "src/uint256.h",
        "status": "modified",
        "additions": 190,
        "deletions": 36,
        "changes": 226,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/uint256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/uint256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/uint256.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "c27b56cbd5676ade997b110b0e1aff3ee704e22c",
        "filename": "src/univalue/gen.cpp",
        "status": "modified",
        "additions": 42,
        "deletions": 34,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/univalue/gen.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/univalue/gen.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/univalue/gen.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "928e8d95fda674717fe9e11beedc4ee8ae2c601d",
        "filename": "src/univalue/univalue.cpp",
        "status": "modified",
        "additions": 60,
        "deletions": 13,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/univalue/univalue.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/univalue/univalue.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/univalue/univalue.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "ccff0af83711275b0d5222c3773688d304d37b6b",
        "filename": "src/univalue/univalue.h",
        "status": "modified",
        "additions": 149,
        "deletions": 43,
        "changes": 192,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/univalue/univalue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/univalue/univalue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/univalue/univalue.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "e178e4e3c47a6b28ce31b9af66c199fb3de05f83",
        "filename": "src/univalue/univalue_escapes.h",
        "status": "modified",
        "additions": 258,
        "deletions": 257,
        "changes": 515,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/univalue/univalue_escapes.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/univalue/univalue_escapes.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/univalue/univalue_escapes.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "a2fb827591d101f3cf8c29e63a5cd37439688c54",
        "filename": "src/univalue/univalue_read.cpp",
        "status": "modified",
        "additions": 213,
        "deletions": 79,
        "changes": 292,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/univalue/univalue_read.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/univalue/univalue_read.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/univalue/univalue_read.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "12e1daee4775b0f090eedf26d9ad4375c9200000",
        "filename": "src/univalue/univalue_write.cpp",
        "status": "modified",
        "additions": 58,
        "deletions": 8,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/univalue/univalue_write.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/univalue/univalue_write.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/univalue/univalue_write.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "17b9af20adfe98729e023b7c1529cf14688e5e26",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 202,
        "deletions": 48,
        "changes": 250,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "de4c987ab19994bcdbd712cec132eecfc7ec524b",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 31,
        "deletions": 13,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "33a9b31cbd75fa55051adea0857759a2b6038747",
        "filename": "src/utilmoneystr.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 7,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/utilmoneystr.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/utilmoneystr.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utilmoneystr.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "6161cfd3b72732e56da2ab703f43f00a7f9b1122",
        "filename": "src/utilmoneystr.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/utilmoneystr.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/utilmoneystr.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utilmoneystr.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "f1abc5d57dd4cb6e9790873419db8c20c0d46370",
        "filename": "src/utilstrencodings.cpp",
        "status": "modified",
        "additions": 316,
        "deletions": 208,
        "changes": 524,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/utilstrencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/utilstrencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utilstrencodings.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "cd52629c49ac56f48ac6249cc1e6e9b4220ebe6e",
        "filename": "src/utilstrencodings.h",
        "status": "modified",
        "additions": 32,
        "deletions": 15,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/utilstrencodings.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/utilstrencodings.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utilstrencodings.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "00019519c3d8302e588b8fa1ce4721e7b1c7a23b",
        "filename": "src/utiltime.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 3,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/utiltime.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/utiltime.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utiltime.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "7a3540d5dc74ccb3d9b4e3e73d18bdb389381995",
        "filename": "src/utiltime.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/utiltime.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/utiltime.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utiltime.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "c0ca0297307c050c9487ecc4b3f258661f6c8c19",
        "filename": "src/version.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 10,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/version.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/version.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/version.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "4bdfe1ec36b391f558915f16c505f2138a497d8e",
        "filename": "src/version.h",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/version.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/version.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/version.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "2c44c7cd3a9e9f206cbd1938500f02d3952748ec",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 850,
        "deletions": 179,
        "changes": 1029,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "ae900a162f44ba51d018a1d17fa868c22e8edde3",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 227,
        "deletions": 67,
        "changes": 294,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "b527316168be4f16b7b2d652a17fc46042d26ef3",
        "filename": "src/wallet_ismine.cpp",
        "status": "modified",
        "additions": 38,
        "deletions": 4,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/wallet_ismine.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/wallet_ismine.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet_ismine.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "0fb7c2c185a5bdae353f52057e8beb67750cea32",
        "filename": "src/wallet_ismine.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/wallet_ismine.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/wallet_ismine.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet_ismine.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "09a912a8bcf5330da0e0fdb8d469b749aec770f9",
        "filename": "src/walletdb.cpp",
        "status": "modified",
        "additions": 237,
        "deletions": 53,
        "changes": 290,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletdb.cpp?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      },
      {
        "sha": "bb34228e831f50c9c98fc130bbe609fa846e76f7",
        "filename": "src/walletdb.h",
        "status": "modified",
        "additions": 9,
        "deletions": 4,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4955de592c10faebeed97ec25bfe5b3b76b4663b/src/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletdb.h?ref=4955de592c10faebeed97ec25bfe5b3b76b4663b"
      }
    ]
  }
]