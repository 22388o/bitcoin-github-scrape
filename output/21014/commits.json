[
  {
    "sha": "4cd36f695ec3fd212248cade2474e7b87706892d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0Y2QzNmY2OTVlYzNmZDIxMjI0OGNhZGUyNDc0ZTdiODc3MDY4OTJk",
    "commit": {
      "author": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2021-01-13T19:01:46Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2021-02-19T16:19:49Z"
      },
      "message": "test:minwallet:changes to accomodate mempool_accept",
      "tree": {
        "sha": "69a304f72677c0a6de1411e4bb6e163977f79ab8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/69a304f72677c0a6de1411e4bb6e163977f79ab8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4cd36f695ec3fd212248cade2474e7b87706892d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4cd36f695ec3fd212248cade2474e7b87706892d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4cd36f695ec3fd212248cade2474e7b87706892d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4cd36f695ec3fd212248cade2474e7b87706892d/comments",
    "author": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "32e59fc371080def4b0be2adbe6486a4ba059972",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/32e59fc371080def4b0be2adbe6486a4ba059972",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/32e59fc371080def4b0be2adbe6486a4ba059972"
      }
    ],
    "stats": {
      "total": 15,
      "additions": 10,
      "deletions": 5
    },
    "files": [
      {
        "sha": "2bb694322897262ec108337bb3dd9fa8edded24c",
        "filename": "test/functional/test_framework/wallet.py",
        "status": "modified",
        "additions": 10,
        "deletions": 5,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4cd36f695ec3fd212248cade2474e7b87706892d/test/functional/test_framework/wallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4cd36f695ec3fd212248cade2474e7b87706892d/test/functional/test_framework/wallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/wallet.py?ref=4cd36f695ec3fd212248cade2474e7b87706892d",
        "patch": "@@ -55,7 +55,7 @@ def get_utxo(self, *, txid=''):\n             index = self._utxos.index(utxo)\n         return self._utxos.pop(index)\n \n-    def send_self_transfer(self, *, fee_rate=Decimal(\"0.003\"), from_node, utxo_to_spend=None):\n+    def send_self_transfer(self, *, fee_rate=Decimal(\"0.003\"), seq_num = 0xffffffff, from_node, utxo_to_spend=None, send_tx = True, nVersion = 1, default_fee = False):\n         \"\"\"Create and send a tx with the specified fee_rate. Fee may be exact or at most one satoshi higher than needed.\"\"\"\n         self._utxos = sorted(self._utxos, key=lambda k: k['value'])\n         utxo_to_spend = utxo_to_spend or self._utxos.pop()  # Pick the largest utxo (if none provided) and hope it covers the fee\n@@ -65,15 +65,20 @@ def send_self_transfer(self, *, fee_rate=Decimal(\"0.003\"), from_node, utxo_to_sp\n         assert send_value > 0\n \n         tx = CTransaction()\n-        tx.vin = [CTxIn(COutPoint(int(utxo_to_spend['txid'], 16), utxo_to_spend['vout']))]\n+        tx.vin = [CTxIn(COutPoint(int(utxo_to_spend['txid'], 16), utxo_to_spend['vout']), nSequence = seq_num)]\n         tx.vout = [CTxOut(int(send_value * COIN), self._scriptPubKey)]\n+        tx.nVersion = 2\n         tx.wit.vtxinwit = [CTxInWitness()]\n         tx.wit.vtxinwit[0].scriptWitness.stack = [CScript([OP_TRUE])]\n         tx_hex = tx.serialize().hex()\n \n         tx_info = from_node.testmempoolaccept([tx_hex])[0]\n-        self._utxos.append({'txid': tx_info['txid'], 'vout': 0, 'value': send_value})\n-        from_node.sendrawtransaction(tx_hex)\n+        if send_tx:\n+            if default_fee:\n+                from_node.sendrawtransaction(tx_hex, 0)\n+            else:\n+                from_node.sendrawtransaction(tx_hex)\n+            self._utxos.append({'txid': tx_info['txid'], 'vout': 0, 'value': send_value})\n         assert_equal(tx_info['vsize'], vsize)\n         assert_equal(tx_info['fees']['base'], fee)\n-        return {'txid': tx_info['txid'], 'wtxid': tx_info['wtxid'], 'hex': tx_hex}\n+        return {'txid': tx_info['txid'], 'wtxid': tx_info['wtxid'], 'hex': tx_hex, 'fees': fee}"
      }
    ]
  },
  {
    "sha": "5ed2bdef6d71fdef5dc8a230d01443f4886da716",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ZWQyYmRlZjZkNzFmZGVmNWRjOGEyMzBkMDE0NDNmNDg4NmRhNzE2",
    "commit": {
      "author": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2021-02-19T16:20:26Z"
      },
      "committer": {
        "name": "Sishir Giri",
        "email": "sishirg27@gmail.com",
        "date": "2021-03-01T16:13:57Z"
      },
      "message": "test:run mempool_accept even when wallet is disabled",
      "tree": {
        "sha": "640748dfde9e552ec49d8f59abadab0d60f4d5fd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/640748dfde9e552ec49d8f59abadab0d60f4d5fd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5ed2bdef6d71fdef5dc8a230d01443f4886da716",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5ed2bdef6d71fdef5dc8a230d01443f4886da716",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5ed2bdef6d71fdef5dc8a230d01443f4886da716",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5ed2bdef6d71fdef5dc8a230d01443f4886da716/comments",
    "author": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stackman27",
      "id": 26356227,
      "node_id": "MDQ6VXNlcjI2MzU2MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26356227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stackman27",
      "html_url": "https://github.com/stackman27",
      "followers_url": "https://api.github.com/users/stackman27/followers",
      "following_url": "https://api.github.com/users/stackman27/following{/other_user}",
      "gists_url": "https://api.github.com/users/stackman27/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stackman27/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stackman27/subscriptions",
      "organizations_url": "https://api.github.com/users/stackman27/orgs",
      "repos_url": "https://api.github.com/users/stackman27/repos",
      "events_url": "https://api.github.com/users/stackman27/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stackman27/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4cd36f695ec3fd212248cade2474e7b87706892d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4cd36f695ec3fd212248cade2474e7b87706892d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4cd36f695ec3fd212248cade2474e7b87706892d"
      }
    ],
    "stats": {
      "total": 83,
      "additions": 30,
      "deletions": 53
    },
    "files": [
      {
        "sha": "30cacfce110fc47ece27c7fe6c9e44a1f0d3dbf6",
        "filename": "test/functional/mempool_accept.py",
        "status": "modified",
        "additions": 30,
        "deletions": 53,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5ed2bdef6d71fdef5dc8a230d01443f4886da716/test/functional/mempool_accept.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5ed2bdef6d71fdef5dc8a230d01443f4886da716/test/functional/mempool_accept.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_accept.py?ref=5ed2bdef6d71fdef5dc8a230d01443f4886da716",
        "patch": "@@ -35,19 +35,17 @@\n     assert_raises_rpc_error,\n     hex_str_to_bytes,\n )\n-\n+from test_framework.wallet import MiniWallet\n \n class MempoolAcceptanceTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 1\n         self.extra_args = [[\n             '-txindex','-permitbaremultisig=0',\n         ]] * self.num_nodes\n+        self.setup_clean_chain = True\n         self.supports_cli = False\n \n-    def skip_test_if_missing_module(self):\n-        self.skip_if_no_wallet()\n-\n     def check_mempool_result(self, result_expected, *args, **kwargs):\n         \"\"\"Wrapper to check result of testmempoolaccept on node_0's mempool\"\"\"\n         result_test = self.nodes[0].testmempoolaccept(*args, **kwargs)\n@@ -58,38 +56,32 @@ def check_mempool_result(self, result_expected, *args, **kwargs):\n \n     def run_test(self):\n         node = self.nodes[0]\n+        miniwallet = MiniWallet(node)\n \n         self.log.info('Start with empty mempool, and 200 blocks')\n         self.mempool_size = 0\n+        miniwallet.generate(10)\n+        node.generate(190)\n         assert_equal(node.getblockcount(), 200)\n         assert_equal(node.getmempoolinfo()['size'], self.mempool_size)\n-        coins = node.listunspent()\n \n         self.log.info('Should not accept garbage to testmempoolaccept')\n         assert_raises_rpc_error(-3, 'Expected type array, got string', lambda: node.testmempoolaccept(rawtxs='ff00baar'))\n         assert_raises_rpc_error(-8, 'Array must contain exactly one raw transaction for now', lambda: node.testmempoolaccept(rawtxs=['ff00baar', 'ff22']))\n         assert_raises_rpc_error(-22, 'TX decode failed', lambda: node.testmempoolaccept(rawtxs=['ff00baar']))\n \n         self.log.info('A transaction already in the blockchain')\n-        coin = coins.pop()  # Pick a random coin(base) to spend\n-        raw_tx_in_block = node.signrawtransactionwithwallet(node.createrawtransaction(\n-            inputs=[{'txid': coin['txid'], 'vout': coin['vout']}],\n-            outputs=[{node.getnewaddress(): 0.3}, {node.getnewaddress(): 49}],\n-        ))['hex']\n-        txid_in_block = node.sendrawtransaction(hexstring=raw_tx_in_block, maxfeerate=0)\n-        node.generate(1)\n+        tx_in_block = miniwallet.send_self_transfer(from_node = node, default_fee = True)\n+        node.generate(1) # Generate a block, tx gets mined therefore mempool is empty\n         self.mempool_size = 0\n         self.check_mempool_result(\n-            result_expected=[{'txid': txid_in_block, 'allowed': False, 'reject-reason': 'txn-already-known'}],\n-            rawtxs=[raw_tx_in_block],\n+            result_expected=[{'txid': tx_in_block['txid'], 'allowed': False, 'reject-reason': 'txn-already-known'}],\n+            rawtxs=[tx_in_block['hex']],\n         )\n \n         self.log.info('A transaction not in the mempool')\n-        fee = Decimal('0.000007')\n-        raw_tx_0 = node.signrawtransactionwithwallet(node.createrawtransaction(\n-            inputs=[{\"txid\": txid_in_block, \"vout\": 0, \"sequence\": BIP125_SEQUENCE_NUMBER}],  # RBF is used later\n-            outputs=[{node.getnewaddress(): Decimal('0.3') - fee}],\n-        ))['hex']\n+        fee = Decimal('0.00000672')\n+        raw_tx_0 = miniwallet.send_self_transfer(from_node = node, seq_num = BIP125_SEQUENCE_NUMBER, fee_rate = Decimal('0.00007672') - fee, send_tx = False)['hex'] # RBF is used later *** NEED TO PASS THE FEE HERE ***\n         tx = CTransaction()\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_0)))\n         txid_0 = tx.rehash()\n@@ -99,21 +91,15 @@ def run_test(self):\n         )\n \n         self.log.info('A final transaction not in the mempool')\n-        coin = coins.pop()  # Pick a random coin(base) to spend\n-        output_amount = Decimal('0.025')\n-        raw_tx_final = node.signrawtransactionwithwallet(node.createrawtransaction(\n-            inputs=[{'txid': coin['txid'], 'vout': coin['vout'], \"sequence\": 0xffffffff}],  # SEQUENCE_FINAL\n-            outputs=[{node.getnewaddress(): output_amount}],\n-            locktime=node.getblockcount() + 2000,  # Can be anything\n-        ))['hex']\n-        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_final)))\n-        fee_expected = coin['amount'] - output_amount\n+        raw_tx_final = miniwallet.send_self_transfer(from_node = node, seq_num = 0xffffffff, send_tx = False)\n+        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_final['hex'])))\n+\n         self.check_mempool_result(\n-            result_expected=[{'txid': tx.rehash(), 'allowed': True, 'vsize': tx.get_vsize(), 'fees': {'base': fee_expected}}],\n+            result_expected=[{'txid': tx.rehash(), 'allowed': True, 'vsize': tx.get_vsize(), 'fees': {'base': raw_tx_final['fees']}}],\n             rawtxs=[tx.serialize().hex()],\n             maxfeerate=0,\n         )\n-        node.sendrawtransaction(hexstring=raw_tx_final, maxfeerate=0)\n+        node.sendrawtransaction(hexstring=raw_tx_final['hex'], maxfeerate=0)\n         self.mempool_size += 1\n \n         self.log.info('A transaction in the mempool')\n@@ -128,7 +114,7 @@ def run_test(self):\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_0)))\n         tx.vout[0].nValue -= int(fee * COIN)  # Double the fee\n         tx.vin[0].nSequence = BIP125_SEQUENCE_NUMBER + 1  # Now, opt out of RBF\n-        raw_tx_0 = node.signrawtransactionwithwallet(tx.serialize().hex())['hex']\n+        raw_tx_0 = tx.serialize().hex()\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_0)))\n         txid_0 = tx.rehash()\n         self.check_mempool_result(\n@@ -161,38 +147,30 @@ def run_test(self):\n         self.log.info('A transaction with missing inputs, that existed once in the past')\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_0)))\n         tx.vin[0].prevout.n = 1  # Set vout to 1, to spend the other outpoint (49 coins) of the in-chain-tx we want to double spend\n-        raw_tx_1 = node.signrawtransactionwithwallet(tx.serialize().hex())['hex']\n-        txid_1 = node.sendrawtransaction(hexstring=raw_tx_1, maxfeerate=0)\n-        # Now spend both to \"clearly hide\" the outputs, ie. remove the coins from the utxo set by spending them\n-        raw_tx_spend_both = node.signrawtransactionwithwallet(node.createrawtransaction(\n-            inputs=[\n-                {'txid': txid_0, 'vout': 0},\n-                {'txid': txid_1, 'vout': 0},\n-            ],\n-            outputs=[{node.getnewaddress(): 0.1}]\n-        ))['hex']\n-        txid_spend_both = node.sendrawtransaction(hexstring=raw_tx_spend_both, maxfeerate=0)\n+\n+        node.sendrawtransaction(hexstring=raw_tx_0, maxfeerate=0) # spend the raw_tx_0\n+        raw_tx_1 = miniwallet.send_self_transfer(from_node = node, fee_rate = 4 *  fee, default_fee = True)\n+        utxo_1 = miniwallet.get_utxo(txid = raw_tx_1['txid'])\n+        txid_spend_1 = miniwallet.send_self_transfer(from_node = node, utxo_to_spend = utxo_1, default_fee = True)['txid']\n         node.generate(1)\n         self.mempool_size = 0\n         # Now see if we can add the coins back to the utxo set by sending the exact txs again\n         self.check_mempool_result(\n-            result_expected=[{'txid': txid_0, 'allowed': False, 'reject-reason': 'missing-inputs'}],\n-            rawtxs=[raw_tx_0],\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'missing-inputs'}],\n+            rawtxs=[tx.serialize().hex()],\n         )\n         self.check_mempool_result(\n-            result_expected=[{'txid': txid_1, 'allowed': False, 'reject-reason': 'missing-inputs'}],\n-            rawtxs=[raw_tx_1],\n+            result_expected=[{'txid': raw_tx_1['txid'], 'allowed': False, 'reject-reason': 'missing-inputs'}],\n+            rawtxs=[raw_tx_1['hex']],\n         )\n \n         self.log.info('Create a signed \"reference\" tx for later use')\n-        raw_tx_reference = node.signrawtransactionwithwallet(node.createrawtransaction(\n-            inputs=[{'txid': txid_spend_both, 'vout': 0}],\n-            outputs=[{node.getnewaddress(): 0.05}],\n-        ))['hex']\n+        utxo_2 = miniwallet.get_utxo(txid = txid_spend_1)\n+        raw_tx_reference = miniwallet.send_self_transfer(from_node = node, utxo_to_spend = utxo_2, nVersion = 2, send_tx = False)['hex']\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n         # Reference tx should be valid on itself\n         self.check_mempool_result(\n-            result_expected=[{'txid': tx.rehash(), 'allowed': True, 'vsize': tx.get_vsize(), 'fees': { 'base': Decimal('0.1') - Decimal('0.05')}}],\n+            result_expected=[{'txid': tx.rehash(), 'allowed': True, 'vsize': tx.get_vsize(), 'fees': { 'base': Decimal('0.00028800')}}],\n             rawtxs=[tx.serialize().hex()],\n             maxfeerate=0,\n         )\n@@ -251,7 +229,7 @@ def run_test(self):\n \n         self.log.info('A coinbase transaction')\n         # Pick the input of the first tx we signed, so it has to be a coinbase tx\n-        raw_tx_coinbase_spent = node.getrawtransaction(txid=node.decoderawtransaction(hexstring=raw_tx_in_block)['vin'][0]['txid'])\n+        raw_tx_coinbase_spent = node.getrawtransaction(txid=node.decoderawtransaction(hexstring=tx_in_block['hex'])['vin'][0]['txid'])\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_coinbase_spent)))\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'coinbase'}],\n@@ -334,6 +312,5 @@ def run_test(self):\n             maxfeerate=0,\n         )\n \n-\n if __name__ == '__main__':\n     MempoolAcceptanceTest().main()"
      }
    ]
  }
]