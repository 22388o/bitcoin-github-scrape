[
  {
    "sha": "32d665c2657793c8b2cc7248d26d80a940acfe20",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozMmQ2NjVjMjY1Nzc5M2M4YjJjYzcyNDhkMjZkODBhOTQwYWNmZTIw",
    "commit": {
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2019-10-11T12:47:38Z"
      },
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2019-10-14T13:03:11Z"
      },
      "message": "test: fix \"tx-size-small\" errors after default address change\n\nAddresses #17043, affects RBF and BIP68 functional tests.\n\nThe \"tx-size-small\" policy rule rejects transactions with a non-witness size of\nsmaller than 82 bytes (see src/validation.cpp:MemPoolAccept::PreChecks(...)),\nwhich corresponds to a transaction with 1 segwit input and 1 P2WPKH output.\n\nThrough the default address change, the created test transactions have segwit\ninputs now and sending to short scriptPubKeys might violate this rule. By\nbumping the dummy scriptPubKey size to 22 bytes (= the size of a P2WPKH\nscriptPubKey), on all occurences the problem is solved.\n\nThe dummy scriptPubKey has the format:\n    21 <21-byte-long string of 'a' or 1s>\n\nformer commit messages, now squashed:\ntest: rbf, bip68: use constant DUMMY_P2WPKH_SCRIPT for bumped scriptPubKey\ntest: rbf, bip68: use constant DUMMY_P2WPKH_SCRIPT for dummy scriptPubKeys (b'a' * 35)\ntest: rbf, bip68: comment DUMMY_P2WPKH_SCRIPT constant, put into common (new) module",
      "tree": {
        "sha": "82af55789519306ce39db9595b5e3fb1a3debdf9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/82af55789519306ce39db9595b5e3fb1a3debdf9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/32d665c2657793c8b2cc7248d26d80a940acfe20",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/32d665c2657793c8b2cc7248d26d80a940acfe20",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/32d665c2657793c8b2cc7248d26d80a940acfe20",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/32d665c2657793c8b2cc7248d26d80a940acfe20/comments",
    "author": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "08ed87e8875d72a1d8b157b67bbd431253d7db24",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/08ed87e8875d72a1d8b157b67bbd431253d7db24",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/08ed87e8875d72a1d8b157b67bbd431253d7db24"
      }
    ],
    "stats": {
      "total": 95,
      "additions": 59,
      "deletions": 36
    },
    "files": [
      {
        "sha": "682a00ff4d0ee8d484c3d9eefacec4968c7b713d",
        "filename": "test/functional/feature_bip68_sequence.py",
        "status": "modified",
        "additions": 10,
        "deletions": 11,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32d665c2657793c8b2cc7248d26d80a940acfe20/test/functional/feature_bip68_sequence.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32d665c2657793c8b2cc7248d26d80a940acfe20/test/functional/feature_bip68_sequence.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_bip68_sequence.py?ref=32d665c2657793c8b2cc7248d26d80a940acfe20",
        "patch": "@@ -8,7 +8,6 @@\n \n from test_framework.blocktools import create_block, create_coinbase, add_witness_commitment\n from test_framework.messages import COIN, COutPoint, CTransaction, CTxIn, CTxOut, FromHex, ToHex\n-from test_framework.script import CScript\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n@@ -17,6 +16,7 @@\n     satoshi_round,\n     softfork_active,\n )\n+from test_framework.script_util import DUMMY_P2WPKH_SCRIPT\n \n SEQUENCE_LOCKTIME_DISABLE_FLAG = (1<<31)\n SEQUENCE_LOCKTIME_TYPE_FLAG = (1<<22) # this means use time (0 means height)\n@@ -29,10 +29,9 @@\n class BIP68Test(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 2\n-        # TODO remove output type argument and fix resulting \"tx-size-small\" errors\n         self.extra_args = [\n-            [\"-acceptnonstdtxn=1\", \"-addresstype=p2sh-segwit\"],\n-            [\"-acceptnonstdtxn=0\", \"-addresstype=p2sh-segwit\"],\n+            [\"-acceptnonstdtxn=1\"],\n+            [\"-acceptnonstdtxn=0\"],\n         ]\n \n     def skip_test_if_missing_module(self):\n@@ -85,7 +84,7 @@ def test_disable_flag(self):\n         # input to mature.\n         sequence_value = SEQUENCE_LOCKTIME_DISABLE_FLAG | 1\n         tx1.vin = [CTxIn(COutPoint(int(utxo[\"txid\"], 16), utxo[\"vout\"]), nSequence=sequence_value)]\n-        tx1.vout = [CTxOut(value, CScript([b'a']))]\n+        tx1.vout = [CTxOut(value, DUMMY_P2WPKH_SCRIPT)]\n \n         tx1_signed = self.nodes[0].signrawtransactionwithwallet(ToHex(tx1))[\"hex\"]\n         tx1_id = self.nodes[0].sendrawtransaction(tx1_signed)\n@@ -97,7 +96,7 @@ def test_disable_flag(self):\n         tx2.nVersion = 2\n         sequence_value = sequence_value & 0x7fffffff\n         tx2.vin = [CTxIn(COutPoint(tx1_id, 0), nSequence=sequence_value)]\n-        tx2.vout = [CTxOut(int(value - self.relayfee * COIN), CScript([b'a' * 35]))]\n+        tx2.vout = [CTxOut(int(value - self.relayfee * COIN), DUMMY_P2WPKH_SCRIPT)]\n         tx2.rehash()\n \n         assert_raises_rpc_error(-26, NOT_FINAL_ERROR, self.nodes[0].sendrawtransaction, ToHex(tx2))\n@@ -192,7 +191,7 @@ def test_sequence_lock_confirmed_inputs(self):\n                 value += utxos[j][\"amount\"]*COIN\n             # Overestimate the size of the tx - signatures should be less than 120 bytes, and leave 50 for the output\n             tx_size = len(ToHex(tx))//2 + 120*num_inputs + 50\n-            tx.vout.append(CTxOut(int(value-self.relayfee*tx_size*COIN/1000), CScript([b'a'])))\n+            tx.vout.append(CTxOut(int(value-self.relayfee*tx_size*COIN/1000), DUMMY_P2WPKH_SCRIPT))\n             rawtx = self.nodes[0].signrawtransactionwithwallet(ToHex(tx))[\"hex\"]\n \n             if (using_sequence_locks and not should_pass):\n@@ -221,7 +220,7 @@ def test_sequence_lock_unconfirmed_inputs(self):\n         tx2 = CTransaction()\n         tx2.nVersion = 2\n         tx2.vin = [CTxIn(COutPoint(tx1.sha256, 0), nSequence=0)]\n-        tx2.vout = [CTxOut(int(tx1.vout[0].nValue - self.relayfee*COIN), CScript([b'a']))]\n+        tx2.vout = [CTxOut(int(tx1.vout[0].nValue - self.relayfee*COIN), DUMMY_P2WPKH_SCRIPT)]\n         tx2_raw = self.nodes[0].signrawtransactionwithwallet(ToHex(tx2))[\"hex\"]\n         tx2 = FromHex(tx2, tx2_raw)\n         tx2.rehash()\n@@ -239,7 +238,7 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n             tx = CTransaction()\n             tx.nVersion = 2\n             tx.vin = [CTxIn(COutPoint(orig_tx.sha256, 0), nSequence=sequence_value)]\n-            tx.vout = [CTxOut(int(orig_tx.vout[0].nValue - relayfee * COIN), CScript([b'a' * 35]))]\n+            tx.vout = [CTxOut(int(orig_tx.vout[0].nValue - relayfee * COIN), DUMMY_P2WPKH_SCRIPT)]\n             tx.rehash()\n \n             if (orig_tx.hash in node.getrawmempool()):\n@@ -352,7 +351,7 @@ def test_bip68_not_consensus(self):\n         tx2 = CTransaction()\n         tx2.nVersion = 1\n         tx2.vin = [CTxIn(COutPoint(tx1.sha256, 0), nSequence=0)]\n-        tx2.vout = [CTxOut(int(tx1.vout[0].nValue - self.relayfee*COIN), CScript([b'a']))]\n+        tx2.vout = [CTxOut(int(tx1.vout[0].nValue - self.relayfee*COIN), DUMMY_P2WPKH_SCRIPT)]\n \n         # sign tx2\n         tx2_raw = self.nodes[0].signrawtransactionwithwallet(ToHex(tx2))[\"hex\"]\n@@ -367,7 +366,7 @@ def test_bip68_not_consensus(self):\n         tx3 = CTransaction()\n         tx3.nVersion = 2\n         tx3.vin = [CTxIn(COutPoint(tx2.sha256, 0), nSequence=sequence_value)]\n-        tx3.vout = [CTxOut(int(tx2.vout[0].nValue - self.relayfee * COIN), CScript([b'a' * 35]))]\n+        tx3.vout = [CTxOut(int(tx2.vout[0].nValue - self.relayfee * COIN), DUMMY_P2WPKH_SCRIPT)]\n         tx3.rehash()\n \n         assert_raises_rpc_error(-26, NOT_FINAL_ERROR, self.nodes[0].sendrawtransaction, ToHex(tx3))"
      },
      {
        "sha": "e7afbd0272a636f19b82e2268321e8c35ae38f76",
        "filename": "test/functional/feature_rbf.py",
        "status": "modified",
        "additions": 24,
        "deletions": 25,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32d665c2657793c8b2cc7248d26d80a940acfe20/test/functional/feature_rbf.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32d665c2657793c8b2cc7248d26d80a940acfe20/test/functional/feature_rbf.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_rbf.py?ref=32d665c2657793c8b2cc7248d26d80a940acfe20",
        "patch": "@@ -10,13 +10,14 @@\n from test_framework.script import CScript, OP_DROP\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal, assert_raises_rpc_error, satoshi_round\n+from test_framework.script_util import DUMMY_P2WPKH_SCRIPT\n \n MAX_REPLACEMENT_LIMIT = 100\n \n def txToHex(tx):\n     return tx.serialize().hex()\n \n-def make_utxo(node, amount, confirmed=True, scriptPubKey=CScript([1])):\n+def make_utxo(node, amount, confirmed=True, scriptPubKey=DUMMY_P2WPKH_SCRIPT):\n     \"\"\"Create a txout with a given amount and scriptPubKey\n \n     Mines coins as needed.\n@@ -65,7 +66,6 @@ def make_utxo(node, amount, confirmed=True, scriptPubKey=CScript([1])):\n class ReplaceByFeeTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 1\n-        # TODO remove output type argument and fix resulting \"tx-size-small\" errors\n         self.extra_args = [\n             [\n                 \"-acceptnonstdtxn=1\",\n@@ -74,7 +74,6 @@ def set_test_params(self):\n                 \"-limitancestorsize=101\",\n                 \"-limitdescendantcount=200\",\n                 \"-limitdescendantsize=101\",\n-                \"-addresstype=p2sh-segwit\",\n             ],\n         ]\n \n@@ -133,7 +132,7 @@ def test_simple_doublespend(self):\n \n         tx1a = CTransaction()\n         tx1a.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n-        tx1a.vout = [CTxOut(1 * COIN, CScript([b'a' * 35]))]\n+        tx1a.vout = [CTxOut(1 * COIN, DUMMY_P2WPKH_SCRIPT)]\n         tx1a_hex = txToHex(tx1a)\n         tx1a_txid = self.nodes[0].sendrawtransaction(tx1a_hex, 0)\n \n@@ -142,7 +141,7 @@ def test_simple_doublespend(self):\n         # Should fail because we haven't changed the fee\n         tx1b = CTransaction()\n         tx1b.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n-        tx1b.vout = [CTxOut(1 * COIN, CScript([b'b' * 35]))]\n+        tx1b.vout = [CTxOut(1 * COIN, DUMMY_P2WPKH_SCRIPT + b'a')]\n         tx1b_hex = txToHex(tx1b)\n \n         # This will raise an exception due to insufficient fee\n@@ -151,7 +150,7 @@ def test_simple_doublespend(self):\n         # Extra 0.1 BTC fee\n         tx1b = CTransaction()\n         tx1b.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n-        tx1b.vout = [CTxOut(int(0.9 * COIN), CScript([b'b' * 35]))]\n+        tx1b.vout = [CTxOut(int(0.9 * COIN), DUMMY_P2WPKH_SCRIPT)]\n         tx1b_hex = txToHex(tx1b)\n         # Works when enabled\n         tx1b_txid = self.nodes[0].sendrawtransaction(tx1b_hex, 0)\n@@ -186,7 +185,7 @@ def test_doublespend_chain(self):\n         # child fees - 40 BTC - so this attempt is rejected.\n         dbl_tx = CTransaction()\n         dbl_tx.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n-        dbl_tx.vout = [CTxOut(initial_nValue - 30 * COIN, CScript([1] * 35))]\n+        dbl_tx.vout = [CTxOut(initial_nValue - 30 * COIN, DUMMY_P2WPKH_SCRIPT)]\n         dbl_tx_hex = txToHex(dbl_tx)\n \n         # This will raise an exception due to insufficient fee\n@@ -195,7 +194,7 @@ def test_doublespend_chain(self):\n         # Accepted with sufficient fee\n         dbl_tx = CTransaction()\n         dbl_tx.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n-        dbl_tx.vout = [CTxOut(1 * COIN, CScript([1] * 35))]\n+        dbl_tx.vout = [CTxOut(1 * COIN, DUMMY_P2WPKH_SCRIPT)]\n         dbl_tx_hex = txToHex(dbl_tx)\n         self.nodes[0].sendrawtransaction(dbl_tx_hex, 0)\n \n@@ -248,15 +247,15 @@ def branch(prevout, initial_value, max_txs, tree_width=5, fee=0.0001*COIN, _tota\n         # Attempt double-spend, will fail because too little fee paid\n         dbl_tx = CTransaction()\n         dbl_tx.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n-        dbl_tx.vout = [CTxOut(initial_nValue - fee * n, CScript([1] * 35))]\n+        dbl_tx.vout = [CTxOut(initial_nValue - fee * n, DUMMY_P2WPKH_SCRIPT)]\n         dbl_tx_hex = txToHex(dbl_tx)\n         # This will raise an exception due to insufficient fee\n         assert_raises_rpc_error(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, dbl_tx_hex, 0)\n \n         # 1 BTC fee is enough\n         dbl_tx = CTransaction()\n         dbl_tx.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n-        dbl_tx.vout = [CTxOut(initial_nValue - fee * n - 1 * COIN, CScript([1] * 35))]\n+        dbl_tx.vout = [CTxOut(initial_nValue - fee * n - 1 * COIN, DUMMY_P2WPKH_SCRIPT)]\n         dbl_tx_hex = txToHex(dbl_tx)\n         self.nodes[0].sendrawtransaction(dbl_tx_hex, 0)\n \n@@ -276,7 +275,7 @@ def branch(prevout, initial_value, max_txs, tree_width=5, fee=0.0001*COIN, _tota\n \n             dbl_tx = CTransaction()\n             dbl_tx.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n-            dbl_tx.vout = [CTxOut(initial_nValue - 2 * fee * n, CScript([1] * 35))]\n+            dbl_tx.vout = [CTxOut(initial_nValue - 2 * fee * n, DUMMY_P2WPKH_SCRIPT)]\n             dbl_tx_hex = txToHex(dbl_tx)\n             # This will raise an exception\n             assert_raises_rpc_error(-26, \"too many potential replacements\", self.nodes[0].sendrawtransaction, dbl_tx_hex, 0)\n@@ -291,7 +290,7 @@ def test_replacement_feeperkb(self):\n \n         tx1a = CTransaction()\n         tx1a.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n-        tx1a.vout = [CTxOut(1 * COIN, CScript([b'a' * 35]))]\n+        tx1a.vout = [CTxOut(1 * COIN, DUMMY_P2WPKH_SCRIPT)]\n         tx1a_hex = txToHex(tx1a)\n         self.nodes[0].sendrawtransaction(tx1a_hex, 0)\n \n@@ -312,7 +311,7 @@ def test_spends_of_conflicting_outputs(self):\n \n         tx1a = CTransaction()\n         tx1a.vin = [CTxIn(utxo1, nSequence=0)]\n-        tx1a.vout = [CTxOut(int(1.1 * COIN), CScript([b'a' * 35]))]\n+        tx1a.vout = [CTxOut(int(1.1 * COIN), DUMMY_P2WPKH_SCRIPT)]\n         tx1a_hex = txToHex(tx1a)\n         tx1a_txid = self.nodes[0].sendrawtransaction(tx1a_hex, 0)\n \n@@ -331,7 +330,7 @@ def test_spends_of_conflicting_outputs(self):\n         # Spend tx1a's output to test the indirect case.\n         tx1b = CTransaction()\n         tx1b.vin = [CTxIn(COutPoint(tx1a_txid, 0), nSequence=0)]\n-        tx1b.vout = [CTxOut(1 * COIN, CScript([b'a' * 35]))]\n+        tx1b.vout = [CTxOut(1 * COIN, DUMMY_P2WPKH_SCRIPT)]\n         tx1b_hex = txToHex(tx1b)\n         tx1b_txid = self.nodes[0].sendrawtransaction(tx1b_hex, 0)\n         tx1b_txid = int(tx1b_txid, 16)\n@@ -352,7 +351,7 @@ def test_new_unconfirmed_inputs(self):\n \n         tx1 = CTransaction()\n         tx1.vin = [CTxIn(confirmed_utxo)]\n-        tx1.vout = [CTxOut(1 * COIN, CScript([b'a' * 35]))]\n+        tx1.vout = [CTxOut(1 * COIN, DUMMY_P2WPKH_SCRIPT)]\n         tx1_hex = txToHex(tx1)\n         self.nodes[0].sendrawtransaction(tx1_hex, 0)\n \n@@ -391,7 +390,7 @@ def test_too_many_replacements(self):\n         for i in range(MAX_REPLACEMENT_LIMIT+1):\n             tx_i = CTransaction()\n             tx_i.vin = [CTxIn(COutPoint(txid, i), nSequence=0)]\n-            tx_i.vout = [CTxOut(split_value - fee, CScript([b'a' * 35]))]\n+            tx_i.vout = [CTxOut(split_value - fee, DUMMY_P2WPKH_SCRIPT)]\n             tx_i_hex = txToHex(tx_i)\n             self.nodes[0].sendrawtransaction(tx_i_hex, 0)\n \n@@ -424,7 +423,7 @@ def test_opt_in(self):\n         # Create a non-opting in transaction\n         tx1a = CTransaction()\n         tx1a.vin = [CTxIn(tx0_outpoint, nSequence=0xffffffff)]\n-        tx1a.vout = [CTxOut(1 * COIN, CScript([b'a' * 35]))]\n+        tx1a.vout = [CTxOut(1 * COIN, DUMMY_P2WPKH_SCRIPT)]\n         tx1a_hex = txToHex(tx1a)\n         tx1a_txid = self.nodes[0].sendrawtransaction(tx1a_hex, 0)\n \n@@ -434,7 +433,7 @@ def test_opt_in(self):\n         # Shouldn't be able to double-spend\n         tx1b = CTransaction()\n         tx1b.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n-        tx1b.vout = [CTxOut(int(0.9 * COIN), CScript([b'b' * 35]))]\n+        tx1b.vout = [CTxOut(int(0.9 * COIN), DUMMY_P2WPKH_SCRIPT)]\n         tx1b_hex = txToHex(tx1b)\n \n         # This will raise an exception\n@@ -445,14 +444,14 @@ def test_opt_in(self):\n         # Create a different non-opting in transaction\n         tx2a = CTransaction()\n         tx2a.vin = [CTxIn(tx1_outpoint, nSequence=0xfffffffe)]\n-        tx2a.vout = [CTxOut(1 * COIN, CScript([b'a' * 35]))]\n+        tx2a.vout = [CTxOut(1 * COIN, DUMMY_P2WPKH_SCRIPT)]\n         tx2a_hex = txToHex(tx2a)\n         tx2a_txid = self.nodes[0].sendrawtransaction(tx2a_hex, 0)\n \n         # Still shouldn't be able to double-spend\n         tx2b = CTransaction()\n         tx2b.vin = [CTxIn(tx1_outpoint, nSequence=0)]\n-        tx2b.vout = [CTxOut(int(0.9 * COIN), CScript([b'b' * 35]))]\n+        tx2b.vout = [CTxOut(int(0.9 * COIN), DUMMY_P2WPKH_SCRIPT)]\n         tx2b_hex = txToHex(tx2b)\n \n         # This will raise an exception\n@@ -478,12 +477,12 @@ def test_opt_in(self):\n \n         tx3b = CTransaction()\n         tx3b.vin = [CTxIn(COutPoint(tx1a_txid, 0), nSequence=0)]\n-        tx3b.vout = [CTxOut(int(0.5 * COIN), CScript([b'e' * 35]))]\n+        tx3b.vout = [CTxOut(int(0.5 * COIN), DUMMY_P2WPKH_SCRIPT)]\n         tx3b_hex = txToHex(tx3b)\n \n         tx3c = CTransaction()\n         tx3c.vin = [CTxIn(COutPoint(tx2a_txid, 0), nSequence=0)]\n-        tx3c.vout = [CTxOut(int(0.5 * COIN), CScript([b'f' * 35]))]\n+        tx3c.vout = [CTxOut(int(0.5 * COIN), DUMMY_P2WPKH_SCRIPT)]\n         tx3c_hex = txToHex(tx3c)\n \n         self.nodes[0].sendrawtransaction(tx3b_hex, 0)\n@@ -500,7 +499,7 @@ def test_prioritised_transactions(self):\n \n         tx1a = CTransaction()\n         tx1a.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n-        tx1a.vout = [CTxOut(1 * COIN, CScript([b'a' * 35]))]\n+        tx1a.vout = [CTxOut(1 * COIN, DUMMY_P2WPKH_SCRIPT)]\n         tx1a_hex = txToHex(tx1a)\n         tx1a_txid = self.nodes[0].sendrawtransaction(tx1a_hex, 0)\n \n@@ -526,14 +525,14 @@ def test_prioritised_transactions(self):\n \n         tx2a = CTransaction()\n         tx2a.vin = [CTxIn(tx1_outpoint, nSequence=0)]\n-        tx2a.vout = [CTxOut(1 * COIN, CScript([b'a' * 35]))]\n+        tx2a.vout = [CTxOut(1 * COIN, DUMMY_P2WPKH_SCRIPT)]\n         tx2a_hex = txToHex(tx2a)\n         self.nodes[0].sendrawtransaction(tx2a_hex, 0)\n \n         # Lower fee, but we'll prioritise it\n         tx2b = CTransaction()\n         tx2b.vin = [CTxIn(tx1_outpoint, nSequence=0)]\n-        tx2b.vout = [CTxOut(int(1.01 * COIN), CScript([b'a' * 35]))]\n+        tx2b.vout = [CTxOut(int(1.01 * COIN), DUMMY_P2WPKH_SCRIPT)]\n         tx2b.rehash()\n         tx2b_hex = txToHex(tx2b)\n "
      },
      {
        "sha": "5ef67226c4fddb4ea740eed126e252d451b1063d",
        "filename": "test/functional/test_framework/script_util.py",
        "status": "added",
        "additions": 25,
        "deletions": 0,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32d665c2657793c8b2cc7248d26d80a940acfe20/test/functional/test_framework/script_util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32d665c2657793c8b2cc7248d26d80a940acfe20/test/functional/test_framework/script_util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/script_util.py?ref=32d665c2657793c8b2cc7248d26d80a940acfe20",
        "patch": "@@ -0,0 +1,25 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Useful Script constants and utils.\"\"\"\n+from test_framework.script import CScript\n+\n+# To prevent a \"tx-size-small\" policy rule error, a transaction has to have a\n+# non-witness size of at least 82 bytes (MIN_STANDARD_TX_NONWITNESS_SIZE in\n+# src/policy/policy.h). Considering a Tx with the smallest possible single\n+# input (blank, empty scriptSig), and with an output omitting the scriptPubKey,\n+# we get to a minimum size of 60 bytes:\n+#\n+# Tx Skeleton: 4 [Version] + 1 [InCount] + 1 [OutCount] + 4 [LockTime] = 10 bytes\n+# Blank Input: 32 [PrevTxHash] + 4 [Index] + 1 [scriptSigLen] + 4 [SeqNo] = 41 bytes\n+# Output:      8 [Amount] + 1 [scriptPubKeyLen] = 9 bytes\n+#\n+# Hence, the scriptPubKey of the single output has to have a size of at\n+# least 22 bytes, which corresponds to the size of a P2WPKH scriptPubKey.\n+# The following script constant consists of a single push of 21 bytes of 'a':\n+#   <PUSH_21> <21-bytes of 'a'>\n+# resulting in a 22-byte size. It should be used whenever (small) fake\n+# scriptPubKeys are needed, to guarantee that the minimum transaction size is\n+# met.\n+DUMMY_P2WPKH_SCRIPT = CScript([b'a' * 21])"
      }
    ]
  }
]