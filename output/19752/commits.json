[
  {
    "sha": "1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMzQzYzg2YzdjYzFmYzg5NjY5NmIzZWQ4N2MxMjAzOWU0ZWYzYTBj",
    "commit": {
      "author": {
        "name": "Seleme Topuz",
        "email": "seleme94@hotmail.com",
        "date": "2020-08-17T15:50:47Z"
      },
      "committer": {
        "name": "Seleme Topuz",
        "email": "seleme94@hotmail.com",
        "date": "2020-08-26T16:01:59Z"
      },
      "message": "test: Update wait_until usage in tests not to use the one from utils\n\nReplace \"wait_until()\" usage from utils, with the ones from BitcoinTestFramework and P2PInterface.\ncloses #19080",
      "tree": {
        "sha": "0e98164b74d0549a90de162226c36b677b7e8846",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0e98164b74d0549a90de162226c36b677b7e8846"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/comments",
    "author": {
      "login": "slmtpz",
      "id": 17165664,
      "node_id": "MDQ6VXNlcjE3MTY1NjY0",
      "avatar_url": "https://avatars.githubusercontent.com/u/17165664?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/slmtpz",
      "html_url": "https://github.com/slmtpz",
      "followers_url": "https://api.github.com/users/slmtpz/followers",
      "following_url": "https://api.github.com/users/slmtpz/following{/other_user}",
      "gists_url": "https://api.github.com/users/slmtpz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/slmtpz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/slmtpz/subscriptions",
      "organizations_url": "https://api.github.com/users/slmtpz/orgs",
      "repos_url": "https://api.github.com/users/slmtpz/repos",
      "events_url": "https://api.github.com/users/slmtpz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/slmtpz/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "slmtpz",
      "id": 17165664,
      "node_id": "MDQ6VXNlcjE3MTY1NjY0",
      "avatar_url": "https://avatars.githubusercontent.com/u/17165664?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/slmtpz",
      "html_url": "https://github.com/slmtpz",
      "followers_url": "https://api.github.com/users/slmtpz/followers",
      "following_url": "https://api.github.com/users/slmtpz/following{/other_user}",
      "gists_url": "https://api.github.com/users/slmtpz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/slmtpz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/slmtpz/subscriptions",
      "organizations_url": "https://api.github.com/users/slmtpz/orgs",
      "repos_url": "https://api.github.com/users/slmtpz/repos",
      "events_url": "https://api.github.com/users/slmtpz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/slmtpz/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "93ab136a33e46080c8aa02d59fb7c2a8d03a3387",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/93ab136a33e46080c8aa02d59fb7c2a8d03a3387",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/93ab136a33e46080c8aa02d59fb7c2a8d03a3387"
      }
    ],
    "stats": {
      "total": 166,
      "additions": 74,
      "deletions": 92
    },
    "files": [
      {
        "sha": "18320439890b3020ec421b02dfc6020c2c087909",
        "filename": "test/functional/example_test.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/example_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/example_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/example_test.py?ref=1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
        "patch": "@@ -26,7 +26,6 @@\n from test_framework.util import (\n     assert_equal,\n     connect_nodes,\n-    wait_until,\n )\n \n # P2PInterface is a class containing callbacks to be executed when a P2P\n@@ -203,7 +202,7 @@ def run_test(self):\n \n         # wait_until() will loop until a predicate condition is met. Use it to test properties of the\n         # P2PInterface objects.\n-        wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5, lock=p2p_lock)\n+        self.nodes[2].p2p.wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5)\n \n         self.log.info(\"Check that each block was received only once\")\n         # The network thread uses a global lock on data access to the P2PConnection objects when sending and receiving"
      },
      {
        "sha": "17fbf50cc85942453a42641b6ce790f8e2855357",
        "filename": "test/functional/feature_abortnode.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/feature_abortnode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/feature_abortnode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_abortnode.py?ref=1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
        "patch": "@@ -11,7 +11,7 @@\n \"\"\"\n \n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import wait_until, get_datadir_path, connect_nodes\n+from test_framework.util import get_datadir_path, connect_nodes\n import os\n \n \n@@ -41,7 +41,7 @@ def run_test(self):\n \n             # Check that node0 aborted\n             self.log.info(\"Waiting for crash\")\n-            wait_until(lambda: self.nodes[0].is_node_stopped(), timeout=200)\n+            self.nodes[0].wait_until_stopped(timeout=200)\n         self.log.info(\"Node crashed - now verifying restart fails\")\n         self.nodes[0].assert_start_raises_init_error()\n "
      },
      {
        "sha": "3497b49a196588f16603b55fa2767538b82fe1d7",
        "filename": "test/functional/feature_notifications.py",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/feature_notifications.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/feature_notifications.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_notifications.py?ref=1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
        "patch": "@@ -9,7 +9,6 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n-    wait_until,\n     connect_nodes,\n     disconnect_nodes,\n     hex_str_to_bytes,\n@@ -56,15 +55,15 @@ def run_test(self):\n         blocks = self.nodes[1].generatetoaddress(block_count, self.nodes[1].getnewaddress() if self.is_wallet_compiled() else ADDRESS_BCRT1_UNSPENDABLE)\n \n         # wait at most 10 seconds for expected number of files before reading the content\n-        wait_until(lambda: len(os.listdir(self.blocknotify_dir)) == block_count, timeout=10)\n+        self.wait_until(lambda: len(os.listdir(self.blocknotify_dir)) == block_count, timeout=10)\n \n         # directory content should equal the generated blocks hashes\n         assert_equal(sorted(blocks), sorted(os.listdir(self.blocknotify_dir)))\n \n         if self.is_wallet_compiled():\n             self.log.info(\"test -walletnotify\")\n             # wait at most 10 seconds for expected number of files before reading the content\n-            wait_until(lambda: len(os.listdir(self.walletnotify_dir)) == block_count, timeout=10)\n+            self.wait_until(lambda: len(os.listdir(self.walletnotify_dir)) == block_count, timeout=10)\n \n             # directory content should equal the generated transaction hashes\n             txids_rpc = list(map(lambda t: notify_outputname(self.wallet, t['txid']), self.nodes[1].listtransactions(\"*\", block_count)))\n@@ -78,7 +77,7 @@ def run_test(self):\n             self.start_node(1)\n             connect_nodes(self.nodes[0], 1)\n \n-            wait_until(lambda: len(os.listdir(self.walletnotify_dir)) == block_count, timeout=10)\n+            self.wait_until(lambda: len(os.listdir(self.walletnotify_dir)) == block_count, timeout=10)\n \n             # directory content should equal the generated transaction hashes\n             txids_rpc = list(map(lambda t: notify_outputname(self.wallet, t['txid']), self.nodes[1].listtransactions(\"*\", block_count)))\n@@ -140,7 +139,7 @@ def run_test(self):\n         # TODO: add test for `-alertnotify` large fork notifications\n \n     def expect_wallet_notify(self, tx_ids):\n-        wait_until(lambda: len(os.listdir(self.walletnotify_dir)) >= len(tx_ids), timeout=10)\n+        self.wait_until(lambda: len(os.listdir(self.walletnotify_dir)) >= len(tx_ids), timeout=10)\n         assert_equal(sorted(notify_outputname(self.wallet, tx_id) for tx_id in tx_ids), sorted(os.listdir(self.walletnotify_dir)))\n         for tx_file in os.listdir(self.walletnotify_dir):\n             os.remove(os.path.join(self.walletnotify_dir, tx_file))"
      },
      {
        "sha": "db408ab67a0acf1928a4c722901971a34a9eaf27",
        "filename": "test/functional/feature_pruning.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/feature_pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/feature_pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_pruning.py?ref=1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
        "patch": "@@ -20,7 +20,6 @@\n     assert_raises_rpc_error,\n     connect_nodes,\n     disconnect_nodes,\n-    wait_until,\n )\n \n # Rescans start at the earliest block up to 2 hours before a key timestamp, so\n@@ -136,7 +135,7 @@ def test_height_min(self):\n         mine_large_blocks(self.nodes[0], 25)\n \n         # Wait for blk00000.dat to be pruned\n-        wait_until(lambda: not os.path.isfile(os.path.join(self.prunedir, \"blk00000.dat\")), timeout=30)\n+        self.wait_until(lambda: not os.path.isfile(os.path.join(self.prunedir, \"blk00000.dat\")), timeout=30)\n \n         self.log.info(\"Success\")\n         usage = calc_usage(self.prunedir)\n@@ -250,7 +249,7 @@ def reorg_back(self):\n \n         self.log.info(\"Verify node 2 reorged back to the main chain, some blocks of which it had to redownload\")\n         # Wait for Node 2 to reorg to proper height\n-        wait_until(lambda: self.nodes[2].getblockcount() >= goalbestheight, timeout=900)\n+        self.wait_until(lambda: self.nodes[2].getblockcount() >= goalbestheight, timeout=900)\n         assert_equal(self.nodes[2].getbestblockhash(), goalbesthash)\n         # Verify we can now have the data for a block previously pruned\n         assert_equal(self.nodes[2].getblock(self.forkhash)[\"height\"], self.forkheight)"
      },
      {
        "sha": "a76e0f1b50afc9a81b9fb580c6cd1a85b557ada9",
        "filename": "test/functional/feature_shutdown.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/feature_shutdown.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/feature_shutdown.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_shutdown.py?ref=1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
        "patch": "@@ -5,7 +5,7 @@\n \"\"\"Test bitcoind shutdown.\"\"\"\n \n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, get_rpc_proxy, wait_until\n+from test_framework.util import assert_equal, get_rpc_proxy\n from threading import Thread\n \n def test_long_call(node):\n@@ -25,7 +25,7 @@ def run_test(self):\n         node.getblockcount()\n         Thread(target=test_long_call, args=(node,)).start()\n         # Wait until the server is executing the above `waitfornewblock`.\n-        wait_until(lambda: len(self.nodes[0].getrpcinfo()['active_commands']) == 2)\n+        self.wait_until(lambda: len(self.nodes[0].getrpcinfo()['active_commands']) == 2)\n         # Wait 1 second after requesting shutdown but not before the `stop` call\n         # finishes. This is to ensure event loop waits for current connections\n         # to close."
      },
      {
        "sha": "e045adac32d2666f86421a5358a57d3801d5b3a6",
        "filename": "test/functional/feature_versionbits_warning.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/feature_versionbits_warning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/feature_versionbits_warning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_versionbits_warning.py?ref=1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
        "patch": "@@ -14,7 +14,6 @@\n from test_framework.messages import msg_block\n from test_framework.p2p import p2p_lock, P2PInterface\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import wait_until\n \n VB_PERIOD = 144           # versionbits period length for regtest\n VB_THRESHOLD = 108        # versionbits activation threshold for regtest\n@@ -91,14 +90,14 @@ def run_test(self):\n \n         # Generating one block guarantees that we'll get out of IBD\n         node.generatetoaddress(1, node_deterministic_address)\n-        wait_until(lambda: not node.getblockchaininfo()['initialblockdownload'], timeout=10, lock=p2p_lock)\n+        self.wait_until(lambda: not node.getblockchaininfo()['initialblockdownload'], timeout=10, lock=p2p_lock)\n         # Generating one more block will be enough to generate an error.\n         node.generatetoaddress(1, node_deterministic_address)\n         # Check that get*info() shows the versionbits unknown rules warning\n         assert WARN_UNKNOWN_RULES_ACTIVE in node.getmininginfo()[\"warnings\"]\n         assert WARN_UNKNOWN_RULES_ACTIVE in node.getnetworkinfo()[\"warnings\"]\n         # Check that the alert file shows the versionbits unknown rules warning\n-        wait_until(lambda: self.versionbits_in_alert_file(), timeout=60)\n+        self.wait_until(lambda: self.versionbits_in_alert_file())\n \n if __name__ == '__main__':\n     VersionBitsWarningTest().main()"
      },
      {
        "sha": "e74ef8cf16be33653b569a039800892b8e451a1d",
        "filename": "test/functional/mempool_packages.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/mempool_packages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/mempool_packages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_packages.py?ref=1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
        "patch": "@@ -13,7 +13,6 @@\n     assert_equal,\n     assert_raises_rpc_error,\n     satoshi_round,\n-    wait_until,\n )\n \n # default limits\n@@ -269,8 +268,8 @@ def run_test(self):\n         # - txs from previous ancestor test (-> custom ancestor limit)\n         # - parent tx for descendant test\n         # - txs chained off parent tx (-> custom descendant limit)\n-        wait_until(lambda: len(self.nodes[1].getrawmempool(False)) ==\n-                           MAX_ANCESTORS_CUSTOM + 1 + MAX_DESCENDANTS_CUSTOM, timeout=10)\n+        self.wait_until(lambda: len(self.nodes[1].getrawmempool(False)) ==\n+                                MAX_ANCESTORS_CUSTOM + 1 + MAX_DESCENDANTS_CUSTOM, timeout=10)\n         mempool0 = self.nodes[0].getrawmempool(False)\n         mempool1 = self.nodes[1].getrawmempool(False)\n         assert set(mempool1).issubset(set(mempool0))"
      },
      {
        "sha": "f73f1a02a2a8bd34b8c81ed357b4a90a751bda85",
        "filename": "test/functional/mempool_persist.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/mempool_persist.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/mempool_persist.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_persist.py?ref=1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
        "patch": "@@ -47,7 +47,6 @@\n     assert_raises_rpc_error,\n     connect_nodes,\n     disconnect_nodes,\n-    wait_until,\n )\n \n \n@@ -172,7 +171,7 @@ def test_persist_unbroadcast(self):\n         # check that txn gets broadcast due to unbroadcast logic\n         conn = node0.add_p2p_connection(P2PTxInvStore())\n         node0.mockscheduler(16*60) # 15 min + 1 for buffer\n-        wait_until(lambda: len(conn.get_invs()) == 1)\n+        self.wait_until(lambda: len(conn.get_invs()) == 1)\n \n if __name__ == '__main__':\n     MempoolPersistTest().main()"
      },
      {
        "sha": "84178d0dd70c2099035984f1227eee545c4a38dd",
        "filename": "test/functional/p2p_blockfilters.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/p2p_blockfilters.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/p2p_blockfilters.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_blockfilters.py?ref=1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
        "patch": "@@ -24,7 +24,6 @@\n     assert_equal,\n     connect_nodes,\n     disconnect_nodes,\n-    wait_until,\n )\n \n class CFiltersClient(P2PInterface):\n@@ -65,11 +64,11 @@ def run_test(self):\n         disconnect_nodes(self.nodes[0], 1)\n \n         self.nodes[0].generate(1)\n-        wait_until(lambda: self.nodes[0].getblockcount() == 1000)\n+        self.wait_until(lambda: self.nodes[0].getblockcount() == 1000)\n         stale_block_hash = self.nodes[0].getblockhash(1000)\n \n         self.nodes[1].generate(1001)\n-        wait_until(lambda: self.nodes[1].getblockcount() == 2000)\n+        self.wait_until(lambda: self.nodes[1].getblockcount() == 2000)\n \n         # Check that nodes have signalled NODE_COMPACT_FILTERS correctly.\n         assert node0.nServices & NODE_COMPACT_FILTERS != 0"
      },
      {
        "sha": "fdae7fb68b3626a02fe79d7c8cb3baa61df1889e",
        "filename": "test/functional/p2p_compactblocks.py",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/p2p_compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/p2p_compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_compactblocks.py?ref=1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
        "patch": "@@ -14,7 +14,7 @@\n from test_framework.p2p import p2p_lock, P2PInterface\n from test_framework.script import CScript, OP_TRUE, OP_DROP\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, wait_until, softfork_active\n+from test_framework.util import assert_equal, softfork_active\n \n # TestP2PConn: A peer we use to send messages to bitcoind, and store responses.\n class TestP2PConn(P2PInterface):\n@@ -73,23 +73,23 @@ def send_header_for_blocks(self, new_blocks):\n     def request_headers_and_sync(self, locator, hashstop=0):\n         self.clear_block_announcement()\n         self.get_headers(locator, hashstop)\n-        wait_until(self.received_block_announcement, timeout=30, lock=p2p_lock)\n+        self.wait_until(self.received_block_announcement, timeout=30)\n         self.clear_block_announcement()\n \n     # Block until a block announcement for a particular block hash is\n     # received.\n     def wait_for_block_announcement(self, block_hash, timeout=30):\n         def received_hash():\n             return (block_hash in self.announced_blockhashes)\n-        wait_until(received_hash, timeout=timeout, lock=p2p_lock)\n+        self.wait_until(received_hash, timeout=timeout)\n \n     def send_await_disconnect(self, message, timeout=30):\n         \"\"\"Sends a message to the node and wait for disconnect.\n \n         This is used when we want to send a message into the node that we expect\n         will get us disconnected, eg an invalid block.\"\"\"\n         self.send_message(message)\n-        wait_until(lambda: not self.is_connected, timeout=timeout, lock=p2p_lock)\n+        self.wait_for_disconnect(timeout)\n \n class CompactBlocksTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -154,7 +154,7 @@ def test_sendcmpct(self, test_node, old_node=None):\n         # Make sure we get a SENDCMPCT message from our peer\n         def received_sendcmpct():\n             return (len(test_node.last_sendcmpct) > 0)\n-        wait_until(received_sendcmpct, timeout=30, lock=p2p_lock)\n+        test_node.wait_until(received_sendcmpct, timeout=30)\n         with p2p_lock:\n             # Check that the first version received is the preferred one\n             assert_equal(test_node.last_sendcmpct[0].version, preferred_version)\n@@ -294,7 +294,7 @@ def test_compactblock_construction(self, test_node, use_witness_address=True):\n         block.rehash()\n \n         # Wait until the block was announced (via compact blocks)\n-        wait_until(lambda: \"cmpctblock\" in test_node.last_message, timeout=30, lock=p2p_lock)\n+        test_node.wait_until(lambda: \"cmpctblock\" in test_node.last_message, timeout=30)\n \n         # Now fetch and check the compact block\n         header_and_shortids = None\n@@ -308,7 +308,7 @@ def test_compactblock_construction(self, test_node, use_witness_address=True):\n         inv = CInv(MSG_CMPCT_BLOCK, block_hash)\n         test_node.send_message(msg_getdata([inv]))\n \n-        wait_until(lambda: \"cmpctblock\" in test_node.last_message, timeout=30, lock=p2p_lock)\n+        test_node.wait_until(lambda: \"cmpctblock\" in test_node.last_message, timeout=30)\n \n         # Now fetch and check the compact block\n         header_and_shortids = None\n@@ -378,7 +378,7 @@ def test_compactblock_requests(self, test_node, segwit=True):\n \n             if announce == \"inv\":\n                 test_node.send_message(msg_inv([CInv(MSG_BLOCK, block.sha256)]))\n-                wait_until(lambda: \"getheaders\" in test_node.last_message, timeout=30, lock=p2p_lock)\n+                test_node.wait_until(lambda: \"getheaders\" in test_node.last_message, timeout=30)\n                 test_node.send_header_for_blocks([block])\n             else:\n                 test_node.send_header_for_blocks([block])\n@@ -588,7 +588,7 @@ def test_getblocktxn_handler(self, test_node):\n             num_to_request = random.randint(1, len(block.vtx))\n             msg.block_txn_request.from_absolute(sorted(random.sample(range(len(block.vtx)), num_to_request)))\n             test_node.send_message(msg)\n-            wait_until(lambda: \"blocktxn\" in test_node.last_message, timeout=10, lock=p2p_lock)\n+            test_node.wait_until(lambda: \"blocktxn\" in test_node.last_message, timeout=10)\n \n             [tx.calc_sha256() for tx in block.vtx]\n             with p2p_lock:\n@@ -628,20 +628,20 @@ def test_compactblocks_not_at_tip(self, test_node):\n         for _ in range(MAX_CMPCTBLOCK_DEPTH + 1):\n             test_node.clear_block_announcement()\n             new_blocks.append(node.generate(1)[0])\n-            wait_until(test_node.received_block_announcement, timeout=30, lock=p2p_lock)\n+            test_node.wait_until(test_node.received_block_announcement, timeout=30)\n \n         test_node.clear_block_announcement()\n         test_node.send_message(msg_getdata([CInv(MSG_CMPCT_BLOCK, int(new_blocks[0], 16))]))\n-        wait_until(lambda: \"cmpctblock\" in test_node.last_message, timeout=30, lock=p2p_lock)\n+        test_node.wait_until(lambda: \"cmpctblock\" in test_node.last_message, timeout=30)\n \n         test_node.clear_block_announcement()\n         node.generate(1)\n-        wait_until(test_node.received_block_announcement, timeout=30, lock=p2p_lock)\n+        test_node.wait_until(test_node.received_block_announcement, timeout=30)\n         test_node.clear_block_announcement()\n         with p2p_lock:\n             test_node.last_message.pop(\"block\", None)\n         test_node.send_message(msg_getdata([CInv(MSG_CMPCT_BLOCK, int(new_blocks[0], 16))]))\n-        wait_until(lambda: \"block\" in test_node.last_message, timeout=30, lock=p2p_lock)\n+        test_node.wait_until(lambda: \"block\" in test_node.last_message, timeout=30)\n         with p2p_lock:\n             test_node.last_message[\"block\"].block.calc_sha256()\n             assert_equal(test_node.last_message[\"block\"].block.sha256, int(new_blocks[0], 16))\n@@ -689,7 +689,7 @@ def test_end_to_end_block_relay(self, listeners):\n         node.submitblock(ToHex(block))\n \n         for l in listeners:\n-            wait_until(lambda: \"cmpctblock\" in l.last_message, timeout=30, lock=p2p_lock)\n+            l.wait_until(lambda: \"cmpctblock\" in l.last_message, timeout=30)\n         with p2p_lock:\n             for l in listeners:\n                 l.last_message[\"cmpctblock\"].header_and_shortids.header.calc_sha256()"
      },
      {
        "sha": "b7c2a306ebc60a685b7cc5925b59de35ba3e10ea",
        "filename": "test/functional/p2p_disconnect_ban.py",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/p2p_disconnect_ban.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/p2p_disconnect_ban.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_disconnect_ban.py?ref=1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
        "patch": "@@ -10,7 +10,6 @@\n     assert_equal,\n     assert_raises_rpc_error,\n     connect_nodes,\n-    wait_until,\n )\n \n class DisconnectBanTest(BitcoinTestFramework):\n@@ -28,7 +27,7 @@ def run_test(self):\n         self.log.info(\"setban: successfully ban single IP address\")\n         assert_equal(len(self.nodes[1].getpeerinfo()), 2)  # node1 should have 2 connections to node0 at this point\n         self.nodes[1].setban(subnet=\"127.0.0.1\", command=\"add\")\n-        wait_until(lambda: len(self.nodes[1].getpeerinfo()) == 0, timeout=10)\n+        self.wait_until(lambda: len(self.nodes[1].getpeerinfo()) == 0, timeout=10)\n         assert_equal(len(self.nodes[1].getpeerinfo()), 0)  # all nodes must be disconnected at this point\n         assert_equal(len(self.nodes[1].listbanned()), 1)\n \n@@ -95,7 +94,7 @@ def run_test(self):\n         self.log.info(\"disconnectnode: successfully disconnect node by address\")\n         address1 = self.nodes[0].getpeerinfo()[0]['addr']\n         self.nodes[0].disconnectnode(address=address1)\n-        wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 1, timeout=10)\n+        self.wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 1, timeout=10)\n         assert not [node for node in self.nodes[0].getpeerinfo() if node['addr'] == address1]\n \n         self.log.info(\"disconnectnode: successfully reconnect node\")\n@@ -106,7 +105,7 @@ def run_test(self):\n         self.log.info(\"disconnectnode: successfully disconnect node by node id\")\n         id1 = self.nodes[0].getpeerinfo()[0]['id']\n         self.nodes[0].disconnectnode(nodeid=id1)\n-        wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 1, timeout=10)\n+        self.wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 1, timeout=10)\n         assert not [node for node in self.nodes[0].getpeerinfo() if node['id'] == id1]\n \n if __name__ == '__main__':"
      },
      {
        "sha": "72a255991c5774c4e75d376aadfdc4d46ab0a918",
        "filename": "test/functional/p2p_eviction.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/p2p_eviction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/p2p_eviction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_eviction.py?ref=1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
        "patch": "@@ -19,7 +19,7 @@\n from test_framework.messages import CTransaction, FromHex, msg_pong, msg_tx\n from test_framework.p2p import P2PDataStore, P2PInterface\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, wait_until\n+from test_framework.util import assert_equal\n \n \n class SlowP2PDataStore(P2PDataStore):\n@@ -92,7 +92,7 @@ def run_test(self):\n         for _ in range(8):\n             fastpeer = node.add_p2p_connection(P2PInterface())\n             current_peer += 1\n-            wait_until(lambda: \"ping\" in fastpeer.last_message, timeout=10)\n+            self.wait_until(lambda: \"ping\" in fastpeer.last_message, timeout=10)\n \n         # Make sure by asking the node what the actual min pings are\n         peerinfo = node.getpeerinfo()"
      },
      {
        "sha": "0c07b56a69ff0d984e6e61dbaf7490197fe62fd3",
        "filename": "test/functional/p2p_feefilter.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/p2p_feefilter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/p2p_feefilter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_feefilter.py?ref=1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
        "patch": "@@ -39,7 +39,7 @@ def on_inv(self, message):\n \n     def wait_for_invs_to_match(self, invs_expected):\n         invs_expected.sort()\n-        self.wait_until(lambda: invs_expected == sorted(self.txinvs), timeout=60)\n+        self.wait_until(lambda: invs_expected == sorted(self.txinvs))\n \n     def clear_invs(self):\n         with p2p_lock:"
      },
      {
        "sha": "aaf862e6c8fb98ed9fd72b9a0eeb718e425e5267",
        "filename": "test/functional/p2p_fingerprint.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/p2p_fingerprint.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/p2p_fingerprint.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_fingerprint.py?ref=1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
        "patch": "@@ -22,9 +22,9 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n-    wait_until,\n )\n \n+\n class P2PFingerprintTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.setup_clean_chain = True\n@@ -102,12 +102,12 @@ def run_test(self):\n         # Check that getdata request for stale block succeeds\n         self.send_block_request(stale_hash, node0)\n         test_function = lambda: self.last_block_equals(stale_hash, node0)\n-        wait_until(test_function, timeout=3)\n+        self.wait_until(test_function, timeout=3)\n \n         # Check that getheader request for stale block header succeeds\n         self.send_header_request(stale_hash, node0)\n         test_function = lambda: self.last_header_equals(stale_hash, node0)\n-        wait_until(test_function, timeout=3)\n+        self.wait_until(test_function, timeout=3)\n \n         # Longest chain is extended so stale is much older than chain tip\n         self.nodes[0].setmocktime(0)\n@@ -138,11 +138,11 @@ def run_test(self):\n \n         self.send_block_request(block_hash, node0)\n         test_function = lambda: self.last_block_equals(block_hash, node0)\n-        wait_until(test_function, timeout=3)\n+        self.wait_until(test_function, timeout=3)\n \n         self.send_header_request(block_hash, node0)\n         test_function = lambda: self.last_header_equals(block_hash, node0)\n-        wait_until(test_function, timeout=3)\n+        self.wait_until(test_function, timeout=3)\n \n if __name__ == '__main__':\n     P2PFingerprintTest().main()"
      },
      {
        "sha": "fe57057a83a80c8a48f139c6db77afb36f427ddd",
        "filename": "test/functional/p2p_invalid_messages.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/p2p_invalid_messages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/p2p_invalid_messages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_messages.py?ref=1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
        "patch": "@@ -24,7 +24,6 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n-    wait_until,\n )\n \n VALID_DATA_LIMIT = MAX_PROTOCOL_MESSAGE_LENGTH - 5  # Account for the 5-byte length prefix\n@@ -70,7 +69,7 @@ def test_buffer(self):\n         before = int(self.nodes[0].getnettotals()['totalbytesrecv'])\n         conn.send_raw_message(msg[:cut_pos])\n         # Wait until node has processed the first half of the message\n-        wait_until(lambda: int(self.nodes[0].getnettotals()['totalbytesrecv']) != before)\n+        self.wait_until(lambda: int(self.nodes[0].getnettotals()['totalbytesrecv']) != before)\n         middle = int(self.nodes[0].getnettotals()['totalbytesrecv'])\n         # If this assert fails, we've hit an unlikely race\n         # where the test framework sent a message in between the two halves"
      },
      {
        "sha": "a0ef6c9d6e8a2e78fd815da5e55bd9c989c634de",
        "filename": "test/functional/p2p_invalid_tx.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/p2p_invalid_tx.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/p2p_invalid_tx.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_tx.py?ref=1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
        "patch": "@@ -17,7 +17,6 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n-    wait_until,\n )\n from data import invalid_txs\n \n@@ -146,7 +145,7 @@ def run_test(self):\n         # tx_orphan_no_fee, because it has too low fee (p2ps[0] is not disconnected for relaying that tx)\n         # tx_orphan_invaid, because it has negative fee (p2ps[1] is disconnected for relaying that tx)\n \n-        wait_until(lambda: 1 == len(node.getpeerinfo()), timeout=12)  # p2ps[1] is no longer connected\n+        self.wait_until(lambda: 1 == len(node.getpeerinfo()), timeout=12)  # p2ps[1] is no longer connected\n         assert_equal(expected_mempool, set(node.getrawmempool()))\n \n         self.log.info('Test orphan pool overflow')"
      },
      {
        "sha": "4978aa3845df8f994f6d1e8b60c4511a06126e18",
        "filename": "test/functional/p2p_leak.py",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/p2p_leak.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/p2p_leak.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_leak.py?ref=1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
        "patch": "@@ -22,7 +22,6 @@\n from test_framework.util import (\n     assert_equal,\n     assert_greater_than_or_equal,\n-    wait_until,\n )\n \n DISCOURAGEMENT_THRESHOLD = 100\n@@ -114,9 +113,9 @@ def run_test(self):\n         # verack, since we never sent one\n         no_verack_idle_peer.wait_for_verack()\n \n-        wait_until(lambda: no_version_disconnect_peer.ever_connected, timeout=10, lock=p2p_lock)\n-        wait_until(lambda: no_version_idle_peer.ever_connected, timeout=10, lock=p2p_lock)\n-        wait_until(lambda: no_verack_idle_peer.version_received, timeout=10, lock=p2p_lock)\n+        self.wait_until(lambda: no_version_disconnect_peer.ever_connected, timeout=10, lock=p2p_lock)\n+        self.wait_until(lambda: no_version_idle_peer.ever_connected, timeout=10, lock=p2p_lock)\n+        self.wait_until(lambda: no_verack_idle_peer.version_received, timeout=10, lock=p2p_lock)\n \n         # Mine a block and make sure that it's not sent to the connected peers\n         self.nodes[0].generate(nblocks=1)"
      },
      {
        "sha": "2c9cbea5e4a7e8802cfd6b11031cb3cc8dcb2855",
        "filename": "test/functional/p2p_node_network_limited.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/p2p_node_network_limited.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/p2p_node_network_limited.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_node_network_limited.py?ref=1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
        "patch": "@@ -9,13 +9,12 @@\n     - send a block within 288 + 2 of the tip\n     - disconnect peers who request blocks older than that.\"\"\"\n from test_framework.messages import CInv, MSG_BLOCK, msg_getdata, msg_verack, NODE_NETWORK_LIMITED, NODE_WITNESS\n-from test_framework.p2p import P2PInterface, p2p_lock\n+from test_framework.p2p import P2PInterface\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n     disconnect_nodes,\n     connect_nodes,\n-    wait_until,\n )\n \n \n@@ -28,7 +27,7 @@ def on_addr(self, message):\n         self.firstAddrnServices = message.addrs[0].nServices\n     def wait_for_addr(self, timeout=5):\n         test_function = lambda: self.last_message.get(\"addr\")\n-        wait_until(test_function, timeout=timeout, lock=p2p_lock)\n+        self.wait_until(test_function, timeout=timeout)\n     def send_getdata_for_block(self, blockhash):\n         getdata_request = msg_getdata()\n         getdata_request.inv.append(CInv(MSG_BLOCK, int(blockhash, 16)))"
      },
      {
        "sha": "3ec36edb41ea56fbaa3a5a963f3488317b23852e",
        "filename": "test/functional/p2p_permissions.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/p2p_permissions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/p2p_permissions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_permissions.py?ref=1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
        "patch": "@@ -24,7 +24,6 @@\n     assert_equal,\n     connect_nodes,\n     p2p_port,\n-    wait_until,\n )\n \n \n@@ -137,7 +136,7 @@ def check_tx_relay(self):\n         connect_nodes(self.nodes[1], 0)\n         with self.nodes[1].assert_debug_log([\"Force relaying tx {} from peer=0\".format(txid)]):\n             p2p_rebroadcast_wallet.send_txs_and_test([tx], self.nodes[1])\n-            wait_until(lambda: txid in self.nodes[0].getrawmempool())\n+            self.wait_until(lambda: txid in self.nodes[0].getrawmempool())\n \n         self.log.debug(\"Check that node[1] will not send an invalid tx to node[0]\")\n         tx.vout[0].nValue += 1"
      },
      {
        "sha": "2155c1d0e7543059261e248a80e74f9b09707a56",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
        "patch": "@@ -83,7 +83,6 @@\n     softfork_active,\n     hex_str_to_bytes,\n     assert_raises_rpc_error,\n-    wait_until,\n )\n \n # The versionbit bit used to signal activation of SegWit\n@@ -2114,7 +2113,7 @@ def test_wtxid_relay(self):\n         # Check wtxidrelay feature negotiation message through connecting a new peer\n         def received_wtxidrelay():\n             return (len(self.wtx_node.last_wtxidrelay) > 0)\n-        wait_until(received_wtxidrelay, timeout=60, lock=p2p_lock)\n+        self.wtx_node.wait_until(received_wtxidrelay)\n \n         # Create a Segwit output from the latest UTXO\n         # and announce it to the network"
      },
      {
        "sha": "04e6ec4172747cfc72801d54d68736bae3f12425",
        "filename": "test/functional/p2p_sendheaders.py",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/p2p_sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/p2p_sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_sendheaders.py?ref=1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
        "patch": "@@ -104,7 +104,6 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n-    wait_until,\n )\n \n DIRECT_FETCH_RESPONSE_TIME = 0.05\n@@ -147,7 +146,7 @@ def send_getblocks(self, locator):\n \n     def wait_for_block_announcement(self, block_hash, timeout=60):\n         test_function = lambda: self.last_blockhash_announced == block_hash\n-        wait_until(test_function, timeout=timeout, lock=p2p_lock)\n+        self.wait_until(test_function, timeout=timeout)\n \n     def on_inv(self, message):\n         self.block_announced = True\n@@ -174,7 +173,7 @@ def check_last_headers_announcement(self, headers):\n         \"\"\"Test whether the last headers announcements received are right.\n            Headers may be announced across more than one message.\"\"\"\n         test_function = lambda: (len(self.recent_headers_announced) >= len(headers))\n-        wait_until(test_function, timeout=60, lock=p2p_lock)\n+        self.wait_until(test_function)\n         with p2p_lock:\n             assert_equal(self.recent_headers_announced, headers)\n             self.block_announced = False\n@@ -186,7 +185,7 @@ def check_last_inv_announcement(self, inv):\n         inv should be a list of block hashes.\"\"\"\n \n         test_function = lambda: self.block_announced\n-        wait_until(test_function, timeout=60, lock=p2p_lock)\n+        self.wait_until(test_function)\n \n         with p2p_lock:\n             compare_inv = []\n@@ -298,7 +297,7 @@ def test_nonnull_locators(self, test_node, inv_node):\n                 test_node.send_header_for_blocks([new_block])\n                 test_node.wait_for_getdata([new_block.sha256])\n                 test_node.send_and_ping(msg_block(new_block))  # make sure this block is processed\n-                wait_until(lambda: inv_node.block_announced, timeout=60, lock=p2p_lock)\n+                inv_node.wait_until(lambda: inv_node.block_announced)\n                 inv_node.clear_block_announcements()\n                 test_node.clear_block_announcements()\n "
      },
      {
        "sha": "653c7ae43f159783e64b8fea37038e5d5f1ae50e",
        "filename": "test/functional/p2p_tx_download.py",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/p2p_tx_download.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/p2p_tx_download.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_tx_download.py?ref=1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
        "patch": "@@ -23,7 +23,6 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n-    wait_until,\n )\n from test_framework.address import ADDRESS_BCRT1_UNSPENDABLE\n \n@@ -80,7 +79,7 @@ def getdata_found(peer_index):\n         while outstanding_peer_index:\n             node_0_mocktime += MAX_GETDATA_INBOUND_WAIT\n             self.nodes[0].setmocktime(node_0_mocktime)\n-            wait_until(lambda: any(getdata_found(i) for i in outstanding_peer_index))\n+            self.wait_until(lambda: any(getdata_found(i) for i in outstanding_peer_index))\n             for i in outstanding_peer_index:\n                 if getdata_found(i):\n                     outstanding_peer_index.remove(i)\n@@ -138,20 +137,20 @@ def test_in_flight_max(self):\n             p.tx_getdata_count = 0\n \n         p.send_message(msg_inv([CInv(t=MSG_WTX, h=i) for i in txids]))\n-        wait_until(lambda: p.tx_getdata_count >= MAX_GETDATA_IN_FLIGHT, lock=p2p_lock)\n+        p.wait_until(lambda: p.tx_getdata_count >= MAX_GETDATA_IN_FLIGHT)\n         with p2p_lock:\n             assert_equal(p.tx_getdata_count, MAX_GETDATA_IN_FLIGHT)\n \n         self.log.info(\"Now check that if we send a NOTFOUND for a transaction, we'll get one more request\")\n         p.send_message(msg_notfound(vec=[CInv(t=MSG_WTX, h=txids[0])]))\n-        wait_until(lambda: p.tx_getdata_count >= MAX_GETDATA_IN_FLIGHT + 1, timeout=10, lock=p2p_lock)\n+        p.wait_until(lambda: p.tx_getdata_count >= MAX_GETDATA_IN_FLIGHT + 1, timeout=10)\n         with p2p_lock:\n             assert_equal(p.tx_getdata_count, MAX_GETDATA_IN_FLIGHT + 1)\n \n         WAIT_TIME = TX_EXPIRY_INTERVAL // 2 + TX_EXPIRY_INTERVAL\n         self.log.info(\"if we wait about {} minutes, we should eventually get more requests\".format(WAIT_TIME / 60))\n         self.nodes[0].setmocktime(int(time.time() + WAIT_TIME))\n-        wait_until(lambda: p.tx_getdata_count == MAX_GETDATA_IN_FLIGHT + 2)\n+        p.wait_until(lambda: p.tx_getdata_count == MAX_GETDATA_IN_FLIGHT + 2)\n         self.nodes[0].setmocktime(0)\n \n     def test_spurious_notfound(self):"
      },
      {
        "sha": "e788e75557a96038bf6aeb4a158d0fd39661de29",
        "filename": "test/functional/rpc_invalidateblock.py",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/rpc_invalidateblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/rpc_invalidateblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_invalidateblock.py?ref=1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
        "patch": "@@ -9,7 +9,6 @@\n from test_framework.util import (\n     assert_equal,\n     connect_nodes,\n-    wait_until,\n )\n \n \n@@ -57,9 +56,9 @@ def run_test(self):\n         self.log.info(\"..and then mine a block\")\n         self.nodes[2].generatetoaddress(1, self.nodes[2].get_deterministic_priv_key().address)\n         self.log.info(\"Verify all nodes are at the right height\")\n-        wait_until(lambda: self.nodes[2].getblockcount() == 3, timeout=5)\n-        wait_until(lambda: self.nodes[0].getblockcount() == 4, timeout=5)\n-        wait_until(lambda: self.nodes[1].getblockcount() == 4, timeout=5)\n+        self.wait_until(lambda: self.nodes[2].getblockcount() == 3, timeout=5)\n+        self.wait_until(lambda: self.nodes[0].getblockcount() == 4, timeout=5)\n+        self.wait_until(lambda: self.nodes[1].getblockcount() == 4, timeout=5)\n \n         self.log.info(\"Verify that we reconsider all ancestors as well\")\n         blocks = self.nodes[1].generatetodescriptor(10, ADDRESS_BCRT1_UNSPENDABLE_DESCRIPTOR)"
      },
      {
        "sha": "506c77c5676f9912e7e3d5ab33447eb37865e439",
        "filename": "test/functional/rpc_net.py",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/rpc_net.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/rpc_net.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_net.py?ref=1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
        "patch": "@@ -26,7 +26,6 @@\n     assert_raises_rpc_error,\n     connect_nodes,\n     p2p_port,\n-    wait_until,\n )\n \n \n@@ -93,8 +92,8 @@ def test_getnettotals(self):\n         # the bytes sent/received should change\n         # note ping and pong are 32 bytes each\n         self.nodes[0].ping()\n-        wait_until(lambda: (self.nodes[0].getnettotals()['totalbytessent'] >= net_totals_after['totalbytessent'] + 32 * 2), timeout=1)\n-        wait_until(lambda: (self.nodes[0].getnettotals()['totalbytesrecv'] >= net_totals_after['totalbytesrecv'] + 32 * 2), timeout=1)\n+        self.wait_until(lambda: (self.nodes[0].getnettotals()['totalbytessent'] >= net_totals_after['totalbytessent'] + 32 * 2), timeout=1)\n+        self.wait_until(lambda: (self.nodes[0].getnettotals()['totalbytesrecv'] >= net_totals_after['totalbytesrecv'] + 32 * 2), timeout=1)\n \n         peer_info_after_ping = self.nodes[0].getpeerinfo()\n         for before, after in zip(peer_info, peer_info_after_ping):\n@@ -110,7 +109,7 @@ def test_getnetworkinfo(self):\n             self.nodes[0].setnetworkactive(state=False)\n         assert_equal(self.nodes[0].getnetworkinfo()['networkactive'], False)\n         # Wait a bit for all sockets to close\n-        wait_until(lambda: self.nodes[0].getnetworkinfo()['connections'] == 0, timeout=3)\n+        self.wait_until(lambda: self.nodes[0].getnetworkinfo()['connections'] == 0, timeout=3)\n \n         with self.nodes[0].assert_debug_log(expected_msgs=['SetNetworkActive: true\\n']):\n             self.nodes[0].setnetworkactive(state=True)"
      },
      {
        "sha": "0327c9e070171378020621ac3356737d991d0a89",
        "filename": "test/functional/wallet_resendwallettransactions.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/wallet_resendwallettransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/wallet_resendwallettransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_resendwallettransactions.py?ref=1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
        "patch": "@@ -7,9 +7,9 @@\n \n from test_framework.blocktools import create_block, create_coinbase\n from test_framework.messages import ToHex\n-from test_framework.p2p import P2PTxInvStore, p2p_lock\n+from test_framework.p2p import P2PTxInvStore\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, wait_until\n+from test_framework.util import assert_equal\n \n class ResendWalletTransactionsTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -24,7 +24,7 @@ def run_test(self):\n         node.add_p2p_connection(P2PTxInvStore())\n \n         self.log.info(\"Create a new transaction and wait until it's broadcast\")\n-        txid = int(node.sendtoaddress(node.getnewaddress(), 1), 16)\n+        txid = node.sendtoaddress(node.getnewaddress(), 1)\n \n         # Wallet rebroadcast is first scheduled 1 sec after startup (see\n         # nNextResend in ResendWalletTransactions()). Sleep for just over a\n@@ -33,7 +33,7 @@ def run_test(self):\n         time.sleep(1.1)\n \n         # Can take a few seconds due to transaction trickling\n-        wait_until(lambda: node.p2p.tx_invs_received[txid] >= 1, lock=p2p_lock)\n+        node.p2p.wait_for_broadcast([txid])\n \n         # Add a second peer since txs aren't rebroadcast to the same peer (see filterInventoryKnown)\n         node.add_p2p_connection(P2PTxInvStore())\n@@ -58,13 +58,13 @@ def run_test(self):\n         two_min = 2 * 60\n         node.setmocktime(now + twelve_hrs - two_min)\n         time.sleep(2) # ensure enough time has passed for rebroadcast attempt to occur\n-        assert_equal(txid in node.p2ps[1].get_invs(), False)\n+        assert_equal(int(txid, 16) in node.p2ps[1].get_invs(), False)\n \n         self.log.info(\"Bump time & check that transaction is rebroadcast\")\n         # Transaction should be rebroadcast approximately 24 hours in the future,\n         # but can range from 12-36. So bump 36 hours to be sure.\n         node.setmocktime(now + 36 * 60 * 60)\n-        wait_until(lambda: node.p2ps[1].tx_invs_received[txid] >= 1, lock=p2p_lock)\n+        node.p2p.wait_for_broadcast([txid])\n \n \n if __name__ == '__main__':"
      },
      {
        "sha": "1287092cacd350f87237e5efecf7969f1b72d886",
        "filename": "test/functional/wallet_zapwallettxes.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/wallet_zapwallettxes.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c/test/functional/wallet_zapwallettxes.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_zapwallettxes.py?ref=1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
        "patch": "@@ -18,9 +18,9 @@\n from test_framework.util import (\n     assert_equal,\n     assert_raises_rpc_error,\n-    wait_until,\n )\n \n+\n class ZapWalletTXesTest (BitcoinTestFramework):\n     def set_test_params(self):\n         self.setup_clean_chain = True\n@@ -59,7 +59,7 @@ def run_test(self):\n         # transaction is zapped from the wallet, but is re-added when the mempool is reloaded.\n         self.restart_node(0, [\"-persistmempool=1\", \"-zapwallettxes=2\"])\n \n-        wait_until(lambda: self.nodes[0].getmempoolinfo()['size'] == 1, timeout=3)\n+        self.wait_until(lambda: self.nodes[0].getmempoolinfo()['size'] == 1, timeout=3)\n         self.nodes[0].syncwithvalidationinterfacequeue()  # Flush mempool to wallet\n \n         assert_equal(self.nodes[0].gettransaction(txid1)['txid'], txid1)"
      }
    ]
  },
  {
    "sha": "d841301010914203fb5ef02627c76fad99cb11f1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkODQxMzAxMDEwOTE0MjAzZmI1ZWYwMjYyN2M3NmZhZDk5Y2IxMWYx",
    "commit": {
      "author": {
        "name": "Seleme Topuz",
        "email": "seleme94@hotmail.com",
        "date": "2020-08-25T19:34:33Z"
      },
      "committer": {
        "name": "Seleme Topuz",
        "email": "seleme94@hotmail.com",
        "date": "2020-08-26T16:01:59Z"
      },
      "message": "test: Add docstring to wait_until() in util.py to warn about its usage",
      "tree": {
        "sha": "92cfb4ee2d9fdc6b3fa70cd767734c3a2409856a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/92cfb4ee2d9fdc6b3fa70cd767734c3a2409856a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d841301010914203fb5ef02627c76fad99cb11f1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d841301010914203fb5ef02627c76fad99cb11f1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d841301010914203fb5ef02627c76fad99cb11f1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d841301010914203fb5ef02627c76fad99cb11f1/comments",
    "author": {
      "login": "slmtpz",
      "id": 17165664,
      "node_id": "MDQ6VXNlcjE3MTY1NjY0",
      "avatar_url": "https://avatars.githubusercontent.com/u/17165664?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/slmtpz",
      "html_url": "https://github.com/slmtpz",
      "followers_url": "https://api.github.com/users/slmtpz/followers",
      "following_url": "https://api.github.com/users/slmtpz/following{/other_user}",
      "gists_url": "https://api.github.com/users/slmtpz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/slmtpz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/slmtpz/subscriptions",
      "organizations_url": "https://api.github.com/users/slmtpz/orgs",
      "repos_url": "https://api.github.com/users/slmtpz/repos",
      "events_url": "https://api.github.com/users/slmtpz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/slmtpz/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "slmtpz",
      "id": 17165664,
      "node_id": "MDQ6VXNlcjE3MTY1NjY0",
      "avatar_url": "https://avatars.githubusercontent.com/u/17165664?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/slmtpz",
      "html_url": "https://github.com/slmtpz",
      "followers_url": "https://api.github.com/users/slmtpz/followers",
      "following_url": "https://api.github.com/users/slmtpz/following{/other_user}",
      "gists_url": "https://api.github.com/users/slmtpz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/slmtpz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/slmtpz/subscriptions",
      "organizations_url": "https://api.github.com/users/slmtpz/orgs",
      "repos_url": "https://api.github.com/users/slmtpz/repos",
      "events_url": "https://api.github.com/users/slmtpz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/slmtpz/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1343c86c7cc1fc896696b3ed87c12039e4ef3a0c"
      }
    ],
    "stats": {
      "total": 8,
      "additions": 8,
      "deletions": 0
    },
    "files": [
      {
        "sha": "cfc4ee65d47be65eae275e8efb35b4ed81b06b10",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d841301010914203fb5ef02627c76fad99cb11f1/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d841301010914203fb5ef02627c76fad99cb11f1/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=d841301010914203fb5ef02627c76fad99cb11f1",
        "patch": "@@ -226,6 +226,14 @@ def satoshi_round(amount):\n \n \n def wait_until(predicate, *, attempts=float('inf'), timeout=float('inf'), lock=None, timeout_factor=1.0):\n+    \"\"\"Sleep until the predicate resolves to be True.\n+\n+    Warning: Note that this method is not recommended to be used in tests as it is\n+    not aware of the context of the test framework. Using `wait_until()` counterpart\n+    from `BitcoinTestFramework` or `P2PInterface` class ensures an understandable\n+    amount of timeout and a common shared timeout_factor. Furthermore, `wait_until()`\n+    from `P2PInterface` class in `mininode.py` has a preset lock.\n+    \"\"\"\n     if attempts == float('inf') and timeout == float('inf'):\n         timeout = 60\n     timeout = timeout * timeout_factor"
      }
    ]
  }
]