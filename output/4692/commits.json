[
  {
    "sha": "c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjMWM2N2FjYzEzOWEzYWEwYjAzNzQ0MGFhMzI0NmVkYzBjZjFiYzAx",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2014-08-11T01:10:26Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2014-08-20T03:05:39Z"
      },
      "message": "Build libbitcoinscript.a, start refactoring script files.\n\nThe goal here is to move towards a C-callable libbitcoinscript.so\nthat any reimplementation can use for its script exectuion instead\nof reimplementing it from scratch, which has been shown to be\nincredibly error-prone.\n\nThis library will implement basic script parsing and execution, but\nit is not the goal to expose things like transaction signing or\nscript analysis.\n\nThe end-goal is to move the things which will be built as a part of\nthis library to the script/ subfolder, with the exposed API in\nscript/bitcoinscript.h. Things which are used only by Bitcoin Core\nwill be in scriptutils.{h,cpp}.",
      "tree": {
        "sha": "e8ca84a0c40c4c5d2a9dffe74e55ac359d2836b0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e8ca84a0c40c4c5d2a9dffe74e55ac359d2836b0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "335e3a5c95165ed778e84757657da65b1358bdff",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/335e3a5c95165ed778e84757657da65b1358bdff",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/335e3a5c95165ed778e84757657da65b1358bdff"
      }
    ],
    "stats": {
      "total": 770,
      "additions": 408,
      "deletions": 362
    },
    "files": [
      {
        "sha": "3953e2feef5db4b3ed7192c9635e243e551768ee",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 13,
        "deletions": 1,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "patch": "@@ -30,6 +30,7 @@ endif\n LIBBITCOIN_SERVER=libbitcoin_server.a\n LIBBITCOIN_WALLET=libbitcoin_wallet.a\n LIBBITCOIN_COMMON=libbitcoin_common.a\n+LIBBITCOIN_SCRIPT=libbitcoin_script.a\n LIBBITCOIN_CLI=libbitcoin_cli.a\n LIBBITCOIN_UTIL=libbitcoin_util.a\n LIBBITCOIN_CRYPTO=crypto/libbitcoin_crypto.a\n@@ -41,8 +42,10 @@ noinst_LIBRARIES = \\\n   libbitcoin_common.a \\\n   libbitcoin_cli.a \\\n   libbitcoin_util.a \\\n+  libbitcoin_script.a \\\n   univalue/libbitcoin_univalue.a \\\n   crypto/libbitcoin_crypto.a\n+\n if ENABLE_WALLET\n BITCOIN_INCLUDES += $(BDB_CPPFLAGS)\n noinst_LIBRARIES += libbitcoin_wallet.a\n@@ -203,9 +206,15 @@ libbitcoin_common_a_SOURCES = \\\n   keystore.cpp \\\n   netbase.cpp \\\n   protocol.cpp \\\n-  script.cpp \\\n+  scriptutils.cpp \\\n   $(BITCOIN_CORE_H)\n \n+# script: implements the scripting language\n+libbitcoin_script_a_CPPFLAGS = $(BITCOIN_INCLUDES)\n+libbitcoin_script_a_SOURCES = \\\n+  script/script.cpp\n+\n+\n # util: shared between all executables.\n # This library *must* be included to make sure that the glibc\n # backward-compatibility objects and their sanity checks are linked.\n@@ -240,6 +249,7 @@ nodist_libbitcoin_util_a_SOURCES = $(srcdir)/obj/build.h\n bitcoind_LDADD = \\\n   $(LIBBITCOIN_SERVER) \\\n   $(LIBBITCOIN_COMMON) \\\n+  $(LIBBITCOIN_SCRIPT) \\\n   $(LIBBITCOIN_UNIVALUE) \\\n   $(LIBBITCOIN_UTIL) \\\n   $(LIBBITCOIN_CRYPTO) \\\n@@ -268,6 +278,7 @@ bitcoind_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS)\n bitcoin_cli_LDADD = \\\n   $(LIBBITCOIN_CLI) \\\n   $(LIBBITCOIN_COMMON) \\\n+  $(LIBBITCOIN_SCRIPT) \\\n   $(LIBBITCOIN_UTIL) \\\n   $(LIBBITCOIN_CRYPTO) \\\n   $(BOOST_LIBS) \\\n@@ -287,6 +298,7 @@ bitcoin_cli_CPPFLAGS = $(BITCOIN_INCLUDES)\n bitcoin_tx_LDADD = \\\n   $(LIBBITCOIN_UNIVALUE) \\\n   $(LIBBITCOIN_COMMON) \\\n+  $(LIBBITCOIN_SCRIPT) \\\n   $(LIBBITCOIN_UTIL) \\\n   $(LIBBITCOIN_CRYPTO)\n "
      },
      {
        "sha": "e928422d19e51b57c1ae2bca2fcbc61e93927f3c",
        "filename": "src/Makefile.qt.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/Makefile.qt.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/Makefile.qt.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qt.include?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "patch": "@@ -357,7 +357,7 @@ qt_bitcoin_qt_LDADD = qt/libbitcoinqt.a $(LIBBITCOIN_SERVER)\n if ENABLE_WALLET\n qt_bitcoin_qt_LDADD += $(LIBBITCOIN_WALLET)\n endif\n-qt_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CRYPTO) $(LIBBITCOIN_UNIVALUE) $(LIBLEVELDB) $(LIBMEMENV) \\\n+qt_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_SCRIPT) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CRYPTO) $(LIBBITCOIN_UNIVALUE) $(LIBLEVELDB) $(LIBMEMENV) \\\n   $(BOOST_LIBS) $(QT_LIBS) $(QT_DBUS_LIBS) $(QR_LIBS) $(PROTOBUF_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS)\n if USE_LIBSECP256K1\n   qt_bitcoin_qt_LDADD += secp256k1/libsecp256k1.la"
      },
      {
        "sha": "47e931ab7c576d59de6b8aec998dc4f8773d9145",
        "filename": "src/Makefile.qttest.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/Makefile.qttest.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/Makefile.qttest.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qttest.include?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "patch": "@@ -30,7 +30,7 @@ qt_test_test_bitcoin_qt_LDADD = $(LIBBITCOINQT) $(LIBBITCOIN_SERVER)\n if ENABLE_WALLET\n qt_test_test_bitcoin_qt_LDADD += $(LIBBITCOIN_WALLET)\n endif\n-qt_test_test_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CRYPTO) $(LIBBITCOIN_UNIVALUE) $(LIBLEVELDB) \\\n+qt_test_test_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_SCRIPT) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CRYPTO) $(LIBBITCOIN_UNIVALUE) $(LIBLEVELDB) \\\n   $(LIBMEMENV) $(BOOST_LIBS) $(QT_DBUS_LIBS) $(QT_TEST_LIBS) $(QT_LIBS) \\\n   $(QR_LIBS) $(PROTOBUF_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS)\n if USE_LIBSECP256K1"
      },
      {
        "sha": "c1c1d40a3b0f1a16a82bfdea52926ca4ddea4e7b",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "patch": "@@ -71,7 +71,7 @@ endif\n \n test_test_bitcoin_SOURCES = $(BITCOIN_TESTS) $(JSON_TEST_FILES) $(RAW_TEST_FILES)\n test_test_bitcoin_CPPFLAGS = $(BITCOIN_INCLUDES) -I$(builddir)/test/ $(TESTDEFS)\n-test_test_bitcoin_LDADD = $(LIBBITCOIN_SERVER) $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CRYPTO) $(LIBBITCOIN_UNIVALUE) $(LIBLEVELDB) $(LIBMEMENV) \\\n+test_test_bitcoin_LDADD = $(LIBBITCOIN_SERVER) $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_SCRIPT) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CRYPTO) $(LIBBITCOIN_UNIVALUE) $(LIBLEVELDB) $(LIBMEMENV) \\\n   $(BOOST_LIBS) $(BOOST_UNIT_TEST_FRAMEWORK_LIB)\n if ENABLE_WALLET\n test_test_bitcoin_LDADD += $(LIBBITCOIN_WALLET)"
      },
      {
        "sha": "a4dc7267670b0a0b43798ed3f5827fc6fb54a546",
        "filename": "src/base58.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/base58.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/base58.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.h?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "patch": "@@ -16,7 +16,7 @@\n \n #include \"chainparams.h\"\n #include \"key.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n \n #include <string>\n #include <vector>"
      },
      {
        "sha": "28a39deaa889db8ab0c4c112d5efcfa9cf80ce35",
        "filename": "src/bloom.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/bloom.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/bloom.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.cpp?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "patch": "@@ -5,7 +5,7 @@\n #include \"bloom.h\"\n \n #include \"core.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n \n #include <math.h>\n #include <stdlib.h>"
      },
      {
        "sha": "48de21b102606fecc891c8fc2969c35c751abdf1",
        "filename": "src/core.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/core.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/core.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core.h?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "patch": "@@ -6,7 +6,7 @@\n #ifndef BITCOIN_CORE_H\n #define BITCOIN_CORE_H\n \n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"serialize.h\"\n #include \"uint256.h\"\n "
      },
      {
        "sha": "d2f2d98f0c605f327c7661cf50537169ce83b679",
        "filename": "src/core_read.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/core_read.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/core_read.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_read.cpp?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "patch": "@@ -5,7 +5,7 @@\n #include \"core_io.h\"\n #include \"core.h\"\n #include \"serialize.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"util.h\"\n \n #include <boost/assign/list_of.hpp>"
      },
      {
        "sha": "7f2a1b95e193389caf5342ba0117f864663e240b",
        "filename": "src/core_write.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/core_write.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/core_write.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_write.cpp?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "patch": "@@ -4,7 +4,7 @@\n \n #include \"core_io.h\"\n #include \"univalue/univalue.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"core.h\"\n #include \"serialize.h\"\n #include \"util.h\""
      },
      {
        "sha": "77aa942afe096c12bad4701a4c540ce1d2feebf9",
        "filename": "src/crypter.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/crypter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/crypter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypter.cpp?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "patch": "@@ -4,7 +4,7 @@\n \n #include \"crypter.h\"\n \n-#include \"script.h\"\n+#include \"scriptutils.h\"\n \n #include <string>\n #include <vector>"
      },
      {
        "sha": "a18d2070afd218d870fe48425927db4879064949",
        "filename": "src/keystore.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/keystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/keystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.cpp?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "patch": "@@ -7,7 +7,7 @@\n \n #include \"crypter.h\"\n #include \"key.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n \n #include <boost/foreach.hpp>\n "
      },
      {
        "sha": "081829fe0f98861a6abf103dc5c841dc6b45726b",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "patch": "@@ -14,7 +14,7 @@\n #include \"coins.h\"\n #include \"core.h\"\n #include \"net.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"sync.h\"\n #include \"txmempool.h\"\n #include \"uint256.h\""
      },
      {
        "sha": "debcead97e0a2ce9559e99f4369cbc6f563c2b03",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "patch": "@@ -11,7 +11,7 @@\n #include \"db.h\"\n #include \"main.h\"\n #include \"paymentserver.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"transactionrecord.h\"\n #include \"timedata.h\"\n #include \"ui_interface.h\""
      },
      {
        "sha": "6b154c7b471f1a079bd7886e5d22302fd49c6d3f",
        "filename": "src/script/bitcoinscript.h",
        "status": "added",
        "additions": 30,
        "deletions": 0,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/script/bitcoinscript.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/script/bitcoinscript.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/bitcoinscript.h?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "patch": "@@ -0,0 +1,30 @@\n+#ifndef H_BITCOIN_BITCOINSCRIPT\n+#define H_BITCOIN_BITCOINSCRIPT\n+\n+/** Script verification flags */\n+enum\n+{\n+    SCRIPT_VERIFY_NONE      = 0,\n+    SCRIPT_VERIFY_P2SH      = (1U << 0), // evaluate P2SH (BIP16) subscripts\n+    SCRIPT_VERIFY_STRICTENC = (1U << 1), // enforce strict conformance to DER and SEC2 for signatures and pubkeys\n+    SCRIPT_VERIFY_LOW_S     = (1U << 2), // enforce low S values (<n/2) in signatures (depends on STRICTENC)\n+    SCRIPT_VERIFY_NULLDUMMY = (1U << 4), // verify dummy stack item consumed by CHECKMULTISIG is of zero-length\n+};\n+\n+// Mandatory script verification flags that all new blocks must comply with for\n+// them to be valid. (but old blocks may not comply with) Currently just P2SH,\n+// but in the future other flags may be added, such as a soft-fork to enforce\n+// strict DER encoding.\n+//\n+// Failing one of these tests may trigger a DoS ban - see CheckInputs() for\n+// details.\n+static const unsigned int MANDATORY_SCRIPT_VERIFY_FLAGS = SCRIPT_VERIFY_P2SH;\n+\n+// Standard script verification flags that standard transactions will comply\n+// with. However scripts violating these flags may still be present in valid\n+// blocks and we must accept those blocks.\n+static const unsigned int STANDARD_SCRIPT_VERIFY_FLAGS = MANDATORY_SCRIPT_VERIFY_FLAGS |\n+                                                         SCRIPT_VERIFY_STRICTENC |\n+                                                         SCRIPT_VERIFY_NULLDUMMY;\n+\n+#endif"
      },
      {
        "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
        "filename": "src/script/script.cpp",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/script/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/script/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.cpp?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01"
      },
      {
        "sha": "647eab5df3256209b56f0eaf38644aa2db7bcf81",
        "filename": "src/script/script.h",
        "status": "added",
        "additions": 338,
        "deletions": 0,
        "changes": 338,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "patch": "@@ -0,0 +1,338 @@\n+#ifndef H_BITCOIN_SCRIPT\n+#define H_BITCOIN_SCRIPT\n+\n+#include <vector>\n+\n+/** Script verification flags (partially duplicated in bitcoinscript.h) */\n+enum\n+{\n+    SCRIPT_VERIFY_NONE      = 0,\n+    SCRIPT_VERIFY_P2SH      = (1U << 0), // evaluate P2SH (BIP16) subscripts\n+    SCRIPT_VERIFY_STRICTENC = (1U << 1), // enforce strict conformance to DER and SEC2 for signatures and pubkeys\n+    SCRIPT_VERIFY_LOW_S     = (1U << 2), // enforce low S values (<n/2) in signatures (depends on STRICTENC)\n+    SCRIPT_VERIFY_NOCACHE   = (1U << 3), // do not store results in signature cache (but do query it)\n+    SCRIPT_VERIFY_NULLDUMMY = (1U << 4), // verify dummy stack item consumed by CHECKMULTISIG is of zero-length\n+\n+    // Mandatory script verification flags that all new blocks must comply with for\n+    // them to be valid. (but old blocks may not comply with) Currently just P2SH,\n+    // but in the future other flags may be added, such as a soft-fork to enforce\n+    // strict DER encoding.\n+    //\n+    // Failing one of these tests may trigger a DoS ban - see CheckInputs() for\n+    // details.\n+    MANDATORY_SCRIPT_VERIFY_FLAGS = SCRIPT_VERIFY_P2SH,\n+\n+    // Standard script verification flags that standard transactions will comply\n+    // with. However scripts violating these flags may still be present in valid\n+    // blocks and we must accept those blocks.\n+    STANDARD_SCRIPT_VERIFY_FLAGS = MANDATORY_SCRIPT_VERIFY_FLAGS |\n+                                   SCRIPT_VERIFY_STRICTENC |\n+                                   SCRIPT_VERIFY_NULLDUMMY,\n+};\n+\n+class scriptnum_error : public std::runtime_error\n+{\n+public:\n+    explicit scriptnum_error(const std::string& str) : std::runtime_error(str) {}\n+};\n+\n+class CScriptNum\n+{\n+// Numeric opcodes (OP_1ADD, etc) are restricted to operating on 4-byte integers.\n+// The semantics are subtle, though: operands must be in the range [-2^31 +1...2^31 -1],\n+// but results may overflow (and are valid as long as they are not used in a subsequent\n+// numeric operation). CScriptNum enforces those semantics by storing results as\n+// an int64 and allowing out-of-range values to be returned as a vector of bytes but\n+// throwing an exception if arithmetic is done or the result is interpreted as an integer.\n+public:\n+\n+    explicit CScriptNum(const int64_t& n)\n+    {\n+        m_value = n;\n+    }\n+\n+    explicit CScriptNum(const std::vector<unsigned char>& vch)\n+    {\n+        if (vch.size() > nMaxNumSize)\n+            throw scriptnum_error(\"CScriptNum(const std::vector<unsigned char>&) : overflow\");\n+        m_value = set_vch(vch);\n+    }\n+\n+    inline bool operator==(const int64_t& rhs) const    { return m_value == rhs; }\n+    inline bool operator!=(const int64_t& rhs) const    { return m_value != rhs; }\n+    inline bool operator<=(const int64_t& rhs) const    { return m_value <= rhs; }\n+    inline bool operator< (const int64_t& rhs) const    { return m_value <  rhs; }\n+    inline bool operator>=(const int64_t& rhs) const    { return m_value >= rhs; }\n+    inline bool operator> (const int64_t& rhs) const    { return m_value >  rhs; }\n+\n+    inline bool operator==(const CScriptNum& rhs) const { return operator==(rhs.m_value); }\n+    inline bool operator!=(const CScriptNum& rhs) const { return operator!=(rhs.m_value); }\n+    inline bool operator<=(const CScriptNum& rhs) const { return operator<=(rhs.m_value); }\n+    inline bool operator< (const CScriptNum& rhs) const { return operator< (rhs.m_value); }\n+    inline bool operator>=(const CScriptNum& rhs) const { return operator>=(rhs.m_value); }\n+    inline bool operator> (const CScriptNum& rhs) const { return operator> (rhs.m_value); }\n+\n+    inline CScriptNum operator+(   const int64_t& rhs)    const { return CScriptNum(m_value + rhs);}\n+    inline CScriptNum operator-(   const int64_t& rhs)    const { return CScriptNum(m_value - rhs);}\n+    inline CScriptNum operator+(   const CScriptNum& rhs) const { return operator+(rhs.m_value);   }\n+    inline CScriptNum operator-(   const CScriptNum& rhs) const { return operator-(rhs.m_value);   }\n+\n+    inline CScriptNum& operator+=( const CScriptNum& rhs)       { return operator+=(rhs.m_value);  }\n+    inline CScriptNum& operator-=( const CScriptNum& rhs)       { return operator-=(rhs.m_value);  }\n+\n+    inline CScriptNum operator-()                         const\n+    {\n+        assert(m_value != std::numeric_limits<int64_t>::min());\n+        return CScriptNum(-m_value);\n+    }\n+\n+    inline CScriptNum& operator=( const int64_t& rhs)\n+    {\n+        m_value = rhs;\n+        return *this;\n+    }\n+\n+    inline CScriptNum& operator+=( const int64_t& rhs)\n+    {\n+        assert(rhs == 0 || (rhs > 0 && m_value <= std::numeric_limits<int64_t>::max() - rhs) ||\n+                           (rhs < 0 && m_value >= std::numeric_limits<int64_t>::min() - rhs));\n+        m_value += rhs;\n+        return *this;\n+    }\n+\n+    inline CScriptNum& operator-=( const int64_t& rhs)\n+    {\n+        assert(rhs == 0 || (rhs > 0 && m_value >= std::numeric_limits<int64_t>::min() + rhs) ||\n+                           (rhs < 0 && m_value <= std::numeric_limits<int64_t>::max() + rhs));\n+        m_value -= rhs;\n+        return *this;\n+    }\n+\n+    int getint() const\n+    {\n+        if (m_value > std::numeric_limits<int>::max())\n+            return std::numeric_limits<int>::max();\n+        else if (m_value < std::numeric_limits<int>::min())\n+            return std::numeric_limits<int>::min();\n+        return m_value;\n+    }\n+\n+    std::vector<unsigned char> getvch() const\n+    {\n+        return serialize(m_value);\n+    }\n+\n+    static std::vector<unsigned char> serialize(const int64_t& value)\n+    {\n+        if(value == 0)\n+            return std::vector<unsigned char>();\n+\n+        std::vector<unsigned char> result;\n+        const bool neg = value < 0;\n+        uint64_t absvalue = neg ? -value : value;\n+\n+        while(absvalue)\n+        {\n+            result.push_back(absvalue & 0xff);\n+            absvalue >>= 8;\n+        }\n+\n+\n+//    - If the most significant byte is >= 0x80 and the value is positive, push a\n+//    new zero-byte to make the significant byte < 0x80 again.\n+\n+//    - If the most significant byte is >= 0x80 and the value is negative, push a\n+//    new 0x80 byte that will be popped off when converting to an integral.\n+\n+//    - If the most significant byte is < 0x80 and the value is negative, add\n+//    0x80 to it, since it will be subtracted and interpreted as a negative when\n+//    converting to an integral.\n+\n+        if (result.back() & 0x80)\n+            result.push_back(neg ? 0x80 : 0);\n+        else if (neg)\n+            result.back() |= 0x80;\n+\n+        return result;\n+    }\n+\n+    static const size_t nMaxNumSize = 4;\n+\n+private:\n+    static int64_t set_vch(const std::vector<unsigned char>& vch)\n+    {\n+      if (vch.empty())\n+          return 0;\n+\n+      int64_t result = 0;\n+      for (size_t i = 0; i != vch.size(); ++i)\n+          result |= static_cast<int64_t>(vch[i]) << 8*i;\n+\n+      // If the input vector's most significant byte is 0x80, remove it from\n+      // the result's msb and return a negative.\n+      if (vch.back() & 0x80)\n+          return -(result & ~(0x80ULL << (8 * (vch.size() - 1))));\n+\n+      return result;\n+    }\n+\n+    int64_t m_value;\n+};\n+\n+/** Script opcodes */\n+enum opcodetype\n+{\n+    // push value\n+    OP_0 = 0x00,\n+    OP_FALSE = OP_0,\n+    OP_PUSHDATA1 = 0x4c,\n+    OP_PUSHDATA2 = 0x4d,\n+    OP_PUSHDATA4 = 0x4e,\n+    OP_1NEGATE = 0x4f,\n+    OP_RESERVED = 0x50,\n+    OP_1 = 0x51,\n+    OP_TRUE=OP_1,\n+    OP_2 = 0x52,\n+    OP_3 = 0x53,\n+    OP_4 = 0x54,\n+    OP_5 = 0x55,\n+    OP_6 = 0x56,\n+    OP_7 = 0x57,\n+    OP_8 = 0x58,\n+    OP_9 = 0x59,\n+    OP_10 = 0x5a,\n+    OP_11 = 0x5b,\n+    OP_12 = 0x5c,\n+    OP_13 = 0x5d,\n+    OP_14 = 0x5e,\n+    OP_15 = 0x5f,\n+    OP_16 = 0x60,\n+\n+    // control\n+    OP_NOP = 0x61,\n+    OP_VER = 0x62,\n+    OP_IF = 0x63,\n+    OP_NOTIF = 0x64,\n+    OP_VERIF = 0x65,\n+    OP_VERNOTIF = 0x66,\n+    OP_ELSE = 0x67,\n+    OP_ENDIF = 0x68,\n+    OP_VERIFY = 0x69,\n+    OP_RETURN = 0x6a,\n+\n+    // stack ops\n+    OP_TOALTSTACK = 0x6b,\n+    OP_FROMALTSTACK = 0x6c,\n+    OP_2DROP = 0x6d,\n+    OP_2DUP = 0x6e,\n+    OP_3DUP = 0x6f,\n+    OP_2OVER = 0x70,\n+    OP_2ROT = 0x71,\n+    OP_2SWAP = 0x72,\n+    OP_IFDUP = 0x73,\n+    OP_DEPTH = 0x74,\n+    OP_DROP = 0x75,\n+    OP_DUP = 0x76,\n+    OP_NIP = 0x77,\n+    OP_OVER = 0x78,\n+    OP_PICK = 0x79,\n+    OP_ROLL = 0x7a,\n+    OP_ROT = 0x7b,\n+    OP_SWAP = 0x7c,\n+    OP_TUCK = 0x7d,\n+\n+    // splice ops\n+    OP_CAT = 0x7e,\n+    OP_SUBSTR = 0x7f,\n+    OP_LEFT = 0x80,\n+    OP_RIGHT = 0x81,\n+    OP_SIZE = 0x82,\n+\n+    // bit logic\n+    OP_INVERT = 0x83,\n+    OP_AND = 0x84,\n+    OP_OR = 0x85,\n+    OP_XOR = 0x86,\n+    OP_EQUAL = 0x87,\n+    OP_EQUALVERIFY = 0x88,\n+    OP_RESERVED1 = 0x89,\n+    OP_RESERVED2 = 0x8a,\n+\n+    // numeric\n+    OP_1ADD = 0x8b,\n+    OP_1SUB = 0x8c,\n+    OP_2MUL = 0x8d,\n+    OP_2DIV = 0x8e,\n+    OP_NEGATE = 0x8f,\n+    OP_ABS = 0x90,\n+    OP_NOT = 0x91,\n+    OP_0NOTEQUAL = 0x92,\n+\n+    OP_ADD = 0x93,\n+    OP_SUB = 0x94,\n+    OP_MUL = 0x95,\n+    OP_DIV = 0x96,\n+    OP_MOD = 0x97,\n+    OP_LSHIFT = 0x98,\n+    OP_RSHIFT = 0x99,\n+\n+    OP_BOOLAND = 0x9a,\n+    OP_BOOLOR = 0x9b,\n+    OP_NUMEQUAL = 0x9c,\n+    OP_NUMEQUALVERIFY = 0x9d,\n+    OP_NUMNOTEQUAL = 0x9e,\n+    OP_LESSTHAN = 0x9f,\n+    OP_GREATERTHAN = 0xa0,\n+    OP_LESSTHANOREQUAL = 0xa1,\n+    OP_GREATERTHANOREQUAL = 0xa2,\n+    OP_MIN = 0xa3,\n+    OP_MAX = 0xa4,\n+\n+    OP_WITHIN = 0xa5,\n+\n+    // crypto\n+    OP_RIPEMD160 = 0xa6,\n+    OP_SHA1 = 0xa7,\n+    OP_SHA256 = 0xa8,\n+    OP_HASH160 = 0xa9,\n+    OP_HASH256 = 0xaa,\n+    OP_CODESEPARATOR = 0xab,\n+    OP_CHECKSIG = 0xac,\n+    OP_CHECKSIGVERIFY = 0xad,\n+    OP_CHECKMULTISIG = 0xae,\n+    OP_CHECKMULTISIGVERIFY = 0xaf,\n+\n+    // expansion\n+    OP_NOP1 = 0xb0,\n+    OP_NOP2 = 0xb1,\n+    OP_NOP3 = 0xb2,\n+    OP_NOP4 = 0xb3,\n+    OP_NOP5 = 0xb4,\n+    OP_NOP6 = 0xb5,\n+    OP_NOP7 = 0xb6,\n+    OP_NOP8 = 0xb7,\n+    OP_NOP9 = 0xb8,\n+    OP_NOP10 = 0xb9,\n+\n+\n+\n+    // template matching params\n+    OP_SMALLDATA = 0xf9,\n+    OP_SMALLINTEGER = 0xfa,\n+    OP_PUBKEYS = 0xfb,\n+    OP_PUBKEYHASH = 0xfd,\n+    OP_PUBKEY = 0xfe,\n+\n+    OP_INVALIDOPCODE = 0xff,\n+};\n+\n+/** Signature hash types/flags */\n+enum\n+{\n+    SIGHASH_ALL = 1,\n+    SIGHASH_NONE = 2,\n+    SIGHASH_SINGLE = 3,\n+    SIGHASH_ANYONECANPAY = 0x80,\n+};\n+\n+#endif"
      },
      {
        "sha": "9fe29566e98f6bcc353f7dabe1128cc8b4b7ee95",
        "filename": "src/scriptutils.cpp",
        "status": "renamed",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/scriptutils.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/scriptutils.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scriptutils.cpp?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "patch": "@@ -3,7 +3,7 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include \"script.h\"\n+#include \"scriptutils.h\"\n \n #include \"crypto/ripemd160.h\"\n #include \"crypto/sha1.h\"",
        "previous_filename": "src/script.cpp"
      },
      {
        "sha": "695fc25f0b94c7c2f1ab284370a6c2cb5ced1d10",
        "filename": "src/scriptutils.h",
        "status": "renamed",
        "additions": 3,
        "deletions": 333,
        "changes": 336,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/scriptutils.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/scriptutils.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scriptutils.h?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "patch": "@@ -3,11 +3,12 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#ifndef H_BITCOIN_SCRIPT\n-#define H_BITCOIN_SCRIPT\n+#ifndef H_BITCOIN_SCRIPTUTILS\n+#define H_BITCOIN_SCRIPTUTILS\n \n #include \"key.h\"\n #include \"util.h\"\n+#include \"script/script.h\"\n \n #include <stdexcept>\n #include <stdint.h>\n@@ -25,175 +26,6 @@ struct CMutableTransaction;\n static const unsigned int MAX_SCRIPT_ELEMENT_SIZE = 520; // bytes\n static const unsigned int MAX_OP_RETURN_RELAY = 40;      // bytes\n \n-class scriptnum_error : public std::runtime_error\n-{\n-public:\n-    explicit scriptnum_error(const std::string& str) : std::runtime_error(str) {}\n-};\n-\n-class CScriptNum\n-{\n-// Numeric opcodes (OP_1ADD, etc) are restricted to operating on 4-byte integers.\n-// The semantics are subtle, though: operands must be in the range [-2^31 +1...2^31 -1],\n-// but results may overflow (and are valid as long as they are not used in a subsequent\n-// numeric operation). CScriptNum enforces those semantics by storing results as\n-// an int64 and allowing out-of-range values to be returned as a vector of bytes but\n-// throwing an exception if arithmetic is done or the result is interpreted as an integer.\n-public:\n-\n-    explicit CScriptNum(const int64_t& n)\n-    {\n-        m_value = n;\n-    }\n-\n-    explicit CScriptNum(const std::vector<unsigned char>& vch)\n-    {\n-        if (vch.size() > nMaxNumSize)\n-            throw scriptnum_error(\"CScriptNum(const std::vector<unsigned char>&) : overflow\");\n-        m_value = set_vch(vch);\n-    }\n-\n-    inline bool operator==(const int64_t& rhs) const    { return m_value == rhs; }\n-    inline bool operator!=(const int64_t& rhs) const    { return m_value != rhs; }\n-    inline bool operator<=(const int64_t& rhs) const    { return m_value <= rhs; }\n-    inline bool operator< (const int64_t& rhs) const    { return m_value <  rhs; }\n-    inline bool operator>=(const int64_t& rhs) const    { return m_value >= rhs; }\n-    inline bool operator> (const int64_t& rhs) const    { return m_value >  rhs; }\n-\n-    inline bool operator==(const CScriptNum& rhs) const { return operator==(rhs.m_value); }\n-    inline bool operator!=(const CScriptNum& rhs) const { return operator!=(rhs.m_value); }\n-    inline bool operator<=(const CScriptNum& rhs) const { return operator<=(rhs.m_value); }\n-    inline bool operator< (const CScriptNum& rhs) const { return operator< (rhs.m_value); }\n-    inline bool operator>=(const CScriptNum& rhs) const { return operator>=(rhs.m_value); }\n-    inline bool operator> (const CScriptNum& rhs) const { return operator> (rhs.m_value); }\n-\n-    inline CScriptNum operator+(   const int64_t& rhs)    const { return CScriptNum(m_value + rhs);}\n-    inline CScriptNum operator-(   const int64_t& rhs)    const { return CScriptNum(m_value - rhs);}\n-    inline CScriptNum operator+(   const CScriptNum& rhs) const { return operator+(rhs.m_value);   }\n-    inline CScriptNum operator-(   const CScriptNum& rhs) const { return operator-(rhs.m_value);   }\n-\n-    inline CScriptNum& operator+=( const CScriptNum& rhs)       { return operator+=(rhs.m_value);  }\n-    inline CScriptNum& operator-=( const CScriptNum& rhs)       { return operator-=(rhs.m_value);  }\n-\n-    inline CScriptNum operator-()                         const\n-    {\n-        assert(m_value != std::numeric_limits<int64_t>::min());\n-        return CScriptNum(-m_value);\n-    }\n-\n-    inline CScriptNum& operator=( const int64_t& rhs)\n-    {\n-        m_value = rhs;\n-        return *this;\n-    }\n-\n-    inline CScriptNum& operator+=( const int64_t& rhs)\n-    {\n-        assert(rhs == 0 || (rhs > 0 && m_value <= std::numeric_limits<int64_t>::max() - rhs) ||\n-                           (rhs < 0 && m_value >= std::numeric_limits<int64_t>::min() - rhs));\n-        m_value += rhs;\n-        return *this;\n-    }\n-\n-    inline CScriptNum& operator-=( const int64_t& rhs)\n-    {\n-        assert(rhs == 0 || (rhs > 0 && m_value >= std::numeric_limits<int64_t>::min() + rhs) ||\n-                           (rhs < 0 && m_value <= std::numeric_limits<int64_t>::max() + rhs));\n-        m_value -= rhs;\n-        return *this;\n-    }\n-\n-    int getint() const\n-    {\n-        if (m_value > std::numeric_limits<int>::max())\n-            return std::numeric_limits<int>::max();\n-        else if (m_value < std::numeric_limits<int>::min())\n-            return std::numeric_limits<int>::min();\n-        return m_value;\n-    }\n-\n-    std::vector<unsigned char> getvch() const\n-    {\n-        return serialize(m_value);\n-    }\n-\n-    static std::vector<unsigned char> serialize(const int64_t& value)\n-    {\n-        if(value == 0)\n-            return std::vector<unsigned char>();\n-\n-        std::vector<unsigned char> result;\n-        const bool neg = value < 0;\n-        uint64_t absvalue = neg ? -value : value;\n-\n-        while(absvalue)\n-        {\n-            result.push_back(absvalue & 0xff);\n-            absvalue >>= 8;\n-        }\n-\n-\n-//    - If the most significant byte is >= 0x80 and the value is positive, push a\n-//    new zero-byte to make the significant byte < 0x80 again.\n-\n-//    - If the most significant byte is >= 0x80 and the value is negative, push a\n-//    new 0x80 byte that will be popped off when converting to an integral.\n-\n-//    - If the most significant byte is < 0x80 and the value is negative, add\n-//    0x80 to it, since it will be subtracted and interpreted as a negative when\n-//    converting to an integral.\n-\n-        if (result.back() & 0x80)\n-            result.push_back(neg ? 0x80 : 0);\n-        else if (neg)\n-            result.back() |= 0x80;\n-\n-        return result;\n-    }\n-\n-    static const size_t nMaxNumSize = 4;\n-\n-private:\n-    static int64_t set_vch(const std::vector<unsigned char>& vch)\n-    {\n-      if (vch.empty())\n-          return 0;\n-\n-      int64_t result = 0;\n-      for (size_t i = 0; i != vch.size(); ++i)\n-          result |= static_cast<int64_t>(vch[i]) << 8*i;\n-\n-      // If the input vector's most significant byte is 0x80, remove it from\n-      // the result's msb and return a negative.\n-      if (vch.back() & 0x80)\n-          return -(result & ~(0x80ULL << (8 * (vch.size() - 1))));\n-\n-      return result;\n-    }\n-\n-    int64_t m_value;\n-};\n-\n-/** Signature hash types/flags */\n-enum\n-{\n-    SIGHASH_ALL = 1,\n-    SIGHASH_NONE = 2,\n-    SIGHASH_SINGLE = 3,\n-    SIGHASH_ANYONECANPAY = 0x80,\n-};\n-\n-/** Script verification flags */\n-enum\n-{\n-    SCRIPT_VERIFY_NONE      = 0,\n-    SCRIPT_VERIFY_P2SH      = (1U << 0), // evaluate P2SH (BIP16) subscripts\n-    SCRIPT_VERIFY_STRICTENC = (1U << 1), // enforce strict conformance to DER and SEC2 for signatures and pubkeys\n-    SCRIPT_VERIFY_LOW_S     = (1U << 2), // enforce low S values (<n/2) in signatures (depends on STRICTENC)\n-    SCRIPT_VERIFY_NOCACHE   = (1U << 3), // do not store results in signature cache (but do query it)\n-    SCRIPT_VERIFY_NULLDUMMY = (1U << 4), // verify dummy stack item consumed by CHECKMULTISIG is of zero-length\n-};\n-\n /** IsMine() return codes */\n enum isminetype\n {\n@@ -205,22 +37,6 @@ enum isminetype\n /** used for bitflags of isminetype */\n typedef uint8_t isminefilter;\n \n-// Mandatory script verification flags that all new blocks must comply with for\n-// them to be valid. (but old blocks may not comply with) Currently just P2SH,\n-// but in the future other flags may be added, such as a soft-fork to enforce\n-// strict DER encoding.\n-//\n-// Failing one of these tests may trigger a DoS ban - see CheckInputs() for\n-// details.\n-static const unsigned int MANDATORY_SCRIPT_VERIFY_FLAGS = SCRIPT_VERIFY_P2SH;\n-\n-// Standard script verification flags that standard transactions will comply\n-// with. However scripts violating these flags may still be present in valid\n-// blocks and we must accept those blocks.\n-static const unsigned int STANDARD_SCRIPT_VERIFY_FLAGS = MANDATORY_SCRIPT_VERIFY_FLAGS |\n-                                                         SCRIPT_VERIFY_STRICTENC |\n-                                                         SCRIPT_VERIFY_NULLDUMMY;\n-\n // For convenience, standard but not mandatory verify flags.\n static const unsigned int STANDARD_NOT_MANDATORY_VERIFY_FLAGS = STANDARD_SCRIPT_VERIFY_FLAGS & ~MANDATORY_SCRIPT_VERIFY_FLAGS;\n \n@@ -251,152 +67,6 @@ typedef boost::variant<CNoDestination, CKeyID, CScriptID> CTxDestination;\n \n const char* GetTxnOutputType(txnouttype t);\n \n-/** Script opcodes */\n-enum opcodetype\n-{\n-    // push value\n-    OP_0 = 0x00,\n-    OP_FALSE = OP_0,\n-    OP_PUSHDATA1 = 0x4c,\n-    OP_PUSHDATA2 = 0x4d,\n-    OP_PUSHDATA4 = 0x4e,\n-    OP_1NEGATE = 0x4f,\n-    OP_RESERVED = 0x50,\n-    OP_1 = 0x51,\n-    OP_TRUE=OP_1,\n-    OP_2 = 0x52,\n-    OP_3 = 0x53,\n-    OP_4 = 0x54,\n-    OP_5 = 0x55,\n-    OP_6 = 0x56,\n-    OP_7 = 0x57,\n-    OP_8 = 0x58,\n-    OP_9 = 0x59,\n-    OP_10 = 0x5a,\n-    OP_11 = 0x5b,\n-    OP_12 = 0x5c,\n-    OP_13 = 0x5d,\n-    OP_14 = 0x5e,\n-    OP_15 = 0x5f,\n-    OP_16 = 0x60,\n-\n-    // control\n-    OP_NOP = 0x61,\n-    OP_VER = 0x62,\n-    OP_IF = 0x63,\n-    OP_NOTIF = 0x64,\n-    OP_VERIF = 0x65,\n-    OP_VERNOTIF = 0x66,\n-    OP_ELSE = 0x67,\n-    OP_ENDIF = 0x68,\n-    OP_VERIFY = 0x69,\n-    OP_RETURN = 0x6a,\n-\n-    // stack ops\n-    OP_TOALTSTACK = 0x6b,\n-    OP_FROMALTSTACK = 0x6c,\n-    OP_2DROP = 0x6d,\n-    OP_2DUP = 0x6e,\n-    OP_3DUP = 0x6f,\n-    OP_2OVER = 0x70,\n-    OP_2ROT = 0x71,\n-    OP_2SWAP = 0x72,\n-    OP_IFDUP = 0x73,\n-    OP_DEPTH = 0x74,\n-    OP_DROP = 0x75,\n-    OP_DUP = 0x76,\n-    OP_NIP = 0x77,\n-    OP_OVER = 0x78,\n-    OP_PICK = 0x79,\n-    OP_ROLL = 0x7a,\n-    OP_ROT = 0x7b,\n-    OP_SWAP = 0x7c,\n-    OP_TUCK = 0x7d,\n-\n-    // splice ops\n-    OP_CAT = 0x7e,\n-    OP_SUBSTR = 0x7f,\n-    OP_LEFT = 0x80,\n-    OP_RIGHT = 0x81,\n-    OP_SIZE = 0x82,\n-\n-    // bit logic\n-    OP_INVERT = 0x83,\n-    OP_AND = 0x84,\n-    OP_OR = 0x85,\n-    OP_XOR = 0x86,\n-    OP_EQUAL = 0x87,\n-    OP_EQUALVERIFY = 0x88,\n-    OP_RESERVED1 = 0x89,\n-    OP_RESERVED2 = 0x8a,\n-\n-    // numeric\n-    OP_1ADD = 0x8b,\n-    OP_1SUB = 0x8c,\n-    OP_2MUL = 0x8d,\n-    OP_2DIV = 0x8e,\n-    OP_NEGATE = 0x8f,\n-    OP_ABS = 0x90,\n-    OP_NOT = 0x91,\n-    OP_0NOTEQUAL = 0x92,\n-\n-    OP_ADD = 0x93,\n-    OP_SUB = 0x94,\n-    OP_MUL = 0x95,\n-    OP_DIV = 0x96,\n-    OP_MOD = 0x97,\n-    OP_LSHIFT = 0x98,\n-    OP_RSHIFT = 0x99,\n-\n-    OP_BOOLAND = 0x9a,\n-    OP_BOOLOR = 0x9b,\n-    OP_NUMEQUAL = 0x9c,\n-    OP_NUMEQUALVERIFY = 0x9d,\n-    OP_NUMNOTEQUAL = 0x9e,\n-    OP_LESSTHAN = 0x9f,\n-    OP_GREATERTHAN = 0xa0,\n-    OP_LESSTHANOREQUAL = 0xa1,\n-    OP_GREATERTHANOREQUAL = 0xa2,\n-    OP_MIN = 0xa3,\n-    OP_MAX = 0xa4,\n-\n-    OP_WITHIN = 0xa5,\n-\n-    // crypto\n-    OP_RIPEMD160 = 0xa6,\n-    OP_SHA1 = 0xa7,\n-    OP_SHA256 = 0xa8,\n-    OP_HASH160 = 0xa9,\n-    OP_HASH256 = 0xaa,\n-    OP_CODESEPARATOR = 0xab,\n-    OP_CHECKSIG = 0xac,\n-    OP_CHECKSIGVERIFY = 0xad,\n-    OP_CHECKMULTISIG = 0xae,\n-    OP_CHECKMULTISIGVERIFY = 0xaf,\n-\n-    // expansion\n-    OP_NOP1 = 0xb0,\n-    OP_NOP2 = 0xb1,\n-    OP_NOP3 = 0xb2,\n-    OP_NOP4 = 0xb3,\n-    OP_NOP5 = 0xb4,\n-    OP_NOP6 = 0xb5,\n-    OP_NOP7 = 0xb6,\n-    OP_NOP8 = 0xb7,\n-    OP_NOP9 = 0xb8,\n-    OP_NOP10 = 0xb9,\n-\n-\n-\n-    // template matching params\n-    OP_SMALLDATA = 0xf9,\n-    OP_SMALLINTEGER = 0xfa,\n-    OP_PUBKEYS = 0xfb,\n-    OP_PUBKEYHASH = 0xfd,\n-    OP_PUBKEY = 0xfe,\n-\n-    OP_INVALIDOPCODE = 0xff,\n-};\n \n const char* GetOpName(opcodetype opcode);\n ",
        "previous_filename": "src/script.h"
      },
      {
        "sha": "36164f8542e05c87aebbefb10d0d95d2fd332801",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "patch": "@@ -12,7 +12,7 @@\n #include \"main.h\"\n #include \"net.h\"\n #include \"pow.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"serialize.h\"\n \n #include <stdint.h>"
      },
      {
        "sha": "0587ddac849368a13bea09e3e6389c599773988e",
        "filename": "src/test/base58_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/test/base58_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/test/base58_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/base58_tests.cpp?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "patch": "@@ -9,7 +9,7 @@\n #include \"data/base58_keys_valid.json.h\"\n \n #include \"key.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"uint256.h\"\n #include \"util.h\"\n "
      },
      {
        "sha": "2d2a600740106f4c489735874f51891be491fb56",
        "filename": "src/test/canonical_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/test/canonical_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/test/canonical_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/canonical_tests.cpp?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "patch": "@@ -9,7 +9,7 @@\n #include \"data/sig_noncanonical.json.h\"\n #include \"data/sig_canonical.json.h\"\n #include \"random.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"util.h\"\n \n #include <boost/foreach.hpp>"
      },
      {
        "sha": "c6bf0db3af3f3d9fe9f10e9cca8a61c20473f60c",
        "filename": "src/test/key_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/test/key_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/test/key_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/key_tests.cpp?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "patch": "@@ -5,7 +5,7 @@\n #include \"key.h\"\n \n #include \"base58.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"uint256.h\"\n #include \"util.h\"\n "
      },
      {
        "sha": "d25223f6f73252e5e7ca2b06917ca18c72cdcb15",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "patch": "@@ -5,7 +5,7 @@\n #include \"key.h\"\n #include \"keystore.h\"\n #include \"main.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"uint256.h\"\n \n #include <boost/assign/std/vector.hpp>"
      },
      {
        "sha": "d27fc71598619b08f634c4c04b7a6899d7b01067",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "patch": "@@ -2,12 +2,10 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include \"script.h\"\n-\n #include \"key.h\"\n #include \"keystore.h\"\n #include \"main.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n \n #include <vector>\n "
      },
      {
        "sha": "c7d0503df3c50eed36e85e413f9948e23a9d8502",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "patch": "@@ -2,15 +2,13 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include \"script.h\"\n-\n #include \"data/script_invalid.json.h\"\n #include \"data/script_valid.json.h\"\n \n #include \"key.h\"\n #include \"keystore.h\"\n #include \"main.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"core_io.h\"\n \n #include <fstream>"
      },
      {
        "sha": "c3cd41cf84525137b731941e48c06ea566dc5933",
        "filename": "src/test/scriptnum_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/test/scriptnum_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/test/scriptnum_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/scriptnum_tests.cpp?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "patch": "@@ -3,7 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"bignum.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include <boost/test/unit_test.hpp>\n #include <limits.h>\n #include <stdint.h>"
      },
      {
        "sha": "53f4d443c4b436f71eca9011a11614ad7a4b786e",
        "filename": "src/test/sighash_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/test/sighash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/test/sighash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sighash_tests.cpp?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "patch": "@@ -6,7 +6,7 @@\n #include \"main.h\"\n #include \"random.h\"\n #include \"serialize.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"util.h\"\n #include \"version.h\"\n "
      },
      {
        "sha": "963ccf560d3ccbda36571817d851fb74cc001555",
        "filename": "src/test/sigopcount_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/test/sigopcount_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/test/sigopcount_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sigopcount_tests.cpp?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "patch": "@@ -3,7 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"key.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"uint256.h\"\n \n #include <vector>"
      },
      {
        "sha": "2b5161b0cf69c3a5ddcf949468cf6e62ffd1cbca",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1c67acc139a3aa0b037440aa3246edc0cf1bc01/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "patch": "@@ -8,7 +8,7 @@\n #include \"key.h\"\n #include \"keystore.h\"\n #include \"main.h\"\n-#include \"script.h\"\n+#include \"scriptutils.h\"\n #include \"core_io.h\"\n \n #include <map>"
      }
    ]
  },
  {
    "sha": "1dc9666c39ca532efad20a236923e0daa4c57921",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxZGM5NjY2YzM5Y2E1MzJlZmFkMjBhMjM2OTIzZTBkYWE0YzU3OTIx",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2014-08-11T04:37:59Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2014-08-20T03:05:54Z"
      },
      "message": "Get a working libbitcoinscript.so build.\n\nThis moves a bunch of functions around and, with minimal changes\ngenerates a linkable (though not useful) libbitcoinscript.so.",
      "tree": {
        "sha": "a0b5e19fecc2a91d03a484b643d05ae639abe462",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a0b5e19fecc2a91d03a484b643d05ae639abe462"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1dc9666c39ca532efad20a236923e0daa4c57921",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1dc9666c39ca532efad20a236923e0daa4c57921",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1dc9666c39ca532efad20a236923e0daa4c57921",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1dc9666c39ca532efad20a236923e0daa4c57921/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c1c67acc139a3aa0b037440aa3246edc0cf1bc01",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c1c67acc139a3aa0b037440aa3246edc0cf1bc01"
      }
    ],
    "stats": {
      "total": 2718,
      "additions": 1409,
      "deletions": 1309
    },
    "files": [
      {
        "sha": "dbf03e260a91f8d71ebc62076449c6e28f9ed7da",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1dc9666c39ca532efad20a236923e0daa4c57921/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1dc9666c39ca532efad20a236923e0daa4c57921/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=1dc9666c39ca532efad20a236923e0daa4c57921",
        "patch": "@@ -27,6 +27,7 @@ src/m4/ltoptions.m4\n src/m4/ltsugar.m4\n src/m4/ltversion.m4\n src/m4/lt~obsolete.m4\n+src/.libs\n \n src/univalue/gen\n \n@@ -49,6 +50,8 @@ src/qt/test/moc*.cpp\n *.patch\n .bitcoin\n *.a\n+*.la\n+*.lo\n *.pb.cc\n *.pb.h\n "
      },
      {
        "sha": "c60658c6b2572cd4235f0e9c017b721650319c9e",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1dc9666c39ca532efad20a236923e0daa4c57921/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1dc9666c39ca532efad20a236923e0daa4c57921/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=1dc9666c39ca532efad20a236923e0daa4c57921",
        "patch": "@@ -46,6 +46,8 @@ noinst_LIBRARIES = \\\n   univalue/libbitcoin_univalue.a \\\n   crypto/libbitcoin_crypto.a\n \n+lib_LTLIBRARIES = libbitcoinscript.la\n+\n if ENABLE_WALLET\n BITCOIN_INCLUDES += $(BDB_CPPFLAGS)\n noinst_LIBRARIES += libbitcoin_wallet.a\n@@ -214,6 +216,24 @@ libbitcoin_script_a_CPPFLAGS = $(BITCOIN_INCLUDES)\n libbitcoin_script_a_SOURCES = \\\n   script/script.cpp\n \n+libbitcoinscript_la_CPPFLAGS = $(BITCOIN_INCLUDES)\n+libbitcoinscript_la_LDFLAGS = -version-info 0:0:0\n+libbitcoinscript_la_LIBADD = \\\n+  $(BOOST_LIBS) \\\n+  $(CRYPTO_LIBS)\n+libbitcoinscript_la_SOURCES = \\\n+  script/standalone.cpp \\\n+  script/script.cpp \\\n+  crypto/sha1.cpp \\\n+  crypto/sha2.cpp \\\n+  crypto/ripemd160.cpp \\\n+  crypto/common.h \\\n+  crypto/sha2.h \\\n+  crypto/sha1.h \\\n+  crypto/ripemd160.h \\\n+  allocators.cpp \\\n+  key.cpp \\\n+  random.cpp\n \n # util: shared between all executables.\n # This library *must* be included to make sure that the glibc"
      },
      {
        "sha": "1ce1d29b267ffebda83ff2251be1c7376673d1a8",
        "filename": "src/script/bitcoinscript.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1dc9666c39ca532efad20a236923e0daa4c57921/src/script/bitcoinscript.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1dc9666c39ca532efad20a236923e0daa4c57921/src/script/bitcoinscript.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/bitcoinscript.h?ref=1dc9666c39ca532efad20a236923e0daa4c57921",
        "patch": "@@ -1,6 +1,11 @@\n #ifndef H_BITCOIN_BITCOINSCRIPT\n #define H_BITCOIN_BITCOINSCRIPT\n \n+#include <vector>\n+\n+class CScript;\n+class CTransaction;\n+\n /** Script verification flags */\n enum\n {\n@@ -27,4 +32,6 @@ static const unsigned int STANDARD_SCRIPT_VERIFY_FLAGS = MANDATORY_SCRIPT_VERIFY\n                                                          SCRIPT_VERIFY_STRICTENC |\n                                                          SCRIPT_VERIFY_NULLDUMMY;\n \n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, unsigned int flags, int nHashType);\n+\n #endif"
      },
      {
        "sha": "84b2832ae9044d369efb1109602637e6f9ff3d6e",
        "filename": "src/script/script.cpp",
        "status": "modified",
        "additions": 987,
        "deletions": 0,
        "changes": 987,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1dc9666c39ca532efad20a236923e0daa4c57921/src/script/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1dc9666c39ca532efad20a236923e0daa4c57921/src/script/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.cpp?ref=1dc9666c39ca532efad20a236923e0daa4c57921",
        "patch": "@@ -0,0 +1,987 @@\n+#include \"script.h\"\n+#include \"crypto/sha1.h\"\n+#include \"core.h\"\n+#include \"util.h\" // For error()\n+\n+using namespace std;\n+\n+typedef vector<unsigned char> valtype;\n+static const valtype vchFalse(0);\n+static const valtype vchZero(0);\n+static const valtype vchTrue(1, 1);\n+static const CScriptNum bnZero(0);\n+static const CScriptNum bnOne(1);\n+static const CScriptNum bnFalse(0);\n+static const CScriptNum bnTrue(1);\n+\n+bool CheckSig(vector<unsigned char> vchSig, const vector<unsigned char> &vchPubKey, const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType, int flags);\n+\n+bool CastToBool(const valtype& vch)\n+{\n+    for (unsigned int i = 0; i < vch.size(); i++)\n+    {\n+        if (vch[i] != 0)\n+        {\n+            // Can be negative zero\n+            if (i == vch.size()-1 && vch[i] == 0x80)\n+                return false;\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+//\n+// Script is a stack machine (like Forth) that evaluates a predicate\n+// returning a bool indicating valid or not.  There are no loops.\n+//\n+#define stacktop(i)  (stack.at(stack.size()+(i)))\n+#define altstacktop(i)  (altstack.at(altstack.size()+(i)))\n+static inline void popstack(vector<valtype>& stack)\n+{\n+    if (stack.empty())\n+        throw runtime_error(\"popstack() : stack empty\");\n+    stack.pop_back();\n+}\n+\n+\n+\n+bool IsCanonicalPubKey(const valtype &vchPubKey, unsigned int flags) {\n+    if (!(flags & SCRIPT_VERIFY_STRICTENC))\n+        return true;\n+\n+    if (vchPubKey.size() < 33)\n+        return error(\"Non-canonical public key: too short\");\n+    if (vchPubKey[0] == 0x04) {\n+        if (vchPubKey.size() != 65)\n+            return error(\"Non-canonical public key: invalid length for uncompressed key\");\n+    } else if (vchPubKey[0] == 0x02 || vchPubKey[0] == 0x03) {\n+        if (vchPubKey.size() != 33)\n+            return error(\"Non-canonical public key: invalid length for compressed key\");\n+    } else {\n+        return error(\"Non-canonical public key: compressed nor uncompressed\");\n+    }\n+    return true;\n+}\n+\n+bool IsCanonicalSignature(const valtype &vchSig, unsigned int flags) {\n+    if (!(flags & SCRIPT_VERIFY_STRICTENC))\n+        return true;\n+\n+    // See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623\n+    // A canonical signature exists of: <30> <total len> <02> <len R> <R> <02> <len S> <S> <hashtype>\n+    // Where R and S are not negative (their first byte has its highest bit not set), and not\n+    // excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,\n+    // in which case a single 0 byte is necessary and even required).\n+    if (vchSig.size() < 9)\n+        return error(\"Non-canonical signature: too short\");\n+    if (vchSig.size() > 73)\n+        return error(\"Non-canonical signature: too long\");\n+    unsigned char nHashType = vchSig[vchSig.size() - 1] & (~(SIGHASH_ANYONECANPAY));\n+    if (nHashType < SIGHASH_ALL || nHashType > SIGHASH_SINGLE)\n+        return error(\"Non-canonical signature: unknown hashtype byte\");\n+    if (vchSig[0] != 0x30)\n+        return error(\"Non-canonical signature: wrong type\");\n+    if (vchSig[1] != vchSig.size()-3)\n+        return error(\"Non-canonical signature: wrong length marker\");\n+    unsigned int nLenR = vchSig[3];\n+    if (5 + nLenR >= vchSig.size())\n+        return error(\"Non-canonical signature: S length misplaced\");\n+    unsigned int nLenS = vchSig[5+nLenR];\n+    if ((unsigned long)(nLenR+nLenS+7) != vchSig.size())\n+        return error(\"Non-canonical signature: R+S length mismatch\");\n+\n+    const unsigned char *R = &vchSig[4];\n+    if (R[-2] != 0x02)\n+        return error(\"Non-canonical signature: R value type mismatch\");\n+    if (nLenR == 0)\n+        return error(\"Non-canonical signature: R length is zero\");\n+    if (R[0] & 0x80)\n+        return error(\"Non-canonical signature: R value negative\");\n+    if (nLenR > 1 && (R[0] == 0x00) && !(R[1] & 0x80))\n+        return error(\"Non-canonical signature: R value excessively padded\");\n+\n+    const unsigned char *S = &vchSig[6+nLenR];\n+    if (S[-2] != 0x02)\n+        return error(\"Non-canonical signature: S value type mismatch\");\n+    if (nLenS == 0)\n+        return error(\"Non-canonical signature: S length is zero\");\n+    if (S[0] & 0x80)\n+        return error(\"Non-canonical signature: S value negative\");\n+    if (nLenS > 1 && (S[0] == 0x00) && !(S[1] & 0x80))\n+        return error(\"Non-canonical signature: S value excessively padded\");\n+\n+    if (flags & SCRIPT_VERIFY_LOW_S) {\n+        // If the S value is above the order of the curve divided by two, its\n+        // complement modulo the order could have been used instead, which is\n+        // one byte shorter when encoded correctly.\n+        if (!CKey::CheckSignatureElement(S, nLenS, true))\n+            return error(\"Non-canonical signature: S value is unnecessarily high\");\n+    }\n+\n+    return true;\n+}\n+\n+bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, unsigned int flags, int nHashType)\n+{\n+    CScript::const_iterator pc = script.begin();\n+    CScript::const_iterator pend = script.end();\n+    CScript::const_iterator pbegincodehash = script.begin();\n+    opcodetype opcode;\n+    valtype vchPushValue;\n+    vector<bool> vfExec;\n+    vector<valtype> altstack;\n+    if (script.size() > 10000)\n+        return false;\n+    int nOpCount = 0;\n+\n+    try\n+    {\n+        while (pc < pend)\n+        {\n+            bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n+\n+            //\n+            // Read instruction\n+            //\n+            if (!script.GetOp(pc, opcode, vchPushValue))\n+                return false;\n+            if (vchPushValue.size() > MAX_SCRIPT_ELEMENT_SIZE)\n+                return false;\n+\n+            // Note how OP_RESERVED does not count towards the opcode limit.\n+            if (opcode > OP_16 && ++nOpCount > 201)\n+                return false;\n+\n+            if (opcode == OP_CAT ||\n+                opcode == OP_SUBSTR ||\n+                opcode == OP_LEFT ||\n+                opcode == OP_RIGHT ||\n+                opcode == OP_INVERT ||\n+                opcode == OP_AND ||\n+                opcode == OP_OR ||\n+                opcode == OP_XOR ||\n+                opcode == OP_2MUL ||\n+                opcode == OP_2DIV ||\n+                opcode == OP_MUL ||\n+                opcode == OP_DIV ||\n+                opcode == OP_MOD ||\n+                opcode == OP_LSHIFT ||\n+                opcode == OP_RSHIFT)\n+                return false; // Disabled opcodes.\n+\n+            if (fExec && 0 <= opcode && opcode <= OP_PUSHDATA4)\n+                stack.push_back(vchPushValue);\n+            else if (fExec || (OP_IF <= opcode && opcode <= OP_ENDIF))\n+            switch (opcode)\n+            {\n+                //\n+                // Push value\n+                //\n+                case OP_1NEGATE:\n+                case OP_1:\n+                case OP_2:\n+                case OP_3:\n+                case OP_4:\n+                case OP_5:\n+                case OP_6:\n+                case OP_7:\n+                case OP_8:\n+                case OP_9:\n+                case OP_10:\n+                case OP_11:\n+                case OP_12:\n+                case OP_13:\n+                case OP_14:\n+                case OP_15:\n+                case OP_16:\n+                {\n+                    // ( -- value)\n+                    CScriptNum bn((int)opcode - (int)(OP_1 - 1));\n+                    stack.push_back(bn.getvch());\n+                }\n+                break;\n+\n+\n+                //\n+                // Control\n+                //\n+                case OP_NOP:\n+                case OP_NOP1: case OP_NOP2: case OP_NOP3: case OP_NOP4: case OP_NOP5:\n+                case OP_NOP6: case OP_NOP7: case OP_NOP8: case OP_NOP9: case OP_NOP10:\n+                break;\n+\n+                case OP_IF:\n+                case OP_NOTIF:\n+                {\n+                    // <expression> if [statements] [else [statements]] endif\n+                    bool fValue = false;\n+                    if (fExec)\n+                    {\n+                        if (stack.size() < 1)\n+                            return false;\n+                        valtype& vch = stacktop(-1);\n+                        fValue = CastToBool(vch);\n+                        if (opcode == OP_NOTIF)\n+                            fValue = !fValue;\n+                        popstack(stack);\n+                    }\n+                    vfExec.push_back(fValue);\n+                }\n+                break;\n+\n+                case OP_ELSE:\n+                {\n+                    if (vfExec.empty())\n+                        return false;\n+                    vfExec.back() = !vfExec.back();\n+                }\n+                break;\n+\n+                case OP_ENDIF:\n+                {\n+                    if (vfExec.empty())\n+                        return false;\n+                    vfExec.pop_back();\n+                }\n+                break;\n+\n+                case OP_VERIFY:\n+                {\n+                    // (true -- ) or\n+                    // (false -- false) and return\n+                    if (stack.size() < 1)\n+                        return false;\n+                    bool fValue = CastToBool(stacktop(-1));\n+                    if (fValue)\n+                        popstack(stack);\n+                    else\n+                        return false;\n+                }\n+                break;\n+\n+                case OP_RETURN:\n+                {\n+                    return false;\n+                }\n+                break;\n+\n+\n+                //\n+                // Stack ops\n+                //\n+                case OP_TOALTSTACK:\n+                {\n+                    if (stack.size() < 1)\n+                        return false;\n+                    altstack.push_back(stacktop(-1));\n+                    popstack(stack);\n+                }\n+                break;\n+\n+                case OP_FROMALTSTACK:\n+                {\n+                    if (altstack.size() < 1)\n+                        return false;\n+                    stack.push_back(altstacktop(-1));\n+                    popstack(altstack);\n+                }\n+                break;\n+\n+                case OP_2DROP:\n+                {\n+                    // (x1 x2 -- )\n+                    if (stack.size() < 2)\n+                        return false;\n+                    popstack(stack);\n+                    popstack(stack);\n+                }\n+                break;\n+\n+                case OP_2DUP:\n+                {\n+                    // (x1 x2 -- x1 x2 x1 x2)\n+                    if (stack.size() < 2)\n+                        return false;\n+                    valtype vch1 = stacktop(-2);\n+                    valtype vch2 = stacktop(-1);\n+                    stack.push_back(vch1);\n+                    stack.push_back(vch2);\n+                }\n+                break;\n+\n+                case OP_3DUP:\n+                {\n+                    // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n+                    if (stack.size() < 3)\n+                        return false;\n+                    valtype vch1 = stacktop(-3);\n+                    valtype vch2 = stacktop(-2);\n+                    valtype vch3 = stacktop(-1);\n+                    stack.push_back(vch1);\n+                    stack.push_back(vch2);\n+                    stack.push_back(vch3);\n+                }\n+                break;\n+\n+                case OP_2OVER:\n+                {\n+                    // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n+                    if (stack.size() < 4)\n+                        return false;\n+                    valtype vch1 = stacktop(-4);\n+                    valtype vch2 = stacktop(-3);\n+                    stack.push_back(vch1);\n+                    stack.push_back(vch2);\n+                }\n+                break;\n+\n+                case OP_2ROT:\n+                {\n+                    // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n+                    if (stack.size() < 6)\n+                        return false;\n+                    valtype vch1 = stacktop(-6);\n+                    valtype vch2 = stacktop(-5);\n+                    stack.erase(stack.end()-6, stack.end()-4);\n+                    stack.push_back(vch1);\n+                    stack.push_back(vch2);\n+                }\n+                break;\n+\n+                case OP_2SWAP:\n+                {\n+                    // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n+                    if (stack.size() < 4)\n+                        return false;\n+                    swap(stacktop(-4), stacktop(-2));\n+                    swap(stacktop(-3), stacktop(-1));\n+                }\n+                break;\n+\n+                case OP_IFDUP:\n+                {\n+                    // (x - 0 | x x)\n+                    if (stack.size() < 1)\n+                        return false;\n+                    valtype vch = stacktop(-1);\n+                    if (CastToBool(vch))\n+                        stack.push_back(vch);\n+                }\n+                break;\n+\n+                case OP_DEPTH:\n+                {\n+                    // -- stacksize\n+                    CScriptNum bn(stack.size());\n+                    stack.push_back(bn.getvch());\n+                }\n+                break;\n+\n+                case OP_DROP:\n+                {\n+                    // (x -- )\n+                    if (stack.size() < 1)\n+                        return false;\n+                    popstack(stack);\n+                }\n+                break;\n+\n+                case OP_DUP:\n+                {\n+                    // (x -- x x)\n+                    if (stack.size() < 1)\n+                        return false;\n+                    valtype vch = stacktop(-1);\n+                    stack.push_back(vch);\n+                }\n+                break;\n+\n+                case OP_NIP:\n+                {\n+                    // (x1 x2 -- x2)\n+                    if (stack.size() < 2)\n+                        return false;\n+                    stack.erase(stack.end() - 2);\n+                }\n+                break;\n+\n+                case OP_OVER:\n+                {\n+                    // (x1 x2 -- x1 x2 x1)\n+                    if (stack.size() < 2)\n+                        return false;\n+                    valtype vch = stacktop(-2);\n+                    stack.push_back(vch);\n+                }\n+                break;\n+\n+                case OP_PICK:\n+                case OP_ROLL:\n+                {\n+                    // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n+                    // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n+                    if (stack.size() < 2)\n+                        return false;\n+                    int n = CScriptNum(stacktop(-1)).getint();\n+                    popstack(stack);\n+                    if (n < 0 || n >= (int)stack.size())\n+                        return false;\n+                    valtype vch = stacktop(-n-1);\n+                    if (opcode == OP_ROLL)\n+                        stack.erase(stack.end()-n-1);\n+                    stack.push_back(vch);\n+                }\n+                break;\n+\n+                case OP_ROT:\n+                {\n+                    // (x1 x2 x3 -- x2 x3 x1)\n+                    //  x2 x1 x3  after first swap\n+                    //  x2 x3 x1  after second swap\n+                    if (stack.size() < 3)\n+                        return false;\n+                    swap(stacktop(-3), stacktop(-2));\n+                    swap(stacktop(-2), stacktop(-1));\n+                }\n+                break;\n+\n+                case OP_SWAP:\n+                {\n+                    // (x1 x2 -- x2 x1)\n+                    if (stack.size() < 2)\n+                        return false;\n+                    swap(stacktop(-2), stacktop(-1));\n+                }\n+                break;\n+\n+                case OP_TUCK:\n+                {\n+                    // (x1 x2 -- x2 x1 x2)\n+                    if (stack.size() < 2)\n+                        return false;\n+                    valtype vch = stacktop(-1);\n+                    stack.insert(stack.end()-2, vch);\n+                }\n+                break;\n+\n+\n+                case OP_SIZE:\n+                {\n+                    // (in -- in size)\n+                    if (stack.size() < 1)\n+                        return false;\n+                    CScriptNum bn(stacktop(-1).size());\n+                    stack.push_back(bn.getvch());\n+                }\n+                break;\n+\n+\n+                //\n+                // Bitwise logic\n+                //\n+                case OP_EQUAL:\n+                case OP_EQUALVERIFY:\n+                //case OP_NOTEQUAL: // use OP_NUMNOTEQUAL\n+                {\n+                    // (x1 x2 - bool)\n+                    if (stack.size() < 2)\n+                        return false;\n+                    valtype& vch1 = stacktop(-2);\n+                    valtype& vch2 = stacktop(-1);\n+                    bool fEqual = (vch1 == vch2);\n+                    // OP_NOTEQUAL is disabled because it would be too easy to say\n+                    // something like n != 1 and have some wiseguy pass in 1 with extra\n+                    // zero bytes after it (numerically, 0x01 == 0x0001 == 0x000001)\n+                    //if (opcode == OP_NOTEQUAL)\n+                    //    fEqual = !fEqual;\n+                    popstack(stack);\n+                    popstack(stack);\n+                    stack.push_back(fEqual ? vchTrue : vchFalse);\n+                    if (opcode == OP_EQUALVERIFY)\n+                    {\n+                        if (fEqual)\n+                            popstack(stack);\n+                        else\n+                            return false;\n+                    }\n+                }\n+                break;\n+\n+\n+                //\n+                // Numeric\n+                //\n+                case OP_1ADD:\n+                case OP_1SUB:\n+                case OP_NEGATE:\n+                case OP_ABS:\n+                case OP_NOT:\n+                case OP_0NOTEQUAL:\n+                {\n+                    // (in -- out)\n+                    if (stack.size() < 1)\n+                        return false;\n+                    CScriptNum bn(stacktop(-1));\n+                    switch (opcode)\n+                    {\n+                    case OP_1ADD:       bn += bnOne; break;\n+                    case OP_1SUB:       bn -= bnOne; break;\n+                    case OP_NEGATE:     bn = -bn; break;\n+                    case OP_ABS:        if (bn < bnZero) bn = -bn; break;\n+                    case OP_NOT:        bn = (bn == bnZero); break;\n+                    case OP_0NOTEQUAL:  bn = (bn != bnZero); break;\n+                    default:            assert(!\"invalid opcode\"); break;\n+                    }\n+                    popstack(stack);\n+                    stack.push_back(bn.getvch());\n+                }\n+                break;\n+\n+                case OP_ADD:\n+                case OP_SUB:\n+                case OP_BOOLAND:\n+                case OP_BOOLOR:\n+                case OP_NUMEQUAL:\n+                case OP_NUMEQUALVERIFY:\n+                case OP_NUMNOTEQUAL:\n+                case OP_LESSTHAN:\n+                case OP_GREATERTHAN:\n+                case OP_LESSTHANOREQUAL:\n+                case OP_GREATERTHANOREQUAL:\n+                case OP_MIN:\n+                case OP_MAX:\n+                {\n+                    // (x1 x2 -- out)\n+                    if (stack.size() < 2)\n+                        return false;\n+                    CScriptNum bn1(stacktop(-2));\n+                    CScriptNum bn2(stacktop(-1));\n+                    CScriptNum bn(0);\n+                    switch (opcode)\n+                    {\n+                    case OP_ADD:\n+                        bn = bn1 + bn2;\n+                        break;\n+\n+                    case OP_SUB:\n+                        bn = bn1 - bn2;\n+                        break;\n+\n+                    case OP_BOOLAND:             bn = (bn1 != bnZero && bn2 != bnZero); break;\n+                    case OP_BOOLOR:              bn = (bn1 != bnZero || bn2 != bnZero); break;\n+                    case OP_NUMEQUAL:            bn = (bn1 == bn2); break;\n+                    case OP_NUMEQUALVERIFY:      bn = (bn1 == bn2); break;\n+                    case OP_NUMNOTEQUAL:         bn = (bn1 != bn2); break;\n+                    case OP_LESSTHAN:            bn = (bn1 < bn2); break;\n+                    case OP_GREATERTHAN:         bn = (bn1 > bn2); break;\n+                    case OP_LESSTHANOREQUAL:     bn = (bn1 <= bn2); break;\n+                    case OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n+                    case OP_MIN:                 bn = (bn1 < bn2 ? bn1 : bn2); break;\n+                    case OP_MAX:                 bn = (bn1 > bn2 ? bn1 : bn2); break;\n+                    default:                     assert(!\"invalid opcode\"); break;\n+                    }\n+                    popstack(stack);\n+                    popstack(stack);\n+                    stack.push_back(bn.getvch());\n+\n+                    if (opcode == OP_NUMEQUALVERIFY)\n+                    {\n+                        if (CastToBool(stacktop(-1)))\n+                            popstack(stack);\n+                        else\n+                            return false;\n+                    }\n+                }\n+                break;\n+\n+                case OP_WITHIN:\n+                {\n+                    // (x min max -- out)\n+                    if (stack.size() < 3)\n+                        return false;\n+                    CScriptNum bn1(stacktop(-3));\n+                    CScriptNum bn2(stacktop(-2));\n+                    CScriptNum bn3(stacktop(-1));\n+                    bool fValue = (bn2 <= bn1 && bn1 < bn3);\n+                    popstack(stack);\n+                    popstack(stack);\n+                    popstack(stack);\n+                    stack.push_back(fValue ? vchTrue : vchFalse);\n+                }\n+                break;\n+\n+\n+                //\n+                // Crypto\n+                //\n+                case OP_RIPEMD160:\n+                case OP_SHA1:\n+                case OP_SHA256:\n+                case OP_HASH160:\n+                case OP_HASH256:\n+                {\n+                    // (in -- hash)\n+                    if (stack.size() < 1)\n+                        return false;\n+                    valtype& vch = stacktop(-1);\n+                    valtype vchHash((opcode == OP_RIPEMD160 || opcode == OP_SHA1 || opcode == OP_HASH160) ? 20 : 32);\n+                    if (opcode == OP_RIPEMD160)\n+                        CRIPEMD160().Write(&vch[0], vch.size()).Finalize(&vchHash[0]);\n+                    else if (opcode == OP_SHA1)\n+                        CSHA1().Write(&vch[0], vch.size()).Finalize(&vchHash[0]);\n+                    else if (opcode == OP_SHA256)\n+                        CSHA256().Write(&vch[0], vch.size()).Finalize(&vchHash[0]);\n+                    else if (opcode == OP_HASH160)\n+                        CHash160().Write(&vch[0], vch.size()).Finalize(&vchHash[0]);\n+                    else if (opcode == OP_HASH256)\n+                        CHash256().Write(&vch[0], vch.size()).Finalize(&vchHash[0]);\n+                    popstack(stack);\n+                    stack.push_back(vchHash);\n+                }\n+                break;\n+\n+                case OP_CODESEPARATOR:\n+                {\n+                    // Hash starts after the code separator\n+                    pbegincodehash = pc;\n+                }\n+                break;\n+\n+                case OP_CHECKSIG:\n+                case OP_CHECKSIGVERIFY:\n+                {\n+                    // (sig pubkey -- bool)\n+                    if (stack.size() < 2)\n+                        return false;\n+\n+                    valtype& vchSig    = stacktop(-2);\n+                    valtype& vchPubKey = stacktop(-1);\n+\n+                    // Subset of script starting at the most recent codeseparator\n+                    CScript scriptCode(pbegincodehash, pend);\n+\n+                    // Drop the signature, since there's no way for a signature to sign itself\n+                    scriptCode.FindAndDelete(CScript(vchSig));\n+\n+                    bool fSuccess = IsCanonicalSignature(vchSig, flags) && IsCanonicalPubKey(vchPubKey, flags) &&\n+                        CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType, flags);\n+\n+                    popstack(stack);\n+                    popstack(stack);\n+                    stack.push_back(fSuccess ? vchTrue : vchFalse);\n+                    if (opcode == OP_CHECKSIGVERIFY)\n+                    {\n+                        if (fSuccess)\n+                            popstack(stack);\n+                        else\n+                            return false;\n+                    }\n+                }\n+                break;\n+\n+                case OP_CHECKMULTISIG:\n+                case OP_CHECKMULTISIGVERIFY:\n+                {\n+                    // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n+\n+                    int i = 1;\n+                    if ((int)stack.size() < i)\n+                        return false;\n+\n+                    int nKeysCount = CScriptNum(stacktop(-i)).getint();\n+                    if (nKeysCount < 0 || nKeysCount > 20)\n+                        return false;\n+                    nOpCount += nKeysCount;\n+                    if (nOpCount > 201)\n+                        return false;\n+                    int ikey = ++i;\n+                    i += nKeysCount;\n+                    if ((int)stack.size() < i)\n+                        return false;\n+\n+                    int nSigsCount = CScriptNum(stacktop(-i)).getint();\n+                    if (nSigsCount < 0 || nSigsCount > nKeysCount)\n+                        return false;\n+                    int isig = ++i;\n+                    i += nSigsCount;\n+                    if ((int)stack.size() < i)\n+                        return false;\n+\n+                    // Subset of script starting at the most recent codeseparator\n+                    CScript scriptCode(pbegincodehash, pend);\n+\n+                    // Drop the signatures, since there's no way for a signature to sign itself\n+                    for (int k = 0; k < nSigsCount; k++)\n+                    {\n+                        valtype& vchSig = stacktop(-isig-k);\n+                        scriptCode.FindAndDelete(CScript(vchSig));\n+                    }\n+\n+                    bool fSuccess = true;\n+                    while (fSuccess && nSigsCount > 0)\n+                    {\n+                        valtype& vchSig    = stacktop(-isig);\n+                        valtype& vchPubKey = stacktop(-ikey);\n+\n+                        // Check signature\n+                        bool fOk = IsCanonicalSignature(vchSig, flags) && IsCanonicalPubKey(vchPubKey, flags) &&\n+                            CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType, flags);\n+\n+                        if (fOk) {\n+                            isig++;\n+                            nSigsCount--;\n+                        }\n+                        ikey++;\n+                        nKeysCount--;\n+\n+                        // If there are more signatures left than keys left,\n+                        // then too many signatures have failed\n+                        if (nSigsCount > nKeysCount)\n+                            fSuccess = false;\n+                    }\n+\n+                    // Clean up stack of actual arguments\n+                    while (i-- > 1)\n+                        popstack(stack);\n+\n+                    // A bug causes CHECKMULTISIG to consume one extra argument\n+                    // whose contents were not checked in any way.\n+                    //\n+                    // Unfortunately this is a potential source of mutability,\n+                    // so optionally verify it is exactly equal to zero prior\n+                    // to removing it from the stack.\n+                    if (stack.size() < 1)\n+                        return false;\n+                    if ((flags & SCRIPT_VERIFY_NULLDUMMY) && stacktop(-1).size())\n+                        return error(\"CHECKMULTISIG dummy argument not null\");\n+                    popstack(stack);\n+\n+                    stack.push_back(fSuccess ? vchTrue : vchFalse);\n+\n+                    if (opcode == OP_CHECKMULTISIGVERIFY)\n+                    {\n+                        if (fSuccess)\n+                            popstack(stack);\n+                        else\n+                            return false;\n+                    }\n+                }\n+                break;\n+\n+                default:\n+                    return false;\n+            }\n+\n+            // Size limits\n+            if (stack.size() + altstack.size() > 1000)\n+                return false;\n+        }\n+    }\n+    catch (...)\n+    {\n+        return false;\n+    }\n+\n+\n+    if (!vfExec.empty())\n+        return false;\n+\n+    return true;\n+}\n+\n+\n+bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n+                  unsigned int flags, int nHashType)\n+{\n+    vector<vector<unsigned char> > stack, stackCopy;\n+    if (!EvalScript(stack, scriptSig, txTo, nIn, flags, nHashType))\n+        return false;\n+    if (flags & SCRIPT_VERIFY_P2SH)\n+        stackCopy = stack;\n+    if (!EvalScript(stack, scriptPubKey, txTo, nIn, flags, nHashType))\n+        return false;\n+    if (stack.empty())\n+        return false;\n+\n+    if (CastToBool(stack.back()) == false)\n+        return false;\n+\n+    // Additional validation for spend-to-script-hash transactions:\n+    if ((flags & SCRIPT_VERIFY_P2SH) && scriptPubKey.IsPayToScriptHash())\n+    {\n+        if (!scriptSig.IsPushOnly()) // scriptSig must be literals-only\n+            return false;            // or validation fails\n+\n+        // stackCopy cannot be empty here, because if it was the\n+        // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with\n+        // an empty stack and the EvalScript above would return false.\n+        assert(!stackCopy.empty());\n+\n+        const valtype& pubKeySerialized = stackCopy.back();\n+        CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end());\n+        popstack(stackCopy);\n+\n+        if (!EvalScript(stackCopy, pubKey2, txTo, nIn, flags, nHashType))\n+            return false;\n+        if (stackCopy.empty())\n+            return false;\n+        return CastToBool(stackCopy.back());\n+    }\n+\n+    return true;\n+}\n+\n+\n+\n+\n+\n+namespace {\n+\n+/** Wrapper that serializes like CTransaction, but with the modifications\n+ *  required for the signature hash done in-place\n+ */\n+class CTransactionSignatureSerializer {\n+private:\n+    const CTransaction &txTo;  // reference to the spending transaction (the one being serialized)\n+    const CScript &scriptCode; // output script being consumed\n+    const unsigned int nIn;    // input index of txTo being signed\n+    const bool fAnyoneCanPay;  // whether the hashtype has the SIGHASH_ANYONECANPAY flag set\n+    const bool fHashSingle;    // whether the hashtype is SIGHASH_SINGLE\n+    const bool fHashNone;      // whether the hashtype is SIGHASH_NONE\n+\n+public:\n+    CTransactionSignatureSerializer(const CTransaction &txToIn, const CScript &scriptCodeIn, unsigned int nInIn, int nHashTypeIn) :\n+        txTo(txToIn), scriptCode(scriptCodeIn), nIn(nInIn),\n+        fAnyoneCanPay(!!(nHashTypeIn & SIGHASH_ANYONECANPAY)),\n+        fHashSingle((nHashTypeIn & 0x1f) == SIGHASH_SINGLE),\n+        fHashNone((nHashTypeIn & 0x1f) == SIGHASH_NONE) {}\n+\n+    /** Serialize the passed scriptCode, skipping OP_CODESEPARATORs */\n+    template<typename S>\n+    void SerializeScriptCode(S &s, int nType, int nVersion) const {\n+        CScript::const_iterator it = scriptCode.begin();\n+        CScript::const_iterator itBegin = it;\n+        opcodetype opcode;\n+        unsigned int nCodeSeparators = 0;\n+        while (scriptCode.GetOp(it, opcode)) {\n+            if (opcode == OP_CODESEPARATOR)\n+                nCodeSeparators++;\n+        }\n+        ::WriteCompactSize(s, scriptCode.size() - nCodeSeparators);\n+        it = itBegin;\n+        while (scriptCode.GetOp(it, opcode)) {\n+            if (opcode == OP_CODESEPARATOR) {\n+                s.write((char*)&itBegin[0], it-itBegin-1);\n+                itBegin = it;\n+            }\n+        }\n+        s.write((char*)&itBegin[0], it-itBegin);\n+    }\n+\n+    /** Serialize an input of txTo */\n+    template<typename S>\n+    void SerializeInput(S &s, unsigned int nInput, int nType, int nVersion) const {\n+        // In case of SIGHASH_ANYONECANPAY, only the input being signed is serialized\n+        if (fAnyoneCanPay)\n+            nInput = nIn;\n+        // Serialize the prevout\n+        ::Serialize(s, txTo.vin[nInput].prevout, nType, nVersion);\n+        // Serialize the script\n+        if (nInput != nIn)\n+            // Blank out other inputs' signatures\n+            ::Serialize(s, CScript(), nType, nVersion);\n+        else\n+            SerializeScriptCode(s, nType, nVersion);\n+        // Serialize the nSequence\n+        if (nInput != nIn && (fHashSingle || fHashNone))\n+            // let the others update at will\n+            ::Serialize(s, (int)0, nType, nVersion);\n+        else\n+            ::Serialize(s, txTo.vin[nInput].nSequence, nType, nVersion);\n+    }\n+\n+    /** Serialize an output of txTo */\n+    template<typename S>\n+    void SerializeOutput(S &s, unsigned int nOutput, int nType, int nVersion) const {\n+        if (fHashSingle && nOutput != nIn)\n+            // Do not lock-in the txout payee at other indices as txin\n+            ::Serialize(s, CTxOut(), nType, nVersion);\n+        else\n+            ::Serialize(s, txTo.vout[nOutput], nType, nVersion);\n+    }\n+\n+    /** Serialize txTo */\n+    template<typename S>\n+    void Serialize(S &s, int nType, int nVersion) const {\n+        // Serialize nVersion\n+        ::Serialize(s, txTo.nVersion, nType, nVersion);\n+        // Serialize vin\n+        unsigned int nInputs = fAnyoneCanPay ? 1 : txTo.vin.size();\n+        ::WriteCompactSize(s, nInputs);\n+        for (unsigned int nInput = 0; nInput < nInputs; nInput++)\n+             SerializeInput(s, nInput, nType, nVersion);\n+        // Serialize vout\n+        unsigned int nOutputs = fHashNone ? 0 : (fHashSingle ? nIn+1 : txTo.vout.size());\n+        ::WriteCompactSize(s, nOutputs);\n+        for (unsigned int nOutput = 0; nOutput < nOutputs; nOutput++)\n+             SerializeOutput(s, nOutput, nType, nVersion);\n+        // Serialie nLockTime\n+        ::Serialize(s, txTo.nLockTime, nType, nVersion);\n+    }\n+};\n+\n+} // anon namespace\n+\n+uint256 SignatureHash(const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType)\n+{\n+    if (nIn >= txTo.vin.size()) {\n+        LogPrintf(\"ERROR: SignatureHash() : nIn=%d out of range\\n\", nIn);\n+        return 1;\n+    }\n+\n+    // Check for invalid use of SIGHASH_SINGLE\n+    if ((nHashType & 0x1f) == SIGHASH_SINGLE) {\n+        if (nIn >= txTo.vout.size()) {\n+            LogPrintf(\"ERROR: SignatureHash() : nOut=%d out of range\\n\", nIn);\n+            return 1;\n+        }\n+    }\n+\n+    // Wrapper to serialize only the necessary parts of the transaction being signed\n+    CTransactionSignatureSerializer txTmp(txTo, scriptCode, nIn, nHashType);\n+\n+    // Serialize and hash\n+    CHashWriter ss(SER_GETHASH, 0);\n+    ss << txTmp << nHashType;\n+    return ss.GetHash();\n+}\n+\n+\n+\n+bool CScript::IsPayToScriptHash() const\n+{\n+    // Extra-fast test for pay-to-script-hash CScripts:\n+    return (this->size() == 23 &&\n+            this->at(0) == OP_HASH160 &&\n+            this->at(1) == 0x14 &&\n+            this->at(22) == OP_EQUAL);\n+}\n+\n+bool CScript::IsPushOnly() const\n+{\n+    const_iterator pc = begin();\n+    while (pc < end())\n+    {\n+        opcodetype opcode;\n+        if (!GetOp(pc, opcode))\n+            return false;\n+        // Note that IsPushOnly() *does* consider OP_RESERVED to be a\n+        // push-type opcode, however execution of OP_RESERVED fails, so\n+        // it's not relevant to P2SH as the scriptSig would fail prior to\n+        // the P2SH special validation code being executed.\n+        if (opcode > OP_16)\n+            return false;\n+    }\n+    return true;\n+}"
      },
      {
        "sha": "c7397ce7c7a0ccbefff3e474ffa7feb1ba20b374",
        "filename": "src/script/script.h",
        "status": "modified",
        "additions": 315,
        "deletions": 0,
        "changes": 315,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1dc9666c39ca532efad20a236923e0daa4c57921/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1dc9666c39ca532efad20a236923e0daa4c57921/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=1dc9666c39ca532efad20a236923e0daa4c57921",
        "patch": "@@ -1,7 +1,19 @@\n #ifndef H_BITCOIN_SCRIPT\n #define H_BITCOIN_SCRIPT\n \n+#include \"key.h\"\n+\n+#include <stdint.h>\n+#include <limits>\n #include <vector>\n+#include <string>\n+#include <stdexcept>\n+\n+#include <boost/foreach.hpp>\n+#include <boost/variant.hpp>\n+\n+static const unsigned int MAX_SCRIPT_ELEMENT_SIZE = 520; // bytes\n+static const unsigned int MAX_OP_RETURN_RELAY = 40;      // bytes\n \n /** Script verification flags (partially duplicated in bitcoinscript.h) */\n enum\n@@ -335,4 +347,307 @@ enum\n     SIGHASH_ANYONECANPAY = 0x80,\n };\n \n+class CNoDestination {\n+public:\n+    friend bool operator==(const CNoDestination &a, const CNoDestination &b) { return true; }\n+    friend bool operator<(const CNoDestination &a, const CNoDestination &b) { return true; }\n+};\n+\n+class CKeyID; class CScriptID;\n+/** A txout script template with a specific destination. It is either:\n+ *  * CNoDestination: no destination set\n+ *  * CKeyID: TX_PUBKEYHASH destination\n+ *  * CScriptID: TX_SCRIPTHASH destination\n+ *  A CTxDestination is the internal data type encoded in a CBitcoinAddress\n+ */\n+typedef boost::variant<CNoDestination, CKeyID, CScriptID> CTxDestination;\n+\n+/** Serialized script, used inside transaction inputs and outputs */\n+class CScript : public std::vector<unsigned char>\n+{\n+protected:\n+    CScript& push_int64(int64_t n)\n+    {\n+        if (n == -1 || (n >= 1 && n <= 16))\n+        {\n+            push_back(n + (OP_1 - 1));\n+        }\n+        else\n+        {\n+            *this << CScriptNum::serialize(n);\n+        }\n+        return *this;\n+    }\n+public:\n+    CScript() { }\n+    CScript(const CScript& b) : std::vector<unsigned char>(b.begin(), b.end()) { }\n+    CScript(const_iterator pbegin, const_iterator pend) : std::vector<unsigned char>(pbegin, pend) { }\n+#ifndef _MSC_VER\n+    CScript(const unsigned char* pbegin, const unsigned char* pend) : std::vector<unsigned char>(pbegin, pend) { }\n+#endif\n+\n+    CScript& operator+=(const CScript& b)\n+    {\n+        insert(end(), b.begin(), b.end());\n+        return *this;\n+    }\n+\n+    friend CScript operator+(const CScript& a, const CScript& b)\n+    {\n+        CScript ret = a;\n+        ret += b;\n+        return ret;\n+    }\n+\n+\n+    CScript(int64_t b)        { operator<<(b); }\n+\n+    explicit CScript(opcodetype b)     { operator<<(b); }\n+    explicit CScript(const uint256& b) { operator<<(b); }\n+    explicit CScript(const CScriptNum& b) { operator<<(b); }\n+    explicit CScript(const std::vector<unsigned char>& b) { operator<<(b); }\n+\n+\n+    CScript& operator<<(int64_t b) { return push_int64(b); }\n+\n+    CScript& operator<<(opcodetype opcode)\n+    {\n+        if (opcode < 0 || opcode > 0xff)\n+            throw std::runtime_error(\"CScript::operator<<() : invalid opcode\");\n+        insert(end(), (unsigned char)opcode);\n+        return *this;\n+    }\n+\n+    CScript& operator<<(const uint160& b)\n+    {\n+        insert(end(), sizeof(b));\n+        insert(end(), (unsigned char*)&b, (unsigned char*)&b + sizeof(b));\n+        return *this;\n+    }\n+\n+    CScript& operator<<(const uint256& b)\n+    {\n+        insert(end(), sizeof(b));\n+        insert(end(), (unsigned char*)&b, (unsigned char*)&b + sizeof(b));\n+        return *this;\n+    }\n+\n+    CScript& operator<<(const CPubKey& key)\n+    {\n+        assert(key.size() < OP_PUSHDATA1);\n+        insert(end(), (unsigned char)key.size());\n+        insert(end(), key.begin(), key.end());\n+        return *this;\n+    }\n+\n+    CScript& operator<<(const CScriptNum& b)\n+    {\n+        *this << b.getvch();\n+        return *this;\n+    }\n+\n+    CScript& operator<<(const std::vector<unsigned char>& b)\n+    {\n+        if (b.size() < OP_PUSHDATA1)\n+        {\n+            insert(end(), (unsigned char)b.size());\n+        }\n+        else if (b.size() <= 0xff)\n+        {\n+            insert(end(), OP_PUSHDATA1);\n+            insert(end(), (unsigned char)b.size());\n+        }\n+        else if (b.size() <= 0xffff)\n+        {\n+            insert(end(), OP_PUSHDATA2);\n+            unsigned short nSize = b.size();\n+            insert(end(), (unsigned char*)&nSize, (unsigned char*)&nSize + sizeof(nSize));\n+        }\n+        else\n+        {\n+            insert(end(), OP_PUSHDATA4);\n+            unsigned int nSize = b.size();\n+            insert(end(), (unsigned char*)&nSize, (unsigned char*)&nSize + sizeof(nSize));\n+        }\n+        insert(end(), b.begin(), b.end());\n+        return *this;\n+    }\n+\n+    CScript& operator<<(const CScript& b)\n+    {\n+        // I'm not sure if this should push the script or concatenate scripts.\n+        // If there's ever a use for pushing a script onto a script, delete this member fn\n+        assert(!\"Warning: Pushing a CScript onto a CScript with << is probably not intended, use + to concatenate!\");\n+        return *this;\n+    }\n+\n+\n+    bool GetOp(iterator& pc, opcodetype& opcodeRet, std::vector<unsigned char>& vchRet)\n+    {\n+         // Wrapper so it can be called with either iterator or const_iterator\n+         const_iterator pc2 = pc;\n+         bool fRet = GetOp2(pc2, opcodeRet, &vchRet);\n+         pc = begin() + (pc2 - begin());\n+         return fRet;\n+    }\n+\n+    bool GetOp(iterator& pc, opcodetype& opcodeRet)\n+    {\n+         const_iterator pc2 = pc;\n+         bool fRet = GetOp2(pc2, opcodeRet, NULL);\n+         pc = begin() + (pc2 - begin());\n+         return fRet;\n+    }\n+\n+    bool GetOp(const_iterator& pc, opcodetype& opcodeRet, std::vector<unsigned char>& vchRet) const\n+    {\n+        return GetOp2(pc, opcodeRet, &vchRet);\n+    }\n+\n+    bool GetOp(const_iterator& pc, opcodetype& opcodeRet) const\n+    {\n+        return GetOp2(pc, opcodeRet, NULL);\n+    }\n+\n+    bool GetOp2(const_iterator& pc, opcodetype& opcodeRet, std::vector<unsigned char>* pvchRet) const\n+    {\n+        opcodeRet = OP_INVALIDOPCODE;\n+        if (pvchRet)\n+            pvchRet->clear();\n+        if (pc >= end())\n+            return false;\n+\n+        // Read instruction\n+        if (end() - pc < 1)\n+            return false;\n+        unsigned int opcode = *pc++;\n+\n+        // Immediate operand\n+        if (opcode <= OP_PUSHDATA4)\n+        {\n+            unsigned int nSize = 0;\n+            if (opcode < OP_PUSHDATA1)\n+            {\n+                nSize = opcode;\n+            }\n+            else if (opcode == OP_PUSHDATA1)\n+            {\n+                if (end() - pc < 1)\n+                    return false;\n+                nSize = *pc++;\n+            }\n+            else if (opcode == OP_PUSHDATA2)\n+            {\n+                if (end() - pc < 2)\n+                    return false;\n+                nSize = 0;\n+                memcpy(&nSize, &pc[0], 2);\n+                pc += 2;\n+            }\n+            else if (opcode == OP_PUSHDATA4)\n+            {\n+                if (end() - pc < 4)\n+                    return false;\n+                memcpy(&nSize, &pc[0], 4);\n+                pc += 4;\n+            }\n+            if (end() - pc < 0 || (unsigned int)(end() - pc) < nSize)\n+                return false;\n+            if (pvchRet)\n+                pvchRet->assign(pc, pc + nSize);\n+            pc += nSize;\n+        }\n+\n+        opcodeRet = (opcodetype)opcode;\n+        return true;\n+    }\n+\n+    // Encode/decode small integers:\n+    static int DecodeOP_N(opcodetype opcode)\n+    {\n+        if (opcode == OP_0)\n+            return 0;\n+        assert(opcode >= OP_1 && opcode <= OP_16);\n+        return (int)opcode - (int)(OP_1 - 1);\n+    }\n+    static opcodetype EncodeOP_N(int n)\n+    {\n+        assert(n >= 0 && n <= 16);\n+        if (n == 0)\n+            return OP_0;\n+        return (opcodetype)(OP_1+n-1);\n+    }\n+\n+    int FindAndDelete(const CScript& b)\n+    {\n+        int nFound = 0;\n+        if (b.empty())\n+            return nFound;\n+        iterator pc = begin();\n+        opcodetype opcode;\n+        do\n+        {\n+            while (end() - pc >= (long)b.size() && memcmp(&pc[0], &b[0], b.size()) == 0)\n+            {\n+                erase(pc, pc + b.size());\n+                ++nFound;\n+            }\n+        }\n+        while (GetOp(pc, opcode));\n+        return nFound;\n+    }\n+    int Find(opcodetype op) const\n+    {\n+        int nFound = 0;\n+        opcodetype opcode;\n+        for (const_iterator pc = begin(); pc != end() && GetOp(pc, opcode);)\n+            if (opcode == op)\n+                ++nFound;\n+        return nFound;\n+    }\n+\n+    // Pre-version-0.6, Bitcoin always counted CHECKMULTISIGs\n+    // as 20 sigops. With pay-to-script-hash, that changed:\n+    // CHECKMULTISIGs serialized in scriptSigs are\n+    // counted more accurately, assuming they are of the form\n+    //  ... OP_N CHECKMULTISIG ...\n+    unsigned int GetSigOpCount(bool fAccurate) const;\n+\n+    // Accurately count sigOps, including sigOps in\n+    // pay-to-script-hash transactions:\n+    unsigned int GetSigOpCount(const CScript& scriptSig) const;\n+\n+    bool IsPayToScriptHash() const;\n+\n+    // Called by IsStandardTx and P2SH VerifyScript (which makes it consensus-critical).\n+    bool IsPushOnly() const;\n+\n+    // Called by IsStandardTx.\n+    bool HasCanonicalPushes() const;\n+\n+    // Returns whether the script is guaranteed to fail at execution,\n+    // regardless of the initial stack. This allows outputs to be pruned\n+    // instantly when entering the UTXO set.\n+    bool IsUnspendable() const\n+    {\n+        return (size() > 0 && *begin() == OP_RETURN);\n+    }\n+\n+    void SetDestination(const CTxDestination& address);\n+    void SetMultisig(int nRequired, const std::vector<CPubKey>& keys);\n+\n+    std::string ToString() const;\n+\n+    CScriptID GetID() const\n+    {\n+        return CScriptID(Hash160(*this));\n+    }\n+};\n+\n+\n+// Exposed only for testing\n+bool IsCanonicalPubKey(const std::vector<unsigned char> &vchPubKey, unsigned int flags);\n+bool IsCanonicalSignature(const std::vector<unsigned char> &vchSig, unsigned int flags);\n+\n+uint256 SignatureHash(const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n #endif"
      },
      {
        "sha": "4aa9ba91ad34b71795ca54d1df282c18eab45168",
        "filename": "src/script/standalone.cpp",
        "status": "added",
        "additions": 45,
        "deletions": 0,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1dc9666c39ca532efad20a236923e0daa4c57921/src/script/standalone.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1dc9666c39ca532efad20a236923e0daa4c57921/src/script/standalone.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standalone.cpp?ref=1dc9666c39ca532efad20a236923e0daa4c57921",
        "patch": "@@ -0,0 +1,45 @@\n+#include \"script.h\"\n+\n+using namespace std;\n+\n+// Same as scriptutils.cpp but without the CSignatureCache\n+bool CheckSig(vector<unsigned char> vchSig, const vector<unsigned char> &vchPubKey, const CScript &scriptCode,\n+              const CTransaction& txTo, unsigned int nIn, int nHashType, int flags)\n+{\n+    CPubKey pubkey(vchPubKey);\n+    if (!pubkey.IsValid())\n+        return false;\n+\n+    // Hash type is one byte tacked on to the end of the signature\n+    if (vchSig.empty())\n+        return false;\n+    if (nHashType == 0)\n+        nHashType = vchSig.back();\n+    else if (nHashType != vchSig.back())\n+        return false;\n+    vchSig.pop_back();\n+\n+    uint256 sighash = SignatureHash(scriptCode, txTo, nIn, nHashType);\n+\n+    if (!pubkey.Verify(sighash, vchSig))\n+        return false;\n+\n+    return true;\n+}\n+\n+int LogPrintStr(const string&)\n+{\n+    return 0;\n+}\n+\n+bool LogAcceptCategory(const char*)\n+{\n+    return false;\n+}\n+\n+int64_t GetTime()\n+{\n+    return time(NULL);\n+}\n+\n+"
      },
      {
        "sha": "fcb6c085f7d2bde4a2cf870e42bc4b0eb32e7cc7",
        "filename": "src/scriptutils.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 961,
        "changes": 992,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1dc9666c39ca532efad20a236923e0daa4c57921/src/scriptutils.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1dc9666c39ca532efad20a236923e0daa4c57921/src/scriptutils.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scriptutils.cpp?ref=1dc9666c39ca532efad20a236923e0daa4c57921",
        "patch": "@@ -25,46 +25,6 @@ using namespace std;\n using namespace boost;\n \n typedef vector<unsigned char> valtype;\n-static const valtype vchFalse(0);\n-static const valtype vchZero(0);\n-static const valtype vchTrue(1, 1);\n-static const CScriptNum bnZero(0);\n-static const CScriptNum bnOne(1);\n-static const CScriptNum bnFalse(0);\n-static const CScriptNum bnTrue(1);\n-\n-bool CheckSig(vector<unsigned char> vchSig, const vector<unsigned char> &vchPubKey, const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType, int flags);\n-\n-bool CastToBool(const valtype& vch)\n-{\n-    for (unsigned int i = 0; i < vch.size(); i++)\n-    {\n-        if (vch[i] != 0)\n-        {\n-            // Can be negative zero\n-            if (i == vch.size()-1 && vch[i] == 0x80)\n-                return false;\n-            return true;\n-        }\n-    }\n-    return false;\n-}\n-\n-\n-\n-//\n-// Script is a stack machine (like Forth) that evaluates a predicate\n-// returning a bool indicating valid or not.  There are no loops.\n-//\n-#define stacktop(i)  (stack.at(stack.size()+(i)))\n-#define altstacktop(i)  (altstack.at(altstack.size()+(i)))\n-static inline void popstack(vector<valtype>& stack)\n-{\n-    if (stack.empty())\n-        throw runtime_error(\"popstack() : stack empty\");\n-    stack.pop_back();\n-}\n-\n \n const char* GetTxnOutputType(txnouttype t)\n {\n@@ -224,876 +184,53 @@ const char* GetOpName(opcodetype opcode)\n     }\n }\n \n-bool IsCanonicalPubKey(const valtype &vchPubKey, unsigned int flags) {\n-    if (!(flags & SCRIPT_VERIFY_STRICTENC))\n-        return true;\n-\n-    if (vchPubKey.size() < 33)\n-        return error(\"Non-canonical public key: too short\");\n-    if (vchPubKey[0] == 0x04) {\n-        if (vchPubKey.size() != 65)\n-            return error(\"Non-canonical public key: invalid length for uncompressed key\");\n-    } else if (vchPubKey[0] == 0x02 || vchPubKey[0] == 0x03) {\n-        if (vchPubKey.size() != 33)\n-            return error(\"Non-canonical public key: invalid length for compressed key\");\n-    } else {\n-        return error(\"Non-canonical public key: compressed nor uncompressed\");\n-    }\n-    return true;\n+inline std::string ValueString(const std::vector<unsigned char>& vch)\n+{\n+    if (vch.size() <= 4)\n+        return strprintf(\"%d\", CScriptNum(vch).getint());\n+    else\n+        return HexStr(vch);\n }\n \n-bool IsCanonicalSignature(const valtype &vchSig, unsigned int flags) {\n-    if (!(flags & SCRIPT_VERIFY_STRICTENC))\n-        return true;\n-\n-    // See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623\n-    // A canonical signature exists of: <30> <total len> <02> <len R> <R> <02> <len S> <S> <hashtype>\n-    // Where R and S are not negative (their first byte has its highest bit not set), and not\n-    // excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,\n-    // in which case a single 0 byte is necessary and even required).\n-    if (vchSig.size() < 9)\n-        return error(\"Non-canonical signature: too short\");\n-    if (vchSig.size() > 73)\n-        return error(\"Non-canonical signature: too long\");\n-    unsigned char nHashType = vchSig[vchSig.size() - 1] & (~(SIGHASH_ANYONECANPAY));\n-    if (nHashType < SIGHASH_ALL || nHashType > SIGHASH_SINGLE)\n-        return error(\"Non-canonical signature: unknown hashtype byte\");\n-    if (vchSig[0] != 0x30)\n-        return error(\"Non-canonical signature: wrong type\");\n-    if (vchSig[1] != vchSig.size()-3)\n-        return error(\"Non-canonical signature: wrong length marker\");\n-    unsigned int nLenR = vchSig[3];\n-    if (5 + nLenR >= vchSig.size())\n-        return error(\"Non-canonical signature: S length misplaced\");\n-    unsigned int nLenS = vchSig[5+nLenR];\n-    if ((unsigned long)(nLenR+nLenS+7) != vchSig.size())\n-        return error(\"Non-canonical signature: R+S length mismatch\");\n-\n-    const unsigned char *R = &vchSig[4];\n-    if (R[-2] != 0x02)\n-        return error(\"Non-canonical signature: R value type mismatch\");\n-    if (nLenR == 0)\n-        return error(\"Non-canonical signature: R length is zero\");\n-    if (R[0] & 0x80)\n-        return error(\"Non-canonical signature: R value negative\");\n-    if (nLenR > 1 && (R[0] == 0x00) && !(R[1] & 0x80))\n-        return error(\"Non-canonical signature: R value excessively padded\");\n-\n-    const unsigned char *S = &vchSig[6+nLenR];\n-    if (S[-2] != 0x02)\n-        return error(\"Non-canonical signature: S value type mismatch\");\n-    if (nLenS == 0)\n-        return error(\"Non-canonical signature: S length is zero\");\n-    if (S[0] & 0x80)\n-        return error(\"Non-canonical signature: S value negative\");\n-    if (nLenS > 1 && (S[0] == 0x00) && !(S[1] & 0x80))\n-        return error(\"Non-canonical signature: S value excessively padded\");\n-\n-    if (flags & SCRIPT_VERIFY_LOW_S) {\n-        // If the S value is above the order of the curve divided by two, its\n-        // complement modulo the order could have been used instead, which is\n-        // one byte shorter when encoded correctly.\n-        if (!CKey::CheckSignatureElement(S, nLenS, true))\n-            return error(\"Non-canonical signature: S value is unnecessarily high\");\n+inline std::string StackString(const std::vector<std::vector<unsigned char> >& vStack)\n+{\n+    std::string str;\n+    BOOST_FOREACH(const std::vector<unsigned char>& vch, vStack)\n+    {\n+        if (!str.empty())\n+            str += \" \";\n+        str += ValueString(vch);\n     }\n-\n-    return true;\n+    return str;\n }\n \n-bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, unsigned int flags, int nHashType)\n+string CScript::ToString() const\n {\n-    CScript::const_iterator pc = script.begin();\n-    CScript::const_iterator pend = script.end();\n-    CScript::const_iterator pbegincodehash = script.begin();\n+    std::string str;\n     opcodetype opcode;\n-    valtype vchPushValue;\n-    vector<bool> vfExec;\n-    vector<valtype> altstack;\n-    if (script.size() > 10000)\n-        return false;\n-    int nOpCount = 0;\n-\n-    try\n+    std::vector<unsigned char> vch;\n+    const_iterator pc = begin();\n+    while (pc < end())\n     {\n-        while (pc < pend)\n+        if (!str.empty())\n+            str += \" \";\n+        if (!GetOp(pc, opcode, vch))\n         {\n-            bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n-\n-            //\n-            // Read instruction\n-            //\n-            if (!script.GetOp(pc, opcode, vchPushValue))\n-                return false;\n-            if (vchPushValue.size() > MAX_SCRIPT_ELEMENT_SIZE)\n-                return false;\n-\n-            // Note how OP_RESERVED does not count towards the opcode limit.\n-            if (opcode > OP_16 && ++nOpCount > 201)\n-                return false;\n-\n-            if (opcode == OP_CAT ||\n-                opcode == OP_SUBSTR ||\n-                opcode == OP_LEFT ||\n-                opcode == OP_RIGHT ||\n-                opcode == OP_INVERT ||\n-                opcode == OP_AND ||\n-                opcode == OP_OR ||\n-                opcode == OP_XOR ||\n-                opcode == OP_2MUL ||\n-                opcode == OP_2DIV ||\n-                opcode == OP_MUL ||\n-                opcode == OP_DIV ||\n-                opcode == OP_MOD ||\n-                opcode == OP_LSHIFT ||\n-                opcode == OP_RSHIFT)\n-                return false; // Disabled opcodes.\n-\n-            if (fExec && 0 <= opcode && opcode <= OP_PUSHDATA4)\n-                stack.push_back(vchPushValue);\n-            else if (fExec || (OP_IF <= opcode && opcode <= OP_ENDIF))\n-            switch (opcode)\n-            {\n-                //\n-                // Push value\n-                //\n-                case OP_1NEGATE:\n-                case OP_1:\n-                case OP_2:\n-                case OP_3:\n-                case OP_4:\n-                case OP_5:\n-                case OP_6:\n-                case OP_7:\n-                case OP_8:\n-                case OP_9:\n-                case OP_10:\n-                case OP_11:\n-                case OP_12:\n-                case OP_13:\n-                case OP_14:\n-                case OP_15:\n-                case OP_16:\n-                {\n-                    // ( -- value)\n-                    CScriptNum bn((int)opcode - (int)(OP_1 - 1));\n-                    stack.push_back(bn.getvch());\n-                }\n-                break;\n-\n-\n-                //\n-                // Control\n-                //\n-                case OP_NOP:\n-                case OP_NOP1: case OP_NOP2: case OP_NOP3: case OP_NOP4: case OP_NOP5:\n-                case OP_NOP6: case OP_NOP7: case OP_NOP8: case OP_NOP9: case OP_NOP10:\n-                break;\n-\n-                case OP_IF:\n-                case OP_NOTIF:\n-                {\n-                    // <expression> if [statements] [else [statements]] endif\n-                    bool fValue = false;\n-                    if (fExec)\n-                    {\n-                        if (stack.size() < 1)\n-                            return false;\n-                        valtype& vch = stacktop(-1);\n-                        fValue = CastToBool(vch);\n-                        if (opcode == OP_NOTIF)\n-                            fValue = !fValue;\n-                        popstack(stack);\n-                    }\n-                    vfExec.push_back(fValue);\n-                }\n-                break;\n-\n-                case OP_ELSE:\n-                {\n-                    if (vfExec.empty())\n-                        return false;\n-                    vfExec.back() = !vfExec.back();\n-                }\n-                break;\n-\n-                case OP_ENDIF:\n-                {\n-                    if (vfExec.empty())\n-                        return false;\n-                    vfExec.pop_back();\n-                }\n-                break;\n-\n-                case OP_VERIFY:\n-                {\n-                    // (true -- ) or\n-                    // (false -- false) and return\n-                    if (stack.size() < 1)\n-                        return false;\n-                    bool fValue = CastToBool(stacktop(-1));\n-                    if (fValue)\n-                        popstack(stack);\n-                    else\n-                        return false;\n-                }\n-                break;\n-\n-                case OP_RETURN:\n-                {\n-                    return false;\n-                }\n-                break;\n-\n-\n-                //\n-                // Stack ops\n-                //\n-                case OP_TOALTSTACK:\n-                {\n-                    if (stack.size() < 1)\n-                        return false;\n-                    altstack.push_back(stacktop(-1));\n-                    popstack(stack);\n-                }\n-                break;\n-\n-                case OP_FROMALTSTACK:\n-                {\n-                    if (altstack.size() < 1)\n-                        return false;\n-                    stack.push_back(altstacktop(-1));\n-                    popstack(altstack);\n-                }\n-                break;\n-\n-                case OP_2DROP:\n-                {\n-                    // (x1 x2 -- )\n-                    if (stack.size() < 2)\n-                        return false;\n-                    popstack(stack);\n-                    popstack(stack);\n-                }\n-                break;\n-\n-                case OP_2DUP:\n-                {\n-                    // (x1 x2 -- x1 x2 x1 x2)\n-                    if (stack.size() < 2)\n-                        return false;\n-                    valtype vch1 = stacktop(-2);\n-                    valtype vch2 = stacktop(-1);\n-                    stack.push_back(vch1);\n-                    stack.push_back(vch2);\n-                }\n-                break;\n-\n-                case OP_3DUP:\n-                {\n-                    // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n-                    if (stack.size() < 3)\n-                        return false;\n-                    valtype vch1 = stacktop(-3);\n-                    valtype vch2 = stacktop(-2);\n-                    valtype vch3 = stacktop(-1);\n-                    stack.push_back(vch1);\n-                    stack.push_back(vch2);\n-                    stack.push_back(vch3);\n-                }\n-                break;\n-\n-                case OP_2OVER:\n-                {\n-                    // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n-                    if (stack.size() < 4)\n-                        return false;\n-                    valtype vch1 = stacktop(-4);\n-                    valtype vch2 = stacktop(-3);\n-                    stack.push_back(vch1);\n-                    stack.push_back(vch2);\n-                }\n-                break;\n-\n-                case OP_2ROT:\n-                {\n-                    // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n-                    if (stack.size() < 6)\n-                        return false;\n-                    valtype vch1 = stacktop(-6);\n-                    valtype vch2 = stacktop(-5);\n-                    stack.erase(stack.end()-6, stack.end()-4);\n-                    stack.push_back(vch1);\n-                    stack.push_back(vch2);\n-                }\n-                break;\n-\n-                case OP_2SWAP:\n-                {\n-                    // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n-                    if (stack.size() < 4)\n-                        return false;\n-                    swap(stacktop(-4), stacktop(-2));\n-                    swap(stacktop(-3), stacktop(-1));\n-                }\n-                break;\n-\n-                case OP_IFDUP:\n-                {\n-                    // (x - 0 | x x)\n-                    if (stack.size() < 1)\n-                        return false;\n-                    valtype vch = stacktop(-1);\n-                    if (CastToBool(vch))\n-                        stack.push_back(vch);\n-                }\n-                break;\n-\n-                case OP_DEPTH:\n-                {\n-                    // -- stacksize\n-                    CScriptNum bn(stack.size());\n-                    stack.push_back(bn.getvch());\n-                }\n-                break;\n-\n-                case OP_DROP:\n-                {\n-                    // (x -- )\n-                    if (stack.size() < 1)\n-                        return false;\n-                    popstack(stack);\n-                }\n-                break;\n-\n-                case OP_DUP:\n-                {\n-                    // (x -- x x)\n-                    if (stack.size() < 1)\n-                        return false;\n-                    valtype vch = stacktop(-1);\n-                    stack.push_back(vch);\n-                }\n-                break;\n-\n-                case OP_NIP:\n-                {\n-                    // (x1 x2 -- x2)\n-                    if (stack.size() < 2)\n-                        return false;\n-                    stack.erase(stack.end() - 2);\n-                }\n-                break;\n-\n-                case OP_OVER:\n-                {\n-                    // (x1 x2 -- x1 x2 x1)\n-                    if (stack.size() < 2)\n-                        return false;\n-                    valtype vch = stacktop(-2);\n-                    stack.push_back(vch);\n-                }\n-                break;\n-\n-                case OP_PICK:\n-                case OP_ROLL:\n-                {\n-                    // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n-                    // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n-                    if (stack.size() < 2)\n-                        return false;\n-                    int n = CScriptNum(stacktop(-1)).getint();\n-                    popstack(stack);\n-                    if (n < 0 || n >= (int)stack.size())\n-                        return false;\n-                    valtype vch = stacktop(-n-1);\n-                    if (opcode == OP_ROLL)\n-                        stack.erase(stack.end()-n-1);\n-                    stack.push_back(vch);\n-                }\n-                break;\n-\n-                case OP_ROT:\n-                {\n-                    // (x1 x2 x3 -- x2 x3 x1)\n-                    //  x2 x1 x3  after first swap\n-                    //  x2 x3 x1  after second swap\n-                    if (stack.size() < 3)\n-                        return false;\n-                    swap(stacktop(-3), stacktop(-2));\n-                    swap(stacktop(-2), stacktop(-1));\n-                }\n-                break;\n-\n-                case OP_SWAP:\n-                {\n-                    // (x1 x2 -- x2 x1)\n-                    if (stack.size() < 2)\n-                        return false;\n-                    swap(stacktop(-2), stacktop(-1));\n-                }\n-                break;\n-\n-                case OP_TUCK:\n-                {\n-                    // (x1 x2 -- x2 x1 x2)\n-                    if (stack.size() < 2)\n-                        return false;\n-                    valtype vch = stacktop(-1);\n-                    stack.insert(stack.end()-2, vch);\n-                }\n-                break;\n-\n-\n-                case OP_SIZE:\n-                {\n-                    // (in -- in size)\n-                    if (stack.size() < 1)\n-                        return false;\n-                    CScriptNum bn(stacktop(-1).size());\n-                    stack.push_back(bn.getvch());\n-                }\n-                break;\n-\n-\n-                //\n-                // Bitwise logic\n-                //\n-                case OP_EQUAL:\n-                case OP_EQUALVERIFY:\n-                //case OP_NOTEQUAL: // use OP_NUMNOTEQUAL\n-                {\n-                    // (x1 x2 - bool)\n-                    if (stack.size() < 2)\n-                        return false;\n-                    valtype& vch1 = stacktop(-2);\n-                    valtype& vch2 = stacktop(-1);\n-                    bool fEqual = (vch1 == vch2);\n-                    // OP_NOTEQUAL is disabled because it would be too easy to say\n-                    // something like n != 1 and have some wiseguy pass in 1 with extra\n-                    // zero bytes after it (numerically, 0x01 == 0x0001 == 0x000001)\n-                    //if (opcode == OP_NOTEQUAL)\n-                    //    fEqual = !fEqual;\n-                    popstack(stack);\n-                    popstack(stack);\n-                    stack.push_back(fEqual ? vchTrue : vchFalse);\n-                    if (opcode == OP_EQUALVERIFY)\n-                    {\n-                        if (fEqual)\n-                            popstack(stack);\n-                        else\n-                            return false;\n-                    }\n-                }\n-                break;\n-\n-\n-                //\n-                // Numeric\n-                //\n-                case OP_1ADD:\n-                case OP_1SUB:\n-                case OP_NEGATE:\n-                case OP_ABS:\n-                case OP_NOT:\n-                case OP_0NOTEQUAL:\n-                {\n-                    // (in -- out)\n-                    if (stack.size() < 1)\n-                        return false;\n-                    CScriptNum bn(stacktop(-1));\n-                    switch (opcode)\n-                    {\n-                    case OP_1ADD:       bn += bnOne; break;\n-                    case OP_1SUB:       bn -= bnOne; break;\n-                    case OP_NEGATE:     bn = -bn; break;\n-                    case OP_ABS:        if (bn < bnZero) bn = -bn; break;\n-                    case OP_NOT:        bn = (bn == bnZero); break;\n-                    case OP_0NOTEQUAL:  bn = (bn != bnZero); break;\n-                    default:            assert(!\"invalid opcode\"); break;\n-                    }\n-                    popstack(stack);\n-                    stack.push_back(bn.getvch());\n-                }\n-                break;\n-\n-                case OP_ADD:\n-                case OP_SUB:\n-                case OP_BOOLAND:\n-                case OP_BOOLOR:\n-                case OP_NUMEQUAL:\n-                case OP_NUMEQUALVERIFY:\n-                case OP_NUMNOTEQUAL:\n-                case OP_LESSTHAN:\n-                case OP_GREATERTHAN:\n-                case OP_LESSTHANOREQUAL:\n-                case OP_GREATERTHANOREQUAL:\n-                case OP_MIN:\n-                case OP_MAX:\n-                {\n-                    // (x1 x2 -- out)\n-                    if (stack.size() < 2)\n-                        return false;\n-                    CScriptNum bn1(stacktop(-2));\n-                    CScriptNum bn2(stacktop(-1));\n-                    CScriptNum bn(0);\n-                    switch (opcode)\n-                    {\n-                    case OP_ADD:\n-                        bn = bn1 + bn2;\n-                        break;\n-\n-                    case OP_SUB:\n-                        bn = bn1 - bn2;\n-                        break;\n-\n-                    case OP_BOOLAND:             bn = (bn1 != bnZero && bn2 != bnZero); break;\n-                    case OP_BOOLOR:              bn = (bn1 != bnZero || bn2 != bnZero); break;\n-                    case OP_NUMEQUAL:            bn = (bn1 == bn2); break;\n-                    case OP_NUMEQUALVERIFY:      bn = (bn1 == bn2); break;\n-                    case OP_NUMNOTEQUAL:         bn = (bn1 != bn2); break;\n-                    case OP_LESSTHAN:            bn = (bn1 < bn2); break;\n-                    case OP_GREATERTHAN:         bn = (bn1 > bn2); break;\n-                    case OP_LESSTHANOREQUAL:     bn = (bn1 <= bn2); break;\n-                    case OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n-                    case OP_MIN:                 bn = (bn1 < bn2 ? bn1 : bn2); break;\n-                    case OP_MAX:                 bn = (bn1 > bn2 ? bn1 : bn2); break;\n-                    default:                     assert(!\"invalid opcode\"); break;\n-                    }\n-                    popstack(stack);\n-                    popstack(stack);\n-                    stack.push_back(bn.getvch());\n-\n-                    if (opcode == OP_NUMEQUALVERIFY)\n-                    {\n-                        if (CastToBool(stacktop(-1)))\n-                            popstack(stack);\n-                        else\n-                            return false;\n-                    }\n-                }\n-                break;\n-\n-                case OP_WITHIN:\n-                {\n-                    // (x min max -- out)\n-                    if (stack.size() < 3)\n-                        return false;\n-                    CScriptNum bn1(stacktop(-3));\n-                    CScriptNum bn2(stacktop(-2));\n-                    CScriptNum bn3(stacktop(-1));\n-                    bool fValue = (bn2 <= bn1 && bn1 < bn3);\n-                    popstack(stack);\n-                    popstack(stack);\n-                    popstack(stack);\n-                    stack.push_back(fValue ? vchTrue : vchFalse);\n-                }\n-                break;\n-\n-\n-                //\n-                // Crypto\n-                //\n-                case OP_RIPEMD160:\n-                case OP_SHA1:\n-                case OP_SHA256:\n-                case OP_HASH160:\n-                case OP_HASH256:\n-                {\n-                    // (in -- hash)\n-                    if (stack.size() < 1)\n-                        return false;\n-                    valtype& vch = stacktop(-1);\n-                    valtype vchHash((opcode == OP_RIPEMD160 || opcode == OP_SHA1 || opcode == OP_HASH160) ? 20 : 32);\n-                    if (opcode == OP_RIPEMD160)\n-                        CRIPEMD160().Write(&vch[0], vch.size()).Finalize(&vchHash[0]);\n-                    else if (opcode == OP_SHA1)\n-                        CSHA1().Write(&vch[0], vch.size()).Finalize(&vchHash[0]);\n-                    else if (opcode == OP_SHA256)\n-                        CSHA256().Write(&vch[0], vch.size()).Finalize(&vchHash[0]);\n-                    else if (opcode == OP_HASH160)\n-                        CHash160().Write(&vch[0], vch.size()).Finalize(&vchHash[0]);\n-                    else if (opcode == OP_HASH256)\n-                        CHash256().Write(&vch[0], vch.size()).Finalize(&vchHash[0]);\n-                    popstack(stack);\n-                    stack.push_back(vchHash);\n-                }\n-                break;\n-\n-                case OP_CODESEPARATOR:\n-                {\n-                    // Hash starts after the code separator\n-                    pbegincodehash = pc;\n-                }\n-                break;\n-\n-                case OP_CHECKSIG:\n-                case OP_CHECKSIGVERIFY:\n-                {\n-                    // (sig pubkey -- bool)\n-                    if (stack.size() < 2)\n-                        return false;\n-\n-                    valtype& vchSig    = stacktop(-2);\n-                    valtype& vchPubKey = stacktop(-1);\n-\n-                    // Subset of script starting at the most recent codeseparator\n-                    CScript scriptCode(pbegincodehash, pend);\n-\n-                    // Drop the signature, since there's no way for a signature to sign itself\n-                    scriptCode.FindAndDelete(CScript(vchSig));\n-\n-                    bool fSuccess = IsCanonicalSignature(vchSig, flags) && IsCanonicalPubKey(vchPubKey, flags) &&\n-                        CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType, flags);\n-\n-                    popstack(stack);\n-                    popstack(stack);\n-                    stack.push_back(fSuccess ? vchTrue : vchFalse);\n-                    if (opcode == OP_CHECKSIGVERIFY)\n-                    {\n-                        if (fSuccess)\n-                            popstack(stack);\n-                        else\n-                            return false;\n-                    }\n-                }\n-                break;\n-\n-                case OP_CHECKMULTISIG:\n-                case OP_CHECKMULTISIGVERIFY:\n-                {\n-                    // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n-\n-                    int i = 1;\n-                    if ((int)stack.size() < i)\n-                        return false;\n-\n-                    int nKeysCount = CScriptNum(stacktop(-i)).getint();\n-                    if (nKeysCount < 0 || nKeysCount > 20)\n-                        return false;\n-                    nOpCount += nKeysCount;\n-                    if (nOpCount > 201)\n-                        return false;\n-                    int ikey = ++i;\n-                    i += nKeysCount;\n-                    if ((int)stack.size() < i)\n-                        return false;\n-\n-                    int nSigsCount = CScriptNum(stacktop(-i)).getint();\n-                    if (nSigsCount < 0 || nSigsCount > nKeysCount)\n-                        return false;\n-                    int isig = ++i;\n-                    i += nSigsCount;\n-                    if ((int)stack.size() < i)\n-                        return false;\n-\n-                    // Subset of script starting at the most recent codeseparator\n-                    CScript scriptCode(pbegincodehash, pend);\n-\n-                    // Drop the signatures, since there's no way for a signature to sign itself\n-                    for (int k = 0; k < nSigsCount; k++)\n-                    {\n-                        valtype& vchSig = stacktop(-isig-k);\n-                        scriptCode.FindAndDelete(CScript(vchSig));\n-                    }\n-\n-                    bool fSuccess = true;\n-                    while (fSuccess && nSigsCount > 0)\n-                    {\n-                        valtype& vchSig    = stacktop(-isig);\n-                        valtype& vchPubKey = stacktop(-ikey);\n-\n-                        // Check signature\n-                        bool fOk = IsCanonicalSignature(vchSig, flags) && IsCanonicalPubKey(vchPubKey, flags) &&\n-                            CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType, flags);\n-\n-                        if (fOk) {\n-                            isig++;\n-                            nSigsCount--;\n-                        }\n-                        ikey++;\n-                        nKeysCount--;\n-\n-                        // If there are more signatures left than keys left,\n-                        // then too many signatures have failed\n-                        if (nSigsCount > nKeysCount)\n-                            fSuccess = false;\n-                    }\n-\n-                    // Clean up stack of actual arguments\n-                    while (i-- > 1)\n-                        popstack(stack);\n-\n-                    // A bug causes CHECKMULTISIG to consume one extra argument\n-                    // whose contents were not checked in any way.\n-                    //\n-                    // Unfortunately this is a potential source of mutability,\n-                    // so optionally verify it is exactly equal to zero prior\n-                    // to removing it from the stack.\n-                    if (stack.size() < 1)\n-                        return false;\n-                    if ((flags & SCRIPT_VERIFY_NULLDUMMY) && stacktop(-1).size())\n-                        return error(\"CHECKMULTISIG dummy argument not null\");\n-                    popstack(stack);\n-\n-                    stack.push_back(fSuccess ? vchTrue : vchFalse);\n-\n-                    if (opcode == OP_CHECKMULTISIGVERIFY)\n-                    {\n-                        if (fSuccess)\n-                            popstack(stack);\n-                        else\n-                            return false;\n-                    }\n-                }\n-                break;\n-\n-                default:\n-                    return false;\n-            }\n-\n-            // Size limits\n-            if (stack.size() + altstack.size() > 1000)\n-                return false;\n+            str += \"[error]\";\n+            return str;\n         }\n-    }\n-    catch (...)\n-    {\n-        return false;\n-    }\n-\n-\n-    if (!vfExec.empty())\n-        return false;\n-\n-    return true;\n-}\n-\n-\n-\n-\n-\n-\n-\n-namespace {\n-\n-/** Wrapper that serializes like CTransaction, but with the modifications\n- *  required for the signature hash done in-place\n- */\n-class CTransactionSignatureSerializer {\n-private:\n-    const CTransaction &txTo;  // reference to the spending transaction (the one being serialized)\n-    const CScript &scriptCode; // output script being consumed\n-    const unsigned int nIn;    // input index of txTo being signed\n-    const bool fAnyoneCanPay;  // whether the hashtype has the SIGHASH_ANYONECANPAY flag set\n-    const bool fHashSingle;    // whether the hashtype is SIGHASH_SINGLE\n-    const bool fHashNone;      // whether the hashtype is SIGHASH_NONE\n-\n-public:\n-    CTransactionSignatureSerializer(const CTransaction &txToIn, const CScript &scriptCodeIn, unsigned int nInIn, int nHashTypeIn) :\n-        txTo(txToIn), scriptCode(scriptCodeIn), nIn(nInIn),\n-        fAnyoneCanPay(!!(nHashTypeIn & SIGHASH_ANYONECANPAY)),\n-        fHashSingle((nHashTypeIn & 0x1f) == SIGHASH_SINGLE),\n-        fHashNone((nHashTypeIn & 0x1f) == SIGHASH_NONE) {}\n-\n-    /** Serialize the passed scriptCode, skipping OP_CODESEPARATORs */\n-    template<typename S>\n-    void SerializeScriptCode(S &s, int nType, int nVersion) const {\n-        CScript::const_iterator it = scriptCode.begin();\n-        CScript::const_iterator itBegin = it;\n-        opcodetype opcode;\n-        unsigned int nCodeSeparators = 0;\n-        while (scriptCode.GetOp(it, opcode)) {\n-            if (opcode == OP_CODESEPARATOR)\n-                nCodeSeparators++;\n-        }\n-        ::WriteCompactSize(s, scriptCode.size() - nCodeSeparators);\n-        it = itBegin;\n-        while (scriptCode.GetOp(it, opcode)) {\n-            if (opcode == OP_CODESEPARATOR) {\n-                s.write((char*)&itBegin[0], it-itBegin-1);\n-                itBegin = it;\n-            }\n-        }\n-        s.write((char*)&itBegin[0], it-itBegin);\n-    }\n-\n-    /** Serialize an input of txTo */\n-    template<typename S>\n-    void SerializeInput(S &s, unsigned int nInput, int nType, int nVersion) const {\n-        // In case of SIGHASH_ANYONECANPAY, only the input being signed is serialized\n-        if (fAnyoneCanPay)\n-            nInput = nIn;\n-        // Serialize the prevout\n-        ::Serialize(s, txTo.vin[nInput].prevout, nType, nVersion);\n-        // Serialize the script\n-        if (nInput != nIn)\n-            // Blank out other inputs' signatures\n-            ::Serialize(s, CScript(), nType, nVersion);\n+        if (0 <= opcode && opcode <= OP_PUSHDATA4)\n+            str += ValueString(vch);\n         else\n-            SerializeScriptCode(s, nType, nVersion);\n-        // Serialize the nSequence\n-        if (nInput != nIn && (fHashSingle || fHashNone))\n-            // let the others update at will\n-            ::Serialize(s, (int)0, nType, nVersion);\n-        else\n-            ::Serialize(s, txTo.vin[nInput].nSequence, nType, nVersion);\n+            str += GetOpName(opcode);\n     }\n+    return str;\n+}\n \n-    /** Serialize an output of txTo */\n-    template<typename S>\n-    void SerializeOutput(S &s, unsigned int nOutput, int nType, int nVersion) const {\n-        if (fHashSingle && nOutput != nIn)\n-            // Do not lock-in the txout payee at other indices as txin\n-            ::Serialize(s, CTxOut(), nType, nVersion);\n-        else\n-            ::Serialize(s, txTo.vout[nOutput], nType, nVersion);\n-    }\n \n-    /** Serialize txTo */\n-    template<typename S>\n-    void Serialize(S &s, int nType, int nVersion) const {\n-        // Serialize nVersion\n-        ::Serialize(s, txTo.nVersion, nType, nVersion);\n-        // Serialize vin\n-        unsigned int nInputs = fAnyoneCanPay ? 1 : txTo.vin.size();\n-        ::WriteCompactSize(s, nInputs);\n-        for (unsigned int nInput = 0; nInput < nInputs; nInput++)\n-             SerializeInput(s, nInput, nType, nVersion);\n-        // Serialize vout\n-        unsigned int nOutputs = fHashNone ? 0 : (fHashSingle ? nIn+1 : txTo.vout.size());\n-        ::WriteCompactSize(s, nOutputs);\n-        for (unsigned int nOutput = 0; nOutput < nOutputs; nOutput++)\n-             SerializeOutput(s, nOutput, nType, nVersion);\n-        // Serialie nLockTime\n-        ::Serialize(s, txTo.nLockTime, nType, nVersion);\n-    }\n-};\n \n-} // anon namespace\n \n-uint256 SignatureHash(const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType)\n-{\n-    if (nIn >= txTo.vin.size()) {\n-        LogPrintf(\"ERROR: SignatureHash() : nIn=%d out of range\\n\", nIn);\n-        return 1;\n-    }\n \n-    // Check for invalid use of SIGHASH_SINGLE\n-    if ((nHashType & 0x1f) == SIGHASH_SINGLE) {\n-        if (nIn >= txTo.vout.size()) {\n-            LogPrintf(\"ERROR: SignatureHash() : nOut=%d out of range\\n\", nIn);\n-            return 1;\n-        }\n-    }\n-\n-    // Wrapper to serialize only the necessary parts of the transaction being signed\n-    CTransactionSignatureSerializer txTmp(txTo, scriptCode, nIn, nHashType);\n-\n-    // Serialize and hash\n-    CHashWriter ss(SER_GETHASH, 0);\n-    ss << txTmp << nHashType;\n-    return ss.GetHash();\n-}\n \n // Valid signature cache, to avoid doing expensive ECDSA signature checking\n // twice for every transaction (once when accepted into memory pool, and\n@@ -1150,6 +287,7 @@ class CSignatureCache\n     }\n };\n \n+// Same as script/standalone.cpp but with the CSignatureCache\n bool CheckSig(vector<unsigned char> vchSig, const vector<unsigned char> &vchPubKey, const CScript &scriptCode,\n               const CTransaction& txTo, unsigned int nIn, int nHashType, int flags)\n {\n@@ -1602,47 +740,6 @@ void ExtractAffectedKeys(const CKeyStore &keystore, const CScript& scriptPubKey,\n     CAffectedKeysVisitor(keystore, vKeys).Process(scriptPubKey);\n }\n \n-bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n-                  unsigned int flags, int nHashType)\n-{\n-    vector<vector<unsigned char> > stack, stackCopy;\n-    if (!EvalScript(stack, scriptSig, txTo, nIn, flags, nHashType))\n-        return false;\n-    if (flags & SCRIPT_VERIFY_P2SH)\n-        stackCopy = stack;\n-    if (!EvalScript(stack, scriptPubKey, txTo, nIn, flags, nHashType))\n-        return false;\n-    if (stack.empty())\n-        return false;\n-\n-    if (CastToBool(stack.back()) == false)\n-        return false;\n-\n-    // Additional validation for spend-to-script-hash transactions:\n-    if ((flags & SCRIPT_VERIFY_P2SH) && scriptPubKey.IsPayToScriptHash())\n-    {\n-        if (!scriptSig.IsPushOnly()) // scriptSig must be literals-only\n-            return false;            // or validation fails\n-\n-        // stackCopy cannot be empty here, because if it was the\n-        // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with\n-        // an empty stack and the EvalScript above would return false.\n-        assert(!stackCopy.empty());\n-\n-        const valtype& pubKeySerialized = stackCopy.back();\n-        CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end());\n-        popstack(stackCopy);\n-\n-        if (!EvalScript(stackCopy, pubKey2, txTo, nIn, flags, nHashType))\n-            return false;\n-        if (stackCopy.empty())\n-            return false;\n-        return CastToBool(stackCopy.back());\n-    }\n-\n-    return true;\n-}\n-\n \n bool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, int nHashType)\n {\n@@ -1860,33 +957,6 @@ unsigned int CScript::GetSigOpCount(const CScript& scriptSig) const\n     return subscript.GetSigOpCount(true);\n }\n \n-bool CScript::IsPayToScriptHash() const\n-{\n-    // Extra-fast test for pay-to-script-hash CScripts:\n-    return (this->size() == 23 &&\n-            this->at(0) == OP_HASH160 &&\n-            this->at(1) == 0x14 &&\n-            this->at(22) == OP_EQUAL);\n-}\n-\n-bool CScript::IsPushOnly() const\n-{\n-    const_iterator pc = begin();\n-    while (pc < end())\n-    {\n-        opcodetype opcode;\n-        if (!GetOp(pc, opcode))\n-            return false;\n-        // Note that IsPushOnly() *does* consider OP_RESERVED to be a\n-        // push-type opcode, however execution of OP_RESERVED fails, so\n-        // it's not relevant to P2SH as the scriptSig would fail prior to\n-        // the P2SH special validation code being executed.\n-        if (opcode > OP_16)\n-            return false;\n-    }\n-    return true;\n-}\n-\n bool CScript::HasCanonicalPushes() const\n {\n     const_iterator pc = begin();"
      },
      {
        "sha": "240dddbed750ca987774fb9a81b53a2b5639c2bc",
        "filename": "src/scriptutils.h",
        "status": "modified",
        "additions": 1,
        "deletions": 348,
        "changes": 349,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1dc9666c39ca532efad20a236923e0daa4c57921/src/scriptutils.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1dc9666c39ca532efad20a236923e0daa4c57921/src/scriptutils.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scriptutils.h?ref=1dc9666c39ca532efad20a236923e0daa4c57921",
        "patch": "@@ -10,7 +10,6 @@\n #include \"util.h\"\n #include \"script/script.h\"\n \n-#include <stdexcept>\n #include <stdint.h>\n #include <string>\n #include <vector>\n@@ -23,9 +22,6 @@ class CKeyStore;\n class CTransaction;\n struct CMutableTransaction;\n \n-static const unsigned int MAX_SCRIPT_ELEMENT_SIZE = 520; // bytes\n-static const unsigned int MAX_OP_RETURN_RELAY = 40;      // bytes\n-\n /** IsMine() return codes */\n enum isminetype\n {\n@@ -51,356 +47,16 @@ enum txnouttype\n     TX_NULL_DATA,\n };\n \n-class CNoDestination {\n-public:\n-    friend bool operator==(const CNoDestination &a, const CNoDestination &b) { return true; }\n-    friend bool operator<(const CNoDestination &a, const CNoDestination &b) { return true; }\n-};\n-\n-/** A txout script template with a specific destination. It is either:\n- *  * CNoDestination: no destination set\n- *  * CKeyID: TX_PUBKEYHASH destination\n- *  * CScriptID: TX_SCRIPTHASH destination\n- *  A CTxDestination is the internal data type encoded in a CBitcoinAddress\n- */\n-typedef boost::variant<CNoDestination, CKeyID, CScriptID> CTxDestination;\n-\n const char* GetTxnOutputType(txnouttype t);\n \n \n-const char* GetOpName(opcodetype opcode);\n-\n-\n-\n-inline std::string ValueString(const std::vector<unsigned char>& vch)\n-{\n-    if (vch.size() <= 4)\n-        return strprintf(\"%d\", CScriptNum(vch).getint());\n-    else\n-        return HexStr(vch);\n-}\n-\n-inline std::string StackString(const std::vector<std::vector<unsigned char> >& vStack)\n-{\n-    std::string str;\n-    BOOST_FOREACH(const std::vector<unsigned char>& vch, vStack)\n-    {\n-        if (!str.empty())\n-            str += \" \";\n-        str += ValueString(vch);\n-    }\n-    return str;\n-}\n-\n-\n-\n-\n-\n-\n-\n-\n-/** Serialized script, used inside transaction inputs and outputs */\n-class CScript : public std::vector<unsigned char>\n-{\n-protected:\n-    CScript& push_int64(int64_t n)\n-    {\n-        if (n == -1 || (n >= 1 && n <= 16))\n-        {\n-            push_back(n + (OP_1 - 1));\n-        }\n-        else\n-        {\n-            *this << CScriptNum::serialize(n);\n-        }\n-        return *this;\n-    }\n-public:\n-    CScript() { }\n-    CScript(const CScript& b) : std::vector<unsigned char>(b.begin(), b.end()) { }\n-    CScript(const_iterator pbegin, const_iterator pend) : std::vector<unsigned char>(pbegin, pend) { }\n-#ifndef _MSC_VER\n-    CScript(const unsigned char* pbegin, const unsigned char* pend) : std::vector<unsigned char>(pbegin, pend) { }\n-#endif\n-\n-    CScript& operator+=(const CScript& b)\n-    {\n-        insert(end(), b.begin(), b.end());\n-        return *this;\n-    }\n-\n-    friend CScript operator+(const CScript& a, const CScript& b)\n-    {\n-        CScript ret = a;\n-        ret += b;\n-        return ret;\n-    }\n-\n-\n-    CScript(int64_t b)        { operator<<(b); }\n-\n-    explicit CScript(opcodetype b)     { operator<<(b); }\n-    explicit CScript(const uint256& b) { operator<<(b); }\n-    explicit CScript(const CScriptNum& b) { operator<<(b); }\n-    explicit CScript(const std::vector<unsigned char>& b) { operator<<(b); }\n-\n-\n-    CScript& operator<<(int64_t b) { return push_int64(b); }\n-\n-    CScript& operator<<(opcodetype opcode)\n-    {\n-        if (opcode < 0 || opcode > 0xff)\n-            throw std::runtime_error(\"CScript::operator<<() : invalid opcode\");\n-        insert(end(), (unsigned char)opcode);\n-        return *this;\n-    }\n-\n-    CScript& operator<<(const uint160& b)\n-    {\n-        insert(end(), sizeof(b));\n-        insert(end(), (unsigned char*)&b, (unsigned char*)&b + sizeof(b));\n-        return *this;\n-    }\n-\n-    CScript& operator<<(const uint256& b)\n-    {\n-        insert(end(), sizeof(b));\n-        insert(end(), (unsigned char*)&b, (unsigned char*)&b + sizeof(b));\n-        return *this;\n-    }\n-\n-    CScript& operator<<(const CPubKey& key)\n-    {\n-        assert(key.size() < OP_PUSHDATA1);\n-        insert(end(), (unsigned char)key.size());\n-        insert(end(), key.begin(), key.end());\n-        return *this;\n-    }\n-\n-    CScript& operator<<(const CScriptNum& b)\n-    {\n-        *this << b.getvch();\n-        return *this;\n-    }\n-\n-    CScript& operator<<(const std::vector<unsigned char>& b)\n-    {\n-        if (b.size() < OP_PUSHDATA1)\n-        {\n-            insert(end(), (unsigned char)b.size());\n-        }\n-        else if (b.size() <= 0xff)\n-        {\n-            insert(end(), OP_PUSHDATA1);\n-            insert(end(), (unsigned char)b.size());\n-        }\n-        else if (b.size() <= 0xffff)\n-        {\n-            insert(end(), OP_PUSHDATA2);\n-            unsigned short nSize = b.size();\n-            insert(end(), (unsigned char*)&nSize, (unsigned char*)&nSize + sizeof(nSize));\n-        }\n-        else\n-        {\n-            insert(end(), OP_PUSHDATA4);\n-            unsigned int nSize = b.size();\n-            insert(end(), (unsigned char*)&nSize, (unsigned char*)&nSize + sizeof(nSize));\n-        }\n-        insert(end(), b.begin(), b.end());\n-        return *this;\n-    }\n-\n-    CScript& operator<<(const CScript& b)\n-    {\n-        // I'm not sure if this should push the script or concatenate scripts.\n-        // If there's ever a use for pushing a script onto a script, delete this member fn\n-        assert(!\"Warning: Pushing a CScript onto a CScript with << is probably not intended, use + to concatenate!\");\n-        return *this;\n-    }\n-\n \n-    bool GetOp(iterator& pc, opcodetype& opcodeRet, std::vector<unsigned char>& vchRet)\n-    {\n-         // Wrapper so it can be called with either iterator or const_iterator\n-         const_iterator pc2 = pc;\n-         bool fRet = GetOp2(pc2, opcodeRet, &vchRet);\n-         pc = begin() + (pc2 - begin());\n-         return fRet;\n-    }\n \n-    bool GetOp(iterator& pc, opcodetype& opcodeRet)\n-    {\n-         const_iterator pc2 = pc;\n-         bool fRet = GetOp2(pc2, opcodeRet, NULL);\n-         pc = begin() + (pc2 - begin());\n-         return fRet;\n-    }\n \n-    bool GetOp(const_iterator& pc, opcodetype& opcodeRet, std::vector<unsigned char>& vchRet) const\n-    {\n-        return GetOp2(pc, opcodeRet, &vchRet);\n-    }\n \n-    bool GetOp(const_iterator& pc, opcodetype& opcodeRet) const\n-    {\n-        return GetOp2(pc, opcodeRet, NULL);\n-    }\n \n-    bool GetOp2(const_iterator& pc, opcodetype& opcodeRet, std::vector<unsigned char>* pvchRet) const\n-    {\n-        opcodeRet = OP_INVALIDOPCODE;\n-        if (pvchRet)\n-            pvchRet->clear();\n-        if (pc >= end())\n-            return false;\n \n-        // Read instruction\n-        if (end() - pc < 1)\n-            return false;\n-        unsigned int opcode = *pc++;\n \n-        // Immediate operand\n-        if (opcode <= OP_PUSHDATA4)\n-        {\n-            unsigned int nSize = 0;\n-            if (opcode < OP_PUSHDATA1)\n-            {\n-                nSize = opcode;\n-            }\n-            else if (opcode == OP_PUSHDATA1)\n-            {\n-                if (end() - pc < 1)\n-                    return false;\n-                nSize = *pc++;\n-            }\n-            else if (opcode == OP_PUSHDATA2)\n-            {\n-                if (end() - pc < 2)\n-                    return false;\n-                nSize = 0;\n-                memcpy(&nSize, &pc[0], 2);\n-                pc += 2;\n-            }\n-            else if (opcode == OP_PUSHDATA4)\n-            {\n-                if (end() - pc < 4)\n-                    return false;\n-                memcpy(&nSize, &pc[0], 4);\n-                pc += 4;\n-            }\n-            if (end() - pc < 0 || (unsigned int)(end() - pc) < nSize)\n-                return false;\n-            if (pvchRet)\n-                pvchRet->assign(pc, pc + nSize);\n-            pc += nSize;\n-        }\n-\n-        opcodeRet = (opcodetype)opcode;\n-        return true;\n-    }\n-\n-    // Encode/decode small integers:\n-    static int DecodeOP_N(opcodetype opcode)\n-    {\n-        if (opcode == OP_0)\n-            return 0;\n-        assert(opcode >= OP_1 && opcode <= OP_16);\n-        return (int)opcode - (int)(OP_1 - 1);\n-    }\n-    static opcodetype EncodeOP_N(int n)\n-    {\n-        assert(n >= 0 && n <= 16);\n-        if (n == 0)\n-            return OP_0;\n-        return (opcodetype)(OP_1+n-1);\n-    }\n-\n-    int FindAndDelete(const CScript& b)\n-    {\n-        int nFound = 0;\n-        if (b.empty())\n-            return nFound;\n-        iterator pc = begin();\n-        opcodetype opcode;\n-        do\n-        {\n-            while (end() - pc >= (long)b.size() && memcmp(&pc[0], &b[0], b.size()) == 0)\n-            {\n-                erase(pc, pc + b.size());\n-                ++nFound;\n-            }\n-        }\n-        while (GetOp(pc, opcode));\n-        return nFound;\n-    }\n-    int Find(opcodetype op) const\n-    {\n-        int nFound = 0;\n-        opcodetype opcode;\n-        for (const_iterator pc = begin(); pc != end() && GetOp(pc, opcode);)\n-            if (opcode == op)\n-                ++nFound;\n-        return nFound;\n-    }\n-\n-    // Pre-version-0.6, Bitcoin always counted CHECKMULTISIGs\n-    // as 20 sigops. With pay-to-script-hash, that changed:\n-    // CHECKMULTISIGs serialized in scriptSigs are\n-    // counted more accurately, assuming they are of the form\n-    //  ... OP_N CHECKMULTISIG ...\n-    unsigned int GetSigOpCount(bool fAccurate) const;\n-\n-    // Accurately count sigOps, including sigOps in\n-    // pay-to-script-hash transactions:\n-    unsigned int GetSigOpCount(const CScript& scriptSig) const;\n-\n-    bool IsPayToScriptHash() const;\n-\n-    // Called by IsStandardTx and P2SH VerifyScript (which makes it consensus-critical).\n-    bool IsPushOnly() const;\n-\n-    // Called by IsStandardTx.\n-    bool HasCanonicalPushes() const;\n-\n-    // Returns whether the script is guaranteed to fail at execution,\n-    // regardless of the initial stack. This allows outputs to be pruned\n-    // instantly when entering the UTXO set.\n-    bool IsUnspendable() const\n-    {\n-        return (size() > 0 && *begin() == OP_RETURN);\n-    }\n-\n-    void SetDestination(const CTxDestination& address);\n-    void SetMultisig(int nRequired, const std::vector<CPubKey>& keys);\n-\n-    std::string ToString() const\n-    {\n-        std::string str;\n-        opcodetype opcode;\n-        std::vector<unsigned char> vch;\n-        const_iterator pc = begin();\n-        while (pc < end())\n-        {\n-            if (!str.empty())\n-                str += \" \";\n-            if (!GetOp(pc, opcode, vch))\n-            {\n-                str += \"[error]\";\n-                return str;\n-            }\n-            if (0 <= opcode && opcode <= OP_PUSHDATA4)\n-                str += ValueString(vch);\n-            else\n-                str += GetOpName(opcode);\n-        }\n-        return str;\n-    }\n-\n-    CScriptID GetID() const\n-    {\n-        return CScriptID(Hash160(*this));\n-    }\n-};\n \n /** Compact serializer for scripts.\n  *\n@@ -475,11 +131,8 @@ class CScriptCompressor\n     }\n };\n \n-bool IsCanonicalPubKey(const std::vector<unsigned char> &vchPubKey, unsigned int flags);\n-bool IsCanonicalSignature(const std::vector<unsigned char> &vchSig, unsigned int flags);\n+const char* GetOpName(opcodetype opcode);\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, unsigned int flags, int nHashType);\n-uint256 SignatureHash(const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<std::vector<unsigned char> >& vSolutionsRet);\n int ScriptSigArgsExpected(txnouttype t, const std::vector<std::vector<unsigned char> >& vSolutions);\n bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType);"
      }
    ]
  },
  {
    "sha": "d5b91eb84e0ae8a0510899f5c10ddb787f147bbe",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNWI5MWViODRlMGFlOGEwNTEwODk5ZjVjMTBkZGI3ODdmMTQ3YmJl",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2014-08-11T06:22:39Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2014-08-20T03:05:55Z"
      },
      "message": "Make bitcoinscript.h expose useful things",
      "tree": {
        "sha": "3c83285f98e0a4630180d8fb5fb7febed847d2b1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3c83285f98e0a4630180d8fb5fb7febed847d2b1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d5b91eb84e0ae8a0510899f5c10ddb787f147bbe",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d5b91eb84e0ae8a0510899f5c10ddb787f147bbe",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d5b91eb84e0ae8a0510899f5c10ddb787f147bbe",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d5b91eb84e0ae8a0510899f5c10ddb787f147bbe/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1dc9666c39ca532efad20a236923e0daa4c57921",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1dc9666c39ca532efad20a236923e0daa4c57921",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1dc9666c39ca532efad20a236923e0daa4c57921"
      }
    ],
    "stats": {
      "total": 37,
      "additions": 23,
      "deletions": 14
    },
    "files": [
      {
        "sha": "495c3ccfe4d297e3b8027901fceb3035014ccb69",
        "filename": "src/core.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 7,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d5b91eb84e0ae8a0510899f5c10ddb787f147bbe/src/core.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d5b91eb84e0ae8a0510899f5c10ddb787f147bbe/src/core.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core.cpp?ref=d5b91eb84e0ae8a0510899f5c10ddb787f147bbe",
        "patch": "@@ -104,13 +104,6 @@ uint256 CMutableTransaction::GetHash() const\n     return SerializeHash(*this);\n }\n \n-void CTransaction::UpdateHash() const\n-{\n-    *const_cast<uint256*>(&hash) = SerializeHash(*this);\n-}\n-\n-CTransaction::CTransaction() : hash(0), nVersion(CTransaction::CURRENT_VERSION), vin(), vout(), nLockTime(0) { }\n-\n CTransaction::CTransaction(const CMutableTransaction &tx) : nVersion(tx.nVersion), vin(tx.vin), vout(tx.vout), nLockTime(tx.nLockTime) {\n     UpdateHash();\n }"
      },
      {
        "sha": "f6263b6cbd726f0615a312d2ed5402aef26d8216",
        "filename": "src/core.h",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d5b91eb84e0ae8a0510899f5c10ddb787f147bbe/src/core.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d5b91eb84e0ae8a0510899f5c10ddb787f147bbe/src/core.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core.h?ref=d5b91eb84e0ae8a0510899f5c10ddb787f147bbe",
        "patch": "@@ -214,7 +214,9 @@ class CTransaction\n private:\n     /** Memory only. */\n     const uint256 hash;\n-    void UpdateHash() const;\n+    void UpdateHash() const {\n+        *const_cast<uint256*>(&hash) = SerializeHash(*this);\n+    }\n \n public:\n     static const int CURRENT_VERSION=1;\n@@ -230,7 +232,8 @@ class CTransaction\n     const unsigned int nLockTime;\n \n     /** Construct a CTransaction that qualifies as IsNull() */\n-    CTransaction();\n+    CTransaction()\n+         : hash(0), nVersion(CTransaction::CURRENT_VERSION), vin(), vout(), nLockTime(0) { };\n \n     /** Convert a CMutableTransaction into a CTransaction. */\n     CTransaction(const CMutableTransaction &tx);"
      },
      {
        "sha": "8690b40b42be1d51e8d07558fde2a87b73aea924",
        "filename": "src/script/bitcoinscript.h",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d5b91eb84e0ae8a0510899f5c10ddb787f147bbe/src/script/bitcoinscript.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d5b91eb84e0ae8a0510899f5c10ddb787f147bbe/src/script/bitcoinscript.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/bitcoinscript.h?ref=d5b91eb84e0ae8a0510899f5c10ddb787f147bbe",
        "patch": "@@ -3,9 +3,6 @@\n \n #include <vector>\n \n-class CScript;\n-class CTransaction;\n-\n /** Script verification flags */\n enum\n {\n@@ -32,6 +29,6 @@ static const unsigned int STANDARD_SCRIPT_VERIFY_FLAGS = MANDATORY_SCRIPT_VERIFY\n                                                          SCRIPT_VERIFY_STRICTENC |\n                                                          SCRIPT_VERIFY_NULLDUMMY;\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, unsigned int flags, int nHashType);\n+bool VerifyScript(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& scriptPubKey, const std::vector<unsigned char>& txTo, unsigned int nIn, unsigned int flags, int nHashType);\n \n #endif"
      },
      {
        "sha": "3a88cbe520c294ddeba7d393aa74801eaa1e6a0a",
        "filename": "src/script/script.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d5b91eb84e0ae8a0510899f5c10ddb787f147bbe/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d5b91eb84e0ae8a0510899f5c10ddb787f147bbe/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=d5b91eb84e0ae8a0510899f5c10ddb787f147bbe",
        "patch": "@@ -12,6 +12,8 @@\n #include <boost/foreach.hpp>\n #include <boost/variant.hpp>\n \n+class CTransaction;\n+\n static const unsigned int MAX_SCRIPT_ELEMENT_SIZE = 520; // bytes\n static const unsigned int MAX_OP_RETURN_RELAY = 40;      // bytes\n \n@@ -650,4 +652,6 @@ bool IsCanonicalPubKey(const std::vector<unsigned char> &vchPubKey, unsigned int\n bool IsCanonicalSignature(const std::vector<unsigned char> &vchSig, unsigned int flags);\n \n uint256 SignatureHash(const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, unsigned int flags, int nHashType);\n+bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, unsigned int flags, int nHashType);\n #endif"
      },
      {
        "sha": "db6e337ad96b875c6fc07a1af262cfee46fdec17",
        "filename": "src/script/standalone.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d5b91eb84e0ae8a0510899f5c10ddb787f147bbe/src/script/standalone.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d5b91eb84e0ae8a0510899f5c10ddb787f147bbe/src/script/standalone.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standalone.cpp?ref=d5b91eb84e0ae8a0510899f5c10ddb787f147bbe",
        "patch": "@@ -1,4 +1,6 @@\n #include \"script.h\"\n+#include \"version.h\"\n+#include \"core.h\"\n \n using namespace std;\n \n@@ -27,6 +29,7 @@ bool CheckSig(vector<unsigned char> vchSig, const vector<unsigned char> &vchPubK\n     return true;\n }\n \n+// From util.cpp\n int LogPrintStr(const string&)\n {\n     return 0;\n@@ -43,3 +46,13 @@ int64_t GetTime()\n }\n \n \n+\n+bool VerifyScript(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& scriptPubKey, const std::vector<unsigned char>& txTo, unsigned int nIn, unsigned int flags, int nHashType)\n+{\n+    CTransaction tx;\n+    CDataStream stream(txTo, SER_NETWORK, PROTOCOL_VERSION);\n+    stream >> tx;\n+    return VerifyScript(CScript(scriptSig.begin(),    scriptSig.end()),\n+                        CScript(scriptPubKey.begin(), scriptPubKey.end()),\n+                        tx, nIn, flags, nHashType);\n+}"
      },
      {
        "sha": "936e54a4dbdd46ab58a23405b353317841e1b7e3",
        "filename": "src/scriptutils.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d5b91eb84e0ae8a0510899f5c10ddb787f147bbe/src/scriptutils.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d5b91eb84e0ae8a0510899f5c10ddb787f147bbe/src/scriptutils.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scriptutils.h?ref=d5b91eb84e0ae8a0510899f5c10ddb787f147bbe",
        "patch": "@@ -143,7 +143,6 @@ bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)\n bool ExtractDestinations(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<CTxDestination>& addressRet, int& nRequiredRet);\n bool SignSignature(const CKeyStore& keystore, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL);\n bool SignSignature(const CKeyStore& keystore, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL);\n-bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, unsigned int flags, int nHashType);\n \n // Given two sets of signatures for scriptPubKey, possibly with OP_0 placeholders,\n // combine them intelligently and return the result."
      }
    ]
  },
  {
    "sha": "176ec02a6c567d84363ea2394f0508a4f67a82fc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxNzZlYzAyYTZjNTY3ZDg0MzYzZWEyMzk0ZjA1MDhhNGY2N2E4MmZj",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2014-08-13T10:25:07Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2014-08-20T03:05:55Z"
      },
      "message": "Make bitcoinscript.h C, not C++",
      "tree": {
        "sha": "c5ba610bfdaa2496d699b7420fb6ebc66313bf1a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c5ba610bfdaa2496d699b7420fb6ebc66313bf1a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/176ec02a6c567d84363ea2394f0508a4f67a82fc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/176ec02a6c567d84363ea2394f0508a4f67a82fc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/176ec02a6c567d84363ea2394f0508a4f67a82fc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/176ec02a6c567d84363ea2394f0508a4f67a82fc/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d5b91eb84e0ae8a0510899f5c10ddb787f147bbe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d5b91eb84e0ae8a0510899f5c10ddb787f147bbe",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d5b91eb84e0ae8a0510899f5c10ddb787f147bbe"
      }
    ],
    "stats": {
      "total": 71,
      "additions": 47,
      "deletions": 24
    },
    "files": [
      {
        "sha": "0eaf78133ee89df8f53659077967bbf28b68c5c8",
        "filename": "src/script/bitcoinscript.h",
        "status": "modified",
        "additions": 27,
        "deletions": 17,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/176ec02a6c567d84363ea2394f0508a4f67a82fc/src/script/bitcoinscript.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/176ec02a6c567d84363ea2394f0508a4f67a82fc/src/script/bitcoinscript.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/bitcoinscript.h?ref=176ec02a6c567d84363ea2394f0508a4f67a82fc",
        "patch": "@@ -1,7 +1,11 @@\n #ifndef H_BITCOIN_BITCOINSCRIPT\n #define H_BITCOIN_BITCOINSCRIPT\n \n-#include <vector>\n+#ifdef __cplusplus\n+extern \"C\" {\n+#else\n+#include <stdbool.h>\n+#endif\n \n /** Script verification flags */\n enum\n@@ -11,24 +15,30 @@ enum\n     SCRIPT_VERIFY_STRICTENC = (1U << 1), // enforce strict conformance to DER and SEC2 for signatures and pubkeys\n     SCRIPT_VERIFY_LOW_S     = (1U << 2), // enforce low S values (<n/2) in signatures (depends on STRICTENC)\n     SCRIPT_VERIFY_NULLDUMMY = (1U << 4), // verify dummy stack item consumed by CHECKMULTISIG is of zero-length\n-};\n \n-// Mandatory script verification flags that all new blocks must comply with for\n-// them to be valid. (but old blocks may not comply with) Currently just P2SH,\n-// but in the future other flags may be added, such as a soft-fork to enforce\n-// strict DER encoding.\n-//\n-// Failing one of these tests may trigger a DoS ban - see CheckInputs() for\n-// details.\n-static const unsigned int MANDATORY_SCRIPT_VERIFY_FLAGS = SCRIPT_VERIFY_P2SH;\n+    // Mandatory script verification flags that all new blocks must comply with for\n+    // them to be valid. (but old blocks may not comply with) Currently just P2SH,\n+    // but in the future other flags may be added, such as a soft-fork to enforce\n+    // strict DER encoding.\n+    //\n+    // Failing one of these tests may trigger a DoS ban - see CheckInputs() for\n+    // details.\n+    MANDATORY_SCRIPT_VERIFY_FLAGS = SCRIPT_VERIFY_P2SH,\n \n-// Standard script verification flags that standard transactions will comply\n-// with. However scripts violating these flags may still be present in valid\n-// blocks and we must accept those blocks.\n-static const unsigned int STANDARD_SCRIPT_VERIFY_FLAGS = MANDATORY_SCRIPT_VERIFY_FLAGS |\n-                                                         SCRIPT_VERIFY_STRICTENC |\n-                                                         SCRIPT_VERIFY_NULLDUMMY;\n+    // Standard script verification flags that standard transactions will comply\n+    // with. However scripts violating these flags may still be present in valid\n+    // blocks and we must accept those blocks.\n+    STANDARD_SCRIPT_VERIFY_FLAGS = MANDATORY_SCRIPT_VERIFY_FLAGS |\n+                                   SCRIPT_VERIFY_STRICTENC |\n+                                   SCRIPT_VERIFY_NULLDUMMY,\n+};\n \n-bool VerifyScript(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& scriptPubKey, const std::vector<unsigned char>& txTo, unsigned int nIn, unsigned int flags, int nHashType);\n+bool VerifyScript(const unsigned char *scriptPubKey, const unsigned int scriptPubKeyLen,\n+                  const unsigned char *txTo,         const unsigned int txToLen,\n+                  const unsigned int nIn, const unsigned int flags);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n \n #endif"
      },
      {
        "sha": "3ae642aa4537de29d2cf11466fc98f6150c7cc6c",
        "filename": "src/script/standalone.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 7,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/176ec02a6c567d84363ea2394f0508a4f67a82fc/src/script/standalone.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/176ec02a6c567d84363ea2394f0508a4f67a82fc/src/script/standalone.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standalone.cpp?ref=176ec02a6c567d84363ea2394f0508a4f67a82fc",
        "patch": "@@ -47,12 +47,25 @@ int64_t GetTime()\n \n \n \n-bool VerifyScript(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& scriptPubKey, const std::vector<unsigned char>& txTo, unsigned int nIn, unsigned int flags, int nHashType)\n+bool VerifyScript(const unsigned char *scriptPubKey, const unsigned int scriptPubKeyLen,\n+                             const unsigned char *txTo,         const unsigned int txToLen,\n+                             const unsigned int nIn, const unsigned int flags)\n {\n-    CTransaction tx;\n-    CDataStream stream(txTo, SER_NETWORK, PROTOCOL_VERSION);\n-    stream >> tx;\n-    return VerifyScript(CScript(scriptSig.begin(),    scriptSig.end()),\n-                        CScript(scriptPubKey.begin(), scriptPubKey.end()),\n-                        tx, nIn, flags, nHashType);\n+    try {\n+        if (!scriptPubKey || !txTo)\n+            return false;\n+\n+        CTransaction tx;\n+        CDataStream stream(std::vector<unsigned char>(txTo, txTo + txToLen), SER_NETWORK, PROTOCOL_VERSION);\n+        stream >> tx;\n+\n+        if (nIn >= tx.vin.size())\n+            return false;\n+\n+        return VerifyScript(tx.vin[nIn].scriptSig,\n+                            CScript(scriptPubKey, scriptPubKey + scriptPubKeyLen),\n+                            tx, nIn, flags, 0);\n+    } catch (std::exception &e) {\n+        return false; // Error deserializing\n+    }\n }"
      }
    ]
  }
]