[
  {
    "sha": "8934f247c61a26e6515e00f4e6bdd14ab98304b4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4OTM0ZjI0N2M2MWEyNmU2NTE1ZTAwZjRlNmJkZDE0YWI5ODMwNGI0",
    "commit": {
      "author": {
        "name": "Hossein Amin",
        "email": "hossein@aminbros.com",
        "date": "2019-05-22T02:20:24Z"
      },
      "committer": {
        "name": "Hossein Amin",
        "email": "hossein@aminbros.com",
        "date": "2019-05-24T08:46:57Z"
      },
      "message": "rpc listtransactions new argument options (paginatebypointer impl)\n\nAdded fifth param to `listtransactions` named `options`, `options` may be an object containing `paginatebypointer` (boolean default: false) and `nextpagepointer` (string default: OMITTED).\n\nWith `paginatebypointer` output will have the following changes.\n\n1. Return transactions is ordered by most recent transactions. Though the default does reverse the order after transactions are fetched and clipped.\n2. `skip` argument has no effect. Instead `nextpagepointer` will be used for pagination.\n3. Return value is an object containing, records (array of txs) and nextpagepointer (string)",
      "tree": {
        "sha": "ee7997104412625f4c4f8e63f3f76cde441f88f5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ee7997104412625f4c4f8e63f3f76cde441f88f5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8934f247c61a26e6515e00f4e6bdd14ab98304b4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8934f247c61a26e6515e00f4e6bdd14ab98304b4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8934f247c61a26e6515e00f4e6bdd14ab98304b4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8934f247c61a26e6515e00f4e6bdd14ab98304b4/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "fe47ae168b575006230da7f8a5b25b1a5f4a4dda",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fe47ae168b575006230da7f8a5b25b1a5f4a4dda",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fe47ae168b575006230da7f8a5b25b1a5f4a4dda"
      }
    ],
    "stats": {
      "total": 301,
      "additions": 261,
      "deletions": 40
    },
    "files": [
      {
        "sha": "a3ed85a52047c44c72882edb586fb2eea5f91816",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8934f247c61a26e6515e00f4e6bdd14ab98304b4/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8934f247c61a26e6515e00f4e6bdd14ab98304b4/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=8934f247c61a26e6515e00f4e6bdd14ab98304b4",
        "patch": "@@ -56,6 +56,7 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"listtransactions\", 1, \"count\" },\n     { \"listtransactions\", 2, \"skip\" },\n     { \"listtransactions\", 3, \"include_watchonly\" },\n+    { \"listtransactions\", 4, \"options\" },\n     { \"walletpassphrase\", 1, \"timeout\" },\n     { \"getblocktemplate\", 0, \"template_request\" },\n     { \"listsinceblock\", 1, \"target_confirmations\" },"
      },
      {
        "sha": "2b5c9a64e461aa51d5a78c7d8732e9d62c2ca7e6",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 197,
        "deletions": 40,
        "changes": 237,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8934f247c61a26e6515e00f4e6bdd14ab98304b4/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8934f247c61a26e6515e00f4e6bdd14ab98304b4/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=8934f247c61a26e6515e00f4e6bdd14ab98304b4",
        "patch": "@@ -1305,8 +1305,13 @@ static void MaybePushAddress(UniValue & entry, const CTxDestination &dest)\n  * @param  ret            The UniValue into which the result is stored.\n  * @param  filter_ismine  The \"is mine\" filter flags.\n  * @param  filter_label   Optional label string to filter incoming transactions.\n+ * @param  afterVOut      start adding after afterVOut\n+ * @param  limit          limits the insertion amount\n+ *\n+ * starts inserting transaction elements from startVOut if >= 0\n+ * Returns true only if all elements got processed\n  */\n-static void ListTransactions(interfaces::Chain::Lock& locked_chain, CWallet* const pwallet, const CWalletTx& wtx, int nMinDepth, bool fLong, UniValue& ret, const isminefilter& filter_ismine, const std::string* filter_label) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static bool ListTransactions(interfaces::Chain::Lock& locked_chain, CWallet* const pwallet, const CWalletTx& wtx, int nMinDepth, bool fLong, UniValue& ret, const isminefilter& filter_ismine, const std::string* filter_label, int limit) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n     CAmount nFee;\n     std::list<COutputEntry> listReceived;\n@@ -1322,6 +1327,10 @@ static void ListTransactions(interfaces::Chain::Lock& locked_chain, CWallet* con\n         for (const COutputEntry& s : listSent)\n         {\n             UniValue entry(UniValue::VOBJ);\n+            // check for limit when new entry exists\n+            if (limit-- == 0) {\n+                return false;\n+            }\n             if (involvesWatchonly || (::IsMine(*pwallet, s.destination) & ISMINE_WATCH_ONLY)) {\n                 entry.pushKV(\"involvesWatchonly\", true);\n             }\n@@ -1352,6 +1361,10 @@ static void ListTransactions(interfaces::Chain::Lock& locked_chain, CWallet* con\n             if (filter_label && label != *filter_label) {\n                 continue;\n             }\n+            // check for limit when new entry exists\n+            if (limit-- == 0) {\n+                return false;\n+            }\n             UniValue entry(UniValue::VOBJ);\n             if (involvesWatchonly || (::IsMine(*pwallet, r.destination) & ISMINE_WATCH_ONLY)) {\n                 entry.pushKV(\"involvesWatchonly\", true);\n@@ -1380,6 +1393,24 @@ static void ListTransactions(interfaces::Chain::Lock& locked_chain, CWallet* con\n             ret.push_back(entry);\n         }\n     }\n+\n+    return true;\n+}\n+\n+/**\n+ * List transactions based on the given criteria.\n+ *\n+ * @param  pwallet        The wallet.\n+ * @param  wtx            The wallet transaction.\n+ * @param  nMinDepth      The minimum confirmation depth.\n+ * @param  fLong          Whether to include the JSON version of the transaction.\n+ * @param  ret            The UniValue into which the result is stored.\n+ * @param  filter_ismine  The \"is mine\" filter flags.\n+ * @param  filter_label   Optional label string to filter incoming transactions.\n+ */\n+static void ListTransactions(interfaces::Chain::Lock& locked_chain, CWallet* const pwallet, const CWalletTx& wtx, int nMinDepth, bool fLong, UniValue& ret, const isminefilter& filter_ismine, const std::string* filter_label)  EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    ListTransactions(locked_chain, pwallet, wtx, nMinDepth, fLong, ret, filter_ismine, filter_label, -1);\n }\n \n UniValue listtransactions(const JSONRPCRequest& request)\n@@ -1391,7 +1422,7 @@ UniValue listtransactions(const JSONRPCRequest& request)\n         return NullUniValue;\n     }\n \n-    if (request.fHelp || request.params.size() > 4)\n+    if (request.fHelp || request.params.size() > 5)\n         throw std::runtime_error(\n             RPCHelpMan{\"listtransactions\",\n                 \"\\nIf a label name is provided, this will return only incoming transactions paying to addresses with the specified label.\\n\"\n@@ -1400,10 +1431,20 @@ UniValue listtransactions(const JSONRPCRequest& request)\n                     {\"label\", RPCArg::Type::STR, RPCArg::Optional::OMITTED_NAMED_ARG, \"If set, should be a valid label name to return only incoming transactions\\n\"\n             \"              with the specified label, or \\\"*\\\" to disable filtering and return all transactions.\"},\n                     {\"count\", RPCArg::Type::NUM, /* default */ \"10\", \"The number of transactions to return\"},\n-                    {\"skip\", RPCArg::Type::NUM, /* default */ \"0\", \"The number of transactions to skip\"},\n+                    {\"skip\", RPCArg::Type::NUM, /* default */ \"0\", \"The number of transactions to skip, If \\\"usesnextpagepointer\\\" option is true, skip won't have an effect.\"},\n                     {\"include_watchonly\", RPCArg::Type::BOOL, /* default */ \"false\", \"Include transactions to watch-only addresses (see 'importaddress')\"},\n+                    {\"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"JSON object for options\",\n+                        {\n+                            {\"paginatebypointer\", RPCArg::Type::BOOL, /* default */ \"false\", \"If it is true it changes output type to an object containing records and nextpagepointer\"},\n+                            {\"nextpagepointer\", RPCArg::Type::STR, RPCArg::Optional::OMITTED, \"A nullable string provided from previous calls to listtransactions for performing pagination\"},\n+                        },\n+                        \"options\"},\n                 },\n                 RPCResult{\n+            \"\\nResult with nextpagepointer option returns an object containing \\\"records\\\" and \\\"nextpagepointer\\\".\"\n+            \"\\nAlso it has a secondary effect at order of output txs. Though it still starts with most recent.\"\n+            \"\\n{ \\\"records\\\": [/*list of txs*/], \\\"nextpagepointer\\\": \\\"txid:vout\\\"|null }\"\n+            \"\\nResult with no nextpagepointer:\\n\"\n             \"[\\n\"\n             \"  {\\n\"\n             \"    \\\"address\\\":\\\"address\\\",    (string) The bitcoin address of the transaction.\\n\"\n@@ -1442,7 +1483,9 @@ UniValue listtransactions(const JSONRPCRequest& request)\n             \"\\nList transactions 100 to 120\\n\"\n             + HelpExampleCli(\"listtransactions\", \"\\\"*\\\" 20 100\") +\n             \"\\nAs a JSON-RPC call\\n\"\n-            + HelpExampleRpc(\"listtransactions\", \"\\\"*\\\", 20, 100\")\n+            + HelpExampleRpc(\"listtransactions\", \"\\\"*\\\", 20, 100\") +\n+            \"\\nlist transactions with paginatebypointer option\\n\"\n+            + HelpExampleCli(\"listtransactions\", \"\\\"*\\\" 20 0 false '{\\\"paginatebypointer\\\":true}'\")\n                 },\n             }.ToString());\n \n@@ -1460,60 +1503,174 @@ UniValue listtransactions(const JSONRPCRequest& request)\n     int nCount = 10;\n     if (!request.params[1].isNull())\n         nCount = request.params[1].get_int();\n-    int nFrom = 0;\n-    if (!request.params[2].isNull())\n-        nFrom = request.params[2].get_int();\n+    if (nCount < 0)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Negative count\");\n+\n     isminefilter filter = ISMINE_SPENDABLE;\n     if(!request.params[3].isNull())\n         if(request.params[3].get_bool())\n             filter = filter | ISMINE_WATCH_ONLY;\n \n-    if (nCount < 0)\n-        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Negative count\");\n-    if (nFrom < 0)\n-        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Negative from\");\n+    bool paginatebypointer = false;\n+    std::string nextpagepointer;\n+    const UniValue& options = request.params[4];\n+    if (!options.isNull()) {\n+        RPCTypeCheckArgument(options, UniValue::VOBJ);\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"paginatebypointer\", UniValueType(UniValue::VBOOL)},\n+                {\"nextpagepointer\", UniValueType(UniValue::VSTR)},\n+            }, true, true);\n+        if (options.exists(\"paginatebypointer\")) {\n+            paginatebypointer = options[\"paginatebypointer\"].get_bool();\n+        }\n+        if (options.exists(\"nextpagepointer\") &&\n+            !options[\"nextpagepointer\"].isNull()) {\n+            nextpagepointer = options[\"nextpagepointer\"].get_str();\n+        }\n+    }\n \n-    UniValue ret(UniValue::VARR);\n+    if (paginatebypointer) {\n+        uint256 nextHash;\n+        // if it is -1 it indicates nextpagepointer is not provided\n+        int32_t nextVOut = -1;\n+        bool nextIsSend = false;\n+        if (!nextpagepointer.empty()) {\n+            std::stringstream ss(nextpagepointer);\n+            std::string s;\n+            int i = 0;\n+            while (std::getline(ss, s, ':')) {\n+                if (i == 0) {\n+                    if (!IsHex(s)) {\n+                        break;\n+                    }\n+                    nextHash = uint256S(s);\n+                } else if (i == 1) {\n+                    if (!ParseInt32(s, &nextVOut)) {\n+                        break;\n+                    }\n+                } else if (i == 2) {\n+                    int32_t v;\n+                    if (!ParseInt32(s, &v)) {\n+                        break;\n+                    }\n+                    nextIsSend = v == 1;\n+                }\n+                i++;\n+            }\n+            if (i != 3) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, nextpagepointer expected to be in format <txid:vout:issend>\");\n+            }\n+        }\n \n-    {\n-        auto locked_chain = pwallet->chain().lock();\n-        LOCK(pwallet->cs_wallet);\n+        UniValue txs(UniValue::VARR);\n+        bool hasMore = false;\n+\n+        {\n+            auto locked_chain = pwallet->chain().lock();\n+            LOCK(pwallet->cs_wallet);\n+\n+            const CWallet::TxItems & txOrdered = pwallet->wtxOrdered;\n+            // iterate backwards until we have nCount items to return:\n+            CWallet::TxItems::const_reverse_iterator it = txOrdered.rbegin();\n+            if (nextVOut != -1) {\n+                // skip processing until txid match found\n+                while (it != txOrdered.rend()) {\n+                    CWalletTx *const pwtx = (*it++).second;\n+                    if (nextHash == pwtx->GetHash()) {\n+                        UniValue tmp(UniValue::VARR);\n+                        ListTransactions(*locked_chain, pwallet, *pwtx, 0, true, tmp, filter, filter_label, -1);\n+                        unsigned int idx = 0;\n+                        while (idx < tmp.size()) {\n+                            const UniValue& o = tmp[idx++].get_obj();\n+                            const bool isSend = find_value(o, \"category\").get_str() == \"send\";\n+                            if (((isSend && nextIsSend) || !isSend) &&\n+                                find_value(o, \"vout\").get_int() == nextVOut) {\n+                                break;\n+                            }\n+                        }\n+                        for (; idx < tmp.size(); idx++) {\n+                            if (((int)txs.size()) >= nCount) {\n+                                hasMore = nCount > 0 && tmp.size() - idx - 1 > 0;\n+                                break;\n+                            }\n+                            txs.push_back(tmp[idx]);\n+                        }\n+                        break;\n+                    }\n+                }\n+            }\n+            // when hasMore is true, no more need for rest of iteration\n+            if (!hasMore) {\n+                for (; it != txOrdered.rend(); ++it) {\n+                    CWalletTx *const pwtx = (*it).second;\n+                    // in all cases, nCount >= txs.size()\n+                    // There's no need to add more if statement\n+                    if (!ListTransactions(*locked_chain, pwallet, *pwtx, 0, true, txs, filter, filter_label, nCount - txs.size())) {\n+                        hasMore = nCount > 0;\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n \n-        const CWallet::TxItems & txOrdered = pwallet->wtxOrdered;\n+        UniValue ret(UniValue::VOBJ);\n+        ret.pushKV(\"records\", txs);\n+        if (hasMore) {\n+            const UniValue& lastTx = txs[txs.size()-1].get_obj();\n+            ret.pushKV(\"nextpagepointer\", strprintf(\"%s:%d:%d\", find_value(lastTx, \"txid\").get_str(), find_value(lastTx, \"vout\").get_int(), find_value(lastTx, \"category\").get_str() == \"send\" ? 1 : 0));\n+        } else {\n+            ret.pushKV(\"nextpagepointer\", NullUniValue); // set to null\n+        }\n+        return ret;\n+    } else {\n+        int nFrom = 0;\n+        if (!request.params[2].isNull())\n+            nFrom = request.params[2].get_int();\n+        if (nFrom < 0)\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Negative from\");\n+        UniValue ret(UniValue::VARR);\n \n-        // iterate backwards until we have nCount items to return:\n-        for (CWallet::TxItems::const_reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n         {\n-            CWalletTx *const pwtx = (*it).second;\n-            ListTransactions(*locked_chain, pwallet, *pwtx, 0, true, ret, filter, filter_label);\n-            if ((int)ret.size() >= (nCount+nFrom)) break;\n+            auto locked_chain = pwallet->chain().lock();\n+            LOCK(pwallet->cs_wallet);\n+\n+            const CWallet::TxItems & txOrdered = pwallet->wtxOrdered;\n+\n+            // iterate backwards until we have nCount items to return:\n+            for (CWallet::TxItems::const_reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n+                {\n+                    CWalletTx *const pwtx = (*it).second;\n+                    ListTransactions(*locked_chain, pwallet, *pwtx, 0, true, ret, filter, filter_label);\n+                    if ((int)ret.size() >= (nCount+nFrom)) break;\n+                }\n         }\n-    }\n \n-    // ret is newest to oldest\n+        // ret is newest to oldest\n \n-    if (nFrom > (int)ret.size())\n-        nFrom = ret.size();\n-    if ((nFrom + nCount) > (int)ret.size())\n-        nCount = ret.size() - nFrom;\n+        if (nFrom > (int)ret.size())\n+            nFrom = ret.size();\n+        if ((nFrom + nCount) > (int)ret.size())\n+            nCount = ret.size() - nFrom;\n \n-    std::vector<UniValue> arrTmp = ret.getValues();\n+        std::vector<UniValue> arrTmp = ret.getValues();\n \n-    std::vector<UniValue>::iterator first = arrTmp.begin();\n-    std::advance(first, nFrom);\n-    std::vector<UniValue>::iterator last = arrTmp.begin();\n-    std::advance(last, nFrom+nCount);\n+        std::vector<UniValue>::iterator first = arrTmp.begin();\n+        std::advance(first, nFrom);\n+        std::vector<UniValue>::iterator last = arrTmp.begin();\n+        std::advance(last, nFrom+nCount);\n \n-    if (last != arrTmp.end()) arrTmp.erase(last, arrTmp.end());\n-    if (first != arrTmp.begin()) arrTmp.erase(arrTmp.begin(), first);\n+        if (last != arrTmp.end()) arrTmp.erase(last, arrTmp.end());\n+        if (first != arrTmp.begin()) arrTmp.erase(arrTmp.begin(), first);\n \n-    std::reverse(arrTmp.begin(), arrTmp.end()); // Return oldest to newest\n+        std::reverse(arrTmp.begin(), arrTmp.end()); // Return oldest to newest\n \n-    ret.clear();\n-    ret.setArray();\n-    ret.push_backV(arrTmp);\n+        ret.clear();\n+        ret.setArray();\n+        ret.push_backV(arrTmp);\n \n-    return ret;\n+        return ret;\n+    }\n }\n \n static UniValue listsinceblock(const JSONRPCRequest& request)\n@@ -4208,7 +4365,7 @@ static const CRPCCommand commands[] =\n     { \"wallet\",             \"listreceivedbyaddress\",            &listreceivedbyaddress,         {\"minconf\",\"include_empty\",\"include_watchonly\",\"address_filter\"} },\n     { \"wallet\",             \"listreceivedbylabel\",              &listreceivedbylabel,           {\"minconf\",\"include_empty\",\"include_watchonly\"} },\n     { \"wallet\",             \"listsinceblock\",                   &listsinceblock,                {\"blockhash\",\"target_confirmations\",\"include_watchonly\",\"include_removed\"} },\n-    { \"wallet\",             \"listtransactions\",                 &listtransactions,              {\"label|dummy\",\"count\",\"skip\",\"include_watchonly\"} },\n+    { \"wallet\",             \"listtransactions\",                 &listtransactions,              {\"label|dummy\",\"count\",\"skip\",\"include_watchonly\",\"options\"} },\n     { \"wallet\",             \"listunspent\",                      &listunspent,                   {\"minconf\",\"maxconf\",\"addresses\",\"include_unsafe\",\"query_options\"} },\n     { \"wallet\",             \"listwalletdir\",                    &listwalletdir,                 {} },\n     { \"wallet\",             \"listwallets\",                      &listwallets,                   {} },"
      },
      {
        "sha": "2fe449ff75624c64f05e7f2d4c6850fc3f3df9ef",
        "filename": "test/functional/wallet_listtransactions.py",
        "status": "modified",
        "additions": 63,
        "deletions": 0,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8934f247c61a26e6515e00f4e6bdd14ab98304b4/test/functional/wallet_listtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8934f247c61a26e6515e00f4e6bdd14ab98304b4/test/functional/wallet_listtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_listtransactions.py?ref=8934f247c61a26e6515e00f4e6bdd14ab98304b4",
        "patch": "@@ -102,6 +102,69 @@ def run_test(self):\n                             {\"txid\": txid, \"label\": \"watchonly\"})\n \n         self.run_rbf_opt_in_test()\n+        self.run_with_paginatebypointer_test()\n+\n+    # specific tests with nextpagepointer flag\n+    def run_with_paginatebypointer_test(self):\n+        def get_with_paginatebypointer(node, count=20, label=\"*\", watchonly=False):\n+            i = 1\n+            records = []\n+            pointer = None\n+            while i < count:\n+                options = {\n+                    \"paginatebypointer\": True,\n+                    \"nextpagepointer\": pointer,\n+                }\n+                #if pointer is None:\n+                #    del options[\"nextpagepointer\"]\n+                result = node.listtransactions(label, i, 0, watchonly, options)\n+                pointer = result.get(\"nextpagepointer\", None)\n+                records += result[\"records\"]\n+                if len(records) >= count or pointer is None:\n+                    break\n+                i += 1\n+            return records\n+        # Simple send, 0 to 1:\n+        txid = self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 0.1)\n+        self.sync_all()\n+        assert_array_result(get_with_paginatebypointer(self.nodes[0]),\n+                            {\"txid\": txid},\n+                            {\"category\": \"send\", \"amount\": Decimal(\"-0.1\"), \"confirmations\": 0})\n+        assert_array_result(get_with_paginatebypointer(self.nodes[1]),\n+                            {\"txid\": txid},\n+                            {\"category\": \"receive\", \"amount\": Decimal(\"0.1\"), \"confirmations\": 0})\n+\n+        # sendmany from node1: twice to self, twice to node2:\n+        send_to = {self.nodes[0].getnewaddress(): 0.111,\n+                   self.nodes[1].getnewaddress(): 0.222,\n+                   self.nodes[0].getnewaddress(): 0.333,\n+                   self.nodes[1].getnewaddress(): 0.444}\n+        txid = self.nodes[1].sendmany(\"\", send_to)\n+        self.sync_all()\n+        assert_array_result(get_with_paginatebypointer(self.nodes[1]),\n+                            {\"category\": \"send\", \"amount\": Decimal(\"-0.111\")},\n+                            {\"txid\": txid})\n+        assert_array_result(get_with_paginatebypointer(self.nodes[0]),\n+                            {\"category\": \"receive\", \"amount\": Decimal(\"0.111\")},\n+                            {\"txid\": txid})\n+        assert_array_result(get_with_paginatebypointer(self.nodes[1]),\n+                            {\"category\": \"send\", \"amount\": Decimal(\"-0.222\")},\n+                            {\"txid\": txid})\n+        assert_array_result(get_with_paginatebypointer(self.nodes[1]),\n+                            {\"category\": \"receive\", \"amount\": Decimal(\"0.222\")},\n+                            {\"txid\": txid})\n+        assert_array_result(get_with_paginatebypointer(self.nodes[1]),\n+                            {\"category\": \"send\", \"amount\": Decimal(\"-0.333\")},\n+                            {\"txid\": txid})\n+        assert_array_result(get_with_paginatebypointer(self.nodes[0]),\n+                            {\"category\": \"receive\", \"amount\": Decimal(\"0.333\")},\n+                            {\"txid\": txid})\n+        assert_array_result(get_with_paginatebypointer(self.nodes[1]),\n+                            {\"category\": \"send\", \"amount\": Decimal(\"-0.444\")},\n+                            {\"txid\": txid})\n+        assert_array_result(get_with_paginatebypointer(self.nodes[1]),\n+                            {\"category\": \"receive\", \"amount\": Decimal(\"0.444\")},\n+                            {\"txid\": txid})\n \n     # Check that the opt-in-rbf flag works properly, for sent and received\n     # transactions."
      }
    ]
  }
]