[
  {
    "sha": "d7afe2d1577eb3f6775301c81b94a191e0db99d9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkN2FmZTJkMTU3N2ViM2Y2Nzc1MzAxYzgxYjk0YTE5MWUwZGI5OWQ5",
    "commit": {
      "author": {
        "name": "Jim Posen",
        "email": "jimpo@coinbase.com",
        "date": "2017-08-18T21:40:29Z"
      },
      "committer": {
        "name": "Jim Posen",
        "email": "jimpo@coinbase.com",
        "date": "2017-09-21T19:24:20Z"
      },
      "message": "[script] Unit tests for script/standard functions",
      "tree": {
        "sha": "3aaf47808c93279fac85fcb578260bfda46b241d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3aaf47808c93279fac85fcb578260bfda46b241d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d7afe2d1577eb3f6775301c81b94a191e0db99d9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d7afe2d1577eb3f6775301c81b94a191e0db99d9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d7afe2d1577eb3f6775301c81b94a191e0db99d9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d7afe2d1577eb3f6775301c81b94a191e0db99d9/comments",
    "author": {
      "login": "jimpo",
      "id": 881253,
      "node_id": "MDQ6VXNlcjg4MTI1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jimpo",
      "html_url": "https://github.com/jimpo",
      "followers_url": "https://api.github.com/users/jimpo/followers",
      "following_url": "https://api.github.com/users/jimpo/following{/other_user}",
      "gists_url": "https://api.github.com/users/jimpo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
      "organizations_url": "https://api.github.com/users/jimpo/orgs",
      "repos_url": "https://api.github.com/users/jimpo/repos",
      "events_url": "https://api.github.com/users/jimpo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jimpo/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jimpo",
      "id": 881253,
      "node_id": "MDQ6VXNlcjg4MTI1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jimpo",
      "html_url": "https://github.com/jimpo",
      "followers_url": "https://api.github.com/users/jimpo/followers",
      "following_url": "https://api.github.com/users/jimpo/following{/other_user}",
      "gists_url": "https://api.github.com/users/jimpo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
      "organizations_url": "https://api.github.com/users/jimpo/orgs",
      "repos_url": "https://api.github.com/users/jimpo/repos",
      "events_url": "https://api.github.com/users/jimpo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jimpo/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4f7e37e26c5d1ca5421bb070e583aaa6b0c93d03",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4f7e37e26c5d1ca5421bb070e583aaa6b0c93d03",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4f7e37e26c5d1ca5421bb070e583aaa6b0c93d03"
      }
    ],
    "stats": {
      "total": 477,
      "additions": 386,
      "deletions": 91
    },
    "files": [
      {
        "sha": "3a932f460d697cc27707789b2dd708fc5fce8776",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d7afe2d1577eb3f6775301c81b94a191e0db99d9/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d7afe2d1577eb3f6775301c81b94a191e0db99d9/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=d7afe2d1577eb3f6775301c81b94a191e0db99d9",
        "patch": "@@ -65,6 +65,7 @@ BITCOIN_TESTS =\\\n   test/scheduler_tests.cpp \\\n   test/script_P2SH_tests.cpp \\\n   test/script_tests.cpp \\\n+  test/script_standard_tests.cpp \\\n   test/scriptnum_tests.cpp \\\n   test/serialize_tests.cpp \\\n   test/sighash_tests.cpp \\"
      },
      {
        "sha": "de7f3b48f5d6fb4036905b078bb8ec320d42bbc5",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 91,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d7afe2d1577eb3f6775301c81b94a191e0db99d9/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d7afe2d1577eb3f6775301c81b94a191e0db99d9/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=d7afe2d1577eb3f6775301c81b94a191e0db99d9",
        "patch": "@@ -16,8 +16,6 @@\n \n #include <boost/test/unit_test.hpp>\n \n-typedef std::vector<unsigned char> valtype;\n-\n BOOST_FIXTURE_TEST_SUITE(multisig_tests, BasicTestingSetup)\n \n CScript\n@@ -173,95 +171,6 @@ BOOST_AUTO_TEST_CASE(multisig_IsStandard)\n         BOOST_CHECK(!::IsStandard(malformed[i], whichType));\n }\n \n-BOOST_AUTO_TEST_CASE(multisig_Solver1)\n-{\n-    // Tests Solver() that returns lists of keys that are\n-    // required to satisfy a ScriptPubKey\n-    //\n-    // Also tests IsMine() and ExtractDestination()\n-    //\n-    // Note: ExtractDestination for the multisignature transactions\n-    // always returns false for this release, even if you have\n-    // one key that would satisfy an (a|b) or 2-of-3 keys needed\n-    // to spend an escrow transaction.\n-    //\n-    CBasicKeyStore keystore, emptykeystore, partialkeystore;\n-    CKey key[3];\n-    CTxDestination keyaddr[3];\n-    for (int i = 0; i < 3; i++)\n-    {\n-        key[i].MakeNewKey(true);\n-        keystore.AddKey(key[i]);\n-        keyaddr[i] = key[i].GetPubKey().GetID();\n-    }\n-    partialkeystore.AddKey(key[0]);\n-\n-    {\n-        std::vector<valtype> solutions;\n-        txnouttype whichType;\n-        CScript s;\n-        s << ToByteVector(key[0].GetPubKey()) << OP_CHECKSIG;\n-        BOOST_CHECK(Solver(s, whichType, solutions));\n-        BOOST_CHECK(solutions.size() == 1);\n-        CTxDestination addr;\n-        BOOST_CHECK(ExtractDestination(s, addr));\n-        BOOST_CHECK(addr == keyaddr[0]);\n-        BOOST_CHECK(IsMine(keystore, s));\n-        BOOST_CHECK(!IsMine(emptykeystore, s));\n-    }\n-    {\n-        std::vector<valtype> solutions;\n-        txnouttype whichType;\n-        CScript s;\n-        s << OP_DUP << OP_HASH160 << ToByteVector(key[0].GetPubKey().GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n-        BOOST_CHECK(Solver(s, whichType, solutions));\n-        BOOST_CHECK(solutions.size() == 1);\n-        CTxDestination addr;\n-        BOOST_CHECK(ExtractDestination(s, addr));\n-        BOOST_CHECK(addr == keyaddr[0]);\n-        BOOST_CHECK(IsMine(keystore, s));\n-        BOOST_CHECK(!IsMine(emptykeystore, s));\n-    }\n-    {\n-        std::vector<valtype> solutions;\n-        txnouttype whichType;\n-        CScript s;\n-        s << OP_2 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\n-        BOOST_CHECK(Solver(s, whichType, solutions));\n-        BOOST_CHECK_EQUAL(solutions.size(), 4U);\n-        CTxDestination addr;\n-        BOOST_CHECK(!ExtractDestination(s, addr));\n-        BOOST_CHECK(IsMine(keystore, s));\n-        BOOST_CHECK(!IsMine(emptykeystore, s));\n-        BOOST_CHECK(!IsMine(partialkeystore, s));\n-    }\n-    {\n-        std::vector<valtype> solutions;\n-        txnouttype whichType;\n-        CScript s;\n-        s << OP_1 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\n-        BOOST_CHECK(Solver(s, whichType, solutions));\n-        BOOST_CHECK_EQUAL(solutions.size(), 4U);\n-        std::vector<CTxDestination> addrs;\n-        int nRequired;\n-        BOOST_CHECK(ExtractDestinations(s, whichType, addrs, nRequired));\n-        BOOST_CHECK(addrs[0] == keyaddr[0]);\n-        BOOST_CHECK(addrs[1] == keyaddr[1]);\n-        BOOST_CHECK(nRequired == 1);\n-        BOOST_CHECK(IsMine(keystore, s));\n-        BOOST_CHECK(!IsMine(emptykeystore, s));\n-        BOOST_CHECK(!IsMine(partialkeystore, s));\n-    }\n-    {\n-        std::vector<valtype> solutions;\n-        txnouttype whichType;\n-        CScript s;\n-        s << OP_2 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << ToByteVector(key[2].GetPubKey()) << OP_3 << OP_CHECKMULTISIG;\n-        BOOST_CHECK(Solver(s, whichType, solutions));\n-        BOOST_CHECK(solutions.size() == 5);\n-    }\n-}\n-\n BOOST_AUTO_TEST_CASE(multisig_Sign)\n {\n     // Test SignSignature() (and therefore the version of Solver() that signs transactions)"
      },
      {
        "sha": "e6a63ad54eb3005c15be93cd72bf80b27e063ef3",
        "filename": "src/test/script_standard_tests.cpp",
        "status": "added",
        "additions": 385,
        "deletions": 0,
        "changes": 385,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d7afe2d1577eb3f6775301c81b94a191e0db99d9/src/test/script_standard_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d7afe2d1577eb3f6775301c81b94a191e0db99d9/src/test/script_standard_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_standard_tests.cpp?ref=d7afe2d1577eb3f6775301c81b94a191e0db99d9",
        "patch": "@@ -0,0 +1,385 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"key.h\"\n+#include \"script/script.h\"\n+#include \"script/script_error.h\"\n+#include \"script/standard.h\"\n+#include \"test/test_bitcoin.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+\n+BOOST_FIXTURE_TEST_SUITE(script_standard_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(script_standard_Solver_success)\n+{\n+    CKey keys[3];\n+    CPubKey pubkeys[3];\n+    for (int i = 0; i < 3; i++) {\n+        keys[i].MakeNewKey(true);\n+        pubkeys[i] = keys[i].GetPubKey();\n+    }\n+\n+    CScript s;\n+    txnouttype whichType;\n+    std::vector<std::vector<unsigned char> > solutions;\n+\n+    // TX_PUBKEY\n+    s.clear();\n+    s << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEY);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(pubkeys[0]));\n+\n+    // TX_PUBKEYHASH\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEYHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(pubkeys[0].GetID()));\n+\n+    // TX_SCRIPTHASH\n+    CScript redeemScript(s); // initialize with leftover P2PKH script\n+    s.clear();\n+    s << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_SCRIPTHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(CScriptID(redeemScript)));\n+\n+    // TX_MULTISIG\n+    s.clear();\n+    s << OP_1 <<\n+        ToByteVector(pubkeys[0]) <<\n+        ToByteVector(pubkeys[1]) <<\n+        OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_MULTISIG);\n+    BOOST_CHECK_EQUAL(solutions.size(), 4);\n+    BOOST_CHECK(solutions[0] == std::vector<unsigned char>({1}));\n+    BOOST_CHECK(solutions[1] == ToByteVector(pubkeys[0]));\n+    BOOST_CHECK(solutions[2] == ToByteVector(pubkeys[1]));\n+    BOOST_CHECK(solutions[3] == std::vector<unsigned char>({2}));\n+\n+    s.clear();\n+    s << OP_2 <<\n+        ToByteVector(pubkeys[0]) <<\n+        ToByteVector(pubkeys[1]) <<\n+        ToByteVector(pubkeys[2]) <<\n+        OP_3 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_MULTISIG);\n+    BOOST_CHECK_EQUAL(solutions.size(), 5);\n+    BOOST_CHECK(solutions[0] == std::vector<unsigned char>({2}));\n+    BOOST_CHECK(solutions[1] == ToByteVector(pubkeys[0]));\n+    BOOST_CHECK(solutions[2] == ToByteVector(pubkeys[1]));\n+    BOOST_CHECK(solutions[3] == ToByteVector(pubkeys[2]));\n+    BOOST_CHECK(solutions[4] == std::vector<unsigned char>({3}));\n+\n+    // TX_NULL_DATA\n+    solutions.clear();\n+    s.clear();\n+    s << OP_RETURN <<\n+        std::vector<unsigned char>({0}) <<\n+        std::vector<unsigned char>({75}) <<\n+        std::vector<unsigned char>({255});\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_NULL_DATA);\n+    BOOST_CHECK_EQUAL(solutions.size(), 0);\n+\n+    // TX_WITNESS_V0_KEYHASH\n+    solutions.clear();\n+    s.clear();\n+    s << OP_0 << ToByteVector(pubkeys[0].GetID());\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_WITNESS_V0_KEYHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(pubkeys[0].GetID()));\n+\n+    // TX_WITNESS_V0_SCRIPTHASH\n+    uint256 scriptHash;\n+    CSHA256().Write(&redeemScript[0], redeemScript.size()).Finalize(scriptHash.begin());\n+\n+    solutions.clear();\n+    s.clear();\n+    s << OP_0 << ToByteVector(scriptHash);\n+    BOOST_CHECK(Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_WITNESS_V0_SCRIPTHASH);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK(solutions[0] == ToByteVector(scriptHash));\n+\n+    // TX_NONSTANDARD\n+    solutions.clear();\n+    s.clear();\n+    s << OP_9 << OP_ADD << OP_11 << OP_EQUAL;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+    BOOST_CHECK_EQUAL(whichType, TX_NONSTANDARD);\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_Solver_failure)\n+{\n+    CKey key;\n+    CPubKey pubkey;\n+    key.MakeNewKey(true);\n+    pubkey = key.GetPubKey();\n+\n+    CScript s;\n+    txnouttype whichType;\n+    std::vector<std::vector<unsigned char> > solutions;\n+\n+    // TX_PUBKEY with incorrectly sized pubkey\n+    s.clear();\n+    s << std::vector<unsigned char>(30, 0x01) << OP_CHECKSIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_PUBKEYHASH with incorrectly sized key hash\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkey) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_SCRIPTHASH with incorrectly sized script hash\n+    s.clear();\n+    s << OP_HASH160 << std::vector<unsigned char>(21, 0x01) << OP_EQUAL;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_MULTISIG 0/2\n+    s.clear();\n+    s << OP_0 << ToByteVector(pubkey) << OP_1 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_MULTISIG 2/1\n+    s.clear();\n+    s << OP_2 << ToByteVector(pubkey) << OP_1 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_MULTISIG n = 2 with 1 pubkey\n+    s.clear();\n+    s << OP_1 << ToByteVector(pubkey) << OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_MULTISIG n = 1 with 0 pubkeys\n+    s.clear();\n+    s << OP_1 << OP_1 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_NULL_DATA with other opcodes\n+    s.clear();\n+    s << OP_RETURN << std::vector<unsigned char>({75}) << OP_ADD;\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_WITNESS with unknown version\n+    s.clear();\n+    s << OP_1 << ToByteVector(pubkey);\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+\n+    // TX_WITNESS with incorrect program size\n+    s.clear();\n+    s << OP_0 << std::vector<unsigned char>(19, 0x01);\n+    BOOST_CHECK(!Solver(s, whichType, solutions));\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_ExtractDestination)\n+{\n+    CKey key;\n+    CPubKey pubkey;\n+    key.MakeNewKey(true);\n+    pubkey = key.GetPubKey();\n+\n+    CScript s;\n+    CTxDestination address;\n+\n+    // TX_PUBKEY\n+    s.clear();\n+    s << ToByteVector(pubkey) << OP_CHECKSIG;\n+    BOOST_CHECK(ExtractDestination(s, address));\n+    BOOST_CHECK(boost::get<CKeyID>(&address) &&\n+                *boost::get<CKeyID>(&address) == pubkey.GetID());\n+\n+    // TX_PUBKEYHASH\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkey.GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(ExtractDestination(s, address));\n+    BOOST_CHECK(boost::get<CKeyID>(&address) &&\n+                *boost::get<CKeyID>(&address) == pubkey.GetID());\n+\n+    // TX_SCRIPTHASH\n+    CScript redeemScript(s); // initialize with leftover P2PKH script\n+    s.clear();\n+    s << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+    BOOST_CHECK(ExtractDestination(s, address));\n+    BOOST_CHECK(boost::get<CScriptID>(&address) &&\n+                *boost::get<CScriptID>(&address) == CScriptID(redeemScript));\n+\n+    // TX_MULTISIG\n+    s.clear();\n+    s << OP_1 << ToByteVector(pubkey) << OP_1 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!ExtractDestination(s, address));\n+\n+    // TX_NULL_DATA\n+    s.clear();\n+    s << OP_RETURN << std::vector<unsigned char>({75});\n+    BOOST_CHECK(!ExtractDestination(s, address));\n+\n+    // TX_WITNESS_V0_KEYHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(pubkey);\n+    BOOST_CHECK(!ExtractDestination(s, address));\n+\n+    // TX_WITNESS_V0_SCRIPTHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(CScriptID(redeemScript));\n+    BOOST_CHECK(!ExtractDestination(s, address));\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_ExtractDestinations)\n+{\n+    CKey keys[3];\n+    CPubKey pubkeys[3];\n+    for (int i = 0; i < 3; i++) {\n+        keys[i].MakeNewKey(true);\n+        pubkeys[i] = keys[i].GetPubKey();\n+    }\n+\n+    CScript s;\n+    txnouttype whichType;\n+    std::vector<CTxDestination> addresses;\n+    int nRequired;\n+\n+    // TX_PUBKEY\n+    s.clear();\n+    s << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n+    BOOST_CHECK(ExtractDestinations(s, whichType, addresses, nRequired));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEY);\n+    BOOST_CHECK_EQUAL(addresses.size(), 1);\n+    BOOST_CHECK_EQUAL(nRequired, 1);\n+    BOOST_CHECK(boost::get<CKeyID>(&addresses[0]) &&\n+                *boost::get<CKeyID>(&addresses[0]) == pubkeys[0].GetID());\n+\n+    // TX_PUBKEYHASH\n+    s.clear();\n+    s << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(ExtractDestinations(s, whichType, addresses, nRequired));\n+    BOOST_CHECK_EQUAL(whichType, TX_PUBKEYHASH);\n+    BOOST_CHECK_EQUAL(addresses.size(), 1);\n+    BOOST_CHECK_EQUAL(nRequired, 1);\n+    BOOST_CHECK(boost::get<CKeyID>(&addresses[0]) &&\n+                *boost::get<CKeyID>(&addresses[0]) == pubkeys[0].GetID());\n+\n+    // TX_SCRIPTHASH\n+    CScript redeemScript(s); // initialize with leftover P2PKH script\n+    s.clear();\n+    s << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+    BOOST_CHECK(ExtractDestinations(s, whichType, addresses, nRequired));\n+    BOOST_CHECK_EQUAL(whichType, TX_SCRIPTHASH);\n+    BOOST_CHECK_EQUAL(addresses.size(), 1);\n+    BOOST_CHECK_EQUAL(nRequired, 1);\n+    BOOST_CHECK(boost::get<CScriptID>(&addresses[0]) &&\n+                *boost::get<CScriptID>(&addresses[0]) == CScriptID(redeemScript));\n+\n+    // TX_MULTISIG\n+    s.clear();\n+    s << OP_2 <<\n+        ToByteVector(pubkeys[0]) <<\n+        ToByteVector(pubkeys[1]) <<\n+        OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(ExtractDestinations(s, whichType, addresses, nRequired));\n+    BOOST_CHECK_EQUAL(whichType, TX_MULTISIG);\n+    BOOST_CHECK_EQUAL(addresses.size(), 2);\n+    BOOST_CHECK_EQUAL(nRequired, 2);\n+    BOOST_CHECK(boost::get<CKeyID>(&addresses[0]) &&\n+                *boost::get<CKeyID>(&addresses[0]) == pubkeys[0].GetID());\n+    BOOST_CHECK(boost::get<CKeyID>(&addresses[1]) &&\n+                *boost::get<CKeyID>(&addresses[1]) == pubkeys[1].GetID());\n+\n+    // TX_NULL_DATA\n+    s.clear();\n+    s << OP_RETURN << std::vector<unsigned char>({75});\n+    BOOST_CHECK(!ExtractDestinations(s, whichType, addresses, nRequired));\n+\n+    // TX_WITNESS_V0_KEYHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(pubkeys[0].GetID());\n+    BOOST_CHECK(!ExtractDestinations(s, whichType, addresses, nRequired));\n+\n+    // TX_WITNESS_V0_SCRIPTHASH\n+    s.clear();\n+    s << OP_0 << ToByteVector(CScriptID(redeemScript));\n+    BOOST_CHECK(!ExtractDestinations(s, whichType, addresses, nRequired));\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_GetScriptFor_)\n+{\n+    CKey keys[3];\n+    CPubKey pubkeys[3];\n+    for (int i = 0; i < 3; i++) {\n+        keys[i].MakeNewKey(true);\n+        pubkeys[i] = keys[i].GetPubKey();\n+    }\n+\n+    CScript expected, result;\n+\n+    // CKeyID\n+    expected.clear();\n+    expected << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    result = GetScriptForDestination(pubkeys[0].GetID());\n+    BOOST_CHECK(result == expected);\n+\n+    // CScriptID\n+    CScript redeemScript(result);\n+    expected.clear();\n+    expected << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+    result = GetScriptForDestination(CScriptID(redeemScript));\n+    BOOST_CHECK(result == expected);\n+\n+    // CNoDestination\n+    expected.clear();\n+    result = GetScriptForDestination(CNoDestination());\n+    BOOST_CHECK(result == expected);\n+\n+    // GetScriptForRawPubKey\n+    expected.clear();\n+    expected << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n+    result = GetScriptForRawPubKey(pubkeys[0]);\n+    BOOST_CHECK(result == expected);\n+\n+    // GetScriptForMultisig\n+    expected.clear();\n+    expected << OP_2 <<\n+        ToByteVector(pubkeys[0]) <<\n+        ToByteVector(pubkeys[1]) <<\n+        ToByteVector(pubkeys[2]) <<\n+        OP_3 << OP_CHECKMULTISIG;\n+    result = GetScriptForMultisig(2, std::vector<CPubKey>(pubkeys, pubkeys + 3));\n+    BOOST_CHECK(result == expected);\n+\n+    // GetScriptForWitness\n+    CScript witnessScript;\n+\n+    witnessScript << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n+    expected.clear();\n+    expected << OP_0 << ToByteVector(pubkeys[0].GetID());\n+    result = GetScriptForWitness(witnessScript);\n+    BOOST_CHECK(result == expected);\n+\n+    witnessScript.clear();\n+    witnessScript << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    result = GetScriptForWitness(witnessScript);\n+    BOOST_CHECK(result == expected);\n+\n+    witnessScript.clear();\n+    witnessScript << OP_1 << ToByteVector(pubkeys[0]) << OP_1 << OP_CHECKMULTISIG;\n+\n+    uint256 scriptHash;\n+    CSHA256().Write(&witnessScript[0], witnessScript.size()).Finalize(scriptHash.begin());\n+\n+    expected.clear();\n+    expected << OP_0 << ToByteVector(scriptHash);\n+    result = GetScriptForWitness(witnessScript);\n+    BOOST_CHECK(result == expected);\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "7a1e873b27b790c965d9927ecd465710dc103136",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3YTFlODczYjI3Yjc5MGM5NjVkOTkyN2VjZDQ2NTcxMGRjMTAzMTM2",
    "commit": {
      "author": {
        "name": "Jim Posen",
        "email": "jimpo@coinbase.com",
        "date": "2017-08-23T00:47:59Z"
      },
      "committer": {
        "name": "Jim Posen",
        "email": "jimpo@coinbase.com",
        "date": "2017-09-21T19:24:23Z"
      },
      "message": "[script] Unit tests for IsMine\n\nDoes not test watch-only addresses.",
      "tree": {
        "sha": "ec57b1c186b742f4539c40de63472c287ba78f23",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ec57b1c186b742f4539c40de63472c287ba78f23"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7a1e873b27b790c965d9927ecd465710dc103136",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7a1e873b27b790c965d9927ecd465710dc103136",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7a1e873b27b790c965d9927ecd465710dc103136",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7a1e873b27b790c965d9927ecd465710dc103136/comments",
    "author": {
      "login": "jimpo",
      "id": 881253,
      "node_id": "MDQ6VXNlcjg4MTI1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jimpo",
      "html_url": "https://github.com/jimpo",
      "followers_url": "https://api.github.com/users/jimpo/followers",
      "following_url": "https://api.github.com/users/jimpo/following{/other_user}",
      "gists_url": "https://api.github.com/users/jimpo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
      "organizations_url": "https://api.github.com/users/jimpo/orgs",
      "repos_url": "https://api.github.com/users/jimpo/repos",
      "events_url": "https://api.github.com/users/jimpo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jimpo/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jimpo",
      "id": 881253,
      "node_id": "MDQ6VXNlcjg4MTI1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jimpo",
      "html_url": "https://github.com/jimpo",
      "followers_url": "https://api.github.com/users/jimpo/followers",
      "following_url": "https://api.github.com/users/jimpo/following{/other_user}",
      "gists_url": "https://api.github.com/users/jimpo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
      "organizations_url": "https://api.github.com/users/jimpo/orgs",
      "repos_url": "https://api.github.com/users/jimpo/repos",
      "events_url": "https://api.github.com/users/jimpo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jimpo/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d7afe2d1577eb3f6775301c81b94a191e0db99d9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d7afe2d1577eb3f6775301c81b94a191e0db99d9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d7afe2d1577eb3f6775301c81b94a191e0db99d9"
      }
    ],
    "stats": {
      "total": 369,
      "additions": 363,
      "deletions": 6
    },
    "files": [
      {
        "sha": "c3aade1774767085b6e6502e3397f9b0b18f9b13",
        "filename": "src/script/ismine.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a1e873b27b790c965d9927ecd465710dc103136/src/script/ismine.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a1e873b27b790c965d9927ecd465710dc103136/src/script/ismine.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/ismine.cpp?ref=7a1e873b27b790c965d9927ecd465710dc103136",
        "patch": "@@ -46,6 +46,8 @@ isminetype IsMine(const CKeyStore &keystore, const CTxDestination& dest, bool& i\n \n isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey, bool& isInvalid, SigVersion sigversion)\n {\n+    isInvalid = false;\n+\n     std::vector<valtype> vSolutions;\n     txnouttype whichType;\n     if (!Solver(scriptPubKey, whichType, vSolutions)) {"
      },
      {
        "sha": "3d17a0dbb6c6ab03c8e9a60d4bc71c069dfa2ee5",
        "filename": "src/test/script_standard_tests.cpp",
        "status": "modified",
        "additions": 361,
        "deletions": 6,
        "changes": 367,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a1e873b27b790c965d9927ecd465710dc103136/src/test/script_standard_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a1e873b27b790c965d9927ecd465710dc103136/src/test/script_standard_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_standard_tests.cpp?ref=7a1e873b27b790c965d9927ecd465710dc103136",
        "patch": "@@ -3,6 +3,8 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"key.h\"\n+#include \"keystore.h\"\n+#include \"script/ismine.h\"\n #include \"script/script.h\"\n #include \"script/script_error.h\"\n #include \"script/standard.h\"\n@@ -81,7 +83,6 @@ BOOST_AUTO_TEST_CASE(script_standard_Solver_success)\n     BOOST_CHECK(solutions[4] == std::vector<unsigned char>({3}));\n \n     // TX_NULL_DATA\n-    solutions.clear();\n     s.clear();\n     s << OP_RETURN <<\n         std::vector<unsigned char>({0}) <<\n@@ -92,7 +93,6 @@ BOOST_AUTO_TEST_CASE(script_standard_Solver_success)\n     BOOST_CHECK_EQUAL(solutions.size(), 0);\n \n     // TX_WITNESS_V0_KEYHASH\n-    solutions.clear();\n     s.clear();\n     s << OP_0 << ToByteVector(pubkeys[0].GetID());\n     BOOST_CHECK(Solver(s, whichType, solutions));\n@@ -102,9 +102,9 @@ BOOST_AUTO_TEST_CASE(script_standard_Solver_success)\n \n     // TX_WITNESS_V0_SCRIPTHASH\n     uint256 scriptHash;\n-    CSHA256().Write(&redeemScript[0], redeemScript.size()).Finalize(scriptHash.begin());\n+    CSHA256().Write(&redeemScript[0], redeemScript.size())\n+        .Finalize(scriptHash.begin());\n \n-    solutions.clear();\n     s.clear();\n     s << OP_0 << ToByteVector(scriptHash);\n     BOOST_CHECK(Solver(s, whichType, solutions));\n@@ -113,7 +113,6 @@ BOOST_AUTO_TEST_CASE(script_standard_Solver_success)\n     BOOST_CHECK(solutions[0] == ToByteVector(scriptHash));\n \n     // TX_NONSTANDARD\n-    solutions.clear();\n     s.clear();\n     s << OP_9 << OP_ADD << OP_11 << OP_EQUAL;\n     BOOST_CHECK(!Solver(s, whichType, solutions));\n@@ -374,12 +373,368 @@ BOOST_AUTO_TEST_CASE(script_standard_GetScriptFor_)\n     witnessScript << OP_1 << ToByteVector(pubkeys[0]) << OP_1 << OP_CHECKMULTISIG;\n \n     uint256 scriptHash;\n-    CSHA256().Write(&witnessScript[0], witnessScript.size()).Finalize(scriptHash.begin());\n+    CSHA256().Write(&witnessScript[0], witnessScript.size())\n+        .Finalize(scriptHash.begin());\n \n     expected.clear();\n     expected << OP_0 << ToByteVector(scriptHash);\n     result = GetScriptForWitness(witnessScript);\n     BOOST_CHECK(result == expected);\n }\n \n+BOOST_AUTO_TEST_CASE(script_standard_IsMine)\n+{\n+    CKey keys[2];\n+    CPubKey pubkeys[2];\n+    for (int i = 0; i < 2; i++) {\n+        keys[i].MakeNewKey(true);\n+        pubkeys[i] = keys[i].GetPubKey();\n+    }\n+\n+    CKey uncompressedKey;\n+    uncompressedKey.MakeNewKey(false);\n+    CPubKey uncompressedPubkey = uncompressedKey.GetPubKey();\n+\n+    CScript scriptPubKey;\n+    isminetype result;\n+    bool isInvalid;\n+\n+    // P2PK compressed\n+    {\n+        CBasicKeyStore keystore;\n+        scriptPubKey.clear();\n+        scriptPubKey << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n+\n+        // Keystore does not have key\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+\n+        // Keystore has key\n+        keystore.AddKey(keys[0]);\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n+        BOOST_CHECK(!isInvalid);\n+    }\n+\n+    // P2PK uncompressed\n+    {\n+        CBasicKeyStore keystore;\n+        scriptPubKey.clear();\n+        scriptPubKey << ToByteVector(uncompressedPubkey) << OP_CHECKSIG;\n+\n+        // Keystore does not have key\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+\n+        // Keystore has key\n+        keystore.AddKey(uncompressedKey);\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n+        BOOST_CHECK(!isInvalid);\n+    }\n+\n+    // P2PKH compressed\n+    {\n+        CBasicKeyStore keystore;\n+        scriptPubKey.clear();\n+        scriptPubKey << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+\n+        // Keystore does not have key\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+\n+        // Keystore has key\n+        keystore.AddKey(keys[0]);\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n+        BOOST_CHECK(!isInvalid);\n+    }\n+\n+    // P2PKH uncompressed\n+    {\n+        CBasicKeyStore keystore;\n+        scriptPubKey.clear();\n+        scriptPubKey << OP_DUP << OP_HASH160 << ToByteVector(uncompressedPubkey.GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+\n+        // Keystore does not have key\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+\n+        // Keystore has key\n+        keystore.AddKey(uncompressedKey);\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n+        BOOST_CHECK(!isInvalid);\n+    }\n+\n+    // P2SH\n+    {\n+        CBasicKeyStore keystore;\n+\n+        CScript redeemScript;\n+        redeemScript << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+\n+        scriptPubKey.clear();\n+        scriptPubKey << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+\n+        // Keystore does not have redeemScript or key\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+\n+        // Keystore has redeemScript but no key\n+        keystore.AddCScript(redeemScript);\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+\n+        // Keystore has redeemScript and key\n+        keystore.AddKey(keys[0]);\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n+        BOOST_CHECK(!isInvalid);\n+    }\n+\n+    // P2WPKH compressed\n+    {\n+        CBasicKeyStore keystore;\n+        keystore.AddKey(keys[0]);\n+\n+        scriptPubKey.clear();\n+        scriptPubKey << OP_0 << ToByteVector(pubkeys[0].GetID());\n+\n+        // Keystore has key, but no P2SH redeemScript\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+\n+        // Keystore has key and P2SH redeemScript\n+        keystore.AddCScript(scriptPubKey);\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n+        BOOST_CHECK(!isInvalid);\n+    }\n+\n+    // P2WPKH uncompressed\n+    {\n+        CBasicKeyStore keystore;\n+        keystore.AddKey(uncompressedKey);\n+\n+        scriptPubKey.clear();\n+        scriptPubKey << OP_0 << ToByteVector(uncompressedPubkey.GetID());\n+\n+        // Keystore has key, but no P2SH redeemScript\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+\n+        // Keystore has key and P2SH redeemScript\n+        keystore.AddCScript(scriptPubKey);\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(isInvalid);\n+    }\n+\n+    // scriptPubKey multisig\n+    {\n+        CBasicKeyStore keystore;\n+\n+        scriptPubKey.clear();\n+        scriptPubKey << OP_2 <<\n+            ToByteVector(uncompressedPubkey) <<\n+            ToByteVector(pubkeys[1]) <<\n+            OP_2 << OP_CHECKMULTISIG;\n+\n+        // Keystore does not have any keys\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+\n+        // Keystore has 1/2 keys\n+        keystore.AddKey(uncompressedKey);\n+\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+\n+        // Keystore has 2/2 keys\n+        keystore.AddKey(keys[1]);\n+\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n+        BOOST_CHECK(!isInvalid);\n+    }\n+\n+    // P2SH multisig\n+    {\n+        CBasicKeyStore keystore;\n+        keystore.AddKey(uncompressedKey);\n+        keystore.AddKey(keys[1]);\n+\n+        CScript redeemScript;\n+        redeemScript << OP_2 <<\n+            ToByteVector(uncompressedPubkey) <<\n+            ToByteVector(pubkeys[1]) <<\n+            OP_2 << OP_CHECKMULTISIG;\n+\n+        scriptPubKey.clear();\n+        scriptPubKey << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+\n+        // Keystore has no redeemScript\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+\n+        // Keystore has redeemScript\n+        keystore.AddCScript(redeemScript);\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n+        BOOST_CHECK(!isInvalid);\n+    }\n+\n+    // P2WSH multisig with compressed keys\n+    {\n+        CBasicKeyStore keystore;\n+        keystore.AddKey(keys[0]);\n+        keystore.AddKey(keys[1]);\n+\n+        CScript witnessScript;\n+        witnessScript << OP_2 <<\n+            ToByteVector(pubkeys[0]) <<\n+            ToByteVector(pubkeys[1]) <<\n+            OP_2 << OP_CHECKMULTISIG;\n+\n+        uint256 scriptHash;\n+        CSHA256().Write(&witnessScript[0], witnessScript.size())\n+            .Finalize(scriptHash.begin());\n+\n+        scriptPubKey.clear();\n+        scriptPubKey << OP_0 << ToByteVector(scriptHash);\n+\n+        // Keystore has keys, but no witnessScript or P2SH redeemScript\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+\n+        // Keystore has keys and witnessScript, but no P2SH redeemScript\n+        keystore.AddCScript(witnessScript);\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+\n+        // Keystore has keys, witnessScript, P2SH redeemScript\n+        keystore.AddCScript(scriptPubKey);\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n+        BOOST_CHECK(!isInvalid);\n+    }\n+\n+    // P2WSH multisig with uncompressed key\n+    {\n+        CBasicKeyStore keystore;\n+        keystore.AddKey(uncompressedKey);\n+        keystore.AddKey(keys[1]);\n+\n+        CScript witnessScript;\n+        witnessScript << OP_2 <<\n+            ToByteVector(uncompressedPubkey) <<\n+            ToByteVector(pubkeys[1]) <<\n+            OP_2 << OP_CHECKMULTISIG;\n+\n+        uint256 scriptHash;\n+        CSHA256().Write(&witnessScript[0], witnessScript.size())\n+            .Finalize(scriptHash.begin());\n+\n+        scriptPubKey.clear();\n+        scriptPubKey << OP_0 << ToByteVector(scriptHash);\n+\n+        // Keystore has keys, but no witnessScript or P2SH redeemScript\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+\n+        // Keystore has keys and witnessScript, but no P2SH redeemScript\n+        keystore.AddCScript(witnessScript);\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+\n+        // Keystore has keys, witnessScript, P2SH redeemScript\n+        keystore.AddCScript(scriptPubKey);\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(isInvalid);\n+    }\n+\n+    // P2WSH multisig wrapped in P2SH\n+    {\n+        CBasicKeyStore keystore;\n+\n+        CScript witnessScript;\n+        witnessScript << OP_2 <<\n+            ToByteVector(pubkeys[0]) <<\n+            ToByteVector(pubkeys[1]) <<\n+            OP_2 << OP_CHECKMULTISIG;\n+\n+        uint256 scriptHash;\n+        CSHA256().Write(&witnessScript[0], witnessScript.size())\n+            .Finalize(scriptHash.begin());\n+\n+        CScript redeemScript;\n+        redeemScript << OP_0 << ToByteVector(scriptHash);\n+\n+        scriptPubKey.clear();\n+        scriptPubKey << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n+\n+        // Keystore has no witnessScript, P2SH redeemScript, or keys\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+\n+        // Keystore has witnessScript and P2SH redeemScript, but no keys\n+        keystore.AddCScript(redeemScript);\n+        keystore.AddCScript(witnessScript);\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+\n+        // Keystore has keys, witnessScript, P2SH redeemScript\n+        keystore.AddKey(keys[0]);\n+        keystore.AddKey(keys[1]);\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n+        BOOST_CHECK(!isInvalid);\n+    }\n+\n+    // OP_RETURN\n+    {\n+        CBasicKeyStore keystore;\n+        keystore.AddKey(keys[0]);\n+\n+        scriptPubKey.clear();\n+        scriptPubKey << OP_RETURN << ToByteVector(pubkeys[0]);\n+\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+    }\n+\n+    // Nonstandard\n+    {\n+        CBasicKeyStore keystore;\n+        keystore.AddKey(keys[0]);\n+\n+        scriptPubKey.clear();\n+        scriptPubKey << OP_9 << OP_ADD << OP_11 << OP_EQUAL;\n+\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+    }\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  }
]