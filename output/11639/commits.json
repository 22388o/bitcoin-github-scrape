[
  {
    "sha": "711f775986af9a87aa03ddfda7e79f85861a8947",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3MTFmNzc1OTg2YWY5YTg3YWEwM2RkZmRhN2U3OWY4NTg2MWE4OTQ3",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-27T22:22:56Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-05-14T16:50:12Z"
      },
      "message": "Add useful-for-dos \"reason\" field to CValidationState\n\nThis is a first step towards cleaning up our DoS interface - make\nvalidation return *why* something is invalid, and let net_processing\nfigure out what that implies in terms of banning/disconnection/etc.",
      "tree": {
        "sha": "0afed485c2e0e6824393a3f125e3d895fc7ac6ad",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0afed485c2e0e6824393a3f125e3d895fc7ac6ad"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/711f775986af9a87aa03ddfda7e79f85861a8947",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/711f775986af9a87aa03ddfda7e79f85861a8947",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/711f775986af9a87aa03ddfda7e79f85861a8947",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/711f775986af9a87aa03ddfda7e79f85861a8947/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c5870ab689995e7dc1ada530e9db27cfae9bb448",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c5870ab689995e7dc1ada530e9db27cfae9bb448",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c5870ab689995e7dc1ada530e9db27cfae9bb448"
      }
    ],
    "stats": {
      "total": 231,
      "additions": 150,
      "deletions": 81
    },
    "files": [
      {
        "sha": "95b42fea4cfe621a1aa0c24a93385d356b19e9b1",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/711f775986af9a87aa03ddfda7e79f85861a8947/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/711f775986af9a87aa03ddfda7e79f85861a8947/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=711f775986af9a87aa03ddfda7e79f85861a8947",
        "patch": "@@ -160,24 +160,24 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n {\n     // Basic checks that don't depend on any context\n     if (tx.vin.empty())\n-        return state.DoS(10, false, REJECT_INVALID, \"bad-txns-vin-empty\");\n+        return state.DoS(10, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-vin-empty\");\n     if (tx.vout.empty())\n-        return state.DoS(10, false, REJECT_INVALID, \"bad-txns-vout-empty\");\n+        return state.DoS(10, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-vout-empty\");\n     // Size limits (this doesn't take the witness into account, as that hasn't been checked for malleability)\n     if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-oversize\");\n+        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-oversize\");\n \n     // Check for negative or overflow output values\n     CAmount nValueOut = 0;\n     for (const auto& txout : tx.vout)\n     {\n         if (txout.nValue < 0)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vout-negative\");\n+            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-vout-negative\");\n         if (txout.nValue > MAX_MONEY)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vout-toolarge\");\n+            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-vout-toolarge\");\n         nValueOut += txout.nValue;\n         if (!MoneyRange(nValueOut))\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-txouttotal-toolarge\");\n+            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-txouttotal-toolarge\");\n     }\n \n     // Check for duplicate inputs - note that this check is slow so we skip it in CheckBlock\n@@ -186,20 +186,20 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n         for (const auto& txin : tx.vin)\n         {\n             if (!vInOutPoints.insert(txin.prevout).second)\n-                return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n+                return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n         }\n     }\n \n     if (tx.IsCoinBase())\n     {\n         if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 100)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-length\");\n+            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-cb-length\");\n     }\n     else\n     {\n         for (const auto& txin : tx.vin)\n             if (txin.prevout.IsNull())\n-                return state.DoS(10, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n+                return state.DoS(10, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n     }\n \n     return true;\n@@ -209,7 +209,7 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n {\n     // are the actual inputs available?\n     if (!inputs.HaveInputs(tx)) {\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-missingorspent\", false,\n+        return state.DoS(100, ValidationInvalidReason::TX_MISSING_INPUTS, false, REJECT_INVALID, \"bad-txns-inputs-missingorspent\", false,\n                          strprintf(\"%s: inputs missing/spent\", __func__));\n     }\n \n@@ -221,28 +221,28 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n \n         // If prev is coinbase, check that it's matured\n         if (coin.IsCoinBase() && nSpendHeight - coin.nHeight < COINBASE_MATURITY) {\n-            return state.Invalid(false,\n+            return state.Invalid(ValidationInvalidReason::TX_MISSING_INPUTS, false,\n                 REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\",\n                 strprintf(\"tried to spend coinbase at depth %d\", nSpendHeight - coin.nHeight));\n         }\n \n         // Check for negative or overflow input values\n         nValueIn += coin.out.nValue;\n         if (!MoneyRange(coin.out.nValue) || !MoneyRange(nValueIn)) {\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputvalues-outofrange\");\n+            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-inputvalues-outofrange\");\n         }\n     }\n \n     const CAmount value_out = tx.GetValueOut();\n     if (nValueIn < value_out) {\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-in-belowout\", false,\n+        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-in-belowout\", false,\n             strprintf(\"value in (%s) < value out (%s)\", FormatMoney(nValueIn), FormatMoney(value_out)));\n     }\n \n     // Tally transaction fees\n     const CAmount txfee_aux = nValueIn - value_out;\n     if (!MoneyRange(txfee_aux)) {\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-fee-outofrange\");\n+        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-fee-outofrange\");\n     }\n \n     txfee = txfee_aux;"
      },
      {
        "sha": "970c04e8645ac27bab7f5a00df0dc4cb307cf2eb",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 51,
        "deletions": 4,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/711f775986af9a87aa03ddfda7e79f85861a8947/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/711f775986af9a87aa03ddfda7e79f85861a8947/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=711f775986af9a87aa03ddfda7e79f85861a8947",
        "patch": "@@ -22,6 +22,49 @@ static const unsigned char REJECT_NONSTANDARD = 0x40;\n static const unsigned char REJECT_INSUFFICIENTFEE = 0x42;\n static const unsigned char REJECT_CHECKPOINT = 0x43;\n \n+/** A \"reason\" why something was invalid, suitable for determining whether the\n+  * provider of the object should be banned/ignored/disconnected/etc.\n+  * These are much more granular than the rejection codes, which may be more\n+  * useful for some other use-cases.\n+  */\n+enum class ValidationInvalidReason {\n+    // txn and blocks:\n+    NONE,                    //!< not actually invalid\n+    CONSENSUS,               //!< invalid by consensus rules (excluding any below reasons)\n+    /**\n+     * Invalid by a change to consensus rules more recent than SegWit.\n+     * Currently unused as there are no such consensus rule changes, and any download\n+     * sources realistically need to support SegWit in order to provide useful data,\n+     * so differentiating between always-invalid and invalid-by-pre-SegWit-soft-fork\n+     * is uninteresting.\n+     */\n+    RECENT_CONSENSUS_CHANGE,\n+    CACHED_INVALID,          //!< this object was cached as being invalid, but we don't know why\n+    // Only blocks:\n+    BLOCK_MUTATED,           //!< the block's data didn't match the data committed to by the PoW\n+    BLOCK_MISSING_PREV,      //!< We don't have the previous block the checked one is built on\n+    BLOCK_INVALID_PREV,      //!< A block this one builds on is invalid\n+    BLOCK_BAD_TIME,          //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    BLOCK_CHECKPOINT,        //!< the block failed to meet one of our checkpoints\n+    // Only loose txn:\n+    TX_NOT_STANDARD,          //!< didn't meet our local policy rules\n+    TX_MISSING_INPUTS,        //!< a transaction was missing some of its inputs (or its inputs were spent at < coinbase maturity height)\n+    /**\n+     * Transaction might be missing a witness, have a witness prior to SegWit\n+     * activation, or witness may have been malleated (which includes\n+     * non-standard witnesses).\n+     */\n+    TX_WITNESS_MUTATED,\n+    /**\n+     * Tx already in mempool or conflicts with a tx in the chain\n+     * (if it conflicts with another tx in mempool, we use MEMPOOL_POLICY as it failed to reach the RBF threshold)\n+     * TODO: Currently this is only used if the transaction already exists in the mempool or on chain,\n+     * TODO: ATMP's fMissingInputs and a valid CValidationState being used to indicate missing inputs\n+     */\n+    TX_CONFLICT,\n+    TX_MEMPOOL_POLICY,        //!< violated mempool's fee/size/descendant/RBF/etc limits\n+};\n+\n /** Capture information about block/transaction validation */\n class CValidationState {\n private:\n@@ -30,17 +73,19 @@ class CValidationState {\n         MODE_INVALID, //!< network rule violation (DoS value may be set)\n         MODE_ERROR,   //!< run-time error\n     } mode;\n+    ValidationInvalidReason reason;\n     int nDoS;\n     std::string strRejectReason;\n     unsigned int chRejectCode;\n     bool corruptionPossible;\n     std::string strDebugMessage;\n public:\n-    CValidationState() : mode(MODE_VALID), nDoS(0), chRejectCode(0), corruptionPossible(false) {}\n-    bool DoS(int level, bool ret = false,\n+    CValidationState() : mode(MODE_VALID), reason(ValidationInvalidReason::NONE), nDoS(0), chRejectCode(0), corruptionPossible(false) {}\n+    bool DoS(int level, ValidationInvalidReason reasonIn, bool ret = false,\n              unsigned int chRejectCodeIn=0, const std::string &strRejectReasonIn=\"\",\n              bool corruptionIn=false,\n              const std::string &strDebugMessageIn=\"\") {\n+        reason = reasonIn;\n         chRejectCode = chRejectCodeIn;\n         strRejectReason = strRejectReasonIn;\n         corruptionPossible = corruptionIn;\n@@ -51,10 +96,10 @@ class CValidationState {\n         mode = MODE_INVALID;\n         return ret;\n     }\n-    bool Invalid(bool ret = false,\n+    bool Invalid(ValidationInvalidReason _reason, bool ret = false,\n                  unsigned int _chRejectCode=0, const std::string &_strRejectReason=\"\",\n                  const std::string &_strDebugMessage=\"\") {\n-        return DoS(0, ret, _chRejectCode, _strRejectReason, false, _strDebugMessage);\n+        return DoS(0, _reason, ret, _chRejectCode, _strRejectReason, false, _strDebugMessage);\n     }\n     bool Error(const std::string& strRejectReasonIn) {\n         if (mode == MODE_VALID)\n@@ -84,6 +129,8 @@ class CValidationState {\n     void SetCorruptionPossible() {\n         corruptionPossible = true;\n     }\n+    ValidationInvalidReason GetReason() const { return reason; }\n+    int GetDoS() const { return nDoS; }\n     unsigned int GetRejectCode() const { return chRejectCode; }\n     std::string GetRejectReason() const { return strRejectReason; }\n     std::string GetDebugMessage() const { return strDebugMessage; }"
      },
      {
        "sha": "2c726945dfa6ee1ec2c551744323481209957a98",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 85,
        "deletions": 63,
        "changes": 148,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/711f775986af9a87aa03ddfda7e79f85861a8947/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/711f775986af9a87aa03ddfda7e79f85861a8947/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=711f775986af9a87aa03ddfda7e79f85861a8947",
        "patch": "@@ -569,34 +569,34 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n     // Coinbase is only valid in a block, not as a loose transaction\n     if (tx.IsCoinBase())\n-        return state.DoS(100, false, REJECT_INVALID, \"coinbase\");\n+        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"coinbase\");\n \n     // Reject transactions with witness before segregated witness activates (override with -prematurewitness)\n     bool witnessEnabled = IsWitnessEnabled(chainActive.Tip(), chainparams.GetConsensus());\n     if (!gArgs.GetBoolArg(\"-prematurewitness\", false) && tx.HasWitness() && !witnessEnabled) {\n-        return state.DoS(0, false, REJECT_NONSTANDARD, \"no-witness-yet\", true);\n+        return state.DoS(0, ValidationInvalidReason::TX_WITNESS_MUTATED, false, REJECT_NONSTANDARD, \"no-witness-yet\", true);\n     }\n \n     // Rather not work on nonstandard transactions (unless -testnet/-regtest)\n     std::string reason;\n     if (fRequireStandard && !IsStandardTx(tx, reason, witnessEnabled))\n-        return state.DoS(0, false, REJECT_NONSTANDARD, reason);\n+        return state.DoS(0, ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, reason);\n \n     // Do not work on transactions that are too small.\n     // A transaction with 1 segwit input and 1 P2WPHK output has non-witness size of 82 bytes.\n     // Transactions smaller than this are not relayed to reduce unnecessary malloc overhead.\n     if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) < MIN_STANDARD_TX_NONWITNESS_SIZE)\n-        return state.DoS(0, false, REJECT_NONSTANDARD, \"tx-size-small\");\n+        return state.DoS(0, ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"tx-size-small\");\n \n     // Only accept nLockTime-using transactions that can be mined in the next\n     // block; we don't want our mempool filled up with transactions that can't\n     // be mined yet.\n     if (!CheckFinalTx(tx, STANDARD_LOCKTIME_VERIFY_FLAGS))\n-        return state.DoS(0, false, REJECT_NONSTANDARD, \"non-final\");\n+        return state.DoS(0, ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"non-final\");\n \n     // is it already in the memory pool?\n     if (pool.exists(hash)) {\n-        return state.Invalid(false, REJECT_DUPLICATE, \"txn-already-in-mempool\");\n+        return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, REJECT_DUPLICATE, \"txn-already-in-mempool\");\n     }\n \n     // Check for conflicts with in-memory transactions\n@@ -634,7 +634,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     }\n                 }\n                 if (fReplacementOptOut) {\n-                    return state.Invalid(false, REJECT_DUPLICATE, \"txn-mempool-conflict\");\n+                    return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_DUPLICATE, \"txn-mempool-conflict\");\n                 }\n \n                 setConflicts.insert(ptxConflicting->GetHash());\n@@ -660,7 +660,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 for (size_t out = 0; out < tx.vout.size(); out++) {\n                     // Optimistically just do efficient check of cache for outputs\n                     if (pcoinsTip->HaveCoinInCache(COutPoint(hash, out))) {\n-                        return state.Invalid(false, REJECT_DUPLICATE, \"txn-already-known\");\n+                        return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, REJECT_DUPLICATE, \"txn-already-known\");\n                     }\n                 }\n                 // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n@@ -683,7 +683,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n         // CoinsViewCache instead of create its own\n         if (!CheckSequenceLocks(tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n-            return state.DoS(0, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n+            return state.DoS(0, ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n \n         CAmount nFees = 0;\n         if (!Consensus::CheckTxInputs(tx, state, view, GetSpendHeight(view), nFees)) {\n@@ -692,11 +692,11 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n         // Check for non-standard pay-to-script-hash in inputs\n         if (fRequireStandard && !AreInputsStandard(tx, view))\n-            return state.Invalid(false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n+            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n \n         // Check for non-standard witness in P2WSH\n         if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, view))\n-            return state.DoS(0, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\", true);\n+            return state.DoS(0, ValidationInvalidReason::TX_WITNESS_MUTATED, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\", true);\n \n         int64_t nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);\n \n@@ -719,27 +719,22 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                               fSpendsCoinbase, nSigOpsCost, lp);\n         unsigned int nSize = entry.GetTxSize();\n \n-        // Check that the transaction doesn't have an excessive number of\n-        // sigops, making it impossible to mine. Since the coinbase transaction\n-        // itself can contain sigops MAX_STANDARD_TX_SIGOPS is less than\n-        // MAX_BLOCK_SIGOPS; we still consider this an invalid rather than\n-        // merely non-standard transaction.\n         if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n-            return state.DoS(0, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\", false,\n+            return state.DoS(0, ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\", false,\n                 strprintf(\"%d\", nSigOpsCost));\n \n         CAmount mempoolRejectFee = pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(nSize);\n         if (!bypass_limits && mempoolRejectFee > 0 && nModifiedFees < mempoolRejectFee) {\n-            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", false, strprintf(\"%d < %d\", nModifiedFees, mempoolRejectFee));\n+            return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", false, strprintf(\"%d < %d\", nModifiedFees, mempoolRejectFee));\n         }\n \n         // No transactions are allowed below minRelayTxFee except from disconnected blocks\n         if (!bypass_limits && nModifiedFees < ::minRelayTxFee.GetFee(nSize)) {\n-            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"min relay fee not met\", false, strprintf(\"%d < %d\", nModifiedFees, ::minRelayTxFee.GetFee(nSize)));\n+            return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"min relay fee not met\", false, strprintf(\"%d < %d\", nModifiedFees, ::minRelayTxFee.GetFee(nSize)));\n         }\n \n         if (nAbsurdFee && nFees > nAbsurdFee)\n-            return state.Invalid(false,\n+            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false,\n                 REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n@@ -751,7 +746,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n         std::string errString;\n         if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n-            return state.DoS(0, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", false, errString);\n+            return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", false, errString);\n         }\n \n         // A transaction that spends outputs that would be replaced by it is invalid. Now\n@@ -763,7 +758,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n             if (setConflicts.count(hashAncestor))\n             {\n-                return state.DoS(10, false,\n+                return state.DoS(10, ValidationInvalidReason::CONSENSUS, false,\n                                  REJECT_INVALID, \"bad-txns-spends-conflicting-tx\", false,\n                                  strprintf(\"%s spends conflicting transaction %s\",\n                                            hash.ToString(),\n@@ -816,7 +811,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n                 if (newFeeRate <= oldFeeRate)\n                 {\n-                    return state.DoS(0, false,\n+                    return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false,\n                             REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n                             strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n                                   hash.ToString(),\n@@ -845,7 +840,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     nConflictingSize += it->GetTxSize();\n                 }\n             } else {\n-                return state.DoS(0, false,\n+                return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false,\n                         REJECT_NONSTANDARD, \"too many potential replacements\", false,\n                         strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n                             hash.ToString(),\n@@ -865,7 +860,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     // it's cheaper to just check if the new input refers to a\n                     // tx that's in the mempool.\n                     if (pool.mapTx.find(tx.vin[j].prevout.hash) != pool.mapTx.end())\n-                        return state.DoS(0, false,\n+                        return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false,\n                                          REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\", false,\n                                          strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n                                                   hash.ToString(), j));\n@@ -877,7 +872,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             // transactions would not be paid for.\n             if (nModifiedFees < nConflictingFees)\n             {\n-                return state.DoS(0, false,\n+                return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false,\n                                  REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n                                  strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n                                           hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)));\n@@ -888,7 +883,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             CAmount nDeltaFees = nModifiedFees - nConflictingFees;\n             if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize))\n             {\n-                return state.DoS(0, false,\n+                return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false,\n                         REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n                         strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n                               hash.ToString(),\n@@ -913,6 +908,8 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             if (!tx.HasWitness() && CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, false, txdata) &&\n                 !CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, false, txdata)) {\n                 // Only the witness is missing, so the transaction itself may be fine.\n+                state.DoS(state.GetDoS(), ValidationInvalidReason::TX_WITNESS_MUTATED, false,\n+                          state.GetRejectCode(), state.GetRejectReason(), state.CorruptionPossible(), state.GetDebugMessage());\n                 state.SetCorruptionPossible();\n             }\n             return false; // state filled in by CheckInputs\n@@ -983,7 +980,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         if (!bypass_limits) {\n             LimitMempoolSize(pool, gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, gArgs.GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n             if (!pool.exists(hash))\n-                return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full\");\n+                return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"mempool full\");\n         }\n     }\n \n@@ -1347,6 +1344,9 @@ void InitScriptExecutionCache() {\n  * which are matched. This is useful for checking blocks where we will likely never need the cache\n  * entry again.\n  *\n+ * Note that we may set state.reason to NOT_STANDARD for extra soft-fork flags in flags, block-checking\n+ * callers should probably reset it to CONSENSUS in such cases.\n+ *\n  * Non-static (and re-declared) in src/test/txvalidationcache_tests.cpp\n  */\n bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks)\n@@ -1408,7 +1408,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                         CScriptCheck check2(coin.out, tx, i,\n                                 flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &txdata);\n                         if (check2())\n-                            return state.Invalid(false, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n+                            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n                     }\n                     // Failures of other flags indicate a transaction that is\n                     // invalid in new blocks, e.g. an invalid P2SH. We DoS ban\n@@ -1417,7 +1417,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                     // as to the correct behavior - we may want to continue\n                     // peering with non-upgraded nodes even after soft-fork\n                     // super-majority signaling has occurred.\n-                    return state.DoS(100,false, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n+                    return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n                 }\n             }\n \n@@ -1931,7 +1931,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n         for (const auto& tx : block.vtx) {\n             for (size_t o = 0; o < tx->vout.size(); o++) {\n                 if (view.HaveCoin(COutPoint(tx->GetHash(), o))) {\n-                    return state.DoS(100, error(\"ConnectBlock(): tried to overwrite transaction\"),\n+                    return state.DoS(100, ValidationInvalidReason::CONSENSUS, error(\"ConnectBlock(): tried to overwrite transaction\"),\n                                      REJECT_INVALID, \"bad-txns-BIP30\");\n                 }\n             }\n@@ -1971,11 +1971,17 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n         {\n             CAmount txfee = 0;\n             if (!Consensus::CheckTxInputs(tx, state, view, pindex->nHeight, txfee)) {\n+                if (state.GetReason() == ValidationInvalidReason::TX_MISSING_INPUTS) {\n+                    // CheckTxInputs may return MISSING_INPUTS but we can't return that, as\n+                    // it's not defined for a block, so we reset the reason flag to CONSENSUS here.\n+                    state.DoS(state.GetDoS(), ValidationInvalidReason::CONSENSUS, false,\n+                              state.GetRejectCode(), state.GetRejectReason(), state.CorruptionPossible(), state.GetDebugMessage());\n+                }\n                 return error(\"%s: Consensus::CheckTxInputs: %s, %s\", __func__, tx.GetHash().ToString(), FormatStateMessage(state));\n             }\n             nFees += txfee;\n             if (!MoneyRange(nFees)) {\n-                return state.DoS(100, error(\"%s: accumulated fee in the block out of range.\", __func__),\n+                return state.DoS(100, ValidationInvalidReason::CONSENSUS, error(\"%s: accumulated fee in the block out of range.\", __func__),\n                                  REJECT_INVALID, \"bad-txns-accumulated-fee-outofrange\");\n             }\n \n@@ -1988,7 +1994,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n             }\n \n             if (!SequenceLocks(tx, nLockTimeFlags, &prevheights, *pindex)) {\n-                return state.DoS(100, error(\"%s: contains a non-BIP68-final transaction\", __func__),\n+                return state.DoS(100, ValidationInvalidReason::CONSENSUS, error(\"%s: contains a non-BIP68-final transaction\", __func__),\n                                  REJECT_INVALID, \"bad-txns-nonfinal\");\n             }\n         }\n@@ -1999,17 +2005,29 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n         // * witness (when witness enabled in flags and excludes coinbase)\n         nSigOpsCost += GetTransactionSigOpCost(tx, view, flags);\n         if (nSigOpsCost > MAX_BLOCK_SIGOPS_COST)\n-            return state.DoS(100, error(\"ConnectBlock(): too many sigops\"),\n+            return state.DoS(100, ValidationInvalidReason::CONSENSUS, error(\"ConnectBlock(): too many sigops\"),\n                              REJECT_INVALID, \"bad-blk-sigops\");\n \n         txdata.emplace_back(tx);\n         if (!tx.IsCoinBase())\n         {\n             std::vector<CScriptCheck> vChecks;\n             bool fCacheResults = fJustCheck; /* Don't cache results if we're actually connecting blocks (still consult the cache, though) */\n-            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, fCacheResults, txdata[i], nScriptCheckThreads ? &vChecks : nullptr))\n+            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, fCacheResults, txdata[i], nScriptCheckThreads ? &vChecks : nullptr)) {\n+                if (state.GetReason() == ValidationInvalidReason::TX_NOT_STANDARD) {\n+                    // CheckInputs may return NOT_STANDARD for extra flags we passed,\n+                    // but we can't return that, as it's not defined for a block, so\n+                    // we reset the reason flag to CONSENSUS here.\n+                    // (note that this may not be the case until we add additional\n+                    // soft-fork flags to our script flags, in which case we  need to\n+                    // be careful to differentiate RECENT_CONSENSUS_CHANGE and\n+                    // CONSENSUS)\n+                    state.DoS(state.GetDoS(), ValidationInvalidReason::CONSENSUS, false,\n+                              state.GetRejectCode(), state.GetRejectReason(), state.CorruptionPossible(), state.GetDebugMessage());\n+                }\n                 return error(\"ConnectBlock(): CheckInputs on %s failed with %s\",\n                     tx.GetHash().ToString(), FormatStateMessage(state));\n+            }\n             control.Add(vChecks);\n         }\n \n@@ -2024,13 +2042,13 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n \n     CAmount blockReward = nFees + GetBlockSubsidy(pindex->nHeight, chainparams.GetConsensus());\n     if (block.vtx[0]->GetValueOut() > blockReward)\n-        return state.DoS(100,\n+        return state.DoS(100, ValidationInvalidReason::CONSENSUS,\n                          error(\"ConnectBlock(): coinbase pays too much (actual=%d vs limit=%d)\",\n                                block.vtx[0]->GetValueOut(), blockReward),\n                                REJECT_INVALID, \"bad-cb-amount\");\n \n     if (!control.Wait())\n-        return state.DoS(100, error(\"%s: CheckQueue failed\", __func__), REJECT_INVALID, \"block-validation-failed\");\n+        return state.DoS(100, ValidationInvalidReason::CONSENSUS, error(\"%s: CheckQueue failed\", __func__), REJECT_INVALID, \"block-validation-failed\");\n     int64_t nTime4 = GetTimeMicros(); nTimeVerify += nTime4 - nTime2;\n     LogPrint(BCLog::BENCH, \"    - Verify %u txins: %.2fms (%.3fms/txin) [%.2fs (%.2fms/blk)]\\n\", nInputs - 1, MILLI * (nTime4 - nTime2), nInputs <= 1 ? 0 : MILLI * (nTime4 - nTime2) / (nInputs-1), nTimeVerify * MICRO, nTimeVerify * MILLI / nBlocksTotal);\n \n@@ -3028,7 +3046,7 @@ static bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state,\n {\n     // Check proof of work matches claimed amount\n     if (fCheckPOW && !CheckProofOfWork(block.GetHash(), block.nBits, consensusParams))\n-        return state.DoS(50, false, REJECT_INVALID, \"high-hash\", false, \"proof of work failed\");\n+        return state.DoS(50, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"high-hash\", false, \"proof of work failed\");\n \n     return true;\n }\n@@ -3050,13 +3068,13 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n         bool mutated;\n         uint256 hashMerkleRoot2 = BlockMerkleRoot(block, &mutated);\n         if (block.hashMerkleRoot != hashMerkleRoot2)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txnmrklroot\", true, \"hashMerkleRoot mismatch\");\n+            return state.DoS(100, ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"bad-txnmrklroot\", true, \"hashMerkleRoot mismatch\");\n \n         // Check for merkle tree malleability (CVE-2012-2459): repeating sequences\n         // of transactions in a block without affecting the merkle root of a block,\n         // while still invalidating it.\n         if (mutated)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-duplicate\", true, \"duplicate transaction\");\n+            return state.DoS(100, ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"bad-txns-duplicate\", true, \"duplicate transaction\");\n     }\n \n     // All potential-corruption validation must be done before we do any\n@@ -3067,28 +3085,30 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n \n     // Size limits\n     if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-blk-length\", false, \"size limits failed\");\n+        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-blk-length\", false, \"size limits failed\");\n \n     // First transaction must be coinbase, the rest must not be\n     if (block.vtx.empty() || !block.vtx[0]->IsCoinBase())\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-cb-missing\", false, \"first tx is not coinbase\");\n+        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-cb-missing\", false, \"first tx is not coinbase\");\n     for (unsigned int i = 1; i < block.vtx.size(); i++)\n         if (block.vtx[i]->IsCoinBase())\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-multiple\", false, \"more than one coinbase\");\n+            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-cb-multiple\", false, \"more than one coinbase\");\n \n     // Check transactions\n-    for (const auto& tx : block.vtx)\n-        if (!CheckTransaction(*tx, state, false))\n-            return state.Invalid(false, state.GetRejectCode(), state.GetRejectReason(),\n-                                 strprintf(\"Transaction check failed (tx hash %s) %s\", tx->GetHash().ToString(), state.GetDebugMessage()));\n+    for (const auto& tx : block.vtx) {\n+        if (!CheckTransaction(*tx, state, false)) {\n+            LogPrintf(\"Transaction check failed (tx hash %s) %s\\n\", tx->GetHash().ToString(), state.GetDebugMessage());\n+            return false;\n+        }\n+    }\n \n     unsigned int nSigOps = 0;\n     for (const auto& tx : block.vtx)\n     {\n         nSigOps += GetLegacySigOpCount(*tx);\n     }\n     if (nSigOps * WITNESS_SCALE_FACTOR > MAX_BLOCK_SIGOPS_COST)\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-blk-sigops\", false, \"out-of-bounds SigOpCount\");\n+        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-blk-sigops\", false, \"out-of-bounds SigOpCount\");\n \n     if (fCheckPOW && fCheckMerkleRoot)\n         block.fChecked = true;\n@@ -3181,7 +3201,7 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n     // Check proof of work\n     const Consensus::Params& consensusParams = params.GetConsensus();\n     if (block.nBits != GetNextWorkRequired(pindexPrev, &block, consensusParams))\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-diffbits\", false, \"incorrect proof of work\");\n+        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-diffbits\", false, \"incorrect proof of work\");\n \n     // Check against checkpoints\n     if (fCheckpointsEnabled) {\n@@ -3190,23 +3210,23 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n         // MapBlockIndex.\n         CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(params.Checkpoints());\n         if (pcheckpoint && nHeight < pcheckpoint->nHeight)\n-            return state.DoS(100, error(\"%s: forked chain older than last checkpoint (height %d)\", __func__, nHeight), REJECT_CHECKPOINT, \"bad-fork-prior-to-checkpoint\");\n+            return state.DoS(100, ValidationInvalidReason::BLOCK_CHECKPOINT, error(\"%s: forked chain older than last checkpoint (height %d)\", __func__, nHeight), REJECT_CHECKPOINT, \"bad-fork-prior-to-checkpoint\");\n     }\n \n     // Check timestamp against prev\n     if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n-        return state.Invalid(false, REJECT_INVALID, \"time-too-old\", \"block's timestamp is too early\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"time-too-old\", \"block's timestamp is too early\");\n \n     // Check timestamp\n     if (block.GetBlockTime() > nAdjustedTime + MAX_FUTURE_BLOCK_TIME)\n-        return state.Invalid(false, REJECT_INVALID, \"time-too-new\", \"block timestamp too far in the future\");\n+        return state.Invalid(ValidationInvalidReason::BLOCK_BAD_TIME, false, REJECT_INVALID, \"time-too-new\", \"block timestamp too far in the future\");\n \n     // Reject outdated version blocks when 95% (75% on testnet) of the network has upgraded:\n     // check for version 2, 3 and 4 upgrades\n     if((block.nVersion < 2 && nHeight >= consensusParams.BIP34Height) ||\n        (block.nVersion < 3 && nHeight >= consensusParams.BIP66Height) ||\n        (block.nVersion < 4 && nHeight >= consensusParams.BIP65Height))\n-            return state.Invalid(false, REJECT_OBSOLETE, strprintf(\"bad-version(0x%08x)\", block.nVersion),\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_OBSOLETE, strprintf(\"bad-version(0x%08x)\", block.nVersion),\n                                  strprintf(\"rejected nVersion=0x%08x block\", block.nVersion));\n \n     return true;\n@@ -3235,7 +3255,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     // Check that all transactions are finalized\n     for (const auto& tx : block.vtx) {\n         if (!IsFinalTx(*tx, nHeight, nLockTimeCutoff)) {\n-            return state.DoS(10, false, REJECT_INVALID, \"bad-txns-nonfinal\", false, \"non-final transaction\");\n+            return state.DoS(10, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-nonfinal\", false, \"non-final transaction\");\n         }\n     }\n \n@@ -3245,7 +3265,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n         CScript expect = CScript() << nHeight;\n         if (block.vtx[0]->vin[0].scriptSig.size() < expect.size() ||\n             !std::equal(expect.begin(), expect.end(), block.vtx[0]->vin[0].scriptSig.begin())) {\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-height\", false, \"block height mismatch in coinbase\");\n+            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-cb-height\", false, \"block height mismatch in coinbase\");\n         }\n     }\n \n@@ -3267,11 +3287,11 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n             // already does not permit it, it is impossible to trigger in the\n             // witness tree.\n             if (block.vtx[0]->vin[0].scriptWitness.stack.size() != 1 || block.vtx[0]->vin[0].scriptWitness.stack[0].size() != 32) {\n-                return state.DoS(100, false, REJECT_INVALID, \"bad-witness-nonce-size\", true, strprintf(\"%s : invalid witness reserved value size\", __func__));\n+                return state.DoS(100, ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"bad-witness-nonce-size\", true, strprintf(\"%s : invalid witness reserved value size\", __func__));\n             }\n             CHash256().Write(hashWitness.begin(), 32).Write(&block.vtx[0]->vin[0].scriptWitness.stack[0][0], 32).Finalize(hashWitness.begin());\n             if (memcmp(hashWitness.begin(), &block.vtx[0]->vout[commitpos].scriptPubKey[6], 32)) {\n-                return state.DoS(100, false, REJECT_INVALID, \"bad-witness-merkle-match\", true, strprintf(\"%s : witness merkle commitment mismatch\", __func__));\n+                return state.DoS(100, ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"bad-witness-merkle-match\", true, strprintf(\"%s : witness merkle commitment mismatch\", __func__));\n             }\n             fHaveWitness = true;\n         }\n@@ -3281,7 +3301,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     if (!fHaveWitness) {\n       for (const auto& tx : block.vtx) {\n             if (tx->HasWitness()) {\n-                return state.DoS(100, false, REJECT_INVALID, \"unexpected-witness\", true, strprintf(\"%s : unexpected witness data found\", __func__));\n+                return state.DoS(100, ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"unexpected-witness\", true, strprintf(\"%s : unexpected witness data found\", __func__));\n             }\n         }\n     }\n@@ -3293,7 +3313,9 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     // the block hash, so we couldn't mark the block as permanently\n     // failed).\n     if (GetBlockWeight(block) > MAX_BLOCK_WEIGHT) {\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-blk-weight\", false, strprintf(\"%s : weight limit failed\", __func__));\n+        // We can call this a consensus failure as any data-providers who provided\n+        // us with witness data can be expected to support SegWit validation.\n+        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-blk-weight\", false, strprintf(\"%s : weight limit failed\", __func__));\n     }\n \n     return true;\n@@ -3313,7 +3335,7 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n             if (ppindex)\n                 *ppindex = pindex;\n             if (pindex->nStatus & BLOCK_FAILED_MASK)\n-                return state.Invalid(error(\"%s: block %s is marked invalid\", __func__, hash.ToString()), 0, \"duplicate\");\n+                return state.Invalid(ValidationInvalidReason::CACHED_INVALID, error(\"%s: block %s is marked invalid\", __func__, hash.ToString()), 0, \"duplicate\");\n             return true;\n         }\n \n@@ -3324,10 +3346,10 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n         CBlockIndex* pindexPrev = nullptr;\n         BlockMap::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n         if (mi == mapBlockIndex.end())\n-            return state.DoS(10, error(\"%s: prev block not found\", __func__), 0, \"prev-blk-not-found\");\n+            return state.DoS(10, ValidationInvalidReason::BLOCK_MISSING_PREV, error(\"%s: prev block not found\", __func__), 0, \"prev-blk-not-found\");\n         pindexPrev = (*mi).second;\n         if (pindexPrev->nStatus & BLOCK_FAILED_MASK)\n-            return state.DoS(100, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n+            return state.DoS(100, ValidationInvalidReason::BLOCK_INVALID_PREV, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n         if (!ContextualCheckBlockHeader(block, state, chainparams, pindexPrev, GetAdjustedTime()))\n             return error(\"%s: Consensus::ContextualCheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));\n \n@@ -3344,7 +3366,7 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n                         setDirtyBlockIndex.insert(invalid_walk);\n                         invalid_walk = invalid_walk->pprev;\n                     }\n-                    return state.DoS(100, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n+                    return state.DoS(100, ValidationInvalidReason::BLOCK_INVALID_PREV, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n                 }\n             }\n         }"
      }
    ]
  },
  {
    "sha": "eb597b6b922fc5499a51ad63f51cd1a0d0d0f289",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplYjU5N2I2YjkyMmZjNTQ5OWE1MWFkNjNmNTFjZDFhMGQwZDBmMjg5",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-11-08T16:57:38Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-05-14T16:52:37Z"
      },
      "message": "Add functions to convert CValidationInterface's reason to DoS info\n\nCValidationInterface's new GetReason() field provides more than\nenough information for net_processing to determine what to do with\nthe peer, use that instead of trusting validation's idea of what\nshould result in a DoS ban.\n\nCompared with previous bans, the following changes are made:\n * Txn with empty vin/vout or null prevouts move from 10 DoS\n   points to 100.\n * Loose transactions with a dependency loop now result in a ban\n   instead of 10 DoS points.\n * Any pre-segwit soft-fork errors (ie all soft-fork errors)\n   now result in a ban.\n * Proof of work failure moves from 50 DoS points to a ban.\n * Blocks with timestamps under MTP now result in a ban, blocks\n   too far in the future continue to *not* result in a ban.\n * Inclusion of non-final transactions in a block now results in a\n   ban instead of 10 DoS points.",
      "tree": {
        "sha": "fcbd488631badfb751f299fbd94e26543187e509",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fcbd488631badfb751f299fbd94e26543187e509"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/eb597b6b922fc5499a51ad63f51cd1a0d0d0f289",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eb597b6b922fc5499a51ad63f51cd1a0d0d0f289",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/eb597b6b922fc5499a51ad63f51cd1a0d0d0f289",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eb597b6b922fc5499a51ad63f51cd1a0d0d0f289/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "711f775986af9a87aa03ddfda7e79f85861a8947",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/711f775986af9a87aa03ddfda7e79f85861a8947",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/711f775986af9a87aa03ddfda7e79f85861a8947"
      }
    ],
    "stats": {
      "total": 77,
      "additions": 77,
      "deletions": 0
    },
    "files": [
      {
        "sha": "42f47688d767c5c4a02faeeb2da10fd9e6a34b35",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 77,
        "deletions": 0,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eb597b6b922fc5499a51ad63f51cd1a0d0d0f289/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eb597b6b922fc5499a51ad63f51cd1a0d0d0f289/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=eb597b6b922fc5499a51ad63f51cd1a0d0d0f289",
        "patch": "@@ -784,6 +784,83 @@ void Misbehaving(NodeId pnode, int howmuch, const std::string& message)\n         LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d)%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed);\n }\n \n+/**\n+ * Returns true if the given validation state result may result in us banning/disconnecting a peer\n+ * which provided such an object. This is used to determine whether to relay transactions to\n+ * whitelisted peers, preventing us from relaying things which would result in them disconnecting\n+ * us.\n+ */\n+static bool MayResultInDisconnect(const CValidationState& state, bool via_compact_block) {\n+    switch (state.GetReason()) {\n+    case ValidationInvalidReason::NONE:\n+        return false;\n+    // The node is is providing invalid data:\n+    case ValidationInvalidReason::CONSENSUS:\n+    case ValidationInvalidReason::BLOCK_MUTATED:\n+    case ValidationInvalidReason::CACHED_INVALID:\n+        if (via_compact_block) { return false; } else { return true; }\n+    case ValidationInvalidReason::BLOCK_CHECKPOINT:\n+    case ValidationInvalidReason::BLOCK_INVALID_PREV:\n+    case ValidationInvalidReason::BLOCK_MISSING_PREV:\n+        return true;\n+    // Conflicting (but not necessarily invalid) data or different policy:\n+    case ValidationInvalidReason::RECENT_CONSENSUS_CHANGE:\n+    case ValidationInvalidReason::BLOCK_BAD_TIME:\n+    case ValidationInvalidReason::TX_NOT_STANDARD:\n+    case ValidationInvalidReason::TX_MISSING_INPUTS:\n+    case ValidationInvalidReason::TX_WITNESS_MUTATED:\n+    case ValidationInvalidReason::TX_CONFLICT:\n+    case ValidationInvalidReason::TX_MEMPOOL_POLICY:\n+        return false;\n+    }\n+    return false;\n+}\n+\n+//! Returns true if the peer was punished (probably disconnected)\n+static bool MaybePunishNode(NodeId nodeid, const CValidationState& state, bool via_compact_block, const std::string& message = \"\") {\n+    switch (state.GetReason()) {\n+    case ValidationInvalidReason::NONE:\n+        break;\n+    // The node is providing invalid data:\n+    case ValidationInvalidReason::CONSENSUS:\n+    case ValidationInvalidReason::BLOCK_MUTATED:\n+    case ValidationInvalidReason::CACHED_INVALID:\n+        if (!via_compact_block) {\n+            LOCK(cs_main);\n+            Misbehaving(nodeid, 100, message);\n+            return true;\n+        }\n+        break;\n+    case ValidationInvalidReason::BLOCK_CHECKPOINT:\n+    case ValidationInvalidReason::BLOCK_INVALID_PREV:\n+        {\n+            LOCK(cs_main);\n+            Misbehaving(nodeid, 100, message);\n+        }\n+        return true;\n+    // Conflicting (but not necessarily invalid) data or different policy:\n+    case ValidationInvalidReason::BLOCK_MISSING_PREV:\n+        {\n+            // TODO: Handle this much more gracefully (10 DoS points is super arbitrary)\n+            LOCK(cs_main);\n+            Misbehaving(nodeid, 10, message);\n+        }\n+        return true;\n+    case ValidationInvalidReason::RECENT_CONSENSUS_CHANGE:\n+    case ValidationInvalidReason::BLOCK_BAD_TIME:\n+    case ValidationInvalidReason::TX_NOT_STANDARD:\n+    case ValidationInvalidReason::TX_MISSING_INPUTS:\n+    case ValidationInvalidReason::TX_WITNESS_MUTATED:\n+    case ValidationInvalidReason::TX_CONFLICT:\n+    case ValidationInvalidReason::TX_MEMPOOL_POLICY:\n+        break;\n+    }\n+    if (message != \"\") {\n+        LogPrint(BCLog::NET, \"peer=%d: %s\\n\", nodeid, message);\n+    }\n+    return false;\n+}\n+\n \n \n "
      }
    ]
  },
  {
    "sha": "16ec67eff703e9e778229ddcf30fd5fd65d2f28d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxNmVjNjdlZmY3MDNlOWU3NzgyMjlkZGNmMzBmZDVmZDY1ZDJmMjhk",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-04-16T16:52:03Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-05-14T16:52:37Z"
      },
      "message": "Use new reason-based DoS/disconnect logic instead of state.nDoS",
      "tree": {
        "sha": "656562dc0899a1d4060f74e067af326475a09ad0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/656562dc0899a1d4060f74e067af326475a09ad0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/16ec67eff703e9e778229ddcf30fd5fd65d2f28d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/16ec67eff703e9e778229ddcf30fd5fd65d2f28d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/16ec67eff703e9e778229ddcf30fd5fd65d2f28d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/16ec67eff703e9e778229ddcf30fd5fd65d2f28d/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "eb597b6b922fc5499a51ad63f51cd1a0d0d0f289",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eb597b6b922fc5499a51ad63f51cd1a0d0d0f289",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/eb597b6b922fc5499a51ad63f51cd1a0d0d0f289"
      }
    ],
    "stats": {
      "total": 89,
      "additions": 31,
      "deletions": 58
    },
    "files": [
      {
        "sha": "548318025ea59509f7f10ec2890ff5833015f0b4",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 0,
        "deletions": 7,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/16ec67eff703e9e778229ddcf30fd5fd65d2f28d/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/16ec67eff703e9e778229ddcf30fd5fd65d2f28d/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=16ec67eff703e9e778229ddcf30fd5fd65d2f28d",
        "patch": "@@ -116,13 +116,6 @@ class CValidationState {\n     bool IsError() const {\n         return mode == MODE_ERROR;\n     }\n-    bool IsInvalid(int &nDoSOut) const {\n-        if (IsInvalid()) {\n-            nDoSOut = nDoS;\n-            return true;\n-        }\n-        return false;\n-    }\n     bool CorruptionPossible() const {\n         return corruptionPossible;\n     }"
      },
      {
        "sha": "f7a910d1e08bd5f53e0822a2f48d26bae820b178",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 42,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/16ec67eff703e9e778229ddcf30fd5fd65d2f28d/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/16ec67eff703e9e778229ddcf30fd5fd65d2f28d/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=16ec67eff703e9e778229ddcf30fd5fd65d2f28d",
        "patch": "@@ -1033,14 +1033,12 @@ void PeerLogicValidation::BlockChecked(const CBlock& block, const CValidationSta\n     const uint256 hash(block.GetHash());\n     std::map<uint256, std::pair<NodeId, bool>>::iterator it = mapBlockSource.find(hash);\n \n-    int nDoS = 0;\n-    if (state.IsInvalid(nDoS)) {\n+    if (state.IsInvalid()) {\n         // Don't send reject message with code 0 or an internal reject code.\n         if (it != mapBlockSource.end() && State(it->second.first) && state.GetRejectCode() > 0 && state.GetRejectCode() < REJECT_INTERNAL) {\n             CBlockReject reject = {(unsigned char)state.GetRejectCode(), state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), hash};\n             State(it->second.first)->rejects.push_back(reject);\n-            if (nDoS > 0 && it->second.second)\n-                Misbehaving(it->second.first, nDoS);\n+            MaybePunishNode(it->second.first, state, !it->second.second);\n         }\n     }\n     // Check that:\n@@ -1443,15 +1441,8 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n     CValidationState state;\n     CBlockHeader first_invalid_header;\n     if (!ProcessNewBlockHeaders(headers, state, chainparams, &pindexLast, &first_invalid_header)) {\n-        int nDoS;\n-        if (state.IsInvalid(nDoS)) {\n-            LOCK(cs_main);\n-            if (nDoS > 0) {\n-                Misbehaving(pfrom->GetId(), nDoS, \"invalid header received\");\n-            } else {\n-                LogPrint(BCLog::NET, \"peer=%d: invalid header received\\n\", pfrom->GetId());\n-            }\n-            if (punish_duplicate_invalid && LookupBlockIndex(first_invalid_header.GetHash())) {\n+        if (state.IsInvalid()) {\n+            if (punish_duplicate_invalid && state.GetReason() == ValidationInvalidReason::CACHED_INVALID) {\n                 // Goal: don't allow outbound peers to use up our outbound\n                 // connection slots if they are on incompatible chains.\n                 //\n@@ -1485,6 +1476,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n                 // etc), and not just the duplicate-invalid case.\n                 pfrom->fDisconnect = true;\n             }\n+            MaybePunishNode(pfrom->GetId(), state, false, \"invalid header received\");\n             return false;\n         }\n     }\n@@ -2288,15 +2280,14 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     const uint256& orphanHash = orphanTx.GetHash();\n                     NodeId fromPeer = (*mi)->second.fromPeer;\n                     bool fMissingInputs2 = false;\n-                    // Use a dummy CValidationState so someone can't setup nodes to counter-DoS based on orphan\n-                    // resolution (that is, feeding people an invalid transaction based on LegitTxX in order to get\n-                    // anyone relaying LegitTxX banned)\n-                    CValidationState stateDummy;\n-\n+                    // Use a new CValidationState because orphans come from different peers (and we call\n+                    // MaybePunishNode based on the source peer from the orphan map, not based on the peer\n+                    // that relayed the previous transaction).\n+                    CValidationState orphan_state;\n \n                     if (setMisbehaving.count(fromPeer))\n                         continue;\n-                    if (AcceptToMemoryPool(mempool, stateDummy, porphanTx, &fMissingInputs2, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n+                    if (AcceptToMemoryPool(mempool, orphan_state, porphanTx, &fMissingInputs2, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n                         LogPrint(BCLog::MEMPOOL, \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n                         RelayTransaction(orphanTx, connman);\n                         for (unsigned int i = 0; i < orphanTx.vout.size(); i++) {\n@@ -2306,19 +2297,19 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     }\n                     else if (!fMissingInputs2)\n                     {\n-                        int nDos = 0;\n-                        if (stateDummy.IsInvalid(nDos) && nDos > 0)\n+                        if (orphan_state.IsInvalid())\n                         {\n                             // Punish peer that gave us an invalid orphan tx\n-                            Misbehaving(fromPeer, nDos);\n-                            setMisbehaving.insert(fromPeer);\n+                            if (MaybePunishNode(fromPeer, orphan_state, false)) {\n+                                setMisbehaving.insert(fromPeer);\n+                            }\n                             LogPrint(BCLog::MEMPOOL, \"   invalid orphan tx %s\\n\", orphanHash.ToString());\n                         }\n                         // Has inputs but not accepted to mempool\n                         // Probably non-standard or insufficient fee\n                         LogPrint(BCLog::MEMPOOL, \"   removed orphan tx %s\\n\", orphanHash.ToString());\n                         vEraseQueue.push_back(orphanHash);\n-                        if (!orphanTx.HasWitness() && !stateDummy.CorruptionPossible()) {\n+                        if (!orphanTx.HasWitness() && orphan_state.GetReason() != ValidationInvalidReason::TX_WITNESS_MUTATED) {\n                             // Do not use rejection cache for witness transactions or\n                             // witness-stripped transactions, as they can have been malleated.\n                             // See https://github.com/bitcoin/bitcoin/issues/8279 for details.\n@@ -2364,7 +2355,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 recentRejects->insert(tx.GetHash());\n             }\n         } else {\n-            if (!tx.HasWitness() && !state.CorruptionPossible()) {\n+            if (!tx.HasWitness() && state.GetReason() != ValidationInvalidReason::TX_WITNESS_MUTATED) {\n                 // Do not use rejection cache for witness transactions or\n                 // witness-stripped transactions, as they can have been malleated.\n                 // See https://github.com/bitcoin/bitcoin/issues/8279 for details.\n@@ -2386,31 +2377,27 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // Never relay transactions that we would assign a non-zero DoS\n                 // score for, as we expect peers to do the same with us in that\n                 // case.\n-                int nDoS = 0;\n-                if (!state.IsInvalid(nDoS) || nDoS == 0) {\n+                if (state.IsInvalid() && MayResultInDisconnect(state, false)) {\n+                    LogPrintf(\"Not relaying invalid transaction %s from whitelisted peer=%d (%s)\\n\", tx.GetHash().ToString(), pfrom->GetId(), FormatStateMessage(state));\n+                } else {\n                     LogPrintf(\"Force relaying tx %s from whitelisted peer=%d\\n\", tx.GetHash().ToString(), pfrom->GetId());\n                     RelayTransaction(tx, connman);\n-                } else {\n-                    LogPrintf(\"Not relaying invalid transaction %s from whitelisted peer=%d (%s)\\n\", tx.GetHash().ToString(), pfrom->GetId(), FormatStateMessage(state));\n                 }\n             }\n         }\n \n         for (const CTransactionRef& removedTx : lRemovedTxn)\n             AddToCompactExtraTransactions(removedTx);\n \n-        int nDoS = 0;\n-        if (state.IsInvalid(nDoS))\n+        if (state.IsInvalid())\n         {\n             LogPrint(BCLog::MEMPOOLREJ, \"%s from peer=%d was not accepted: %s\\n\", tx.GetHash().ToString(),\n                 pfrom->GetId(),\n                 FormatStateMessage(state));\n             if (state.GetRejectCode() > 0 && state.GetRejectCode() < REJECT_INTERNAL) // Never send AcceptToMemoryPool's internal codes over P2P\n                 connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n                                    state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), inv.hash));\n-            if (nDoS > 0) {\n-                Misbehaving(pfrom->GetId(), nDoS);\n-            }\n+            MaybePunishNode(pfrom->GetId(), state, false);\n         }\n     }\n \n@@ -2440,14 +2427,8 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         const CBlockIndex *pindex = nullptr;\n         CValidationState state;\n         if (!ProcessNewBlockHeaders({cmpctblock.header}, state, chainparams, &pindex)) {\n-            int nDoS;\n-            if (state.IsInvalid(nDoS)) {\n-                if (nDoS > 0) {\n-                    LOCK(cs_main);\n-                    Misbehaving(pfrom->GetId(), nDoS, strprintf(\"Peer %d sent us invalid header via cmpctblock\\n\", pfrom->GetId()));\n-                } else {\n-                    LogPrint(BCLog::NET, \"Peer %d sent us invalid header via cmpctblock\\n\", pfrom->GetId());\n-                }\n+            if (state.IsInvalid()) {\n+                MaybePunishNode(pfrom->GetId(), state, true, \"invalid header via cmpctblock\");\n                 return true;\n             }\n         }"
      },
      {
        "sha": "0c11bf509d905ddbcd9569c8967c47c1dc83c732",
        "filename": "src/test/txvalidation_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/16ec67eff703e9e778229ddcf30fd5fd65d2f28d/src/test/txvalidation_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/16ec67eff703e9e778229ddcf30fd5fd65d2f28d/src/test/txvalidation_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidation_tests.cpp?ref=16ec67eff703e9e778229ddcf30fd5fd65d2f28d",
        "patch": "@@ -53,9 +53,8 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_reject_coinbase, TestChain100Setup)\n     BOOST_CHECK(state.IsInvalid());\n     BOOST_CHECK_EQUAL(state.GetRejectReason(), \"coinbase\");\n \n-    int nDoS;\n-    BOOST_CHECK_EQUAL(state.IsInvalid(nDoS), true);\n-    BOOST_CHECK_EQUAL(nDoS, 100);\n+    BOOST_CHECK_EQUAL(state.IsInvalid(), true);\n+    BOOST_CHECK(state.GetReason() == ValidationInvalidReason::CONSENSUS);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "2692e208f258ff21c3611aa28b1e2745bdb118bb",
        "filename": "test/functional/feature_block.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/16ec67eff703e9e778229ddcf30fd5fd65d2f28d/test/functional/feature_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/16ec67eff703e9e778229ddcf30fd5fd65d2f28d/test/functional/feature_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_block.py?ref=16ec67eff703e9e778229ddcf30fd5fd65d2f28d",
        "patch": "@@ -249,7 +249,7 @@ def run_test(self):\n         self.log.info(\"Reject a block spending an immature coinbase.\")\n         self.move_tip(15)\n         b20 = self.next_block(20, spend=out[7])\n-        self.sync_blocks([b20], False, 16, b'bad-txns-premature-spend-of-coinbase')\n+        self.sync_blocks([b20], False, 16, b'bad-txns-premature-spend-of-coinbase', reconnect=True)\n \n         # Attempt to spend a coinbase at depth too low (on a fork this time)\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -262,7 +262,7 @@ def run_test(self):\n         self.sync_blocks([b21], False)\n \n         b22 = self.next_block(22, spend=out[5])\n-        self.sync_blocks([b22], False, 16, b'bad-txns-premature-spend-of-coinbase')\n+        self.sync_blocks([b22], False, 16, b'bad-txns-premature-spend-of-coinbase', reconnect=True)\n \n         # Create a block on either side of MAX_BLOCK_BASE_SIZE and make sure its accepted/rejected\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -584,7 +584,7 @@ def run_test(self):\n         while b47.sha256 < target:\n             b47.nNonce += 1\n             b47.rehash()\n-        self.sync_blocks([b47], False, request_block=False)\n+        self.sync_blocks([b47], False, request_block=False, reconnect=True)\n \n         self.log.info(\"Reject a block with a timestamp >2 hours in the future\")\n         self.move_tip(44)\n@@ -635,7 +635,7 @@ def run_test(self):\n         b54 = self.next_block(54, spend=out[15])\n         b54.nTime = b35.nTime - 1\n         b54.solve()\n-        self.sync_blocks([b54], False, request_block=False)\n+        self.sync_blocks([b54], False, request_block=False, reconnect=True)\n \n         # valid timestamp\n         self.move_tip(53)\n@@ -782,7 +782,7 @@ def run_test(self):\n         assert(tx.vin[0].nSequence < 0xffffffff)\n         tx.calc_sha256()\n         b62 = self.update_block(62, [tx])\n-        self.sync_blocks([b62], False, 16, b'bad-txns-nonfinal')\n+        self.sync_blocks([b62], False, 16, b'bad-txns-nonfinal', reconnect=True)\n \n         # Test a non-final coinbase is also rejected\n         #\n@@ -796,7 +796,7 @@ def run_test(self):\n         b63.vtx[0].vin[0].nSequence = 0xDEADBEEF\n         b63.vtx[0].rehash()\n         b63 = self.update_block(63, [])\n-        self.sync_blocks([b63], False, 16, b'bad-txns-nonfinal')\n+        self.sync_blocks([b63], False, 16, b'bad-txns-nonfinal', reconnect=True)\n \n         #  This checks that a block with a bloated VARINT between the block_header and the array of tx such that\n         #  the block is > MAX_BLOCK_BASE_SIZE with the bloated varint, but <= MAX_BLOCK_BASE_SIZE without the bloated varint,"
      }
    ]
  },
  {
    "sha": "d22c9dbb7380b1a380d8459148205135fd4dd304",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMjJjOWRiYjczODBiMWEzODBkODQ1OTE0ODIwNTEzNWZkNGRkMzA0",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-11-08T20:05:13Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-05-14T16:52:37Z"
      },
      "message": "Use state reason field to check for collisions in cmpctblocks",
      "tree": {
        "sha": "573c8872d155214357ac0829d8dd0278511bacb9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/573c8872d155214357ac0829d8dd0278511bacb9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d22c9dbb7380b1a380d8459148205135fd4dd304",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d22c9dbb7380b1a380d8459148205135fd4dd304",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d22c9dbb7380b1a380d8459148205135fd4dd304",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d22c9dbb7380b1a380d8459148205135fd4dd304/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "16ec67eff703e9e778229ddcf30fd5fd65d2f28d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/16ec67eff703e9e778229ddcf30fd5fd65d2f28d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/16ec67eff703e9e778229ddcf30fd5fd65d2f28d"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "bb95ebe9ff50b2c0cffe3d058ef3915a58b2e01e",
        "filename": "src/blockencodings.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d22c9dbb7380b1a380d8459148205135fd4dd304/src/blockencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d22c9dbb7380b1a380d8459148205135fd4dd304/src/blockencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockencodings.cpp?ref=d22c9dbb7380b1a380d8459148205135fd4dd304",
        "patch": "@@ -202,7 +202,7 @@ ReadStatus PartiallyDownloadedBlock::FillBlock(CBlock& block, const std::vector<\n         // but that is expensive, and CheckBlock caches a block's\n         // \"checked-status\" (in the CBlock?). CBlock should be able to\n         // check its own merkle root and cache that check.\n-        if (state.CorruptionPossible())\n+        if (state.GetReason() == ValidationInvalidReason::BLOCK_MUTATED)\n             return READ_STATUS_FAILED; // Possible Short ID collision\n         return READ_STATUS_CHECKBLOCK_FAILED;\n     }"
      }
    ]
  },
  {
    "sha": "905bca5cb7570039b4c59cfbeb5bcdf3107c4091",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MDViY2E1Y2I3NTcwMDM5YjRjNTljZmJlYjViY2RmMzEwN2M0MDkx",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-11-08T19:50:18Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-05-14T16:52:37Z"
      },
      "message": "Prep for scripted-diff by removing some \\ns which annoy sed.",
      "tree": {
        "sha": "5c3e9eae1d0abcf37436aa1a2ea0948f4ae5adb1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5c3e9eae1d0abcf37436aa1a2ea0948f4ae5adb1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/905bca5cb7570039b4c59cfbeb5bcdf3107c4091",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/905bca5cb7570039b4c59cfbeb5bcdf3107c4091",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/905bca5cb7570039b4c59cfbeb5bcdf3107c4091",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/905bca5cb7570039b4c59cfbeb5bcdf3107c4091/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d22c9dbb7380b1a380d8459148205135fd4dd304",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d22c9dbb7380b1a380d8459148205135fd4dd304",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d22c9dbb7380b1a380d8459148205135fd4dd304"
      }
    ],
    "stats": {
      "total": 18,
      "additions": 6,
      "deletions": 12
    },
    "files": [
      {
        "sha": "e9b41f14777b8c9c67f080563147f7674d83e89b",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 12,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/905bca5cb7570039b4c59cfbeb5bcdf3107c4091/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/905bca5cb7570039b4c59cfbeb5bcdf3107c4091/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=905bca5cb7570039b4c59cfbeb5bcdf3107c4091",
        "patch": "@@ -758,8 +758,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n             if (setConflicts.count(hashAncestor))\n             {\n-                return state.DoS(10, ValidationInvalidReason::CONSENSUS, false,\n-                                 REJECT_INVALID, \"bad-txns-spends-conflicting-tx\", false,\n+                return state.DoS(10, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-spends-conflicting-tx\", false,\n                                  strprintf(\"%s spends conflicting transaction %s\",\n                                            hash.ToString(),\n                                            hashAncestor.ToString()));\n@@ -811,8 +810,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n                 if (newFeeRate <= oldFeeRate)\n                 {\n-                    return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false,\n-                            REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                    return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n                             strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n                                   hash.ToString(),\n                                   newFeeRate.ToString(),\n@@ -840,8 +838,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     nConflictingSize += it->GetTxSize();\n                 }\n             } else {\n-                return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false,\n-                        REJECT_NONSTANDARD, \"too many potential replacements\", false,\n+                return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too many potential replacements\", false,\n                         strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n                             hash.ToString(),\n                             nConflictingCount,\n@@ -860,8 +857,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     // it's cheaper to just check if the new input refers to a\n                     // tx that's in the mempool.\n                     if (pool.mapTx.find(tx.vin[j].prevout.hash) != pool.mapTx.end())\n-                        return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false,\n-                                         REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\", false,\n+                        return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\", false,\n                                          strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n                                                   hash.ToString(), j));\n                 }\n@@ -872,8 +868,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             // transactions would not be paid for.\n             if (nModifiedFees < nConflictingFees)\n             {\n-                return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false,\n-                                 REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n                                  strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n                                           hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)));\n             }\n@@ -883,8 +878,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             CAmount nDeltaFees = nModifiedFees - nConflictingFees;\n             if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize))\n             {\n-                return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false,\n-                        REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n                         strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n                               hash.ToString(),\n                               FormatMoney(nDeltaFees),"
      }
    ]
  },
  {
    "sha": "54d68ca93680247c059b3ea33c22f5d94e1bdec3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NGQ2OGNhOTM2ODAyNDdjMDU5YjNlYTMzYzIyZjVkOTRlMWJkZWMz",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-05-14T16:53:03Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-05-14T16:53:03Z"
      },
      "message": "scripted-diff: Remove DoS calls to CValidationState\n\n-BEGIN VERIFY SCRIPT-\nsed -i 's/\\.DoS(\\(.*\\), REJECT_\\(.*\\), \\(true\\|false\\)/.DoS(\\1, REJECT_\\2/' src/validation.cpp src/consensus/tx_verify.cpp\nsed -i 's/state.GetRejectCode(), state.GetRejectReason(), state.CorruptionPossible(), state.GetDebugMessage())/state.GetRejectCode(), state.GetRejectReason(), state.GetDebugMessage())/' src/validation.cpp\nsed -i 's/\\.DoS([^,]*, /.Invalid\\(/' src/validation.cpp src/consensus/tx_verify.cpp\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "16c1d64fbe1133d7c29da8ca841d6aa990f02d70",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/16c1d64fbe1133d7c29da8ca841d6aa990f02d70"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/54d68ca93680247c059b3ea33c22f5d94e1bdec3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/54d68ca93680247c059b3ea33c22f5d94e1bdec3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/54d68ca93680247c059b3ea33c22f5d94e1bdec3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/54d68ca93680247c059b3ea33c22f5d94e1bdec3/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "905bca5cb7570039b4c59cfbeb5bcdf3107c4091",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/905bca5cb7570039b4c59cfbeb5bcdf3107c4091",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/905bca5cb7570039b4c59cfbeb5bcdf3107c4091"
      }
    ],
    "stats": {
      "total": 124,
      "additions": 62,
      "deletions": 62
    },
    "files": [
      {
        "sha": "35c8ea7afaf24a84a6c2bd1d9ee7365fba0bb2f7",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54d68ca93680247c059b3ea33c22f5d94e1bdec3/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54d68ca93680247c059b3ea33c22f5d94e1bdec3/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=54d68ca93680247c059b3ea33c22f5d94e1bdec3",
        "patch": "@@ -160,24 +160,24 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n {\n     // Basic checks that don't depend on any context\n     if (tx.vin.empty())\n-        return state.DoS(10, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-vin-empty\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-vin-empty\");\n     if (tx.vout.empty())\n-        return state.DoS(10, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-vout-empty\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-vout-empty\");\n     // Size limits (this doesn't take the witness into account, as that hasn't been checked for malleability)\n     if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n-        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-oversize\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-oversize\");\n \n     // Check for negative or overflow output values\n     CAmount nValueOut = 0;\n     for (const auto& txout : tx.vout)\n     {\n         if (txout.nValue < 0)\n-            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-vout-negative\");\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-vout-negative\");\n         if (txout.nValue > MAX_MONEY)\n-            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-vout-toolarge\");\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-vout-toolarge\");\n         nValueOut += txout.nValue;\n         if (!MoneyRange(nValueOut))\n-            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-txouttotal-toolarge\");\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-txouttotal-toolarge\");\n     }\n \n     // Check for duplicate inputs - note that this check is slow so we skip it in CheckBlock\n@@ -186,20 +186,20 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n         for (const auto& txin : tx.vin)\n         {\n             if (!vInOutPoints.insert(txin.prevout).second)\n-                return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n+                return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n         }\n     }\n \n     if (tx.IsCoinBase())\n     {\n         if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 100)\n-            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-cb-length\");\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-cb-length\");\n     }\n     else\n     {\n         for (const auto& txin : tx.vin)\n             if (txin.prevout.IsNull())\n-                return state.DoS(10, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n+                return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n     }\n \n     return true;\n@@ -209,7 +209,7 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n {\n     // are the actual inputs available?\n     if (!inputs.HaveInputs(tx)) {\n-        return state.DoS(100, ValidationInvalidReason::TX_MISSING_INPUTS, false, REJECT_INVALID, \"bad-txns-inputs-missingorspent\", false,\n+        return state.Invalid(ValidationInvalidReason::TX_MISSING_INPUTS, false, REJECT_INVALID, \"bad-txns-inputs-missingorspent\",\n                          strprintf(\"%s: inputs missing/spent\", __func__));\n     }\n \n@@ -229,20 +229,20 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n         // Check for negative or overflow input values\n         nValueIn += coin.out.nValue;\n         if (!MoneyRange(coin.out.nValue) || !MoneyRange(nValueIn)) {\n-            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-inputvalues-outofrange\");\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-inputvalues-outofrange\");\n         }\n     }\n \n     const CAmount value_out = tx.GetValueOut();\n     if (nValueIn < value_out) {\n-        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-in-belowout\", false,\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-in-belowout\",\n             strprintf(\"value in (%s) < value out (%s)\", FormatMoney(nValueIn), FormatMoney(value_out)));\n     }\n \n     // Tally transaction fees\n     const CAmount txfee_aux = nValueIn - value_out;\n     if (!MoneyRange(txfee_aux)) {\n-        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-fee-outofrange\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-fee-outofrange\");\n     }\n \n     txfee = txfee_aux;"
      },
      {
        "sha": "67e236cf4c443e7c73b4b74fdbbf7cae8c8db20a",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 49,
        "deletions": 49,
        "changes": 98,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54d68ca93680247c059b3ea33c22f5d94e1bdec3/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54d68ca93680247c059b3ea33c22f5d94e1bdec3/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=54d68ca93680247c059b3ea33c22f5d94e1bdec3",
        "patch": "@@ -569,30 +569,30 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n     // Coinbase is only valid in a block, not as a loose transaction\n     if (tx.IsCoinBase())\n-        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"coinbase\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"coinbase\");\n \n     // Reject transactions with witness before segregated witness activates (override with -prematurewitness)\n     bool witnessEnabled = IsWitnessEnabled(chainActive.Tip(), chainparams.GetConsensus());\n     if (!gArgs.GetBoolArg(\"-prematurewitness\", false) && tx.HasWitness() && !witnessEnabled) {\n-        return state.DoS(0, ValidationInvalidReason::TX_WITNESS_MUTATED, false, REJECT_NONSTANDARD, \"no-witness-yet\", true);\n+        return state.Invalid(ValidationInvalidReason::TX_WITNESS_MUTATED, false, REJECT_NONSTANDARD, \"no-witness-yet\");\n     }\n \n     // Rather not work on nonstandard transactions (unless -testnet/-regtest)\n     std::string reason;\n     if (fRequireStandard && !IsStandardTx(tx, reason, witnessEnabled))\n-        return state.DoS(0, ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, reason);\n+        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, reason);\n \n     // Do not work on transactions that are too small.\n     // A transaction with 1 segwit input and 1 P2WPHK output has non-witness size of 82 bytes.\n     // Transactions smaller than this are not relayed to reduce unnecessary malloc overhead.\n     if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) < MIN_STANDARD_TX_NONWITNESS_SIZE)\n-        return state.DoS(0, ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"tx-size-small\");\n+        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"tx-size-small\");\n \n     // Only accept nLockTime-using transactions that can be mined in the next\n     // block; we don't want our mempool filled up with transactions that can't\n     // be mined yet.\n     if (!CheckFinalTx(tx, STANDARD_LOCKTIME_VERIFY_FLAGS))\n-        return state.DoS(0, ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"non-final\");\n+        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"non-final\");\n \n     // is it already in the memory pool?\n     if (pool.exists(hash)) {\n@@ -683,7 +683,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n         // CoinsViewCache instead of create its own\n         if (!CheckSequenceLocks(tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n-            return state.DoS(0, ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n+            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n \n         CAmount nFees = 0;\n         if (!Consensus::CheckTxInputs(tx, state, view, GetSpendHeight(view), nFees)) {\n@@ -696,7 +696,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n         // Check for non-standard witness in P2WSH\n         if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, view))\n-            return state.DoS(0, ValidationInvalidReason::TX_WITNESS_MUTATED, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\", true);\n+            return state.Invalid(ValidationInvalidReason::TX_WITNESS_MUTATED, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\");\n \n         int64_t nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);\n \n@@ -720,17 +720,17 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         unsigned int nSize = entry.GetTxSize();\n \n         if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n-            return state.DoS(0, ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\", false,\n+            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\",\n                 strprintf(\"%d\", nSigOpsCost));\n \n         CAmount mempoolRejectFee = pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(nSize);\n         if (!bypass_limits && mempoolRejectFee > 0 && nModifiedFees < mempoolRejectFee) {\n-            return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", false, strprintf(\"%d < %d\", nModifiedFees, mempoolRejectFee));\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", strprintf(\"%d < %d\", nModifiedFees, mempoolRejectFee));\n         }\n \n         // No transactions are allowed below minRelayTxFee except from disconnected blocks\n         if (!bypass_limits && nModifiedFees < ::minRelayTxFee.GetFee(nSize)) {\n-            return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"min relay fee not met\", false, strprintf(\"%d < %d\", nModifiedFees, ::minRelayTxFee.GetFee(nSize)));\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"min relay fee not met\", strprintf(\"%d < %d\", nModifiedFees, ::minRelayTxFee.GetFee(nSize)));\n         }\n \n         if (nAbsurdFee && nFees > nAbsurdFee)\n@@ -746,7 +746,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n         std::string errString;\n         if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n-            return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", false, errString);\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n         }\n \n         // A transaction that spends outputs that would be replaced by it is invalid. Now\n@@ -758,7 +758,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n             if (setConflicts.count(hashAncestor))\n             {\n-                return state.DoS(10, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-spends-conflicting-tx\", false,\n+                return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-spends-conflicting-tx\",\n                                  strprintf(\"%s spends conflicting transaction %s\",\n                                            hash.ToString(),\n                                            hashAncestor.ToString()));\n@@ -810,7 +810,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n                 if (newFeeRate <= oldFeeRate)\n                 {\n-                    return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                    return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n                             strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n                                   hash.ToString(),\n                                   newFeeRate.ToString(),\n@@ -838,7 +838,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     nConflictingSize += it->GetTxSize();\n                 }\n             } else {\n-                return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too many potential replacements\", false,\n+                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too many potential replacements\",\n                         strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n                             hash.ToString(),\n                             nConflictingCount,\n@@ -857,7 +857,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     // it's cheaper to just check if the new input refers to a\n                     // tx that's in the mempool.\n                     if (pool.mapTx.find(tx.vin[j].prevout.hash) != pool.mapTx.end())\n-                        return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\", false,\n+                        return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\",\n                                          strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n                                                   hash.ToString(), j));\n                 }\n@@ -868,7 +868,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             // transactions would not be paid for.\n             if (nModifiedFees < nConflictingFees)\n             {\n-                return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n                                  strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n                                           hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)));\n             }\n@@ -878,7 +878,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             CAmount nDeltaFees = nModifiedFees - nConflictingFees;\n             if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize))\n             {\n-                return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n                         strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n                               hash.ToString(),\n                               FormatMoney(nDeltaFees),\n@@ -902,8 +902,8 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             if (!tx.HasWitness() && CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, false, txdata) &&\n                 !CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, false, txdata)) {\n                 // Only the witness is missing, so the transaction itself may be fine.\n-                state.DoS(state.GetDoS(), ValidationInvalidReason::TX_WITNESS_MUTATED, false,\n-                          state.GetRejectCode(), state.GetRejectReason(), state.CorruptionPossible(), state.GetDebugMessage());\n+                state.Invalid(ValidationInvalidReason::TX_WITNESS_MUTATED, false,\n+                          state.GetRejectCode(), state.GetRejectReason(), state.GetDebugMessage());\n                 state.SetCorruptionPossible();\n             }\n             return false; // state filled in by CheckInputs\n@@ -974,7 +974,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         if (!bypass_limits) {\n             LimitMempoolSize(pool, gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, gArgs.GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n             if (!pool.exists(hash))\n-                return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"mempool full\");\n+                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"mempool full\");\n         }\n     }\n \n@@ -1411,7 +1411,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                     // as to the correct behavior - we may want to continue\n                     // peering with non-upgraded nodes even after soft-fork\n                     // super-majority signaling has occurred.\n-                    return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n+                    return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n                 }\n             }\n \n@@ -1925,7 +1925,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n         for (const auto& tx : block.vtx) {\n             for (size_t o = 0; o < tx->vout.size(); o++) {\n                 if (view.HaveCoin(COutPoint(tx->GetHash(), o))) {\n-                    return state.DoS(100, ValidationInvalidReason::CONSENSUS, error(\"ConnectBlock(): tried to overwrite transaction\"),\n+                    return state.Invalid(ValidationInvalidReason::CONSENSUS, error(\"ConnectBlock(): tried to overwrite transaction\"),\n                                      REJECT_INVALID, \"bad-txns-BIP30\");\n                 }\n             }\n@@ -1968,14 +1968,14 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n                 if (state.GetReason() == ValidationInvalidReason::TX_MISSING_INPUTS) {\n                     // CheckTxInputs may return MISSING_INPUTS but we can't return that, as\n                     // it's not defined for a block, so we reset the reason flag to CONSENSUS here.\n-                    state.DoS(state.GetDoS(), ValidationInvalidReason::CONSENSUS, false,\n-                              state.GetRejectCode(), state.GetRejectReason(), state.CorruptionPossible(), state.GetDebugMessage());\n+                    state.Invalid(ValidationInvalidReason::CONSENSUS, false,\n+                              state.GetRejectCode(), state.GetRejectReason(), state.GetDebugMessage());\n                 }\n                 return error(\"%s: Consensus::CheckTxInputs: %s, %s\", __func__, tx.GetHash().ToString(), FormatStateMessage(state));\n             }\n             nFees += txfee;\n             if (!MoneyRange(nFees)) {\n-                return state.DoS(100, ValidationInvalidReason::CONSENSUS, error(\"%s: accumulated fee in the block out of range.\", __func__),\n+                return state.Invalid(ValidationInvalidReason::CONSENSUS, error(\"%s: accumulated fee in the block out of range.\", __func__),\n                                  REJECT_INVALID, \"bad-txns-accumulated-fee-outofrange\");\n             }\n \n@@ -1988,7 +1988,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n             }\n \n             if (!SequenceLocks(tx, nLockTimeFlags, &prevheights, *pindex)) {\n-                return state.DoS(100, ValidationInvalidReason::CONSENSUS, error(\"%s: contains a non-BIP68-final transaction\", __func__),\n+                return state.Invalid(ValidationInvalidReason::CONSENSUS, error(\"%s: contains a non-BIP68-final transaction\", __func__),\n                                  REJECT_INVALID, \"bad-txns-nonfinal\");\n             }\n         }\n@@ -1999,7 +1999,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n         // * witness (when witness enabled in flags and excludes coinbase)\n         nSigOpsCost += GetTransactionSigOpCost(tx, view, flags);\n         if (nSigOpsCost > MAX_BLOCK_SIGOPS_COST)\n-            return state.DoS(100, ValidationInvalidReason::CONSENSUS, error(\"ConnectBlock(): too many sigops\"),\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, error(\"ConnectBlock(): too many sigops\"),\n                              REJECT_INVALID, \"bad-blk-sigops\");\n \n         txdata.emplace_back(tx);\n@@ -2016,8 +2016,8 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n                     // soft-fork flags to our script flags, in which case we  need to\n                     // be careful to differentiate RECENT_CONSENSUS_CHANGE and\n                     // CONSENSUS)\n-                    state.DoS(state.GetDoS(), ValidationInvalidReason::CONSENSUS, false,\n-                              state.GetRejectCode(), state.GetRejectReason(), state.CorruptionPossible(), state.GetDebugMessage());\n+                    state.Invalid(ValidationInvalidReason::CONSENSUS, false,\n+                              state.GetRejectCode(), state.GetRejectReason(), state.GetDebugMessage());\n                 }\n                 return error(\"ConnectBlock(): CheckInputs on %s failed with %s\",\n                     tx.GetHash().ToString(), FormatStateMessage(state));\n@@ -2036,13 +2036,13 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n \n     CAmount blockReward = nFees + GetBlockSubsidy(pindex->nHeight, chainparams.GetConsensus());\n     if (block.vtx[0]->GetValueOut() > blockReward)\n-        return state.DoS(100, ValidationInvalidReason::CONSENSUS,\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS,\n                          error(\"ConnectBlock(): coinbase pays too much (actual=%d vs limit=%d)\",\n                                block.vtx[0]->GetValueOut(), blockReward),\n                                REJECT_INVALID, \"bad-cb-amount\");\n \n     if (!control.Wait())\n-        return state.DoS(100, ValidationInvalidReason::CONSENSUS, error(\"%s: CheckQueue failed\", __func__), REJECT_INVALID, \"block-validation-failed\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, error(\"%s: CheckQueue failed\", __func__), REJECT_INVALID, \"block-validation-failed\");\n     int64_t nTime4 = GetTimeMicros(); nTimeVerify += nTime4 - nTime2;\n     LogPrint(BCLog::BENCH, \"    - Verify %u txins: %.2fms (%.3fms/txin) [%.2fs (%.2fms/blk)]\\n\", nInputs - 1, MILLI * (nTime4 - nTime2), nInputs <= 1 ? 0 : MILLI * (nTime4 - nTime2) / (nInputs-1), nTimeVerify * MICRO, nTimeVerify * MILLI / nBlocksTotal);\n \n@@ -3040,7 +3040,7 @@ static bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state,\n {\n     // Check proof of work matches claimed amount\n     if (fCheckPOW && !CheckProofOfWork(block.GetHash(), block.nBits, consensusParams))\n-        return state.DoS(50, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"high-hash\", false, \"proof of work failed\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"high-hash\", \"proof of work failed\");\n \n     return true;\n }\n@@ -3062,13 +3062,13 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n         bool mutated;\n         uint256 hashMerkleRoot2 = BlockMerkleRoot(block, &mutated);\n         if (block.hashMerkleRoot != hashMerkleRoot2)\n-            return state.DoS(100, ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"bad-txnmrklroot\", true, \"hashMerkleRoot mismatch\");\n+            return state.Invalid(ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"bad-txnmrklroot\", \"hashMerkleRoot mismatch\");\n \n         // Check for merkle tree malleability (CVE-2012-2459): repeating sequences\n         // of transactions in a block without affecting the merkle root of a block,\n         // while still invalidating it.\n         if (mutated)\n-            return state.DoS(100, ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"bad-txns-duplicate\", true, \"duplicate transaction\");\n+            return state.Invalid(ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"bad-txns-duplicate\", \"duplicate transaction\");\n     }\n \n     // All potential-corruption validation must be done before we do any\n@@ -3079,14 +3079,14 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n \n     // Size limits\n     if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n-        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-blk-length\", false, \"size limits failed\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-blk-length\", \"size limits failed\");\n \n     // First transaction must be coinbase, the rest must not be\n     if (block.vtx.empty() || !block.vtx[0]->IsCoinBase())\n-        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-cb-missing\", false, \"first tx is not coinbase\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-cb-missing\", \"first tx is not coinbase\");\n     for (unsigned int i = 1; i < block.vtx.size(); i++)\n         if (block.vtx[i]->IsCoinBase())\n-            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-cb-multiple\", false, \"more than one coinbase\");\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-cb-multiple\", \"more than one coinbase\");\n \n     // Check transactions\n     for (const auto& tx : block.vtx) {\n@@ -3102,7 +3102,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n         nSigOps += GetLegacySigOpCount(*tx);\n     }\n     if (nSigOps * WITNESS_SCALE_FACTOR > MAX_BLOCK_SIGOPS_COST)\n-        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-blk-sigops\", false, \"out-of-bounds SigOpCount\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-blk-sigops\", \"out-of-bounds SigOpCount\");\n \n     if (fCheckPOW && fCheckMerkleRoot)\n         block.fChecked = true;\n@@ -3195,7 +3195,7 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n     // Check proof of work\n     const Consensus::Params& consensusParams = params.GetConsensus();\n     if (block.nBits != GetNextWorkRequired(pindexPrev, &block, consensusParams))\n-        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-diffbits\", false, \"incorrect proof of work\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-diffbits\", \"incorrect proof of work\");\n \n     // Check against checkpoints\n     if (fCheckpointsEnabled) {\n@@ -3204,7 +3204,7 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n         // MapBlockIndex.\n         CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(params.Checkpoints());\n         if (pcheckpoint && nHeight < pcheckpoint->nHeight)\n-            return state.DoS(100, ValidationInvalidReason::BLOCK_CHECKPOINT, error(\"%s: forked chain older than last checkpoint (height %d)\", __func__, nHeight), REJECT_CHECKPOINT, \"bad-fork-prior-to-checkpoint\");\n+            return state.Invalid(ValidationInvalidReason::BLOCK_CHECKPOINT, error(\"%s: forked chain older than last checkpoint (height %d)\", __func__, nHeight), REJECT_CHECKPOINT, \"bad-fork-prior-to-checkpoint\");\n     }\n \n     // Check timestamp against prev\n@@ -3249,7 +3249,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     // Check that all transactions are finalized\n     for (const auto& tx : block.vtx) {\n         if (!IsFinalTx(*tx, nHeight, nLockTimeCutoff)) {\n-            return state.DoS(10, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-nonfinal\", false, \"non-final transaction\");\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-nonfinal\", \"non-final transaction\");\n         }\n     }\n \n@@ -3259,7 +3259,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n         CScript expect = CScript() << nHeight;\n         if (block.vtx[0]->vin[0].scriptSig.size() < expect.size() ||\n             !std::equal(expect.begin(), expect.end(), block.vtx[0]->vin[0].scriptSig.begin())) {\n-            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-cb-height\", false, \"block height mismatch in coinbase\");\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-cb-height\", \"block height mismatch in coinbase\");\n         }\n     }\n \n@@ -3281,11 +3281,11 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n             // already does not permit it, it is impossible to trigger in the\n             // witness tree.\n             if (block.vtx[0]->vin[0].scriptWitness.stack.size() != 1 || block.vtx[0]->vin[0].scriptWitness.stack[0].size() != 32) {\n-                return state.DoS(100, ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"bad-witness-nonce-size\", true, strprintf(\"%s : invalid witness reserved value size\", __func__));\n+                return state.Invalid(ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"bad-witness-nonce-size\", strprintf(\"%s : invalid witness reserved value size\", __func__));\n             }\n             CHash256().Write(hashWitness.begin(), 32).Write(&block.vtx[0]->vin[0].scriptWitness.stack[0][0], 32).Finalize(hashWitness.begin());\n             if (memcmp(hashWitness.begin(), &block.vtx[0]->vout[commitpos].scriptPubKey[6], 32)) {\n-                return state.DoS(100, ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"bad-witness-merkle-match\", true, strprintf(\"%s : witness merkle commitment mismatch\", __func__));\n+                return state.Invalid(ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"bad-witness-merkle-match\", strprintf(\"%s : witness merkle commitment mismatch\", __func__));\n             }\n             fHaveWitness = true;\n         }\n@@ -3295,7 +3295,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     if (!fHaveWitness) {\n       for (const auto& tx : block.vtx) {\n             if (tx->HasWitness()) {\n-                return state.DoS(100, ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"unexpected-witness\", true, strprintf(\"%s : unexpected witness data found\", __func__));\n+                return state.Invalid(ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"unexpected-witness\", strprintf(\"%s : unexpected witness data found\", __func__));\n             }\n         }\n     }\n@@ -3309,7 +3309,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     if (GetBlockWeight(block) > MAX_BLOCK_WEIGHT) {\n         // We can call this a consensus failure as any data-providers who provided\n         // us with witness data can be expected to support SegWit validation.\n-        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-blk-weight\", false, strprintf(\"%s : weight limit failed\", __func__));\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-blk-weight\", strprintf(\"%s : weight limit failed\", __func__));\n     }\n \n     return true;\n@@ -3340,10 +3340,10 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n         CBlockIndex* pindexPrev = nullptr;\n         BlockMap::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n         if (mi == mapBlockIndex.end())\n-            return state.DoS(10, ValidationInvalidReason::BLOCK_MISSING_PREV, error(\"%s: prev block not found\", __func__), 0, \"prev-blk-not-found\");\n+            return state.Invalid(ValidationInvalidReason::BLOCK_MISSING_PREV, error(\"%s: prev block not found\", __func__), 0, \"prev-blk-not-found\");\n         pindexPrev = (*mi).second;\n         if (pindexPrev->nStatus & BLOCK_FAILED_MASK)\n-            return state.DoS(100, ValidationInvalidReason::BLOCK_INVALID_PREV, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n+            return state.Invalid(ValidationInvalidReason::BLOCK_INVALID_PREV, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n         if (!ContextualCheckBlockHeader(block, state, chainparams, pindexPrev, GetAdjustedTime()))\n             return error(\"%s: Consensus::ContextualCheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));\n \n@@ -3360,7 +3360,7 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n                         setDirtyBlockIndex.insert(invalid_walk);\n                         invalid_walk = invalid_walk->pprev;\n                     }\n-                    return state.DoS(100, ValidationInvalidReason::BLOCK_INVALID_PREV, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n+                    return state.Invalid(ValidationInvalidReason::BLOCK_INVALID_PREV, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n                 }\n             }\n         }"
      }
    ]
  },
  {
    "sha": "8c35ac4d3d78d84fd61347b8cd5955490d4c7c60",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YzM1YWM0ZDNkNzhkODRmZDYxMzQ3YjhjZDU5NTU0OTBkNGM3YzYw",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-11-08T20:17:38Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-05-14T16:56:41Z"
      },
      "message": "Remove references to CValidationState's DoS and CorruptionPossible",
      "tree": {
        "sha": "b2cfaaeddcc4f086fef0e183b4fd28dde4974ec7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b2cfaaeddcc4f086fef0e183b4fd28dde4974ec7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8c35ac4d3d78d84fd61347b8cd5955490d4c7c60",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8c35ac4d3d78d84fd61347b8cd5955490d4c7c60",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8c35ac4d3d78d84fd61347b8cd5955490d4c7c60",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8c35ac4d3d78d84fd61347b8cd5955490d4c7c60/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "54d68ca93680247c059b3ea33c22f5d94e1bdec3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/54d68ca93680247c059b3ea33c22f5d94e1bdec3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/54d68ca93680247c059b3ea33c22f5d94e1bdec3"
      }
    ],
    "stats": {
      "total": 30,
      "additions": 6,
      "deletions": 24
    },
    "files": [
      {
        "sha": "55c535543fdff81b114e5c9f7094e777f1a7e0ef",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 19,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8c35ac4d3d78d84fd61347b8cd5955490d4c7c60/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8c35ac4d3d78d84fd61347b8cd5955490d4c7c60/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=8c35ac4d3d78d84fd61347b8cd5955490d4c7c60",
        "patch": "@@ -74,33 +74,23 @@ class CValidationState {\n         MODE_ERROR,   //!< run-time error\n     } mode;\n     ValidationInvalidReason reason;\n-    int nDoS;\n     std::string strRejectReason;\n     unsigned int chRejectCode;\n-    bool corruptionPossible;\n     std::string strDebugMessage;\n public:\n-    CValidationState() : mode(MODE_VALID), reason(ValidationInvalidReason::NONE), nDoS(0), chRejectCode(0), corruptionPossible(false) {}\n-    bool DoS(int level, ValidationInvalidReason reasonIn, bool ret = false,\n+    CValidationState() : mode(MODE_VALID), reason(ValidationInvalidReason::NONE), chRejectCode(0) {}\n+    bool Invalid(ValidationInvalidReason reasonIn, bool ret = false,\n              unsigned int chRejectCodeIn=0, const std::string &strRejectReasonIn=\"\",\n-             bool corruptionIn=false,\n              const std::string &strDebugMessageIn=\"\") {\n         reason = reasonIn;\n         chRejectCode = chRejectCodeIn;\n         strRejectReason = strRejectReasonIn;\n-        corruptionPossible = corruptionIn;\n         strDebugMessage = strDebugMessageIn;\n         if (mode == MODE_ERROR)\n             return ret;\n-        nDoS += level;\n         mode = MODE_INVALID;\n         return ret;\n     }\n-    bool Invalid(ValidationInvalidReason _reason, bool ret = false,\n-                 unsigned int _chRejectCode=0, const std::string &_strRejectReason=\"\",\n-                 const std::string &_strDebugMessage=\"\") {\n-        return DoS(0, _reason, ret, _chRejectCode, _strRejectReason, false, _strDebugMessage);\n-    }\n     bool Error(const std::string& strRejectReasonIn) {\n         if (mode == MODE_VALID)\n             strRejectReason = strRejectReasonIn;\n@@ -116,14 +106,7 @@ class CValidationState {\n     bool IsError() const {\n         return mode == MODE_ERROR;\n     }\n-    bool CorruptionPossible() const {\n-        return corruptionPossible;\n-    }\n-    void SetCorruptionPossible() {\n-        corruptionPossible = true;\n-    }\n     ValidationInvalidReason GetReason() const { return reason; }\n-    int GetDoS() const { return nDoS; }\n     unsigned int GetRejectCode() const { return chRejectCode; }\n     std::string GetRejectReason() const { return strRejectReason; }\n     std::string GetDebugMessage() const { return strDebugMessage; }"
      },
      {
        "sha": "068e81819c7dbcf58d8af2b7a7a9947836aac07e",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8c35ac4d3d78d84fd61347b8cd5955490d4c7c60/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8c35ac4d3d78d84fd61347b8cd5955490d4c7c60/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=8c35ac4d3d78d84fd61347b8cd5955490d4c7c60",
        "patch": "@@ -904,7 +904,6 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 // Only the witness is missing, so the transaction itself may be fine.\n                 state.Invalid(ValidationInvalidReason::TX_WITNESS_MUTATED, false,\n                           state.GetRejectCode(), state.GetRejectReason(), state.GetDebugMessage());\n-                state.SetCorruptionPossible();\n             }\n             return false; // state filled in by CheckInputs\n         }\n@@ -1270,7 +1269,7 @@ void static InvalidChainFound(CBlockIndex* pindexNew)\n }\n \n void CChainState::InvalidBlockFound(CBlockIndex *pindex, const CValidationState &state) {\n-    if (!state.CorruptionPossible()) {\n+    if (state.GetReason() != ValidationInvalidReason::BLOCK_MUTATED) {\n         pindex->nStatus |= BLOCK_FAILED_VALID;\n         m_failed_blocks.insert(pindex);\n         setDirtyBlockIndex.insert(pindex);\n@@ -1790,7 +1789,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n     // re-enforce that rule here (at least until we make it impossible for\n     // GetAdjustedTime() to go backward).\n     if (!CheckBlock(block, state, chainparams.GetConsensus(), !fJustCheck, !fJustCheck)) {\n-        if (state.CorruptionPossible()) {\n+        if (state.GetReason() == ValidationInvalidReason::BLOCK_MUTATED) {\n             // We don't write down blocks to disk if they may have been\n             // corrupted, so this should be impossible unless we're having hardware\n             // problems.\n@@ -2569,7 +2568,7 @@ bool CChainState::ActivateBestChainStep(CValidationState& state, const CChainPar\n             if (!ConnectTip(state, chainparams, pindexConnect, pindexConnect == pindexMostWork ? pblock : std::shared_ptr<const CBlock>(), connectTrace, disconnectpool)) {\n                 if (state.IsInvalid()) {\n                     // The block violates a consensus rule.\n-                    if (!state.CorruptionPossible()) {\n+                    if (state.GetReason() != ValidationInvalidReason::BLOCK_MUTATED) {\n                         InvalidChainFound(vpindexToConnect.front());\n                     }\n                     state = CValidationState();\n@@ -3465,7 +3464,7 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CVali\n \n     if (!CheckBlock(block, state, chainparams.GetConsensus()) ||\n         !ContextualCheckBlock(block, state, chainparams.GetConsensus(), pindex->pprev)) {\n-        if (state.IsInvalid() && !state.CorruptionPossible()) {\n+        if (state.IsInvalid() && state.GetReason() != ValidationInvalidReason::BLOCK_MUTATED) {\n             pindex->nStatus |= BLOCK_FAILED_VALID;\n             setDirtyBlockIndex.insert(pindex);\n         }"
      }
    ]
  },
  {
    "sha": "e73cf5195daa5b740775a1cd07ece992c6a89cae",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNzNjZjUxOTVkYWE1Yjc0MDc3NWExY2QwN2VjZTk5MmM2YTg5Y2Fl",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-04-17T14:46:30Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-05-14T16:56:41Z"
      },
      "message": "Update some comments in validation.cpp as we arent doing DoS there",
      "tree": {
        "sha": "65da273ca79f6f53427d3c4c11ee8cf563df80fd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/65da273ca79f6f53427d3c4c11ee8cf563df80fd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e73cf5195daa5b740775a1cd07ece992c6a89cae",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e73cf5195daa5b740775a1cd07ece992c6a89cae",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e73cf5195daa5b740775a1cd07ece992c6a89cae",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e73cf5195daa5b740775a1cd07ece992c6a89cae/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8c35ac4d3d78d84fd61347b8cd5955490d4c7c60",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8c35ac4d3d78d84fd61347b8cd5955490d4c7c60",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8c35ac4d3d78d84fd61347b8cd5955490d4c7c60"
      }
    ],
    "stats": {
      "total": 15,
      "additions": 5,
      "deletions": 10
    },
    "files": [
      {
        "sha": "4b7580a78fe71eecfdd943ebc1fb5b426a8b7444",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 10,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e73cf5195daa5b740775a1cd07ece992c6a89cae/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e73cf5195daa5b740775a1cd07ece992c6a89cae/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=e73cf5195daa5b740775a1cd07ece992c6a89cae",
        "patch": "@@ -1395,21 +1395,16 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                         // Check whether the failure was caused by a\n                         // non-mandatory script verification check, such as\n                         // non-standard DER encodings or non-null dummy\n-                        // arguments; if so, don't trigger DoS protection to\n-                        // avoid splitting the network between upgraded and\n-                        // non-upgraded nodes.\n+                        // arguments; if so, ensure we return NOT_STANDARD\n+                        // instead of CONSENSUS to avoid downstream users\n+                        // splitting the network between upgraded and\n+                        // non-upgraded nodes by banning CONSENSUS-failing\n+                        // data providers.\n                         CScriptCheck check2(coin.out, tx, i,\n                                 flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &txdata);\n                         if (check2())\n                             return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n                     }\n-                    // Failures of other flags indicate a transaction that is\n-                    // invalid in new blocks, e.g. an invalid P2SH. We DoS ban\n-                    // such nodes as they are not following the protocol. That\n-                    // said during an upgrade careful thought should be taken\n-                    // as to the correct behavior - we may want to continue\n-                    // peering with non-upgraded nodes even after soft-fork\n-                    // super-majority signaling has occurred.\n                     return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n                 }\n             }"
      }
    ]
  }
]