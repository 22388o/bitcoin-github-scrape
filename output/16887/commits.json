[
  {
    "sha": "230d43fdbc41b356700b0d8a6984d69e00279ade",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMzBkNDNmZGJjNDFiMzU2NzAwYjBkOGE2OTg0ZDY5ZTAwMjc5YWRl",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-07-30T21:53:05Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-09-18T19:12:13Z"
      },
      "message": "Abstract out some of the descriptor Span-parsing helpers",
      "tree": {
        "sha": "0576b8cc76c3b3c2a491a226e450e6169d1fdafb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0576b8cc76c3b3c2a491a226e450e6169d1fdafb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/230d43fdbc41b356700b0d8a6984d69e00279ade",
      "comment_count": 1,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/230d43fdbc41b356700b0d8a6984d69e00279ade",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/230d43fdbc41b356700b0d8a6984d69e00279ade",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/230d43fdbc41b356700b0d8a6984d69e00279ade/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "796b71363396e2ac99d241f5975c0978cdae3d67",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/796b71363396e2ac99d241f5975c0978cdae3d67",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/796b71363396e2ac99d241f5975c0978cdae3d67"
      }
    ],
    "stats": {
      "total": 164,
      "additions": 107,
      "deletions": 57
    },
    "files": [
      {
        "sha": "ca349eac2a8ae64e27f892e41b401ac2950c1f21",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/230d43fdbc41b356700b0d8a6984d69e00279ade/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/230d43fdbc41b356700b0d8a6984d69e00279ade/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=230d43fdbc41b356700b0d8a6984d69e00279ade",
        "patch": "@@ -208,6 +208,7 @@ BITCOIN_CORE_H = \\\n   util/bytevectorhash.h \\\n   util/error.h \\\n   util/fees.h \\\n+  util/spanparsing.h \\\n   util/system.h \\\n   util/memory.h \\\n   util/moneystr.h \\\n@@ -503,6 +504,7 @@ libbitcoin_util_a_SOURCES = \\\n   util/moneystr.cpp \\\n   util/rbf.cpp \\\n   util/threadnames.cpp \\\n+  util/spanparsing.cpp \\\n   util/strencodings.cpp \\\n   util/string.cpp \\\n   util/time.cpp \\"
      },
      {
        "sha": "2d056b5616a1601aa8645e00ca14c5fbe1351f39",
        "filename": "src/script/descriptor.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 57,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/230d43fdbc41b356700b0d8a6984d69e00279ade/src/script/descriptor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/230d43fdbc41b356700b0d8a6984d69e00279ade/src/script/descriptor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.cpp?ref=230d43fdbc41b356700b0d8a6984d69e00279ade",
        "patch": "@@ -11,6 +11,7 @@\n \n #include <span.h>\n #include <util/bip32.h>\n+#include <util/spanparsing.h>\n #include <util/system.h>\n #include <util/strencodings.h>\n \n@@ -632,63 +633,6 @@ enum class ParseScriptContext {\n     P2WSH,\n };\n \n-/** Parse a constant. If successful, sp is updated to skip the constant and return true. */\n-bool Const(const std::string& str, Span<const char>& sp)\n-{\n-    if ((size_t)sp.size() >= str.size() && std::equal(str.begin(), str.end(), sp.begin())) {\n-        sp = sp.subspan(str.size());\n-        return true;\n-    }\n-    return false;\n-}\n-\n-/** Parse a function call. If successful, sp is updated to be the function's argument(s). */\n-bool Func(const std::string& str, Span<const char>& sp)\n-{\n-    if ((size_t)sp.size() >= str.size() + 2 && sp[str.size()] == '(' && sp[sp.size() - 1] == ')' && std::equal(str.begin(), str.end(), sp.begin())) {\n-        sp = sp.subspan(str.size() + 1, sp.size() - str.size() - 2);\n-        return true;\n-    }\n-    return false;\n-}\n-\n-/** Return the expression that sp begins with, and update sp to skip it. */\n-Span<const char> Expr(Span<const char>& sp)\n-{\n-    int level = 0;\n-    auto it = sp.begin();\n-    while (it != sp.end()) {\n-        if (*it == '(') {\n-            ++level;\n-        } else if (level && *it == ')') {\n-            --level;\n-        } else if (level == 0 && (*it == ')' || *it == ',')) {\n-            break;\n-        }\n-        ++it;\n-    }\n-    Span<const char> ret = sp.first(it - sp.begin());\n-    sp = sp.subspan(it - sp.begin());\n-    return ret;\n-}\n-\n-/** Split a string on every instance of sep, returning a vector. */\n-std::vector<Span<const char>> Split(const Span<const char>& sp, char sep)\n-{\n-    std::vector<Span<const char>> ret;\n-    auto it = sp.begin();\n-    auto start = it;\n-    while (it != sp.end()) {\n-        if (*it == sep) {\n-            ret.emplace_back(start, it);\n-            start = it + 1;\n-        }\n-        ++it;\n-    }\n-    ret.emplace_back(start, it);\n-    return ret;\n-}\n-\n /** Parse a key path, being passed a split list of elements (the first element is ignored). */\n NODISCARD bool ParseKeyPath(const std::vector<Span<const char>>& split, KeyPath& out, std::string& error)\n {\n@@ -715,6 +659,8 @@ NODISCARD bool ParseKeyPath(const std::vector<Span<const char>>& split, KeyPath&\n /** Parse a public key that excludes origin information. */\n std::unique_ptr<PubkeyProvider> ParsePubkeyInner(const Span<const char>& sp, bool permit_uncompressed, FlatSigningProvider& out, std::string& error)\n {\n+    using namespace spanparsing;\n+\n     auto split = Split(sp, '/');\n     std::string str(split[0].begin(), split[0].end());\n     if (str.size() == 0) {\n@@ -774,6 +720,8 @@ std::unique_ptr<PubkeyProvider> ParsePubkeyInner(const Span<const char>& sp, boo\n /** Parse a public key including origin information (if enabled). */\n std::unique_ptr<PubkeyProvider> ParsePubkey(const Span<const char>& sp, bool permit_uncompressed, FlatSigningProvider& out, std::string& error)\n {\n+    using namespace spanparsing;\n+\n     auto origin_split = Split(sp, ']');\n     if (origin_split.size() > 2) {\n         error = \"Multiple ']' characters found for a single pubkey\";\n@@ -808,6 +756,8 @@ std::unique_ptr<PubkeyProvider> ParsePubkey(const Span<const char>& sp, bool per\n /** Parse a script in a particular context. */\n std::unique_ptr<DescriptorImpl> ParseScript(Span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n+    using namespace spanparsing;\n+\n     auto expr = Expr(sp);\n     if (Func(\"pk\", expr)) {\n         auto pubkey = ParsePubkey(expr, ctx != ParseScriptContext::P2WSH, out, error);\n@@ -1003,6 +953,8 @@ std::unique_ptr<DescriptorImpl> InferScript(const CScript& script, ParseScriptCo\n /** Check a descriptor checksum, and update desc to be the checksum-less part. */\n bool CheckChecksum(Span<const char>& sp, bool require_checksum, std::string& error, std::string* out_checksum = nullptr)\n {\n+    using namespace spanparsing;\n+\n     auto check_split = Split(sp, '#');\n     if (check_split.size() > 2) {\n         error = \"Multiple '#' symbols\";"
      },
      {
        "sha": "0c8575399aa575ddaa3715e6a3bdaae280fe0f24",
        "filename": "src/util/spanparsing.cpp",
        "status": "added",
        "additions": 67,
        "deletions": 0,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/230d43fdbc41b356700b0d8a6984d69e00279ade/src/util/spanparsing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/230d43fdbc41b356700b0d8a6984d69e00279ade/src/util/spanparsing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/spanparsing.cpp?ref=230d43fdbc41b356700b0d8a6984d69e00279ade",
        "patch": "@@ -0,0 +1,67 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/spanparsing.h>\n+\n+#include <span.h>\n+\n+#include <string>\n+#include <vector>\n+\n+namespace spanparsing {\n+\n+bool Const(const std::string& str, Span<const char>& sp)\n+{\n+    if ((size_t)sp.size() >= str.size() && std::equal(str.begin(), str.end(), sp.begin())) {\n+        sp = sp.subspan(str.size());\n+        return true;\n+    }\n+    return false;\n+}\n+\n+bool Func(const std::string& str, Span<const char>& sp)\n+{\n+    if ((size_t)sp.size() >= str.size() + 2 && sp[str.size()] == '(' && sp[sp.size() - 1] == ')' && std::equal(str.begin(), str.end(), sp.begin())) {\n+        sp = sp.subspan(str.size() + 1, sp.size() - str.size() - 2);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+Span<const char> Expr(Span<const char>& sp)\n+{\n+    int level = 0;\n+    auto it = sp.begin();\n+    while (it != sp.end()) {\n+        if (*it == '(') {\n+            ++level;\n+        } else if (level && *it == ')') {\n+            --level;\n+        } else if (level == 0 && (*it == ')' || *it == ',')) {\n+            break;\n+        }\n+        ++it;\n+    }\n+    Span<const char> ret = sp.first(it - sp.begin());\n+    sp = sp.subspan(it - sp.begin());\n+    return ret;\n+}\n+\n+std::vector<Span<const char>> Split(const Span<const char>& sp, char sep)\n+{\n+    std::vector<Span<const char>> ret;\n+    auto it = sp.begin();\n+    auto start = it;\n+    while (it != sp.end()) {\n+        if (*it == sep) {\n+            ret.emplace_back(start, it);\n+            start = it + 1;\n+        }\n+        ++it;\n+    }\n+    ret.emplace_back(start, it);\n+    return ret;\n+}\n+\n+} // namespace spanparsing"
      },
      {
        "sha": "a2eb24b1fb74d4bda860efc9cc517bc54d8cd6c7",
        "filename": "src/util/spanparsing.h",
        "status": "added",
        "additions": 29,
        "deletions": 0,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/230d43fdbc41b356700b0d8a6984d69e00279ade/src/util/spanparsing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/230d43fdbc41b356700b0d8a6984d69e00279ade/src/util/spanparsing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/spanparsing.h?ref=230d43fdbc41b356700b0d8a6984d69e00279ade",
        "patch": "@@ -0,0 +1,29 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_SPANPARSING_H\n+#define BITCOIN_UTIL_SPANPARSING_H\n+\n+#include <span.h>\n+\n+#include <string>\n+#include <vector>\n+\n+namespace spanparsing {\n+\n+/** Parse a constant. If successful, sp is updated to skip the constant and return true. */\n+bool Const(const std::string& str, Span<const char>& sp);\n+\n+/** Parse a function call. If successful, sp is updated to be the function's argument(s). */\n+bool Func(const std::string& str, Span<const char>& sp);\n+\n+/** Return the expression that sp begins with, and update sp to skip it. */\n+Span<const char> Expr(Span<const char>& sp);\n+\n+/** Split a string on every instance of sep, returning a vector. */\n+std::vector<Span<const char>> Split(const Span<const char>& sp, char sep);\n+\n+} // namespace spanparsing\n+\n+#endif // BITCOIN_UTIL_SPANPARSING_H"
      }
    ]
  },
  {
    "sha": "5e69aeec3f2a0fafd5e591b7222716f00145761d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ZTY5YWVlYzNmMmEwZmFmZDVlNTkxYjcyMjI3MTZmMDAxNDU3NjFk",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-09-18T19:25:55Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-09-18T19:25:55Z"
      },
      "message": "Add documenting comments to spanparsing.h",
      "tree": {
        "sha": "6005548a9a4a7780a4914e13e7464b53e86ad58f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6005548a9a4a7780a4914e13e7464b53e86ad58f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5e69aeec3f2a0fafd5e591b7222716f00145761d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5e69aeec3f2a0fafd5e591b7222716f00145761d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5e69aeec3f2a0fafd5e591b7222716f00145761d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5e69aeec3f2a0fafd5e591b7222716f00145761d/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "230d43fdbc41b356700b0d8a6984d69e00279ade",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/230d43fdbc41b356700b0d8a6984d69e00279ade",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/230d43fdbc41b356700b0d8a6984d69e00279ade"
      }
    ],
    "stats": {
      "total": 29,
      "additions": 25,
      "deletions": 4
    },
    "files": [
      {
        "sha": "63f54758bd2987971c9ab31e4607703f2d7cbd98",
        "filename": "src/util/spanparsing.h",
        "status": "modified",
        "additions": 25,
        "deletions": 4,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e69aeec3f2a0fafd5e591b7222716f00145761d/src/util/spanparsing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e69aeec3f2a0fafd5e591b7222716f00145761d/src/util/spanparsing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/spanparsing.h?ref=5e69aeec3f2a0fafd5e591b7222716f00145761d",
        "patch": "@@ -12,16 +12,37 @@\n \n namespace spanparsing {\n \n-/** Parse a constant. If successful, sp is updated to skip the constant and return true. */\n+/** Parse a constant.\n+ *\n+ * If sp's initial part matches str, sp is updated to skip that part, and true is returned.\n+ * Otherwise sp is unmodified and false is returned.\n+ */\n bool Const(const std::string& str, Span<const char>& sp);\n \n-/** Parse a function call. If successful, sp is updated to be the function's argument(s). */\n+/** Parse a function call.\n+ *\n+ * If sp's initial part matches str + \"(\", and sp ends with \")\", sp is updated to be the\n+ * section between the braces, and true is returned. Otherwise sp is unmodified and false\n+ * is returned.\n+ */\n bool Func(const std::string& str, Span<const char>& sp);\n \n-/** Return the expression that sp begins with, and update sp to skip it. */\n+/** Extract the expression that sp begins with.\n+ *\n+ * This function will return the initial part of sp, up to (but not including) the first\n+ * comma or closing brace, skipping ones that are surrounded by braces. So for example,\n+ * for \"foo(bar(1),2),3\" the initial part \"foo(bar(1),2)\" will be returned. sp will be\n+ * updated to skip the initial part that is returned.\n+ */\n Span<const char> Expr(Span<const char>& sp);\n \n-/** Split a string on every instance of sep, returning a vector. */\n+/** Split a string on every instance of sep, returning a vector.\n+ *\n+ * If sep does not occur in sp, a singleton with the entirety of sp is returned.\n+ *\n+ * Note that this function does not care about braces, so splitting\n+ * \"foo(bar(1),2),3) on ',' will return {\"foo(bar(1)\", \"2)\", \"3)\"}.\n+ */\n std::vector<Span<const char>> Split(const Span<const char>& sp, char sep);\n \n } // namespace spanparsing"
      }
    ]
  },
  {
    "sha": "bb36372b8f2bd675313ae8553ceb61f28c2c1afd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiYjM2MzcyYjhmMmJkNjc1MzEzYWU4NTUzY2ViNjFmMjhjMmMxYWZk",
    "commit": {
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2019-09-25T07:10:28Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-10-10T01:11:14Z"
      },
      "message": "test: add unit tests for Span-parsing helpers\n\ntests the following four functions:\n    - Const() [parse constant]\n    - Func()  [parse function]\n    - Expr()  [parse expression]\n    - Split() [split up a string]",
      "tree": {
        "sha": "497baeb35a5451bd5954e711413d0e8e0ecde721",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/497baeb35a5451bd5954e711413d0e8e0ecde721"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bb36372b8f2bd675313ae8553ceb61f28c2c1afd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bb36372b8f2bd675313ae8553ceb61f28c2c1afd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bb36372b8f2bd675313ae8553ceb61f28c2c1afd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bb36372b8f2bd675313ae8553ceb61f28c2c1afd/comments",
    "author": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5e69aeec3f2a0fafd5e591b7222716f00145761d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5e69aeec3f2a0fafd5e591b7222716f00145761d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5e69aeec3f2a0fafd5e591b7222716f00145761d"
      }
    ],
    "stats": {
      "total": 124,
      "additions": 124,
      "deletions": 0
    },
    "files": [
      {
        "sha": "31a66b6fa9d6341ae1ae2300ca1a2785c6e4405b",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 124,
        "deletions": 0,
        "changes": 124,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bb36372b8f2bd675313ae8553ceb61f28c2c1afd/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bb36372b8f2bd675313ae8553ceb61f28c2c1afd/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=bb36372b8f2bd675313ae8553ceb61f28c2c1afd",
        "patch": "@@ -12,6 +12,7 @@\n #include <util/strencodings.h>\n #include <util/string.h>\n #include <util/time.h>\n+#include <util/spanparsing.h>\n \n #include <stdint.h>\n #include <thread>\n@@ -1572,4 +1573,127 @@ BOOST_AUTO_TEST_CASE(test_Capitalize)\n     BOOST_CHECK_EQUAL(Capitalize(\"\\x00\\xfe\\xff\"), \"\\x00\\xfe\\xff\");\n }\n \n+static std::string SpanToStr(Span<const char>& span)\n+{\n+    return std::string(span.begin(), span.end());\n+}\n+\n+BOOST_AUTO_TEST_CASE(test_spanparsing)\n+{\n+    using namespace spanparsing;\n+    std::string input;\n+    Span<const char> sp;\n+    bool success;\n+\n+    // Const(...): parse a constant, update span to skip it if successful\n+    input = \"MilkToastHoney\";\n+    sp = MakeSpan(input);\n+    success = Const(\"\", sp); // empty\n+    BOOST_CHECK(success);\n+    BOOST_CHECK_EQUAL(SpanToStr(sp), \"MilkToastHoney\");\n+\n+    success = Const(\"Milk\", sp);\n+    BOOST_CHECK(success);\n+    BOOST_CHECK_EQUAL(SpanToStr(sp), \"ToastHoney\");\n+\n+    success = Const(\"Bread\", sp);\n+    BOOST_CHECK(!success);\n+\n+    success = Const(\"Toast\", sp);\n+    BOOST_CHECK(success);\n+    BOOST_CHECK_EQUAL(SpanToStr(sp), \"Honey\");\n+\n+    success = Const(\"Honeybadger\", sp);\n+    BOOST_CHECK(!success);\n+\n+    success = Const(\"Honey\", sp);\n+    BOOST_CHECK(success);\n+    BOOST_CHECK_EQUAL(SpanToStr(sp), \"\");\n+\n+    // Func(...): parse a function call, update span to argument if successful\n+    input = \"Foo(Bar(xy,z()))\";\n+    sp = MakeSpan(input);\n+\n+    success = Func(\"FooBar\", sp);\n+    BOOST_CHECK(!success);\n+\n+    success = Func(\"Foo(\", sp);\n+    BOOST_CHECK(!success);\n+\n+    success = Func(\"Foo\", sp);\n+    BOOST_CHECK(success);\n+    BOOST_CHECK_EQUAL(SpanToStr(sp), \"Bar(xy,z())\");\n+\n+    success = Func(\"Bar\", sp);\n+    BOOST_CHECK(success);\n+    BOOST_CHECK_EQUAL(SpanToStr(sp), \"xy,z()\");\n+\n+    success = Func(\"xy\", sp);\n+    BOOST_CHECK(!success);\n+\n+    // Expr(...): return expression that span begins with, update span to skip it\n+    Span<const char> result;\n+\n+    input = \"(n*(n-1))/2\";\n+    sp = MakeSpan(input);\n+    result = Expr(sp);\n+    BOOST_CHECK_EQUAL(SpanToStr(result), \"(n*(n-1))/2\");\n+    BOOST_CHECK_EQUAL(SpanToStr(sp), \"\");\n+\n+    input = \"foo,bar\";\n+    sp = MakeSpan(input);\n+    result = Expr(sp);\n+    BOOST_CHECK_EQUAL(SpanToStr(result), \"foo\");\n+    BOOST_CHECK_EQUAL(SpanToStr(sp), \",bar\");\n+\n+    input = \"(aaaaa,bbbbb()),c\";\n+    sp = MakeSpan(input);\n+    result = Expr(sp);\n+    BOOST_CHECK_EQUAL(SpanToStr(result), \"(aaaaa,bbbbb())\");\n+    BOOST_CHECK_EQUAL(SpanToStr(sp), \",c\");\n+\n+    input = \"xyz)foo\";\n+    sp = MakeSpan(input);\n+    result = Expr(sp);\n+    BOOST_CHECK_EQUAL(SpanToStr(result), \"xyz\");\n+    BOOST_CHECK_EQUAL(SpanToStr(sp), \")foo\");\n+\n+    input = \"((a),(b),(c)),xxx\";\n+    sp = MakeSpan(input);\n+    result = Expr(sp);\n+    BOOST_CHECK_EQUAL(SpanToStr(result), \"((a),(b),(c))\");\n+    BOOST_CHECK_EQUAL(SpanToStr(sp), \",xxx\");\n+\n+    // Split(...): split a string on every instance of sep, return vector\n+    std::vector<Span<const char>> results;\n+\n+    input = \"xxx\";\n+    results = Split(MakeSpan(input), 'x');\n+    BOOST_CHECK_EQUAL(results.size(), 4);\n+    BOOST_CHECK_EQUAL(SpanToStr(results[0]), \"\");\n+    BOOST_CHECK_EQUAL(SpanToStr(results[1]), \"\");\n+    BOOST_CHECK_EQUAL(SpanToStr(results[2]), \"\");\n+    BOOST_CHECK_EQUAL(SpanToStr(results[3]), \"\");\n+\n+    input = \"one#two#three\";\n+    results = Split(MakeSpan(input), '-');\n+    BOOST_CHECK_EQUAL(results.size(), 1);\n+    BOOST_CHECK_EQUAL(SpanToStr(results[0]), \"one#two#three\");\n+\n+    input = \"one#two#three\";\n+    results = Split(MakeSpan(input), '#');\n+    BOOST_CHECK_EQUAL(results.size(), 3);\n+    BOOST_CHECK_EQUAL(SpanToStr(results[0]), \"one\");\n+    BOOST_CHECK_EQUAL(SpanToStr(results[1]), \"two\");\n+    BOOST_CHECK_EQUAL(SpanToStr(results[2]), \"three\");\n+\n+    input = \"*foo*bar*\";\n+    results = Split(MakeSpan(input), '*');\n+    BOOST_CHECK_EQUAL(results.size(), 4);\n+    BOOST_CHECK_EQUAL(SpanToStr(results[0]), \"\");\n+    BOOST_CHECK_EQUAL(SpanToStr(results[1]), \"foo\");\n+    BOOST_CHECK_EQUAL(SpanToStr(results[2]), \"bar\");\n+    BOOST_CHECK_EQUAL(SpanToStr(results[3]), \"\");\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  }
]