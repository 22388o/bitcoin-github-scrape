[
  {
    "sha": "00721e69f8280f8bc59bede43b335ecc347d4fdf",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMDcyMWU2OWY4MjgwZjhiYzU5YmVkZTQzYjMzNWVjYzM0N2Q0ZmRm",
    "commit": {
      "author": {
        "name": "Martin Ankerl",
        "email": "Martin.Ankerl@gmail.com",
        "date": "2017-10-17T14:48:02Z"
      },
      "committer": {
        "name": "Martin Ankerl",
        "email": "Martin.Ankerl@gmail.com",
        "date": "2017-12-23T10:03:17Z"
      },
      "message": "Improved microbenchmarking with multiple features.\n\n* inline performance critical code\n* Average runtime is specified and used to calculate iterations.\n* Console: show median of multiple runs\n* plot: show box plot\n* filter benchmarks\n* specify scaling factor\n* ignore src/test and src/bench in command line check script\n* number of iterations instead of time\n* Replaced runtime in BENCHMARK makro number of iterations.\n* Added -? to bench_bitcoin\n* Benchmark plotly.js URL, width, height can be customized\n* Fixed incorrect precision warning",
      "tree": {
        "sha": "950b08aebdfa195a4f166664dd9934164d2edf59",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/950b08aebdfa195a4f166664dd9934164d2edf59"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/00721e69f8280f8bc59bede43b335ecc347d4fdf",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00721e69f8280f8bc59bede43b335ecc347d4fdf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/00721e69f8280f8bc59bede43b335ecc347d4fdf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00721e69f8280f8bc59bede43b335ecc347d4fdf/comments",
    "author": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "604e08c83cf58ca7e7cda2ab284c1ace7bb12977",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/604e08c83cf58ca7e7cda2ab284c1ace7bb12977",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/604e08c83cf58ca7e7cda2ab284c1ace7bb12977"
      }
    ],
    "stats": {
      "total": 457,
      "additions": 286,
      "deletions": 171
    },
    "files": [
      {
        "sha": "47d80e5e015ce22a888fed25de9b62ab7cb809cd",
        "filename": "src/bench/Examples.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/Examples.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/Examples.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/Examples.cpp?ref=00721e69f8280f8bc59bede43b335ecc347d4fdf",
        "patch": "@@ -15,7 +15,7 @@ static void Sleep100ms(benchmark::State& state)\n     }\n }\n \n-BENCHMARK(Sleep100ms);\n+BENCHMARK(Sleep100ms, 10);\n \n // Extremely fast-running benchmark:\n #include <math.h>\n@@ -31,4 +31,4 @@ static void Trig(benchmark::State& state)\n     }\n }\n \n-BENCHMARK(Trig);\n+BENCHMARK(Trig, 12 * 1000 * 1000);"
      },
      {
        "sha": "294fcc3c3362a5d2745e8d7a6f625a7efa0b64e9",
        "filename": "src/bench/base58.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/base58.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/base58.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/base58.cpp?ref=00721e69f8280f8bc59bede43b335ecc347d4fdf",
        "patch": "@@ -54,6 +54,6 @@ static void Base58Decode(benchmark::State& state)\n }\n \n \n-BENCHMARK(Base58Encode);\n-BENCHMARK(Base58CheckEncode);\n-BENCHMARK(Base58Decode);\n+BENCHMARK(Base58Encode, 470 * 1000);\n+BENCHMARK(Base58CheckEncode, 320 * 1000);\n+BENCHMARK(Base58Decode, 800 * 1000);"
      },
      {
        "sha": "edbad09ebdf32c07383b62aea57b91e28d9e1cc1",
        "filename": "src/bench/bench.cpp",
        "status": "modified",
        "additions": 110,
        "deletions": 72,
        "changes": 182,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/bench.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/bench.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.cpp?ref=00721e69f8280f8bc59bede43b335ecc347d4fdf",
        "patch": "@@ -8,98 +8,136 @@\n #include <assert.h>\n #include <iostream>\n #include <iomanip>\n+#include <algorithm>\n+#include <regex>\n+#include <numeric>\n \n-benchmark::BenchRunner::BenchmarkMap &benchmark::BenchRunner::benchmarks() {\n-    static std::map<std::string, benchmark::BenchFunction> benchmarks_map;\n-    return benchmarks_map;\n+void benchmark::ConsolePrinter::header()\n+{\n+    std::cout << \"# Benchmark, evals, iterations, total, min, max, median\" << std::endl;\n }\n \n-benchmark::BenchRunner::BenchRunner(std::string name, benchmark::BenchFunction func)\n+void benchmark::ConsolePrinter::result(const State& state)\n {\n-    benchmarks().insert(std::make_pair(name, func));\n+    auto results = state.m_elapsed_results;\n+    std::sort(results.begin(), results.end());\n+\n+    double total = state.m_num_iters * std::accumulate(results.begin(), results.end(), 0.0);\n+\n+    double front = 0;\n+    double back = 0;\n+    double median = 0;\n+\n+    if (!results.empty()) {\n+        front = results.front();\n+        back = results.back();\n+\n+        size_t mid = results.size() / 2;\n+        median = results[mid];\n+        if (0 == results.size() % 2) {\n+            median = (results[mid] + results[mid + 1]) / 2;\n+        }\n+    }\n+\n+    std::cout << std::setprecision(6);\n+    std::cout << state.m_name << \", \" << state.m_num_evals << \", \" << state.m_num_iters << \", \" << total << \", \" << front << \", \" << back << \", \" << median << std::endl;\n }\n \n-void\n-benchmark::BenchRunner::RunAll(benchmark::duration elapsedTimeForOne)\n+void benchmark::ConsolePrinter::footer() {}\n+benchmark::PlotlyPrinter::PlotlyPrinter(std::string plotly_url, int64_t width, int64_t height)\n+    : m_plotly_url(plotly_url), m_width(width), m_height(height)\n {\n-    perf_init();\n-    if (std::ratio_less_equal<benchmark::clock::period, std::micro>::value) {\n-        std::cerr << \"WARNING: Clock precision is worse than microsecond - benchmarks may be less accurate!\\n\";\n-    }\n-    std::cout << \"#Benchmark\" << \",\" << \"count\" << \",\" << \"min(ns)\" << \",\" << \"max(ns)\" << \",\" << \"average(ns)\" << \",\"\n-              << \"min_cycles\" << \",\" << \"max_cycles\" << \",\" << \"average_cycles\" << \"\\n\";\n+}\n \n-    for (const auto &p: benchmarks()) {\n-        State state(p.first, elapsedTimeForOne);\n-        p.second(state);\n-    }\n-    perf_fini();\n+void benchmark::PlotlyPrinter::header()\n+{\n+    std::cout << \"<html><head>\"\n+              << \"<script src=\\\"\" << m_plotly_url << \"\\\"></script>\"\n+              << \"</head><body><div id=\\\"myDiv\\\" style=\\\"width:\" << m_width << \"px; height:\" << m_height << \"px\\\"></div>\"\n+              << \"<script> var data = [\"\n+              << std::endl;\n }\n \n-bool benchmark::State::KeepRunning()\n+void benchmark::PlotlyPrinter::result(const State& state)\n {\n-    if (count & countMask) {\n-      ++count;\n-      return true;\n+    std::cout << \"{ \" << std::endl\n+              << \"  name: '\" << state.m_name << \"', \" << std::endl\n+              << \"  y: [\";\n+\n+    const char* prefix = \"\";\n+    for (const auto& e : state.m_elapsed_results) {\n+        std::cout << prefix << std::setprecision(6) << e;\n+        prefix = \", \";\n     }\n-    time_point now;\n+    std::cout << \"],\" << std::endl\n+              << \"  boxpoints: 'all', jitter: 0.3, pointpos: 0, type: 'box',\"\n+              << std::endl\n+              << \"},\" << std::endl;\n+}\n+\n+void benchmark::PlotlyPrinter::footer()\n+{\n+    std::cout << \"]; var layout = { showlegend: false, yaxis: { rangemode: 'tozero', autorange: true } };\"\n+              << \"Plotly.newPlot('myDiv', data, layout);\"\n+              << \"</script></body></html>\";\n+}\n \n-    uint64_t nowCycles;\n-    if (count == 0) {\n-        lastTime = beginTime = now = clock::now();\n-        lastCycles = beginCycles = nowCycles = perf_cpucycles();\n+\n+benchmark::BenchRunner::BenchmarkMap& benchmark::BenchRunner::benchmarks()\n+{\n+    static std::map<std::string, Bench> benchmarks_map;\n+    return benchmarks_map;\n+}\n+\n+benchmark::BenchRunner::BenchRunner(std::string name, benchmark::BenchFunction func, uint64_t num_iters_for_one_second)\n+{\n+    benchmarks().insert(std::make_pair(name, Bench{func, num_iters_for_one_second}));\n+}\n+\n+void benchmark::BenchRunner::RunAll(Printer& printer, uint64_t num_evals, double scaling, const std::string& filter, bool is_list_only)\n+{\n+    perf_init();\n+    if (!std::ratio_less_equal<benchmark::clock::period, std::micro>::value) {\n+        std::cerr << \"WARNING: Clock precision is worse than microsecond - benchmarks may be less accurate!\\n\";\n     }\n-    else {\n-        now = clock::now();\n-        auto elapsed = now - lastTime;\n-        auto elapsedOne = elapsed / (countMask + 1);\n-        if (elapsedOne < minTime) minTime = elapsedOne;\n-        if (elapsedOne > maxTime) maxTime = elapsedOne;\n-\n-        // We only use relative values, so don't have to handle 64-bit wrap-around specially\n-        nowCycles = perf_cpucycles();\n-        uint64_t elapsedOneCycles = (nowCycles - lastCycles) / (countMask + 1);\n-        if (elapsedOneCycles < minCycles) minCycles = elapsedOneCycles;\n-        if (elapsedOneCycles > maxCycles) maxCycles = elapsedOneCycles;\n-\n-        if (elapsed*128 < maxElapsed) {\n-          // If the execution was much too fast (1/128th of maxElapsed), increase the count mask by 8x and restart timing.\n-          // The restart avoids including the overhead of this code in the measurement.\n-          countMask = ((countMask<<3)|7) & ((1LL<<60)-1);\n-          count = 0;\n-          minTime = duration::max();\n-          maxTime = duration::zero();\n-          minCycles = std::numeric_limits<uint64_t>::max();\n-          maxCycles = std::numeric_limits<uint64_t>::min();\n-          return true;\n+\n+    std::regex reFilter(filter);\n+    std::smatch baseMatch;\n+\n+    printer.header();\n+\n+    for (const auto& p : benchmarks()) {\n+        if (!std::regex_match(p.first, baseMatch, reFilter)) {\n+            continue;\n+        }\n+\n+        uint64_t num_iters = static_cast<uint64_t>(p.second.num_iters_for_one_second * scaling);\n+        if (0 == num_iters) {\n+            num_iters = 1;\n         }\n-        if (elapsed*16 < maxElapsed) {\n-          uint64_t newCountMask = ((countMask<<1)|1) & ((1LL<<60)-1);\n-          if ((count & newCountMask)==0) {\n-              countMask = newCountMask;\n-          }\n+        State state(p.first, num_evals, num_iters, printer);\n+        if (!is_list_only) {\n+            p.second.func(state);\n         }\n+        printer.result(state);\n     }\n-    lastTime = now;\n-    lastCycles = nowCycles;\n-    ++count;\n \n-    if (now - beginTime < maxElapsed) return true; // Keep going\n+    printer.footer();\n \n-    --count;\n+    perf_fini();\n+}\n \n-    assert(count != 0 && \"count == 0 => (now == 0 && beginTime == 0) => return above\");\n+bool benchmark::State::UpdateTimer(const benchmark::time_point current_time)\n+{\n+    if (m_start_time != time_point()) {\n+        std::chrono::duration<double> diff = current_time - m_start_time;\n+        m_elapsed_results.push_back(diff.count() / m_num_iters);\n \n-    // Output results\n-    // Duration casts are only necessary here because hardware with sub-nanosecond clocks\n-    // will lose precision.\n-    int64_t min_elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>(minTime).count();\n-    int64_t max_elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>(maxTime).count();\n-    int64_t avg_elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>((now-beginTime)/count).count();\n-    int64_t averageCycles = (nowCycles-beginCycles)/count;\n-    std::cout << std::fixed << std::setprecision(15) << name << \",\" << count << \",\" << min_elapsed << \",\" << max_elapsed << \",\" << avg_elapsed << \",\"\n-              << minCycles << \",\" << maxCycles << \",\" << averageCycles << \"\\n\";\n-    std::cout.copyfmt(std::ios(nullptr));\n+        if (m_elapsed_results.size() == m_num_evals) {\n+            return false;\n+        }\n+    }\n \n-    return false;\n+    m_num_iters_left = m_num_iters - 1;\n+    return true;\n }"
      },
      {
        "sha": "b7d81f0e2142f5f5a39d8fef914caf449cef216a",
        "filename": "src/bench/bench.h",
        "status": "modified",
        "additions": 95,
        "deletions": 48,
        "changes": 143,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.h?ref=00721e69f8280f8bc59bede43b335ecc347d4fdf",
        "patch": "@@ -9,6 +9,7 @@\n #include <limits>\n #include <map>\n #include <string>\n+#include <vector>\n #include <chrono>\n \n #include <boost/preprocessor/cat.hpp>\n@@ -32,64 +33,110 @@ static void CODE_TO_TIME(benchmark::State& state)\n     ... do any cleanup needed...\n }\n \n-BENCHMARK(CODE_TO_TIME);\n+// default to running benchmark for 5000 iterations\n+BENCHMARK(CODE_TO_TIME, 5000);\n \n  */\n- \n+\n namespace benchmark {\n-    // In case high_resolution_clock is steady, prefer that, otherwise use steady_clock.\n-    struct best_clock {\n-        using hi_res_clock = std::chrono::high_resolution_clock;\n-        using steady_clock = std::chrono::steady_clock;\n-        using type = std::conditional<hi_res_clock::is_steady, hi_res_clock, steady_clock>::type;\n-    };\n-    using clock = best_clock::type;\n-    using time_point = clock::time_point;\n-    using duration = clock::duration;\n-\n-    class State {\n-        std::string name;\n-        duration maxElapsed;\n-        time_point beginTime, lastTime;\n-        duration minTime, maxTime;\n-        uint64_t count;\n-        uint64_t countMask;\n-        uint64_t beginCycles;\n-        uint64_t lastCycles;\n-        uint64_t minCycles;\n-        uint64_t maxCycles;\n-    public:\n-        State(std::string _name, duration _maxElapsed) :\n-            name(_name),\n-            maxElapsed(_maxElapsed),\n-            minTime(duration::max()),\n-            maxTime(duration::zero()),\n-            count(0),\n-            countMask(1),\n-            beginCycles(0),\n-            lastCycles(0),\n-            minCycles(std::numeric_limits<uint64_t>::max()),\n-            maxCycles(std::numeric_limits<uint64_t>::min()) {\n-        }\n-        bool KeepRunning();\n-    };\n+// In case high_resolution_clock is steady, prefer that, otherwise use steady_clock.\n+struct best_clock {\n+    using hi_res_clock = std::chrono::high_resolution_clock;\n+    using steady_clock = std::chrono::steady_clock;\n+    using type = std::conditional<hi_res_clock::is_steady, hi_res_clock, steady_clock>::type;\n+};\n+using clock = best_clock::type;\n+using time_point = clock::time_point;\n+using duration = clock::duration;\n+\n+class Printer;\n+\n+class State\n+{\n+public:\n+    std::string m_name;\n+    uint64_t m_num_iters_left;\n+    const uint64_t m_num_iters;\n+    const uint64_t m_num_evals;\n+    std::vector<double> m_elapsed_results;\n+    time_point m_start_time;\n+\n+    bool UpdateTimer(time_point finish_time);\n \n-    typedef std::function<void(State&)> BenchFunction;\n+    State(std::string name, uint64_t num_evals, double num_iters, Printer& printer) : m_name(name), m_num_iters_left(0), m_num_iters(num_iters), m_num_evals(num_evals)\n+    {\n+    }\n \n-    class BenchRunner\n+    inline bool KeepRunning()\n     {\n-        typedef std::map<std::string, BenchFunction> BenchmarkMap;\n-        static BenchmarkMap &benchmarks();\n+        if (m_num_iters_left--) {\n+            return true;\n+        }\n+\n+        bool result = UpdateTimer(clock::now());\n+        // measure again so runtime of UpdateTimer is not included\n+        m_start_time = clock::now();\n+        return result;\n+    }\n+};\n \n-    public:\n-        BenchRunner(std::string name, BenchFunction func);\n+typedef std::function<void(State&)> BenchFunction;\n \n-        static void RunAll(duration elapsedTimeForOne = std::chrono::seconds(1));\n+class BenchRunner\n+{\n+    struct Bench {\n+        BenchFunction func;\n+        uint64_t num_iters_for_one_second;\n     };\n+    typedef std::map<std::string, Bench> BenchmarkMap;\n+    static BenchmarkMap& benchmarks();\n+\n+public:\n+    BenchRunner(std::string name, BenchFunction func, uint64_t num_iters_for_one_second);\n+\n+    static void RunAll(Printer& printer, uint64_t num_evals, double scaling, const std::string& filter, bool is_list_only);\n+};\n+\n+// interface to output benchmark results.\n+class Printer\n+{\n+public:\n+    virtual ~Printer() {}\n+    virtual void header() = 0;\n+    virtual void result(const State& state) = 0;\n+    virtual void footer() = 0;\n+};\n+\n+// default printer to console, shows min, max, median.\n+class ConsolePrinter : public Printer\n+{\n+public:\n+    void header();\n+    void result(const State& state);\n+    void footer();\n+};\n+\n+// creates box plot with plotly.js\n+class PlotlyPrinter : public Printer\n+{\n+public:\n+    PlotlyPrinter(std::string plotly_url, int64_t width, int64_t height);\n+    void header();\n+    void result(const State& state);\n+    void footer();\n+\n+private:\n+    std::string m_plotly_url;\n+    int64_t m_width;\n+    int64_t m_height;\n+};\n }\n \n-// BENCHMARK(foo) expands to:  benchmark::BenchRunner bench_11foo(\"foo\", foo);\n-#define BENCHMARK(n) \\\n-    benchmark::BenchRunner BOOST_PP_CAT(bench_, BOOST_PP_CAT(__LINE__, n))(BOOST_PP_STRINGIZE(n), n);\n+\n+// BENCHMARK(foo, num_iters_for_one_second) expands to:  benchmark::BenchRunner bench_11foo(\"foo\", num_iterations);\n+// Choose a num_iters_for_one_second that takes roughly 1 second. The goal is that all benchmarks should take approximately\n+// the same time, and scaling factor can be used that the total time is appropriate for your system.\n+#define BENCHMARK(n, num_iters_for_one_second) \\\n+    benchmark::BenchRunner BOOST_PP_CAT(bench_, BOOST_PP_CAT(__LINE__, n))(BOOST_PP_STRINGIZE(n), n, (num_iters_for_one_second));\n \n #endif // BITCOIN_BENCH_BENCH_H"
      },
      {
        "sha": "5e0432f0eeb6ff67a3f681b7cb9441371158d717",
        "filename": "src/bench/bench_bitcoin.cpp",
        "status": "modified",
        "additions": 47,
        "deletions": 1,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/bench_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/bench_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench_bitcoin.cpp?ref=00721e69f8280f8bc59bede43b335ecc347d4fdf",
        "patch": "@@ -10,16 +10,62 @@\n #include <util.h>\n #include <random.h>\n \n+#include <boost/lexical_cast.hpp>\n+\n+#include <memory>\n+\n+static const int64_t DEFAULT_BENCH_EVALUATIONS = 5;\n+static const char* DEFAULT_BENCH_FILTER = \".*\";\n+static const char* DEFAULT_BENCH_SCALING = \"1.0\";\n+static const char* DEFAULT_BENCH_PRINTER = \"console\";\n+static const char* DEFAULT_PLOT_PLOTLYURL = \"https://cdn.plot.ly/plotly-latest.min.js\";\n+static const int64_t DEFAULT_PLOT_WIDTH = 1024;\n+static const int64_t DEFAULT_PLOT_HEIGHT = 768;\n+\n int\n main(int argc, char** argv)\n {\n+    gArgs.ParseParameters(argc, argv);\n+\n+    if (gArgs.IsArgSet(\"-?\") || gArgs.IsArgSet(\"-h\") || gArgs.IsArgSet(\"-help\")) {\n+        std::cout << HelpMessageGroup(_(\"Options:\"))\n+                  << HelpMessageOpt(\"-?\", _(\"Print this help message and exit\"))\n+                  << HelpMessageOpt(\"-list\", _(\"List benchmarks without executing them. Can be combined with -scaling and -filter\"))\n+                  << HelpMessageOpt(\"-evals=<n>\", strprintf(_(\"Number of measurement evaluations to perform. (default: %u)\"), DEFAULT_BENCH_EVALUATIONS))\n+                  << HelpMessageOpt(\"-filter=<regex>\", strprintf(_(\"Regular expression filter to select benchmark by name (default: %s)\"), DEFAULT_BENCH_FILTER))\n+                  << HelpMessageOpt(\"-scaling=<n>\", strprintf(_(\"Scaling factor for benchmark's runtime (default: %u)\"), DEFAULT_BENCH_SCALING))\n+                  << HelpMessageOpt(\"-printer=(console|plot)\", strprintf(_(\"Choose printer format. console: print data to console. plot: Print results as HTML graph (default: %s)\"), DEFAULT_BENCH_PRINTER))\n+                  << HelpMessageOpt(\"-plot-plotlyurl=<uri>\", strprintf(_(\"URL to use for plotly.js (default: %s)\"), DEFAULT_PLOT_PLOTLYURL))\n+                  << HelpMessageOpt(\"-plot-width=<x>\", strprintf(_(\"Plot width in pixel (default: %u)\"), DEFAULT_PLOT_WIDTH))\n+                  << HelpMessageOpt(\"-plot-height=<x>\", strprintf(_(\"Plot height in pixel (default: %u)\"), DEFAULT_PLOT_HEIGHT));\n+\n+        return 0;\n+    }\n+\n     SHA256AutoDetect();\n     RandomInit();\n     ECC_Start();\n     SetupEnvironment();\n     fPrintToDebugLog = false; // don't want to write to debug.log file\n \n-    benchmark::BenchRunner::RunAll();\n+    int64_t evaluations = gArgs.GetArg(\"-evals\", DEFAULT_BENCH_EVALUATIONS);\n+    std::string regex_filter = gArgs.GetArg(\"-filter\", DEFAULT_BENCH_FILTER);\n+    std::string scaling_str = gArgs.GetArg(\"-scaling\", DEFAULT_BENCH_SCALING);\n+    bool is_list_only = gArgs.GetBoolArg(\"-list\", false);\n+\n+    double scaling_factor = boost::lexical_cast<double>(scaling_str);\n+\n+\n+    std::unique_ptr<benchmark::Printer> printer(new benchmark::ConsolePrinter());\n+    std::string printer_arg = gArgs.GetArg(\"-printer\", DEFAULT_BENCH_PRINTER);\n+    if (\"plot\" == printer_arg) {\n+        printer.reset(new benchmark::PlotlyPrinter(\n+            gArgs.GetArg(\"-plot-plotlyurl\", DEFAULT_PLOT_PLOTLYURL),\n+            gArgs.GetArg(\"-plot-width\", DEFAULT_PLOT_WIDTH),\n+            gArgs.GetArg(\"-plot-height\", DEFAULT_PLOT_HEIGHT)));\n+    }\n+\n+    benchmark::BenchRunner::RunAll(*printer, evaluations, scaling_factor, regex_filter, is_list_only);\n \n     ECC_Stop();\n }"
      },
      {
        "sha": "1bce0fffbde8f8633cee2f05b7ca1bc6478075d6",
        "filename": "src/bench/ccoins_caching.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/ccoins_caching.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/ccoins_caching.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/ccoins_caching.cpp?ref=00721e69f8280f8bc59bede43b335ecc347d4fdf",
        "patch": "@@ -84,4 +84,4 @@ static void CCoinsCaching(benchmark::State& state)\n     }\n }\n \n-BENCHMARK(CCoinsCaching);\n+BENCHMARK(CCoinsCaching, 170 * 1000);"
      },
      {
        "sha": "af77c8cd8b9fd52b2e94501bac56f6beee786fee",
        "filename": "src/bench/checkblock.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/checkblock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/checkblock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkblock.cpp?ref=00721e69f8280f8bc59bede43b335ecc347d4fdf",
        "patch": "@@ -52,5 +52,5 @@ static void DeserializeAndCheckBlockTest(benchmark::State& state)\n     }\n }\n \n-BENCHMARK(DeserializeBlockTest);\n-BENCHMARK(DeserializeAndCheckBlockTest);\n+BENCHMARK(DeserializeBlockTest, 130);\n+BENCHMARK(DeserializeAndCheckBlockTest, 160);"
      },
      {
        "sha": "e79c9867927e3c40b666619c78b051151650108c",
        "filename": "src/bench/checkqueue.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/checkqueue.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/checkqueue.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkqueue.cpp?ref=00721e69f8280f8bc59bede43b335ecc347d4fdf",
        "patch": "@@ -99,5 +99,5 @@ static void CCheckQueueSpeedPrevectorJob(benchmark::State& state)\n     tg.interrupt_all();\n     tg.join_all();\n }\n-BENCHMARK(CCheckQueueSpeed);\n-BENCHMARK(CCheckQueueSpeedPrevectorJob);\n+BENCHMARK(CCheckQueueSpeed, 29000);\n+BENCHMARK(CCheckQueueSpeedPrevectorJob, 1400);"
      },
      {
        "sha": "b9353293d4951460765aa83790abe8bd981c366b",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=00721e69f8280f8bc59bede43b335ecc347d4fdf",
        "patch": "@@ -56,4 +56,4 @@ static void CoinSelection(benchmark::State& state)\n     }\n }\n \n-BENCHMARK(CoinSelection);\n+BENCHMARK(CoinSelection, 650);"
      },
      {
        "sha": "bb89718074049383f2ecd72276c26e54bf08d7fe",
        "filename": "src/bench/crypto_hash.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 20,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/crypto_hash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/crypto_hash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/crypto_hash.cpp?ref=00721e69f8280f8bc59bede43b335ecc347d4fdf",
        "patch": "@@ -46,9 +46,9 @@ static void SHA256_32b(benchmark::State& state)\n {\n     std::vector<uint8_t> in(32,0);\n     while (state.KeepRunning()) {\n-        for (int i = 0; i < 1000000; i++) {\n-            CSHA256().Write(in.data(), in.size()).Finalize(in.data());\n-        }\n+        CSHA256()\n+            .Write(in.data(), in.size())\n+            .Finalize(in.data());\n     }\n }\n \n@@ -63,10 +63,9 @@ static void SHA512(benchmark::State& state)\n static void SipHash_32b(benchmark::State& state)\n {\n     uint256 x;\n+    uint64_t k1 = 0;\n     while (state.KeepRunning()) {\n-        for (int i = 0; i < 1000000; i++) {\n-            *((uint64_t*)x.begin()) = SipHashUint256(0, i, x);\n-        }\n+        *((uint64_t*)x.begin()) = SipHashUint256(0, ++k1, x);\n     }\n }\n \n@@ -75,9 +74,7 @@ static void FastRandom_32bit(benchmark::State& state)\n     FastRandomContext rng(true);\n     uint32_t x = 0;\n     while (state.KeepRunning()) {\n-        for (int i = 0; i < 1000000; i++) {\n-            x += rng.rand32();\n-        }\n+        x += rng.rand32();\n     }\n }\n \n@@ -86,18 +83,16 @@ static void FastRandom_1bit(benchmark::State& state)\n     FastRandomContext rng(true);\n     uint32_t x = 0;\n     while (state.KeepRunning()) {\n-        for (int i = 0; i < 1000000; i++) {\n-            x += rng.randbool();\n-        }\n+        x += rng.randbool();\n     }\n }\n \n-BENCHMARK(RIPEMD160);\n-BENCHMARK(SHA1);\n-BENCHMARK(SHA256);\n-BENCHMARK(SHA512);\n+BENCHMARK(RIPEMD160, 440);\n+BENCHMARK(SHA1, 570);\n+BENCHMARK(SHA256, 340);\n+BENCHMARK(SHA512, 330);\n \n-BENCHMARK(SHA256_32b);\n-BENCHMARK(SipHash_32b);\n-BENCHMARK(FastRandom_32bit);\n-BENCHMARK(FastRandom_1bit);\n+BENCHMARK(SHA256_32b, 4700 * 1000);\n+BENCHMARK(SipHash_32b, 40 * 1000 * 1000);\n+BENCHMARK(FastRandom_32bit, 110 * 1000 * 1000);\n+BENCHMARK(FastRandom_1bit, 440 * 1000 * 1000);"
      },
      {
        "sha": "914e37a2ed9fc51f5ddc74f1aa05132f32a8da4a",
        "filename": "src/bench/lockedpool.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/lockedpool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/lockedpool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/lockedpool.cpp?ref=00721e69f8280f8bc59bede43b335ecc347d4fdf",
        "patch": "@@ -43,5 +43,4 @@ static void BenchLockedPool(benchmark::State& state)\n     addr.clear();\n }\n \n-BENCHMARK(BenchLockedPool);\n-\n+BENCHMARK(BenchLockedPool, 530);"
      },
      {
        "sha": "de9f6432e306fbca4f1ee38642724f123be9b534",
        "filename": "src/bench/mempool_eviction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/mempool_eviction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/mempool_eviction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/mempool_eviction.cpp?ref=00721e69f8280f8bc59bede43b335ecc347d4fdf",
        "patch": "@@ -111,4 +111,4 @@ static void MempoolEviction(benchmark::State& state)\n     }\n }\n \n-BENCHMARK(MempoolEviction);\n+BENCHMARK(MempoolEviction, 41000);"
      },
      {
        "sha": "39d0ee5eb194a214aeda584bd4a150156a78bce6",
        "filename": "src/bench/prevector_destructor.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/prevector_destructor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/prevector_destructor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/prevector_destructor.cpp?ref=00721e69f8280f8bc59bede43b335ecc347d4fdf",
        "patch": "@@ -32,5 +32,5 @@ static void PrevectorClear(benchmark::State& state)\n     }\n }\n \n-BENCHMARK(PrevectorDestructor);\n-BENCHMARK(PrevectorClear);\n+BENCHMARK(PrevectorDestructor, 5700);\n+BENCHMARK(PrevectorClear, 5600);"
      },
      {
        "sha": "031355c06ecea92ac2f5f4eeb1b51a4ae5284d42",
        "filename": "src/bench/rollingbloom.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 13,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/rollingbloom.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/rollingbloom.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/rollingbloom.cpp?ref=00721e69f8280f8bc59bede43b335ecc347d4fdf",
        "patch": "@@ -12,25 +12,15 @@ static void RollingBloom(benchmark::State& state)\n     CRollingBloomFilter filter(120000, 0.000001);\n     std::vector<unsigned char> data(32);\n     uint32_t count = 0;\n-    uint32_t nEntriesPerGeneration = (120000 + 1) / 2;\n-    uint32_t countnow = 0;\n     uint64_t match = 0;\n     while (state.KeepRunning()) {\n         count++;\n         data[0] = count;\n         data[1] = count >> 8;\n         data[2] = count >> 16;\n         data[3] = count >> 24;\n-        if (countnow == nEntriesPerGeneration) {\n-            auto b = benchmark::clock::now();\n-            filter.insert(data);\n-            auto total = std::chrono::duration_cast<std::chrono::nanoseconds>(benchmark::clock::now() - b).count();\n-            std::cout << \"RollingBloom-refresh,1,\" << total << \",\" << total << \",\" << total << \"\\n\";\n-            countnow = 0;\n-        } else {\n-            filter.insert(data);\n-        }\n-        countnow++;\n+        filter.insert(data);\n+\n         data[0] = count >> 24;\n         data[1] = count >> 16;\n         data[2] = count >> 8;\n@@ -39,4 +29,4 @@ static void RollingBloom(benchmark::State& state)\n     }\n }\n \n-BENCHMARK(RollingBloom);\n+BENCHMARK(RollingBloom, 1500 * 1000);"
      },
      {
        "sha": "af6d626ed04835a184cb345f6723a99ac8fe8a2b",
        "filename": "src/bench/verify_script.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/verify_script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00721e69f8280f8bc59bede43b335ecc347d4fdf/src/bench/verify_script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/verify_script.cpp?ref=00721e69f8280f8bc59bede43b335ecc347d4fdf",
        "patch": "@@ -105,4 +105,4 @@ static void VerifyScriptBench(benchmark::State& state)\n     }\n }\n \n-BENCHMARK(VerifyScriptBench);\n+BENCHMARK(VerifyScriptBench, 6300);"
      }
    ]
  },
  {
    "sha": "760af84072408ba53d009e868fccc25fb186d40c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3NjBhZjg0MDcyNDA4YmE1M2QwMDllODY4ZmNjYzI1ZmIxODZkNDBj",
    "commit": {
      "author": {
        "name": "Martin Ankerl",
        "email": "Martin.Ankerl@gmail.com",
        "date": "2017-12-20T18:53:28Z"
      },
      "committer": {
        "name": "Martin Ankerl",
        "email": "Martin.Ankerl@gmail.com",
        "date": "2017-12-23T10:03:17Z"
      },
      "message": "Removed CCheckQueueSpeed benchmark\n\nThis benchmark's runtime was rather unpredictive on different machines, not really a useful benchmark.",
      "tree": {
        "sha": "a1c416ed81a450f35488cdf2d7e1091f856b0fb7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a1c416ed81a450f35488cdf2d7e1091f856b0fb7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/760af84072408ba53d009e868fccc25fb186d40c",
      "comment_count": 2,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/760af84072408ba53d009e868fccc25fb186d40c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/760af84072408ba53d009e868fccc25fb186d40c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/760af84072408ba53d009e868fccc25fb186d40c/comments",
    "author": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "00721e69f8280f8bc59bede43b335ecc347d4fdf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00721e69f8280f8bc59bede43b335ecc347d4fdf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/00721e69f8280f8bc59bede43b335ecc347d4fdf"
      }
    ],
    "stats": {
      "total": 41,
      "additions": 0,
      "deletions": 41
    },
    "files": [
      {
        "sha": "4d41e28db6e29b027c83b92483bfe354382ecf67",
        "filename": "src/bench/checkqueue.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 41,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/760af84072408ba53d009e868fccc25fb186d40c/src/bench/checkqueue.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/760af84072408ba53d009e868fccc25fb186d40c/src/bench/checkqueue.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkqueue.cpp?ref=760af84072408ba53d009e868fccc25fb186d40c",
        "patch": "@@ -12,51 +12,11 @@\n #include <random.h>\n \n \n-// This Benchmark tests the CheckQueue with the lightest\n-// weight Checks, so it should make any lock contention\n-// particularly visible\n static const int MIN_CORES = 2;\n static const size_t BATCHES = 101;\n static const size_t BATCH_SIZE = 30;\n static const int PREVECTOR_SIZE = 28;\n static const unsigned int QUEUE_BATCH_SIZE = 128;\n-static void CCheckQueueSpeed(benchmark::State& state)\n-{\n-    struct FakeJobNoWork {\n-        bool operator()()\n-        {\n-            return true;\n-        }\n-        void swap(FakeJobNoWork& x){};\n-    };\n-    CCheckQueue<FakeJobNoWork> queue {QUEUE_BATCH_SIZE};\n-    boost::thread_group tg;\n-    for (auto x = 0; x < std::max(MIN_CORES, GetNumCores()); ++x) {\n-       tg.create_thread([&]{queue.Thread();});\n-    }\n-    while (state.KeepRunning()) {\n-        CCheckQueueControl<FakeJobNoWork> control(&queue);\n-\n-        // We call Add a number of times to simulate the behavior of adding\n-        // a block of transactions at once.\n-\n-        std::vector<std::vector<FakeJobNoWork>> vBatches(BATCHES);\n-        for (auto& vChecks : vBatches) {\n-            vChecks.resize(BATCH_SIZE);\n-        }\n-        for (auto& vChecks : vBatches) {\n-            // We can't make vChecks in the inner loop because we want to measure\n-            // the cost of getting the memory to each thread and we might get the same\n-            // memory\n-            control.Add(vChecks);\n-        }\n-        // control waits for completion by RAII, but\n-        // it is done explicitly here for clarity\n-        control.Wait();\n-    }\n-    tg.interrupt_all();\n-    tg.join_all();\n-}\n \n // This Benchmark tests the CheckQueue with a slightly realistic workload,\n // where checks all contain a prevector that is indirect 50% of the time\n@@ -99,5 +59,4 @@ static void CCheckQueueSpeedPrevectorJob(benchmark::State& state)\n     tg.interrupt_all();\n     tg.join_all();\n }\n-BENCHMARK(CCheckQueueSpeed, 29000);\n BENCHMARK(CCheckQueueSpeedPrevectorJob, 1400);"
      }
    ]
  }
]