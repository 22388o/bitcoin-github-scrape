[
  {
    "sha": "2d4327db1973a354e9e4153de6958d49120fcde8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyZDQzMjdkYjE5NzNhMzU0ZTllNDE1M2RlNjk1OGQ0OTEyMGZjZGU4",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-10-23T17:36:15Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-11-01T17:13:43Z"
      },
      "message": "net: Allow connecting to extra outbound peers",
      "tree": {
        "sha": "2f31c4deb1facd3378b84467e3e1ddbca3a51da9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2f31c4deb1facd3378b84467e3e1ddbca3a51da9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2d4327db1973a354e9e4153de6958d49120fcde8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2d4327db1973a354e9e4153de6958d49120fcde8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2d4327db1973a354e9e4153de6958d49120fcde8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2d4327db1973a354e9e4153de6958d49120fcde8/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ba216b5fa63e7e6cae847d1e3621f5c54840f898",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ba216b5fa63e7e6cae847d1e3621f5c54840f898",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ba216b5fa63e7e6cae847d1e3621f5c54840f898"
      }
    ],
    "stats": {
      "total": 52,
      "additions": 51,
      "deletions": 1
    },
    "files": [
      {
        "sha": "077a51bac37423eb07abfb9be344cc54c09a53d1",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 1,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2d4327db1973a354e9e4153de6958d49120fcde8/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2d4327db1973a354e9e4153de6958d49120fcde8/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=2d4327db1973a354e9e4153de6958d49120fcde8",
        "patch": "@@ -1693,6 +1693,36 @@ void CConnman::ProcessOneShot()\n     }\n }\n \n+bool CConnman::GetTryNewOutboundPeer()\n+{\n+    return m_try_another_outbound_peer;\n+}\n+\n+void CConnman::SetTryNewOutboundPeer(bool flag)\n+{\n+    m_try_another_outbound_peer = flag;\n+}\n+\n+// Return the number of peers we have over our outbound connection limit\n+// Exclude peers that are marked for disconnect, or are going to be\n+// disconnected soon (eg one-shots and feelers)\n+// Also exclude peers that haven't finished initial connection handshake yet\n+// (so that we don't decide we're over our desired connection limit, and then\n+// evict some peer that has finished the handshake)\n+int CConnman::GetExtraOutboundCount()\n+{\n+    int nOutbound = 0;\n+    {\n+        LOCK(cs_vNodes);\n+        for (CNode* pnode : vNodes) {\n+            if (!pnode->fInbound && !pnode->m_manual_connection && !pnode->fFeeler && !pnode->fDisconnect && !pnode->fOneShot && pnode->fSuccessfullyConnected) {\n+                ++nOutbound;\n+            }\n+        }\n+    }\n+    return std::max(nOutbound - nMaxOutbound, 0);\n+}\n+\n void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n {\n     // Connect to specific addresses\n@@ -1781,7 +1811,8 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n         //  * Only make a feeler connection once every few minutes.\n         //\n         bool fFeeler = false;\n-        if (nOutbound >= nMaxOutbound) {\n+\n+        if (nOutbound >= nMaxOutbound && !GetTryNewOutboundPeer()) {\n             int64_t nTime = GetTimeMicros(); // The current time right now (in microseconds).\n             if (nTime > nNextFeeler) {\n                 nNextFeeler = PoissonNextSend(nTime, FEELER_INTERVAL);\n@@ -2204,6 +2235,7 @@ CConnman::CConnman(uint64_t nSeed0In, uint64_t nSeed1In) : nSeed0(nSeed0In), nSe\n     semOutbound = nullptr;\n     semAddnode = nullptr;\n     flagInterruptMsgProc = false;\n+    SetTryNewOutboundPeer(false);\n \n     Options connOptions;\n     Init(connOptions);"
      },
      {
        "sha": "c90df649922986440d1165e70e7b21f0e602e4a8",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2d4327db1973a354e9e4153de6958d49120fcde8/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2d4327db1973a354e9e4153de6958d49120fcde8/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=2d4327db1973a354e9e4153de6958d49120fcde8",
        "patch": "@@ -251,6 +251,19 @@ class CConnman\n     void GetBanned(banmap_t &banmap);\n     void SetBanned(const banmap_t &banmap);\n \n+    // This allows temporarily exceeding nMaxOutbound, with the goal of finding\n+    // a peer that is better than all our current peers.\n+    void SetTryNewOutboundPeer(bool flag);\n+    bool GetTryNewOutboundPeer();\n+\n+    // Return the number of outbound peers we have in excess of our target (eg,\n+    // if we previously called SetTryNewOutboundPeer(true), and have since set\n+    // to false, we may have extra peers that we wish to disconnect). This may\n+    // return a value less than (num_outbound_connections - num_outbound_slots)\n+    // in cases where some outbound connections are not yet fully connected, or\n+    // not yet fully disconnected.\n+    int GetExtraOutboundCount();\n+\n     bool AddNode(const std::string& node);\n     bool RemoveAddedNode(const std::string& node);\n     std::vector<AddedNodeInfo> GetAddedNodeInfo();\n@@ -413,6 +426,11 @@ class CConnman\n     std::thread threadOpenAddedConnections;\n     std::thread threadOpenConnections;\n     std::thread threadMessageHandler;\n+\n+    /** flag for deciding to connect to an extra outbound peer,\n+     *  in excess of nMaxOutbound\n+     *  This takes the place of a feeler connection */\n+    std::atomic_bool m_try_another_outbound_peer;\n };\n extern std::unique_ptr<CConnman> g_connman;\n void Discover(boost::thread_group& threadGroup);"
      }
    ]
  },
  {
    "sha": "db32a6589720e5b15931cef82e477118dfd92669",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkYjMyYTY1ODk3MjBlNWIxNTkzMWNlZjgyZTQ3NzExOGRmZDkyNjY5",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-10-23T17:59:07Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-11-01T17:13:45Z"
      },
      "message": "Track tip update time and last new block announcement from each peer",
      "tree": {
        "sha": "613e1d9e19c8eef9915c80443efda7cad64afa20",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/613e1d9e19c8eef9915c80443efda7cad64afa20"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/db32a6589720e5b15931cef82e477118dfd92669",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/db32a6589720e5b15931cef82e477118dfd92669",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/db32a6589720e5b15931cef82e477118dfd92669",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/db32a6589720e5b15931cef82e477118dfd92669/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2d4327db1973a354e9e4153de6958d49120fcde8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2d4327db1973a354e9e4153de6958d49120fcde8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2d4327db1973a354e9e4153de6958d49120fcde8"
      }
    ],
    "stats": {
      "total": 37,
      "additions": 35,
      "deletions": 2
    },
    "files": [
      {
        "sha": "59df5d6502b5ad9e824cb0396ca292c268ef393b",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 2,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/db32a6589720e5b15931cef82e477118dfd92669/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/db32a6589720e5b15931cef82e477118dfd92669/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=db32a6589720e5b15931cef82e477118dfd92669",
        "patch": "@@ -127,6 +127,10 @@ namespace {\n     /** Number of outbound peers with m_chain_sync.m_protect. */\n     int g_outbound_peers_with_protect_from_disconnect = 0;\n \n+\n+    /** When our tip was last updated. */\n+    int64_t g_last_tip_update = 0;\n+\n     /** Relay map, protected by cs_main. */\n     typedef std::map<uint256, CTransactionRef> MapRelay;\n     MapRelay mapRelay;\n@@ -231,6 +235,9 @@ struct CNodeState {\n \n     ChainSyncTimeoutState m_chain_sync;\n \n+    //! Time of last new block announcement\n+    int64_t m_last_block_announcement;\n+\n     CNodeState(CAddress addrIn, std::string addrNameIn) : address(addrIn), name(addrNameIn) {\n         fCurrentlyConnected = false;\n         nMisbehavior = 0;\n@@ -254,6 +261,7 @@ struct CNodeState {\n         fWantsCmpctWitness = false;\n         fSupportsDesiredCmpctVersion = false;\n         m_chain_sync = { 0, nullptr, false, false };\n+        m_last_block_announcement = 0;\n     }\n };\n \n@@ -797,6 +805,8 @@ void PeerLogicValidation::BlockConnected(const std::shared_ptr<const CBlock>& pb\n         }\n         LogPrint(BCLog::MEMPOOL, \"Erased %d orphan tx included or conflicted by block\\n\", nErased);\n     }\n+\n+    g_last_tip_update = GetTime();\n }\n \n // All of the following cache a recent block, and are protected by cs_most_recent_block\n@@ -1215,6 +1225,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n         return true;\n     }\n \n+    bool received_new_header = false;\n     const CBlockIndex *pindexLast = nullptr;\n     {\n         LOCK(cs_main);\n@@ -1255,6 +1266,12 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n             }\n             hashLastBlock = header.GetHash();\n         }\n+\n+        // If we don't have the last header, then they'll have given us\n+        // something new (if these headers are valid).\n+        if (mapBlockIndex.find(hashLastBlock) == mapBlockIndex.end()) {\n+            received_new_header = true;\n+        }\n     }\n \n     CValidationState state;\n@@ -1319,6 +1336,10 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n         // because it is set in UpdateBlockAvailability. Some nullptr checks\n         // are still present, however, as belt-and-suspenders.\n \n+        if (received_new_header && pindexLast->nChainWork > chainActive.Tip()->nChainWork) {\n+            nodestate->m_last_block_announcement = GetTime();\n+        }\n+\n         if (nCount == MAX_HEADERS_RESULTS) {\n             // Headers message had its maximum size; the peer may have more headers.\n             // TODO: optimize: if pindexLast is an ancestor of chainActive.Tip or pindexBestHeader, continue\n@@ -2219,6 +2240,8 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         CBlockHeaderAndShortTxIDs cmpctblock;\n         vRecv >> cmpctblock;\n \n+        bool received_new_header = false;\n+\n         {\n         LOCK(cs_main);\n \n@@ -2228,6 +2251,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));\n             return true;\n         }\n+\n+        if (mapBlockIndex.find(cmpctblock.header.GetHash()) == mapBlockIndex.end()) {\n+            received_new_header = true;\n+        }\n         }\n \n         const CBlockIndex *pindex = nullptr;\n@@ -2266,6 +2293,14 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         assert(pindex);\n         UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());\n \n+        CNodeState *nodestate = State(pfrom->GetId());\n+\n+        // If this was a new header with more work than our tip, update the\n+        // peer's last block announcement time\n+        if (received_new_header && pindex->nChainWork > chainActive.Tip()->nChainWork) {\n+            nodestate->m_last_block_announcement = GetTime();\n+        }\n+\n         std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n         bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();\n \n@@ -2288,8 +2323,6 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (!fAlreadyInFlight && !CanDirectFetch(chainparams.GetConsensus()))\n             return true;\n \n-        CNodeState *nodestate = State(pfrom->GetId());\n-\n         if (IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) && !nodestate->fSupportsDesiredCmpctVersion) {\n             // Don't bother trying to process compact blocks from v1 peers\n             // after segwit activates."
      }
    ]
  },
  {
    "sha": "ac7b37cd2bd612a64a4009ba82f1cd1d57f37434",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphYzdiMzdjZDJiZDYxMmE2NGE0MDA5YmE4MmYxY2QxZDU3ZjM3NDM0",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-10-24T20:56:07Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-11-02T16:39:14Z"
      },
      "message": "Connect to an extra outbound peer if our tip is stale\n\nIf our tip hasn't updated in a while, that may be because our peers are\nnot relaying blocks to us that we would consider valid. Allow connection\nto an additional outbound peer in that circumstance.\n\nAlso, periodically check to see if we are exceeding our target number of\noutbound peers, and disconnect the one which has least recently\nannounced a new block to us (choosing the newest such peer in the case\nof tie).",
      "tree": {
        "sha": "cd7e7a674a9de4e5d93fea61c869fb7a03180725",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cd7e7a674a9de4e5d93fea61c869fb7a03180725"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ac7b37cd2bd612a64a4009ba82f1cd1d57f37434",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ac7b37cd2bd612a64a4009ba82f1cd1d57f37434",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ac7b37cd2bd612a64a4009ba82f1cd1d57f37434",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ac7b37cd2bd612a64a4009ba82f1cd1d57f37434/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "db32a6589720e5b15931cef82e477118dfd92669",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/db32a6589720e5b15931cef82e477118dfd92669",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/db32a6589720e5b15931cef82e477118dfd92669"
      }
    ],
    "stats": {
      "total": 120,
      "additions": 114,
      "deletions": 6
    },
    "files": [
      {
        "sha": "e57ea0f4367ef242d5a07eb4fd79ac5593b00339",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac7b37cd2bd612a64a4009ba82f1cd1d57f37434/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac7b37cd2bd612a64a4009ba82f1cd1d57f37434/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=ac7b37cd2bd612a64a4009ba82f1cd1d57f37434",
        "patch": "@@ -1270,7 +1270,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     g_connman = std::unique_ptr<CConnman>(new CConnman(GetRand(std::numeric_limits<uint64_t>::max()), GetRand(std::numeric_limits<uint64_t>::max())));\n     CConnman& connman = *g_connman;\n \n-    peerLogic.reset(new PeerLogicValidation(&connman));\n+    peerLogic.reset(new PeerLogicValidation(&connman, scheduler));\n     RegisterValidationInterface(peerLogic.get());\n \n     // sanitize comments per BIP-0014, format user agent and check total size"
      },
      {
        "sha": "5eaeaab8f643300829a6a3d3f493761cf00394a7",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac7b37cd2bd612a64a4009ba82f1cd1d57f37434/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac7b37cd2bd612a64a4009ba82f1cd1d57f37434/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=ac7b37cd2bd612a64a4009ba82f1cd1d57f37434",
        "patch": "@@ -1701,6 +1701,7 @@ bool CConnman::GetTryNewOutboundPeer()\n void CConnman::SetTryNewOutboundPeer(bool flag)\n {\n     m_try_another_outbound_peer = flag;\n+    LogPrint(BCLog::NET, \"net: setting try another outbound peer=%s\\n\", flag ? \"true\" : \"false\");\n }\n \n // Return the number of peers we have over our outbound connection limit"
      },
      {
        "sha": "3aa13fff435f306c8d6270f3f4a266c8603e3b8d",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 97,
        "deletions": 2,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac7b37cd2bd612a64a4009ba82f1cd1d57f37434/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac7b37cd2bd612a64a4009ba82f1cd1d57f37434/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=ac7b37cd2bd612a64a4009ba82f1cd1d57f37434",
        "patch": "@@ -23,6 +23,7 @@\n #include \"primitives/transaction.h\"\n #include \"random.h\"\n #include \"reverse_iterator.h\"\n+#include \"scheduler.h\"\n #include \"tinyformat.h\"\n #include \"txmempool.h\"\n #include \"ui_interface.h\"\n@@ -127,7 +128,6 @@ namespace {\n     /** Number of outbound peers with m_chain_sync.m_protect. */\n     int g_outbound_peers_with_protect_from_disconnect = 0;\n \n-\n     /** When our tip was last updated. */\n     int64_t g_last_tip_update = 0;\n \n@@ -435,6 +435,15 @@ void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman* connman) {\n     }\n }\n \n+bool TipMayBeStale(const Consensus::Params &consensusParams)\n+{\n+    AssertLockHeld(cs_main);\n+    if (g_last_tip_update == 0) {\n+        g_last_tip_update = GetTime();\n+    }\n+    return g_last_tip_update < GetTime() - consensusParams.nPowTargetSpacing * 3 && mapBlocksInFlight.empty();\n+}\n+\n // Requires cs_main\n bool CanDirectFetch(const Consensus::Params &consensusParams)\n {\n@@ -772,9 +781,17 @@ static bool StaleBlockRequestAllowed(const CBlockIndex* pindex, const Consensus:\n         (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, consensusParams) < STALE_RELAY_AGE_LIMIT);\n }\n \n-PeerLogicValidation::PeerLogicValidation(CConnman* connmanIn) : connman(connmanIn) {\n+PeerLogicValidation::PeerLogicValidation(CConnman* connmanIn, CScheduler &scheduler) : connman(connmanIn), m_stale_tip_check_time(0) {\n     // Initialize global variables that cannot be constructed at startup.\n     recentRejects.reset(new CRollingBloomFilter(120000, 0.000001));\n+\n+    const Consensus::Params& consensusParams = Params().GetConsensus();\n+    // Stale tip checking and peer eviction are on two different timers, but we\n+    // don't want them to get out of sync due to drift in the scheduler, so we\n+    // combine them in one function and schedule at the quicker (peer-eviction)\n+    // timer.\n+    static_assert(EXTRA_PEER_CHECK_INTERVAL < STALE_CHECK_INTERVAL, \"peer eviction timer should be less than stale tip check timer\");\n+    scheduler.scheduleEvery(std::bind(&PeerLogicValidation::CheckForStaleTipAndEvictPeers, this, consensusParams), EXTRA_PEER_CHECK_INTERVAL * 1000);\n }\n \n void PeerLogicValidation::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindex, const std::vector<CTransactionRef>& vtxConflicted) {\n@@ -1424,6 +1441,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n             // If this is an outbound peer, check to see if we should protect\n             // it from the bad/lagging chain logic.\n             if (g_outbound_peers_with_protect_from_disconnect < MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT && nodestate->pindexBestKnownBlock->nChainWork >= chainActive.Tip()->nChainWork && !nodestate->m_chain_sync.m_protect) {\n+                LogPrint(BCLog::NET, \"Protecting outbound peer=%d from eviction\\n\", pfrom->GetId());\n                 nodestate->m_chain_sync.m_protect = true;\n                 ++g_outbound_peers_with_protect_from_disconnect;\n             }\n@@ -3004,6 +3022,83 @@ void PeerLogicValidation::ConsiderEviction(CNode *pto, int64_t time_in_seconds)\n     }\n }\n \n+void PeerLogicValidation::EvictExtraOutboundPeers(int64_t time_in_seconds)\n+{\n+    // Check whether we have too many outbound peers\n+    int extra_peers = connman->GetExtraOutboundCount();\n+    if (extra_peers > 0) {\n+        // If we have more outbound peers than we target, disconnect one.\n+        // Pick the outbound peer that least recently announced\n+        // us a new block, with ties broken by choosing the more recent\n+        // connection (higher node id)\n+        NodeId worst_peer = -1;\n+        int64_t oldest_block_announcement = std::numeric_limits<int64_t>::max();\n+\n+        LOCK(cs_main);\n+\n+        connman->ForEachNode([&](CNode* pnode) {\n+            // Ignore non-outbound peers, or nodes marked for disconnect already\n+            if (!IsOutboundDisconnectionCandidate(pnode) || pnode->fDisconnect) return;\n+            CNodeState *state = State(pnode->GetId());\n+            if (state == nullptr) return; // shouldn't be possible, but just in case\n+            // Don't evict our protected peers\n+            if (state->m_chain_sync.m_protect) return;\n+            if (state->m_last_block_announcement < oldest_block_announcement || (state->m_last_block_announcement == oldest_block_announcement && pnode->GetId() > worst_peer)) {\n+                worst_peer = pnode->GetId();\n+                oldest_block_announcement = state->m_last_block_announcement;\n+            }\n+        });\n+        if (worst_peer != -1) {\n+            bool disconnected = connman->ForNode(worst_peer, [&](CNode *pnode) {\n+                // Only disconnect a peer that has been connected to us for\n+                // some reasonable fraction of our check-frequency, to give\n+                // it time for new information to have arrived.\n+                // Also don't disconnect any peer we're trying to download a\n+                // block from.\n+                CNodeState &state = *State(pnode->GetId());\n+                if (time_in_seconds - pnode->nTimeConnected > MINIMUM_CONNECT_TIME && state.nBlocksInFlight == 0) {\n+                    LogPrint(BCLog::NET, \"disconnecting extra outbound peer=%d (last block announcement received at time %d)\\n\", pnode->GetId(), oldest_block_announcement);\n+                    pnode->fDisconnect = true;\n+                    return true;\n+                } else {\n+                    LogPrint(BCLog::NET, \"keeping outbound peer=%d chosen for eviction (connect time: %d, blocks_in_flight: %d)\\n\", pnode->GetId(), pnode->nTimeConnected, state.nBlocksInFlight);\n+                    return false;\n+                }\n+            });\n+            if (disconnected) {\n+                // If we disconnected an extra peer, that means we successfully\n+                // connected to at least one peer after the last time we\n+                // detected a stale tip. Don't try any more extra peers until\n+                // we next detect a stale tip, to limit the load we put on the\n+                // network from these extra connections.\n+                connman->SetTryNewOutboundPeer(false);\n+            }\n+        }\n+    }\n+}\n+\n+void PeerLogicValidation::CheckForStaleTipAndEvictPeers(const Consensus::Params &consensusParams)\n+{\n+    if (connman == nullptr) return;\n+\n+    int64_t time_in_seconds = GetTime();\n+\n+    EvictExtraOutboundPeers(time_in_seconds);\n+\n+    if (time_in_seconds > m_stale_tip_check_time) {\n+        LOCK(cs_main);\n+        // Check whether our tip is stale, and if so, allow using an extra\n+        // outbound peer\n+        if (TipMayBeStale(consensusParams)) {\n+            LogPrintf(\"Potential stale tip detected, will try using extra outbound peer (last tip update: %d seconds ago)\\n\", time_in_seconds - g_last_tip_update);\n+            connman->SetTryNewOutboundPeer(true);\n+        } else if (connman->GetTryNewOutboundPeer()) {\n+            connman->SetTryNewOutboundPeer(false);\n+        }\n+        m_stale_tip_check_time = time_in_seconds + STALE_CHECK_INTERVAL;\n+    }\n+}\n+\n class CompareInvMempoolOrder\n {\n     CTxMemPool *mp;"
      },
      {
        "sha": "0a49972eed148f2447e50a2301e905f3b3be4ff7",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 14,
        "deletions": 2,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac7b37cd2bd612a64a4009ba82f1cd1d57f37434/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac7b37cd2bd612a64a4009ba82f1cd1d57f37434/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=ac7b37cd2bd612a64a4009ba82f1cd1d57f37434",
        "patch": "@@ -8,6 +8,7 @@\n \n #include \"net.h\"\n #include \"validationinterface.h\"\n+#include \"consensus/params.h\"\n \n /** Default for -maxorphantx, maximum number of orphan transactions kept in memory */\n static const unsigned int DEFAULT_MAX_ORPHAN_TRANSACTIONS = 100;\n@@ -27,13 +28,19 @@ static constexpr int64_t HEADERS_DOWNLOAD_TIMEOUT_PER_HEADER = 1000; // 1ms/head\n static constexpr int32_t MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT = 4;\n /** Timeout for (unprotected) outbound peers to sync to our chainwork, in seconds */\n static constexpr int64_t CHAIN_SYNC_TIMEOUT = 20 * 60; // 20 minutes\n+/** How frequently to check for stale tips, in seconds */\n+static constexpr int64_t STALE_CHECK_INTERVAL = 10 * 60; // 10 minutes\n+/** How frequently to check for extra outbound peers and disconnect, in seconds */\n+static constexpr int64_t EXTRA_PEER_CHECK_INTERVAL = 45;\n+/** Minimum time an outbound-peer-eviction candidate must be connected for, in order to evict, in seconds */\n+static constexpr int64_t MINIMUM_CONNECT_TIME = 30;\n \n class PeerLogicValidation : public CValidationInterface, public NetEventsInterface {\n private:\n-    CConnman* connman;\n+    CConnman* const connman;\n \n public:\n-    explicit PeerLogicValidation(CConnman* connman);\n+    explicit PeerLogicValidation(CConnman* connman, CScheduler &scheduler);\n \n     void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected, const std::vector<CTransactionRef>& vtxConflicted) override;\n     void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) override;\n@@ -55,6 +62,11 @@ class PeerLogicValidation : public CValidationInterface, public NetEventsInterfa\n     bool SendMessages(CNode* pto, std::atomic<bool>& interrupt) override;\n \n     void ConsiderEviction(CNode *pto, int64_t time_in_seconds);\n+    void CheckForStaleTipAndEvictPeers(const Consensus::Params &consensusParams);\n+    void EvictExtraOutboundPeers(int64_t time_in_seconds);\n+\n+private:\n+    int64_t m_stale_tip_check_time; //! Next time to check for stale tip\n };\n \n struct CNodeStateStats {"
      },
      {
        "sha": "c768446d30532d259ca20f5beb4fc6016e131fdf",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac7b37cd2bd612a64a4009ba82f1cd1d57f37434/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac7b37cd2bd612a64a4009ba82f1cd1d57f37434/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=ac7b37cd2bd612a64a4009ba82f1cd1d57f37434",
        "patch": "@@ -86,7 +86,7 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n             threadGroup.create_thread(&ThreadScriptCheck);\n         g_connman = std::unique_ptr<CConnman>(new CConnman(0x1337, 0x1337)); // Deterministic randomness for tests.\n         connman = g_connman.get();\n-        peerLogic.reset(new PeerLogicValidation(connman));\n+        peerLogic.reset(new PeerLogicValidation(connman, scheduler));\n }\n \n TestingSetup::~TestingSetup()"
      }
    ]
  },
  {
    "sha": "83df25736ebaa23777e965d265ed677a8d79f23f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4M2RmMjU3MzZlYmFhMjM3NzdlOTY1ZDI2NWVkNjc3YThkNzlmMjNm",
    "commit": {
      "author": {
        "name": "Jo\u00e3o Barbosa",
        "email": "joao.paulo.barbosa@gmail.com",
        "date": "2017-10-24T08:26:05Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-11-02T16:39:14Z"
      },
      "message": "Add CConnmanTest to mutate g_connman in tests",
      "tree": {
        "sha": "781000ee1e9b246db0ff115229e53171b69b7c96",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/781000ee1e9b246db0ff115229e53171b69b7c96"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/83df25736ebaa23777e965d265ed677a8d79f23f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/83df25736ebaa23777e965d265ed677a8d79f23f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/83df25736ebaa23777e965d265ed677a8d79f23f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/83df25736ebaa23777e965d265ed677a8d79f23f/comments",
    "author": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ac7b37cd2bd612a64a4009ba82f1cd1d57f37434",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ac7b37cd2bd612a64a4009ba82f1cd1d57f37434",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ac7b37cd2bd612a64a4009ba82f1cd1d57f37434"
      }
    ],
    "stats": {
      "total": 20,
      "additions": 20,
      "deletions": 0
    },
    "files": [
      {
        "sha": "edca1171ab741e7f4a7ecb6c934eb973516bc496",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/83df25736ebaa23777e965d265ed677a8d79f23f/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/83df25736ebaa23777e965d265ed677a8d79f23f/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=83df25736ebaa23777e965d265ed677a8d79f23f",
        "patch": "@@ -431,6 +431,8 @@ class CConnman\n      *  in excess of nMaxOutbound\n      *  This takes the place of a feeler connection */\n     std::atomic_bool m_try_another_outbound_peer;\n+\n+    friend struct CConnmanTest;\n };\n extern std::unique_ptr<CConnman> g_connman;\n void Discover(boost::thread_group& threadGroup);"
      },
      {
        "sha": "85476b6da254bf4029a26ad837d924804b19ace0",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/83df25736ebaa23777e965d265ed677a8d79f23f/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/83df25736ebaa23777e965d265ed677a8d79f23f/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=83df25736ebaa23777e965d265ed677a8d79f23f",
        "patch": "@@ -25,6 +25,18 @@\n \n #include <memory>\n \n+void CConnmanTest::AddNode(CNode& node)\n+{\n+    LOCK(g_connman->cs_vNodes);\n+    g_connman->vNodes.push_back(&node);\n+}\n+\n+void CConnmanTest::ClearNodes()\n+{\n+    LOCK(g_connman->cs_vNodes);\n+    g_connman->vNodes.clear();\n+}\n+\n uint256 insecure_rand_seed = GetRandHash();\n FastRandomContext insecure_rand_ctx(insecure_rand_seed);\n "
      },
      {
        "sha": "62ded2aaf5ac3ce09571edfbd163958f89edc79b",
        "filename": "src/test/test_bitcoin.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/83df25736ebaa23777e965d265ed677a8d79f23f/src/test/test_bitcoin.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/83df25736ebaa23777e965d265ed677a8d79f23f/src/test/test_bitcoin.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.h?ref=83df25736ebaa23777e965d265ed677a8d79f23f",
        "patch": "@@ -49,6 +49,12 @@ struct BasicTestingSetup {\n  * Included are data directory, coins database, script check threads setup.\n  */\n class CConnman;\n+class CNode;\n+struct CConnmanTest {\n+    static void AddNode(CNode& node);\n+    static void ClearNodes();\n+};\n+\n class PeerLogicValidation;\n struct TestingSetup: public BasicTestingSetup {\n     CCoinsViewDB *pcoinsdbview;"
      }
    ]
  },
  {
    "sha": "626291508c433488439b662f2e88882048fb59fb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MjYyOTE1MDhjNDMzNDg4NDM5YjY2MmYyZTg4ODgyMDQ4ZmI1OWZi",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-10-26T14:32:46Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-11-02T16:39:14Z"
      },
      "message": "Add unit test for stale tip checking",
      "tree": {
        "sha": "f09d67b67497f85d76def9de2783048ec23aa109",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f09d67b67497f85d76def9de2783048ec23aa109"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/626291508c433488439b662f2e88882048fb59fb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/626291508c433488439b662f2e88882048fb59fb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/626291508c433488439b662f2e88882048fb59fb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/626291508c433488439b662f2e88882048fb59fb/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "83df25736ebaa23777e965d265ed677a8d79f23f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/83df25736ebaa23777e965d265ed677a8d79f23f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/83df25736ebaa23777e965d265ed677a8d79f23f"
      }
    ],
    "stats": {
      "total": 94,
      "additions": 94,
      "deletions": 0
    },
    "files": [
      {
        "sha": "faa0c7620b49b1c970597c1269384da6d99e2731",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/626291508c433488439b662f2e88882048fb59fb/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/626291508c433488439b662f2e88882048fb59fb/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=626291508c433488439b662f2e88882048fb59fb",
        "patch": "@@ -550,6 +550,15 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n \n } // namespace\n \n+// This function is used for testing the stale tip eviction logic, see\n+// DoS_tests.cpp\n+void UpdateLastBlockAnnounceTime(NodeId node, int64_t time_in_seconds)\n+{\n+    LOCK(cs_main);\n+    CNodeState *state = State(node);\n+    if (state) state->m_last_block_announcement = time_in_seconds;\n+}\n+\n // Returns true for outbound peers, excluding manual connections, feelers, and\n // one-shots\n bool IsOutboundDisconnectionCandidate(const CNode *node)"
      },
      {
        "sha": "d1f9e63ecf5537b4aced43eac01eb610ae458d5e",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 85,
        "deletions": 0,
        "changes": 85,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/626291508c433488439b662f2e88882048fb59fb/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/626291508c433488439b662f2e88882048fb59fb/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=626291508c433488439b662f2e88882048fb59fb",
        "patch": "@@ -40,6 +40,8 @@ CService ip(uint32_t i)\n \n static NodeId id = 0;\n \n+void UpdateLastBlockAnnounceTime(NodeId node, int64_t time_in_seconds);\n+\n BOOST_FIXTURE_TEST_SUITE(DoS_tests, TestingSetup)\n \n // Test eviction of an outbound peer whose chain never advances\n@@ -87,6 +89,89 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n     peerLogic->FinalizeNode(dummyNode1.GetId(), dummy);\n }\n \n+void AddRandomOutboundPeer(std::vector<CNode *> &vNodes, PeerLogicValidation &peerLogic)\n+{\n+    CAddress addr(ip(GetRandInt(0xffffffff)), NODE_NONE);\n+    vNodes.emplace_back(new CNode(id++, ServiceFlags(NODE_NETWORK|NODE_WITNESS), 0, INVALID_SOCKET, addr, 0, 0, CAddress(), \"\", /*fInboundIn=*/ false));\n+    CNode &node = *vNodes.back();\n+    node.SetSendVersion(PROTOCOL_VERSION);\n+\n+    peerLogic.InitializeNode(&node);\n+    node.nVersion = 1;\n+    node.fSuccessfullyConnected = true;\n+\n+    CConnmanTest::AddNode(node);\n+}\n+\n+BOOST_AUTO_TEST_CASE(stale_tip_peer_management)\n+{\n+    const Consensus::Params& consensusParams = Params().GetConsensus();\n+    constexpr int nMaxOutbound = 8;\n+    CConnman::Options options;\n+    options.nMaxConnections = 125;\n+    options.nMaxOutbound = nMaxOutbound;\n+    options.nMaxFeeler = 1;\n+\n+    connman->Init(options);\n+    std::vector<CNode *> vNodes;\n+\n+    // Mock some outbound peers\n+    for (int i=0; i<nMaxOutbound; ++i) {\n+        AddRandomOutboundPeer(vNodes, *peerLogic);\n+    }\n+\n+    peerLogic->CheckForStaleTipAndEvictPeers(consensusParams);\n+\n+    // No nodes should be marked for disconnection while we have no extra peers\n+    for (const CNode *node : vNodes) {\n+        BOOST_CHECK(node->fDisconnect == false);\n+    }\n+\n+    SetMockTime(GetTime() + 3*consensusParams.nPowTargetSpacing + 1);\n+\n+    // Now tip should definitely be stale, and we should look for an extra\n+    // outbound peer\n+    peerLogic->CheckForStaleTipAndEvictPeers(consensusParams);\n+    BOOST_CHECK(connman->GetTryNewOutboundPeer());\n+\n+    // Still no peers should be marked for disconnection\n+    for (const CNode *node : vNodes) {\n+        BOOST_CHECK(node->fDisconnect == false);\n+    }\n+\n+    // If we add one more peer, something should get marked for eviction\n+    // on the next check (since we're mocking the time to be in the future, the\n+    // required time connected check should be satisfied).\n+    AddRandomOutboundPeer(vNodes, *peerLogic);\n+\n+    peerLogic->CheckForStaleTipAndEvictPeers(consensusParams);\n+    for (int i=0; i<nMaxOutbound; ++i) {\n+        BOOST_CHECK(vNodes[i]->fDisconnect == false);\n+    }\n+    // Last added node should get marked for eviction\n+    BOOST_CHECK(vNodes.back()->fDisconnect == true);\n+\n+    vNodes.back()->fDisconnect = false;\n+\n+    // Update the last announced block time for the last\n+    // peer, and check that the next newest node gets evicted.\n+    UpdateLastBlockAnnounceTime(vNodes.back()->GetId(), GetTime());\n+\n+    peerLogic->CheckForStaleTipAndEvictPeers(consensusParams);\n+    for (int i=0; i<nMaxOutbound-1; ++i) {\n+        BOOST_CHECK(vNodes[i]->fDisconnect == false);\n+    }\n+    BOOST_CHECK(vNodes[nMaxOutbound-1]->fDisconnect == true);\n+    BOOST_CHECK(vNodes.back()->fDisconnect == false);\n+\n+    bool dummy;\n+    for (const CNode *node : vNodes) {\n+        peerLogic->FinalizeNode(node->GetId(), dummy);\n+    }\n+\n+    CConnmanTest::ClearNodes();\n+}\n+\n BOOST_AUTO_TEST_CASE(DoS_banning)\n {\n     std::atomic<bool> interruptDummy(false);"
      }
    ]
  }
]