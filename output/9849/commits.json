[
  {
    "sha": "9800d9d761352b2cb8391efa020cfd6e76de68f5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ODAwZDlkNzYxMzUyYjJjYjgzOTFlZmEwMjBjZmQ2ZTc2ZGU2OGY1",
    "commit": {
      "author": {
        "name": "Luke Dashjr",
        "email": "luke-jr+git@utopios.org",
        "date": "2017-08-24T21:50:31Z"
      },
      "committer": {
        "name": "Luke Dashjr",
        "email": "luke-jr+git@utopios.org",
        "date": "2019-02-12T16:09:06Z"
      },
      "message": "CValidationInterface: ValidationInterfaceUnregistering, called when being unregistered",
      "tree": {
        "sha": "7641c211d357b796eaac0beda466ecfb90822607",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7641c211d357b796eaac0beda466ecfb90822607"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9800d9d761352b2cb8391efa020cfd6e76de68f5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9800d9d761352b2cb8391efa020cfd6e76de68f5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9800d9d761352b2cb8391efa020cfd6e76de68f5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9800d9d761352b2cb8391efa020cfd6e76de68f5/comments",
    "author": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "65435701efdafc6b91db542327c57c69386f02eb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/65435701efdafc6b91db542327c57c69386f02eb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/65435701efdafc6b91db542327c57c69386f02eb"
      }
    ],
    "stats": {
      "total": 13,
      "additions": 13,
      "deletions": 0
    },
    "files": [
      {
        "sha": "8d5ec501016293412df2eccb6ed6450ec13815b1",
        "filename": "src/validationinterface.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9800d9d761352b2cb8391efa020cfd6e76de68f5/src/validationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9800d9d761352b2cb8391efa020cfd6e76de68f5/src/validationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.cpp?ref=9800d9d761352b2cb8391efa020cfd6e76de68f5",
        "patch": "@@ -28,6 +28,7 @@ struct ValidationInterfaceConnections {\n     boost::signals2::scoped_connection Broadcast;\n     boost::signals2::scoped_connection BlockChecked;\n     boost::signals2::scoped_connection NewPoWValidBlock;\n+    boost::signals2::scoped_connection ValidationInterfaceUnregistering;\n };\n \n struct MainSignalsInstance {\n@@ -40,6 +41,7 @@ struct MainSignalsInstance {\n     boost::signals2::signal<void (int64_t nBestBlockTime, CConnman* connman)> Broadcast;\n     boost::signals2::signal<void (const CBlock&, const CValidationState&)> BlockChecked;\n     boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n+    boost::signals2::signal<void ()> ValidationInterfaceUnregistering;\n \n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n@@ -104,9 +106,12 @@ void RegisterValidationInterface(CValidationInterface* pwalletIn) {\n     conns.Broadcast = g_signals.m_internals->Broadcast.connect(std::bind(&CValidationInterface::ResendWalletTransactions, pwalletIn, std::placeholders::_1, std::placeholders::_2));\n     conns.BlockChecked = g_signals.m_internals->BlockChecked.connect(std::bind(&CValidationInterface::BlockChecked, pwalletIn, std::placeholders::_1, std::placeholders::_2));\n     conns.NewPoWValidBlock = g_signals.m_internals->NewPoWValidBlock.connect(std::bind(&CValidationInterface::NewPoWValidBlock, pwalletIn, std::placeholders::_1, std::placeholders::_2));\n+    conns.ValidationInterfaceUnregistering = g_signals.m_internals->ValidationInterfaceUnregistering.connect(std::bind(&CValidationInterface::ValidationInterfaceUnregistering, pwalletIn));\n }\n \n void UnregisterValidationInterface(CValidationInterface* pwalletIn) {\n+    pwalletIn->ValidationInterfaceUnregistering();\n+\n     if (g_signals.m_internals) {\n         g_signals.m_internals->m_connMainSignals.erase(pwalletIn);\n     }\n@@ -116,6 +121,9 @@ void UnregisterAllValidationInterfaces() {\n     if (!g_signals.m_internals) {\n         return;\n     }\n+\n+    g_signals.m_internals->ValidationInterfaceUnregistering();\n+\n     g_signals.m_internals->m_connMainSignals.clear();\n }\n "
      },
      {
        "sha": "28c95b072f21f63a8a838762f1531b8724214e3c",
        "filename": "src/validationinterface.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9800d9d761352b2cb8391efa020cfd6e76de68f5/src/validationinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9800d9d761352b2cb8391efa020cfd6e76de68f5/src/validationinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.h?ref=9800d9d761352b2cb8391efa020cfd6e76de68f5",
        "patch": "@@ -147,6 +147,11 @@ class CValidationInterface {\n      * Notifies listeners that a block which builds directly on our current tip\n      * has been received and connected to the headers tree, though not validated yet */\n     virtual void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& block) {};\n+    /**\n+     * Notifies the validation interface that it is being unregistered\n+     */\n+    virtual void ValidationInterfaceUnregistering() {};\n+\n     friend void ::RegisterValidationInterface(CValidationInterface*);\n     friend void ::UnregisterValidationInterface(CValidationInterface*);\n     friend void ::UnregisterAllValidationInterfaces();"
      }
    ]
  },
  {
    "sha": "ba6074b561fce84191bce5f3749f66436473599b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiYTYwNzRiNTYxZmNlODQxOTFiY2U1ZjM3NDlmNjY0MzY0NzM1OTli",
    "commit": {
      "author": {
        "name": "Luke Dashjr",
        "email": "luke-jr+git@utopios.org",
        "date": "2017-02-24T03:54:50Z"
      },
      "committer": {
        "name": "Luke Dashjr",
        "email": "luke-jr+git@utopios.org",
        "date": "2019-02-12T16:46:31Z"
      },
      "message": "Qt: Network Watch tool\n\nSimple realtime log of p2p network activity (blocks and transactions only)\n\n- Doesn't begin logging until opened; limited to 0x400 entries (outputs)\n- Automatically scrolls if left at the bottom of the log; maintains position if left elsewhere\n- Memory-efficient circular buffer; CTransaction references become weak after they're 0x200 entries back in the log\n- Search function that selects all matching log entries, including ongoing",
      "tree": {
        "sha": "3f6080e24462e2d551bb60d794ee860503034192",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3f6080e24462e2d551bb60d794ee860503034192"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ba6074b561fce84191bce5f3749f66436473599b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ba6074b561fce84191bce5f3749f66436473599b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ba6074b561fce84191bce5f3749f66436473599b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ba6074b561fce84191bce5f3749f66436473599b/comments",
    "author": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9800d9d761352b2cb8391efa020cfd6e76de68f5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9800d9d761352b2cb8391efa020cfd6e76de68f5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9800d9d761352b2cb8391efa020cfd6e76de68f5"
      }
    ],
    "stats": {
      "total": 1096,
      "additions": 1096,
      "deletions": 0
    },
    "files": [
      {
        "sha": "b4583f8efe1a26896c47ad289302bbff8fa4aa47",
        "filename": "src/Makefile.qt.include",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ba6074b561fce84191bce5f3749f66436473599b/src/Makefile.qt.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ba6074b561fce84191bce5f3749f66436473599b/src/Makefile.qt.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qt.include?ref=ba6074b561fce84191bce5f3749f66436473599b",
        "patch": "@@ -133,6 +133,7 @@ QT_MOC_CPP = \\\n   qt/moc_macdockiconhandler.cpp \\\n   qt/moc_macnotificationhandler.cpp \\\n   qt/moc_modaloverlay.cpp \\\n+  qt/moc_netwatch.cpp \\\n   qt/moc_notificator.cpp \\\n   qt/moc_openuridialog.cpp \\\n   qt/moc_optionsdialog.cpp \\\n@@ -210,6 +211,7 @@ BITCOIN_QT_H = \\\n   qt/macnotificationhandler.h \\\n   qt/macos_appnap.h \\\n   qt/modaloverlay.h \\\n+  qt/netwatch.h \\\n   qt/networkstyle.h \\\n   qt/notificator.h \\\n   qt/openuridialog.h \\\n@@ -315,6 +317,7 @@ BITCOIN_QT_BASE_CPP = \\\n   qt/guiutil.cpp \\\n   qt/intro.cpp \\\n   qt/modaloverlay.cpp \\\n+  qt/netwatch.cpp \\\n   qt/networkstyle.cpp \\\n   qt/notificator.cpp \\\n   qt/optionsdialog.cpp \\"
      },
      {
        "sha": "e0c8931040cded7456bf6b9e5a46df69d6d85b72",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 0,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ba6074b561fce84191bce5f3749f66436473599b/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ba6074b561fce84191bce5f3749f66436473599b/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=ba6074b561fce84191bce5f3749f66436473599b",
        "patch": "@@ -9,6 +9,7 @@\n #include <qt/guiconstants.h>\n #include <qt/guiutil.h>\n #include <qt/modaloverlay.h>\n+#include <qt/netwatch.h>\n #include <qt/networkstyle.h>\n #include <qt/notificator.h>\n #include <qt/openuridialog.h>\n@@ -230,6 +231,7 @@ BitcoinGUI::~BitcoinGUI()\n     MacDockIconHandler::cleanup();\n #endif\n \n+    delete NetWatch;\n     delete rpcConsole;\n }\n \n@@ -320,6 +322,9 @@ void BitcoinGUI::createActions()\n     verifyMessageAction = new QAction(platformStyle->TextColorIcon(\":/icons/verify\"), tr(\"&Verify message...\"), this);\n     verifyMessageAction->setStatusTip(tr(\"Verify messages to ensure they were signed with specified Bitcoin addresses\"));\n \n+    m_show_netwatch_action = new QAction(QIcon(), tr(\"&Watch network activity\"), this);\n+    m_show_netwatch_action->setStatusTip(tr(\"Open p2p network watching window\"));\n+\n     openRPCConsoleAction = new QAction(platformStyle->TextColorIcon(\":/icons/debugwindow\"), tr(\"&Debug window\"), this);\n     openRPCConsoleAction->setStatusTip(tr(\"Open debugging and diagnostic console\"));\n     // initially disable the debug window menu item\n@@ -344,6 +349,7 @@ void BitcoinGUI::createActions()\n     connect(optionsAction, &QAction::triggered, this, &BitcoinGUI::optionsClicked);\n     connect(toggleHideAction, &QAction::triggered, this, &BitcoinGUI::toggleHidden);\n     connect(showHelpMessageAction, &QAction::triggered, this, &BitcoinGUI::showHelpMessageClicked);\n+    connect(m_show_netwatch_action, &QAction::triggered, this, &BitcoinGUI::showNetWatch);\n     connect(openRPCConsoleAction, &QAction::triggered, this, &BitcoinGUI::showDebugWindow);\n     // prevents an open debug window from becoming stuck/unusable on client shutdown\n     connect(quitAction, &QAction::triggered, rpcConsole, &QWidget::hide);\n@@ -447,6 +453,8 @@ void BitcoinGUI::createMenuBar()\n         window_menu->addAction(usedReceivingAddressesAction);\n     }\n \n+    window_menu->addAction(m_show_netwatch_action);\n+\n     window_menu->addSeparator();\n     for (RPCConsole::TabTypes tab_type : rpcConsole->tabs()) {\n         QAction* tab_action = window_menu->addAction(rpcConsole->tabTitle(tab_type));\n@@ -526,6 +534,10 @@ void BitcoinGUI::setClientModel(ClientModel *_clientModel)\n         // Show progress dialog\n         connect(_clientModel, &ClientModel::showProgress, this, &BitcoinGUI::showProgress);\n \n+        if (NetWatch) {\n+            NetWatch->setClientModel(_clientModel);\n+        }\n+\n         rpcConsole->setClientModel(_clientModel);\n \n         updateProxyIcon();\n@@ -555,6 +567,9 @@ void BitcoinGUI::setClientModel(ClientModel *_clientModel)\n             trayIconMenu->clear();\n         }\n         // Propagate cleared model to child objects\n+        if (NetWatch) {\n+            NetWatch->setClientModel(nullptr);\n+        }\n         rpcConsole->setClientModel(nullptr);\n #ifdef ENABLE_WALLET\n         if (walletFrame)\n@@ -740,6 +755,15 @@ void BitcoinGUI::aboutClicked()\n     dlg.exec();\n }\n \n+void BitcoinGUI::showNetWatch()\n+{\n+    if (!NetWatch) {\n+        NetWatch = new GuiNetWatch(platformStyle, m_network_style);\n+        NetWatch->setClientModel(clientModel);\n+    }\n+    GUIUtil::bringToFront(NetWatch);\n+}\n+\n void BitcoinGUI::showDebugWindow()\n {\n     GUIUtil::bringToFront(rpcConsole);\n@@ -1066,6 +1090,9 @@ void BitcoinGUI::closeEvent(QCloseEvent *event)\n     {\n         if(!clientModel->getOptionsModel()->getMinimizeOnClose())\n         {\n+            if (NetWatch) {\n+                NetWatch->close();\n+            }\n             // close rpcConsole in case it was open to make some space for the shutdown window\n             rpcConsole->close();\n \n@@ -1262,6 +1289,9 @@ void BitcoinGUI::detectShutdown()\n {\n     if (m_node.shutdownRequested())\n     {\n+        if (NetWatch) {\n+            NetWatch->hide();\n+        }\n         if(rpcConsole)\n             rpcConsole->hide();\n         qApp->quit();"
      },
      {
        "sha": "0617ae0c9451e14640f179776c8d1375370ff0ac",
        "filename": "src/qt/bitcoingui.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ba6074b561fce84191bce5f3749f66436473599b/src/qt/bitcoingui.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ba6074b561fce84191bce5f3749f66436473599b/src/qt/bitcoingui.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.h?ref=ba6074b561fce84191bce5f3749f66436473599b",
        "patch": "@@ -26,6 +26,7 @@\n #include <memory>\n \n class ClientModel;\n+class GuiNetWatch;\n class NetworkStyle;\n class Notificator;\n class OptionsModel;\n@@ -144,6 +145,7 @@ class BitcoinGUI : public QMainWindow\n     QAction* backupWalletAction = nullptr;\n     QAction* changePassphraseAction = nullptr;\n     QAction* aboutQtAction = nullptr;\n+    QAction* m_show_netwatch_action = nullptr;\n     QAction* openRPCConsoleAction = nullptr;\n     QAction* openAction = nullptr;\n     QAction* showHelpMessageAction = nullptr;\n@@ -156,6 +158,7 @@ class BitcoinGUI : public QMainWindow\n     QSystemTrayIcon* trayIcon = nullptr;\n     const std::unique_ptr<QMenu> trayIconMenu;\n     Notificator* notificator = nullptr;\n+    GuiNetWatch* NetWatch = nullptr;\n     RPCConsole* rpcConsole = nullptr;\n     HelpMessageDialog* helpMessageDialog = nullptr;\n     ModalOverlay* modalOverlay = nullptr;\n@@ -274,6 +277,7 @@ public Q_SLOTS:\n     void optionsClicked();\n     /** Show about dialog */\n     void aboutClicked();\n+    void showNetWatch();\n     /** Show debug window */\n     void showDebugWindow();\n     /** Show debug window and set focus to the console */"
      },
      {
        "sha": "70c768f505f50899d1eb2aea50458205050fb59f",
        "filename": "src/qt/guiconstants.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ba6074b561fce84191bce5f3749f66436473599b/src/qt/guiconstants.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ba6074b561fce84191bce5f3749f66436473599b/src/qt/guiconstants.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiconstants.h?ref=ba6074b561fce84191bce5f3749f66436473599b",
        "patch": "@@ -18,6 +18,8 @@ static const bool DEFAULT_SPLASHSCREEN = true;\n \n /* Invalid field background style */\n #define STYLE_INVALID \"background:#FF8080\"\n+/* Background style for active search in NetWatch */\n+#define STYLE_ACTIVE \"background:#00c000\"\n \n /* Transaction list -- unconfirmed transaction */\n #define COLOR_UNCONFIRMED QColor(128, 128, 128)"
      },
      {
        "sha": "6bfcbd3d17aa0a1e91d886b7d1db60ed2d00d7e7",
        "filename": "src/qt/netwatch.cpp",
        "status": "added",
        "additions": 827,
        "deletions": 0,
        "changes": 827,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ba6074b561fce84191bce5f3749f66436473599b/src/qt/netwatch.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ba6074b561fce84191bce5f3749f66436473599b/src/qt/netwatch.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/netwatch.cpp?ref=ba6074b561fce84191bce5f3749f66436473599b",
        "patch": "@@ -0,0 +1,827 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/networkstyle.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <util/time.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QVBoxLayout>\n+#include <QWidget>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (const auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType log_entry_type)\n+{\n+    switch (log_entry_type) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.m_data) {\n+        m_data = nullptr;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.m_data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    m_data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)m_data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&m_data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    m_data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(m_data + alignment_weak, tx);\n+        new (m_data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (m_data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)m_data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!m_data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)m_data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete m_data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return m_data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)m_data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    explicit NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}\n+    void ValidationInterfaceUnregistering() override;\n+\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) override;\n+    void TransactionAddedToMempool(const CTransactionRef &) override;\n+};\n+\n+void NetWatchValidationInterface::ValidationInterfaceUnregistering()\n+{\n+    model.OrphanedValidationInterface();\n+}\n+\n+void NetWatchValidationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload)\n+{\n+    if (pindexNew != pindexFork) {\n+        model.LogBlock(pindexNew);\n+    }\n+}\n+\n+void NetWatchValidationInterface::TransactionAddedToMempool(const CTransactionRef &ptx)\n+{\n+    model.LogTransaction(ptx);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    m_widget(parent),\n+    m_validation_interface(new NetWatchValidationInterface(*this))\n+{\n+    RegisterValidationInterface(m_validation_interface);\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    LOCK(cs);\n+    if (m_validation_interface) {\n+        UnregisterValidationInterface(m_validation_interface);\n+        delete m_validation_interface;\n+        m_validation_interface = nullptr;\n+    }\n+}\n+\n+void NetWatchLogModel::OrphanedValidationInterface()\n+{\n+    LOCK(cs);\n+    delete m_validation_interface;\n+    m_validation_interface = nullptr;\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return m_log.size() - m_logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());\n+            return data(block.vtx[0], txout_index, header);\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+QVariant NetWatchLogModel::data(const CTransactionRef& tx, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+        case NWLMH_ID:\n+            return QString::fromStdString(tx->GetHash().GetHex());\n+        case NWLMH_ADDR: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                // Only datacarriers\n+                ptxout = &tx->vout[0];\n+            }\n+            CTxDestination txdest;\n+            if (ptxout->scriptPubKey[0] == OP_RETURN && ptxout->nValue > 0) {\n+                return tr(\"(Burn)\", \"Tx Watch: Provably burned value in transaction\");\n+            } else if (!ExtractDestination(ptxout->scriptPubKey, txdest)) {\n+                return tr(\"(Unknown)\", \"Tx Watch: Unknown transaction output type\");\n+            }\n+            return QString::fromStdString(EncodeDestination(txdest));\n+        }\n+        case NWLMH_VALUE: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                ptxout = &tx->vout[0];\n+            }\n+            if (m_client_model) {\n+                return BitcoinUnits::format(m_client_model->getOptionsModel()->getDisplayUnit(), ptxout->nValue);\n+            } else {\n+                return qlonglong(ptxout->nValue);\n+            }\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+const LogEntry& NetWatchLogModel::getLogEntryRow(int row) const\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (m_logpos + row) % m_log.size();\n+    return m_log[pos];\n+}\n+\n+LogEntry& NetWatchLogModel::getLogEntryRow(int row)\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (m_logpos + row) % m_log.size();\n+    return m_log[pos];\n+}\n+\n+bool NetWatchLogModel::isLogRowContinuation(int row) const\n+{\n+    AssertLockHeld(cs);\n+    return !getLogEntryRow(row);\n+}\n+\n+const LogEntry& NetWatchLogModel::findLogEntry(int row, int& out_entry_row) const\n+{\n+    AssertLockHeld(cs);\n+    out_entry_row = 0;\n+    while (row && isLogRowContinuation(row)) {\n+        --row;\n+        ++out_entry_row;\n+    }\n+    return getLogEntryRow(row);\n+}\n+\n+QVariant NetWatchLogModel::data(const QModelIndex& index, int role) const\n+{\n+    const Header header = Header(index.column());\n+    switch (role) {\n+        case Qt::DisplayRole:\n+            break;\n+        case Qt::BackgroundRole: {\n+            if (!data(index, Qt::DisplayRole).isValid()) {\n+                return m_widget->palette().brush(QPalette::WindowText);\n+            }\n+            LogEntry::LogEntryType type;\n+            {\n+                int entry_row;\n+                LOCK(cs);\n+                const LogEntry& le = findLogEntry(index.row(), entry_row);\n+                type = le.getType();\n+            }\n+            if (type == LogEntry::LET_BLOCK) {\n+                return m_widget->palette().brush(QPalette::AlternateBase);\n+            }\n+            return QVariant();\n+        }\n+        case Qt::ForegroundRole: {\n+            if (index.column() < 3) {\n+                bool iscont;\n+                {\n+                    LOCK(cs);\n+                    iscont = isLogRowContinuation(index.row());\n+                }\n+                if (iscont) {\n+                    QBrush brush = m_widget->palette().brush(QPalette::WindowText);\n+                    QColor color = brush.color();\n+                    color.setAlpha(color.alpha() / 2);\n+                    brush.setColor(color);\n+                    return brush;\n+                }\n+            }\n+            return QVariant();\n+        }\n+        case Qt::TextAlignmentRole:\n+            if (header == NWLMH_VALUE) {\n+                return QVariant(Qt::AlignRight | Qt::AlignVCenter);\n+            }\n+            return QVariant();\n+        case Qt::FontRole:\n+            if (header == NWLMH_ID) {\n+                return GUIUtil::fixedPitchFont();\n+            }\n+            return QVariant();\n+        default:\n+            return QVariant();\n+    }\n+    int entry_row;\n+    LOCK(cs);\n+    const LogEntry& le = findLogEntry(index.row(), entry_row);\n+    if (header == NWLMH_TIME) {\n+        return GUIUtil::dateTimeStr(le.getTimestamp(GetTime()));\n+    }\n+    const LogEntry::LogEntryType type = le.getType();\n+    if (type == LogEntry::LET_BLOCK) {\n+        return data(le.getBlockIndex(), entry_row, header);\n+    }\n+    if (header == NWLMH_TYPE) {\n+        return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+    }\n+\n+    if (le.expired()) {\n+        return QVariant();\n+    }\n+    return data(le.getTransactionRef(), entry_row, header);\n+}\n+\n+QVariant NetWatchLogModel::headerData(int section, Qt::Orientation orientation, int role) const\n+{\n+    if (orientation != Qt::Horizontal || role != Qt::DisplayRole) {\n+        return QVariant();\n+    }\n+    switch (section) {\n+        case NWLMH_TIME:  return tr(\"Time\"   , \"NetWatch: Time header\");\n+        case NWLMH_TYPE:  return tr(\"Type\"   , \"NetWatch: Type header\");\n+        case NWLMH_ID:    return tr(\"Id\"     , \"NetWatch: Block hash / Txid header\");\n+        case NWLMH_ADDR:  return tr(\"Address\", \"NetWatch: Address header\");\n+        case NWLMH_VALUE:\n+            if (m_client_model) {\n+                return BitcoinUnits::getAmountColumnTitle(m_client_model->getOptionsModel()->getDisplayUnit());\n+            } else {\n+                // Used only for sizing of the column\n+                return BitcoinUnits::getAmountColumnTitle(BitcoinUnits::mBTC);\n+            }\n+    }\n+    return QVariant();\n+}\n+\n+NetWatchLogSearch::NetWatchLogSearch(const QString& query, int display_unit) :\n+    m_query(query)\n+{\n+    const QRegExp reHex(\"^[\\\\da-f]+$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+    const QRegExp reType(\"^(T(xn?)?|B(lk?)?)$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+\n+    m_check_type = m_query.length() < 4 && reType.exactMatch(m_query);\n+    m_check_id = m_query.length() <= 64 && reHex.exactMatch(m_query);\n+    m_check_addr = m_query.length() <= nLongestAddress;\n+    CAmount val;\n+    m_check_value = BitcoinUnits::parse(display_unit, m_query, &val) && val >= 0 && val <= BitcoinUnits::maxMoney();\n+}\n+\n+bool NetWatchLogSearch::match(const NetWatchLogModel& model, int row) const\n+{\n+    if (model.data(model.index(row, NetWatchLogModel::NWLMH_TIME)).toString().contains(m_query)) {\n+        return true;\n+    } else if (m_check_type && model.data(model.index(row, NetWatchLogModel::NWLMH_TYPE)).toString().contains(m_query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (m_check_id && model.data(model.index(row, NetWatchLogModel::NWLMH_ID)).toString().contains(m_query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (m_check_addr && model.data(model.index(row, NetWatchLogModel::NWLMH_ADDR)).toString().contains(m_query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (m_check_value && model.data(model.index(row, NetWatchLogModel::NWLMH_VALUE)).toString().contains(m_query)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void NetWatchLogModel::searchRows(const QString& query, QList<int>& results)\n+{\n+    const auto currentUnit = m_client_model->getOptionsModel()->getDisplayUnit();\n+    NetWatchLogSearch *newsearch = new NetWatchLogSearch(query, currentUnit);\n+    LOCK(cs);\n+    delete m_current_search;\n+    m_current_search = newsearch;\n+\n+    bool fAdding = false;\n+    const size_t rows_used = rowCount();\n+    for (size_t row = 0; row < rows_used; ++row) {\n+        if (isLogRowContinuation(row) || newsearch->m_check_addr || newsearch->m_check_value) {\n+            // Check for a match\n+            fAdding = newsearch->match(*this, row);\n+        }\n+        if (fAdding) {\n+            results.append(row);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::searchDisable() {\n+    LOCK(cs);\n+    delete m_current_search;\n+    m_current_search = nullptr;\n+}\n+\n+void NetWatchLogModel::log_append(const LogEntry& le, size_t& rows_used)\n+{\n+    AssertLockHeld(cs);\n+    if (m_logskip) {\n+        // Replace a deleted row\n+        getLogEntryRow(rows_used) = le;\n+        --m_logskip;\n+    } else {\n+        // Haven't filled up yet, so just push_back\n+        assert(!m_logpos);\n+        m_log.push_back(le);\n+    }\n+    ++rows_used;\n+    if (rows_used > max_nonweak_txouts) {\n+        LogEntry& old_le = getLogEntryRow(rows_used - max_nonweak_txouts - 1);\n+        if (old_le) {\n+            old_le.makeWeak();\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogAddEntry(const LogEntry& le, size_t vout_count)\n+{\n+    if (vout_count < 1) {\n+        vout_count = 1;\n+    }\n+    const QModelIndex dummy;\n+    LOCK(cs);\n+    size_t rows_to_remove = 0;\n+    if (vout_count >= max_vout_per_tx) {\n+        vout_count = max_vout_per_tx;\n+    }\n+    size_t rows_used = rowCount();\n+    if (rows_used > logsizelimit - vout_count) {\n+        rows_to_remove = (rows_used + vout_count) - logsizelimit;\n+    }\n+    if (rows_to_remove) {\n+        // Don't orphan continuation entries\n+        while (isLogRowContinuation(rows_to_remove)) {\n+            ++rows_to_remove;\n+        }\n+\n+        beginRemoveRows(dummy, 0, rows_to_remove - 1);\n+        m_logpos = (m_logpos + rows_to_remove) % m_log.size();\n+        m_logskip += rows_to_remove;\n+        endRemoveRows();\n+\n+        rows_used = rowCount();\n+    }\n+\n+    const LogEntry cont_le;\n+    const int first_new_row = rows_used, last_new_row = rows_used + vout_count - 1;\n+    beginInsertRows(dummy, first_new_row, last_new_row);\n+    log_append(le, rows_used);\n+    for (size_t i = 1; i < vout_count; ++i) {\n+        log_append(cont_le, rows_used);\n+    }\n+    endInsertRows();\n+\n+    if (m_current_search) {\n+        QList<int> new_matches;\n+        if (m_current_search->m_check_addr || m_current_search->m_check_value) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                if (m_current_search->match(*this, row)) {\n+                    new_matches.append(row);\n+                }\n+            }\n+        } else if (m_current_search->match(*this, first_new_row)) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                new_matches.append(row);\n+            }\n+        }\n+        if (!new_matches.isEmpty()) {\n+            Q_EMIT moreSearchResults(new_matches);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogBlock(const CBlockIndex* pblockindex)\n+{\n+    CBlock block;\n+    if (!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus())) {\n+        // Indicate error somehow?\n+        return;\n+    }\n+    assert(block.vtx.size());\n+    const size_t vout_count = CountNonDatacarrierOutputs(block.vtx[0]);\n+    LogAddEntry(LogEntry(GetTime(), *pblockindex), vout_count);\n+}\n+\n+void NetWatchLogModel::LogTransaction(const CTransactionRef& tx)\n+{\n+    const size_t vout_count = CountNonDatacarrierOutputs(tx);\n+    LogAddEntry(LogEntry(GetTime(), tx), vout_count);\n+}\n+\n+void NetWatchLogModel::setClientModel(ClientModel *model)\n+{\n+    if (m_client_model) {\n+        disconnect(m_client_model->getOptionsModel(), &OptionsModel::displayUnitChanged, this, &NetWatchLogModel::updateDisplayUnit);\n+    }\n+    m_client_model = model;\n+    if (model) {\n+        connect(model->getOptionsModel(), &OptionsModel::displayUnitChanged, this, &NetWatchLogModel::updateDisplayUnit);\n+    }\n+    updateDisplayUnit();\n+}\n+\n+void NetWatchLogModel::updateDisplayUnit()\n+{\n+    Q_EMIT headerDataChanged(Qt::Horizontal, NWLMH_VALUE, NWLMH_VALUE);\n+    Q_EMIT dataChanged(index(0, NWLMH_VALUE), index(rowCount() - 1, NWLMH_VALUE));\n+}\n+\n+int NetWatchLogTestModel::rowCount(const QModelIndex& parent) const\n+{\n+    return 2;\n+}\n+\n+QVariant NetWatchLogTestModel::data(const QModelIndex& index, int role) const\n+{\n+    const NetWatchLogModel::Header header = NetWatchLogModel::Header(index.column());\n+    if (role == Qt::FontRole && header == NWLMH_ID) {\n+        return GUIUtil::fixedPitchFont();\n+    } else if (role != Qt::DisplayRole) {\n+        return QVariant();\n+    }\n+    switch (header) {\n+        case NWLMH_TIME:\n+            return GUIUtil::dateTimeStr(GetTime()) + \"4\";\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LogEntryType(index.row()));\n+        case NWLMH_ID:\n+            return QString(64, '0');\n+        case NWLMH_ADDR:\n+            return QString(nLongestAddress, 'W');\n+        case NWLMH_VALUE:\n+            return \"20000000.00000000\";\n+    }\n+    return QVariant();\n+}\n+\n+GuiNetWatch::GuiNetWatch(const PlatformStyle *platformStyle, const NetworkStyle *networkStyle, QWidget *parent) :\n+    QWidget(parent)\n+{\n+    QVBoxLayout * const layout = new QVBoxLayout(this);\n+\n+    m_search_editor = new QLineEdit(this);\n+#if QT_VERSION >= 0x040700\n+    m_search_editor->setPlaceholderText(\"Search\");\n+#endif\n+    layout->addWidget(m_search_editor);\n+\n+    m_log_view = new QTableView(this);\n+    m_log_view->verticalHeader()->hide();\n+    m_log_view->setSizePolicy(QSizePolicy(QSizePolicy::Ignored, QSizePolicy::Ignored));\n+    m_log_view->setSelectionBehavior(QAbstractItemView::SelectRows);\n+    m_log_view->setTabKeyNavigation(false);\n+    m_log_view->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);\n+\n+    {\n+        NetWatchLogTestModel testmodel;\n+        m_log_view->setModel(&testmodel);\n+        m_log_view->resizeColumnsToContents();\n+\n+        log_model = new NetWatchLogModel(this);\n+        m_log_view->setModel(log_model);\n+    }\n+    layout->addWidget(m_log_view);\n+\n+    setWindowTitle(tr(PACKAGE_NAME) + \" - \" + tr(\"Network Watch\") + \" \" + networkStyle->getTitleAddText());\n+    setMinimumSize(640, 480);\n+    resize(layout->contentsMargins().left() + (m_log_view->frameWidth() * 2) + m_log_view->columnViewportPosition(NetWatchLogModel::NWLMHeaderCount-1) + m_log_view->columnWidth(NetWatchLogModel::NWLMHeaderCount-1) + m_log_view->verticalScrollBar()->size().width() + layout->contentsMargins().right(), 480);\n+    setWindowIcon(networkStyle->getTrayAndWindowIcon());\n+\n+    connect(m_search_editor, &QLineEdit::textChanged, this, &GuiNetWatch::doSearch);\n+\n+    connect(log_model, &NetWatchLogModel::rowsRemoved, this, &GuiNetWatch::rowsRemoved);\n+    connect(log_model, &NetWatchLogModel::rowsAboutToBeInserted, this, &GuiNetWatch::aboutToInsert);\n+    connect(log_model, &NetWatchLogModel::rowsInserted, this, &GuiNetWatch::maybeScrollToBottom);\n+    connect(log_model, &NetWatchLogModel::moreSearchResults, this, &GuiNetWatch::moreSearchResults);\n+\n+    connect(m_log_view->selectionModel(), &QItemSelectionModel::selectionChanged, this, &GuiNetWatch::maybeCancelSearch);\n+\n+    setLayout(layout);\n+}\n+\n+void GuiNetWatch::setClientModel(ClientModel *model)\n+{\n+    log_model->setClientModel(model);\n+}\n+\n+void GuiNetWatch::rowsRemoved(const QModelIndex& parent, int start, int end)\n+{\n+    if (m_log_view->verticalScrollBar()->value() >= m_log_view->verticalScrollBar()->maximum()) {\n+        return;\n+    }\n+    // Maintain the current viewed entries in place\n+    int scrollpos = m_log_view->verticalScrollBar()->value();\n+    if (start < scrollpos) {\n+        scrollpos -= std::max(0, 1 + end - start);\n+        m_log_view->verticalScrollBar()->setValue(scrollpos);\n+    }\n+}\n+\n+void GuiNetWatch::aboutToInsert()\n+{\n+    m_adjust_scroll = (m_log_view->verticalScrollBar()->value() >= m_log_view->verticalScrollBar()->maximum());\n+}\n+\n+void GuiNetWatch::maybeScrollToBottom()\n+{\n+    if (m_adjust_scroll) {\n+        m_log_view->scrollToBottom();\n+    }\n+}\n+\n+void GuiNetWatch::doSearch(const QString& query)\n+{\n+    if (query.isEmpty()) {\n+        log_model->searchDisable();\n+        m_search_editor->setStyleSheet(\"\");\n+        return;\n+    }\n+    QList<int> results;\n+    log_model->searchRows(query, results);\n+    if (results.isEmpty()) {\n+        m_search_editor->setStyleSheet(STYLE_INVALID);\n+        return;\n+    }\n+    m_search_editor->setStyleSheet(STYLE_ACTIVE);\n+    QItemSelectionModel& sel = *m_log_view->selectionModel();\n+    m_dont_cancel_search = true;\n+    sel.clear();\n+    Q_FOREACH (int row, results) {\n+        sel.select(log_model->index(row, 0), QItemSelectionModel::Rows | QItemSelectionModel::Select);\n+    }\n+    m_dont_cancel_search = false;\n+    m_log_view->scrollTo(log_model->index(results.back(), NetWatchLogModel::NWLMH_ID));\n+}\n+\n+void GuiNetWatch::moreSearchResults(const QList<int>& rows)\n+{\n+    m_search_editor->setStyleSheet(STYLE_ACTIVE);\n+    QItemSelectionModel& sel = *m_log_view->selectionModel();\n+    m_dont_cancel_search = true;\n+    Q_FOREACH (int row, rows) {\n+        sel.select(log_model->index(row, 0), QItemSelectionModel::Rows | QItemSelectionModel::Select);\n+    }\n+    m_dont_cancel_search = false;\n+}\n+\n+void GuiNetWatch::maybeCancelSearch()\n+{\n+    if (m_dont_cancel_search) {\n+        return;\n+    }\n+    m_search_editor->setStyleSheet(\"\");\n+    log_model->searchDisable();\n+}"
      },
      {
        "sha": "1e2d69e9f54fa9f5972f315010a766c7fd8e086e",
        "filename": "src/qt/netwatch.h",
        "status": "added",
        "additions": 228,
        "deletions": 0,
        "changes": 228,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ba6074b561fce84191bce5f3749f66436473599b/src/qt/netwatch.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ba6074b561fce84191bce5f3749f66436473599b/src/qt/netwatch.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/netwatch.h?ref=ba6074b561fce84191bce5f3749f66436473599b",
        "patch": "@@ -0,0 +1,228 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Copyright (c) 2011-2013 David Krauss (std::align substitute from c-plus)\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_QT_NETWATCH_H\n+#define BITCOIN_QT_NETWATCH_H\n+\n+#include <primitives/transaction.h>\n+#include <sync.h>\n+#include <validationinterface.h>\n+\n+#include <QAbstractTableModel>\n+#include <QWidget>\n+\n+QT_BEGIN_NAMESPACE\n+class QLineEdit;\n+class QTableView;\n+QT_END_NAMESPACE\n+\n+class CBlock;\n+class CBlockIndex;\n+class ClientModel;\n+class LogEntry;\n+class NetworkStyle;\n+class PlatformStyle;\n+\n+static const int nLongestAddress = 35;\n+\n+class LogEntry {\n+private:\n+    /* m_data is a uint32_t (meta_t) with the top two bits used for:\n+     *   1: CBlockIndex*\n+     *   2: CTransactionRef\n+     *   3: weak_ptr<const CTransaction>\n+     * The subsequent 30 bits are the timestamp, assumed to be most recent to the current time.\n+     * Following this, and any padding necessary for alignment, the object itself is stored\n+     */\n+    uint8_t *m_data = nullptr;\n+\n+    typedef uint32_t meta_t;\n+    typedef std::weak_ptr<const CTransaction> CTransactionWeakref;\n+    static const uint32_t rel_ts_mask = 0x3fffffff;\n+    static const uint64_t rel_ts_mask64 = rel_ts_mask;\n+\n+    template<typename T> static size_t data_sizeof(size_t& offset) {\n+        void *p = (void *)intptr_t(sizeof(meta_t));\n+        size_t dummy_bufsize = sizeof(T) * 2;\n+        p = align(std::alignment_of<T>::value, sizeof(T), p, dummy_bufsize);\n+        assert(p);\n+        offset = size_t(p);\n+        return offset + sizeof(T);\n+    }\n+\n+    // std::align (missing in at least GCC 4.9) substitute from c-plus\n+    static inline void *align(std::size_t alignment, std::size_t size, void *&ptr, std::size_t &space) {\n+        auto pn = reinterpret_cast<std::uintptr_t>(ptr);\n+        auto aligned = (pn + alignment - 1) & -alignment;\n+        auto new_space = space - (aligned - pn);\n+        if (new_space < size) {\n+            return nullptr;\n+        }\n+        space = new_space;\n+        return ptr = reinterpret_cast<void *>(aligned);\n+    }\n+\n+    void init(const LogEntry&);\n+    void init(int32_t relTimestamp, const CBlockIndex&);\n+    void init(int32_t relTimestamp, const CTransactionWeakref&, bool weak);\n+    void clear();\n+\n+public:\n+    enum LogEntryType {\n+        LET_BLOCK,\n+        LET_TX,\n+    };\n+    static const QString LogEntryTypeAbbreviation(LogEntryType);\n+\n+    LogEntry(const LogEntry&);\n+    LogEntry() { }\n+    explicit LogEntry(int32_t relTimestamp, const CBlockIndex&);\n+    explicit LogEntry(int32_t relTimestamp, const CTransactionWeakref&, bool weak = true);\n+    explicit LogEntry(int32_t relTimestamp, const CTransactionRef&, bool weak = false);\n+    ~LogEntry();\n+\n+    LogEntry& operator=(const LogEntry& other);\n+\n+    explicit operator bool() const;\n+    int32_t getRelTimestamp() const;\n+    uint64_t getTimestamp(uint64_t now) const;\n+    LogEntryType getType() const;\n+\n+    template <typename T> T* get() const {\n+        void *p = m_data + sizeof(meta_t);\n+        size_t dummy_bufsize = sizeof(T) * 2;\n+        p = align(std::alignment_of<T>::value, sizeof(T), p, dummy_bufsize);\n+        assert(p);\n+        return (T*)p;\n+    }\n+\n+    const CBlockIndex& getBlockIndex() const;\n+    CTransactionRef getTransactionRef() const;\n+    bool isWeak() const;\n+    bool expired() const;\n+    void makeWeak();\n+};\n+\n+class NetWatchLogModel;\n+\n+class NetWatchLogSearch {\n+public:\n+    QString m_query;\n+\n+    bool m_check_type;\n+    bool m_check_id;\n+    bool m_check_addr;\n+    bool m_check_value;\n+\n+    NetWatchLogSearch(const QString& query, int display_unit);\n+    bool match(const NetWatchLogModel& model, int row) const;\n+};\n+\n+class NetWatchValidationInterface;\n+\n+class NetWatchLogModel : public QAbstractTableModel\n+{\n+    Q_OBJECT\n+\n+private:\n+    QWidget * const m_widget;\n+    ClientModel *m_client_model = nullptr;\n+\n+    NetWatchValidationInterface *m_validation_interface;\n+\n+    mutable CCriticalSection cs;\n+    std::vector<LogEntry> m_log;\n+    static const size_t logsizelimit = 0x400;\n+    size_t m_logpos = 0;\n+    size_t m_logskip = 0;\n+\n+    static const size_t max_nonweak_txouts = 0x200;\n+    static const size_t max_vout_per_tx = 0x100;\n+\n+    NetWatchLogSearch *m_current_search = nullptr;\n+\n+    const LogEntry& getLogEntryRow(int row) const;\n+    LogEntry& getLogEntryRow(int row);\n+    void log_append(const LogEntry&, size_t& rows_used);\n+\n+public:\n+    static const int NWLMHeaderCount = 5;\n+    enum Header {\n+        NWLMH_TIME,\n+        NWLMH_TYPE,\n+        NWLMH_ID,\n+        NWLMH_ADDR,\n+        NWLMH_VALUE,\n+    };\n+\n+    explicit NetWatchLogModel(QWidget *parent);\n+    ~NetWatchLogModel();\n+\n+    void setClientModel(ClientModel *model);\n+    void OrphanedValidationInterface();\n+\n+    bool isLogRowContinuation(int row) const;\n+    const LogEntry& findLogEntry(int row, int& out_entry_row) const;\n+\n+    int rowCount(const QModelIndex& parent = QModelIndex()) const;\n+    int columnCount(const QModelIndex& parent) const;\n+    QVariant data(const CBlockIndex&, int txout_index, const Header) const;\n+    QVariant data(const CTransactionRef&, int txout_index, const Header) const;\n+    QVariant data(const QModelIndex&, int role = Qt::DisplayRole) const;\n+    QVariant headerData(int section, Qt::Orientation, int role = Qt::DisplayRole) const;\n+\n+    void searchRows(const QString& query, QList<int>& results);\n+    void searchDisable();\n+\n+    void LogAddEntry(const LogEntry& le, size_t vout_count);\n+    void LogBlock(const CBlockIndex*);\n+    void LogTransaction(const CTransactionRef&);\n+\n+Q_SIGNALS:\n+    void moreSearchResults(const QList<int>& rows);\n+\n+public Q_SLOTS:\n+    void updateDisplayUnit();\n+};\n+\n+class NetWatchLogTestModel : public NetWatchLogModel\n+{\n+    Q_OBJECT\n+\n+public:\n+    NetWatchLogTestModel() : NetWatchLogModel(nullptr) { }\n+\n+    int rowCount(const QModelIndex& parent) const;\n+    QVariant data(const QModelIndex&, int role = Qt::DisplayRole) const;\n+};\n+\n+class GuiNetWatch: public QWidget\n+{\n+    Q_OBJECT\n+\n+private:\n+    bool m_adjust_scroll;\n+\n+public:\n+    GuiNetWatch(const PlatformStyle *, const NetworkStyle *, QWidget * parent = nullptr);\n+\n+    void setClientModel(ClientModel *model);\n+\n+    NetWatchLogModel *log_model;\n+    bool m_dont_cancel_search = false;\n+\n+    QLineEdit *m_search_editor;\n+    QTableView *m_log_view;\n+\n+public Q_SLOTS:\n+    void rowsRemoved(const QModelIndex& parent, int start, int end);\n+    void aboutToInsert();\n+    void maybeScrollToBottom();\n+    void doSearch(const QString& query);\n+    void moreSearchResults(const QList<int>& rows);\n+    void maybeCancelSearch();\n+};\n+\n+#endif // BITCOIN_QT_NETWATCH_H"
      },
      {
        "sha": "128c92ad92743b979dfe6ec4e43f3fc57e8a6316",
        "filename": "src/qt/rpcconsole.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ba6074b561fce84191bce5f3749f66436473599b/src/qt/rpcconsole.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ba6074b561fce84191bce5f3749f66436473599b/src/qt/rpcconsole.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.h?ref=ba6074b561fce84191bce5f3749f66436473599b",
        "patch": "@@ -15,6 +15,7 @@\n #include <QThread>\n \n class ClientModel;\n+class GuiNetWatch;\n class PlatformStyle;\n class RPCTimerInterface;\n class WalletModel;\n@@ -153,6 +154,7 @@ public Q_SLOTS:\n     interfaces::Node& m_node;\n     Ui::RPCConsole* const ui;\n     ClientModel *clientModel = nullptr;\n+    GuiNetWatch *netwatch = nullptr;\n     QStringList history;\n     int historyPtr = 0;\n     QString cmdBeforeBrowsing;"
      }
    ]
  }
]