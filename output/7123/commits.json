[
  {
    "sha": "dc6115cd1202ee9146419b55f6c021c92c42e4cf",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkYzYxMTVjZDEyMDJlZTkxNDY0MTliNTVmNmMwMjFjOTJjNDJlNGNm",
    "commit": {
      "author": {
        "name": "Gregory Maxwell",
        "email": "greg@xiph.org",
        "date": "2015-11-28T10:03:43Z"
      },
      "committer": {
        "name": "Gregory Maxwell",
        "email": "greg@xiph.org",
        "date": "2015-11-28T10:23:58Z"
      },
      "message": "Make trickle logic useful again, delay trickle when past upload limit.\n\nThese change should improve privacy, discourage some resource\n wasting behavior from parties trying to attack user privacy, and\n provides additional node bandwidth control.\n\nWhen Bitcoin Core was changed to not use fixed sleeps in network\n message handling this mostly broke the trickle logic:  Instead of\n picking a new random node to bypass the delay every 100ms, it now\n chooses a new one every time through the message processing loop\n which can be much faster and can be remotely triggered.\n\nAs a result a vast majority of invs simply blew through without\n any delay.\n\nThis patch drops the old 1/4 random selection logic and elects two\n trickle peers which will get immediate forwards.  These peers\n are selected at random from the top four peers ordered by their\n ability to take unfiltered relays, being outbound, being\n network nodes, and highest uptime.  All other peers have their\n INVs triggered on a shared random delay (with a mean of 1 second).\n\nThe selection criteria tries to find a stable set of non-attacker\n controlled nodes that work and stick with them.\n\nTwo are used so that even if one was the original source of the\n only transactions ready to send the transactions will not\n be guaranteed to end their journey here.  It also should improve\n robustness to dysfunctional nodes.\n\nWhen the upload limit is passed, this responds by increasing the\n batching interval by another second. Preliminary testing suggests\n this significantly reduces the number of transaction getdatas\n the node receives.\n\nFinally, this sorts transaction INV before sending them to reduce\n the potential for information to leak in INV ordering.",
      "tree": {
        "sha": "23a1c20700ab4b6697aa5e4714b9937a23789186",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/23a1c20700ab4b6697aa5e4714b9937a23789186"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dc6115cd1202ee9146419b55f6c021c92c42e4cf",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dc6115cd1202ee9146419b55f6c021c92c42e4cf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dc6115cd1202ee9146419b55f6c021c92c42e4cf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dc6115cd1202ee9146419b55f6c021c92c42e4cf/comments",
    "author": {
      "login": "gmaxwell",
      "id": 858454,
      "node_id": "MDQ6VXNlcjg1ODQ1NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gmaxwell",
      "html_url": "https://github.com/gmaxwell",
      "followers_url": "https://api.github.com/users/gmaxwell/followers",
      "following_url": "https://api.github.com/users/gmaxwell/following{/other_user}",
      "gists_url": "https://api.github.com/users/gmaxwell/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
      "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
      "repos_url": "https://api.github.com/users/gmaxwell/repos",
      "events_url": "https://api.github.com/users/gmaxwell/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gmaxwell",
      "id": 858454,
      "node_id": "MDQ6VXNlcjg1ODQ1NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gmaxwell",
      "html_url": "https://github.com/gmaxwell",
      "followers_url": "https://api.github.com/users/gmaxwell/followers",
      "following_url": "https://api.github.com/users/gmaxwell/following{/other_user}",
      "gists_url": "https://api.github.com/users/gmaxwell/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
      "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
      "repos_url": "https://api.github.com/users/gmaxwell/repos",
      "events_url": "https://api.github.com/users/gmaxwell/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8284feb3c91f91505c66d5c3b7ef8349b7d79862",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8284feb3c91f91505c66d5c3b7ef8349b7d79862",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8284feb3c91f91505c66d5c3b7ef8349b7d79862"
      }
    ],
    "stats": {
      "total": 109,
      "additions": 87,
      "deletions": 22
    },
    "files": [
      {
        "sha": "8559c6d10839c83fa9639f5bcf5cfb22390b9f10",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 17,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dc6115cd1202ee9146419b55f6c021c92c42e4cf/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dc6115cd1202ee9146419b55f6c021c92c42e4cf/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=dc6115cd1202ee9146419b55f6c021c92c42e4cf",
        "patch": "@@ -5156,6 +5156,11 @@ bool ProcessMessages(CNode* pfrom)\n }\n \n \n+static bool CompareInvHash(const CInv a, const CInv &b)\n+{\n+    return a.hash < b.hash;\n+}\n+\n bool SendMessages(CNode* pto, bool fSendTrickle)\n {\n     const Consensus::Params& consensusParams = Params().GetConsensus();\n@@ -5308,35 +5313,37 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n                     continue;\n \n                 // trickle out tx inv to protect privacy\n-                if (inv.type == MSG_TX && !fSendTrickle)\n+                if (inv.type == MSG_TX)\n                 {\n-                    // 1/4 of tx invs blast to all immediately\n-                    static uint256 hashSalt;\n-                    if (hashSalt.IsNull())\n-                        hashSalt = GetRandHash();\n-                    uint256 hashRand = ArithToUint256(UintToArith256(inv.hash) ^ UintToArith256(hashSalt));\n-                    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n-                    bool fTrickleWait = ((UintToArith256(hashRand) & 3) != 0);\n-\n-                    if (fTrickleWait)\n-                    {\n-                        vInvWait.push_back(inv);\n-                        continue;\n-                    }\n+                    vInvWait.push_back(inv);\n+                    continue;\n                 }\n+                pto->setInventoryKnown.insert(inv);\n+                vInv.push_back(inv);\n+                if (vInv.size() >= 1000)\n+                {\n+                    pto->PushMessage(\"inv\", vInv);\n+                    vInv.clear();\n+                }\n+            }\n \n-                // returns true if wasn't already contained in the set\n-                if (pto->setInventoryKnown.insert(inv).second)\n+            if(fSendTrickle)\n+            {\n+                std::sort(vInvWait.begin(), vInvWait.end(), CompareInvHash);\n+                BOOST_FOREACH(const CInv& inv, vInvWait)\n                 {\n+                    pto->setInventoryKnown.insert(inv);\n                     vInv.push_back(inv);\n                     if (vInv.size() >= 1000)\n                     {\n                         pto->PushMessage(\"inv\", vInv);\n                         vInv.clear();\n                     }\n                 }\n+                pto->vInventoryToSend.clear();\n+            } else {\n+                pto->vInventoryToSend = vInvWait;\n             }\n-            pto->vInventoryToSend = vInvWait;\n         }\n         if (!vInv.empty())\n             pto->PushMessage(\"inv\", vInv);"
      },
      {
        "sha": "9d840087e14340ef1aad7d2e65db93dd951606c7",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 63,
        "deletions": 5,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dc6115cd1202ee9146419b55f6c021c92c42e4cf/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dc6115cd1202ee9146419b55f6c021c92c42e4cf/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=dc6115cd1202ee9146419b55f6c021c92c42e4cf",
        "patch": "@@ -1703,31 +1703,79 @@ bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOu\n     return true;\n }\n \n+static bool CompareNodeMessageHandler(const CNodeRef &a, const CNodeRef &b)\n+{\n+   // Prefer nodes that want tx-realy, non-filtering nodes,\n+   // nodes that have relayed tx to us, nodes that claim NodeNework,\n+   // outbound peers, lower node ID.\n+\n+    if (a->fRelayTxes != b->fRelayTxes)\n+        return a->fRelayTxes;\n+\n+    if ((a->pfilter == NULL) != (b->pfilter == NULL))\n+        return a->pfilter == NULL;\n+\n+/*    if ((a->nTimeLastTX > 0) != (b->nTimeLastTX > 0))\n+        return a->nTimeLastTX > 0;*/\n+\n+    if (a->fInbound != b->fInbound)\n+        return b->fInbound;\n+\n+    if (a->fClient != b->fClient)\n+        return b->fClient;\n+\n+    return a->id < b->id;\n+}\n \n void ThreadMessageHandler()\n {\n     boost::mutex condition_mutex;\n     boost::unique_lock<boost::mutex> lock(condition_mutex);\n \n     SetThreadPriority(THREAD_PRIORITY_BELOW_NORMAL);\n+    int64_t nNextTrickleTime = 0;\n+    CNode* pnodeTrickle1 = NULL;\n+    CNode* pnodeTrickle2 = NULL;\n     while (true)\n     {\n+        bool fHasTrickle1 = false;\n+        bool fHasTrickle2 = false;\n         vector<CNode*> vNodesCopy;\n         {\n             LOCK(cs_vNodes);\n             vNodesCopy = vNodes;\n+            std::sort(vNodesCopy.begin(), vNodesCopy.end(), CompareNodeMessageHandler);\n             BOOST_FOREACH(CNode* pnode, vNodesCopy) {\n                 pnode->AddRef();\n+                fHasTrickle1 |= pnodeTrickle1 == pnode && !pnode->fDisconnect;\n+                fHasTrickle2 |= pnodeTrickle2 == pnode && !pnode->fDisconnect;\n             }\n         }\n \n-        // Poll the connected nodes for messages\n-        CNode* pnodeTrickle = NULL;\n-        if (!vNodesCopy.empty())\n-            pnodeTrickle = vNodesCopy[GetRand(vNodesCopy.size())];\n+        if (!fHasTrickle1)\n+            pnodeTrickle1 = NULL;\n+\n+        // Elect new trickle nodes from one of the best 4 peers.\n+        if (pnodeTrickle1 == NULL && !vNodesCopy.empty())\n+            pnodeTrickle1 = vNodesCopy[GetRand(min(vNodesCopy.size(), (size_t)4))];\n+\n+        if (!fHasTrickle2 || pnodeTrickle2 == pnodeTrickle1)\n+            pnodeTrickle2 = NULL;\n+\n+        if (pnodeTrickle2 == NULL && vNodesCopy.size() > 1)\n+        {\n+            do {\n+                pnodeTrickle2 = vNodesCopy[GetRand(min(vNodesCopy.size(), (size_t)4))];\n+            } while(pnodeTrickle1 == pnodeTrickle2);\n+        }\n+\n \n         bool fSleep = true;\n+        bool fSendBatch = GetTimeMillis() > nNextTrickleTime;\n \n+        LogPrintf(\"Trickle: Debug prints to be removed. batch: %d elected %d %d\\n\", fSendBatch, pnodeTrickle1 != NULL?pnodeTrickle1->id:-1, pnodeTrickle2 != NULL?pnodeTrickle2->id:-1);\n+\n+        // Poll the connected nodes for messages\n         BOOST_FOREACH(CNode* pnode, vNodesCopy)\n         {\n             if (pnode->fDisconnect)\n@@ -1756,11 +1804,21 @@ void ThreadMessageHandler()\n             {\n                 TRY_LOCK(pnode->cs_vSend, lockSend);\n                 if (lockSend)\n-                    g_signals.SendMessages(pnode, pnode == pnodeTrickle || pnode->fWhitelisted);\n+                    g_signals.SendMessages(pnode, fSendBatch || pnode == pnodeTrickle1 || pnode == pnodeTrickle2 || pnode->fWhitelisted);\n             }\n             boost::this_thread::interruption_point();\n         }\n \n+        if (fSendBatch)\n+        {\n+            nNextTrickleTime = GetTimeMillis() + 500 + GetRand(1000);\n+            // Delay transaction INVs when we're out of bandwidth to reduce how often peers getdata from us.\n+            if (CNode::OutboundTargetReached(true))\n+                nNextTrickleTime += 1000;\n+            pnodeTrickle1 = NULL;\n+            pnodeTrickle2 = NULL;\n+        }\n+\n         {\n             LOCK(cs_vNodes);\n             BOOST_FOREACH(CNode* pnode, vNodesCopy)"
      }
    ]
  }
]