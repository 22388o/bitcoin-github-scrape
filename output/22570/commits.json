[
  {
    "sha": "fa384fdd0b7af73d81fa9619c5fba779452cd2af",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTM4NGZkZDBiN2FmNzNkODFmYTk2MTljNWZiYTc3OTQ1MmNkMmFm",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-07-28T18:00:23Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-07-30T09:21:51Z"
      },
      "message": "Ignore banlist.dat\n\nThis also allows to remove the \"dirty\" argument, which can now be\ndeduced from the return value of Read().",
      "tree": {
        "sha": "916e3054782a7188df547399f4efe191dca415d1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/916e3054782a7188df547399f4efe191dca415d1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa384fdd0b7af73d81fa9619c5fba779452cd2af",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUgJVAv/XlDfw4EpRATIKXCLBhmrZzvprpgHZfe4t6l5Bnqos6lgc0CSaR8PvDEr\nIaOYX9CC5xFDeIsKvUhUX0fUq6wjt8SL76/dn0rMdloNBhEAHkbksoUZzlZBsvBF\niGEku6bupLVduXj09ktUhxgZw696HsCAP4Omm2Xwoqww4JZraix/RHSzvNAVzBe2\nL9Kqr8lvhkFe0A2oVAKTfNH+7Ev5DoWjj8QuB0xVyf3QMNg7h8He0Td3ff1E+bXb\nrSbSgZb6nsfZ+6eAvad3ZgGCjJXXGI01fO648dsk9iNbLwL046C6MDmNFZsG6NUb\nohPSROHdfe5nFgkAG/VHPIoy/bHdcIdCpyqOzerDPS32dHNzIT/pRodsZi7UIgu5\np7ZUkDCSHdcMqk8yvsjSpGINI2fq1W0N2x9+MNZlKbZebotRqdNC8vcpmK86Ub7M\nlQrzzrZbiUvoGzSiTOjJSR60Prg3Yp6hrvN0fKfTcdf+XW+qxgHfThxnJdVhzYY7\nTNV1qrpU\n=qEkc\n-----END PGP SIGNATURE-----",
        "payload": "tree 916e3054782a7188df547399f4efe191dca415d1\nparent 4b1fb50def0dea0cd320bc43c12d9a12edde0390\nauthor MarcoFalke <falke.marco@gmail.com> 1627495223 +0200\ncommitter MarcoFalke <falke.marco@gmail.com> 1627636911 +0200\n\nIgnore banlist.dat\n\nThis also allows to remove the \"dirty\" argument, which can now be\ndeduced from the return value of Read().\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa384fdd0b7af73d81fa9619c5fba779452cd2af",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa384fdd0b7af73d81fa9619c5fba779452cd2af",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa384fdd0b7af73d81fa9619c5fba779452cd2af/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4b1fb50def0dea0cd320bc43c12d9a12edde0390",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4b1fb50def0dea0cd320bc43c12d9a12edde0390",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4b1fb50def0dea0cd320bc43c12d9a12edde0390"
      }
    ],
    "stats": {
      "total": 29,
      "additions": 12,
      "deletions": 17
    },
    "files": [
      {
        "sha": "f88d3f91a1c166a6997872eacb295799a78f0338",
        "filename": "doc/files.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa384fdd0b7af73d81fa9619c5fba779452cd2af/doc/files.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa384fdd0b7af73d81fa9619c5fba779452cd2af/doc/files.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/files.md?ref=fa384fdd0b7af73d81fa9619c5fba779452cd2af",
        "patch": "@@ -56,7 +56,6 @@ Subdirectory       | File(s)               | Description\n `indexes/coinstats/db/` | LevelDB database | Coinstats index; *optional*, used if `-coinstatsindex=1`\n `wallets/`         |                       | [Contains wallets](#multi-wallet-environment); can be specified by `-walletdir` option; if `wallets/` subdirectory does not exist, wallets reside in the [data directory](#data-directory-location)\n `./`               | `anchors.dat`         | Anchor IP address database, created on shutdown and deleted at startup. Anchors are last known outgoing block-relay-only peers that are tried to re-connect to on startup\n-`./`               | `banlist.dat`         | Stores the addresses/subnets of banned nodes (deprecated). `bitcoind` or `bitcoin-qt` no longer save the banlist to this file, but read it on startup if `banlist.json` is not present.\n `./`               | `banlist.json`        | Stores the addresses/subnets of banned nodes.\n `./`               | `bitcoin.conf`        | User-defined [configuration settings](bitcoin-conf.md) for `bitcoind` or `bitcoin-qt`. File is not written to by the software and must be created manually. Path can be specified by `-conf` option\n `./`               | `bitcoind.pid`        | Stores the process ID (PID) of `bitcoind` or `bitcoin-qt` while running; created at start and deleted on shutdown; can be specified by `-pid` option\n@@ -114,6 +113,7 @@ These subdirectories and files are no longer used by Bitcoin Core:\n \n Path           | Description | Repository notes\n ---------------|-------------|-----------------\n+`banlist.dat`  | Stores the addresses/subnets of banned nodes; superseded by `banlist.json` in 22.0 and completely ignored in 23.0 | [PR #20966](https://github.com/bitcoin/bitcoin/pull/20966), [PR #22570](https://github.com/bitcoin/bitcoin/pull/22570)\n `blktree/`     | Blockchain index; replaced by `blocks/index/` in [0.8.0](https://github.com/bitcoin/bitcoin/blob/master/doc/release-notes/release-notes-0.8.0.md#improvements) | [PR #2231](https://github.com/bitcoin/bitcoin/pull/2231), [`8fdc94cc`](https://github.com/bitcoin/bitcoin/commit/8fdc94cc8f0341e96b1edb3a5b56811c0b20bd15)\n `coins/`       | Unspent transaction output database; replaced by `chainstate/` in 0.8.0 | [PR #2231](https://github.com/bitcoin/bitcoin/pull/2231), [`8fdc94cc`](https://github.com/bitcoin/bitcoin/commit/8fdc94cc8f0341e96b1edb3a5b56811c0b20bd15)\n `blkindex.dat` | Blockchain index BDB database; replaced by {`chainstate/`, `blocks/index/`, `blocks/revNNNNN.dat`<sup>[\\[2\\]](#note2)</sup>} in 0.8.0 | [PR #1677](https://github.com/bitcoin/bitcoin/pull/1677)"
      },
      {
        "sha": "c3e224ee83de84c5924bcd61f95ce9359e0bca70",
        "filename": "src/addrdb.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa384fdd0b7af73d81fa9619c5fba779452cd2af/src/addrdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa384fdd0b7af73d81fa9619c5fba779452cd2af/src/addrdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.cpp?ref=fa384fdd0b7af73d81fa9619c5fba779452cd2af",
        "patch": "@@ -197,17 +197,16 @@ bool CBanDB::Write(const banmap_t& banSet)\n     return false;\n }\n \n-bool CBanDB::Read(banmap_t& banSet, bool& dirty)\n+bool CBanDB::Read(banmap_t& banSet)\n {\n-    // If the JSON banlist does not exist, then try to read the non-upgraded banlist.dat.\n+    if (fs::exists(m_banlist_dat)) {\n+        LogPrintf(\"banlist.dat ignored because it can only be read by \" PACKAGE_NAME \" version 22.x. Remove %s to silence this warning.\\n\", m_banlist_dat);\n+    }\n+    // If the JSON banlist does not exist, then recreate it\n     if (!fs::exists(m_banlist_json)) {\n-        // If this succeeds then we need to flush to disk in order to create the JSON banlist.\n-        dirty = true;\n-        return DeserializeFileDB(m_banlist_dat, banSet, CLIENT_VERSION);\n+        return false;\n     }\n \n-    dirty = false;\n-\n     std::map<std::string, util::SettingsValue> settings;\n     std::vector<std::string> errors;\n "
      },
      {
        "sha": "1e0ccb1f60b7f1715a550e1f0e76eb45277f04ad",
        "filename": "src/addrdb.h",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa384fdd0b7af73d81fa9619c5fba779452cd2af/src/addrdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa384fdd0b7af73d81fa9619c5fba779452cd2af/src/addrdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.h?ref=fa384fdd0b7af73d81fa9619c5fba779452cd2af",
        "patch": "@@ -76,7 +76,7 @@ class CAddrDB\n     static bool Read(CAddrMan& addr, CDataStream& ssPeers);\n };\n \n-/** Access to the banlist databases (banlist.json and banlist.dat) */\n+/** Access to the banlist database (banlist.json) */\n class CBanDB\n {\n private:\n@@ -95,11 +95,9 @@ class CBanDB\n      * Read the banlist from disk.\n      * @param[out] banSet The loaded list. Set if `true` is returned, otherwise it is left\n      * in an undefined state.\n-     * @param[out] dirty Indicates whether the loaded list needs flushing to disk. Set if\n-     * `true` is returned, otherwise it is left in an undefined state.\n      * @return true on success\n      */\n-    bool Read(banmap_t& banSet, bool& dirty);\n+    bool Read(banmap_t& banSet);\n };\n \n /**"
      },
      {
        "sha": "c64a48a05ac9d6db308d0974a0d69b85875356d8",
        "filename": "src/banman.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa384fdd0b7af73d81fa9619c5fba779452cd2af/src/banman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa384fdd0b7af73d81fa9619c5fba779452cd2af/src/banman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/banman.cpp?ref=fa384fdd0b7af73d81fa9619c5fba779452cd2af",
        "patch": "@@ -18,7 +18,7 @@ BanMan::BanMan(fs::path ban_file, CClientUIInterface* client_interface, int64_t\n     if (m_client_interface) m_client_interface->InitMessage(_(\"Loading banlist\u2026\").translated);\n \n     int64_t n_start = GetTimeMillis();\n-    if (m_ban_db.Read(m_banned, m_is_dirty)) {\n+    if (m_ban_db.Read(m_banned)) {\n         SweepBanned(); // sweep out unused entries\n \n         LogPrint(BCLog::NET, \"Loaded %d banned node addresses/subnets  %dms\\n\", m_banned.size(),"
      },
      {
        "sha": "8a03a9e3fcbaef53c92b21c8dd394687290d39e4",
        "filename": "src/banman.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa384fdd0b7af73d81fa9619c5fba779452cd2af/src/banman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa384fdd0b7af73d81fa9619c5fba779452cd2af/src/banman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/banman.h?ref=fa384fdd0b7af73d81fa9619c5fba779452cd2af",
        "patch": "@@ -88,7 +88,7 @@ class BanMan\n \n     RecursiveMutex m_cs_banned;\n     banmap_t m_banned GUARDED_BY(m_cs_banned);\n-    bool m_is_dirty GUARDED_BY(m_cs_banned);\n+    bool m_is_dirty GUARDED_BY(m_cs_banned){false};\n     CClientUIInterface* m_client_interface = nullptr;\n     CBanDB m_ban_db;\n     const int64_t m_default_ban_time;"
      },
      {
        "sha": "de211f601fa0edb28c9b5bf79d87ff476f0067fb",
        "filename": "src/test/fuzz/banman.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa384fdd0b7af73d81fa9619c5fba779452cd2af/src/test/fuzz/banman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa384fdd0b7af73d81fa9619c5fba779452cd2af/src/test/fuzz/banman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/banman.cpp?ref=fa384fdd0b7af73d81fa9619c5fba779452cd2af",
        "patch": "@@ -52,8 +52,7 @@ FUZZ_TARGET_INIT(banman, initialize_banman)\n     const bool start_with_corrupted_banlist{fuzzed_data_provider.ConsumeBool()};\n     bool force_read_and_write_to_err{false};\n     if (start_with_corrupted_banlist) {\n-        const std::string sfx{fuzzed_data_provider.ConsumeBool() ? \".dat\" : \".json\"};\n-        assert(WriteBinaryFile(banlist_file.string() + sfx,\n+        assert(WriteBinaryFile(banlist_file.string() + \".json\",\n                                fuzzed_data_provider.ConsumeRandomLengthString()));\n     } else {\n         force_read_and_write_to_err = fuzzed_data_provider.ConsumeBool();\n@@ -114,6 +113,5 @@ FUZZ_TARGET_INIT(banman, initialize_banman)\n             (void)(banmap == banmap_read);\n         }\n     }\n-    fs::remove(banlist_file.string() + \".dat\");\n     fs::remove(banlist_file.string() + \".json\");\n }"
      }
    ]
  },
  {
    "sha": "fa4e6afdae7b82df638b60edf37ac36d57a8cb4f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTRlNmFmZGFlN2I4MmRmNjM4YjYwZWRmMzdhYzM2ZDU3YThjYjRm",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-07-28T17:52:14Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-07-30T09:24:41Z"
      },
      "message": "Remove unused CSubNet serialize code",
      "tree": {
        "sha": "716dcf16ea1a32b2d1ce70199752b5bedfe64140",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/716dcf16ea1a32b2d1ce70199752b5bedfe64140"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa4e6afdae7b82df638b60edf37ac36d57a8cb4f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUhh2wv/TbSAbo5QPYc+DXbyVHxPXHluP+Ng+WjK+SO1qFXlhqkakNhUWTZzh12C\nFcdJZNKAsLPWTP588EAorUD1+o1jnCZgSR9cAQhKLKGr4IiE1nUIcNirUyC9IZ/f\njuVFhkuJA7kErk6MTe5wm+omv49yjQ+R6oJtAifdcb/obBjlFcO7/DMgPLtLaEgS\nAS+JvDzXGBTJ/PGYLlFzRaAKltEjqh/BFfccgG++HMCtYks7R08uKbDDFfnRbb2D\n8GDobF7Sq54SPYkZ9kCNKr6LZABsWrQQhycZDAkb9/3G2baZQ4644t7fifEMwfsF\nuqDZFbTYbrHyFmr0pid8GGJC3TCCzDuhKRnKgAq/bwmxdyi3pt5awt1IRNSZRnZ5\namzjWTPWg6aqk+7vNL0NPe4FvaR0qr1oaTiK0FVczXDjBYNXCYWkXzquyJ37MYUC\nWubeuTcymQmU2La3866b2OGBIxKZD/9YONk3HXv9iZ8jqbuVQL2HqFRZADczkzY8\nMhSZUUOB\n=a/6+\n-----END PGP SIGNATURE-----",
        "payload": "tree 716dcf16ea1a32b2d1ce70199752b5bedfe64140\nparent fa384fdd0b7af73d81fa9619c5fba779452cd2af\nauthor MarcoFalke <falke.marco@gmail.com> 1627494734 +0200\ncommitter MarcoFalke <falke.marco@gmail.com> 1627637081 +0200\n\nRemove unused CSubNet serialize code\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa4e6afdae7b82df638b60edf37ac36d57a8cb4f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa4e6afdae7b82df638b60edf37ac36d57a8cb4f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa4e6afdae7b82df638b60edf37ac36d57a8cb4f/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fa384fdd0b7af73d81fa9619c5fba779452cd2af",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa384fdd0b7af73d81fa9619c5fba779452cd2af",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fa384fdd0b7af73d81fa9619c5fba779452cd2af"
      }
    ],
    "stats": {
      "total": 29,
      "additions": 0,
      "deletions": 29
    },
    "files": [
      {
        "sha": "c81f9fd5d8f95ccd606ba9b40a24196996b00ecb",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 0,
        "deletions": 18,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa4e6afdae7b82df638b60edf37ac36d57a8cb4f/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa4e6afdae7b82df638b60edf37ac36d57a8cb4f/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=fa4e6afdae7b82df638b60edf37ac36d57a8cb4f",
        "patch": "@@ -536,24 +536,6 @@ class CSubNet\n         friend bool operator==(const CSubNet& a, const CSubNet& b);\n         friend bool operator!=(const CSubNet& a, const CSubNet& b) { return !(a == b); }\n         friend bool operator<(const CSubNet& a, const CSubNet& b);\n-\n-        SERIALIZE_METHODS(CSubNet, obj)\n-        {\n-            READWRITE(obj.network);\n-            if (obj.network.IsIPv4()) {\n-                // Before commit 102867c587f5f7954232fb8ed8e85cda78bb4d32, CSubNet used the last 4 bytes of netmask\n-                // to store the relevant bytes for an IPv4 mask. For compatibility reasons, keep doing so in\n-                // serialized form.\n-                unsigned char dummy[12] = {0};\n-                READWRITE(dummy);\n-                READWRITE(MakeSpan(obj.netmask).first(4));\n-            } else {\n-                READWRITE(obj.netmask);\n-            }\n-            READWRITE(obj.valid);\n-            // Mark invalid if the result doesn't pass sanity checking.\n-            SER_READ(obj, if (obj.valid) obj.valid = obj.SanityCheck());\n-        }\n };\n \n /** A combination of a network address (CNetAddr) and a (TCP) port */"
      },
      {
        "sha": "63f75bc9a05d9e79c073d7b72568b18b725db463",
        "filename": "src/test/fuzz/deserialize.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 11,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa4e6afdae7b82df638b60edf37ac36d57a8cb4f/src/test/fuzz/deserialize.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa4e6afdae7b82df638b60edf37ac36d57a8cb4f/src/test/fuzz/deserialize.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/deserialize.cpp?ref=fa4e6afdae7b82df638b60edf37ac36d57a8cb4f",
        "patch": "@@ -142,17 +142,6 @@ FUZZ_TARGET_DESERIALIZE(script_deserialize, {\n         CScript script;\n         DeserializeFromFuzzingInput(buffer, script);\n })\n-FUZZ_TARGET_DESERIALIZE(sub_net_deserialize, {\n-        CSubNet sub_net_1;\n-        DeserializeFromFuzzingInput(buffer, sub_net_1, INIT_PROTO_VERSION);\n-        AssertEqualAfterSerializeDeserialize(sub_net_1, INIT_PROTO_VERSION);\n-        CSubNet sub_net_2;\n-        DeserializeFromFuzzingInput(buffer, sub_net_2, INIT_PROTO_VERSION | ADDRV2_FORMAT);\n-        AssertEqualAfterSerializeDeserialize(sub_net_2, INIT_PROTO_VERSION | ADDRV2_FORMAT);\n-        CSubNet sub_net_3;\n-        DeserializeFromFuzzingInput(buffer, sub_net_3);\n-        AssertEqualAfterSerializeDeserialize(sub_net_3, INIT_PROTO_VERSION | ADDRV2_FORMAT);\n-})\n FUZZ_TARGET_DESERIALIZE(tx_in_deserialize, {\n         CTxIn tx_in;\n         DeserializeFromFuzzingInput(buffer, tx_in);"
      }
    ]
  },
  {
    "sha": "fa1eddb1a3d1319ddc3643b6f34fe2014de32764",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTFlZGRiMWEzZDEzMTlkZGMzNjQzYjZmMzRmZTIwMTRkZTMyNzY0",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-07-28T17:54:51Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-07-30T09:24:59Z"
      },
      "message": "Fix whitespace in touched files\n\nLeaving the incorrect indentation would be frustrating because:\n* Some editor may fix up the whitespace when editing a file, so before\n  commiting the whitespace changes need to be undone.\n* It makes it harder to use clang-format-diff on a change.\n\nCan be trivially reviewed with --word-diff-regex=. --ignore-all-space",
      "tree": {
        "sha": "4491bcf931a2815a5234fb37b95f51cfa21a12d4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4491bcf931a2815a5234fb37b95f51cfa21a12d4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa1eddb1a3d1319ddc3643b6f34fe2014de32764",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUiwIQwAirtMiF4R1dr+Hj7lp3WXH1PyuxjjRfCVdWhCgkvGJ7Hw/8LRK3Ui7Qk/\no49+Ps0NKUm/TmXUcMEqQLfrOI9cr7lV2LbnA+eNp2uETpL4CD4Zmq2QjRWZ2Icf\nr2oghTTy70Y4A6qFElBbseCzn8kKY7n6cwAtjQlz9vOlINCnMB+90362HpeqOzM7\nJqLsFvegI4oIddNJicF5GJ/nb6nqMn/LRz2iJn7/wFKbgmwOwjWXclztMGP8jBqz\ne2SpQGVcGzISOneGNt5FWvu/2hYIwZGdr1R3CHzi2j4yVFFbxZVF1bFS0iXNSvY3\nL56VuygoIpKUHhq8Dvm7ofdVCj8O8IHdiWQDlEDh0p/wcGtPDbrP1r+kHHpQz3C+\nLDw06L9zOxIyWNkq3Jz7Ls+bkGBTs8GI9PiNMvLF2l35gRW1DLlkSA7Bj04OarjQ\nxtxR2WMqfkjY94uQS9acXZaxmWPN4SBWcwPNq8uv7Nxuh8TYl0pn7qyRTNigw4p+\nug9nMSad\n=lb92\n-----END PGP SIGNATURE-----",
        "payload": "tree 4491bcf931a2815a5234fb37b95f51cfa21a12d4\nparent fa4e6afdae7b82df638b60edf37ac36d57a8cb4f\nauthor MarcoFalke <falke.marco@gmail.com> 1627494891 +0200\ncommitter MarcoFalke <falke.marco@gmail.com> 1627637099 +0200\n\nFix whitespace in touched files\n\nLeaving the incorrect indentation would be frustrating because:\n* Some editor may fix up the whitespace when editing a file, so before\n  commiting the whitespace changes need to be undone.\n* It makes it harder to use clang-format-diff on a change.\n\nCan be trivially reviewed with --word-diff-regex=. --ignore-all-space\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa1eddb1a3d1319ddc3643b6f34fe2014de32764",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa1eddb1a3d1319ddc3643b6f34fe2014de32764",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa1eddb1a3d1319ddc3643b6f34fe2014de32764/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fa4e6afdae7b82df638b60edf37ac36d57a8cb4f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa4e6afdae7b82df638b60edf37ac36d57a8cb4f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fa4e6afdae7b82df638b60edf37ac36d57a8cb4f"
      }
    ],
    "stats": {
      "total": 1079,
      "additions": 538,
      "deletions": 541
    },
    "files": [
      {
        "sha": "eb35ed3fac722d135388b6a3a61db94f2d4b0ba3",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 404,
        "deletions": 407,
        "changes": 811,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa1eddb1a3d1319ddc3643b6f34fe2014de32764/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa1eddb1a3d1319ddc3643b6f34fe2014de32764/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=fa1eddb1a3d1319ddc3643b6f34fe2014de32764",
        "patch": "@@ -42,8 +42,7 @@ static constexpr int ADDRV2_FORMAT = 0x20000000;\n  * over all enum values and also `GetExtNetwork()` \"extends\" this enum by\n  * introducing standalone constants starting from `NET_MAX`.\n  */\n-enum Network\n-{\n+enum Network {\n     /// Addresses from these networks are not publicly routable on the global Internet.\n     NET_UNROUTABLE = 0,\n \n@@ -73,16 +72,14 @@ enum Network\n /// Prefix of an IPv6 address when it contains an embedded IPv4 address.\n /// Used when (un)serializing addresses in ADDRv1 format (pre-BIP155).\n static const std::array<uint8_t, 12> IPV4_IN_IPV6_PREFIX{\n-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF\n-};\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF};\n \n /// Prefix of an IPv6 address when it contains an embedded TORv2 address.\n /// Used when (un)serializing addresses in ADDRv1 format (pre-BIP155).\n /// Such dummy IPv6 addresses are guaranteed to not be publicly routable as they\n /// fall under RFC4193's fc00::/7 subnet allocated to unique-local addresses.\n static const std::array<uint8_t, 6> TORV2_IN_IPV6_PREFIX{\n-    0xFD, 0x87, 0xD8, 0x7E, 0xEB, 0x43\n-};\n+    0xFD, 0x87, 0xD8, 0x7E, 0xEB, 0x43};\n \n /// Prefix of an IPv6 address when it contains an embedded \"internal\" address.\n /// Used when (un)serializing addresses in ADDRv1 format (pre-BIP155).\n@@ -120,354 +117,354 @@ static constexpr uint16_t I2P_SAM31_PORT{0};\n  */\n class CNetAddr\n {\n-    protected:\n-        /**\n-         * Raw representation of the network address.\n-         * In network byte order (big endian) for IPv4 and IPv6.\n-         */\n-        prevector<ADDR_IPV6_SIZE, uint8_t> m_addr{ADDR_IPV6_SIZE, 0x0};\n-\n-        /**\n-         * Network to which this address belongs.\n-         */\n-        Network m_net{NET_IPV6};\n-\n-        /**\n-         * Scope id if scoped/link-local IPV6 address.\n-         * See https://tools.ietf.org/html/rfc4007\n-         */\n-        uint32_t m_scope_id{0};\n-\n-    public:\n-        CNetAddr();\n-        explicit CNetAddr(const struct in_addr& ipv4Addr);\n-        void SetIP(const CNetAddr& ip);\n-\n-        /**\n-         * Set from a legacy IPv6 address.\n-         * Legacy IPv6 address may be a normal IPv6 address, or another address\n-         * (e.g. IPv4) disguised as IPv6. This encoding is used in the legacy\n-         * `addr` encoding.\n-         */\n-        void SetLegacyIPv6(Span<const uint8_t> ipv6);\n-\n-        bool SetInternal(const std::string& name);\n-\n-        /**\n-         * Parse a Tor or I2P address and set this object to it.\n-         * @param[in] addr Address to parse, for example\n-         * pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscryd.onion or\n-         * ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p.\n-         * @returns Whether the operation was successful.\n-         * @see CNetAddr::IsTor(), CNetAddr::IsI2P()\n-         */\n-        bool SetSpecial(const std::string& addr);\n-\n-        bool IsBindAny() const; // INADDR_ANY equivalent\n-        bool IsIPv4() const;    // IPv4 mapped address (::FFFF:0:0/96, 0.0.0.0/0)\n-        bool IsIPv6() const;    // IPv6 address (not mapped IPv4, not Tor)\n-        bool IsRFC1918() const; // IPv4 private networks (10.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12)\n-        bool IsRFC2544() const; // IPv4 inter-network communications (198.18.0.0/15)\n-        bool IsRFC6598() const; // IPv4 ISP-level NAT (100.64.0.0/10)\n-        bool IsRFC5737() const; // IPv4 documentation addresses (192.0.2.0/24, 198.51.100.0/24, 203.0.113.0/24)\n-        bool IsRFC3849() const; // IPv6 documentation address (2001:0DB8::/32)\n-        bool IsRFC3927() const; // IPv4 autoconfig (169.254.0.0/16)\n-        bool IsRFC3964() const; // IPv6 6to4 tunnelling (2002::/16)\n-        bool IsRFC4193() const; // IPv6 unique local (FC00::/7)\n-        bool IsRFC4380() const; // IPv6 Teredo tunnelling (2001::/32)\n-        bool IsRFC4843() const; // IPv6 ORCHID (deprecated) (2001:10::/28)\n-        bool IsRFC7343() const; // IPv6 ORCHIDv2 (2001:20::/28)\n-        bool IsRFC4862() const; // IPv6 autoconfig (FE80::/64)\n-        bool IsRFC6052() const; // IPv6 well-known prefix for IPv4-embedded address (64:FF9B::/96)\n-        bool IsRFC6145() const; // IPv6 IPv4-translated address (::FFFF:0:0:0/96) (actually defined in RFC2765)\n-        bool IsHeNet() const;   // IPv6 Hurricane Electric - https://he.net (2001:0470::/36)\n-        bool IsTor() const;\n-        bool IsI2P() const;\n-        bool IsCJDNS() const;\n-        bool IsLocal() const;\n-        bool IsRoutable() const;\n-        bool IsInternal() const;\n-        bool IsValid() const;\n-\n-        /**\n-         * Check if the current object can be serialized in pre-ADDRv2/BIP155 format.\n-         */\n-        bool IsAddrV1Compatible() const;\n-\n-        enum Network GetNetwork() const;\n-        std::string ToString() const;\n-        std::string ToStringIP() const;\n-        uint64_t GetHash() const;\n-        bool GetInAddr(struct in_addr* pipv4Addr) const;\n-        Network GetNetClass() const;\n-\n-        //! For IPv4, mapped IPv4, SIIT translated IPv4, Teredo, 6to4 tunneled addresses, return the relevant IPv4 address as a uint32.\n-        uint32_t GetLinkedIPv4() const;\n-        //! Whether this address has a linked IPv4 address (see GetLinkedIPv4()).\n-        bool HasLinkedIPv4() const;\n-\n-        // The AS on the BGP path to the node we use to diversify\n-        // peers in AddrMan bucketing based on the AS infrastructure.\n-        // The ip->AS mapping depends on how asmap is constructed.\n-        uint32_t GetMappedAS(const std::vector<bool> &asmap) const;\n-\n-        std::vector<unsigned char> GetGroup(const std::vector<bool> &asmap) const;\n-        std::vector<unsigned char> GetAddrBytes() const;\n-        int GetReachabilityFrom(const CNetAddr *paddrPartner = nullptr) const;\n-\n-        explicit CNetAddr(const struct in6_addr& pipv6Addr, const uint32_t scope = 0);\n-        bool GetIn6Addr(struct in6_addr* pipv6Addr) const;\n-\n-        friend bool operator==(const CNetAddr& a, const CNetAddr& b);\n-        friend bool operator!=(const CNetAddr& a, const CNetAddr& b) { return !(a == b); }\n-        friend bool operator<(const CNetAddr& a, const CNetAddr& b);\n-\n-        /**\n-         * Whether this address should be relayed to other peers even if we can't reach it ourselves.\n-         */\n-        bool IsRelayable() const\n-        {\n-            return IsIPv4() || IsIPv6() || IsTor() || IsI2P();\n-        }\n+protected:\n+    /**\n+     * Raw representation of the network address.\n+     * In network byte order (big endian) for IPv4 and IPv6.\n+     */\n+    prevector<ADDR_IPV6_SIZE, uint8_t> m_addr{ADDR_IPV6_SIZE, 0x0};\n+\n+    /**\n+     * Network to which this address belongs.\n+     */\n+    Network m_net{NET_IPV6};\n+\n+    /**\n+     * Scope id if scoped/link-local IPV6 address.\n+     * See https://tools.ietf.org/html/rfc4007\n+     */\n+    uint32_t m_scope_id{0};\n \n-        /**\n-         * Serialize to a stream.\n-         */\n-        template <typename Stream>\n-        void Serialize(Stream& s) const\n-        {\n-            if (s.GetVersion() & ADDRV2_FORMAT) {\n-                SerializeV2Stream(s);\n-            } else {\n-                SerializeV1Stream(s);\n-            }\n-        }\n+public:\n+    CNetAddr();\n+    explicit CNetAddr(const struct in_addr& ipv4Addr);\n+    void SetIP(const CNetAddr& ip);\n+\n+    /**\n+     * Set from a legacy IPv6 address.\n+     * Legacy IPv6 address may be a normal IPv6 address, or another address\n+     * (e.g. IPv4) disguised as IPv6. This encoding is used in the legacy\n+     * `addr` encoding.\n+     */\n+    void SetLegacyIPv6(Span<const uint8_t> ipv6);\n+\n+    bool SetInternal(const std::string& name);\n+\n+    /**\n+     * Parse a Tor or I2P address and set this object to it.\n+     * @param[in] addr Address to parse, for example\n+     * pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscryd.onion or\n+     * ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p.\n+     * @returns Whether the operation was successful.\n+     * @see CNetAddr::IsTor(), CNetAddr::IsI2P()\n+     */\n+    bool SetSpecial(const std::string& addr);\n+\n+    bool IsBindAny() const; // INADDR_ANY equivalent\n+    bool IsIPv4() const;    // IPv4 mapped address (::FFFF:0:0/96, 0.0.0.0/0)\n+    bool IsIPv6() const;    // IPv6 address (not mapped IPv4, not Tor)\n+    bool IsRFC1918() const; // IPv4 private networks (10.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12)\n+    bool IsRFC2544() const; // IPv4 inter-network communications (198.18.0.0/15)\n+    bool IsRFC6598() const; // IPv4 ISP-level NAT (100.64.0.0/10)\n+    bool IsRFC5737() const; // IPv4 documentation addresses (192.0.2.0/24, 198.51.100.0/24, 203.0.113.0/24)\n+    bool IsRFC3849() const; // IPv6 documentation address (2001:0DB8::/32)\n+    bool IsRFC3927() const; // IPv4 autoconfig (169.254.0.0/16)\n+    bool IsRFC3964() const; // IPv6 6to4 tunnelling (2002::/16)\n+    bool IsRFC4193() const; // IPv6 unique local (FC00::/7)\n+    bool IsRFC4380() const; // IPv6 Teredo tunnelling (2001::/32)\n+    bool IsRFC4843() const; // IPv6 ORCHID (deprecated) (2001:10::/28)\n+    bool IsRFC7343() const; // IPv6 ORCHIDv2 (2001:20::/28)\n+    bool IsRFC4862() const; // IPv6 autoconfig (FE80::/64)\n+    bool IsRFC6052() const; // IPv6 well-known prefix for IPv4-embedded address (64:FF9B::/96)\n+    bool IsRFC6145() const; // IPv6 IPv4-translated address (::FFFF:0:0:0/96) (actually defined in RFC2765)\n+    bool IsHeNet() const;   // IPv6 Hurricane Electric - https://he.net (2001:0470::/36)\n+    bool IsTor() const;\n+    bool IsI2P() const;\n+    bool IsCJDNS() const;\n+    bool IsLocal() const;\n+    bool IsRoutable() const;\n+    bool IsInternal() const;\n+    bool IsValid() const;\n+\n+    /**\n+     * Check if the current object can be serialized in pre-ADDRv2/BIP155 format.\n+     */\n+    bool IsAddrV1Compatible() const;\n+\n+    enum Network GetNetwork() const;\n+    std::string ToString() const;\n+    std::string ToStringIP() const;\n+    uint64_t GetHash() const;\n+    bool GetInAddr(struct in_addr* pipv4Addr) const;\n+    Network GetNetClass() const;\n+\n+    //! For IPv4, mapped IPv4, SIIT translated IPv4, Teredo, 6to4 tunneled addresses, return the relevant IPv4 address as a uint32.\n+    uint32_t GetLinkedIPv4() const;\n+    //! Whether this address has a linked IPv4 address (see GetLinkedIPv4()).\n+    bool HasLinkedIPv4() const;\n+\n+    // The AS on the BGP path to the node we use to diversify\n+    // peers in AddrMan bucketing based on the AS infrastructure.\n+    // The ip->AS mapping depends on how asmap is constructed.\n+    uint32_t GetMappedAS(const std::vector<bool>& asmap) const;\n+\n+    std::vector<unsigned char> GetGroup(const std::vector<bool>& asmap) const;\n+    std::vector<unsigned char> GetAddrBytes() const;\n+    int GetReachabilityFrom(const CNetAddr* paddrPartner = nullptr) const;\n+\n+    explicit CNetAddr(const struct in6_addr& pipv6Addr, const uint32_t scope = 0);\n+    bool GetIn6Addr(struct in6_addr* pipv6Addr) const;\n+\n+    friend bool operator==(const CNetAddr& a, const CNetAddr& b);\n+    friend bool operator!=(const CNetAddr& a, const CNetAddr& b) { return !(a == b); }\n+    friend bool operator<(const CNetAddr& a, const CNetAddr& b);\n+\n+    /**\n+     * Whether this address should be relayed to other peers even if we can't reach it ourselves.\n+     */\n+    bool IsRelayable() const\n+    {\n+        return IsIPv4() || IsIPv6() || IsTor() || IsI2P();\n+    }\n \n-        /**\n-         * Unserialize from a stream.\n-         */\n-        template <typename Stream>\n-        void Unserialize(Stream& s)\n-        {\n-            if (s.GetVersion() & ADDRV2_FORMAT) {\n-                UnserializeV2Stream(s);\n-            } else {\n-                UnserializeV1Stream(s);\n-            }\n+    /**\n+     * Serialize to a stream.\n+     */\n+    template <typename Stream>\n+    void Serialize(Stream& s) const\n+    {\n+        if (s.GetVersion() & ADDRV2_FORMAT) {\n+            SerializeV2Stream(s);\n+        } else {\n+            SerializeV1Stream(s);\n         }\n+    }\n \n-        friend class CNetAddrHash;\n-        friend class CSubNet;\n-\n-    private:\n-        /**\n-         * Parse a Tor address and set this object to it.\n-         * @param[in] addr Address to parse, must be a valid C string, for example\n-         * pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscryd.onion.\n-         * @returns Whether the operation was successful.\n-         * @see CNetAddr::IsTor()\n-         */\n-        bool SetTor(const std::string& addr);\n-\n-        /**\n-         * Parse an I2P address and set this object to it.\n-         * @param[in] addr Address to parse, must be a valid C string, for example\n-         * ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p.\n-         * @returns Whether the operation was successful.\n-         * @see CNetAddr::IsI2P()\n-         */\n-        bool SetI2P(const std::string& addr);\n-\n-        /**\n-         * BIP155 network ids recognized by this software.\n-         */\n-        enum BIP155Network : uint8_t {\n-            IPV4 = 1,\n-            IPV6 = 2,\n-            TORV2 = 3,\n-            TORV3 = 4,\n-            I2P = 5,\n-            CJDNS = 6,\n-        };\n-\n-        /**\n-         * Size of CNetAddr when serialized as ADDRv1 (pre-BIP155) (in bytes).\n-         */\n-        static constexpr size_t V1_SERIALIZATION_SIZE = ADDR_IPV6_SIZE;\n-\n-        /**\n-         * Maximum size of an address as defined in BIP155 (in bytes).\n-         * This is only the size of the address, not the entire CNetAddr object\n-         * when serialized.\n-         */\n-        static constexpr size_t MAX_ADDRV2_SIZE = 512;\n-\n-        /**\n-         * Get the BIP155 network id of this address.\n-         * Must not be called for IsInternal() objects.\n-         * @returns BIP155 network id, except TORV2 which is no longer supported.\n-         */\n-        BIP155Network GetBIP155Network() const;\n-\n-        /**\n-         * Set `m_net` from the provided BIP155 network id and size after validation.\n-         * @retval true the network was recognized, is valid and `m_net` was set\n-         * @retval false not recognised (from future?) and should be silently ignored\n-         * @throws std::ios_base::failure if the network is one of the BIP155 founding\n-         * networks (id 1..6) with wrong address size.\n-         */\n-        bool SetNetFromBIP155Network(uint8_t possible_bip155_net, size_t address_size);\n-\n-        /**\n-         * Serialize in pre-ADDRv2/BIP155 format to an array.\n-         */\n-        void SerializeV1Array(uint8_t (&arr)[V1_SERIALIZATION_SIZE]) const\n-        {\n-            size_t prefix_size;\n-\n-            switch (m_net) {\n-            case NET_IPV6:\n-                assert(m_addr.size() == sizeof(arr));\n-                memcpy(arr, m_addr.data(), m_addr.size());\n-                return;\n-            case NET_IPV4:\n-                prefix_size = sizeof(IPV4_IN_IPV6_PREFIX);\n-                assert(prefix_size + m_addr.size() == sizeof(arr));\n-                memcpy(arr, IPV4_IN_IPV6_PREFIX.data(), prefix_size);\n-                memcpy(arr + prefix_size, m_addr.data(), m_addr.size());\n-                return;\n-            case NET_INTERNAL:\n-                prefix_size = sizeof(INTERNAL_IN_IPV6_PREFIX);\n-                assert(prefix_size + m_addr.size() == sizeof(arr));\n-                memcpy(arr, INTERNAL_IN_IPV6_PREFIX.data(), prefix_size);\n-                memcpy(arr + prefix_size, m_addr.data(), m_addr.size());\n-                return;\n-            case NET_ONION:\n-            case NET_I2P:\n-            case NET_CJDNS:\n-                break;\n-            case NET_UNROUTABLE:\n-            case NET_MAX:\n-                assert(false);\n-            } // no default case, so the compiler can warn about missing cases\n-\n-            // Serialize ONION, I2P and CJDNS as all-zeros.\n-            memset(arr, 0x0, V1_SERIALIZATION_SIZE);\n+    /**\n+     * Unserialize from a stream.\n+     */\n+    template <typename Stream>\n+    void Unserialize(Stream& s)\n+    {\n+        if (s.GetVersion() & ADDRV2_FORMAT) {\n+            UnserializeV2Stream(s);\n+        } else {\n+            UnserializeV1Stream(s);\n         }\n+    }\n \n-        /**\n-         * Serialize in pre-ADDRv2/BIP155 format to a stream.\n-         */\n-        template <typename Stream>\n-        void SerializeV1Stream(Stream& s) const\n-        {\n-            uint8_t serialized[V1_SERIALIZATION_SIZE];\n+    friend class CNetAddrHash;\n+    friend class CSubNet;\n \n-            SerializeV1Array(serialized);\n+private:\n+    /**\n+     * Parse a Tor address and set this object to it.\n+     * @param[in] addr Address to parse, must be a valid C string, for example\n+     * pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscryd.onion.\n+     * @returns Whether the operation was successful.\n+     * @see CNetAddr::IsTor()\n+     */\n+    bool SetTor(const std::string& addr);\n+\n+    /**\n+     * Parse an I2P address and set this object to it.\n+     * @param[in] addr Address to parse, must be a valid C string, for example\n+     * ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p.\n+     * @returns Whether the operation was successful.\n+     * @see CNetAddr::IsI2P()\n+     */\n+    bool SetI2P(const std::string& addr);\n+\n+    /**\n+     * BIP155 network ids recognized by this software.\n+     */\n+    enum BIP155Network : uint8_t {\n+        IPV4 = 1,\n+        IPV6 = 2,\n+        TORV2 = 3,\n+        TORV3 = 4,\n+        I2P = 5,\n+        CJDNS = 6,\n+    };\n+\n+    /**\n+     * Size of CNetAddr when serialized as ADDRv1 (pre-BIP155) (in bytes).\n+     */\n+    static constexpr size_t V1_SERIALIZATION_SIZE = ADDR_IPV6_SIZE;\n+\n+    /**\n+     * Maximum size of an address as defined in BIP155 (in bytes).\n+     * This is only the size of the address, not the entire CNetAddr object\n+     * when serialized.\n+     */\n+    static constexpr size_t MAX_ADDRV2_SIZE = 512;\n+\n+    /**\n+     * Get the BIP155 network id of this address.\n+     * Must not be called for IsInternal() objects.\n+     * @returns BIP155 network id, except TORV2 which is no longer supported.\n+     */\n+    BIP155Network GetBIP155Network() const;\n+\n+    /**\n+     * Set `m_net` from the provided BIP155 network id and size after validation.\n+     * @retval true the network was recognized, is valid and `m_net` was set\n+     * @retval false not recognised (from future?) and should be silently ignored\n+     * @throws std::ios_base::failure if the network is one of the BIP155 founding\n+     * networks (id 1..6) with wrong address size.\n+     */\n+    bool SetNetFromBIP155Network(uint8_t possible_bip155_net, size_t address_size);\n+\n+    /**\n+     * Serialize in pre-ADDRv2/BIP155 format to an array.\n+     */\n+    void SerializeV1Array(uint8_t (&arr)[V1_SERIALIZATION_SIZE]) const\n+    {\n+        size_t prefix_size;\n+\n+        switch (m_net) {\n+        case NET_IPV6:\n+            assert(m_addr.size() == sizeof(arr));\n+            memcpy(arr, m_addr.data(), m_addr.size());\n+            return;\n+        case NET_IPV4:\n+            prefix_size = sizeof(IPV4_IN_IPV6_PREFIX);\n+            assert(prefix_size + m_addr.size() == sizeof(arr));\n+            memcpy(arr, IPV4_IN_IPV6_PREFIX.data(), prefix_size);\n+            memcpy(arr + prefix_size, m_addr.data(), m_addr.size());\n+            return;\n+        case NET_INTERNAL:\n+            prefix_size = sizeof(INTERNAL_IN_IPV6_PREFIX);\n+            assert(prefix_size + m_addr.size() == sizeof(arr));\n+            memcpy(arr, INTERNAL_IN_IPV6_PREFIX.data(), prefix_size);\n+            memcpy(arr + prefix_size, m_addr.data(), m_addr.size());\n+            return;\n+        case NET_ONION:\n+        case NET_I2P:\n+        case NET_CJDNS:\n+            break;\n+        case NET_UNROUTABLE:\n+        case NET_MAX:\n+            assert(false);\n+        } // no default case, so the compiler can warn about missing cases\n+\n+        // Serialize ONION, I2P and CJDNS as all-zeros.\n+        memset(arr, 0x0, V1_SERIALIZATION_SIZE);\n+    }\n \n-            s << serialized;\n-        }\n+    /**\n+     * Serialize in pre-ADDRv2/BIP155 format to a stream.\n+     */\n+    template <typename Stream>\n+    void SerializeV1Stream(Stream& s) const\n+    {\n+        uint8_t serialized[V1_SERIALIZATION_SIZE];\n \n-        /**\n-         * Serialize as ADDRv2 / BIP155.\n-         */\n-        template <typename Stream>\n-        void SerializeV2Stream(Stream& s) const\n-        {\n-            if (IsInternal()) {\n-                // Serialize NET_INTERNAL as embedded in IPv6. We need to\n-                // serialize such addresses from addrman.\n-                s << static_cast<uint8_t>(BIP155Network::IPV6);\n-                s << COMPACTSIZE(ADDR_IPV6_SIZE);\n-                SerializeV1Stream(s);\n-                return;\n-            }\n+        SerializeV1Array(serialized);\n \n-            s << static_cast<uint8_t>(GetBIP155Network());\n-            s << m_addr;\n-        }\n+        s << serialized;\n+    }\n \n-        /**\n-         * Unserialize from a pre-ADDRv2/BIP155 format from an array.\n-         */\n-        void UnserializeV1Array(uint8_t (&arr)[V1_SERIALIZATION_SIZE])\n-        {\n-            // Use SetLegacyIPv6() so that m_net is set correctly. For example\n-            // ::FFFF:0102:0304 should be set as m_net=NET_IPV4 (1.2.3.4).\n-            SetLegacyIPv6(arr);\n+    /**\n+     * Serialize as ADDRv2 / BIP155.\n+     */\n+    template <typename Stream>\n+    void SerializeV2Stream(Stream& s) const\n+    {\n+        if (IsInternal()) {\n+            // Serialize NET_INTERNAL as embedded in IPv6. We need to\n+            // serialize such addresses from addrman.\n+            s << static_cast<uint8_t>(BIP155Network::IPV6);\n+            s << COMPACTSIZE(ADDR_IPV6_SIZE);\n+            SerializeV1Stream(s);\n+            return;\n         }\n \n-        /**\n-         * Unserialize from a pre-ADDRv2/BIP155 format from a stream.\n-         */\n-        template <typename Stream>\n-        void UnserializeV1Stream(Stream& s)\n-        {\n-            uint8_t serialized[V1_SERIALIZATION_SIZE];\n+        s << static_cast<uint8_t>(GetBIP155Network());\n+        s << m_addr;\n+    }\n+\n+    /**\n+     * Unserialize from a pre-ADDRv2/BIP155 format from an array.\n+     */\n+    void UnserializeV1Array(uint8_t (&arr)[V1_SERIALIZATION_SIZE])\n+    {\n+        // Use SetLegacyIPv6() so that m_net is set correctly. For example\n+        // ::FFFF:0102:0304 should be set as m_net=NET_IPV4 (1.2.3.4).\n+        SetLegacyIPv6(arr);\n+    }\n+\n+    /**\n+     * Unserialize from a pre-ADDRv2/BIP155 format from a stream.\n+     */\n+    template <typename Stream>\n+    void UnserializeV1Stream(Stream& s)\n+    {\n+        uint8_t serialized[V1_SERIALIZATION_SIZE];\n+\n+        s >> serialized;\n+\n+        UnserializeV1Array(serialized);\n+    }\n+\n+    /**\n+     * Unserialize from a ADDRv2 / BIP155 format.\n+     */\n+    template <typename Stream>\n+    void UnserializeV2Stream(Stream& s)\n+    {\n+        uint8_t bip155_net;\n+        s >> bip155_net;\n \n-            s >> serialized;\n+        size_t address_size;\n+        s >> COMPACTSIZE(address_size);\n \n-            UnserializeV1Array(serialized);\n+        if (address_size > MAX_ADDRV2_SIZE) {\n+            throw std::ios_base::failure(strprintf(\n+                \"Address too long: %u > %u\", address_size, MAX_ADDRV2_SIZE));\n         }\n \n-        /**\n-         * Unserialize from a ADDRv2 / BIP155 format.\n-         */\n-        template <typename Stream>\n-        void UnserializeV2Stream(Stream& s)\n-        {\n-            uint8_t bip155_net;\n-            s >> bip155_net;\n-\n-            size_t address_size;\n-            s >> COMPACTSIZE(address_size);\n-\n-            if (address_size > MAX_ADDRV2_SIZE) {\n-                throw std::ios_base::failure(strprintf(\n-                    \"Address too long: %u > %u\", address_size, MAX_ADDRV2_SIZE));\n+        m_scope_id = 0;\n+\n+        if (SetNetFromBIP155Network(bip155_net, address_size)) {\n+            m_addr.resize(address_size);\n+            s >> MakeSpan(m_addr);\n+\n+            if (m_net != NET_IPV6) {\n+                return;\n+            }\n+\n+            // Do some special checks on IPv6 addresses.\n+\n+            // Recognize NET_INTERNAL embedded in IPv6, such addresses are not\n+            // gossiped but could be coming from addrman, when unserializing from\n+            // disk.\n+            if (HasPrefix(m_addr, INTERNAL_IN_IPV6_PREFIX)) {\n+                m_net = NET_INTERNAL;\n+                memmove(m_addr.data(), m_addr.data() + INTERNAL_IN_IPV6_PREFIX.size(),\n+                        ADDR_INTERNAL_SIZE);\n+                m_addr.resize(ADDR_INTERNAL_SIZE);\n+                return;\n             }\n \n-            m_scope_id = 0;\n-\n-            if (SetNetFromBIP155Network(bip155_net, address_size)) {\n-                m_addr.resize(address_size);\n-                s >> MakeSpan(m_addr);\n-\n-                if (m_net != NET_IPV6) {\n-                    return;\n-                }\n-\n-                // Do some special checks on IPv6 addresses.\n-\n-                // Recognize NET_INTERNAL embedded in IPv6, such addresses are not\n-                // gossiped but could be coming from addrman, when unserializing from\n-                // disk.\n-                if (HasPrefix(m_addr, INTERNAL_IN_IPV6_PREFIX)) {\n-                    m_net = NET_INTERNAL;\n-                    memmove(m_addr.data(), m_addr.data() + INTERNAL_IN_IPV6_PREFIX.size(),\n-                            ADDR_INTERNAL_SIZE);\n-                    m_addr.resize(ADDR_INTERNAL_SIZE);\n-                    return;\n-                }\n-\n-                if (!HasPrefix(m_addr, IPV4_IN_IPV6_PREFIX) &&\n-                    !HasPrefix(m_addr, TORV2_IN_IPV6_PREFIX)) {\n-                    return;\n-                }\n-\n-                // IPv4 and TORv2 are not supposed to be embedded in IPv6 (like in V1\n-                // encoding). Unserialize as !IsValid(), thus ignoring them.\n-            } else {\n-                // If we receive an unknown BIP155 network id (from the future?) then\n-                // ignore the address - unserialize as !IsValid().\n-                s.ignore(address_size);\n+            if (!HasPrefix(m_addr, IPV4_IN_IPV6_PREFIX) &&\n+                !HasPrefix(m_addr, TORV2_IN_IPV6_PREFIX)) {\n+                return;\n             }\n \n-            // Mimic a default-constructed CNetAddr object which is !IsValid() and thus\n-            // will not be gossiped, but continue reading next addresses from the stream.\n-            m_net = NET_IPV6;\n-            m_addr.assign(ADDR_IPV6_SIZE, 0x0);\n+            // IPv4 and TORv2 are not supposed to be embedded in IPv6 (like in V1\n+            // encoding). Unserialize as !IsValid(), thus ignoring them.\n+        } else {\n+            // If we receive an unknown BIP155 network id (from the future?) then\n+            // ignore the address - unserialize as !IsValid().\n+            s.ignore(address_size);\n         }\n+\n+        // Mimic a default-constructed CNetAddr object which is !IsValid() and thus\n+        // will not be gossiped, but continue reading next addresses from the stream.\n+        m_net = NET_IPV6;\n+        m_addr.assign(ADDR_IPV6_SIZE, 0x0);\n+    }\n };\n \n class CNetAddrHash\n@@ -488,86 +485,86 @@ class CNetAddrHash\n \n class CSubNet\n {\n-    protected:\n-        /// Network (base) address\n-        CNetAddr network;\n-        /// Netmask, in network byte order\n-        uint8_t netmask[16];\n-        /// Is this value valid? (only used to signal parse errors)\n-        bool valid;\n-\n-        bool SanityCheck() const;\n-\n-    public:\n-        /**\n-         * Construct an invalid subnet (empty, `Match()` always returns false).\n-         */\n-        CSubNet();\n-\n-        /**\n-         * Construct from a given network start and number of bits (CIDR mask).\n-         * @param[in] addr Network start. Must be IPv4 or IPv6, otherwise an invalid subnet is\n-         * created.\n-         * @param[in] mask CIDR mask, must be in [0, 32] for IPv4 addresses and in [0, 128] for\n-         * IPv6 addresses. Otherwise an invalid subnet is created.\n-         */\n-        CSubNet(const CNetAddr& addr, uint8_t mask);\n-\n-        /**\n-         * Construct from a given network start and mask.\n-         * @param[in] addr Network start. Must be IPv4 or IPv6, otherwise an invalid subnet is\n-         * created.\n-         * @param[in] mask Network mask, must be of the same type as `addr` and not contain 0-bits\n-         * followed by 1-bits. Otherwise an invalid subnet is created.\n-         */\n-        CSubNet(const CNetAddr& addr, const CNetAddr& mask);\n-\n-        /**\n-         * Construct a single-host subnet.\n-         * @param[in] addr The sole address to be contained in the subnet, can also be non-IPv[46].\n-         */\n-        explicit CSubNet(const CNetAddr& addr);\n-\n-        bool Match(const CNetAddr &addr) const;\n-\n-        std::string ToString() const;\n-        bool IsValid() const;\n-\n-        friend bool operator==(const CSubNet& a, const CSubNet& b);\n-        friend bool operator!=(const CSubNet& a, const CSubNet& b) { return !(a == b); }\n-        friend bool operator<(const CSubNet& a, const CSubNet& b);\n+protected:\n+    /// Network (base) address\n+    CNetAddr network;\n+    /// Netmask, in network byte order\n+    uint8_t netmask[16];\n+    /// Is this value valid? (only used to signal parse errors)\n+    bool valid;\n+\n+    bool SanityCheck() const;\n+\n+public:\n+    /**\n+     * Construct an invalid subnet (empty, `Match()` always returns false).\n+     */\n+    CSubNet();\n+\n+    /**\n+     * Construct from a given network start and number of bits (CIDR mask).\n+     * @param[in] addr Network start. Must be IPv4 or IPv6, otherwise an invalid subnet is\n+     * created.\n+     * @param[in] mask CIDR mask, must be in [0, 32] for IPv4 addresses and in [0, 128] for\n+     * IPv6 addresses. Otherwise an invalid subnet is created.\n+     */\n+    CSubNet(const CNetAddr& addr, uint8_t mask);\n+\n+    /**\n+     * Construct from a given network start and mask.\n+     * @param[in] addr Network start. Must be IPv4 or IPv6, otherwise an invalid subnet is\n+     * created.\n+     * @param[in] mask Network mask, must be of the same type as `addr` and not contain 0-bits\n+     * followed by 1-bits. Otherwise an invalid subnet is created.\n+     */\n+    CSubNet(const CNetAddr& addr, const CNetAddr& mask);\n+\n+    /**\n+     * Construct a single-host subnet.\n+     * @param[in] addr The sole address to be contained in the subnet, can also be non-IPv[46].\n+     */\n+    explicit CSubNet(const CNetAddr& addr);\n+\n+    bool Match(const CNetAddr& addr) const;\n+\n+    std::string ToString() const;\n+    bool IsValid() const;\n+\n+    friend bool operator==(const CSubNet& a, const CSubNet& b);\n+    friend bool operator!=(const CSubNet& a, const CSubNet& b) { return !(a == b); }\n+    friend bool operator<(const CSubNet& a, const CSubNet& b);\n };\n \n /** A combination of a network address (CNetAddr) and a (TCP) port */\n class CService : public CNetAddr\n {\n-    protected:\n-        uint16_t port; // host order\n-\n-    public:\n-        CService();\n-        CService(const CNetAddr& ip, uint16_t port);\n-        CService(const struct in_addr& ipv4Addr, uint16_t port);\n-        explicit CService(const struct sockaddr_in& addr);\n-        uint16_t GetPort() const;\n-        bool GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const;\n-        bool SetSockAddr(const struct sockaddr* paddr);\n-        friend bool operator==(const CService& a, const CService& b);\n-        friend bool operator!=(const CService& a, const CService& b) { return !(a == b); }\n-        friend bool operator<(const CService& a, const CService& b);\n-        std::vector<unsigned char> GetKey() const;\n-        std::string ToString() const;\n-        std::string ToStringPort() const;\n-        std::string ToStringIPPort() const;\n-\n-        CService(const struct in6_addr& ipv6Addr, uint16_t port);\n-        explicit CService(const struct sockaddr_in6& addr);\n-\n-        SERIALIZE_METHODS(CService, obj)\n-        {\n-            READWRITEAS(CNetAddr, obj);\n-            READWRITE(Using<BigEndianFormatter<2>>(obj.port));\n-        }\n+protected:\n+    uint16_t port; // host order\n+\n+public:\n+    CService();\n+    CService(const CNetAddr& ip, uint16_t port);\n+    CService(const struct in_addr& ipv4Addr, uint16_t port);\n+    explicit CService(const struct sockaddr_in& addr);\n+    uint16_t GetPort() const;\n+    bool GetSockAddr(struct sockaddr* paddr, socklen_t* addrlen) const;\n+    bool SetSockAddr(const struct sockaddr* paddr);\n+    friend bool operator==(const CService& a, const CService& b);\n+    friend bool operator!=(const CService& a, const CService& b) { return !(a == b); }\n+    friend bool operator<(const CService& a, const CService& b);\n+    std::vector<unsigned char> GetKey() const;\n+    std::string ToString() const;\n+    std::string ToStringPort() const;\n+    std::string ToStringIPPort() const;\n+\n+    CService(const struct in6_addr& ipv6Addr, uint16_t port);\n+    explicit CService(const struct sockaddr_in6& addr);\n+\n+    SERIALIZE_METHODS(CService, obj)\n+    {\n+        READWRITEAS(CNetAddr, obj);\n+        READWRITE(Using<BigEndianFormatter<2>>(obj.port));\n+    }\n };\n \n bool SanityCheckASMap(const std::vector<bool>& asmap);"
      },
      {
        "sha": "d5b56cb7cd8fc14e98042e346a59d9ef8283c354",
        "filename": "src/test/fuzz/deserialize.cpp",
        "status": "modified",
        "additions": 134,
        "deletions": 134,
        "changes": 268,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa1eddb1a3d1319ddc3643b6f34fe2014de32764/src/test/fuzz/deserialize.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa1eddb1a3d1319ddc3643b6f34fe2014de32764/src/test/fuzz/deserialize.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/deserialize.cpp?ref=fa1eddb1a3d1319ddc3643b6f34fe2014de32764",
        "patch": "@@ -100,217 +100,217 @@ void AssertEqualAfterSerializeDeserialize(const T& obj, const int version = INIT\n } // namespace\n \n FUZZ_TARGET_DESERIALIZE(block_filter_deserialize, {\n-        BlockFilter block_filter;\n-        DeserializeFromFuzzingInput(buffer, block_filter);\n+    BlockFilter block_filter;\n+    DeserializeFromFuzzingInput(buffer, block_filter);\n })\n FUZZ_TARGET_DESERIALIZE(addr_info_deserialize, {\n-        CAddrInfo addr_info;\n-        DeserializeFromFuzzingInput(buffer, addr_info);\n+    CAddrInfo addr_info;\n+    DeserializeFromFuzzingInput(buffer, addr_info);\n })\n FUZZ_TARGET_DESERIALIZE(block_file_info_deserialize, {\n-        CBlockFileInfo block_file_info;\n-        DeserializeFromFuzzingInput(buffer, block_file_info);\n+    CBlockFileInfo block_file_info;\n+    DeserializeFromFuzzingInput(buffer, block_file_info);\n })\n FUZZ_TARGET_DESERIALIZE(block_header_and_short_txids_deserialize, {\n-        CBlockHeaderAndShortTxIDs block_header_and_short_txids;\n-        DeserializeFromFuzzingInput(buffer, block_header_and_short_txids);\n+    CBlockHeaderAndShortTxIDs block_header_and_short_txids;\n+    DeserializeFromFuzzingInput(buffer, block_header_and_short_txids);\n })\n FUZZ_TARGET_DESERIALIZE(fee_rate_deserialize, {\n-        CFeeRate fee_rate;\n-        DeserializeFromFuzzingInput(buffer, fee_rate);\n-        AssertEqualAfterSerializeDeserialize(fee_rate);\n+    CFeeRate fee_rate;\n+    DeserializeFromFuzzingInput(buffer, fee_rate);\n+    AssertEqualAfterSerializeDeserialize(fee_rate);\n })\n FUZZ_TARGET_DESERIALIZE(merkle_block_deserialize, {\n-        CMerkleBlock merkle_block;\n-        DeserializeFromFuzzingInput(buffer, merkle_block);\n+    CMerkleBlock merkle_block;\n+    DeserializeFromFuzzingInput(buffer, merkle_block);\n })\n FUZZ_TARGET_DESERIALIZE(out_point_deserialize, {\n-        COutPoint out_point;\n-        DeserializeFromFuzzingInput(buffer, out_point);\n-        AssertEqualAfterSerializeDeserialize(out_point);\n+    COutPoint out_point;\n+    DeserializeFromFuzzingInput(buffer, out_point);\n+    AssertEqualAfterSerializeDeserialize(out_point);\n })\n FUZZ_TARGET_DESERIALIZE(partial_merkle_tree_deserialize, {\n-        CPartialMerkleTree partial_merkle_tree;\n-        DeserializeFromFuzzingInput(buffer, partial_merkle_tree);\n+    CPartialMerkleTree partial_merkle_tree;\n+    DeserializeFromFuzzingInput(buffer, partial_merkle_tree);\n })\n FUZZ_TARGET_DESERIALIZE(pub_key_deserialize, {\n-        CPubKey pub_key;\n-        DeserializeFromFuzzingInput(buffer, pub_key);\n-        AssertEqualAfterSerializeDeserialize(pub_key);\n+    CPubKey pub_key;\n+    DeserializeFromFuzzingInput(buffer, pub_key);\n+    AssertEqualAfterSerializeDeserialize(pub_key);\n })\n FUZZ_TARGET_DESERIALIZE(script_deserialize, {\n-        CScript script;\n-        DeserializeFromFuzzingInput(buffer, script);\n+    CScript script;\n+    DeserializeFromFuzzingInput(buffer, script);\n })\n FUZZ_TARGET_DESERIALIZE(tx_in_deserialize, {\n-        CTxIn tx_in;\n-        DeserializeFromFuzzingInput(buffer, tx_in);\n-        AssertEqualAfterSerializeDeserialize(tx_in);\n+    CTxIn tx_in;\n+    DeserializeFromFuzzingInput(buffer, tx_in);\n+    AssertEqualAfterSerializeDeserialize(tx_in);\n })\n FUZZ_TARGET_DESERIALIZE(flat_file_pos_deserialize, {\n-        FlatFilePos flat_file_pos;\n-        DeserializeFromFuzzingInput(buffer, flat_file_pos);\n-        AssertEqualAfterSerializeDeserialize(flat_file_pos);\n+    FlatFilePos flat_file_pos;\n+    DeserializeFromFuzzingInput(buffer, flat_file_pos);\n+    AssertEqualAfterSerializeDeserialize(flat_file_pos);\n })\n FUZZ_TARGET_DESERIALIZE(key_origin_info_deserialize, {\n-        KeyOriginInfo key_origin_info;\n-        DeserializeFromFuzzingInput(buffer, key_origin_info);\n-        AssertEqualAfterSerializeDeserialize(key_origin_info);\n+    KeyOriginInfo key_origin_info;\n+    DeserializeFromFuzzingInput(buffer, key_origin_info);\n+    AssertEqualAfterSerializeDeserialize(key_origin_info);\n })\n FUZZ_TARGET_DESERIALIZE(partially_signed_transaction_deserialize, {\n-        PartiallySignedTransaction partially_signed_transaction;\n-        DeserializeFromFuzzingInput(buffer, partially_signed_transaction);\n+    PartiallySignedTransaction partially_signed_transaction;\n+    DeserializeFromFuzzingInput(buffer, partially_signed_transaction);\n })\n FUZZ_TARGET_DESERIALIZE(prefilled_transaction_deserialize, {\n-        PrefilledTransaction prefilled_transaction;\n-        DeserializeFromFuzzingInput(buffer, prefilled_transaction);\n+    PrefilledTransaction prefilled_transaction;\n+    DeserializeFromFuzzingInput(buffer, prefilled_transaction);\n })\n FUZZ_TARGET_DESERIALIZE(psbt_input_deserialize, {\n-        PSBTInput psbt_input;\n-        DeserializeFromFuzzingInput(buffer, psbt_input);\n+    PSBTInput psbt_input;\n+    DeserializeFromFuzzingInput(buffer, psbt_input);\n })\n FUZZ_TARGET_DESERIALIZE(psbt_output_deserialize, {\n-        PSBTOutput psbt_output;\n-        DeserializeFromFuzzingInput(buffer, psbt_output);\n+    PSBTOutput psbt_output;\n+    DeserializeFromFuzzingInput(buffer, psbt_output);\n })\n FUZZ_TARGET_DESERIALIZE(block_deserialize, {\n-        CBlock block;\n-        DeserializeFromFuzzingInput(buffer, block);\n+    CBlock block;\n+    DeserializeFromFuzzingInput(buffer, block);\n })\n FUZZ_TARGET_DESERIALIZE(blocklocator_deserialize, {\n-        CBlockLocator bl;\n-        DeserializeFromFuzzingInput(buffer, bl);\n+    CBlockLocator bl;\n+    DeserializeFromFuzzingInput(buffer, bl);\n })\n FUZZ_TARGET_DESERIALIZE(blockmerkleroot, {\n-        CBlock block;\n-        DeserializeFromFuzzingInput(buffer, block);\n-        bool mutated;\n-        BlockMerkleRoot(block, &mutated);\n+    CBlock block;\n+    DeserializeFromFuzzingInput(buffer, block);\n+    bool mutated;\n+    BlockMerkleRoot(block, &mutated);\n })\n FUZZ_TARGET_DESERIALIZE(addrman_deserialize, {\n-        CAddrMan am;\n-        DeserializeFromFuzzingInput(buffer, am);\n+    CAddrMan am;\n+    DeserializeFromFuzzingInput(buffer, am);\n })\n FUZZ_TARGET_DESERIALIZE(blockheader_deserialize, {\n-        CBlockHeader bh;\n-        DeserializeFromFuzzingInput(buffer, bh);\n+    CBlockHeader bh;\n+    DeserializeFromFuzzingInput(buffer, bh);\n })\n FUZZ_TARGET_DESERIALIZE(banentry_deserialize, {\n-        CBanEntry be;\n-        DeserializeFromFuzzingInput(buffer, be);\n+    CBanEntry be;\n+    DeserializeFromFuzzingInput(buffer, be);\n })\n FUZZ_TARGET_DESERIALIZE(txundo_deserialize, {\n-        CTxUndo tu;\n-        DeserializeFromFuzzingInput(buffer, tu);\n+    CTxUndo tu;\n+    DeserializeFromFuzzingInput(buffer, tu);\n })\n FUZZ_TARGET_DESERIALIZE(blockundo_deserialize, {\n-        CBlockUndo bu;\n-        DeserializeFromFuzzingInput(buffer, bu);\n+    CBlockUndo bu;\n+    DeserializeFromFuzzingInput(buffer, bu);\n })\n FUZZ_TARGET_DESERIALIZE(coins_deserialize, {\n-        Coin coin;\n-        DeserializeFromFuzzingInput(buffer, coin);\n+    Coin coin;\n+    DeserializeFromFuzzingInput(buffer, coin);\n })\n FUZZ_TARGET_DESERIALIZE(netaddr_deserialize, {\n-        CNetAddr na;\n-        DeserializeFromFuzzingInput(buffer, na);\n-        if (na.IsAddrV1Compatible()) {\n-            AssertEqualAfterSerializeDeserialize(na);\n-        }\n-        AssertEqualAfterSerializeDeserialize(na, INIT_PROTO_VERSION | ADDRV2_FORMAT);\n+    CNetAddr na;\n+    DeserializeFromFuzzingInput(buffer, na);\n+    if (na.IsAddrV1Compatible()) {\n+        AssertEqualAfterSerializeDeserialize(na);\n+    }\n+    AssertEqualAfterSerializeDeserialize(na, INIT_PROTO_VERSION | ADDRV2_FORMAT);\n })\n FUZZ_TARGET_DESERIALIZE(service_deserialize, {\n-        CService s;\n-        DeserializeFromFuzzingInput(buffer, s);\n-        if (s.IsAddrV1Compatible()) {\n-            AssertEqualAfterSerializeDeserialize(s);\n-        }\n-        AssertEqualAfterSerializeDeserialize(s, INIT_PROTO_VERSION | ADDRV2_FORMAT);\n-        CService s1;\n-        DeserializeFromFuzzingInput(buffer, s1, INIT_PROTO_VERSION);\n-        AssertEqualAfterSerializeDeserialize(s1, INIT_PROTO_VERSION);\n-        assert(s1.IsAddrV1Compatible());\n-        CService s2;\n-        DeserializeFromFuzzingInput(buffer, s2, INIT_PROTO_VERSION | ADDRV2_FORMAT);\n-        AssertEqualAfterSerializeDeserialize(s2, INIT_PROTO_VERSION | ADDRV2_FORMAT);\n+    CService s;\n+    DeserializeFromFuzzingInput(buffer, s);\n+    if (s.IsAddrV1Compatible()) {\n+        AssertEqualAfterSerializeDeserialize(s);\n+    }\n+    AssertEqualAfterSerializeDeserialize(s, INIT_PROTO_VERSION | ADDRV2_FORMAT);\n+    CService s1;\n+    DeserializeFromFuzzingInput(buffer, s1, INIT_PROTO_VERSION);\n+    AssertEqualAfterSerializeDeserialize(s1, INIT_PROTO_VERSION);\n+    assert(s1.IsAddrV1Compatible());\n+    CService s2;\n+    DeserializeFromFuzzingInput(buffer, s2, INIT_PROTO_VERSION | ADDRV2_FORMAT);\n+    AssertEqualAfterSerializeDeserialize(s2, INIT_PROTO_VERSION | ADDRV2_FORMAT);\n })\n FUZZ_TARGET_DESERIALIZE(messageheader_deserialize, {\n-        CMessageHeader mh;\n-        DeserializeFromFuzzingInput(buffer, mh);\n-        (void)mh.IsCommandValid();\n+    CMessageHeader mh;\n+    DeserializeFromFuzzingInput(buffer, mh);\n+    (void)mh.IsCommandValid();\n })\n FUZZ_TARGET_DESERIALIZE(address_deserialize_v1_notime, {\n-        CAddress a;\n-        DeserializeFromFuzzingInput(buffer, a, INIT_PROTO_VERSION);\n-        // A CAddress without nTime (as is expected under INIT_PROTO_VERSION) will roundtrip\n-        // in all 5 formats (with/without nTime, v1/v2, network/disk)\n-        AssertEqualAfterSerializeDeserialize(a, INIT_PROTO_VERSION);\n-        AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION);\n-        AssertEqualAfterSerializeDeserialize(a, 0, SER_DISK);\n-        AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION | ADDRV2_FORMAT);\n-        AssertEqualAfterSerializeDeserialize(a, ADDRV2_FORMAT, SER_DISK);\n+    CAddress a;\n+    DeserializeFromFuzzingInput(buffer, a, INIT_PROTO_VERSION);\n+    // A CAddress without nTime (as is expected under INIT_PROTO_VERSION) will roundtrip\n+    // in all 5 formats (with/without nTime, v1/v2, network/disk)\n+    AssertEqualAfterSerializeDeserialize(a, INIT_PROTO_VERSION);\n+    AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION);\n+    AssertEqualAfterSerializeDeserialize(a, 0, SER_DISK);\n+    AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION | ADDRV2_FORMAT);\n+    AssertEqualAfterSerializeDeserialize(a, ADDRV2_FORMAT, SER_DISK);\n })\n FUZZ_TARGET_DESERIALIZE(address_deserialize_v1_withtime, {\n-        CAddress a;\n-        DeserializeFromFuzzingInput(buffer, a, PROTOCOL_VERSION);\n-        // A CAddress in V1 mode will roundtrip in all 4 formats that have nTime.\n-        AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION);\n-        AssertEqualAfterSerializeDeserialize(a, 0, SER_DISK);\n-        AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION | ADDRV2_FORMAT);\n-        AssertEqualAfterSerializeDeserialize(a, ADDRV2_FORMAT, SER_DISK);\n+    CAddress a;\n+    DeserializeFromFuzzingInput(buffer, a, PROTOCOL_VERSION);\n+    // A CAddress in V1 mode will roundtrip in all 4 formats that have nTime.\n+    AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION);\n+    AssertEqualAfterSerializeDeserialize(a, 0, SER_DISK);\n+    AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION | ADDRV2_FORMAT);\n+    AssertEqualAfterSerializeDeserialize(a, ADDRV2_FORMAT, SER_DISK);\n })\n FUZZ_TARGET_DESERIALIZE(address_deserialize_v2, {\n-        CAddress a;\n-        DeserializeFromFuzzingInput(buffer, a, PROTOCOL_VERSION | ADDRV2_FORMAT);\n-        // A CAddress in V2 mode will roundtrip in both V2 formats, and also in the V1 formats\n-        // with time if it's V1 compatible.\n-        if (a.IsAddrV1Compatible()) {\n-            AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION);\n-            AssertEqualAfterSerializeDeserialize(a, 0, SER_DISK);\n-        }\n-        AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION | ADDRV2_FORMAT);\n-        AssertEqualAfterSerializeDeserialize(a, ADDRV2_FORMAT, SER_DISK);\n+    CAddress a;\n+    DeserializeFromFuzzingInput(buffer, a, PROTOCOL_VERSION | ADDRV2_FORMAT);\n+    // A CAddress in V2 mode will roundtrip in both V2 formats, and also in the V1 formats\n+    // with time if it's V1 compatible.\n+    if (a.IsAddrV1Compatible()) {\n+        AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION);\n+        AssertEqualAfterSerializeDeserialize(a, 0, SER_DISK);\n+    }\n+    AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION | ADDRV2_FORMAT);\n+    AssertEqualAfterSerializeDeserialize(a, ADDRV2_FORMAT, SER_DISK);\n })\n FUZZ_TARGET_DESERIALIZE(inv_deserialize, {\n-        CInv i;\n-        DeserializeFromFuzzingInput(buffer, i);\n+    CInv i;\n+    DeserializeFromFuzzingInput(buffer, i);\n })\n FUZZ_TARGET_DESERIALIZE(bloomfilter_deserialize, {\n-        CBloomFilter bf;\n-        DeserializeFromFuzzingInput(buffer, bf);\n+    CBloomFilter bf;\n+    DeserializeFromFuzzingInput(buffer, bf);\n })\n FUZZ_TARGET_DESERIALIZE(diskblockindex_deserialize, {\n-        CDiskBlockIndex dbi;\n-        DeserializeFromFuzzingInput(buffer, dbi);\n+    CDiskBlockIndex dbi;\n+    DeserializeFromFuzzingInput(buffer, dbi);\n })\n FUZZ_TARGET_DESERIALIZE(txoutcompressor_deserialize, {\n-        CTxOut to;\n-        auto toc = Using<TxOutCompression>(to);\n-        DeserializeFromFuzzingInput(buffer, toc);\n+    CTxOut to;\n+    auto toc = Using<TxOutCompression>(to);\n+    DeserializeFromFuzzingInput(buffer, toc);\n })\n FUZZ_TARGET_DESERIALIZE(blocktransactions_deserialize, {\n-        BlockTransactions bt;\n-        DeserializeFromFuzzingInput(buffer, bt);\n+    BlockTransactions bt;\n+    DeserializeFromFuzzingInput(buffer, bt);\n })\n FUZZ_TARGET_DESERIALIZE(blocktransactionsrequest_deserialize, {\n-        BlockTransactionsRequest btr;\n-        DeserializeFromFuzzingInput(buffer, btr);\n+    BlockTransactionsRequest btr;\n+    DeserializeFromFuzzingInput(buffer, btr);\n })\n FUZZ_TARGET_DESERIALIZE(snapshotmetadata_deserialize, {\n-        SnapshotMetadata snapshot_metadata;\n-        DeserializeFromFuzzingInput(buffer, snapshot_metadata);\n+    SnapshotMetadata snapshot_metadata;\n+    DeserializeFromFuzzingInput(buffer, snapshot_metadata);\n })\n FUZZ_TARGET_DESERIALIZE(uint160_deserialize, {\n-        uint160 u160;\n-        DeserializeFromFuzzingInput(buffer, u160);\n-        AssertEqualAfterSerializeDeserialize(u160);\n+    uint160 u160;\n+    DeserializeFromFuzzingInput(buffer, u160);\n+    AssertEqualAfterSerializeDeserialize(u160);\n })\n FUZZ_TARGET_DESERIALIZE(uint256_deserialize, {\n-        uint256 u256;\n-        DeserializeFromFuzzingInput(buffer, u256);\n-        AssertEqualAfterSerializeDeserialize(u256);\n-})\n-        // Classes intentionally not covered in this file since their deserialization code is\n-        // fuzzed elsewhere:\n-        // * Deserialization of CTxOut is fuzzed in test/fuzz/tx_out.cpp\n-        // * Deserialization of CMutableTransaction is fuzzed in src/test/fuzz/transaction.cpp\n+    uint256 u256;\n+    DeserializeFromFuzzingInput(buffer, u256);\n+    AssertEqualAfterSerializeDeserialize(u256);\n+})\n+// Classes intentionally not covered in this file since their deserialization code is\n+// fuzzed elsewhere:\n+// * Deserialization of CTxOut is fuzzed in test/fuzz/tx_out.cpp\n+// * Deserialization of CMutableTransaction is fuzzed in src/test/fuzz/transaction.cpp"
      }
    ]
  }
]