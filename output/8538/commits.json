[
  {
    "sha": "58ff2d8b8499d650c578662e5b229474b1dc9f86",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1OGZmMmQ4Yjg0OTlkNjUwYzU3ODY2MmU1YjIyOTQ3NGIxZGM5Zjg2",
    "commit": {
      "author": {
        "name": "MCCCS",
        "email": "mcccs@users.noreply.github.com",
        "date": "2016-08-19T10:22:23Z"
      },
      "committer": {
        "name": "MCCCS",
        "email": "mcccs@users.noreply.github.com",
        "date": "2016-08-19T10:22:23Z"
      },
      "message": "Remove IP transaction check",
      "tree": {
        "sha": "5f8b1aacf96e8899797f9f222555bd0620863f76",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5f8b1aacf96e8899797f9f222555bd0620863f76"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/58ff2d8b8499d650c578662e5b229474b1dc9f86",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/58ff2d8b8499d650c578662e5b229474b1dc9f86",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/58ff2d8b8499d650c578662e5b229474b1dc9f86",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/58ff2d8b8499d650c578662e5b229474b1dc9f86/comments",
    "author": {
      "login": "mcccs",
      "id": 43574227,
      "node_id": "MDQ6VXNlcjQzNTc0MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/43574227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mcccs",
      "html_url": "https://github.com/mcccs",
      "followers_url": "https://api.github.com/users/mcccs/followers",
      "following_url": "https://api.github.com/users/mcccs/following{/other_user}",
      "gists_url": "https://api.github.com/users/mcccs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mcccs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mcccs/subscriptions",
      "organizations_url": "https://api.github.com/users/mcccs/orgs",
      "repos_url": "https://api.github.com/users/mcccs/repos",
      "events_url": "https://api.github.com/users/mcccs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mcccs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mcccs",
      "id": 43574227,
      "node_id": "MDQ6VXNlcjQzNTc0MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/43574227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mcccs",
      "html_url": "https://github.com/mcccs",
      "followers_url": "https://api.github.com/users/mcccs/followers",
      "following_url": "https://api.github.com/users/mcccs/following{/other_user}",
      "gists_url": "https://api.github.com/users/mcccs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mcccs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mcccs/subscriptions",
      "organizations_url": "https://api.github.com/users/mcccs/orgs",
      "repos_url": "https://api.github.com/users/mcccs/repos",
      "events_url": "https://api.github.com/users/mcccs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mcccs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bc94b87487824c6fba45788facf96faba97a4aa6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bc94b87487824c6fba45788facf96faba97a4aa6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bc94b87487824c6fba45788facf96faba97a4aa6"
      }
    ],
    "stats": {
      "total": 281,
      "additions": 208,
      "deletions": 73
    },
    "files": [
      {
        "sha": "2afefb733edcf7112ed330738ab7566003a6b0f0",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 3,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=58ff2d8b8499d650c578662e5b229474b1dc9f86",
        "patch": "@@ -902,17 +902,22 @@ void BitcoinGUI::closeEvent(QCloseEvent *event)\n #ifndef Q_OS_MAC // Ignored on Mac\n     if(clientModel && clientModel->getOptionsModel())\n     {\n-        if(!clientModel->getOptionsModel()->getMinimizeToTray() &&\n-           !clientModel->getOptionsModel()->getMinimizeOnClose())\n+        if(!clientModel->getOptionsModel()->getMinimizeOnClose())\n         {\n             // close rpcConsole in case it was open to make some space for the shutdown window\n             rpcConsole->close();\n \n             QApplication::quit();\n         }\n+        else\n+        {\n+            QMainWindow::showMinimized();\n+            event->ignore();\n+        }\n     }\n-#endif\n+#else\n     QMainWindow::closeEvent(event);\n+#endif\n }\n \n void BitcoinGUI::showEvent(QShowEvent *event)"
      },
      {
        "sha": "bca5b72827f3120b59395fd84fa5f8183ead798c",
        "filename": "src/qt/bitcoinstrings.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/bitcoinstrings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/bitcoinstrings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoinstrings.cpp?ref=58ff2d8b8499d650c578662e5b229474b1dc9f86",
        "patch": "@@ -311,9 +311,8 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Send trace/debug info to console instead of d\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Send transactions as zero-fee transactions if possible (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Set database cache size in megabytes (%d to %d, default: %d)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Set key pool size to <n> (default: %u)\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Set maximum block cost (default: %d)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Set maximum BIP141 block cost (default: %d)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Set maximum block size in bytes (default: %d)\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Set minimum block size in bytes (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Set the number of threads to service RPC calls (default: %d)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Show all debugging options (usage: --help -help-debug)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Shrink debug.log file on client startup (default: 1 when no -debug)\"),"
      },
      {
        "sha": "2708324d172e137140cc6caf4c9a16d25ac2f324",
        "filename": "src/qt/locale/bitcoin_de.ts",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/locale/bitcoin_de.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/locale/bitcoin_de.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_de.ts?ref=58ff2d8b8499d650c578662e5b229474b1dc9f86",
        "patch": "@@ -2006,6 +2006,10 @@\n         <source>Only connect to nodes in network &lt;net&gt; (ipv4, ipv6 or onion)</source>\n         <translation>Nur zu Knoten des Netzwerktyps &lt;net&gt; verbinden (ipv4, ipv6 oder onion)</translation>\n     </message>\n+    <message>\n+        <source>Print this help message and exit</source>\n+        <translation>Drucke diese Hilfemeldung und beende</translation>\n+    </message>\n     <message>\n         <source>Print version and exit</source>\n         <translation>Gibt die Versionsnummer aus und beendet das Programm</translation>"
      },
      {
        "sha": "79c3e87b2b10aeb7be297e25e40bf1a3d4b77e3d",
        "filename": "src/qt/locale/bitcoin_en.ts",
        "status": "modified",
        "additions": 19,
        "deletions": 24,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/locale/bitcoin_en.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/locale/bitcoin_en.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_en.ts?ref=58ff2d8b8499d650c578662e5b229474b1dc9f86",
        "patch": "@@ -1218,12 +1218,12 @@\n         <translation type=\"unfinished\">Amount</translation>\n     </message>\n     <message>\n-        <location filename=\"../guiutil.cpp\" line=\"+118\"/>\n+        <location filename=\"../guiutil.cpp\" line=\"+135\"/>\n         <source>Enter a Bitcoin address (e.g. %1)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+763\"/>\n+        <location line=\"+764\"/>\n         <source>%1 d</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -2231,22 +2231,22 @@\n         <translation>Options:</translation>\n     </message>\n     <message>\n-        <location line=\"+31\"/>\n+        <location line=\"+30\"/>\n         <source>Specify data directory</source>\n         <translation>Specify data directory</translation>\n     </message>\n     <message>\n-        <location line=\"-90\"/>\n+        <location line=\"-89\"/>\n         <source>Connect to a node to retrieve peer addresses, and disconnect</source>\n         <translation>Connect to a node to retrieve peer addresses, and disconnect</translation>\n     </message>\n     <message>\n-        <location line=\"+93\"/>\n+        <location line=\"+92\"/>\n         <source>Specify your own public address</source>\n         <translation>Specify your own public address</translation>\n     </message>\n     <message>\n-        <location line=\"-109\"/>\n+        <location line=\"-108\"/>\n         <source>Accept command line and JSON-RPC commands</source>\n         <translation>Accept command line and JSON-RPC commands</translation>\n     </message>\n@@ -2296,12 +2296,12 @@\n         <translation>Run in the background as a daemon and accept commands</translation>\n     </message>\n     <message>\n-        <location line=\"+31\"/>\n+        <location line=\"+30\"/>\n         <source>Unable to start HTTP server. See debug log for details.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-122\"/>\n+        <location line=\"-121\"/>\n         <source>Accept connections from outside (default: 1 if no -proxy or -connect)</source>\n         <translation>Accept connections from outside (default: 1 if no -proxy or -connect)</translation>\n     </message>\n@@ -2686,17 +2686,12 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+2\"/>\n-        <source>Set maximum block cost (default: %d)</source>\n-        <translation type=\"unfinished\"></translation>\n-    </message>\n-    <message>\n-        <location line=\"+1\"/>\n+        <location line=\"+3\"/>\n         <source>Set maximum block size in bytes (default: %d)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+10\"/>\n+        <location line=\"+9\"/>\n         <source>Specify wallet file (within data directory)</source>\n         <translation>Specify wallet file (within data directory)</translation>\n     </message>\n@@ -2766,7 +2761,7 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-322\"/>\n+        <location line=\"-321\"/>\n         <source>Allow JSON-RPC connections from specified source. Valid for &lt;ip&gt; are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24). This option can be specified multiple times</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -2946,7 +2941,12 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+7\"/>\n+        <location line=\"+3\"/>\n+        <source>Set maximum BIP141 block cost (default: %d)</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+3\"/>\n         <source>Show all debugging options (usage: --help -help-debug)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -3041,7 +3041,7 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-66\"/>\n+        <location line=\"-65\"/>\n         <source>Password for JSON-RPC connections</source>\n         <translation>Password for JSON-RPC connections</translation>\n     </message>\n@@ -3227,11 +3227,6 @@\n     </message>\n     <message>\n         <location line=\"+3\"/>\n-        <source>Set minimum block size in bytes (default: %u)</source>\n-        <translation type=\"unfinished\"></translation>\n-    </message>\n-    <message>\n-        <location line=\"+1\"/>\n         <source>Set the number of threads to service RPC calls (default: %d)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -3266,7 +3261,7 @@\n         <translation>Unknown network specified in -onlynet: &apos;%s&apos;</translation>\n     </message>\n     <message>\n-        <location line=\"-74\"/>\n+        <location line=\"-73\"/>\n         <source>Insufficient funds</source>\n         <translation>Insufficient funds</translation>\n     </message>"
      },
      {
        "sha": "0a6ea1e1dd11260938e08b9117fa42cb2c76a504",
        "filename": "src/qt/locale/bitcoin_es_MX.ts",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/locale/bitcoin_es_MX.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/locale/bitcoin_es_MX.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_es_MX.ts?ref=58ff2d8b8499d650c578662e5b229474b1dc9f86",
        "patch": "@@ -44,6 +44,10 @@\n </context>\n <context>\n     <name>AskPassphraseDialog</name>\n+    <message>\n+        <source>Passphrase Dialog</source>\n+        <translation>Dialogo de contrase\u00f1a</translation>\n+    </message>\n     <message>\n         <source>Enter passphrase</source>\n         <translation>Ingrese la contrase\u00f1a</translation>\n@@ -59,6 +63,10 @@\n </context>\n <context>\n     <name>BanTableModel</name>\n+    <message>\n+        <source>IP/Netmask</source>\n+        <translation>IP/M\u00e1scara de red</translation>\n+    </message>\n     </context>\n <context>\n     <name>BitcoinGUI</name>\n@@ -178,6 +186,10 @@\n         <source>&amp;Receive</source>\n         <translation>&amp;Recibir</translation>\n     </message>\n+    <message>\n+        <source>&amp;Show / Hide</source>\n+        <translation>&amp;Mostrar / Ocultar</translation>\n+    </message>\n     <message>\n         <source>&amp;File</source>\n         <translation>&amp;Archivo</translation>"
      },
      {
        "sha": "c565a63cd885fb7c51d25162c1704b0c47683ded",
        "filename": "src/qt/locale/bitcoin_es_UY.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/locale/bitcoin_es_UY.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/locale/bitcoin_es_UY.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_es_UY.ts?ref=58ff2d8b8499d650c578662e5b229474b1dc9f86",
        "patch": "@@ -108,7 +108,7 @@\n     </message>\n     <message>\n         <source>Send coins to a Bitcoin address</source>\n-        <translation>Enviar monedas a una direcci\u00f3n BItCoin</translation>\n+        <translation>Enviar monedas a una direcci\u00f3n Bitcoin</translation>\n     </message>\n     <message>\n         <source>Change the passphrase used for wallet encryption</source>"
      },
      {
        "sha": "98543ded461bb14df2297cb92055c31d76ab68bc",
        "filename": "src/qt/locale/bitcoin_fa.ts",
        "status": "modified",
        "additions": 71,
        "deletions": 3,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/locale/bitcoin_fa.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/locale/bitcoin_fa.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_fa.ts?ref=58ff2d8b8499d650c578662e5b229474b1dc9f86",
        "patch": "@@ -67,7 +67,11 @@\n         <source>IP/Netmask</source>\n         <translation>\u0622\u06cc\u200c\u067e\u06cc/\u0646\u062a\u200c\u0645\u0627\u0633\u06a9</translation>\n     </message>\n-    </context>\n+    <message>\n+        <source>Banned Until</source>\n+        <translation>\u0645\u0633\u062f\u0648\u062f \u0634\u062f\u0647 \u062a\u0627</translation>\n+    </message>\n+</context>\n <context>\n     <name>BitcoinGUI</name>\n     <message>\n@@ -110,6 +114,10 @@\n         <source>&amp;About %1</source>\n         <translation>&amp;\u062d\u062f\u0648\u062f%1</translation>\n     </message>\n+    <message>\n+        <source>Show information about %1</source>\n+        <translation>\u0646\u0645\u0627\u06cc\u0634 \u0627\u0637\u0644\u0627\u0639\u0627\u062a \u062f\u0631\u0628\u0627\u0631\u0647\u0654 %1</translation>\n+    </message>\n     <message>\n         <source>About &amp;Qt</source>\n         <translation>\u062f\u0631\u0628\u0627\u0631\u0647\u0654 &amp;\u06a9\u06cc\u0648\u062a</translation>\n@@ -510,6 +518,10 @@\n     </context>\n <context>\n     <name>OpenURIDialog</name>\n+    <message>\n+        <source>Open URI</source>\n+        <translation>\u0628\u0627\u0632\u06a9\u0631\u062f\u0646 \u0622\u062f\u0631\u0633</translation>\n+    </message>\n     </context>\n <context>\n     <name>OptionsDialog</name>\n@@ -525,6 +537,10 @@\n         <source>Accept connections from outside</source>\n         <translation>\u067e\u0630\u06cc\u0631\u0634 \u0627\u062a\u0635\u0627\u0644\u0627\u062a \u0627\u0632 \u0628\u06cc\u0631\u0648\u0646</translation>\n     </message>\n+    <message>\n+        <source>Allow incoming connections</source>\n+        <translation>\u0627\u062c\u0627\u0632\u0647 \u062f\u0627\u062f\u0646 \u0628\u0647 \u0627\u062a\u0635\u0627\u0644\u0627\u062a \u062f\u0631\u06cc\u0627\u0641\u062a\u06cc</translation>\n+    </message>\n     <message>\n         <source>Reset all client options to default.</source>\n         <translation>\u0628\u0627\u0632\u0646\u0634\u0627\u0646\u06cc \u062a\u0645\u0627\u0645 \u062a\u0646\u0638\u06cc\u0645\u0627\u062a \u0628\u0647 \u067e\u06cc\u0634\u200c\u0641\u0631\u0636.</translation>\n@@ -691,7 +707,11 @@\n     </context>\n <context>\n     <name>PeerTableModel</name>\n-    </context>\n+    <message>\n+        <source>Ping Time</source>\n+        <translation>\u0632\u0645\u0627\u0646 \u067e\u06cc\u0646\u06af</translation>\n+    </message>\n+</context>\n <context>\n     <name>QObject</name>\n     <message>\n@@ -797,6 +817,14 @@\n         <source>Last Receive</source>\n         <translation>\u0622\u062e\u0631\u06cc\u0646 \u062f\u0631\u06cc\u0627\u0641\u062a\u06cc</translation>\n     </message>\n+    <message>\n+        <source>Ping Time</source>\n+        <translation>\u0632\u0645\u0627\u0646 \u067e\u06cc\u0646\u06af</translation>\n+    </message>\n+    <message>\n+        <source>Ping Wait</source>\n+        <translation>\u0627\u0646\u062a\u0638\u0627\u0631 \u067e\u06cc\u0646\u06af</translation>\n+    </message>\n     <message>\n         <source>Last block time</source>\n         <translation>\u0632\u0645\u0627\u0646 \u0622\u062e\u0631\u06cc\u0646 \u0628\u0644\u0648\u06a9</translation>\n@@ -833,6 +861,22 @@\n         <source>Type &lt;b&gt;help&lt;/b&gt; for an overview of available commands.</source>\n         <translation>\u0628\u0631\u0627\u06cc \u0646\u0645\u0627\u06cc\u0634 \u06cc\u06a9 \u0645\u0631\u0648\u0631 \u06a9\u0644\u06cc \u0627\u0632 \u062f\u0633\u062a\u0648\u0631\u0627\u062a \u0645\u0645\u06a9\u0646\u060c \u0639\u0628\u0627\u0631\u062a &lt;b&gt;help&lt;/b&gt; \u0631\u0627 \u0628\u0646\u0648\u06cc\u0633\u06cc\u062f.</translation>\n     </message>\n+    <message>\n+        <source>%1 B</source>\n+        <translation>%1 \u0628\u0627\u06cc\u062a</translation>\n+    </message>\n+    <message>\n+        <source>%1 KB</source>\n+        <translation>%1 \u06a9\u06cc\u0644\u0648\u0628\u0627\u06cc\u062a</translation>\n+    </message>\n+    <message>\n+        <source>%1 MB</source>\n+        <translation>%1 \u0645\u06af\u0627\u0628\u0627\u06cc\u062a</translation>\n+    </message>\n+    <message>\n+        <source>%1 GB</source>\n+        <translation>%1 \u06af\u06cc\u06af\u0627\u0628\u0627\u06cc\u062a</translation>\n+    </message>\n     <message>\n         <source>never</source>\n         <translation>\u0647\u0631\u06af\u0632</translation>\n@@ -887,7 +931,11 @@\n         <source>Copy &amp;Address</source>\n         <translation>&amp;\u06a9\u067e\u06cc \u0646\u0634\u0627\u0646\u06cc</translation>\n     </message>\n-    </context>\n+    <message>\n+        <source>&amp;Save Image...</source>\n+        <translation>&amp;\u0630\u062e\u06cc\u0631\u0647 \u0639\u06a9\u0633...</translation>\n+    </message>\n+</context>\n <context>\n     <name>SendCoinsDialog</name>\n     <message>\n@@ -934,6 +982,18 @@\n         <source>Hide</source>\n         <translation>\u067e\u0646\u0647\u0627\u0646 \u06a9\u0631\u062f\u0646</translation>\n     </message>\n+    <message>\n+        <source>Recommended:</source>\n+        <translation>\u062a\u0648\u0635\u06cc\u0647 \u0634\u062f\u0647:</translation>\n+    </message>\n+    <message>\n+        <source>Custom:</source>\n+        <translation>\u0633\u0641\u0627\u0631\u0634\u06cc:</translation>\n+    </message>\n+    <message>\n+        <source>Confirmation time:</source>\n+        <translation>\u0631\u0648\u0632 \u062a\u0627\u06cc\u06cc\u062f:</translation>\n+    </message>\n     <message>\n         <source>normal</source>\n         <translation>\u0646\u0631\u0645\u0627\u0644</translation>\n@@ -1024,6 +1084,10 @@\n </context>\n <context>\n     <name>ShutdownWindow</name>\n+    <message>\n+        <source>%1 is shutting down...</source>\n+        <translation>%1 \u062f\u0631 \u062d\u0627\u0644 \u062e\u0627\u0645\u0648\u0634 \u0634\u062f\u0646 \u0627\u0633\u062a...</translation>\n+    </message>\n     </context>\n <context>\n     <name>SignVerifyMessageDialog</name>\n@@ -1250,6 +1314,10 @@\n         <source>Wallet options:</source>\n         <translation>\u06af\u0632\u06cc\u0646\u0647\u200c\u0647\u0627\u06cc \u06a9\u06cc\u0641 \u067e\u0648\u0644:</translation>\n     </message>\n+    <message>\n+        <source>(default: %u)</source>\n+        <translation>(\u067e\u06cc\u0634\u200c\u0641\u0631\u0636 %u)</translation>\n+    </message>\n     <message>\n         <source>Information</source>\n         <translation>\u0627\u0637\u0644\u0627\u0639\u0627\u062a</translation>"
      },
      {
        "sha": "09f748b83cbf8ffdaecdf20dff304468e9e8e5d8",
        "filename": "src/qt/locale/bitcoin_pl.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/locale/bitcoin_pl.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/locale/bitcoin_pl.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_pl.ts?ref=58ff2d8b8499d650c578662e5b229474b1dc9f86",
        "patch": "@@ -300,7 +300,7 @@\n     </message>\n     <message>\n         <source>%1 behind</source>\n-        <translation>%1 wstecz</translation>\n+        <translation>%1 za</translation>\n     </message>\n     <message>\n         <source>Last received block was generated %1 ago.</source>"
      },
      {
        "sha": "ee48c673413da6ac8473ca5f8010a1585caaf1d5",
        "filename": "src/qt/locale/bitcoin_pt_BR.ts",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/locale/bitcoin_pt_BR.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/locale/bitcoin_pt_BR.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_pt_BR.ts?ref=58ff2d8b8499d650c578662e5b229474b1dc9f86",
        "patch": "@@ -1894,6 +1894,10 @@\n         <source>Append comment to the user agent string</source>\n         <translation>Adiciona coment\u00e1rio ao user-agent do navegador</translation>\n     </message>\n+    <message>\n+        <source>Attempt to recover private keys from a corrupt wallet on startup</source>\n+        <translation>Tentando recuperar a chape privada da carteira corrompida ao inicializar</translation>\n+    </message>\n     <message>\n         <source>Block creation options:</source>\n         <translation>Op\u00e7\u00f5es de cria\u00e7\u00e3o de blocos:</translation>"
      },
      {
        "sha": "eed262e010ee65de7806278cc2f11a4153358e59",
        "filename": "src/qt/locale/bitcoin_pt_PT.ts",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/locale/bitcoin_pt_PT.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/locale/bitcoin_pt_PT.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_pt_PT.ts?ref=58ff2d8b8499d650c578662e5b229474b1dc9f86",
        "patch": "@@ -617,6 +617,10 @@\n         <source>&amp;Main</source>\n         <translation>&amp;Principal</translation>\n     </message>\n+    <message>\n+        <source>Automatically start %1 after logging in to the system.</source>\n+        <translation>Come\u00e7ar o %1 automaticamente ao iniciar a sess\u00e3o no sistema.</translation>\n+    </message>\n     <message>\n         <source>&amp;Start %1 on system login</source>\n         <translation>&amp;Iniciar o %1 no in\u00edcio de sess\u00e3o do sistema</translation>\n@@ -1831,6 +1835,10 @@\n         <source>Append comment to the user agent string</source>\n         <translation>Anexar um coment\u00e1rio para a entrada de agente do utilizador</translation>\n     </message>\n+    <message>\n+        <source>Attempt to recover private keys from a corrupt wallet on startup</source>\n+        <translation>Tentar reuperar as chaves privadas de um \"wallet\" ao iniciar</translation>\n+    </message>\n     <message>\n         <source>Block creation options:</source>\n         <translation>Op\u00e7\u00f5es da cria\u00e7\u00e3o de bloco:</translation>"
      },
      {
        "sha": "e3a811b504e99ddcdc89aad11c9d6ed167eb2b72",
        "filename": "src/qt/locale/bitcoin_tr.ts",
        "status": "modified",
        "additions": 32,
        "deletions": 0,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/locale/bitcoin_tr.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/locale/bitcoin_tr.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_tr.ts?ref=58ff2d8b8499d650c578662e5b229474b1dc9f86",
        "patch": "@@ -1830,6 +1830,10 @@\n         <source>Distributed under the MIT software license, see the accompanying file COPYING or &lt;http://www.opensource.org/licenses/mit-license.php&gt;.</source>\n         <translation>MIT yaz\u0131l\u0131m lisans\u0131 kapsam\u0131nda yay\u0131nlanm\u0131\u015ft\u0131r, ekteki COPYING dosyas\u0131na ya da &lt;http://www.opensource.org/licenses/mit-license.php&gt; adresine bak\u0131n\u0131z.</translation>\n     </message>\n+    <message>\n+        <source>Error loading %s: You can't enable HD on a already existing non-HD wallet</source>\n+        <translation>%s y\u00fcklenmesinde hata: zaten var olan ve HD olmayan bir c\u00fczdanda HD etkinle\u015ftirilemez.</translation>\n+    </message>\n     <message>\n         <source>Error reading %s! All keys read correctly, but transaction data or address book entries might be missing or incorrect.</source>\n         <translation>%s dosyas\u0131n\u0131n okunmas\u0131 s\u0131ras\u0131nda bir hata meydana geldi! T\u00fcm anahtarlar do\u011fru bir \u015fekilde okundu, ancak muamele verileri ya da adres defteri unsurlar\u0131 hatal\u0131 veya eksik olabilir.</translation>\n@@ -1854,6 +1858,10 @@\n         <source>Please check that your computer's date and time are correct! If your clock is wrong, %s will not work properly.</source>\n         <translation>L\u00fctfen bilgisayar\u0131n\u0131z\u0131n saat ve tarihinin do\u011fru oldu\u011funu kontrol ediniz! Saatinizde gecikme varsa %s do\u011fru \u015fekilde \u00e7al\u0131\u015famaz.</translation>\n     </message>\n+    <message>\n+        <source>Please contribute if you find %s useful. Visit %s for further information about the software.</source>\n+        <translation>%s program\u0131n\u0131 faydal\u0131 buluyorsan\u0131z l\u00fctfen katk\u0131da bulununuz. Yaz\u0131l\u0131m hakk\u0131nda daha fazla bilgi i\u00e7in %s adresini ziyaret ediniz.</translation>\n+    </message>\n     <message>\n         <source>Set the number of script verification threads (%u to %d, 0 = auto, &lt;0 = leave that many cores free, default: %d)</source>\n         <translation>Betik kontrol\u00fc i\u015f par\u00e7ac\u0131klar\u0131n\u0131n say\u0131s\u0131n\u0131 belirler (%u il\u00e2 %d, 0 = otomatik, &lt;0 = bu say\u0131da \u00e7ekirde\u011fi kullanma, varsay\u0131lan: %d)</translation>\n@@ -1866,6 +1874,10 @@\n         <source>This is a pre-release test build - use at your own risk - do not use for mining or merchant applications</source>\n         <translation>Bu yay\u0131n \u00f6ncesi bir deneme s\u00fcr\u00fcm\u00fcd\u00fcr - t\u00fcm riski siz \u00fcstlenmi\u015f olursunuz - bitcoin olu\u015fturmak ya da ticari uygulamalar i\u00e7in kullanmay\u0131n\u0131z</translation>\n     </message>\n+    <message>\n+        <source>Unable to rewind the database to a pre-fork state. You will need to redownload the blockchain</source>\n+        <translation>Veritaban\u0131n\u0131 \u00e7atallama \u00f6ncesi duruma geri sarmak m\u00fcmk\u00fcn de\u011fil. Blok zincirini tekrar indirmeniz gerekmektedir</translation>\n+    </message>\n     <message>\n         <source>Use UPnP to map the listening port (default: 1 when listening and no -proxy)</source>\n         <translation>Dinlenecek portu haritalamak i\u00e7in UPnP kullan (varsay\u0131lan: dinlenildi\u011finde ve -proxy olmad\u0131\u011f\u0131nda 1)</translation>\n@@ -1986,6 +1998,10 @@\n         <source>Error loading %s: Wallet requires newer version of %s</source>\n         <translation>%s unsurunun y\u00fcklenmesinde hata olu\u015ftu: c\u00fczdan %s program\u0131n\u0131n yeni bir s\u00fcr\u00fcm\u00fcne ihtiya\u00e7 duyuyor</translation>\n     </message>\n+    <message>\n+        <source>Error loading %s: You can't disable HD on a already existing HD wallet</source>\n+        <translation>%s y\u00fcklenmesinde hata: zaten var olan HD bir c\u00fczdanda HD devre d\u0131\u015f\u0131 b\u0131rak\u0131lamaz.</translation>\n+    </message>\n     <message>\n         <source>Error loading block database</source>\n         <translation>Blok veritaban\u0131n\u0131n y\u00fcklenmesinde hata</translation>\n@@ -2074,10 +2090,18 @@\n         <source>Rebuild chain state from the currently indexed blocks</source>\n         <translation>Zincir durumunu g\u00fcncel olarak endekslenen bloklardan yeniden derle</translation>\n     </message>\n+    <message>\n+        <source>Rewinding blocks...</source>\n+        <translation>Bloklar geri sar\u0131l\u0131yor...</translation>\n+    </message>\n     <message>\n         <source>Set database cache size in megabytes (%d to %d, default: %d)</source>\n         <translation>Veritaban\u0131 \u00f6nbellek boyutunu megabayt olarak belirt (%d il\u00e2 %d, varsay\u0131lan: %d)</translation>\n     </message>\n+    <message>\n+        <source>Set maximum block cost (default: %d)</source>\n+        <translation>Azami blok maliyetini ayarla (varsay\u0131lan: %d)</translation>\n+    </message>\n     <message>\n         <source>Set maximum block size in bytes (default: %d)</source>\n         <translation>Azami blok boyutunu bayt olarak ayarla (varsay\u0131lan: %d)</translation>\n@@ -2086,6 +2110,10 @@\n         <source>Specify wallet file (within data directory)</source>\n         <translation>C\u00fczdan dosyas\u0131 belirtiniz (veri klas\u00f6r\u00fcn\u00fcn i\u00e7inde)</translation>\n     </message>\n+    <message>\n+        <source>The source code is available from %s.</source>\n+        <translation>Kaynak kod \u015furadan elde edilebilir: %s.</translation>\n+    </message>\n     <message>\n         <source>Unable to bind to %s on this computer. %s is probably already running.</source>\n         <translation>Bu bilgisayarda %s unsuruna ba\u011flan\u0131lamad\u0131. %s muhtemelen h\u00e2lihaz\u0131rda \u00e7al\u0131\u015fmaktad\u0131r.</translation>\n@@ -2198,6 +2226,10 @@\n         <source>This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit &lt;https://www.openssl.org/&gt; and cryptographic software written by Eric Young and UPnP software written by Thomas Bernard.</source>\n         <translation>Bu \u00fcr\u00fcn OpenSSL projesi taraf\u0131ndan OpenSSL ara\u00e7 tak\u0131m\u0131 (http://www.openssl.org/) i\u00e7in geli\u015ftirilen yaz\u0131l\u0131mlar, Eric Young (eay@cryptsoft.com) taraf\u0131ndan haz\u0131rlanm\u0131\u015f \u015fifreleme yaz\u0131l\u0131mlar\u0131 ve Thomas Bernard taraf\u0131ndan programlanm\u0131\u015f UPnP yaz\u0131l\u0131m\u0131 i\u00e7erir.</translation>\n     </message>\n+    <message>\n+        <source>Use hierarchical deterministic key generation (HD) after BIP32. Only has effect during wallet creation/first start</source>\n+        <translation>BIP32'den sonra hiyerar\u015fik determinist (HD) anahtar \u00fcretimini kullan. Sadece c\u00fczdan olu\u015fturulmas\u0131nda/ilk ba\u015flamada etkiye sahiptir.</translation>\n+    </message>\n     <message>\n         <source>Whitelisted peers cannot be DoS banned and their transactions are always relayed, even if they are already in the mempool, useful e.g. for a gateway</source>\n         <translation>Beyaz listeye al\u0131nan e\u015fler DoS yasaklamas\u0131na u\u011framazlar ve muameleleri zaten mempool'da olsalar da daima aktar\u0131l\u0131r, bu mesela bir ge\u00e7it i\u00e7in kullan\u0131\u015fl\u0131d\u0131r</translation>"
      },
      {
        "sha": "f73bb87064088013bea026311a71c606d8410277",
        "filename": "src/qt/optionsdialog.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/optionsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/optionsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsdialog.cpp?ref=58ff2d8b8499d650c578662e5b229474b1dc9f86",
        "patch": "@@ -327,7 +327,8 @@ QValidator::State ProxyAddressValidator::validate(QString &input, int &pos) cons\n {\n     Q_UNUSED(pos);\n     // Validate the proxy\n-    proxyType addrProxy = proxyType(CService(input.toStdString(), 9050), true);\n+    CService serv(LookupNumeric(input.toStdString().c_str(), 9050));\n+    proxyType addrProxy = proxyType(serv, true);\n     if (addrProxy.IsValid())\n         return QValidator::Acceptable;\n "
      },
      {
        "sha": "d33ab682770f0005d88c365a394e962b364c8ac6",
        "filename": "src/qt/optionsmodel.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/optionsmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/optionsmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsmodel.cpp?ref=58ff2d8b8499d650c578662e5b229474b1dc9f86",
        "patch": "@@ -15,6 +15,7 @@\n #include \"init.h\"\n #include \"main.h\" // For DEFAULT_SCRIPTCHECK_THREADS\n #include \"net.h\"\n+#include \"netbase.h\"\n #include \"txdb.h\" // for -dbcache defaults\n \n #ifdef ENABLE_WALLET\n@@ -43,6 +44,8 @@ void OptionsModel::Init(bool resetSettings)\n     if (resetSettings)\n         Reset();\n \n+    checkAndMigrate();\n+\n     QSettings settings;\n \n     // Ensure restart flag is unset on client startup\n@@ -429,3 +432,22 @@ bool OptionsModel::isRestartRequired()\n     QSettings settings;\n     return settings.value(\"fRestartRequired\", false).toBool();\n }\n+\n+void OptionsModel::checkAndMigrate()\n+{\n+    // Migration of default values\n+    // Check if the QSettings container was already loaded with this client version\n+    QSettings settings;\n+    static const char strSettingsVersionKey[] = \"nSettingsVersion\";\n+    int settingsVersion = settings.contains(strSettingsVersionKey) ? settings.value(strSettingsVersionKey).toInt() : 0;\n+    if (settingsVersion < CLIENT_VERSION)\n+    {\n+        // -dbcache was bumped from 100 to 300 in 0.13\n+        // see https://github.com/bitcoin/bitcoin/pull/8273\n+        // force people to upgrade to the new value if they are using 100MB\n+        if (settingsVersion < 130000 && settings.contains(\"nDatabaseCache\") && settings.value(\"nDatabaseCache\").toLongLong() == 100)\n+            settings.setValue(\"nDatabaseCache\", (qint64)nDefaultDbCache);\n+\n+        settings.setValue(strSettingsVersionKey, CLIENT_VERSION);\n+    }\n+}\n\\ No newline at end of file"
      },
      {
        "sha": "b23b5f2607a6c67814d40744764702cd8fc77138",
        "filename": "src/qt/optionsmodel.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/optionsmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/optionsmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsmodel.h?ref=58ff2d8b8499d650c578662e5b229474b1dc9f86",
        "patch": "@@ -84,9 +84,11 @@ class OptionsModel : public QAbstractListModel\n     /* settings that were overriden by command-line */\n     QString strOverriddenByCommandLine;\n \n-    /// Add option to list of GUI options overridden through command line/config file\n+    // Add option to list of GUI options overridden through command line/config file\n     void addOverriddenOption(const std::string &option);\n \n+    // Check settings version and upgrade default values if required\n+    void checkAndMigrate();\n Q_SIGNALS:\n     void displayUnitChanged(int unit);\n     void coinControlFeaturesChanged(bool);"
      },
      {
        "sha": "bcaa9164c91ba9b80f447b45e256e58560118dd7",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 2,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=58ff2d8b8499d650c578662e5b229474b1dc9f86",
        "patch": "@@ -16,6 +16,7 @@\n #include \"bantablemodel.h\"\n \n #include \"chainparams.h\"\n+#include \"netbase.h\"\n #include \"rpc/server.h\"\n #include \"rpc/client.h\"\n #include \"util.h\"\n@@ -898,7 +899,10 @@ void RPCConsole::banSelectedNode(int bantime)\n         int port = 0;\n         SplitHostPort(nStr, port, addr);\n \n-        CNode::Ban(CNetAddr(addr), BanReasonManuallyAdded, bantime);\n+        CNetAddr resolved;\n+        if(!LookupHost(addr.c_str(), resolved, false))\n+            return;\n+        CNode::Ban(resolved, BanReasonManuallyAdded, bantime);\n \n         clearSelectedNode();\n         clientModel->getBanTableModel()->refresh();\n@@ -912,8 +916,9 @@ void RPCConsole::unbanSelectedNode()\n \n     // Get currently selected ban address\n     QString strNode = GUIUtil::getEntryData(ui->banlistWidget, 0, BanTableModel::Address);\n-    CSubNet possibleSubnet(strNode.toStdString());\n+    CSubNet possibleSubnet;\n \n+    LookupSubNet(strNode.toStdString().c_str(), possibleSubnet);\n     if (possibleSubnet.IsValid())\n     {\n         CNode::Unban(possibleSubnet);"
      },
      {
        "sha": "c5f2fae06122add8c0891eea757fc55d3daffe9a",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 35,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58ff2d8b8499d650c578662e5b229474b1dc9f86/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=58ff2d8b8499d650c578662e5b229474b1dc9f86",
        "patch": "@@ -80,14 +80,8 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n     {\n         strHTML += \"<b>\" + tr(\"Source\") + \":</b> \" + tr(\"Generated\") + \"<br>\";\n     }\n-    else if (wtx.mapValue.count(\"from\") && !wtx.mapValue[\"from\"].empty())\n-    {\n-        // Online transaction\n-        strHTML += \"<b>\" + tr(\"From\") + \":</b> \" + GUIUtil::HtmlEscape(wtx.mapValue[\"from\"]) + \"<br>\";\n-    }\n     else\n     {\n-        // Offline transaction\n         if (nNet > 0)\n         {\n             // Credit\n@@ -110,20 +104,6 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n         }\n     }\n \n-    //\n-    // To\n-    //\n-    if (wtx.mapValue.count(\"to\") && !wtx.mapValue[\"to\"].empty())\n-    {\n-        // Online transaction\n-        std::string strAddress = wtx.mapValue[\"to\"];\n-        strHTML += \"<b>\" + tr(\"To\") + \":</b> \";\n-        CTxDestination dest = CBitcoinAddress(strAddress).Get();\n-        if (wallet->mapAddressBook.count(dest) && !wallet->mapAddressBook[dest].name.empty())\n-            strHTML += GUIUtil::HtmlEscape(wallet->mapAddressBook[dest].name) + \" \";\n-        strHTML += GUIUtil::HtmlEscape(strAddress) + \"<br>\";\n-    }\n-\n     //\n     // Amount\n     //\n@@ -180,22 +160,20 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n                 if ((toSelf == ISMINE_SPENDABLE) && (fAllFromMe == ISMINE_SPENDABLE))\n                     continue;\n \n-                if (!wtx.mapValue.count(\"to\") || wtx.mapValue[\"to\"].empty())\n+\n+                CTxDestination address;\n+                if (ExtractDestination(txout.scriptPubKey, address))\n                 {\n-                    // Offline transaction\n-                    CTxDestination address;\n-                    if (ExtractDestination(txout.scriptPubKey, address))\n-                    {\n-                        strHTML += \"<b>\" + tr(\"To\") + \":</b> \";\n-                        if (wallet->mapAddressBook.count(address) && !wallet->mapAddressBook[address].name.empty())\n-                            strHTML += GUIUtil::HtmlEscape(wallet->mapAddressBook[address].name) + \" \";\n-                        strHTML += GUIUtil::HtmlEscape(CBitcoinAddress(address).ToString());\n-                        if(toSelf == ISMINE_SPENDABLE)\n-                            strHTML += \" (own address)\";\n-                        else if(toSelf & ISMINE_WATCH_ONLY)\n-                            strHTML += \" (watch-only)\";\n-                        strHTML += \"<br>\";\n-                    }\n+                    strHTML += \"<b>\" + tr(\"To\") + \":</b> \";\n+                    if (wallet->mapAddressBook.count(address) && !wallet->mapAddressBook[address].name.empty())\n+                        strHTML += GUIUtil::HtmlEscape(wallet->mapAddressBook[address].name) + \" \";\n+                    strHTML += GUIUtil::HtmlEscape(CBitcoinAddress(address).ToString());\n+                    if(toSelf == ISMINE_SPENDABLE)\n+                        strHTML += \" (own address)\";\n+                    else if(toSelf & ISMINE_WATCH_ONLY)\n+                        strHTML += \" (watch-only)\";\n+                    strHTML += \"<br>\";\n+\n                 }\n \n                 strHTML += \"<b>\" + tr(\"Debit\") + \":</b> \" + BitcoinUnits::formatHtmlWithUnit(unit, -txout.nValue) + \"<br>\";"
      }
    ]
  },
  {
    "sha": "d70185724b9df301216c5bc8807af17c9eb6225f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNzAxODU3MjRiOWRmMzAxMjE2YzViYzg4MDdhZjE3YzllYjYyMjVm",
    "commit": {
      "author": {
        "name": "MCCCS",
        "email": "mcccs@users.noreply.github.com",
        "date": "2016-08-19T10:25:46Z"
      },
      "committer": {
        "name": "MCCCS",
        "email": "mcccs@users.noreply.github.com",
        "date": "2016-08-19T10:25:46Z"
      },
      "message": "?",
      "tree": {
        "sha": "7a1c7d03e188912b2cb596cba427bdc6962b5ebc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7a1c7d03e188912b2cb596cba427bdc6962b5ebc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d70185724b9df301216c5bc8807af17c9eb6225f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d70185724b9df301216c5bc8807af17c9eb6225f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d70185724b9df301216c5bc8807af17c9eb6225f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d70185724b9df301216c5bc8807af17c9eb6225f/comments",
    "author": {
      "login": "mcccs",
      "id": 43574227,
      "node_id": "MDQ6VXNlcjQzNTc0MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/43574227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mcccs",
      "html_url": "https://github.com/mcccs",
      "followers_url": "https://api.github.com/users/mcccs/followers",
      "following_url": "https://api.github.com/users/mcccs/following{/other_user}",
      "gists_url": "https://api.github.com/users/mcccs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mcccs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mcccs/subscriptions",
      "organizations_url": "https://api.github.com/users/mcccs/orgs",
      "repos_url": "https://api.github.com/users/mcccs/repos",
      "events_url": "https://api.github.com/users/mcccs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mcccs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mcccs",
      "id": 43574227,
      "node_id": "MDQ6VXNlcjQzNTc0MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/43574227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mcccs",
      "html_url": "https://github.com/mcccs",
      "followers_url": "https://api.github.com/users/mcccs/followers",
      "following_url": "https://api.github.com/users/mcccs/following{/other_user}",
      "gists_url": "https://api.github.com/users/mcccs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mcccs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mcccs/subscriptions",
      "organizations_url": "https://api.github.com/users/mcccs/orgs",
      "repos_url": "https://api.github.com/users/mcccs/repos",
      "events_url": "https://api.github.com/users/mcccs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mcccs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "58ff2d8b8499d650c578662e5b229474b1dc9f86",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/58ff2d8b8499d650c578662e5b229474b1dc9f86",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/58ff2d8b8499d650c578662e5b229474b1dc9f86"
      }
    ],
    "stats": {
      "total": 10763,
      "additions": 7916,
      "deletions": 2847
    },
    "files": [
      {
        "sha": "a16cedd7fda0c67189a54da3dc4fa104162bcd78",
        "filename": ".github/ISSUE_TEMPLATE.md",
        "status": "added",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/.github/ISSUE_TEMPLATE.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/.github/ISSUE_TEMPLATE.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.github/ISSUE_TEMPLATE.md?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -0,0 +1,23 @@\n+<!--- Remove sections that do not apply -->\n+### Describe the issue\n+\n+### Is the issue reproducible?\n+#### List steps to reproduce below:\n+1. \n+2. \n+3. \n+\n+### Expected behavior\n+Tell us what should happen\n+\n+### Actual behavior\n+Tell us what happens instead\n+\n+### Any information in the debug.log file related to this issue?\n+\n+### Screenshots (if available)\n+\n+### What binary version was used (official or self compiled)\n+\n+### Machine specs: CPU, RAM, Disk space & OS (Windows, OS X, Linux) \n+"
      },
      {
        "sha": "892b2a3e08e0c6bcee23db524d99a2abdb333bba",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -103,10 +103,9 @@ linux-build\n win32-build\n qa/pull-tester/run-bitcoind-for-test.sh\n qa/pull-tester/tests_config.py\n-qa/pull-tester/cache/*\n qa/pull-tester/test.*/*\n qa/tmp\n-cache/\n+qa/cache/*\n share/BitcoindComparisonTool.jar\n \n !src/leveldb*/Makefile"
      },
      {
        "sha": "0b38fd45fe46e9d7514bf443311ce46269121725",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 5,
        "deletions": 10,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -1,10 +1,5 @@\n sudo: required\n dist: trusty\n-\n-#workaround for https://github.com/travis-ci/travis-ci/issues/5227\n-addons:\n-  hostname: bitcoin-tester\n-\n os: linux\n language: generic\n cache:\n@@ -29,15 +24,15 @@ env:\n # ARM\n     - HOST=arm-linux-gnueabihf PACKAGES=\"g++-arm-linux-gnueabihf\" DEP_OPTS=\"NO_QT=1\" CHECK_DOC=1 GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports\"\n # Win32\n-    - HOST=i686-w64-mingw32 DPKG_ADD_ARCH=\"i386\" DEP_OPTS=\"NO_QT=1\" PACKAGES=\"python3 nsis g++-mingw-w64-i686 wine1.6 bc openjdk-7-jre-headless\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-reduce-exports\"\n+    - HOST=i686-w64-mingw32 DPKG_ADD_ARCH=\"i386\" DEP_OPTS=\"NO_QT=1\" PACKAGES=\"python3 nsis g++-mingw-w64-i686 wine1.6 bc\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-reduce-exports\"\n # 32-bit + dash\n-    - HOST=i686-pc-linux-gnu PACKAGES=\"g++-multilib bc python3-zmq openjdk-7-jre-headless\" DEP_OPTS=\"NO_QT=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --enable-glibc-back-compat --enable-reduce-exports LDFLAGS=-static-libstdc++\" USE_SHELL=\"/bin/dash\"\n+    - HOST=i686-pc-linux-gnu PACKAGES=\"g++-multilib bc python3-zmq\" DEP_OPTS=\"NO_QT=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --enable-glibc-back-compat --enable-reduce-exports LDFLAGS=-static-libstdc++\" USE_SHELL=\"/bin/dash\"\n # Win64\n-    - HOST=x86_64-w64-mingw32 DPKG_ADD_ARCH=\"i386\" DEP_OPTS=\"NO_QT=1\" PACKAGES=\"python3 nsis g++-mingw-w64-x86-64 wine1.6 bc openjdk-7-jre-headless\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-reduce-exports\"\n+    - HOST=x86_64-w64-mingw32 DPKG_ADD_ARCH=\"i386\" DEP_OPTS=\"NO_QT=1\" PACKAGES=\"python3 nsis g++-mingw-w64-x86-64 wine1.6 bc\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-reduce-exports\"\n # bitcoind\n-    - HOST=x86_64-unknown-linux-gnu PACKAGES=\"bc python3-zmq openjdk-7-jre-headless\" DEP_OPTS=\"NO_QT=1 NO_UPNP=1 DEBUG=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --enable-glibc-back-compat --enable-reduce-exports CPPFLAGS=-DDEBUG_LOCKORDER\"\n+    - HOST=x86_64-unknown-linux-gnu PACKAGES=\"bc python3-zmq\" DEP_OPTS=\"NO_QT=1 NO_UPNP=1 DEBUG=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --enable-glibc-back-compat --enable-reduce-exports CPPFLAGS=-DDEBUG_LOCKORDER\"\n # No wallet\n-    - HOST=x86_64-unknown-linux-gnu PACKAGES=\" openjdk-7-jre-headless python3\" DEP_OPTS=\"NO_WALLET=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports\"\n+    - HOST=x86_64-unknown-linux-gnu PACKAGES=\"python3\" DEP_OPTS=\"NO_WALLET=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports\"\n # Cross-Mac\n     - HOST=x86_64-apple-darwin11 PACKAGES=\"cmake imagemagick libcap-dev librsvg2-bin libz-dev libbz2-dev libtiff-tools python-dev\" BITCOIN_CONFIG=\"--enable-reduce-exports\" OSX_SDK=10.11 GOAL=\"deploy\"\n "
      },
      {
        "sha": "37c1e98eca6bc37beb0549a227061edb97c81511",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 4,
        "deletions": 20,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -47,9 +47,9 @@ OSX_PACKAGING = $(OSX_DEPLOY_SCRIPT) $(OSX_FANCY_PLIST) $(OSX_INSTALLER_ICONS) \\\n   $(top_srcdir)/contrib/macdeploy/detached-sig-apply.sh \\\n   $(top_srcdir)/contrib/macdeploy/detached-sig-create.sh\n \n-COVERAGE_INFO = baseline_filtered_combined.info baseline.info block_test.info \\\n+COVERAGE_INFO = baseline_filtered_combined.info baseline.info \\\n   leveldb_baseline.info test_bitcoin_filtered.info total_coverage.info \\\n-  baseline_filtered.info block_test_filtered.info rpc_test.info rpc_test_filtered.info \\\n+  baseline_filtered.info rpc_test.info rpc_test_filtered.info \\\n   leveldb_baseline_filtered.info test_bitcoin_coverage.info test_bitcoin.info\n \n dist-hook:\n@@ -175,16 +175,6 @@ test_bitcoin.info: baseline_filtered_combined.info\n test_bitcoin_filtered.info: test_bitcoin.info\n \t$(LCOV) -r $< \"/usr/include/*\" -o $@\n \n-block_test.info: test_bitcoin_filtered.info\n-\t$(MKDIR_P) qa/tmp\n-\t-@TIMEOUT=15 qa/pull-tester/run-bitcoind-for-test.sh $(JAVA) -jar $(JAVA_COMPARISON_TOOL) qa/tmp/compTool $(COMPARISON_TOOL_REORG_TESTS)\n-\t$(LCOV) -c -d $(abs_builddir)/src --t BitcoinJBlockTest -o $@\n-\t$(LCOV) -z -d $(abs_builddir)/src\n-\t$(LCOV) -z -d $(abs_builddir)/src/leveldb\n-\n-block_test_filtered.info: block_test.info\n-\t$(LCOV) -r $< \"/usr/include/*\" -o $@\n-\n rpc_test.info: test_bitcoin_filtered.info\n \t-@TIMEOUT=15 python qa/pull-tester/rpc-tests.py $(EXTENDED_RPC_TESTS)\n \t$(LCOV) -c -d $(abs_builddir)/src --t rpc-tests -o $@\n@@ -197,8 +187,8 @@ rpc_test_filtered.info: rpc_test.info\n test_bitcoin_coverage.info: baseline_filtered_combined.info test_bitcoin_filtered.info\n \t$(LCOV) -a baseline_filtered.info -a leveldb_baseline_filtered.info -a test_bitcoin_filtered.info -o $@\n \n-total_coverage.info: baseline_filtered_combined.info test_bitcoin_filtered.info block_test_filtered.info rpc_test_filtered.info\n-\t$(LCOV) -a baseline_filtered.info -a leveldb_baseline_filtered.info -a test_bitcoin_filtered.info -a block_test_filtered.info -a rpc_test_filtered.info -o $@ | $(GREP) \"\\%\" | $(AWK) '{ print substr($$3,2,50) \"/\" $$5 }' > coverage_percent.txt\n+total_coverage.info: baseline_filtered_combined.info test_bitcoin_filtered.info rpc_test_filtered.info\n+\t$(LCOV) -a baseline_filtered.info -a leveldb_baseline_filtered.info -a test_bitcoin_filtered.info -a rpc_test_filtered.info -o $@ | $(GREP) \"\\%\" | $(AWK) '{ print substr($$3,2,50) \"/\" $$5 }' > coverage_percent.txt\n \n test_bitcoin.coverage/.dirstamp:  test_bitcoin_coverage.info\n \t$(GENHTML) -s $< -o $(@D)\n@@ -212,12 +202,6 @@ cov: test_bitcoin.coverage/.dirstamp total.coverage/.dirstamp\n \n endif\n \n-if USE_COMPARISON_TOOL\n-check-local:\n-\t$(MKDIR_P) qa/tmp\n-\t@qa/pull-tester/run-bitcoind-for-test.sh $(JAVA) -jar $(JAVA_COMPARISON_TOOL) qa/tmp/compTool $(COMPARISON_TOOL_REORG_TESTS) 2>&1\n-endif\n-\n dist_noinst_SCRIPTS = autogen.sh\n \n EXTRA_DIST = $(top_srcdir)/share/genbuild.sh qa/pull-tester/rpc-tests.py qa/rpc-tests $(DIST_DOCS) $(WINDOWS_PACKAGING) $(OSX_PACKAGING) $(BIN_CHECKS)"
      },
      {
        "sha": "d332f4face3ee0bec7f68fcf885775eb0eb7cf46",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 25,
        "deletions": 46,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -1,7 +1,7 @@\n dnl require autoconf 2.60 (AS_ECHO/AS_ECHO_N)\n AC_PREREQ([2.60])\n define(_CLIENT_VERSION_MAJOR, 0)\n-define(_CLIENT_VERSION_MINOR, 12)\n+define(_CLIENT_VERSION_MINOR, 13)\n define(_CLIENT_VERSION_REVISION, 99)\n define(_CLIENT_VERSION_BUILD, 0)\n define(_CLIENT_VERSION_IS_RELEASE, false)\n@@ -66,7 +66,6 @@ AC_PATH_TOOL(RANLIB, ranlib)\n AC_PATH_TOOL(STRIP, strip)\n AC_PATH_TOOL(GCOV, gcov)\n AC_PATH_PROG(LCOV, lcov)\n-AC_PATH_PROG(JAVA, java)\n AC_PATH_PROGS([PYTHON], [python3 python2.7 python2 python])\n AC_PATH_PROG(GENHTML, genhtml)\n AC_PATH_PROG([GIT], [git])\n@@ -113,16 +112,6 @@ AC_ARG_ENABLE(bench,\n     [use_bench=$enableval],\n     [use_bench=yes])\n \n-AC_ARG_WITH([comparison-tool],\n-    AS_HELP_STRING([--with-comparison-tool],[path to java comparison tool (requires --enable-tests)]),\n-    [use_comparison_tool=$withval],\n-    [use_comparison_tool=no])\n-\n-AC_ARG_ENABLE([comparison-tool-reorg-tests],\n-    AS_HELP_STRING([--enable-comparison-tool-reorg-tests],[enable expensive reorg tests in the comparison tool (default no)]),\n-    [use_comparison_tool_reorg_tests=$enableval],\n-    [use_comparison_tool_reorg_tests=no])\n-\n AC_ARG_ENABLE([extended-rpc-tests],\n     AS_HELP_STRING([--enable-extended-rpc-tests],[enable expensive RPC tests when using lcov (default no)]),\n     [use_extended_rpc_tests=$enableval],\n@@ -382,19 +371,6 @@ if test x$use_pkgconfig = xyes; then\n   ])\n fi\n \n-if test x$use_comparison_tool != xno; then\n-  AC_SUBST(JAVA_COMPARISON_TOOL, $use_comparison_tool)\n-fi\n-\n-if test x$use_comparison_tool_reorg_tests != xno; then\n-  if test x$use_comparison_tool = x; then\n-    AC_MSG_ERROR(\"comparison tool reorg tests but comparison tool was not specified\")\n-  fi\n-  AC_SUBST(COMPARISON_TOOL_REORG_TESTS, 1)\n-else\n-  AC_SUBST(COMPARISON_TOOL_REORG_TESTS, 0)\n-fi\n-\n if test x$use_extended_rpc_tests != xno; then\n   AC_SUBST(EXTENDED_RPC_TESTS, -extended)\n fi\n@@ -406,18 +382,12 @@ if test x$use_lcov = xyes; then\n   if test x$GCOV = x; then\n     AC_MSG_ERROR(\"lcov testing requested but gcov not found\")\n   fi\n-  if test x$JAVA = x; then\n-    AC_MSG_ERROR(\"lcov testing requested but java not found\")\n-  fi\n   if test x$PYTHON = x; then\n     AC_MSG_ERROR(\"lcov testing requested but python not found\")\n   fi\n   if test x$GENHTML = x; then\n     AC_MSG_ERROR(\"lcov testing requested but genhtml not found\")\n   fi\n-  if test x$use_comparison_tool = x; then\n-    AC_MSG_ERROR(\"lcov testing requested but comparison tool was not specified\")\n-  fi\n   LCOV=\"$LCOV --gcov-tool=$GCOV\"\n   AX_CHECK_COMPILE_FLAG([--coverage],[CXXFLAGS=\"$CXXFLAGS --coverage\"],\n     [AC_MSG_ERROR(\"lcov testing requested but --coverage flag does not work\")])\n@@ -816,6 +786,15 @@ else\n     AC_DEFINE_UNQUOTED([ENABLE_ZMQ],[0],[Define to 1 to enable ZMQ functions])\n   fi\n \n+  if test \"x$use_zmq\" = \"xyes\"; then\n+    dnl Assume libzmq was built for static linking\n+    case $host in\n+      *mingw*)\n+        ZMQ_CFLAGS=\"$ZMQ_CFLAGS -DZMQ_STATIC\"\n+      ;;\n+    esac\n+  fi\n+\n   BITCOIN_QT_CHECK(AC_CHECK_LIB([protobuf] ,[main],[PROTOBUF_LIBS=-lprotobuf], BITCOIN_QT_FAIL(libprotobuf not found)))\n   if test x$use_qr != xno; then\n     BITCOIN_QT_CHECK([AC_CHECK_LIB([qrencode], [main],[QR_LIBS=-lqrencode], [have_qrencode=no])])\n@@ -825,6 +804,12 @@ fi\n \n dnl univalue check\n \n+need_bundled_univalue=yes\n+\n+if test x$build_bitcoin_utils$build_bitcoind$bitcoin_enable_qt$use_tests$use_bench = xnonononono; then\n+  need_bundled_univalue=no\n+else\n+\n if test x$system_univalue != xno ; then\n   found_univalue=no\n   if test x$use_pkgconfig = xyes; then\n@@ -846,29 +831,25 @@ if test x$system_univalue != xno ; then\n \n   if test x$found_univalue = xyes ; then\n     system_univalue=yes\n+    need_bundled_univalue=no\n   elif test x$system_univalue = xyes ; then\n     AC_MSG_ERROR([univalue not found])\n   else\n     system_univalue=no\n   fi\n fi\n \n-if test x$system_univalue = xno ; then\n+if test x$need_bundled_univalue = xyes ; then\n   UNIVALUE_CFLAGS='-I$(srcdir)/univalue/include'\n   UNIVALUE_LIBS='univalue/libunivalue.la'\n fi\n-AM_CONDITIONAL([EMBEDDED_UNIVALUE],[test x$system_univalue = xno])\n+\n+fi\n+\n+AM_CONDITIONAL([EMBEDDED_UNIVALUE],[test x$need_bundled_univalue = xyes])\n AC_SUBST(UNIVALUE_CFLAGS)\n AC_SUBST(UNIVALUE_LIBS)\n \n-CXXFLAGS_TEMP=\"$CXXFLAGS\"\n-LIBS_TEMP=\"$LIBS\"\n-CXXFLAGS=\"$CXXFLAGS $SSL_CFLAGS $CRYPTO_CFLAGS\"\n-LIBS=\"$LIBS $SSL_LIBS $CRYPTO_LIBS\"\n-AC_CHECK_HEADER([openssl/ec.h],, AC_MSG_ERROR(OpenSSL ec header missing),)\n-CXXFLAGS=\"$CXXFLAGS_TEMP\"\n-LIBS=\"$LIBS_TEMP\"\n-\n BITCOIN_QT_PATH_PROGS([PROTOC], [protoc],$protoc_bin_path)\n \n AC_MSG_CHECKING([whether to build bitcoind])\n@@ -1003,8 +984,8 @@ else\n   AC_MSG_RESULT([no])\n fi\n \n-if test x$build_bitcoin_utils$build_bitcoin_libs$build_bitcoind$bitcoin_enable_qt$use_tests = xnonononono; then\n-  AC_MSG_ERROR([No targets! Please specify at least one of: --with-utils --with-libs --with-daemon --with-gui or --enable-tests])\n+if test x$build_bitcoin_utils$build_bitcoin_libs$build_bitcoind$bitcoin_enable_qt$use_bench$use_tests = xnononononono; then\n+  AC_MSG_ERROR([No targets! Please specify at least one of: --with-utils --with-libs --with-daemon --with-gui --enable-bench or --enable-tests])\n fi\n \n AM_CONDITIONAL([TARGET_DARWIN], [test x$TARGET_OS = xdarwin])\n@@ -1017,8 +998,6 @@ AM_CONDITIONAL([ENABLE_QT_TESTS],[test x$BUILD_TEST_QT = xyes])\n AM_CONDITIONAL([ENABLE_BENCH],[test x$use_bench = xyes])\n AM_CONDITIONAL([USE_QRCODE], [test x$use_qr = xyes])\n AM_CONDITIONAL([USE_LCOV],[test x$use_lcov = xyes])\n-AM_CONDITIONAL([USE_COMPARISON_TOOL],[test x$use_comparison_tool != xno])\n-AM_CONDITIONAL([USE_COMPARISON_TOOL_REORG_TESTS],[test x$use_comparison_tool_reorg_test != xno])\n AM_CONDITIONAL([GLIBC_BACK_COMPAT],[test x$use_glibc_compat = xyes])\n AM_CONDITIONAL([HARDEN],[test x$use_hardening = xyes])\n \n@@ -1096,7 +1075,7 @@ PKGCONFIG_LIBDIR_TEMP=\"$PKG_CONFIG_LIBDIR\"\n unset PKG_CONFIG_LIBDIR\n PKG_CONFIG_LIBDIR=\"$PKGCONFIG_LIBDIR_TEMP\"\n \n-if test x$system_univalue = xno; then\n+if test x$need_bundled_univalue = xyes; then\n   AC_CONFIG_SUBDIRS([src/univalue])\n fi\n "
      },
      {
        "sha": "9ea0131ac3aa4933d4ebc45b78a9282805974a73",
        "filename": "contrib/devtools/check-doc.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/contrib/devtools/check-doc.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/contrib/devtools/check-doc.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/check-doc.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -21,7 +21,7 @@\n REGEX_ARG = re.compile(r'(?:map(?:Multi)?Args(?:\\.count\\(|\\[)|Get(?:Bool)?Arg\\()\\\"(\\-[^\\\"]+?)\\\"')\n REGEX_DOC = re.compile(r'HelpMessageOpt\\(\\\"(\\-[^\\\"=]+?)(?:=|\\\")')\n # list unsupported, deprecated and duplicate args as they need no documentation\n-SET_DOC_OPTIONAL = set(['-rpcssl', '-benchmark', '-h', '-help', '-socks', '-tor', '-debugnet', '-whitelistalwaysrelay', '-prematurewitness', '-walletprematurewitness', '-promiscuousmempoolflags'])\n+SET_DOC_OPTIONAL = set(['-rpcssl', '-benchmark', '-h', '-help', '-socks', '-tor', '-debugnet', '-whitelistalwaysrelay', '-prematurewitness', '-walletprematurewitness', '-promiscuousmempoolflags', '-blockminsize'])\n \n def main():\n   used = check_output(CMD_GREP_ARGS, shell=True)"
      },
      {
        "sha": "c61d6526417676f6f4f13f28a1ee4e4ba436f4ba",
        "filename": "contrib/devtools/security-check.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/contrib/devtools/security-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/contrib/devtools/security-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/security-check.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/python2\n+#!/usr/bin/env python\n '''\n Perform basic ELF security checks on a series of executables.\n Exit status will be 0 if successful, and the program will be silent."
      },
      {
        "sha": "8f8685006e1150ea4cd36ec60ae10ed223b69b51",
        "filename": "contrib/devtools/symbol-check.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/contrib/devtools/symbol-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/contrib/devtools/symbol-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/symbol-check.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/python2\n+#!/usr/bin/env python\n # Copyright (c) 2014 Wladimir J. van der Laan\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php."
      },
      {
        "sha": "324b7bcd85ae3fece7dd61a76d375c223433c53a",
        "filename": "contrib/devtools/test-security-check.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/contrib/devtools/test-security-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/contrib/devtools/test-security-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/test-security-check.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/python2\n+#!/usr/bin/env python2\n '''\n Test script for security-check.py\n '''"
      },
      {
        "sha": "78b9f9d179eb6d7c59f1b773be310a9a5e33be49",
        "filename": "contrib/devtools/update-translations.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/contrib/devtools/update-translations.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/contrib/devtools/update-translations.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/update-translations.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/python\n+#!/usr/bin/env python\n # Copyright (c) 2014 Wladimir J. van der Laan\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php."
      },
      {
        "sha": "8badb4b318b019b015fae6a81880dd03fbbac4bc",
        "filename": "contrib/linearize/linearize-data.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/contrib/linearize/linearize-data.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/contrib/linearize/linearize-data.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/linearize/linearize-data.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/python\n+#!/usr/bin/env python\n #\n # linearize-data.py: Construct a linear, no-fork version of the chain.\n #"
      },
      {
        "sha": "cb40c664fafdefcecf4746a029b9aa63c40e0daf",
        "filename": "contrib/linearize/linearize-hashes.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/contrib/linearize/linearize-hashes.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/contrib/linearize/linearize-hashes.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/linearize/linearize-hashes.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/python\n+#!/usr/bin/env python\n #\n # linearize-hashes.py:  List blocks in a linear, no-fork version of the chain.\n #"
      },
      {
        "sha": "f43dc0b218adb2598cd9474e10258648af69d316",
        "filename": "contrib/seeds/generate-seeds.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/contrib/seeds/generate-seeds.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/contrib/seeds/generate-seeds.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/seeds/generate-seeds.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/python\n+#!/usr/bin/env python\n # Copyright (c) 2014 Wladimir J. van der Laan\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php."
      },
      {
        "sha": "27e3aedd8ed4ff3399a878bcccc41eb7f753636c",
        "filename": "depends/config.site.in",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/depends/config.site.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/depends/config.site.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/config.site.in?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -19,9 +19,6 @@ fi\n if test -z $with_protoc_bindir; then\n   with_protoc_bindir=$depends_prefix/native/bin\n fi\n-if test -z $with_comparison_tool; then\n-  with_comparison_tool=$depends_prefix/native/share/BitcoindComparisonTool_jar/BitcoindComparisonTool.jar\n-fi\n \n \n if test -z $enable_wallet && test -n \"@no_wallet@\"; then"
      },
      {
        "sha": "3c6e8900f66465976a26b77a14683d8b9859c63e",
        "filename": "depends/packages/native_biplist.mk",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/depends/packages/native_biplist.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/depends/packages/native_biplist.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/native_biplist.mk?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -4,6 +4,11 @@ $(package)_download_path=https://pypi.python.org/packages/source/b/biplist\n $(package)_file_name=biplist-$($(package)_version).tar.gz\n $(package)_sha256_hash=b57cadfd26e4754efdf89e9e37de87885f9b5c847b2615688ca04adfaf6ca604\n $(package)_install_libdir=$(build_prefix)/lib/python/dist-packages\n+$(package)_patches=sorted_list.patch\n+\n+define $(package)_preprocess_cmds\n+  patch -p1 < $($(package)_patch_dir)/sorted_list.patch\n+endef\n \n define $(package)_build_cmds\n     python setup.py build"
      },
      {
        "sha": "e0ae0cec700e921cdfc6c4bdc9760467655dcb4d",
        "filename": "depends/packages/native_comparisontool.mk",
        "status": "removed",
        "additions": 0,
        "deletions": 21,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58ff2d8b8499d650c578662e5b229474b1dc9f86/depends/packages/native_comparisontool.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58ff2d8b8499d650c578662e5b229474b1dc9f86/depends/packages/native_comparisontool.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/native_comparisontool.mk?ref=58ff2d8b8499d650c578662e5b229474b1dc9f86",
        "patch": "@@ -1,21 +0,0 @@\n-package=native_comparisontool\n-$(package)_version=8c6666f\n-$(package)_download_path=https://github.com/theuni/bitcoind-comparisontool/raw/master\n-$(package)_file_name=pull-tests-$($(package)_version).jar\n-$(package)_sha256_hash=a865332b3827abcde684ab79f5f43c083b0b6a4c97ff5508c79f29fee24f11cd\n-$(package)_install_dirname=BitcoindComparisonTool_jar\n-$(package)_install_filename=BitcoindComparisonTool.jar\n-\n-define $(package)_extract_cmds\n-endef\n-\n-define $(package)_configure_cmds\n-endef\n-\n-define $(package)_build_cmds\n-endef\n-\n-define $(package)_stage_cmds\n-  mkdir -p $($(package)_staging_prefix_dir)/share/$($(package)_install_dirname) && \\\n-  cp $($(package)_source) $($(package)_staging_prefix_dir)/share/$($(package)_install_dirname)/$($(package)_install_filename)\n-endef"
      },
      {
        "sha": "4cf44385b88dc4501f9d40f35ea1d878d46beba4",
        "filename": "depends/packages/packages.mk",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/depends/packages/packages.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/depends/packages/packages.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/packages.mk?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -1,7 +1,5 @@\n-packages:=boost openssl libevent\n-darwin_packages:=zeromq\n-linux_packages:=zeromq\n-native_packages := native_ccache native_comparisontool\n+packages:=boost openssl libevent zeromq\n+native_packages := native_ccache\n \n qt_native_packages = native_protobuf\n qt_packages = qrencode protobuf\n@@ -12,7 +10,6 @@ qt_i686_linux_packages:=$(qt_x86_64_linux_packages)\n qt_darwin_packages=qt\n qt_mingw32_packages=qt\n \n-\n wallet_packages=bdb\n \n upnp_packages=miniupnpc"
      },
      {
        "sha": "01146c26f69bc426f351424bc2cdcfded19e0b65",
        "filename": "depends/packages/zeromq.mk",
        "status": "modified",
        "additions": 11,
        "deletions": 4,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/depends/packages/zeromq.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/depends/packages/zeromq.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/zeromq.mk?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -1,15 +1,22 @@\n package=zeromq\n-$(package)_version=4.1.4\n-$(package)_download_path=http://download.zeromq.org\n+$(package)_version=4.1.5\n+$(package)_download_path=https://github.com/zeromq/zeromq4-1/releases/download/v$($(package)_version)/\n $(package)_file_name=$(package)-$($(package)_version).tar.gz\n-$(package)_sha256_hash=e99f44fde25c2e4cb84ce440f87ca7d3fe3271c2b8cfbc67d55e4de25e6fe378\n+$(package)_sha256_hash=04aac57f081ffa3a2ee5ed04887be9e205df3a7ddade0027460b8042432bdbcf\n+$(package)_patches=9114d3957725acd34aa8b8d011585812f3369411.patch 9e6745c12e0b100cd38acecc16ce7db02905e27c.patch\n \n define $(package)_set_vars\n-  $(package)_config_opts=--without-documentation --disable-shared --without-libsodium\n+  $(package)_config_opts=--without-documentation --disable-shared --without-libsodium --disable-curve\n   $(package)_config_opts_linux=--with-pic\n   $(package)_cxxflags=-std=c++11\n endef\n \n+define $(package)_preprocess_cmds\n+  patch -p1 < $($(package)_patch_dir)/9114d3957725acd34aa8b8d011585812f3369411.patch && \\\n+  patch -p1 < $($(package)_patch_dir)/9e6745c12e0b100cd38acecc16ce7db02905e27c.patch && \\\n+  ./autogen.sh\n+endef\n+\n define $(package)_config_cmds\n   $($(package)_autoconf)\n endef"
      },
      {
        "sha": "22850db8354290de5cf488ba14fdb5881dbe6672",
        "filename": "doc/Doxyfile",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/doc/Doxyfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/doc/Doxyfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/Doxyfile?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -34,7 +34,7 @@ PROJECT_NAME           = Bitcoin\n # This could be handy for archiving the generated documentation or \n # if some version control system is used.\n \n-PROJECT_NUMBER         = 0.12.99\n+PROJECT_NUMBER         = 0.13.99\n \n # Using the PROJECT_BRIEF tag one can provide an optional one line description \n # for a project that appears at the top of each page and should give viewer "
      },
      {
        "sha": "09a507c9ce6e90b4e124337a6f6a94ad8bf1eef4",
        "filename": "doc/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/doc/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/doc/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/README.md?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -1,4 +1,4 @@\n-Bitcoin Core 0.12.99\n+Bitcoin Core 0.13.99\n =====================\n \n Setup"
      },
      {
        "sha": "6a5c672277cf7d59f6485514f0573a16e41a0f90",
        "filename": "doc/README_osx.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/doc/README_osx.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/doc/README_osx.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/README_osx.md?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -22,7 +22,7 @@ These tools inject timestamps by default, which produce non-deterministic\n binaries. The ZERO_AR_DATE environment variable is used to disable that.\n \n This version of cctools has been patched to use the current version of clang's\n-headers and and its libLTO.so rather than those from llvmgcc, as it was\n+headers and its libLTO.so rather than those from llvmgcc, as it was\n originally done in toolchain4.\n \n To complicate things further, all builds must target an Apple SDK. These SDKs"
      },
      {
        "sha": "74a05138a42806c061983b7ad6d3602085cca2d0",
        "filename": "doc/README_windows.txt",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/doc/README_windows.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/doc/README_windows.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/README_windows.txt?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -1,4 +1,4 @@\n-Bitcoin Core 0.12.99\r\n+Bitcoin Core 0.13.99\r\n =====================\r\n \r\n Intro\r"
      },
      {
        "sha": "938f92ff1281fab3c4707368b881ff40905fb55b",
        "filename": "doc/gitian-building.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/doc/gitian-building.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/doc/gitian-building.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/gitian-building.md?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -55,7 +55,7 @@ In the VirtualBox GUI click \"New\" and choose the following parameters in the wiz\n \n ![](gitian-building/create_vm_memsize.png)\n \n-- Memory Size: at least 1024MB, anything less will really slow down the build.\n+- Memory Size: at least 3000MB, anything less and the build might not complete.\n \n ![](gitian-building/create_vm_hard_disk.png)\n "
      },
      {
        "sha": "6f42cda73f3cabb02e39ae0309ac67f419a168c7",
        "filename": "doc/gitian-building/create_vm_memsize.png",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/doc/gitian-building/create_vm_memsize.png",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/doc/gitian-building/create_vm_memsize.png",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/gitian-building/create_vm_memsize.png?ref=d70185724b9df301216c5bc8807af17c9eb6225f"
      },
      {
        "sha": "b99192ae97c9b3b7f9d3f5b6c669b713e1b1676a",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 9,
        "deletions": 138,
        "changes": 147,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -31,7 +31,7 @@ libraries such as Qt are no longer being tested on XP.\n \n We do not have time nor resources to provide support for an OS that is\n end-of-life. From 0.13.0 on, Windows XP is no longer supported. Users are\n-suggested to upgrade to a newer verion of Windows, or install an alternative OS\n+suggested to upgrade to a newer version of Windows, or install an alternative OS\n that is supported.\n \n No attempt is made to prevent installing or running the software on Windows XP,\n@@ -41,81 +41,7 @@ report issues about Windows XP to the issue tracker.\n Notable changes\n ===============\n \n-Database cache memory increased\n---------------------------------\n-\n-As a result of growth of the UTXO set, performance with the prior default\n-database cache of 100 MiB has suffered.\n-For this reason the default was changed to 300 MiB in this release.\n-\n-For nodes on low-memory systems, the database cache can be changed back to\n-100 MiB (or to another value) by either:\n-\n-- Adding `dbcache=100` in bitcoin.conf\n-- Changing it in the GUI under `Options \u2192 Size of database cache`\n-\n-Note that the database cache setting has the most performance impact\n-during initial sync of a node, and when catching up after downtime.\n-\n-bitcoin-cli: arguments privacy\n---------------------------------\n-\n-The RPC command line client gained a new argument, `-stdin`\n-to read extra arguments from standard input, one per line until EOF/Ctrl-D.\n-For example:\n-\n-    $ echo -e \"mysecretcode\\n120\" | src/bitcoin-cli -stdin walletpassphrase\n-\n-It is recommended to use this for sensitive information such as wallet\n-passphrases, as command-line arguments can usually be read from the process\n-table by any user on the system.\n-\n-RPC low-level changes\n-----------------------\n-\n-- `gettxoutsetinfo` UTXO hash (`hash_serialized`) has changed. There was a divergence between\n-  32-bit and 64-bit platforms, and the txids were missing in the hashed data. This has been\n-  fixed, but this means that the output will be different than from previous versions.\n-\n-- Full UTF-8 support in the RPC API. Non-ASCII characters in, for example,\n-  wallet labels have always been malformed because they weren't taken into account\n-  properly in JSON RPC processing. This is no longer the case. This also affects\n-  the GUI debug console.\n-\n-C++11 and Python 3\n--------------------\n-\n-Various code modernizations have been done. The Bitcoin Core code base has\n-started using C++11. This means that a C++11-capable compiler is now needed for\n-building. Effectively this means GCC 4.7 or higher, or Clang 3.3 or higher.\n-\n-When cross-compiling for a target that doesn't have C++11 libraries, configure with\n-`./configure --enable-glibc-back-compat ... LDFLAGS=-static-libstdc++`.\n-\n-For running the functional tests in `qa/rpc-tests`, Python3.4 or higher is now\n-required.\n-\n-Linux ARM builds\n-------------------\n-\n-Due to popular request, Linux ARM builds have been added to the uploaded\n-executables.\n-\n-The following extra files can be found in the download directory or torrent:\n-\n-- `bitcoin-${VERSION}-arm-linux-gnueabihf.tar.gz`: Linux binaries for the most\n-  common 32-bit ARM architecture.\n-- `bitcoin-${VERSION}-aarch64-linux-gnu.tar.gz`: Linux binaries for the most\n-  common 64-bit ARM architecture.\n-\n-ARM builds are still experimental. If you have problems on a certain device or\n-Linux distribution combination please report them on the bug tracker, it may be\n-possible to resolve them.\n-\n-Note that Android is not considered ARM Linux in this context. The executables\n-are not expected to work out of the box on Android.\n-\n-0.13.0 Change log\n+0.14.0 Change log\n =================\n \n Detailed release notes follow. This overview includes changes that affect\n@@ -125,83 +51,28 @@ git merge commit are mentioned.\n \n ### RPC and REST\n \n-Asm script outputs replacements for OP_NOP2 and OP_NOP3\n--------------------------------------------------------\n-\n-OP_NOP2 has been renamed to OP_CHECKLOCKTIMEVERIFY by [BIP \n-65](https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki)\n-\n-OP_NOP3 has been renamed to OP_CHECKSEQUENCEVERIFY by [BIP \n-112](https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki)\n-\n-The following outputs are affected by this change:\n-- RPC `getrawtransaction` (in verbose mode)\n-- RPC `decoderawtransaction`\n-- RPC `decodescript`\n-- REST `/rest/tx/` (JSON format)\n-- REST `/rest/block/` (JSON format when including extended tx details)\n-- `bitcoin-tx -json`\n-\n-New mempool information RPC calls\n----------------------------------\n-\n-RPC calls have been added to output detailed statistics for individual mempool\n-entries, as well as to calculate the in-mempool ancestors or descendants of a\n-transaction: see `getmempoolentry`, `getmempoolancestors`, `getmempooldescendants`.\n-\n-### ZMQ\n-\n-Each ZMQ notification now contains an up-counting sequence number that allows\n-listeners to detect lost notifications.\n-The sequence number is always the last element in a multi-part ZMQ notification and\n-therefore backward compatible.\n-Each message type has its own counter.\n-(https://github.com/bitcoin/bitcoin/pull/7762)\n-\n ### Configuration and command-line options\n \n ### Block and transaction handling\n \n ### P2P protocol and network code\n \n-The p2p alert system has been removed in #7692 and the 'alert' message is no longer supported.\n-\n-\n-Fee filtering of invs (BIP 133)\n-------------------------------------\n-\n-The optional new p2p message \"feefilter\" is implemented and the protocol\n-version is bumped to 70013. Upon receiving a feefilter message from a peer,\n-a node will not send invs for any transactions which do not meet the filter\n-feerate. [BIP 133](https://github.com/bitcoin/bips/blob/master/bip-0133.mediawiki)\n-\n ### Validation\n \n ### Build system\n \n ### Wallet\n \n-Hierarchical Deterministic Key Generation\n------------------------------------------\n-Newly created wallets will use hierarchical deterministic key generation\n-according to BIP32 (keypath m/0'/0'/k').\n-Existing wallets will still use traditional key generation.\n-\n-Backups of HD wallets, regardless of when they have been created, can\n-therefore be used to re-generate all possible private keys, even the\n-ones which haven't already been generated during the time of the backup.\n-\n-HD key generation for new wallets can be disabled by `-usehd=0`. Keep in\n-mind that this flag only has affect on newly created wallets.\n-You can't disable HD key generation once you have created a HD wallet.\n-\n-There is no distinction between internal (change) and external keys.\n-\n-[Pull request](https://github.com/bitcoin/bitcoin/pull/8035/files), [BIP 32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)\n-\n ### GUI\n \n ### Tests\n \n ### Miscellaneous\n \n+Credits\n+=======\n+\n+Thanks to everyone who directly contributed to this release:\n+\n+\n+As well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/)."
      },
      {
        "sha": "cf74a1797520713b405da0ac47e54fb978e344da",
        "filename": "doc/release-notes/release-notes-0.12.0.md",
        "status": "modified",
        "additions": 8,
        "deletions": 4,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/doc/release-notes/release-notes-0.12.0.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/doc/release-notes/release-notes-0.12.0.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.12.0.md?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -104,9 +104,6 @@ announcing their headers directly, instead of just announcing the hash. In a\n reorganization, all new headers are sent, instead of just the new tip. This\n can often prevent an extra roundtrip before the actual block is downloaded.\n \n-With this change, pruning nodes are now able to relay new blocks to compatible\n-peers.\n-\n Memory pool limiting\n --------------------\n \n@@ -188,6 +185,14 @@ the OP_RETURN. The limit on OP_RETURN output size is now applied to the entire\n serialized scriptPubKey, 83 bytes by default. (the previous 80 byte default plus\n three bytes overhead)\n \n+Relay: New and only new blocks relayed when pruning\n+---------------------------------------------------\n+\n+When running in pruned mode, the client will now relay new blocks. When\n+responding to the `getblocks` message, only hashes of blocks that are on disk\n+and are likely to remain there for some reasonable time window (1 hour) will be\n+returned (previously all relevant hashes were returned).\n+\n Relay and Mining: Priority transactions\n ---------------------------------------\n \n@@ -887,4 +892,3 @@ Thanks to everyone who directly contributed to this release:\n - zathras-crypto\n \n As well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/).\n-"
      },
      {
        "sha": "41c1ac8556b1abdb65c65246a36660b60c0c9484",
        "filename": "doc/release-process.md",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/doc/release-process.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/doc/release-process.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-process.md?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -112,16 +112,16 @@ The gbuild invocations below <b>DO NOT DO THIS</b> by default.\n ### Build and sign Bitcoin Core for Linux, Windows, and OS X:\n \n     pushd ./gitian-builder\n-    ./bin/gbuild --commit bitcoin=v${VERSION} ../bitcoin/contrib/gitian-descriptors/gitian-linux.yml\n+    ./bin/gbuild --memory 3000 --commit bitcoin=v${VERSION} ../bitcoin/contrib/gitian-descriptors/gitian-linux.yml\n     ./bin/gsign --signer $SIGNER --release ${VERSION}-linux --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-linux.yml\n     mv build/out/bitcoin-*.tar.gz build/out/src/bitcoin-*.tar.gz ../\n \n-    ./bin/gbuild --commit bitcoin=v${VERSION} ../bitcoin/contrib/gitian-descriptors/gitian-win.yml\n+    ./bin/gbuild --memory 3000 --commit bitcoin=v${VERSION} ../bitcoin/contrib/gitian-descriptors/gitian-win.yml\n     ./bin/gsign --signer $SIGNER --release ${VERSION}-win-unsigned --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-win.yml\n     mv build/out/bitcoin-*-win-unsigned.tar.gz inputs/bitcoin-win-unsigned.tar.gz\n     mv build/out/bitcoin-*.zip build/out/bitcoin-*.exe ../\n \n-    ./bin/gbuild --commit bitcoin=v${VERSION} ../bitcoin/contrib/gitian-descriptors/gitian-osx.yml\n+    ./bin/gbuild --memory 3000 --commit bitcoin=v${VERSION} ../bitcoin/contrib/gitian-descriptors/gitian-osx.yml\n     ./bin/gsign --signer $SIGNER --release ${VERSION}-osx-unsigned --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-osx.yml\n     mv build/out/bitcoin-*-osx-unsigned.tar.gz inputs/bitcoin-osx-unsigned.tar.gz\n     mv build/out/bitcoin-*.tar.gz build/out/bitcoin-*.dmg ../"
      },
      {
        "sha": "d8a85292e8ed8faa62a7860c320e09ce710a72d6",
        "filename": "doc/translation_process.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/doc/translation_process.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/doc/translation_process.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/translation_process.md?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -94,7 +94,7 @@ When new plurals are added to the source file, it's important to do the followin\n 7. Save the source file\n \n ### Translating a new language\n-To create a new language template, you will need to edit the languages manifest file `src/qt/bitcoin.qrc` and add a new entry. Below is an example of the english language entry.\n+To create a new language template, you will need to edit the languages manifest file `src/qt/bitcoin.qrc` and add a new entry. Below is an example of the English language entry.\n \n ```xml\n <qresource prefix=\"/translations\">"
      },
      {
        "sha": "a0951f31a0ecbd053b707a0b98e465a18902e29c",
        "filename": "qa/pull-tester/rpc-tests.py",
        "status": "modified",
        "additions": 7,
        "deletions": 3,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/qa/pull-tester/rpc-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/qa/pull-tester/rpc-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -107,10 +107,13 @@\n     'bip68-112-113-p2p.py',\n     'wallet.py',\n     'wallet-hd.py',\n+    'wallet-dump.py',\n     'listtransactions.py',\n     'receivedby.py',\n     'mempool_resurrect_test.py',\n     'txn_doublespend.py --mineblock',\n+    'p2p-segwit.py',\n+    'segwit.py',\n     'txn_clone.py',\n     'getchaintips.py',\n     'rawtransactions.py',\n@@ -132,15 +135,15 @@\n     'disablewallet.py',\n     'sendheaders.py',\n     'keypool.py',\n+    'p2p-mempool.py',\n     'prioritise_transaction.py',\n     'invalidblockrequest.py',\n     'invalidtxrequest.py',\n     'abandonconflict.py',\n     'p2p-versionbits-warning.py',\n-    'p2p-segwit.py',\n-    'segwit.py',\n     'importprunedfunds.py',\n     'signmessages.py',\n+    'p2p-compactblocks.py',\n ]\n if ENABLE_ZMQ:\n     testScripts.append('zmq_test.py')\n@@ -158,7 +161,7 @@\n     'txn_clone.py --mineblock',\n     'forknotify.py',\n     'invalidateblock.py',\n-#    'rpcbind_test.py', #temporary, bug in libevent, see #6655\n+    'rpcbind_test.py',\n     'smartfees.py',\n     'maxblocksinflight.py',\n     'p2p-acceptblock.py',\n@@ -192,6 +195,7 @@ def runtests():\n         coverage = RPCCoverage()\n         print(\"Initializing coverage directory at %s\\n\" % coverage.dir)\n     flags = [\"--srcdir=%s/src\" % BUILDDIR] + passon_args\n+    flags.append(\"--cachedir=%s/qa/cache\" % BUILDDIR)\n     if coverage:\n         flags.append(coverage.flag)\n "
      },
      {
        "sha": "874df487777cf6d9e4f028d282782eec7536b23f",
        "filename": "qa/rpc-tests/abandonconflict.py",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/abandonconflict.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/abandonconflict.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/abandonconflict.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -68,7 +68,7 @@ def run_test(self):\n \n         # In mempool txs from self should increase balance from change\n         newbalance = self.nodes[0].getbalance()\n-        assert(newbalance == balance - Decimal(\"30\") + Decimal(\"24.9996\"))\n+        assert_equal(newbalance, balance - Decimal(\"30\") + Decimal(\"24.9996\"))\n         balance = newbalance\n \n         # Restart the node with a higher min relay fee so the parent tx is no longer in mempool\n@@ -78,16 +78,16 @@ def run_test(self):\n         self.nodes[0]=start_node(0, self.options.tmpdir, [\"-debug\",\"-logtimemicros\",\"-minrelaytxfee=0.0001\"])\n \n         # Verify txs no longer in mempool\n-        assert(len(self.nodes[0].getrawmempool()) == 0)\n+        assert_equal(len(self.nodes[0].getrawmempool()), 0)\n \n         # Not in mempool txs from self should only reduce balance\n         # inputs are still spent, but change not received\n         newbalance = self.nodes[0].getbalance()\n-        assert(newbalance == balance - Decimal(\"24.9996\"))\n+        assert_equal(newbalance, balance - Decimal(\"24.9996\"))\n         # Unconfirmed received funds that are not in mempool, also shouldn't show\n         # up in unconfirmed balance\n         unconfbalance = self.nodes[0].getunconfirmedbalance() + self.nodes[0].getbalance()\n-        assert(unconfbalance == newbalance)\n+        assert_equal(unconfbalance, newbalance)\n         # Also shouldn't show up in listunspent\n         assert(not txABC2 in [utxo[\"txid\"] for utxo in self.nodes[0].listunspent(0)])\n         balance = newbalance\n@@ -96,35 +96,35 @@ def run_test(self):\n         # including that the child tx was also abandoned\n         self.nodes[0].abandontransaction(txAB1)\n         newbalance = self.nodes[0].getbalance()\n-        assert(newbalance == balance + Decimal(\"30\"))\n+        assert_equal(newbalance, balance + Decimal(\"30\"))\n         balance = newbalance\n \n         # Verify that even with a low min relay fee, the tx is not reaccepted from wallet on startup once abandoned\n         stop_node(self.nodes[0],0)\n         self.nodes[0]=start_node(0, self.options.tmpdir, [\"-debug\",\"-logtimemicros\",\"-minrelaytxfee=0.00001\"])\n-        assert(len(self.nodes[0].getrawmempool()) == 0)\n-        assert(self.nodes[0].getbalance() == balance)\n+        assert_equal(len(self.nodes[0].getrawmempool()), 0)\n+        assert_equal(self.nodes[0].getbalance(), balance)\n \n         # But if its received again then it is unabandoned\n         # And since now in mempool, the change is available\n         # But its child tx remains abandoned\n         self.nodes[0].sendrawtransaction(signed[\"hex\"])\n         newbalance = self.nodes[0].getbalance()\n-        assert(newbalance == balance - Decimal(\"20\") + Decimal(\"14.99998\"))\n+        assert_equal(newbalance, balance - Decimal(\"20\") + Decimal(\"14.99998\"))\n         balance = newbalance\n \n         # Send child tx again so its unabandoned\n         self.nodes[0].sendrawtransaction(signed2[\"hex\"])\n         newbalance = self.nodes[0].getbalance()\n-        assert(newbalance == balance - Decimal(\"10\") - Decimal(\"14.99998\") + Decimal(\"24.9996\"))\n+        assert_equal(newbalance, balance - Decimal(\"10\") - Decimal(\"14.99998\") + Decimal(\"24.9996\"))\n         balance = newbalance\n \n         # Remove using high relay fee again\n         stop_node(self.nodes[0],0)\n         self.nodes[0]=start_node(0, self.options.tmpdir, [\"-debug\",\"-logtimemicros\",\"-minrelaytxfee=0.0001\"])\n-        assert(len(self.nodes[0].getrawmempool()) == 0)\n+        assert_equal(len(self.nodes[0].getrawmempool()), 0)\n         newbalance = self.nodes[0].getbalance()\n-        assert(newbalance == balance - Decimal(\"24.9996\"))\n+        assert_equal(newbalance, balance - Decimal(\"24.9996\"))\n         balance = newbalance\n \n         # Create a double spend of AB1 by spending again from only A's 10 output\n@@ -143,15 +143,15 @@ def run_test(self):\n \n         # Verify that B and C's 10 BTC outputs are available for spending again because AB1 is now conflicted\n         newbalance = self.nodes[0].getbalance()\n-        assert(newbalance == balance + Decimal(\"20\"))\n+        assert_equal(newbalance, balance + Decimal(\"20\"))\n         balance = newbalance\n \n         # There is currently a minor bug around this and so this test doesn't work.  See Issue #7315\n         # Invalidate the block with the double spend and B's 10 BTC output should no longer be available\n         # Don't think C's should either\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n         newbalance = self.nodes[0].getbalance()\n-        #assert(newbalance == balance - Decimal(\"10\"))\n+        #assert_equal(newbalance, balance - Decimal(\"10\"))\n         print(\"If balance has not declined after invalidateblock then out of mempool wallet tx which is no longer\")\n         print(\"conflicted has not resumed causing its inputs to be seen as spent.  See Issue #7315\")\n         print(str(balance) + \" -> \" + str(newbalance) + \" ?\")"
      },
      {
        "sha": "e903b2fbf07b329746081dfe0c98c3c322736bbc",
        "filename": "qa/rpc-tests/bip65-cltv-p2p.py",
        "status": "modified",
        "additions": 20,
        "deletions": 20,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/bip65-cltv-p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/bip65-cltv-p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bip65-cltv-p2p.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -71,9 +71,9 @@ def get_tests(self):\n         self.nodeaddress = self.nodes[0].getnewaddress()\n         self.last_block_time = int(time.time())\n \n-        ''' 98 more version 3 blocks '''\n+        ''' 398 more version 3 blocks '''\n         test_blocks = []\n-        for i in range(98):\n+        for i in range(398):\n             block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n             block.nVersion = 3\n             block.rehash()\n@@ -118,24 +118,6 @@ def get_tests(self):\n         height += 1\n         yield TestInstance([[block, True]])\n \n-        '''\n-        Check that the new CLTV rules are enforced in the 751st version 4\n-        block.\n-        '''\n-        spendtx = self.create_transaction(self.nodes[0],\n-                self.coinbase_blocks[1], self.nodeaddress, 1.0)\n-        cltv_invalidate(spendtx)\n-        spendtx.rehash()\n-\n-        block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n-        block.nVersion = 4\n-        block.vtx.append(spendtx)\n-        block.hashMerkleRoot = block.calc_merkle_root()\n-        block.rehash()\n-        block.solve()\n-        self.last_block_time += 1\n-        yield TestInstance([[block, False]])\n-\n         ''' Mine 199 new version blocks on last valid tip '''\n         test_blocks = []\n         for i in range(199):\n@@ -169,6 +151,24 @@ def get_tests(self):\n         height += 1\n         yield TestInstance([[block, True]])\n \n+        '''\n+        Check that the new CLTV rules are enforced in the 951st version 4\n+        block.\n+        '''\n+        spendtx = self.create_transaction(self.nodes[0],\n+                self.coinbase_blocks[1], self.nodeaddress, 1.0)\n+        cltv_invalidate(spendtx)\n+        spendtx.rehash()\n+\n+        block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n+        block.nVersion = 4\n+        block.vtx.append(spendtx)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        block.rehash()\n+        block.solve()\n+        self.last_block_time += 1\n+        yield TestInstance([[block, False]])\n+\n         ''' Mine 1 old version block, should be invalid '''\n         block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n         block.nVersion = 3"
      },
      {
        "sha": "baa77b92a05bbfb69551245021bf9248bf2708c2",
        "filename": "qa/rpc-tests/bip65-cltv.py",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/bip65-cltv.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/bip65-cltv.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bip65-cltv.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -30,7 +30,8 @@ def run_test(self):\n         cnt = self.nodes[0].getblockcount()\n \n         # Mine some old-version blocks\n-        self.nodes[1].generate(100)\n+        self.nodes[1].generate(200)\n+        cnt += 100\n         self.sync_all()\n         if (self.nodes[0].getblockcount() != cnt + 100):\n             raise AssertionError(\"Failed to mine 100 version=3 blocks\")"
      },
      {
        "sha": "3bad5af5e67a44dd623201d75980a4461162a434",
        "filename": "qa/rpc-tests/bipdersig-p2p.py",
        "status": "modified",
        "additions": 21,
        "deletions": 21,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/bipdersig-p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/bipdersig-p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bipdersig-p2p.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -79,9 +79,9 @@ def get_tests(self):\n         self.nodeaddress = self.nodes[0].getnewaddress()\n         self.last_block_time = int(time.time())\n \n-        ''' 98 more version 2 blocks '''\n+        ''' 298 more version 2 blocks '''\n         test_blocks = []\n-        for i in range(98):\n+        for i in range(298):\n             block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n             block.nVersion = 2\n             block.rehash()\n@@ -124,25 +124,7 @@ def get_tests(self):\n         self.last_block_time += 1\n         self.tip = block.sha256\n         height += 1\n-        yield TestInstance([[block, True]])\n-\n-        ''' \n-        Check that the new DERSIG rules are enforced in the 751st version 3\n-        block.\n-        '''\n-        spendtx = self.create_transaction(self.nodes[0],\n-                self.coinbase_blocks[1], self.nodeaddress, 1.0)\n-        unDERify(spendtx)\n-        spendtx.rehash()\n-\n-        block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n-        block.nVersion = 3\n-        block.vtx.append(spendtx)\n-        block.hashMerkleRoot = block.calc_merkle_root()\n-        block.rehash()\n-        block.solve()\n-        self.last_block_time += 1\n-        yield TestInstance([[block, False]])\n+        yield TestInstance([[block, True]])       \n \n         ''' Mine 199 new version blocks on last valid tip '''\n         test_blocks = []\n@@ -177,6 +159,24 @@ def get_tests(self):\n         height += 1\n         yield TestInstance([[block, True]])\n \n+        ''' \n+        Check that the new DERSIG rules are enforced in the 951st version 3\n+        block.\n+        '''\n+        spendtx = self.create_transaction(self.nodes[0],\n+                self.coinbase_blocks[1], self.nodeaddress, 1.0)\n+        unDERify(spendtx)\n+        spendtx.rehash()\n+\n+        block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n+        block.nVersion = 3\n+        block.vtx.append(spendtx)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        block.rehash()\n+        block.solve()\n+        self.last_block_time += 1\n+        yield TestInstance([[block, False]])\n+\n         ''' Mine 1 old version block, should be invalid '''\n         block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n         block.nVersion = 2"
      },
      {
        "sha": "fa3947656809c26466fe065f553842317cdecd1c",
        "filename": "qa/rpc-tests/keypool.py",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/keypool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/keypool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/keypool.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -12,13 +12,23 @@ class KeyPoolTest(BitcoinTestFramework):\n \n     def run_test(self):\n         nodes = self.nodes\n+        addr_before_encrypting = nodes[0].getnewaddress()\n+        addr_before_encrypting_data = nodes[0].validateaddress(addr_before_encrypting)\n+        wallet_info_old = nodes[0].getwalletinfo()\n+        assert(addr_before_encrypting_data['hdmasterkeyid'] == wallet_info_old['hdmasterkeyid'])\n+        \n         # Encrypt wallet and wait to terminate\n         nodes[0].encryptwallet('test')\n         bitcoind_processes[0].wait()\n         # Restart node 0\n         nodes[0] = start_node(0, self.options.tmpdir)\n         # Keep creating keys\n         addr = nodes[0].getnewaddress()\n+        addr_data = nodes[0].validateaddress(addr)\n+        wallet_info = nodes[0].getwalletinfo()\n+        assert(addr_before_encrypting_data['hdmasterkeyid'] != wallet_info['hdmasterkeyid'])\n+        assert(addr_data['hdmasterkeyid'] == wallet_info['hdmasterkeyid'])\n+        \n         try:\n             addr = nodes[0].getnewaddress()\n             raise AssertionError('Keypool should be exhausted after one address')"
      },
      {
        "sha": "7fe7ecc16c6e19ae3fb4e9ece144f28fcee60740",
        "filename": "qa/rpc-tests/p2p-compactblocks.py",
        "status": "added",
        "additions": 608,
        "deletions": 0,
        "changes": 608,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/p2p-compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/p2p-compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-compactblocks.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -0,0 +1,608 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.mininode import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.blocktools import create_block, create_coinbase\n+from test_framework.siphash import siphash256\n+from test_framework.script import CScript, OP_TRUE\n+\n+'''\n+CompactBlocksTest -- test compact blocks (BIP 152)\n+'''\n+\n+\n+# TestNode: A peer we use to send messages to bitcoind, and store responses.\n+class TestNode(SingleNodeConnCB):\n+    def __init__(self):\n+        SingleNodeConnCB.__init__(self)\n+        self.last_sendcmpct = None\n+        self.last_headers = None\n+        self.last_inv = None\n+        self.last_cmpctblock = None\n+        self.block_announced = False\n+        self.last_getdata = None\n+        self.last_getblocktxn = None\n+        self.last_block = None\n+        self.last_blocktxn = None\n+\n+    def on_sendcmpct(self, conn, message):\n+        self.last_sendcmpct = message\n+\n+    def on_block(self, conn, message):\n+        self.last_block = message\n+\n+    def on_cmpctblock(self, conn, message):\n+        self.last_cmpctblock = message\n+        self.block_announced = True\n+\n+    def on_headers(self, conn, message):\n+        self.last_headers = message\n+        self.block_announced = True\n+\n+    def on_inv(self, conn, message):\n+        self.last_inv = message\n+        self.block_announced = True\n+\n+    def on_getdata(self, conn, message):\n+        self.last_getdata = message\n+\n+    def on_getblocktxn(self, conn, message):\n+        self.last_getblocktxn = message\n+\n+    def on_blocktxn(self, conn, message):\n+        self.last_blocktxn = message\n+\n+    # Requires caller to hold mininode_lock\n+    def received_block_announcement(self):\n+        return self.block_announced\n+\n+    def clear_block_announcement(self):\n+        with mininode_lock:\n+            self.block_announced = False\n+            self.last_inv = None\n+            self.last_headers = None\n+            self.last_cmpctblock = None\n+\n+    def get_headers(self, locator, hashstop):\n+        msg = msg_getheaders()\n+        msg.locator.vHave = locator\n+        msg.hashstop = hashstop\n+        self.connection.send_message(msg)\n+\n+    def send_header_for_blocks(self, new_blocks):\n+        headers_message = msg_headers()\n+        headers_message.headers = [CBlockHeader(b) for b in new_blocks]\n+        self.send_message(headers_message)\n+\n+\n+class CompactBlocksTest(BitcoinTestFramework):\n+    def __init__(self):\n+        super().__init__()\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.utxos = []\n+\n+    def setup_network(self):\n+        self.nodes = []\n+\n+        # Turn off segwit in this test, as compact blocks don't currently work\n+        # with segwit.  (After BIP 152 is updated to support segwit, we can\n+        # test behavior with and without segwit enabled by adding a second node\n+        # to the test.)\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, [[\"-debug\", \"-logtimemicros=1\", \"-bip9params=segwit:0:0\"]])\n+\n+    def build_block_on_tip(self):\n+        height = self.nodes[0].getblockcount()\n+        tip = self.nodes[0].getbestblockhash()\n+        mtp = self.nodes[0].getblockheader(tip)['mediantime']\n+        block = create_block(int(tip, 16), create_coinbase(height + 1), mtp + 1)\n+        block.solve()\n+        return block\n+\n+    # Create 10 more anyone-can-spend utxo's for testing.\n+    def make_utxos(self):\n+        block = self.build_block_on_tip()\n+        self.test_node.send_and_ping(msg_block(block))\n+        assert(int(self.nodes[0].getbestblockhash(), 16) == block.sha256)\n+        self.nodes[0].generate(100)\n+\n+        total_value = block.vtx[0].vout[0].nValue\n+        out_value = total_value // 10\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(block.vtx[0].sha256, 0), b''))\n+        for i in range(10):\n+            tx.vout.append(CTxOut(out_value, CScript([OP_TRUE])))\n+        tx.rehash()\n+\n+        block2 = self.build_block_on_tip()\n+        block2.vtx.append(tx)\n+        block2.hashMerkleRoot = block2.calc_merkle_root()\n+        block2.solve()\n+        self.test_node.send_and_ping(msg_block(block2))\n+        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block2.sha256)\n+        self.utxos.extend([[tx.sha256, i, out_value] for i in range(10)])\n+        return\n+\n+    # Test \"sendcmpct\":\n+    # - No compact block announcements or getdata(MSG_CMPCT_BLOCK) unless\n+    #   sendcmpct is sent.\n+    # - If sendcmpct is sent with version > 0, the message is ignored.\n+    # - If sendcmpct is sent with boolean 0, then block announcements are not\n+    #   made with compact blocks.\n+    # - If sendcmpct is then sent with boolean 1, then new block announcements\n+    #   are made with compact blocks.\n+    def test_sendcmpct(self):\n+        print(\"Testing SENDCMPCT p2p message... \")\n+\n+        # Make sure we get a version 0 SENDCMPCT message from our peer\n+        def received_sendcmpct():\n+            return (self.test_node.last_sendcmpct is not None)\n+        got_message = wait_until(received_sendcmpct, timeout=30)\n+        assert(got_message)\n+        assert_equal(self.test_node.last_sendcmpct.version, 1)\n+\n+        tip = int(self.nodes[0].getbestblockhash(), 16)\n+\n+        def check_announcement_of_new_block(node, peer, predicate):\n+            self.test_node.clear_block_announcement()\n+            node.generate(1)\n+            got_message = wait_until(peer.received_block_announcement, timeout=30)\n+            assert(got_message)\n+            with mininode_lock:\n+                assert(predicate)\n+\n+        # We shouldn't get any block announcements via cmpctblock yet.\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is None)\n+\n+        # Try one more time, this time after requesting headers.\n+        self.test_node.clear_block_announcement()\n+        self.test_node.get_headers(locator=[tip], hashstop=0)\n+        wait_until(self.test_node.received_block_announcement, timeout=30)\n+        self.test_node.clear_block_announcement()\n+\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is None and self.test_node.last_inv is not None)\n+\n+        # Now try a SENDCMPCT message with too-high version\n+        sendcmpct = msg_sendcmpct()\n+        sendcmpct.version = 2\n+        self.test_node.send_message(sendcmpct)\n+\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is None)\n+\n+        # Now try a SENDCMPCT message with valid version, but announce=False\n+        self.test_node.send_message(msg_sendcmpct())\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is None)\n+\n+        # Finally, try a SENDCMPCT message with announce=True\n+        sendcmpct.version = 1\n+        sendcmpct.announce = True\n+        self.test_node.send_message(sendcmpct)\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is not None)\n+\n+        # Try one more time\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is not None)\n+\n+        # Try one more time, after turning on sendheaders\n+        self.test_node.send_message(msg_sendheaders())\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is not None)\n+\n+        # Now turn off announcements\n+        sendcmpct.announce = False\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is None and self.test_node.last_headers is not None)\n+\n+    # This test actually causes bitcoind to (reasonably!) disconnect us, so do this last.\n+    def test_invalid_cmpctblock_message(self):\n+        print(\"Testing invalid index in cmpctblock message...\")\n+        self.nodes[0].generate(101)\n+        block = self.build_block_on_tip()\n+\n+        cmpct_block = P2PHeaderAndShortIDs()\n+        cmpct_block.header = CBlockHeader(block)\n+        cmpct_block.prefilled_txn_length = 1\n+        # This index will be too high\n+        prefilled_txn = PrefilledTransaction(1, block.vtx[0])\n+        cmpct_block.prefilled_txn = [prefilled_txn]\n+        self.test_node.send_and_ping(msg_cmpctblock(cmpct_block))\n+        assert(int(self.nodes[0].getbestblockhash(), 16) == block.hashPrevBlock)\n+\n+    # Compare the generated shortids to what we expect based on BIP 152, given\n+    # bitcoind's choice of nonce.\n+    def test_compactblock_construction(self):\n+        print(\"Testing compactblock headers and shortIDs are correct...\")\n+\n+        # Generate a bunch of transactions.\n+        self.nodes[0].generate(101)\n+        num_transactions = 25\n+        address = self.nodes[0].getnewaddress()\n+        for i in range(num_transactions):\n+            self.nodes[0].sendtoaddress(address, 0.1)\n+\n+        # Now mine a block, and look at the resulting compact block.\n+        self.test_node.clear_block_announcement()\n+        block_hash = int(self.nodes[0].generate(1)[0], 16)\n+\n+        # Store the raw block in our internal format.\n+        block = FromHex(CBlock(), self.nodes[0].getblock(\"%02x\" % block_hash, False))\n+        [tx.calc_sha256() for tx in block.vtx]\n+        block.rehash()\n+\n+        # Don't care which type of announcement came back for this test; just\n+        # request the compact block if we didn't get one yet.\n+        wait_until(self.test_node.received_block_announcement, timeout=30)\n+\n+        with mininode_lock:\n+            if self.test_node.last_cmpctblock is None:\n+                self.test_node.clear_block_announcement()\n+                inv = CInv(4, block_hash)  # 4 == \"CompactBlock\"\n+                self.test_node.send_message(msg_getdata([inv]))\n+\n+        wait_until(self.test_node.received_block_announcement, timeout=30)\n+\n+        # Now we should have the compactblock\n+        header_and_shortids = None\n+        with mininode_lock:\n+            assert(self.test_node.last_cmpctblock is not None)\n+            # Convert the on-the-wire representation to absolute indexes\n+            header_and_shortids = HeaderAndShortIDs(self.test_node.last_cmpctblock.header_and_shortids)\n+\n+        # Check that we got the right block!\n+        header_and_shortids.header.calc_sha256()\n+        assert_equal(header_and_shortids.header.sha256, block_hash)\n+\n+        # Make sure the prefilled_txn appears to have included the coinbase\n+        assert(len(header_and_shortids.prefilled_txn) >= 1)\n+        assert_equal(header_and_shortids.prefilled_txn[0].index, 0)\n+\n+        # Check that all prefilled_txn entries match what's in the block.\n+        for entry in header_and_shortids.prefilled_txn:\n+            entry.tx.calc_sha256()\n+            assert_equal(entry.tx.sha256, block.vtx[entry.index].sha256)\n+\n+        # Check that the cmpctblock message announced all the transactions.\n+        assert_equal(len(header_and_shortids.prefilled_txn) + len(header_and_shortids.shortids), len(block.vtx))\n+\n+        # And now check that all the shortids are as expected as well.\n+        # Determine the siphash keys to use.\n+        [k0, k1] = header_and_shortids.get_siphash_keys()\n+\n+        index = 0\n+        while index < len(block.vtx):\n+            if (len(header_and_shortids.prefilled_txn) > 0 and\n+                    header_and_shortids.prefilled_txn[0].index == index):\n+                # Already checked prefilled transactions above\n+                header_and_shortids.prefilled_txn.pop(0)\n+            else:\n+                shortid = calculate_shortid(k0, k1, block.vtx[index].sha256)\n+                assert_equal(shortid, header_and_shortids.shortids[0])\n+                header_and_shortids.shortids.pop(0)\n+            index += 1\n+\n+    # Test that bitcoind requests compact blocks when we announce new blocks\n+    # via header or inv, and that responding to getblocktxn causes the block\n+    # to be successfully reconstructed.\n+    def test_compactblock_requests(self):\n+        print(\"Testing compactblock requests... \")\n+\n+        # Try announcing a block with an inv or header, expect a compactblock\n+        # request\n+        for announce in [\"inv\", \"header\"]:\n+            block = self.build_block_on_tip()\n+            with mininode_lock:\n+                self.test_node.last_getdata = None\n+\n+            if announce == \"inv\":\n+                self.test_node.send_message(msg_inv([CInv(2, block.sha256)]))\n+            else:\n+                self.test_node.send_header_for_blocks([block])\n+            success = wait_until(lambda: self.test_node.last_getdata is not None, timeout=30)\n+            assert(success)\n+            assert_equal(len(self.test_node.last_getdata.inv), 1)\n+            assert_equal(self.test_node.last_getdata.inv[0].type, 4)\n+            assert_equal(self.test_node.last_getdata.inv[0].hash, block.sha256)\n+\n+            # Send back a compactblock message that omits the coinbase\n+            comp_block = HeaderAndShortIDs()\n+            comp_block.header = CBlockHeader(block)\n+            comp_block.nonce = 0\n+            comp_block.shortids = [1]  # this is useless, and wrong\n+            self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+            assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.hashPrevBlock)\n+            # Expect a getblocktxn message.\n+            with mininode_lock:\n+                assert(self.test_node.last_getblocktxn is not None)\n+                absolute_indexes = self.test_node.last_getblocktxn.block_txn_request.to_absolute()\n+            assert_equal(absolute_indexes, [0])  # should be a coinbase request\n+\n+            # Send the coinbase, and verify that the tip advances.\n+            msg = msg_blocktxn()\n+            msg.block_transactions.blockhash = block.sha256\n+            msg.block_transactions.transactions = [block.vtx[0]]\n+            self.test_node.send_and_ping(msg)\n+            assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+\n+    # Create a chain of transactions from given utxo, and add to a new block.\n+    def build_block_with_transactions(self, utxo, num_transactions):\n+        block = self.build_block_on_tip()\n+\n+        for i in range(num_transactions):\n+            tx = CTransaction()\n+            tx.vin.append(CTxIn(COutPoint(utxo[0], utxo[1]), b''))\n+            tx.vout.append(CTxOut(utxo[2] - 1000, CScript([OP_TRUE])))\n+            tx.rehash()\n+            utxo = [tx.sha256, 0, tx.vout[0].nValue]\n+            block.vtx.append(tx)\n+\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        block.solve()\n+        return block\n+\n+    # Test that we only receive getblocktxn requests for transactions that the\n+    # node needs, and that responding to them causes the block to be\n+    # reconstructed.\n+    def test_getblocktxn_requests(self):\n+        print(\"Testing getblocktxn requests...\")\n+\n+        # First try announcing compactblocks that won't reconstruct, and verify\n+        # that we receive getblocktxn messages back.\n+        utxo = self.utxos.pop(0)\n+\n+        block = self.build_block_with_transactions(utxo, 5)\n+        self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n+\n+        comp_block = HeaderAndShortIDs()\n+        comp_block.initialize_from_block(block)\n+\n+        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+        with mininode_lock:\n+            assert(self.test_node.last_getblocktxn is not None)\n+            absolute_indexes = self.test_node.last_getblocktxn.block_txn_request.to_absolute()\n+        assert_equal(absolute_indexes, [1, 2, 3, 4, 5])\n+        msg = msg_blocktxn()\n+        msg.block_transactions = BlockTransactions(block.sha256, block.vtx[1:])\n+        self.test_node.send_and_ping(msg)\n+        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+\n+        utxo = self.utxos.pop(0)\n+        block = self.build_block_with_transactions(utxo, 5)\n+        self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n+\n+        # Now try interspersing the prefilled transactions\n+        comp_block.initialize_from_block(block, prefill_list=[0, 1, 5])\n+        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+        with mininode_lock:\n+            assert(self.test_node.last_getblocktxn is not None)\n+            absolute_indexes = self.test_node.last_getblocktxn.block_txn_request.to_absolute()\n+        assert_equal(absolute_indexes, [2, 3, 4])\n+        msg.block_transactions = BlockTransactions(block.sha256, block.vtx[2:5])\n+        self.test_node.send_and_ping(msg)\n+        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+\n+        # Now try giving one transaction ahead of time.\n+        utxo = self.utxos.pop(0)\n+        block = self.build_block_with_transactions(utxo, 5)\n+        self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n+        self.test_node.send_and_ping(msg_tx(block.vtx[1]))\n+        assert(block.vtx[1].hash in self.nodes[0].getrawmempool())\n+\n+        # Prefill 4 out of the 6 transactions, and verify that only the one\n+        # that was not in the mempool is requested.\n+        comp_block.initialize_from_block(block, prefill_list=[0, 2, 3, 4])\n+        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+        with mininode_lock:\n+            assert(self.test_node.last_getblocktxn is not None)\n+            absolute_indexes = self.test_node.last_getblocktxn.block_txn_request.to_absolute()\n+        assert_equal(absolute_indexes, [5])\n+\n+        msg.block_transactions = BlockTransactions(block.sha256, [block.vtx[5]])\n+        self.test_node.send_and_ping(msg)\n+        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+\n+        # Now provide all transactions to the node before the block is\n+        # announced and verify reconstruction happens immediately.\n+        utxo = self.utxos.pop(0)\n+        block = self.build_block_with_transactions(utxo, 10)\n+        self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n+        for tx in block.vtx[1:]:\n+            self.test_node.send_message(msg_tx(tx))\n+        self.test_node.sync_with_ping()\n+        # Make sure all transactions were accepted.\n+        mempool = self.nodes[0].getrawmempool()\n+        for tx in block.vtx[1:]:\n+            assert(tx.hash in mempool)\n+\n+        # Clear out last request.\n+        with mininode_lock:\n+            self.test_node.last_getblocktxn = None\n+\n+        # Send compact block\n+        comp_block.initialize_from_block(block, prefill_list=[0])\n+        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+        with mininode_lock:\n+            # Shouldn't have gotten a request for any transaction\n+            assert(self.test_node.last_getblocktxn is None)\n+        # Tip should have updated\n+        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+\n+    # Incorrectly responding to a getblocktxn shouldn't cause the block to be\n+    # permanently failed.\n+    def test_incorrect_blocktxn_response(self):\n+        print(\"Testing handling of incorrect blocktxn responses...\")\n+\n+        if (len(self.utxos) == 0):\n+            self.make_utxos()\n+        utxo = self.utxos.pop(0)\n+\n+        block = self.build_block_with_transactions(utxo, 10)\n+        self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n+        # Relay the first 5 transactions from the block in advance\n+        for tx in block.vtx[1:6]:\n+            self.test_node.send_message(msg_tx(tx))\n+        self.test_node.sync_with_ping()\n+        # Make sure all transactions were accepted.\n+        mempool = self.nodes[0].getrawmempool()\n+        for tx in block.vtx[1:6]:\n+            assert(tx.hash in mempool)\n+\n+        # Send compact block\n+        comp_block = HeaderAndShortIDs()\n+        comp_block.initialize_from_block(block, prefill_list=[0])\n+        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+        absolute_indexes = []\n+        with mininode_lock:\n+            assert(self.test_node.last_getblocktxn is not None)\n+            absolute_indexes = self.test_node.last_getblocktxn.block_txn_request.to_absolute()\n+        assert_equal(absolute_indexes, [6, 7, 8, 9, 10])\n+\n+        # Now give an incorrect response.\n+        # Note that it's possible for bitcoind to be smart enough to know we're\n+        # lying, since it could check to see if the shortid matches what we're\n+        # sending, and eg disconnect us for misbehavior.  If that behavior\n+        # change were made, we could just modify this test by having a\n+        # different peer provide the block further down, so that we're still\n+        # verifying that the block isn't marked bad permanently. This is good\n+        # enough for now.\n+        msg = msg_blocktxn()\n+        msg.block_transactions = BlockTransactions(block.sha256, [block.vtx[5]] + block.vtx[7:])\n+        self.test_node.send_and_ping(msg)\n+\n+        # Tip should not have updated\n+        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.hashPrevBlock)\n+\n+        # We should receive a getdata request\n+        success = wait_until(lambda: self.test_node.last_getdata is not None, timeout=10)\n+        assert(success)\n+        assert_equal(len(self.test_node.last_getdata.inv), 1)\n+        assert_equal(self.test_node.last_getdata.inv[0].type, 2)\n+        assert_equal(self.test_node.last_getdata.inv[0].hash, block.sha256)\n+\n+        # Deliver the block\n+        self.test_node.send_and_ping(msg_block(block))\n+        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+\n+    def test_getblocktxn_handler(self):\n+        print(\"Testing getblocktxn handler...\")\n+\n+        # bitcoind won't respond for blocks whose height is more than 15 blocks\n+        # deep.\n+        MAX_GETBLOCKTXN_DEPTH = 15\n+        chain_height = self.nodes[0].getblockcount()\n+        current_height = chain_height\n+        while (current_height >= chain_height - MAX_GETBLOCKTXN_DEPTH):\n+            block_hash = self.nodes[0].getblockhash(current_height)\n+            block = FromHex(CBlock(), self.nodes[0].getblock(block_hash, False))\n+\n+            msg = msg_getblocktxn()\n+            msg.block_txn_request = BlockTransactionsRequest(int(block_hash, 16), [])\n+            num_to_request = random.randint(1, len(block.vtx))\n+            msg.block_txn_request.from_absolute(sorted(random.sample(range(len(block.vtx)), num_to_request)))\n+            self.test_node.send_message(msg)\n+            success = wait_until(lambda: self.test_node.last_blocktxn is not None, timeout=10)\n+            assert(success)\n+\n+            [tx.calc_sha256() for tx in block.vtx]\n+            with mininode_lock:\n+                assert_equal(self.test_node.last_blocktxn.block_transactions.blockhash, int(block_hash, 16))\n+                all_indices = msg.block_txn_request.to_absolute()\n+                for index in all_indices:\n+                    tx = self.test_node.last_blocktxn.block_transactions.transactions.pop(0)\n+                    tx.calc_sha256()\n+                    assert_equal(tx.sha256, block.vtx[index].sha256)\n+                self.test_node.last_blocktxn = None\n+            current_height -= 1\n+\n+        # Next request should be ignored, as we're past the allowed depth.\n+        block_hash = self.nodes[0].getblockhash(current_height)\n+        msg.block_txn_request = BlockTransactionsRequest(int(block_hash, 16), [0])\n+        self.test_node.send_and_ping(msg)\n+        with mininode_lock:\n+            assert_equal(self.test_node.last_blocktxn, None)\n+\n+    def test_compactblocks_not_at_tip(self):\n+        print(\"Testing compactblock requests/announcements not at chain tip...\")\n+\n+        # Test that requesting old compactblocks doesn't work.\n+        MAX_CMPCTBLOCK_DEPTH = 11\n+        new_blocks = []\n+        for i in range(MAX_CMPCTBLOCK_DEPTH):\n+            self.test_node.clear_block_announcement()\n+            new_blocks.append(self.nodes[0].generate(1)[0])\n+            wait_until(self.test_node.received_block_announcement, timeout=30)\n+\n+        self.test_node.clear_block_announcement()\n+        self.test_node.send_message(msg_getdata([CInv(4, int(new_blocks[0], 16))]))\n+        success = wait_until(lambda: self.test_node.last_cmpctblock is not None, timeout=30)\n+        assert(success)\n+\n+        self.test_node.clear_block_announcement()\n+        self.nodes[0].generate(1)\n+        wait_until(self.test_node.received_block_announcement, timeout=30)\n+        self.test_node.clear_block_announcement()\n+        self.test_node.send_message(msg_getdata([CInv(4, int(new_blocks[0], 16))]))\n+        success = wait_until(lambda: self.test_node.last_block is not None, timeout=30)\n+        assert(success)\n+        with mininode_lock:\n+            self.test_node.last_block.block.calc_sha256()\n+            assert_equal(self.test_node.last_block.block.sha256, int(new_blocks[0], 16))\n+\n+        # Generate an old compactblock, and verify that it's not accepted.\n+        cur_height = self.nodes[0].getblockcount()\n+        hashPrevBlock = int(self.nodes[0].getblockhash(cur_height-5), 16)\n+        block = self.build_block_on_tip()\n+        block.hashPrevBlock = hashPrevBlock\n+        block.solve()\n+\n+        comp_block = HeaderAndShortIDs()\n+        comp_block.initialize_from_block(block)\n+        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+\n+        tips = self.nodes[0].getchaintips()\n+        found = False\n+        for x in tips:\n+            if x[\"hash\"] == block.hash:\n+                assert_equal(x[\"status\"], \"headers-only\")\n+                found = True\n+                break\n+        assert(found)\n+\n+        # Requesting this block via getblocktxn should silently fail\n+        # (to avoid fingerprinting attacks).\n+        msg = msg_getblocktxn()\n+        msg.block_txn_request = BlockTransactionsRequest(block.sha256, [0])\n+        with mininode_lock:\n+            self.test_node.last_blocktxn = None\n+        self.test_node.send_and_ping(msg)\n+        with mininode_lock:\n+            assert(self.test_node.last_blocktxn is None)\n+\n+    def run_test(self):\n+        # Setup the p2p connections and start up the network thread.\n+        self.test_node = TestNode()\n+\n+        connections = []\n+        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], self.test_node))\n+        self.test_node.add_connection(connections[0])\n+\n+        NetworkThread().start()  # Start up network handling in another thread\n+\n+        # Test logic begins here\n+        self.test_node.wait_for_verack()\n+\n+        # We will need UTXOs to construct transactions in later tests.\n+        self.make_utxos()\n+\n+        self.test_sendcmpct()\n+        self.test_compactblock_construction()\n+        self.test_compactblock_requests()\n+        self.test_getblocktxn_requests()\n+        self.test_getblocktxn_handler()\n+        self.test_compactblocks_not_at_tip()\n+        self.test_incorrect_blocktxn_response()\n+        self.test_invalid_cmpctblock_message()\n+\n+\n+if __name__ == '__main__':\n+    CompactBlocksTest().main()"
      },
      {
        "sha": "96d99d38a73c13cbf43b99e8dd8cca57684b25e4",
        "filename": "qa/rpc-tests/p2p-feefilter.py",
        "status": "modified",
        "additions": 12,
        "deletions": 2,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/p2p-feefilter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/p2p-feefilter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-feefilter.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -62,6 +62,7 @@ def setup_network(self):\n \n     def run_test(self):\n         node1 = self.nodes[1]\n+        node0 = self.nodes[0]\n         # Get out of IBD\n         node1.generate(1)\n         sync_blocks(self.nodes)\n@@ -91,8 +92,17 @@ def run_test(self):\n         node1.settxfee(Decimal(\"0.00010000\"))\n         [node1.sendtoaddress(node1.getnewaddress(), 1) for x in range(3)]\n         sync_mempools(self.nodes) # must be sure node 0 has received all txs \n-        time.sleep(10) # wait 10 secs to be sure its doesn't relay any\n-        assert(allInvsMatch([], test_node))\n+\n+        # Send one transaction from node0 that should be received, so that we\n+        # we can sync the test on receipt (if node1's txs were relayed, they'd\n+        # be received by the time this node0 tx is received). This is\n+        # unfortunately reliant on the current relay behavior where we batch up\n+        # to 35 entries in an inv, which means that when this next transaction\n+        # is eligible for relay, the prior transactions from node1 are eligible\n+        # as well.\n+        node0.settxfee(Decimal(\"0.00020000\"))\n+        txids = [node0.sendtoaddress(node0.getnewaddress(), 1)]\n+        assert(allInvsMatch(txids, test_node))\n         test_node.clear_invs()\n \n         # Remove fee filter and check that txs are received again"
      },
      {
        "sha": "9aee81164f088c53c8cd5cdb94e69c346984a7ee",
        "filename": "qa/rpc-tests/p2p-fullblocktest.py",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/p2p-fullblocktest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/p2p-fullblocktest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-fullblocktest.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -25,9 +25,6 @@ def __init__(self, tx = CTransaction(), n = -1):\n each test.\n '''\n \n-def hash160(s):\n-    return hashlib.new('ripemd160', sha256(s)).digest()\n-\n #  Use this class for tests that require behavior other than normal \"mininode\" behavior.\n #  For now, it is used to serialize a bloated varint (b64).\n class CBrokenBlock(CBlock):"
      },
      {
        "sha": "5c5d778f429b9b664f339a30b3d13c8312b9db2b",
        "filename": "qa/rpc-tests/p2p-mempool.py",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/p2p-mempool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/p2p-mempool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-mempool.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -72,8 +72,11 @@ def send_mempool(self):\n         self.send_message(msg_mempool())\n \n class P2PMempoolTests(BitcoinTestFramework):\n-    def setup_chain(self):\n-        initialize_chain_clean(self.options.tmpdir, 2)\n+\n+    def __init__(self):\n+        super().__init__()\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n \n     def setup_network(self):\n         # Start a node with maxuploadtarget of 200 MB (/24h)"
      },
      {
        "sha": "eb857ed983b3ce7b81cd112bfdf3e3595da3be2d",
        "filename": "qa/rpc-tests/p2p-segwit.py",
        "status": "modified",
        "additions": 86,
        "deletions": 5,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/p2p-segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/p2p-segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-segwit.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -168,8 +168,11 @@ def __init__(self, sha256, n, nValue):\n \n \n class SegWitTest(BitcoinTestFramework):\n-    def setup_chain(self):\n-        initialize_chain_clean(self.options.tmpdir, 3)\n+\n+    def __init__(self):\n+        super().__init__()\n+        self.setup_clean_chain = True\n+        self.num_nodes = 3\n \n     def add_options(self, parser):\n         parser.add_option(\"--oldbinary\", dest=\"oldbinary\",\n@@ -1065,12 +1068,12 @@ def test_block_relay(self, segwit_activated):\n             assert_equal(wit_block.serialize(False), non_wit_block.serialize())\n             assert_equal(wit_block.serialize(True), block.serialize(True))\n \n-            # Test size, vsize, cost\n+            # Test size, vsize, weight\n             rpc_details = self.nodes[0].getblock(block.hash, True)\n             assert_equal(rpc_details[\"size\"], len(block.serialize(True)))\n             assert_equal(rpc_details[\"strippedsize\"], len(block.serialize(False)))\n-            cost = 3*len(block.serialize(False)) + len(block.serialize(True))\n-            assert_equal(rpc_details[\"cost\"], cost)\n+            weight = 3*len(block.serialize(False)) + len(block.serialize(True))\n+            assert_equal(rpc_details[\"weight\"], weight)\n \n             # Upgraded node should not ask for blocks from unupgraded\n             block4 = self.build_next_block(nVersion=4)\n@@ -1086,6 +1089,82 @@ def test_block_relay(self, segwit_activated):\n             self.old_node.announce_tx_and_wait_for_getdata(block4.vtx[0])\n             assert(block4.sha256 not in self.old_node.getdataset)\n \n+    # V0 segwit outputs should be standard after activation, but not before.\n+    def test_standardness_v0(self, segwit_activated):\n+        print(\"\\tTesting standardness of v0 outputs (%s activation)\" % (\"after\" if segwit_activated else \"before\"))\n+        assert(len(self.utxo))\n+\n+        witness_program = CScript([OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+\n+        p2sh_pubkey = hash160(witness_program)\n+        p2sh_scriptPubKey = CScript([OP_HASH160, p2sh_pubkey, OP_EQUAL])\n+\n+        # First prepare a p2sh output (so that spending it will pass standardness)\n+        p2sh_tx = CTransaction()\n+        p2sh_tx.vin = [CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\")]\n+        p2sh_tx.vout = [CTxOut(self.utxo[0].nValue-1000, p2sh_scriptPubKey)]\n+        p2sh_tx.rehash()\n+\n+        # Mine it on test_node to create the confirmed output.\n+        self.test_node.test_transaction_acceptance(p2sh_tx, with_witness=True, accepted=True)\n+        self.nodes[0].generate(1)\n+        sync_blocks(self.nodes)\n+\n+        # Now test standardness of v0 P2WSH outputs.\n+        # Start by creating a transaction with two outputs.\n+        tx = CTransaction()\n+        tx.vin = [CTxIn(COutPoint(p2sh_tx.sha256, 0), CScript([witness_program]))]\n+        tx.vout = [CTxOut(p2sh_tx.vout[0].nValue-10000, scriptPubKey)]\n+        tx.vout.append(CTxOut(8000, scriptPubKey)) # Might burn this later\n+        tx.rehash()\n+\n+        self.std_node.test_transaction_acceptance(tx, with_witness=True, accepted=segwit_activated)\n+\n+        # Now create something that looks like a P2PKH output. This won't be spendable.\n+        scriptPubKey = CScript([OP_0, hash160(witness_hash)])\n+        tx2 = CTransaction()\n+        if segwit_activated:\n+            # if tx was accepted, then we spend the second output.\n+            tx2.vin = [CTxIn(COutPoint(tx.sha256, 1), b\"\")]\n+            tx2.vout = [CTxOut(7000, scriptPubKey)]\n+            tx2.wit.vtxinwit.append(CTxInWitness())\n+            tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n+        else:\n+            # if tx wasn't accepted, we just re-spend the p2sh output we started with.\n+            tx2.vin = [CTxIn(COutPoint(p2sh_tx.sha256, 0), CScript([witness_program]))]\n+            tx2.vout = [CTxOut(p2sh_tx.vout[0].nValue-1000, scriptPubKey)]\n+        tx2.rehash()\n+\n+        self.std_node.test_transaction_acceptance(tx2, with_witness=True, accepted=segwit_activated)\n+\n+        # Now update self.utxo for later tests.\n+        tx3 = CTransaction()\n+        if segwit_activated:\n+            # tx and tx2 were both accepted.  Don't bother trying to reclaim the\n+            # P2PKH output; just send tx's first output back to an anyone-can-spend.\n+            sync_mempools(self.nodes)\n+            tx3.vin = [CTxIn(COutPoint(tx.sha256, 0), b\"\")]\n+            tx3.vout = [CTxOut(tx.vout[0].nValue-1000, CScript([OP_TRUE]))]\n+            tx3.wit.vtxinwit.append(CTxInWitness())\n+            tx3.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n+            tx3.rehash()\n+            self.test_node.test_transaction_acceptance(tx3, with_witness=True, accepted=True)\n+        else:\n+            # tx and tx2 didn't go anywhere; just clean up the p2sh_tx output.\n+            tx3.vin = [CTxIn(COutPoint(p2sh_tx.sha256, 0), CScript([witness_program]))]\n+            tx3.vout = [CTxOut(p2sh_tx.vout[0].nValue-1000, witness_program)]\n+            tx3.rehash()\n+            self.test_node.test_transaction_acceptance(tx3, with_witness=True, accepted=True)\n+\n+        self.nodes[0].generate(1)\n+        sync_blocks(self.nodes)\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n+        assert_equal(len(self.nodes[1].getrawmempool()), 0)\n+\n+\n     # Verify that future segwit upgraded transactions are non-standard,\n     # but valid in blocks. Can run this before and after segwit activation.\n     def test_segwit_versions(self):\n@@ -1658,6 +1737,7 @@ def run_test(self):\n         self.test_witness_tx_relay_before_segwit_activation()\n         self.test_block_relay(segwit_activated=False)\n         self.test_p2sh_witness(segwit_activated=False)\n+        self.test_standardness_v0(segwit_activated=False)\n \n         sync_blocks(self.nodes)\n \n@@ -1679,6 +1759,7 @@ def run_test(self):\n         self.test_witness_input_length()\n         self.test_block_relay(segwit_activated=True)\n         self.test_tx_relay_after_segwit_activation()\n+        self.test_standardness_v0(segwit_activated=True)\n         self.test_segwit_versions()\n         self.test_premature_coinbase_witness_spend()\n         self.test_signature_version_1()"
      },
      {
        "sha": "bf1cc8712611a7e962fc5dc0cfb9e70a7545ed59",
        "filename": "qa/rpc-tests/rpcbind_test.py",
        "status": "modified",
        "additions": 92,
        "deletions": 127,
        "changes": 219,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/rpcbind_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/rpcbind_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/rpcbind_test.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -5,143 +5,108 @@\n \n # Test for -rpcbind, as well as -rpcallowip and -rpcconnect\n \n-# TODO extend this test from the test framework (like all other tests)\n-\n import tempfile\n import traceback\n \n+from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n from test_framework.netutil import *\n \n-def run_bind_test(tmpdir, allow_ips, connect_to, addresses, expected):\n-    '''\n-    Start a node with requested rpcallowip and rpcbind parameters,\n-    then try to connect, and check if the set of bound addresses\n-    matches the expected set.\n-    '''\n-    expected = [(addr_to_hex(addr), port) for (addr, port) in expected]\n-    base_args = ['-disablewallet', '-nolisten']\n-    if allow_ips:\n-        base_args += ['-rpcallowip=' + x for x in allow_ips]\n-    binds = ['-rpcbind='+addr for addr in addresses]\n-    nodes = start_nodes(self.num_nodes, tmpdir, [base_args + binds], connect_to)\n-    try:\n-        pid = bitcoind_processes[0].pid\n-        assert_equal(set(get_bind_addrs(pid)), set(expected))\n-    finally:\n-        stop_nodes(nodes)\n-        wait_bitcoinds()\n-\n-def run_allowip_test(tmpdir, allow_ips, rpchost, rpcport):\n-    '''\n-    Start a node with rpcwallow IP, and request getinfo\n-    at a non-localhost IP.\n-    '''\n-    base_args = ['-disablewallet', '-nolisten'] + ['-rpcallowip='+x for x in allow_ips]\n-    nodes = start_nodes(self.num_nodes, tmpdir, [base_args])\n-    try:\n-        # connect to node through non-loopback interface\n-        url = \"http://rt:rt@%s:%d\" % (rpchost, rpcport,)\n-        node = get_rpc_proxy(url, 1)\n-        node.getinfo()\n-    finally:\n-        node = None # make sure connection will be garbage collected and closed\n-        stop_nodes(nodes)\n-        wait_bitcoinds()\n-\n-\n-def run_test(tmpdir):\n-    assert(sys.platform.startswith('linux')) # due to OS-specific network stats queries, this test works only on Linux\n-    # find the first non-loopback interface for testing\n-    non_loopback_ip = None\n-    for name,ip in all_interfaces():\n-        if ip != '127.0.0.1':\n-            non_loopback_ip = ip\n-            break\n-    if non_loopback_ip is None:\n-        assert(not 'This test requires at least one non-loopback IPv4 interface')\n-    print(\"Using interface %s for testing\" % non_loopback_ip)\n+class RPCBindTest(BitcoinTestFramework):\n \n-    defaultport = rpc_port(0)\n+    def __init__(self):\n+        super().__init__()\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n \n-    # check default without rpcallowip (IPv4 and IPv6 localhost)\n-    run_bind_test(tmpdir, None, '127.0.0.1', [],\n-        [('127.0.0.1', defaultport), ('::1', defaultport)])\n-    # check default with rpcallowip (IPv6 any)\n-    run_bind_test(tmpdir, ['127.0.0.1'], '127.0.0.1', [],\n-        [('::0', defaultport)])\n-    # check only IPv4 localhost (explicit)\n-    run_bind_test(tmpdir, ['127.0.0.1'], '127.0.0.1', ['127.0.0.1'],\n-        [('127.0.0.1', defaultport)])\n-    # check only IPv4 localhost (explicit) with alternative port\n-    run_bind_test(tmpdir, ['127.0.0.1'], '127.0.0.1:32171', ['127.0.0.1:32171'],\n-        [('127.0.0.1', 32171)])\n-    # check only IPv4 localhost (explicit) with multiple alternative ports on same host\n-    run_bind_test(tmpdir, ['127.0.0.1'], '127.0.0.1:32171', ['127.0.0.1:32171', '127.0.0.1:32172'],\n-        [('127.0.0.1', 32171), ('127.0.0.1', 32172)])\n-    # check only IPv6 localhost (explicit)\n-    run_bind_test(tmpdir, ['[::1]'], '[::1]', ['[::1]'],\n-        [('::1', defaultport)])\n-    # check both IPv4 and IPv6 localhost (explicit)\n-    run_bind_test(tmpdir, ['127.0.0.1'], '127.0.0.1', ['127.0.0.1', '[::1]'],\n-        [('127.0.0.1', defaultport), ('::1', defaultport)])\n-    # check only non-loopback interface\n-    run_bind_test(tmpdir, [non_loopback_ip], non_loopback_ip, [non_loopback_ip],\n-        [(non_loopback_ip, defaultport)])\n-\n-    # Check that with invalid rpcallowip, we are denied\n-    run_allowip_test(tmpdir, [non_loopback_ip], non_loopback_ip, defaultport)\n-    try:\n-        run_allowip_test(tmpdir, ['1.1.1.1'], non_loopback_ip, defaultport)\n-        assert(not 'Connection not denied by rpcallowip as expected')\n-    except ValueError:\n+    def setup_network(self):\n         pass\n \n-def main():\n-    import optparse\n-\n-    parser = optparse.OptionParser(usage=\"%prog [options]\")\n-    parser.add_option(\"--nocleanup\", dest=\"nocleanup\", default=False, action=\"store_true\",\n-                      help=\"Leave bitcoinds and test.* datadir on exit or error\")\n-    parser.add_option(\"--srcdir\", dest=\"srcdir\", default=\"../../src\",\n-                      help=\"Source directory containing bitcoind/bitcoin-cli (default: %default%)\")\n-    parser.add_option(\"--tmpdir\", dest=\"tmpdir\", default=tempfile.mkdtemp(prefix=\"test\"),\n-                      help=\"Root directory for datadirs\")\n-    (options, args) = parser.parse_args()\n-\n-    os.environ['PATH'] = options.srcdir+\":\"+os.environ['PATH']\n-\n-    check_json_precision()\n-\n-    success = False\n-    nodes = []\n-    try:\n-        print(\"Initializing test directory \"+options.tmpdir)\n-        if not os.path.isdir(options.tmpdir):\n-            os.makedirs(options.tmpdir)\n-        initialize_chain(options.tmpdir)\n-\n-        run_test(options.tmpdir)\n-\n-        success = True\n-\n-    except AssertionError as e:\n-        print(\"Assertion failed: \"+e.message)\n-    except Exception as e:\n-        print(\"Unexpected exception caught during testing: \"+str(e))\n-        traceback.print_tb(sys.exc_info()[2])\n-\n-    if not options.nocleanup:\n-        print(\"Cleaning up\")\n-        wait_bitcoinds()\n-        shutil.rmtree(options.tmpdir)\n+    def setup_nodes(self):\n+        pass\n \n-    if success:\n-        print(\"Tests successful\")\n-        sys.exit(0)\n-    else:\n-        print(\"Failed\")\n-        sys.exit(1)\n+    def run_bind_test(self, allow_ips, connect_to, addresses, expected):\n+        '''\n+        Start a node with requested rpcallowip and rpcbind parameters,\n+        then try to connect, and check if the set of bound addresses\n+        matches the expected set.\n+        '''\n+        expected = [(addr_to_hex(addr), port) for (addr, port) in expected]\n+        base_args = ['-disablewallet', '-nolisten']\n+        if allow_ips:\n+            base_args += ['-rpcallowip=' + x for x in allow_ips]\n+        binds = ['-rpcbind='+addr for addr in addresses]\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, [base_args + binds], connect_to)\n+        try:\n+            pid = bitcoind_processes[0].pid\n+            assert_equal(set(get_bind_addrs(pid)), set(expected))\n+        finally:\n+            stop_nodes(self.nodes)\n+            wait_bitcoinds()\n+\n+    def run_allowip_test(self, allow_ips, rpchost, rpcport):\n+        '''\n+        Start a node with rpcwallow IP, and request getinfo\n+        at a non-localhost IP.\n+        '''\n+        base_args = ['-disablewallet', '-nolisten'] + ['-rpcallowip='+x for x in allow_ips]\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, [base_args])\n+        try:\n+            # connect to node through non-loopback interface\n+            node = get_rpc_proxy(rpc_url(0, \"%s:%d\" % (rpchost, rpcport)), 0)\n+            node.getinfo()\n+        finally:\n+            node = None # make sure connection will be garbage collected and closed\n+            stop_nodes(self.nodes)\n+            wait_bitcoinds()\n+\n+    def run_test(self):\n+        # due to OS-specific network stats queries, this test works only on Linux\n+        assert(sys.platform.startswith('linux'))\n+        # find the first non-loopback interface for testing\n+        non_loopback_ip = None\n+        for name,ip in all_interfaces():\n+            if ip != '127.0.0.1':\n+                non_loopback_ip = ip\n+                break\n+        if non_loopback_ip is None:\n+            assert(not 'This test requires at least one non-loopback IPv4 interface')\n+        print(\"Using interface %s for testing\" % non_loopback_ip)\n+\n+        defaultport = rpc_port(0)\n+\n+        # check default without rpcallowip (IPv4 and IPv6 localhost)\n+        self.run_bind_test(None, '127.0.0.1', [],\n+            [('127.0.0.1', defaultport), ('::1', defaultport)])\n+        # check default with rpcallowip (IPv6 any)\n+        self.run_bind_test(['127.0.0.1'], '127.0.0.1', [],\n+            [('::0', defaultport)])\n+        # check only IPv4 localhost (explicit)\n+        self.run_bind_test(['127.0.0.1'], '127.0.0.1', ['127.0.0.1'],\n+            [('127.0.0.1', defaultport)])\n+        # check only IPv4 localhost (explicit) with alternative port\n+        self.run_bind_test(['127.0.0.1'], '127.0.0.1:32171', ['127.0.0.1:32171'],\n+            [('127.0.0.1', 32171)])\n+        # check only IPv4 localhost (explicit) with multiple alternative ports on same host\n+        self.run_bind_test(['127.0.0.1'], '127.0.0.1:32171', ['127.0.0.1:32171', '127.0.0.1:32172'],\n+            [('127.0.0.1', 32171), ('127.0.0.1', 32172)])\n+        # check only IPv6 localhost (explicit)\n+        self.run_bind_test(['[::1]'], '[::1]', ['[::1]'],\n+            [('::1', defaultport)])\n+        # check both IPv4 and IPv6 localhost (explicit)\n+        self.run_bind_test(['127.0.0.1'], '127.0.0.1', ['127.0.0.1', '[::1]'],\n+            [('127.0.0.1', defaultport), ('::1', defaultport)])\n+        # check only non-loopback interface\n+        self.run_bind_test([non_loopback_ip], non_loopback_ip, [non_loopback_ip],\n+            [(non_loopback_ip, defaultport)])\n+\n+        # Check that with invalid rpcallowip, we are denied\n+        self.run_allowip_test([non_loopback_ip], non_loopback_ip, defaultport)\n+        try:\n+            self.run_allowip_test(['1.1.1.1'], non_loopback_ip, defaultport)\n+            assert(not 'Connection not denied by rpcallowip as expected')\n+        except JSONRPCException:\n+            pass\n \n if __name__ == '__main__':\n-    main()\n+    RPCBindTest ().main ()"
      },
      {
        "sha": "da82b09901611398748d5098d2ccab87531a27c1",
        "filename": "qa/rpc-tests/segwit.py",
        "status": "modified",
        "additions": 49,
        "deletions": 10,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/segwit.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -69,11 +69,17 @@ def getutxo(txid):\n     utxo[\"txid\"] = txid\n     return utxo\n \n+def find_unspent(node, min_value):\n+    for utxo in node.listunspent():\n+        if utxo['amount'] >= min_value:\n+            return utxo\n+\n class SegWitTest(BitcoinTestFramework):\n \n-    def setup_chain(self):\n-        print(\"Initializing test directory \"+self.options.tmpdir)\n-        initialize_chain_clean(self.options.tmpdir, 3)\n+    def __init__(self):\n+        super().__init__()\n+        self.setup_clean_chain = True\n+        self.num_nodes = 3\n \n     def setup_network(self):\n         self.nodes = []\n@@ -117,8 +123,21 @@ def fail_mine(self, node, txid, sign, redeem_script=\"\"):\n         sync_blocks(self.nodes)\n \n     def run_test(self):\n-        self.nodes[0].generate(160) #block 160\n-\n+        self.nodes[0].generate(161) #block 161\n+\n+        print(\"Verify sigops are counted in GBT with pre-BIP141 rules before the fork\")\n+        txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n+        tmpl = self.nodes[0].getblocktemplate({})\n+        assert(tmpl['sigoplimit'] == 20000)\n+        assert(tmpl['transactions'][0]['hash'] == txid)\n+        assert(tmpl['transactions'][0]['sigops'] == 2)\n+        tmpl = self.nodes[0].getblocktemplate({'rules':['segwit']})\n+        assert(tmpl['sigoplimit'] == 20000)\n+        assert(tmpl['transactions'][0]['hash'] == txid)\n+        assert(tmpl['transactions'][0]['sigops'] == 2)\n+        self.nodes[0].generate(1) #block 162\n+\n+        balance_presetup = self.nodes[0].getbalance()\n         self.pubkey = []\n         p2sh_ids = [] # p2sh_ids[NODE][VER] is an array of txids that spend to a witness version VER pkscript to an address for NODE embedded in p2sh\n         wit_ids = [] # wit_ids[NODE][VER] is an array of txids that spend to a witness version VER pkscript to an address for NODE via bare witness\n@@ -137,18 +156,18 @@ def run_test(self):\n         for i in range(5):\n             for n in range(3):\n                 for v in range(2):\n-                    wit_ids[n][v].append(send_to_witness(v, self.nodes[0], self.nodes[0].listunspent()[0], self.pubkey[n], False, Decimal(\"49.999\")))\n-                    p2sh_ids[n][v].append(send_to_witness(v, self.nodes[0], self.nodes[0].listunspent()[0], self.pubkey[n], True, Decimal(\"49.999\")))\n+                    wit_ids[n][v].append(send_to_witness(v, self.nodes[0], find_unspent(self.nodes[0], 50), self.pubkey[n], False, Decimal(\"49.999\")))\n+                    p2sh_ids[n][v].append(send_to_witness(v, self.nodes[0], find_unspent(self.nodes[0], 50), self.pubkey[n], True, Decimal(\"49.999\")))\n \n-        self.nodes[0].generate(1) #block 161\n+        self.nodes[0].generate(1) #block 163\n         sync_blocks(self.nodes)\n \n         # Make sure all nodes recognize the transactions as theirs\n-        assert_equal(self.nodes[0].getbalance(), 60*50 - 60*50 + 20*Decimal(\"49.999\") + 50)\n+        assert_equal(self.nodes[0].getbalance(), balance_presetup - 60*50 + 20*Decimal(\"49.999\") + 50)\n         assert_equal(self.nodes[1].getbalance(), 20*Decimal(\"49.999\"))\n         assert_equal(self.nodes[2].getbalance(), 20*Decimal(\"49.999\"))\n \n-        self.nodes[0].generate(262) #block 423\n+        self.nodes[0].generate(260) #block 423\n         sync_blocks(self.nodes)\n \n         print(\"Verify default node can't accept any witness format txs before fork\")\n@@ -205,5 +224,25 @@ def run_test(self):\n         self.success_mine(self.nodes[0], p2sh_ids[NODE_0][WIT_V0][0], True) #block 434\n         self.success_mine(self.nodes[0], p2sh_ids[NODE_0][WIT_V1][0], True) #block 435\n \n+        print(\"Verify sigops are counted in GBT with BIP141 rules after the fork\")\n+        txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n+        tmpl = self.nodes[0].getblocktemplate({'rules':['segwit']})\n+        assert(tmpl['sigoplimit'] == 80000)\n+        assert(tmpl['transactions'][0]['txid'] == txid)\n+        assert(tmpl['transactions'][0]['sigops'] == 8)\n+\n+        print(\"Verify non-segwit miners get a valid GBT response after the fork\")\n+        send_to_witness(1, self.nodes[0], find_unspent(self.nodes[0], 50), self.pubkey[0], False, Decimal(\"49.998\"))\n+        try:\n+            tmpl = self.nodes[0].getblocktemplate({})\n+            assert(len(tmpl['transactions']) == 1)  # Doesn't include witness tx\n+            assert(tmpl['sigoplimit'] == 20000)\n+            assert(tmpl['transactions'][0]['hash'] == txid)\n+            assert(tmpl['transactions'][0]['sigops'] == 2)\n+            assert(('!segwit' in tmpl['rules']) or ('segwit' not in tmpl['rules']))\n+        except JSONRPCException:\n+            # This is an acceptable outcome\n+            pass\n+\n if __name__ == '__main__':\n     SegWitTest().main()"
      },
      {
        "sha": "c3f3180b6bca38eafcc150fcc843ec97a47b2512",
        "filename": "qa/rpc-tests/sendheaders.py",
        "status": "modified",
        "additions": 105,
        "deletions": 0,
        "changes": 105,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/sendheaders.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -63,6 +63,21 @@\n    Expect: getdata request for 14 more blocks.\n f. Announce 1 more header that builds on that fork.\n    Expect: no response.\n+\n+Part 5: Test handling of headers that don't connect.\n+a. Repeat 10 times:\n+   1. Announce a header that doesn't connect.\n+      Expect: getheaders message\n+   2. Send headers chain.\n+      Expect: getdata for the missing blocks, tip update.\n+b. Then send 9 more headers that don't connect.\n+   Expect: getheaders message each time.\n+c. Announce a header that does connect.\n+   Expect: no response.\n+d. Announce 49 headers that don't connect.\n+   Expect: getheaders message each time.\n+e. Announce one more that doesn't connect.\n+   Expect: disconnect.\n '''\n \n class BaseNode(NodeConnCB):\n@@ -77,6 +92,8 @@ def __init__(self):\n         self.last_getdata = None\n         self.sleep_time = 0.05\n         self.block_announced = False\n+        self.last_getheaders = None\n+        self.disconnected = False\n \n     def clear_last_announcement(self):\n         with mininode_lock:\n@@ -127,6 +144,12 @@ def on_getdata(self, conn, message):\n     def on_pong(self, conn, message):\n         self.last_pong = message\n \n+    def on_getheaders(self, conn, message):\n+        self.last_getheaders = message\n+\n+    def on_close(self, conn):\n+        self.disconnected = True\n+\n     # Test whether the last announcement we received had the\n     # right header or the right inv\n     # inv and headers should be lists of block hashes\n@@ -178,6 +201,11 @@ def wait_for_block(self, blockhash, timeout=60):\n         self.sync(test_function, timeout)\n         return\n \n+    def wait_for_getheaders(self, timeout=60):\n+        test_function = lambda: self.last_getheaders != None\n+        self.sync(test_function, timeout)\n+        return\n+\n     def wait_for_getdata(self, hash_list, timeout=60):\n         if hash_list == []:\n             return\n@@ -186,6 +214,11 @@ def wait_for_getdata(self, hash_list, timeout=60):\n         self.sync(test_function, timeout)\n         return\n \n+    def wait_for_disconnect(self, timeout=60):\n+        test_function = lambda: self.disconnected\n+        self.sync(test_function, timeout)\n+        return\n+\n     def send_header_for_blocks(self, new_blocks):\n         headers_message = msg_headers()\n         headers_message.headers = [ CBlockHeader(b) for b in new_blocks ]\n@@ -510,6 +543,78 @@ def run_test(self):\n \n         print(\"Part 4: success!\")\n \n+        # Now deliver all those blocks we announced.\n+        [ test_node.send_message(msg_block(x)) for x in blocks ]\n+\n+        print(\"Part 5: Testing handling of unconnecting headers\")\n+        # First we test that receipt of an unconnecting header doesn't prevent\n+        # chain sync.\n+        for i in range(10):\n+            test_node.last_getdata = None\n+            blocks = []\n+            # Create two more blocks.\n+            for j in range(2):\n+                blocks.append(create_block(tip, create_coinbase(height), block_time))\n+                blocks[-1].solve()\n+                tip = blocks[-1].sha256\n+                block_time += 1\n+                height += 1\n+            # Send the header of the second block -> this won't connect.\n+            with mininode_lock:\n+                test_node.last_getheaders = None\n+            test_node.send_header_for_blocks([blocks[1]])\n+            test_node.wait_for_getheaders(timeout=1)\n+            test_node.send_header_for_blocks(blocks)\n+            test_node.wait_for_getdata([x.sha256 for x in blocks])\n+            [ test_node.send_message(msg_block(x)) for x in blocks ]\n+            test_node.sync_with_ping()\n+            assert_equal(int(self.nodes[0].getbestblockhash(), 16), blocks[1].sha256)\n+\n+        blocks = []\n+        # Now we test that if we repeatedly don't send connecting headers, we\n+        # don't go into an infinite loop trying to get them to connect.\n+        MAX_UNCONNECTING_HEADERS = 10\n+        for j in range(MAX_UNCONNECTING_HEADERS+1):\n+            blocks.append(create_block(tip, create_coinbase(height), block_time))\n+            blocks[-1].solve()\n+            tip = blocks[-1].sha256\n+            block_time += 1\n+            height += 1\n+\n+        for i in range(1, MAX_UNCONNECTING_HEADERS):\n+            # Send a header that doesn't connect, check that we get a getheaders.\n+            with mininode_lock:\n+                test_node.last_getheaders = None\n+            test_node.send_header_for_blocks([blocks[i]])\n+            test_node.wait_for_getheaders(timeout=1)\n+\n+        # Next header will connect, should re-set our count:\n+        test_node.send_header_for_blocks([blocks[0]])\n+\n+        # Remove the first two entries (blocks[1] would connect):\n+        blocks = blocks[2:]\n+\n+        # Now try to see how many unconnecting headers we can send\n+        # before we get disconnected.  Should be 5*MAX_UNCONNECTING_HEADERS\n+        for i in range(5*MAX_UNCONNECTING_HEADERS - 1):\n+            # Send a header that doesn't connect, check that we get a getheaders.\n+            with mininode_lock:\n+                test_node.last_getheaders = None\n+            test_node.send_header_for_blocks([blocks[i%len(blocks)]])\n+            test_node.wait_for_getheaders(timeout=1)\n+\n+        # Eventually this stops working.\n+        with mininode_lock:\n+            self.last_getheaders = None\n+        test_node.send_header_for_blocks([blocks[-1]])\n+\n+        # Should get disconnected\n+        test_node.wait_for_disconnect()\n+        with mininode_lock:\n+            self.last_getheaders = True\n+\n+        print(\"Part 5: success!\")\n+\n         # Finally, check that the inv node never received a getdata request,\n         # throughout the test\n         assert_equal(inv_node.last_getdata, None)"
      },
      {
        "sha": "caffab35351df437f8828baa60284f0b3ac79cac",
        "filename": "qa/rpc-tests/test_framework/mininode.py",
        "status": "modified",
        "additions": 297,
        "deletions": 76,
        "changes": 373,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/mininode.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -36,9 +36,10 @@\n from threading import Thread\n import logging\n import copy\n+from test_framework.siphash import siphash256\n \n BIP0031_VERSION = 60000\n-MY_VERSION = 60001  # past bip-31 for ping/pong\n+MY_VERSION = 70014  # past bip-31 for ping/pong\n MY_SUBVERSION = b\"/python-mininode-tester:0.0.3/\"\n \n MAX_INV_SZ = 50000\n@@ -52,7 +53,7 @@\n NODE_WITNESS = (1 << 3)\n \n # Keep our own socket map for asyncore, so that we can track disconnects\n-# ourselves (to workaround an issue with closing an asyncore socket when \n+# ourselves (to workaround an issue with closing an asyncore socket when\n # using select)\n mininode_socket_map = dict()\n \n@@ -74,25 +75,34 @@ def ripemd160(s):\n def hash256(s):\n     return sha256(sha256(s))\n \n+def ser_compact_size(l):\n+    r = b\"\"\n+    if l < 253:\n+        r = struct.pack(\"B\", l)\n+    elif l < 0x10000:\n+        r = struct.pack(\"<BH\", 253, l)\n+    elif l < 0x100000000:\n+        r = struct.pack(\"<BI\", 254, l)\n+    else:\n+        r = struct.pack(\"<BQ\", 255, l)\n+    return r\n \n-def deser_string(f):\n+def deser_compact_size(f):\n     nit = struct.unpack(\"<B\", f.read(1))[0]\n     if nit == 253:\n         nit = struct.unpack(\"<H\", f.read(2))[0]\n     elif nit == 254:\n         nit = struct.unpack(\"<I\", f.read(4))[0]\n     elif nit == 255:\n         nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    return nit\n+\n+def deser_string(f):\n+    nit = deser_compact_size(f)\n     return f.read(nit)\n \n def ser_string(s):\n-    if len(s) < 253:\n-        return struct.pack(\"B\", len(s)) + s\n-    elif len(s) < 0x10000:\n-        return struct.pack(\"<BH\", 253, len(s)) + s\n-    elif len(s) < 0x100000000:\n-        return struct.pack(\"<BI\", 254, len(s)) + s\n-    return struct.pack(\"<BQ\", 255, len(s)) + s\n+    return ser_compact_size(len(s)) + s\n \n def deser_uint256(f):\n     r = 0\n@@ -125,13 +135,7 @@ def uint256_from_compact(c):\n \n \n def deser_vector(f, c):\n-    nit = struct.unpack(\"<B\", f.read(1))[0]\n-    if nit == 253:\n-        nit = struct.unpack(\"<H\", f.read(2))[0]\n-    elif nit == 254:\n-        nit = struct.unpack(\"<I\", f.read(4))[0]\n-    elif nit == 255:\n-        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    nit = deser_compact_size(f)\n     r = []\n     for i in range(nit):\n         t = c()\n@@ -144,15 +148,7 @@ def deser_vector(f, c):\n # entries in the vector (we use this for serializing the vector of transactions\n # for a witness block).\n def ser_vector(l, ser_function_name=None):\n-    r = b\"\"\n-    if len(l) < 253:\n-        r = struct.pack(\"B\", len(l))\n-    elif len(l) < 0x10000:\n-        r = struct.pack(\"<BH\", 253, len(l))\n-    elif len(l) < 0x100000000:\n-        r = struct.pack(\"<BI\", 254, len(l))\n-    else:\n-        r = struct.pack(\"<BQ\", 255, len(l))\n+    r = ser_compact_size(len(l))\n     for i in l:\n         if ser_function_name:\n             r += getattr(i, ser_function_name)()\n@@ -162,13 +158,7 @@ def ser_vector(l, ser_function_name=None):\n \n \n def deser_uint256_vector(f):\n-    nit = struct.unpack(\"<B\", f.read(1))[0]\n-    if nit == 253:\n-        nit = struct.unpack(\"<H\", f.read(2))[0]\n-    elif nit == 254:\n-        nit = struct.unpack(\"<I\", f.read(4))[0]\n-    elif nit == 255:\n-        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    nit = deser_compact_size(f)\n     r = []\n     for i in range(nit):\n         t = deser_uint256(f)\n@@ -177,28 +167,14 @@ def deser_uint256_vector(f):\n \n \n def ser_uint256_vector(l):\n-    r = b\"\"\n-    if len(l) < 253:\n-        r = struct.pack(\"B\", len(l))\n-    elif len(l) < 0x10000:\n-        r = struct.pack(\"<BH\", 253, len(l))\n-    elif len(l) < 0x100000000:\n-        r = struct.pack(\"<BI\", 254, len(l))\n-    else:\n-        r = struct.pack(\"<BQ\", 255, len(l))\n+    r = ser_compact_size(len(l))\n     for i in l:\n         r += ser_uint256(i)\n     return r\n \n \n def deser_string_vector(f):\n-    nit = struct.unpack(\"<B\", f.read(1))[0]\n-    if nit == 253:\n-        nit = struct.unpack(\"<H\", f.read(2))[0]\n-    elif nit == 254:\n-        nit = struct.unpack(\"<I\", f.read(4))[0]\n-    elif nit == 255:\n-        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    nit = deser_compact_size(f)\n     r = []\n     for i in range(nit):\n         t = deser_string(f)\n@@ -207,28 +183,14 @@ def deser_string_vector(f):\n \n \n def ser_string_vector(l):\n-    r = b\"\"\n-    if len(l) < 253:\n-        r = struct.pack(\"B\", len(l))\n-    elif len(l) < 0x10000:\n-        r = struct.pack(\"<BH\", 253, len(l))\n-    elif len(l) < 0x100000000:\n-        r = struct.pack(\"<BI\", 254, len(l))\n-    else:\n-        r = struct.pack(\"<BQ\", 255, len(l))\n+    r = ser_compact_size(len(l))\n     for sv in l:\n         r += ser_string(sv)\n     return r\n \n \n def deser_int_vector(f):\n-    nit = struct.unpack(\"<B\", f.read(1))[0]\n-    if nit == 253:\n-        nit = struct.unpack(\"<H\", f.read(2))[0]\n-    elif nit == 254:\n-        nit = struct.unpack(\"<I\", f.read(4))[0]\n-    elif nit == 255:\n-        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    nit = deser_compact_size(f)\n     r = []\n     for i in range(nit):\n         t = struct.unpack(\"<i\", f.read(4))[0]\n@@ -237,15 +199,7 @@ def deser_int_vector(f):\n \n \n def ser_int_vector(l):\n-    r = b\"\"\n-    if len(l) < 253:\n-        r = struct.pack(\"B\", len(l))\n-    elif len(l) < 0x10000:\n-        r = struct.pack(\"<BH\", 253, len(l))\n-    elif len(l) < 0x100000000:\n-        r = struct.pack(\"<BI\", 254, len(l))\n-    else:\n-        r = struct.pack(\"<BQ\", 255, len(l))\n+    r = ser_compact_size(len(l))\n     for i in l:\n         r += struct.pack(\"<i\", i)\n     return r\n@@ -294,7 +248,8 @@ class CInv(object):\n         1: \"TX\",\n         2: \"Block\",\n         1|MSG_WITNESS_FLAG: \"WitnessTx\",\n-        2|MSG_WITNESS_FLAG : \"WitnessBlock\"\n+        2|MSG_WITNESS_FLAG : \"WitnessBlock\",\n+        4: \"CompactBlock\"\n     }\n \n     def __init__(self, t=0, h=0):\n@@ -781,6 +736,187 @@ def __repr__(self):\n             % (len(self.vchMsg), len(self.vchSig))\n \n \n+class PrefilledTransaction(object):\n+    def __init__(self, index=0, tx = None):\n+        self.index = index\n+        self.tx = tx\n+\n+    def deserialize(self, f):\n+        self.index = deser_compact_size(f)\n+        self.tx = CTransaction()\n+        self.tx.deserialize(f)\n+\n+    def serialize(self, with_witness=False):\n+        r = b\"\"\n+        r += ser_compact_size(self.index)\n+        if with_witness:\n+            r += self.tx.serialize_with_witness()\n+        else:\n+            r += self.tx.serialize_without_witness()\n+        return r\n+\n+    def __repr__(self):\n+        return \"PrefilledTransaction(index=%d, tx=%s)\" % (self.index, repr(self.tx))\n+\n+# This is what we send on the wire, in a cmpctblock message.\n+class P2PHeaderAndShortIDs(object):\n+    def __init__(self):\n+        self.header = CBlockHeader()\n+        self.nonce = 0\n+        self.shortids_length = 0\n+        self.shortids = []\n+        self.prefilled_txn_length = 0\n+        self.prefilled_txn = []\n+\n+    def deserialize(self, f):\n+        self.header.deserialize(f)\n+        self.nonce = struct.unpack(\"<Q\", f.read(8))[0]\n+        self.shortids_length = deser_compact_size(f)\n+        for i in range(self.shortids_length):\n+            # shortids are defined to be 6 bytes in the spec, so append\n+            # two zero bytes and read it in as an 8-byte number\n+            self.shortids.append(struct.unpack(\"<Q\", f.read(6) + b'\\x00\\x00')[0])\n+        self.prefilled_txn = deser_vector(f, PrefilledTransaction)\n+        self.prefilled_txn_length = len(self.prefilled_txn)\n+\n+    def serialize(self, with_witness=False):\n+        r = b\"\"\n+        r += self.header.serialize()\n+        r += struct.pack(\"<Q\", self.nonce)\n+        r += ser_compact_size(self.shortids_length)\n+        for x in self.shortids:\n+            # We only want the first 6 bytes\n+            r += struct.pack(\"<Q\", x)[0:6]\n+        r += ser_vector(self.prefilled_txn)\n+        return r\n+\n+    def __repr__(self):\n+        return \"P2PHeaderAndShortIDs(header=%s, nonce=%d, shortids_length=%d, shortids=%s, prefilled_txn_length=%d, prefilledtxn=%s\" % (repr(self.header), self.nonce, self.shortids_length, repr(self.shortids), self.prefilled_txn_length, repr(self.prefilled_txn))\n+\n+\n+# Calculate the BIP 152-compact blocks shortid for a given transaction hash\n+def calculate_shortid(k0, k1, tx_hash):\n+    expected_shortid = siphash256(k0, k1, tx_hash)\n+    expected_shortid &= 0x0000ffffffffffff\n+    return expected_shortid\n+\n+# This version gets rid of the array lengths, and reinterprets the differential\n+# encoding into indices that can be used for lookup.\n+class HeaderAndShortIDs(object):\n+    def __init__(self, p2pheaders_and_shortids = None):\n+        self.header = CBlockHeader()\n+        self.nonce = 0\n+        self.shortids = []\n+        self.prefilled_txn = []\n+\n+        if p2pheaders_and_shortids != None:\n+            self.header = p2pheaders_and_shortids.header\n+            self.nonce = p2pheaders_and_shortids.nonce\n+            self.shortids = p2pheaders_and_shortids.shortids\n+            last_index = -1\n+            for x in p2pheaders_and_shortids.prefilled_txn:\n+                self.prefilled_txn.append(PrefilledTransaction(x.index + last_index + 1, x.tx))\n+                last_index = self.prefilled_txn[-1].index\n+\n+    def to_p2p(self):\n+        ret = P2PHeaderAndShortIDs()\n+        ret.header = self.header\n+        ret.nonce = self.nonce\n+        ret.shortids_length = len(self.shortids)\n+        ret.shortids = self.shortids\n+        ret.prefilled_txn_length = len(self.prefilled_txn)\n+        ret.prefilled_txn = []\n+        last_index = -1\n+        for x in self.prefilled_txn:\n+            ret.prefilled_txn.append(PrefilledTransaction(x.index - last_index - 1, x.tx))\n+            last_index = x.index\n+        return ret\n+\n+    def get_siphash_keys(self):\n+        header_nonce = self.header.serialize()\n+        header_nonce += struct.pack(\"<Q\", self.nonce)\n+        hash_header_nonce_as_str = sha256(header_nonce)\n+        key0 = struct.unpack(\"<Q\", hash_header_nonce_as_str[0:8])[0]\n+        key1 = struct.unpack(\"<Q\", hash_header_nonce_as_str[8:16])[0]\n+        return [ key0, key1 ]\n+\n+    def initialize_from_block(self, block, nonce=0, prefill_list = [0]):\n+        self.header = CBlockHeader(block)\n+        self.nonce = nonce\n+        self.prefilled_txn = [ PrefilledTransaction(i, block.vtx[i]) for i in prefill_list ]\n+        self.shortids = []\n+        [k0, k1] = self.get_siphash_keys()\n+        for i in range(len(block.vtx)):\n+            if i not in prefill_list:\n+                self.shortids.append(calculate_shortid(k0, k1, block.vtx[i].sha256))\n+\n+    def __repr__(self):\n+        return \"HeaderAndShortIDs(header=%s, nonce=%d, shortids=%s, prefilledtxn=%s\" % (repr(self.header), self.nonce, repr(self.shortids), repr(self.prefilled_txn))\n+\n+\n+class BlockTransactionsRequest(object):\n+\n+    def __init__(self, blockhash=0, indexes = None):\n+        self.blockhash = blockhash\n+        self.indexes = indexes if indexes != None else []\n+\n+    def deserialize(self, f):\n+        self.blockhash = deser_uint256(f)\n+        indexes_length = deser_compact_size(f)\n+        for i in range(indexes_length):\n+            self.indexes.append(deser_compact_size(f))\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += ser_uint256(self.blockhash)\n+        r += ser_compact_size(len(self.indexes))\n+        for x in self.indexes:\n+            r += ser_compact_size(x)\n+        return r\n+\n+    # helper to set the differentially encoded indexes from absolute ones\n+    def from_absolute(self, absolute_indexes):\n+        self.indexes = []\n+        last_index = -1\n+        for x in absolute_indexes:\n+            self.indexes.append(x-last_index-1)\n+            last_index = x\n+\n+    def to_absolute(self):\n+        absolute_indexes = []\n+        last_index = -1\n+        for x in self.indexes:\n+            absolute_indexes.append(x+last_index+1)\n+            last_index = absolute_indexes[-1]\n+        return absolute_indexes\n+\n+    def __repr__(self):\n+        return \"BlockTransactionsRequest(hash=%064x indexes=%s)\" % (self.blockhash, repr(self.indexes))\n+\n+\n+class BlockTransactions(object):\n+\n+    def __init__(self, blockhash=0, transactions = None):\n+        self.blockhash = blockhash\n+        self.transactions = transactions if transactions != None else []\n+\n+    def deserialize(self, f):\n+        self.blockhash = deser_uint256(f)\n+        self.transactions = deser_vector(f, CTransaction)\n+\n+    def serialize(self, with_witness=False):\n+        r = b\"\"\n+        r += ser_uint256(self.blockhash)\n+        if with_witness:\n+            r += ser_vector(self.transactions, \"serialize_with_witness\")\n+        else:\n+            r += ser_vector(self.transactions)\n+        return r\n+\n+    def __repr__(self):\n+        return \"BlockTransactions(hash=%064x transactions=%s)\" % (self.blockhash, repr(self.transactions))\n+\n+\n # Objects that correspond to messages on the wire\n class msg_version(object):\n     command = b\"version\"\n@@ -1215,6 +1351,79 @@ def serialize(self):\n     def __repr__(self):\n         return \"msg_feefilter(feerate=%08x)\" % self.feerate\n \n+class msg_sendcmpct(object):\n+    command = b\"sendcmpct\"\n+\n+    def __init__(self):\n+        self.announce = False\n+        self.version = 1\n+\n+    def deserialize(self, f):\n+        self.announce = struct.unpack(\"<?\", f.read(1))[0]\n+        self.version = struct.unpack(\"<Q\", f.read(8))[0]\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<?\", self.announce)\n+        r += struct.pack(\"<Q\", self.version)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_sendcmpct(announce=%s, version=%lu)\" % (self.announce, self.version)\n+\n+class msg_cmpctblock(object):\n+    command = b\"cmpctblock\"\n+\n+    def __init__(self, header_and_shortids = None):\n+        self.header_and_shortids = header_and_shortids\n+\n+    def deserialize(self, f):\n+        self.header_and_shortids = P2PHeaderAndShortIDs()\n+        self.header_and_shortids.deserialize(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += self.header_and_shortids.serialize()\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_cmpctblock(HeaderAndShortIDs=%s)\" % repr(self.header_and_shortids)\n+\n+class msg_getblocktxn(object):\n+    command = b\"getblocktxn\"\n+\n+    def __init__(self):\n+        self.block_txn_request = None\n+\n+    def deserialize(self, f):\n+        self.block_txn_request = BlockTransactionsRequest()\n+        self.block_txn_request.deserialize(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += self.block_txn_request.serialize()\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_getblocktxn(block_txn_request=%s)\" % (repr(self.block_txn_request))\n+\n+class msg_blocktxn(object):\n+    command = b\"blocktxn\"\n+\n+    def __init__(self):\n+        self.block_transactions = BlockTransactions()\n+\n+    def deserialize(self, f):\n+        self.block_transactions.deserialize(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += self.block_transactions.serialize()\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_blocktxn(block_transactions=%s)\" % (repr(self.block_transactions))\n+\n # This is what a callback should look like for NodeConn\n # Reimplement the on_* functions to provide handling for events\n class NodeConnCB(object):\n@@ -1295,6 +1504,10 @@ def on_mempool(self, conn): pass\n     def on_pong(self, conn, message): pass\n     def on_feefilter(self, conn, message): pass\n     def on_sendheaders(self, conn, message): pass\n+    def on_sendcmpct(self, conn, message): pass\n+    def on_cmpctblock(self, conn, message): pass\n+    def on_getblocktxn(self, conn, message): pass\n+    def on_blocktxn(self, conn, message): pass\n \n # More useful callbacks and functions for NodeConnCB's which have a single NodeConn\n class SingleNodeConnCB(NodeConnCB):\n@@ -1311,6 +1524,10 @@ def add_connection(self, conn):\n     def send_message(self, message):\n         self.connection.send_message(message)\n \n+    def send_and_ping(self, message):\n+        self.send_message(message)\n+        self.sync_with_ping()\n+\n     def on_pong(self, conn, message):\n         self.last_pong = message\n \n@@ -1344,7 +1561,11 @@ class NodeConn(asyncore.dispatcher):\n         b\"reject\": msg_reject,\n         b\"mempool\": msg_mempool,\n         b\"feefilter\": msg_feefilter,\n-        b\"sendheaders\": msg_sendheaders\n+        b\"sendheaders\": msg_sendheaders,\n+        b\"sendcmpct\": msg_sendcmpct,\n+        b\"cmpctblock\": msg_cmpctblock,\n+        b\"getblocktxn\": msg_getblocktxn,\n+        b\"blocktxn\": msg_blocktxn\n     }\n     MAGIC_BYTES = {\n         \"mainnet\": b\"\\xf9\\xbe\\xb4\\xd9\",   # mainnet"
      },
      {
        "sha": "9c0574bd931758cca0b1583da0269bec96b5d8bf",
        "filename": "qa/rpc-tests/test_framework/siphash.py",
        "status": "added",
        "additions": 64,
        "deletions": 0,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/test_framework/siphash.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/test_framework/siphash.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/siphash.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -0,0 +1,64 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# siphash.py - Specialized SipHash-2-4 implementations\n+#\n+# This implements SipHash-2-4 for 256-bit integers.\n+\n+def rotl64(n, b):\n+    return n >> (64 - b) | (n & ((1 << (64 - b)) - 1)) << b\n+\n+def siphash_round(v0, v1, v2, v3):\n+    v0 = (v0 + v1) & ((1 << 64) - 1)\n+    v1 = rotl64(v1, 13)\n+    v1 ^= v0\n+    v0 = rotl64(v0, 32)\n+    v2 = (v2 + v3) & ((1 << 64) - 1)\n+    v3 = rotl64(v3, 16)\n+    v3 ^= v2\n+    v0 = (v0 + v3) & ((1 << 64) - 1)\n+    v3 = rotl64(v3, 21)\n+    v3 ^= v0\n+    v2 = (v2 + v1) & ((1 << 64) - 1)\n+    v1 = rotl64(v1, 17)\n+    v1 ^= v2\n+    v2 = rotl64(v2, 32)\n+    return (v0, v1, v2, v3)\n+\n+def siphash256(k0, k1, h):\n+    n0 = h & ((1 << 64) - 1)\n+    n1 = (h >> 64) & ((1 << 64) - 1)\n+    n2 = (h >> 128) & ((1 << 64) - 1)\n+    n3 = (h >> 192) & ((1 << 64) - 1)\n+    v0 = 0x736f6d6570736575 ^ k0\n+    v1 = 0x646f72616e646f6d ^ k1\n+    v2 = 0x6c7967656e657261 ^ k0\n+    v3 = 0x7465646279746573 ^ k1 ^ n0\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0 ^= n0\n+    v3 ^= n1\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0 ^= n1\n+    v3 ^= n2\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0 ^= n2\n+    v3 ^= n3\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0 ^= n3\n+    v3 ^= 0x2000000000000000\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0 ^= 0x2000000000000000\n+    v2 ^= 0xFF\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    v0, v1, v2, v3 = siphash_round(v0, v1, v2, v3)\n+    return v0 ^ v1 ^ v2 ^ v3"
      },
      {
        "sha": "a1383729fad964af2c3bb3e0e35bb0b584b17eb7",
        "filename": "qa/rpc-tests/test_framework/test_framework.py",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/test_framework/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/test_framework/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/test_framework.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -48,7 +48,7 @@ def setup_chain(self):\n         if self.setup_clean_chain:\n             initialize_chain_clean(self.options.tmpdir, self.num_nodes)\n         else:\n-            initialize_chain(self.options.tmpdir, self.num_nodes)\n+            initialize_chain(self.options.tmpdir, self.num_nodes, self.options.cachedir)\n \n     def stop_node(self, num_node):\n         stop_node(self.nodes[num_node], num_node)\n@@ -112,6 +112,8 @@ def main(self):\n                           help=\"Don't stop bitcoinds after the test execution\")\n         parser.add_option(\"--srcdir\", dest=\"srcdir\", default=os.path.normpath(os.path.dirname(os.path.realpath(__file__))+\"/../../../src\"),\n                           help=\"Source directory containing bitcoind/bitcoin-cli (default: %default)\")\n+        parser.add_option(\"--cachedir\", dest=\"cachedir\", default=os.path.normpath(os.path.dirname(os.path.realpath(__file__))+\"/../../cache\"),\n+                          help=\"Directory for caching pregenerated datadirs\")\n         parser.add_option(\"--tmpdir\", dest=\"tmpdir\", default=tempfile.mkdtemp(prefix=\"test\"),\n                           help=\"Root directory for datadirs\")\n         parser.add_option(\"--tracerpc\", dest=\"trace_rpc\", default=False, action=\"store_true\","
      },
      {
        "sha": "190fa7f661a6dae08f9a5aad3cfe520ffe9f11be",
        "filename": "qa/rpc-tests/test_framework/util.py",
        "status": "modified",
        "additions": 19,
        "deletions": 11,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/util.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -171,7 +171,15 @@ def rpc_auth_pair(n):\n \n def rpc_url(i, rpchost=None):\n     rpc_u, rpc_p = rpc_auth_pair(i)\n-    return \"http://%s:%s@%s:%d\" % (rpc_u, rpc_p, rpchost or '127.0.0.1', rpc_port(i))\n+    host = '127.0.0.1'\n+    port = rpc_port(i)\n+    if rpchost:\n+        parts = rpchost.split(':')\n+        if len(parts) == 2:\n+            host, port = parts\n+        else:\n+            host = rpchost\n+    return \"http://%s:%s@%s:%d\" % (rpc_u, rpc_p, host, int(port))\n \n def wait_for_bitcoind_start(process, url, i):\n     '''\n@@ -193,7 +201,7 @@ def wait_for_bitcoind_start(process, url, i):\n                 raise # unkown JSON RPC exception\n         time.sleep(0.25)\n \n-def initialize_chain(test_dir, num_nodes):\n+def initialize_chain(test_dir, num_nodes, cachedir):\n     \"\"\"\n     Create a cache of a 200-block-long chain (with wallet) for MAX_NODES\n     Afterward, create num_nodes copies from the cache\n@@ -202,20 +210,20 @@ def initialize_chain(test_dir, num_nodes):\n     assert num_nodes <= MAX_NODES\n     create_cache = False\n     for i in range(MAX_NODES):\n-        if not os.path.isdir(os.path.join('cache', 'node'+str(i))):\n+        if not os.path.isdir(os.path.join(cachedir, 'node'+str(i))):\n             create_cache = True\n             break\n \n     if create_cache:\n \n         #find and delete old cache directories if any exist\n         for i in range(MAX_NODES):\n-            if os.path.isdir(os.path.join(\"cache\",\"node\"+str(i))):\n-                shutil.rmtree(os.path.join(\"cache\",\"node\"+str(i)))\n+            if os.path.isdir(os.path.join(cachedir,\"node\"+str(i))):\n+                shutil.rmtree(os.path.join(cachedir,\"node\"+str(i)))\n \n         # Create cache directories, run bitcoinds:\n         for i in range(MAX_NODES):\n-            datadir=initialize_datadir(\"cache\", i)\n+            datadir=initialize_datadir(cachedir, i)\n             args = [ os.getenv(\"BITCOIND\", \"bitcoind\"), \"-server\", \"-keypool=1\", \"-datadir=\"+datadir, \"-discover=0\" ]\n             if i > 0:\n                 args.append(\"-connect=127.0.0.1:\"+str(p2p_port(0)))\n@@ -257,13 +265,13 @@ def initialize_chain(test_dir, num_nodes):\n         wait_bitcoinds()\n         disable_mocktime()\n         for i in range(MAX_NODES):\n-            os.remove(log_filename(\"cache\", i, \"debug.log\"))\n-            os.remove(log_filename(\"cache\", i, \"db.log\"))\n-            os.remove(log_filename(\"cache\", i, \"peers.dat\"))\n-            os.remove(log_filename(\"cache\", i, \"fee_estimates.dat\"))\n+            os.remove(log_filename(cachedir, i, \"debug.log\"))\n+            os.remove(log_filename(cachedir, i, \"db.log\"))\n+            os.remove(log_filename(cachedir, i, \"peers.dat\"))\n+            os.remove(log_filename(cachedir, i, \"fee_estimates.dat\"))\n \n     for i in range(num_nodes):\n-        from_dir = os.path.join(\"cache\", \"node\"+str(i))\n+        from_dir = os.path.join(cachedir, \"node\"+str(i))\n         to_dir = os.path.join(test_dir,  \"node\"+str(i))\n         shutil.copytree(from_dir, to_dir)\n         initialize_datadir(test_dir, i) # Overwrite port/rpcport in bitcoin.conf"
      },
      {
        "sha": "6028d2c20b19178b60b224cb8b144389a12a47ef",
        "filename": "qa/rpc-tests/wallet-dump.py",
        "status": "added",
        "additions": 104,
        "deletions": 0,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/wallet-dump.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/wallet-dump.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/wallet-dump.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -0,0 +1,104 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (start_nodes, start_node, assert_equal, bitcoind_processes)\n+\n+\n+def read_dump(file_name, addrs, hd_master_addr_old):\n+    \"\"\"\n+    Read the given dump, count the addrs that match, count change and reserve.\n+    Also check that the old hd_master is inactive\n+    \"\"\"\n+    with open(file_name) as inputfile:\n+        found_addr = 0\n+        found_addr_chg = 0\n+        found_addr_rsv = 0\n+        hd_master_addr_ret = None\n+        for line in inputfile:\n+            # only read non comment lines\n+            if line[0] != \"#\" and len(line) > 10:\n+                # split out some data\n+                key_label, comment = line.split(\"#\")\n+                # key = key_label.split(\" \")[0]\n+                keytype = key_label.split(\" \")[2]\n+                if len(comment) > 1:\n+                    addr_keypath = comment.split(\" addr=\")[1]\n+                    addr = addr_keypath.split(\" \")[0]\n+                    keypath = None\n+                    if keytype == \"inactivehdmaster=1\":\n+                        # ensure the old master is still available\n+                        assert(hd_master_addr_old == addr)\n+                    elif keytype == \"hdmaster=1\":\n+                        # ensure we have generated a new hd master key\n+                        assert(hd_master_addr_old != addr)\n+                        hd_master_addr_ret = addr\n+                    else:\n+                        keypath = addr_keypath.rstrip().split(\"hdkeypath=\")[1]\n+\n+                    # count key types\n+                    for addrObj in addrs:\n+                        if addrObj['address'] == addr and addrObj['hdkeypath'] == keypath and keytype == \"label=\":\n+                            found_addr += 1\n+                            break\n+                        elif keytype == \"change=1\":\n+                            found_addr_chg += 1\n+                            break\n+                        elif keytype == \"reserve=1\":\n+                            found_addr_rsv += 1\n+                            break\n+        return found_addr, found_addr_chg, found_addr_rsv, hd_master_addr_ret\n+\n+\n+class WalletDumpTest(BitcoinTestFramework):\n+\n+    def __init__(self):\n+        super().__init__()\n+        self.setup_clean_chain = False\n+        self.num_nodes = 1\n+        self.extra_args = [[\"-keypool=90\"]]\n+\n+    def setup_network(self, split=False):\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, self.extra_args)\n+\n+    def run_test (self):\n+        tmpdir = self.options.tmpdir\n+\n+        # generate 20 addresses to compare against the dump\n+        test_addr_count = 20\n+        addrs = []\n+        for i in range(0,test_addr_count):\n+            addr = self.nodes[0].getnewaddress()\n+            vaddr= self.nodes[0].validateaddress(addr) #required to get hd keypath\n+            addrs.append(vaddr)\n+        # Should be a no-op:\n+        self.nodes[0].keypoolrefill()\n+\n+        # dump unencrypted wallet\n+        self.nodes[0].dumpwallet(tmpdir + \"/node0/wallet.unencrypted.dump\")\n+\n+        found_addr, found_addr_chg, found_addr_rsv, hd_master_addr_unenc = \\\n+            read_dump(tmpdir + \"/node0/wallet.unencrypted.dump\", addrs, None)\n+        assert_equal(found_addr, test_addr_count)  # all keys must be in the dump\n+        assert_equal(found_addr_chg, 50)  # 50 blocks where mined\n+        assert_equal(found_addr_rsv, 90 + 1)  # keypool size (TODO: fix off-by-one)\n+\n+        #encrypt wallet, restart, unlock and dump\n+        self.nodes[0].encryptwallet('test')\n+        bitcoind_processes[0].wait()\n+        self.nodes[0] = start_node(0, self.options.tmpdir, self.extra_args[0])\n+        self.nodes[0].walletpassphrase('test', 10)\n+        # Should be a no-op:\n+        self.nodes[0].keypoolrefill()\n+        self.nodes[0].dumpwallet(tmpdir + \"/node0/wallet.encrypted.dump\")\n+\n+        found_addr, found_addr_chg, found_addr_rsv, hd_master_addr_enc = \\\n+            read_dump(tmpdir + \"/node0/wallet.encrypted.dump\", addrs, hd_master_addr_unenc)\n+        assert_equal(found_addr, test_addr_count)\n+        assert_equal(found_addr_chg, 90 + 1 + 50)  # old reserve keys are marked as change now\n+        assert_equal(found_addr_rsv, 90 + 1)  # keypool size (TODO: fix off-by-one)\n+\n+if __name__ == '__main__':\n+    WalletDumpTest().main ()"
      },
      {
        "sha": "c11da1e9a99896930b3a9c46bcf0795da6e5e334",
        "filename": "qa/rpc-tests/wallet-hd.py",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/wallet-hd.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/qa/rpc-tests/wallet-hd.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/wallet-hd.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -30,6 +30,10 @@ def setup_network(self):\n     def run_test (self):\n         tmpdir = self.options.tmpdir\n \n+        # Make sure we use hd, keep masterkeyid\n+        masterkeyid = self.nodes[1].getwalletinfo()['hdmasterkeyid']\n+        assert_equal(len(masterkeyid), 40)\n+\n         # Import a non-HD private key in the HD wallet\n         non_hd_add = self.nodes[0].getnewaddress()\n         self.nodes[1].importprivkey(self.nodes[0].dumpprivkey(non_hd_add))\n@@ -43,8 +47,11 @@ def run_test (self):\n         self.nodes[0].generate(101)\n         hd_add = None\n         num_hd_adds = 300\n-        for _ in range(num_hd_adds):\n+        for i in range(num_hd_adds):\n             hd_add = self.nodes[1].getnewaddress()\n+            hd_info = self.nodes[1].validateaddress(hd_add)\n+            assert_equal(hd_info[\"hdkeypath\"], \"m/0'/0'/\"+str(i+1)+\"'\")\n+            assert_equal(hd_info[\"hdmasterkeyid\"], masterkeyid)\n             self.nodes[0].sendtoaddress(hd_add, 1)\n             self.nodes[0].generate(1)\n         self.nodes[0].sendtoaddress(non_hd_add, 1)\n@@ -64,6 +71,9 @@ def run_test (self):\n         hd_add_2 = None\n         for _ in range(num_hd_adds):\n             hd_add_2 = self.nodes[1].getnewaddress()\n+            hd_info_2 = self.nodes[1].validateaddress(hd_add_2)\n+            assert_equal(hd_info_2[\"hdkeypath\"], \"m/0'/0'/\"+str(_+1)+\"'\")\n+            assert_equal(hd_info_2[\"hdmasterkeyid\"], masterkeyid)\n         assert_equal(hd_add, hd_add_2)\n \n         # Needs rescan"
      },
      {
        "sha": "9624abf1fcdd35b9ba3900dd46fe28cec07731c7",
        "filename": "share/qt/extract_strings_qt.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/share/qt/extract_strings_qt.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/share/qt/extract_strings_qt.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/qt/extract_strings_qt.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/python\n+#!/usr/bin/env python\n '''\n Extract _(\"...\") strings for translation and convert to Qt stringdefs so that\n they can be picked up by Qt linguist."
      },
      {
        "sha": "03fac5bf979ac84da16de762cc9fc6dac52078fd",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -105,6 +105,7 @@ BITCOIN_CORE_H = \\\n   merkleblock.h \\\n   miner.h \\\n   net.h \\\n+  netaddress.h \\\n   netbase.h \\\n   noui.h \\\n   policy/fees.h \\\n@@ -289,6 +290,7 @@ libbitcoin_common_a_SOURCES = \\\n   core_write.cpp \\\n   key.cpp \\\n   keystore.cpp \\\n+  netaddress.cpp \\\n   netbase.cpp \\\n   protocol.cpp \\\n   scheduler.cpp \\"
      },
      {
        "sha": "9bab39049d7ab2ed886ceb62e19156d63dc78d6e",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -6,7 +6,7 @@\n #ifndef BITCOIN_ADDRMAN_H\n #define BITCOIN_ADDRMAN_H\n \n-#include \"netbase.h\"\n+#include \"netaddress.h\"\n #include \"protocol.h\"\n #include \"random.h\"\n #include \"sync.h\""
      },
      {
        "sha": "df237f8f26f5876f04c00c7f94653cf0a7234e67",
        "filename": "src/blockencodings.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/blockencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/blockencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockencodings.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -75,7 +75,7 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c\n     }\n     prefilled_count = cmpctblock.prefilledtxn.size();\n \n-    // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n+    // Calculate map of txids -> positions and check mempool to see what we have (or don't)\n     // Because well-formed cmpctblock messages will have a (relatively) uniform distribution\n     // of short IDs, any highly-uneven distribution of elements can be safely treated as a\n     // READ_STATUS_FAILED."
      },
      {
        "sha": "ea6e3aada24ad6091608ae71d4deed0cbcd3f44a",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 10,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -71,11 +71,10 @@ class CMainParams : public CChainParams {\n     CMainParams() {\n         strNetworkID = \"main\";\n         consensus.nSubsidyHalvingInterval = 210000;\n-        consensus.nMajorityEnforceBlockUpgrade = 750;\n-        consensus.nMajorityRejectBlockOutdated = 950;\n-        consensus.nMajorityWindow = 1000;\n         consensus.BIP34Height = 227931;\n         consensus.BIP34Hash = uint256S(\"0x000000000000024b89b42a942fe0d9fea3bb44ab7bd1b19115dd6a759c0808b8\");\n+        consensus.BIP65Height = 388381; // 000000000000000004c2b624ed5d7756c508d90fd0da2c7c679febfa6c4735f0\n+        consensus.BIP66Height = 363725; // 00000000000000000379eaa19dce8c9b722d46ae6a57c2f1a988119488b50931\n         consensus.powLimit = uint256S(\"00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n         consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks\n         consensus.nPowTargetSpacing = 10 * 60;\n@@ -167,11 +166,10 @@ class CTestNetParams : public CChainParams {\n     CTestNetParams() {\n         strNetworkID = \"test\";\n         consensus.nSubsidyHalvingInterval = 210000;\n-        consensus.nMajorityEnforceBlockUpgrade = 51;\n-        consensus.nMajorityRejectBlockOutdated = 75;\n-        consensus.nMajorityWindow = 100;\n         consensus.BIP34Height = 21111;\n         consensus.BIP34Hash = uint256S(\"0x0000000023b3a96d3484e5abb3755c413e7d41500f8e2a5c3f0dd01299cd8ef8\");\n+        consensus.BIP65Height = 581885; // 00000000007f6655f22f98e72ed80d8b06dc761d5da09df0fa1dc4be4f861eb6\n+        consensus.BIP66Height = 330776; // 000000002104c8c45e99a8853285a3b592602a3ccde2b832481da85e9e4ba182\n         consensus.powLimit = uint256S(\"00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n         consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks\n         consensus.nPowTargetSpacing = 10 * 60;\n@@ -247,11 +245,10 @@ class CRegTestParams : public CChainParams {\n     CRegTestParams() {\n         strNetworkID = \"regtest\";\n         consensus.nSubsidyHalvingInterval = 150;\n-        consensus.nMajorityEnforceBlockUpgrade = 750;\n-        consensus.nMajorityRejectBlockOutdated = 950;\n-        consensus.nMajorityWindow = 1000;\n-        consensus.BIP34Height = -1; // BIP34 has not necessarily activated on regtest\n+        consensus.BIP34Height = 100000000; // BIP34 has not activated on regtest (far in the future so block v1 are not rejected in tests)\n         consensus.BIP34Hash = uint256();\n+        consensus.BIP65Height = 1351; // BIP65 activated on regtest (Used in rpc activation tests)\n+        consensus.BIP66Height = 1251; // BIP66 activated on regtest (Used in rpc activation tests)\n         consensus.powLimit = uint256S(\"7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n         consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks\n         consensus.nPowTargetSpacing = 10 * 60;\n@@ -303,6 +300,12 @@ class CRegTestParams : public CChainParams {\n         base58Prefixes[EXT_PUBLIC_KEY] = boost::assign::list_of(0x04)(0x35)(0x87)(0xCF).convert_to_container<std::vector<unsigned char> >();\n         base58Prefixes[EXT_SECRET_KEY] = boost::assign::list_of(0x04)(0x35)(0x83)(0x94).convert_to_container<std::vector<unsigned char> >();\n     }\n+\n+    void UpdateBIP9Parameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)\n+    {\n+        consensus.vDeployments[d].nStartTime = nStartTime;\n+        consensus.vDeployments[d].nTimeout = nTimeout;\n+    }\n };\n static CRegTestParams regTestParams;\n \n@@ -330,4 +333,9 @@ void SelectParams(const std::string& network)\n     SelectBaseParams(network);\n     pCurrentParams = &Params(network);\n }\n+\n+void UpdateRegtestBIP9Parameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)\n+{\n+    regTestParams.UpdateBIP9Parameters(d, nStartTime, nTimeout);\n+}\n  "
      },
      {
        "sha": "0c3820b7c6e725ff5e468606c3b985185fb41754",
        "filename": "src/chainparams.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/chainparams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/chainparams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -112,4 +112,9 @@ CChainParams& Params(const std::string& chain);\n  */\n void SelectParams(const std::string& chain);\n \n+/**\n+ * Allows modifying the BIP9 regtest parameters.\n+ */\n+void UpdateRegtestBIP9Parameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout);\n+\n #endif // BITCOIN_CHAINPARAMS_H"
      },
      {
        "sha": "53ad460346466cc6bf30c1f7a9ae968c6ee0d62b",
        "filename": "src/clientversion.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/clientversion.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/clientversion.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/clientversion.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -15,7 +15,7 @@\n \n //! These need to be macros, as clientversion.cpp's and bitcoin*-res.rc's voodoo requires it\n #define CLIENT_VERSION_MAJOR 0\n-#define CLIENT_VERSION_MINOR 12\n+#define CLIENT_VERSION_MINOR 13\n #define CLIENT_VERSION_REVISION 99\n #define CLIENT_VERSION_BUILD 0\n "
      },
      {
        "sha": "690856586604e67b79d81003695d10cca5c77a31",
        "filename": "src/consensus/consensus.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/consensus/consensus.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/consensus/consensus.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/consensus.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -10,8 +10,8 @@\n \n /** The maximum allowed size for a serialized block, in bytes (only for buffer size limits) */\n static const unsigned int MAX_BLOCK_SERIALIZED_SIZE = 4000000;\n-/** The maximum allowed cost for a block, see BIP 141 (network rule) */\n-static const unsigned int MAX_BLOCK_COST = 4000000;\n+/** The maximum allowed weight for a block, see BIP 141 (network rule) */\n+static const unsigned int MAX_BLOCK_WEIGHT = 4000000;\n /** The maximum allowed size for a block excluding witness data, in bytes (network rule) */\n static const unsigned int MAX_BLOCK_BASE_SIZE = 1000000;\n /** The maximum allowed number of signature check operations in a block (network rule) */"
      },
      {
        "sha": "5b2f49184fc3f6d2a1a28e8c69e5f5271600fc20",
        "filename": "src/consensus/params.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/consensus/params.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/consensus/params.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/params.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -39,13 +39,13 @@ struct BIP9Deployment {\n struct Params {\n     uint256 hashGenesisBlock;\n     int nSubsidyHalvingInterval;\n-    /** Used to check majorities for block version upgrade */\n-    int nMajorityEnforceBlockUpgrade;\n-    int nMajorityRejectBlockOutdated;\n-    int nMajorityWindow;\n     /** Block height and hash at which BIP34 becomes active */\n     int BIP34Height;\n     uint256 BIP34Hash;\n+    /** Block height at which BIP65 becomes active */\n+    int BIP65Height;\n+    /** Block height at which BIP66 becomes active */\n+    int BIP66Height;\n     /**\n      * Minimum blocks including miner confirmation of the total of 2016 blocks in a retargetting period,\n      * (nPowTargetTimespan / nPowTargetSpacing) which is also used for BIP9 deployments."
      },
      {
        "sha": "47bdb31b5b888fbe329e8fa64072fda509909786",
        "filename": "src/dbwrapper.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/dbwrapper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/dbwrapper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dbwrapper.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -52,9 +52,9 @@ class CDBBatch\n \n public:\n     /**\n-     * @param[in] parent    CDBWrapper that this batch is to be submitted to\n+     * @param[in] _parent   CDBWrapper that this batch is to be submitted to\n      */\n-    CDBBatch(const CDBWrapper &parent) : parent(parent) { };\n+    CDBBatch(const CDBWrapper &_parent) : parent(_parent) { };\n \n     template <typename K, typename V>\n     void Write(const K& key, const V& value)\n@@ -94,11 +94,11 @@ class CDBIterator\n public:\n \n     /**\n-     * @param[in] parent           Parent CDBWrapper instance.\n-     * @param[in] piterIn          The original leveldb iterator.\n+     * @param[in] _parent          Parent CDBWrapper instance.\n+     * @param[in] _piter           The original leveldb iterator.\n      */\n-    CDBIterator(const CDBWrapper &parent, leveldb::Iterator *piterIn) :\n-        parent(parent), piter(piterIn) { };\n+    CDBIterator(const CDBWrapper &_parent, leveldb::Iterator *_piter) :\n+        parent(_parent), piter(_piter) { };\n     ~CDBIterator();\n \n     bool Valid();"
      },
      {
        "sha": "f921305fcc36b824c9bda95ecd20165afecf6787",
        "filename": "src/httpserver.cpp",
        "status": "modified",
        "additions": 38,
        "deletions": 33,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/httpserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/httpserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -19,6 +19,7 @@\n #include <sys/types.h>\n #include <sys/stat.h>\n #include <signal.h>\n+#include <future>\n \n #include <event2/event.h>\n #include <event2/http.h>\n@@ -34,9 +35,6 @@\n #endif\n #endif\n \n-#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n-#include <boost/foreach.hpp>\n-\n /** Maximum size of http request (request line + headers) */\n static const size_t MAX_HEADERS_SIZE = 8192;\n \n@@ -68,8 +66,8 @@ class WorkQueue\n {\n private:\n     /** Mutex protects entire object */\n-    CWaitableCriticalSection cs;\n-    CConditionVariable cond;\n+    std::mutex cs;\n+    std::condition_variable cond;\n     std::deque<std::unique_ptr<WorkItem>> queue;\n     bool running;\n     size_t maxDepth;\n@@ -82,12 +80,12 @@ class WorkQueue\n         WorkQueue &wq;\n         ThreadCounter(WorkQueue &w): wq(w)\n         {\n-            boost::lock_guard<boost::mutex> lock(wq.cs);\n+            std::lock_guard<std::mutex> lock(wq.cs);\n             wq.numThreads += 1;\n         }\n         ~ThreadCounter()\n         {\n-            boost::lock_guard<boost::mutex> lock(wq.cs);\n+            std::lock_guard<std::mutex> lock(wq.cs);\n             wq.numThreads -= 1;\n             wq.cond.notify_all();\n         }\n@@ -108,7 +106,7 @@ class WorkQueue\n     /** Enqueue a work item */\n     bool Enqueue(WorkItem* item)\n     {\n-        boost::unique_lock<boost::mutex> lock(cs);\n+        std::unique_lock<std::mutex> lock(cs);\n         if (queue.size() >= maxDepth) {\n             return false;\n         }\n@@ -123,7 +121,7 @@ class WorkQueue\n         while (running) {\n             std::unique_ptr<WorkItem> i;\n             {\n-                boost::unique_lock<boost::mutex> lock(cs);\n+                std::unique_lock<std::mutex> lock(cs);\n                 while (running && queue.empty())\n                     cond.wait(lock);\n                 if (!running)\n@@ -137,22 +135,22 @@ class WorkQueue\n     /** Interrupt and exit loops */\n     void Interrupt()\n     {\n-        boost::unique_lock<boost::mutex> lock(cs);\n+        std::unique_lock<std::mutex> lock(cs);\n         running = false;\n         cond.notify_all();\n     }\n     /** Wait for worker threads to exit */\n     void WaitExit()\n     {\n-        boost::unique_lock<boost::mutex> lock(cs);\n+        std::unique_lock<std::mutex> lock(cs);\n         while (numThreads > 0)\n             cond.wait(lock);\n     }\n \n     /** Return current depth of queue */\n     size_t Depth()\n     {\n-        boost::unique_lock<boost::mutex> lock(cs);\n+        std::unique_lock<std::mutex> lock(cs);\n         return queue.size();\n     }\n };\n@@ -189,7 +187,7 @@ static bool ClientAllowed(const CNetAddr& netaddr)\n {\n     if (!netaddr.IsValid())\n         return false;\n-    BOOST_FOREACH (const CSubNet& subnet, rpc_allow_subnets)\n+    for(const CSubNet& subnet : rpc_allow_subnets)\n         if (subnet.Match(netaddr))\n             return true;\n     return false;\n@@ -199,12 +197,17 @@ static bool ClientAllowed(const CNetAddr& netaddr)\n static bool InitHTTPAllowList()\n {\n     rpc_allow_subnets.clear();\n-    rpc_allow_subnets.push_back(CSubNet(\"127.0.0.0/8\")); // always allow IPv4 local subnet\n-    rpc_allow_subnets.push_back(CSubNet(\"::1\"));         // always allow IPv6 localhost\n+    CNetAddr localv4;\n+    CNetAddr localv6;\n+    LookupHost(\"127.0.0.1\", localv4, false);\n+    LookupHost(\"::1\", localv6, false);\n+    rpc_allow_subnets.push_back(CSubNet(localv4, 8));      // always allow IPv4 local subnet\n+    rpc_allow_subnets.push_back(CSubNet(localv6));         // always allow IPv6 localhost\n     if (mapMultiArgs.count(\"-rpcallowip\")) {\n         const std::vector<std::string>& vAllow = mapMultiArgs[\"-rpcallowip\"];\n-        BOOST_FOREACH (std::string strAllow, vAllow) {\n-            CSubNet subnet(strAllow);\n+        for (std::string strAllow : vAllow) {\n+            CSubNet subnet;\n+            LookupSubNet(strAllow.c_str(), subnet);\n             if (!subnet.IsValid()) {\n                 uiInterface.ThreadSafeMessageBox(\n                     strprintf(\"Invalid -rpcallowip subnet specification: %s. Valid are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24).\", strAllow),\n@@ -215,7 +218,7 @@ static bool InitHTTPAllowList()\n         }\n     }\n     std::string strAllowed;\n-    BOOST_FOREACH (const CSubNet& subnet, rpc_allow_subnets)\n+    for (const CSubNet& subnet : rpc_allow_subnets)\n         strAllowed += subnet.ToString() + \" \";\n     LogPrint(\"http\", \"Allowing HTTP connections from: %s\\n\", strAllowed);\n     return true;\n@@ -302,13 +305,14 @@ static void http_reject_request_cb(struct evhttp_request* req, void*)\n }\n \n /** Event dispatcher thread */\n-static void ThreadHTTP(struct event_base* base, struct evhttp* http)\n+static bool ThreadHTTP(struct event_base* base, struct evhttp* http)\n {\n     RenameThread(\"bitcoin-http\");\n     LogPrint(\"http\", \"Entering http event loop\\n\");\n     event_base_dispatch(base);\n     // Event loop will be interrupted by InterruptHTTPServer()\n     LogPrint(\"http\", \"Exited http event loop\\n\");\n+    return event_base_got_break(base) == 0;\n }\n \n /** Bind HTTP server to specified addresses */\n@@ -437,17 +441,22 @@ bool InitHTTPServer()\n     return true;\n }\n \n-boost::thread threadHTTP;\n+std::thread threadHTTP;\n+std::future<bool> threadResult;\n \n bool StartHTTPServer()\n {\n     LogPrint(\"http\", \"Starting HTTP server\\n\");\n     int rpcThreads = std::max((long)GetArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n     LogPrintf(\"HTTP: starting %d worker threads\\n\", rpcThreads);\n-    threadHTTP = boost::thread(boost::bind(&ThreadHTTP, eventBase, eventHTTP));\n+    std::packaged_task<bool(event_base*, evhttp*)> task(ThreadHTTP);\n+    threadResult = task.get_future();\n+    threadHTTP = std::thread(std::move(task), eventBase, eventHTTP);\n \n-    for (int i = 0; i < rpcThreads; i++)\n-        boost::thread(boost::bind(&HTTPWorkQueueRun, workQueue));\n+    for (int i = 0; i < rpcThreads; i++) {\n+        std::thread rpc_worker(HTTPWorkQueueRun, workQueue);\n+        rpc_worker.detach();\n+    }\n     return true;\n }\n \n@@ -456,7 +465,7 @@ void InterruptHTTPServer()\n     LogPrint(\"http\", \"Interrupting HTTP server\\n\");\n     if (eventHTTP) {\n         // Unlisten sockets\n-        BOOST_FOREACH (evhttp_bound_socket *socket, boundSockets) {\n+        for (evhttp_bound_socket *socket : boundSockets) {\n             evhttp_del_accept_socket(eventHTTP, socket);\n         }\n         // Reject requests on current connections\n@@ -482,15 +491,11 @@ void StopHTTPServer()\n         // master that appears to be solved, so in the future that solution\n         // could be used again (if desirable).\n         // (see discussion in https://github.com/bitcoin/bitcoin/pull/6990)\n-#if BOOST_VERSION >= 105000\n-        if (!threadHTTP.try_join_for(boost::chrono::milliseconds(2000))) {\n-#else\n-        if (!threadHTTP.timed_join(boost::posix_time::milliseconds(2000))) {\n-#endif\n+        if (threadResult.valid() && threadResult.wait_for(std::chrono::milliseconds(2000)) == std::future_status::timeout) {\n             LogPrintf(\"HTTP event loop did not exit within allotted time, sending loopbreak\\n\");\n             event_base_loopbreak(eventBase);\n-            threadHTTP.join();\n         }\n+        threadHTTP.join();\n     }\n     if (eventHTTP) {\n         evhttp_free(eventHTTP);\n@@ -517,7 +522,7 @@ static void httpevent_callback_fn(evutil_socket_t, short, void* data)\n         delete self;\n }\n \n-HTTPEvent::HTTPEvent(struct event_base* base, bool deleteWhenTriggered, const boost::function<void(void)>& handler):\n+HTTPEvent::HTTPEvent(struct event_base* base, bool deleteWhenTriggered, const std::function<void(void)>& handler):\n     deleteWhenTriggered(deleteWhenTriggered), handler(handler)\n {\n     ev = event_new(base, -1, 0, httpevent_callback_fn, this);\n@@ -599,7 +604,7 @@ void HTTPRequest::WriteReply(int nStatus, const std::string& strReply)\n     assert(evb);\n     evbuffer_add(evb, strReply.data(), strReply.size());\n     HTTPEvent* ev = new HTTPEvent(eventBase, true,\n-        boost::bind(evhttp_send_reply, req, nStatus, (const char*)NULL, (struct evbuffer *)NULL));\n+        std::bind(evhttp_send_reply, req, nStatus, (const char*)NULL, (struct evbuffer *)NULL));\n     ev->trigger(0);\n     replySent = true;\n     req = 0; // transferred back to main thread\n@@ -614,7 +619,7 @@ CService HTTPRequest::GetPeer()\n         const char* address = \"\";\n         uint16_t port = 0;\n         evhttp_connection_get_peer(con, (char**)&address, &port);\n-        peer = CService(address, port);\n+        peer = LookupNumeric(address, port);\n     }\n     return peer;\n }"
      },
      {
        "sha": "49d67f4b88427dd5234e26c434a18e560d998f79",
        "filename": "src/httpserver.h",
        "status": "modified",
        "additions": 4,
        "deletions": 6,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/httpserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/httpserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -7,9 +7,7 @@\n \n #include <string>\n #include <stdint.h>\n-#include <boost/thread.hpp>\n-#include <boost/scoped_ptr.hpp>\n-#include <boost/function.hpp>\n+#include <functional>\n \n static const int DEFAULT_HTTP_THREADS=4;\n static const int DEFAULT_HTTP_WORKQUEUE=16;\n@@ -35,7 +33,7 @@ void InterruptHTTPServer();\n void StopHTTPServer();\n \n /** Handler for requests to a certain HTTP path */\n-typedef boost::function<void(HTTPRequest* req, const std::string &)> HTTPRequestHandler;\n+typedef std::function<bool(HTTPRequest* req, const std::string &)> HTTPRequestHandler;\n /** Register handler for prefix.\n  * If multiple handlers match a prefix, the first-registered one will\n  * be invoked.\n@@ -132,7 +130,7 @@ class HTTPEvent\n      * deleteWhenTriggered deletes this event object after the event is triggered (and the handler called)\n      * handler is the handler to call when the event is triggered.\n      */\n-    HTTPEvent(struct event_base* base, bool deleteWhenTriggered, const boost::function<void(void)>& handler);\n+    HTTPEvent(struct event_base* base, bool deleteWhenTriggered, const std::function<void(void)>& handler);\n     ~HTTPEvent();\n \n     /** Trigger the event. If tv is 0, trigger it immediately. Otherwise trigger it after\n@@ -141,7 +139,7 @@ class HTTPEvent\n     void trigger(struct timeval* tv);\n \n     bool deleteWhenTriggered;\n-    boost::function<void(void)> handler;\n+    std::function<void(void)> handler;\n private:\n     struct event* ev;\n };"
      },
      {
        "sha": "76da4a6bd5575af785318e9135c2079820c5ac2c",
        "filename": "src/indirectmap.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/indirectmap.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/indirectmap.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/indirectmap.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -1,3 +1,7 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n #ifndef BITCOIN_INDIRECTMAP_H\n #define BITCOIN_INDIRECTMAP_H\n "
      },
      {
        "sha": "ce5f4b3a88f429b34a2735ddb3887bc7d566e897",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 85,
        "deletions": 27,
        "changes": 112,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -21,6 +21,7 @@\n #include \"key.h\"\n #include \"main.h\"\n #include \"miner.h\"\n+#include \"netbase.h\"\n #include \"net.h\"\n #include \"policy/policy.h\"\n #include \"rpc/server.h\"\n@@ -410,6 +411,7 @@ std::string HelpMessage(HelpMessageMode mode)\n         strUsage += HelpMessageOpt(\"-limitancestorsize=<n>\", strprintf(\"Do not accept transactions whose size with all in-mempool ancestors exceeds <n> kilobytes (default: %u)\", DEFAULT_ANCESTOR_SIZE_LIMIT));\n         strUsage += HelpMessageOpt(\"-limitdescendantcount=<n>\", strprintf(\"Do not accept transactions if any ancestor would have <n> or more in-mempool descendants (default: %u)\", DEFAULT_DESCENDANT_LIMIT));\n         strUsage += HelpMessageOpt(\"-limitdescendantsize=<n>\", strprintf(\"Do not accept transactions if any ancestor would have more than <n> kilobytes of in-mempool descendants (default: %u).\", DEFAULT_DESCENDANT_SIZE_LIMIT));\n+        strUsage += HelpMessageOpt(\"-bip9params=deployment:start:end\", \"Use given start/end times for specified BIP9 deployment (regtest-only)\");\n     }\n     string debugCategories = \"addrman, alert, bench, coindb, db, http, libevent, lock, mempool, mempoolrej, net, proxy, prune, rand, reindex, rpc, selectcoins, tor, zmq\"; // Don't translate these and qt below\n     if (mode == HMM_BITCOIN_QT)\n@@ -446,14 +448,13 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageGroup(_(\"Node relay options:\"));\n     if (showDebug)\n         strUsage += HelpMessageOpt(\"-acceptnonstdtxn\", strprintf(\"Relay and mine \\\"non-standard\\\" transactions (%sdefault: %u)\", \"testnet/regtest only; \", !Params(CBaseChainParams::TESTNET).RequireStandard()));\n-    strUsage += HelpMessageOpt(\"-bytespersigop\", strprintf(_(\"Minimum bytes per sigop in transactions we relay and mine (default: %u)\"), DEFAULT_BYTES_PER_SIGOP));\n+    strUsage += HelpMessageOpt(\"-bytespersigop\", strprintf(_(\"Equivalent bytes per sigop in transactions for relay and mining (default: %u)\"), DEFAULT_BYTES_PER_SIGOP));\n     strUsage += HelpMessageOpt(\"-datacarrier\", strprintf(_(\"Relay and mine data carrier transactions (default: %u)\"), DEFAULT_ACCEPT_DATACARRIER));\n     strUsage += HelpMessageOpt(\"-datacarriersize\", strprintf(_(\"Maximum size of data in data carrier transactions we relay and mine (default: %u)\"), MAX_OP_RETURN_RELAY));\n     strUsage += HelpMessageOpt(\"-mempoolreplacement\", strprintf(_(\"Enable transaction replacement in the memory pool (default: %u)\"), DEFAULT_ENABLE_REPLACEMENT));\n \n     strUsage += HelpMessageGroup(_(\"Block creation options:\"));\n-    strUsage += HelpMessageOpt(\"-blockmaxcost=<n>\", strprintf(_(\"Set maximum block cost (default: %d)\"), DEFAULT_BLOCK_MAX_COST));\n-    strUsage += HelpMessageOpt(\"-blockminsize=<n>\", strprintf(_(\"Set minimum block size in bytes (default: %u)\"), DEFAULT_BLOCK_MIN_SIZE));\n+    strUsage += HelpMessageOpt(\"-blockmaxweight=<n>\", strprintf(_(\"Set maximum BIP141 block weight (default: %d)\"), DEFAULT_BLOCK_MAX_WEIGHT));\n     strUsage += HelpMessageOpt(\"-blockmaxsize=<n>\", strprintf(_(\"Set maximum block size in bytes (default: %d)\"), DEFAULT_BLOCK_MAX_SIZE));\n     strUsage += HelpMessageOpt(\"-blockprioritysize=<n>\", strprintf(_(\"Set maximum size of high-priority/low-fee transactions in bytes (default: %d)\"), DEFAULT_BLOCK_PRIORITY_SIZE));\n     if (showDebug)\n@@ -482,7 +483,7 @@ std::string LicenseInfo()\n {\n     const std::string URL_SOURCE_CODE = \"<https://github.com/bitcoin/bitcoin>\";\n     const std::string URL_WEBSITE = \"<https://bitcoincore.org>\";\n-    // todo: remove urls from translations on next change\n+\n     return CopyrightHolders(strprintf(_(\"Copyright (C) %i-%i\"), 2009, COPYRIGHT_YEAR) + \" \") + \"\\n\" +\n            \"\\n\" +\n            strprintf(_(\"Please contribute if you find %s useful. \"\n@@ -494,9 +495,9 @@ std::string LicenseInfo()\n            \"\\n\" +\n            \"\\n\" +\n            _(\"This is experimental software.\") + \"\\n\" +\n-           _(\"Distributed under the MIT software license, see the accompanying file COPYING or <http://www.opensource.org/licenses/mit-license.php>.\") + \"\\n\" +\n+           strprintf(_(\"Distributed under the MIT software license, see the accompanying file %s or %s\"), \"COPYING\", \"<https://opensource.org/licenses/MIT>\") + \"\\n\" +\n            \"\\n\" +\n-           _(\"This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit <https://www.openssl.org/> and cryptographic software written by Eric Young and UPnP software written by Thomas Bernard.\") +\n+           strprintf(_(\"This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit %s and cryptographic software written by Eric Young and UPnP software written by Thomas Bernard.\"), \"<https://www.openssl.org>\") +\n            \"\\n\";\n }\n \n@@ -511,6 +512,21 @@ static void BlockNotifyCallback(bool initialSync, const CBlockIndex *pBlockIndex\n     boost::thread t(runCommand, strCmd); // thread runs free\n }\n \n+static bool fHaveGenesis = false;\n+static boost::mutex cs_GenesisWait;\n+static CConditionVariable condvar_GenesisWait;\n+\n+static void BlockNotifyGenesisWait(bool, const CBlockIndex *pBlockIndex)\n+{\n+    if (pBlockIndex != NULL) {\n+        {\n+            boost::unique_lock<boost::mutex> lock_GenesisWait(cs_GenesisWait);\n+            fHaveGenesis = true;\n+        }\n+        condvar_GenesisWait.notify_all();\n+    }\n+}\n+\n struct CImportingNow\n {\n     CImportingNow() {\n@@ -877,6 +893,9 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n     if (GetBoolArg(\"-whitelistalwaysrelay\", false))\n         InitWarning(_(\"Unsupported argument -whitelistalwaysrelay ignored, use -whitelistrelay and/or -whitelistforcerelay.\"));\n \n+    if (mapArgs.count(\"-blockminsize\"))\n+        InitWarning(\"Unsupported argument -blockminsize ignored.\");\n+\n     // Checkmempool and checkblockindex default to true in regtest mode\n     int ratio = std::min<int>(std::max<int>(GetArg(\"-checkmempool\", chainparams.DefaultConsistencyChecks() ? 1 : 0), 0), 1000000);\n     if (ratio != 0) {\n@@ -973,6 +992,41 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n         fEnableReplacement = (std::find(vstrReplacementModes.begin(), vstrReplacementModes.end(), \"fee\") != vstrReplacementModes.end());\n     }\n \n+    if (!mapMultiArgs[\"-bip9params\"].empty()) {\n+        // Allow overriding BIP9 parameters for testing\n+        if (!Params().MineBlocksOnDemand()) {\n+            return InitError(\"BIP9 parameters may only be overridden on regtest.\");\n+        }\n+        const vector<string>& deployments = mapMultiArgs[\"-bip9params\"];\n+        for (auto i : deployments) {\n+            std::vector<std::string> vDeploymentParams;\n+            boost::split(vDeploymentParams, i, boost::is_any_of(\":\"));\n+            if (vDeploymentParams.size() != 3) {\n+                return InitError(\"BIP9 parameters malformed, expecting deployment:start:end\");\n+            }\n+            int64_t nStartTime, nTimeout;\n+            if (!ParseInt64(vDeploymentParams[1], &nStartTime)) {\n+                return InitError(strprintf(\"Invalid nStartTime (%s)\", vDeploymentParams[1]));\n+            }\n+            if (!ParseInt64(vDeploymentParams[2], &nTimeout)) {\n+                return InitError(strprintf(\"Invalid nTimeout (%s)\", vDeploymentParams[2]));\n+            }\n+            bool found = false;\n+            for (int j=0; j<(int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j)\n+            {\n+                if (vDeploymentParams[0].compare(VersionBitsDeploymentInfo[j].name) == 0) {\n+                    UpdateRegtestBIP9Parameters(Consensus::DeploymentPos(j), nStartTime, nTimeout);\n+                    found = true;\n+                    LogPrintf(\"Setting BIP9 activation parameters for %s to start=%ld, timeout=%ld\\n\", vDeploymentParams[0], nStartTime, nTimeout);\n+                    break;\n+                }\n+            }\n+            if (!found) {\n+                return InitError(strprintf(\"Invalid deployment (%s)\", vDeploymentParams[0]));\n+            }\n+        }\n+    }\n+\n     // ********************************************************* Step 4: application initialization: dir lock, daemonize, pidfile, debug log\n \n     // Initialize elliptic curve code\n@@ -1013,7 +1067,6 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n     LogPrintf(\"Using data directory %s\\n\", strDataDir);\n     LogPrintf(\"Using config file %s\\n\", GetConfigFile().string());\n     LogPrintf(\"Using at most %i connections (%i file descriptors available)\\n\", nMaxConnections, nFD);\n-    std::ostringstream strErrors;\n \n     LogPrintf(\"Using %u threads for script verification\\n\", nScriptCheckThreads);\n     if (nScriptCheckThreads) {\n@@ -1081,7 +1134,8 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n \n     if (mapArgs.count(\"-whitelist\")) {\n         BOOST_FOREACH(const std::string& net, mapMultiArgs[\"-whitelist\"]) {\n-            CSubNet subnet(net);\n+            CSubNet subnet;\n+            LookupSubNet(net.c_str(), subnet);\n             if (!subnet.IsValid())\n                 return InitError(strprintf(_(\"Invalid netmask specified in -whitelist: '%s'\"), net));\n             CNode::AddWhitelistedRange(subnet);\n@@ -1094,7 +1148,8 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n     std::string proxyArg = GetArg(\"-proxy\", \"\");\n     SetLimited(NET_TOR);\n     if (proxyArg != \"\" && proxyArg != \"0\") {\n-        proxyType addrProxy = proxyType(CService(proxyArg, 9050), proxyRandomize);\n+        CService resolved(LookupNumeric(proxyArg.c_str(), 9050));\n+        proxyType addrProxy = proxyType(resolved, proxyRandomize);\n         if (!addrProxy.IsValid())\n             return InitError(strprintf(_(\"Invalid -proxy address: '%s'\"), proxyArg));\n \n@@ -1113,7 +1168,8 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n         if (onionArg == \"0\") { // Handle -noonion/-onion=0\n             SetLimited(NET_TOR); // set onions as unreachable\n         } else {\n-            proxyType addrOnion = proxyType(CService(onionArg, 9050), proxyRandomize);\n+            CService resolved(LookupNumeric(onionArg.c_str(), 9050));\n+            proxyType addrOnion = proxyType(resolved, proxyRandomize);\n             if (!addrOnion.IsValid())\n                 return InitError(strprintf(_(\"Invalid -onion address: '%s'\"), onionArg));\n             SetProxy(NET_TOR, addrOnion);\n@@ -1214,7 +1270,7 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n     // cache size calculations\n     int64_t nTotalCache = (GetArg(\"-dbcache\", nDefaultDbCache) << 20);\n     nTotalCache = std::max(nTotalCache, nMinDbCache << 20); // total cache cannot be less than nMinDbCache\n-    nTotalCache = std::min(nTotalCache, nMaxDbCache << 20); // total cache cannot be greated than nMaxDbcache\n+    nTotalCache = std::min(nTotalCache, nMaxDbCache << 20); // total cache cannot be greater than nMaxDbcache\n     int64_t nBlockTreeDBCache = nTotalCache / 8;\n     nBlockTreeDBCache = std::min(nBlockTreeDBCache, (GetBoolArg(\"-txindex\", DEFAULT_TXINDEX) ? nMaxBlockDBAndTxIndexCache : nMaxBlockDBCache) << 20);\n     nTotalCache -= nBlockTreeDBCache;\n@@ -1284,7 +1340,7 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n                     break;\n                 }\n \n-                if (!fReindex) {\n+                if (!fReindex && chainActive.Tip() != NULL) {\n                     uiInterface.InitMessage(_(\"Rewinding blocks...\"));\n                     if (!RewindBlockIndex(chainparams)) {\n                         strLoadError = _(\"Unable to rewind the database to a pre-fork state. You will need to redownload the blockchain\");\n@@ -1401,6 +1457,17 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n \n     // ********************************************************* Step 10: import blocks\n \n+    if (!CheckDiskSpace())\n+        return false;\n+\n+    // Either install a handler to notify us when genesis activates, or set fHaveGenesis directly.\n+    // No locking, as this happens before any background thread is started.\n+    if (chainActive.Tip() == NULL) {\n+        uiInterface.NotifyBlockTip.connect(BlockNotifyGenesisWait);\n+    } else {\n+        fHaveGenesis = true;\n+    }\n+\n     if (mapArgs.count(\"-blocknotify\"))\n         uiInterface.NotifyBlockTip.connect(BlockNotifyCallback);\n \n@@ -1410,29 +1477,20 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n         BOOST_FOREACH(const std::string& strFile, mapMultiArgs[\"-loadblock\"])\n             vImportFiles.push_back(strFile);\n     }\n+\n     threadGroup.create_thread(boost::bind(&ThreadImport, vImportFiles));\n \n     // Wait for genesis block to be processed\n-    bool fHaveGenesis = false;\n-    while (!fHaveGenesis && !fRequestShutdown) {\n-        {\n-            LOCK(cs_main);\n-            fHaveGenesis = (chainActive.Tip() != NULL);\n-        }\n-\n-        if (!fHaveGenesis) {\n-            MilliSleep(10);\n+    {\n+        boost::unique_lock<boost::mutex> lock(cs_GenesisWait);\n+        while (!fHaveGenesis) {\n+            condvar_GenesisWait.wait(lock);\n         }\n+        uiInterface.NotifyBlockTip.disconnect(BlockNotifyGenesisWait);\n     }\n \n     // ********************************************************* Step 11: start node\n \n-    if (!CheckDiskSpace())\n-        return false;\n-\n-    if (!strErrors.str().empty())\n-        return InitError(strErrors.str());\n-\n     //// debug print\n     LogPrintf(\"mapBlockIndex.size() = %u\\n\",   mapBlockIndex.size());\n     LogPrintf(\"nBestHeight = %d\\n\",                   chainActive.Height());"
      },
      {
        "sha": "b589710badffb11e26b2d65520b72d61c4f42e03",
        "filename": "src/key.h",
        "status": "modified",
        "additions": 16,
        "deletions": 15,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/key.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/key.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -15,7 +15,7 @@\n #include <vector>\n \n \n-/** \n+/**\n  * secp256k1:\n  * const unsigned int PRIVATE_KEY_SIZE = 279;\n  * const unsigned int PUBLIC_KEY_SIZE  = 65;\n@@ -45,6 +45,8 @@ class CKey\n     //! The actual byte data\n     unsigned char vch[32];\n \n+    static_assert(sizeof(vch) == 32, \"vch must be 32 bytes in length to not break serialization\");\n+\n     //! Check whether the 32-byte array pointed to be vch is valid keydata.\n     bool static Check(const unsigned char* vch);\n \n@@ -70,20 +72,19 @@ class CKey\n \n     friend bool operator==(const CKey& a, const CKey& b)\n     {\n-        return a.fCompressed == b.fCompressed && a.size() == b.size() &&\n-               memcmp(&a.vch[0], &b.vch[0], a.size()) == 0;\n+        return a.fCompressed == b.fCompressed &&\n+            a.size() == b.size() &&\n+            memcmp(&a.vch[0], &b.vch[0], a.size()) == 0;\n     }\n \n     //! Initialize using begin and end iterators to byte data.\n     template <typename T>\n     void Set(const T pbegin, const T pend, bool fCompressedIn)\n     {\n-        if (pend - pbegin != 32) {\n+        if (pend - pbegin != sizeof(vch)) {\n             fValid = false;\n-            return;\n-        }\n-        if (Check(&pbegin[0])) {\n-            memcpy(vch, (unsigned char*)&pbegin[0], 32);\n+        } else if (Check(&pbegin[0])) {\n+            memcpy(vch, (unsigned char*)&pbegin[0], sizeof(vch));\n             fValid = true;\n             fCompressed = fCompressedIn;\n         } else {\n@@ -92,7 +93,7 @@ class CKey\n     }\n \n     //! Simple read-only vector-like interface.\n-    unsigned int size() const { return (fValid ? 32 : 0); }\n+    unsigned int size() const { return (fValid ? sizeof(vch) : 0); }\n     const unsigned char* begin() const { return vch; }\n     const unsigned char* end() const { return vch + size(); }\n \n@@ -110,7 +111,7 @@ class CKey\n \n     /**\n      * Convert the private key to a CPrivKey (serialized OpenSSL private key data).\n-     * This is expensive. \n+     * This is expensive.\n      */\n     CPrivKey GetPrivKey() const;\n \n@@ -146,9 +147,6 @@ class CKey\n \n     //! Load private key and check that public key matches.\n     bool Load(CPrivKey& privkey, CPubKey& vchPubKey, bool fSkipCheck);\n-\n-    //! Check whether an element of a signature (r or s) is valid.\n-    static bool CheckSignatureElement(const unsigned char* vch, int len, bool half);\n };\n \n struct CExtKey {\n@@ -160,8 +158,11 @@ struct CExtKey {\n \n     friend bool operator==(const CExtKey& a, const CExtKey& b)\n     {\n-        return a.nDepth == b.nDepth && memcmp(&a.vchFingerprint[0], &b.vchFingerprint[0], 4) == 0 && a.nChild == b.nChild &&\n-               a.chaincode == b.chaincode && a.key == b.key;\n+        return a.nDepth == b.nDepth &&\n+            memcmp(&a.vchFingerprint[0], &b.vchFingerprint[0], sizeof(vchFingerprint)) == 0 &&\n+            a.nChild == b.nChild &&\n+            a.chaincode == b.chaincode &&\n+            a.key == b.key;\n     }\n \n     void Encode(unsigned char code[BIP32_EXTKEY_SIZE]) const;"
      },
      {
        "sha": "7841d7f4a4abe006ef1fc13ef200f89eb63b0564",
        "filename": "src/limitedmap.h",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/limitedmap.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/limitedmap.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/limitedmap.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -66,8 +66,11 @@ class limitedmap\n     }\n     void update(const_iterator itIn, const mapped_type& v)\n     {\n-        // TODO: When we switch to C++11, use map.erase(itIn, itIn) to get the non-const iterator.\n-        iterator itTarget = map.find(itIn->first);\n+        // Using map::erase() with empty range instead of map::find() to get a non-const iterator,\n+        // since it is a constant time operation in C++11. For more details, see\n+        // https://stackoverflow.com/questions/765148/how-to-remove-constness-of-const-iterator\n+        iterator itTarget = map.erase(itIn, itIn);\n+        \n         if (itTarget == map.end())\n             return;\n         std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);"
      },
      {
        "sha": "75f991d31a723c37d090d3023cc832238228dea5",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 111,
        "deletions": 85,
        "changes": 196,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -74,7 +74,6 @@ bool fHavePruned = false;\n bool fPruneMode = false;\n bool fIsBareMultisigStd = DEFAULT_PERMIT_BAREMULTISIG;\n bool fRequireStandard = true;\n-unsigned int nBytesPerSigOp = DEFAULT_BYTES_PER_SIGOP;\n bool fCheckBlockIndex = false;\n bool fCheckpointsEnabled = DEFAULT_CHECKPOINTS_ENABLED;\n size_t nCoinCacheUsage = 5000 * 300;\n@@ -107,11 +106,6 @@ map<uint256, COrphanTx> mapOrphanTransactions GUARDED_BY(cs_main);\n map<COutPoint, set<map<uint256, COrphanTx>::iterator, IteratorComparator>> mapOrphanTransactionsByPrev GUARDED_BY(cs_main);\n void EraseOrphansFor(NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n-/**\n- * Returns true if there are nRequired or more blocks of minVersion or above\n- * in the last Consensus::Params::nMajorityWindow blocks, starting at pstart and going backwards.\n- */\n-static bool IsSuperMajority(int minVersion, const CBlockIndex* pstart, unsigned nRequired, const Consensus::Params& consensusParams);\n static void CheckBlockIndex(const Consensus::Params& consensusParams);\n \n /** Constant stuff for coinbase transactions we create: */\n@@ -276,6 +270,8 @@ struct CNodeState {\n     CBlockIndex *pindexLastCommonBlock;\n     //! The best header we have sent our peer.\n     CBlockIndex *pindexBestHeaderSent;\n+    //! Length of current-streak of unconnecting headers announcements\n+    int nUnconnectingHeaders;\n     //! Whether we've started headers synchronization with this peer.\n     bool fSyncStarted;\n     //! Since when we're stalling block download progress (in microseconds), or 0.\n@@ -304,6 +300,7 @@ struct CNodeState {\n         hashLastUnknownBlock.SetNull();\n         pindexLastCommonBlock = NULL;\n         pindexBestHeaderSent = NULL;\n+        nUnconnectingHeaders = 0;\n         fSyncStarted = false;\n         nStallingSince = 0;\n         nDownloadingSince = 0;\n@@ -691,8 +688,8 @@ bool AddOrphanTx(const CTransaction& tx, NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(c\n     // have been mined or received.\n     // 100 orphans, each of which is at most 99,999 bytes big is\n     // at most 10 megabytes of orphans and somewhat more byprev index (in the worst case):\n-    unsigned int sz = GetTransactionCost(tx);\n-    if (sz >= MAX_STANDARD_TX_COST)\n+    unsigned int sz = GetTransactionWeight(tx);\n+    if (sz >= MAX_STANDARD_TX_WEIGHT)\n     {\n         LogPrint(\"mempool\", \"ignoring large orphan tx (size: %u, hash: %s)\\n\", sz, hash.ToString());\n         return false;\n@@ -785,7 +782,7 @@ bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64_t nBlockTime)\n         return true;\n     if ((int64_t)tx.nLockTime < ((int64_t)tx.nLockTime < LOCKTIME_THRESHOLD ? (int64_t)nBlockHeight : nBlockTime))\n         return true;\n-    BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n+    for (const auto& txin : tx.vin) {\n         if (!(txin.nSequence == CTxIn::SEQUENCE_FINAL))\n             return false;\n     }\n@@ -999,11 +996,11 @@ bool CheckSequenceLocks(const CTransaction &tx, int flags, LockPoints* lp, bool\n unsigned int GetLegacySigOpCount(const CTransaction& tx)\n {\n     unsigned int nSigOps = 0;\n-    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+    for (const auto& txin : tx.vin)\n     {\n         nSigOps += txin.scriptSig.GetSigOpCount(false);\n     }\n-    BOOST_FOREACH(const CTxOut& txout, tx.vout)\n+    for (const auto& txout : tx.vout)\n     {\n         nSigOps += txout.scriptPubKey.GetSigOpCount(false);\n     }\n@@ -1061,7 +1058,7 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state)\n \n     // Check for negative or overflow output values\n     CAmount nValueOut = 0;\n-    BOOST_FOREACH(const CTxOut& txout, tx.vout)\n+    for (const auto& txout : tx.vout)\n     {\n         if (txout.nValue < 0)\n             return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vout-negative\");\n@@ -1074,7 +1071,7 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state)\n \n     // Check for duplicate inputs\n     set<COutPoint> vInOutPoints;\n-    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+    for (const auto& txin : tx.vin)\n     {\n         if (vInOutPoints.count(txin.prevout))\n             return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n@@ -1088,7 +1085,7 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state)\n     }\n     else\n     {\n-        BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+        for (const auto& txin : tx.vin)\n             if (txin.prevout.IsNull())\n                 return state.DoS(10, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n     }\n@@ -1141,13 +1138,14 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n     }\n \n     // Reject transactions with witness before segregated witness activates (override with -prematurewitness)\n-    if (!GetBoolArg(\"-prematurewitness\",false) && !tx.wit.IsNull() && !IsWitnessEnabled(chainActive.Tip(), Params().GetConsensus())) {\n+    bool witnessEnabled = IsWitnessEnabled(chainActive.Tip(), Params().GetConsensus());\n+    if (!GetBoolArg(\"-prematurewitness\",false) && !tx.wit.IsNull() && !witnessEnabled) {\n         return state.DoS(0, false, REJECT_NONSTANDARD, \"no-witness-yet\", true);\n     }\n \n     // Rather not work on nonstandard transactions (unless -testnet/-regtest)\n     string reason;\n-    if (fRequireStandard && !IsStandardTx(tx, reason))\n+    if (fRequireStandard && !IsStandardTx(tx, reason, witnessEnabled))\n         return state.DoS(0, false, REJECT_NONSTANDARD, reason);\n \n     // Only accept nLockTime-using transactions that can be mined in the next\n@@ -1176,7 +1174,7 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n                 // nSequence >= maxint-1 on all inputs.\n                 //\n                 // maxint-1 is picked to still allow use of nLockTime by\n-                // non-replacable transactions. All inputs rather than just one\n+                // non-replaceable transactions. All inputs rather than just one\n                 // is for the sake of multi-party protocols, where we don't\n                 // want a single party to be able to disable replacement.\n                 //\n@@ -1293,7 +1291,7 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         // itself can contain sigops MAX_STANDARD_TX_SIGOPS is less than\n         // MAX_BLOCK_SIGOPS; we still consider this an invalid rather than\n         // merely non-standard transaction.\n-        if ((nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST) || (nBytesPerSigOp && nSigOpsCost > nSize * WITNESS_SCALE_FACTOR / nBytesPerSigOp))\n+        if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n             return state.DoS(0, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\", false,\n                 strprintf(\"%d\", nSigOpsCost));\n \n@@ -1543,7 +1541,7 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         }\n     }\n \n-    SyncWithWallets(tx, NULL, NULL);\n+    SyncWithWallets(tx, NULL);\n \n     return true;\n }\n@@ -1990,7 +1988,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n         // is safe because block merkle hashes are still computed and checked,\n         // and any change will be caught at the next checkpoint. Of course, if\n         // the checkpoint is for a chain that's invalid due to false scriptSigs\n-        // this optimisation would allow an invalid chain to be accepted.\n+        // this optimization would allow an invalid chain to be accepted.\n         if (fScriptChecks) {\n             for (unsigned int i = 0; i < tx.vin.size(); i++) {\n                 const COutPoint &prevout = tx.vin[i].prevout;\n@@ -2369,15 +2367,13 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n \n     unsigned int flags = fStrictPayToScriptHash ? SCRIPT_VERIFY_P2SH : SCRIPT_VERIFY_NONE;\n \n-    // Start enforcing the DERSIG (BIP66) rules, for block.nVersion=3 blocks,\n-    // when 75% of the network has upgraded:\n-    if (block.nVersion >= 3 && IsSuperMajority(3, pindex->pprev, chainparams.GetConsensus().nMajorityEnforceBlockUpgrade, chainparams.GetConsensus())) {\n+    // Start enforcing the DERSIG (BIP66) rule\n+    if (pindex->nHeight >= chainparams.GetConsensus().BIP66Height) {\n         flags |= SCRIPT_VERIFY_DERSIG;\n     }\n \n-    // Start enforcing CHECKLOCKTIMEVERIFY, (BIP65) for block.nVersion=4\n-    // blocks, when 75% of the network has upgraded:\n-    if (block.nVersion >= 4 && IsSuperMajority(4, pindex->pprev, chainparams.GetConsensus().nMajorityEnforceBlockUpgrade, chainparams.GetConsensus())) {\n+    // Start enforcing CHECKLOCKTIMEVERIFY (BIP65) rule\n+    if (pindex->nHeight >= chainparams.GetConsensus().BIP65Height) {\n         flags |= SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY;\n     }\n \n@@ -2774,7 +2770,7 @@ bool static DisconnectTip(CValidationState& state, const CChainParams& chainpara\n     // Let wallets know transactions went from 1-confirmed to\n     // 0-confirmed or conflicted:\n     BOOST_FOREACH(const CTransaction &tx, block.vtx) {\n-        SyncWithWallets(tx, pindexDelete->pprev, NULL);\n+        SyncWithWallets(tx, pindexDelete->pprev);\n     }\n     return true;\n }\n@@ -2789,7 +2785,7 @@ static int64_t nTimePostConnect = 0;\n  * Connect a new block to chainActive. pblock is either NULL or a pointer to a CBlock\n  * corresponding to pindexNew, to bypass loading it again from disk.\n  */\n-bool static ConnectTip(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const CBlock* pblock)\n+bool static ConnectTip(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const CBlock* pblock, std::list<CTransaction> &txConflicted, std::vector<std::tuple<CTransaction,CBlockIndex*,int> > &txChanged)\n {\n     assert(pindexNew->pprev == chainActive.Tip());\n     // Read block from disk.\n@@ -2825,20 +2821,13 @@ bool static ConnectTip(CValidationState& state, const CChainParams& chainparams,\n         return false;\n     int64_t nTime5 = GetTimeMicros(); nTimeChainState += nTime5 - nTime4;\n     LogPrint(\"bench\", \"  - Writing chainstate: %.2fms [%.2fs]\\n\", (nTime5 - nTime4) * 0.001, nTimeChainState * 0.000001);\n-    // Remove conflicting transactions from the mempool.\n-    list<CTransaction> txConflicted;\n+    // Remove conflicting transactions from the mempool.;\n     mempool.removeForBlock(pblock->vtx, pindexNew->nHeight, txConflicted, !IsInitialBlockDownload());\n     // Update chainActive & related variables.\n     UpdateTip(pindexNew, chainparams);\n-    // Tell wallet about transactions that went from mempool\n-    // to conflicted:\n-    BOOST_FOREACH(const CTransaction &tx, txConflicted) {\n-        SyncWithWallets(tx, pindexNew, NULL);\n-    }\n-    // ... and about transactions that got confirmed:\n-    BOOST_FOREACH(const CTransaction &tx, pblock->vtx) {\n-        SyncWithWallets(tx, pindexNew, pblock);\n-    }\n+\n+    for(unsigned int i=0; i < pblock->vtx.size(); i++)\n+        txChanged.push_back(std::make_tuple(pblock->vtx[i], pindexNew, i));\n \n     int64_t nTime6 = GetTimeMicros(); nTimePostConnect += nTime6 - nTime5; nTimeTotal += nTime6 - nTime1;\n     LogPrint(\"bench\", \"  - Connect postprocess: %.2fms [%.2fs]\\n\", (nTime6 - nTime5) * 0.001, nTimePostConnect * 0.000001);\n@@ -2920,7 +2909,7 @@ static void PruneBlockIndexCandidates() {\n  * Try to make some progress towards making pindexMostWork the active block.\n  * pblock is either NULL or a pointer to a CBlock corresponding to pindexMostWork.\n  */\n-static bool ActivateBestChainStep(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const CBlock* pblock, bool& fInvalidFound)\n+static bool ActivateBestChainStep(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const CBlock* pblock, bool& fInvalidFound, std::list<CTransaction>& txConflicted, std::vector<std::tuple<CTransaction,CBlockIndex*,int> >& txChanged)\n {\n     AssertLockHeld(cs_main);\n     const CBlockIndex *pindexOldTip = chainActive.Tip();\n@@ -2953,7 +2942,7 @@ static bool ActivateBestChainStep(CValidationState& state, const CChainParams& c\n \n         // Connect new blocks.\n         BOOST_REVERSE_FOREACH(CBlockIndex *pindexConnect, vpindexToConnect) {\n-            if (!ConnectTip(state, chainparams, pindexConnect, pindexConnect == pindexMostWork ? pblock : NULL)) {\n+            if (!ConnectTip(state, chainparams, pindexConnect, pindexConnect == pindexMostWork ? pblock : NULL, txConflicted, txChanged)) {\n                 if (state.IsInvalid()) {\n                     // The block violates a consensus rule.\n                     if (!state.CorruptionPossible())\n@@ -3028,6 +3017,8 @@ bool ActivateBestChain(CValidationState &state, const CChainParams& chainparams,\n             break;\n \n         const CBlockIndex *pindexFork;\n+        std::list<CTransaction> txConflicted;\n+        std::vector<std::tuple<CTransaction,CBlockIndex*,int> > txChanged;\n         bool fInitialDownload;\n         int nNewHeight;\n         {\n@@ -3042,7 +3033,7 @@ bool ActivateBestChain(CValidationState &state, const CChainParams& chainparams,\n                 return true;\n \n             bool fInvalidFound = false;\n-            if (!ActivateBestChainStep(state, chainparams, pindexMostWork, pblock && pblock->GetHash() == pindexMostWork->GetBlockHash() ? pblock : NULL, fInvalidFound))\n+            if (!ActivateBestChainStep(state, chainparams, pindexMostWork, pblock && pblock->GetHash() == pindexMostWork->GetBlockHash() ? pblock : NULL, fInvalidFound, txConflicted, txChanged))\n                 return false;\n \n             if (fInvalidFound) {\n@@ -3057,6 +3048,17 @@ bool ActivateBestChain(CValidationState &state, const CChainParams& chainparams,\n         // When we reach this point, we switched to a new tip (stored in pindexNewTip).\n \n         // Notifications/callbacks that can run without cs_main\n+\n+        // throw all transactions though the signal-interface\n+        // while _not_ holding the cs_main lock\n+        BOOST_FOREACH(const CTransaction &tx, txConflicted)\n+        {\n+            SyncWithWallets(tx, pindexNewTip);\n+        }\n+        // ... and about transactions that got confirmed:\n+        for(unsigned int i = 0; i < txChanged.size(); i++)\n+            SyncWithWallets(std::get<0>(txChanged[i]), std::get<1>(txChanged[i]), std::get<2>(txChanged[i]));\n+\n         // Always notify the UI if a new block tip was connected\n         if (pindexFork != pindexNewTip) {\n             uiInterface.NotifyBlockTip(fInitialDownload, pindexNewTip);\n@@ -3401,13 +3403,13 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n             return state.DoS(100, false, REJECT_INVALID, \"bad-cb-multiple\", false, \"more than one coinbase\");\n \n     // Check transactions\n-    BOOST_FOREACH(const CTransaction& tx, block.vtx)\n+    for (const auto& tx : block.vtx)\n         if (!CheckTransaction(tx, state))\n             return state.Invalid(false, state.GetRejectCode(), state.GetRejectReason(),\n                                  strprintf(\"Transaction check failed (tx hash %s) %s\", tx.GetHash().ToString(), state.GetDebugMessage()));\n \n     unsigned int nSigOps = 0;\n-    BOOST_FOREACH(const CTransaction& tx, block.vtx)\n+    for (const auto& tx : block.vtx)\n     {\n         nSigOps += GetLegacySigOpCount(tx);\n     }\n@@ -3499,8 +3501,9 @@ std::vector<unsigned char> GenerateCoinbaseCommitment(CBlock& block, const CBloc\n     return commitment;\n }\n \n-bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& state, const Consensus::Params& consensusParams, CBlockIndex * const pindexPrev, int64_t nAdjustedTime)\n+bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& state, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev, int64_t nAdjustedTime)\n {\n+    const int nHeight = pindexPrev == NULL ? 0 : pindexPrev->nHeight + 1;\n     // Check proof of work\n     if (block.nBits != GetNextWorkRequired(pindexPrev, &block, consensusParams))\n         return state.DoS(100, false, REJECT_INVALID, \"bad-diffbits\", false, \"incorrect proof of work\");\n@@ -3514,18 +3517,19 @@ bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& sta\n         return state.Invalid(false, REJECT_INVALID, \"time-too-new\", \"block timestamp too far in the future\");\n \n     // Reject outdated version blocks when 95% (75% on testnet) of the network has upgraded:\n-    for (int32_t version = 2; version < 5; ++version) // check for version 2, 3 and 4 upgrades\n-        if (block.nVersion < version && IsSuperMajority(version, pindexPrev, consensusParams.nMajorityRejectBlockOutdated, consensusParams))\n-            return state.Invalid(false, REJECT_OBSOLETE, strprintf(\"bad-version(0x%08x)\", version - 1),\n-                                 strprintf(\"rejected nVersion=0x%08x block\", version - 1));\n+    // check for version 2, 3 and 4 upgrades\n+    if((block.nVersion < 2 && nHeight >= consensusParams.BIP34Height) ||\n+       (block.nVersion < 3 && nHeight >= consensusParams.BIP66Height) ||\n+       (block.nVersion < 4 && nHeight >= consensusParams.BIP65Height))\n+            return state.Invalid(false, REJECT_OBSOLETE, strprintf(\"bad-version(0x%08x)\", block.nVersion),\n+                                 strprintf(\"rejected nVersion=0x%08x block\", block.nVersion));\n \n     return true;\n }\n \n-bool ContextualCheckBlock(const CBlock& block, CValidationState& state, CBlockIndex * const pindexPrev)\n+bool ContextualCheckBlock(const CBlock& block, CValidationState& state, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev)\n {\n     const int nHeight = pindexPrev == NULL ? 0 : pindexPrev->nHeight + 1;\n-    const Consensus::Params& consensusParams = Params().GetConsensus();\n \n     // Start enforcing BIP113 (Median Time Past) using versionbits logic.\n     int nLockTimeFlags = 0;\n@@ -3538,15 +3542,14 @@ bool ContextualCheckBlock(const CBlock& block, CValidationState& state, CBlockIn\n                               : block.GetBlockTime();\n \n     // Check that all transactions are finalized\n-    BOOST_FOREACH(const CTransaction& tx, block.vtx) {\n+    for (const auto& tx : block.vtx) {\n         if (!IsFinalTx(tx, nHeight, nLockTimeCutoff)) {\n             return state.DoS(10, false, REJECT_INVALID, \"bad-txns-nonfinal\", false, \"non-final transaction\");\n         }\n     }\n \n-    // Enforce block.nVersion=2 rule that the coinbase starts with serialized block height\n-    // if 750 of the last 1,000 blocks are version 2 or greater (51/100 if testnet):\n-    if (block.nVersion >= 2 && IsSuperMajority(2, pindexPrev, consensusParams.nMajorityEnforceBlockUpgrade, consensusParams))\n+    // Enforce rule that the coinbase starts with serialized block height\n+    if (nHeight >= consensusParams.BIP34Height)\n     {\n         CScript expect = CScript() << nHeight;\n         if (block.vtx[0].vin[0].scriptSig.size() < expect.size() ||\n@@ -3564,7 +3567,7 @@ bool ContextualCheckBlock(const CBlock& block, CValidationState& state, CBlockIn\n     //   {0xaa, 0x21, 0xa9, 0xed}, and the following 32 bytes are SHA256^2(witness root, witness nonce). In case there are\n     //   multiple, the last one is used.\n     bool fHaveWitness = false;\n-    if (IsWitnessEnabled(pindexPrev, consensusParams)) {\n+    if (VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_SEGWIT, versionbitscache) == THRESHOLD_ACTIVE) {\n         int commitpos = GetWitnessCommitmentIndex(block);\n         if (commitpos != -1) {\n             bool malleated = false;\n@@ -3573,11 +3576,11 @@ bool ContextualCheckBlock(const CBlock& block, CValidationState& state, CBlockIn\n             // already does not permit it, it is impossible to trigger in the\n             // witness tree.\n             if (block.vtx[0].wit.vtxinwit.size() != 1 || block.vtx[0].wit.vtxinwit[0].scriptWitness.stack.size() != 1 || block.vtx[0].wit.vtxinwit[0].scriptWitness.stack[0].size() != 32) {\n-                return state.DoS(100, error(\"%s : invalid witness nonce size\", __func__), REJECT_INVALID, \"bad-witness-nonce-size\", true);\n+                return state.DoS(100, false, REJECT_INVALID, \"bad-witness-nonce-size\", true, strprintf(\"%s : invalid witness nonce size\", __func__));\n             }\n             CHash256().Write(hashWitness.begin(), 32).Write(&block.vtx[0].wit.vtxinwit[0].scriptWitness.stack[0][0], 32).Finalize(hashWitness.begin());\n             if (memcmp(hashWitness.begin(), &block.vtx[0].vout[commitpos].scriptPubKey[6], 32)) {\n-                return state.DoS(100, error(\"%s : witness merkle commitment mismatch\", __func__), REJECT_INVALID, \"bad-witness-merkle-match\", true);\n+                return state.DoS(100, false, REJECT_INVALID, \"bad-witness-merkle-match\", true, strprintf(\"%s : witness merkle commitment mismatch\", __func__));\n             }\n             fHaveWitness = true;\n         }\n@@ -3587,19 +3590,19 @@ bool ContextualCheckBlock(const CBlock& block, CValidationState& state, CBlockIn\n     if (!fHaveWitness) {\n         for (size_t i = 0; i < block.vtx.size(); i++) {\n             if (!block.vtx[i].wit.IsNull()) {\n-                return state.DoS(100, error(\"%s : unexpected witness data found\", __func__), REJECT_INVALID, \"unexpected-witness\", true);\n+                return state.DoS(100, false, REJECT_INVALID, \"unexpected-witness\", true, strprintf(\"%s : unexpected witness data found\", __func__));\n             }\n         }\n     }\n \n     // After the coinbase witness nonce and commitment are verified,\n-    // we can check if the block cost passes (before we've checked the\n-    // coinbase witness, it would be possible for the cost to be too\n+    // we can check if the block weight passes (before we've checked the\n+    // coinbase witness, it would be possible for the weight to be too\n     // large by filling up the coinbase witness, which doesn't change\n     // the block hash, so we couldn't mark the block as permanently\n     // failed).\n-    if (GetBlockCost(block) > MAX_BLOCK_COST) {\n-        return state.DoS(100, error(\"ContextualCheckBlock(): cost limit failed\"), REJECT_INVALID, \"bad-blk-cost\");\n+    if (GetBlockWeight(block) > MAX_BLOCK_WEIGHT) {\n+        return state.DoS(100, false, REJECT_INVALID, \"bad-blk-weight\", false, strprintf(\"%s : weight limit failed\", __func__));\n     }\n \n     return true;\n@@ -3686,7 +3689,8 @@ static bool AcceptBlock(const CBlock& block, CValidationState& state, const CCha\n     }\n     if (fNewBlock) *fNewBlock = true;\n \n-    if ((!CheckBlock(block, state, chainparams.GetConsensus(), GetAdjustedTime())) || !ContextualCheckBlock(block, state, pindex->pprev)) {\n+    if (!CheckBlock(block, state, chainparams.GetConsensus(), GetAdjustedTime()) ||\n+        !ContextualCheckBlock(block, state, chainparams.GetConsensus(), pindex->pprev)) {\n         if (state.IsInvalid() && !state.CorruptionPossible()) {\n             pindex->nStatus |= BLOCK_FAILED_VALID;\n             setDirtyBlockIndex.insert(pindex);\n@@ -3719,19 +3723,6 @@ static bool AcceptBlock(const CBlock& block, CValidationState& state, const CCha\n     return true;\n }\n \n-static bool IsSuperMajority(int minVersion, const CBlockIndex* pstart, unsigned nRequired, const Consensus::Params& consensusParams)\n-{\n-    unsigned int nFound = 0;\n-    for (int i = 0; i < consensusParams.nMajorityWindow && nFound < nRequired && pstart != NULL; i++)\n-    {\n-        if (pstart->nVersion >= minVersion)\n-            ++nFound;\n-        pstart = pstart->pprev;\n-    }\n-    return (nFound >= nRequired);\n-}\n-\n-\n bool ProcessNewBlock(CValidationState& state, const CChainParams& chainparams, CNode* pfrom, const CBlock* pblock, bool fForceProcessing, const CDiskBlockPos* dbp)\n {\n     {\n@@ -3777,7 +3768,7 @@ bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams,\n         return error(\"%s: Consensus::ContextualCheckBlockHeader: %s\", __func__, FormatStateMessage(state));\n     if (!CheckBlock(block, state, chainparams.GetConsensus(), fCheckPOW, fCheckMerkleRoot))\n         return error(\"%s: Consensus::CheckBlock: %s\", __func__, FormatStateMessage(state));\n-    if (!ContextualCheckBlock(block, state, pindexPrev))\n+    if (!ContextualCheckBlock(block, state, chainparams.GetConsensus(), pindexPrev))\n         return error(\"%s: Consensus::ContextualCheckBlock: %s\", __func__, FormatStateMessage(state));\n     if (!ConnectBlock(block, state, &indexDummy, viewNew, chainparams, true))\n         return false;\n@@ -4097,7 +4088,7 @@ bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview,\n     int nGoodTransactions = 0;\n     CValidationState state;\n     int reportDone = 0;\n-    LogPrintf(\"[0%]...\");\n+    LogPrintf(\"[0%%]...\");\n     for (CBlockIndex* pindex = chainActive.Tip(); pindex && pindex->pprev; pindex = pindex->pprev)\n     {\n         boost::this_thread::interruption_point();\n@@ -4328,8 +4319,6 @@ bool InitBlockIndex(const CChainParams& chainparams)\n             CBlockIndex *pindex = AddToBlockIndex(block);\n             if (!ReceivedBlockTransactions(block, state, pindex, blockPos))\n                 return error(\"LoadBlockIndex(): genesis block not accepted\");\n-            if (!ActivateBestChain(state, chainparams, &block))\n-                return error(\"LoadBlockIndex(): genesis block cannot be activated\");\n             // Force a chainstate write so that when we VerifyDB in a moment, it doesn't check stale data\n             return FlushStateToDisk(state, FLUSH_STATE_ALWAYS);\n         } catch (const std::runtime_error& e) {\n@@ -4812,7 +4801,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                     {\n                         // If a peer is asking for old blocks, we're almost guaranteed\n                         // they wont have a useful mempool to match against a compact block,\n-                        // and we dont feel like constructing the object for them, so\n+                        // and we don't feel like constructing the object for them, so\n                         // instead we respond with the full, non-compact block.\n                         if (mi->second->nHeight >= chainActive.Height() - 10) {\n                             CBlockHeaderAndShortTxIDs cmpctblock(block);\n@@ -5340,7 +5329,6 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n         BlockMap::iterator it = mapBlockIndex.find(req.blockhash);\n         if (it == mapBlockIndex.end() || !(it->second->nStatus & BLOCK_HAVE_DATA)) {\n-            Misbehaving(pfrom->GetId(), 100);\n             LogPrintf(\"Peer %d sent us a getblocktxn for a block we don't have\", pfrom->id);\n             return true;\n         }\n@@ -5624,8 +5612,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 std::vector<CInv> vInv(1);\n                 vInv[0] = CInv(MSG_BLOCK, cmpctblock.header.GetHash());\n                 pfrom->PushMessage(NetMsgType::GETDATA, vInv);\n-                return true;\n             }\n+            return true;\n         }\n \n         // If we're not close to tip yet, give up and let parallel block fetch work its magic\n@@ -5773,6 +5761,35 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n+        CNodeState *nodestate = State(pfrom->GetId());\n+\n+        // If this looks like it could be a block announcement (nCount <\n+        // MAX_BLOCKS_TO_ANNOUNCE), use special logic for handling headers that\n+        // don't connect:\n+        // - Send a getheaders message in response to try to connect the chain.\n+        // - The peer can send up to MAX_UNCONNECTING_HEADERS in a row that\n+        //   don't connect before giving DoS points\n+        // - Once a headers message is received that is valid and does connect,\n+        //   nUnconnectingHeaders gets reset back to 0.\n+        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end() && nCount < MAX_BLOCKS_TO_ANNOUNCE) {\n+            nodestate->nUnconnectingHeaders++;\n+            pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+            LogPrint(\"net\", \"received header %s: missing prev block %s, sending getheaders (%d) to end (peer=%d, nUnconnectingHeaders=%d)\\n\",\n+                    headers[0].GetHash().ToString(),\n+                    headers[0].hashPrevBlock.ToString(),\n+                    pindexBestHeader->nHeight,\n+                    pfrom->id, nodestate->nUnconnectingHeaders);\n+            // Set hashLastUnknownBlock for this peer, so that if we\n+            // eventually get the headers - even from a different peer -\n+            // we can use this peer to download.\n+            UpdateBlockAvailability(pfrom->GetId(), headers.back().GetHash());\n+\n+            if (nodestate->nUnconnectingHeaders % MAX_UNCONNECTING_HEADERS == 0) {\n+                Misbehaving(pfrom->GetId(), 20);\n+            }\n+            return true;\n+        }\n+\n         CBlockIndex *pindexLast = NULL;\n         BOOST_FOREACH(const CBlockHeader& header, headers) {\n             CValidationState state;\n@@ -5790,6 +5807,11 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             }\n         }\n \n+        if (nodestate->nUnconnectingHeaders > 0) {\n+            LogPrint(\"net\", \"peer=%d: resetting nUnconnectingHeaders (%d -> 0)\\n\", pfrom->id, nodestate->nUnconnectingHeaders);\n+        }\n+        nodestate->nUnconnectingHeaders = 0;\n+\n         assert(pindexLast);\n         UpdateBlockAvailability(pfrom->GetId(), pindexLast->GetBlockHash());\n \n@@ -5802,7 +5824,6 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         }\n \n         bool fCanDirectFetch = CanDirectFetch(chainparams.GetConsensus());\n-        CNodeState *nodestate = State(pfrom->GetId());\n         // If this set of headers is valid and ends in a block with at least as\n         // much work as our tip, download as much as possible.\n         if (fCanDirectFetch && pindexLast->IsValid(BLOCK_VALID_TREE) && chainActive.Tip()->nChainWork <= pindexLast->nChainWork) {\n@@ -6110,6 +6131,11 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         }\n     }\n \n+    else if (strCommand == NetMsgType::NOTFOUND) {\n+        // We do not care about the NOTFOUND message, but logging an Unknown Command\n+        // message would be undesirable as we transmit it ourselves.\n+    }\n+\n     else {\n         // Ignore unknown commands for extensibility\n         LogPrint(\"net\", \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(strCommand), pfrom->id);"
      },
      {
        "sha": "e9106fccf79272815778e04e65548a828b695eb8",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 20,
        "deletions": 6,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -124,7 +124,6 @@ static const int64_t DEFAULT_MAX_TIP_AGE = 24 * 60 * 60;\n \n /** Default for -permitbaremultisig */\n static const bool DEFAULT_PERMIT_BAREMULTISIG = true;\n-static const unsigned int DEFAULT_BYTES_PER_SIGOP = 20;\n static const bool DEFAULT_CHECKPOINTS_ENABLED = true;\n static const bool DEFAULT_TXINDEX = false;\n static const unsigned int DEFAULT_BANSCORE_THRESHOLD = 100;\n@@ -138,6 +137,9 @@ static const bool DEFAULT_FEEFILTER = true;\n /** Maximum number of headers to announce when relaying blocks with headers message.*/\n static const unsigned int MAX_BLOCKS_TO_ANNOUNCE = 8;\n \n+/** Maximum number of unconnecting headers announcements before DoS score */\n+static const int MAX_UNCONNECTING_HEADERS = 10;\n+\n static const bool DEFAULT_PEERBLOOMFILTERS = true;\n \n struct BlockHasher\n@@ -152,7 +154,7 @@ typedef boost::unordered_map<uint256, CBlockIndex*, BlockHasher> BlockMap;\n extern BlockMap mapBlockIndex;\n extern uint64_t nLastBlockTx;\n extern uint64_t nLastBlockSize;\n-extern uint64_t nLastBlockCost;\n+extern uint64_t nLastBlockWeight;\n extern const std::string strMessageMagic;\n extern CWaitableCriticalSection csBestBlock;\n extern CConditionVariable cvBlockChange;\n@@ -162,7 +164,6 @@ extern int nScriptCheckThreads;\n extern bool fTxIndex;\n extern bool fIsBareMultisigStd;\n extern bool fRequireStandard;\n-extern unsigned int nBytesPerSigOp;\n extern bool fCheckBlockIndex;\n extern bool fCheckpointsEnabled;\n extern size_t nCoinCacheUsage;\n@@ -213,7 +214,7 @@ void UnregisterNodeSignals(CNodeSignals& nodeSignals);\n  * block is made active. Note that it does not, however, guarantee that the\n  * specific block passed to it has been checked for validity!\n  * \n- * @param[out]  state   This may be set to an Error state if any error occurred processing it, including during validation/connection/etc of otherwise unrelated blocks during reorganisation; or it may be set to an Invalid state if pblock is itself invalid (but this is not guaranteed even when the block is checked). If you want to *possibly* get feedback on whether pblock is valid, you must also install a CValidationInterface (see validationinterface.h) - this will have its BlockChecked method called whenever *any* block completes validation.\n+ * @param[out]  state   This may be set to an Error state if any error occurred processing it, including during validation/connection/etc of otherwise unrelated blocks during reorganization; or it may be set to an Invalid state if pblock is itself invalid (but this is not guaranteed even when the block is checked). If you want to *possibly* get feedback on whether pblock is valid, you must also install a CValidationInterface (see validationinterface.h) - this will have its BlockChecked method called whenever *any* block completes validation.\n  * @param[in]   pfrom   The node which we are receiving the block from; it is added to mapBlockSource and may be penalised if the block is invalid.\n  * @param[in]   pblock  The block we want to process.\n  * @param[in]   fForceProcessing Process this block even if unrequested; used for non-network block sources and whitelisted peers.\n@@ -351,9 +352,22 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n /** Apply the effects of this transaction on the UTXO set represented by view */\n void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, int nHeight);\n \n+/** Transaction validation functions */\n+\n /** Context-independent validity checks */\n bool CheckTransaction(const CTransaction& tx, CValidationState& state);\n \n+namespace Consensus {\n+\n+/**\n+ * Check whether all inputs of this transaction are valid (no double spends and amounts)\n+ * This does not modify the UTXO set. This does not check scripts and sigs.\n+ * Preconditions: tx.IsCoinBase() is false.\n+ */\n+bool CheckTxInputs(const CTransaction& tx, CValidationState& state, const CCoinsViewCache& inputs, int nSpendHeight);\n+\n+} // namespace Consensus\n+\n /**\n  * Check if transaction is final and can be included in a block with the\n  * specified height and time. Consensus critical.\n@@ -444,8 +458,8 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n /** Context-dependent validity checks.\n  *  By \"context\", we mean only the previous block headers, but not the UTXO\n  *  set; UTXO-related validity checks are done in ConnectBlock(). */\n-bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& state, const Consensus::Params& consensusParams, CBlockIndex* pindexPrev, int64_t nAdjustedTime);\n-bool ContextualCheckBlock(const CBlock& block, CValidationState& state, CBlockIndex *pindexPrev);\n+bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& state, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev, int64_t nAdjustedTime);\n+bool ContextualCheckBlock(const CBlock& block, CValidationState& state, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev);\n \n /** Apply the effects of this block (with given index) on the UTXO set represented by coins.\n  *  Validity checks that depend on the UTXO set are also done; ConnectBlock()"
      },
      {
        "sha": "9575858840df0df7aeab64616efe37173efdad56",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 100,
        "changes": 145,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -45,7 +45,7 @@ using namespace std;\n \n uint64_t nLastBlockTx = 0;\n uint64_t nLastBlockSize = 0;\n-uint64_t nLastBlockCost = 0;\n+uint64_t nLastBlockWeight = 0;\n \n class ScoreCompare\n {\n@@ -77,35 +77,31 @@ BlockAssembler::BlockAssembler(const CChainParams& _chainparams)\n     : chainparams(_chainparams)\n {\n     // Block resource limits\n-    // If neither -blockmaxsize or -blockmaxcost is given, limit to DEFAULT_BLOCK_MAX_*\n+    // If neither -blockmaxsize or -blockmaxweight is given, limit to DEFAULT_BLOCK_MAX_*\n     // If only one is given, only restrict the specified resource.\n     // If both are given, restrict both.\n-    nBlockMaxCost = DEFAULT_BLOCK_MAX_COST;\n+    nBlockMaxWeight = DEFAULT_BLOCK_MAX_WEIGHT;\n     nBlockMaxSize = DEFAULT_BLOCK_MAX_SIZE;\n-    bool fCostSet = false;\n-    if (mapArgs.count(\"-blockmaxcost\")) {\n-        nBlockMaxCost = GetArg(\"-blockmaxcost\", DEFAULT_BLOCK_MAX_COST);\n+    bool fWeightSet = false;\n+    if (mapArgs.count(\"-blockmaxweight\")) {\n+        nBlockMaxWeight = GetArg(\"-blockmaxweight\", DEFAULT_BLOCK_MAX_WEIGHT);\n         nBlockMaxSize = MAX_BLOCK_SERIALIZED_SIZE;\n-        fCostSet = true;\n+        fWeightSet = true;\n     }\n     if (mapArgs.count(\"-blockmaxsize\")) {\n         nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n-        if (!fCostSet) {\n-            nBlockMaxCost = nBlockMaxSize * WITNESS_SCALE_FACTOR;\n+        if (!fWeightSet) {\n+            nBlockMaxWeight = nBlockMaxSize * WITNESS_SCALE_FACTOR;\n         }\n     }\n-    // Limit cost to between 4K and MAX_BLOCK_COST-4K for sanity:\n-    nBlockMaxCost = std::max((unsigned int)4000, std::min((unsigned int)(MAX_BLOCK_COST-4000), nBlockMaxCost));\n+\n+    // Limit weight to between 4K and MAX_BLOCK_WEIGHT-4K for sanity:\n+    nBlockMaxWeight = std::max((unsigned int)4000, std::min((unsigned int)(MAX_BLOCK_WEIGHT-4000), nBlockMaxWeight));\n     // Limit size to between 1K and MAX_BLOCK_SERIALIZED_SIZE-1K for sanity:\n     nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SERIALIZED_SIZE-1000), nBlockMaxSize));\n \n-    // Minimum block size you want to create; block will be filled with free transactions\n-    // until there are no more or the block reaches this size:\n-    nBlockMinSize = GetArg(\"-blockminsize\", DEFAULT_BLOCK_MIN_SIZE);\n-    nBlockMinSize = std::min(nBlockMaxSize, nBlockMinSize);\n-\n-    // Whether we need to account for byte usage (in addition to cost usage)\n-    fNeedSizeAccounting = (nBlockMaxSize < MAX_BLOCK_SERIALIZED_SIZE-1000) || (nBlockMinSize > 0);\n+    // Whether we need to account for byte usage (in addition to weight usage)\n+    fNeedSizeAccounting = (nBlockMaxSize < MAX_BLOCK_SERIALIZED_SIZE-1000);\n }\n \n void BlockAssembler::resetBlock()\n@@ -114,7 +110,7 @@ void BlockAssembler::resetBlock()\n \n     // Reserve space for coinbase tx\n     nBlockSize = 1000;\n-    nBlockCost = 4000;\n+    nBlockWeight = 4000;\n     nBlockSigOpsCost = 400;\n     fIncludeWitness = false;\n \n@@ -167,17 +163,11 @@ CBlockTemplate* BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn)\n     fIncludeWitness = IsWitnessEnabled(pindexPrev, chainparams.GetConsensus());\n \n     addPriorityTxs();\n-    if (fNeedSizeAccounting) {\n-        // addPackageTxs (the CPFP-based algorithm) cannot deal with size based\n-        // accounting, so fall back to the old algorithm.\n-        addScoreTxs();\n-    } else {\n-        addPackageTxs();\n-    }\n+    addPackageTxs();\n \n     nLastBlockTx = nBlockTx;\n     nLastBlockSize = nBlockSize;\n-    nLastBlockCost = nBlockCost;\n+    nLastBlockWeight = nBlockWeight;\n     LogPrintf(\"CreateNewBlock(): total size %u txs: %u fees: %ld sigops %d\\n\", nBlockSize, nBlockTx, nFees, nBlockSigOpsCost);\n \n     // Create coinbase transaction.\n@@ -197,7 +187,7 @@ CBlockTemplate* BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn)\n     UpdateTime(pblock, chainparams.GetConsensus(), pindexPrev);\n     pblock->nBits          = GetNextWorkRequired(pindexPrev, pblock, chainparams.GetConsensus());\n     pblock->nNonce         = 0;\n-    pblocktemplate->vTxSigOpsCost[0] = GetLegacySigOpCount(pblock->vtx[0]);\n+    pblocktemplate->vTxSigOpsCost[0] = WITNESS_SCALE_FACTOR * GetLegacySigOpCount(pblock->vtx[0]);\n \n     CValidationState state;\n     if (!TestBlockValidity(state, chainparams, *pblock, pindexPrev, false, false)) {\n@@ -233,38 +223,51 @@ void BlockAssembler::onlyUnconfirmed(CTxMemPool::setEntries& testSet)\n \n bool BlockAssembler::TestPackage(uint64_t packageSize, int64_t packageSigOpsCost)\n {\n-    // TODO: switch to cost-based accounting for packages instead of vsize-based accounting.\n-    if (nBlockCost + WITNESS_SCALE_FACTOR * packageSize >= nBlockMaxCost)\n+    // TODO: switch to weight-based accounting for packages instead of vsize-based accounting.\n+    if (nBlockWeight + WITNESS_SCALE_FACTOR * packageSize >= nBlockMaxWeight)\n         return false;\n     if (nBlockSigOpsCost + packageSigOpsCost >= MAX_BLOCK_SIGOPS_COST)\n         return false;\n     return true;\n }\n \n-// Block size and sigops have already been tested.  Check that all transactions\n-// are final.\n-bool BlockAssembler::TestPackageFinality(const CTxMemPool::setEntries& package)\n+// Perform transaction-level checks before adding to block:\n+// - transaction finality (locktime)\n+// - premature witness (in case segwit transactions are added to mempool before\n+//   segwit activation)\n+// - serialized size (in case -blockmaxsize is in use)\n+bool BlockAssembler::TestPackageTransactions(const CTxMemPool::setEntries& package)\n {\n+    uint64_t nPotentialBlockSize = nBlockSize; // only used with fNeedSizeAccounting\n     BOOST_FOREACH (const CTxMemPool::txiter it, package) {\n         if (!IsFinalTx(it->GetTx(), nHeight, nLockTimeCutoff))\n             return false;\n+        if (!fIncludeWitness && !it->GetTx().wit.IsNull())\n+            return false;\n+        if (fNeedSizeAccounting) {\n+            uint64_t nTxSize = ::GetSerializeSize(it->GetTx(), SER_NETWORK, PROTOCOL_VERSION);\n+            if (nPotentialBlockSize + nTxSize >= nBlockMaxSize) {\n+                return false;\n+            }\n+            nPotentialBlockSize += nTxSize;\n+        }\n     }\n     return true;\n }\n \n bool BlockAssembler::TestForBlock(CTxMemPool::txiter iter)\n {\n-    if (nBlockCost + iter->GetTxCost() >= nBlockMaxCost) {\n+    if (nBlockWeight + iter->GetTxWeight() >= nBlockMaxWeight) {\n         // If the block is so close to full that no more txs will fit\n         // or if we've tried more than 50 times to fill remaining space\n         // then flag that the block is finished\n-        if (nBlockCost >  nBlockMaxCost - 400 || lastFewTxs > 50) {\n+        if (nBlockWeight >  nBlockMaxWeight - 400 || lastFewTxs > 50) {\n              blockFinished = true;\n              return false;\n         }\n-        // Once we're within 4000 cost of a full block, only look at 50 more txs\n+        // Once we're within 4000 weight of a full block, only look at 50 more txs\n         // to try to fill the remaining space.\n-        if (nBlockCost > nBlockMaxCost - 4000) {\n+        if (nBlockWeight > nBlockMaxWeight - 4000) {\n             lastFewTxs++;\n         }\n         return false;\n@@ -312,7 +315,7 @@ void BlockAssembler::AddToBlock(CTxMemPool::txiter iter)\n     if (fNeedSizeAccounting) {\n         nBlockSize += ::GetSerializeSize(iter->GetTx(), SER_NETWORK, PROTOCOL_VERSION);\n     }\n-    nBlockCost += iter->GetTxCost();\n+    nBlockWeight += iter->GetTxWeight();\n     ++nBlockTx;\n     nBlockSigOpsCost += iter->GetSigOpCost();\n     nFees += iter->GetFee();\n@@ -330,66 +333,6 @@ void BlockAssembler::AddToBlock(CTxMemPool::txiter iter)\n     }\n }\n \n-void BlockAssembler::addScoreTxs()\n-{\n-    std::priority_queue<CTxMemPool::txiter, std::vector<CTxMemPool::txiter>, ScoreCompare> clearedTxs;\n-    CTxMemPool::setEntries waitSet;\n-    CTxMemPool::indexed_transaction_set::index<mining_score>::type::iterator mi = mempool.mapTx.get<mining_score>().begin();\n-    CTxMemPool::txiter iter;\n-    while (!blockFinished && (mi != mempool.mapTx.get<mining_score>().end() || !clearedTxs.empty()))\n-    {\n-        // If no txs that were previously postponed are available to try\n-        // again, then try the next highest score tx\n-        if (clearedTxs.empty()) {\n-            iter = mempool.mapTx.project<0>(mi);\n-            mi++;\n-        }\n-        // If a previously postponed tx is available to try again, then it\n-        // has higher score than all untried so far txs\n-        else {\n-            iter = clearedTxs.top();\n-            clearedTxs.pop();\n-        }\n-\n-        // If tx already in block, skip  (added by addPriorityTxs)\n-        if (inBlock.count(iter)) {\n-            continue;\n-        }\n-\n-        // cannot accept witness transactions into a non-witness block\n-        if (!fIncludeWitness && !iter->GetTx().wit.IsNull())\n-            continue;\n-\n-        // If tx is dependent on other mempool txs which haven't yet been included\n-        // then put it in the waitSet\n-        if (isStillDependent(iter)) {\n-            waitSet.insert(iter);\n-            continue;\n-        }\n-\n-        // If the fee rate is below the min fee rate for mining, then we're done\n-        // adding txs based on score (fee rate)\n-        if (iter->GetModifiedFee() < ::minRelayTxFee.GetFee(iter->GetTxSize()) && nBlockSize >= nBlockMinSize) {\n-            return;\n-        }\n-\n-        // If this tx fits in the block add it, otherwise keep looping\n-        if (TestForBlock(iter)) {\n-            AddToBlock(iter);\n-\n-            // This tx was successfully added, so\n-            // add transactions that depend on this one to the priority queue to try again\n-            BOOST_FOREACH(CTxMemPool::txiter child, mempool.GetMemPoolChildren(iter))\n-            {\n-                if (waitSet.count(child)) {\n-                    clearedTxs.push(child);\n-                    waitSet.erase(child);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n void BlockAssembler::UpdatePackagesForAdded(const CTxMemPool::setEntries& alreadyAdded,\n         indexed_modified_transaction_set &mapModifiedTx)\n {\n@@ -539,7 +482,7 @@ void BlockAssembler::addPackageTxs()\n         ancestors.insert(iter);\n \n         // Test if all tx's are Final\n-        if (!TestPackageFinality(ancestors)) {\n+        if (!TestPackageTransactions(ancestors)) {\n             if (fUsingModified) {\n                 mapModifiedTx.get<ancestor_score>().erase(modit);\n                 failedTx.insert(iter);\n@@ -573,6 +516,7 @@ void BlockAssembler::addPriorityTxs()\n         return;\n     }\n \n+    bool fSizeAccounting = fNeedSizeAccounting;\n     fNeedSizeAccounting = true;\n \n     // This vector will be sorted into a priority queue:\n@@ -624,7 +568,7 @@ void BlockAssembler::addPriorityTxs()\n             // If now that this txs is added we've surpassed our desired priority size\n             // or have dropped below the AllowFreeThreshold, then we're done adding priority txs\n             if (nBlockSize >= nBlockPrioritySize || !AllowFree(actualPriority)) {\n-                return;\n+                break;\n             }\n \n             // This tx was successfully added, so\n@@ -640,6 +584,7 @@ void BlockAssembler::addPriorityTxs()\n             }\n         }\n     }\n+    fNeedSizeAccounting = fSizeAccounting;\n }\n \n void IncrementExtraNonce(CBlock* pblock, const CBlockIndex* pindexPrev, unsigned int& nExtraNonce)"
      },
      {
        "sha": "11753f5e43787d361d589ade9d6b0bccef87df97",
        "filename": "src/miner.h",
        "status": "modified",
        "additions": 9,
        "deletions": 8,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -141,11 +141,11 @@ class BlockAssembler\n \n     // Configuration parameters for the block size\n     bool fIncludeWitness;\n-    unsigned int nBlockMaxCost, nBlockMaxSize, nBlockMinSize;\n+    unsigned int nBlockMaxWeight, nBlockMaxSize;\n     bool fNeedSizeAccounting;\n \n     // Information on the current status of the block\n-    uint64_t nBlockCost;\n+    uint64_t nBlockWeight;\n     uint64_t nBlockSize;\n     uint64_t nBlockTx;\n     uint64_t nBlockSigOpsCost;\n@@ -157,7 +157,7 @@ class BlockAssembler\n     int64_t nLockTimeCutoff;\n     const CChainParams& chainparams;\n \n-    // Variables used for addScoreTxs and addPriorityTxs\n+    // Variables used for addPriorityTxs\n     int lastFewTxs;\n     bool blockFinished;\n \n@@ -174,14 +174,12 @@ class BlockAssembler\n     void AddToBlock(CTxMemPool::txiter iter);\n \n     // Methods for how to add transactions to a block.\n-    /** Add transactions based on modified feerate */\n-    void addScoreTxs();\n     /** Add transactions based on tx \"priority\" */\n     void addPriorityTxs();\n     /** Add transactions based on feerate including unconfirmed ancestors */\n     void addPackageTxs();\n \n-    // helper function for addScoreTxs and addPriorityTxs\n+    // helper function for addPriorityTxs\n     /** Test if tx will still \"fit\" in the block */\n     bool TestForBlock(CTxMemPool::txiter iter);\n     /** Test if tx still has unconfirmed parents not yet in block */\n@@ -192,8 +190,11 @@ class BlockAssembler\n     void onlyUnconfirmed(CTxMemPool::setEntries& testSet);\n     /** Test if a new package would \"fit\" in the block */\n     bool TestPackage(uint64_t packageSize, int64_t packageSigOpsCost);\n-    /** Test if a set of transactions are all final */\n-    bool TestPackageFinality(const CTxMemPool::setEntries& package);\n+    /** Perform checks on each transaction in a package:\n+      * locktime, premature-witness, serialized size (if necessary)\n+      * These checks should always succeed, and they're here\n+      * only as an extra check in case of suboptimal node configuration */\n+    bool TestPackageTransactions(const CTxMemPool::setEntries& package);\n     /** Return true if given transaction from mapTx has already been evaluated,\n       * or if the transaction's cached data in mapTx is incorrect. */\n     bool SkipMapTxEntry(CTxMemPool::txiter it, indexed_modified_transaction_set &mapModifiedTx, CTxMemPool::setEntries &failedTx);"
      },
      {
        "sha": "39c8d12e2081f41471fb97bc573eacd4ec73bcfc",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 15,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -17,6 +17,7 @@\n #include \"crypto/sha256.h\"\n #include \"hash.h\"\n #include \"primitives/transaction.h\"\n+#include \"netbase.h\"\n #include \"scheduler.h\"\n #include \"ui_interface.h\"\n #include \"utilstrencodings.h\"\n@@ -175,7 +176,7 @@ static std::vector<CAddress> convertSeed6(const std::vector<SeedSpec6> &vSeedsIn\n // one by discovery.\n CAddress GetLocalAddress(const CNetAddr *paddrPeer)\n {\n-    CAddress ret(CService(\"0.0.0.0\",GetListenPort()), NODE_NONE);\n+    CAddress ret(CService(CNetAddr(),GetListenPort()), NODE_NONE);\n     CService addr;\n     if (GetLocal(addr, paddrPeer))\n     {\n@@ -494,7 +495,7 @@ void CNode::PushVersion()\n     int nBestHeight = GetNodeSignals().GetHeight().get_value_or(0);\n \n     int64_t nTime = (fInbound ? GetAdjustedTime() : GetTime());\n-    CAddress addrYou = (addr.IsRoutable() && !IsProxy(addr) ? addr : CAddress(CService(\"0.0.0.0\", 0), addr.nServices));\n+    CAddress addrYou = (addr.IsRoutable() && !IsProxy(addr) ? addr : CAddress(CService(), addr.nServices));\n     CAddress addrMe = GetLocalAddress(&addr);\n     GetRandBytes((unsigned char*)&nLocalHostNonce, sizeof(nLocalHostNonce));\n     if (fLogIPs)\n@@ -982,11 +983,11 @@ static bool AttemptToEvictConnection() {\n     uint64_t naMostConnections;\n     unsigned int nMostConnections = 0;\n     int64_t nMostConnectionsTime = 0;\n-    std::map<uint64_t, std::vector<NodeEvictionCandidate> > mapAddrCounts;\n+    std::map<uint64_t, std::vector<NodeEvictionCandidate> > mapNetGroupNodes;\n     BOOST_FOREACH(const NodeEvictionCandidate &node, vEvictionCandidates) {\n-        mapAddrCounts[node.nKeyedNetGroup].push_back(node);\n-        int64_t grouptime = mapAddrCounts[node.nKeyedNetGroup][0].nTimeConnected;\n-        size_t groupsize = mapAddrCounts[node.nKeyedNetGroup].size();\n+        mapNetGroupNodes[node.nKeyedNetGroup].push_back(node);\n+        int64_t grouptime = mapNetGroupNodes[node.nKeyedNetGroup][0].nTimeConnected;\n+        size_t groupsize = mapNetGroupNodes[node.nKeyedNetGroup].size();\n \n         if (groupsize > nMostConnections || (groupsize == nMostConnections && grouptime > nMostConnectionsTime)) {\n             nMostConnections = groupsize;\n@@ -996,7 +997,7 @@ static bool AttemptToEvictConnection() {\n     }\n \n     // Reduce to the network group with the most connections\n-    vEvictionCandidates = std::move(mapAddrCounts[naMostConnections]);\n+    vEvictionCandidates = std::move(mapNetGroupNodes[naMostConnections]);\n \n     // Disconnect from the network group with the most connections\n     NodeId evicted = vEvictionCandidates.front().id;\n@@ -1396,8 +1397,11 @@ void ThreadMapPort()\n             {\n                 if(externalIPAddress[0])\n                 {\n-                    LogPrintf(\"UPnP: ExternalIPAddress = %s\\n\", externalIPAddress);\n-                    AddLocal(CNetAddr(externalIPAddress), LOCAL_UPNP);\n+                    CNetAddr resolved;\n+                    if(LookupHost(externalIPAddress, resolved, false)) {\n+                        LogPrintf(\"UPnP: ExternalIPAddress = %s\\n\", resolved.ToString().c_str());\n+                        AddLocal(resolved, LOCAL_UPNP);\n+                    }\n                 }\n                 else\n                     LogPrintf(\"UPnP: GetExternalIPAddress failed.\\n\");\n@@ -1623,7 +1627,9 @@ void ThreadOpenConnections()\n             static bool done = false;\n             if (!done) {\n                 LogPrintf(\"Adding fixed seed nodes as DNS doesn't seem to be available.\\n\");\n-                addrman.Add(convertSeed6(Params().FixedSeeds()), CNetAddr(\"127.0.0.1\"));\n+                CNetAddr local;\n+                LookupHost(\"127.0.0.1\", local, false);\n+                addrman.Add(convertSeed6(Params().FixedSeeds()), local);\n                 done = true;\n             }\n         }\n@@ -1676,7 +1682,7 @@ void ThreadOpenConnections()\n             if (nANow - addr.nLastTry < 600 && nTries < 30)\n                 continue;\n \n-            // only consider nodes missing relevant services after 40 failed attemps\n+            // only consider nodes missing relevant services after 40 failed attempts\n             if ((addr.nServices & nRelevantServices) != nRelevantServices && nTries < 40)\n                 continue;\n \n@@ -1722,7 +1728,7 @@ std::vector<AddedNodeInfo> GetAddedNodeInfo()\n     }\n \n     BOOST_FOREACH(const std::string& strAddNode, lAddresses) {\n-        CService service(strAddNode, Params().GetDefaultPort());\n+        CService service(LookupNumeric(strAddNode.c_str(), Params().GetDefaultPort()));\n         if (service.IsValid()) {\n             // strAddNode is an IP:port\n             auto it = mapConnected.find(service);\n@@ -1760,7 +1766,7 @@ void ThreadOpenAddedConnections()\n                 CSemaphoreGrant grant(*semOutbound);\n                 // If strAddedNode is an IP/port, decode it immediately, so\n                 // OpenNetworkConnection can detect existing connections to that IP/port.\n-                CService service(info.strAddedNode, Params().GetDefaultPort());\n+                CService service(LookupNumeric(info.strAddedNode.c_str(), Params().GetDefaultPort()));\n                 OpenNetworkConnection(CAddress(service, NODE_NONE), false, &grant, info.strAddedNode.c_str(), false);\n                 MilliSleep(500);\n             }\n@@ -2050,6 +2056,8 @@ void StartNode(boost::thread_group& threadGroup, CScheduler& scheduler)\n         DumpBanlist();\n     }\n \n+    uiInterface.InitMessage(_(\"Starting network threads...\"));\n+\n     fAddressesInitialized = true;\n \n     if (semOutbound == NULL) {\n@@ -2058,8 +2066,11 @@ void StartNode(boost::thread_group& threadGroup, CScheduler& scheduler)\n         semOutbound = new CSemaphore(nMaxOutbound);\n     }\n \n-    if (pnodeLocalHost == NULL)\n-        pnodeLocalHost = new CNode(INVALID_SOCKET, CAddress(CService(\"127.0.0.1\", 0), nLocalServices));\n+    if (pnodeLocalHost == NULL) {\n+        CNetAddr local;\n+        LookupHost(\"127.0.0.1\", local, false);\n+        pnodeLocalHost = new CNode(INVALID_SOCKET, CAddress(CService(local, 0), nLocalServices));\n+    }\n \n     Discover(threadGroup);\n "
      },
      {
        "sha": "ea03defc408cf683e3cb8572cf22764b3bde38b4",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -10,7 +10,7 @@\n #include \"bloom.h\"\n #include \"compat.h\"\n #include \"limitedmap.h\"\n-#include \"netbase.h\"\n+#include \"netaddress.h\"\n #include \"protocol.h\"\n #include \"random.h\"\n #include \"streams.h\""
      },
      {
        "sha": "7000ce3f0accec588451f9fedb35b999337b4526",
        "filename": "src/netaddress.cpp",
        "status": "added",
        "additions": 716,
        "deletions": 0,
        "changes": 716,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -0,0 +1,716 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifdef HAVE_CONFIG_H\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#include \"netaddress.h\"\n+#include \"hash.h\"\n+#include \"utilstrencodings.h\"\n+#include \"tinyformat.h\"\n+\n+static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n+static const unsigned char pchOnionCat[] = {0xFD,0x87,0xD8,0x7E,0xEB,0x43};\n+\n+void CNetAddr::Init()\n+{\n+    memset(ip, 0, sizeof(ip));\n+    scopeId = 0;\n+}\n+\n+void CNetAddr::SetIP(const CNetAddr& ipIn)\n+{\n+    memcpy(ip, ipIn.ip, sizeof(ip));\n+}\n+\n+void CNetAddr::SetRaw(Network network, const uint8_t *ip_in)\n+{\n+    switch(network)\n+    {\n+        case NET_IPV4:\n+            memcpy(ip, pchIPv4, 12);\n+            memcpy(ip+12, ip_in, 4);\n+            break;\n+        case NET_IPV6:\n+            memcpy(ip, ip_in, 16);\n+            break;\n+        default:\n+            assert(!\"invalid network\");\n+    }\n+}\n+\n+bool CNetAddr::SetSpecial(const std::string &strName)\n+{\n+    if (strName.size()>6 && strName.substr(strName.size() - 6, 6) == \".onion\") {\n+        std::vector<unsigned char> vchAddr = DecodeBase32(strName.substr(0, strName.size() - 6).c_str());\n+        if (vchAddr.size() != 16-sizeof(pchOnionCat))\n+            return false;\n+        memcpy(ip, pchOnionCat, sizeof(pchOnionCat));\n+        for (unsigned int i=0; i<16-sizeof(pchOnionCat); i++)\n+            ip[i + sizeof(pchOnionCat)] = vchAddr[i];\n+        return true;\n+    }\n+    return false;\n+}\n+\n+CNetAddr::CNetAddr()\n+{\n+    Init();\n+}\n+\n+CNetAddr::CNetAddr(const struct in_addr& ipv4Addr)\n+{\n+    SetRaw(NET_IPV4, (const uint8_t*)&ipv4Addr);\n+}\n+\n+CNetAddr::CNetAddr(const struct in6_addr& ipv6Addr, const uint32_t scope)\n+{\n+    SetRaw(NET_IPV6, (const uint8_t*)&ipv6Addr);\n+    scopeId = scope;\n+}\n+\n+unsigned int CNetAddr::GetByte(int n) const\n+{\n+    return ip[15-n];\n+}\n+\n+bool CNetAddr::IsIPv4() const\n+{\n+    return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n+}\n+\n+bool CNetAddr::IsIPv6() const\n+{\n+    return (!IsIPv4() && !IsTor());\n+}\n+\n+bool CNetAddr::IsRFC1918() const\n+{\n+    return IsIPv4() && (\n+        GetByte(3) == 10 ||\n+        (GetByte(3) == 192 && GetByte(2) == 168) ||\n+        (GetByte(3) == 172 && (GetByte(2) >= 16 && GetByte(2) <= 31)));\n+}\n+\n+bool CNetAddr::IsRFC2544() const\n+{\n+    return IsIPv4() && GetByte(3) == 198 && (GetByte(2) == 18 || GetByte(2) == 19);\n+}\n+\n+bool CNetAddr::IsRFC3927() const\n+{\n+    return IsIPv4() && (GetByte(3) == 169 && GetByte(2) == 254);\n+}\n+\n+bool CNetAddr::IsRFC6598() const\n+{\n+    return IsIPv4() && GetByte(3) == 100 && GetByte(2) >= 64 && GetByte(2) <= 127;\n+}\n+\n+bool CNetAddr::IsRFC5737() const\n+{\n+    return IsIPv4() && ((GetByte(3) == 192 && GetByte(2) == 0 && GetByte(1) == 2) ||\n+        (GetByte(3) == 198 && GetByte(2) == 51 && GetByte(1) == 100) ||\n+        (GetByte(3) == 203 && GetByte(2) == 0 && GetByte(1) == 113));\n+}\n+\n+bool CNetAddr::IsRFC3849() const\n+{\n+    return GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x0D && GetByte(12) == 0xB8;\n+}\n+\n+bool CNetAddr::IsRFC3964() const\n+{\n+    return (GetByte(15) == 0x20 && GetByte(14) == 0x02);\n+}\n+\n+bool CNetAddr::IsRFC6052() const\n+{\n+    static const unsigned char pchRFC6052[] = {0,0x64,0xFF,0x9B,0,0,0,0,0,0,0,0};\n+    return (memcmp(ip, pchRFC6052, sizeof(pchRFC6052)) == 0);\n+}\n+\n+bool CNetAddr::IsRFC4380() const\n+{\n+    return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0 && GetByte(12) == 0);\n+}\n+\n+bool CNetAddr::IsRFC4862() const\n+{\n+    static const unsigned char pchRFC4862[] = {0xFE,0x80,0,0,0,0,0,0};\n+    return (memcmp(ip, pchRFC4862, sizeof(pchRFC4862)) == 0);\n+}\n+\n+bool CNetAddr::IsRFC4193() const\n+{\n+    return ((GetByte(15) & 0xFE) == 0xFC);\n+}\n+\n+bool CNetAddr::IsRFC6145() const\n+{\n+    static const unsigned char pchRFC6145[] = {0,0,0,0,0,0,0,0,0xFF,0xFF,0,0};\n+    return (memcmp(ip, pchRFC6145, sizeof(pchRFC6145)) == 0);\n+}\n+\n+bool CNetAddr::IsRFC4843() const\n+{\n+    return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x00 && (GetByte(12) & 0xF0) == 0x10);\n+}\n+\n+bool CNetAddr::IsTor() const\n+{\n+    return (memcmp(ip, pchOnionCat, sizeof(pchOnionCat)) == 0);\n+}\n+\n+bool CNetAddr::IsLocal() const\n+{\n+    // IPv4 loopback\n+   if (IsIPv4() && (GetByte(3) == 127 || GetByte(3) == 0))\n+       return true;\n+\n+   // IPv6 loopback (::1/128)\n+   static const unsigned char pchLocal[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};\n+   if (memcmp(ip, pchLocal, 16) == 0)\n+       return true;\n+\n+   return false;\n+}\n+\n+bool CNetAddr::IsMulticast() const\n+{\n+    return    (IsIPv4() && (GetByte(3) & 0xF0) == 0xE0)\n+           || (GetByte(15) == 0xFF);\n+}\n+\n+bool CNetAddr::IsValid() const\n+{\n+    // Cleanup 3-byte shifted addresses caused by garbage in size field\n+    // of addr messages from versions before 0.2.9 checksum.\n+    // Two consecutive addr messages look like this:\n+    // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n+    // so if the first length field is garbled, it reads the second batch\n+    // of addr misaligned by 3 bytes.\n+    if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n+        return false;\n+\n+    // unspecified IPv6 address (::/128)\n+    unsigned char ipNone[16] = {};\n+    if (memcmp(ip, ipNone, 16) == 0)\n+        return false;\n+\n+    // documentation IPv6 address\n+    if (IsRFC3849())\n+        return false;\n+\n+    if (IsIPv4())\n+    {\n+        // INADDR_NONE\n+        uint32_t ipNone = INADDR_NONE;\n+        if (memcmp(ip+12, &ipNone, 4) == 0)\n+            return false;\n+\n+        // 0\n+        ipNone = 0;\n+        if (memcmp(ip+12, &ipNone, 4) == 0)\n+            return false;\n+    }\n+\n+    return true;\n+}\n+\n+bool CNetAddr::IsRoutable() const\n+{\n+    return IsValid() && !(IsRFC1918() || IsRFC2544() || IsRFC3927() || IsRFC4862() || IsRFC6598() || IsRFC5737() || (IsRFC4193() && !IsTor()) || IsRFC4843() || IsLocal());\n+}\n+\n+enum Network CNetAddr::GetNetwork() const\n+{\n+    if (!IsRoutable())\n+        return NET_UNROUTABLE;\n+\n+    if (IsIPv4())\n+        return NET_IPV4;\n+\n+    if (IsTor())\n+        return NET_TOR;\n+\n+    return NET_IPV6;\n+}\n+\n+std::string CNetAddr::ToStringIP() const\n+{\n+    if (IsTor())\n+        return EncodeBase32(&ip[6], 10) + \".onion\";\n+    CService serv(*this, 0);\n+    struct sockaddr_storage sockaddr;\n+    socklen_t socklen = sizeof(sockaddr);\n+    if (serv.GetSockAddr((struct sockaddr*)&sockaddr, &socklen)) {\n+        char name[1025] = \"\";\n+        if (!getnameinfo((const struct sockaddr*)&sockaddr, socklen, name, sizeof(name), NULL, 0, NI_NUMERICHOST))\n+            return std::string(name);\n+    }\n+    if (IsIPv4())\n+        return strprintf(\"%u.%u.%u.%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0));\n+    else\n+        return strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n+                         GetByte(15) << 8 | GetByte(14), GetByte(13) << 8 | GetByte(12),\n+                         GetByte(11) << 8 | GetByte(10), GetByte(9) << 8 | GetByte(8),\n+                         GetByte(7) << 8 | GetByte(6), GetByte(5) << 8 | GetByte(4),\n+                         GetByte(3) << 8 | GetByte(2), GetByte(1) << 8 | GetByte(0));\n+}\n+\n+std::string CNetAddr::ToString() const\n+{\n+    return ToStringIP();\n+}\n+\n+bool operator==(const CNetAddr& a, const CNetAddr& b)\n+{\n+    return (memcmp(a.ip, b.ip, 16) == 0);\n+}\n+\n+bool operator!=(const CNetAddr& a, const CNetAddr& b)\n+{\n+    return (memcmp(a.ip, b.ip, 16) != 0);\n+}\n+\n+bool operator<(const CNetAddr& a, const CNetAddr& b)\n+{\n+    return (memcmp(a.ip, b.ip, 16) < 0);\n+}\n+\n+bool CNetAddr::GetInAddr(struct in_addr* pipv4Addr) const\n+{\n+    if (!IsIPv4())\n+        return false;\n+    memcpy(pipv4Addr, ip+12, 4);\n+    return true;\n+}\n+\n+bool CNetAddr::GetIn6Addr(struct in6_addr* pipv6Addr) const\n+{\n+    memcpy(pipv6Addr, ip, 16);\n+    return true;\n+}\n+\n+// get canonical identifier of an address' group\n+// no two connections will be attempted to addresses with the same group\n+std::vector<unsigned char> CNetAddr::GetGroup() const\n+{\n+    std::vector<unsigned char> vchRet;\n+    int nClass = NET_IPV6;\n+    int nStartByte = 0;\n+    int nBits = 16;\n+\n+    // all local addresses belong to the same group\n+    if (IsLocal())\n+    {\n+        nClass = 255;\n+        nBits = 0;\n+    }\n+\n+    // all unroutable addresses belong to the same group\n+    if (!IsRoutable())\n+    {\n+        nClass = NET_UNROUTABLE;\n+        nBits = 0;\n+    }\n+    // for IPv4 addresses, '1' + the 16 higher-order bits of the IP\n+    // includes mapped IPv4, SIIT translated IPv4, and the well-known prefix\n+    else if (IsIPv4() || IsRFC6145() || IsRFC6052())\n+    {\n+        nClass = NET_IPV4;\n+        nStartByte = 12;\n+    }\n+    // for 6to4 tunnelled addresses, use the encapsulated IPv4 address\n+    else if (IsRFC3964())\n+    {\n+        nClass = NET_IPV4;\n+        nStartByte = 2;\n+    }\n+    // for Teredo-tunnelled IPv6 addresses, use the encapsulated IPv4 address\n+    else if (IsRFC4380())\n+    {\n+        vchRet.push_back(NET_IPV4);\n+        vchRet.push_back(GetByte(3) ^ 0xFF);\n+        vchRet.push_back(GetByte(2) ^ 0xFF);\n+        return vchRet;\n+    }\n+    else if (IsTor())\n+    {\n+        nClass = NET_TOR;\n+        nStartByte = 6;\n+        nBits = 4;\n+    }\n+    // for he.net, use /36 groups\n+    else if (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x04 && GetByte(12) == 0x70)\n+        nBits = 36;\n+    // for the rest of the IPv6 network, use /32 groups\n+    else\n+        nBits = 32;\n+\n+    vchRet.push_back(nClass);\n+    while (nBits >= 8)\n+    {\n+        vchRet.push_back(GetByte(15 - nStartByte));\n+        nStartByte++;\n+        nBits -= 8;\n+    }\n+    if (nBits > 0)\n+        vchRet.push_back(GetByte(15 - nStartByte) | ((1 << (8 - nBits)) - 1));\n+\n+    return vchRet;\n+}\n+\n+uint64_t CNetAddr::GetHash() const\n+{\n+    uint256 hash = Hash(&ip[0], &ip[16]);\n+    uint64_t nRet;\n+    memcpy(&nRet, &hash, sizeof(nRet));\n+    return nRet;\n+}\n+\n+// private extensions to enum Network, only returned by GetExtNetwork,\n+// and only used in GetReachabilityFrom\n+static const int NET_UNKNOWN = NET_MAX + 0;\n+static const int NET_TEREDO  = NET_MAX + 1;\n+int static GetExtNetwork(const CNetAddr *addr)\n+{\n+    if (addr == NULL)\n+        return NET_UNKNOWN;\n+    if (addr->IsRFC4380())\n+        return NET_TEREDO;\n+    return addr->GetNetwork();\n+}\n+\n+/** Calculates a metric for how reachable (*this) is from a given partner */\n+int CNetAddr::GetReachabilityFrom(const CNetAddr *paddrPartner) const\n+{\n+    enum Reachability {\n+        REACH_UNREACHABLE,\n+        REACH_DEFAULT,\n+        REACH_TEREDO,\n+        REACH_IPV6_WEAK,\n+        REACH_IPV4,\n+        REACH_IPV6_STRONG,\n+        REACH_PRIVATE\n+    };\n+\n+    if (!IsRoutable())\n+        return REACH_UNREACHABLE;\n+\n+    int ourNet = GetExtNetwork(this);\n+    int theirNet = GetExtNetwork(paddrPartner);\n+    bool fTunnel = IsRFC3964() || IsRFC6052() || IsRFC6145();\n+\n+    switch(theirNet) {\n+    case NET_IPV4:\n+        switch(ourNet) {\n+        default:       return REACH_DEFAULT;\n+        case NET_IPV4: return REACH_IPV4;\n+        }\n+    case NET_IPV6:\n+        switch(ourNet) {\n+        default:         return REACH_DEFAULT;\n+        case NET_TEREDO: return REACH_TEREDO;\n+        case NET_IPV4:   return REACH_IPV4;\n+        case NET_IPV6:   return fTunnel ? REACH_IPV6_WEAK : REACH_IPV6_STRONG; // only prefer giving our IPv6 address if it's not tunnelled\n+        }\n+    case NET_TOR:\n+        switch(ourNet) {\n+        default:         return REACH_DEFAULT;\n+        case NET_IPV4:   return REACH_IPV4; // Tor users can connect to IPv4 as well\n+        case NET_TOR:    return REACH_PRIVATE;\n+        }\n+    case NET_TEREDO:\n+        switch(ourNet) {\n+        default:          return REACH_DEFAULT;\n+        case NET_TEREDO:  return REACH_TEREDO;\n+        case NET_IPV6:    return REACH_IPV6_WEAK;\n+        case NET_IPV4:    return REACH_IPV4;\n+        }\n+    case NET_UNKNOWN:\n+    case NET_UNROUTABLE:\n+    default:\n+        switch(ourNet) {\n+        default:          return REACH_DEFAULT;\n+        case NET_TEREDO:  return REACH_TEREDO;\n+        case NET_IPV6:    return REACH_IPV6_WEAK;\n+        case NET_IPV4:    return REACH_IPV4;\n+        case NET_TOR:     return REACH_PRIVATE; // either from Tor, or don't care about our address\n+        }\n+    }\n+}\n+\n+void CService::Init()\n+{\n+    port = 0;\n+}\n+\n+CService::CService()\n+{\n+    Init();\n+}\n+\n+CService::CService(const CNetAddr& cip, unsigned short portIn) : CNetAddr(cip), port(portIn)\n+{\n+}\n+\n+CService::CService(const struct in_addr& ipv4Addr, unsigned short portIn) : CNetAddr(ipv4Addr), port(portIn)\n+{\n+}\n+\n+CService::CService(const struct in6_addr& ipv6Addr, unsigned short portIn) : CNetAddr(ipv6Addr), port(portIn)\n+{\n+}\n+\n+CService::CService(const struct sockaddr_in& addr) : CNetAddr(addr.sin_addr), port(ntohs(addr.sin_port))\n+{\n+    assert(addr.sin_family == AF_INET);\n+}\n+\n+CService::CService(const struct sockaddr_in6 &addr) : CNetAddr(addr.sin6_addr, addr.sin6_scope_id), port(ntohs(addr.sin6_port))\n+{\n+   assert(addr.sin6_family == AF_INET6);\n+}\n+\n+bool CService::SetSockAddr(const struct sockaddr *paddr)\n+{\n+    switch (paddr->sa_family) {\n+    case AF_INET:\n+        *this = CService(*(const struct sockaddr_in*)paddr);\n+        return true;\n+    case AF_INET6:\n+        *this = CService(*(const struct sockaddr_in6*)paddr);\n+        return true;\n+    default:\n+        return false;\n+    }\n+}\n+\n+unsigned short CService::GetPort() const\n+{\n+    return port;\n+}\n+\n+bool operator==(const CService& a, const CService& b)\n+{\n+    return (CNetAddr)a == (CNetAddr)b && a.port == b.port;\n+}\n+\n+bool operator!=(const CService& a, const CService& b)\n+{\n+    return (CNetAddr)a != (CNetAddr)b || a.port != b.port;\n+}\n+\n+bool operator<(const CService& a, const CService& b)\n+{\n+    return (CNetAddr)a < (CNetAddr)b || ((CNetAddr)a == (CNetAddr)b && a.port < b.port);\n+}\n+\n+bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n+{\n+    if (IsIPv4()) {\n+        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n+            return false;\n+        *addrlen = sizeof(struct sockaddr_in);\n+        struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n+        memset(paddrin, 0, *addrlen);\n+        if (!GetInAddr(&paddrin->sin_addr))\n+            return false;\n+        paddrin->sin_family = AF_INET;\n+        paddrin->sin_port = htons(port);\n+        return true;\n+    }\n+    if (IsIPv6()) {\n+        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n+            return false;\n+        *addrlen = sizeof(struct sockaddr_in6);\n+        struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n+        memset(paddrin6, 0, *addrlen);\n+        if (!GetIn6Addr(&paddrin6->sin6_addr))\n+            return false;\n+        paddrin6->sin6_scope_id = scopeId;\n+        paddrin6->sin6_family = AF_INET6;\n+        paddrin6->sin6_port = htons(port);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+std::vector<unsigned char> CService::GetKey() const\n+{\n+     std::vector<unsigned char> vKey;\n+     vKey.resize(18);\n+     memcpy(&vKey[0], ip, 16);\n+     vKey[16] = port / 0x100;\n+     vKey[17] = port & 0x0FF;\n+     return vKey;\n+}\n+\n+std::string CService::ToStringPort() const\n+{\n+    return strprintf(\"%u\", port);\n+}\n+\n+std::string CService::ToStringIPPort() const\n+{\n+    if (IsIPv4() || IsTor()) {\n+        return ToStringIP() + \":\" + ToStringPort();\n+    } else {\n+        return \"[\" + ToStringIP() + \"]:\" + ToStringPort();\n+    }\n+}\n+\n+std::string CService::ToString() const\n+{\n+    return ToStringIPPort();\n+}\n+\n+void CService::SetPort(unsigned short portIn)\n+{\n+    port = portIn;\n+}\n+\n+CSubNet::CSubNet():\n+    valid(false)\n+{\n+    memset(netmask, 0, sizeof(netmask));\n+}\n+\n+CSubNet::CSubNet(const CNetAddr &addr, int32_t mask)\n+{\n+    valid = true;\n+    network = addr;\n+    // Default to /32 (IPv4) or /128 (IPv6), i.e. match single address\n+    memset(netmask, 255, sizeof(netmask));\n+\n+    // IPv4 addresses start at offset 12, and first 12 bytes must match, so just offset n\n+    const int astartofs = network.IsIPv4() ? 12 : 0;\n+\n+    int32_t n = mask;\n+    if(n >= 0 && n <= (128 - astartofs*8)) // Only valid if in range of bits of address\n+    {\n+        n += astartofs*8;\n+        // Clear bits [n..127]\n+        for (; n < 128; ++n)\n+            netmask[n>>3] &= ~(1<<(7-(n&7)));\n+    } else\n+        valid = false;\n+\n+    // Normalize network according to netmask\n+    for(int x=0; x<16; ++x)\n+        network.ip[x] &= netmask[x];\n+}\n+\n+CSubNet::CSubNet(const CNetAddr &addr, const CNetAddr &mask)\n+{\n+    valid = true;\n+    network = addr;\n+    // Default to /32 (IPv4) or /128 (IPv6), i.e. match single address\n+    memset(netmask, 255, sizeof(netmask));\n+\n+    // IPv4 addresses start at offset 12, and first 12 bytes must match, so just offset n\n+    const int astartofs = network.IsIPv4() ? 12 : 0;\n+\n+    for(int x=astartofs; x<16; ++x)\n+        netmask[x] = mask.ip[x];\n+\n+    // Normalize network according to netmask\n+    for(int x=0; x<16; ++x)\n+        network.ip[x] &= netmask[x];\n+}\n+\n+CSubNet::CSubNet(const CNetAddr &addr):\n+    valid(addr.IsValid())\n+{\n+    memset(netmask, 255, sizeof(netmask));\n+    network = addr;\n+}\n+\n+bool CSubNet::Match(const CNetAddr &addr) const\n+{\n+    if (!valid || !addr.IsValid())\n+        return false;\n+    for(int x=0; x<16; ++x)\n+        if ((addr.ip[x] & netmask[x]) != network.ip[x])\n+            return false;\n+    return true;\n+}\n+\n+static inline int NetmaskBits(uint8_t x)\n+{\n+    switch(x) {\n+    case 0x00: return 0; break;\n+    case 0x80: return 1; break;\n+    case 0xc0: return 2; break;\n+    case 0xe0: return 3; break;\n+    case 0xf0: return 4; break;\n+    case 0xf8: return 5; break;\n+    case 0xfc: return 6; break;\n+    case 0xfe: return 7; break;\n+    case 0xff: return 8; break;\n+    default: return -1; break;\n+    }\n+}\n+\n+std::string CSubNet::ToString() const\n+{\n+    /* Parse binary 1{n}0{N-n} to see if mask can be represented as /n */\n+    int cidr = 0;\n+    bool valid_cidr = true;\n+    int n = network.IsIPv4() ? 12 : 0;\n+    for (; n < 16 && netmask[n] == 0xff; ++n)\n+        cidr += 8;\n+    if (n < 16) {\n+        int bits = NetmaskBits(netmask[n]);\n+        if (bits < 0)\n+            valid_cidr = false;\n+        else\n+            cidr += bits;\n+        ++n;\n+    }\n+    for (; n < 16 && valid_cidr; ++n)\n+        if (netmask[n] != 0x00)\n+            valid_cidr = false;\n+\n+    /* Format output */\n+    std::string strNetmask;\n+    if (valid_cidr) {\n+        strNetmask = strprintf(\"%u\", cidr);\n+    } else {\n+        if (network.IsIPv4())\n+            strNetmask = strprintf(\"%u.%u.%u.%u\", netmask[12], netmask[13], netmask[14], netmask[15]);\n+        else\n+            strNetmask = strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n+                             netmask[0] << 8 | netmask[1], netmask[2] << 8 | netmask[3],\n+                             netmask[4] << 8 | netmask[5], netmask[6] << 8 | netmask[7],\n+                             netmask[8] << 8 | netmask[9], netmask[10] << 8 | netmask[11],\n+                             netmask[12] << 8 | netmask[13], netmask[14] << 8 | netmask[15]);\n+    }\n+\n+    return network.ToString() + \"/\" + strNetmask;\n+}\n+\n+bool CSubNet::IsValid() const\n+{\n+    return valid;\n+}\n+\n+bool operator==(const CSubNet& a, const CSubNet& b)\n+{\n+    return a.valid == b.valid && a.network == b.network && !memcmp(a.netmask, b.netmask, 16);\n+}\n+\n+bool operator!=(const CSubNet& a, const CSubNet& b)\n+{\n+    return !(a==b);\n+}\n+\n+bool operator<(const CSubNet& a, const CSubNet& b)\n+{\n+    return (a.network < b.network || (a.network == b.network && memcmp(a.netmask, b.netmask, 16) < 0));\n+}"
      },
      {
        "sha": "9330fe33285821ac294ef221e20359884b454cf8",
        "filename": "src/netaddress.h",
        "status": "added",
        "additions": 171,
        "deletions": 0,
        "changes": 171,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -0,0 +1,171 @@\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NETADDRESS_H\n+#define BITCOIN_NETADDRESS_H\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#include \"compat.h\"\n+#include \"serialize.h\"\n+\n+#include <stdint.h>\n+#include <string>\n+#include <vector>\n+\n+enum Network\n+{\n+    NET_UNROUTABLE = 0,\n+    NET_IPV4,\n+    NET_IPV6,\n+    NET_TOR,\n+\n+    NET_MAX,\n+};\n+\n+/** IP address (IPv6, or IPv4 using mapped IPv6 range (::FFFF:0:0/96)) */\n+class CNetAddr\n+{\n+    protected:\n+        unsigned char ip[16]; // in network byte order\n+        uint32_t scopeId; // for scoped/link-local ipv6 addresses\n+\n+    public:\n+        CNetAddr();\n+        CNetAddr(const struct in_addr& ipv4Addr);\n+        void Init();\n+        void SetIP(const CNetAddr& ip);\n+\n+        /**\n+         * Set raw IPv4 or IPv6 address (in network byte order)\n+         * @note Only NET_IPV4 and NET_IPV6 are allowed for network.\n+         */\n+        void SetRaw(Network network, const uint8_t *data);\n+\n+        bool SetSpecial(const std::string &strName); // for Tor addresses\n+        bool IsIPv4() const;    // IPv4 mapped address (::FFFF:0:0/96, 0.0.0.0/0)\n+        bool IsIPv6() const;    // IPv6 address (not mapped IPv4, not Tor)\n+        bool IsRFC1918() const; // IPv4 private networks (10.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12)\n+        bool IsRFC2544() const; // IPv4 inter-network communcations (192.18.0.0/15)\n+        bool IsRFC6598() const; // IPv4 ISP-level NAT (100.64.0.0/10)\n+        bool IsRFC5737() const; // IPv4 documentation addresses (192.0.2.0/24, 198.51.100.0/24, 203.0.113.0/24)\n+        bool IsRFC3849() const; // IPv6 documentation address (2001:0DB8::/32)\n+        bool IsRFC3927() const; // IPv4 autoconfig (169.254.0.0/16)\n+        bool IsRFC3964() const; // IPv6 6to4 tunnelling (2002::/16)\n+        bool IsRFC4193() const; // IPv6 unique local (FC00::/7)\n+        bool IsRFC4380() const; // IPv6 Teredo tunnelling (2001::/32)\n+        bool IsRFC4843() const; // IPv6 ORCHID (2001:10::/28)\n+        bool IsRFC4862() const; // IPv6 autoconfig (FE80::/64)\n+        bool IsRFC6052() const; // IPv6 well-known prefix (64:FF9B::/96)\n+        bool IsRFC6145() const; // IPv6 IPv4-translated address (::FFFF:0:0:0/96)\n+        bool IsTor() const;\n+        bool IsLocal() const;\n+        bool IsRoutable() const;\n+        bool IsValid() const;\n+        bool IsMulticast() const;\n+        enum Network GetNetwork() const;\n+        std::string ToString() const;\n+        std::string ToStringIP() const;\n+        unsigned int GetByte(int n) const;\n+        uint64_t GetHash() const;\n+        bool GetInAddr(struct in_addr* pipv4Addr) const;\n+        std::vector<unsigned char> GetGroup() const;\n+        int GetReachabilityFrom(const CNetAddr *paddrPartner = NULL) const;\n+\n+        CNetAddr(const struct in6_addr& pipv6Addr, const uint32_t scope = 0);\n+        bool GetIn6Addr(struct in6_addr* pipv6Addr) const;\n+\n+        friend bool operator==(const CNetAddr& a, const CNetAddr& b);\n+        friend bool operator!=(const CNetAddr& a, const CNetAddr& b);\n+        friend bool operator<(const CNetAddr& a, const CNetAddr& b);\n+\n+        ADD_SERIALIZE_METHODS;\n+\n+        template <typename Stream, typename Operation>\n+        inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+            READWRITE(FLATDATA(ip));\n+        }\n+\n+        friend class CSubNet;\n+};\n+\n+class CSubNet\n+{\n+    protected:\n+        /// Network (base) address\n+        CNetAddr network;\n+        /// Netmask, in network byte order\n+        uint8_t netmask[16];\n+        /// Is this value valid? (only used to signal parse errors)\n+        bool valid;\n+\n+    public:\n+        CSubNet();\n+        CSubNet(const CNetAddr &addr, int32_t mask);\n+        CSubNet(const CNetAddr &addr, const CNetAddr &mask);\n+\n+        //constructor for single ip subnet (<ipv4>/32 or <ipv6>/128)\n+        explicit CSubNet(const CNetAddr &addr);\n+\n+        bool Match(const CNetAddr &addr) const;\n+\n+        std::string ToString() const;\n+        bool IsValid() const;\n+\n+        friend bool operator==(const CSubNet& a, const CSubNet& b);\n+        friend bool operator!=(const CSubNet& a, const CSubNet& b);\n+        friend bool operator<(const CSubNet& a, const CSubNet& b);\n+\n+        ADD_SERIALIZE_METHODS;\n+\n+        template <typename Stream, typename Operation>\n+        inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+            READWRITE(network);\n+            READWRITE(FLATDATA(netmask));\n+            READWRITE(FLATDATA(valid));\n+        }\n+};\n+\n+/** A combination of a network address (CNetAddr) and a (TCP) port */\n+class CService : public CNetAddr\n+{\n+    protected:\n+        unsigned short port; // host order\n+\n+    public:\n+        CService();\n+        CService(const CNetAddr& ip, unsigned short port);\n+        CService(const struct in_addr& ipv4Addr, unsigned short port);\n+        CService(const struct sockaddr_in& addr);\n+        void Init();\n+        void SetPort(unsigned short portIn);\n+        unsigned short GetPort() const;\n+        bool GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const;\n+        bool SetSockAddr(const struct sockaddr* paddr);\n+        friend bool operator==(const CService& a, const CService& b);\n+        friend bool operator!=(const CService& a, const CService& b);\n+        friend bool operator<(const CService& a, const CService& b);\n+        std::vector<unsigned char> GetKey() const;\n+        std::string ToString() const;\n+        std::string ToStringPort() const;\n+        std::string ToStringIPPort() const;\n+\n+        CService(const struct in6_addr& ipv6Addr, unsigned short port);\n+        CService(const struct sockaddr_in6& addr);\n+\n+        ADD_SERIALIZE_METHODS;\n+\n+        template <typename Stream, typename Operation>\n+        inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+            READWRITE(FLATDATA(ip));\n+            unsigned short portN = htons(port);\n+            READWRITE(FLATDATA(portN));\n+            if (ser_action.ForRead())\n+                 port = ntohs(portN);\n+        }\n+};\n+\n+#endif // BITCOIN_NETADDRESS_H"
      },
      {
        "sha": "4f243ec6f539746ed80d57a592158d4a7e85dad6",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 749,
        "changes": 782,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -42,8 +42,6 @@ static CCriticalSection cs_proxyInfos;\n int nConnectTimeout = DEFAULT_CONNECT_TIMEOUT;\n bool fNameLookup = DEFAULT_NAME_LOOKUP;\n \n-static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n-\n // Need ample time for negotiation for very slow proxies such as Tor (milliseconds)\n static const int SOCKS5_RECV_TIMEOUT = 20 * 1000;\n \n@@ -195,6 +193,16 @@ bool LookupHost(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nM\n     return LookupIntern(strHost.c_str(), vIP, nMaxSolutions, fAllowLookup);\n }\n \n+bool LookupHost(const char *pszName, CNetAddr& addr, bool fAllowLookup)\n+{\n+    std::vector<CNetAddr> vIP;\n+    LookupHost(pszName, vIP, 1, fAllowLookup);\n+    if(vIP.empty())\n+        return false;\n+    addr = vIP.front();\n+    return true;\n+}\n+\n bool Lookup(const char *pszName, std::vector<CService>& vAddr, int portDefault, bool fAllowLookup, unsigned int nMaxSolutions)\n {\n     if (pszName[0] == 0)\n@@ -223,9 +231,14 @@ bool Lookup(const char *pszName, CService& addr, int portDefault, bool fAllowLoo\n     return true;\n }\n \n-bool LookupNumeric(const char *pszName, CService& addr, int portDefault)\n+CService LookupNumeric(const char *pszName, int portDefault)\n {\n-    return Lookup(pszName, addr, portDefault, false);\n+    CService addr;\n+    // \"1.2:345\" will fail to resolve the ip, but will still set the port.\n+    // If the ip fails to resolve, re-init the result.\n+    if(!Lookup(pszName, addr, portDefault, false))\n+        addr = CService();\n+    return addr;\n }\n \n struct timeval MillisToTimeval(int64_t nTimeout)\n@@ -629,777 +642,48 @@ bool ConnectSocketByName(CService &addr, SOCKET& hSocketRet, const char *pszDest\n         }\n     }\n \n-    addr = CService(\"0.0.0.0:0\");\n+    addr = CService();\n \n     if (!HaveNameProxy())\n         return false;\n     return ConnectThroughProxy(nameProxy, strDest, port, hSocketRet, nTimeout, outProxyConnectionFailed);\n }\n \n-void CNetAddr::Init()\n-{\n-    memset(ip, 0, sizeof(ip));\n-    scopeId = 0;\n-}\n-\n-void CNetAddr::SetIP(const CNetAddr& ipIn)\n-{\n-    memcpy(ip, ipIn.ip, sizeof(ip));\n-}\n-\n-void CNetAddr::SetRaw(Network network, const uint8_t *ip_in)\n-{\n-    switch(network)\n-    {\n-        case NET_IPV4:\n-            memcpy(ip, pchIPv4, 12);\n-            memcpy(ip+12, ip_in, 4);\n-            break;\n-        case NET_IPV6:\n-            memcpy(ip, ip_in, 16);\n-            break;\n-        default:\n-            assert(!\"invalid network\");\n-    }\n-}\n-\n-static const unsigned char pchOnionCat[] = {0xFD,0x87,0xD8,0x7E,0xEB,0x43};\n-\n-bool CNetAddr::SetSpecial(const std::string &strName)\n-{\n-    if (strName.size()>6 && strName.substr(strName.size() - 6, 6) == \".onion\") {\n-        std::vector<unsigned char> vchAddr = DecodeBase32(strName.substr(0, strName.size() - 6).c_str());\n-        if (vchAddr.size() != 16-sizeof(pchOnionCat))\n-            return false;\n-        memcpy(ip, pchOnionCat, sizeof(pchOnionCat));\n-        for (unsigned int i=0; i<16-sizeof(pchOnionCat); i++)\n-            ip[i + sizeof(pchOnionCat)] = vchAddr[i];\n-        return true;\n-    }\n-    return false;\n-}\n-\n-CNetAddr::CNetAddr()\n-{\n-    Init();\n-}\n-\n-CNetAddr::CNetAddr(const struct in_addr& ipv4Addr)\n-{\n-    SetRaw(NET_IPV4, (const uint8_t*)&ipv4Addr);\n-}\n-\n-CNetAddr::CNetAddr(const struct in6_addr& ipv6Addr, const uint32_t scope)\n-{\n-    SetRaw(NET_IPV6, (const uint8_t*)&ipv6Addr);\n-    scopeId = scope;\n-}\n-\n-CNetAddr::CNetAddr(const char *pszIp)\n-{\n-    Init();\n-    std::vector<CNetAddr> vIP;\n-    if (LookupHost(pszIp, vIP, 1, false))\n-        *this = vIP[0];\n-}\n-\n-CNetAddr::CNetAddr(const std::string &strIp)\n-{\n-    Init();\n-    std::vector<CNetAddr> vIP;\n-    if (LookupHost(strIp.c_str(), vIP, 1, false))\n-        *this = vIP[0];\n-}\n-\n-unsigned int CNetAddr::GetByte(int n) const\n-{\n-    return ip[15-n];\n-}\n-\n-bool CNetAddr::IsIPv4() const\n-{\n-    return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n-}\n-\n-bool CNetAddr::IsIPv6() const\n-{\n-    return (!IsIPv4() && !IsTor());\n-}\n-\n-bool CNetAddr::IsRFC1918() const\n-{\n-    return IsIPv4() && (\n-        GetByte(3) == 10 ||\n-        (GetByte(3) == 192 && GetByte(2) == 168) ||\n-        (GetByte(3) == 172 && (GetByte(2) >= 16 && GetByte(2) <= 31)));\n-}\n-\n-bool CNetAddr::IsRFC2544() const\n-{\n-    return IsIPv4() && GetByte(3) == 198 && (GetByte(2) == 18 || GetByte(2) == 19);\n-}\n-\n-bool CNetAddr::IsRFC3927() const\n-{\n-    return IsIPv4() && (GetByte(3) == 169 && GetByte(2) == 254);\n-}\n-\n-bool CNetAddr::IsRFC6598() const\n-{\n-    return IsIPv4() && GetByte(3) == 100 && GetByte(2) >= 64 && GetByte(2) <= 127;\n-}\n-\n-bool CNetAddr::IsRFC5737() const\n-{\n-    return IsIPv4() && ((GetByte(3) == 192 && GetByte(2) == 0 && GetByte(1) == 2) ||\n-        (GetByte(3) == 198 && GetByte(2) == 51 && GetByte(1) == 100) ||\n-        (GetByte(3) == 203 && GetByte(2) == 0 && GetByte(1) == 113));\n-}\n-\n-bool CNetAddr::IsRFC3849() const\n-{\n-    return GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x0D && GetByte(12) == 0xB8;\n-}\n-\n-bool CNetAddr::IsRFC3964() const\n-{\n-    return (GetByte(15) == 0x20 && GetByte(14) == 0x02);\n-}\n-\n-bool CNetAddr::IsRFC6052() const\n-{\n-    static const unsigned char pchRFC6052[] = {0,0x64,0xFF,0x9B,0,0,0,0,0,0,0,0};\n-    return (memcmp(ip, pchRFC6052, sizeof(pchRFC6052)) == 0);\n-}\n-\n-bool CNetAddr::IsRFC4380() const\n-{\n-    return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0 && GetByte(12) == 0);\n-}\n-\n-bool CNetAddr::IsRFC4862() const\n-{\n-    static const unsigned char pchRFC4862[] = {0xFE,0x80,0,0,0,0,0,0};\n-    return (memcmp(ip, pchRFC4862, sizeof(pchRFC4862)) == 0);\n-}\n-\n-bool CNetAddr::IsRFC4193() const\n-{\n-    return ((GetByte(15) & 0xFE) == 0xFC);\n-}\n-\n-bool CNetAddr::IsRFC6145() const\n-{\n-    static const unsigned char pchRFC6145[] = {0,0,0,0,0,0,0,0,0xFF,0xFF,0,0};\n-    return (memcmp(ip, pchRFC6145, sizeof(pchRFC6145)) == 0);\n-}\n-\n-bool CNetAddr::IsRFC4843() const\n-{\n-    return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x00 && (GetByte(12) & 0xF0) == 0x10);\n-}\n-\n-bool CNetAddr::IsTor() const\n-{\n-    return (memcmp(ip, pchOnionCat, sizeof(pchOnionCat)) == 0);\n-}\n-\n-bool CNetAddr::IsLocal() const\n-{\n-    // IPv4 loopback\n-   if (IsIPv4() && (GetByte(3) == 127 || GetByte(3) == 0))\n-       return true;\n-\n-   // IPv6 loopback (::1/128)\n-   static const unsigned char pchLocal[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};\n-   if (memcmp(ip, pchLocal, 16) == 0)\n-       return true;\n-\n-   return false;\n-}\n-\n-bool CNetAddr::IsMulticast() const\n-{\n-    return    (IsIPv4() && (GetByte(3) & 0xF0) == 0xE0)\n-           || (GetByte(15) == 0xFF);\n-}\n-\n-bool CNetAddr::IsValid() const\n-{\n-    // Cleanup 3-byte shifted addresses caused by garbage in size field\n-    // of addr messages from versions before 0.2.9 checksum.\n-    // Two consecutive addr messages look like this:\n-    // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n-    // so if the first length field is garbled, it reads the second batch\n-    // of addr misaligned by 3 bytes.\n-    if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n-        return false;\n-\n-    // unspecified IPv6 address (::/128)\n-    unsigned char ipNone[16] = {};\n-    if (memcmp(ip, ipNone, 16) == 0)\n-        return false;\n-\n-    // documentation IPv6 address\n-    if (IsRFC3849())\n-        return false;\n-\n-    if (IsIPv4())\n-    {\n-        // INADDR_NONE\n-        uint32_t ipNone = INADDR_NONE;\n-        if (memcmp(ip+12, &ipNone, 4) == 0)\n-            return false;\n-\n-        // 0\n-        ipNone = 0;\n-        if (memcmp(ip+12, &ipNone, 4) == 0)\n-            return false;\n-    }\n-\n-    return true;\n-}\n-\n-bool CNetAddr::IsRoutable() const\n-{\n-    return IsValid() && !(IsRFC1918() || IsRFC2544() || IsRFC3927() || IsRFC4862() || IsRFC6598() || IsRFC5737() || (IsRFC4193() && !IsTor()) || IsRFC4843() || IsLocal());\n-}\n-\n-enum Network CNetAddr::GetNetwork() const\n-{\n-    if (!IsRoutable())\n-        return NET_UNROUTABLE;\n-\n-    if (IsIPv4())\n-        return NET_IPV4;\n-\n-    if (IsTor())\n-        return NET_TOR;\n-\n-    return NET_IPV6;\n-}\n-\n-std::string CNetAddr::ToStringIP() const\n-{\n-    if (IsTor())\n-        return EncodeBase32(&ip[6], 10) + \".onion\";\n-    CService serv(*this, 0);\n-    struct sockaddr_storage sockaddr;\n-    socklen_t socklen = sizeof(sockaddr);\n-    if (serv.GetSockAddr((struct sockaddr*)&sockaddr, &socklen)) {\n-        char name[1025] = \"\";\n-        if (!getnameinfo((const struct sockaddr*)&sockaddr, socklen, name, sizeof(name), NULL, 0, NI_NUMERICHOST))\n-            return std::string(name);\n-    }\n-    if (IsIPv4())\n-        return strprintf(\"%u.%u.%u.%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0));\n-    else\n-        return strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n-                         GetByte(15) << 8 | GetByte(14), GetByte(13) << 8 | GetByte(12),\n-                         GetByte(11) << 8 | GetByte(10), GetByte(9) << 8 | GetByte(8),\n-                         GetByte(7) << 8 | GetByte(6), GetByte(5) << 8 | GetByte(4),\n-                         GetByte(3) << 8 | GetByte(2), GetByte(1) << 8 | GetByte(0));\n-}\n-\n-std::string CNetAddr::ToString() const\n-{\n-    return ToStringIP();\n-}\n-\n-bool operator==(const CNetAddr& a, const CNetAddr& b)\n-{\n-    return (memcmp(a.ip, b.ip, 16) == 0);\n-}\n-\n-bool operator!=(const CNetAddr& a, const CNetAddr& b)\n-{\n-    return (memcmp(a.ip, b.ip, 16) != 0);\n-}\n-\n-bool operator<(const CNetAddr& a, const CNetAddr& b)\n-{\n-    return (memcmp(a.ip, b.ip, 16) < 0);\n-}\n-\n-bool CNetAddr::GetInAddr(struct in_addr* pipv4Addr) const\n-{\n-    if (!IsIPv4())\n-        return false;\n-    memcpy(pipv4Addr, ip+12, 4);\n-    return true;\n-}\n-\n-bool CNetAddr::GetIn6Addr(struct in6_addr* pipv6Addr) const\n-{\n-    memcpy(pipv6Addr, ip, 16);\n-    return true;\n-}\n-\n-// get canonical identifier of an address' group\n-// no two connections will be attempted to addresses with the same group\n-std::vector<unsigned char> CNetAddr::GetGroup() const\n-{\n-    std::vector<unsigned char> vchRet;\n-    int nClass = NET_IPV6;\n-    int nStartByte = 0;\n-    int nBits = 16;\n-\n-    // all local addresses belong to the same group\n-    if (IsLocal())\n-    {\n-        nClass = 255;\n-        nBits = 0;\n-    }\n-\n-    // all unroutable addresses belong to the same group\n-    if (!IsRoutable())\n-    {\n-        nClass = NET_UNROUTABLE;\n-        nBits = 0;\n-    }\n-    // for IPv4 addresses, '1' + the 16 higher-order bits of the IP\n-    // includes mapped IPv4, SIIT translated IPv4, and the well-known prefix\n-    else if (IsIPv4() || IsRFC6145() || IsRFC6052())\n-    {\n-        nClass = NET_IPV4;\n-        nStartByte = 12;\n-    }\n-    // for 6to4 tunnelled addresses, use the encapsulated IPv4 address\n-    else if (IsRFC3964())\n-    {\n-        nClass = NET_IPV4;\n-        nStartByte = 2;\n-    }\n-    // for Teredo-tunnelled IPv6 addresses, use the encapsulated IPv4 address\n-    else if (IsRFC4380())\n-    {\n-        vchRet.push_back(NET_IPV4);\n-        vchRet.push_back(GetByte(3) ^ 0xFF);\n-        vchRet.push_back(GetByte(2) ^ 0xFF);\n-        return vchRet;\n-    }\n-    else if (IsTor())\n-    {\n-        nClass = NET_TOR;\n-        nStartByte = 6;\n-        nBits = 4;\n-    }\n-    // for he.net, use /36 groups\n-    else if (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x04 && GetByte(12) == 0x70)\n-        nBits = 36;\n-    // for the rest of the IPv6 network, use /32 groups\n-    else\n-        nBits = 32;\n-\n-    vchRet.push_back(nClass);\n-    while (nBits >= 8)\n-    {\n-        vchRet.push_back(GetByte(15 - nStartByte));\n-        nStartByte++;\n-        nBits -= 8;\n-    }\n-    if (nBits > 0)\n-        vchRet.push_back(GetByte(15 - nStartByte) | ((1 << (8 - nBits)) - 1));\n-\n-    return vchRet;\n-}\n-\n-uint64_t CNetAddr::GetHash() const\n-{\n-    uint256 hash = Hash(&ip[0], &ip[16]);\n-    uint64_t nRet;\n-    memcpy(&nRet, &hash, sizeof(nRet));\n-    return nRet;\n-}\n-\n-// private extensions to enum Network, only returned by GetExtNetwork,\n-// and only used in GetReachabilityFrom\n-static const int NET_UNKNOWN = NET_MAX + 0;\n-static const int NET_TEREDO  = NET_MAX + 1;\n-int static GetExtNetwork(const CNetAddr *addr)\n-{\n-    if (addr == NULL)\n-        return NET_UNKNOWN;\n-    if (addr->IsRFC4380())\n-        return NET_TEREDO;\n-    return addr->GetNetwork();\n-}\n-\n-/** Calculates a metric for how reachable (*this) is from a given partner */\n-int CNetAddr::GetReachabilityFrom(const CNetAddr *paddrPartner) const\n-{\n-    enum Reachability {\n-        REACH_UNREACHABLE,\n-        REACH_DEFAULT,\n-        REACH_TEREDO,\n-        REACH_IPV6_WEAK,\n-        REACH_IPV4,\n-        REACH_IPV6_STRONG,\n-        REACH_PRIVATE\n-    };\n-\n-    if (!IsRoutable())\n-        return REACH_UNREACHABLE;\n-\n-    int ourNet = GetExtNetwork(this);\n-    int theirNet = GetExtNetwork(paddrPartner);\n-    bool fTunnel = IsRFC3964() || IsRFC6052() || IsRFC6145();\n-\n-    switch(theirNet) {\n-    case NET_IPV4:\n-        switch(ourNet) {\n-        default:       return REACH_DEFAULT;\n-        case NET_IPV4: return REACH_IPV4;\n-        }\n-    case NET_IPV6:\n-        switch(ourNet) {\n-        default:         return REACH_DEFAULT;\n-        case NET_TEREDO: return REACH_TEREDO;\n-        case NET_IPV4:   return REACH_IPV4;\n-        case NET_IPV6:   return fTunnel ? REACH_IPV6_WEAK : REACH_IPV6_STRONG; // only prefer giving our IPv6 address if it's not tunnelled\n-        }\n-    case NET_TOR:\n-        switch(ourNet) {\n-        default:         return REACH_DEFAULT;\n-        case NET_IPV4:   return REACH_IPV4; // Tor users can connect to IPv4 as well\n-        case NET_TOR:    return REACH_PRIVATE;\n-        }\n-    case NET_TEREDO:\n-        switch(ourNet) {\n-        default:          return REACH_DEFAULT;\n-        case NET_TEREDO:  return REACH_TEREDO;\n-        case NET_IPV6:    return REACH_IPV6_WEAK;\n-        case NET_IPV4:    return REACH_IPV4;\n-        }\n-    case NET_UNKNOWN:\n-    case NET_UNROUTABLE:\n-    default:\n-        switch(ourNet) {\n-        default:          return REACH_DEFAULT;\n-        case NET_TEREDO:  return REACH_TEREDO;\n-        case NET_IPV6:    return REACH_IPV6_WEAK;\n-        case NET_IPV4:    return REACH_IPV4;\n-        case NET_TOR:     return REACH_PRIVATE; // either from Tor, or don't care about our address\n-        }\n-    }\n-}\n-\n-void CService::Init()\n-{\n-    port = 0;\n-}\n-\n-CService::CService()\n-{\n-    Init();\n-}\n-\n-CService::CService(const CNetAddr& cip, unsigned short portIn) : CNetAddr(cip), port(portIn)\n-{\n-}\n-\n-CService::CService(const struct in_addr& ipv4Addr, unsigned short portIn) : CNetAddr(ipv4Addr), port(portIn)\n-{\n-}\n-\n-CService::CService(const struct in6_addr& ipv6Addr, unsigned short portIn) : CNetAddr(ipv6Addr), port(portIn)\n-{\n-}\n-\n-CService::CService(const struct sockaddr_in& addr) : CNetAddr(addr.sin_addr), port(ntohs(addr.sin_port))\n-{\n-    assert(addr.sin_family == AF_INET);\n-}\n-\n-CService::CService(const struct sockaddr_in6 &addr) : CNetAddr(addr.sin6_addr, addr.sin6_scope_id), port(ntohs(addr.sin6_port))\n-{\n-   assert(addr.sin6_family == AF_INET6);\n-}\n-\n-bool CService::SetSockAddr(const struct sockaddr *paddr)\n-{\n-    switch (paddr->sa_family) {\n-    case AF_INET:\n-        *this = CService(*(const struct sockaddr_in*)paddr);\n-        return true;\n-    case AF_INET6:\n-        *this = CService(*(const struct sockaddr_in6*)paddr);\n-        return true;\n-    default:\n-        return false;\n-    }\n-}\n-\n-CService::CService(const char *pszIpPort)\n-{\n-    Init();\n-    CService ip;\n-    if (Lookup(pszIpPort, ip, 0, false))\n-        *this = ip;\n-}\n-\n-CService::CService(const char *pszIpPort, int portDefault)\n-{\n-    Init();\n-    CService ip;\n-    if (Lookup(pszIpPort, ip, portDefault, false))\n-        *this = ip;\n-}\n-\n-CService::CService(const std::string &strIpPort)\n-{\n-    Init();\n-    CService ip;\n-    if (Lookup(strIpPort.c_str(), ip, 0, false))\n-        *this = ip;\n-}\n-\n-CService::CService(const std::string &strIpPort, int portDefault)\n-{\n-    Init();\n-    CService ip;\n-    if (Lookup(strIpPort.c_str(), ip, portDefault, false))\n-        *this = ip;\n-}\n-\n-unsigned short CService::GetPort() const\n-{\n-    return port;\n-}\n-\n-bool operator==(const CService& a, const CService& b)\n-{\n-    return (CNetAddr)a == (CNetAddr)b && a.port == b.port;\n-}\n-\n-bool operator!=(const CService& a, const CService& b)\n-{\n-    return (CNetAddr)a != (CNetAddr)b || a.port != b.port;\n-}\n-\n-bool operator<(const CService& a, const CService& b)\n-{\n-    return (CNetAddr)a < (CNetAddr)b || ((CNetAddr)a == (CNetAddr)b && a.port < b.port);\n-}\n-\n-bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n-{\n-    if (IsIPv4()) {\n-        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n-            return false;\n-        *addrlen = sizeof(struct sockaddr_in);\n-        struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n-        memset(paddrin, 0, *addrlen);\n-        if (!GetInAddr(&paddrin->sin_addr))\n-            return false;\n-        paddrin->sin_family = AF_INET;\n-        paddrin->sin_port = htons(port);\n-        return true;\n-    }\n-    if (IsIPv6()) {\n-        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n-            return false;\n-        *addrlen = sizeof(struct sockaddr_in6);\n-        struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n-        memset(paddrin6, 0, *addrlen);\n-        if (!GetIn6Addr(&paddrin6->sin6_addr))\n-            return false;\n-        paddrin6->sin6_scope_id = scopeId;\n-        paddrin6->sin6_family = AF_INET6;\n-        paddrin6->sin6_port = htons(port);\n-        return true;\n-    }\n-    return false;\n-}\n-\n-std::vector<unsigned char> CService::GetKey() const\n-{\n-     std::vector<unsigned char> vKey;\n-     vKey.resize(18);\n-     memcpy(&vKey[0], ip, 16);\n-     vKey[16] = port / 0x100;\n-     vKey[17] = port & 0x0FF;\n-     return vKey;\n-}\n-\n-std::string CService::ToStringPort() const\n-{\n-    return strprintf(\"%u\", port);\n-}\n-\n-std::string CService::ToStringIPPort() const\n-{\n-    if (IsIPv4() || IsTor()) {\n-        return ToStringIP() + \":\" + ToStringPort();\n-    } else {\n-        return \"[\" + ToStringIP() + \"]:\" + ToStringPort();\n-    }\n-}\n-\n-std::string CService::ToString() const\n-{\n-    return ToStringIPPort();\n-}\n-\n-void CService::SetPort(unsigned short portIn)\n-{\n-    port = portIn;\n-}\n-\n-CSubNet::CSubNet():\n-    valid(false)\n-{\n-    memset(netmask, 0, sizeof(netmask));\n-}\n-\n-CSubNet::CSubNet(const std::string &strSubnet)\n+bool LookupSubNet(const char* pszName, CSubNet& ret)\n {\n+    std::string strSubnet(pszName);\n     size_t slash = strSubnet.find_last_of('/');\n     std::vector<CNetAddr> vIP;\n \n-    valid = true;\n-    // Default to /32 (IPv4) or /128 (IPv6), i.e. match single address\n-    memset(netmask, 255, sizeof(netmask));\n-\n     std::string strAddress = strSubnet.substr(0, slash);\n     if (LookupHost(strAddress.c_str(), vIP, 1, false))\n     {\n-        network = vIP[0];\n+        CNetAddr network = vIP[0];\n         if (slash != strSubnet.npos)\n         {\n             std::string strNetmask = strSubnet.substr(slash + 1);\n             int32_t n;\n             // IPv4 addresses start at offset 12, and first 12 bytes must match, so just offset n\n-            const int astartofs = network.IsIPv4() ? 12 : 0;\n-            if (ParseInt32(strNetmask, &n)) // If valid number, assume /24 symtex\n-            {\n-                if(n >= 0 && n <= (128 - astartofs*8)) // Only valid if in range of bits of address\n-                {\n-                    n += astartofs*8;\n-                    // Clear bits [n..127]\n-                    for (; n < 128; ++n)\n-                        netmask[n>>3] &= ~(1<<(7-(n&7)));\n-                }\n-                else\n-                {\n-                    valid = false;\n-                }\n+            if (ParseInt32(strNetmask, &n)) { // If valid number, assume /24 syntax\n+                ret = CSubNet(network, n);\n+                return ret.IsValid();\n             }\n             else // If not a valid number, try full netmask syntax\n             {\n-                if (LookupHost(strNetmask.c_str(), vIP, 1, false)) // Never allow lookup for netmask\n-                {\n-                    // Copy only the *last* four bytes in case of IPv4, the rest of the mask should stay 1's as\n-                    // we don't want pchIPv4 to be part of the mask.\n-                    for(int x=astartofs; x<16; ++x)\n-                        netmask[x] = vIP[0].ip[x];\n-                }\n-                else\n-                {\n-                    valid = false;\n+                // Never allow lookup for netmask\n+                if (LookupHost(strNetmask.c_str(), vIP, 1, false)) {\n+                    ret = CSubNet(network, vIP[0]);\n+                    return ret.IsValid();\n                 }\n             }\n         }\n-    }\n-    else\n-    {\n-        valid = false;\n-    }\n-\n-    // Normalize network according to netmask\n-    for(int x=0; x<16; ++x)\n-        network.ip[x] &= netmask[x];\n-}\n-\n-CSubNet::CSubNet(const CNetAddr &addr):\n-    valid(addr.IsValid())\n-{\n-    memset(netmask, 255, sizeof(netmask));\n-    network = addr;\n-}\n-\n-bool CSubNet::Match(const CNetAddr &addr) const\n-{\n-    if (!valid || !addr.IsValid())\n-        return false;\n-    for(int x=0; x<16; ++x)\n-        if ((addr.ip[x] & netmask[x]) != network.ip[x])\n-            return false;\n-    return true;\n-}\n-\n-static inline int NetmaskBits(uint8_t x)\n-{\n-    switch(x) {\n-    case 0x00: return 0; break;\n-    case 0x80: return 1; break;\n-    case 0xc0: return 2; break;\n-    case 0xe0: return 3; break;\n-    case 0xf0: return 4; break;\n-    case 0xf8: return 5; break;\n-    case 0xfc: return 6; break;\n-    case 0xfe: return 7; break;\n-    case 0xff: return 8; break;\n-    default: return -1; break;\n-    }\n-}\n-\n-std::string CSubNet::ToString() const\n-{\n-    /* Parse binary 1{n}0{N-n} to see if mask can be represented as /n */\n-    int cidr = 0;\n-    bool valid_cidr = true;\n-    int n = network.IsIPv4() ? 12 : 0;\n-    for (; n < 16 && netmask[n] == 0xff; ++n)\n-        cidr += 8;\n-    if (n < 16) {\n-        int bits = NetmaskBits(netmask[n]);\n-        if (bits < 0)\n-            valid_cidr = false;\n         else\n-            cidr += bits;\n-        ++n;\n-    }\n-    for (; n < 16 && valid_cidr; ++n)\n-        if (netmask[n] != 0x00)\n-            valid_cidr = false;\n-\n-    /* Format output */\n-    std::string strNetmask;\n-    if (valid_cidr) {\n-        strNetmask = strprintf(\"%u\", cidr);\n-    } else {\n-        if (network.IsIPv4())\n-            strNetmask = strprintf(\"%u.%u.%u.%u\", netmask[12], netmask[13], netmask[14], netmask[15]);\n-        else\n-            strNetmask = strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n-                             netmask[0] << 8 | netmask[1], netmask[2] << 8 | netmask[3],\n-                             netmask[4] << 8 | netmask[5], netmask[6] << 8 | netmask[7],\n-                             netmask[8] << 8 | netmask[9], netmask[10] << 8 | netmask[11],\n-                             netmask[12] << 8 | netmask[13], netmask[14] << 8 | netmask[15]);\n+        {\n+            ret = CSubNet(network);\n+            return ret.IsValid();\n+        }\n     }\n-\n-    return network.ToString() + \"/\" + strNetmask;\n-}\n-\n-bool CSubNet::IsValid() const\n-{\n-    return valid;\n-}\n-\n-bool operator==(const CSubNet& a, const CSubNet& b)\n-{\n-    return a.valid == b.valid && a.network == b.network && !memcmp(a.netmask, b.netmask, 16);\n-}\n-\n-bool operator!=(const CSubNet& a, const CSubNet& b)\n-{\n-    return !(a==b);\n-}\n-\n-bool operator<(const CSubNet& a, const CSubNet& b)\n-{\n-    return (a.network < b.network || (a.network == b.network && memcmp(a.netmask, b.netmask, 16) < 0));\n+    return false;\n }\n \n #ifdef WIN32"
      },
      {
        "sha": "bb12019a8216b0ccc592552762f1dced63c75390",
        "filename": "src/netbase.h",
        "status": "modified",
        "additions": 4,
        "deletions": 163,
        "changes": 167,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -10,6 +10,7 @@\n #endif\n \n #include \"compat.h\"\n+#include \"netaddress.h\"\n #include \"serialize.h\"\n \n #include <stdint.h>\n@@ -24,168 +25,6 @@ static const int DEFAULT_CONNECT_TIMEOUT = 5000;\n //! -dns default\n static const int DEFAULT_NAME_LOOKUP = true;\n \n-#ifdef WIN32\n-// In MSVC, this is defined as a macro, undefine it to prevent a compile and link error\n-#undef SetPort\n-#endif\n-\n-enum Network\n-{\n-    NET_UNROUTABLE = 0,\n-    NET_IPV4,\n-    NET_IPV6,\n-    NET_TOR,\n-\n-    NET_MAX,\n-};\n-\n-/** IP address (IPv6, or IPv4 using mapped IPv6 range (::FFFF:0:0/96)) */\n-class CNetAddr\n-{\n-    protected:\n-        unsigned char ip[16]; // in network byte order\n-        uint32_t scopeId; // for scoped/link-local ipv6 addresses\n-\n-    public:\n-        CNetAddr();\n-        CNetAddr(const struct in_addr& ipv4Addr);\n-        explicit CNetAddr(const char *pszIp);\n-        explicit CNetAddr(const std::string &strIp);\n-        void Init();\n-        void SetIP(const CNetAddr& ip);\n-\n-        /**\n-         * Set raw IPv4 or IPv6 address (in network byte order)\n-         * @note Only NET_IPV4 and NET_IPV6 are allowed for network.\n-         */\n-        void SetRaw(Network network, const uint8_t *data);\n-\n-        bool SetSpecial(const std::string &strName); // for Tor addresses\n-        bool IsIPv4() const;    // IPv4 mapped address (::FFFF:0:0/96, 0.0.0.0/0)\n-        bool IsIPv6() const;    // IPv6 address (not mapped IPv4, not Tor)\n-        bool IsRFC1918() const; // IPv4 private networks (10.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12)\n-        bool IsRFC2544() const; // IPv4 inter-network communcations (192.18.0.0/15)\n-        bool IsRFC6598() const; // IPv4 ISP-level NAT (100.64.0.0/10)\n-        bool IsRFC5737() const; // IPv4 documentation addresses (192.0.2.0/24, 198.51.100.0/24, 203.0.113.0/24)\n-        bool IsRFC3849() const; // IPv6 documentation address (2001:0DB8::/32)\n-        bool IsRFC3927() const; // IPv4 autoconfig (169.254.0.0/16)\n-        bool IsRFC3964() const; // IPv6 6to4 tunnelling (2002::/16)\n-        bool IsRFC4193() const; // IPv6 unique local (FC00::/7)\n-        bool IsRFC4380() const; // IPv6 Teredo tunnelling (2001::/32)\n-        bool IsRFC4843() const; // IPv6 ORCHID (2001:10::/28)\n-        bool IsRFC4862() const; // IPv6 autoconfig (FE80::/64)\n-        bool IsRFC6052() const; // IPv6 well-known prefix (64:FF9B::/96)\n-        bool IsRFC6145() const; // IPv6 IPv4-translated address (::FFFF:0:0:0/96)\n-        bool IsTor() const;\n-        bool IsLocal() const;\n-        bool IsRoutable() const;\n-        bool IsValid() const;\n-        bool IsMulticast() const;\n-        enum Network GetNetwork() const;\n-        std::string ToString() const;\n-        std::string ToStringIP() const;\n-        unsigned int GetByte(int n) const;\n-        uint64_t GetHash() const;\n-        bool GetInAddr(struct in_addr* pipv4Addr) const;\n-        std::vector<unsigned char> GetGroup() const;\n-        int GetReachabilityFrom(const CNetAddr *paddrPartner = NULL) const;\n-\n-        CNetAddr(const struct in6_addr& pipv6Addr, const uint32_t scope = 0);\n-        bool GetIn6Addr(struct in6_addr* pipv6Addr) const;\n-\n-        friend bool operator==(const CNetAddr& a, const CNetAddr& b);\n-        friend bool operator!=(const CNetAddr& a, const CNetAddr& b);\n-        friend bool operator<(const CNetAddr& a, const CNetAddr& b);\n-\n-        ADD_SERIALIZE_METHODS;\n-\n-        template <typename Stream, typename Operation>\n-        inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n-            READWRITE(FLATDATA(ip));\n-        }\n-\n-        friend class CSubNet;\n-};\n-\n-class CSubNet\n-{\n-    protected:\n-        /// Network (base) address\n-        CNetAddr network;\n-        /// Netmask, in network byte order\n-        uint8_t netmask[16];\n-        /// Is this value valid? (only used to signal parse errors)\n-        bool valid;\n-\n-    public:\n-        CSubNet();\n-        explicit CSubNet(const std::string &strSubnet);\n-\n-        //constructor for single ip subnet (<ipv4>/32 or <ipv6>/128)\n-        explicit CSubNet(const CNetAddr &addr);\n-\n-        bool Match(const CNetAddr &addr) const;\n-\n-        std::string ToString() const;\n-        bool IsValid() const;\n-\n-        friend bool operator==(const CSubNet& a, const CSubNet& b);\n-        friend bool operator!=(const CSubNet& a, const CSubNet& b);\n-        friend bool operator<(const CSubNet& a, const CSubNet& b);\n-\n-        ADD_SERIALIZE_METHODS;\n-\n-        template <typename Stream, typename Operation>\n-        inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n-            READWRITE(network);\n-            READWRITE(FLATDATA(netmask));\n-            READWRITE(FLATDATA(valid));\n-        }\n-};\n-\n-/** A combination of a network address (CNetAddr) and a (TCP) port */\n-class CService : public CNetAddr\n-{\n-    protected:\n-        unsigned short port; // host order\n-\n-    public:\n-        CService();\n-        CService(const CNetAddr& ip, unsigned short port);\n-        CService(const struct in_addr& ipv4Addr, unsigned short port);\n-        CService(const struct sockaddr_in& addr);\n-        explicit CService(const char *pszIpPort, int portDefault);\n-        explicit CService(const char *pszIpPort);\n-        explicit CService(const std::string& strIpPort, int portDefault);\n-        explicit CService(const std::string& strIpPort);\n-        void Init();\n-        void SetPort(unsigned short portIn);\n-        unsigned short GetPort() const;\n-        bool GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const;\n-        bool SetSockAddr(const struct sockaddr* paddr);\n-        friend bool operator==(const CService& a, const CService& b);\n-        friend bool operator!=(const CService& a, const CService& b);\n-        friend bool operator<(const CService& a, const CService& b);\n-        std::vector<unsigned char> GetKey() const;\n-        std::string ToString() const;\n-        std::string ToStringPort() const;\n-        std::string ToStringIPPort() const;\n-\n-        CService(const struct in6_addr& ipv6Addr, unsigned short port);\n-        CService(const struct sockaddr_in6& addr);\n-\n-        ADD_SERIALIZE_METHODS;\n-\n-        template <typename Stream, typename Operation>\n-        inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n-            READWRITE(FLATDATA(ip));\n-            unsigned short portN = htons(port);\n-            READWRITE(FLATDATA(portN));\n-            if (ser_action.ForRead())\n-                 port = ntohs(portN);\n-        }\n-};\n-\n class proxyType\n {\n public:\n@@ -207,9 +46,11 @@ bool IsProxy(const CNetAddr &addr);\n bool SetNameProxy(const proxyType &addrProxy);\n bool HaveNameProxy();\n bool LookupHost(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup);\n+bool LookupHost(const char *pszName, CNetAddr& addr, bool fAllowLookup);\n bool Lookup(const char *pszName, CService& addr, int portDefault, bool fAllowLookup);\n bool Lookup(const char *pszName, std::vector<CService>& vAddr, int portDefault, bool fAllowLookup, unsigned int nMaxSolutions);\n-bool LookupNumeric(const char *pszName, CService& addr, int portDefault = 0);\n+CService LookupNumeric(const char *pszName, int portDefault = 0);\n+bool LookupSubNet(const char *pszName, CSubNet& subnet);\n bool ConnectSocket(const CService &addr, SOCKET& hSocketRet, int nTimeout, bool *outProxyConnectionFailed = 0);\n bool ConnectSocketByName(CService &addr, SOCKET& hSocketRet, const char *pszDest, int portDefault, int nTimeout, bool *outProxyConnectionFailed = 0);\n /** Return readable error string for a network error code */"
      },
      {
        "sha": "48080abc778d5c0f9534695a013b6f60449eabbe",
        "filename": "src/policy/policy.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 9,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/policy/policy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/policy/policy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -31,7 +31,7 @@\n      *   DUP CHECKSIG DROP ... repeated 100 times... OP_1\n      */\n \n-bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType)\n+bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType, const bool witnessEnabled)\n {\n     std::vector<std::vector<unsigned char> > vSolutions;\n     if (!Solver(scriptPubKey, whichType, vSolutions))\n@@ -50,10 +50,13 @@ bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType)\n                (!fAcceptDatacarrier || scriptPubKey.size() > nMaxDatacarrierBytes))\n           return false;\n \n+    else if (!witnessEnabled && (whichType == TX_WITNESS_V0_KEYHASH || whichType == TX_WITNESS_V0_SCRIPTHASH))\n+        return false;\n+\n     return whichType != TX_NONSTANDARD;\n }\n \n-bool IsStandardTx(const CTransaction& tx, std::string& reason)\n+bool IsStandardTx(const CTransaction& tx, std::string& reason, const bool witnessEnabled)\n {\n     if (tx.nVersion > CTransaction::MAX_STANDARD_VERSION || tx.nVersion < 1) {\n         reason = \"version\";\n@@ -64,8 +67,8 @@ bool IsStandardTx(const CTransaction& tx, std::string& reason)\n     // almost as much to process as they cost the sender in fees, because\n     // computing signature hashes is O(ninputs*txsize). Limiting transactions\n     // to MAX_STANDARD_TX_SIZE mitigates CPU exhaustion attacks.\n-    unsigned int sz = GetTransactionCost(tx);\n-    if (sz >= MAX_STANDARD_TX_COST) {\n+    unsigned int sz = GetTransactionWeight(tx);\n+    if (sz >= MAX_STANDARD_TX_WEIGHT) {\n         reason = \"tx-size\";\n         return false;\n     }\n@@ -92,7 +95,7 @@ bool IsStandardTx(const CTransaction& tx, std::string& reason)\n     unsigned int nDataOut = 0;\n     txnouttype whichType;\n     BOOST_FOREACH(const CTxOut& txout, tx.vout) {\n-        if (!::IsStandard(txout.scriptPubKey, whichType)) {\n+        if (!::IsStandard(txout.scriptPubKey, whichType, witnessEnabled)) {\n             reason = \"scriptpubkey\";\n             return false;\n         }\n@@ -151,12 +154,14 @@ bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n     return true;\n }\n \n-int64_t GetVirtualTransactionSize(int64_t nCost)\n+unsigned int nBytesPerSigOp = DEFAULT_BYTES_PER_SIGOP;\n+\n+int64_t GetVirtualTransactionSize(int64_t nWeight, int64_t nSigOpCost)\n {\n-    return (nCost + WITNESS_SCALE_FACTOR - 1) / WITNESS_SCALE_FACTOR;\n+    return (std::max(nWeight, nSigOpCost * nBytesPerSigOp) + WITNESS_SCALE_FACTOR - 1) / WITNESS_SCALE_FACTOR;\n }\n \n-int64_t GetVirtualTransactionSize(const CTransaction& tx)\n+int64_t GetVirtualTransactionSize(const CTransaction& tx, int64_t nSigOpCost)\n {\n-    return GetVirtualTransactionSize(GetTransactionCost(tx));\n+    return GetVirtualTransactionSize(GetTransactionWeight(tx), nSigOpCost);\n }"
      },
      {
        "sha": "6bf5ca0ee5567d7272826a73b6a4d6b8291360b7",
        "filename": "src/policy/policy.h",
        "status": "modified",
        "additions": 14,
        "deletions": 11,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/policy/policy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/policy/policy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -14,21 +14,22 @@\n \n class CCoinsViewCache;\n \n-/** Default for -blockmaxsize and -blockminsize, which control the range of sizes the mining code will create **/\n+/** Default for -blockmaxsize, which controls the maximum size of block the mining code will create **/\n static const unsigned int DEFAULT_BLOCK_MAX_SIZE = 750000;\n-static const unsigned int DEFAULT_BLOCK_MIN_SIZE = 0;\n /** Default for -blockprioritysize, maximum space for zero/low-fee transactions **/\n static const unsigned int DEFAULT_BLOCK_PRIORITY_SIZE = 0;\n-/** Default for -blockmaxcost, which control the range of block costs the mining code will create **/\n-static const unsigned int DEFAULT_BLOCK_MAX_COST = 3000000;\n-/** The maximum size for transactions we're willing to relay/mine */\n-static const unsigned int MAX_STANDARD_TX_COST = 400000;\n+/** Default for -blockmaxweight, which controls the range of block weights the mining code will create **/\n+static const unsigned int DEFAULT_BLOCK_MAX_WEIGHT = 3000000;\n+/** The maximum weight for transactions we're willing to relay/mine */\n+static const unsigned int MAX_STANDARD_TX_WEIGHT = 400000;\n /** Maximum number of signature check operations in an IsStandard() P2SH script */\n static const unsigned int MAX_P2SH_SIGOPS = 15;\n /** The maximum number of sigops we're willing to relay/mine in a single tx */\n static const unsigned int MAX_STANDARD_TX_SIGOPS_COST = MAX_BLOCK_SIGOPS_COST/5;\n /** Default for -maxmempool, maximum megabytes of mempool memory usage */\n static const unsigned int DEFAULT_MAX_MEMPOOL_SIZE = 300;\n+/** Default for -bytespersigop */\n+static const unsigned int DEFAULT_BYTES_PER_SIGOP = 20;\n /**\n  * Standard script verification flags that standard transactions will comply\n  * with. However scripts violating these flags may still be present in valid\n@@ -54,21 +55,23 @@ static const unsigned int STANDARD_NOT_MANDATORY_VERIFY_FLAGS = STANDARD_SCRIPT_\n static const unsigned int STANDARD_LOCKTIME_VERIFY_FLAGS = LOCKTIME_VERIFY_SEQUENCE |\n                                                            LOCKTIME_MEDIAN_TIME_PAST;\n \n-bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType);\n+bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType, const bool witnessEnabled = false);\n     /**\n      * Check for standard transaction types\n      * @return True if all outputs (scriptPubKeys) use only standard transaction forms\n      */\n-bool IsStandardTx(const CTransaction& tx, std::string& reason);\n+bool IsStandardTx(const CTransaction& tx, std::string& reason, const bool witnessEnabled = false);\n     /**\n      * Check for standard transaction types\n      * @param[in] mapInputs    Map of previous transactions that have outputs we're spending\n      * @return True if all inputs (scriptSigs) use only standard transaction forms\n      */\n bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs);\n \n-/** Compute the virtual transaction size (cost reinterpreted as bytes). */\n-int64_t GetVirtualTransactionSize(int64_t nCost);\n-int64_t GetVirtualTransactionSize(const CTransaction& tx);\n+extern unsigned int nBytesPerSigOp;\n+\n+/** Compute the virtual transaction size (weight reinterpreted as bytes). */\n+int64_t GetVirtualTransactionSize(int64_t nWeight, int64_t nSigOpCost);\n+int64_t GetVirtualTransactionSize(const CTransaction& tx, int64_t nSigOpCost = 0);\n \n #endif // BITCOIN_POLICY_POLICY_H"
      },
      {
        "sha": "0e6ab4dd718b37f19c102e28eb5b3c821afb915e",
        "filename": "src/primitives/block.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/primitives/block.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/primitives/block.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/block.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -32,11 +32,11 @@ std::string CBlock::ToString() const\n     return s.str();\n }\n \n-int64_t GetBlockCost(const CBlock& block)\n+int64_t GetBlockWeight(const CBlock& block)\n {\n-    // This implements the cost = (stripped_size * 4) + witness_size formula,\n+    // This implements the weight = (stripped_size * 4) + witness_size formula,\n     // using only serialization with and without witness data. As witness_size\n     // is equal to total_size - stripped_size, this formula is identical to:\n-    // cost = (stripped_size * 3) + total_size.\n+    // weight = (stripped_size * 3) + total_size.\n     return ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION);\n }"
      },
      {
        "sha": "72dfed985ae937b3b37cd818df77a3f7dcafd8df",
        "filename": "src/primitives/block.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/primitives/block.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/primitives/block.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/block.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -154,7 +154,7 @@ struct CBlockLocator\n     }\n };\n \n-/** Compute the consensus-critical block cost (see BIP 141). */\n-int64_t GetBlockCost(const CBlock& tx);\n+/** Compute the consensus-critical block weight (see BIP 141). */\n+int64_t GetBlockWeight(const CBlock& tx);\n \n #endif // BITCOIN_PRIMITIVES_BLOCK_H"
      },
      {
        "sha": "8d6380564365e755db18d30a8c86616703f997b4",
        "filename": "src/primitives/transaction.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/primitives/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/primitives/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -121,7 +121,7 @@ unsigned int CTransaction::CalculateModifiedSize(unsigned int nTxSize) const\n     // Providing any more cleanup incentive than making additional inputs free would\n     // risk encouraging people to create junk outputs to redeem later.\n     if (nTxSize == 0)\n-        nTxSize = (GetTransactionCost(*this) + WITNESS_SCALE_FACTOR - 1) / WITNESS_SCALE_FACTOR;\n+        nTxSize = (GetTransactionWeight(*this) + WITNESS_SCALE_FACTOR - 1) / WITNESS_SCALE_FACTOR;\n     for (std::vector<CTxIn>::const_iterator it(vin.begin()); it != vin.end(); ++it)\n     {\n         unsigned int offset = 41U + std::min(110U, (unsigned int)it->scriptSig.size());\n@@ -149,7 +149,7 @@ std::string CTransaction::ToString() const\n     return str;\n }\n \n-int64_t GetTransactionCost(const CTransaction& tx)\n+int64_t GetTransactionWeight(const CTransaction& tx)\n {\n     return ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR -1) + ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n }"
      },
      {
        "sha": "5689d15bf7eb1892f7e36e82307077969bc8c26c",
        "filename": "src/primitives/transaction.h",
        "status": "modified",
        "additions": 7,
        "deletions": 5,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/primitives/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/primitives/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -290,6 +290,8 @@ struct CMutableTransaction;\n  */\n template<typename Stream, typename Operation, typename TxType>\n inline void SerializeTransaction(TxType& tx, Stream& s, Operation ser_action, int nType, int nVersion) {\n+    const bool fAllowWitness = !(nVersion & SERIALIZE_TRANSACTION_NO_WITNESS);\n+\n     READWRITE(*const_cast<int32_t*>(&tx.nVersion));\n     unsigned char flags = 0;\n     if (ser_action.ForRead()) {\n@@ -298,7 +300,7 @@ inline void SerializeTransaction(TxType& tx, Stream& s, Operation ser_action, in\n         const_cast<CTxWitness*>(&tx.wit)->SetNull();\n         /* Try to read the vin. In case the dummy is there, this will be read as an empty vector. */\n         READWRITE(*const_cast<std::vector<CTxIn>*>(&tx.vin));\n-        if (tx.vin.size() == 0 && !(nVersion & SERIALIZE_TRANSACTION_NO_WITNESS)) {\n+        if (tx.vin.size() == 0 && fAllowWitness) {\n             /* We read a dummy or an empty vin. */\n             READWRITE(flags);\n             if (flags != 0) {\n@@ -309,7 +311,7 @@ inline void SerializeTransaction(TxType& tx, Stream& s, Operation ser_action, in\n             /* We read a non-empty vin. Assume a normal vout follows. */\n             READWRITE(*const_cast<std::vector<CTxOut>*>(&tx.vout));\n         }\n-        if ((flags & 1) && !(nVersion & SERIALIZE_TRANSACTION_NO_WITNESS)) {\n+        if ((flags & 1) && fAllowWitness) {\n             /* The witness flag is present, and we support witnesses. */\n             flags ^= 1;\n             const_cast<CTxWitness*>(&tx.wit)->vtxinwit.resize(tx.vin.size());\n@@ -322,7 +324,7 @@ inline void SerializeTransaction(TxType& tx, Stream& s, Operation ser_action, in\n     } else {\n         // Consistency check\n         assert(tx.wit.vtxinwit.size() <= tx.vin.size());\n-        if (!(nVersion & SERIALIZE_TRANSACTION_NO_WITNESS)) {\n+        if (fAllowWitness) {\n             /* Check whether witnesses need to be serialized. */\n             if (!tx.wit.IsNull()) {\n                 flags |= 1;\n@@ -459,7 +461,7 @@ struct CMutableTransaction\n     uint256 GetHash() const;\n };\n \n-/** Compute the cost of a transaction, as defined by BIP 141 */\n-int64_t GetTransactionCost(const CTransaction &tx);\n+/** Compute the weight of a transaction, as defined by BIP 141 */\n+int64_t GetTransactionWeight(const CTransaction &tx);\n \n #endif // BITCOIN_PRIMITIVES_TRANSACTION_H"
      },
      {
        "sha": "015215b2a668b2757db2a0718062fda7d1d3d171",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -10,7 +10,7 @@\n #ifndef BITCOIN_PROTOCOL_H\n #define BITCOIN_PROTOCOL_H\n \n-#include \"netbase.h\"\n+#include \"netaddress.h\"\n #include \"serialize.h\"\n #include \"uint256.h\"\n #include \"version.h\""
      },
      {
        "sha": "aebfdbc82662880a21cb4ea95b874dd34dace94c",
        "filename": "src/pubkey.h",
        "status": "modified",
        "additions": 7,
        "deletions": 4,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/pubkey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/pubkey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -13,7 +13,7 @@\n #include <stdexcept>\n #include <vector>\n \n-/** \n+/**\n  * secp256k1:\n  * const unsigned int PRIVATE_KEY_SIZE = 279;\n  * const unsigned int PUBLIC_KEY_SIZE  = 65;\n@@ -156,7 +156,7 @@ class CPubKey\n \n     /*\n      * Check syntactic correctness.\n-     * \n+     *\n      * Note that this is consensus critical as CheckSig() calls it!\n      */\n     bool IsValid() const\n@@ -203,8 +203,11 @@ struct CExtPubKey {\n \n     friend bool operator==(const CExtPubKey &a, const CExtPubKey &b)\n     {\n-        return a.nDepth == b.nDepth && memcmp(&a.vchFingerprint[0], &b.vchFingerprint[0], 4) == 0 && a.nChild == b.nChild &&\n-               a.chaincode == b.chaincode && a.pubkey == b.pubkey;\n+        return a.nDepth == b.nDepth &&\n+            memcmp(&a.vchFingerprint[0], &b.vchFingerprint[0], sizeof(vchFingerprint)) == 0 &&\n+            a.nChild == b.nChild &&\n+            a.chaincode == b.chaincode &&\n+            a.pubkey == b.pubkey;\n     }\n \n     void Encode(unsigned char code[BIP32_EXTKEY_SIZE]) const;"
      },
      {
        "sha": "e3c32d905af74a0b2f307fc53694eb61f1c8d930",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 22,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -101,7 +101,7 @@ UniValue blockToJSON(const CBlock& block, const CBlockIndex* blockindex, bool tx\n     result.push_back(Pair(\"confirmations\", confirmations));\n     result.push_back(Pair(\"strippedsize\", (int)::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS)));\n     result.push_back(Pair(\"size\", (int)::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION)));\n-    result.push_back(Pair(\"cost\", (int)::GetBlockCost(block)));\n+    result.push_back(Pair(\"weight\", (int)::GetBlockWeight(block)));\n     result.push_back(Pair(\"height\", blockindex->nHeight));\n     result.push_back(Pair(\"version\", block.nVersion));\n     result.push_back(Pair(\"versionHex\", strprintf(\"%08x\", block.nVersion)));\n@@ -559,7 +559,7 @@ UniValue getblock(const UniValue& params, bool fHelp)\n             \"  \\\"confirmations\\\" : n,   (numeric) The number of confirmations, or -1 if the block is not on the main chain\\n\"\n             \"  \\\"size\\\" : n,            (numeric) The block size\\n\"\n             \"  \\\"strippedsize\\\" : n,    (numeric) The block size excluding witness data\\n\"\n-            \"  \\\"cost\\\" : n             (numeric) The block cost\\n\"\n+            \"  \\\"weight\\\" : n           (numeric) The block weight (BIP 141)\\n\"\n             \"  \\\"height\\\" : n,          (numeric) The block height or index\\n\"\n             \"  \\\"version\\\" : n,         (numeric) The block version\\n\"\n             \"  \\\"versionHex\\\" : \\\"00000000\\\", (string) The block version formatted in hexadecimal\\n\"\n@@ -817,22 +817,23 @@ UniValue verifychain(const UniValue& params, bool fHelp)\n }\n \n /** Implementation of IsSuperMajority with better feedback */\n-static UniValue SoftForkMajorityDesc(int minVersion, CBlockIndex* pindex, int nRequired, const Consensus::Params& consensusParams)\n+static UniValue SoftForkMajorityDesc(int version, CBlockIndex* pindex, const Consensus::Params& consensusParams)\n {\n-    int nFound = 0;\n-    CBlockIndex* pstart = pindex;\n-    for (int i = 0; i < consensusParams.nMajorityWindow && pstart != NULL; i++)\n+    UniValue rv(UniValue::VOBJ);\n+    bool activated = false;\n+    switch(version)\n     {\n-        if (pstart->nVersion >= minVersion)\n-            ++nFound;\n-        pstart = pstart->pprev;\n+        case 2:\n+            activated = pindex->nHeight >= consensusParams.BIP34Height;\n+            break;\n+        case 3:\n+            activated = pindex->nHeight >= consensusParams.BIP66Height;\n+            break;\n+        case 4:\n+            activated = pindex->nHeight >= consensusParams.BIP65Height;\n+            break;\n     }\n-\n-    UniValue rv(UniValue::VOBJ);\n-    rv.push_back(Pair(\"status\", nFound >= nRequired));\n-    rv.push_back(Pair(\"found\", nFound));\n-    rv.push_back(Pair(\"required\", nRequired));\n-    rv.push_back(Pair(\"window\", consensusParams.nMajorityWindow));\n+    rv.push_back(Pair(\"status\", activated));\n     return rv;\n }\n \n@@ -841,8 +842,7 @@ static UniValue SoftForkDesc(const std::string &name, int version, CBlockIndex*\n     UniValue rv(UniValue::VOBJ);\n     rv.push_back(Pair(\"id\", name));\n     rv.push_back(Pair(\"version\", version));\n-    rv.push_back(Pair(\"enforce\", SoftForkMajorityDesc(version, pindex, consensusParams.nMajorityEnforceBlockUpgrade, consensusParams)));\n-    rv.push_back(Pair(\"reject\", SoftForkMajorityDesc(version, pindex, consensusParams.nMajorityRejectBlockOutdated, consensusParams)));\n+    rv.push_back(Pair(\"reject\", SoftForkMajorityDesc(version, pindex, consensusParams)));\n     return rv;\n }\n \n@@ -897,13 +897,9 @@ UniValue getblockchaininfo(const UniValue& params, bool fHelp)\n             \"     {\\n\"\n             \"        \\\"id\\\": \\\"xxxx\\\",        (string) name of softfork\\n\"\n             \"        \\\"version\\\": xx,         (numeric) block version\\n\"\n-            \"        \\\"enforce\\\": {           (object) progress toward enforcing the softfork rules for new-version blocks\\n\"\n+            \"        \\\"reject\\\": {            (object) progress toward rejecting pre-softfork blocks\\n\"\n             \"           \\\"status\\\": xx,       (boolean) true if threshold reached\\n\"\n-            \"           \\\"found\\\": xx,        (numeric) number of blocks with the new version found\\n\"\n-            \"           \\\"required\\\": xx,     (numeric) number of blocks required to trigger\\n\"\n-            \"           \\\"window\\\": xx,       (numeric) maximum size of examined window of recent blocks\\n\"\n             \"        },\\n\"\n-            \"        \\\"reject\\\": { ... }      (object) progress toward rejecting pre-softfork blocks (same fields as \\\"enforce\\\")\\n\"\n             \"     }, ...\\n\"\n             \"  ],\\n\"\n             \"  \\\"bip9_softforks\\\": {          (object) status of BIP9 softforks in progress\\n\""
      },
      {
        "sha": "6d88d4bec8147cb1d3f994a18f1512c20d26355c",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 9,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -224,7 +224,7 @@ UniValue getmininginfo(const UniValue& params, bool fHelp)\n             \"{\\n\"\n             \"  \\\"blocks\\\": nnn,             (numeric) The current block\\n\"\n             \"  \\\"currentblocksize\\\": nnn,   (numeric) The last block size\\n\"\n-            \"  \\\"currentblockcost\\\": nnn,   (numeric) The last block cost\\n\"\n+            \"  \\\"currentblockweight\\\": nnn, (numeric) The last block weight\\n\"\n             \"  \\\"currentblocktx\\\": nnn,     (numeric) The last block transaction\\n\"\n             \"  \\\"difficulty\\\": xxx.xxxxx    (numeric) The current difficulty\\n\"\n             \"  \\\"errors\\\": \\\"...\\\"          (string) Current errors\\n\"\n@@ -243,7 +243,7 @@ UniValue getmininginfo(const UniValue& params, bool fHelp)\n     UniValue obj(UniValue::VOBJ);\n     obj.push_back(Pair(\"blocks\",           (int)chainActive.Height()));\n     obj.push_back(Pair(\"currentblocksize\", (uint64_t)nLastBlockSize));\n-    obj.push_back(Pair(\"currentblockcost\", (uint64_t)nLastBlockCost));\n+    obj.push_back(Pair(\"currentblockweight\", (uint64_t)nLastBlockWeight));\n     obj.push_back(Pair(\"currentblocktx\",   (uint64_t)nLastBlockTx));\n     obj.push_back(Pair(\"difficulty\",       (double)GetDifficulty()));\n     obj.push_back(Pair(\"errors\",           GetWarnings(\"statusbar\")));\n@@ -358,7 +358,7 @@ UniValue getblocktemplate(const UniValue& params, bool fHelp)\n             \"         ],\\n\"\n             \"         \\\"fee\\\": n,                   (numeric) difference in value between transaction inputs and outputs (in Satoshis); for coinbase transactions, this is a negative Number of the total collected block fees (ie, not including the block subsidy); if key is not present, fee is unknown and clients MUST NOT assume there isn't one\\n\"\n             \"         \\\"sigops\\\" : n,               (numeric) total SigOps cost, as counted for purposes of block limits; if key is not present, sigop cost is unknown and clients MUST NOT assume it is zero\\n\"\n-            \"         \\\"cost\\\" : n,                 (numeric) total transaction size cost, as counted for purposes of block limits\\n\"\n+            \"         \\\"weight\\\" : n,               (numeric) total transaction weight, as counted for purposes of block limits\\n\"\n             \"         \\\"required\\\" : true|false     (boolean) if provided and true, this transaction must be in the final block\\n\"\n             \"      }\\n\"\n             \"      ,...\\n\"\n@@ -377,7 +377,7 @@ UniValue getblocktemplate(const UniValue& params, bool fHelp)\n             \"  \\\"noncerange\\\" : \\\"00000000ffffffff\\\",   (string) A range of valid nonces\\n\"\n             \"  \\\"sigoplimit\\\" : n,                 (numeric) cost limit of sigops in blocks\\n\"\n             \"  \\\"sizelimit\\\" : n,                  (numeric) limit of block size\\n\"\n-            \"  \\\"costlimit\\\" : n,                  (numeric) limit of block cost\\n\"\n+            \"  \\\"weightlimit\\\" : n,                (numeric) limit of block weight\\n\"\n             \"  \\\"curtime\\\" : ttt,                  (numeric) current timestamp in seconds since epoch (Jan 1 1970 GMT)\\n\"\n             \"  \\\"bits\\\" : \\\"xxx\\\",                 (string) compressed target of next block\\n\"\n             \"  \\\"height\\\" : n                      (numeric) The height of the next block\\n\"\n@@ -546,6 +546,9 @@ UniValue getblocktemplate(const UniValue& params, bool fHelp)\n     UpdateTime(pblock, consensusParams, pindexPrev);\n     pblock->nNonce = 0;\n \n+    // NOTE: If at some point we support pre-segwit miners post-segwit-activation, this needs to take segwit support into consideration\n+    const bool fPreSegWit = (THRESHOLD_ACTIVE != VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_SEGWIT, versionbitscache));\n+\n     UniValue aCaps(UniValue::VARR); aCaps.push_back(\"proposal\");\n \n     UniValue transactions(UniValue::VARR);\n@@ -574,8 +577,13 @@ UniValue getblocktemplate(const UniValue& params, bool fHelp)\n \n         int index_in_template = i - 1;\n         entry.push_back(Pair(\"fee\", pblocktemplate->vTxFees[index_in_template]));\n-        entry.push_back(Pair(\"sigops\", pblocktemplate->vTxSigOpsCost[index_in_template]));\n-        entry.push_back(Pair(\"cost\", GetTransactionCost(tx)));\n+        int64_t nTxSigOps = pblocktemplate->vTxSigOpsCost[index_in_template];\n+        if (fPreSegWit) {\n+            assert(nTxSigOps % WITNESS_SCALE_FACTOR == 0);\n+            nTxSigOps /= WITNESS_SCALE_FACTOR;\n+        }\n+        entry.push_back(Pair(\"sigops\", nTxSigOps));\n+        entry.push_back(Pair(\"weight\", GetTransactionWeight(tx)));\n \n         transactions.push_back(entry);\n     }\n@@ -642,7 +650,7 @@ UniValue getblocktemplate(const UniValue& params, bool fHelp)\n \n     if (nMaxVersionPreVB >= 2) {\n         // If VB is supported by the client, nMaxVersionPreVB is -1, so we won't get here\n-        // Because BIP 34 changed how the generation transaction is serialised, we can only use version/force back to v2 blocks\n+        // Because BIP 34 changed how the generation transaction is serialized, we can only use version/force back to v2 blocks\n         // This is safe to do [otherwise-]unconditionally only because we are throwing an exception above if a non-force deployment gets activated\n         // Note that this can probably also be removed entirely after the first BIP9 non-force deployment (ie, probably segwit) gets activated\n         aMutable.push_back(\"version/force\");\n@@ -657,9 +665,14 @@ UniValue getblocktemplate(const UniValue& params, bool fHelp)\n     result.push_back(Pair(\"mintime\", (int64_t)pindexPrev->GetMedianTimePast()+1));\n     result.push_back(Pair(\"mutable\", aMutable));\n     result.push_back(Pair(\"noncerange\", \"00000000ffffffff\"));\n-    result.push_back(Pair(\"sigoplimit\", (int64_t)MAX_BLOCK_SIGOPS_COST));\n+    int64_t nSigOpLimit = MAX_BLOCK_SIGOPS_COST;\n+    if (fPreSegWit) {\n+        assert(nSigOpLimit % WITNESS_SCALE_FACTOR == 0);\n+        nSigOpLimit /= WITNESS_SCALE_FACTOR;\n+    }\n+    result.push_back(Pair(\"sigoplimit\", nSigOpLimit));\n     result.push_back(Pair(\"sizelimit\", (int64_t)MAX_BLOCK_SERIALIZED_SIZE));\n-    result.push_back(Pair(\"costlimit\", (int64_t)MAX_BLOCK_COST));\n+    result.push_back(Pair(\"weightlimit\", (int64_t)MAX_BLOCK_WEIGHT));\n     result.push_back(Pair(\"curtime\", pblock->GetBlockTime()));\n     result.push_back(Pair(\"bits\", strprintf(\"%08x\", pblock->nBits)));\n     result.push_back(Pair(\"height\", (int64_t)(pindexPrev->nHeight+1)));"
      },
      {
        "sha": "a8c5bcd177fbc8ddacd296f41d52d423e4fe5b9b",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -166,6 +166,8 @@ UniValue validateaddress(const UniValue& params, bool fHelp)\n             \"  \\\"pubkey\\\" : \\\"publickeyhex\\\",    (string) The hex value of the raw public key\\n\"\n             \"  \\\"iscompressed\\\" : true|false,  (boolean) If the address is compressed\\n\"\n             \"  \\\"account\\\" : \\\"account\\\"         (string) DEPRECATED. The account associated with the address, \\\"\\\" is the default account\\n\"\n+            \"  \\\"hdkeypath\\\" : \\\"keypath\\\"       (string, optional) The HD keypath if the key is HD and available\\n\"\n+            \"  \\\"hdmasterkeyid\\\" : \\\"<hash160>\\\" (string, optional) The Hash160 of the HD master pubkey\\n\"\n             \"}\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"validateaddress\", \"\\\"1PSSGeFHDnKNxiEyFrD1wcEaHr9hrQDDWc\\\"\")\n@@ -200,6 +202,12 @@ UniValue validateaddress(const UniValue& params, bool fHelp)\n         ret.pushKVs(detail);\n         if (pwalletMain && pwalletMain->mapAddressBook.count(dest))\n             ret.push_back(Pair(\"account\", pwalletMain->mapAddressBook[dest].name));\n+        CKeyID keyID;\n+        if (pwalletMain && address.GetKeyID(keyID) && pwalletMain->mapKeyMetadata.count(keyID) && !pwalletMain->mapKeyMetadata[keyID].hdKeypath.empty())\n+        {\n+            ret.push_back(Pair(\"hdkeypath\", pwalletMain->mapKeyMetadata[keyID].hdKeypath));\n+            ret.push_back(Pair(\"hdmasterkeyid\", pwalletMain->mapKeyMetadata[keyID].hdMasterKeyID.GetHex()));\n+        }\n #endif\n     }\n     return ret;"
      },
      {
        "sha": "4ce122648b939c560d2dc22cecffa9f97a347589",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 4,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -484,7 +484,7 @@ UniValue setban(const UniValue& params, bool fHelp)\n                             \"\\nExamples:\\n\"\n                             + HelpExampleCli(\"setban\", \"\\\"192.168.0.6\\\" \\\"add\\\" 86400\")\n                             + HelpExampleCli(\"setban\", \"\\\"192.168.0.0/24\\\" \\\"add\\\"\")\n-                            + HelpExampleRpc(\"setban\", \"\\\"192.168.0.6\\\", \\\"add\\\" 86400\")\n+                            + HelpExampleRpc(\"setban\", \"\\\"192.168.0.6\\\", \\\"add\\\", 86400\")\n                             );\n \n     CSubNet subNet;\n@@ -494,10 +494,13 @@ UniValue setban(const UniValue& params, bool fHelp)\n     if (params[0].get_str().find(\"/\") != string::npos)\n         isSubnet = true;\n \n-    if (!isSubnet)\n-        netAddr = CNetAddr(params[0].get_str());\n+    if (!isSubnet) {\n+        CNetAddr resolved;\n+        LookupHost(params[0].get_str().c_str(), resolved, false);\n+        netAddr = resolved;\n+    }\n     else\n-        subNet = CSubNet(params[0].get_str());\n+        LookupSubNet(params[0].get_str().c_str(), subNet);\n \n     if (! (isSubnet ? subNet.IsValid() : netAddr.IsValid()) )\n         throw JSONRPCError(RPC_CLIENT_NODE_ALREADY_ADDED, \"Error: Invalid IP/Subnet\");"
      },
      {
        "sha": "5fb97f7496217312d346e1f5c0b5e5a30e27c1a2",
        "filename": "src/rpc/server.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/rpc/server.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/rpc/server.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -25,6 +25,8 @@\n #include <boost/thread.hpp>\n #include <boost/algorithm/string/case_conv.hpp> // for to_upper()\n \n+#include <memory> // for unique_ptr\n+\n using namespace RPCServer;\n using namespace std;\n \n@@ -34,9 +36,8 @@ static std::string rpcWarmupStatus(\"RPC server started\");\n static CCriticalSection cs_rpcWarmup;\n /* Timer-creating functions */\n static RPCTimerInterface* timerInterface = NULL;\n-/* Map of name to timer.\n- * @note Can be changed to std::unique_ptr when C++11 */\n-static std::map<std::string, boost::shared_ptr<RPCTimerBase> > deadlineTimers;\n+/* Map of name to timer. */\n+static std::map<std::string, std::unique_ptr<RPCTimerBase> > deadlineTimers;\n \n static struct CRPCSignals\n {\n@@ -490,7 +491,7 @@ void RPCRunLater(const std::string& name, boost::function<void(void)> func, int6\n         throw JSONRPCError(RPC_INTERNAL_ERROR, \"No timer handler registered for RPC\");\n     deadlineTimers.erase(name);\n     LogPrint(\"rpc\", \"queue run of timer %s in %i seconds (using %s)\\n\", name, nSeconds, timerInterface->Name());\n-    deadlineTimers.insert(std::make_pair(name, boost::shared_ptr<RPCTimerBase>(timerInterface->NewTimer(func, nSeconds*1000))));\n+    deadlineTimers.emplace(name, std::unique_ptr<RPCTimerBase>(timerInterface->NewTimer(func, nSeconds*1000)));\n }\n \n CRPCTable tableRPC;"
      },
      {
        "sha": "f73a8e30bc6c488ccb48f5756d758bfa32fb020e",
        "filename": "src/script/bitcoinconsensus.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/script/bitcoinconsensus.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/script/bitcoinconsensus.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/bitcoinconsensus.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -51,6 +51,7 @@ enum\n     bitcoinconsensus_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), // evaluate P2SH (BIP16) subscripts\n     bitcoinconsensus_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), // enforce strict DER (BIP66) compliance\n     bitcoinconsensus_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), // enable CHECKLOCKTIMEVERIFY (BIP65)\n+    bitcoinconsensus_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), // enable CHECKSEQUENCEVERIFY (BIP112)\n     bitcoinconsensus_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), // enable WITNESS (BIP141)\n };\n "
      },
      {
        "sha": "efb277d3470657ab7ebef58ffe7687feb57de3c8",
        "filename": "src/secp256k1/.gitignore",
        "status": "modified",
        "additions": 13,
        "deletions": 6,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.gitignore?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -25,17 +25,24 @@ config.status\n libtool\n .deps/\n .dirstamp\n-build-aux/\n *.lo\n *.o\n *~\n src/libsecp256k1-config.h\n src/libsecp256k1-config.h.in\n src/ecmult_static_context.h\n-m4/libtool.m4\n-m4/ltoptions.m4\n-m4/ltsugar.m4\n-m4/ltversion.m4\n-m4/lt~obsolete.m4\n+build-aux/config.guess\n+build-aux/config.sub\n+build-aux/depcomp\n+build-aux/install-sh\n+build-aux/ltmain.sh\n+build-aux/m4/libtool.m4\n+build-aux/m4/lt~obsolete.m4\n+build-aux/m4/ltoptions.m4\n+build-aux/m4/ltsugar.m4\n+build-aux/m4/ltversion.m4\n+build-aux/missing\n+build-aux/compile\n+build-aux/test-driver\n src/stamp-h1\n libsecp256k1.pc"
      },
      {
        "sha": "2c5c63adadcb193b73d3302d78136c3ab6826674",
        "filename": "src/secp256k1/.travis.yml",
        "status": "modified",
        "additions": 13,
        "deletions": 6,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.travis.yml?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -6,26 +6,31 @@ addons:\n compiler:\n   - clang\n   - gcc\n+cache:\n+  directories:\n+  - src/java/guava/\n env:\n   global:\n-    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  schnorr=no  RECOVERY=no\n+    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  schnorr=no  RECOVERY=no  EXPERIMENTAL=no\n+    - GUAVA_URL=https://search.maven.org/remotecontent?filepath=com/google/guava/guava/18.0/guava-18.0.jar GUAVA_JAR=src/java/guava/guava-18.0.jar\n   matrix:\n     - SCALAR=32bit    RECOVERY=yes\n-    - SCALAR=32bit    FIELD=32bit       ECDH=yes\n+    - SCALAR=32bit    FIELD=32bit       ECDH=yes  EXPERIMENTAL=yes\n     - SCALAR=64bit\n     - FIELD=64bit     RECOVERY=yes\n     - FIELD=64bit     ENDOMORPHISM=yes\n-    - FIELD=64bit     ENDOMORPHISM=yes  ECDH=yes\n+    - FIELD=64bit     ENDOMORPHISM=yes  ECDH=yes EXPERIMENTAL=yes\n     - FIELD=64bit                       ASM=x86_64\n     - FIELD=64bit     ENDOMORPHISM=yes  ASM=x86_64\n-    - FIELD=32bit     SCHNORR=yes\n+    - FIELD=32bit     SCHNORR=yes EXPERIMENTAL=yes\n     - FIELD=32bit     ENDOMORPHISM=yes\n     - BIGNUM=no\n-    - BIGNUM=no       ENDOMORPHISM=yes SCHNORR=yes  RECOVERY=yes\n+    - BIGNUM=no       ENDOMORPHISM=yes SCHNORR=yes  RECOVERY=yes EXPERIMENTAL=yes\n     - BIGNUM=no       STATICPRECOMPUTATION=no\n     - BUILD=distcheck\n     - EXTRAFLAGS=CPPFLAGS=-DDETERMINISTIC\n     - EXTRAFLAGS=CFLAGS=-O0\n+    - BUILD=check-java ECDH=yes SCHNORR=yes EXPERIMENTAL=yes\n matrix:\n   fast_finish: true\n   include:\n@@ -55,9 +60,11 @@ matrix:\n           packages:\n             - gcc-multilib\n             - libgmp-dev:i386\n+before_install: mkdir -p `dirname $GUAVA_JAR`\n+install: if [ ! -f $GUAVA_JAR ]; then wget $GUAVA_URL -O $GUAVA_JAR; fi\n before_script: ./autogen.sh\n script:\n  - if [ -n \"$HOST\" ]; then export USE_HOST=\"--host=$HOST\"; fi\n  - if [ \"x$HOST\" = \"xi686-linux-gnu\" ]; then export CC=\"$CC -m32\"; fi\n- - ./configure --enable-endomorphism=$ENDOMORPHISM --with-field=$FIELD --with-bignum=$BIGNUM --with-scalar=$SCALAR --enable-ecmult-static-precomputation=$STATICPRECOMPUTATION --enable-module-ecdh=$ECDH --enable-module-schnorr=$SCHNORR --enable-module-recovery=$RECOVERY $EXTRAFLAGS $USE_HOST && make -j2 $BUILD\n+ - ./configure --enable-experimental=$EXPERIMENTAL --enable-endomorphism=$ENDOMORPHISM --with-field=$FIELD --with-bignum=$BIGNUM --with-scalar=$SCALAR --enable-ecmult-static-precomputation=$STATICPRECOMPUTATION --enable-module-ecdh=$ECDH --enable-module-schnorr=$SCHNORR --enable-module-recovery=$RECOVERY $EXTRAFLAGS $USE_HOST && make -j2 $BUILD\n os: linux"
      },
      {
        "sha": "3d130bdcbd71784fa6f7bbd039bb732131d28f7c",
        "filename": "src/secp256k1/Makefile.am",
        "status": "modified",
        "additions": 62,
        "deletions": 10,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/Makefile.am?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -1,6 +1,12 @@\n ACLOCAL_AMFLAGS = -I build-aux/m4\n \n lib_LTLIBRARIES = libsecp256k1.la\n+if USE_JNI\n+JNI_LIB = libsecp256k1_jni.la\n+noinst_LTLIBRARIES = $(JNI_LIB)\n+else\n+JNI_LIB =\n+endif\n include_HEADERS = include/secp256k1.h\n noinst_HEADERS =\n noinst_HEADERS += src/scalar.h\n@@ -32,6 +38,7 @@ noinst_HEADERS += src/field_5x52_impl.h\n noinst_HEADERS += src/field_5x52_int128_impl.h\n noinst_HEADERS += src/field_5x52_asm_impl.h\n noinst_HEADERS += src/java/org_bitcoin_NativeSecp256k1.h\n+noinst_HEADERS += src/java/org_bitcoin_Secp256k1Context.h\n noinst_HEADERS += src/util.h\n noinst_HEADERS += src/testrand.h\n noinst_HEADERS += src/testrand_impl.h\n@@ -45,35 +52,80 @@ noinst_HEADERS += contrib/lax_der_parsing.c\n noinst_HEADERS += contrib/lax_der_privatekey_parsing.h\n noinst_HEADERS += contrib/lax_der_privatekey_parsing.c\n \n+if USE_EXTERNAL_ASM\n+COMMON_LIB = libsecp256k1_common.la\n+noinst_LTLIBRARIES = $(COMMON_LIB)\n+else\n+COMMON_LIB =\n+endif\n+\n pkgconfigdir = $(libdir)/pkgconfig\n pkgconfig_DATA = libsecp256k1.pc\n \n+if USE_EXTERNAL_ASM\n+if USE_ASM_ARM\n+libsecp256k1_common_la_SOURCES = src/asm/field_10x26_arm.s\n+endif\n+endif\n+\n libsecp256k1_la_SOURCES = src/secp256k1.c\n-libsecp256k1_la_CPPFLAGS = -I$(top_srcdir)/include -I$(top_srcdir)/src $(SECP_INCLUDES)\n-libsecp256k1_la_LIBADD = $(SECP_LIBS)\n+libsecp256k1_la_CPPFLAGS = -DSECP256K1_BUILD -I$(top_srcdir)/include -I$(top_srcdir)/src $(SECP_INCLUDES)\n+libsecp256k1_la_LIBADD = $(JNI_LIB) $(SECP_LIBS) $(COMMON_LIB)\n \n+libsecp256k1_jni_la_SOURCES  = src/java/org_bitcoin_NativeSecp256k1.c src/java/org_bitcoin_Secp256k1Context.c\n+libsecp256k1_jni_la_CPPFLAGS = -DSECP256K1_BUILD $(JNI_INCLUDES)\n \n noinst_PROGRAMS =\n if USE_BENCHMARK\n noinst_PROGRAMS += bench_verify bench_sign bench_internal\n bench_verify_SOURCES = src/bench_verify.c\n-bench_verify_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_verify_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n bench_sign_SOURCES = src/bench_sign.c\n-bench_sign_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_sign_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n bench_internal_SOURCES = src/bench_internal.c\n-bench_internal_LDADD = $(SECP_LIBS)\n-bench_internal_CPPFLAGS = $(SECP_INCLUDES)\n+bench_internal_LDADD = $(SECP_LIBS) $(COMMON_LIB)\n+bench_internal_CPPFLAGS = -DSECP256K1_BUILD $(SECP_INCLUDES)\n endif\n \n if USE_TESTS\n noinst_PROGRAMS += tests\n tests_SOURCES = src/tests.c\n-tests_CPPFLAGS = -DVERIFY -I$(top_srcdir)/src -I$(top_srcdir)/include $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n-tests_LDADD = $(SECP_LIBS) $(SECP_TEST_LIBS)\n+tests_CPPFLAGS = -DSECP256K1_BUILD -DVERIFY -I$(top_srcdir)/src -I$(top_srcdir)/include $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n+tests_LDADD = $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n tests_LDFLAGS = -static\n TESTS = tests\n endif\n \n+JAVAROOT=src/java\n+JAVAORG=org/bitcoin\n+JAVA_GUAVA=$(srcdir)/$(JAVAROOT)/guava/guava-18.0.jar\n+CLASSPATH_ENV=CLASSPATH=$(JAVA_GUAVA)\n+JAVA_FILES= \\\n+  $(JAVAROOT)/$(JAVAORG)/NativeSecp256k1.java \\\n+  $(JAVAROOT)/$(JAVAORG)/NativeSecp256k1Test.java \\\n+  $(JAVAROOT)/$(JAVAORG)/NativeSecp256k1Util.java \\\n+  $(JAVAROOT)/$(JAVAORG)/Secp256k1Context.java\n+\n+if USE_JNI\n+\n+$(JAVA_GUAVA):\n+\t@echo Guava is missing. Fetch it via: \\\n+\twget https://search.maven.org/remotecontent?filepath=com/google/guava/guava/18.0/guava-18.0.jar -O $(@)\n+\t@false\n+\n+.stamp-java: $(JAVA_FILES)\n+\t@echo   Compiling $^\n+\t$(AM_V_at)$(CLASSPATH_ENV) javac $^\n+\t@touch $@\n+\n+if USE_TESTS\n+\n+check-java: libsecp256k1.la $(JAVA_GUAVA) .stamp-java\n+\t$(AM_V_at)java -Djava.library.path=\"./:./src:./src/.libs:.libs/\" -cp \"$(JAVA_GUAVA):$(JAVAROOT)\" $(JAVAORG)/NativeSecp256k1Test\n+\n+endif\n+endif\n+\n if USE_ECMULT_STATIC_PRECOMPUTATION\n CPPFLAGS_FOR_BUILD +=-I$(top_srcdir)\n CFLAGS_FOR_BUILD += -Wall -Wextra -Wno-unused-function\n@@ -93,10 +145,10 @@ $(bench_internal_OBJECTS): src/ecmult_static_context.h\n src/ecmult_static_context.h: $(gen_context_BIN)\n \t./$(gen_context_BIN)\n \n-CLEANFILES = $(gen_context_BIN) src/ecmult_static_context.h\n+CLEANFILES = $(gen_context_BIN) src/ecmult_static_context.h $(JAVAROOT)/$(JAVAORG)/*.class .stamp-java\n endif\n \n-EXTRA_DIST = autogen.sh src/gen_context.c src/basic-config.h\n+EXTRA_DIST = autogen.sh src/gen_context.c src/basic-config.h $(JAVA_FILES)\n \n if ENABLE_MODULE_ECDH\n include src/modules/ecdh/Makefile.am.include"
      },
      {
        "sha": "8cd344ea81232413cf9004bc50dec4ec2fe112a6",
        "filename": "src/secp256k1/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/README.md?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -1,7 +1,7 @@\n libsecp256k1\n ============\n \n-[![Build Status](https://travis-ci.org/bitcoin/secp256k1.svg?branch=master)](https://travis-ci.org/bitcoin/secp256k1)\n+[![Build Status](https://travis-ci.org/bitcoin-core/secp256k1.svg?branch=master)](https://travis-ci.org/bitcoin-core/secp256k1)\n \n Optimized C library for EC operations on curve secp256k1.\n "
      },
      {
        "sha": "1fc36276144a2fb7740c436bd53f09f42b12daff",
        "filename": "src/secp256k1/build-aux/m4/ax_jni_include_dir.m4",
        "status": "added",
        "additions": 140,
        "deletions": 0,
        "changes": 140,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/build-aux/m4/ax_jni_include_dir.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/build-aux/m4/ax_jni_include_dir.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/build-aux/m4/ax_jni_include_dir.m4?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -0,0 +1,140 @@\n+# ===========================================================================\n+#    http://www.gnu.org/software/autoconf-archive/ax_jni_include_dir.html\n+# ===========================================================================\n+#\n+# SYNOPSIS\n+#\n+#   AX_JNI_INCLUDE_DIR\n+#\n+# DESCRIPTION\n+#\n+#   AX_JNI_INCLUDE_DIR finds include directories needed for compiling\n+#   programs using the JNI interface.\n+#\n+#   JNI include directories are usually in the Java distribution. This is\n+#   deduced from the value of $JAVA_HOME, $JAVAC, or the path to \"javac\", in\n+#   that order. When this macro completes, a list of directories is left in\n+#   the variable JNI_INCLUDE_DIRS.\n+#\n+#   Example usage follows:\n+#\n+#     AX_JNI_INCLUDE_DIR\n+#\n+#     for JNI_INCLUDE_DIR in $JNI_INCLUDE_DIRS\n+#     do\n+#             CPPFLAGS=\"$CPPFLAGS -I$JNI_INCLUDE_DIR\"\n+#     done\n+#\n+#   If you want to force a specific compiler:\n+#\n+#   - at the configure.in level, set JAVAC=yourcompiler before calling\n+#   AX_JNI_INCLUDE_DIR\n+#\n+#   - at the configure level, setenv JAVAC\n+#\n+#   Note: This macro can work with the autoconf M4 macros for Java programs.\n+#   This particular macro is not part of the original set of macros.\n+#\n+# LICENSE\n+#\n+#   Copyright (c) 2008 Don Anderson <dda@sleepycat.com>\n+#\n+#   Copying and distribution of this file, with or without modification, are\n+#   permitted in any medium without royalty provided the copyright notice\n+#   and this notice are preserved. This file is offered as-is, without any\n+#   warranty.\n+\n+#serial 10\n+\n+AU_ALIAS([AC_JNI_INCLUDE_DIR], [AX_JNI_INCLUDE_DIR])\n+AC_DEFUN([AX_JNI_INCLUDE_DIR],[\n+\n+JNI_INCLUDE_DIRS=\"\"\n+\n+if test \"x$JAVA_HOME\" != x; then\n+\t_JTOPDIR=\"$JAVA_HOME\"\n+else\n+\tif test \"x$JAVAC\" = x; then\n+\t\tJAVAC=javac\n+\tfi\n+\tAC_PATH_PROG([_ACJNI_JAVAC], [$JAVAC], [no])\n+\tif test \"x$_ACJNI_JAVAC\" = xno; then\n+\t\tAC_MSG_WARN([cannot find JDK; try setting \\$JAVAC or \\$JAVA_HOME])\n+\tfi\n+\t_ACJNI_FOLLOW_SYMLINKS(\"$_ACJNI_JAVAC\")\n+\t_JTOPDIR=`echo \"$_ACJNI_FOLLOWED\" | sed -e 's://*:/:g' -e 's:/[[^/]]*$::'`\n+fi\n+\n+case \"$host_os\" in\n+        darwin*)        _JTOPDIR=`echo \"$_JTOPDIR\" | sed -e 's:/[[^/]]*$::'`\n+                        _JINC=\"$_JTOPDIR/Headers\";;\n+        *)              _JINC=\"$_JTOPDIR/include\";;\n+esac\n+_AS_ECHO_LOG([_JTOPDIR=$_JTOPDIR])\n+_AS_ECHO_LOG([_JINC=$_JINC])\n+\n+# On Mac OS X 10.6.4, jni.h is a symlink:\n+# /System/Library/Frameworks/JavaVM.framework/Versions/Current/Headers/jni.h\n+# -> ../../CurrentJDK/Headers/jni.h.\n+\n+AC_CACHE_CHECK(jni headers, ac_cv_jni_header_path,\n+[\n+if test -f \"$_JINC/jni.h\"; then\n+  ac_cv_jni_header_path=\"$_JINC\"\n+  JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $ac_cv_jni_header_path\"\n+else\n+  _JTOPDIR=`echo \"$_JTOPDIR\" | sed -e 's:/[[^/]]*$::'`\n+  if test -f \"$_JTOPDIR/include/jni.h\"; then\n+    ac_cv_jni_header_path=\"$_JTOPDIR/include\"\n+    JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $ac_cv_jni_header_path\"\n+  else\n+    ac_cv_jni_header_path=none\n+  fi\n+fi\n+])\n+\n+\n+\n+# get the likely subdirectories for system specific java includes\n+case \"$host_os\" in\n+bsdi*)          _JNI_INC_SUBDIRS=\"bsdos\";;\n+darwin*)        _JNI_INC_SUBDIRS=\"darwin\";;\n+freebsd*)       _JNI_INC_SUBDIRS=\"freebsd\";;\n+linux*)         _JNI_INC_SUBDIRS=\"linux genunix\";;\n+osf*)           _JNI_INC_SUBDIRS=\"alpha\";;\n+solaris*)       _JNI_INC_SUBDIRS=\"solaris\";;\n+mingw*)\t\t_JNI_INC_SUBDIRS=\"win32\";;\n+cygwin*)\t_JNI_INC_SUBDIRS=\"win32\";;\n+*)              _JNI_INC_SUBDIRS=\"genunix\";;\n+esac\n+\n+if test \"x$ac_cv_jni_header_path\" != \"xnone\"; then\n+  # add any subdirectories that are present\n+  for JINCSUBDIR in $_JNI_INC_SUBDIRS\n+  do\n+      if test -d \"$_JTOPDIR/include/$JINCSUBDIR\"; then\n+           JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $_JTOPDIR/include/$JINCSUBDIR\"\n+      fi\n+  done\n+fi\n+])\n+\n+# _ACJNI_FOLLOW_SYMLINKS <path>\n+# Follows symbolic links on <path>,\n+# finally setting variable _ACJNI_FOLLOWED\n+# ----------------------------------------\n+AC_DEFUN([_ACJNI_FOLLOW_SYMLINKS],[\n+# find the include directory relative to the javac executable\n+_cur=\"$1\"\n+while ls -ld \"$_cur\" 2>/dev/null | grep \" -> \" >/dev/null; do\n+        AC_MSG_CHECKING([symlink for $_cur])\n+        _slink=`ls -ld \"$_cur\" | sed 's/.* -> //'`\n+        case \"$_slink\" in\n+        /*) _cur=\"$_slink\";;\n+        # 'X' avoids triggering unwanted echo options.\n+        *) _cur=`echo \"X$_cur\" | sed -e 's/^X//' -e 's:[[^/]]*$::'`\"$_slink\";;\n+        esac\n+        AC_MSG_RESULT([$_cur])\n+done\n+_ACJNI_FOLLOWED=\"$_cur\"\n+])# _ACJNI"
      },
      {
        "sha": "b25d8adb92c7fd207a7f142d2328940d222d57b7",
        "filename": "src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/build-aux/m4/bitcoin_secp.m4?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -3,13 +3,13 @@ AC_DEFUN([SECP_INT128_CHECK],[\n has_int128=$ac_cv_type___int128\n ])\n \n-dnl \n+dnl escape \"$0x\" below using the m4 quadrigaph @S|@, and escape it again with a \\ for the shell.\n AC_DEFUN([SECP_64BIT_ASM_CHECK],[\n AC_MSG_CHECKING(for x86_64 assembly availability)\n AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n   #include <stdint.h>]],[[\n   uint64_t a = 11, tmp;\n-  __asm__ __volatile__(\"movq $0x100000000,%1; mulq %%rsi\" : \"+a\"(a) : \"S\"(tmp) : \"cc\", \"%rdx\");\n+  __asm__ __volatile__(\"movq \\@S|@0x100000000,%1; mulq %%rsi\" : \"+a\"(a) : \"S\"(tmp) : \"cc\", \"%rdx\");\n   ]])],[has_64bit_asm=yes],[has_64bit_asm=no])\n AC_MSG_RESULT([$has_64bit_asm])\n ])"
      },
      {
        "sha": "0743c36690c7aec009d52d4ac84ea8639fe5dfe6",
        "filename": "src/secp256k1/configure.ac",
        "status": "modified",
        "additions": 130,
        "deletions": 16,
        "changes": 146,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/configure.ac?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -29,6 +29,7 @@ AC_PROG_CC_C89\n if test x\"$ac_cv_prog_cc_c89\" = x\"no\"; then\n   AC_MSG_ERROR([c89 compiler support required])\n fi\n+AM_PROG_AS\n \n case $host_os in\n   *darwin*)\n@@ -93,23 +94,33 @@ AC_ARG_ENABLE(tests,\n     [use_tests=$enableval],\n     [use_tests=yes])\n \n+AC_ARG_ENABLE(openssl_tests,\n+    AS_HELP_STRING([--enable-openssl-tests],[enable OpenSSL tests, if OpenSSL is available (default is auto)]),\n+    [enable_openssl_tests=$enableval],\n+    [enable_openssl_tests=auto])\n+\n+AC_ARG_ENABLE(experimental,\n+    AS_HELP_STRING([--enable-experimental],[allow experimental configure options (default is no)]),\n+    [use_experimental=$enableval],\n+    [use_experimental=no])\n+\n AC_ARG_ENABLE(endomorphism,\n     AS_HELP_STRING([--enable-endomorphism],[enable endomorphism (default is no)]),\n     [use_endomorphism=$enableval],\n     [use_endomorphism=no])\n-    \n+\n AC_ARG_ENABLE(ecmult_static_precomputation,\n     AS_HELP_STRING([--enable-ecmult-static-precomputation],[enable precomputed ecmult table for signing (default is yes)]),\n     [use_ecmult_static_precomputation=$enableval],\n-    [use_ecmult_static_precomputation=yes])\n+    [use_ecmult_static_precomputation=auto])\n \n AC_ARG_ENABLE(module_ecdh,\n-    AS_HELP_STRING([--enable-module-ecdh],[enable ECDH shared secret computation (default is no)]),\n+    AS_HELP_STRING([--enable-module-ecdh],[enable ECDH shared secret computation (experimental)]),\n     [enable_module_ecdh=$enableval],\n     [enable_module_ecdh=no])\n \n AC_ARG_ENABLE(module_schnorr,\n-    AS_HELP_STRING([--enable-module-schnorr],[enable Schnorr signature module (default is no)]),\n+    AS_HELP_STRING([--enable-module-schnorr],[enable Schnorr signature module (experimental)]),\n     [enable_module_schnorr=$enableval],\n     [enable_module_schnorr=no])\n \n@@ -118,6 +129,11 @@ AC_ARG_ENABLE(module_recovery,\n     [enable_module_recovery=$enableval],\n     [enable_module_recovery=no])\n \n+AC_ARG_ENABLE(jni,\n+    AS_HELP_STRING([--enable-jni],[enable libsecp256k1_jni (default is auto)]),\n+    [use_jni=$enableval],\n+    [use_jni=auto])\n+\n AC_ARG_WITH([field], [AS_HELP_STRING([--with-field=64bit|32bit|auto],\n [Specify Field Implementation. Default is auto])],[req_field=$withval], [req_field=auto])\n \n@@ -127,8 +143,8 @@ AC_ARG_WITH([bignum], [AS_HELP_STRING([--with-bignum=gmp|no|auto],\n AC_ARG_WITH([scalar], [AS_HELP_STRING([--with-scalar=64bit|32bit|auto],\n [Specify scalar implementation. Default is auto])],[req_scalar=$withval], [req_scalar=auto])\n \n-AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|no|auto]\n-[Specify assembly optimizations to use. Default is auto])],[req_asm=$withval], [req_asm=auto])\n+AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|arm|no|auto]\n+[Specify assembly optimizations to use. Default is auto (experimental: arm)])],[req_asm=$withval], [req_asm=auto])\n \n AC_CHECK_TYPES([__int128])\n \n@@ -138,6 +154,34 @@ AC_COMPILE_IFELSE([AC_LANG_SOURCE([[void myfunc() {__builtin_expect(0,0);}]])],\n     [ AC_MSG_RESULT([no])\n     ])\n \n+if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n+  save_cross_compiling=$cross_compiling\n+  cross_compiling=no\n+  TEMP_CC=\"$CC\"\n+  CC=\"$CC_FOR_BUILD\"\n+  AC_MSG_CHECKING([native compiler: ${CC_FOR_BUILD}])\n+  AC_RUN_IFELSE(\n+    [AC_LANG_PROGRAM([], [return 0])],\n+    [working_native_cc=yes],\n+    [working_native_cc=no],[dnl])\n+  CC=\"$TEMP_CC\"\n+  cross_compiling=$save_cross_compiling\n+\n+  if test x\"$working_native_cc\" = x\"no\"; then\n+    set_precomp=no\n+    if test x\"$use_ecmult_static_precomputation\" = x\"yes\";  then\n+      AC_MSG_ERROR([${CC_FOR_BUILD} does not produce working binaries. Please set CC_FOR_BUILD])\n+    else\n+      AC_MSG_RESULT([${CC_FOR_BUILD} does not produce working binaries. Please set CC_FOR_BUILD])\n+    fi\n+  else\n+    AC_MSG_RESULT([ok])\n+    set_precomp=yes\n+  fi\n+else\n+  set_precomp=no\n+fi\n+\n if test x\"$req_asm\" = x\"auto\"; then\n   SECP_64BIT_ASM_CHECK\n   if test x\"$has_64bit_asm\" = x\"yes\"; then\n@@ -155,6 +199,8 @@ else\n       AC_MSG_ERROR([x86_64 assembly optimization requested but not available])\n     fi\n     ;;\n+  arm)\n+    ;;\n   no)\n     ;;\n   *)\n@@ -247,10 +293,15 @@ else\n fi\n \n # select assembly optimization\n+use_external_asm=no\n+\n case $set_asm in\n x86_64)\n   AC_DEFINE(USE_ASM_X86_64, 1, [Define this symbol to enable x86_64 assembly optimizations])\n   ;;\n+arm)\n+  use_external_asm=yes\n+  ;;\n no)\n   ;;\n *)\n@@ -305,16 +356,51 @@ esac\n if test x\"$use_tests\" = x\"yes\"; then\n   SECP_OPENSSL_CHECK\n   if test x\"$has_openssl_ec\" = x\"yes\"; then\n-    AC_DEFINE(ENABLE_OPENSSL_TESTS, 1, [Define this symbol if OpenSSL EC functions are available])\n-    SECP_TEST_INCLUDES=\"$SSL_CFLAGS $CRYPTO_CFLAGS\"\n-    SECP_TEST_LIBS=\"$CRYPTO_LIBS\"\n-\n-    case $host in\n-    *mingw*)\n-      SECP_TEST_LIBS=\"$SECP_TEST_LIBS -lgdi32\"\n-      ;;\n-    esac\n+    if test x\"$enable_openssl_tests\" != x\"no\"; then\n+      AC_DEFINE(ENABLE_OPENSSL_TESTS, 1, [Define this symbol if OpenSSL EC functions are available])\n+      SECP_TEST_INCLUDES=\"$SSL_CFLAGS $CRYPTO_CFLAGS\"\n+      SECP_TEST_LIBS=\"$CRYPTO_LIBS\"\n+\n+      case $host in\n+      *mingw*)\n+        SECP_TEST_LIBS=\"$SECP_TEST_LIBS -lgdi32\"\n+        ;;\n+      esac\n+    fi\n+  else\n+    if test x\"$enable_openssl_tests\" = x\"yes\"; then\n+      AC_MSG_ERROR([OpenSSL tests requested but OpenSSL with EC support is not available])\n+    fi\n+  fi\n+else\n+  if test x\"$enable_openssl_tests\" = x\"yes\"; then\n+    AC_MSG_ERROR([OpenSSL tests requested but tests are not enabled])\n+  fi\n+fi\n \n+if test x\"$use_jni\" != x\"no\"; then\n+  AX_JNI_INCLUDE_DIR\n+  have_jni_dependencies=yes\n+  if test x\"$enable_module_schnorr\" = x\"no\"; then\n+    have_jni_dependencies=no\n+  fi\n+  if test x\"$enable_module_ecdh\" = x\"no\"; then\n+    have_jni_dependencies=no\n+  fi\n+  if test \"x$JNI_INCLUDE_DIRS\" = \"x\"; then\n+    have_jni_dependencies=no\n+  fi\n+  if test \"x$have_jni_dependencies\" = \"xno\"; then\n+    if test x\"$use_jni\" = x\"yes\"; then\n+      AC_MSG_ERROR([jni support explicitly requested but headers/dependencies were not found. Enable ECDH and Schnorr and try again.])\n+    fi\n+    AC_MSG_WARN([jni headers/dependencies not found. jni support disabled])\n+    use_jni=no\n+  else\n+    use_jni=yes\n+    for JNI_INCLUDE_DIR in $JNI_INCLUDE_DIRS; do\n+      JNI_INCLUDES=\"$JNI_INCLUDES -I$JNI_INCLUDE_DIR\"\n+    done\n   fi\n fi\n \n@@ -345,18 +431,43 @@ fi\n \n AC_C_BIGENDIAN()\n \n+if test x\"$use_external_asm\" = x\"yes\"; then\n+  AC_DEFINE(USE_EXTERNAL_ASM, 1, [Define this symbol if an external (non-inline) assembly implementation is used])\n+fi\n+\n+AC_MSG_NOTICE([Using static precomputation: $set_precomp])\n AC_MSG_NOTICE([Using assembly optimizations: $set_asm])\n AC_MSG_NOTICE([Using field implementation: $set_field])\n AC_MSG_NOTICE([Using bignum implementation: $set_bignum])\n AC_MSG_NOTICE([Using scalar implementation: $set_scalar])\n AC_MSG_NOTICE([Using endomorphism optimizations: $use_endomorphism])\n AC_MSG_NOTICE([Building ECDH module: $enable_module_ecdh])\n-\n AC_MSG_NOTICE([Building Schnorr signatures module: $enable_module_schnorr])\n AC_MSG_NOTICE([Building ECDSA pubkey recovery module: $enable_module_recovery])\n+AC_MSG_NOTICE([Using jni: $use_jni])\n+\n+if test x\"$enable_experimental\" = x\"yes\"; then\n+  AC_MSG_NOTICE([******])\n+  AC_MSG_NOTICE([WARNING: experimental build])\n+  AC_MSG_NOTICE([Experimental features do not have stable APIs or properties, and may not be safe for production use.])\n+  AC_MSG_NOTICE([Building ECDH module: $enable_module_ecdh])\n+  AC_MSG_NOTICE([Building Schnorr signatures module: $enable_module_schnorr])\n+  AC_MSG_NOTICE([******])\n+else\n+  if test x\"$enable_module_schnorr\" = x\"yes\"; then\n+    AC_MSG_ERROR([Schnorr signature module is experimental. Use --enable-experimental to allow.])\n+  fi\n+  if test x\"$enable_module_ecdh\" = x\"yes\"; then\n+    AC_MSG_ERROR([ECDH module is experimental. Use --enable-experimental to allow.])\n+  fi\n+  if test x\"$set_asm\" = x\"arm\"; then\n+    AC_MSG_ERROR([ARM assembly optimization is experimental. Use --enable-experimental to allow.])\n+  fi\n+fi\n \n AC_CONFIG_HEADERS([src/libsecp256k1-config.h])\n AC_CONFIG_FILES([Makefile libsecp256k1.pc])\n+AC_SUBST(JNI_INCLUDES)\n AC_SUBST(SECP_INCLUDES)\n AC_SUBST(SECP_LIBS)\n AC_SUBST(SECP_TEST_LIBS)\n@@ -367,6 +478,9 @@ AM_CONDITIONAL([USE_ECMULT_STATIC_PRECOMPUTATION], [test x\"$use_ecmult_static_pr\n AM_CONDITIONAL([ENABLE_MODULE_ECDH], [test x\"$enable_module_ecdh\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_SCHNORR], [test x\"$enable_module_schnorr\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_RECOVERY], [test x\"$enable_module_recovery\" = x\"yes\"])\n+AM_CONDITIONAL([USE_JNI], [test x\"$use_jni\" == x\"yes\"])\n+AM_CONDITIONAL([USE_EXTERNAL_ASM], [test x\"$use_external_asm\" = x\"yes\"])\n+AM_CONDITIONAL([USE_ASM_ARM], [test x\"$set_asm\" = x\"arm\"])\n \n dnl make sure nothing new is exported so that we don't break the cache\n PKGCONFIG_PATH_TEMP=\"$PKG_CONFIG_PATH\""
      },
      {
        "sha": "a0d006f1131f47d9bb80de6d425e38912e1258f0",
        "filename": "src/secp256k1/libsecp256k1.pc.in",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/libsecp256k1.pc.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/libsecp256k1.pc.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/libsecp256k1.pc.in?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -5,7 +5,7 @@ includedir=@includedir@\n \n Name: libsecp256k1\n Description: Optimized C library for EC operations on curve secp256k1\n-URL: https://github.com/bitcoin/secp256k1\n+URL: https://github.com/bitcoin-core/secp256k1\n Version: @PACKAGE_VERSION@\n Cflags: -I${includedir}\n Libs.private: @SECP_LIBS@"
      },
      {
        "sha": "ab580c5b23bbf786f41757b8a3800958db37c7a7",
        "filename": "src/secp256k1/sage/group_prover.sage",
        "status": "added",
        "additions": 322,
        "deletions": 0,
        "changes": 322,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/sage/group_prover.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/sage/group_prover.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/sage/group_prover.sage?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -0,0 +1,322 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map(numerator, assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+class constraints:\n+  \"\"\"A set of constraints, consisting of zero and nonzero expressions.\n+\n+  Constraints can either be used to express knowledge or a requirement.\n+\n+  Both the fields zero and nonzero are maps from expressions to description\n+  strings. The expressions that are the keys in zero are required to be zero,\n+  and the expressions that are the keys in nonzero are required to be nonzero.\n+\n+  Note that (a != 0) and (b != 0) is the same as (a*b != 0), so all keys in\n+  nonzero could be multiplied into a single key. This is often much less\n+  efficient to work with though, so we keep them separate inside the\n+  constraints. This allows higher-level code to do fast checks on the individual\n+  nonzero elements, or combine them if needed for stronger checks.\n+\n+  We can't multiply the different zero elements, as it would suffice for one of\n+  the factors to be zero, instead of all of them. Instead, the zero elements are\n+  typically combined into an ideal first.\n+  \"\"\"\n+\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map(numerator, con.zero))\n+  if 1 in zero:\n+    return True\n+  # First a cheap check whether any of the individual nonzero terms conflict on\n+  # their own.\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  # It can be the case that entries in the nonzero set do not individually\n+  # conflict with the zero set, but their combination does. For example, knowing\n+  # that either x or y is zero is equivalent to having x*y in the zero set.\n+  # Having x or y individually in the nonzero set is not a conflict, but both\n+  # simultaneously is, so that is the right thing to check for.\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True\n+  return False\n+\n+\n+def get_nonzero_set(R, assume):\n+  \"\"\"Calculate a simple set of nonzero expressions\"\"\"\n+  zero = R.ideal(map(numerator, assume.zero))\n+  nonzero = set()\n+  for nz in map(numerator, assume.nonzero):\n+    for (f,n) in nz.factor():\n+      nonzero.add(f)\n+    rnz = zero.reduce(nz)\n+    for (f,n) in rnz.factor():\n+      nonzero.add(f)\n+  return nonzero\n+\n+\n+def prove_nonzero(R, exprs, assume):\n+  \"\"\"Check whether an expression is provably nonzero, given assumptions\"\"\"\n+  zero = R.ideal(map(numerator, assume.zero))\n+  nonzero = get_nonzero_set(R, assume)\n+  expl = set()\n+  ok = True\n+  for expr in exprs:\n+    if numerator(expr) in zero:\n+      return (False, [exprs[expr]])\n+  allexprs = reduce(lambda a,b: numerator(a)*numerator(b), exprs, 1)\n+  for (f, n) in allexprs.factor():\n+    if f not in nonzero:\n+      ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for (f, n) in zero.reduce(numerator(allexprs)).factor():\n+    if f not in nonzero:\n+      ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for expr in exprs:\n+    for (f,n) in numerator(expr).factor():\n+      if f not in nonzero:\n+        ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for expr in exprs:\n+    for (f,n) in zero.reduce(numerator(expr)).factor():\n+      if f not in nonzero:\n+        expl.add(exprs[expr])\n+  if expl:\n+    return (False, list(expl))\n+  else:\n+    return (True, None)\n+\n+\n+def prove_zero(R, exprs, assume):\n+  \"\"\"Check whether all of the passed expressions are provably zero, given assumptions\"\"\"\n+  r, e = prove_nonzero(R, dict(map(lambda x: (fastfrac(R, x.bot, 1), exprs[x]), exprs)), assume)\n+  if not r:\n+    return (False, map(lambda x: \"Possibly zero denominator: %s\" % x, e))\n+  zero = R.ideal(map(numerator, assume.zero))\n+  nonzero = prod(x for x in assume.nonzero)\n+  expl = []\n+  for expr in exprs:\n+    if not expr.iszero(zero):\n+      expl.append(exprs[expr])\n+  if not expl:\n+    return (True, None)\n+  return (False, expl)\n+\n+\n+def describe_extra(R, assume, assumeExtra):\n+  \"\"\"Describe what assumptions are added, given existing assumptions\"\"\"\n+  zerox = assume.zero.copy()\n+  zerox.update(assumeExtra.zero)\n+  zero = R.ideal(map(numerator, assume.zero))\n+  zeroextra = R.ideal(map(numerator, zerox))\n+  nonzero = get_nonzero_set(R, assume)\n+  ret = set()\n+  # Iterate over the extra zero expressions\n+  for base in assumeExtra.zero:\n+    if base not in zero:\n+      add = []\n+      for (f, n) in numerator(base).factor():\n+        if f not in nonzero:\n+          add += [\"%s\" % f]\n+      if add:\n+        ret.add((\" * \".join(add)) + \" = 0 [%s]\" % assumeExtra.zero[base])\n+  # Iterate over the extra nonzero expressions\n+  for nz in assumeExtra.nonzero:\n+    nzr = zeroextra.reduce(numerator(nz))\n+    if nzr not in zeroextra:\n+      for (f,n) in nzr.factor():\n+        if zeroextra.reduce(f) not in nonzero:\n+          ret.add(\"%s != 0\" % zeroextra.reduce(f))\n+  return \", \".join(x for x in ret)\n+\n+\n+def check_symbolic(R, assumeLaw, assumeAssert, assumeBranch, require):\n+  \"\"\"Check a set of zero and nonzero requirements, given a set of zero and nonzero assumptions\"\"\"\n+  assume = assumeLaw + assumeAssert + assumeBranch\n+\n+  if conflicts(R, assume):\n+    # This formula does not apply\n+    return None\n+\n+  describe = describe_extra(R, assumeLaw + assumeBranch, assumeAssert)\n+\n+  ok, msg = prove_zero(R, require.zero, assume)\n+  if not ok:\n+    return \"FAIL, %s fails (assuming %s)\" % (str(msg), describe)\n+\n+  res, expl = prove_nonzero(R, require.nonzero, assume)\n+  if not res:\n+    return \"FAIL, %s fails (assuming %s)\" % (str(expl), describe)\n+\n+  if describe != \"\":\n+    return \"OK (assuming %s)\" % describe\n+  else:\n+    return \"OK\"\n+\n+\n+def concrete_verify(c):\n+  for k in c.zero:\n+    if k != 0:\n+      return (False, c.zero[k])\n+  for k in c.nonzero:\n+    if k == 0:\n+      return (False, c.nonzero[k])\n+  return (True, None)"
      },
      {
        "sha": "a97e732f7fa3ab681a63070eda20455cda3a6c32",
        "filename": "src/secp256k1/sage/secp256k1.sage",
        "status": "added",
        "additions": 306,
        "deletions": 0,
        "changes": 306,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/sage/secp256k1.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/sage/secp256k1.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/sage/secp256k1.sage?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -0,0 +1,306 @@\n+# Test libsecp256k1' group operation implementations using prover.sage\n+\n+import sys\n+\n+load(\"group_prover.sage\")\n+load(\"weierstrass_prover.sage\")\n+\n+def formula_secp256k1_gej_double_var(a):\n+  \"\"\"libsecp256k1's secp256k1_gej_double_var, used by various addition functions\"\"\"\n+  rz = a.Z * a.Y\n+  rz = rz * 2\n+  t1 = a.X^2\n+  t1 = t1 * 3\n+  t2 = t1^2\n+  t3 = a.Y^2\n+  t3 = t3 * 2\n+  t4 = t3^2\n+  t4 = t4 * 2\n+  t3 = t3 * a.X\n+  rx = t3\n+  rx = rx * 4\n+  rx = -rx\n+  rx = rx + t2\n+  t2 = -t2\n+  t3 = t3 * 6\n+  t3 = t3 + t2\n+  ry = t1 * t3\n+  t2 = -t4\n+  ry = ry + t2\n+  return jacobianpoint(rx, ry, rz)\n+\n+def formula_secp256k1_gej_add_var(branch, a, b):\n+  \"\"\"libsecp256k1's secp256k1_gej_add_var\"\"\"\n+  if branch == 0:\n+    return (constraints(), constraints(nonzero={a.Infinity : 'a_infinite'}), b)\n+  if branch == 1:\n+    return (constraints(), constraints(zero={a.Infinity : 'a_finite'}, nonzero={b.Infinity : 'b_infinite'}), a)\n+  z22 = b.Z^2\n+  z12 = a.Z^2\n+  u1 = a.X * z22\n+  u2 = b.X * z12\n+  s1 = a.Y * z22\n+  s1 = s1 * b.Z\n+  s2 = b.Y * z12\n+  s2 = s2 * a.Z\n+  h = -u1\n+  h = h + u2\n+  i = -s1\n+  i = i + s2\n+  if branch == 2:\n+    r = formula_secp256k1_gej_double_var(a)\n+    return (constraints(), constraints(zero={h : 'h=0', i : 'i=0', a.Infinity : 'a_finite', b.Infinity : 'b_finite'}), r)\n+  if branch == 3:\n+    return (constraints(), constraints(zero={h : 'h=0', a.Infinity : 'a_finite', b.Infinity : 'b_finite'}, nonzero={i : 'i!=0'}), point_at_infinity())\n+  i2 = i^2\n+  h2 = h^2\n+  h3 = h2 * h\n+  h = h * b.Z\n+  rz = a.Z * h\n+  t = u1 * h2\n+  rx = t\n+  rx = rx * 2\n+  rx = rx + h3\n+  rx = -rx\n+  rx = rx + i2\n+  ry = -rx\n+  ry = ry + t\n+  ry = ry * i\n+  h3 = h3 * s1\n+  h3 = -h3\n+  ry = ry + h3\n+  return (constraints(), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite'}, nonzero={h : 'h!=0'}), jacobianpoint(rx, ry, rz))\n+\n+def formula_secp256k1_gej_add_ge_var(branch, a, b):\n+  \"\"\"libsecp256k1's secp256k1_gej_add_ge_var, which assume bz==1\"\"\"\n+  if branch == 0:\n+    return (constraints(zero={b.Z - 1 : 'b.z=1'}), constraints(nonzero={a.Infinity : 'a_infinite'}), b)\n+  if branch == 1:\n+    return (constraints(zero={b.Z - 1 : 'b.z=1'}), constraints(zero={a.Infinity : 'a_finite'}, nonzero={b.Infinity : 'b_infinite'}), a)\n+  z12 = a.Z^2\n+  u1 = a.X\n+  u2 = b.X * z12\n+  s1 = a.Y\n+  s2 = b.Y * z12\n+  s2 = s2 * a.Z\n+  h = -u1\n+  h = h + u2\n+  i = -s1\n+  i = i + s2\n+  if (branch == 2):\n+    r = formula_secp256k1_gej_double_var(a)\n+    return (constraints(zero={b.Z - 1 : 'b.z=1'}), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite', h : 'h=0', i : 'i=0'}), r)\n+  if (branch == 3):\n+    return (constraints(zero={b.Z - 1 : 'b.z=1'}), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite', h : 'h=0'}, nonzero={i : 'i!=0'}), point_at_infinity())\n+  i2 = i^2\n+  h2 = h^2\n+  h3 = h * h2\n+  rz = a.Z * h\n+  t = u1 * h2\n+  rx = t\n+  rx = rx * 2\n+  rx = rx + h3\n+  rx = -rx\n+  rx = rx + i2\n+  ry = -rx\n+  ry = ry + t\n+  ry = ry * i\n+  h3 = h3 * s1\n+  h3 = -h3\n+  ry = ry + h3\n+  return (constraints(zero={b.Z - 1 : 'b.z=1'}), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite'}, nonzero={h : 'h!=0'}), jacobianpoint(rx, ry, rz))\n+\n+def formula_secp256k1_gej_add_zinv_var(branch, a, b):\n+  \"\"\"libsecp256k1's secp256k1_gej_add_zinv_var\"\"\"\n+  bzinv = b.Z^(-1)\n+  if branch == 0:\n+    return (constraints(), constraints(nonzero={b.Infinity : 'b_infinite'}), a)\n+  if branch == 1:\n+    bzinv2 = bzinv^2\n+    bzinv3 = bzinv2 * bzinv\n+    rx = b.X * bzinv2\n+    ry = b.Y * bzinv3\n+    rz = 1\n+    return (constraints(), constraints(zero={b.Infinity : 'b_finite'}, nonzero={a.Infinity : 'a_infinite'}), jacobianpoint(rx, ry, rz))\n+  azz = a.Z * bzinv\n+  z12 = azz^2\n+  u1 = a.X\n+  u2 = b.X * z12\n+  s1 = a.Y\n+  s2 = b.Y * z12\n+  s2 = s2 * azz\n+  h = -u1\n+  h = h + u2\n+  i = -s1\n+  i = i + s2\n+  if branch == 2:\n+    r = formula_secp256k1_gej_double_var(a)\n+    return (constraints(), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite', h : 'h=0', i : 'i=0'}), r)\n+  if branch == 3:\n+    return (constraints(), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite', h : 'h=0'}, nonzero={i : 'i!=0'}), point_at_infinity())\n+  i2 = i^2\n+  h2 = h^2\n+  h3 = h * h2\n+  rz = a.Z\n+  rz = rz * h\n+  t = u1 * h2\n+  rx = t\n+  rx = rx * 2\n+  rx = rx + h3\n+  rx = -rx\n+  rx = rx + i2\n+  ry = -rx\n+  ry = ry + t\n+  ry = ry * i\n+  h3 = h3 * s1\n+  h3 = -h3\n+  ry = ry + h3\n+  return (constraints(), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite'}, nonzero={h : 'h!=0'}), jacobianpoint(rx, ry, rz))\n+\n+def formula_secp256k1_gej_add_ge(branch, a, b):\n+  \"\"\"libsecp256k1's secp256k1_gej_add_ge\"\"\"\n+  zeroes = {}\n+  nonzeroes = {}\n+  a_infinity = False\n+  if (branch & 4) != 0:\n+    nonzeroes.update({a.Infinity : 'a_infinite'})\n+    a_infinity = True\n+  else:\n+    zeroes.update({a.Infinity : 'a_finite'})\n+  zz = a.Z^2\n+  u1 = a.X\n+  u2 = b.X * zz\n+  s1 = a.Y\n+  s2 = b.Y * zz\n+  s2 = s2 * a.Z\n+  t = u1\n+  t = t + u2\n+  m = s1\n+  m = m + s2\n+  rr = t^2\n+  m_alt = -u2\n+  tt = u1 * m_alt\n+  rr = rr + tt\n+  degenerate = (branch & 3) == 3\n+  if (branch & 1) != 0:\n+    zeroes.update({m : 'm_zero'})\n+  else:\n+    nonzeroes.update({m : 'm_nonzero'})\n+  if (branch & 2) != 0:\n+    zeroes.update({rr : 'rr_zero'})\n+  else:\n+    nonzeroes.update({rr : 'rr_nonzero'})\n+  rr_alt = s1\n+  rr_alt = rr_alt * 2\n+  m_alt = m_alt + u1\n+  if not degenerate:\n+    rr_alt = rr\n+    m_alt = m\n+  n = m_alt^2\n+  q = n * t\n+  n = n^2\n+  if degenerate:\n+    n = m\n+  t = rr_alt^2\n+  rz = a.Z * m_alt\n+  infinity = False\n+  if (branch & 8) != 0:\n+    if not a_infinity:\n+      infinity = True\n+    zeroes.update({rz : 'r.z=0'})\n+  else:\n+    nonzeroes.update({rz : 'r.z!=0'})\n+  rz = rz * 2\n+  q = -q\n+  t = t + q\n+  rx = t\n+  t = t * 2\n+  t = t + q\n+  t = t * rr_alt\n+  t = t + n\n+  ry = -t\n+  rx = rx * 4\n+  ry = ry * 4\n+  if a_infinity:\n+    rx = b.X\n+    ry = b.Y\n+    rz = 1\n+  if infinity:\n+    return (constraints(zero={b.Z - 1 : 'b.z=1', b.Infinity : 'b_finite'}), constraints(zero=zeroes, nonzero=nonzeroes), point_at_infinity())\n+  return (constraints(zero={b.Z - 1 : 'b.z=1', b.Infinity : 'b_finite'}), constraints(zero=zeroes, nonzero=nonzeroes), jacobianpoint(rx, ry, rz))\n+\n+def formula_secp256k1_gej_add_ge_old(branch, a, b):\n+  \"\"\"libsecp256k1's old secp256k1_gej_add_ge, which fails when ay+by=0 but ax!=bx\"\"\"\n+  a_infinity = (branch & 1) != 0\n+  zero = {}\n+  nonzero = {}\n+  if a_infinity:\n+    nonzero.update({a.Infinity : 'a_infinite'})\n+  else:\n+    zero.update({a.Infinity : 'a_finite'})\n+  zz = a.Z^2\n+  u1 = a.X\n+  u2 = b.X * zz\n+  s1 = a.Y\n+  s2 = b.Y * zz\n+  s2 = s2 * a.Z\n+  z = a.Z\n+  t = u1\n+  t = t + u2\n+  m = s1\n+  m = m + s2\n+  n = m^2\n+  q = n * t\n+  n = n^2\n+  rr = t^2\n+  t = u1 * u2\n+  t = -t\n+  rr = rr + t\n+  t = rr^2\n+  rz = m * z\n+  infinity = False\n+  if (branch & 2) != 0:\n+    if not a_infinity:\n+      infinity = True\n+    else:\n+      return (constraints(zero={b.Z - 1 : 'b.z=1', b.Infinity : 'b_finite'}), constraints(nonzero={z : 'conflict_a'}, zero={z : 'conflict_b'}), point_at_infinity())\n+    zero.update({rz : 'r.z=0'})\n+  else:\n+    nonzero.update({rz : 'r.z!=0'})\n+  rz = rz * (0 if a_infinity else 2)\n+  rx = t\n+  q = -q\n+  rx = rx + q\n+  q = q * 3\n+  t = t * 2\n+  t = t + q\n+  t = t * rr\n+  t = t + n\n+  ry = -t\n+  rx = rx * (0 if a_infinity else 4)\n+  ry = ry * (0 if a_infinity else 4)\n+  t = b.X\n+  t = t * (1 if a_infinity else 0)\n+  rx = rx + t\n+  t = b.Y\n+  t = t * (1 if a_infinity else 0)\n+  ry = ry + t\n+  t = (1 if a_infinity else 0)\n+  rz = rz + t\n+  if infinity:\n+    return (constraints(zero={b.Z - 1 : 'b.z=1', b.Infinity : 'b_finite'}), constraints(zero=zero, nonzero=nonzero), point_at_infinity())\n+  return (constraints(zero={b.Z - 1 : 'b.z=1', b.Infinity : 'b_finite'}), constraints(zero=zero, nonzero=nonzero), jacobianpoint(rx, ry, rz))\n+\n+if __name__ == \"__main__\":\n+  check_symbolic_jacobian_weierstrass(\"secp256k1_gej_add_var\", 0, 7, 5, formula_secp256k1_gej_add_var)\n+  check_symbolic_jacobian_weierstrass(\"secp256k1_gej_add_ge_var\", 0, 7, 5, formula_secp256k1_gej_add_ge_var)\n+  check_symbolic_jacobian_weierstrass(\"secp256k1_gej_add_zinv_var\", 0, 7, 5, formula_secp256k1_gej_add_zinv_var)\n+  check_symbolic_jacobian_weierstrass(\"secp256k1_gej_add_ge\", 0, 7, 16, formula_secp256k1_gej_add_ge)\n+  check_symbolic_jacobian_weierstrass(\"secp256k1_gej_add_ge_old [should fail]\", 0, 7, 4, formula_secp256k1_gej_add_ge_old)\n+\n+  if len(sys.argv) >= 2 and sys.argv[1] == \"--exhaustive\":\n+    check_exhaustive_jacobian_weierstrass(\"secp256k1_gej_add_var\", 0, 7, 5, formula_secp256k1_gej_add_var, 43)\n+    check_exhaustive_jacobian_weierstrass(\"secp256k1_gej_add_ge_var\", 0, 7, 5, formula_secp256k1_gej_add_ge_var, 43)\n+    check_exhaustive_jacobian_weierstrass(\"secp256k1_gej_add_zinv_var\", 0, 7, 5, formula_secp256k1_gej_add_zinv_var, 43)\n+    check_exhaustive_jacobian_weierstrass(\"secp256k1_gej_add_ge\", 0, 7, 16, formula_secp256k1_gej_add_ge, 43)\n+    check_exhaustive_jacobian_weierstrass(\"secp256k1_gej_add_ge_old [should fail]\", 0, 7, 4, formula_secp256k1_gej_add_ge_old, 43)"
      },
      {
        "sha": "03ef2ec901ea9cafa47b4ccdce7bbba61279930f",
        "filename": "src/secp256k1/sage/weierstrass_prover.sage",
        "status": "added",
        "additions": 264,
        "deletions": 0,
        "changes": 264,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/sage/weierstrass_prover.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/sage/weierstrass_prover.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/sage/weierstrass_prover.sage?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -0,0 +1,264 @@\n+# Prover implementation for Weierstrass curves of the form\n+# y^2 = x^3 + A * x + B, specifically with a = 0 and b = 7, with group laws\n+# operating on affine and Jacobian coordinates, including the point at infinity\n+# represented by a 4th variable in coordinates.\n+\n+load(\"group_prover.sage\")\n+\n+\n+class affinepoint:\n+  def __init__(self, x, y, infinity=0):\n+    self.x = x\n+    self.y = y\n+    self.infinity = infinity\n+  def __str__(self):\n+    return \"affinepoint(x=%s,y=%s,inf=%s)\" % (self.x, self.y, self.infinity)\n+\n+\n+class jacobianpoint:\n+  def __init__(self, x, y, z, infinity=0):\n+    self.X = x\n+    self.Y = y\n+    self.Z = z\n+    self.Infinity = infinity\n+  def __str__(self):\n+    return \"jacobianpoint(X=%s,Y=%s,Z=%s,inf=%s)\" % (self.X, self.Y, self.Z, self.Infinity)\n+\n+\n+def point_at_infinity():\n+  return jacobianpoint(1, 1, 1, 1)\n+\n+\n+def negate(p):\n+  if p.__class__ == affinepoint:\n+    return affinepoint(p.x, -p.y)\n+  if p.__class__ == jacobianpoint:\n+    return jacobianpoint(p.X, -p.Y, p.Z)\n+  assert(False)\n+\n+\n+def on_weierstrass_curve(A, B, p):\n+  \"\"\"Return a set of zero-expressions for an affine point to be on the curve\"\"\"\n+  return constraints(zero={p.x^3 + A*p.x + B - p.y^2: 'on_curve'})\n+\n+\n+def tangential_to_weierstrass_curve(A, B, p12, p3):\n+  \"\"\"Return a set of zero-expressions for ((x12,y12),(x3,y3)) to be a line that is tangential to the curve at (x12,y12)\"\"\"\n+  return constraints(zero={\n+    (p12.y - p3.y) * (p12.y * 2) - (p12.x^2 * 3 + A) * (p12.x - p3.x): 'tangential_to_curve'\n+  })\n+\n+\n+def colinear(p1, p2, p3):\n+  \"\"\"Return a set of zero-expressions for ((x1,y1),(x2,y2),(x3,y3)) to be collinear\"\"\"\n+  return constraints(zero={\n+    (p1.y - p2.y) * (p1.x - p3.x) - (p1.y - p3.y) * (p1.x - p2.x): 'colinear_1',\n+    (p2.y - p3.y) * (p2.x - p1.x) - (p2.y - p1.y) * (p2.x - p3.x): 'colinear_2',\n+    (p3.y - p1.y) * (p3.x - p2.x) - (p3.y - p2.y) * (p3.x - p1.x): 'colinear_3'\n+  })\n+\n+\n+def good_affine_point(p):\n+  return constraints(nonzero={p.x : 'nonzero_x', p.y : 'nonzero_y'})\n+\n+\n+def good_jacobian_point(p):\n+  return constraints(nonzero={p.X : 'nonzero_X', p.Y : 'nonzero_Y', p.Z^6 : 'nonzero_Z'})\n+\n+\n+def good_point(p):\n+  return constraints(nonzero={p.Z^6 : 'nonzero_X'})\n+\n+\n+def finite(p, *affine_fns):\n+  con = good_point(p) + constraints(zero={p.Infinity : 'finite_point'})\n+  if p.Z != 0:\n+    return con + reduce(lambda a, b: a + b, (f(affinepoint(p.X / p.Z^2, p.Y / p.Z^3)) for f in affine_fns), con)\n+  else:\n+    return con\n+\n+def infinite(p):\n+  return constraints(nonzero={p.Infinity : 'infinite_point'})\n+\n+\n+def law_jacobian_weierstrass_add(A, B, pa, pb, pA, pB, pC):\n+  \"\"\"Check whether the passed set of coordinates is a valid Jacobian add, given assumptions\"\"\"\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               on_weierstrass_curve(A, B, pa) +\n+               on_weierstrass_curve(A, B, pb) +\n+               finite(pA) +\n+               finite(pB) +\n+               constraints(nonzero={pa.x - pb.x : 'different_x'}))\n+  require = (finite(pC, lambda pc: on_weierstrass_curve(A, B, pc) +\n+             colinear(pa, pb, negate(pc))))\n+  return (assumeLaw, require)\n+\n+\n+def law_jacobian_weierstrass_double(A, B, pa, pb, pA, pB, pC):\n+  \"\"\"Check whether the passed set of coordinates is a valid Jacobian doubling, given assumptions\"\"\"\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               on_weierstrass_curve(A, B, pa) +\n+               on_weierstrass_curve(A, B, pb) +\n+               finite(pA) +\n+               finite(pB) +\n+               constraints(zero={pa.x - pb.x : 'equal_x', pa.y - pb.y : 'equal_y'}))\n+  require = (finite(pC, lambda pc: on_weierstrass_curve(A, B, pc) +\n+             tangential_to_weierstrass_curve(A, B, pa, negate(pc))))\n+  return (assumeLaw, require)\n+\n+\n+def law_jacobian_weierstrass_add_opposites(A, B, pa, pb, pA, pB, pC):\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               on_weierstrass_curve(A, B, pa) +\n+               on_weierstrass_curve(A, B, pb) +\n+               finite(pA) +\n+               finite(pB) +\n+               constraints(zero={pa.x - pb.x : 'equal_x', pa.y + pb.y : 'opposite_y'}))\n+  require = infinite(pC)\n+  return (assumeLaw, require)\n+\n+\n+def law_jacobian_weierstrass_add_infinite_a(A, B, pa, pb, pA, pB, pC):\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               on_weierstrass_curve(A, B, pb) +\n+               infinite(pA) +\n+               finite(pB))\n+  require = finite(pC, lambda pc: constraints(zero={pc.x - pb.x : 'c.x=b.x', pc.y - pb.y : 'c.y=b.y'}))\n+  return (assumeLaw, require)\n+\n+\n+def law_jacobian_weierstrass_add_infinite_b(A, B, pa, pb, pA, pB, pC):\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               on_weierstrass_curve(A, B, pa) +\n+               infinite(pB) +\n+               finite(pA))\n+  require = finite(pC, lambda pc: constraints(zero={pc.x - pa.x : 'c.x=a.x', pc.y - pa.y : 'c.y=a.y'}))\n+  return (assumeLaw, require)\n+\n+\n+def law_jacobian_weierstrass_add_infinite_ab(A, B, pa, pb, pA, pB, pC):\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               infinite(pA) +\n+               infinite(pB))\n+  require = infinite(pC)\n+  return (assumeLaw, require)\n+\n+\n+laws_jacobian_weierstrass = {\n+  'add': law_jacobian_weierstrass_add,\n+  'double': law_jacobian_weierstrass_double,\n+  'add_opposite': law_jacobian_weierstrass_add_opposites,\n+  'add_infinite_a': law_jacobian_weierstrass_add_infinite_a,\n+  'add_infinite_b': law_jacobian_weierstrass_add_infinite_b,\n+  'add_infinite_ab': law_jacobian_weierstrass_add_infinite_ab\n+}\n+\n+\n+def check_exhaustive_jacobian_weierstrass(name, A, B, branches, formula, p):\n+  \"\"\"Verify an implementation of addition of Jacobian points on a Weierstrass curve, by executing and validating the result for every possible addition in a prime field\"\"\"\n+  F = Integers(p)\n+  print \"Formula %s on Z%i:\" % (name, p)\n+  points = []\n+  for x in xrange(0, p):\n+    for y in xrange(0, p):\n+      point = affinepoint(F(x), F(y))\n+      r, e = concrete_verify(on_weierstrass_curve(A, B, point))\n+      if r:\n+        points.append(point)\n+\n+  for za in xrange(1, p):\n+    for zb in xrange(1, p):\n+      for pa in points:\n+        for pb in points:\n+          for ia in xrange(2):\n+            for ib in xrange(2):\n+              pA = jacobianpoint(pa.x * F(za)^2, pa.y * F(za)^3, F(za), ia)\n+              pB = jacobianpoint(pb.x * F(zb)^2, pb.y * F(zb)^3, F(zb), ib)\n+              for branch in xrange(0, branches):\n+                assumeAssert, assumeBranch, pC = formula(branch, pA, pB)\n+                pC.X = F(pC.X)\n+                pC.Y = F(pC.Y)\n+                pC.Z = F(pC.Z)\n+                pC.Infinity = F(pC.Infinity)\n+                r, e = concrete_verify(assumeAssert + assumeBranch)\n+                if r:\n+                  match = False\n+                  for key in laws_jacobian_weierstrass:\n+                    assumeLaw, require = laws_jacobian_weierstrass[key](A, B, pa, pb, pA, pB, pC)\n+                    r, e = concrete_verify(assumeLaw)\n+                    if r:\n+                      if match:\n+                        print \"  multiple branches for (%s,%s,%s,%s) + (%s,%s,%s,%s)\" % (pA.X, pA.Y, pA.Z, pA.Infinity, pB.X, pB.Y, pB.Z, pB.Infinity)\n+                      else:\n+                        match = True\n+                      r, e = concrete_verify(require)\n+                      if not r:\n+                        print \"  failure in branch %i for (%s,%s,%s,%s) + (%s,%s,%s,%s) = (%s,%s,%s,%s): %s\" % (branch, pA.X, pA.Y, pA.Z, pA.Infinity, pB.X, pB.Y, pB.Z, pB.Infinity, pC.X, pC.Y, pC.Z, pC.Infinity, e)\n+  print\n+\n+\n+def check_symbolic_function(R, assumeAssert, assumeBranch, f, A, B, pa, pb, pA, pB, pC):\n+  assumeLaw, require = f(A, B, pa, pb, pA, pB, pC)\n+  return check_symbolic(R, assumeLaw, assumeAssert, assumeBranch, require)\n+\n+def check_symbolic_jacobian_weierstrass(name, A, B, branches, formula):\n+  \"\"\"Verify an implementation of addition of Jacobian points on a Weierstrass curve symbolically\"\"\"\n+  R.<ax,bx,ay,by,Az,Bz,Ai,Bi> = PolynomialRing(QQ,8,order='invlex')\n+  lift = lambda x: fastfrac(R,x)\n+  ax = lift(ax)\n+  ay = lift(ay)\n+  Az = lift(Az)\n+  bx = lift(bx)\n+  by = lift(by)\n+  Bz = lift(Bz)\n+  Ai = lift(Ai)\n+  Bi = lift(Bi)\n+\n+  pa = affinepoint(ax, ay, Ai)\n+  pb = affinepoint(bx, by, Bi)\n+  pA = jacobianpoint(ax * Az^2, ay * Az^3, Az, Ai)\n+  pB = jacobianpoint(bx * Bz^2, by * Bz^3, Bz, Bi)\n+\n+  res = {}\n+\n+  for key in laws_jacobian_weierstrass:\n+    res[key] = []\n+\n+  print (\"Formula \" + name + \":\")\n+  count = 0\n+  for branch in xrange(branches):\n+    assumeFormula, assumeBranch, pC = formula(branch, pA, pB)\n+    pC.X = lift(pC.X)\n+    pC.Y = lift(pC.Y)\n+    pC.Z = lift(pC.Z)\n+    pC.Infinity = lift(pC.Infinity)\n+\n+    for key in laws_jacobian_weierstrass:\n+      res[key].append((check_symbolic_function(R, assumeFormula, assumeBranch, laws_jacobian_weierstrass[key], A, B, pa, pb, pA, pB, pC), branch))\n+\n+  for key in res:\n+    print \"  %s:\" % key\n+    val = res[key]\n+    for x in val:\n+      if x[0] is not None:\n+        print \"    branch %i: %s\" % (x[1], x[0])\n+\n+  print"
      },
      {
        "sha": "5df561f2fc939e332dae7137345a18fdef9906eb",
        "filename": "src/secp256k1/src/asm/field_10x26_arm.s",
        "status": "added",
        "additions": 919,
        "deletions": 0,
        "changes": 919,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/asm/field_10x26_arm.s",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/asm/field_10x26_arm.s",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/asm/field_10x26_arm.s?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -0,0 +1,919 @@\n+@ vim: set tabstop=8 softtabstop=8 shiftwidth=8 noexpandtab syntax=armasm:\n+/**********************************************************************\n+ * Copyright (c) 2014 Wladimir J. van der Laan                        *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+/*\n+ARM implementation of field_10x26 inner loops.\n+\n+Note:\n+\n+- To avoid unnecessary loads and make use of available registers, two\n+  'passes' have every time been interleaved, with the odd passes accumulating c' and d' \n+  which will be added to c and d respectively in the the even passes\n+\n+*/\n+\n+\t.syntax unified\n+\t.arch armv7-a\n+\t@ eabi attributes - see readelf -A\n+\t.eabi_attribute 8, 1  @ Tag_ARM_ISA_use = yes\n+\t.eabi_attribute 9, 0  @ Tag_Thumb_ISA_use = no\n+\t.eabi_attribute 10, 0 @ Tag_FP_arch = none\n+\t.eabi_attribute 24, 1 @ Tag_ABI_align_needed = 8-byte\n+\t.eabi_attribute 25, 1 @ Tag_ABI_align_preserved = 8-byte, except leaf SP\n+\t.eabi_attribute 30, 2 @ Tag_ABI_optimization_goals = Agressive Speed\n+\t.eabi_attribute 34, 1 @ Tag_CPU_unaligned_access = v6\n+\t.text\n+\n+\t@ Field constants\n+\t.set field_R0, 0x3d10\n+\t.set field_R1, 0x400\n+\t.set field_not_M, 0xfc000000\t@ ~M = ~0x3ffffff\n+\n+\t.align\t2\n+\t.global secp256k1_fe_mul_inner\n+\t.type\tsecp256k1_fe_mul_inner, %function\n+\t@ Arguments:\n+\t@  r0  r      Restrict: can overlap with a, not with b\n+\t@  r1  a\n+\t@  r2  b\n+\t@ Stack (total 4+10*4 = 44)\n+\t@  sp + #0        saved 'r' pointer\n+\t@  sp + #4 + 4*X  t0,t1,t2,t3,t4,t5,t6,t7,u8,t9\n+secp256k1_fe_mul_inner:\n+\tstmfd\tsp!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}\n+\tsub\tsp, sp, #48\t\t\t@ frame=44 + alignment\n+\tstr     r0, [sp, #0]\t\t\t@ save result address, we need it only at the end\n+\n+\t/******************************************\n+\t * Main computation code.\n+\t ******************************************\n+\n+\tAllocation:\n+\t    r0,r14,r7,r8   scratch\n+\t    r1       a (pointer)\n+\t    r2       b (pointer)\n+\t    r3:r4    c\n+\t    r5:r6    d\n+\t    r11:r12  c'\n+\t    r9:r10   d'\n+\n+\tNote: do not write to r[] here, it may overlap with a[]\n+\t*/\n+\n+\t/* A - interleaved with B */\n+\tldr\tr7, [r1, #0*4]\t\t\t@ a[0]\n+\tldr\tr8, [r2, #9*4]\t\t\t@ b[9]\n+\tldr\tr0, [r1, #1*4]\t\t\t@ a[1]\n+\tumull\tr5, r6, r7, r8\t\t\t@ d = a[0] * b[9]\n+\tldr\tr14, [r2, #8*4]\t\t\t@ b[8]\n+\tumull\tr9, r10, r0, r8\t\t\t@ d' = a[1] * b[9]\n+\tldr\tr7, [r1, #2*4]\t\t\t@ a[2]\n+\tumlal\tr5, r6, r0, r14\t\t\t@ d += a[1] * b[8]\n+\tldr\tr8, [r2, #7*4] \t\t\t@ b[7]\n+\tumlal\tr9, r10, r7, r14\t\t@ d' += a[2] * b[8]\n+\tldr\tr0, [r1, #3*4]   \t\t@ a[3]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[2] * b[7]\n+\tldr\tr14, [r2, #6*4]   \t\t@ b[6]\n+\tumlal\tr9, r10, r0, r8  \t\t@ d' += a[3] * b[7]\n+\tldr\tr7, [r1, #4*4]   \t\t@ a[4]\n+\tumlal\tr5, r6, r0, r14   \t\t@ d += a[3] * b[6]\n+\tldr\tr8, [r2, #5*4]   \t\t@ b[5]\n+\tumlal\tr9, r10, r7, r14  \t\t@ d' += a[4] * b[6]\n+\tldr\tr0, [r1, #5*4]   \t\t@ a[5]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[4] * b[5]\n+\tldr\tr14, [r2, #4*4]   \t\t@ b[4]\n+\tumlal\tr9, r10, r0, r8  \t\t@ d' += a[5] * b[5]\n+\tldr\tr7, [r1, #6*4]   \t\t@ a[6]\n+\tumlal\tr5, r6, r0, r14   \t\t@ d += a[5] * b[4]\n+\tldr\tr8, [r2, #3*4]   \t\t@ b[3]\n+\tumlal\tr9, r10, r7, r14  \t\t@ d' += a[6] * b[4]\n+\tldr\tr0, [r1, #7*4]   \t\t@ a[7]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[6] * b[3]\n+\tldr\tr14, [r2, #2*4]   \t\t@ b[2]\n+\tumlal\tr9, r10, r0, r8  \t\t@ d' += a[7] * b[3]\n+\tldr\tr7, [r1, #8*4]   \t\t@ a[8]\n+\tumlal\tr5, r6, r0, r14   \t\t@ d += a[7] * b[2]\n+\tldr\tr8, [r2, #1*4]   \t\t@ b[1]\n+\tumlal\tr9, r10, r7, r14  \t\t@ d' += a[8] * b[2]\n+\tldr\tr0, [r1, #9*4]   \t\t@ a[9]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[8] * b[1]\n+\tldr\tr14, [r2, #0*4]   \t\t@ b[0]\n+\tumlal\tr9, r10, r0, r8  \t\t@ d' += a[9] * b[1]\n+\tldr\tr7, [r1, #0*4]   \t\t@ a[0]\n+\tumlal\tr5, r6, r0, r14   \t\t@ d += a[9] * b[0]\n+\t@ r7,r14 used in B\n+\n+\tbic\tr0, r5, field_not_M \t\t@ t9 = d & M\n+\tstr     r0, [sp, #4 + 4*9]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26 \n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\n+\t/* B */\n+\tumull\tr3, r4, r7, r14   \t\t@ c = a[0] * b[0]\n+\tadds\tr5, r5, r9       \t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u0 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u0 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t0 = c & M\n+\tstr\tr14, [sp, #4 + 0*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u0 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* C - interleaved with D */\n+\tldr\tr7, [r1, #0*4]   \t\t@ a[0]\n+\tldr\tr8, [r2, #2*4]   \t\t@ b[2]\n+\tldr\tr14, [r2, #1*4]   \t\t@ b[1]\n+\tumull\tr11, r12, r7, r8   \t\t@ c' = a[0] * b[2]\n+\tldr\tr0, [r1, #1*4]   \t\t@ a[1]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[0] * b[1]\n+\tldr\tr8, [r2, #0*4]   \t\t@ b[0]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[1] * b[1]\n+\tldr\tr7, [r1, #2*4]   \t\t@ a[2]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[1] * b[0]\n+\tldr\tr14, [r2, #9*4]   \t\t@ b[9]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[2] * b[0]\n+\tldr\tr0, [r1, #3*4]   \t\t@ a[3]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[2] * b[9]\n+\tldr\tr8, [r2, #8*4]   \t\t@ b[8]\n+\tumull\tr9, r10, r0, r14   \t\t@ d' = a[3] * b[9]\n+\tldr\tr7, [r1, #4*4]   \t\t@ a[4]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[3] * b[8]\n+\tldr\tr14, [r2, #7*4]   \t\t@ b[7]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[4] * b[8]\n+\tldr\tr0, [r1, #5*4]   \t\t@ a[5]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[4] * b[7]\n+\tldr\tr8, [r2, #6*4]   \t\t@ b[6]\n+\tumlal\tr9, r10, r0, r14   \t\t@ d' += a[5] * b[7]\n+\tldr\tr7, [r1, #6*4]   \t\t@ a[6]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[5] * b[6]\n+\tldr\tr14, [r2, #5*4]   \t\t@ b[5]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[6] * b[6]\n+\tldr\tr0, [r1, #7*4]   \t\t@ a[7]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[6] * b[5]\n+\tldr\tr8, [r2, #4*4]   \t\t@ b[4]\n+\tumlal\tr9, r10, r0, r14   \t\t@ d' += a[7] * b[5]\n+\tldr\tr7, [r1, #8*4]   \t\t@ a[8]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[7] * b[4]\n+\tldr\tr14, [r2, #3*4]   \t\t@ b[3]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[8] * b[4]\n+\tldr\tr0, [r1, #9*4]   \t\t@ a[9]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[8] * b[3]\n+\tldr\tr8, [r2, #2*4]   \t\t@ b[2]\n+\tumlal\tr9, r10, r0, r14   \t\t@ d' += a[9] * b[3]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[9] * b[2]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u1 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u1 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t1 = c & M\n+\tstr\tr14, [sp, #4 + 1*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u1 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* D */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u2 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u2 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t2 = c & M\n+\tstr\tr14, [sp, #4 + 2*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u2 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* E - interleaved with F */\n+\tldr\tr7, [r1, #0*4]   \t\t@ a[0]\n+\tldr\tr8, [r2, #4*4]   \t\t@ b[4]\n+\tumull\tr11, r12, r7, r8   \t\t@ c' = a[0] * b[4]\n+\tldr\tr8, [r2, #3*4]   \t\t@ b[3]\n+\tumlal   r3, r4, r7, r8   \t\t@ c += a[0] * b[3]\n+\tldr\tr7, [r1, #1*4]   \t\t@ a[1]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[1] * b[3]\n+\tldr\tr8, [r2, #2*4]   \t\t@ b[2]\n+\tumlal   r3, r4, r7, r8   \t\t@ c += a[1] * b[2]\n+\tldr\tr7, [r1, #2*4]   \t\t@ a[2]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[2] * b[2]\n+\tldr\tr8, [r2, #1*4]   \t\t@ b[1]\n+\tumlal   r3, r4, r7, r8   \t\t@ c += a[2] * b[1]\n+\tldr\tr7, [r1, #3*4]   \t\t@ a[3]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[3] * b[1]\n+\tldr\tr8, [r2, #0*4]   \t\t@ b[0]\n+\tumlal   r3, r4, r7, r8   \t\t@ c += a[3] * b[0]\n+\tldr\tr7, [r1, #4*4]   \t\t@ a[4]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[4] * b[0]\n+\tldr\tr8, [r2, #9*4]   \t\t@ b[9]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[4] * b[9]\n+\tldr\tr7, [r1, #5*4]   \t\t@ a[5]\n+\tumull\tr9, r10, r7, r8   \t\t@ d' = a[5] * b[9]\n+\tldr\tr8, [r2, #8*4]   \t\t@ b[8]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[5] * b[8]\n+\tldr\tr7, [r1, #6*4]   \t\t@ a[6]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[6] * b[8]\n+\tldr\tr8, [r2, #7*4]   \t\t@ b[7]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[6] * b[7]\n+\tldr\tr7, [r1, #7*4]   \t\t@ a[7]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[7] * b[7]\n+\tldr\tr8, [r2, #6*4]   \t\t@ b[6]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[7] * b[6]\n+\tldr\tr7, [r1, #8*4]   \t\t@ a[8]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[8] * b[6]\n+\tldr\tr8, [r2, #5*4]   \t\t@ b[5]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[8] * b[5]\n+\tldr\tr7, [r1, #9*4]   \t\t@ a[9]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[9] * b[5]\n+\tldr\tr8, [r2, #4*4]   \t\t@ b[4]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[9] * b[4]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u3 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u3 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t3 = c & M\n+\tstr\tr14, [sp, #4 + 3*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u3 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* F */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u4 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u4 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t4 = c & M\n+\tstr\tr14, [sp, #4 + 4*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u4 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* G - interleaved with H */\n+\tldr\tr7, [r1, #0*4]   \t\t@ a[0]\n+\tldr\tr8, [r2, #6*4]   \t\t@ b[6]\n+\tldr\tr14, [r2, #5*4]   \t\t@ b[5]\n+\tumull\tr11, r12, r7, r8   \t\t@ c' = a[0] * b[6]\n+\tldr\tr0, [r1, #1*4]   \t\t@ a[1]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[0] * b[5]\n+\tldr\tr8, [r2, #4*4]   \t\t@ b[4]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[1] * b[5]\n+\tldr\tr7, [r1, #2*4]   \t\t@ a[2]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[1] * b[4]\n+\tldr\tr14, [r2, #3*4]   \t\t@ b[3]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[2] * b[4]\n+\tldr\tr0, [r1, #3*4]   \t\t@ a[3]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[2] * b[3]\n+\tldr\tr8, [r2, #2*4]   \t\t@ b[2]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[3] * b[3]\n+\tldr\tr7, [r1, #4*4]   \t\t@ a[4]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[3] * b[2]\n+\tldr\tr14, [r2, #1*4]   \t\t@ b[1]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[4] * b[2]\n+\tldr\tr0, [r1, #5*4]   \t\t@ a[5]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[4] * b[1]\n+\tldr\tr8, [r2, #0*4]   \t\t@ b[0]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[5] * b[1]\n+\tldr\tr7, [r1, #6*4]   \t\t@ a[6]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[5] * b[0]\n+\tldr\tr14, [r2, #9*4]   \t\t@ b[9]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[6] * b[0]\n+\tldr\tr0, [r1, #7*4]   \t\t@ a[7]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[6] * b[9]\n+\tldr\tr8, [r2, #8*4]   \t\t@ b[8]\n+\tumull\tr9, r10, r0, r14   \t\t@ d' = a[7] * b[9]\n+\tldr\tr7, [r1, #8*4]   \t\t@ a[8]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[7] * b[8]\n+\tldr\tr14, [r2, #7*4]   \t\t@ b[7]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[8] * b[8]\n+\tldr\tr0, [r1, #9*4]   \t\t@ a[9]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[8] * b[7]\n+\tldr\tr8, [r2, #6*4]   \t\t@ b[6]\n+\tumlal\tr9, r10, r0, r14   \t\t@ d' += a[9] * b[7]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[9] * b[6]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u5 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u5 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t5 = c & M\n+\tstr\tr14, [sp, #4 + 5*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u5 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* H */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u6 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u6 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t6 = c & M\n+\tstr\tr14, [sp, #4 + 6*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u6 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* I - interleaved with J */\n+\tldr\tr8, [r2, #8*4]   \t\t@ b[8]\n+\tldr\tr7, [r1, #0*4]   \t\t@ a[0]\n+\tldr\tr14, [r2, #7*4]   \t\t@ b[7]\n+\tumull   r11, r12, r7, r8   \t\t@ c' = a[0] * b[8]\n+\tldr\tr0, [r1, #1*4]   \t\t@ a[1]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[0] * b[7]\n+\tldr\tr8, [r2, #6*4]   \t\t@ b[6]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[1] * b[7]\n+\tldr\tr7, [r1, #2*4]   \t\t@ a[2]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[1] * b[6]\n+\tldr\tr14, [r2, #5*4]   \t\t@ b[5]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[2] * b[6]\n+\tldr\tr0, [r1, #3*4]   \t\t@ a[3]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[2] * b[5]\n+\tldr\tr8, [r2, #4*4]   \t\t@ b[4]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[3] * b[5]\n+\tldr\tr7, [r1, #4*4]   \t\t@ a[4]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[3] * b[4]\n+\tldr\tr14, [r2, #3*4]   \t\t@ b[3]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[4] * b[4]\n+\tldr\tr0, [r1, #5*4]   \t\t@ a[5]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[4] * b[3]\n+\tldr\tr8, [r2, #2*4]   \t\t@ b[2]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[5] * b[3]\n+\tldr\tr7, [r1, #6*4]   \t\t@ a[6]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[5] * b[2]\n+\tldr\tr14, [r2, #1*4]   \t\t@ b[1]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[6] * b[2]\n+\tldr\tr0, [r1, #7*4]   \t\t@ a[7]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[6] * b[1]\n+\tldr\tr8, [r2, #0*4]   \t\t@ b[0]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[7] * b[1]\n+\tldr\tr7, [r1, #8*4]   \t\t@ a[8]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[7] * b[0]\n+\tldr\tr14, [r2, #9*4]   \t\t@ b[9]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[8] * b[0]\n+\tldr\tr0, [r1, #9*4]   \t\t@ a[9]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[8] * b[9]\n+\tldr\tr8, [r2, #8*4]   \t\t@ b[8]\n+\tumull\tr9, r10, r0, r14  \t\t@ d' = a[9] * b[9]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[9] * b[8]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u7 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u7 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t7 = c & M\n+\tstr\tr14, [sp, #4 + 7*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u7 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* J */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u8 = d & M\n+\tstr\tr0, [sp, #4 + 8*4]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u8 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\t/******************************************\n+\t * compute and write back result\n+\t ******************************************\n+\tAllocation:\n+\t    r0    r\n+\t    r3:r4 c\n+\t    r5:r6 d\n+\t    r7    t0\n+\t    r8    t1\n+\t    r9    t2\n+\t    r11   u8\n+\t    r12   t9\n+\t    r1,r2,r10,r14 scratch\n+\n+\tNote: do not read from a[] after here, it may overlap with r[]\n+\t*/\n+\tldr\tr0, [sp, #0]\n+\tadd\tr1, sp, #4 + 3*4\t\t@ r[3..7] = t3..7, r11=u8, r12=t9\n+\tldmia\tr1, {r2,r7,r8,r9,r10,r11,r12}\n+\tadd\tr1, r0, #3*4\n+\tstmia\tr1, {r2,r7,r8,r9,r10}\n+\n+\tbic\tr2, r3, field_not_M \t\t@ r[8] = c & M\n+\tstr\tr2, [r0, #8*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u8 * R1\n+\tumlal   r3, r4, r11, r14\n+\tmovw    r14, field_R0\t\t\t@ c += d * R0\n+\tumlal   r3, r4, r5, r14\n+\tadds\tr3, r3, r12\t\t\t@ c += t9\n+\tadc\tr4, r4, #0\n+\n+\tadd\tr1, sp, #4 + 0*4\t\t@ r7,r8,r9 = t0,t1,t2\n+\tldmia\tr1, {r7,r8,r9}\n+\n+\tubfx\tr2, r3, #0, #22     \t\t@ r[9] = c & (M >> 4)\n+\tstr\tr2, [r0, #9*4]\n+\tmov\tr3, r3, lsr #22     \t\t@ c >>= 22\n+\torr\tr3, r3, r4, asl #10\n+\tmov     r4, r4, lsr #22\n+\tmovw    r14, field_R1 << 4   \t\t@ c += d * (R1 << 4)\n+\tumlal   r3, r4, r5, r14\n+\n+\tmovw    r14, field_R0 >> 4   \t\t@ d = c * (R0 >> 4) + t0 (64x64 multiply+add)\n+\tumull\tr5, r6, r3, r14\t\t\t@ d = c.lo * (R0 >> 4)\n+\tadds\tr5, r5, r7\t    \t\t@ d.lo += t0\n+\tmla\tr6, r14, r4, r6\t\t\t@ d.hi += c.hi * (R0 >> 4)\n+\tadc\tr6, r6, 0\t     \t\t@ d.hi += carry\n+\n+\tbic\tr2, r5, field_not_M \t\t@ r[0] = d & M\n+\tstr\tr2, [r0, #0*4]\n+\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\t\n+\tmovw    r14, field_R1 >> 4   \t\t@ d += c * (R1 >> 4) + t1 (64x64 multiply+add)\n+\tumull\tr1, r2, r3, r14       \t\t@ tmp = c.lo * (R1 >> 4)\n+\tadds\tr5, r5, r8\t    \t\t@ d.lo += t1\n+\tadc\tr6, r6, #0\t    \t\t@ d.hi += carry\n+\tadds\tr5, r5, r1\t    \t\t@ d.lo += tmp.lo\n+\tmla\tr2, r14, r4, r2      \t\t@ tmp.hi += c.hi * (R1 >> 4)\n+\tadc\tr6, r6, r2\t   \t\t@ d.hi += carry + tmp.hi\n+\n+\tbic\tr2, r5, field_not_M \t\t@ r[1] = d & M\n+\tstr\tr2, [r0, #1*4]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26 (ignore hi)\n+\torr\tr5, r5, r6, asl #6\n+\n+\tadd\tr5, r5, r9\t  \t\t@ d += t2\n+\tstr\tr5, [r0, #2*4]      \t\t@ r[2] = d\n+\n+\tadd\tsp, sp, #48\n+\tldmfd\tsp!, {r4, r5, r6, r7, r8, r9, r10, r11, pc}\n+\t.size\tsecp256k1_fe_mul_inner, .-secp256k1_fe_mul_inner\n+\n+\t.align\t2\n+\t.global secp256k1_fe_sqr_inner\n+\t.type\tsecp256k1_fe_sqr_inner, %function\n+\t@ Arguments:\n+\t@  r0  r\t Can overlap with a\n+\t@  r1  a\n+\t@ Stack (total 4+10*4 = 44)\n+\t@  sp + #0        saved 'r' pointer\n+\t@  sp + #4 + 4*X  t0,t1,t2,t3,t4,t5,t6,t7,u8,t9\n+secp256k1_fe_sqr_inner:\n+\tstmfd\tsp!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}\n+\tsub\tsp, sp, #48\t\t\t@ frame=44 + alignment\n+\tstr     r0, [sp, #0]\t\t\t@ save result address, we need it only at the end\n+\t/******************************************\n+\t * Main computation code.\n+\t ******************************************\n+\n+\tAllocation:\n+\t    r0,r14,r2,r7,r8   scratch\n+\t    r1       a (pointer)\n+\t    r3:r4    c\n+\t    r5:r6    d\n+\t    r11:r12  c'\n+\t    r9:r10   d'\n+\n+\tNote: do not write to r[] here, it may overlap with a[]\n+\t*/\n+\t/* A interleaved with B */\n+\tldr\tr0, [r1, #1*4]\t\t\t@ a[1]*2\n+\tldr\tr7, [r1, #0*4]\t\t\t@ a[0]\n+\tmov\tr0, r0, asl #1\n+\tldr\tr14, [r1, #9*4]\t\t\t@ a[9]\n+\tumull\tr3, r4, r7, r7\t\t\t@ c = a[0] * a[0]\n+\tldr\tr8, [r1, #8*4]\t\t\t@ a[8]\n+\tmov\tr7, r7, asl #1\n+\tumull\tr5, r6, r7, r14\t\t\t@ d = a[0]*2 * a[9]\n+\tldr\tr7, [r1, #2*4]\t\t\t@ a[2]*2\n+\tumull\tr9, r10, r0, r14\t\t@ d' = a[1]*2 * a[9]\n+\tldr\tr14, [r1, #7*4]\t\t\t@ a[7]\n+\tumlal\tr5, r6, r0, r8\t\t\t@ d += a[1]*2 * a[8]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr0, [r1, #3*4]\t\t\t@ a[3]*2\n+\tumlal\tr9, r10, r7, r8\t\t\t@ d' += a[2]*2 * a[8]\n+\tldr\tr8, [r1, #6*4]\t\t\t@ a[6]\n+\tumlal\tr5, r6, r7, r14\t\t\t@ d += a[2]*2 * a[7]\n+\tmov\tr0, r0, asl #1\n+\tldr\tr7, [r1, #4*4]\t\t\t@ a[4]*2\n+\tumlal\tr9, r10, r0, r14\t\t@ d' += a[3]*2 * a[7]\n+\tldr\tr14, [r1, #5*4]\t\t\t@ a[5]\n+\tmov\tr7, r7, asl #1\n+\tumlal\tr5, r6, r0, r8\t\t\t@ d += a[3]*2 * a[6]\n+\tumlal\tr9, r10, r7, r8\t\t\t@ d' += a[4]*2 * a[6]\n+\tumlal\tr5, r6, r7, r14\t\t\t@ d += a[4]*2 * a[5]\n+\tumlal\tr9, r10, r14, r14\t\t@ d' += a[5] * a[5]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ t9 = d & M\n+\tstr     r0, [sp, #4 + 9*4]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26 \n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\n+\t/* B */\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u0 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u0 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t0 = c & M\n+\tstr\tr14, [sp, #4 + 0*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u0 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* C interleaved with D */\n+\tldr\tr0, [r1, #0*4]\t\t\t@ a[0]*2\n+\tldr\tr14, [r1, #1*4]\t\t\t@ a[1]\n+\tmov\tr0, r0, asl #1\n+\tldr\tr8, [r1, #2*4]\t\t\t@ a[2]\n+\tumlal\tr3, r4, r0, r14\t\t\t@ c += a[0]*2 * a[1]\n+\tmov\tr7, r8, asl #1                  @ a[2]*2\n+\tumull\tr11, r12, r14, r14\t\t@ c' = a[1] * a[1]\n+\tldr\tr14, [r1, #9*4]\t\t\t@ a[9]\n+\tumlal\tr11, r12, r0, r8\t\t@ c' += a[0]*2 * a[2]\n+\tldr\tr0, [r1, #3*4]\t\t\t@ a[3]*2\n+\tldr\tr8, [r1, #8*4]\t\t\t@ a[8]\n+\tumlal\tr5, r6, r7, r14\t\t\t@ d += a[2]*2 * a[9]\n+\tmov\tr0, r0, asl #1\n+\tldr\tr7, [r1, #4*4]\t\t\t@ a[4]*2\n+\tumull\tr9, r10, r0, r14\t\t@ d' = a[3]*2 * a[9]\n+\tldr\tr14, [r1, #7*4]\t\t\t@ a[7]\n+\tumlal\tr5, r6, r0, r8\t\t\t@ d += a[3]*2 * a[8]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr0, [r1, #5*4]\t\t\t@ a[5]*2\n+\tumlal\tr9, r10, r7, r8\t\t\t@ d' += a[4]*2 * a[8]\n+\tldr\tr8, [r1, #6*4]\t\t\t@ a[6]\n+\tmov\tr0, r0, asl #1\n+\tumlal\tr5, r6, r7, r14\t\t\t@ d += a[4]*2 * a[7]\n+\tumlal\tr9, r10, r0, r14\t\t@ d' += a[5]*2 * a[7]\n+\tumlal\tr5, r6, r0, r8\t\t\t@ d += a[5]*2 * a[6]\n+\tumlal\tr9, r10, r8, r8\t\t\t@ d' += a[6] * a[6]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u1 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u1 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t1 = c & M\n+\tstr\tr14, [sp, #4 + 1*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u1 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* D */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u2 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u2 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t2 = c & M\n+\tstr\tr14, [sp, #4 + 2*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u2 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* E interleaved with F */\n+\tldr\tr7, [r1, #0*4]\t\t\t@ a[0]*2\n+\tldr\tr0, [r1, #1*4]\t\t\t@ a[1]*2\n+\tldr\tr14, [r1, #2*4]\t\t\t@ a[2]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #3*4]\t\t\t@ a[3]\n+\tldr\tr2, [r1, #4*4]\n+\tumlal\tr3, r4, r7, r8\t\t\t@ c += a[0]*2 * a[3]\n+\tmov\tr0, r0, asl #1\n+\tumull\tr11, r12, r7, r2\t\t@ c' = a[0]*2 * a[4]\n+\tmov\tr2, r2, asl #1\t\t\t@ a[4]*2\n+\tumlal\tr11, r12, r0, r8\t\t@ c' += a[1]*2 * a[3]\n+\tldr\tr8, [r1, #9*4]\t\t\t@ a[9]\n+\tumlal\tr3, r4, r0, r14\t\t\t@ c += a[1]*2 * a[2]\n+\tldr\tr0, [r1, #5*4]\t\t\t@ a[5]*2\n+\tumlal\tr11, r12, r14, r14\t\t@ c' += a[2] * a[2]\n+\tldr\tr14, [r1, #8*4]\t\t\t@ a[8]\n+\tmov\tr0, r0, asl #1\n+\tumlal\tr5, r6, r2, r8\t\t\t@ d += a[4]*2 * a[9]\n+\tldr\tr7, [r1, #6*4]\t\t\t@ a[6]*2\n+\tumull\tr9, r10, r0, r8\t\t\t@ d' = a[5]*2 * a[9]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #7*4]\t\t\t@ a[7]\n+\tumlal\tr5, r6, r0, r14\t\t\t@ d += a[5]*2 * a[8]\n+\tumlal\tr9, r10, r7, r14\t\t@ d' += a[6]*2 * a[8]\n+\tumlal\tr5, r6, r7, r8\t\t\t@ d += a[6]*2 * a[7]\n+\tumlal\tr9, r10, r8, r8\t\t\t@ d' += a[7] * a[7]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u3 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u3 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t3 = c & M\n+\tstr\tr14, [sp, #4 + 3*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u3 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* F */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u4 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u4 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t4 = c & M\n+\tstr\tr14, [sp, #4 + 4*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u4 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* G interleaved with H */\n+\tldr\tr7, [r1, #0*4]\t\t\t@ a[0]*2\n+\tldr\tr0, [r1, #1*4]\t\t\t@ a[1]*2\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #5*4]\t\t\t@ a[5]\n+\tldr\tr2, [r1, #6*4]\t\t\t@ a[6]\n+\tumlal\tr3, r4, r7, r8\t\t\t@ c += a[0]*2 * a[5]\n+\tldr\tr14, [r1, #4*4]\t\t\t@ a[4]\n+\tmov\tr0, r0, asl #1\n+\tumull\tr11, r12, r7, r2\t\t@ c' = a[0]*2 * a[6]\n+\tldr\tr7, [r1, #2*4]\t\t\t@ a[2]*2\n+\tumlal\tr11, r12, r0, r8\t\t@ c' += a[1]*2 * a[5]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #3*4]\t\t\t@ a[3]\n+\tumlal\tr3, r4, r0, r14\t\t\t@ c += a[1]*2 * a[4]\n+\tmov\tr0, r2, asl #1\t\t\t@ a[6]*2\n+\tumlal\tr11, r12, r7, r14\t\t@ c' += a[2]*2 * a[4]\n+\tldr\tr14, [r1, #9*4]\t\t\t@ a[9]\n+\tumlal\tr3, r4, r7, r8\t\t\t@ c += a[2]*2 * a[3]\n+\tldr\tr7, [r1, #7*4]\t\t\t@ a[7]*2\n+\tumlal\tr11, r12, r8, r8\t\t@ c' += a[3] * a[3]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #8*4]\t\t\t@ a[8]\n+\tumlal\tr5, r6, r0, r14\t\t\t@ d += a[6]*2 * a[9]\n+\tumull\tr9, r10, r7, r14\t\t@ d' = a[7]*2 * a[9]\n+\tumlal\tr5, r6, r7, r8\t\t\t@ d += a[7]*2 * a[8]\n+\tumlal\tr9, r10, r8, r8\t\t\t@ d' += a[8] * a[8]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u5 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u5 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t5 = c & M\n+\tstr\tr14, [sp, #4 + 5*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u5 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* H */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u6 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u6 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t6 = c & M\n+\tstr\tr14, [sp, #4 + 6*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u6 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* I interleaved with J */\n+\tldr\tr7, [r1, #0*4]\t\t\t@ a[0]*2\n+\tldr\tr0, [r1, #1*4]\t\t\t@ a[1]*2\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #7*4]\t\t\t@ a[7]\n+\tldr\tr2, [r1, #8*4]\t\t\t@ a[8]\n+\tumlal\tr3, r4, r7, r8\t\t\t@ c += a[0]*2 * a[7]\n+\tldr\tr14, [r1, #6*4]\t\t\t@ a[6]\n+\tmov\tr0, r0, asl #1\n+\tumull\tr11, r12, r7, r2\t\t@ c' = a[0]*2 * a[8]\n+\tldr\tr7, [r1, #2*4]\t\t\t@ a[2]*2\n+\tumlal\tr11, r12, r0, r8\t\t@ c' += a[1]*2 * a[7]\n+\tldr\tr8, [r1, #5*4]\t\t\t@ a[5]\n+\tumlal\tr3, r4, r0, r14\t\t\t@ c += a[1]*2 * a[6]\n+\tldr\tr0, [r1, #3*4]\t\t\t@ a[3]*2\n+\tmov\tr7, r7, asl #1\n+\tumlal\tr11, r12, r7, r14\t\t@ c' += a[2]*2 * a[6]\n+\tldr\tr14, [r1, #4*4]\t\t\t@ a[4]\n+\tmov\tr0, r0, asl #1\n+\tumlal\tr3, r4, r7, r8\t\t\t@ c += a[2]*2 * a[5]\n+\tmov\tr2, r2, asl #1\t\t\t@ a[8]*2\n+\tumlal\tr11, r12, r0, r8\t\t@ c' += a[3]*2 * a[5]\n+\tumlal\tr3, r4, r0, r14\t\t\t@ c += a[3]*2 * a[4]\n+\tumlal\tr11, r12, r14, r14\t\t@ c' += a[4] * a[4]\n+\tldr\tr8, [r1, #9*4]\t\t\t@ a[9]\n+\tumlal\tr5, r6, r2, r8\t\t\t@ d += a[8]*2 * a[9]\n+\t@ r8 will be used in J\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u7 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u7 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t7 = c & M\n+\tstr\tr14, [sp, #4 + 7*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u7 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* J */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tumlal\tr5, r6, r8, r8\t\t\t@ d += a[9] * a[9]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u8 = d & M\n+\tstr\tr0, [sp, #4 + 8*4]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u8 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\t/******************************************\n+\t * compute and write back result\n+\t ******************************************\n+\tAllocation:\n+\t    r0    r\n+\t    r3:r4 c\n+\t    r5:r6 d\n+\t    r7    t0\n+\t    r8    t1\n+\t    r9    t2\n+\t    r11   u8\n+\t    r12   t9\n+\t    r1,r2,r10,r14 scratch\n+\n+\tNote: do not read from a[] after here, it may overlap with r[]\n+\t*/\n+\tldr\tr0, [sp, #0]\n+\tadd\tr1, sp, #4 + 3*4\t\t@ r[3..7] = t3..7, r11=u8, r12=t9\n+\tldmia\tr1, {r2,r7,r8,r9,r10,r11,r12}\n+\tadd\tr1, r0, #3*4\n+\tstmia\tr1, {r2,r7,r8,r9,r10}\n+\n+\tbic\tr2, r3, field_not_M \t\t@ r[8] = c & M\n+\tstr\tr2, [r0, #8*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u8 * R1\n+\tumlal   r3, r4, r11, r14\n+\tmovw    r14, field_R0\t\t\t@ c += d * R0\n+\tumlal   r3, r4, r5, r14\n+\tadds\tr3, r3, r12\t\t\t@ c += t9\n+\tadc\tr4, r4, #0\n+\n+\tadd\tr1, sp, #4 + 0*4\t\t@ r7,r8,r9 = t0,t1,t2\n+\tldmia\tr1, {r7,r8,r9}\n+\n+\tubfx\tr2, r3, #0, #22     \t\t@ r[9] = c & (M >> 4)\n+\tstr\tr2, [r0, #9*4]\n+\tmov\tr3, r3, lsr #22     \t\t@ c >>= 22\n+\torr\tr3, r3, r4, asl #10\n+\tmov     r4, r4, lsr #22\n+\tmovw    r14, field_R1 << 4   \t\t@ c += d * (R1 << 4)\n+\tumlal   r3, r4, r5, r14\n+\n+\tmovw    r14, field_R0 >> 4   \t\t@ d = c * (R0 >> 4) + t0 (64x64 multiply+add)\n+\tumull\tr5, r6, r3, r14\t\t\t@ d = c.lo * (R0 >> 4)\n+\tadds\tr5, r5, r7\t    \t\t@ d.lo += t0\n+\tmla\tr6, r14, r4, r6\t\t\t@ d.hi += c.hi * (R0 >> 4)\n+\tadc\tr6, r6, 0\t     \t\t@ d.hi += carry\n+\n+\tbic\tr2, r5, field_not_M \t\t@ r[0] = d & M\n+\tstr\tr2, [r0, #0*4]\n+\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\t\n+\tmovw    r14, field_R1 >> 4   \t\t@ d += c * (R1 >> 4) + t1 (64x64 multiply+add)\n+\tumull\tr1, r2, r3, r14       \t\t@ tmp = c.lo * (R1 >> 4)\n+\tadds\tr5, r5, r8\t    \t\t@ d.lo += t1\n+\tadc\tr6, r6, #0\t    \t\t@ d.hi += carry\n+\tadds\tr5, r5, r1\t    \t\t@ d.lo += tmp.lo\n+\tmla\tr2, r14, r4, r2      \t\t@ tmp.hi += c.hi * (R1 >> 4)\n+\tadc\tr6, r6, r2\t   \t\t@ d.hi += carry + tmp.hi\n+\n+\tbic\tr2, r5, field_not_M \t\t@ r[1] = d & M\n+\tstr\tr2, [r0, #1*4]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26 (ignore hi)\n+\torr\tr5, r5, r6, asl #6\n+\n+\tadd\tr5, r5, r9\t  \t\t@ d += t2\n+\tstr\tr5, [r0, #2*4]      \t\t@ r[2] = d\n+\n+\tadd\tsp, sp, #48\n+\tldmfd\tsp!, {r4, r5, r6, r7, r8, r9, r10, r11, pc}\n+\t.size\tsecp256k1_fe_sqr_inner, .-secp256k1_fe_sqr_inner\n+"
      },
      {
        "sha": "cde5e2dbb4e4ea1bd4fedced7ba1fecea7de8aa1",
        "filename": "src/secp256k1/src/bench_ecdh.c",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/bench_ecdh.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/bench_ecdh.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_ecdh.c?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -28,7 +28,8 @@ static void bench_ecdh_setup(void* arg) {\n         0xa2, 0xba, 0xd1, 0x84, 0xf8, 0x83, 0xc6, 0x9f\n     };\n \n-    data->ctx = secp256k1_context_create(0);\n+    /* create a context with no capabilities */\n+    data->ctx = secp256k1_context_create(SECP256K1_FLAGS_TYPE_CONTEXT);\n     for (i = 0; i < 32; i++) {\n         data->scalar[i] = i + 1;\n     }"
      },
      {
        "sha": "0809f77bda108dacd5a9a2c6208827c985f00f54",
        "filename": "src/secp256k1/src/bench_internal.c",
        "status": "modified",
        "additions": 31,
        "deletions": 3,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/bench_internal.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/bench_internal.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_internal.c?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -181,12 +181,12 @@ void bench_field_inverse_var(void* arg) {\n     }\n }\n \n-void bench_field_sqrt_var(void* arg) {\n+void bench_field_sqrt(void* arg) {\n     int i;\n     bench_inv_t *data = (bench_inv_t*)arg;\n \n     for (i = 0; i < 20000; i++) {\n-        secp256k1_fe_sqrt_var(&data->fe_x, &data->fe_x);\n+        secp256k1_fe_sqrt(&data->fe_x, &data->fe_x);\n         secp256k1_fe_add(&data->fe_x, &data->fe_y);\n     }\n }\n@@ -227,6 +227,15 @@ void bench_group_add_affine_var(void* arg) {\n     }\n }\n \n+void bench_group_jacobi_var(void* arg) {\n+    int i;\n+    bench_inv_t *data = (bench_inv_t*)arg;\n+\n+    for (i = 0; i < 20000; i++) {\n+        secp256k1_gej_has_quad_y_var(&data->gej_x);\n+    }\n+}\n+\n void bench_ecmult_wnaf(void* arg) {\n     int i;\n     bench_inv_t *data = (bench_inv_t*)arg;\n@@ -299,6 +308,21 @@ void bench_context_sign(void* arg) {\n     }\n }\n \n+#ifndef USE_NUM_NONE\n+void bench_num_jacobi(void* arg) {\n+    int i;\n+    bench_inv_t *data = (bench_inv_t*)arg;\n+    secp256k1_num nx, norder;\n+\n+    secp256k1_scalar_get_num(&nx, &data->scalar_x);\n+    secp256k1_scalar_order_get_num(&norder);\n+    secp256k1_scalar_get_num(&norder, &data->scalar_y);\n+\n+    for (i = 0; i < 200000; i++) {\n+        secp256k1_num_jacobi(&nx, &norder);\n+    }\n+}\n+#endif\n \n int have_flag(int argc, char** argv, char *flag) {\n     char** argm = argv + argc;\n@@ -333,12 +357,13 @@ int main(int argc, char **argv) {\n     if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"mul\")) run_benchmark(\"field_mul\", bench_field_mul, bench_setup, NULL, &data, 10, 200000);\n     if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse\", bench_field_inverse, bench_setup, NULL, &data, 10, 20000);\n     if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse_var\", bench_field_inverse_var, bench_setup, NULL, &data, 10, 20000);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"sqrt\")) run_benchmark(\"field_sqrt_var\", bench_field_sqrt_var, bench_setup, NULL, &data, 10, 20000);\n+    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"sqrt\")) run_benchmark(\"field_sqrt\", bench_field_sqrt, bench_setup, NULL, &data, 10, 20000);\n \n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"double\")) run_benchmark(\"group_double_var\", bench_group_double_var, bench_setup, NULL, &data, 10, 200000);\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_var\", bench_group_add_var, bench_setup, NULL, &data, 10, 200000);\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine\", bench_group_add_affine, bench_setup, NULL, &data, 10, 200000);\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine_var\", bench_group_add_affine_var, bench_setup, NULL, &data, 10, 200000);\n+    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"jacobi\")) run_benchmark(\"group_jacobi_var\", bench_group_jacobi_var, bench_setup, NULL, &data, 10, 20000);\n \n     if (have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"wnaf_const\", bench_wnaf_const, bench_setup, NULL, &data, 10, 20000);\n     if (have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"ecmult_wnaf\", bench_ecmult_wnaf, bench_setup, NULL, &data, 10, 20000);\n@@ -350,5 +375,8 @@ int main(int argc, char **argv) {\n     if (have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"verify\")) run_benchmark(\"context_verify\", bench_context_verify, bench_setup, NULL, &data, 10, 20);\n     if (have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"sign\")) run_benchmark(\"context_sign\", bench_context_sign, bench_setup, NULL, &data, 10, 200);\n \n+#ifndef USE_NUM_NONE\n+    if (have_flag(argc, argv, \"num\") || have_flag(argc, argv, \"jacobi\")) run_benchmark(\"num_jacobi\", bench_num_jacobi, bench_setup, NULL, &data, 10, 200000);\n+#endif\n     return 0;\n }"
      },
      {
        "sha": "418defa0aa22a06dff07d3f1567e205235706976",
        "filename": "src/secp256k1/src/bench_verify.c",
        "status": "modified",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/bench_verify.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/bench_verify.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_verify.c?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -11,6 +11,12 @@\n #include \"util.h\"\n #include \"bench.h\"\n \n+#ifdef ENABLE_OPENSSL_TESTS\n+#include <openssl/bn.h>\n+#include <openssl/ecdsa.h>\n+#include <openssl/obj_mac.h>\n+#endif\n+\n typedef struct {\n     secp256k1_context *ctx;\n     unsigned char msg[32];\n@@ -19,6 +25,9 @@ typedef struct {\n     size_t siglen;\n     unsigned char pubkey[33];\n     size_t pubkeylen;\n+#ifdef ENABLE_OPENSSL_TESTS\n+    EC_GROUP* ec_group;\n+#endif\n } benchmark_verify_t;\n \n static void benchmark_verify(void* arg) {\n@@ -40,6 +49,36 @@ static void benchmark_verify(void* arg) {\n     }\n }\n \n+#ifdef ENABLE_OPENSSL_TESTS\n+static void benchmark_verify_openssl(void* arg) {\n+    int i;\n+    benchmark_verify_t* data = (benchmark_verify_t*)arg;\n+\n+    for (i = 0; i < 20000; i++) {\n+        data->sig[data->siglen - 1] ^= (i & 0xFF);\n+        data->sig[data->siglen - 2] ^= ((i >> 8) & 0xFF);\n+        data->sig[data->siglen - 3] ^= ((i >> 16) & 0xFF);\n+        {\n+            EC_KEY *pkey = EC_KEY_new();\n+            const unsigned char *pubkey = &data->pubkey[0];\n+            int result;\n+\n+            CHECK(pkey != NULL);\n+            result = EC_KEY_set_group(pkey, data->ec_group);\n+            CHECK(result);\n+            result = (o2i_ECPublicKey(&pkey, &pubkey, data->pubkeylen)) != NULL;\n+            CHECK(result);\n+            result = ECDSA_verify(0, &data->msg[0], sizeof(data->msg), &data->sig[0], data->siglen, pkey) == (i == 0);\n+            CHECK(result);\n+            EC_KEY_free(pkey);\n+        }\n+        data->sig[data->siglen - 1] ^= (i & 0xFF);\n+        data->sig[data->siglen - 2] ^= ((i >> 8) & 0xFF);\n+        data->sig[data->siglen - 3] ^= ((i >> 16) & 0xFF);\n+    }\n+}\n+#endif\n+\n int main(void) {\n     int i;\n     secp256k1_pubkey pubkey;\n@@ -62,6 +101,11 @@ int main(void) {\n     CHECK(secp256k1_ec_pubkey_serialize(data.ctx, data.pubkey, &data.pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED) == 1);\n \n     run_benchmark(\"ecdsa_verify\", benchmark_verify, NULL, NULL, &data, 10, 20000);\n+#ifdef ENABLE_OPENSSL_TESTS\n+    data.ec_group = EC_GROUP_new_by_curve_name(NID_secp256k1);\n+    run_benchmark(\"ecdsa_verify_openssl\", benchmark_verify_openssl, NULL, NULL, &data, 10, 20000);\n+    EC_GROUP_free(data.ec_group);\n+#endif\n \n     secp256k1_context_destroy(data.ctx);\n     return 0;"
      },
      {
        "sha": "7a6a25318c4cf4a83ea60771755c59f7676dfc71",
        "filename": "src/secp256k1/src/ecmult_const_impl.h",
        "status": "modified",
        "additions": 23,
        "deletions": 44,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/ecmult_const_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/ecmult_const_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_const_impl.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -58,22 +58,24 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w) {\n     int global_sign;\n     int skew = 0;\n     int word = 0;\n+\n     /* 1 2 3 */\n     int u_last;\n     int u;\n \n-#ifdef USE_ENDOMORPHISM\n     int flip;\n     int bit;\n     secp256k1_scalar neg_s;\n     int not_neg_one;\n-    /* If we are using the endomorphism, we cannot handle even numbers by negating\n-     * them, since we are working with 128-bit numbers whose negations would be 256\n-     * bits, eliminating the performance advantage. Instead we use a technique from\n+    /* Note that we cannot handle even numbers by negating them to be odd, as is\n+     * done in other implementations, since if our scalars were specified to have\n+     * width < 256 for performance reasons, their negations would have width 256\n+     * and we'd lose any performance benefit. Instead, we use a technique from\n      * Section 4.2 of the Okeya/Tagaki paper, which is to add either 1 (for even)\n-     * or 2 (for odd) to the number we are encoding, then compensating after the\n-     * multiplication. */\n-    /* Negative 128-bit numbers will be negated, since otherwise they are 256-bit */\n+     * or 2 (for odd) to the number we are encoding, returning a skew value indicating\n+     * this, and having the caller compensate after doing the multiplication. */\n+\n+    /* Negative numbers will be negated to keep their bit representation below the maximum width */\n     flip = secp256k1_scalar_is_high(&s);\n     /* We add 1 to even numbers, 2 to odd ones, noting that negation flips parity */\n     bit = flip ^ (s.d[0] & 1);\n@@ -89,11 +91,6 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w) {\n     global_sign = secp256k1_scalar_cond_negate(&s, flip);\n     global_sign *= not_neg_one * 2 - 1;\n     skew = 1 << bit;\n-#else\n-    /* Otherwise, we just negate to force oddness */\n-    int is_even = secp256k1_scalar_is_even(&s);\n-    global_sign = secp256k1_scalar_cond_negate(&s, is_even);\n-#endif\n \n     /* 4 */\n     u_last = secp256k1_scalar_shr_int(&s, w);\n@@ -127,15 +124,13 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n     secp256k1_ge tmpa;\n     secp256k1_fe Z;\n \n+    int skew_1;\n+    int wnaf_1[1 + WNAF_SIZE(WINDOW_A - 1)];\n #ifdef USE_ENDOMORPHISM\n     secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n-    int wnaf_1[1 + WNAF_SIZE(WINDOW_A - 1)];\n     int wnaf_lam[1 + WNAF_SIZE(WINDOW_A - 1)];\n-    int skew_1;\n     int skew_lam;\n     secp256k1_scalar q_1, q_lam;\n-#else\n-    int wnaf[1 + WNAF_SIZE(WINDOW_A - 1)];\n #endif\n \n     int i;\n@@ -145,18 +140,10 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n #ifdef USE_ENDOMORPHISM\n     /* split q into q_1 and q_lam (where q = q_1 + q_lam*lambda, and q_1 and q_lam are ~128 bit) */\n     secp256k1_scalar_split_lambda(&q_1, &q_lam, &sc);\n-    /* no need for zero correction when using endomorphism since even\n-     * numbers have one added to them anyway */\n     skew_1   = secp256k1_wnaf_const(wnaf_1,   q_1,   WINDOW_A - 1);\n     skew_lam = secp256k1_wnaf_const(wnaf_lam, q_lam, WINDOW_A - 1);\n #else\n-    int is_zero = secp256k1_scalar_is_zero(scalar);\n-    /* the wNAF ladder cannot handle zero, so bump this to one .. we will\n-     * correct the result after the fact */\n-    sc.d[0] += is_zero;\n-    VERIFY_CHECK(!secp256k1_scalar_is_zero(&sc));\n-\n-    secp256k1_wnaf_const(wnaf, sc, WINDOW_A - 1);\n+    skew_1   = secp256k1_wnaf_const(wnaf_1, sc, WINDOW_A - 1);\n #endif\n \n     /* Calculate odd multiples of a.\n@@ -179,21 +166,15 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n     /* first loop iteration (separated out so we can directly set r, rather\n      * than having it start at infinity, get doubled several times, then have\n      * its new value added to it) */\n-#ifdef USE_ENDOMORPHISM\n     i = wnaf_1[WNAF_SIZE(WINDOW_A - 1)];\n     VERIFY_CHECK(i != 0);\n     ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a, i, WINDOW_A);\n     secp256k1_gej_set_ge(r, &tmpa);\n-\n+#ifdef USE_ENDOMORPHISM\n     i = wnaf_lam[WNAF_SIZE(WINDOW_A - 1)];\n     VERIFY_CHECK(i != 0);\n     ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a_lam, i, WINDOW_A);\n     secp256k1_gej_add_ge(r, r, &tmpa);\n-#else\n-    i = wnaf[WNAF_SIZE(WINDOW_A - 1)];\n-    VERIFY_CHECK(i != 0);\n-    ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a, i, WINDOW_A);\n-    secp256k1_gej_set_ge(r, &tmpa);\n #endif\n     /* remaining loop iterations */\n     for (i = WNAF_SIZE(WINDOW_A - 1) - 1; i >= 0; i--) {\n@@ -202,59 +183,57 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n         for (j = 0; j < WINDOW_A - 1; ++j) {\n             secp256k1_gej_double_nonzero(r, r, NULL);\n         }\n-#ifdef USE_ENDOMORPHISM\n+\n         n = wnaf_1[i];\n         ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a, n, WINDOW_A);\n         VERIFY_CHECK(n != 0);\n         secp256k1_gej_add_ge(r, r, &tmpa);\n-\n+#ifdef USE_ENDOMORPHISM\n         n = wnaf_lam[i];\n         ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a_lam, n, WINDOW_A);\n         VERIFY_CHECK(n != 0);\n         secp256k1_gej_add_ge(r, r, &tmpa);\n-#else\n-        n = wnaf[i];\n-        VERIFY_CHECK(n != 0);\n-        ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a, n, WINDOW_A);\n-        secp256k1_gej_add_ge(r, r, &tmpa);\n #endif\n     }\n \n     secp256k1_fe_mul(&r->z, &r->z, &Z);\n \n-#ifdef USE_ENDOMORPHISM\n     {\n         /* Correct for wNAF skew */\n         secp256k1_ge correction = *a;\n         secp256k1_ge_storage correction_1_stor;\n+#ifdef USE_ENDOMORPHISM\n         secp256k1_ge_storage correction_lam_stor;\n+#endif\n         secp256k1_ge_storage a2_stor;\n         secp256k1_gej tmpj;\n         secp256k1_gej_set_ge(&tmpj, &correction);\n         secp256k1_gej_double_var(&tmpj, &tmpj, NULL);\n         secp256k1_ge_set_gej(&correction, &tmpj);\n         secp256k1_ge_to_storage(&correction_1_stor, a);\n+#ifdef USE_ENDOMORPHISM\n         secp256k1_ge_to_storage(&correction_lam_stor, a);\n+#endif\n         secp256k1_ge_to_storage(&a2_stor, &correction);\n \n         /* For odd numbers this is 2a (so replace it), for even ones a (so no-op) */\n         secp256k1_ge_storage_cmov(&correction_1_stor, &a2_stor, skew_1 == 2);\n+#ifdef USE_ENDOMORPHISM\n         secp256k1_ge_storage_cmov(&correction_lam_stor, &a2_stor, skew_lam == 2);\n+#endif\n \n         /* Apply the correction */\n         secp256k1_ge_from_storage(&correction, &correction_1_stor);\n         secp256k1_ge_neg(&correction, &correction);\n         secp256k1_gej_add_ge(r, r, &correction);\n \n+#ifdef USE_ENDOMORPHISM\n         secp256k1_ge_from_storage(&correction, &correction_lam_stor);\n         secp256k1_ge_neg(&correction, &correction);\n         secp256k1_ge_mul_lambda(&correction, &correction);\n         secp256k1_gej_add_ge(r, r, &correction);\n-    }\n-#else\n-    /* correct for zero */\n-    r->infinity |= is_zero;\n #endif\n+    }\n }\n \n #endif"
      },
      {
        "sha": "81ae08e100b6b52ee6428eab17d15588acccdd51",
        "filename": "src/secp256k1/src/ecmult_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_impl.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -11,6 +11,8 @@\n #include \"scalar.h\"\n #include \"ecmult.h\"\n \n+#include <string.h>\n+\n /* optimal for 128-bit and 256-bit exponents. */\n #define WINDOW_A 5\n "
      },
      {
        "sha": "c5ba074244e6ab37bc53ac7d189a339e7cd42025",
        "filename": "src/secp256k1/src/field.h",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/field.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/field.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -57,6 +57,9 @@ static int secp256k1_fe_is_zero(const secp256k1_fe *a);\n static int secp256k1_fe_is_odd(const secp256k1_fe *a);\n \n /** Compare two field elements. Requires magnitude-1 inputs. */\n+static int secp256k1_fe_equal(const secp256k1_fe *a, const secp256k1_fe *b);\n+\n+/** Same as secp256k1_fe_equal, but may be variable time. */\n static int secp256k1_fe_equal_var(const secp256k1_fe *a, const secp256k1_fe *b);\n \n /** Compare two field elements. Requires both inputs to be normalized */\n@@ -92,7 +95,10 @@ static void secp256k1_fe_sqr(secp256k1_fe *r, const secp256k1_fe *a);\n  *  The input's magnitude can be at most 8. The output magnitude is 1 (but not\n  *  guaranteed to be normalized). The result in r will always be a square\n  *  itself. */\n-static int secp256k1_fe_sqrt_var(secp256k1_fe *r, const secp256k1_fe *a);\n+static int secp256k1_fe_sqrt(secp256k1_fe *r, const secp256k1_fe *a);\n+\n+/** Checks whether a field element is a quadratic residue. */\n+static int secp256k1_fe_is_quad_var(const secp256k1_fe *a);\n \n /** Sets a field element to be the (modular) inverse of another. Requires the input's magnitude to be\n  *  at most 8. The output magnitude is 1 (but not guaranteed to be normalized). */"
      },
      {
        "sha": "7b8c07960847ebe8a4dfde401bc6596795b83b15",
        "filename": "src/secp256k1/src/field_10x26_impl.h",
        "status": "modified",
        "additions": 9,
        "deletions": 3,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/field_10x26_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/field_10x26_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_10x26_impl.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -7,8 +7,6 @@\n #ifndef _SECP256K1_FIELD_REPR_IMPL_H_\n #define _SECP256K1_FIELD_REPR_IMPL_H_\n \n-#include <stdio.h>\n-#include <string.h>\n #include \"util.h\"\n #include \"num.h\"\n #include \"field.h\"\n@@ -429,6 +427,14 @@ SECP256K1_INLINE static void secp256k1_fe_add(secp256k1_fe *r, const secp256k1_f\n #endif\n }\n \n+#if defined(USE_EXTERNAL_ASM)\n+\n+/* External assembler implementation */\n+void secp256k1_fe_mul_inner(uint32_t *r, const uint32_t *a, const uint32_t * SECP256K1_RESTRICT b);\n+void secp256k1_fe_sqr_inner(uint32_t *r, const uint32_t *a);\n+\n+#else\n+\n #ifdef VERIFY\n #define VERIFY_BITS(x, n) VERIFY_CHECK(((x) >> (n)) == 0)\n #else\n@@ -1037,7 +1043,7 @@ SECP256K1_INLINE static void secp256k1_fe_sqr_inner(uint32_t *r, const uint32_t\n     VERIFY_BITS(r[2], 27);\n     /* [r9 r8 r7 r6 r5 r4 r3 r2 r1 r0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n }\n-\n+#endif\n \n static void secp256k1_fe_mul(secp256k1_fe *r, const secp256k1_fe *a, const secp256k1_fe * SECP256K1_RESTRICT b) {\n #ifdef VERIFY"
      },
      {
        "sha": "7a99eb21eccc6bcea99d6d015bf0a7307d26db21",
        "filename": "src/secp256k1/src/field_5x52_impl.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/field_5x52_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/field_5x52_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52_impl.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -11,7 +11,6 @@\n #include \"libsecp256k1-config.h\"\n #endif\n \n-#include <string.h>\n #include \"util.h\"\n #include \"num.h\"\n #include \"field.h\""
      },
      {
        "sha": "0bf22bdd3ec887251346dac826291fd1432c13ce",
        "filename": "src/secp256k1/src/field_5x52_int128_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/field_5x52_int128_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/field_5x52_int128_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52_int128_impl.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -137,7 +137,7 @@ SECP256K1_INLINE static void secp256k1_fe_mul_inner(uint64_t *r, const uint64_t\n     VERIFY_BITS(r[2], 52);\n     VERIFY_BITS(c, 63);\n     /* [d 0 0 0 t4 t3+c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n-    c   += d * R + t3;;\n+    c   += d * R + t3;\n     VERIFY_BITS(c, 100);\n     /* [t4 c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n     r[3] = c & M; c >>= 52;\n@@ -259,7 +259,7 @@ SECP256K1_INLINE static void secp256k1_fe_sqr_inner(uint64_t *r, const uint64_t\n     VERIFY_BITS(c, 63);\n     /* [d 0 0 0 t4 t3+c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n \n-    c   += d * R + t3;;\n+    c   += d * R + t3;\n     VERIFY_BITS(c, 100);\n     /* [t4 c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n     r[3] = c & M; c >>= 52;"
      },
      {
        "sha": "52cd902eb3873993a00bb2e2b2fa11857900dd65",
        "filename": "src/secp256k1/src/field_impl.h",
        "status": "modified",
        "additions": 34,
        "deletions": 2,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/field_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/field_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_impl.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -21,14 +21,21 @@\n #error \"Please select field implementation\"\n #endif\n \n+SECP256K1_INLINE static int secp256k1_fe_equal(const secp256k1_fe *a, const secp256k1_fe *b) {\n+    secp256k1_fe na;\n+    secp256k1_fe_negate(&na, a, 1);\n+    secp256k1_fe_add(&na, b);\n+    return secp256k1_fe_normalizes_to_zero(&na);\n+}\n+\n SECP256K1_INLINE static int secp256k1_fe_equal_var(const secp256k1_fe *a, const secp256k1_fe *b) {\n     secp256k1_fe na;\n     secp256k1_fe_negate(&na, a, 1);\n     secp256k1_fe_add(&na, b);\n     return secp256k1_fe_normalizes_to_zero_var(&na);\n }\n \n-static int secp256k1_fe_sqrt_var(secp256k1_fe *r, const secp256k1_fe *a) {\n+static int secp256k1_fe_sqrt(secp256k1_fe *r, const secp256k1_fe *a) {\n     /** Given that p is congruent to 3 mod 4, we can compute the square root of\n      *  a mod p as the (p+1)/4'th power of a.\n      *\n@@ -123,7 +130,7 @@ static int secp256k1_fe_sqrt_var(secp256k1_fe *r, const secp256k1_fe *a) {\n     /* Check that a square root was actually calculated */\n \n     secp256k1_fe_sqr(&t1, r);\n-    return secp256k1_fe_equal_var(&t1, a);\n+    return secp256k1_fe_equal(&t1, a);\n }\n \n static void secp256k1_fe_inv(secp256k1_fe *r, const secp256k1_fe *a) {\n@@ -280,4 +287,29 @@ static void secp256k1_fe_inv_all_var(size_t len, secp256k1_fe *r, const secp256k\n     r[0] = u;\n }\n \n+static int secp256k1_fe_is_quad_var(const secp256k1_fe *a) {\n+#ifndef USE_NUM_NONE\n+    unsigned char b[32];\n+    secp256k1_num n;\n+    secp256k1_num m;\n+    /* secp256k1 field prime, value p defined in \"Standards for Efficient Cryptography\" (SEC2) 2.7.1. */\n+    static const unsigned char prime[32] = {\n+        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+        0xFF,0xFF,0xFF,0xFE,0xFF,0xFF,0xFC,0x2F\n+    };\n+\n+    secp256k1_fe c = *a;\n+    secp256k1_fe_normalize_var(&c);\n+    secp256k1_fe_get_b32(b, &c);\n+    secp256k1_num_set_bin(&n, b, 32);\n+    secp256k1_num_set_bin(&m, prime, 32);\n+    return secp256k1_num_jacobi(&n, &m) >= 0;\n+#else\n+    secp256k1_fe r;\n+    return secp256k1_fe_sqrt(&r, a);\n+#endif\n+}\n+\n #endif"
      },
      {
        "sha": "d5157167447a77e94cbf04d9efa94c63cd7d0dca",
        "filename": "src/secp256k1/src/group.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/group.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/group.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -47,7 +47,7 @@ static void secp256k1_ge_set_xy(secp256k1_ge *r, const secp256k1_fe *x, const se\n  *  and a Y coordinate that is a quadratic residue modulo p. The return value\n  *  is true iff a coordinate with the given X coordinate exists.\n  */\n-static int secp256k1_ge_set_xquad_var(secp256k1_ge *r, const secp256k1_fe *x);\n+static int secp256k1_ge_set_xquad(secp256k1_ge *r, const secp256k1_fe *x);\n \n /** Set a group element (affine) equal to the point with the given X coordinate, and given oddness\n  *  for Y. Return value indicates whether the result is valid. */\n@@ -94,6 +94,9 @@ static void secp256k1_gej_neg(secp256k1_gej *r, const secp256k1_gej *a);\n /** Check whether a group element is the point at infinity. */\n static int secp256k1_gej_is_infinity(const secp256k1_gej *a);\n \n+/** Check whether a group element's y coordinate is a quadratic residue. */\n+static int secp256k1_gej_has_quad_y_var(const secp256k1_gej *a);\n+\n /** Set r equal to the double of a. If rzr is not-NULL, r->z = a->z * *rzr (where infinity means an implicit z = 0).\n  * a may not be zero. Constant time. */\n static void secp256k1_gej_double_nonzero(secp256k1_gej *r, const secp256k1_gej *a, secp256k1_fe *rzr);"
      },
      {
        "sha": "3e9c4c410d4132dc1a2ab62075997b10645bd5f5",
        "filename": "src/secp256k1/src/group_impl.h",
        "status": "modified",
        "additions": 30,
        "deletions": 6,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group_impl.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -7,8 +7,6 @@\n #ifndef _SECP256K1_GROUP_IMPL_H_\n #define _SECP256K1_GROUP_IMPL_H_\n \n-#include <string.h>\n-\n #include \"num.h\"\n #include \"field.h\"\n #include \"group.h\"\n@@ -165,19 +163,19 @@ static void secp256k1_ge_clear(secp256k1_ge *r) {\n     secp256k1_fe_clear(&r->y);\n }\n \n-static int secp256k1_ge_set_xquad_var(secp256k1_ge *r, const secp256k1_fe *x) {\n+static int secp256k1_ge_set_xquad(secp256k1_ge *r, const secp256k1_fe *x) {\n     secp256k1_fe x2, x3, c;\n     r->x = *x;\n     secp256k1_fe_sqr(&x2, x);\n     secp256k1_fe_mul(&x3, x, &x2);\n     r->infinity = 0;\n     secp256k1_fe_set_int(&c, 7);\n     secp256k1_fe_add(&c, &x3);\n-    return secp256k1_fe_sqrt_var(&r->y, &c);\n+    return secp256k1_fe_sqrt(&r->y, &c);\n }\n \n static int secp256k1_ge_set_xo_var(secp256k1_ge *r, const secp256k1_fe *x, int odd) {\n-    if (!secp256k1_ge_set_xquad_var(r, x)) {\n+    if (!secp256k1_ge_set_xquad(r, x)) {\n         return 0;\n     }\n     secp256k1_fe_normalize_var(&r->y);\n@@ -251,11 +249,23 @@ static int secp256k1_ge_is_valid_var(const secp256k1_ge *a) {\n }\n \n static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, secp256k1_fe *rzr) {\n-    /* Operations: 3 mul, 4 sqr, 0 normalize, 12 mul_int/add/negate */\n+    /* Operations: 3 mul, 4 sqr, 0 normalize, 12 mul_int/add/negate.\n+     *\n+     * Note that there is an implementation described at\n+     *     https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l\n+     * which trades a multiply for a square, but in practice this is actually slower,\n+     * mainly because it requires more normalizations.\n+     */\n     secp256k1_fe t1,t2,t3,t4;\n     /** For secp256k1, 2Q is infinity if and only if Q is infinity. This is because if 2Q = infinity,\n      *  Q must equal -Q, or that Q.y == -(Q.y), or Q.y is 0. For a point on y^2 = x^3 + 7 to have\n      *  y=0, x^3 must be -7 mod p. However, -7 has no cube root mod p.\n+     *  \n+     *  Having said this, if this function receives a point on a sextic twist, e.g. by\n+     *  a fault attack, it is possible for y to be 0. This happens for y^2 = x^3 + 6,\n+     *  since -6 does have a cube root mod p. For this point, this function will not set\n+     *  the infinity flag even though the point doubles to infinity, and the result\n+     *  point will be gibberish (z = 0 but infinity = 0).\n      */\n     r->infinity = a->infinity;\n     if (r->infinity) {\n@@ -623,4 +633,18 @@ static void secp256k1_ge_mul_lambda(secp256k1_ge *r, const secp256k1_ge *a) {\n }\n #endif\n \n+static int secp256k1_gej_has_quad_y_var(const secp256k1_gej *a) {\n+    secp256k1_fe yz;\n+\n+    if (a->infinity) {\n+        return 0;\n+    }\n+\n+    /* We rely on the fact that the Jacobi symbol of 1 / a->z^3 is the same as\n+     * that of a->z. Thus a->y / a->z^3 is a quadratic residue iff a->y * a->z\n+       is */\n+    secp256k1_fe_mul(&yz, &a->y, &a->z);\n+    return secp256k1_fe_is_quad_var(&yz);\n+}\n+\n #endif"
      },
      {
        "sha": "fca98cab9f8315bd4fa5c165d9f8e2f16dc2a493",
        "filename": "src/secp256k1/src/hash.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/hash.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -11,7 +11,7 @@\n #include <stdint.h>\n \n typedef struct {\n-    uint32_t s[32];\n+    uint32_t s[8];\n     uint32_t buf[16]; /* In big endian */\n     size_t bytes;\n } secp256k1_sha256_t;"
      },
      {
        "sha": "b47e65f830a906fc0eb9ff7939d62966823202b1",
        "filename": "src/secp256k1/src/hash_impl.h",
        "status": "modified",
        "additions": 4,
        "deletions": 6,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/hash_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/hash_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/hash_impl.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -269,15 +269,13 @@ static void secp256k1_rfc6979_hmac_sha256_finalize(secp256k1_rfc6979_hmac_sha256\n     rng->retry = 0;\n }\n \n-\n+#undef BE32\n #undef Round\n-#undef sigma0\n #undef sigma1\n-#undef Sigma0\n+#undef sigma0\n #undef Sigma1\n-#undef Ch\n+#undef Sigma0\n #undef Maj\n-#undef ReadBE32\n-#undef WriteBE32\n+#undef Ch\n \n #endif"
      },
      {
        "sha": "be67048fbed69e04b799cba74232aee471782747",
        "filename": "src/secp256k1/src/java/org/bitcoin/NativeSecp256k1.java",
        "status": "modified",
        "additions": 445,
        "deletions": 27,
        "changes": 472,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1.java?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -1,60 +1,478 @@\n+/*\n+ * Copyright 2013 Google Inc.\n+ * Copyright 2014-2016 the libsecp256k1 contributors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n package org.bitcoin;\n \n import java.nio.ByteBuffer;\n import java.nio.ByteOrder;\n \n+import java.math.BigInteger;\n import com.google.common.base.Preconditions;\n-\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import static org.bitcoin.NativeSecp256k1Util.*;\n \n /**\n- * This class holds native methods to handle ECDSA verification.\n- * You can find an example library that can be used for this at\n- * https://github.com/sipa/secp256k1\n+ * <p>This class holds native methods to handle ECDSA verification.</p>\n+ *\n+ * <p>You can find an example library that can be used for this at https://github.com/bitcoin/secp256k1</p>\n+ *\n+ * <p>To build secp256k1 for use with bitcoinj, run\n+ * `./configure --enable-jni --enable-experimental --enable-module-schnorr --enable-module-ecdh`\n+ * and `make` then copy `.libs/libsecp256k1.so` to your system library path\n+ * or point the JVM to the folder containing it with -Djava.library.path\n+ * </p>\n  */\n public class NativeSecp256k1 {\n-    public static final boolean enabled;\n-    static {\n-        boolean isEnabled = true;\n-        try {\n-            System.loadLibrary(\"javasecp256k1\");\n-        } catch (UnsatisfiedLinkError e) {\n-            isEnabled = false;\n-        }\n-        enabled = isEnabled;\n-    }\n-    \n+\n+    private static final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n+    private static final Lock r = rwl.readLock();\n+    private static final Lock w = rwl.writeLock();\n     private static ThreadLocal<ByteBuffer> nativeECDSABuffer = new ThreadLocal<ByteBuffer>();\n     /**\n      * Verifies the given secp256k1 signature in native code.\n      * Calling when enabled == false is undefined (probably library not loaded)\n-     * \n+     *\n      * @param data The data which was signed, must be exactly 32 bytes\n      * @param signature The signature\n      * @param pub The public key which did the signing\n      */\n-    public static boolean verify(byte[] data, byte[] signature, byte[] pub) {\n+    public static boolean verify(byte[] data, byte[] signature, byte[] pub) throws AssertFailException{\n         Preconditions.checkArgument(data.length == 32 && signature.length <= 520 && pub.length <= 520);\n \n         ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null) {\n-            byteBuff = ByteBuffer.allocateDirect(32 + 8 + 520 + 520);\n+        if (byteBuff == null || byteBuff.capacity() < 520) {\n+            byteBuff = ByteBuffer.allocateDirect(520);\n             byteBuff.order(ByteOrder.nativeOrder());\n             nativeECDSABuffer.set(byteBuff);\n         }\n         byteBuff.rewind();\n         byteBuff.put(data);\n-        byteBuff.putInt(signature.length);\n-        byteBuff.putInt(pub.length);\n         byteBuff.put(signature);\n         byteBuff.put(pub);\n-        return secp256k1_ecdsa_verify(byteBuff) == 1;\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ecdsa_verify(byteBuff, Secp256k1Context.getContext(), signature.length, pub.length) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+    /**\n+     * libsecp256k1 Create an ECDSA signature.\n+     *\n+     * @param data Message hash, 32 bytes\n+     * @param key Secret key, 32 bytes\n+     *\n+     * Return values\n+     * @param sig byte array of signature\n+     */\n+    public static byte[] sign(byte[] data, byte[] sec) throws AssertFailException{\n+        Preconditions.checkArgument(data.length == 32 && sec.length <= 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + 32) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 32);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.put(sec);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ecdsa_sign(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] sigArr = retByteArray[0];\n+        int sigLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(sigArr.length, sigLen, \"Got bad signature length.\");\n+\n+        return retVal == 0 ? new byte[0] : sigArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Seckey Verify - returns 1 if valid, 0 if invalid\n+     *\n+     * @param seckey ECDSA Secret key, 32 bytes\n+     */\n+    public static boolean secKeyVerify(byte[] seckey) {\n+        Preconditions.checkArgument(seckey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ec_seckey_verify(byteBuff,Secp256k1Context.getContext()) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+\n+    /**\n+     * libsecp256k1 Compute Pubkey - computes public key from secret key\n+     *\n+     * @param seckey ECDSA Secret key, 32 bytes\n+     *\n+     * Return values\n+     * @param pubkey ECDSA Public key, 33 or 65 bytes\n+     */\n+    //TODO add a 'compressed' arg\n+    public static byte[] computePubkey(byte[] seckey) throws AssertFailException{\n+        Preconditions.checkArgument(seckey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ec_pubkey_create(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+        int pubLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        return retVal == 0 ? new byte[0]: pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Cleanup - This destroys the secp256k1 context object\n+     * This should be called at the end of the program for proper cleanup of the context.\n+     */\n+    public static synchronized void cleanup() {\n+        w.lock();\n+        try {\n+          secp256k1_destroy_context(Secp256k1Context.getContext());\n+        } finally {\n+          w.unlock();\n+        }\n+    }\n+\n+    public static long cloneContext() {\n+       r.lock();\n+       try {\n+        return secp256k1_ctx_clone(Secp256k1Context.getContext());\n+       } finally { r.unlock(); }\n+    }\n+\n+    /**\n+     * libsecp256k1 PrivKey Tweak-Mul - Tweak privkey by multiplying to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param seckey 32-byte seckey\n+     */\n+    public static byte[] privKeyTweakMul(byte[] privkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_privkey_tweak_mul(byteBuff,Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n     }\n \n     /**\n-     * @param byteBuff signature format is byte[32] data,\n-     *        native-endian int signatureLength, native-endian int pubkeyLength,\n-     *        byte[signatureLength] signature, byte[pubkeyLength] pub\n-     * @returns 1 for valid signature, anything else for invalid\n+     * libsecp256k1 PrivKey Tweak-Add - Tweak privkey by adding to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param seckey 32-byte seckey\n      */\n-    private static native int secp256k1_ecdsa_verify(ByteBuffer byteBuff);\n+    public static byte[] privKeyTweakAdd(byte[] privkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_privkey_tweak_add(byteBuff,Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PubKey Tweak-Add - Tweak pubkey by adding to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param pubkey 32-byte seckey\n+     */\n+    public static byte[] pubKeyTweakAdd(byte[] pubkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(pubkey.length == 33 || pubkey.length == 65);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < pubkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(pubkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(pubkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_pubkey_tweak_add(byteBuff,Secp256k1Context.getContext(), pubkey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+\n+        int pubLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PubKey Tweak-Mul - Tweak pubkey by multiplying to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param pubkey 32-byte seckey\n+     */\n+    public static byte[] pubKeyTweakMul(byte[] pubkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(pubkey.length == 33 || pubkey.length == 65);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < pubkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(pubkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(pubkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_pubkey_tweak_mul(byteBuff,Secp256k1Context.getContext(), pubkey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+\n+        int pubLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 create ECDH secret - constant time ECDH calculation\n+     *\n+     * @param seckey byte array of secret key used in exponentiaion\n+     * @param pubkey byte array of public key used in exponentiaion\n+     */\n+    public static byte[] createECDHSecret(byte[] seckey, byte[] pubkey) throws AssertFailException{\n+        Preconditions.checkArgument(seckey.length <= 32 && pubkey.length <= 65);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + pubkey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + pubkey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+        byteBuff.put(pubkey);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ecdh(byteBuff, Secp256k1Context.getContext(), pubkey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] resArr = retByteArray[0];\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+\n+        assertEquals(resArr.length, 32, \"Got bad result length.\");\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return resArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 randomize - updates the context randomization\n+     *\n+     * @param seed 32-byte random seed\n+     */\n+    public static synchronized boolean randomize(byte[] seed) throws AssertFailException{\n+        Preconditions.checkArgument(seed.length == 32 || seed == null);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seed.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seed.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seed);\n+\n+        w.lock();\n+        try {\n+          return secp256k1_context_randomize(byteBuff, Secp256k1Context.getContext()) == 1;\n+        } finally {\n+          w.unlock();\n+        }\n+    }\n+\n+    public static byte[] schnorrSign(byte[] data, byte[] sec) throws AssertFailException {\n+        Preconditions.checkArgument(data.length == 32 && sec.length <= 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 32);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.put(sec);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_schnorr_sign(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] sigArr = retByteArray[0];\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+\n+        assertEquals(sigArr.length, 64, \"Got bad signature length.\");\n+\n+        return retVal == 0 ? new byte[0] : sigArr;\n+    }\n+\n+    private static native long secp256k1_ctx_clone(long context);\n+\n+    private static native int secp256k1_context_randomize(ByteBuffer byteBuff, long context);\n+\n+    private static native byte[][] secp256k1_privkey_tweak_add(ByteBuffer byteBuff, long context);\n+\n+    private static native byte[][] secp256k1_privkey_tweak_mul(ByteBuffer byteBuff, long context);\n+\n+    private static native byte[][] secp256k1_pubkey_tweak_add(ByteBuffer byteBuff, long context, int pubLen);\n+\n+    private static native byte[][] secp256k1_pubkey_tweak_mul(ByteBuffer byteBuff, long context, int pubLen);\n+\n+    private static native void secp256k1_destroy_context(long context);\n+\n+    private static native int secp256k1_ecdsa_verify(ByteBuffer byteBuff, long context, int sigLen, int pubLen);\n+\n+    private static native byte[][] secp256k1_ecdsa_sign(ByteBuffer byteBuff, long context);\n+\n+    private static native int secp256k1_ec_seckey_verify(ByteBuffer byteBuff, long context);\n+\n+    private static native byte[][] secp256k1_ec_pubkey_create(ByteBuffer byteBuff, long context);\n+\n+    private static native byte[][] secp256k1_ec_pubkey_parse(ByteBuffer byteBuff, long context, int inputLen);\n+\n+    private static native byte[][] secp256k1_schnorr_sign(ByteBuffer byteBuff, long context);\n+\n+    private static native byte[][] secp256k1_ecdh(ByteBuffer byteBuff, long context, int inputLen);\n+\n }"
      },
      {
        "sha": "f18ce95810d138fbf40e7a0b03d9c43e3d29593f",
        "filename": "src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "status": "added",
        "additions": 247,
        "deletions": 0,
        "changes": 247,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -0,0 +1,247 @@\n+package org.bitcoin;\n+\n+import com.google.common.io.BaseEncoding;\n+import java.util.Arrays;\n+import java.math.BigInteger;\n+import javax.xml.bind.DatatypeConverter;\n+import static org.bitcoin.NativeSecp256k1Util.*;\n+\n+/**\n+ * This class holds test cases defined for testing this library.\n+ */\n+public class NativeSecp256k1Test {\n+\n+    //TODO improve comments/add more tests\n+    /**\n+      * This tests verify() for a valid signature\n+      */\n+    public static void testVerifyPos() throws AssertFailException{\n+        boolean result = false;\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A90\".toLowerCase()); //sha256hash of \"testing\"\n+        byte[] sig = BaseEncoding.base16().lowerCase().decode(\"3044022079BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F817980220294F14E883B3F525B5367756C2A11EF6CF84B730B36C17CB0C56F0AAB2C98589\".toLowerCase());\n+        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n+\n+        result = NativeSecp256k1.verify( data, sig, pub);\n+        assertEquals( result, true , \"testVerifyPos\");\n+    }\n+\n+    /**\n+      * This tests verify() for a non-valid signature\n+      */\n+    public static void testVerifyNeg() throws AssertFailException{\n+        boolean result = false;\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A91\".toLowerCase()); //sha256hash of \"testing\"\n+        byte[] sig = BaseEncoding.base16().lowerCase().decode(\"3044022079BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F817980220294F14E883B3F525B5367756C2A11EF6CF84B730B36C17CB0C56F0AAB2C98589\".toLowerCase());\n+        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n+\n+        result = NativeSecp256k1.verify( data, sig, pub);\n+        //System.out.println(\" TEST \" + new BigInteger(1, resultbytes).toString(16));\n+        assertEquals( result, false , \"testVerifyNeg\");\n+    }\n+\n+    /**\n+      * This tests secret key verify() for a valid secretkey\n+      */\n+    public static void testSecKeyVerifyPos() throws AssertFailException{\n+        boolean result = false;\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+\n+        result = NativeSecp256k1.secKeyVerify( sec );\n+        //System.out.println(\" TEST \" + new BigInteger(1, resultbytes).toString(16));\n+        assertEquals( result, true , \"testSecKeyVerifyPos\");\n+    }\n+\n+    /**\n+      * This tests secret key verify() for a invalid secretkey\n+      */\n+    public static void testSecKeyVerifyNeg() throws AssertFailException{\n+        boolean result = false;\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n+\n+        result = NativeSecp256k1.secKeyVerify( sec );\n+        //System.out.println(\" TEST \" + new BigInteger(1, resultbytes).toString(16));\n+        assertEquals( result, false , \"testSecKeyVerifyNeg\");\n+    }\n+\n+    /**\n+      * This tests public key create() for a valid secretkey\n+      */\n+    public static void testPubKeyCreatePos() throws AssertFailException{\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+\n+        byte[] resultArr = NativeSecp256k1.computePubkey( sec);\n+        String pubkeyString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( pubkeyString , \"04C591A8FF19AC9C4E4E5793673B83123437E975285E7B442F4EE2654DFFCA5E2D2103ED494718C697AC9AEBCFD19612E224DB46661011863ED2FC54E71861E2A6\" , \"testPubKeyCreatePos\");\n+    }\n+\n+    /**\n+      * This tests public key create() for a invalid secretkey\n+      */\n+    public static void testPubKeyCreateNeg() throws AssertFailException{\n+       byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n+\n+       byte[] resultArr = NativeSecp256k1.computePubkey( sec);\n+       String pubkeyString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+       assertEquals( pubkeyString, \"\" , \"testPubKeyCreateNeg\");\n+    }\n+\n+    /**\n+      * This tests sign() for a valid secretkey\n+      */\n+    public static void testSignPos() throws AssertFailException{\n+\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A90\".toLowerCase()); //sha256hash of \"testing\"\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+\n+        byte[] resultArr = NativeSecp256k1.sign(data, sec);\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString, \"30440220182A108E1448DC8F1FB467D06A0F3BB8EA0533584CB954EF8DA112F1D60E39A202201C66F36DA211C087F3AF88B50EDF4F9BDAA6CF5FD6817E74DCA34DB12390C6E9\" , \"testSignPos\");\n+    }\n+\n+    /**\n+      * This tests sign() for a invalid secretkey\n+      */\n+    public static void testSignNeg() throws AssertFailException{\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A90\".toLowerCase()); //sha256hash of \"testing\"\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n+\n+        byte[] resultArr = NativeSecp256k1.sign(data, sec);\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString, \"\" , \"testSignNeg\");\n+    }\n+\n+    /**\n+      * This tests private key tweak-add\n+      */\n+    public static void testPrivKeyTweakAdd_1() throws AssertFailException {\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n+\n+        byte[] resultArr = NativeSecp256k1.privKeyTweakAdd( sec , data );\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString , \"A168571E189E6F9A7E2D657A4B53AE99B909F7E712D1C23CED28093CD57C88F3\" , \"testPrivKeyAdd_1\");\n+    }\n+\n+    /**\n+      * This tests private key tweak-mul\n+      */\n+    public static void testPrivKeyTweakMul_1() throws AssertFailException {\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n+\n+        byte[] resultArr = NativeSecp256k1.privKeyTweakMul( sec , data );\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString , \"97F8184235F101550F3C71C927507651BD3F1CDB4A5A33B8986ACF0DEE20FFFC\" , \"testPrivKeyMul_1\");\n+    }\n+\n+    /**\n+      * This tests private key tweak-add uncompressed\n+      */\n+    public static void testPrivKeyTweakAdd_2() throws AssertFailException {\n+        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n+\n+        byte[] resultArr = NativeSecp256k1.pubKeyTweakAdd( pub , data );\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString , \"0411C6790F4B663CCE607BAAE08C43557EDC1A4D11D88DFCB3D841D0C6A941AF525A268E2A863C148555C48FB5FBA368E88718A46E205FABC3DBA2CCFFAB0796EF\" , \"testPrivKeyAdd_2\");\n+    }\n+\n+    /**\n+      * This tests private key tweak-mul uncompressed\n+      */\n+    public static void testPrivKeyTweakMul_2() throws AssertFailException {\n+        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n+\n+        byte[] resultArr = NativeSecp256k1.pubKeyTweakMul( pub , data );\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString , \"04E0FE6FE55EBCA626B98A807F6CAF654139E14E5E3698F01A9A658E21DC1D2791EC060D4F412A794D5370F672BC94B722640B5F76914151CFCA6E712CA48CC589\" , \"testPrivKeyMul_2\");\n+    }\n+\n+    /**\n+      * This tests seed randomization\n+      */\n+    public static void testRandomize() throws AssertFailException {\n+        byte[] seed = BaseEncoding.base16().lowerCase().decode(\"A441B15FE9A3CF56661190A0B93B9DEC7D04127288CC87250967CF3B52894D11\".toLowerCase()); //sha256hash of \"random\"\n+        boolean result = NativeSecp256k1.randomize(seed);\n+        assertEquals( result, true, \"testRandomize\");\n+    }\n+\n+    /**\n+      * This tests signSchnorr() for a valid secretkey\n+      */\n+    public static void testSchnorrSign() throws AssertFailException{\n+\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A90\".toLowerCase()); //sha256hash of \"testing\"\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+\n+        byte[] resultArr = NativeSecp256k1.schnorrSign(data, sec);\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString, \"C5E929AA058B982048760422D3B563749B7D0E50C5EBD8CD2FFC23214BD6A2F1B072C13880997EBA847CF20F2F90FCE07C1CA33A890A4127095A351127F8D95F\" , \"testSchnorrSign\");\n+    }\n+\n+    /**\n+      * This tests signSchnorr() for a valid secretkey\n+      */\n+    public static void testCreateECDHSecret() throws AssertFailException{\n+\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n+\n+        byte[] resultArr = NativeSecp256k1.createECDHSecret(sec, pub);\n+        String ecdhString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( ecdhString, \"2A2A67007A926E6594AF3EB564FC74005B37A9C8AEF2033C4552051B5C87F043\" , \"testCreateECDHSecret\");\n+    }\n+\n+    public static void main(String[] args) throws AssertFailException{\n+\n+\n+        System.out.println(\"\\n libsecp256k1 enabled: \" + Secp256k1Context.isEnabled() + \"\\n\");\n+\n+        assertEquals( Secp256k1Context.isEnabled(), true, \"isEnabled\" );\n+\n+        //Test verify() success/fail\n+        testVerifyPos();\n+        testVerifyNeg();\n+\n+        //Test secKeyVerify() success/fail\n+        testSecKeyVerifyPos();\n+        testSecKeyVerifyNeg();\n+\n+        //Test computePubkey() success/fail\n+        testPubKeyCreatePos();\n+        testPubKeyCreateNeg();\n+\n+        //Test sign() success/fail\n+        testSignPos();\n+        testSignNeg();\n+\n+        //Test Schnorr (partial support) //TODO\n+        testSchnorrSign();\n+        //testSchnorrVerify\n+        //testSchnorrRecovery\n+\n+        //Test privKeyTweakAdd() 1\n+        testPrivKeyTweakAdd_1();\n+\n+        //Test privKeyTweakMul() 2\n+        testPrivKeyTweakMul_1();\n+\n+        //Test privKeyTweakAdd() 3\n+        testPrivKeyTweakAdd_2();\n+\n+        //Test privKeyTweakMul() 4\n+        testPrivKeyTweakMul_2();\n+\n+        //Test randomize()\n+        testRandomize();\n+\n+        //Test ECDH\n+        testCreateECDHSecret();\n+\n+        NativeSecp256k1.cleanup();\n+\n+        System.out.println(\" All tests passed.\" );\n+\n+    }\n+}"
      },
      {
        "sha": "04732ba044363a5dc5c525661a090c1bdf1d077f",
        "filename": "src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Util.java",
        "status": "added",
        "additions": 45,
        "deletions": 0,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Util.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Util.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Util.java?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2014-2016 the libsecp256k1 contributors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.bitcoin;\n+\n+public class NativeSecp256k1Util{\n+\n+    public static void assertEquals( int val, int val2, String message ) throws AssertFailException{\n+      if( val != val2 )\n+        throw new AssertFailException(\"FAIL: \" + message);\n+    }\n+\n+    public static void assertEquals( boolean val, boolean val2, String message ) throws AssertFailException{\n+      if( val != val2 )\n+        throw new AssertFailException(\"FAIL: \" + message);\n+      else\n+        System.out.println(\"PASS: \" + message);\n+    }\n+\n+    public static void assertEquals( String val, String val2, String message ) throws AssertFailException{\n+      if( !val.equals(val2) )\n+        throw new AssertFailException(\"FAIL: \" + message);\n+      else\n+        System.out.println(\"PASS: \" + message);\n+    }\n+\n+    public static class AssertFailException extends Exception {\n+      public AssertFailException(String message) {\n+        super( message );\n+      }\n+    }\n+}"
      },
      {
        "sha": "216c986a8b564d49b01243d513bdd182339e51b6",
        "filename": "src/secp256k1/src/java/org/bitcoin/Secp256k1Context.java",
        "status": "added",
        "additions": 51,
        "deletions": 0,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/java/org/bitcoin/Secp256k1Context.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/java/org/bitcoin/Secp256k1Context.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org/bitcoin/Secp256k1Context.java?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2014-2016 the libsecp256k1 contributors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.bitcoin;\n+\n+/**\n+ * This class holds the context reference used in native methods \n+ * to handle ECDSA operations.\n+ */\n+public class Secp256k1Context {\n+  private static final boolean enabled; //true if the library is loaded\n+  private static final long context; //ref to pointer to context obj\n+\n+  static { //static initializer\n+      boolean isEnabled = true;\n+      long contextRef = -1;\n+      try {\n+          System.loadLibrary(\"secp256k1\");\n+          contextRef = secp256k1_init_context();\n+      } catch (UnsatisfiedLinkError e) {\n+          System.out.println(\"UnsatisfiedLinkError: \" + e.toString());\n+          isEnabled = false;\n+      }\n+      enabled = isEnabled;\n+      context = contextRef;\n+  }\n+\n+  public static boolean isEnabled() {\n+     return enabled;\n+  }\n+\n+  public static long getContext() {\n+     if(!enabled) return -1; //sanity check\n+     return context;\n+  }\n+\n+  private static native long secp256k1_init_context();\n+}"
      },
      {
        "sha": "dba9524dd4cc291058e70f7b6574e846d64035f3",
        "filename": "src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "status": "modified",
        "additions": 400,
        "deletions": 12,
        "changes": 412,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -1,23 +1,411 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <string.h>\n #include \"org_bitcoin_NativeSecp256k1.h\"\n #include \"include/secp256k1.h\"\n+#include \"include/secp256k1_ecdh.h\"\n+#include \"include/secp256k1_recovery.h\"\n+#include \"include/secp256k1_schnorr.h\"\n \n-JNIEXPORT jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject)\n+\n+SECP256K1_API jlong JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ctx_1clone\n+  (JNIEnv* env, jclass classObject, jlong ctx_l)\n+{\n+  const secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+\n+  jlong ctx_clone_l = (uintptr_t) secp256k1_context_clone(ctx);\n+\n+  (void)classObject;(void)env;\n+\n+  return ctx_clone_l;\n+\n+}\n+\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1context_1randomize\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+\n+  const unsigned char* seed = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+\n+  (void)classObject;\n+\n+  return secp256k1_context_randomize(ctx, seed);\n+\n+}\n+\n+SECP256K1_API void JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1destroy_1context\n+  (JNIEnv* env, jclass classObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+\n+  secp256k1_context_destroy(ctx);\n+\n+  (void)classObject;(void)env;\n+}\n+\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint siglen, jint publen)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+\n+  unsigned char* data = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* sigdata = {  (unsigned char*) (data + 32) };\n+  const unsigned char* pubdata = { (unsigned char*) (data + siglen + 32) };\n+\n+  secp256k1_ecdsa_signature sig;\n+  secp256k1_pubkey pubkey;\n+\n+  int ret = secp256k1_ecdsa_signature_parse_der(ctx, &sig, sigdata, siglen);\n+\n+  if( ret ) {\n+    ret = secp256k1_ec_pubkey_parse(ctx, &pubkey, pubdata, publen);\n+\n+    if( ret ) {\n+      ret = secp256k1_ecdsa_verify(ctx, &sig, data, &pubkey);\n+    }\n+  }\n+\n+  (void)classObject;\n+\n+  return ret;\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1sign\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  unsigned char* data = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  unsigned char* secKey = (unsigned char*) (data + 32);\n+\n+  jobjectArray retArray;\n+  jbyteArray sigArray, intsByteArray;\n+  unsigned char intsarray[2];\n+\n+  secp256k1_ecdsa_signature sig[72];\n+\n+  int ret = secp256k1_ecdsa_sign(ctx, sig, data, secKey, NULL, NULL );\n+\n+  unsigned char outputSer[72];\n+  size_t outputLen = 72;\n+\n+  if( ret ) {\n+    int ret2 = secp256k1_ecdsa_signature_serialize_der(ctx,outputSer, &outputLen, sig ); (void)ret2;\n+  }\n+\n+  intsarray[0] = outputLen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  sigArray = (*env)->NewByteArray(env, outputLen);\n+  (*env)->SetByteArrayRegion(env, sigArray, 0, outputLen, (jbyte*)outputSer);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, sigArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+}\n+\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1seckey_1verify\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  unsigned char* secKey = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+\n+  (void)classObject;\n+\n+  return secp256k1_ec_seckey_verify(ctx, secKey);\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1pubkey_1create\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  const unsigned char* secKey = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+\n+  secp256k1_pubkey pubkey;\n+\n+  jobjectArray retArray;\n+  jbyteArray pubkeyArray, intsByteArray;\n+  unsigned char intsarray[2];\n+\n+  int ret = secp256k1_ec_pubkey_create(ctx, &pubkey, secKey);\n+\n+  unsigned char outputSer[65];\n+  size_t outputLen = 65;\n+\n+  if( ret ) {\n+    int ret2 = secp256k1_ec_pubkey_serialize(ctx,outputSer, &outputLen, &pubkey,SECP256K1_EC_UNCOMPRESSED );(void)ret2;\n+  }\n+\n+  intsarray[0] = outputLen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  pubkeyArray = (*env)->NewByteArray(env, outputLen);\n+  (*env)->SetByteArrayRegion(env, pubkeyArray, 0, outputLen, (jbyte*)outputSer);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, pubkeyArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1privkey_1tweak_1add\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  unsigned char* privkey = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* tweak = (unsigned char*) (privkey + 32);\n+\n+  jobjectArray retArray;\n+  jbyteArray privArray, intsByteArray;\n+  unsigned char intsarray[2];\n+\n+  int privkeylen = 32;\n+\n+  int ret = secp256k1_ec_privkey_tweak_add(ctx, privkey, tweak);\n+\n+  intsarray[0] = privkeylen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  privArray = (*env)->NewByteArray(env, privkeylen);\n+  (*env)->SetByteArrayRegion(env, privArray, 0, privkeylen, (jbyte*)privkey);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, privArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1privkey_1tweak_1mul\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  unsigned char* privkey = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* tweak = (unsigned char*) (privkey + 32);\n+\n+  jobjectArray retArray;\n+  jbyteArray privArray, intsByteArray;\n+  unsigned char intsarray[2];\n+\n+  int privkeylen = 32;\n+\n+  int ret = secp256k1_ec_privkey_tweak_mul(ctx, privkey, tweak);\n+\n+  intsarray[0] = privkeylen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  privArray = (*env)->NewByteArray(env, privkeylen);\n+  (*env)->SetByteArrayRegion(env, privArray, 0, privkeylen, (jbyte*)privkey);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, privArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1pubkey_1tweak_1add\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+/*  secp256k1_pubkey* pubkey = (secp256k1_pubkey*) (*env)->GetDirectBufferAddress(env, byteBufferObject);*/\n+  unsigned char* pkey = (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* tweak = (unsigned char*) (pkey + publen);\n+\n+  jobjectArray retArray;\n+  jbyteArray pubArray, intsByteArray;\n+  unsigned char intsarray[2];\n+  unsigned char outputSer[65];\n+  size_t outputLen = 65;\n+\n+  secp256k1_pubkey pubkey;\n+  int ret = secp256k1_ec_pubkey_parse(ctx, &pubkey, pkey, publen);\n+\n+  if( ret ) {\n+    ret = secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, tweak);\n+  }\n+\n+  if( ret ) {\n+    int ret2 = secp256k1_ec_pubkey_serialize(ctx,outputSer, &outputLen, &pubkey,SECP256K1_EC_UNCOMPRESSED );(void)ret2;\n+  }\n+\n+  intsarray[0] = outputLen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  pubArray = (*env)->NewByteArray(env, outputLen);\n+  (*env)->SetByteArrayRegion(env, pubArray, 0, outputLen, (jbyte*)outputSer);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, pubArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1pubkey_1tweak_1mul\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen)\n {\n-\tunsigned char* data = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n-\tint sigLen = *((int*)(data + 32));\n-\tint pubLen = *((int*)(data + 32 + 4));\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  unsigned char* pkey = (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* tweak = (unsigned char*) (pkey + publen);\n+\n+  jobjectArray retArray;\n+  jbyteArray pubArray, intsByteArray;\n+  unsigned char intsarray[2];\n+  unsigned char outputSer[65];\n+  size_t outputLen = 65;\n+\n+  secp256k1_pubkey pubkey;\n+  int ret = secp256k1_ec_pubkey_parse(ctx, &pubkey, pkey, publen);\n+\n+  if ( ret ) {\n+    ret = secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, tweak);\n+  }\n+\n+  if( ret ) {\n+    int ret2 = secp256k1_ec_pubkey_serialize(ctx,outputSer, &outputLen, &pubkey,SECP256K1_EC_UNCOMPRESSED );(void)ret2;\n+  }\n+\n+  intsarray[0] = outputLen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  pubArray = (*env)->NewByteArray(env, outputLen);\n+  (*env)->SetByteArrayRegion(env, pubArray, 0, outputLen, (jbyte*)outputSer);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, pubArray);\n \n-\treturn secp256k1_ecdsa_verify(data, 32, data+32+8, sigLen, data+32+8+sigLen, pubLen);\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n }\n \n-static void __javasecp256k1_attach(void) __attribute__((constructor));\n-static void __javasecp256k1_detach(void) __attribute__((destructor));\n+SECP256K1_API jlong JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1pubkey_1combine\n+  (JNIEnv * env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint numkeys)\n+{\n+  (void)classObject;(void)env;(void)byteBufferObject;(void)ctx_l;(void)numkeys;\n \n-static void __javasecp256k1_attach(void) {\n-\tsecp256k1_start(SECP256K1_START_VERIFY);\n+  return 0;\n }\n \n-static void __javasecp256k1_detach(void) {\n-\tsecp256k1_stop();\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1schnorr_1sign\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  unsigned char* data = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  unsigned char* secKey = (unsigned char*) (data + 32);\n+\n+  jobjectArray retArray;\n+  jbyteArray sigArray, intsByteArray;\n+  unsigned char intsarray[1];\n+  unsigned char sig[64];\n+\n+  int ret = secp256k1_schnorr_sign(ctx, sig, data, secKey, NULL, NULL);\n+\n+  intsarray[0] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  sigArray = (*env)->NewByteArray(env, 64);\n+  (*env)->SetByteArrayRegion(env, sigArray, 0, 64, (jbyte*)sig);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, sigArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 1);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 1, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdh\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  const unsigned char* secdata = (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* pubdata = (const unsigned char*) (secdata + 32);\n+\n+  jobjectArray retArray;\n+  jbyteArray outArray, intsByteArray;\n+  unsigned char intsarray[1];\n+  secp256k1_pubkey pubkey;\n+  unsigned char nonce_res[32];\n+  size_t outputLen = 32;\n+\n+  int ret = secp256k1_ec_pubkey_parse(ctx, &pubkey, pubdata, publen);\n+\n+  if (ret) {\n+    ret = secp256k1_ecdh(\n+      ctx,\n+      nonce_res,\n+      &pubkey,\n+      secdata\n+    );\n+  }\n+\n+  intsarray[0] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  outArray = (*env)->NewByteArray(env, outputLen);\n+  (*env)->SetByteArrayRegion(env, outArray, 0, 32, (jbyte*)nonce_res);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, outArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 1);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 1, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n }"
      },
      {
        "sha": "4125a1f5233beae400c4846ad975a7b6b47721d6",
        "filename": "src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.h",
        "status": "modified",
        "additions": 109,
        "deletions": 3,
        "changes": 112,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -1,19 +1,125 @@\n /* DO NOT EDIT THIS FILE - it is machine generated */\n #include <jni.h>\n+#include \"include/secp256k1.h\"\n /* Header for class org_bitcoin_NativeSecp256k1 */\n \n #ifndef _Included_org_bitcoin_NativeSecp256k1\n #define _Included_org_bitcoin_NativeSecp256k1\n #ifdef __cplusplus\n extern \"C\" {\n #endif\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ctx_clone\n+ * Signature: (J)J\n+ */\n+SECP256K1_API jlong JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ctx_1clone\n+  (JNIEnv *, jclass, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_context_randomize\n+ * Signature: (Ljava/nio/ByteBuffer;J)I\n+ */\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1context_1randomize\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_privkey_tweak_add\n+ * Signature: (Ljava/nio/ByteBuffer;J)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1privkey_1tweak_1add\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_privkey_tweak_mul\n+ * Signature: (Ljava/nio/ByteBuffer;J)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1privkey_1tweak_1mul\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_pubkey_tweak_add\n+ * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1pubkey_1tweak_1add\n+  (JNIEnv *, jclass, jobject, jlong, jint);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_pubkey_tweak_mul\n+ * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1pubkey_1tweak_1mul\n+  (JNIEnv *, jclass, jobject, jlong, jint);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_destroy_context\n+ * Signature: (J)V\n+ */\n+SECP256K1_API void JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1destroy_1context\n+  (JNIEnv *, jclass, jlong);\n+\n /*\n  * Class:     org_bitcoin_NativeSecp256k1\n  * Method:    secp256k1_ecdsa_verify\n- * Signature: (Ljava/nio/ByteBuffer;)I\n+ * Signature: (Ljava/nio/ByteBuffer;JII)I\n+ */\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify\n+  (JNIEnv *, jclass, jobject, jlong, jint, jint);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ecdsa_sign\n+ * Signature: (Ljava/nio/ByteBuffer;J)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1sign\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ec_seckey_verify\n+ * Signature: (Ljava/nio/ByteBuffer;J)I\n+ */\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1seckey_1verify\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ec_pubkey_create\n+ * Signature: (Ljava/nio/ByteBuffer;J)[[B\n  */\n-JNIEXPORT jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify\n-  (JNIEnv *, jclass, jobject);\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1pubkey_1create\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ec_pubkey_parse\n+ * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1pubkey_1parse\n+  (JNIEnv *, jclass, jobject, jlong, jint);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_schnorr_sign\n+ * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1schnorr_1sign\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ecdh\n+ * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdh\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen);\n+\n \n #ifdef __cplusplus\n }"
      },
      {
        "sha": "a52939e7e7dacda374ec879d69b29ebb9add2dbc",
        "filename": "src/secp256k1/src/java/org_bitcoin_Secp256k1Context.c",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/java/org_bitcoin_Secp256k1Context.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/java/org_bitcoin_Secp256k1Context.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org_bitcoin_Secp256k1Context.c?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -0,0 +1,15 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include \"org_bitcoin_Secp256k1Context.h\"\n+#include \"include/secp256k1.h\"\n+\n+SECP256K1_API jlong JNICALL Java_org_bitcoin_Secp256k1Context_secp256k1_1init_1context\n+  (JNIEnv* env, jclass classObject)\n+{\n+  secp256k1_context *ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+\n+  (void)classObject;(void)env;\n+\n+  return (uintptr_t)ctx;\n+}\n+"
      },
      {
        "sha": "0d2bc84b7f3fde84f81115a037be6de105f0472b",
        "filename": "src/secp256k1/src/java/org_bitcoin_Secp256k1Context.h",
        "status": "added",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/java/org_bitcoin_Secp256k1Context.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/java/org_bitcoin_Secp256k1Context.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org_bitcoin_Secp256k1Context.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -0,0 +1,22 @@\n+/* DO NOT EDIT THIS FILE - it is machine generated */\n+#include <jni.h>\n+#include \"include/secp256k1.h\"\n+/* Header for class org_bitcoin_Secp256k1Context */\n+\n+#ifndef _Included_org_bitcoin_Secp256k1Context\n+#define _Included_org_bitcoin_Secp256k1Context\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+/*\n+ * Class:     org_bitcoin_Secp256k1Context\n+ * Method:    secp256k1_init_context\n+ * Signature: ()J\n+ */\n+SECP256K1_API jlong JNICALL Java_org_bitcoin_Secp256k1Context_secp256k1_1init_1context\n+  (JNIEnv *, jclass);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+#endif"
      },
      {
        "sha": "e3088b469790bdc14b8982931d5729a7eabde69b",
        "filename": "src/secp256k1/src/modules/ecdh/Makefile.am.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/modules/ecdh/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/modules/ecdh/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/ecdh/Makefile.am.include?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -4,5 +4,5 @@ noinst_HEADERS += src/modules/ecdh/tests_impl.h\n if USE_BENCHMARK\n noinst_PROGRAMS += bench_ecdh\n bench_ecdh_SOURCES = src/bench_ecdh.c\n-bench_ecdh_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_ecdh_LDADD = libsecp256k1.la $(SECP_LIBS) $(COMMON_LIB)\n endif"
      },
      {
        "sha": "bf23c26e71c5dd88df965141295bb33144007147",
        "filename": "src/secp256k1/src/modules/recovery/Makefile.am.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/modules/recovery/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/modules/recovery/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/Makefile.am.include?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -4,5 +4,5 @@ noinst_HEADERS += src/modules/recovery/tests_impl.h\n if USE_BENCHMARK\n noinst_PROGRAMS += bench_recover\n bench_recover_SOURCES = src/bench_recover.c\n-bench_recover_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_recover_LDADD = libsecp256k1.la $(SECP_LIBS) $(COMMON_LIB)\n endif"
      },
      {
        "sha": "f1af8e83255fd0c1e0bd7d051dcaed609bae1447",
        "filename": "src/secp256k1/src/modules/schnorr/Makefile.am.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/modules/schnorr/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/modules/schnorr/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorr/Makefile.am.include?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -6,5 +6,5 @@ noinst_HEADERS += src/modules/schnorr/tests_impl.h\n if USE_BENCHMARK\n noinst_PROGRAMS += bench_schnorr_verify\n bench_schnorr_verify_SOURCES = src/bench_schnorr_verify.c\n-bench_schnorr_verify_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_schnorr_verify_LDADD = libsecp256k1.la $(SECP_LIBS) $(COMMON_LIB)\n endif"
      },
      {
        "sha": "7bb9c5be8cf5a6d020ef4bfcac1af13902e5d533",
        "filename": "src/secp256k1/src/num.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/num.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/num.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/num.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -32,6 +32,9 @@ static void secp256k1_num_set_bin(secp256k1_num *r, const unsigned char *a, unsi\n /** Compute a modular inverse. The input must be less than the modulus. */\n static void secp256k1_num_mod_inverse(secp256k1_num *r, const secp256k1_num *a, const secp256k1_num *m);\n \n+/** Compute the jacobi symbol (a|b). b must be positive and odd. */\n+static int secp256k1_num_jacobi(const secp256k1_num *a, const secp256k1_num *b);\n+\n /** Compare the absolute value of two numbers. */\n static int secp256k1_num_cmp(const secp256k1_num *a, const secp256k1_num *b);\n \n@@ -57,6 +60,9 @@ static void secp256k1_num_shift(secp256k1_num *r, int bits);\n /** Check whether a number is zero. */\n static int secp256k1_num_is_zero(const secp256k1_num *a);\n \n+/** Check whether a number is one. */\n+static int secp256k1_num_is_one(const secp256k1_num *a);\n+\n /** Check whether a number is strictly negative. */\n static int secp256k1_num_is_neg(const secp256k1_num *a);\n "
      },
      {
        "sha": "3a46495eeac7d979a87871ca20ce30c2010a54ce",
        "filename": "src/secp256k1/src/num_gmp_impl.h",
        "status": "modified",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/num_gmp_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/num_gmp_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/num_gmp_impl.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -144,6 +144,32 @@ static void secp256k1_num_mod_inverse(secp256k1_num *r, const secp256k1_num *a,\n     memset(v, 0, sizeof(v));\n }\n \n+static int secp256k1_num_jacobi(const secp256k1_num *a, const secp256k1_num *b) {\n+    int ret;\n+    mpz_t ga, gb;\n+    secp256k1_num_sanity(a);\n+    secp256k1_num_sanity(b);\n+    VERIFY_CHECK(!b->neg && (b->limbs > 0) && (b->data[0] & 1));\n+\n+    mpz_inits(ga, gb, NULL);\n+\n+    mpz_import(gb, b->limbs, -1, sizeof(mp_limb_t), 0, 0, b->data);\n+    mpz_import(ga, a->limbs, -1, sizeof(mp_limb_t), 0, 0, a->data);\n+    if (a->neg) {\n+        mpz_neg(ga, ga);\n+    }\n+\n+    ret = mpz_jacobi(ga, gb);\n+\n+    mpz_clears(ga, gb, NULL);\n+\n+    return ret;\n+}\n+\n+static int secp256k1_num_is_one(const secp256k1_num *a) {\n+    return (a->limbs == 1 && a->data[0] == 1);\n+}\n+\n static int secp256k1_num_is_zero(const secp256k1_num *a) {\n     return (a->limbs == 1 && a->data[0] == 0);\n }"
      },
      {
        "sha": "c5baf4df413e0895135f3c4f974998d97613e836",
        "filename": "src/secp256k1/src/scalar_impl.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_impl.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -7,8 +7,6 @@\n #ifndef _SECP256K1_SCALAR_IMPL_H_\n #define _SECP256K1_SCALAR_IMPL_H_\n \n-#include <string.h>\n-\n #include \"group.h\"\n #include \"scalar.h\"\n "
      },
      {
        "sha": "7973d60c36a81e6bd5cc765a9e038d12b1790195",
        "filename": "src/secp256k1/src/secp256k1.c",
        "status": "modified",
        "additions": 4,
        "deletions": 11,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/secp256k1.c?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -4,8 +4,6 @@\n  * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n  **********************************************************************/\n \n-#define SECP256K1_BUILD (1)\n-\n #include \"include/secp256k1.h\"\n \n #include \"util.h\"\n@@ -152,7 +150,6 @@ static void secp256k1_pubkey_save(secp256k1_pubkey* pubkey, secp256k1_ge* ge) {\n int secp256k1_ec_pubkey_parse(const secp256k1_context* ctx, secp256k1_pubkey* pubkey, const unsigned char *input, size_t inputlen) {\n     secp256k1_ge Q;\n \n-    (void)ctx;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(pubkey != NULL);\n     memset(pubkey, 0, sizeof(*pubkey));\n@@ -170,7 +167,6 @@ int secp256k1_ec_pubkey_serialize(const secp256k1_context* ctx, unsigned char *o\n     size_t len;\n     int ret = 0;\n \n-    (void)ctx;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(outputlen != NULL);\n     ARG_CHECK(*outputlen >= ((flags & SECP256K1_FLAGS_BIT_COMPRESSION) ? 33 : 65));\n@@ -216,7 +212,7 @@ static void secp256k1_ecdsa_signature_save(secp256k1_ecdsa_signature* sig, const\n int secp256k1_ecdsa_signature_parse_der(const secp256k1_context* ctx, secp256k1_ecdsa_signature* sig, const unsigned char *input, size_t inputlen) {\n     secp256k1_scalar r, s;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(sig != NULL);\n     ARG_CHECK(input != NULL);\n \n@@ -234,7 +230,7 @@ int secp256k1_ecdsa_signature_parse_compact(const secp256k1_context* ctx, secp25\n     int ret = 1;\n     int overflow = 0;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(sig != NULL);\n     ARG_CHECK(input64 != NULL);\n \n@@ -253,7 +249,7 @@ int secp256k1_ecdsa_signature_parse_compact(const secp256k1_context* ctx, secp25\n int secp256k1_ecdsa_signature_serialize_der(const secp256k1_context* ctx, unsigned char *output, size_t *outputlen, const secp256k1_ecdsa_signature* sig) {\n     secp256k1_scalar r, s;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(output != NULL);\n     ARG_CHECK(outputlen != NULL);\n     ARG_CHECK(sig != NULL);\n@@ -265,7 +261,7 @@ int secp256k1_ecdsa_signature_serialize_der(const secp256k1_context* ctx, unsign\n int secp256k1_ecdsa_signature_serialize_compact(const secp256k1_context* ctx, unsigned char *output64, const secp256k1_ecdsa_signature* sig) {\n     secp256k1_scalar r, s;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(output64 != NULL);\n     ARG_CHECK(sig != NULL);\n \n@@ -398,7 +394,6 @@ int secp256k1_ec_seckey_verify(const secp256k1_context* ctx, const unsigned char\n     int overflow;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(seckey != NULL);\n-    (void)ctx;\n \n     secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n     ret = !overflow && !secp256k1_scalar_is_zero(&sec);\n@@ -437,7 +432,6 @@ int secp256k1_ec_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(seckey != NULL);\n     ARG_CHECK(tweak != NULL);\n-    (void)ctx;\n \n     secp256k1_scalar_set_b32(&term, tweak, &overflow);\n     secp256k1_scalar_set_b32(&sec, seckey, NULL);\n@@ -485,7 +479,6 @@ int secp256k1_ec_privkey_tweak_mul(const secp256k1_context* ctx, unsigned char *\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(seckey != NULL);\n     ARG_CHECK(tweak != NULL);\n-    (void)ctx;\n \n     secp256k1_scalar_set_b32(&factor, tweak, &overflow);\n     secp256k1_scalar_set_b32(&sec, seckey, NULL);"
      },
      {
        "sha": "b32cb90813718cd1feae8bea86c4c0990c96a70a",
        "filename": "src/secp256k1/src/tests.c",
        "status": "modified",
        "additions": 166,
        "deletions": 24,
        "changes": 190,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/secp256k1/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests.c?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -473,6 +473,8 @@ void test_num_negate(void) {\n }\n \n void test_num_add_sub(void) {\n+    int i;\n+    secp256k1_scalar s;\n     secp256k1_num n1;\n     secp256k1_num n2;\n     secp256k1_num n1p2, n2p1, n1m2, n2m1;\n@@ -498,13 +500,119 @@ void test_num_add_sub(void) {\n     CHECK(!secp256k1_num_eq(&n2p1, &n1));\n     secp256k1_num_sub(&n2p1, &n2p1, &n2); /* n2p1 = R2 + R1 - R2 = R1 */\n     CHECK(secp256k1_num_eq(&n2p1, &n1));\n+\n+    /* check is_one */\n+    secp256k1_scalar_set_int(&s, 1);\n+    secp256k1_scalar_get_num(&n1, &s);\n+    CHECK(secp256k1_num_is_one(&n1));\n+    /* check that 2^n + 1 is never 1 */\n+    secp256k1_scalar_get_num(&n2, &s);\n+    for (i = 0; i < 250; ++i) {\n+        secp256k1_num_add(&n1, &n1, &n1);    /* n1 *= 2 */\n+        secp256k1_num_add(&n1p2, &n1, &n2);  /* n1p2 = n1 + 1 */\n+        CHECK(!secp256k1_num_is_one(&n1p2));\n+    }\n+}\n+\n+void test_num_mod(void) {\n+    int i;\n+    secp256k1_scalar s;\n+    secp256k1_num order, n;\n+\n+    /* check that 0 mod anything is 0 */\n+    random_scalar_order_test(&s); \n+    secp256k1_scalar_get_num(&order, &s);\n+    secp256k1_scalar_set_int(&s, 0);\n+    secp256k1_scalar_get_num(&n, &s);\n+    secp256k1_num_mod(&n, &order);\n+    CHECK(secp256k1_num_is_zero(&n));\n+\n+    /* check that anything mod 1 is 0 */\n+    secp256k1_scalar_set_int(&s, 1);\n+    secp256k1_scalar_get_num(&order, &s);\n+    secp256k1_scalar_get_num(&n, &s);\n+    secp256k1_num_mod(&n, &order);\n+    CHECK(secp256k1_num_is_zero(&n));\n+\n+    /* check that increasing the number past 2^256 does not break this */\n+    random_scalar_order_test(&s); \n+    secp256k1_scalar_get_num(&n, &s);\n+    /* multiply by 2^8, which'll test this case with high probability */\n+    for (i = 0; i < 8; ++i) {\n+        secp256k1_num_add(&n, &n, &n);\n+    }\n+    secp256k1_num_mod(&n, &order);\n+    CHECK(secp256k1_num_is_zero(&n));\n+}\n+\n+void test_num_jacobi(void) {\n+    secp256k1_scalar sqr;\n+    secp256k1_scalar small;\n+    secp256k1_scalar five;  /* five is not a quadratic residue */\n+    secp256k1_num order, n;\n+    int i;\n+    /* squares mod 5 are 1, 4 */\n+    const int jacobi5[10] = { 0, 1, -1, -1, 1, 0, 1, -1, -1, 1 };\n+\n+    /* check some small values with 5 as the order */\n+    secp256k1_scalar_set_int(&five, 5);\n+    secp256k1_scalar_get_num(&order, &five);\n+    for (i = 0; i < 10; ++i) {\n+        secp256k1_scalar_set_int(&small, i);\n+        secp256k1_scalar_get_num(&n, &small);\n+        CHECK(secp256k1_num_jacobi(&n, &order) == jacobi5[i]);\n+    }\n+\n+    /** test large values with 5 as group order */\n+    secp256k1_scalar_get_num(&order, &five);\n+    /* we first need a scalar which is not a multiple of 5 */\n+    do {\n+        secp256k1_num fiven;\n+        random_scalar_order_test(&sqr); \n+        secp256k1_scalar_get_num(&fiven, &five);\n+        secp256k1_scalar_get_num(&n, &sqr);\n+        secp256k1_num_mod(&n, &fiven);\n+    } while (secp256k1_num_is_zero(&n));\n+    /* next force it to be a residue. 2 is a nonresidue mod 5 so we can\n+     * just multiply by two, i.e. add the number to itself */\n+    if (secp256k1_num_jacobi(&n, &order) == -1) {\n+        secp256k1_num_add(&n, &n, &n);\n+    }\n+\n+    /* test residue */\n+    CHECK(secp256k1_num_jacobi(&n, &order) == 1);\n+    /* test nonresidue */\n+    secp256k1_num_add(&n, &n, &n);\n+    CHECK(secp256k1_num_jacobi(&n, &order) == -1);\n+\n+    /** test with secp group order as order */\n+    secp256k1_scalar_order_get_num(&order);\n+    random_scalar_order_test(&sqr); \n+    secp256k1_scalar_sqr(&sqr, &sqr);\n+    /* test residue */\n+    secp256k1_scalar_get_num(&n, &sqr);\n+    CHECK(secp256k1_num_jacobi(&n, &order) == 1);\n+    /* test nonresidue */\n+    secp256k1_scalar_mul(&sqr, &sqr, &five);\n+    secp256k1_scalar_get_num(&n, &sqr);\n+    CHECK(secp256k1_num_jacobi(&n, &order) == -1);\n+    /* test multiple of the order*/\n+    CHECK(secp256k1_num_jacobi(&order, &order) == 0);\n+\n+    /* check one less than the order */\n+    secp256k1_scalar_set_int(&small, 1);\n+    secp256k1_scalar_get_num(&n, &small);\n+    secp256k1_num_sub(&n, &order, &n);\n+    CHECK(secp256k1_num_jacobi(&n, &order) == 1);  /* sage confirms this is 1 */\n }\n \n void run_num_smalltests(void) {\n     int i;\n     for (i = 0; i < 100*count; i++) {\n         test_num_negate();\n         test_num_add_sub();\n+        test_num_mod();\n+        test_num_jacobi();\n     }\n }\n #endif\n@@ -689,6 +797,10 @@ void scalar_test(void) {\n             secp256k1_scalar_inverse(&inv, &inv);\n             /* Inverting one must result in one. */\n             CHECK(secp256k1_scalar_is_one(&inv));\n+#ifndef USE_NUM_NONE\n+            secp256k1_scalar_get_num(&invnum, &inv);\n+            CHECK(secp256k1_num_is_one(&invnum));\n+#endif\n         }\n     }\n \n@@ -855,7 +967,7 @@ void run_scalar_tests(void) {\n         secp256k1_scalar zzv;\n #endif\n         int overflow;\n-        unsigned char chal[32][2][32] = {\n+        unsigned char chal[33][2][32] = {\n             {{0xff, 0xff, 0x03, 0x07, 0x00, 0x00, 0x00, 0x00,\n               0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03,\n               0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff,\n@@ -1111,9 +1223,17 @@ void run_scalar_tests(void) {\n              {0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff,\n               0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x00,\n               0xf8, 0x07, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff,\n-              0xff, 0xc7, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff}}\n+              0xff, 0xc7, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff}},\n+            {{0x82, 0xc9, 0xfa, 0xb0, 0x68, 0x04, 0xa0, 0x00,\n+              0x82, 0xc9, 0xfa, 0xb0, 0x68, 0x04, 0xa0, 0x00,\n+              0xff, 0xff, 0xff, 0xff, 0xff, 0x6f, 0x03, 0xfb,\n+              0xfa, 0x8a, 0x7d, 0xdf, 0x13, 0x86, 0xe2, 0x03},\n+             {0x82, 0xc9, 0xfa, 0xb0, 0x68, 0x04, 0xa0, 0x00,\n+              0x82, 0xc9, 0xfa, 0xb0, 0x68, 0x04, 0xa0, 0x00,\n+              0xff, 0xff, 0xff, 0xff, 0xff, 0x6f, 0x03, 0xfb,\n+              0xfa, 0x8a, 0x7d, 0xdf, 0x13, 0x86, 0xe2, 0x03}}\n         };\n-        unsigned char res[32][2][32] = {\n+        unsigned char res[33][2][32] = {\n             {{0x0c, 0x3b, 0x0a, 0xca, 0x8d, 0x1a, 0x2f, 0xb9,\n               0x8a, 0x7b, 0x53, 0x5a, 0x1f, 0xc5, 0x22, 0xa1,\n               0x07, 0x2a, 0x48, 0xea, 0x02, 0xeb, 0xb3, 0xd6,\n@@ -1369,10 +1489,18 @@ void run_scalar_tests(void) {\n              {0xe4, 0xf1, 0x23, 0x84, 0xe1, 0xb5, 0x9d, 0xf2,\n               0xb8, 0x73, 0x8b, 0x45, 0x2b, 0x35, 0x46, 0x38,\n               0x10, 0x2b, 0x50, 0xf8, 0x8b, 0x35, 0xcd, 0x34,\n-              0xc8, 0x0e, 0xf6, 0xdb, 0x09, 0x35, 0xf0, 0xda}}\n+              0xc8, 0x0e, 0xf6, 0xdb, 0x09, 0x35, 0xf0, 0xda}},\n+            {{0xdb, 0x21, 0x5c, 0x8d, 0x83, 0x1d, 0xb3, 0x34,\n+              0xc7, 0x0e, 0x43, 0xa1, 0x58, 0x79, 0x67, 0x13,\n+              0x1e, 0x86, 0x5d, 0x89, 0x63, 0xe6, 0x0a, 0x46,\n+              0x5c, 0x02, 0x97, 0x1b, 0x62, 0x43, 0x86, 0xf5},\n+             {0xdb, 0x21, 0x5c, 0x8d, 0x83, 0x1d, 0xb3, 0x34,\n+              0xc7, 0x0e, 0x43, 0xa1, 0x58, 0x79, 0x67, 0x13,\n+              0x1e, 0x86, 0x5d, 0x89, 0x63, 0xe6, 0x0a, 0x46,\n+              0x5c, 0x02, 0x97, 0x1b, 0x62, 0x43, 0x86, 0xf5}}\n         };\n         secp256k1_scalar_set_int(&one, 1);\n-        for (i = 0; i < 32; i++) {\n+        for (i = 0; i < 33; i++) {\n             secp256k1_scalar_set_b32(&x, chal[i][0], &overflow);\n             CHECK(!overflow);\n             secp256k1_scalar_set_b32(&y, chal[i][1], &overflow);\n@@ -1446,7 +1574,7 @@ void random_fe_non_zero(secp256k1_fe *nz) {\n void random_fe_non_square(secp256k1_fe *ns) {\n     secp256k1_fe r;\n     random_fe_non_zero(ns);\n-    if (secp256k1_fe_sqrt_var(&r, ns)) {\n+    if (secp256k1_fe_sqrt(&r, ns)) {\n         secp256k1_fe_negate(ns, ns, 1);\n     }\n }\n@@ -1641,7 +1769,7 @@ void run_sqr(void) {\n \n void test_sqrt(const secp256k1_fe *a, const secp256k1_fe *k) {\n     secp256k1_fe r1, r2;\n-    int v = secp256k1_fe_sqrt_var(&r1, a);\n+    int v = secp256k1_fe_sqrt(&r1, a);\n     CHECK((v == 0) == (k == NULL));\n \n     if (k != NULL) {\n@@ -1951,8 +2079,8 @@ void test_add_neg_y_diff_x(void) {\n      * of the sum to be wrong (since infinity has no xy coordinates).\n      * HOWEVER, if the x-coordinates are different, infinity is the\n      * wrong answer, and such degeneracies are exposed. This is the\n-     * root of https://github.com/bitcoin/secp256k1/issues/257 which\n-     * this test is a regression test for.\n+     * root of https://github.com/bitcoin-core/secp256k1/issues/257\n+     * which this test is a regression test for.\n      *\n      * These points were generated in sage as\n      * # secp256k1 params\n@@ -2051,15 +2179,16 @@ void run_ec_combine(void) {\n void test_group_decompress(const secp256k1_fe* x) {\n     /* The input itself, normalized. */\n     secp256k1_fe fex = *x;\n-    secp256k1_fe tmp;\n+    secp256k1_fe fez;\n     /* Results of set_xquad_var, set_xo_var(..., 0), set_xo_var(..., 1). */\n     secp256k1_ge ge_quad, ge_even, ge_odd;\n+    secp256k1_gej gej_quad;\n     /* Return values of the above calls. */\n     int res_quad, res_even, res_odd;\n \n     secp256k1_fe_normalize_var(&fex);\n \n-    res_quad = secp256k1_ge_set_xquad_var(&ge_quad, &fex);\n+    res_quad = secp256k1_ge_set_xquad(&ge_quad, &fex);\n     res_even = secp256k1_ge_set_xo_var(&ge_even, &fex, 0);\n     res_odd = secp256k1_ge_set_xo_var(&ge_odd, &fex, 1);\n \n@@ -2085,13 +2214,29 @@ void test_group_decompress(const secp256k1_fe* x) {\n         CHECK(secp256k1_fe_equal_var(&ge_odd.x, x));\n \n         /* Check that the Y coordinate result in ge_quad is a square. */\n-        CHECK(secp256k1_fe_sqrt_var(&tmp, &ge_quad.y));\n-        secp256k1_fe_sqr(&tmp, &tmp);\n-        CHECK(secp256k1_fe_equal_var(&tmp, &ge_quad.y));\n+        CHECK(secp256k1_fe_is_quad_var(&ge_quad.y));\n \n         /* Check odd/even Y in ge_odd, ge_even. */\n         CHECK(secp256k1_fe_is_odd(&ge_odd.y));\n         CHECK(!secp256k1_fe_is_odd(&ge_even.y));\n+\n+        /* Check secp256k1_gej_has_quad_y_var. */\n+        secp256k1_gej_set_ge(&gej_quad, &ge_quad);\n+        CHECK(secp256k1_gej_has_quad_y_var(&gej_quad));\n+        do {\n+            random_fe_test(&fez);\n+        } while (secp256k1_fe_is_zero(&fez));\n+        secp256k1_gej_rescale(&gej_quad, &fez);\n+        CHECK(secp256k1_gej_has_quad_y_var(&gej_quad));\n+        secp256k1_gej_neg(&gej_quad, &gej_quad);\n+        CHECK(!secp256k1_gej_has_quad_y_var(&gej_quad));\n+        do {\n+            random_fe_test(&fez);\n+        } while (secp256k1_fe_is_zero(&fez));\n+        secp256k1_gej_rescale(&gej_quad, &fez);\n+        CHECK(!secp256k1_gej_has_quad_y_var(&gej_quad));\n+        secp256k1_gej_neg(&gej_quad, &gej_quad);\n+        CHECK(secp256k1_gej_has_quad_y_var(&gej_quad));\n     }\n }\n \n@@ -2383,9 +2528,7 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n     secp256k1_scalar x, shift;\n     int wnaf[256] = {0};\n     int i;\n-#ifdef USE_ENDOMORPHISM\n     int skew;\n-#endif\n     secp256k1_scalar num = *number;\n \n     secp256k1_scalar_set_int(&x, 0);\n@@ -2395,10 +2538,8 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n     for (i = 0; i < 16; ++i) {\n         secp256k1_scalar_shr_int(&num, 8);\n     }\n-    skew = secp256k1_wnaf_const(wnaf, num, w);\n-#else\n-    secp256k1_wnaf_const(wnaf, num, w);\n #endif\n+    skew = secp256k1_wnaf_const(wnaf, num, w);\n \n     for (i = WNAF_SIZE(w); i >= 0; --i) {\n         secp256k1_scalar t;\n@@ -2417,10 +2558,8 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n         }\n         secp256k1_scalar_add(&x, &x, &t);\n     }\n-#ifdef USE_ENDOMORPHISM\n-    /* Skew num because when encoding 128-bit numbers as odd we use an offset */\n+    /* Skew num because when encoding numbers as odd we use an offset */\n     secp256k1_scalar_cadd_bit(&num, skew == 2, 1);\n-#endif\n     CHECK(secp256k1_scalar_eq(&x, &num));\n }\n \n@@ -3484,12 +3623,14 @@ void run_ecdsa_end_to_end(void) {\n \n int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_der, int certainly_not_der) {\n     static const unsigned char zeroes[32] = {0};\n+#ifdef ENABLE_OPENSSL_TESTS\n     static const unsigned char max_scalar[32] = {\n         0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n         0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,\n         0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b,\n         0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x40\n     };\n+#endif\n \n     int ret = 0;\n \n@@ -3607,13 +3748,13 @@ static void assign_big_endian(unsigned char *ptr, size_t ptrlen, uint32_t val) {\n static void damage_array(unsigned char *sig, size_t *len) {\n     int pos;\n     int action = secp256k1_rand_bits(3);\n-    if (action < 1) {\n+    if (action < 1 && *len > 3) {\n         /* Delete a byte. */\n         pos = secp256k1_rand_int(*len);\n         memmove(sig + pos, sig + pos + 1, *len - pos - 1);\n         (*len)--;\n         return;\n-    } else if (action < 2) {\n+    } else if (action < 2 && *len < 2048) {\n         /* Insert a byte. */\n         pos = secp256k1_rand_int(1 + *len);\n         memmove(sig + pos + 1, sig + pos, *len - pos);\n@@ -3785,6 +3926,7 @@ void run_ecdsa_der_parse(void) {\n         int certainly_der = 0;\n         int certainly_not_der = 0;\n         random_ber_signature(buffer, &buflen, &certainly_der, &certainly_not_der);\n+        CHECK(buflen <= 2048);\n         for (j = 0; j < 16; j++) {\n             int ret = 0;\n             if (j > 0) {"
      },
      {
        "sha": "61462642bfb9c8df1fd708ded994a84d077f122b",
        "filename": "src/test/README.md",
        "status": "modified",
        "additions": 9,
        "deletions": 12,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/test/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/test/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/README.md?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -5,18 +5,15 @@ sense to simply use this framework rather than require developers to\n configure some other framework (we want as few impediments to creating\n unit tests as possible).\n \n-The build system is setup to compile an executable called \"test_bitcoin\"\n+The build system is setup to compile an executable called `test_bitcoin`\n that runs all of the unit tests.  The main source file is called\n-test_bitcoin.cpp, which simply includes other files that contain the\n-actual unit tests (outside of a couple required preprocessor\n-directives).  The pattern is to create one test file for each class or\n-source file for which you want to create unit tests.  The file naming\n-convention is \"<source_filename>_tests.cpp\" and such files should wrap\n-their tests in a test suite called \"<source_filename>_tests\".  For an\n-examples of this pattern, examine uint160_tests.cpp and\n-uint256_tests.cpp.\n-\n-Add the source files to /src/Makefile.test.include to add them to the build.\n+test_bitcoin.cpp. To add a new unit test file to our test suite you need \n+to add the file to `src/Makefile.test.include`. The pattern is to create \n+one test file for each class or source file for which you want to create \n+unit tests.  The file naming convention is `<source_filename>_tests.cpp` \n+and such files should wrap their tests in a test suite \n+called `<source_filename>_tests`. For an example of this pattern, \n+examine `uint256_tests.cpp`.\n \n For further reading, I found the following website to be helpful in\n explaining how the boost unit test framework works:\n@@ -31,5 +28,5 @@ example, to run just the getarg_tests verbosely:\n \n     test_bitcoin --run_test=getarg_tests/doubledash\n \n-Run  test_bitcoin --help   for the full list.\n+Run `test_bitcoin --help` for the full list.\n "
      },
      {
        "sha": "5f150e4812af5220d51c22c751a28fad1d030a9d",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 88,
        "deletions": 63,
        "changes": 151,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -7,6 +7,7 @@\n #include <boost/test/unit_test.hpp>\n \n #include \"hash.h\"\n+#include \"netbase.h\"\n #include \"random.h\"\n \n using namespace std;\n@@ -50,6 +51,30 @@ class CAddrManTest : public CAddrMan\n     }\n };\n \n+static CNetAddr ResolveIP(const char* ip)\n+{\n+    CNetAddr addr;\n+    BOOST_CHECK_MESSAGE(LookupHost(ip, addr, false), strprintf(\"failed to resolve: %s\", ip));\n+    return addr;\n+}\n+\n+static CNetAddr ResolveIP(std::string ip)\n+{\n+    return ResolveIP(ip.c_str());\n+}\n+\n+static CService ResolveService(const char* ip, int port = 0)\n+{\n+    CService serv;\n+    BOOST_CHECK_MESSAGE(Lookup(ip, serv, port, false), strprintf(\"failed to resolve: %s:%i\", ip, port));\n+    return serv;\n+}\n+\n+static CService ResolveService(std::string ip, int port = 0)\n+{\n+    return ResolveService(ip.c_str(), port);\n+}\n+\n BOOST_FIXTURE_TEST_SUITE(addrman_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(addrman_simple)\n@@ -59,30 +84,30 @@ BOOST_AUTO_TEST_CASE(addrman_simple)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    CNetAddr source = CNetAddr(\"252.2.2.2\");\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n     // Test 1: Does Addrman respond correctly when empty.\n     BOOST_CHECK(addrman.size() == 0);\n     CAddrInfo addr_null = addrman.Select();\n     BOOST_CHECK(addr_null.ToString() == \"[::]:0\");\n \n     // Test 2: Does Addrman::Add work as expected.\n-    CService addr1 = CService(\"250.1.1.1\", 8333);\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n     BOOST_CHECK(addrman.size() == 1);\n     CAddrInfo addr_ret1 = addrman.Select();\n     BOOST_CHECK(addr_ret1.ToString() == \"250.1.1.1:8333\");\n \n     // Test 3: Does IP address deduplication work correctly.\n     //  Expected dup IP should not be added.\n-    CService addr1_dup = CService(\"250.1.1.1\", 8333);\n+    CService addr1_dup = ResolveService(\"250.1.1.1\", 8333);\n     addrman.Add(CAddress(addr1_dup, NODE_NONE), source);\n     BOOST_CHECK(addrman.size() == 1);\n \n \n     // Test 5: New table has one addr and we add a diff addr we should\n     //  have two addrs.\n-    CService addr2 = CService(\"250.1.1.2\", 8333);\n+    CService addr2 = ResolveService(\"250.1.1.2\", 8333);\n     addrman.Add(CAddress(addr2, NODE_NONE), source);\n     BOOST_CHECK(addrman.size() == 2);\n \n@@ -100,16 +125,16 @@ BOOST_AUTO_TEST_CASE(addrman_ports)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    CNetAddr source = CNetAddr(\"252.2.2.2\");\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n     BOOST_CHECK(addrman.size() == 0);\n \n     // Test 7; Addr with same IP but diff port does not replace existing addr.\n-    CService addr1 = CService(\"250.1.1.1\", 8333);\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n     BOOST_CHECK(addrman.size() == 1);\n \n-    CService addr1_port = CService(\"250.1.1.1\", 8334);\n+    CService addr1_port = ResolveService(\"250.1.1.1\", 8334);\n     addrman.Add(CAddress(addr1_port, NODE_NONE), source);\n     BOOST_CHECK(addrman.size() == 1);\n     CAddrInfo addr_ret2 = addrman.Select();\n@@ -132,10 +157,10 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    CNetAddr source = CNetAddr(\"252.2.2.2\");\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n     // Test 9: Select from new with 1 addr in new.\n-    CService addr1 = CService(\"250.1.1.1\", 8333);\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n     BOOST_CHECK(addrman.size() == 1);\n \n@@ -156,24 +181,24 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n \n \n     // Add three addresses to new table.\n-    CService addr2 = CService(\"250.3.1.1\", 8333);\n-    CService addr3 = CService(\"250.3.2.2\", 9999);\n-    CService addr4 = CService(\"250.3.3.3\", 9999);\n+    CService addr2 = ResolveService(\"250.3.1.1\", 8333);\n+    CService addr3 = ResolveService(\"250.3.2.2\", 9999);\n+    CService addr4 = ResolveService(\"250.3.3.3\", 9999);\n \n-    addrman.Add(CAddress(addr2, NODE_NONE), CService(\"250.3.1.1\", 8333));\n-    addrman.Add(CAddress(addr3, NODE_NONE), CService(\"250.3.1.1\", 8333));\n-    addrman.Add(CAddress(addr4, NODE_NONE), CService(\"250.4.1.1\", 8333));\n+    addrman.Add(CAddress(addr2, NODE_NONE), ResolveService(\"250.3.1.1\", 8333));\n+    addrman.Add(CAddress(addr3, NODE_NONE), ResolveService(\"250.3.1.1\", 8333));\n+    addrman.Add(CAddress(addr4, NODE_NONE), ResolveService(\"250.4.1.1\", 8333));\n \n     // Add three addresses to tried table.\n-    CService addr5 = CService(\"250.4.4.4\", 8333);\n-    CService addr6 = CService(\"250.4.5.5\", 7777);\n-    CService addr7 = CService(\"250.4.6.6\", 8333);\n+    CService addr5 = ResolveService(\"250.4.4.4\", 8333);\n+    CService addr6 = ResolveService(\"250.4.5.5\", 7777);\n+    CService addr7 = ResolveService(\"250.4.6.6\", 8333);\n \n-    addrman.Add(CAddress(addr5, NODE_NONE), CService(\"250.3.1.1\", 8333));\n+    addrman.Add(CAddress(addr5, NODE_NONE), ResolveService(\"250.3.1.1\", 8333));\n     addrman.Good(CAddress(addr5, NODE_NONE));\n-    addrman.Add(CAddress(addr6, NODE_NONE), CService(\"250.3.1.1\", 8333));\n+    addrman.Add(CAddress(addr6, NODE_NONE), ResolveService(\"250.3.1.1\", 8333));\n     addrman.Good(CAddress(addr6, NODE_NONE));\n-    addrman.Add(CAddress(addr7, NODE_NONE), CService(\"250.1.1.3\", 8333));\n+    addrman.Add(CAddress(addr7, NODE_NONE), ResolveService(\"250.1.1.3\", 8333));\n     addrman.Good(CAddress(addr7, NODE_NONE));\n \n     // Test 11: 6 addrs + 1 addr from last test = 7.\n@@ -193,24 +218,24 @@ BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    CNetAddr source = CNetAddr(\"252.2.2.2\");\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n     BOOST_CHECK(addrman.size() == 0);\n \n     for (unsigned int i = 1; i < 18; i++) {\n-        CService addr = CService(\"250.1.1.\" + boost::to_string(i));\n+        CService addr = ResolveService(\"250.1.1.\" + boost::to_string(i));\n         addrman.Add(CAddress(addr, NODE_NONE), source);\n \n         //Test 13: No collision in new table yet.\n         BOOST_CHECK(addrman.size() == i);\n     }\n \n     //Test 14: new table collision!\n-    CService addr1 = CService(\"250.1.1.18\");\n+    CService addr1 = ResolveService(\"250.1.1.18\");\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n     BOOST_CHECK(addrman.size() == 17);\n \n-    CService addr2 = CService(\"250.1.1.19\");\n+    CService addr2 = ResolveService(\"250.1.1.19\");\n     addrman.Add(CAddress(addr2, NODE_NONE), source);\n     BOOST_CHECK(addrman.size() == 18);\n }\n@@ -222,12 +247,12 @@ BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    CNetAddr source = CNetAddr(\"252.2.2.2\");\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n     BOOST_CHECK(addrman.size() == 0);\n \n     for (unsigned int i = 1; i < 80; i++) {\n-        CService addr = CService(\"250.1.1.\" + boost::to_string(i));\n+        CService addr = ResolveService(\"250.1.1.\" + boost::to_string(i));\n         addrman.Add(CAddress(addr, NODE_NONE), source);\n         addrman.Good(CAddress(addr, NODE_NONE));\n \n@@ -237,11 +262,11 @@ BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n     }\n \n     //Test 16: tried table collision!\n-    CService addr1 = CService(\"250.1.1.80\");\n+    CService addr1 = ResolveService(\"250.1.1.80\");\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n     BOOST_CHECK(addrman.size() == 79);\n \n-    CService addr2 = CService(\"250.1.1.81\");\n+    CService addr2 = ResolveService(\"250.1.1.81\");\n     addrman.Add(CAddress(addr2, NODE_NONE), source);\n     BOOST_CHECK(addrman.size() == 80);\n }\n@@ -255,12 +280,12 @@ BOOST_AUTO_TEST_CASE(addrman_find)\n \n     BOOST_CHECK(addrman.size() == 0);\n \n-    CAddress addr1 = CAddress(CService(\"250.1.2.1\", 8333), NODE_NONE);\n-    CAddress addr2 = CAddress(CService(\"250.1.2.1\", 9999), NODE_NONE);\n-    CAddress addr3 = CAddress(CService(\"251.255.2.1\", 8333), NODE_NONE);\n+    CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n+    CAddress addr2 = CAddress(ResolveService(\"250.1.2.1\", 9999), NODE_NONE);\n+    CAddress addr3 = CAddress(ResolveService(\"251.255.2.1\", 8333), NODE_NONE);\n \n-    CNetAddr source1 = CNetAddr(\"250.1.2.1\");\n-    CNetAddr source2 = CNetAddr(\"250.1.2.2\");\n+    CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n+    CNetAddr source2 = ResolveIP(\"250.1.2.2\");\n \n     addrman.Add(addr1, source1);\n     addrman.Add(addr2, source2);\n@@ -294,8 +319,8 @@ BOOST_AUTO_TEST_CASE(addrman_create)\n \n     BOOST_CHECK(addrman.size() == 0);\n \n-    CAddress addr1 = CAddress(CService(\"250.1.2.1\", 8333), NODE_NONE);\n-    CNetAddr source1 = CNetAddr(\"250.1.2.1\");\n+    CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n+    CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n \n     int nId;\n     CAddrInfo* pinfo = addrman.Create(addr1, source1, &nId);\n@@ -317,8 +342,8 @@ BOOST_AUTO_TEST_CASE(addrman_delete)\n \n     BOOST_CHECK(addrman.size() == 0);\n \n-    CAddress addr1 = CAddress(CService(\"250.1.2.1\", 8333), NODE_NONE);\n-    CNetAddr source1 = CNetAddr(\"250.1.2.1\");\n+    CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n+    CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n \n     int nId;\n     addrman.Create(addr1, source1, &nId);\n@@ -344,18 +369,18 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n     vector<CAddress> vAddr1 = addrman.GetAddr();\n     BOOST_CHECK(vAddr1.size() == 0);\n \n-    CAddress addr1 = CAddress(CService(\"250.250.2.1\", 8333), NODE_NONE);\n+    CAddress addr1 = CAddress(ResolveService(\"250.250.2.1\", 8333), NODE_NONE);\n     addr1.nTime = GetAdjustedTime(); // Set time so isTerrible = false\n-    CAddress addr2 = CAddress(CService(\"250.251.2.2\", 9999), NODE_NONE);\n+    CAddress addr2 = CAddress(ResolveService(\"250.251.2.2\", 9999), NODE_NONE);\n     addr2.nTime = GetAdjustedTime();\n-    CAddress addr3 = CAddress(CService(\"251.252.2.3\", 8333), NODE_NONE);\n+    CAddress addr3 = CAddress(ResolveService(\"251.252.2.3\", 8333), NODE_NONE);\n     addr3.nTime = GetAdjustedTime();\n-    CAddress addr4 = CAddress(CService(\"252.253.3.4\", 8333), NODE_NONE);\n+    CAddress addr4 = CAddress(ResolveService(\"252.253.3.4\", 8333), NODE_NONE);\n     addr4.nTime = GetAdjustedTime();\n-    CAddress addr5 = CAddress(CService(\"252.254.4.5\", 8333), NODE_NONE);\n+    CAddress addr5 = CAddress(ResolveService(\"252.254.4.5\", 8333), NODE_NONE);\n     addr5.nTime = GetAdjustedTime();\n-    CNetAddr source1 = CNetAddr(\"250.1.2.1\");\n-    CNetAddr source2 = CNetAddr(\"250.2.3.3\");\n+    CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n+    CNetAddr source2 = ResolveIP(\"250.2.3.3\");\n \n     // Test 23: Ensure GetAddr works with new addresses.\n     addrman.Add(addr1, source1);\n@@ -378,11 +403,11 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n         int octet2 = (i / 256) % 256;\n         int octet3 = (i / (256 * 2)) % 256;\n         string strAddr = boost::to_string(octet1) + \".\" + boost::to_string(octet2) + \".\" + boost::to_string(octet3) + \".23\";\n-        CAddress addr = CAddress(CService(strAddr), NODE_NONE);\n+        CAddress addr = CAddress(ResolveService(strAddr), NODE_NONE);\n         \n         // Ensure that for all addrs in addrman, isTerrible == false.\n         addr.nTime = GetAdjustedTime();\n-        addrman.Add(addr, CNetAddr(strAddr));\n+        addrman.Add(addr, ResolveIP(strAddr));\n         if (i % 8 == 0)\n             addrman.Good(addr);\n     }\n@@ -403,10 +428,10 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    CAddress addr1 = CAddress(CService(\"250.1.1.1\", 8333), NODE_NONE);\n-    CAddress addr2 = CAddress(CService(\"250.1.1.1\", 9999), NODE_NONE);\n+    CAddress addr1 = CAddress(ResolveService(\"250.1.1.1\", 8333), NODE_NONE);\n+    CAddress addr2 = CAddress(ResolveService(\"250.1.1.1\", 9999), NODE_NONE);\n \n-    CNetAddr source1 = CNetAddr(\"250.1.1.1\");\n+    CNetAddr source1 = ResolveIP(\"250.1.1.1\");\n \n \n     CAddrInfo info1 = CAddrInfo(addr1, source1);\n@@ -431,8 +456,8 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n     set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n         CAddrInfo infoi = CAddrInfo(\n-            CAddress(CService(\"250.1.1.\" + boost::to_string(i)), NODE_NONE),\n-            CNetAddr(\"250.1.1.\" + boost::to_string(i)));\n+            CAddress(ResolveService(\"250.1.1.\" + boost::to_string(i)), NODE_NONE),\n+            ResolveIP(\"250.1.1.\" + boost::to_string(i)));\n         int bucket = infoi.GetTriedBucket(nKey1);\n         buckets.insert(bucket);\n     }\n@@ -443,8 +468,8 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n     buckets.clear();\n     for (int j = 0; j < 255; j++) {\n         CAddrInfo infoj = CAddrInfo(\n-            CAddress(CService(\"250.\" + boost::to_string(j) + \".1.1\"), NODE_NONE),\n-            CNetAddr(\"250.\" + boost::to_string(j) + \".1.1\"));\n+            CAddress(ResolveService(\"250.\" + boost::to_string(j) + \".1.1\"), NODE_NONE),\n+            ResolveIP(\"250.\" + boost::to_string(j) + \".1.1\"));\n         int bucket = infoj.GetTriedBucket(nKey1);\n         buckets.insert(bucket);\n     }\n@@ -460,10 +485,10 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    CAddress addr1 = CAddress(CService(\"250.1.2.1\", 8333), NODE_NONE);\n-    CAddress addr2 = CAddress(CService(\"250.1.2.1\", 9999), NODE_NONE);\n+    CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n+    CAddress addr2 = CAddress(ResolveService(\"250.1.2.1\", 9999), NODE_NONE);\n \n-    CNetAddr source1 = CNetAddr(\"250.1.2.1\");\n+    CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n \n     CAddrInfo info1 = CAddrInfo(addr1, source1);\n \n@@ -484,8 +509,8 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n         CAddrInfo infoi = CAddrInfo(\n-            CAddress(CService(\"250.1.1.\" + boost::to_string(i)), NODE_NONE),\n-            CNetAddr(\"250.1.1.\" + boost::to_string(i)));\n+            CAddress(ResolveService(\"250.1.1.\" + boost::to_string(i)), NODE_NONE),\n+            ResolveIP(\"250.1.1.\" + boost::to_string(i)));\n         int bucket = infoi.GetNewBucket(nKey1);\n         buckets.insert(bucket);\n     }\n@@ -496,9 +521,9 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     buckets.clear();\n     for (int j = 0; j < 4 * 255; j++) {\n         CAddrInfo infoj = CAddrInfo(CAddress(\n-                                        CService(\n+                                        ResolveService(\n                                             boost::to_string(250 + (j / 255)) + \".\" + boost::to_string(j % 256) + \".1.1\"), NODE_NONE),\n-            CNetAddr(\"251.4.1.1\"));\n+            ResolveIP(\"251.4.1.1\"));\n         int bucket = infoj.GetNewBucket(nKey1);\n         buckets.insert(bucket);\n     }\n@@ -509,8 +534,8 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     buckets.clear();\n     for (int p = 0; p < 255; p++) {\n         CAddrInfo infoj = CAddrInfo(\n-            CAddress(CService(\"250.1.1.1\"), NODE_NONE),\n-            CNetAddr(\"250.\" + boost::to_string(p) + \".1.1\"));\n+            CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE),\n+            ResolveIP(\"250.\" + boost::to_string(p) + \".1.1\"));\n         int bucket = infoj.GetNewBucket(nKey1);\n         buckets.insert(bucket);\n     }"
      },
      {
        "sha": "882b5c67b862dc3e02b3f470da24f2c5ccbd19a7",
        "filename": "src/test/bitcoin-util-test.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/test/bitcoin-util-test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/test/bitcoin-util-test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bitcoin-util-test.py?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/python\n+#!/usr/bin/env python\n # Copyright 2014 BitPay, Inc.\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php."
      },
      {
        "sha": "153f34a3dbc71e24ade4d228868e1fd8321302fa",
        "filename": "src/test/buildenv.py.in",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/test/buildenv.py.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/test/buildenv.py.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/buildenv.py.in?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -1,2 +1,2 @@\n-#!/usr/bin/python\n+#!/usr/bin/env python\n exeext=\"@EXEEXT@\""
      },
      {
        "sha": "fa9624f13daf5508d21571c50d2540f5580ba8e3",
        "filename": "src/test/hash_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/test/hash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/test/hash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/hash_tests.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -122,6 +122,10 @@ BOOST_AUTO_TEST_CASE(siphash)\n         hasher3.Write(uint64_t(x)|(uint64_t(x+1)<<8)|(uint64_t(x+2)<<16)|(uint64_t(x+3)<<24)|\n                      (uint64_t(x+4)<<32)|(uint64_t(x+5)<<40)|(uint64_t(x+6)<<48)|(uint64_t(x+7)<<56));\n     }\n+\n+    CHashWriter ss(SER_DISK, CLIENT_VERSION);\n+    ss << CTransaction();\n+    BOOST_CHECK_EQUAL(SipHashUint256(1, 2, ss.GetHash()), 0x79751e980c2a0a35ULL);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "15fceb963a59f1c81165fd31e5e41ee02e83c3ae",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -181,9 +181,7 @@ void TestPackageSelection(const CChainParams& chainparams, CScript scriptPubKey,\n // NOTE: These tests rely on CreateNewBlock doing its own self-validation!\n BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n {\n-    // Disable size accounting (CPFP does not support it)\n-    mapArgs[\"-blockmaxsize\"] = strprintf(\"%u\", MAX_BLOCK_SERIALIZED_SIZE);\n-\n+    // Note that by default, these tests run with size accounting enabled.\n     const CChainParams& chainparams = Params(CBaseChainParams::MAIN);\n     CScript scriptPubKey = CScript() << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\") << OP_CHECKSIG;\n     CBlockTemplate *pblocktemplate;"
      },
      {
        "sha": "6511e6ffa24f14e48d45241da057d0c62226024f",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 8,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -9,6 +9,7 @@\n #include \"serialize.h\"\n #include \"streams.h\"\n #include \"net.h\"\n+#include \"netbase.h\"\n #include \"chainparams.h\"\n \n using namespace std;\n@@ -51,8 +52,12 @@ class CAddrManCorrupted : public CAddrManSerializationMock\n         int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);\n         s << nUBuckets;\n \n-        CAddress addr = CAddress(CService(\"252.1.1.1\", 7777), NODE_NONE);\n-        CAddrInfo info = CAddrInfo(addr, CNetAddr(\"252.2.2.2\"));\n+        CService serv;\n+        Lookup(\"252.1.1.1\", serv, 7777, false);\n+        CAddress addr = CAddress(serv, NODE_NONE);\n+        CNetAddr resolved;\n+        LookupHost(\"252.2.2.2\", resolved, false);\n+        CAddrInfo info = CAddrInfo(addr, resolved);\n         s << info;\n     }\n };\n@@ -74,14 +79,17 @@ BOOST_AUTO_TEST_CASE(caddrdb_read)\n     CAddrManUncorrupted addrmanUncorrupted;\n     addrmanUncorrupted.MakeDeterministic();\n \n-    CService addr1 = CService(\"250.7.1.1\", 8333);\n-    CService addr2 = CService(\"250.7.2.2\", 9999);\n-    CService addr3 = CService(\"250.7.3.3\", 9999);\n+    CService addr1, addr2, addr3;\n+    Lookup(\"250.7.1.1\", addr1, 8333, false);\n+    Lookup(\"250.7.2.2\", addr2, 9999, false);\n+    Lookup(\"250.7.3.3\", addr3, 9999, false);\n \n     // Add three addresses to new table.\n-    addrmanUncorrupted.Add(CAddress(addr1, NODE_NONE), CService(\"252.5.1.1\", 8333));\n-    addrmanUncorrupted.Add(CAddress(addr2, NODE_NONE), CService(\"252.5.1.1\", 8333));\n-    addrmanUncorrupted.Add(CAddress(addr3, NODE_NONE), CService(\"252.5.1.1\", 8333));\n+    CService source;\n+    Lookup(\"252.5.1.1\", source, 8333, false);\n+    addrmanUncorrupted.Add(CAddress(addr1, NODE_NONE), source);\n+    addrmanUncorrupted.Add(CAddress(addr2, NODE_NONE), source);\n+    addrmanUncorrupted.Add(CAddress(addr3, NODE_NONE), source);\n \n     // Test that the de-serialization does not throw an exception.\n     CDataStream ssPeers1 = AddrmanToStream(addrmanUncorrupted);"
      },
      {
        "sha": "18ad5dc90bf4ed4e7b655ff421ddf6af878b2a53",
        "filename": "src/test/netbase_tests.cpp",
        "status": "modified",
        "additions": 158,
        "deletions": 123,
        "changes": 281,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/test/netbase_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/test/netbase_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/netbase_tests.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -14,37 +14,54 @@ using namespace std;\n \n BOOST_FIXTURE_TEST_SUITE(netbase_tests, BasicTestingSetup)\n \n+static CNetAddr ResolveIP(const char* ip)\n+{\n+    CNetAddr addr;\n+    LookupHost(ip, addr, false);\n+    return addr;\n+}\n+\n+static CSubNet ResolveSubNet(const char* subnet)\n+{\n+    CSubNet ret;\n+    LookupSubNet(subnet, ret);\n+    return ret;\n+}\n+\n BOOST_AUTO_TEST_CASE(netbase_networks)\n {\n-    BOOST_CHECK(CNetAddr(\"127.0.0.1\").GetNetwork()                              == NET_UNROUTABLE);\n-    BOOST_CHECK(CNetAddr(\"::1\").GetNetwork()                                    == NET_UNROUTABLE);\n-    BOOST_CHECK(CNetAddr(\"8.8.8.8\").GetNetwork()                                == NET_IPV4);\n-    BOOST_CHECK(CNetAddr(\"2001::8888\").GetNetwork()                             == NET_IPV6);\n-    BOOST_CHECK(CNetAddr(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\").GetNetwork() == NET_TOR);\n+    BOOST_CHECK(ResolveIP(\"127.0.0.1\").GetNetwork()                              == NET_UNROUTABLE);\n+    BOOST_CHECK(ResolveIP(\"::1\").GetNetwork()                                    == NET_UNROUTABLE);\n+    BOOST_CHECK(ResolveIP(\"8.8.8.8\").GetNetwork()                                == NET_IPV4);\n+    BOOST_CHECK(ResolveIP(\"2001::8888\").GetNetwork()                             == NET_IPV6);\n+    BOOST_CHECK(ResolveIP(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\").GetNetwork() == NET_TOR);\n+\n }\n \n BOOST_AUTO_TEST_CASE(netbase_properties)\n {\n-    BOOST_CHECK(CNetAddr(\"127.0.0.1\").IsIPv4());\n-    BOOST_CHECK(CNetAddr(\"::FFFF:192.168.1.1\").IsIPv4());\n-    BOOST_CHECK(CNetAddr(\"::1\").IsIPv6());\n-    BOOST_CHECK(CNetAddr(\"10.0.0.1\").IsRFC1918());\n-    BOOST_CHECK(CNetAddr(\"192.168.1.1\").IsRFC1918());\n-    BOOST_CHECK(CNetAddr(\"172.31.255.255\").IsRFC1918());\n-    BOOST_CHECK(CNetAddr(\"2001:0DB8::\").IsRFC3849());\n-    BOOST_CHECK(CNetAddr(\"169.254.1.1\").IsRFC3927());\n-    BOOST_CHECK(CNetAddr(\"2002::1\").IsRFC3964());\n-    BOOST_CHECK(CNetAddr(\"FC00::\").IsRFC4193());\n-    BOOST_CHECK(CNetAddr(\"2001::2\").IsRFC4380());\n-    BOOST_CHECK(CNetAddr(\"2001:10::\").IsRFC4843());\n-    BOOST_CHECK(CNetAddr(\"FE80::\").IsRFC4862());\n-    BOOST_CHECK(CNetAddr(\"64:FF9B::\").IsRFC6052());\n-    BOOST_CHECK(CNetAddr(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\").IsTor());\n-    BOOST_CHECK(CNetAddr(\"127.0.0.1\").IsLocal());\n-    BOOST_CHECK(CNetAddr(\"::1\").IsLocal());\n-    BOOST_CHECK(CNetAddr(\"8.8.8.8\").IsRoutable());\n-    BOOST_CHECK(CNetAddr(\"2001::1\").IsRoutable());\n-    BOOST_CHECK(CNetAddr(\"127.0.0.1\").IsValid());\n+\n+    BOOST_CHECK(ResolveIP(\"127.0.0.1\").IsIPv4());\n+    BOOST_CHECK(ResolveIP(\"::FFFF:192.168.1.1\").IsIPv4());\n+    BOOST_CHECK(ResolveIP(\"::1\").IsIPv6());\n+    BOOST_CHECK(ResolveIP(\"10.0.0.1\").IsRFC1918());\n+    BOOST_CHECK(ResolveIP(\"192.168.1.1\").IsRFC1918());\n+    BOOST_CHECK(ResolveIP(\"172.31.255.255\").IsRFC1918());\n+    BOOST_CHECK(ResolveIP(\"2001:0DB8::\").IsRFC3849());\n+    BOOST_CHECK(ResolveIP(\"169.254.1.1\").IsRFC3927());\n+    BOOST_CHECK(ResolveIP(\"2002::1\").IsRFC3964());\n+    BOOST_CHECK(ResolveIP(\"FC00::\").IsRFC4193());\n+    BOOST_CHECK(ResolveIP(\"2001::2\").IsRFC4380());\n+    BOOST_CHECK(ResolveIP(\"2001:10::\").IsRFC4843());\n+    BOOST_CHECK(ResolveIP(\"FE80::\").IsRFC4862());\n+    BOOST_CHECK(ResolveIP(\"64:FF9B::\").IsRFC6052());\n+    BOOST_CHECK(ResolveIP(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\").IsTor());\n+    BOOST_CHECK(ResolveIP(\"127.0.0.1\").IsLocal());\n+    BOOST_CHECK(ResolveIP(\"::1\").IsLocal());\n+    BOOST_CHECK(ResolveIP(\"8.8.8.8\").IsRoutable());\n+    BOOST_CHECK(ResolveIP(\"2001::1\").IsRoutable());\n+    BOOST_CHECK(ResolveIP(\"127.0.0.1\").IsValid());\n+\n }\n \n bool static TestSplitHost(string test, string host, int port)\n@@ -76,9 +93,7 @@ BOOST_AUTO_TEST_CASE(netbase_splithost)\n \n bool static TestParse(string src, string canon)\n {\n-    CService addr;\n-    if (!LookupNumeric(src.c_str(), addr, 65535))\n-        return canon == \"\";\n+    CService addr(LookupNumeric(src.c_str(), 65535));\n     return canon == addr.ToString();\n }\n \n@@ -90,165 +105,185 @@ BOOST_AUTO_TEST_CASE(netbase_lookupnumeric)\n     BOOST_CHECK(TestParse(\"::\", \"[::]:65535\"));\n     BOOST_CHECK(TestParse(\"[::]:8333\", \"[::]:8333\"));\n     BOOST_CHECK(TestParse(\"[127.0.0.1]\", \"127.0.0.1:65535\"));\n-    BOOST_CHECK(TestParse(\":::\", \"\"));\n+    BOOST_CHECK(TestParse(\":::\", \"[::]:0\"));\n }\n \n BOOST_AUTO_TEST_CASE(onioncat_test)\n {\n+\n     // values from https://web.archive.org/web/20121122003543/http://www.cypherpunk.at/onioncat/wiki/OnionCat\n-    CNetAddr addr1(\"5wyqrzbvrdsumnok.onion\");\n-    CNetAddr addr2(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\");\n+    CNetAddr addr1(ResolveIP(\"5wyqrzbvrdsumnok.onion\"));\n+    CNetAddr addr2(ResolveIP(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\"));\n     BOOST_CHECK(addr1 == addr2);\n     BOOST_CHECK(addr1.IsTor());\n     BOOST_CHECK(addr1.ToStringIP() == \"5wyqrzbvrdsumnok.onion\");\n     BOOST_CHECK(addr1.IsRoutable());\n+\n }\n \n BOOST_AUTO_TEST_CASE(subnet_test)\n {\n-    BOOST_CHECK(CSubNet(\"1.2.3.0/24\") == CSubNet(\"1.2.3.0/255.255.255.0\"));\n-    BOOST_CHECK(CSubNet(\"1.2.3.0/24\") != CSubNet(\"1.2.4.0/255.255.255.0\"));\n-    BOOST_CHECK(CSubNet(\"1.2.3.0/24\").Match(CNetAddr(\"1.2.3.4\")));\n-    BOOST_CHECK(!CSubNet(\"1.2.2.0/24\").Match(CNetAddr(\"1.2.3.4\")));\n-    BOOST_CHECK(CSubNet(\"1.2.3.4\").Match(CNetAddr(\"1.2.3.4\")));\n-    BOOST_CHECK(CSubNet(\"1.2.3.4/32\").Match(CNetAddr(\"1.2.3.4\")));\n-    BOOST_CHECK(!CSubNet(\"1.2.3.4\").Match(CNetAddr(\"5.6.7.8\")));\n-    BOOST_CHECK(!CSubNet(\"1.2.3.4/32\").Match(CNetAddr(\"5.6.7.8\")));\n-    BOOST_CHECK(CSubNet(\"::ffff:127.0.0.1\").Match(CNetAddr(\"127.0.0.1\")));\n-    BOOST_CHECK(CSubNet(\"1:2:3:4:5:6:7:8\").Match(CNetAddr(\"1:2:3:4:5:6:7:8\")));\n-    BOOST_CHECK(!CSubNet(\"1:2:3:4:5:6:7:8\").Match(CNetAddr(\"1:2:3:4:5:6:7:9\")));\n-    BOOST_CHECK(CSubNet(\"1:2:3:4:5:6:7:0/112\").Match(CNetAddr(\"1:2:3:4:5:6:7:1234\")));\n-    BOOST_CHECK(CSubNet(\"192.168.0.1/24\").Match(CNetAddr(\"192.168.0.2\")));\n-    BOOST_CHECK(CSubNet(\"192.168.0.20/29\").Match(CNetAddr(\"192.168.0.18\")));\n-    BOOST_CHECK(CSubNet(\"1.2.2.1/24\").Match(CNetAddr(\"1.2.2.4\")));\n-    BOOST_CHECK(CSubNet(\"1.2.2.110/31\").Match(CNetAddr(\"1.2.2.111\")));\n-    BOOST_CHECK(CSubNet(\"1.2.2.20/26\").Match(CNetAddr(\"1.2.2.63\")));\n+\n+    BOOST_CHECK(ResolveSubNet(\"1.2.3.0/24\") == ResolveSubNet(\"1.2.3.0/255.255.255.0\"));\n+    BOOST_CHECK(ResolveSubNet(\"1.2.3.0/24\") != ResolveSubNet(\"1.2.4.0/255.255.255.0\"));\n+    BOOST_CHECK(ResolveSubNet(\"1.2.3.0/24\").Match(ResolveIP(\"1.2.3.4\")));\n+    BOOST_CHECK(!ResolveSubNet(\"1.2.2.0/24\").Match(ResolveIP(\"1.2.3.4\")));\n+    BOOST_CHECK(ResolveSubNet(\"1.2.3.4\").Match(ResolveIP(\"1.2.3.4\")));\n+    BOOST_CHECK(ResolveSubNet(\"1.2.3.4/32\").Match(ResolveIP(\"1.2.3.4\")));\n+    BOOST_CHECK(!ResolveSubNet(\"1.2.3.4\").Match(ResolveIP(\"5.6.7.8\")));\n+    BOOST_CHECK(!ResolveSubNet(\"1.2.3.4/32\").Match(ResolveIP(\"5.6.7.8\")));\n+    BOOST_CHECK(ResolveSubNet(\"::ffff:127.0.0.1\").Match(ResolveIP(\"127.0.0.1\")));\n+    BOOST_CHECK(ResolveSubNet(\"1:2:3:4:5:6:7:8\").Match(ResolveIP(\"1:2:3:4:5:6:7:8\")));\n+    BOOST_CHECK(!ResolveSubNet(\"1:2:3:4:5:6:7:8\").Match(ResolveIP(\"1:2:3:4:5:6:7:9\")));\n+    BOOST_CHECK(ResolveSubNet(\"1:2:3:4:5:6:7:0/112\").Match(ResolveIP(\"1:2:3:4:5:6:7:1234\")));\n+    BOOST_CHECK(ResolveSubNet(\"192.168.0.1/24\").Match(ResolveIP(\"192.168.0.2\")));\n+    BOOST_CHECK(ResolveSubNet(\"192.168.0.20/29\").Match(ResolveIP(\"192.168.0.18\")));\n+    BOOST_CHECK(ResolveSubNet(\"1.2.2.1/24\").Match(ResolveIP(\"1.2.2.4\")));\n+    BOOST_CHECK(ResolveSubNet(\"1.2.2.110/31\").Match(ResolveIP(\"1.2.2.111\")));\n+    BOOST_CHECK(ResolveSubNet(\"1.2.2.20/26\").Match(ResolveIP(\"1.2.2.63\")));\n     // All-Matching IPv6 Matches arbitrary IPv4 and IPv6\n-    BOOST_CHECK(CSubNet(\"::/0\").Match(CNetAddr(\"1:2:3:4:5:6:7:1234\")));\n-    BOOST_CHECK(CSubNet(\"::/0\").Match(CNetAddr(\"1.2.3.4\")));\n+    BOOST_CHECK(ResolveSubNet(\"::/0\").Match(ResolveIP(\"1:2:3:4:5:6:7:1234\")));\n+    BOOST_CHECK(ResolveSubNet(\"::/0\").Match(ResolveIP(\"1.2.3.4\")));\n     // All-Matching IPv4 does not Match IPv6\n-    BOOST_CHECK(!CSubNet(\"0.0.0.0/0\").Match(CNetAddr(\"1:2:3:4:5:6:7:1234\")));\n+    BOOST_CHECK(!ResolveSubNet(\"0.0.0.0/0\").Match(ResolveIP(\"1:2:3:4:5:6:7:1234\")));\n     // Invalid subnets Match nothing (not even invalid addresses)\n-    BOOST_CHECK(!CSubNet().Match(CNetAddr(\"1.2.3.4\")));\n-    BOOST_CHECK(!CSubNet(\"\").Match(CNetAddr(\"4.5.6.7\")));\n-    BOOST_CHECK(!CSubNet(\"bloop\").Match(CNetAddr(\"0.0.0.0\")));\n-    BOOST_CHECK(!CSubNet(\"bloop\").Match(CNetAddr(\"hab\")));\n+    BOOST_CHECK(!CSubNet().Match(ResolveIP(\"1.2.3.4\")));\n+    BOOST_CHECK(!ResolveSubNet(\"\").Match(ResolveIP(\"4.5.6.7\")));\n+    BOOST_CHECK(!ResolveSubNet(\"bloop\").Match(ResolveIP(\"0.0.0.0\")));\n+    BOOST_CHECK(!ResolveSubNet(\"bloop\").Match(ResolveIP(\"hab\")));\n     // Check valid/invalid\n-    BOOST_CHECK(CSubNet(\"1.2.3.0/0\").IsValid());\n-    BOOST_CHECK(!CSubNet(\"1.2.3.0/-1\").IsValid());\n-    BOOST_CHECK(CSubNet(\"1.2.3.0/32\").IsValid());\n-    BOOST_CHECK(!CSubNet(\"1.2.3.0/33\").IsValid());\n-    BOOST_CHECK(CSubNet(\"1:2:3:4:5:6:7:8/0\").IsValid());\n-    BOOST_CHECK(CSubNet(\"1:2:3:4:5:6:7:8/33\").IsValid());\n-    BOOST_CHECK(!CSubNet(\"1:2:3:4:5:6:7:8/-1\").IsValid());\n-    BOOST_CHECK(CSubNet(\"1:2:3:4:5:6:7:8/128\").IsValid());\n-    BOOST_CHECK(!CSubNet(\"1:2:3:4:5:6:7:8/129\").IsValid());\n-    BOOST_CHECK(!CSubNet(\"fuzzy\").IsValid());\n+    BOOST_CHECK(ResolveSubNet(\"1.2.3.0/0\").IsValid());\n+    BOOST_CHECK(!ResolveSubNet(\"1.2.3.0/-1\").IsValid());\n+    BOOST_CHECK(ResolveSubNet(\"1.2.3.0/32\").IsValid());\n+    BOOST_CHECK(!ResolveSubNet(\"1.2.3.0/33\").IsValid());\n+    BOOST_CHECK(ResolveSubNet(\"1:2:3:4:5:6:7:8/0\").IsValid());\n+    BOOST_CHECK(ResolveSubNet(\"1:2:3:4:5:6:7:8/33\").IsValid());\n+    BOOST_CHECK(!ResolveSubNet(\"1:2:3:4:5:6:7:8/-1\").IsValid());\n+    BOOST_CHECK(ResolveSubNet(\"1:2:3:4:5:6:7:8/128\").IsValid());\n+    BOOST_CHECK(!ResolveSubNet(\"1:2:3:4:5:6:7:8/129\").IsValid());\n+    BOOST_CHECK(!ResolveSubNet(\"fuzzy\").IsValid());\n \n     //CNetAddr constructor test\n-    BOOST_CHECK(CSubNet(CNetAddr(\"127.0.0.1\")).IsValid());\n-    BOOST_CHECK(CSubNet(CNetAddr(\"127.0.0.1\")).Match(CNetAddr(\"127.0.0.1\")));\n-    BOOST_CHECK(!CSubNet(CNetAddr(\"127.0.0.1\")).Match(CNetAddr(\"127.0.0.2\")));\n-    BOOST_CHECK(CSubNet(CNetAddr(\"127.0.0.1\")).ToString() == \"127.0.0.1/32\");\n+    BOOST_CHECK(CSubNet(ResolveIP(\"127.0.0.1\")).IsValid());\n+    BOOST_CHECK(CSubNet(ResolveIP(\"127.0.0.1\")).Match(ResolveIP(\"127.0.0.1\")));\n+    BOOST_CHECK(!CSubNet(ResolveIP(\"127.0.0.1\")).Match(ResolveIP(\"127.0.0.2\")));\n+    BOOST_CHECK(CSubNet(ResolveIP(\"127.0.0.1\")).ToString() == \"127.0.0.1/32\");\n \n-    BOOST_CHECK(CSubNet(CNetAddr(\"1:2:3:4:5:6:7:8\")).IsValid());\n-    BOOST_CHECK(CSubNet(CNetAddr(\"1:2:3:4:5:6:7:8\")).Match(CNetAddr(\"1:2:3:4:5:6:7:8\")));\n-    BOOST_CHECK(!CSubNet(CNetAddr(\"1:2:3:4:5:6:7:8\")).Match(CNetAddr(\"1:2:3:4:5:6:7:9\")));\n-    BOOST_CHECK(CSubNet(CNetAddr(\"1:2:3:4:5:6:7:8\")).ToString() == \"1:2:3:4:5:6:7:8/128\");\n+    CSubNet subnet = CSubNet(ResolveIP(\"1.2.3.4\"), 32);\n+    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.4/32\");\n+    subnet = CSubNet(ResolveIP(\"1.2.3.4\"), 8);\n+    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/8\");\n+    subnet = CSubNet(ResolveIP(\"1.2.3.4\"), 0);\n+    BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/0\");\n \n-    CSubNet subnet = CSubNet(\"1.2.3.4/255.255.255.255\");\n+    subnet = CSubNet(ResolveIP(\"1.2.3.4\"), ResolveIP(\"255.255.255.255\"));\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.4/32\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.255.254\");\n+    subnet = CSubNet(ResolveIP(\"1.2.3.4\"), ResolveIP(\"255.0.0.0\"));\n+    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/8\");\n+    subnet = CSubNet(ResolveIP(\"1.2.3.4\"), ResolveIP(\"0.0.0.0\"));\n+    BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/0\");\n+\n+    BOOST_CHECK(CSubNet(ResolveIP(\"1:2:3:4:5:6:7:8\")).IsValid());\n+    BOOST_CHECK(CSubNet(ResolveIP(\"1:2:3:4:5:6:7:8\")).Match(ResolveIP(\"1:2:3:4:5:6:7:8\")));\n+    BOOST_CHECK(!CSubNet(ResolveIP(\"1:2:3:4:5:6:7:8\")).Match(ResolveIP(\"1:2:3:4:5:6:7:9\")));\n+    BOOST_CHECK(CSubNet(ResolveIP(\"1:2:3:4:5:6:7:8\")).ToString() == \"1:2:3:4:5:6:7:8/128\");\n+\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.255.255\");\n+    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.4/32\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.255.254\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.4/31\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.255.252\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.255.252\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.4/30\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.255.248\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.255.248\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.0/29\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.255.240\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.255.240\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.0/28\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.255.224\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.255.224\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.0/27\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.255.192\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.255.192\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.0/26\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.255.128\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.255.128\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.0/25\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.255.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.255.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.0/24\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.254.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.254.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.2.0/23\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.252.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.252.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/22\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.248.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.248.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/21\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.240.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.240.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/20\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.224.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.224.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/19\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.192.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.192.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/18\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.128.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.128.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/17\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/16\");\n-    subnet = CSubNet(\"1.2.3.4/255.254.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.254.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/15\");\n-    subnet = CSubNet(\"1.2.3.4/255.252.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.252.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/14\");\n-    subnet = CSubNet(\"1.2.3.4/255.248.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.248.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/13\");\n-    subnet = CSubNet(\"1.2.3.4/255.240.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.240.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/12\");\n-    subnet = CSubNet(\"1.2.3.4/255.224.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.224.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/11\");\n-    subnet = CSubNet(\"1.2.3.4/255.192.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.192.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/10\");\n-    subnet = CSubNet(\"1.2.3.4/255.128.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.128.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/9\");\n-    subnet = CSubNet(\"1.2.3.4/255.0.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.0.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/8\");\n-    subnet = CSubNet(\"1.2.3.4/254.0.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/254.0.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/7\");\n-    subnet = CSubNet(\"1.2.3.4/252.0.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/252.0.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/6\");\n-    subnet = CSubNet(\"1.2.3.4/248.0.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/248.0.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/5\");\n-    subnet = CSubNet(\"1.2.3.4/240.0.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/240.0.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/4\");\n-    subnet = CSubNet(\"1.2.3.4/224.0.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/224.0.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/3\");\n-    subnet = CSubNet(\"1.2.3.4/192.0.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/192.0.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/2\");\n-    subnet = CSubNet(\"1.2.3.4/128.0.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/128.0.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/1\");\n-    subnet = CSubNet(\"1.2.3.4/0.0.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/0.0.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/0\");\n \n-    subnet = CSubNet(\"1:2:3:4:5:6:7:8/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\");\n+    subnet = ResolveSubNet(\"1:2:3:4:5:6:7:8/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1:2:3:4:5:6:7:8/128\");\n-    subnet = CSubNet(\"1:2:3:4:5:6:7:8/ffff:0000:0000:0000:0000:0000:0000:0000\");\n+    subnet = ResolveSubNet(\"1:2:3:4:5:6:7:8/ffff:0000:0000:0000:0000:0000:0000:0000\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1::/16\");\n-    subnet = CSubNet(\"1:2:3:4:5:6:7:8/0000:0000:0000:0000:0000:0000:0000:0000\");\n+    subnet = ResolveSubNet(\"1:2:3:4:5:6:7:8/0000:0000:0000:0000:0000:0000:0000:0000\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"::/0\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.232.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.232.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/255.255.232.0\");\n-    subnet = CSubNet(\"1:2:3:4:5:6:7:8/ffff:ffff:ffff:fffe:ffff:ffff:ffff:ff0f\");\n+    subnet = ResolveSubNet(\"1:2:3:4:5:6:7:8/ffff:ffff:ffff:fffe:ffff:ffff:ffff:ff0f\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1:2:3:4:5:6:7:8/ffff:ffff:ffff:fffe:ffff:ffff:ffff:ff0f\");\n+\n }\n \n BOOST_AUTO_TEST_CASE(netbase_getgroup)\n {\n-    BOOST_CHECK(CNetAddr(\"127.0.0.1\").GetGroup() == boost::assign::list_of(0)); // Local -> !Routable()\n-    BOOST_CHECK(CNetAddr(\"257.0.0.1\").GetGroup() == boost::assign::list_of(0)); // !Valid -> !Routable()\n-    BOOST_CHECK(CNetAddr(\"10.0.0.1\").GetGroup() == boost::assign::list_of(0)); // RFC1918 -> !Routable()\n-    BOOST_CHECK(CNetAddr(\"169.254.1.1\").GetGroup() == boost::assign::list_of(0)); // RFC3927 -> !Routable()\n-    BOOST_CHECK(CNetAddr(\"1.2.3.4\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // IPv4\n-    BOOST_CHECK(CNetAddr(\"::FFFF:0:102:304\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // RFC6145\n-    BOOST_CHECK(CNetAddr(\"64:FF9B::102:304\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // RFC6052\n-    BOOST_CHECK(CNetAddr(\"2002:102:304:9999:9999:9999:9999:9999\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // RFC3964\n-    BOOST_CHECK(CNetAddr(\"2001:0:9999:9999:9999:9999:FEFD:FCFB\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // RFC4380\n-    BOOST_CHECK(CNetAddr(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\").GetGroup() == boost::assign::list_of((unsigned char)NET_TOR)(239)); // Tor\n-    BOOST_CHECK(CNetAddr(\"2001:470:abcd:9999:9999:9999:9999:9999\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV6)(32)(1)(4)(112)(175)); //he.net\n-    BOOST_CHECK(CNetAddr(\"2001:2001:9999:9999:9999:9999:9999:9999\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV6)(32)(1)(32)(1)); //IPv6\n+\n+    BOOST_CHECK(ResolveIP(\"127.0.0.1\").GetGroup() == boost::assign::list_of(0)); // Local -> !Routable()\n+    BOOST_CHECK(ResolveIP(\"257.0.0.1\").GetGroup() == boost::assign::list_of(0)); // !Valid -> !Routable()\n+    BOOST_CHECK(ResolveIP(\"10.0.0.1\").GetGroup() == boost::assign::list_of(0)); // RFC1918 -> !Routable()\n+    BOOST_CHECK(ResolveIP(\"169.254.1.1\").GetGroup() == boost::assign::list_of(0)); // RFC3927 -> !Routable()\n+    BOOST_CHECK(ResolveIP(\"1.2.3.4\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // IPv4\n+    BOOST_CHECK(ResolveIP(\"::FFFF:0:102:304\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // RFC6145\n+    BOOST_CHECK(ResolveIP(\"64:FF9B::102:304\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // RFC6052\n+    BOOST_CHECK(ResolveIP(\"2002:102:304:9999:9999:9999:9999:9999\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // RFC3964\n+    BOOST_CHECK(ResolveIP(\"2001:0:9999:9999:9999:9999:FEFD:FCFB\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // RFC4380\n+    BOOST_CHECK(ResolveIP(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\").GetGroup() == boost::assign::list_of((unsigned char)NET_TOR)(239)); // Tor\n+    BOOST_CHECK(ResolveIP(\"2001:470:abcd:9999:9999:9999:9999:9999\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV6)(32)(1)(4)(112)(175)); //he.net\n+    BOOST_CHECK(ResolveIP(\"2001:2001:9999:9999:9999:9999:9999:9999\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV6)(32)(1)(32)(1)); //IPv6\n+\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "056f2982cf1eb0e8e8eca76cda73dd0b2acecc67",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -60,6 +60,11 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n         pcoinsdbview = new CCoinsViewDB(1 << 23, true);\n         pcoinsTip = new CCoinsViewCache(pcoinsdbview);\n         InitBlockIndex(chainparams);\n+        {\n+            CValidationState state;\n+            bool ok = ActivateBestChain(state, chainparams);\n+            BOOST_CHECK(ok);\n+        }\n         nScriptCheckThreads = 3;\n         for (int i=0; i < nScriptCheckThreads-1; i++)\n             threadGroup.create_thread(&ThreadScriptCheck);"
      },
      {
        "sha": "25fc494121d4debbd00f91fb8af6674beb600dca",
        "filename": "src/timedata.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/timedata.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/timedata.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -8,7 +8,7 @@\n \n #include \"timedata.h\"\n \n-#include \"netbase.h\"\n+#include \"netaddress.h\"\n #include \"sync.h\"\n #include \"ui_interface.h\"\n #include \"util.h\""
      },
      {
        "sha": "17f0360c42f24f5dfcfd7c5d69a53b4bddb10454",
        "filename": "src/tinyformat.h",
        "status": "modified",
        "additions": 368,
        "deletions": 332,
        "changes": 700,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/tinyformat.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/tinyformat.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tinyformat.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -67,7 +67,9 @@\n //                                  weekday, month, day, hour, min);\n //   std::cout << date;\n //\n-// These are the three primary interface functions.\n+// These are the three primary interface functions.  There is also a\n+// convenience function printfln() which appends a newline to the usual result\n+// of printf() for super simple logging.\n //\n //\n // User defined format functions\n@@ -86,6 +88,18 @@\n // defined function bodies, use the macro TINYFORMAT_FOREACH_ARGNUM.  For an\n // example, see the implementation of printf() at the end of the source file.\n //\n+// Sometimes it's useful to be able to pass a list of format arguments through\n+// to a non-template function.  The FormatList class is provided as a way to do\n+// this by storing the argument list in a type-opaque way.  Continuing the\n+// example from above, we construct a FormatList using makeFormatList():\n+//\n+//   FormatListRef formatList = tfm::makeFormatList(weekday, month, day, hour, min);\n+//\n+// The format list can now be passed into any non-template function and used\n+// via a call to the vformat() function:\n+//\n+//   tfm::vformat(std::cout, \"%s, %s %d, %.2d:%.2d\\n\", formatList);\n+//\n //\n // Additional API information\n // --------------------------\n@@ -118,6 +132,7 @@ namespace tfm = tinyformat;\n \n //------------------------------------------------------------------------------\n // Implementation details.\n+#include <algorithm>\n #include <cassert>\n #include <iostream>\n #include <sstream>\n@@ -133,20 +148,20 @@ namespace tfm = tinyformat;\n #   endif\n #endif\n \n-#ifdef __GNUC__\n-#   define TINYFORMAT_NOINLINE __attribute__((noinline))\n-#elif defined(_MSC_VER)\n-#   define TINYFORMAT_NOINLINE __declspec(noinline)\n-#else\n-#   define TINYFORMAT_NOINLINE\n-#endif\n-\n #if defined(__GLIBCXX__) && __GLIBCXX__ < 20080201\n //  std::showpos is broken on old libstdc++ as provided with OSX.  See\n //  http://gcc.gnu.org/ml/libstdc++/2007-11/msg00075.html\n #   define TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND\n #endif\n \n+#ifdef __APPLE__\n+// Workaround OSX linker warning: xcode uses different default symbol\n+// visibilities for static libs vs executables (see issue #25)\n+#   define TINYFORMAT_HIDDEN __attribute__((visibility(\"hidden\")))\n+#else\n+#   define TINYFORMAT_HIDDEN\n+#endif\n+\n namespace tinyformat {\n \n //------------------------------------------------------------------------------\n@@ -247,6 +262,29 @@ struct convertToInt<T,true>\n     static int invoke(const T& value) { return static_cast<int>(value); }\n };\n \n+// Format at most ntrunc characters to the given stream.\n+template<typename T>\n+inline void formatTruncated(std::ostream& out, const T& value, int ntrunc)\n+{\n+    std::ostringstream tmp;\n+    tmp << value;\n+    std::string result = tmp.str();\n+    out.write(result.c_str(), (std::min)(ntrunc, static_cast<int>(result.size())));\n+}\n+#define TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(type)       \\\n+inline void formatTruncated(std::ostream& out, type* value, int ntrunc) \\\n+{                                                           \\\n+    std::streamsize len = 0;                                \\\n+    while(len < ntrunc && value[len] != 0)                  \\\n+        ++len;                                              \\\n+    out.write(value, len);                                  \\\n+}\n+// Overload for const char* and char*.  Could overload for signed & unsigned\n+// char too, but these are technically unneeded for printf compatibility.\n+TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(const char)\n+TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(char)\n+#undef TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR\n+\n } // namespace detail\n \n \n@@ -255,18 +293,20 @@ struct convertToInt<T,true>\n // desired.\n \n \n-// Format a value into a stream. Called from format() for all types by default.\n-//\n-// Users may override this for their own types.  When this function is called,\n-// the stream flags will have been modified according to the format string.\n-// The format specification is provided in the range [fmtBegin, fmtEnd).\n-//\n-// By default, formatValue() uses the usual stream insertion operator\n-// operator<< to format the type T, with special cases for the %c and %p\n-// conversions.\n+/// Format a value into a stream, delegating to operator<< by default.\n+///\n+/// Users may override this for their own types.  When this function is called,\n+/// the stream flags will have been modified according to the format string.\n+/// The format specification is provided in the range [fmtBegin, fmtEnd).  For\n+/// truncating conversions, ntrunc is set to the desired maximum number of\n+/// characters, for example \"%.7s\" calls formatValue with ntrunc = 7.\n+///\n+/// By default, formatValue() uses the usual stream insertion operator\n+/// operator<< to format the type T, with special cases for the %c and %p\n+/// conversions.\n template<typename T>\n inline void formatValue(std::ostream& out, const char* /*fmtBegin*/,\n-                        const char* fmtEnd, const T& value)\n+                        const char* fmtEnd, int ntrunc, const T& value)\n {\n #ifndef TINYFORMAT_ALLOW_WCHAR_STRINGS\n     // Since we don't support printing of wchar_t using \"%ls\", make it fail at\n@@ -288,6 +328,12 @@ inline void formatValue(std::ostream& out, const char* /*fmtBegin*/,\n #ifdef TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND\n     else if(detail::formatZeroIntegerWorkaround<T>::invoke(out, value)) /**/;\n #endif\n+    else if(ntrunc >= 0)\n+    {\n+        // Take care not to overread C strings in truncating conversions like\n+        // \"%.4s\" where at most 4 characters may be read.\n+        detail::formatTruncated(out, value, ntrunc);\n+    }\n     else\n         out << value;\n }\n@@ -296,7 +342,7 @@ inline void formatValue(std::ostream& out, const char* /*fmtBegin*/,\n // Overloaded version for char types to support printing as an integer\n #define TINYFORMAT_DEFINE_FORMATVALUE_CHAR(charType)                  \\\n inline void formatValue(std::ostream& out, const char* /*fmtBegin*/,  \\\n-                        const char* fmtEnd, charType value)           \\\n+                        const char* fmtEnd, int /**/, charType value) \\\n {                                                                     \\\n     switch(*(fmtEnd-1))                                               \\\n     {                                                                 \\\n@@ -435,225 +481,91 @@ cog.outl('#define TINYFORMAT_FOREACH_ARGNUM(m) \\\\\\n    ' +\n \n namespace detail {\n \n-// Class holding current position in format string and an output stream into\n-// which arguments are formatted.\n-class FormatIterator\n+// Type-opaque holder for an argument to format(), with associated actions on\n+// the type held as explicit function pointers.  This allows FormatArg's for\n+// each argument to be allocated as a homogenous array inside FormatList\n+// whereas a naive implementation based on inheritance does not.\n+class FormatArg\n {\n     public:\n-        // Flags for features not representable with standard stream state\n-        enum ExtraFormatFlags\n-        {\n-            Flag_None                = 0,\n-            Flag_TruncateToPrecision = 1<<0, // truncate length to stream precision()\n-            Flag_SpacePadPositive    = 1<<1, // pad positive values with spaces\n-            Flag_VariableWidth       = 1<<2, // variable field width in arg list\n-            Flag_VariablePrecision   = 1<<3  // variable field precision in arg list\n-        };\n-\n-        // out is the output stream, fmt is the full format string\n-        FormatIterator(std::ostream& out, const char* fmt)\n-            : m_out(out),\n-            m_fmt(fmt),\n-            m_extraFlags(Flag_None),\n-            m_wantWidth(false),\n-            m_wantPrecision(false),\n-            m_variableWidth(0),\n-            m_variablePrecision(0),\n-            m_origWidth(out.width()),\n-            m_origPrecision(out.precision()),\n-            m_origFlags(out.flags()),\n-            m_origFill(out.fill())\n+        FormatArg() {}\n+\n+        template<typename T>\n+        FormatArg(const T& value)\n+            : m_value(static_cast<const void*>(&value)),\n+            m_formatImpl(&formatImpl<T>),\n+            m_toIntImpl(&toIntImpl<T>)\n         { }\n \n-        // Print remaining part of format string.\n-        void finish()\n+        void format(std::ostream& out, const char* fmtBegin,\n+                    const char* fmtEnd, int ntrunc) const\n         {\n-            // It would be nice if we could do this from the destructor, but we\n-            // can't if TINFORMAT_ERROR is used to throw an exception!\n-            m_fmt = printFormatStringLiteral(m_out, m_fmt);\n-            if(*m_fmt != '\\0')\n-                TINYFORMAT_ERROR(\"tinyformat: Too many conversion specifiers in format string\");\n+            m_formatImpl(out, fmtBegin, fmtEnd, ntrunc, m_value);\n         }\n \n-        ~FormatIterator()\n+        int toInt() const\n         {\n-            // Restore stream state\n-            m_out.width(m_origWidth);\n-            m_out.precision(m_origPrecision);\n-            m_out.flags(m_origFlags);\n-            m_out.fill(m_origFill);\n+            return m_toIntImpl(m_value);\n         }\n \n-        template<typename T>\n-        void accept(const T& value);\n-\n     private:\n-        // Parse and return an integer from the string c, as atoi()\n-        // On return, c is set to one past the end of the integer.\n-        static int parseIntAndAdvance(const char*& c)\n+        template<typename T>\n+        TINYFORMAT_HIDDEN static void formatImpl(std::ostream& out, const char* fmtBegin,\n+                        const char* fmtEnd, int ntrunc, const void* value)\n         {\n-            int i = 0;\n-            for(;*c >= '0' && *c <= '9'; ++c)\n-                i = 10*i + (*c - '0');\n-            return i;\n+            formatValue(out, fmtBegin, fmtEnd, ntrunc, *static_cast<const T*>(value));\n         }\n \n-        // Format at most truncLen characters of a C string to the given\n-        // stream.  Return true if formatting proceeded (generic version always\n-        // returns false)\n         template<typename T>\n-        static bool formatCStringTruncate(std::ostream& /*out*/, const T& /*value*/,\n-                                        std::streamsize /*truncLen*/)\n+        TINYFORMAT_HIDDEN static int toIntImpl(const void* value)\n         {\n-            return false;\n-        }\n-#       define TINYFORMAT_DEFINE_FORMAT_C_STRING_TRUNCATE(type)            \\\n-        static bool formatCStringTruncate(std::ostream& out, type* value,  \\\n-                                        std::streamsize truncLen)          \\\n-        {                                                                  \\\n-            std::streamsize len = 0;                                       \\\n-            while(len < truncLen && value[len] != 0)                       \\\n-                ++len;                                                     \\\n-            out.write(value, len);                                         \\\n-            return true;                                                   \\\n-        }\n-        // Overload for const char* and char*.  Could overload for signed &\n-        // unsigned char too, but these are technically unneeded for printf\n-        // compatibility.\n-        TINYFORMAT_DEFINE_FORMAT_C_STRING_TRUNCATE(const char)\n-        TINYFORMAT_DEFINE_FORMAT_C_STRING_TRUNCATE(char)\n-#       undef TINYFORMAT_DEFINE_FORMAT_C_STRING_TRUNCATE\n-\n-        // Print literal part of format string and return next format spec\n-        // position.\n-        //\n-        // Skips over any occurrences of '%%', printing a literal '%' to the\n-        // output.  The position of the first % character of the next\n-        // nontrivial format spec is returned, or the end of string.\n-        static const char* printFormatStringLiteral(std::ostream& out,\n-                                                    const char* fmt)\n-        {\n-            const char* c = fmt;\n-            for(; true; ++c)\n-            {\n-                switch(*c)\n-                {\n-                    case '\\0':\n-                        out.write(fmt, static_cast<std::streamsize>(c - fmt));\n-                        return c;\n-                    case '%':\n-                        out.write(fmt, static_cast<std::streamsize>(c - fmt));\n-                        if(*(c+1) != '%')\n-                            return c;\n-                        // for \"%%\", tack trailing % onto next literal section.\n-                        fmt = ++c;\n-                        break;\n-                }\n-            }\n+            return convertToInt<T>::invoke(*static_cast<const T*>(value));\n         }\n \n-        static const char* streamStateFromFormat(std::ostream& out,\n-                                                 unsigned int& extraFlags,\n-                                                 const char* fmtStart,\n-                                                 int variableWidth,\n-                                                 int variablePrecision);\n-\n-        // Private copy & assign: Kill gcc warnings with -Weffc++\n-        FormatIterator(const FormatIterator&);\n-        FormatIterator& operator=(const FormatIterator&);\n-\n-        // Stream, current format string & state\n-        std::ostream& m_out;\n-        const char* m_fmt;\n-        unsigned int m_extraFlags;\n-        // State machine info for handling of variable width & precision\n-        bool m_wantWidth;\n-        bool m_wantPrecision;\n-        int m_variableWidth;\n-        int m_variablePrecision;\n-        // Saved stream state\n-        std::streamsize m_origWidth;\n-        std::streamsize m_origPrecision;\n-        std::ios::fmtflags m_origFlags;\n-        char m_origFill;\n+        const void* m_value;\n+        void (*m_formatImpl)(std::ostream& out, const char* fmtBegin,\n+                             const char* fmtEnd, int ntrunc, const void* value);\n+        int (*m_toIntImpl)(const void* value);\n };\n \n \n-// Accept a value for formatting into the internal stream.\n-template<typename T>\n-TINYFORMAT_NOINLINE  // < greatly reduces bloat in optimized builds\n-void FormatIterator::accept(const T& value)\n+// Parse and return an integer from the string c, as atoi()\n+// On return, c is set to one past the end of the integer.\n+inline int parseIntAndAdvance(const char*& c)\n {\n-    // Parse the format string\n-    const char* fmtEnd = 0;\n-    if(m_extraFlags == Flag_None && !m_wantWidth && !m_wantPrecision)\n-    {\n-        m_fmt = printFormatStringLiteral(m_out, m_fmt);\n-        fmtEnd = streamStateFromFormat(m_out, m_extraFlags, m_fmt, 0, 0);\n-        m_wantWidth     = (m_extraFlags & Flag_VariableWidth) != 0;\n-        m_wantPrecision = (m_extraFlags & Flag_VariablePrecision) != 0;\n-    }\n-    // Consume value as variable width and precision specifier if necessary\n-    if(m_extraFlags & (Flag_VariableWidth | Flag_VariablePrecision))\n-    {\n-        if(m_wantWidth || m_wantPrecision)\n-        {\n-            int v = convertToInt<T>::invoke(value);\n-            if(m_wantWidth)\n-            {\n-                m_variableWidth = v;\n-                m_wantWidth = false;\n-            }\n-            else if(m_wantPrecision)\n-            {\n-                m_variablePrecision = v;\n-                m_wantPrecision = false;\n-            }\n-            return;\n-        }\n-        // If we get here, we've set both the variable precision and width as\n-        // required and we need to rerun the stream state setup to insert these.\n-        fmtEnd = streamStateFromFormat(m_out, m_extraFlags, m_fmt,\n-                                       m_variableWidth, m_variablePrecision);\n-    }\n+    int i = 0;\n+    for(;*c >= '0' && *c <= '9'; ++c)\n+        i = 10*i + (*c - '0');\n+    return i;\n+}\n \n-    // Format the value into the stream.\n-    if(!(m_extraFlags & (Flag_SpacePadPositive | Flag_TruncateToPrecision)))\n-        formatValue(m_out, m_fmt, fmtEnd, value);\n-    else\n+// Print literal part of format string and return next format spec\n+// position.\n+//\n+// Skips over any occurrences of '%%', printing a literal '%' to the\n+// output.  The position of the first % character of the next\n+// nontrivial format spec is returned, or the end of string.\n+inline const char* printFormatStringLiteral(std::ostream& out, const char* fmt)\n+{\n+    const char* c = fmt;\n+    for(;; ++c)\n     {\n-        // The following are special cases where there's no direct\n-        // correspondence between stream formatting and the printf() behaviour.\n-        // Instead, we simulate the behaviour crudely by formatting into a\n-        // temporary string stream and munging the resulting string.\n-        std::ostringstream tmpStream;\n-        tmpStream.copyfmt(m_out);\n-        if(m_extraFlags & Flag_SpacePadPositive)\n-            tmpStream.setf(std::ios::showpos);\n-        // formatCStringTruncate is required for truncating conversions like\n-        // \"%.4s\" where at most 4 characters of the c-string should be read.\n-        // If we didn't include this special case, we might read off the end.\n-        if(!( (m_extraFlags & Flag_TruncateToPrecision) &&\n-             formatCStringTruncate(tmpStream, value, m_out.precision()) ))\n-        {\n-            // Not a truncated c-string; just format normally.\n-            formatValue(tmpStream, m_fmt, fmtEnd, value);\n-        }\n-        std::string result = tmpStream.str(); // allocates... yuck.\n-        if(m_extraFlags & Flag_SpacePadPositive)\n+        switch(*c)\n         {\n-            for(size_t i = 0, iend = result.size(); i < iend; ++i)\n-                if(result[i] == '+')\n-                    result[i] = ' ';\n+            case '\\0':\n+                out.write(fmt, c - fmt);\n+                return c;\n+            case '%':\n+                out.write(fmt, c - fmt);\n+                if(*(c+1) != '%')\n+                    return c;\n+                // for \"%%\", tack trailing % onto next literal section.\n+                fmt = ++c;\n+                break;\n+            default:\n+                break;\n         }\n-        if((m_extraFlags & Flag_TruncateToPrecision) &&\n-           (int)result.size() > (int)m_out.precision())\n-            m_out.write(result.c_str(), m_out.precision());\n-        else\n-            m_out << result;\n     }\n-    m_extraFlags = Flag_None;\n-    m_fmt = fmtEnd;\n }\n \n \n@@ -663,13 +575,14 @@ void FormatIterator::accept(const T& value)\n // with the form \"%[flags][width][.precision][length]type\".\n //\n // Formatting options which can't be natively represented using the ostream\n-// state are returned in the extraFlags parameter which is a bitwise\n-// combination of values from the ExtraFormatFlags enum.\n-inline const char* FormatIterator::streamStateFromFormat(std::ostream& out,\n-                                                         unsigned int& extraFlags,\n-                                                         const char* fmtStart,\n-                                                         int variableWidth,\n-                                                         int variablePrecision)\n+// state are returned in spacePadPositive (for space padded positive numbers)\n+// and ntrunc (for truncating conversions).  argIndex is incremented if\n+// necessary to pull out variable width and precision .  The function returns a\n+// pointer to the character after the end of the current format spec.\n+inline const char* streamStateFromFormat(std::ostream& out, bool& spacePadPositive,\n+                                         int& ntrunc, const char* fmtStart,\n+                                         const detail::FormatArg* formatters,\n+                                         int& argIndex, int numFormatters)\n {\n     if(*fmtStart != '%')\n     {\n@@ -684,9 +597,9 @@ inline const char* FormatIterator::streamStateFromFormat(std::ostream& out,\n     out.unsetf(std::ios::adjustfield | std::ios::basefield |\n                std::ios::floatfield | std::ios::showbase | std::ios::boolalpha |\n                std::ios::showpoint | std::ios::showpos | std::ios::uppercase);\n-    extraFlags = Flag_None;\n     bool precisionSet = false;\n     bool widthSet = false;\n+    int widthExtra = 0;\n     const char* c = fmtStart + 1;\n     // 1) Parse flags\n     for(;; ++c)\n@@ -713,12 +626,15 @@ inline const char* FormatIterator::streamStateFromFormat(std::ostream& out,\n             case ' ':\n                 // overridden by show positive sign, '+' flag.\n                 if(!(out.flags() & std::ios::showpos))\n-                    extraFlags |= Flag_SpacePadPositive;\n+                    spacePadPositive = true;\n                 continue;\n             case '+':\n                 out.setf(std::ios::showpos);\n-                extraFlags &= ~Flag_SpacePadPositive;\n+                spacePadPositive = false;\n+                widthExtra = 1;\n                 continue;\n+            default:\n+                break;\n         }\n         break;\n     }\n@@ -731,15 +647,19 @@ inline const char* FormatIterator::streamStateFromFormat(std::ostream& out,\n     if(*c == '*')\n     {\n         widthSet = true;\n-        if(variableWidth < 0)\n+        int width = 0;\n+        if(argIndex < numFormatters)\n+            width = formatters[argIndex++].toInt();\n+        else\n+            TINYFORMAT_ERROR(\"tinyformat: Not enough arguments to read variable width\");\n+        if(width < 0)\n         {\n             // negative widths correspond to '-' flag set\n             out.fill(' ');\n             out.setf(std::ios::left, std::ios::adjustfield);\n-            variableWidth = -variableWidth;\n+            width = -width;\n         }\n-        out.width(variableWidth);\n-        extraFlags |= Flag_VariableWidth;\n+        out.width(width);\n         ++c;\n     }\n     // 3) Parse precision\n@@ -750,8 +670,10 @@ inline const char* FormatIterator::streamStateFromFormat(std::ostream& out,\n         if(*c == '*')\n         {\n             ++c;\n-            extraFlags |= Flag_VariablePrecision;\n-            precision = variablePrecision;\n+            if(argIndex < numFormatters)\n+                precision = formatters[argIndex++].toInt();\n+            else\n+                TINYFORMAT_ERROR(\"tinyformat: Not enough arguments to read variable precision\");\n         }\n         else\n         {\n@@ -814,7 +736,7 @@ inline const char* FormatIterator::streamStateFromFormat(std::ostream& out,\n             break;\n         case 's':\n             if(precisionSet)\n-                extraFlags |= Flag_TruncateToPrecision;\n+                ntrunc = static_cast<int>(out.precision());\n             // Make %s print booleans as \"true\" and \"false\"\n             out.setf(std::ios::boolalpha);\n             break;\n@@ -826,185 +748,299 @@ inline const char* FormatIterator::streamStateFromFormat(std::ostream& out,\n             TINYFORMAT_ERROR(\"tinyformat: Conversion spec incorrectly \"\n                              \"terminated by end of string\");\n             return c;\n+        default:\n+            break;\n     }\n     if(intConversion && precisionSet && !widthSet)\n     {\n         // \"precision\" for integers gives the minimum number of digits (to be\n         // padded with zeros on the left).  This isn't really supported by the\n         // iostreams, but we can approximately simulate it with the width if\n         // the width isn't otherwise used.\n-        out.width(out.precision());\n+        out.width(out.precision() + widthExtra);\n         out.setf(std::ios::internal, std::ios::adjustfield);\n         out.fill('0');\n     }\n     return c+1;\n }\n \n \n-\n //------------------------------------------------------------------------------\n-// Private format function on top of which the public interface is implemented.\n-// We enforce a mimimum of one value to be formatted to prevent bugs looking like\n-//\n-//   const char* myStr = \"100% broken\";\n-//   printf(myStr);   // Parses % as a format specifier\n-#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES\n-\n-template<typename T1>\n-void format(FormatIterator& fmtIter, const T1& value1)\n+inline void formatImpl(std::ostream& out, const char* fmt,\n+                       const detail::FormatArg* formatters,\n+                       int numFormatters)\n {\n-    fmtIter.accept(value1);\n-    fmtIter.finish();\n+    // Saved stream state\n+    std::streamsize origWidth = out.width();\n+    std::streamsize origPrecision = out.precision();\n+    std::ios::fmtflags origFlags = out.flags();\n+    char origFill = out.fill();\n+\n+    for (int argIndex = 0; argIndex < numFormatters; ++argIndex)\n+    {\n+        // Parse the format string\n+        fmt = printFormatStringLiteral(out, fmt);\n+        bool spacePadPositive = false;\n+        int ntrunc = -1;\n+        const char* fmtEnd = streamStateFromFormat(out, spacePadPositive, ntrunc, fmt,\n+                                                   formatters, argIndex, numFormatters);\n+        if (argIndex >= numFormatters)\n+        {\n+            // Check args remain after reading any variable width/precision\n+            TINYFORMAT_ERROR(\"tinyformat: Not enough format arguments\");\n+            return;\n+        }\n+        const FormatArg& arg = formatters[argIndex];\n+        // Format the arg into the stream.\n+        if(!spacePadPositive)\n+            arg.format(out, fmt, fmtEnd, ntrunc);\n+        else\n+        {\n+            // The following is a special case with no direct correspondence\n+            // between stream formatting and the printf() behaviour.  Simulate\n+            // it crudely by formatting into a temporary string stream and\n+            // munging the resulting string.\n+            std::ostringstream tmpStream;\n+            tmpStream.copyfmt(out);\n+            tmpStream.setf(std::ios::showpos);\n+            arg.format(tmpStream, fmt, fmtEnd, ntrunc);\n+            std::string result = tmpStream.str(); // allocates... yuck.\n+            for(size_t i = 0, iend = result.size(); i < iend; ++i)\n+                if(result[i] == '+') result[i] = ' ';\n+            out << result;\n+        }\n+        fmt = fmtEnd;\n+    }\n+\n+    // Print remaining part of format string.\n+    fmt = printFormatStringLiteral(out, fmt);\n+    if(*fmt != '\\0')\n+        TINYFORMAT_ERROR(\"tinyformat: Too many conversion specifiers in format string\");\n+\n+    // Restore stream state\n+    out.width(origWidth);\n+    out.precision(origPrecision);\n+    out.flags(origFlags);\n+    out.fill(origFill);\n }\n \n-// General version for C++11\n-template<typename T1, typename... Args>\n-void format(FormatIterator& fmtIter, const T1& value1, const Args&... args)\n+} // namespace detail\n+\n+\n+/// List of template arguments format(), held in a type-opaque way.\n+///\n+/// A const reference to FormatList (typedef'd as FormatListRef) may be\n+/// conveniently used to pass arguments to non-template functions: All type\n+/// information has been stripped from the arguments, leaving just enough of a\n+/// common interface to perform formatting as required.\n+class FormatList\n {\n-    fmtIter.accept(value1);\n-    format(fmtIter, args...);\n-}\n+    public:\n+        FormatList(detail::FormatArg* formatters, int N)\n+            : m_formatters(formatters), m_N(N) { }\n \n-#else\n+        friend void vformat(std::ostream& out, const char* fmt,\n+                            const FormatList& list);\n \n-inline void format(FormatIterator& fmtIter)\n+    private:\n+        const detail::FormatArg* m_formatters;\n+        int m_N;\n+};\n+\n+/// Reference to type-opaque format list for passing to vformat()\n+typedef const FormatList& FormatListRef;\n+\n+\n+namespace detail {\n+\n+// Format list subclass with fixed storage to avoid dynamic allocation\n+template<int N>\n+class FormatListN : public FormatList\n {\n-    fmtIter.finish();\n-}\n+    public:\n+#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES\n+        template<typename... Args>\n+        FormatListN(const Args&... args)\n+            : FormatList(&m_formatterStore[0], N),\n+            m_formatterStore { FormatArg(args)... }\n+        { static_assert(sizeof...(args) == N, \"Number of args must be N\"); }\n+#else // C++98 version\n+        void init(int) {}\n+#       define TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR(n)       \\\n+                                                               \\\n+        template<TINYFORMAT_ARGTYPES(n)>                       \\\n+        FormatListN(TINYFORMAT_VARARGS(n))                     \\\n+            : FormatList(&m_formatterStore[0], n)              \\\n+        { assert(n == N); init(0, TINYFORMAT_PASSARGS(n)); }   \\\n+                                                               \\\n+        template<TINYFORMAT_ARGTYPES(n)>                       \\\n+        void init(int i, TINYFORMAT_VARARGS(n))                \\\n+        {                                                      \\\n+            m_formatterStore[i] = FormatArg(v1);               \\\n+            init(i+1 TINYFORMAT_PASSARGS_TAIL(n));             \\\n+        }\n \n-// General version for C++98\n-#define TINYFORMAT_MAKE_FORMAT_DETAIL(n)                                  \\\n-template<TINYFORMAT_ARGTYPES(n)>                                          \\\n-void format(detail::FormatIterator& fmtIter, TINYFORMAT_VARARGS(n))       \\\n-{                                                                         \\\n-    fmtIter.accept(v1);                                                   \\\n-    format(fmtIter TINYFORMAT_PASSARGS_TAIL(n));                          \\\n-}\n+        TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR)\n+#       undef TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR\n+#endif\n \n-TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_FORMAT_DETAIL)\n-#undef TINYFORMAT_MAKE_FORMAT_DETAIL\n+    private:\n+        FormatArg m_formatterStore[N];\n+};\n \n-#endif // End C++98 variadic template emulation for format()\n+// Special 0-arg version - MSVC says zero-sized C array in struct is nonstandard\n+template<> class FormatListN<0> : public FormatList\n+{\n+    public: FormatListN() : FormatList(0, 0) {}\n+};\n \n } // namespace detail\n \n \n //------------------------------------------------------------------------------\n-// Implement all the main interface functions here in terms of detail::format()\n+// Primary API functions\n \n #ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES\n \n-// C++11 - the simple case\n-template<typename T1, typename... Args>\n-void format(std::ostream& out, const char* fmt, const T1& v1, const Args&... args)\n+/// Make type-agnostic format list from list of template arguments.\n+///\n+/// The exact return type of this function is an implementation detail and\n+/// shouldn't be relied upon.  Instead it should be stored as a FormatListRef:\n+///\n+///   FormatListRef formatList = makeFormatList( /*...*/ );\n+template<typename... Args>\n+detail::FormatListN<sizeof...(Args)> makeFormatList(const Args&... args)\n {\n-    detail::FormatIterator fmtIter(out, fmt);\n-    format(fmtIter, v1, args...);\n+    return detail::FormatListN<sizeof...(args)>(args...);\n }\n \n-template<typename T1, typename... Args>\n-std::string format(const char* fmt, const T1& v1, const Args&... args)\n+#else // C++98 version\n+\n+inline detail::FormatListN<0> makeFormatList()\n+{\n+    return detail::FormatListN<0>();\n+}\n+#define TINYFORMAT_MAKE_MAKEFORMATLIST(n)                     \\\n+template<TINYFORMAT_ARGTYPES(n)>                              \\\n+detail::FormatListN<n> makeFormatList(TINYFORMAT_VARARGS(n))  \\\n+{                                                             \\\n+    return detail::FormatListN<n>(TINYFORMAT_PASSARGS(n));    \\\n+}\n+TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_MAKEFORMATLIST)\n+#undef TINYFORMAT_MAKE_MAKEFORMATLIST\n+\n+#endif\n+\n+/// Format list of arguments to the stream according to the given format string.\n+///\n+/// The name vformat() is chosen for the semantic similarity to vprintf(): the\n+/// list of format arguments is held in a single function argument.\n+inline void vformat(std::ostream& out, const char* fmt, FormatListRef list)\n+{\n+    detail::formatImpl(out, fmt, list.m_formatters, list.m_N);\n+}\n+\n+\n+#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES\n+\n+/// Format list of arguments to the stream according to given format string.\n+template<typename... Args>\n+void format(std::ostream& out, const char* fmt, const Args&... args)\n+{\n+    vformat(out, fmt, makeFormatList(args...));\n+}\n+\n+/// Format list of arguments according to the given format string and return\n+/// the result as a string.\n+template<typename... Args>\n+std::string format(const char* fmt, const Args&... args)\n {\n     std::ostringstream oss;\n-    format(oss, fmt, v1, args...);\n+    format(oss, fmt, args...);\n     return oss.str();\n }\n \n-template<typename T1, typename... Args>\n-std::string format(const std::string &fmt, const T1& v1, const Args&... args)\n+/// Format list of arguments to std::cout, according to the given format string\n+template<typename... Args>\n+void printf(const char* fmt, const Args&... args)\n+{\n+    format(std::cout, fmt, args...);\n+}\n+\n+template<typename... Args>\n+void printfln(const char* fmt, const Args&... args)\n+{\n+    format(std::cout, fmt, args...);\n+    std::cout << '\\n';\n+}\n+\n+#else // C++98 version\n+\n+inline void format(std::ostream& out, const char* fmt)\n+{\n+    vformat(out, fmt, makeFormatList());\n+}\n+\n+inline std::string format(const char* fmt)\n {\n     std::ostringstream oss;\n-    format(oss, fmt.c_str(), v1, args...);\n+    format(oss, fmt);\n     return oss.str();\n }\n \n-template<typename T1, typename... Args>\n-void printf(const char* fmt, const T1& v1, const Args&... args)\n+inline void printf(const char* fmt)\n {\n-    format(std::cout, fmt, v1, args...);\n+    format(std::cout, fmt);\n }\n \n-#else\n+inline void printfln(const char* fmt)\n+{\n+    format(std::cout, fmt);\n+    std::cout << '\\n';\n+}\n \n-// C++98 - define the interface functions using the wrapping macros\n #define TINYFORMAT_MAKE_FORMAT_FUNCS(n)                                   \\\n                                                                           \\\n template<TINYFORMAT_ARGTYPES(n)>                                          \\\n void format(std::ostream& out, const char* fmt, TINYFORMAT_VARARGS(n))    \\\n {                                                                         \\\n-    tinyformat::detail::FormatIterator fmtIter(out, fmt);                 \\\n-    tinyformat::detail::format(fmtIter, TINYFORMAT_PASSARGS(n));          \\\n+    vformat(out, fmt, makeFormatList(TINYFORMAT_PASSARGS(n)));            \\\n }                                                                         \\\n                                                                           \\\n template<TINYFORMAT_ARGTYPES(n)>                                          \\\n std::string format(const char* fmt, TINYFORMAT_VARARGS(n))                \\\n {                                                                         \\\n     std::ostringstream oss;                                               \\\n-    tinyformat::format(oss, fmt, TINYFORMAT_PASSARGS(n));                 \\\n+    format(oss, fmt, TINYFORMAT_PASSARGS(n));                             \\\n     return oss.str();                                                     \\\n }                                                                         \\\n                                                                           \\\n template<TINYFORMAT_ARGTYPES(n)>                                          \\\n-std::string format(const std::string &fmt, TINYFORMAT_VARARGS(n))         \\\n+void printf(const char* fmt, TINYFORMAT_VARARGS(n))                       \\\n {                                                                         \\\n-    std::ostringstream oss;                                               \\\n-    tinyformat::format(oss, fmt.c_str(), TINYFORMAT_PASSARGS(n));         \\\n-    return oss.str();                                                     \\\n+    format(std::cout, fmt, TINYFORMAT_PASSARGS(n));                       \\\n }                                                                         \\\n                                                                           \\\n template<TINYFORMAT_ARGTYPES(n)>                                          \\\n-void printf(const char* fmt, TINYFORMAT_VARARGS(n))                       \\\n+void printfln(const char* fmt, TINYFORMAT_VARARGS(n))                     \\\n {                                                                         \\\n-    tinyformat::format(std::cout, fmt, TINYFORMAT_PASSARGS(n));           \\\n+    format(std::cout, fmt, TINYFORMAT_PASSARGS(n));                       \\\n+    std::cout << '\\n';                                                    \\\n }\n \n TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_FORMAT_FUNCS)\n #undef TINYFORMAT_MAKE_FORMAT_FUNCS\n-#endif\n-\n \n-//------------------------------------------------------------------------------\n-// Define deprecated wrapping macro for backward compatibility in tinyformat\n-// 1.x.  Will be removed in version 2!\n-#define TINYFORMAT_WRAP_FORMAT_EXTRA_ARGS\n-#define TINYFORMAT_WRAP_FORMAT_N(n, returnType, funcName, funcDeclSuffix,  \\\n-                                 bodyPrefix, streamName, bodySuffix)       \\\n-template<TINYFORMAT_ARGTYPES(n)>                                           \\\n-returnType funcName(TINYFORMAT_WRAP_FORMAT_EXTRA_ARGS const char* fmt,     \\\n-                    TINYFORMAT_VARARGS(n)) funcDeclSuffix                  \\\n-{                                                                          \\\n-    bodyPrefix                                                             \\\n-    tinyformat::format(streamName, fmt, TINYFORMAT_PASSARGS(n));           \\\n-    bodySuffix                                                             \\\n-}                                                                          \\\n-\n-#define TINYFORMAT_WRAP_FORMAT(returnType, funcName, funcDeclSuffix,       \\\n-                               bodyPrefix, streamName, bodySuffix)         \\\n-inline                                                                     \\\n-returnType funcName(TINYFORMAT_WRAP_FORMAT_EXTRA_ARGS const char* fmt      \\\n-                    ) funcDeclSuffix                                       \\\n-{                                                                          \\\n-    bodyPrefix                                                             \\\n-    tinyformat::detail::FormatIterator(streamName, fmt).finish();          \\\n-    bodySuffix                                                             \\\n-}                                                                          \\\n-TINYFORMAT_WRAP_FORMAT_N(1 , returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(2 , returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(3 , returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(4 , returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(5 , returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(6 , returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(7 , returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(8 , returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(9 , returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(10, returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(11, returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(12, returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(13, returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(14, returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(15, returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n-TINYFORMAT_WRAP_FORMAT_N(16, returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n+#endif\n \n+// Added for Bitcoin Core\n+template<typename... Args>\n+std::string format(const std::string &fmt, const Args&... args)\n+{\n+    std::ostringstream oss;\n+    format(oss, fmt.c_str(), args...);\n+    return oss.str();\n+}\n \n } // namespace tinyformat\n "
      },
      {
        "sha": "99c45d489cb2146c5f1e0a70ba88c03021c680e5",
        "filename": "src/torcontrol.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/torcontrol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/torcontrol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/torcontrol.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -4,6 +4,7 @@\n \n #include \"torcontrol.h\"\n #include \"utilstrencodings.h\"\n+#include \"netbase.h\"\n #include \"net.h\"\n #include \"util.h\"\n #include \"crypto/hmac_sha256.h\"\n@@ -437,8 +438,7 @@ void TorController::add_onion_cb(TorControlConnection& conn, const TorControlRep\n             if ((i = m.find(\"PrivateKey\")) != m.end())\n                 private_key = i->second;\n         }\n-\n-        service = CService(service_id+\".onion\", GetListenPort());\n+        service = LookupNumeric(std::string(service_id+\".onion\").c_str(), GetListenPort());\n         LogPrintf(\"tor: Got service ID %s, advertising service %s\\n\", service_id, service.ToString());\n         if (WriteBinaryFile(GetPrivateKeyFile(), private_key)) {\n             LogPrint(\"tor\", \"tor: Cached service private key to %s\\n\", GetPrivateKeyFile());\n@@ -462,7 +462,8 @@ void TorController::auth_cb(TorControlConnection& conn, const TorControlReply& r\n         // Now that we know Tor is running setup the proxy for onion addresses\n         // if -onion isn't set to something else.\n         if (GetArg(\"-onion\", \"\") == \"\") {\n-            proxyType addrOnion = proxyType(CService(\"127.0.0.1\", 9050), true);\n+            CService resolved(LookupNumeric(\"127.0.0.1\", 9050));\n+            proxyType addrOnion = proxyType(resolved, true);\n             SetProxy(NET_TOR, addrOnion);\n             SetLimited(NET_TOR, false);\n         }"
      },
      {
        "sha": "b631c48484891547148cd7959a5537bfdcd5e676",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 4,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -28,7 +28,7 @@ CTxMemPoolEntry::CTxMemPoolEntry(const CTransaction& _tx, const CAmount& _nFee,\n     hadNoDependencies(poolHasNoInputsOf), inChainInputValue(_inChainInputValue),\n     spendsCoinbase(_spendsCoinbase), sigOpCost(_sigOpsCost), lockPoints(lp)\n {\n-    nTxCost = GetTransactionCost(_tx);\n+    nTxWeight = GetTransactionWeight(_tx);\n     nModSize = _tx.CalculateModifiedSize(GetTxSize());\n     nUsageSize = RecursiveDynamicUsage(*tx) + memusage::DynamicUsage(tx);\n \n@@ -75,7 +75,7 @@ void CTxMemPoolEntry::UpdateLockPoints(const LockPoints& lp)\n \n size_t CTxMemPoolEntry::GetTxSize() const\n {\n-    return GetVirtualTransactionSize(nTxCost);\n+    return GetVirtualTransactionSize(nTxWeight, sigOpCost);\n }\n \n // Update the given tx for any in-mempool descendants.\n@@ -657,6 +657,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n     uint64_t innerUsage = 0;\n \n     CCoinsViewCache mempoolDuplicate(const_cast<CCoinsViewCache*>(pcoins));\n+    const int64_t nSpendHeight = GetSpendHeight(mempoolDuplicate);\n \n     LOCK(cs);\n     list<const CTxMemPoolEntry*> waitingOnDependants;\n@@ -737,7 +738,9 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n             waitingOnDependants.push_back(&(*it));\n         else {\n             CValidationState state;\n-            assert(CheckInputs(tx, state, mempoolDuplicate, false, 0, false, NULL));\n+            bool fCheckResult = tx.IsCoinBase() ||\n+                Consensus::CheckTxInputs(tx, state, mempoolDuplicate, nSpendHeight);\n+            assert(fCheckResult);\n             UpdateCoins(tx, mempoolDuplicate, 1000000);\n         }\n     }\n@@ -751,7 +754,9 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n             stepsSinceLastRemove++;\n             assert(stepsSinceLastRemove < waitingOnDependants.size());\n         } else {\n-            assert(CheckInputs(entry->GetTx(), state, mempoolDuplicate, false, 0, false, NULL));\n+            bool fCheckResult = entry->GetTx().IsCoinBase() ||\n+                Consensus::CheckTxInputs(entry->GetTx(), state, mempoolDuplicate, nSpendHeight);\n+            assert(fCheckResult);\n             UpdateCoins(entry->GetTx(), mempoolDuplicate, 1000000);\n             stepsSinceLastRemove = 0;\n         }"
      },
      {
        "sha": "2c2127f326de2cce875c5a4c3689dbb7f25d6b0c",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -78,7 +78,7 @@ class CTxMemPoolEntry\n private:\n     std::shared_ptr<const CTransaction> tx;\n     CAmount nFee;              //!< Cached to avoid expensive parent-transaction lookups\n-    size_t nTxCost;            //!< ... and avoid recomputing tx cost (also used for GetTxSize())\n+    size_t nTxWeight;          //!< ... and avoid recomputing tx weight (also used for GetTxSize())\n     size_t nModSize;           //!< ... and modified size for priority\n     size_t nUsageSize;         //!< ... and total memory usage\n     int64_t nTime;             //!< Local time when entering the mempool\n@@ -122,7 +122,7 @@ class CTxMemPoolEntry\n     double GetPriority(unsigned int currentHeight) const;\n     const CAmount& GetFee() const { return nFee; }\n     size_t GetTxSize() const;\n-    size_t GetTxCost() const { return nTxCost; }\n+    size_t GetTxWeight() const { return nTxWeight; }\n     int64_t GetTime() const { return nTime; }\n     unsigned int GetHeight() const { return entryHeight; }\n     bool WasClearAtEntry() const { return hadNoDependencies; }"
      },
      {
        "sha": "39328b51ef154c38df64dd7266e9c28039f34f1a",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 6,
        "deletions": 22,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -77,33 +77,17 @@ int LogPrintStr(const std::string &str);\n \n #define LogPrintf(...) LogPrint(NULL, __VA_ARGS__)\n \n-template<typename T1, typename... Args>\n-static inline int LogPrint(const char* category, const char* fmt, const T1& v1, const Args&... args)\n+template<typename... Args>\n+static inline int LogPrint(const char* category, const char* fmt, const Args&... args)\n {\n     if(!LogAcceptCategory(category)) return 0;                            \\\n-    return LogPrintStr(tfm::format(fmt, v1, args...));\n+    return LogPrintStr(tfm::format(fmt, args...));\n }\n \n-template<typename T1, typename... Args>\n-bool error(const char* fmt, const T1& v1, const Args&... args)\n+template<typename... Args>\n+bool error(const char* fmt, const Args&... args)\n {\n-    LogPrintStr(\"ERROR: \" + tfm::format(fmt, v1, args...) + \"\\n\");\n-    return false;\n-}\n-\n-/**\n- * Zero-arg versions of logging and error, these are not covered by\n- * the variadic templates above (and don't take format arguments but\n- * bare strings).\n- */\n-static inline int LogPrint(const char* category, const char* s)\n-{\n-    if(!LogAcceptCategory(category)) return 0;\n-    return LogPrintStr(s);\n-}\n-static inline bool error(const char* s)\n-{\n-    LogPrintStr(std::string(\"ERROR: \") + s + \"\\n\");\n+    LogPrintStr(\"ERROR: \" + tfm::format(fmt, args...) + \"\\n\");\n     return false;\n }\n "
      },
      {
        "sha": "cf1d6ca08699a39f250811e2feb8289a4a17f98e",
        "filename": "src/validationinterface.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/validationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/validationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -48,6 +48,6 @@ void UnregisterAllValidationInterfaces() {\n     g_signals.UpdatedBlockTip.disconnect_all_slots();\n }\n \n-void SyncWithWallets(const CTransaction &tx, const CBlockIndex *pindex, const CBlock *pblock) {\n-    g_signals.SyncTransaction(tx, pindex, pblock);\n+void SyncWithWallets(const CTransaction &tx, const CBlockIndex *pindex, int posInBlock) {\n+    g_signals.SyncTransaction(tx, pindex, posInBlock);\n }"
      },
      {
        "sha": "094b1cfe26672a41b0de27066e515a57fc9b4177",
        "filename": "src/validationinterface.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/validationinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/validationinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -28,12 +28,12 @@ void UnregisterValidationInterface(CValidationInterface* pwalletIn);\n /** Unregister all wallets from core */\n void UnregisterAllValidationInterfaces();\n /** Push an updated transaction to all registered wallets */\n-void SyncWithWallets(const CTransaction& tx, const CBlockIndex *pindex, const CBlock* pblock = NULL);\n+void SyncWithWallets(const CTransaction& tx, const CBlockIndex *pindex, int posInBlock = -1);\n \n class CValidationInterface {\n protected:\n     virtual void UpdatedBlockTip(const CBlockIndex *pindex) {}\n-    virtual void SyncTransaction(const CTransaction &tx, const CBlockIndex *pindex, const CBlock *pblock) {}\n+    virtual void SyncTransaction(const CTransaction &tx, const CBlockIndex *pindex, int posInBlock) {}\n     virtual void SetBestChain(const CBlockLocator &locator) {}\n     virtual void UpdatedTransaction(const uint256 &hash) {}\n     virtual void Inventory(const uint256 &hash) {}\n@@ -50,7 +50,7 @@ struct CMainSignals {\n     /** Notifies listeners of updated block chain tip */\n     boost::signals2::signal<void (const CBlockIndex *)> UpdatedBlockTip;\n     /** Notifies listeners of updated transaction data (transaction, and optionally the block it is found in. */\n-    boost::signals2::signal<void (const CTransaction &, const CBlockIndex *pindex, const CBlock *)> SyncTransaction;\n+    boost::signals2::signal<void (const CTransaction &, const CBlockIndex *pindex, int posInBlock)> SyncTransaction;\n     /** Notifies listeners of an updated transaction without new data (for now: a coinbase potentially becoming visible). */\n     boost::signals2::signal<void (const uint256 &)> UpdatedTransaction;\n     /** Notifies listeners of a new active block chain. */"
      },
      {
        "sha": "fe8b53ceb0c1af8de6d4d506ef613b8491790e48",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 5,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -309,8 +309,7 @@ UniValue importprunedfunds(const UniValue& params, bool fHelp)\n     LOCK2(cs_main, pwalletMain->cs_wallet);\n \n     if (pwalletMain->IsMine(tx)) {\n-        CWalletDB walletdb(pwalletMain->strWalletFile, \"r+\", false);\n-        pwalletMain->AddToWallet(wtx, false, &walletdb);\n+        pwalletMain->AddToWallet(wtx, false);\n         return NullUniValue;\n     }\n \n@@ -602,19 +601,42 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)\n     file << strprintf(\"# * Best block at time of backup was %i (%s),\\n\", chainActive.Height(), chainActive.Tip()->GetBlockHash().ToString());\n     file << strprintf(\"#   mined on %s\\n\", EncodeDumpTime(chainActive.Tip()->GetBlockTime()));\n     file << \"\\n\";\n+\n+    // add the base58check encoded extended master if the wallet uses HD \n+    CKeyID masterKeyID = pwalletMain->GetHDChain().masterKeyID;\n+    if (!masterKeyID.IsNull())\n+    {\n+        CKey key;\n+        if (pwalletMain->GetKey(masterKeyID, key))\n+        {\n+            CExtKey masterKey;\n+            masterKey.SetMaster(key.begin(), key.size());\n+\n+            CBitcoinExtKey b58extkey;\n+            b58extkey.SetKey(masterKey);\n+\n+            file << \"# extended private masterkey: \" << b58extkey.ToString() << \"\\n\\n\";\n+        }\n+    }\n     for (std::vector<std::pair<int64_t, CKeyID> >::const_iterator it = vKeyBirth.begin(); it != vKeyBirth.end(); it++) {\n         const CKeyID &keyid = it->second;\n         std::string strTime = EncodeDumpTime(it->first);\n         std::string strAddr = CBitcoinAddress(keyid).ToString();\n         CKey key;\n         if (pwalletMain->GetKey(keyid, key)) {\n+            file << strprintf(\"%s %s \", CBitcoinSecret(key).ToString(), strTime);\n             if (pwalletMain->mapAddressBook.count(keyid)) {\n-                file << strprintf(\"%s %s label=%s # addr=%s\\n\", CBitcoinSecret(key).ToString(), strTime, EncodeDumpString(pwalletMain->mapAddressBook[keyid].name), strAddr);\n+                file << strprintf(\"label=%s\", EncodeDumpString(pwalletMain->mapAddressBook[keyid].name));\n+            } else if (keyid == masterKeyID) {\n+                file << \"hdmaster=1\";\n             } else if (setKeyPool.count(keyid)) {\n-                file << strprintf(\"%s %s reserve=1 # addr=%s\\n\", CBitcoinSecret(key).ToString(), strTime, strAddr);\n+                file << \"reserve=1\";\n+            } else if (pwalletMain->mapKeyMetadata[keyid].hdKeypath == \"m\") {\n+                file << \"inactivehdmaster=1\";\n             } else {\n-                file << strprintf(\"%s %s change=1 # addr=%s\\n\", CBitcoinSecret(key).ToString(), strTime, strAddr);\n+                file << \"change=1\";\n             }\n+            file << strprintf(\" # addr=%s%s\\n\", strAddr, (pwalletMain->mapKeyMetadata[keyid].hdKeypath.size() > 0 ? \" hdkeypath=\"+pwalletMain->mapKeyMetadata[keyid].hdKeypath : \"\"));\n         }\n     }\n     file << \"\\n\";"
      },
      {
        "sha": "aa0a9374c19917d8692b258731f949cebeebfc1a",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 11,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -10,7 +10,6 @@\n #include \"init.h\"\n #include \"main.h\"\n #include \"net.h\"\n-#include \"netbase.h\"\n #include \"policy/rbf.h\"\n #include \"rpc/server.h\"\n #include \"timedata.h\"\n@@ -2081,7 +2080,7 @@ UniValue encryptwallet(const UniValue& params, bool fHelp)\n     // slack space in .dat files; that is bad if the old data is\n     // unencrypted private keys. So:\n     StartShutdown();\n-    return \"wallet encrypted; Bitcoin server stopping, restart to run with encrypted wallet. The keypool has been flushed, you need to make a new backup.\";\n+    return \"wallet encrypted; Bitcoin server stopping, restart to run with encrypted wallet. The keypool has been flushed and a new HD seed was generated (if you are using HD). You need to make a new backup.\";\n }\n \n UniValue lockunspent(const UniValue& params, bool fHelp)\n@@ -2260,15 +2259,16 @@ UniValue getwalletinfo(const UniValue& params, bool fHelp)\n             \"Returns an object containing various wallet state info.\\n\"\n             \"\\nResult:\\n\"\n             \"{\\n\"\n-            \"  \\\"walletversion\\\": xxxxx,     (numeric) the wallet version\\n\"\n-            \"  \\\"balance\\\": xxxxxxx,         (numeric) the total confirmed balance of the wallet in \" + CURRENCY_UNIT + \"\\n\"\n-            \"  \\\"unconfirmed_balance\\\": xxx, (numeric) the total unconfirmed balance of the wallet in \" + CURRENCY_UNIT + \"\\n\"\n-            \"  \\\"immature_balance\\\": xxxxxx, (numeric) the total immature balance of the wallet in \" + CURRENCY_UNIT + \"\\n\"\n-            \"  \\\"txcount\\\": xxxxxxx,         (numeric) the total number of transactions in the wallet\\n\"\n-            \"  \\\"keypoololdest\\\": xxxxxx,    (numeric) the timestamp (seconds since GMT epoch) of the oldest pre-generated key in the key pool\\n\"\n-            \"  \\\"keypoolsize\\\": xxxx,        (numeric) how many new keys are pre-generated\\n\"\n-            \"  \\\"unlocked_until\\\": ttt,      (numeric) the timestamp in seconds since epoch (midnight Jan 1 1970 GMT) that the wallet is unlocked for transfers, or 0 if the wallet is locked\\n\"\n-            \"  \\\"paytxfee\\\": x.xxxx,         (numeric) the transaction fee configuration, set in \" + CURRENCY_UNIT + \"/kB\\n\"\n+            \"  \\\"walletversion\\\": xxxxx,       (numeric) the wallet version\\n\"\n+            \"  \\\"balance\\\": xxxxxxx,           (numeric) the total confirmed balance of the wallet in \" + CURRENCY_UNIT + \"\\n\"\n+            \"  \\\"unconfirmed_balance\\\": xxx,   (numeric) the total unconfirmed balance of the wallet in \" + CURRENCY_UNIT + \"\\n\"\n+            \"  \\\"immature_balance\\\": xxxxxx,   (numeric) the total immature balance of the wallet in \" + CURRENCY_UNIT + \"\\n\"\n+            \"  \\\"txcount\\\": xxxxxxx,           (numeric) the total number of transactions in the wallet\\n\"\n+            \"  \\\"keypoololdest\\\": xxxxxx,      (numeric) the timestamp (seconds since GMT epoch) of the oldest pre-generated key in the key pool\\n\"\n+            \"  \\\"keypoolsize\\\": xxxx,          (numeric) how many new keys are pre-generated\\n\"\n+            \"  \\\"unlocked_until\\\": ttt,        (numeric) the timestamp in seconds since epoch (midnight Jan 1 1970 GMT) that the wallet is unlocked for transfers, or 0 if the wallet is locked\\n\"\n+            \"  \\\"paytxfee\\\": x.xxxx,           (numeric) the transaction fee configuration, set in \" + CURRENCY_UNIT + \"/kB\\n\"\n+            \"  \\\"hdmasterkeyid\\\": \\\"<hash160>\\\", (string) the Hash160 of the HD master pubkey\\n\"\n             \"}\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"getwalletinfo\", \"\")\n@@ -2288,6 +2288,9 @@ UniValue getwalletinfo(const UniValue& params, bool fHelp)\n     if (pwalletMain->IsCrypted())\n         obj.push_back(Pair(\"unlocked_until\", nWalletUnlockTime));\n     obj.push_back(Pair(\"paytxfee\",      ValueFromAmount(payTxFee.GetFeePerK())));\n+    CKeyID masterKeyID = pwalletMain->GetHDChain().masterKeyID;\n+    if (!masterKeyID.IsNull())\n+         obj.push_back(Pair(\"hdmasterkeyid\", masterKeyID.GetHex()));\n     return obj;\n }\n "
      },
      {
        "sha": "a6cada46a226c83d47d0db47e1828358bfd27efb",
        "filename": "src/wallet/test/accounting_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/wallet/test/accounting_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/wallet/test/accounting_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/accounting_tests.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -48,7 +48,7 @@ BOOST_AUTO_TEST_CASE(acc_orderupgrade)\n     pwalletMain->AddAccountingEntry(ae, walletdb);\n \n     wtx.mapValue[\"comment\"] = \"z\";\n-    pwalletMain->AddToWallet(wtx, false, &walletdb);\n+    pwalletMain->AddToWallet(wtx);\n     vpwtx.push_back(&pwalletMain->mapWallet[wtx.GetHash()]);\n     vpwtx[0]->nTimeReceived = (unsigned int)1333333335;\n     vpwtx[0]->nOrderPos = -1;\n@@ -90,7 +90,7 @@ BOOST_AUTO_TEST_CASE(acc_orderupgrade)\n         --tx.nLockTime;  // Just to change the hash :)\n         *static_cast<CTransaction*>(&wtx) = CTransaction(tx);\n     }\n-    pwalletMain->AddToWallet(wtx, false, &walletdb);\n+    pwalletMain->AddToWallet(wtx);\n     vpwtx.push_back(&pwalletMain->mapWallet[wtx.GetHash()]);\n     vpwtx[1]->nTimeReceived = (unsigned int)1333333336;\n \n@@ -100,7 +100,7 @@ BOOST_AUTO_TEST_CASE(acc_orderupgrade)\n         --tx.nLockTime;  // Just to change the hash :)\n         *static_cast<CTransaction*>(&wtx) = CTransaction(tx);\n     }\n-    pwalletMain->AddToWallet(wtx, false, &walletdb);\n+    pwalletMain->AddToWallet(wtx);\n     vpwtx.push_back(&pwalletMain->mapWallet[wtx.GetHash()]);\n     vpwtx[2]->nTimeReceived = (unsigned int)1333333329;\n     vpwtx[2]->nOrderPos = -1;"
      },
      {
        "sha": "05bb357257ec83b3d4230787e6bc5d423d0f758e",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 178,
        "deletions": 159,
        "changes": 337,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -126,6 +126,8 @@ CPubKey CWallet::GenerateNewKey()\n             // childIndex | BIP32_HARDENED_KEY_LIMIT = derive childIndex in hardened child-index-range\n             // example: 1 | BIP32_HARDENED_KEY_LIMIT == 0x80000001 == 2147483649\n             externalChainChildKey.Derive(childKey, hdChain.nExternalChainCounter | BIP32_HARDENED_KEY_LIMIT);\n+            metadata.hdKeypath     = \"m/0'/0'/\"+std::to_string(hdChain.nExternalChainCounter)+\"'\";\n+            metadata.hdMasterKeyID = hdChain.masterKeyID;\n             // increment childkey index\n             hdChain.nExternalChainCounter++;\n         } while(HaveKey(childKey.key.GetPubKey().GetID()));\n@@ -624,6 +626,15 @@ bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n \n         Lock();\n         Unlock(strWalletPassphrase);\n+\n+        // if we are using HD, replace the HD master key (seed) with a new one\n+        if (!hdChain.masterKeyID.IsNull()) {\n+            CKey key;\n+            CPubKey masterPubKey = GenerateNewHDMasterKey();\n+            if (!SetHDMasterKey(masterPubKey))\n+                return false;\n+        }\n+\n         NewKeyPool();\n         Lock();\n \n@@ -730,138 +741,143 @@ void CWallet::MarkDirty()\n     }\n }\n \n-bool CWallet::AddToWallet(const CWalletTx& wtxIn, bool fFromLoadWallet, CWalletDB* pwalletdb)\n+bool CWallet::AddToWallet(const CWalletTx& wtxIn, bool fFlushOnClose)\n {\n+    LOCK(cs_wallet);\n+\n+    CWalletDB walletdb(strWalletFile, \"r+\", fFlushOnClose);\n+\n     uint256 hash = wtxIn.GetHash();\n \n-    if (fFromLoadWallet)\n+    // Inserts only if not already there, returns tx inserted or tx found\n+    pair<map<uint256, CWalletTx>::iterator, bool> ret = mapWallet.insert(make_pair(hash, wtxIn));\n+    CWalletTx& wtx = (*ret.first).second;\n+    wtx.BindWallet(this);\n+    bool fInsertedNew = ret.second;\n+    if (fInsertedNew)\n     {\n-        mapWallet[hash] = wtxIn;\n-        CWalletTx& wtx = mapWallet[hash];\n-        wtx.BindWallet(this);\n+        wtx.nTimeReceived = GetAdjustedTime();\n+        wtx.nOrderPos = IncOrderPosNext(&walletdb);\n         wtxOrdered.insert(make_pair(wtx.nOrderPos, TxPair(&wtx, (CAccountingEntry*)0)));\n-        AddToSpends(hash);\n-        BOOST_FOREACH(const CTxIn& txin, wtx.vin) {\n-            if (mapWallet.count(txin.prevout.hash)) {\n-                CWalletTx& prevtx = mapWallet[txin.prevout.hash];\n-                if (prevtx.nIndex == -1 && !prevtx.hashUnset()) {\n-                    MarkConflicted(prevtx.hashBlock, wtx.GetHash());\n-                }\n-            }\n-        }\n-    }\n-    else\n-    {\n-        LOCK(cs_wallet);\n-        // Inserts only if not already there, returns tx inserted or tx found\n-        pair<map<uint256, CWalletTx>::iterator, bool> ret = mapWallet.insert(make_pair(hash, wtxIn));\n-        CWalletTx& wtx = (*ret.first).second;\n-        wtx.BindWallet(this);\n-        bool fInsertedNew = ret.second;\n-        if (fInsertedNew)\n-        {\n-            wtx.nTimeReceived = GetAdjustedTime();\n-            wtx.nOrderPos = IncOrderPosNext(pwalletdb);\n-            wtxOrdered.insert(make_pair(wtx.nOrderPos, TxPair(&wtx, (CAccountingEntry*)0)));\n-\n-            wtx.nTimeSmart = wtx.nTimeReceived;\n-            if (!wtxIn.hashUnset())\n+\n+        wtx.nTimeSmart = wtx.nTimeReceived;\n+        if (!wtxIn.hashUnset())\n+        {\n+            if (mapBlockIndex.count(wtxIn.hashBlock))\n             {\n-                if (mapBlockIndex.count(wtxIn.hashBlock))\n+                int64_t latestNow = wtx.nTimeReceived;\n+                int64_t latestEntry = 0;\n                 {\n-                    int64_t latestNow = wtx.nTimeReceived;\n-                    int64_t latestEntry = 0;\n+                    // Tolerate times up to the last timestamp in the wallet not more than 5 minutes into the future\n+                    int64_t latestTolerated = latestNow + 300;\n+                    const TxItems & txOrdered = wtxOrdered;\n+                    for (TxItems::const_reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n                     {\n-                        // Tolerate times up to the last timestamp in the wallet not more than 5 minutes into the future\n-                        int64_t latestTolerated = latestNow + 300;\n-                        const TxItems & txOrdered = wtxOrdered;\n-                        for (TxItems::const_reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n+                        CWalletTx *const pwtx = (*it).second.first;\n+                        if (pwtx == &wtx)\n+                            continue;\n+                        CAccountingEntry *const pacentry = (*it).second.second;\n+                        int64_t nSmartTime;\n+                        if (pwtx)\n                         {\n-                            CWalletTx *const pwtx = (*it).second.first;\n-                            if (pwtx == &wtx)\n-                                continue;\n-                            CAccountingEntry *const pacentry = (*it).second.second;\n-                            int64_t nSmartTime;\n-                            if (pwtx)\n-                            {\n-                                nSmartTime = pwtx->nTimeSmart;\n-                                if (!nSmartTime)\n-                                    nSmartTime = pwtx->nTimeReceived;\n-                            }\n-                            else\n-                                nSmartTime = pacentry->nTime;\n-                            if (nSmartTime <= latestTolerated)\n-                            {\n-                                latestEntry = nSmartTime;\n-                                if (nSmartTime > latestNow)\n-                                    latestNow = nSmartTime;\n-                                break;\n-                            }\n+                            nSmartTime = pwtx->nTimeSmart;\n+                            if (!nSmartTime)\n+                                nSmartTime = pwtx->nTimeReceived;\n+                        }\n+                        else\n+                            nSmartTime = pacentry->nTime;\n+                        if (nSmartTime <= latestTolerated)\n+                        {\n+                            latestEntry = nSmartTime;\n+                            if (nSmartTime > latestNow)\n+                                latestNow = nSmartTime;\n+                            break;\n                         }\n                     }\n-\n-                    int64_t blocktime = mapBlockIndex[wtxIn.hashBlock]->GetBlockTime();\n-                    wtx.nTimeSmart = std::max(latestEntry, std::min(blocktime, latestNow));\n                 }\n-                else\n-                    LogPrintf(\"AddToWallet(): found %s in block %s not in index\\n\",\n-                             wtxIn.GetHash().ToString(),\n-                             wtxIn.hashBlock.ToString());\n+\n+                int64_t blocktime = mapBlockIndex[wtxIn.hashBlock]->GetBlockTime();\n+                wtx.nTimeSmart = std::max(latestEntry, std::min(blocktime, latestNow));\n             }\n-            AddToSpends(hash);\n+            else\n+                LogPrintf(\"AddToWallet(): found %s in block %s not in index\\n\",\n+                         wtxIn.GetHash().ToString(),\n+                         wtxIn.hashBlock.ToString());\n         }\n+        AddToSpends(hash);\n+    }\n \n-        bool fUpdated = false;\n-        if (!fInsertedNew)\n+    bool fUpdated = false;\n+    if (!fInsertedNew)\n+    {\n+        // Merge\n+        if (!wtxIn.hashUnset() && wtxIn.hashBlock != wtx.hashBlock)\n         {\n-            // Merge\n-            if (!wtxIn.hashUnset() && wtxIn.hashBlock != wtx.hashBlock)\n-            {\n-                wtx.hashBlock = wtxIn.hashBlock;\n-                fUpdated = true;\n-            }\n-            // If no longer abandoned, update\n-            if (wtxIn.hashBlock.IsNull() && wtx.isAbandoned())\n-            {\n-                wtx.hashBlock = wtxIn.hashBlock;\n-                fUpdated = true;\n-            }\n-            if (wtxIn.nIndex != -1 && (wtxIn.nIndex != wtx.nIndex))\n-            {\n-                wtx.nIndex = wtxIn.nIndex;\n-                fUpdated = true;\n-            }\n-            if (wtxIn.fFromMe && wtxIn.fFromMe != wtx.fFromMe)\n-            {\n-                wtx.fFromMe = wtxIn.fFromMe;\n-                fUpdated = true;\n-            }\n+            wtx.hashBlock = wtxIn.hashBlock;\n+            fUpdated = true;\n         }\n+        // If no longer abandoned, update\n+        if (wtxIn.hashBlock.IsNull() && wtx.isAbandoned())\n+        {\n+            wtx.hashBlock = wtxIn.hashBlock;\n+            fUpdated = true;\n+        }\n+        if (wtxIn.nIndex != -1 && (wtxIn.nIndex != wtx.nIndex))\n+        {\n+            wtx.nIndex = wtxIn.nIndex;\n+            fUpdated = true;\n+        }\n+        if (wtxIn.fFromMe && wtxIn.fFromMe != wtx.fFromMe)\n+        {\n+            wtx.fFromMe = wtxIn.fFromMe;\n+            fUpdated = true;\n+        }\n+    }\n \n-        //// debug print\n-        LogPrintf(\"AddToWallet %s  %s%s\\n\", wtxIn.GetHash().ToString(), (fInsertedNew ? \"new\" : \"\"), (fUpdated ? \"update\" : \"\"));\n+    //// debug print\n+    LogPrintf(\"AddToWallet %s  %s%s\\n\", wtxIn.GetHash().ToString(), (fInsertedNew ? \"new\" : \"\"), (fUpdated ? \"update\" : \"\"));\n \n-        // Write to disk\n-        if (fInsertedNew || fUpdated)\n-            if (!pwalletdb->WriteTx(wtx))\n-                return false;\n+    // Write to disk\n+    if (fInsertedNew || fUpdated)\n+        if (!walletdb.WriteTx(wtx))\n+            return false;\n \n-        // Break debit/credit balance caches:\n-        wtx.MarkDirty();\n+    // Break debit/credit balance caches:\n+    wtx.MarkDirty();\n \n-        // Notify UI of new or updated transaction\n-        NotifyTransactionChanged(this, hash, fInsertedNew ? CT_NEW : CT_UPDATED);\n+    // Notify UI of new or updated transaction\n+    NotifyTransactionChanged(this, hash, fInsertedNew ? CT_NEW : CT_UPDATED);\n \n-        // notify an external script when a wallet transaction comes in or is updated\n-        std::string strCmd = GetArg(\"-walletnotify\", \"\");\n+    // notify an external script when a wallet transaction comes in or is updated\n+    std::string strCmd = GetArg(\"-walletnotify\", \"\");\n \n-        if ( !strCmd.empty())\n-        {\n-            boost::replace_all(strCmd, \"%s\", wtxIn.GetHash().GetHex());\n-            boost::thread t(runCommand, strCmd); // thread runs free\n-        }\n+    if ( !strCmd.empty())\n+    {\n+        boost::replace_all(strCmd, \"%s\", wtxIn.GetHash().GetHex());\n+        boost::thread t(runCommand, strCmd); // thread runs free\n+    }\n+\n+    return true;\n+}\n \n+bool CWallet::LoadToWallet(const CWalletTx& wtxIn)\n+{\n+    uint256 hash = wtxIn.GetHash();\n+\n+    mapWallet[hash] = wtxIn;\n+    CWalletTx& wtx = mapWallet[hash];\n+    wtx.BindWallet(this);\n+    wtxOrdered.insert(make_pair(wtx.nOrderPos, TxPair(&wtx, (CAccountingEntry*)0)));\n+    AddToSpends(hash);\n+    BOOST_FOREACH(const CTxIn& txin, wtx.vin) {\n+        if (mapWallet.count(txin.prevout.hash)) {\n+            CWalletTx& prevtx = mapWallet[txin.prevout.hash];\n+            if (prevtx.nIndex == -1 && !prevtx.hashUnset()) {\n+                MarkConflicted(prevtx.hashBlock, wtx.GetHash());\n+            }\n+        }\n     }\n+\n     return true;\n }\n \n@@ -870,18 +886,18 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn, bool fFromLoadWallet, CWalletD\n  * pblock is optional, but should be provided if the transaction is known to be in a block.\n  * If fUpdate is true, existing transactions will be updated.\n  */\n-bool CWallet::AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pblock, bool fUpdate)\n+bool CWallet::AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlockIndex* pIndex, int posInBlock, bool fUpdate)\n {\n     {\n         AssertLockHeld(cs_wallet);\n \n-        if (pblock) {\n+        if (posInBlock != -1) {\n             BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n                 std::pair<TxSpends::const_iterator, TxSpends::const_iterator> range = mapTxSpends.equal_range(txin.prevout);\n                 while (range.first != range.second) {\n                     if (range.first->second != tx.GetHash()) {\n-                        LogPrintf(\"Transaction %s (in block %s) conflicts with wallet transaction %s (both spend %s:%i)\\n\", tx.GetHash().ToString(), pblock->GetHash().ToString(), range.first->second.ToString(), range.first->first.hash.ToString(), range.first->first.n);\n-                        MarkConflicted(pblock->GetHash(), range.first->second);\n+                        LogPrintf(\"Transaction %s (in block %s) conflicts with wallet transaction %s (both spend %s:%i)\\n\", tx.GetHash().ToString(), pIndex->GetBlockHash().ToString(), range.first->second.ToString(), range.first->first.hash.ToString(), range.first->first.n);\n+                        MarkConflicted(pIndex->GetBlockHash(), range.first->second);\n                     }\n                     range.first++;\n                 }\n@@ -895,14 +911,10 @@ bool CWallet::AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pbl\n             CWalletTx wtx(this,tx);\n \n             // Get merkle branch if transaction was found in a block\n-            if (pblock)\n-                wtx.SetMerkleBranch(*pblock);\n-\n-            // Do not flush the wallet here for performance reasons\n-            // this is safe, as in case of a crash, we rescan the necessary blocks on startup through our SetBestChain-mechanism\n-            CWalletDB walletdb(strWalletFile, \"r+\", false);\n+            if (posInBlock != -1)\n+                wtx.SetMerkleBranch(pIndex, posInBlock);\n \n-            return AddToWallet(wtx, false, &walletdb);\n+            return AddToWallet(wtx, false);\n         }\n     }\n     return false;\n@@ -1025,11 +1037,11 @@ void CWallet::MarkConflicted(const uint256& hashBlock, const uint256& hashTx)\n     }\n }\n \n-void CWallet::SyncTransaction(const CTransaction& tx, const CBlockIndex *pindex, const CBlock* pblock)\n+void CWallet::SyncTransaction(const CTransaction& tx, const CBlockIndex *pindex, int posInBlock)\n {\n     LOCK2(cs_main, cs_wallet);\n \n-    if (!AddToWalletIfInvolvingMe(tx, pblock, true))\n+    if (!AddToWalletIfInvolvingMe(tx, pindex, posInBlock, true))\n         return; // Not one of ours\n \n     // If a transaction changes 'conflicted' state, that changes the balance\n@@ -1164,16 +1176,42 @@ CAmount CWallet::GetChange(const CTransaction& tx) const\n     return nChange;\n }\n \n-bool CWallet::SetHDMasterKey(const CKey& key)\n+CPubKey CWallet::GenerateNewHDMasterKey()\n {\n-    LOCK(cs_wallet);\n+    CKey key;\n+    key.MakeNewKey(true);\n \n-    // store the key as normal \"key\"/\"ckey\" object\n-    // in the database\n-    // key metadata is not required\n+    int64_t nCreationTime = GetTime();\n+    CKeyMetadata metadata(nCreationTime);\n+\n+    // calculate the pubkey\n     CPubKey pubkey = key.GetPubKey();\n-    if (!AddKeyPubKey(key, pubkey))\n-        throw std::runtime_error(\"CWallet::GenerateNewKey(): AddKey failed\");\n+    assert(key.VerifyPubKey(pubkey));\n+\n+    // set the hd keypath to \"m\" -> Master, refers the masterkeyid to itself\n+    metadata.hdKeypath     = \"m\";\n+    metadata.hdMasterKeyID = pubkey.GetID();\n+\n+    {\n+        LOCK(cs_wallet);\n+\n+        // mem store the metadata\n+        mapKeyMetadata[pubkey.GetID()] = metadata;\n+\n+        // write the key&metadata to the database\n+        if (!AddKeyPubKey(key, pubkey))\n+            throw std::runtime_error(\"CWallet::GenerateNewKey(): AddKey failed\");\n+    }\n+\n+    return pubkey;\n+}\n+\n+bool CWallet::SetHDMasterKey(const CPubKey& pubkey)\n+{\n+    LOCK(cs_wallet);\n+\n+    // ensure this wallet.dat can only be opened by clients supporting HD\n+    SetMinVersion(FEATURE_HD);\n \n     // store the keyid (hash160) together with\n     // the child index counter in the database\n@@ -1361,9 +1399,10 @@ int CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n \n             CBlock block;\n             ReadBlockFromDisk(block, pindex, Params().GetConsensus());\n-            BOOST_FOREACH(CTransaction& tx, block.vtx)\n+            int posInBlock;\n+            for (posInBlock = 0; posInBlock < (int)block.vtx.size(); posInBlock++)\n             {\n-                if (AddToWalletIfInvolvingMe(tx, &block, fUpdate))\n+                if (AddToWalletIfInvolvingMe(block.vtx[posInBlock], pindex, posInBlock, fUpdate))\n                     ret++;\n             }\n             pindex = chainActive.Next(pindex);\n@@ -2354,7 +2393,7 @@ bool CWallet::CreateTransaction(const vector<CRecipient>& vecSend, CWalletTx& wt\n                 *static_cast<CTransaction*>(&wtxNew) = CTransaction(txNew);\n \n                 // Limit size\n-                if (GetTransactionCost(txNew) >= MAX_STANDARD_TX_COST)\n+                if (GetTransactionWeight(txNew) >= MAX_STANDARD_TX_WEIGHT)\n                 {\n                     strFailReason = _(\"Transaction too large\");\n                     return false;\n@@ -2409,17 +2448,12 @@ bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n         LOCK2(cs_main, cs_wallet);\n         LogPrintf(\"CommitTransaction:\\n%s\", wtxNew.ToString());\n         {\n-            // This is only to keep the database open to defeat the auto-flush for the\n-            // duration of this scope.  This is the only place where this optimization\n-            // maybe makes sense; please don't do it anywhere else.\n-            CWalletDB* pwalletdb = fFileBacked ? new CWalletDB(strWalletFile,\"r+\") : NULL;\n-\n             // Take key pair from key pool so it won't be used again\n             reservekey.KeepKey();\n \n             // Add tx to wallet, because if it has change it's also ours,\n             // otherwise just for transaction history.\n-            AddToWallet(wtxNew, false, pwalletdb);\n+            AddToWallet(wtxNew);\n \n             // Notify that old coins are spent\n             set<CWalletTx*> setCoins;\n@@ -2429,9 +2463,6 @@ bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n                 coin.BindWallet(this);\n                 NotifyTransactionChanged(this, coin.GetHash(), CT_UPDATED);\n             }\n-\n-            if (fFileBacked)\n-                delete pwalletdb;\n         }\n \n         // Track how many getdata requests our transaction gets\n@@ -3102,7 +3133,7 @@ void CWallet::GetKeyBirthTimes(std::map<CKeyID, int64_t> &mapKeyBirth) const {\n             mapKeyBirth[it->first] = it->second.nCreateTime;\n \n     // map in which we'll infer heights of other keys\n-    CBlockIndex *pindexMax = chainActive[std::max(0, chainActive.Height() - 144)]; // the tip can be reorganised; use a 144-block safety margin\n+    CBlockIndex *pindexMax = chainActive[std::max(0, chainActive.Height() - 144)]; // the tip can be reorganized; use a 144-block safety margin\n     std::map<CKeyID, CBlockIndex*> mapKeyFirstBlock;\n     std::set<CKeyID> setKeys;\n     GetKeys(setKeys);\n@@ -3294,8 +3325,8 @@ bool CWallet::InitLoadWallet()\n         if (GetBoolArg(\"-usehd\", DEFAULT_USE_HD_WALLET) && walletInstance->hdChain.masterKeyID.IsNull()) {\n             // generate a new master key\n             CKey key;\n-            key.MakeNewKey(true);\n-            if (!walletInstance->SetHDMasterKey(key))\n+            CPubKey masterPubKey = walletInstance->GenerateNewHDMasterKey();\n+            if (!walletInstance->SetHDMasterKey(masterPubKey))\n                 throw std::runtime_error(\"CWallet::GenerateNewKey(): Storing master key failed\");\n         }\n         CPubKey newDefaultKey;\n@@ -3496,31 +3527,19 @@ CWalletKey::CWalletKey(int64_t nExpires)\n     nTimeExpires = nExpires;\n }\n \n-int CMerkleTx::SetMerkleBranch(const CBlock& block)\n+int CMerkleTx::SetMerkleBranch(const CBlockIndex* pindex, int posInBlock)\n {\n     AssertLockHeld(cs_main);\n     CBlock blockTmp;\n \n     // Update the tx's hashBlock\n-    hashBlock = block.GetHash();\n+    hashBlock = pindex->GetBlockHash();\n \n-    // Locate the transaction\n-    for (nIndex = 0; nIndex < (int)block.vtx.size(); nIndex++)\n-        if (block.vtx[nIndex] == *(CTransaction*)this)\n-            break;\n-    if (nIndex == (int)block.vtx.size())\n-    {\n-        nIndex = -1;\n-        LogPrintf(\"ERROR: SetMerkleBranch(): couldn't find tx in block\\n\");\n-        return 0;\n-    }\n+    // set the position of the transaction in the block\n+    nIndex = posInBlock;\n \n     // Is the tx in a block that's in the main chain\n-    BlockMap::iterator mi = mapBlockIndex.find(hashBlock);\n-    if (mi == mapBlockIndex.end())\n-        return 0;\n-    const CBlockIndex* pindex = (*mi).second;\n-    if (!pindex || !chainActive.Contains(pindex))\n+    if (!chainActive.Contains(pindex))\n         return 0;\n \n     return chainActive.Height() - pindex->nHeight + 1;"
      },
      {
        "sha": "952acd1535abf01b0a9658cd45f1e86ec6fe54b9",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 16,
        "deletions": 10,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -78,7 +78,8 @@ enum WalletFeature\n     FEATURE_WALLETCRYPT = 40000, // wallet encryption\n     FEATURE_COMPRPUBKEY = 60000, // compressed public keys\n \n-    FEATURE_LATEST = 60000\n+    FEATURE_HD = 130000, // Hierarchical key derivation after BIP32 (HD Wallet)\n+    FEATURE_LATEST = FEATURE_COMPRPUBKEY // HD is optional, use FEATURE_COMPRPUBKEY as latest version\n };\n \n \n@@ -199,7 +200,7 @@ class CMerkleTx : public CTransaction\n         READWRITE(nIndex);\n     }\n \n-    int SetMerkleBranch(const CBlock& block);\n+    int SetMerkleBranch(const CBlockIndex* pIndex, int posInBlock);\n \n     /**\n      * Return depth of transaction in blockchain:\n@@ -577,9 +578,10 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n \n     void SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator>);\n \n-    /* the hd chain data model (external chain counters) */\n+    /* the HD chain data model (external chain counters) */\n     CHDChain hdChain;\n \n+    bool fFileBacked;\n public:\n     /*\n      * Main wallet lock.\n@@ -590,7 +592,6 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n      */\n     mutable CCriticalSection cs_wallet;\n \n-    bool fFileBacked;\n     std::string strWalletFile;\n \n     std::set<int64_t> setKeyPool;\n@@ -728,9 +729,10 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     bool GetAccountPubkey(CPubKey &pubKey, std::string strAccount, bool bForceNew = false);\n \n     void MarkDirty();\n-    bool AddToWallet(const CWalletTx& wtxIn, bool fFromLoadWallet, CWalletDB* pwalletdb);\n-    void SyncTransaction(const CTransaction& tx, const CBlockIndex *pindex, const CBlock* pblock);\n-    bool AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pblock, bool fUpdate);\n+    bool AddToWallet(const CWalletTx& wtxIn, bool fFlushOnClose=true);\n+    bool LoadToWallet(const CWalletTx& wtxIn);\n+    void SyncTransaction(const CTransaction& tx, const CBlockIndex *pindex, int posInBlock);\n+    bool AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlockIndex* pIndex, int posInBlock, bool fUpdate);\n     int ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate = false);\n     void ReacceptWalletTransactions();\n     void ResendWalletTransactions(int64_t nBestBlockTime);\n@@ -896,11 +898,15 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n \n     bool BackupWallet(const std::string& strDest);\n \n-    /* Set the hd chain model (chain child index counters) */\n+    /* Set the HD chain model (chain child index counters) */\n     bool SetHDChain(const CHDChain& chain, bool memonly);\n+    const CHDChain& GetHDChain() { return hdChain; }\n \n-    /* Set the current hd master key (will reset the chain child index counters) */\n-    bool SetHDMasterKey(const CKey& key);\n+    /* Generates a new HD master key (will not be activated) */\n+    CPubKey GenerateNewHDMasterKey();\n+    \n+    /* Set the current HD master key (will reset the chain child index counters) */\n+    bool SetHDMasterKey(const CPubKey& key);\n };\n \n /** A key allocated from the key pool. */"
      },
      {
        "sha": "543522ca6485c111c3ed048bc42a9ca35fa2a07d",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -400,7 +400,7 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n             if (wtx.nOrderPos == -1)\n                 wss.fAnyUnordered = true;\n \n-            pwallet->AddToWallet(wtx, true, NULL);\n+            pwallet->LoadToWallet(wtx);\n         }\n         else if (strType == \"acentry\")\n         {"
      },
      {
        "sha": "5addd5c5c022590bf9a28fb73a23cdd393a307a7",
        "filename": "src/wallet/walletdb.h",
        "status": "modified",
        "additions": 14,
        "deletions": 3,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/wallet/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/wallet/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -41,7 +41,7 @@ enum DBErrors\n     DB_NEED_REWRITE\n };\n \n-/* simple hd chain data model */\n+/* simple HD chain data model */\n class CHDChain\n {\n public:\n@@ -73,17 +73,21 @@ class CHDChain\n class CKeyMetadata\n {\n public:\n-    static const int CURRENT_VERSION=1;\n+    static const int VERSION_BASIC=1;\n+    static const int VERSION_WITH_HDDATA=10;\n+    static const int CURRENT_VERSION=VERSION_WITH_HDDATA;\n     int nVersion;\n     int64_t nCreateTime; // 0 means unknown\n+    std::string hdKeypath; //optional HD/bip32 keypath\n+    CKeyID hdMasterKeyID; //id of the HD masterkey used to derive this key\n \n     CKeyMetadata()\n     {\n         SetNull();\n     }\n     CKeyMetadata(int64_t nCreateTime_)\n     {\n-        nVersion = CKeyMetadata::CURRENT_VERSION;\n+        SetNull();\n         nCreateTime = nCreateTime_;\n     }\n \n@@ -94,12 +98,19 @@ class CKeyMetadata\n         READWRITE(this->nVersion);\n         nVersion = this->nVersion;\n         READWRITE(nCreateTime);\n+        if (this->nVersion >= VERSION_WITH_HDDATA)\n+        {\n+            READWRITE(hdKeypath);\n+            READWRITE(hdMasterKeyID);\n+        }\n     }\n \n     void SetNull()\n     {\n         nVersion = CKeyMetadata::CURRENT_VERSION;\n         nCreateTime = 0;\n+        hdKeypath.clear();\n+        hdMasterKeyID.SetNull();\n     }\n };\n "
      },
      {
        "sha": "376e7dec590b560de960f143852ffa6bafa182da",
        "filename": "src/zmq/zmqnotificationinterface.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/zmq/zmqnotificationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/zmq/zmqnotificationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqnotificationinterface.cpp?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -141,7 +141,7 @@ void CZMQNotificationInterface::UpdatedBlockTip(const CBlockIndex *pindex)\n     }\n }\n \n-void CZMQNotificationInterface::SyncTransaction(const CTransaction& tx, const CBlockIndex* pindex, const CBlock* pblock)\n+void CZMQNotificationInterface::SyncTransaction(const CTransaction& tx, const CBlockIndex* pindex, int posInBlock)\n {\n     for (std::list<CZMQAbstractNotifier*>::iterator i = notifiers.begin(); i!=notifiers.end(); )\n     {"
      },
      {
        "sha": "a853447267f31126867c7144fd44eb71fa1b9e5c",
        "filename": "src/zmq/zmqnotificationinterface.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d70185724b9df301216c5bc8807af17c9eb6225f/src/zmq/zmqnotificationinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d70185724b9df301216c5bc8807af17c9eb6225f/src/zmq/zmqnotificationinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqnotificationinterface.h?ref=d70185724b9df301216c5bc8807af17c9eb6225f",
        "patch": "@@ -24,7 +24,7 @@ class CZMQNotificationInterface : public CValidationInterface\n     void Shutdown();\n \n     // CValidationInterface\n-    void SyncTransaction(const CTransaction& tx, const CBlockIndex *pindex, const CBlock* pblock);\n+    void SyncTransaction(const CTransaction& tx, const CBlockIndex *pindex, int posInBlock);\n     void UpdatedBlockTip(const CBlockIndex *pindex);\n \n private:"
      }
    ]
  },
  {
    "sha": "d9ce6c194963ad3755e52c80f6c1b7b2dca8dd7b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkOWNlNmMxOTQ5NjNhZDM3NTVlNTJjODBmNmMxYjdiMmRjYThkZDdi",
    "commit": {
      "author": {
        "name": "MCCCS",
        "email": "mcccs@users.noreply.github.com",
        "date": "2016-08-19T10:22:23Z"
      },
      "committer": {
        "name": "MCCCS",
        "email": "mcccs@users.noreply.github.com",
        "date": "2016-08-19T10:29:05Z"
      },
      "message": "Remove IP transaction check",
      "tree": {
        "sha": "6892bbec604152052d00a47f732bec971b5a5d66",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6892bbec604152052d00a47f732bec971b5a5d66"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d9ce6c194963ad3755e52c80f6c1b7b2dca8dd7b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d9ce6c194963ad3755e52c80f6c1b7b2dca8dd7b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d9ce6c194963ad3755e52c80f6c1b7b2dca8dd7b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d9ce6c194963ad3755e52c80f6c1b7b2dca8dd7b/comments",
    "author": {
      "login": "mcccs",
      "id": 43574227,
      "node_id": "MDQ6VXNlcjQzNTc0MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/43574227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mcccs",
      "html_url": "https://github.com/mcccs",
      "followers_url": "https://api.github.com/users/mcccs/followers",
      "following_url": "https://api.github.com/users/mcccs/following{/other_user}",
      "gists_url": "https://api.github.com/users/mcccs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mcccs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mcccs/subscriptions",
      "organizations_url": "https://api.github.com/users/mcccs/orgs",
      "repos_url": "https://api.github.com/users/mcccs/repos",
      "events_url": "https://api.github.com/users/mcccs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mcccs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mcccs",
      "id": 43574227,
      "node_id": "MDQ6VXNlcjQzNTc0MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/43574227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mcccs",
      "html_url": "https://github.com/mcccs",
      "followers_url": "https://api.github.com/users/mcccs/followers",
      "following_url": "https://api.github.com/users/mcccs/following{/other_user}",
      "gists_url": "https://api.github.com/users/mcccs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mcccs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mcccs/subscriptions",
      "organizations_url": "https://api.github.com/users/mcccs/orgs",
      "repos_url": "https://api.github.com/users/mcccs/repos",
      "events_url": "https://api.github.com/users/mcccs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mcccs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f4e777819c54fe0e386de517a201053698556236",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f4e777819c54fe0e386de517a201053698556236",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f4e777819c54fe0e386de517a201053698556236"
      }
    ],
    "stats": {
      "total": 48,
      "additions": 13,
      "deletions": 35
    },
    "files": [
      {
        "sha": "c5f2fae06122add8c0891eea757fc55d3daffe9a",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 35,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d9ce6c194963ad3755e52c80f6c1b7b2dca8dd7b/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d9ce6c194963ad3755e52c80f6c1b7b2dca8dd7b/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=d9ce6c194963ad3755e52c80f6c1b7b2dca8dd7b",
        "patch": "@@ -80,14 +80,8 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n     {\n         strHTML += \"<b>\" + tr(\"Source\") + \":</b> \" + tr(\"Generated\") + \"<br>\";\n     }\n-    else if (wtx.mapValue.count(\"from\") && !wtx.mapValue[\"from\"].empty())\n-    {\n-        // Online transaction\n-        strHTML += \"<b>\" + tr(\"From\") + \":</b> \" + GUIUtil::HtmlEscape(wtx.mapValue[\"from\"]) + \"<br>\";\n-    }\n     else\n     {\n-        // Offline transaction\n         if (nNet > 0)\n         {\n             // Credit\n@@ -110,20 +104,6 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n         }\n     }\n \n-    //\n-    // To\n-    //\n-    if (wtx.mapValue.count(\"to\") && !wtx.mapValue[\"to\"].empty())\n-    {\n-        // Online transaction\n-        std::string strAddress = wtx.mapValue[\"to\"];\n-        strHTML += \"<b>\" + tr(\"To\") + \":</b> \";\n-        CTxDestination dest = CBitcoinAddress(strAddress).Get();\n-        if (wallet->mapAddressBook.count(dest) && !wallet->mapAddressBook[dest].name.empty())\n-            strHTML += GUIUtil::HtmlEscape(wallet->mapAddressBook[dest].name) + \" \";\n-        strHTML += GUIUtil::HtmlEscape(strAddress) + \"<br>\";\n-    }\n-\n     //\n     // Amount\n     //\n@@ -180,22 +160,20 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n                 if ((toSelf == ISMINE_SPENDABLE) && (fAllFromMe == ISMINE_SPENDABLE))\n                     continue;\n \n-                if (!wtx.mapValue.count(\"to\") || wtx.mapValue[\"to\"].empty())\n+\n+                CTxDestination address;\n+                if (ExtractDestination(txout.scriptPubKey, address))\n                 {\n-                    // Offline transaction\n-                    CTxDestination address;\n-                    if (ExtractDestination(txout.scriptPubKey, address))\n-                    {\n-                        strHTML += \"<b>\" + tr(\"To\") + \":</b> \";\n-                        if (wallet->mapAddressBook.count(address) && !wallet->mapAddressBook[address].name.empty())\n-                            strHTML += GUIUtil::HtmlEscape(wallet->mapAddressBook[address].name) + \" \";\n-                        strHTML += GUIUtil::HtmlEscape(CBitcoinAddress(address).ToString());\n-                        if(toSelf == ISMINE_SPENDABLE)\n-                            strHTML += \" (own address)\";\n-                        else if(toSelf & ISMINE_WATCH_ONLY)\n-                            strHTML += \" (watch-only)\";\n-                        strHTML += \"<br>\";\n-                    }\n+                    strHTML += \"<b>\" + tr(\"To\") + \":</b> \";\n+                    if (wallet->mapAddressBook.count(address) && !wallet->mapAddressBook[address].name.empty())\n+                        strHTML += GUIUtil::HtmlEscape(wallet->mapAddressBook[address].name) + \" \";\n+                    strHTML += GUIUtil::HtmlEscape(CBitcoinAddress(address).ToString());\n+                    if(toSelf == ISMINE_SPENDABLE)\n+                        strHTML += \" (own address)\";\n+                    else if(toSelf & ISMINE_WATCH_ONLY)\n+                        strHTML += \" (watch-only)\";\n+                    strHTML += \"<br>\";\n+\n                 }\n \n                 strHTML += \"<b>\" + tr(\"Debit\") + \":</b> \" + BitcoinUnits::formatHtmlWithUnit(unit, -txout.nValue) + \"<br>\";"
      }
    ]
  },
  {
    "sha": "e853eac0bfd55c1b0519469054558fbed7027940",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplODUzZWFjMGJmZDU1YzFiMDUxOTQ2OTA1NDU1OGZiZWQ3MDI3OTQw",
    "commit": {
      "author": {
        "name": "MCCCS",
        "email": "mcccs@users.noreply.github.com",
        "date": "2016-08-19T10:29:21Z"
      },
      "committer": {
        "name": "MCCCS",
        "email": "mcccs@users.noreply.github.com",
        "date": "2016-08-19T10:29:21Z"
      },
      "message": "Merge remote-tracking branch 'origin/Ip-check' into Ip-check",
      "tree": {
        "sha": "6892bbec604152052d00a47f732bec971b5a5d66",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6892bbec604152052d00a47f732bec971b5a5d66"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e853eac0bfd55c1b0519469054558fbed7027940",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e853eac0bfd55c1b0519469054558fbed7027940",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e853eac0bfd55c1b0519469054558fbed7027940",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e853eac0bfd55c1b0519469054558fbed7027940/comments",
    "author": {
      "login": "mcccs",
      "id": 43574227,
      "node_id": "MDQ6VXNlcjQzNTc0MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/43574227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mcccs",
      "html_url": "https://github.com/mcccs",
      "followers_url": "https://api.github.com/users/mcccs/followers",
      "following_url": "https://api.github.com/users/mcccs/following{/other_user}",
      "gists_url": "https://api.github.com/users/mcccs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mcccs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mcccs/subscriptions",
      "organizations_url": "https://api.github.com/users/mcccs/orgs",
      "repos_url": "https://api.github.com/users/mcccs/repos",
      "events_url": "https://api.github.com/users/mcccs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mcccs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mcccs",
      "id": 43574227,
      "node_id": "MDQ6VXNlcjQzNTc0MjI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/43574227?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mcccs",
      "html_url": "https://github.com/mcccs",
      "followers_url": "https://api.github.com/users/mcccs/followers",
      "following_url": "https://api.github.com/users/mcccs/following{/other_user}",
      "gists_url": "https://api.github.com/users/mcccs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mcccs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mcccs/subscriptions",
      "organizations_url": "https://api.github.com/users/mcccs/orgs",
      "repos_url": "https://api.github.com/users/mcccs/repos",
      "events_url": "https://api.github.com/users/mcccs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mcccs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d9ce6c194963ad3755e52c80f6c1b7b2dca8dd7b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d9ce6c194963ad3755e52c80f6c1b7b2dca8dd7b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d9ce6c194963ad3755e52c80f6c1b7b2dca8dd7b"
      },
      {
        "sha": "d70185724b9df301216c5bc8807af17c9eb6225f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d70185724b9df301216c5bc8807af17c9eb6225f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d70185724b9df301216c5bc8807af17c9eb6225f"
      }
    ],
    "stats": {
      "total": 0,
      "additions": 0,
      "deletions": 0
    },
    "files": []
  }
]