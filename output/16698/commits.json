[
  {
    "sha": "9e9b185186b6de98d58f003e790f1d427a90b5ee",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZTliMTg1MTg2YjZkZTk4ZDU4ZjAwM2U3OTBmMWQ0MjdhOTBiNWVl",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2019-08-23T17:56:51Z"
      },
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2020-01-03T22:56:56Z"
      },
      "message": "[p2p] implement mempool rebroadcast functionality\n\nUpdate rebroadcast logic to live in the mempool & have two\nfundamental differences from the existing wallet logic:\n1. Apply to all transactions (not just mine)\n2. Rebroadcast txns expected to have been mined by now.\n\nThe main reasoning behind these changes are to improve privacy.",
      "tree": {
        "sha": "9baa6d9e228982446cdd3381f06b8efb7b3389fe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9baa6d9e228982446cdd3381f06b8efb7b3389fe"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9e9b185186b6de98d58f003e790f1d427a90b5ee",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e9b185186b6de98d58f003e790f1d427a90b5ee",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9e9b185186b6de98d58f003e790f1d427a90b5ee",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e9b185186b6de98d58f003e790f1d427a90b5ee/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "816464198c34a373229e865d76f4bc0ca8f127dc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/816464198c34a373229e865d76f4bc0ca8f127dc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/816464198c34a373229e865d76f4bc0ca8f127dc"
      }
    ],
    "stats": {
      "total": 62,
      "additions": 62,
      "deletions": 0
    },
    "files": [
      {
        "sha": "bb00009010ce8c06a521042c13786f4bcc2e133c",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e9b185186b6de98d58f003e790f1d427a90b5ee/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e9b185186b6de98d58f003e790f1d427a90b5ee/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=9e9b185186b6de98d58f003e790f1d427a90b5ee",
        "patch": "@@ -823,6 +823,9 @@ class CNode\n     // Used for headers announcements - unfiltered blocks to relay\n     std::vector<uint256> vBlockHashesToAnnounce GUARDED_BY(cs_inventory);\n \n+    // Used for scheduling rebroadcasts\n+    std::chrono::microseconds m_next_rebroadcast{0};\n+\n     // Block and TXN accept times\n     std::atomic<int64_t> nLastBlockTime{0};\n     std::atomic<int64_t> nLastTXTime{0};"
      },
      {
        "sha": "0146f00994f25685b45d8d9b5b5a897b50f75ec9",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e9b185186b6de98d58f003e790f1d427a90b5ee/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e9b185186b6de98d58f003e790f1d427a90b5ee/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=9e9b185186b6de98d58f003e790f1d427a90b5ee",
        "patch": "@@ -112,6 +112,8 @@ static constexpr unsigned int INVENTORY_BROADCAST_MAX = 7 * INVENTORY_BROADCAST_\n static constexpr unsigned int AVG_FEEFILTER_BROADCAST_INTERVAL = 10 * 60;\n /** Maximum feefilter broadcast delay after significant change. */\n static constexpr unsigned int MAX_FEEFILTER_CHANGE_DELAY = 5 * 60;\n+/** Average delay between rebroadcasts */\n+static const std::chrono::seconds TX_REBROADCAST_INTERVAL = std::chrono::seconds{60 * 60};\n \n // Internal stuff\n namespace {\n@@ -3787,6 +3789,30 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                     }\n                 }\n \n+                // use mockable current_time rather than nNow to allow for testing\n+                const std::chrono::microseconds current_time = GetTime<std::chrono::microseconds>();\n+\n+                // Check for rebroadcasts\n+                if (pto->m_next_rebroadcast < current_time) {\n+                    LogPrint(BCLog::NET, \"Rebroadcast timer triggered\\n\");\n+                    // schedule next rebroadcast\n+                    bool fFirst = (pto->m_next_rebroadcast.count() == 0);\n+                    pto->m_next_rebroadcast = PoissonNextSend(current_time, TX_REBROADCAST_INTERVAL);\n+\n+                    if (!fFirst) {\n+                        std::vector<uint256> rebroadcastTxs;\n+                        mempool.GetRebroadcastTransactions(rebroadcastTxs);\n+\n+                        for (const uint256& hash : rebroadcastTxs) {\n+                            LogPrint(BCLog::NET, \"Rebroadcast tx=%s peer=%d\\n\", hash.GetHex(), pto->GetId());\n+                        }\n+\n+                        // add rebroadcast txns\n+                        pto->m_tx_relay->setInventoryTxToSend.insert(rebroadcastTxs.begin(), rebroadcastTxs.end());\n+\n+                    }\n+                }\n+\n                 // Time to send but the peer has requested we not relay transactions.\n                 if (fSendTrickle) {\n                     LOCK(pto->m_tx_relay->cs_filter);"
      },
      {
        "sha": "cbd6c7030a6f3b510808dd68e428c6f6e5fb0e6a",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e9b185186b6de98d58f003e790f1d427a90b5ee/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e9b185186b6de98d58f003e790f1d427a90b5ee/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=9e9b185186b6de98d58f003e790f1d427a90b5ee",
        "patch": "@@ -5,9 +5,11 @@\n \n #include <txmempool.h>\n \n+#include <chainparams.h>\n #include <consensus/consensus.h>\n #include <consensus/tx_verify.h>\n #include <consensus/validation.h>\n+#include <miner.h>\n #include <optional.h>\n #include <validation.h>\n #include <policy/policy.h>\n@@ -99,6 +101,26 @@ void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendan\n     mapTx.modify(updateIt, update_descendant_state(modifySize, modifyFee, modifyCount));\n }\n \n+void CTxMemPool::GetRebroadcastTransactions(std::vector<uint256>& rebroadcastTxs)\n+{\n+    // Don't rebroadcast txns during importing, reindex, or IBD to ensure we don't\n+    // accidentally spam our peers with old transactions.\n+    if (::ChainstateActive().IsInitialBlockDownload() || ::fImporting || ::fReindex) return;\n+\n+    BlockAssembler::Options options;\n+    options.nBlockMaxWeight = MAX_REBROADCAST_WEIGHT;\n+    CScript dummy_script = CScript();\n+\n+    // use CreateNewBlock to get set of transaction candidates\n+    std::unique_ptr<CBlockTemplate> pblocktemplate = BlockAssembler(mempool, Params(), options).CreateNewBlock(dummy_script);\n+\n+    LOCK(cs);\n+    for (const CTransactionRef& tx : pblocktemplate->block.vtx) {\n+        // add to rebroadcast set\n+        rebroadcastTxs.push_back(tx->GetHash());\n+    }\n+}\n+\n // vHashesToUpdate is the set of transaction hashes from a disconnected block\n // which has been re-added to the mempool.\n // for each entry, look for descendants that are outside vHashesToUpdate, and"
      },
      {
        "sha": "27b4b36d4c3502d623c5848481f9f225b1994b50",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e9b185186b6de98d58f003e790f1d427a90b5ee/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e9b185186b6de98d58f003e790f1d427a90b5ee/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=9e9b185186b6de98d58f003e790f1d427a90b5ee",
        "patch": "@@ -15,6 +15,7 @@\n \n #include <amount.h>\n #include <coins.h>\n+#include <consensus/consensus.h>\n #include <crypto/siphash.h>\n #include <indirectmap.h>\n #include <optional.h>\n@@ -35,6 +36,10 @@ extern CCriticalSection cs_main;\n /** Fake height value used in Coin to signify they are only in the memory pool (since 0.8) */\n static const uint32_t MEMPOOL_HEIGHT = 0x7FFFFFFF;\n \n+// we rebroadcast 3/4 of max block weight to reduce noise due to circumstances\n+// such as miners mining priority txns\n+static const unsigned int MAX_REBROADCAST_WEIGHT = 0.75 * MAX_BLOCK_WEIGHT;\n+\n struct LockPoints\n {\n     // Will be set to the blockchain height and median time past\n@@ -615,6 +620,11 @@ class CTxMemPool\n      */\n     void RemoveStaged(setEntries& stage, bool updateDescendants, MemPoolRemovalReason reason) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n+    /** Use CreateNewBlock with specific rebroadcast parameters to identify a set\n+     * of transaction candidates & populate them in rebroadcastTxs.\n+     */\n+    void GetRebroadcastTransactions(std::vector<uint256>& rebroadcastTxs);\n+\n     /** When adding transactions from a disconnected block back to the mempool,\n      *  new mempool entries may have children in the mempool (which is generally\n      *  not the case when otherwise adding transactions)."
      },
      {
        "sha": "46b0d28bccafdc20ee107f4f9ae73eeaccb6111f",
        "filename": "test/lint/lint-circular-dependencies.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e9b185186b6de98d58f003e790f1d427a90b5ee/test/lint/lint-circular-dependencies.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e9b185186b6de98d58f003e790f1d427a90b5ee/test/lint/lint-circular-dependencies.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-circular-dependencies.sh?ref=9e9b185186b6de98d58f003e790f1d427a90b5ee",
        "patch": "@@ -26,6 +26,7 @@ EXPECTED_CIRCULAR_DEPENDENCIES=(\n     \"wallet/wallet -> wallet/walletdb -> wallet/wallet\"\n     \"policy/fees -> txmempool -> validation -> policy/fees\"\n     \"wallet/scriptpubkeyman -> wallet/wallet -> wallet/scriptpubkeyman\"\n+    \"miner -> txmempool -> miner\"\n )\n \n EXIT_CODE=0"
      }
    ]
  },
  {
    "sha": "0b2c36e6a3612411a77158221692a1eb72d35404",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowYjJjMzZlNmEzNjEyNDExYTc3MTU4MjIxNjkyYTFlYjcyZDM1NDA0",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2019-08-23T15:10:10Z"
      },
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2020-01-03T22:56:56Z"
      },
      "message": "[docs] updates to prioritisetransaction help man",
      "tree": {
        "sha": "dad01601ef030188c4cab61898438d8b0e24afeb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/dad01601ef030188c4cab61898438d8b0e24afeb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0b2c36e6a3612411a77158221692a1eb72d35404",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0b2c36e6a3612411a77158221692a1eb72d35404",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0b2c36e6a3612411a77158221692a1eb72d35404",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0b2c36e6a3612411a77158221692a1eb72d35404/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9e9b185186b6de98d58f003e790f1d427a90b5ee",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e9b185186b6de98d58f003e790f1d427a90b5ee",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9e9b185186b6de98d58f003e790f1d427a90b5ee"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 3,
      "deletions": 1
    },
    "files": [
      {
        "sha": "75406bba52e9a493f8c9b73f81a0d27f1e630d90",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0b2c36e6a3612411a77158221692a1eb72d35404/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0b2c36e6a3612411a77158221692a1eb72d35404/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=0b2c36e6a3612411a77158221692a1eb72d35404",
        "patch": "@@ -267,7 +267,9 @@ static UniValue getmininginfo(const JSONRPCRequest& request)\n static UniValue prioritisetransaction(const JSONRPCRequest& request)\n {\n             RPCHelpMan{\"prioritisetransaction\",\n-                \"Accepts the transaction into mined blocks at a higher (or lower) priority\\n\",\n+                \"Accepts the transaction into mined blocks at a higher (or lower) priority.\\n\"\n+                \"\\nNote that prioritizing a transaction could leak privacy, through both\\n\"\n+                \"block mining and likelihood of rebroadcast.\",\n                 {\n                     {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id.\"},\n                     {\"dummy\", RPCArg::Type::NUM, RPCArg::Optional::OMITTED_NAMED_ARG, \"API-Compatibility for previous API. Must be zero or null.\\n\""
      }
    ]
  },
  {
    "sha": "24ff7de788e77af3df6def7ffde7917dff3f88cc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNGZmN2RlNzg4ZTc3YWYzZGY2ZGVmN2ZmZGU3OTE3ZGZmM2Y4OGNj",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2019-08-23T15:11:14Z"
      },
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2020-01-03T22:56:56Z"
      },
      "message": "[mining] add recency filter on block creation to get rebroadcast set\n\nTo reduce noise, apply a filter to ensure recent txns are not rebroadcast",
      "tree": {
        "sha": "45174224fbf94c67bf49f872ffbf6388e5a0e19c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/45174224fbf94c67bf49f872ffbf6388e5a0e19c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/24ff7de788e77af3df6def7ffde7917dff3f88cc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/24ff7de788e77af3df6def7ffde7917dff3f88cc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/24ff7de788e77af3df6def7ffde7917dff3f88cc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/24ff7de788e77af3df6def7ffde7917dff3f88cc/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0b2c36e6a3612411a77158221692a1eb72d35404",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0b2c36e6a3612411a77158221692a1eb72d35404",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0b2c36e6a3612411a77158221692a1eb72d35404"
      }
    ],
    "stats": {
      "total": 17,
      "additions": 16,
      "deletions": 1
    },
    "files": [
      {
        "sha": "b42ddbe3bf3a4a2b6253813735daf50ce35c2b01",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/24ff7de788e77af3df6def7ffde7917dff3f88cc/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/24ff7de788e77af3df6def7ffde7917dff3f88cc/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=24ff7de788e77af3df6def7ffde7917dff3f88cc",
        "patch": "@@ -43,6 +43,7 @@ int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParam\n BlockAssembler::Options::Options() {\n     blockMinFeeRate = CFeeRate(DEFAULT_BLOCK_MIN_TX_FEE);\n     nBlockMaxWeight = DEFAULT_BLOCK_MAX_WEIGHT;\n+    m_skip_inclusion_until = std::chrono::seconds::max();\n }\n \n BlockAssembler::BlockAssembler(const CTxMemPool& mempool, const CChainParams& params, const Options& options)\n@@ -52,6 +53,7 @@ BlockAssembler::BlockAssembler(const CTxMemPool& mempool, const CChainParams& pa\n     blockMinFeeRate = options.blockMinFeeRate;\n     // Limit weight to between 4K and MAX_BLOCK_WEIGHT-4K for sanity:\n     nBlockMaxWeight = std::max<size_t>(4000, std::min<size_t>(MAX_BLOCK_WEIGHT - 4000, options.nBlockMaxWeight));\n+    m_skip_inclusion_until = options.m_skip_inclusion_until;\n }\n \n static BlockAssembler::Options DefaultOptions()\n@@ -66,6 +68,8 @@ static BlockAssembler::Options DefaultOptions()\n     } else {\n         options.blockMinFeeRate = CFeeRate(DEFAULT_BLOCK_MIN_TX_FEE);\n     }\n+    options.m_skip_inclusion_until = std::chrono::seconds::max();\n+\n     return options;\n }\n \n@@ -269,9 +273,12 @@ int BlockAssembler::UpdatePackagesForAdded(const CTxMemPool::setEntries& already\n // guaranteed to fail again, but as a belt-and-suspenders check we put it in\n // failedTx and avoid re-evaluation, since the re-evaluation would be using\n // cached size/sigops/fee values that are not actually correct.\n+// The default case will not skip any transactions for being too recent, but\n+// the time filter is used for identifying transactions to rebroadcast.\n bool BlockAssembler::SkipMapTxEntry(CTxMemPool::txiter it, indexed_modified_transaction_set &mapModifiedTx, CTxMemPool::setEntries &failedTx)\n {\n     assert(it != m_mempool.mapTx.end());\n+    if (it->GetTime() > m_skip_inclusion_until) return true; // txn too recent\n     return mapModifiedTx.count(it) || inBlock.count(it) || failedTx.count(it);\n }\n "
      },
      {
        "sha": "c4972082af08813e451eb248eebdcec3e6cadf3a",
        "filename": "src/miner.h",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/24ff7de788e77af3df6def7ffde7917dff3f88cc/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/24ff7de788e77af3df6def7ffde7917dff3f88cc/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=24ff7de788e77af3df6def7ffde7917dff3f88cc",
        "patch": "@@ -135,6 +135,7 @@ class BlockAssembler\n     bool fIncludeWitness;\n     unsigned int nBlockMaxWeight;\n     CFeeRate blockMinFeeRate;\n+    std::chrono::seconds m_skip_inclusion_until;\n \n     // Information on the current status of the block\n     uint64_t nBlockWeight;\n@@ -154,6 +155,7 @@ class BlockAssembler\n         Options();\n         size_t nBlockMaxWeight;\n         CFeeRate blockMinFeeRate;\n+        std::chrono::seconds m_skip_inclusion_until;\n     };\n \n     explicit BlockAssembler(const CTxMemPool& mempool, const CChainParams& params);\n@@ -189,7 +191,9 @@ class BlockAssembler\n       * only as an extra check in case of suboptimal node configuration */\n     bool TestPackageTransactions(const CTxMemPool::setEntries& package);\n     /** Return true if given transaction from mapTx has already been evaluated,\n-      * or if the transaction's cached data in mapTx is incorrect. */\n+      * or if the transaction's cached data in mapTx is incorrect.\n+      * If m_skip_inclusion_until is set in the options, we will skip transactions\n+      * until they meet that age. This is currently used for rebroadcast logic. */\n     bool SkipMapTxEntry(CTxMemPool::txiter it, indexed_modified_transaction_set& mapModifiedTx, CTxMemPool::setEntries& failedTx) EXCLUSIVE_LOCKS_REQUIRED(m_mempool.cs);\n     /** Sort the package in an order that is valid to appear in a block */\n     void SortForBlock(const CTxMemPool::setEntries& package, std::vector<CTxMemPool::txiter>& sortedEntries);"
      },
      {
        "sha": "0ce88c4b1d754d8609f612ce40eeaf2cb19850da",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/24ff7de788e77af3df6def7ffde7917dff3f88cc/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/24ff7de788e77af3df6def7ffde7917dff3f88cc/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=24ff7de788e77af3df6def7ffde7917dff3f88cc",
        "patch": "@@ -109,6 +109,7 @@ void CTxMemPool::GetRebroadcastTransactions(std::vector<uint256>& rebroadcastTxs\n \n     BlockAssembler::Options options;\n     options.nBlockMaxWeight = MAX_REBROADCAST_WEIGHT;\n+    options.m_skip_inclusion_until = std::chrono::seconds(GetTime()) - REBROADCAST_MIN_TX_AGE;\n     CScript dummy_script = CScript();\n \n     // use CreateNewBlock to get set of transaction candidates"
      },
      {
        "sha": "ed93fc8cc4c4ce59608f9f73aced3bba29417981",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/24ff7de788e77af3df6def7ffde7917dff3f88cc/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/24ff7de788e77af3df6def7ffde7917dff3f88cc/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=24ff7de788e77af3df6def7ffde7917dff3f88cc",
        "patch": "@@ -36,6 +36,9 @@ extern CCriticalSection cs_main;\n /** Fake height value used in Coin to signify they are only in the memory pool (since 0.8) */\n static const uint32_t MEMPOOL_HEIGHT = 0x7FFFFFFF;\n \n+// Default minimum age for a txn to be rebroadcast in seconds - 30 min\n+static const std::chrono::seconds REBROADCAST_MIN_TX_AGE = std::chrono::seconds{30 * 60};\n+\n // we rebroadcast 3/4 of max block weight to reduce noise due to circumstances\n // such as miners mining priority txns\n static const unsigned int MAX_REBROADCAST_WEIGHT = 0.75 * MAX_BLOCK_WEIGHT;"
      }
    ]
  },
  {
    "sha": "d3154f11604dbaf018b123a69155674eaf316fcb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMzE1NGYxMTYwNGRiYWYwMThiMTIzYTY5MTU1Njc0ZWFmMzE2ZmNi",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2019-08-23T15:09:48Z"
      },
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2020-01-03T22:56:56Z"
      },
      "message": "[test] Test rebroadcast functionality\n\nAdd functional tests to ensure that rebroadcast behavior works\nas expected, namely that only txns at the top of the mempool\n(according to block assembler logic) are rebroadcast, and txns\nthat are recent are excluded from the set.",
      "tree": {
        "sha": "2c7b670f496c5c6a7a95d5bf8297a039d26d3b73",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2c7b670f496c5c6a7a95d5bf8297a039d26d3b73"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d3154f11604dbaf018b123a69155674eaf316fcb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d3154f11604dbaf018b123a69155674eaf316fcb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d3154f11604dbaf018b123a69155674eaf316fcb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d3154f11604dbaf018b123a69155674eaf316fcb/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "24ff7de788e77af3df6def7ffde7917dff3f88cc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/24ff7de788e77af3df6def7ffde7917dff3f88cc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/24ff7de788e77af3df6def7ffde7917dff3f88cc"
      }
    ],
    "stats": {
      "total": 225,
      "additions": 225,
      "deletions": 0
    },
    "files": [
      {
        "sha": "285a5535c1c2715fcb96b63b9baecfbaf53fc634",
        "filename": "test/functional/mempool_rebroadcast.py",
        "status": "added",
        "additions": 208,
        "deletions": 0,
        "changes": 208,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d3154f11604dbaf018b123a69155674eaf316fcb/test/functional/mempool_rebroadcast.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d3154f11604dbaf018b123a69155674eaf316fcb/test/functional/mempool_rebroadcast.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_rebroadcast.py?ref=d3154f11604dbaf018b123a69155674eaf316fcb",
        "patch": "@@ -0,0 +1,208 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2009-2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test mempool rebroadcast logic.\n+\n+\"\"\"\n+\n+from test_framework.mininode import P2PTxInvStore\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+        assert_equal,\n+        assert_greater_than,\n+        wait_until,\n+        disconnect_nodes,\n+        connect_nodes,\n+        gen_return_txouts,\n+        create_confirmed_utxos,\n+        create_lots_of_big_transactions,\n+)\n+import time\n+\n+# Constant from txmempool.h\n+MAX_REBROADCAST_WEIGHT = 3000000\n+\n+class MempoolRebroadcastTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\n+            \"-acceptnonstdtxn=1\",\n+            \"-blockmaxweight=3000000\",\n+            \"-whitelist=127.0.0.1\"\n+            ]] * self.num_nodes\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_simple_rebroadcast()\n+        self.test_rebroadcast_top_txns()\n+        self.test_recency_filter()\n+\n+    # helper method that uses getblocktemplate with node arg\n+    # set to MAX_REBROADCAST_WEIGHT to find txns expected to\n+    # be rebroadcast\n+    def find_top_txns(self, node):\n+        tmpl = node.getblocktemplate({'rules': ['segwit']})\n+\n+        tx_hshs = []\n+        for tx in tmpl['transactions']:\n+            tx_hshs.append(tx['hash'])\n+\n+        return tx_hshs\n+\n+    def compare_txns_to_invs(self, txn_hshs, invs):\n+        tx_ids = [int(txhsh, 16) for txhsh in txn_hshs]\n+\n+        assert_equal(len(tx_ids), len(invs))\n+        assert_equal(tx_ids.sort(), invs.sort())\n+\n+    def test_simple_rebroadcast(self):\n+        self.log.info(\"Test simplest rebroadcast case\")\n+\n+        node0 = self.nodes[0]\n+        node1 = self.nodes[1]\n+\n+        # generate mempool transactions that both nodes know about\n+        for _ in range(3):\n+            node0.sendtoaddress(node1.getnewaddress(), 4)\n+\n+        self.sync_all()\n+\n+        # generate mempool transactions that only node0 knows about\n+        disconnect_nodes(node0, 1)\n+\n+        for _ in range(3):\n+            node0.sendtoaddress(node1.getnewaddress(), 5)\n+\n+        # check that mempools are different\n+        assert_equal(len(node0.getrawmempool()), 6)\n+        assert_equal(len(node1.getrawmempool()), 3)\n+\n+        # reconnect the nodes\n+        connect_nodes(node0, 1)\n+\n+        # rebroadcast will only occur if there has been a block since the\n+        # last run of CacheMinRebroadcastFee. when we connect a new peer, rebroadcast\n+        # will be skipped on the first run, but caching will trigger.\n+        # have node1 generate so there are still mempool txns that need to be synched.\n+        node1.generate(1)\n+\n+        assert_equal(len(node1.getrawmempool()), 0)\n+        wait_until(lambda: len(node0.getrawmempool()) == 3)\n+\n+        # bump time to hit rebroadcast interval\n+        mocktime = int(time.time()) + 300 * 60\n+        node0.setmocktime(mocktime)\n+        node1.setmocktime(mocktime)\n+\n+        # check that node1 got txns bc rebroadcasting\n+        wait_until(lambda: len(node1.getrawmempool()) == 3, timeout=30)\n+\n+    def test_rebroadcast_top_txns(self):\n+        self.log.info(\"Testing that only txns with top fee rate get rebroadcast\")\n+\n+        node = self.nodes[0]\n+        node.setmocktime(0)\n+\n+        # mine a block to clear out the mempool\n+        node.generate(1)\n+        assert_equal(len(node.getrawmempool()), 0)\n+\n+        conn1 = node.add_p2p_connection(P2PTxInvStore())\n+\n+        # create txns\n+        min_relay_fee = node.getnetworkinfo()[\"relayfee\"]\n+        txouts = gen_return_txouts()\n+        utxo_count = 90\n+        utxos = create_confirmed_utxos(min_relay_fee, node, utxo_count)\n+        base_fee = min_relay_fee*100 # our transactions are smaller than 100kb\n+        txids = []\n+\n+        # Create 3 batches of transactions at 3 different fee rate levels\n+        range_size = utxo_count // 3\n+\n+        for i in range(3):\n+            start_range = i * range_size\n+            end_range = start_range + range_size\n+            txids.append(create_lots_of_big_transactions(node, txouts, utxos[start_range:end_range], end_range - start_range, (i+1)*base_fee))\n+\n+        # 90 transactions should be created\n+        # confirm the invs were sent (initial broadcast)\n+        assert_equal(len(node.getrawmempool()), 90)\n+        wait_until(lambda: len(conn1.tx_invs_received) == 90)\n+\n+        # confirm txns are more than max rebroadcast amount\n+        assert_greater_than(node.getmempoolinfo()['bytes'], MAX_REBROADCAST_WEIGHT)\n+\n+        # age txns to ensure they won't be excluded due to recency filter\n+        mocktime = int(time.time()) + 31 * 60\n+        node.setmocktime(mocktime)\n+\n+        # add another p2p connection since txns aren't rebroadcast to the same peer (see filterInventoryKnown)\n+        conn2 = node.add_p2p_connection(P2PTxInvStore())\n+\n+        # trigger rebroadcast to occur\n+        mocktime += 300 * 60 # seconds\n+        node.setmocktime(mocktime)\n+        time.sleep(1) # ensure send message thread runs so invs get sent\n+\n+        # `nNextInvSend` delay on `setInventoryTxToSend\n+        wait_until(lambda: conn2.get_invs(), timeout=30)\n+\n+        global global_mocktime\n+        global_mocktime = mocktime\n+\n+    def test_recency_filter(self):\n+        self.log.info(\"Test recent txns don't get rebroadcast\")\n+\n+        node = self.nodes[0]\n+        node1 = self.nodes[1]\n+\n+        node.setmocktime(0)\n+\n+        # mine blocks to clear out the mempool\n+        node.generate(10)\n+        assert_equal(len(node.getrawmempool()), 0)\n+\n+        # add p2p connection\n+        conn = node.add_p2p_connection(P2PTxInvStore())\n+\n+        # create old txn\n+        node.sendtoaddress(node.getnewaddress(), 2)\n+        assert_equal(len(node.getrawmempool()), 1)\n+        wait_until(lambda: conn.get_invs(), timeout=30)\n+\n+        # bump mocktime to ensure the txn is old\n+        mocktime = int(time.time()) + 31 * 60 # seconds\n+        node.setmocktime(mocktime)\n+\n+        delta_time = 28 * 60 # seconds\n+        while True:\n+            # create a recent transaction\n+            new_tx = node1.sendtoaddress(node1.getnewaddress(), 2)\n+            new_tx_id = int(new_tx, 16)\n+\n+            # ensure node0 has the transaction\n+            wait_until(lambda: new_tx in node.getrawmempool())\n+\n+            # add another p2p connection since txns aren't rebroadcast\n+            # to the same peer (see filterInventoryKnown)\n+            new_conn = node.add_p2p_connection(P2PTxInvStore())\n+\n+            # bump mocktime to try to get rebroadcast,\n+            # but not so much that the txn would be old\n+            mocktime += delta_time\n+            node.setmocktime(mocktime)\n+\n+            time.sleep(1.1)\n+\n+            # once we get any rebroadcasts, ensure the most recent txn is not included\n+            if new_conn.get_invs():\n+                assert(new_tx_id not in new_conn.get_invs())\n+                break\n+\n+if __name__ == '__main__':\n+    MempoolRebroadcastTest().main()\n+"
      },
      {
        "sha": "205ed07d3949aeea47b7796d8d31f2dd7b5fb8e1",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d3154f11604dbaf018b123a69155674eaf316fcb/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d3154f11604dbaf018b123a69155674eaf316fcb/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=d3154f11604dbaf018b123a69155674eaf316fcb",
        "patch": "@@ -606,3 +606,19 @@ def send_txs_and_test(self, txs, node, *, success=True, expect_disconnect=False,\n                 # Check that none of the txs are now in the mempool\n                 for tx in txs:\n                     assert tx.hash not in raw_mempool, \"{} tx found in mempool\".format(tx.hash)\n+\n+class P2PTxInvStore(P2PInterface):\n+    def __init__(self):\n+        super().__init__()\n+        self.tx_invs_received = defaultdict(int)\n+\n+    def on_inv(self, message):\n+        # Store how many times invs have been received for each tx.\n+        for i in message.inv:\n+            if i.type == 1:\n+                # save txid\n+                self.tx_invs_received[i.hash] += 1\n+\n+    def get_invs(self):\n+        with mininode_lock:\n+            return list(self.tx_invs_received.keys())"
      },
      {
        "sha": "f4b5791041e2e21f063fcc298397679342db0b49",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d3154f11604dbaf018b123a69155674eaf316fcb/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d3154f11604dbaf018b123a69155674eaf316fcb/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=d3154f11604dbaf018b123a69155674eaf316fcb",
        "patch": "@@ -108,6 +108,7 @@\n     'p2p_feefilter.py',\n     'feature_reindex.py',\n     'feature_abortnode.py',\n+    'mempool_rebroadcast.py',\n     # vv Tests less than 30s vv\n     'wallet_keypool_topup.py',\n     'feature_fee_estimation.py',"
      }
    ]
  },
  {
    "sha": "baf7de22108eb9081ddc700067b72409efbc382e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiYWY3ZGUyMjEwOGViOTA4MWRkYzcwMDA2N2I3MjQwOWVmYmMzODJl",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2019-08-23T15:13:15Z"
      },
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2020-01-03T22:56:56Z"
      },
      "message": "[wallet] update wallet to resubmit to node rather than rebroadcast\n\nWith the new functionality added to the mempool, the wallet\nno longer needs to rebroadcast transactions to peers directly.\nInstead, it resubmits txns to the nodes once a day in case they\nwere dropped (expired, evicted, etc.) from the local mempool\nbefore being confirmed.\n\nRename `ResendWalletTransactions` method to\n`ResubmitWalletTransactionsToMempool` for clarity.",
      "tree": {
        "sha": "c37a4265a29561285626c69b7a8f056aa4c32759",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c37a4265a29561285626c69b7a8f056aa4c32759"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/baf7de22108eb9081ddc700067b72409efbc382e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/baf7de22108eb9081ddc700067b72409efbc382e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/baf7de22108eb9081ddc700067b72409efbc382e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/baf7de22108eb9081ddc700067b72409efbc382e/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d3154f11604dbaf018b123a69155674eaf316fcb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d3154f11604dbaf018b123a69155674eaf316fcb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d3154f11604dbaf018b123a69155674eaf316fcb"
      }
    ],
    "stats": {
      "total": 183,
      "additions": 75,
      "deletions": 108
    },
    "files": [
      {
        "sha": "18308997ea8823d0ce28eed4bc37aba6a8c42846",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 28,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/baf7de22108eb9081ddc700067b72409efbc382e/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/baf7de22108eb9081ddc700067b72409efbc382e/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=baf7de22108eb9081ddc700067b72409efbc382e",
        "patch": "@@ -44,6 +44,8 @@ const std::map<uint64_t,std::string> WALLET_FLAG_CAVEATS{\n };\n \n static const size_t OUTPUT_GROUP_MAX_ENTRIES = 10;\n+// frequency of resubmitting txns to mempool- 24 hours\n+static const std::chrono::milliseconds RESEND_TXS_FREQUENCY { 1000 * 60 * 60 * 24 };\n \n static CCriticalSection cs_wallets;\n static std::vector<std::shared_ptr<CWallet>> vpwallets GUARDED_BY(cs_wallets);\n@@ -1915,47 +1917,29 @@ bool CWalletTx::IsEquivalentTo(const CWalletTx& _tx) const\n         return CTransaction(tx1) == CTransaction(tx2);\n }\n \n-// Rebroadcast transactions from the wallet. We do this on a random timer\n-// to slightly obfuscate which transactions come from our wallet.\n-//\n-// Ideally, we'd only resend transactions that we think should have been\n-// mined in the most recent block. Any transaction that wasn't in the top\n-// blockweight of transactions in the mempool shouldn't have been mined,\n-// and so is probably just sitting in the mempool waiting to be confirmed.\n-// Rebroadcasting does nothing to speed up confirmation and only damages\n-// privacy.\n-void CWallet::ResendWalletTransactions()\n+// Once a day, resubmit all wallet transactions to the node,\n+// in case it has been dropped from your mempool.\n+void CWallet::ResubmitWalletTransactionsToMempool()\n {\n     // During reindex, importing and IBD, old wallet transactions become\n-    // unconfirmed. Don't resend them as that would spam other nodes.\n+    // unconfirmed. Don't need to resubmit to our node.\n     if (!chain().isReadyToBroadcast()) return;\n \n-    // Do this infrequently and randomly to avoid giving away\n-    // that these are our transactions.\n-    if (GetTime() < nNextResend || !fBroadcastTransactions) return;\n-    bool fFirst = (nNextResend == 0);\n-    nNextResend = GetTime() + GetRand(30 * 60);\n-    if (fFirst) return;\n-\n-    // Only do it if there's been a new block since last time\n-    if (m_best_block_time < nLastResend) return;\n-    nLastResend = GetTime();\n+    // Do this once per day.\n+    if (std::chrono::milliseconds{GetTime()} < nNextResend) return;\n+    nNextResend = std::chrono::milliseconds{GetTime()} + RESEND_TXS_FREQUENCY;\n \n     int submitted_tx_count = 0;\n \n     { // locked_chain and cs_wallet scope\n         auto locked_chain = chain().lock();\n         LOCK(cs_wallet);\n \n-        // Relay transactions\n+        // Resubmit transactions\n         for (std::pair<const uint256, CWalletTx>& item : mapWallet) {\n             CWalletTx& wtx = item.second;\n-            // Attempt to rebroadcast all txes more than 5 minutes older than\n-            // the last block. SubmitMemoryPoolAndRelay() will not rebroadcast\n-            // any confirmed or conflicting txs.\n-            if (wtx.nTimeReceived > m_best_block_time - 5 * 60) continue;\n             std::string unused_err_string;\n-            if (wtx.SubmitMemoryPoolAndRelay(unused_err_string, true)) ++submitted_tx_count;\n+            if (wtx.SubmitMemoryPoolAndRelay(unused_err_string, false)) ++submitted_tx_count;\n         }\n     } // locked_chain and cs_wallet\n \n@@ -1969,7 +1953,7 @@ void CWallet::ResendWalletTransactions()\n void MaybeResendWalletTxs()\n {\n     for (const std::shared_ptr<CWallet>& pwallet : GetWallets()) {\n-        pwallet->ResendWalletTransactions();\n+        pwallet->ResubmitWalletTransactionsToMempool();\n     }\n }\n "
      },
      {
        "sha": "eb64b13dc84fea6f2568c29221e622e594b4584e",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/baf7de22108eb9081ddc700067b72409efbc382e/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/baf7de22108eb9081ddc700067b72409efbc382e/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=baf7de22108eb9081ddc700067b72409efbc382e",
        "patch": "@@ -613,8 +613,7 @@ class CWallet final : public WalletStorage, private interfaces::Chain::Notificat\n     //! the maximum wallet format version: memory-only variable that specifies to what version this wallet may be upgraded\n     int nWalletMaxVersion GUARDED_BY(cs_wallet) = FEATURE_BASE;\n \n-    int64_t nNextResend = 0;\n-    int64_t nLastResend = 0;\n+    std::chrono::milliseconds nNextResend = std::chrono::milliseconds{0};\n     bool fBroadcastTransactions = false;\n     // Local time that the tip block was received. Used to schedule wallet rebroadcasts.\n     std::atomic<int64_t> m_best_block_time {0};\n@@ -880,7 +879,7 @@ class CWallet final : public WalletStorage, private interfaces::Chain::Notificat\n     ScanResult ScanForWalletTransactions(const uint256& first_block, const uint256& last_block, const WalletRescanReserver& reserver, bool fUpdate);\n     void TransactionRemovedFromMempool(const CTransactionRef &ptx) override;\n     void ReacceptWalletTransactions() EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    void ResendWalletTransactions();\n+    void ResubmitWalletTransactionsToMempool();\n     struct Balance {\n         CAmount m_mine_trusted{0};           //!< Trusted, at depth=GetBalance.min_depth or more\n         CAmount m_mine_untrusted_pending{0}; //!< Untrusted, but in mempool (pending)"
      },
      {
        "sha": "a3cbcbc025502f955dc71dfb7a9a5738e893c051",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/baf7de22108eb9081ddc700067b72409efbc382e/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/baf7de22108eb9081ddc700067b72409efbc382e/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=baf7de22108eb9081ddc700067b72409efbc382e",
        "patch": "@@ -191,7 +191,7 @@\n     'feature_dersig.py',\n     'feature_cltv.py',\n     'rpc_uptime.py',\n-    'wallet_resendwallettransactions.py',\n+    'wallet_resubmit_txs.py',\n     'wallet_fallbackfee.py',\n     'rpc_dumptxoutset.py',\n     'feature_minchainwork.py',"
      },
      {
        "sha": "91d26e9cb3978021c66d6af985e081a226efa239",
        "filename": "test/functional/wallet_resendwallettransactions.py",
        "status": "removed",
        "additions": 0,
        "deletions": 76,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d3154f11604dbaf018b123a69155674eaf316fcb/test/functional/wallet_resendwallettransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d3154f11604dbaf018b123a69155674eaf316fcb/test/functional/wallet_resendwallettransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_resendwallettransactions.py?ref=d3154f11604dbaf018b123a69155674eaf316fcb",
        "patch": "@@ -1,76 +0,0 @@\n-#!/usr/bin/env python3\n-# Copyright (c) 2017-2019 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Test that the wallet resends transactions periodically.\"\"\"\n-from collections import defaultdict\n-import time\n-\n-from test_framework.blocktools import create_block, create_coinbase\n-from test_framework.messages import ToHex\n-from test_framework.mininode import P2PInterface, mininode_lock\n-from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, wait_until\n-\n-class P2PStoreTxInvs(P2PInterface):\n-    def __init__(self):\n-        super().__init__()\n-        self.tx_invs_received = defaultdict(int)\n-\n-    def on_inv(self, message):\n-        # Store how many times invs have been received for each tx.\n-        for i in message.inv:\n-            if i.type == 1:\n-                # save txid\n-                self.tx_invs_received[i.hash] += 1\n-\n-class ResendWalletTransactionsTest(BitcoinTestFramework):\n-    def set_test_params(self):\n-        self.num_nodes = 1\n-\n-    def skip_test_if_missing_module(self):\n-        self.skip_if_no_wallet()\n-\n-    def run_test(self):\n-        node = self.nodes[0]  # alias\n-\n-        node.add_p2p_connection(P2PStoreTxInvs())\n-\n-        self.log.info(\"Create a new transaction and wait until it's broadcast\")\n-        txid = int(node.sendtoaddress(node.getnewaddress(), 1), 16)\n-\n-        # Wallet rebroadcast is first scheduled 1 sec after startup (see\n-        # nNextResend in ResendWalletTransactions()). Sleep for just over a\n-        # second to be certain that it has been called before the first\n-        # setmocktime call below.\n-        time.sleep(1.1)\n-\n-        # Can take a few seconds due to transaction trickling\n-        wait_until(lambda: node.p2p.tx_invs_received[txid] >= 1, lock=mininode_lock)\n-\n-        # Add a second peer since txs aren't rebroadcast to the same peer (see filterInventoryKnown)\n-        node.add_p2p_connection(P2PStoreTxInvs())\n-\n-        self.log.info(\"Create a block\")\n-        # Create and submit a block without the transaction.\n-        # Transactions are only rebroadcast if there has been a block at least five minutes\n-        # after the last time we tried to broadcast. Use mocktime and give an extra minute to be sure.\n-        block_time = int(time.time()) + 6 * 60\n-        node.setmocktime(block_time)\n-        block = create_block(int(node.getbestblockhash(), 16), create_coinbase(node.getblockcount() + 1), block_time)\n-        block.rehash()\n-        block.solve()\n-        node.submitblock(ToHex(block))\n-\n-        # Transaction should not be rebroadcast\n-        node.p2ps[1].sync_with_ping()\n-        assert_equal(node.p2ps[1].tx_invs_received[txid], 0)\n-\n-        self.log.info(\"Transaction should be rebroadcast after 30 minutes\")\n-        # Use mocktime and give an extra 5 minutes to be sure.\n-        rebroadcast_time = int(time.time()) + 41 * 60\n-        node.setmocktime(rebroadcast_time)\n-        wait_until(lambda: node.p2ps[1].tx_invs_received[txid] >= 1, lock=mininode_lock)\n-\n-if __name__ == '__main__':\n-    ResendWalletTransactionsTest().main()"
      },
      {
        "sha": "8c8f307abe32c0355153a46ad42ed2d3fa70822b",
        "filename": "test/functional/wallet_resubmit_txs.py",
        "status": "added",
        "additions": 60,
        "deletions": 0,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/baf7de22108eb9081ddc700067b72409efbc382e/test/functional/wallet_resubmit_txs.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/baf7de22108eb9081ddc700067b72409efbc382e/test/functional/wallet_resubmit_txs.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_resubmit_txs.py?ref=baf7de22108eb9081ddc700067b72409efbc382e",
        "patch": "@@ -0,0 +1,60 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test that the wallet resends transactions periodically.\"\"\"\n+import time\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import wait_until\n+\n+class ResubmitWalletTransactionsToMempoolTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+\n+        node = self.nodes[0]\n+\n+        self.log.info(\"Create a new wallet transaction\")\n+\n+        relayfee = node.getnetworkinfo()['relayfee']\n+        node.settxfee(relayfee)\n+        txhsh = node.sendtoaddress(node.getnewaddress(), 1)\n+\n+        assert txhsh in node.getrawmempool()\n+\n+        # bump mocktime so the transaction should expire\n+        # add an extra hour for good measure\n+        two_weeks_in_seconds = 60 * 60 * 24 * 14\n+        mocktime = int(time.time()) + two_weeks_in_seconds + 60 * 60\n+        node.setmocktime(mocktime)\n+\n+        # making a new transaction invokes ATMP which expires old txns\n+        node.sendtoaddress(node.getnewaddress(), 1)\n+\n+        # confirm txn is no longer in mempool\n+        self.log.info(\"Confirm transaction is no longer in mempool\")\n+        assert txhsh not in node.getrawmempool()\n+\n+        # bumptime so ResubmitWalletTransactionsToMempool triggers\n+        # we resend once / day, so bump 25 hours just to be sure\n+        # we don't resubmit the first time, so we bump mocktime\n+        # twice so the resend occurs the second time around\n+        one_day_in_seconds = 60 * 60 * 25\n+        node.setmocktime(mocktime + one_day_in_seconds)\n+\n+        time.sleep(1.1)\n+\n+        node.setmocktime(mocktime + 2 * one_day_in_seconds)\n+\n+        # confirm that its back in the mempool\n+        self.log.info(\"Transaction should be resubmitted to mempool\")\n+        wait_until(lambda: txhsh in node.getrawmempool(), timeout=30)\n+\n+\n+if __name__ == '__main__':\n+    ResubmitWalletTransactionsToMempoolTest().main()"
      }
    ]
  },
  {
    "sha": "f8835c989bb6897a4684c7cffc00a1f6cd442e04",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmODgzNWM5ODliYjY4OTdhNDY4NGM3Y2ZmYzAwYTFmNmNkNDQyZTA0",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2019-08-23T20:09:50Z"
      },
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2020-01-03T22:56:56Z"
      },
      "message": "[mempool] mempool tracks wallet txns & ensures successful initial broadcast\n\nSince the newly implemented functionality only rebroadcasts txns at\nthe top of the mempool, its possible to hit a case where if a txn was\nsubmitted locally & not immediately relayed, it would take a long time\nto be included in the rebroadcast set & ever succesfully be initially\nbroadcast.\n\nTo prevent this case, the mempool keeps track of `m_unbroadcast_txids`,\nand deems the txn relay successful when an associated GETDATA message is\nreceived. On the rebroadcast timer, txns from this set are added to the\ntxns being relayed.",
      "tree": {
        "sha": "4dd5796fe59e38a331c45b48612054ad4166c769",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4dd5796fe59e38a331c45b48612054ad4166c769"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f8835c989bb6897a4684c7cffc00a1f6cd442e04",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f8835c989bb6897a4684c7cffc00a1f6cd442e04",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f8835c989bb6897a4684c7cffc00a1f6cd442e04",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f8835c989bb6897a4684c7cffc00a1f6cd442e04/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "baf7de22108eb9081ddc700067b72409efbc382e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/baf7de22108eb9081ddc700067b72409efbc382e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/baf7de22108eb9081ddc700067b72409efbc382e"
      }
    ],
    "stats": {
      "total": 132,
      "additions": 132,
      "deletions": 0
    },
    "files": [
      {
        "sha": "aa99a2cfbea92a39593b8d118a7072b52130af78",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8835c989bb6897a4684c7cffc00a1f6cd442e04/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8835c989bb6897a4684c7cffc00a1f6cd442e04/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=f8835c989bb6897a4684c7cffc00a1f6cd442e04",
        "patch": "@@ -1564,6 +1564,11 @@ void static ProcessGetData(CNode* pfrom, const CChainParams& chainparams, CConnm\n             if (mi != mapRelay.end()) {\n                 connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *mi->second));\n                 push = true;\n+                // Once the first peer requests GETDATA for a txn, we deem initial broadcast a success\n+                auto num = mempool.m_unbroadcast_txids.erase(inv.hash);\n+                if (num) {\n+                    LogPrint(BCLog::NET, \"Removed %i from m_unbroadcast_txids \\n\", inv.hash.GetHex());\n+                }\n             } else {\n                 auto txinfo = mempool.info(inv.hash);\n                 // To protect privacy, do not answer getdata using the mempool when\n@@ -3810,6 +3815,10 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                         // add rebroadcast txns\n                         pto->m_tx_relay->setInventoryTxToSend.insert(rebroadcastTxs.begin(), rebroadcastTxs.end());\n \n+                        // also include wallet txns that haven't been successfully broadcast yet\n+                        LogPrint(BCLog::NET, \"Force initial broadcast of %lu transactions \\n\", mempool.m_unbroadcast_txids.size());\n+                        // since set elements are unique, this will be a no-op if the txns are already in setInventoryTxToSend\n+                        pto->m_tx_relay->setInventoryTxToSend.insert(mempool.m_unbroadcast_txids.begin(), mempool.m_unbroadcast_txids.end());\n                     }\n                 }\n "
      },
      {
        "sha": "550b9418185fb2c1a634a4f3fdc4900ab34bc29a",
        "filename": "src/node/transaction.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8835c989bb6897a4684c7cffc00a1f6cd442e04/src/node/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8835c989bb6897a4684c7cffc00a1f6cd442e04/src/node/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/transaction.cpp?ref=f8835c989bb6897a4684c7cffc00a1f6cd442e04",
        "patch": "@@ -79,6 +79,9 @@ TransactionError BroadcastTransaction(NodeContext& node, const CTransactionRef t\n     }\n \n     if (relay) {\n+        // the mempool explicitly keeps track of locally submitted txns to ensure successful initial broadcast\n+        mempool.m_unbroadcast_txids.insert(hashTx);\n+\n         RelayTransaction(hashTx, *node.connman);\n     }\n "
      },
      {
        "sha": "5fcd3c66457ddc7fc544046c0b37c452a186acc9",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8835c989bb6897a4684c7cffc00a1f6cd442e04/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8835c989bb6897a4684c7cffc00a1f6cd442e04/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=f8835c989bb6897a4684c7cffc00a1f6cd442e04",
        "patch": "@@ -539,6 +539,10 @@ class CTxMemPool\n     const setEntries & GetMemPoolParents(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n     const setEntries & GetMemPoolChildren(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n     uint64_t CalculateDescendantMaximum(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    // track wallet transactions to ensure they are successfully broadcast\n+    std::set<uint256> m_unbroadcast_txids;\n+\n private:\n     typedef std::map<txiter, setEntries, CompareIteratorByHash> cacheMap;\n "
      },
      {
        "sha": "d53822c625eceed2e6405f1cb8a341f0bbe415f1",
        "filename": "test/functional/mempool_local_transactions.py",
        "status": "added",
        "additions": 115,
        "deletions": 0,
        "changes": 115,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8835c989bb6897a4684c7cffc00a1f6cd442e04/test/functional/mempool_local_transactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8835c989bb6897a4684c7cffc00a1f6cd442e04/test/functional/mempool_local_transactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_local_transactions.py?ref=f8835c989bb6897a4684c7cffc00a1f6cd442e04",
        "patch": "@@ -0,0 +1,115 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2009-2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Ensure that transactions submitted locally (via rpc or wallet) are successfully\n+broadcast to at least one peer.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+        assert_greater_than,\n+        wait_until,\n+        create_confirmed_utxos,\n+        disconnect_nodes\n+)\n+from test_framework.mininode import P2PTxInvStore\n+import time\n+\n+# Constant from txmempool.h\n+MAX_REBROADCAST_WEIGHT = 3000000\n+\n+class MempoolLocalTransactionsTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\n+            \"-whitelist=127.0.0.1\",\n+            \"-blockmaxweight=3000000\"\n+            ]] * self.num_nodes\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.log.info(\"test that mempool will ensure initial broadcast of locally submitted txns\")\n+\n+        node = self.nodes[0]\n+        min_relay_fee = node.getnetworkinfo()[\"relayfee\"]\n+        utxos = create_confirmed_utxos(min_relay_fee, node, 2000)\n+\n+        self.log.info(\"populate mempool with transactions\")\n+        node.settxfee(min_relay_fee * 3)\n+\n+        addresses = []\n+        for _ in range(50):\n+            addresses.append(self.nodes[1].getnewaddress())\n+\n+        # create large txns by sending to all the addresses\n+        outputs = {}\n+        for addr in addresses:\n+            outputs[addr] = 0.0001\n+\n+        self.sync_blocks()\n+\n+        # create lots of txns with that large output\n+        for _ in range(len(utxos) - 2):\n+            utxo = utxos.pop()\n+            inputs = [{'txid': utxo['txid'], 'vout': utxo['vout']}]\n+            raw_tx_hex = node.createrawtransaction(inputs, outputs)\n+            signed_tx = node.signrawtransactionwithwallet(raw_tx_hex)\n+            node.sendrawtransaction(hexstring=signed_tx['hex'], maxfeerate=0)\n+            self.nodes[1].sendrawtransaction(hexstring=signed_tx['hex'], maxfeerate=0)\n+\n+        self.sync_mempools()\n+\n+        # confirm txns are more than max rebroadcast amount\n+        assert_greater_than(node.getmempoolinfo()['bytes'], MAX_REBROADCAST_WEIGHT)\n+\n+        # node needs any connection to pass check in getblocktemplate\n+        node.add_p2p_connection(P2PTxInvStore())\n+\n+        self.log.info(\"generate txns that won't be marked as broadcast\")\n+        disconnect_nodes(node, 1)\n+\n+        # generate a txn using sendrawtransaction\n+        us0 = utxos.pop()\n+        inputs = [{ \"txid\" : us0[\"txid\"], \"vout\" : us0[\"vout\"]}]\n+        addr = node.getnewaddress()\n+        outputs = {addr: 0.0001}\n+        tx = node.createrawtransaction(inputs, outputs)\n+        node.settxfee(min_relay_fee) # specifically fund this tx with low fee\n+        txF = node.fundrawtransaction(tx)\n+        txFS = node.signrawtransactionwithwallet(txF['hex'])\n+        rpc_tx_hsh = node.sendrawtransaction(txFS['hex'])  # txhsh in hex\n+\n+        # generate a wallet txn\n+        utxo = utxos.pop()\n+        wallet_tx_hsh = node.sendtoaddress(addr, 0.0001)\n+\n+        # ensure the txns won't be rebroadcast due to top-of-mempool rule\n+        tx_hshs = []\n+        tmpl = node.getblocktemplate({'rules': ['segwit']})\n+\n+        for tx in tmpl['transactions']:\n+            tx_hshs.append(tx['hash'])\n+\n+        assert(rpc_tx_hsh not in tx_hshs)\n+        assert(wallet_tx_hsh not in tx_hshs)\n+\n+        # trigger rebroadcast\n+        conn = node.add_p2p_connection(P2PTxInvStore())\n+        mocktime = int(time.time()) + 300 * 60\n+        node.setmocktime(mocktime)\n+\n+        # verify the txn invs were sent due to tracking unbroadcast set\n+        wallet_tx_id = int(wallet_tx_hsh, 16)\n+        rpc_tx_id = int(rpc_tx_hsh, 16)\n+\n+        self.log.info(\"verify invs were sent due to unbroadcast tracking\")\n+        wait_until(lambda: wallet_tx_id in conn.get_invs())\n+        wait_until(lambda: rpc_tx_id in conn.get_invs())\n+\n+if __name__ == '__main__':\n+    MempoolLocalTransactionsTest().main()\n+"
      },
      {
        "sha": "356b00b1a65b38dcf8d31c6ddc3bc9008796334d",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8835c989bb6897a4684c7cffc00a1f6cd442e04/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8835c989bb6897a4684c7cffc00a1f6cd442e04/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=f8835c989bb6897a4684c7cffc00a1f6cd442e04",
        "patch": "@@ -138,6 +138,7 @@\n     'rpc_psbt.py',\n     'rpc_users.py',\n     'rpc_whitelist.py',\n+    'mempool_local_transactions.py',\n     'feature_proxy.py',\n     'rpc_signrawtransaction.py',\n     'wallet_groups.py',"
      }
    ]
  },
  {
    "sha": "939e2206021fd00cfd56c4de090434e4152bae8a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MzllMjIwNjAyMWZkMDBjZmQ1NmM0ZGUwOTA0MzRlNDE1MmJhZThh",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2019-11-20T18:21:39Z"
      },
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2020-01-03T22:56:56Z"
      },
      "message": "[mempool] add fee rate filter on rebroadcast set\n\nPeriodically (~20 mins) construct a block, identify the minimum\nfee rate for a package to be included & cache the result. Only\nrebroadcast transactions with higher fee rate than cached value.\nThis is to reduce rebroadcast noise.\n\nWe add logic to ensure a new block between last cache run &\nrebroadcast, because otherwise the cache doesn't eliminate any\ntransactions from the set.\n\nAt the time of rebroadcast, if the cache has run within the past\n30 mins, it will work together with the recency filter to remove\ntxns from the rebroadcast set.",
      "tree": {
        "sha": "2687bf64794129bbd0c26494fdf024505e872398",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2687bf64794129bbd0c26494fdf024505e872398"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/939e2206021fd00cfd56c4de090434e4152bae8a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/939e2206021fd00cfd56c4de090434e4152bae8a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/939e2206021fd00cfd56c4de090434e4152bae8a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/939e2206021fd00cfd56c4de090434e4152bae8a/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f8835c989bb6897a4684c7cffc00a1f6cd442e04",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f8835c989bb6897a4684c7cffc00a1f6cd442e04",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f8835c989bb6897a4684c7cffc00a1f6cd442e04"
      }
    ],
    "stats": {
      "total": 348,
      "additions": 264,
      "deletions": 84
    },
    "files": [
      {
        "sha": "4ee91c6d13aa448f52f488ae186f8bdbe9610f01",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 46,
        "deletions": 2,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/939e2206021fd00cfd56c4de090434e4152bae8a/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/939e2206021fd00cfd56c4de090434e4152bae8a/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=939e2206021fd00cfd56c4de090434e4152bae8a",
        "patch": "@@ -141,7 +141,9 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc\n \n     int nPackagesSelected = 0;\n     int nDescendantsUpdated = 0;\n-    addPackageTxs(nPackagesSelected, nDescendantsUpdated);\n+    CFeeRate min_fee_rate = CFeeRate(COIN, 1);\n+\n+    addPackageTxs(nPackagesSelected, nDescendantsUpdated, min_fee_rate);\n \n     int64_t nTime1 = GetTimeMicros();\n \n@@ -293,6 +295,44 @@ void BlockAssembler::SortForBlock(const CTxMemPool::setEntries& package, std::ve\n     std::sort(sortedEntries.begin(), sortedEntries.end(), CompareTxIterByAncestorCount());\n }\n \n+// This method is just a wrapper to addPackageTxs with all the setup required.\n+CFeeRate BlockAssembler::minTxFeeRate()\n+{\n+    int nPackagesSelected = 0;\n+    int nDescendantsUpdated = 0;\n+    CFeeRate min_fee_rate = CFeeRate(COIN, 1);\n+\n+    resetBlock();\n+    pblocktemplate.reset(new CBlockTemplate());\n+\n+    if(!pblocktemplate.get()){\n+        return min_fee_rate;\n+    }\n+    pblock = &pblocktemplate->block; // pointer for convenience\n+\n+    // Add dummy coinbase tx as first transaction\n+    pblock->vtx.emplace_back();\n+    pblocktemplate->vTxFees.push_back(-1); // updated at end\n+    pblocktemplate->vTxSigOpsCost.push_back(-1); // updated at end\n+\n+    CBlockIndex* pindexPrev = ::ChainActive().Tip();\n+    assert(pindexPrev != nullptr);\n+    nHeight = pindexPrev->nHeight + 1;\n+\n+    pblock->nTime = GetAdjustedTime();\n+    const int64_t nMedianTimePast = pindexPrev->GetMedianTimePast();\n+\n+    nLockTimeCutoff = nMedianTimePast;\n+    fIncludeWitness = IsWitnessEnabled(pindexPrev, chainparams.GetConsensus());\n+\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        addPackageTxs(nPackagesSelected, nDescendantsUpdated, min_fee_rate);\n+    }\n+\n+    return min_fee_rate;\n+}\n+\n // This transaction selection algorithm orders the mempool based\n // on feerate of a transaction including all unconfirmed ancestors.\n // Since we don't remove transactions from the mempool as we select them\n@@ -303,7 +343,7 @@ void BlockAssembler::SortForBlock(const CTxMemPool::setEntries& package, std::ve\n // Each time through the loop, we compare the best transaction in\n // mapModifiedTxs with the next transaction in the mempool to decide what\n // transaction package to work on next.\n-void BlockAssembler::addPackageTxs(int &nPackagesSelected, int &nDescendantsUpdated)\n+void BlockAssembler::addPackageTxs(int &nPackagesSelected, int &nDescendantsUpdated, CFeeRate &minPackageFeeRate)\n {\n     // mapModifiedTx will store sorted packages after they are modified\n     // because some of their txs are already in the block\n@@ -415,6 +455,10 @@ void BlockAssembler::addPackageTxs(int &nPackagesSelected, int &nDescendantsUpda\n         // This transaction will make it in; reset the failed counter.\n         nConsecutiveFailed = 0;\n \n+        CFeeRate newFeeRate(packageFees, packageSize * WITNESS_SCALE_FACTOR);\n+\n+        if (newFeeRate < minPackageFeeRate) minPackageFeeRate = newFeeRate;\n+\n         // Package can be added. Sort the entries in a valid order.\n         std::vector<CTxMemPool::txiter> sortedEntries;\n         SortForBlock(ancestors, sortedEntries);"
      },
      {
        "sha": "1f87aa4eac6f0d715588bbf40ced33cc0ddac9e8",
        "filename": "src/miner.h",
        "status": "modified",
        "additions": 7,
        "deletions": 3,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/939e2206021fd00cfd56c4de090434e4152bae8a/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/939e2206021fd00cfd56c4de090434e4152bae8a/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=939e2206021fd00cfd56c4de090434e4152bae8a",
        "patch": "@@ -167,6 +167,9 @@ class BlockAssembler\n     static Optional<int64_t> m_last_block_num_txs;\n     static Optional<int64_t> m_last_block_weight;\n \n+    /** Wrapper to addPackageTxs that returns the minimum fee rate of a package\n+      * included in the block. Used for rebroadcast cache. */\n+    CFeeRate minTxFeeRate();\n private:\n     // utility functions\n     /** Clear the block's state and prepare for assembling a new block */\n@@ -177,9 +180,10 @@ class BlockAssembler\n     // Methods for how to add transactions to a block.\n     /** Add transactions based on feerate including unconfirmed ancestors\n       * Increments nPackagesSelected / nDescendantsUpdated with corresponding\n-      * statistics from the package selection (for logging statistics). */\n-    void addPackageTxs(int& nPackagesSelected, int& nDescendantsUpdated) EXCLUSIVE_LOCKS_REQUIRED(m_mempool.cs);\n-\n+      * statistics from the package selection (for logging statistics).\n+      * Populates minPackageFeeRate with the minimum fee rate of a package\n+      * included in the block (used for rebroadcast cache). */\n+    void addPackageTxs(int& nPackagesSelected, int& nDescendantsUpdated, CFeeRate &minPackageFeeRate) EXCLUSIVE_LOCKS_REQUIRED(m_mempool.cs);\n     // helper functions for addPackageTxs()\n     /** Remove confirmed (inBlock) entries from given set */\n     void onlyUnconfirmed(CTxMemPool::setEntries& testSet);"
      },
      {
        "sha": "48d06f22210b09d8e23f7f4a77c6a1fef7218f97",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 1,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/939e2206021fd00cfd56c4de090434e4152bae8a/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/939e2206021fd00cfd56c4de090434e4152bae8a/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=939e2206021fd00cfd56c4de090434e4152bae8a",
        "patch": "@@ -3804,7 +3804,15 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                     bool fFirst = (pto->m_next_rebroadcast.count() == 0);\n                     pto->m_next_rebroadcast = PoissonNextSend(current_time, TX_REBROADCAST_INTERVAL);\n \n-                    if (!fFirst) {\n+                    // if there hasn't been a block since last cache, don't rebroadcast yet\n+                    bool fSkipRun = ::ChainActive().Tip() == mempool.m_tip_at_cache_time && false;\n+                    if (fSkipRun) {\n+                        LogPrint(BCLog::NET, \"Bumping rebroadcast because no new blocks since last cache run\\n\");\n+                        mempool.m_next_min_fee_cache += REBROADCAST_FEE_RATE_CACHE_INTERVAL;\n+                        pto->m_next_rebroadcast = current_time + std::chrono::minutes{10};\n+                    }\n+\n+                    if (!fFirst && !fSkipRun) {\n                         std::vector<uint256> rebroadcastTxs;\n                         mempool.GetRebroadcastTransactions(rebroadcastTxs);\n \n@@ -3822,6 +3830,12 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                     }\n                 }\n \n+                // cache the min fee rate for a txn to be included in a block\n+                // applied as rebroadcast filter above\n+                if (mempool.m_next_min_fee_cache < current_time){\n+                    mempool.CacheMinRebroadcastFee();\n+                }\n+\n                 // Time to send but the peer has requested we not relay transactions.\n                 if (fSendTrickle) {\n                     LOCK(pto->m_tx_relay->cs_filter);"
      },
      {
        "sha": "b6d770ef61b6b8b55b04cc33c3e285b3e6c9de3e",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 2,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/939e2206021fd00cfd56c4de090434e4152bae8a/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/939e2206021fd00cfd56c4de090434e4152bae8a/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=939e2206021fd00cfd56c4de090434e4152bae8a",
        "patch": "@@ -116,10 +116,35 @@ void CTxMemPool::GetRebroadcastTransactions(std::vector<uint256>& rebroadcastTxs\n     std::unique_ptr<CBlockTemplate> pblocktemplate = BlockAssembler(mempool, Params(), options).CreateNewBlock(dummy_script);\n \n     LOCK(cs);\n+    int count = 0;\n     for (const CTransactionRef& tx : pblocktemplate->block.vtx) {\n-        // add to rebroadcast set\n-        rebroadcastTxs.push_back(tx->GetHash());\n+        txiter it = mapTx.find(tx->GetHash());\n+        if (it == mapTx.end()) { continue; }\n+        CFeeRate fee_rate = CFeeRate(it->GetModifiedFee(), GetTransactionWeight(*tx));\n+\n+        // compare txn fee rate to cached value\n+        if (fee_rate > m_cached_fee_rate) {\n+            // add to rebroadcast set\n+            rebroadcastTxs.push_back(tx->GetHash());\n+            count += 1;\n+        }\n     }\n+\n+    LogPrint(BCLog::MEMPOOL, \"%d transactions queued for rebroadcast, from %s candidates filtered with cached fee rate of %s. \\n\", count, pblocktemplate->block.vtx.size(), m_cached_fee_rate.ToString());\n+}\n+\n+void CTxMemPool::CacheMinRebroadcastFee()\n+{\n+    // update time of next run\n+    mempool.m_next_min_fee_cache = REBROADCAST_FEE_RATE_CACHE_INTERVAL + GetTime<std::chrono::microseconds>();\n+\n+    // update stamp of chain tip on cache run\n+    m_tip_at_cache_time = ::ChainActive().Tip();\n+\n+    // update cache\n+    m_cached_fee_rate = BlockAssembler(mempool, Params()).minTxFeeRate();\n+\n+    LogPrint(BCLog::MEMPOOL, \"Rebroadcast cached_fee_rate has been updated to=%s \\n\", m_cached_fee_rate.ToString());\n }\n \n // vHashesToUpdate is the set of transaction hashes from a disconnected block"
      },
      {
        "sha": "50dcbe0f70d7d154b54148fed2495b1f4b7eabaf",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 15,
        "deletions": 3,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/939e2206021fd00cfd56c4de090434e4152bae8a/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/939e2206021fd00cfd56c4de090434e4152bae8a/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=939e2206021fd00cfd56c4de090434e4152bae8a",
        "patch": "@@ -43,6 +43,9 @@ static const std::chrono::seconds REBROADCAST_MIN_TX_AGE = std::chrono::seconds{\n // such as miners mining priority txns\n static const unsigned int MAX_REBROADCAST_WEIGHT = 0.75 * MAX_BLOCK_WEIGHT;\n \n+// Frequency of updating the cache value applied as a filter on rebroadcast set.\n+const std::chrono::microseconds REBROADCAST_FEE_RATE_CACHE_INTERVAL = std::chrono::minutes{20};\n+\n struct LockPoints\n {\n     // Will be set to the blockchain height and median time past\n@@ -540,8 +543,11 @@ class CTxMemPool\n     const setEntries & GetMemPoolChildren(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n     uint64_t CalculateDescendantMaximum(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    // track wallet transactions to ensure they are successfully broadcast\n-    std::set<uint256> m_unbroadcast_txids;\n+    // rebroadcast\n+    std::set<uint256> m_unbroadcast_txids;             //!< track wallet transactions to ensure they are successfully broadcast\n+    std::chrono::microseconds m_next_min_fee_cache{0}; //!< timer for updating fee rate cache\n+    CBlockIndex* m_tip_at_cache_time;                  //!< block height at time of cache\n+    CFeeRate m_cached_fee_rate;                        //!< min package fee rate for block inclusion\n \n private:\n     typedef std::map<txiter, setEntries, CompareIteratorByHash> cacheMap;\n@@ -628,10 +634,16 @@ class CTxMemPool\n     void RemoveStaged(setEntries& stage, bool updateDescendants, MemPoolRemovalReason reason) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     /** Use CreateNewBlock with specific rebroadcast parameters to identify a set\n-     * of transaction candidates & populate them in rebroadcastTxs.\n+     * of rebroadcast candidates, filter them by comparing their fee rates with\n+     * the cached fee rate & populate rebroadcastTxs with remaining.\n      */\n     void GetRebroadcastTransactions(std::vector<uint256>& rebroadcastTxs);\n \n+    /** Assemble a block from the local mempool and update a cache with the\n+     *  minimum fee rate for a package to be included.\n+     */\n+    void CacheMinRebroadcastFee();\n+\n     /** When adding transactions from a disconnected block back to the mempool,\n      *  new mempool entries may have children in the mempool (which is generally\n      *  not the case when otherwise adding transactions)."
      },
      {
        "sha": "a21f6277c6e2b85b80d62550eb6a0f3b407296f3",
        "filename": "test/functional/mempool_rebroadcast.py",
        "status": "modified",
        "additions": 154,
        "deletions": 73,
        "changes": 227,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/939e2206021fd00cfd56c4de090434e4152bae8a/test/functional/mempool_rebroadcast.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/939e2206021fd00cfd56c4de090434e4152bae8a/test/functional/mempool_rebroadcast.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_rebroadcast.py?ref=939e2206021fd00cfd56c4de090434e4152bae8a",
        "patch": "@@ -9,54 +9,84 @@\n from test_framework.mininode import P2PTxInvStore\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n+        assert_approx,\n         assert_equal,\n         assert_greater_than,\n         wait_until,\n         disconnect_nodes,\n         connect_nodes,\n-        gen_return_txouts,\n         create_confirmed_utxos,\n-        create_lots_of_big_transactions,\n )\n import time\n+from decimal import Decimal\n \n # Constant from txmempool.h\n MAX_REBROADCAST_WEIGHT = 3000000\n \n+# Constant from consensus.h\n+MAX_BLOCK_WEIGHT = 4000000\n+\n+global_mocktime = 0\n+\n class MempoolRebroadcastTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 2\n         self.extra_args = [[\n-            \"-acceptnonstdtxn=1\",\n-            \"-blockmaxweight=3000000\",\n-            \"-whitelist=127.0.0.1\"\n+            \"-whitelist=127.0.0.1\",\n+            \"-txindex=1\"\n             ]] * self.num_nodes\n \n     def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()\n \n     def run_test(self):\n         self.test_simple_rebroadcast()\n-        self.test_rebroadcast_top_txns()\n         self.test_recency_filter()\n+        self.test_fee_rate_cache()\n+\n+    def make_txn_at_fee_rate(self, input_utxo, outputs, outputs_sum, desired_fee_rate, change_address):\n+        node = self.nodes[0]\n+        node1 = self.nodes[1]\n+\n+        inputs = [{'txid': input_utxo['txid'], 'vout': input_utxo['vout']}]\n+\n+        # calculate how much input values add up to\n+        input_tx_hsh = input_utxo['txid']\n+        raw_tx = node.decoderawtransaction(node.getrawtransaction(input_tx_hsh))\n+        inputs_list = raw_tx['vout']\n+        if 'coinbase' in raw_tx['vin'][0].keys():\n+            return\n+        index = raw_tx['vin'][0]['vout']\n+        inputs_sum = inputs_list[index]['value']\n+\n+        # vsize is in bytes, cache fee rate is BTC / kB. Thus divide by 1000\n+        tx_vsize_with_change = 1660\n+        desired_fee_btc = desired_fee_rate * tx_vsize_with_change / 1000\n+        current_fee_btc = inputs_sum - Decimal(str(outputs_sum))\n \n-    # helper method that uses getblocktemplate with node arg\n-    # set to MAX_REBROADCAST_WEIGHT to find txns expected to\n-    # be rebroadcast\n-    def find_top_txns(self, node):\n-        tmpl = node.getblocktemplate({'rules': ['segwit']})\n+        # add another output with change\n+        outputs[change_address] = float(current_fee_btc - desired_fee_btc)\n+        outputs_sum += outputs[change_address]\n \n-        tx_hshs = []\n-        for tx in tmpl['transactions']:\n-            tx_hshs.append(tx['hash'])\n+        # form txn & submit to mempool\n+        raw_tx_hex = node.createrawtransaction(inputs, outputs)\n+        signed_tx = node.signrawtransactionwithwallet(raw_tx_hex)\n+        tx_hsh = node.sendrawtransaction(hexstring=signed_tx['hex'], maxfeerate=0)\n+        node1.sendrawtransaction(hexstring=signed_tx['hex'], maxfeerate=0)\n \n-        return tx_hshs\n+        # retrieve mempool txn to calculate fee rate\n+        mempool_entry = node.getmempoolentry(tx_hsh)\n \n-    def compare_txns_to_invs(self, txn_hshs, invs):\n-        tx_ids = [int(txhsh, 16) for txhsh in txn_hshs]\n+        # check absolute fee matches up to expectations\n+        fee_calculated = inputs_sum - Decimal(str(outputs_sum))\n+        fee_got = mempool_entry['fee']\n+        assert_approx(float(fee_calculated), float(fee_got))\n \n-        assert_equal(len(tx_ids), len(invs))\n-        assert_equal(tx_ids.sort(), invs.sort())\n+        # mempool_entry['fee'] is in BTC, fee rate should be BTC / kb\n+        fee_rate = mempool_entry['fee']*1000/mempool_entry['vsize']\n+        assert_approx(float(fee_rate), float(desired_fee_rate))\n+\n+        return tx_hsh\n \n     def test_simple_rebroadcast(self):\n         self.log.info(\"Test simplest rebroadcast case\")\n@@ -100,57 +130,6 @@ def test_simple_rebroadcast(self):\n         # check that node1 got txns bc rebroadcasting\n         wait_until(lambda: len(node1.getrawmempool()) == 3, timeout=30)\n \n-    def test_rebroadcast_top_txns(self):\n-        self.log.info(\"Testing that only txns with top fee rate get rebroadcast\")\n-\n-        node = self.nodes[0]\n-        node.setmocktime(0)\n-\n-        # mine a block to clear out the mempool\n-        node.generate(1)\n-        assert_equal(len(node.getrawmempool()), 0)\n-\n-        conn1 = node.add_p2p_connection(P2PTxInvStore())\n-\n-        # create txns\n-        min_relay_fee = node.getnetworkinfo()[\"relayfee\"]\n-        txouts = gen_return_txouts()\n-        utxo_count = 90\n-        utxos = create_confirmed_utxos(min_relay_fee, node, utxo_count)\n-        base_fee = min_relay_fee*100 # our transactions are smaller than 100kb\n-        txids = []\n-\n-        # Create 3 batches of transactions at 3 different fee rate levels\n-        range_size = utxo_count // 3\n-\n-        for i in range(3):\n-            start_range = i * range_size\n-            end_range = start_range + range_size\n-            txids.append(create_lots_of_big_transactions(node, txouts, utxos[start_range:end_range], end_range - start_range, (i+1)*base_fee))\n-\n-        # 90 transactions should be created\n-        # confirm the invs were sent (initial broadcast)\n-        assert_equal(len(node.getrawmempool()), 90)\n-        wait_until(lambda: len(conn1.tx_invs_received) == 90)\n-\n-        # confirm txns are more than max rebroadcast amount\n-        assert_greater_than(node.getmempoolinfo()['bytes'], MAX_REBROADCAST_WEIGHT)\n-\n-        # age txns to ensure they won't be excluded due to recency filter\n-        mocktime = int(time.time()) + 31 * 60\n-        node.setmocktime(mocktime)\n-\n-        # add another p2p connection since txns aren't rebroadcast to the same peer (see filterInventoryKnown)\n-        conn2 = node.add_p2p_connection(P2PTxInvStore())\n-\n-        # trigger rebroadcast to occur\n-        mocktime += 300 * 60 # seconds\n-        node.setmocktime(mocktime)\n-        time.sleep(1) # ensure send message thread runs so invs get sent\n-\n-        # `nNextInvSend` delay on `setInventoryTxToSend\n-        wait_until(lambda: conn2.get_invs(), timeout=30)\n-\n         global global_mocktime\n         global_mocktime = mocktime\n \n@@ -160,10 +139,14 @@ def test_recency_filter(self):\n         node = self.nodes[0]\n         node1 = self.nodes[1]\n \n-        node.setmocktime(0)\n+        global global_mocktime\n+        mocktime = global_mocktime\n+\n+        node.setmocktime(global_mocktime)\n+        node1.setmocktime(global_mocktime)\n \n         # mine blocks to clear out the mempool\n-        node.generate(10)\n+        node.generate(4)\n         assert_equal(len(node.getrawmempool()), 0)\n \n         # add p2p connection\n@@ -175,7 +158,7 @@ def test_recency_filter(self):\n         wait_until(lambda: conn.get_invs(), timeout=30)\n \n         # bump mocktime to ensure the txn is old\n-        mocktime = int(time.time()) + 31 * 60 # seconds\n+        mocktime += 31 * 60 # seconds\n         node.setmocktime(mocktime)\n \n         delta_time = 28 * 60 # seconds\n@@ -187,10 +170,14 @@ def test_recency_filter(self):\n             # ensure node0 has the transaction\n             wait_until(lambda: new_tx in node.getrawmempool())\n \n+            node.disconnect_p2ps()\n+\n             # add another p2p connection since txns aren't rebroadcast\n             # to the same peer (see filterInventoryKnown)\n             new_conn = node.add_p2p_connection(P2PTxInvStore())\n \n+            assert_equal(len(node.p2ps), 1)\n+\n             # bump mocktime to try to get rebroadcast,\n             # but not so much that the txn would be old\n             mocktime += delta_time\n@@ -203,6 +190,100 @@ def test_recency_filter(self):\n                 assert(new_tx_id not in new_conn.get_invs())\n                 break\n \n+        global_mocktime = mocktime\n+        node.disconnect_p2ps()\n+\n+    def test_fee_rate_cache(self):\n+        self.log.info(\"test that min-fee-rate cache limits rebroadcast set\")\n+        node = self.nodes[0]\n+        node1 = self.nodes[1]\n+\n+        mocktime = global_mocktime\n+        node.setmocktime(mocktime)\n+        node1.setmocktime(mocktime)\n+\n+        min_relay_fee = node.getnetworkinfo()[\"relayfee\"]\n+        assert_equal(len(node.p2ps), 0)\n+\n+        utxos = create_confirmed_utxos(min_relay_fee, node, 3000)\n+\n+        addresses = []\n+        for _ in range(50):\n+            addresses.append(node.getnewaddress())\n+\n+        # create large txns by sending to all the addresses\n+        outputs = { addr: 0.0001 for addr in addresses }\n+        change_address = node.getnewaddress()\n+        outputs_sum = 0.0001 * 50\n+\n+        self.sync_mempools()\n+\n+        self.log.info(\"fill mempool with txns with fee at cache_fee_rate\")\n+        initial_tx_hshs = []\n+        cache_fee_rate = min_relay_fee * 3\n+\n+        # create lots of txns with that large output\n+        for _ in range(len(utxos) - 500):\n+            tx_hsh = self.make_txn_at_fee_rate(utxos.pop(), outputs, outputs_sum, cache_fee_rate, change_address)\n+            initial_tx_hshs.append(tx_hsh)\n+\n+        self.sync_mempools()\n+        assert_greater_than(node.getmempoolinfo()['bytes'], MAX_BLOCK_WEIGHT)\n+\n+        # ensure cache job runs\n+        mocktime += 21 * 60\n+        node.setmocktime(mocktime)\n+        node1.setmocktime(mocktime)\n+\n+        time.sleep(1)\n+\n+        # make a block. it will leave behind some txns > cache fee rate\n+        # the cache job should have run by now, and we won't rebroadcast\n+        # unless there's a block after time of last cache\n+        node.generate(1)\n+\n+        self.log.info(\"make high fee rate txns\")\n+        high_fee_rate_tx_hshs = []\n+        high_fee_rate = min_relay_fee * 4\n+\n+        for _ in range(10):\n+            tx_hsh = self.make_txn_at_fee_rate(utxos.pop(), outputs, outputs_sum, high_fee_rate, change_address)\n+            high_fee_rate_tx_hshs.append(tx_hsh)\n+\n+        self.log.info(\"make low fee rate txns\")\n+        low_fee_rate_tx_hshs = []\n+        low_fee_rate = min_relay_fee * 2\n+\n+        for _ in range(10):\n+            tx_hsh = self.make_txn_at_fee_rate(utxos.pop(), outputs, outputs_sum, low_fee_rate, change_address)\n+            low_fee_rate_tx_hshs.append(tx_hsh)\n+\n+        # ensure these txns removed from unbroadcast set\n+        # aka that all the GETDATAs have been received before its time to rebroadcast\n+        self.sync_mempools()\n+\n+        self.log.info(\"trigger rebroadcast\")\n+        conn = node.add_p2p_connection(P2PTxInvStore())\n+\n+        mocktime += 300 * 60\n+        node.setmocktime(mocktime)\n+\n+        time.sleep(0.5) # ensure send message thread runs so invs get sent\n+\n+        # `nNextInvSend` delay on `setInventoryTxToSend`\n+        wait_until(lambda: conn.get_invs(), timeout=30)\n+        rebroadcasted_invs = conn.get_invs()\n+\n+        # check that top fee rate txns are rebroadcast\n+        high_fee_rate_tx_ids = [int(txhsh, 16) for txhsh in high_fee_rate_tx_hshs]\n+        for high_tx_id in high_fee_rate_tx_ids:\n+            assert(high_tx_id in rebroadcasted_invs)\n+\n+        # check that low fee rate txns are not rebroadcast\n+        low_fee_rate_tx_ids = [int(txhsh, 16) for txhsh in low_fee_rate_tx_hshs]\n+        for low_tx_id in low_fee_rate_tx_ids:\n+            assert(low_tx_id not in rebroadcasted_invs)\n+\n if __name__ == '__main__':\n     MempoolRebroadcastTest().main()\n "
      }
    ]
  }
]