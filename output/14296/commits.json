[
  {
    "sha": "67d7d67cf32d3652dc1a06a6835c9c3d8b2f38ff",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2N2Q3ZDY3Y2YzMmQzNjUyZGMxYTA2YTY4MzVjOWMzZDhiMmYzOGZm",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-09-23T12:50:47Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-09-23T12:50:47Z"
      },
      "message": "[test] Fix flake8 warnings in tests\n\nFix all flake8 warnings in tests that are about to be updated\nto remove addwitnessaddress",
      "tree": {
        "sha": "4bd331fb7cfc4106e49a2e0647035761d637802e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4bd331fb7cfc4106e49a2e0647035761d637802e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/67d7d67cf32d3652dc1a06a6835c9c3d8b2f38ff",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/67d7d67cf32d3652dc1a06a6835c9c3d8b2f38ff",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/67d7d67cf32d3652dc1a06a6835c9c3d8b2f38ff",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/67d7d67cf32d3652dc1a06a6835c9c3d8b2f38ff/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "920c090f63f4990bf0f3b3d1a6d3d8a8bcd14ba0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/920c090f63f4990bf0f3b3d1a6d3d8a8bcd14ba0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/920c090f63f4990bf0f3b3d1a6d3d8a8bcd14ba0"
      }
    ],
    "stats": {
      "total": 174,
      "additions": 82,
      "deletions": 92
    },
    "files": [
      {
        "sha": "f51d5ca4fe6869676fdd868836fc6f6bb6ffb305",
        "filename": "test/functional/feature_nulldummy.py",
        "status": "modified",
        "additions": 5,
        "deletions": 7,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67d7d67cf32d3652dc1a06a6835c9c3d8b2f38ff/test/functional/feature_nulldummy.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67d7d67cf32d3652dc1a06a6835c9c3d8b2f38ff/test/functional/feature_nulldummy.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_nulldummy.py?ref=67d7d67cf32d3652dc1a06a6835c9c3d8b2f38ff",
        "patch": "@@ -12,15 +12,14 @@\n [Consensus] Check that the new NULLDUMMY rules are not enforced on the 431st block.\n [Policy/Consensus] Check that the new NULLDUMMY rules are enforced on the 432nd block.\n \"\"\"\n+import time\n \n from test_framework.blocktools import create_coinbase, create_block, create_transaction, add_witness_commitment\n from test_framework.messages import CTransaction\n from test_framework.script import CScript\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal, assert_raises_rpc_error, bytes_to_hex_str\n \n-import time\n-\n NULLDUMMY_ERROR = \"non-mandatory-script-verify-flag (Dummy CHECKMULTISIG argument must be zero) (code 64)\"\n \n def trueDummy(tx):\n@@ -53,11 +52,11 @@ def run_test(self):\n         self.wit_address = self.nodes[0].addwitnessaddress(self.address)\n         self.wit_ms_address = self.nodes[0].addmultisigaddress(1, [self.address], '', 'p2sh-segwit')['address']\n \n-        self.coinbase_blocks = self.nodes[0].generate(2) # Block 2\n+        self.coinbase_blocks = self.nodes[0].generate(2)  # Block 2\n         coinbase_txid = []\n         for i in self.coinbase_blocks:\n             coinbase_txid.append(self.nodes[0].getblock(i)['tx'][0])\n-        self.nodes[0].generate(427) # Block 429\n+        self.nodes[0].generate(427)  # Block 429\n         self.lastblockhash = self.nodes[0].getbestblockhash()\n         self.tip = int(\"0x\" + self.lastblockhash, 0)\n         self.lastblockheight = 429\n@@ -82,7 +81,7 @@ def run_test(self):\n \n         self.log.info(\"Test 4: Non-NULLDUMMY base multisig transaction is invalid after activation\")\n         test4tx = create_transaction(self.nodes[0], test2tx.hash, self.address, amount=46)\n-        test6txs=[CTransaction(test4tx)]\n+        test6txs = [CTransaction(test4tx)]\n         trueDummy(test4tx)\n         assert_raises_rpc_error(-26, NULLDUMMY_ERROR, self.nodes[0].sendrawtransaction, bytes_to_hex_str(test4tx.serialize_with_witness()), True)\n         self.block_submit(self.nodes[0], [test4tx])\n@@ -99,8 +98,7 @@ def run_test(self):\n             self.nodes[0].sendrawtransaction(bytes_to_hex_str(i.serialize_with_witness()), True)\n         self.block_submit(self.nodes[0], test6txs, True, True)\n \n-\n-    def block_submit(self, node, txs, witness = False, accept = False):\n+    def block_submit(self, node, txs, witness=False, accept=False):\n         block = create_block(self.tip, create_coinbase(self.lastblockheight + 1), self.lastblocktime + 1)\n         block.nVersion = 4\n         for tx in txs:"
      },
      {
        "sha": "fcf175cb2e23783a693f31ae5a85c4ac8982389a",
        "filename": "test/functional/feature_segwit.py",
        "status": "modified",
        "additions": 51,
        "deletions": 53,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67d7d67cf32d3652dc1a06a6835c9c3d8b2f38ff/test/functional/feature_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67d7d67cf32d3652dc1a06a6835c9c3d8b2f38ff/test/functional/feature_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_segwit.py?ref=67d7d67cf32d3652dc1a06a6835c9c3d8b2f38ff",
        "patch": "@@ -5,6 +5,7 @@\n \"\"\"Test the SegWit changeover logic.\"\"\"\n \n from decimal import Decimal\n+from io import BytesIO\n \n from test_framework.address import (\n     key_to_p2pkh,\n@@ -21,8 +22,6 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal, assert_raises_rpc_error, bytes_to_hex_str, connect_nodes, hex_str_to_bytes, sync_blocks, try_rpc\n \n-from io import BytesIO\n-\n NODE_0 = 0\n NODE_2 = 2\n WIT_V0 = 0\n@@ -91,9 +90,8 @@ def skip_mine(self, node, txid, sign, redeem_script=\"\"):\n     def fail_accept(self, node, error_msg, txid, sign, redeem_script=\"\"):\n         assert_raises_rpc_error(-26, error_msg, send_to_witness, use_p2wsh=1, node=node, utxo=getutxo(txid), pubkey=self.pubkey[0], encode_p2sh=False, amount=Decimal(\"49.998\"), sign=sign, insert_redeem_script=redeem_script)\n \n-\n     def run_test(self):\n-        self.nodes[0].generate(161) #block 161\n+        self.nodes[0].generate(161)  # block 161\n \n         self.log.info(\"Verify sigops are counted in GBT with pre-BIP141 rules before the fork\")\n         txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n@@ -103,18 +101,18 @@ def run_test(self):\n         assert(tmpl['sigoplimit'] == 20000)\n         assert(tmpl['transactions'][0]['hash'] == txid)\n         assert(tmpl['transactions'][0]['sigops'] == 2)\n-        tmpl = self.nodes[0].getblocktemplate({'rules':['segwit']})\n+        tmpl = self.nodes[0].getblocktemplate({'rules': ['segwit']})\n         assert(tmpl['sizelimit'] == 1000000)\n         assert('weightlimit' not in tmpl)\n         assert(tmpl['sigoplimit'] == 20000)\n         assert(tmpl['transactions'][0]['hash'] == txid)\n         assert(tmpl['transactions'][0]['sigops'] == 2)\n-        self.nodes[0].generate(1) #block 162\n+        self.nodes[0].generate(1)  # block 162\n \n         balance_presetup = self.nodes[0].getbalance()\n         self.pubkey = []\n-        p2sh_ids = [] # p2sh_ids[NODE][VER] is an array of txids that spend to a witness version VER pkscript to an address for NODE embedded in p2sh\n-        wit_ids = [] # wit_ids[NODE][VER] is an array of txids that spend to a witness version VER pkscript to an address for NODE via bare witness\n+        p2sh_ids = []  # p2sh_ids[NODE][VER] is an array of txids that spend to a witness version VER pkscript to an address for NODE embedded in p2sh\n+        wit_ids = []  # wit_ids[NODE][VER] is an array of txids that spend to a witness version VER pkscript to an address for NODE via bare witness\n         for i in range(3):\n             newaddress = self.nodes[i].getnewaddress()\n             self.pubkey.append(self.nodes[i].getaddressinfo(newaddress)[\"pubkey\"])\n@@ -139,32 +137,32 @@ def run_test(self):\n                     wit_ids[n][v].append(send_to_witness(v, self.nodes[0], find_spendable_utxo(self.nodes[0], 50), self.pubkey[n], False, Decimal(\"49.999\")))\n                     p2sh_ids[n][v].append(send_to_witness(v, self.nodes[0], find_spendable_utxo(self.nodes[0], 50), self.pubkey[n], True, Decimal(\"49.999\")))\n \n-        self.nodes[0].generate(1) #block 163\n+        self.nodes[0].generate(1)  # block 163\n         sync_blocks(self.nodes)\n \n         # Make sure all nodes recognize the transactions as theirs\n-        assert_equal(self.nodes[0].getbalance(), balance_presetup - 60*50 + 20*Decimal(\"49.999\") + 50)\n-        assert_equal(self.nodes[1].getbalance(), 20*Decimal(\"49.999\"))\n-        assert_equal(self.nodes[2].getbalance(), 20*Decimal(\"49.999\"))\n+        assert_equal(self.nodes[0].getbalance(), balance_presetup - 60 * 50 + 20 * Decimal(\"49.999\") + 50)\n+        assert_equal(self.nodes[1].getbalance(), 20 * Decimal(\"49.999\"))\n+        assert_equal(self.nodes[2].getbalance(), 20 * Decimal(\"49.999\"))\n \n-        self.nodes[0].generate(260) #block 423\n+        self.nodes[0].generate(260)  # block 423\n         sync_blocks(self.nodes)\n \n         self.log.info(\"Verify witness txs are skipped for mining before the fork\")\n-        self.skip_mine(self.nodes[2], wit_ids[NODE_2][WIT_V0][0], True) #block 424\n-        self.skip_mine(self.nodes[2], wit_ids[NODE_2][WIT_V1][0], True) #block 425\n-        self.skip_mine(self.nodes[2], p2sh_ids[NODE_2][WIT_V0][0], True) #block 426\n-        self.skip_mine(self.nodes[2], p2sh_ids[NODE_2][WIT_V1][0], True) #block 427\n+        self.skip_mine(self.nodes[2], wit_ids[NODE_2][WIT_V0][0], True)  # block 424\n+        self.skip_mine(self.nodes[2], wit_ids[NODE_2][WIT_V1][0], True)  # block 425\n+        self.skip_mine(self.nodes[2], p2sh_ids[NODE_2][WIT_V0][0], True)  # block 426\n+        self.skip_mine(self.nodes[2], p2sh_ids[NODE_2][WIT_V1][0], True)  # block 427\n \n         self.log.info(\"Verify unsigned p2sh witness txs without a redeem script are invalid\")\n         self.fail_accept(self.nodes[2], \"mandatory-script-verify-flag\", p2sh_ids[NODE_2][WIT_V0][1], False)\n         self.fail_accept(self.nodes[2], \"mandatory-script-verify-flag\", p2sh_ids[NODE_2][WIT_V1][1], False)\n \n-        self.nodes[2].generate(4) # blocks 428-431\n+        self.nodes[2].generate(4)  # blocks 428-431\n \n         self.log.info(\"Verify previous witness txs skipped for mining can now be mined\")\n         assert_equal(len(self.nodes[2].getrawmempool()), 4)\n-        block = self.nodes[2].generate(1) #block 432 (first block with new rules; 432 = 144 * 3)\n+        block = self.nodes[2].generate(1)  # block 432 (first block with new rules; 432 = 144 * 3)\n         sync_blocks(self.nodes)\n         assert_equal(len(self.nodes[2].getrawmempool()), 0)\n         segwit_tx_list = self.nodes[2].getblock(block[0])[\"tx\"]\n@@ -181,8 +179,8 @@ def run_test(self):\n         self.fail_accept(self.nodes[0], \"mandatory-script-verify-flag\", p2sh_ids[NODE_0][WIT_V1][0], False, witness_script(True, self.pubkey[0]))\n \n         self.log.info(\"Verify block and transaction serialization rpcs return differing serializations depending on rpc serialization flag\")\n-        assert(self.nodes[2].getblock(block[0], False) !=  self.nodes[0].getblock(block[0], False))\n-        assert(self.nodes[1].getblock(block[0], False) ==  self.nodes[2].getblock(block[0], False))\n+        assert(self.nodes[2].getblock(block[0], False) != self.nodes[0].getblock(block[0], False))\n+        assert(self.nodes[1].getblock(block[0], False) == self.nodes[2].getblock(block[0], False))\n         for i in range(len(segwit_tx_list)):\n             tx = FromHex(CTransaction(), self.nodes[2].gettransaction(segwit_tx_list[i])[\"hex\"])\n             assert(self.nodes[2].getrawtransaction(segwit_tx_list[i]) != self.nodes[0].getrawtransaction(segwit_tx_list[i]))\n@@ -198,21 +196,21 @@ def run_test(self):\n         self.fail_accept(self.nodes[2], 'non-mandatory-script-verify-flag (Witness program was passed an empty witness) (code 64)', p2sh_ids[NODE_2][WIT_V1][2], sign=False, redeem_script=witness_script(True, self.pubkey[2]))\n \n         self.log.info(\"Verify default node can now use witness txs\")\n-        self.success_mine(self.nodes[0], wit_ids[NODE_0][WIT_V0][0], True) #block 432\n-        self.success_mine(self.nodes[0], wit_ids[NODE_0][WIT_V1][0], True) #block 433\n-        self.success_mine(self.nodes[0], p2sh_ids[NODE_0][WIT_V0][0], True) #block 434\n-        self.success_mine(self.nodes[0], p2sh_ids[NODE_0][WIT_V1][0], True) #block 435\n+        self.success_mine(self.nodes[0], wit_ids[NODE_0][WIT_V0][0], True)  # block 432\n+        self.success_mine(self.nodes[0], wit_ids[NODE_0][WIT_V1][0], True)  # block 433\n+        self.success_mine(self.nodes[0], p2sh_ids[NODE_0][WIT_V0][0], True)  # block 434\n+        self.success_mine(self.nodes[0], p2sh_ids[NODE_0][WIT_V1][0], True)  # block 435\n \n         self.log.info(\"Verify sigops are counted in GBT with BIP141 rules after the fork\")\n         txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n-        tmpl = self.nodes[0].getblocktemplate({'rules':['segwit']})\n+        tmpl = self.nodes[0].getblocktemplate({'rules': ['segwit']})\n         assert(tmpl['sizelimit'] >= 3999577)  # actual maximum size is lower due to minimum mandatory non-witness data\n         assert(tmpl['weightlimit'] == 4000000)\n         assert(tmpl['sigoplimit'] == 80000)\n         assert(tmpl['transactions'][0]['txid'] == txid)\n         assert(tmpl['transactions'][0]['sigops'] == 8)\n \n-        self.nodes[0].generate(1) # Mine a block to clear the gbt cache\n+        self.nodes[0].generate(1)  # Mine a block to clear the gbt cache\n \n         self.log.info(\"Non-segwit miners are able to use GBT response after activation.\")\n         # Create a 3-tx chain: tx1 (non-segwit input, paying to a segwit output) ->\n@@ -222,7 +220,7 @@ def run_test(self):\n         txid1 = send_to_witness(1, self.nodes[0], find_spendable_utxo(self.nodes[0], 50), self.pubkey[0], False, Decimal(\"49.996\"))\n         hex_tx = self.nodes[0].gettransaction(txid)['hex']\n         tx = FromHex(CTransaction(), hex_tx)\n-        assert(tx.wit.is_null()) # This should not be a segwit input\n+        assert(tx.wit.is_null())  # This should not be a segwit input\n         assert(txid1 in self.nodes[0].getrawmempool())\n \n         # Now create tx2, which will spend from txid1.\n@@ -247,13 +245,13 @@ def run_test(self):\n         template = self.nodes[0].getblocktemplate()\n \n         # Check that tx1 is the only transaction of the 3 in the template.\n-        template_txids = [ t['txid'] for t in template['transactions'] ]\n+        template_txids = [t['txid'] for t in template['transactions']]\n         assert(txid2 not in template_txids and txid3 not in template_txids)\n         assert(txid1 in template_txids)\n \n         # Check that running with segwit support results in all 3 being included.\n         template = self.nodes[0].getblocktemplate({\"rules\": [\"segwit\"]})\n-        template_txids = [ t['txid'] for t in template['transactions'] ]\n+        template_txids = [t['txid'] for t in template['transactions']]\n         assert(txid1 in template_txids)\n         assert(txid2 in template_txids)\n         assert(txid3 in template_txids)\n@@ -268,22 +266,22 @@ def run_test(self):\n \n         # Some public keys to be used later\n         pubkeys = [\n-            \"0363D44AABD0F1699138239DF2F042C3282C0671CC7A76826A55C8203D90E39242\", # cPiM8Ub4heR9NBYmgVzJQiUH1if44GSBGiqaeJySuL2BKxubvgwb\n-            \"02D3E626B3E616FC8662B489C123349FECBFC611E778E5BE739B257EAE4721E5BF\", # cPpAdHaD6VoYbW78kveN2bsvb45Q7G5PhaPApVUGwvF8VQ9brD97\n-            \"04A47F2CBCEFFA7B9BCDA184E7D5668D3DA6F9079AD41E422FA5FD7B2D458F2538A62F5BD8EC85C2477F39650BD391EA6250207065B2A81DA8B009FC891E898F0E\", # 91zqCU5B9sdWxzMt1ca3VzbtVm2YM6Hi5Rxn4UDtxEaN9C9nzXV\n-            \"02A47F2CBCEFFA7B9BCDA184E7D5668D3DA6F9079AD41E422FA5FD7B2D458F2538\", # cPQFjcVRpAUBG8BA9hzr2yEzHwKoMgLkJZBBtK9vJnvGJgMjzTbd\n-            \"036722F784214129FEB9E8129D626324F3F6716555B603FFE8300BBCB882151228\", # cQGtcm34xiLjB1v7bkRa4V3aAc9tS2UTuBZ1UnZGeSeNy627fN66\n-            \"0266A8396EE936BF6D99D17920DB21C6C7B1AB14C639D5CD72B300297E416FD2EC\", # cTW5mR5M45vHxXkeChZdtSPozrFwFgmEvTNnanCW6wrqwaCZ1X7K\n-            \"0450A38BD7F0AC212FEBA77354A9B036A32E0F7C81FC4E0C5ADCA7C549C4505D2522458C2D9AE3CEFD684E039194B72C8A10F9CB9D4764AB26FCC2718D421D3B84\", # 92h2XPssjBpsJN5CqSP7v9a7cf2kgDunBC6PDFwJHMACM1rrVBJ\n+            \"0363D44AABD0F1699138239DF2F042C3282C0671CC7A76826A55C8203D90E39242\",  # cPiM8Ub4heR9NBYmgVzJQiUH1if44GSBGiqaeJySuL2BKxubvgwb\n+            \"02D3E626B3E616FC8662B489C123349FECBFC611E778E5BE739B257EAE4721E5BF\",  # cPpAdHaD6VoYbW78kveN2bsvb45Q7G5PhaPApVUGwvF8VQ9brD97\n+            \"04A47F2CBCEFFA7B9BCDA184E7D5668D3DA6F9079AD41E422FA5FD7B2D458F2538A62F5BD8EC85C2477F39650BD391EA6250207065B2A81DA8B009FC891E898F0E\",  # 91zqCU5B9sdWxzMt1ca3VzbtVm2YM6Hi5Rxn4UDtxEaN9C9nzXV\n+            \"02A47F2CBCEFFA7B9BCDA184E7D5668D3DA6F9079AD41E422FA5FD7B2D458F2538\",  # cPQFjcVRpAUBG8BA9hzr2yEzHwKoMgLkJZBBtK9vJnvGJgMjzTbd\n+            \"036722F784214129FEB9E8129D626324F3F6716555B603FFE8300BBCB882151228\",  # cQGtcm34xiLjB1v7bkRa4V3aAc9tS2UTuBZ1UnZGeSeNy627fN66\n+            \"0266A8396EE936BF6D99D17920DB21C6C7B1AB14C639D5CD72B300297E416FD2EC\",  # cTW5mR5M45vHxXkeChZdtSPozrFwFgmEvTNnanCW6wrqwaCZ1X7K\n+            \"0450A38BD7F0AC212FEBA77354A9B036A32E0F7C81FC4E0C5ADCA7C549C4505D2522458C2D9AE3CEFD684E039194B72C8A10F9CB9D4764AB26FCC2718D421D3B84\",  # 92h2XPssjBpsJN5CqSP7v9a7cf2kgDunBC6PDFwJHMACM1rrVBJ\n         ]\n \n         # Import a compressed key and an uncompressed key, generate some multisig addresses\n         self.nodes[0].importprivkey(\"92e6XLo5jVAVwrQKPNTs93oQco8f8sDNBcpv73Dsrs397fQtFQn\")\n         uncompressed_spendable_address = [\"mvozP4UwyGD2mGZU4D2eMvMLPB9WkMmMQu\"]\n         self.nodes[0].importprivkey(\"cNC8eQ5dg3mFAVePDX4ddmPYpPbw41r9bm2jd1nLJT77e6RrzTRR\")\n         compressed_spendable_address = [\"mmWQubrDomqpgSYekvsU7HWEVjLFHAakLe\"]\n-        assert ((self.nodes[0].getaddressinfo(uncompressed_spendable_address[0])['iscompressed'] == False))\n-        assert ((self.nodes[0].getaddressinfo(compressed_spendable_address[0])['iscompressed'] == True))\n+        assert not self.nodes[0].getaddressinfo(uncompressed_spendable_address[0])['iscompressed']\n+        assert self.nodes[0].getaddressinfo(compressed_spendable_address[0])['iscompressed']\n \n         self.nodes[0].importpubkey(pubkeys[0])\n         compressed_solvable_address = [key_to_p2pkh(pubkeys[0])]\n@@ -394,9 +392,9 @@ def run_test(self):\n         p2wshop1 = CScript([OP_0, sha256(op1)])\n         unsolvable_after_importaddress.append(unsolvablep2pkh)\n         unsolvable_after_importaddress.append(unsolvablep2wshp2pkh)\n-        unsolvable_after_importaddress.append(op1) # OP_1 will be imported as script\n+        unsolvable_after_importaddress.append(op1)  # OP_1 will be imported as script\n         unsolvable_after_importaddress.append(p2wshop1)\n-        unseen_anytime.append(op0) # OP_0 will be imported as P2SH address with no script provided\n+        unseen_anytime.append(op0)  # OP_0 will be imported as P2SH address with no script provided\n         unsolvable_after_importaddress.append(p2shop0)\n \n         spendable_txid = []\n@@ -432,8 +430,8 @@ def run_test(self):\n             # exceptions and continue.\n             try_rpc(-4, \"The wallet already contains the private key for this address or script\", self.nodes[0].importaddress, i, \"\", False, True)\n \n-        self.nodes[0].importaddress(script_to_p2sh(op0)) # import OP_0 as address only\n-        self.nodes[0].importaddress(multisig_without_privkey_address) # Test multisig_without_privkey\n+        self.nodes[0].importaddress(script_to_p2sh(op0))  # import OP_0 as address only\n+        self.nodes[0].importaddress(multisig_without_privkey_address)  # Test multisig_without_privkey\n \n         spendable_txid.append(self.mine_and_test_listunspent(spendable_anytime + spendable_after_importaddress, 2))\n         solvable_txid.append(self.mine_and_test_listunspent(solvable_anytime + solvable_after_importaddress, 1))\n@@ -471,7 +469,7 @@ def run_test(self):\n         uncompressed_solvable_address = [key_to_p2pkh(pubkeys[6])]\n \n         spendable_after_addwitnessaddress = []      # These outputs should be seen after importaddress\n-        solvable_after_addwitnessaddress=[]         # These outputs should be seen after importaddress but not spendable\n+        solvable_after_addwitnessaddress = []       # These outputs should be seen after importaddress but not spendable\n         unseen_anytime = []                         # These outputs should never be seen\n         solvable_anytime = []                       # These outputs should be solvable after importpubkey\n         unseen_anytime = []                         # These outputs should never be seen\n@@ -532,7 +530,7 @@ def run_test(self):\n \n         # after importaddress it should pass addwitnessaddress\n         v = self.nodes[0].getaddressinfo(compressed_solvable_address[1])\n-        self.nodes[0].importaddress(v['hex'],\"\",False,True)\n+        self.nodes[0].importaddress(v['hex'], \"\", False, True)\n         for i in compressed_spendable_address + compressed_solvable_address + premature_witaddress:\n             witaddress = self.nodes[0].addwitnessaddress(i)\n             assert_equal(witaddress, self.nodes[0].addwitnessaddress(witaddress))\n@@ -542,8 +540,8 @@ def run_test(self):\n         self.mine_and_test_listunspent(unseen_anytime, 0)\n \n         # Check that createrawtransaction/decoderawtransaction with non-v0 Bech32 works\n-        v1_addr = program_to_witness(1, [3,5])\n-        v1_tx = self.nodes[0].createrawtransaction([getutxo(spendable_txid[0])],{v1_addr: 1})\n+        v1_addr = program_to_witness(1, [3, 5])\n+        v1_tx = self.nodes[0].createrawtransaction([getutxo(spendable_txid[0])], {v1_addr: 1})\n         v1_decoded = self.nodes[1].decoderawtransaction(v1_tx)\n         assert_equal(v1_decoded['vout'][0]['scriptPubKey']['addresses'][0], v1_addr)\n         assert_equal(v1_decoded['vout'][0]['scriptPubKey']['hex'], \"51020305\")\n@@ -586,7 +584,7 @@ def run_test(self):\n     def mine_and_test_listunspent(self, script_list, ismine):\n         utxo = find_spendable_utxo(self.nodes[0], 50)\n         tx = CTransaction()\n-        tx.vin.append(CTxIn(COutPoint(int('0x'+utxo['txid'],0), utxo['vout'])))\n+        tx.vin.append(CTxIn(COutPoint(int('0x' + utxo['txid'], 0), utxo['vout'])))\n         for i in script_list:\n             tx.vout.append(CTxOut(10000000, i))\n         tx.rehash()\n@@ -599,7 +597,7 @@ def mine_and_test_listunspent(self, script_list, ismine):\n         for i in self.nodes[0].listunspent():\n             if (i['txid'] == txid):\n                 watchcount += 1\n-                if (i['spendable'] == True):\n+                if i['spendable']:\n                     spendcount += 1\n         if (ismine == 2):\n             assert_equal(spendcount, len(script_list))\n@@ -610,14 +608,14 @@ def mine_and_test_listunspent(self, script_list, ismine):\n             assert_equal(watchcount, 0)\n         return txid\n \n-    def p2sh_address_to_script(self,v):\n+    def p2sh_address_to_script(self, v):\n         bare = CScript(hex_str_to_bytes(v['hex']))\n         p2sh = CScript(hex_str_to_bytes(v['scriptPubKey']))\n         p2wsh = CScript([OP_0, sha256(bare)])\n         p2sh_p2wsh = CScript([OP_HASH160, hash160(p2wsh), OP_EQUAL])\n         return([bare, p2sh, p2wsh, p2sh_p2wsh])\n \n-    def p2pkh_address_to_script(self,v):\n+    def p2pkh_address_to_script(self, v):\n         pubkey = hex_str_to_bytes(v['pubkey'])\n         p2wpkh = CScript([OP_0, hash160(pubkey)])\n         p2sh_p2wpkh = CScript([OP_HASH160, hash160(p2wpkh), OP_EQUAL])\n@@ -631,15 +629,15 @@ def p2pkh_address_to_script(self,v):\n         p2sh_p2wsh_p2pkh = CScript([OP_HASH160, hash160(p2wsh_p2pkh), OP_EQUAL])\n         return [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh]\n \n-    def create_and_mine_tx_from_txids(self, txids, success = True):\n+    def create_and_mine_tx_from_txids(self, txids, success=True):\n         tx = CTransaction()\n         for i in txids:\n             txtmp = CTransaction()\n             txraw = self.nodes[0].getrawtransaction(i)\n             f = BytesIO(hex_str_to_bytes(txraw))\n             txtmp.deserialize(f)\n             for j in range(len(txtmp.vout)):\n-                tx.vin.append(CTxIn(COutPoint(int('0x'+i,0), j)))\n+                tx.vin.append(CTxIn(COutPoint(int('0x' + i, 0), j)))\n         tx.vout.append(CTxOut(0, CScript()))\n         tx.rehash()\n         signresults = self.nodes[0].signrawtransactionwithwallet(bytes_to_hex_str(tx.serialize_without_witness()))['hex']"
      },
      {
        "sha": "600b97cd116808549f83d0bf2fd14c3d8b9be417",
        "filename": "test/functional/p2p_compactblocks.py",
        "status": "modified",
        "additions": 15,
        "deletions": 17,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67d7d67cf32d3652dc1a06a6835c9c3d8b2f38ff/test/functional/p2p_compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67d7d67cf32d3652dc1a06a6835c9c3d8b2f38ff/test/functional/p2p_compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_compactblocks.py?ref=67d7d67cf32d3652dc1a06a6835c9c3d8b2f38ff",
        "patch": "@@ -7,7 +7,6 @@\n Version 1 compact blocks are pre-segwit (txids)\n Version 2 compact blocks are post-segwit (wtxids)\n \"\"\"\n-\n from decimal import Decimal\n import random\n \n@@ -189,7 +188,7 @@ def check_announcement_of_new_block(node, peer, predicate):\n \n         # Now try a SENDCMPCT message with too-high version\n         sendcmpct = msg_sendcmpct()\n-        sendcmpct.version = preferred_version+1\n+        sendcmpct.version = preferred_version + 1\n         sendcmpct.announce = True\n         test_node.send_and_ping(sendcmpct)\n         check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" not in p.last_message)\n@@ -220,7 +219,7 @@ def check_announcement_of_new_block(node, peer, predicate):\n         check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" in p.last_message)\n \n         # Try one more time, after sending a version-1, announce=false message.\n-        sendcmpct.version = preferred_version-1\n+        sendcmpct.version = preferred_version - 1\n         sendcmpct.announce = False\n         test_node.send_and_ping(sendcmpct)\n         check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" in p.last_message)\n@@ -234,7 +233,7 @@ def check_announcement_of_new_block(node, peer, predicate):\n         if old_node is not None:\n             # Verify that a peer using an older protocol version can receive\n             # announcements from this node.\n-            sendcmpct.version = preferred_version-1\n+            sendcmpct.version = preferred_version - 1\n             sendcmpct.announce = True\n             old_node.send_and_ping(sendcmpct)\n             # Header sync\n@@ -267,7 +266,7 @@ def test_compactblock_construction(self, node, test_node, version, use_witness_a\n             # a witness address.\n             address = node.addwitnessaddress(address)\n             value_to_send = node.getbalance()\n-            node.sendtoaddress(address, satoshi_round(value_to_send-Decimal(0.1)))\n+            node.sendtoaddress(address, satoshi_round(value_to_send - Decimal(0.1)))\n             node.generate(1)\n \n         segwit_tx_generated = False\n@@ -279,7 +278,7 @@ def test_compactblock_construction(self, node, test_node, version, use_witness_a\n                 segwit_tx_generated = True\n \n         if use_witness_address:\n-            assert(segwit_tx_generated) # check that our test is not broken\n+            assert segwit_tx_generated  # check that our test is not broken\n \n         # Wait until we've seen the block announcement for the resulting tip\n         tip = int(node.getbestblockhash(), 16)\n@@ -403,8 +402,7 @@ def test_compactblock_requests(self, node, test_node, version, segwit):\n             coinbase_hash = block.vtx[0].sha256\n             if version == 2:\n                 coinbase_hash = block.vtx[0].calc_sha256(True)\n-            comp_block.shortids = [\n-                    calculate_shortid(k0, k1, coinbase_hash) ]\n+            comp_block.shortids = [calculate_shortid(k0, k1, coinbase_hash)]\n             test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n             assert_equal(int(node.getbestblockhash(), 16), block.hashPrevBlock)\n             # Expect a getblocktxn message.\n@@ -443,7 +441,7 @@ def build_block_with_transactions(self, node, utxo, num_transactions):\n     # node needs, and that responding to them causes the block to be\n     # reconstructed.\n     def test_getblocktxn_requests(self, node, test_node, version):\n-        with_witness = (version==2)\n+        with_witness = (version == 2)\n \n         def test_getblocktxn_response(compact_block, peer, expected_result):\n             msg = msg_cmpctblock(compact_block.to_p2p())\n@@ -470,7 +468,7 @@ def test_tip_after_message(node, peer, msg, tip):\n \n         msg_bt = msg_blocktxn()\n         if with_witness:\n-            msg_bt = msg_witness_blocktxn() # serialize with witnesses\n+            msg_bt = msg_witness_blocktxn()  # serialize with witnesses\n         msg_bt.block_transactions = BlockTransactions(block.sha256, block.vtx[1:])\n         test_tip_after_message(node, test_node, msg_bt, block.sha256)\n \n@@ -560,7 +558,7 @@ def test_incorrect_blocktxn_response(self, node, test_node, version):\n         # verifying that the block isn't marked bad permanently. This is good\n         # enough for now.\n         msg = msg_blocktxn()\n-        if version==2:\n+        if version == 2:\n             msg = msg_witness_blocktxn()\n         msg.block_transactions = BlockTransactions(block.sha256, [block.vtx[5]] + block.vtx[7:])\n         test_node.send_and_ping(msg)\n@@ -571,11 +569,11 @@ def test_incorrect_blocktxn_response(self, node, test_node, version):\n         # We should receive a getdata request\n         wait_until(lambda: \"getdata\" in test_node.last_message, timeout=10, lock=mininode_lock)\n         assert_equal(len(test_node.last_message[\"getdata\"].inv), 1)\n-        assert(test_node.last_message[\"getdata\"].inv[0].type == 2 or test_node.last_message[\"getdata\"].inv[0].type == 2|MSG_WITNESS_FLAG)\n+        assert(test_node.last_message[\"getdata\"].inv[0].type == 2 or test_node.last_message[\"getdata\"].inv[0].type == 2 | MSG_WITNESS_FLAG)\n         assert_equal(test_node.last_message[\"getdata\"].inv[0].hash, block.sha256)\n \n         # Deliver the block\n-        if version==2:\n+        if version == 2:\n             test_node.send_and_ping(msg_witness_block(block))\n         else:\n             test_node.send_and_ping(msg_block(block))\n@@ -655,7 +653,7 @@ def test_compactblocks_not_at_tip(self, node, test_node):\n \n         # Generate an old compactblock, and verify that it's not accepted.\n         cur_height = node.getblockcount()\n-        hashPrevBlock = int(node.getblockhash(cur_height-5), 16)\n+        hashPrevBlock = int(node.getblockhash(cur_height - 5), 16)\n         block = self.build_block_on_tip(node)\n         block.hashPrevBlock = hashPrevBlock\n         block.solve()\n@@ -684,7 +682,7 @@ def test_compactblocks_not_at_tip(self, node, test_node):\n             assert \"blocktxn\" not in test_node.last_message\n \n     def activate_segwit(self, node):\n-        node.generate(144*3)\n+        node.generate(144 * 3)\n         assert_equal(get_bip9_status(node, \"segwit\")[\"status\"], 'active')\n \n     def test_end_to_end_block_relay(self, node, listeners):\n@@ -780,7 +778,7 @@ def announce_cmpct_block(node, peer):\n             delivery_peer.send_message(msg_tx(tx))\n         delivery_peer.sync_with_ping()\n \n-        cmpct_block.prefilled_txn[0].tx.wit.vtxinwit = [ CTxInWitness() ]\n+        cmpct_block.prefilled_txn[0].tx.wit.vtxinwit = [CTxInWitness()]\n         cmpct_block.prefilled_txn[0].tx.wit.vtxinwit[0].scriptWitness.stack = [ser_uint256(0)]\n \n         cmpct_block.use_witness = True\n@@ -886,7 +884,7 @@ def run_test(self):\n         self.log.info(\"Syncing nodes...\")\n         assert(self.nodes[0].getbestblockhash() != self.nodes[1].getbestblockhash())\n         while (self.nodes[0].getblockcount() > self.nodes[1].getblockcount()):\n-            block_hash = self.nodes[0].getblockhash(self.nodes[1].getblockcount()+1)\n+            block_hash = self.nodes[0].getblockhash(self.nodes[1].getblockcount() + 1)\n             self.nodes[1].submitblock(self.nodes[0].getblock(block_hash, False))\n         assert_equal(self.nodes[0].getbestblockhash(), self.nodes[1].getbestblockhash())\n "
      },
      {
        "sha": "b4580ac74adda00df768383ac9dbc66d550218ee",
        "filename": "test/functional/wallet_bumpfee.py",
        "status": "modified",
        "additions": 6,
        "deletions": 9,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67d7d67cf32d3652dc1a06a6835c9c3d8b2f38ff/test/functional/wallet_bumpfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67d7d67cf32d3652dc1a06a6835c9c3d8b2f38ff/test/functional/wallet_bumpfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_bumpfee.py?ref=67d7d67cf32d3652dc1a06a6835c9c3d8b2f38ff",
        "patch": "@@ -13,20 +13,17 @@\n added in the future, they should try to follow the same convention and not\n make assumptions about execution order.\n \"\"\"\n-\n from decimal import Decimal\n+import io\n \n from test_framework.blocktools import add_witness_commitment, create_block, create_coinbase, send_to_witness\n from test_framework.messages import BIP125_SEQUENCE_NUMBER, CTransaction\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal, assert_greater_than, assert_raises_rpc_error, bytes_to_hex_str, connect_nodes_bi, hex_str_to_bytes, sync_mempools\n \n-import io\n-\n WALLET_PASSPHRASE = \"test\"\n WALLET_PASSPHRASE_TIMEOUT = 3600\n \n-\n class BumpFeeTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 2\n@@ -157,7 +154,7 @@ def test_notmine_bumpfee_fails(rbf_node, peer_node, dest_address):\n     signedtx = peer_node.signrawtransactionwithwallet(signedtx[\"hex\"])\n     rbfid = rbf_node.sendrawtransaction(signedtx[\"hex\"])\n     assert_raises_rpc_error(-4, \"Transaction contains inputs that don't belong to this wallet\",\n-                          rbf_node.bumpfee, rbfid)\n+                            rbf_node.bumpfee, rbfid)\n \n \n def test_bumpfee_with_descendant_fails(rbf_node, rbf_node_address, dest_address):\n@@ -187,11 +184,11 @@ def test_dust_to_fee(rbf_node, dest_address):\n     # (32-byte p2sh-pwpkh output size + 148 p2pkh spend estimate) * 10k(discard_rate) / 1000 = 1800\n     # P2SH outputs are slightly \"over-discarding\" due to the IsDust calculation assuming it will\n     # be spent as a P2PKH.\n-    bumped_tx = rbf_node.bumpfee(rbfid, {\"totalFee\": 50000-1800})\n+    bumped_tx = rbf_node.bumpfee(rbfid, {\"totalFee\": 50000 - 1800})\n     full_bumped_tx = rbf_node.getrawtransaction(bumped_tx[\"txid\"], 1)\n     assert_equal(bumped_tx[\"fee\"], Decimal(\"0.00050000\"))\n     assert_equal(len(fulltx[\"vout\"]), 2)\n-    assert_equal(len(full_bumped_tx[\"vout\"]), 1)  #change output is eliminated\n+    assert_equal(len(full_bumped_tx[\"vout\"]), 1)  # change output is eliminated\n \n \n def test_settxfee(rbf_node, dest_address):\n@@ -222,7 +219,7 @@ def test_rebumping_not_replaceable(rbf_node, dest_address):\n     rbfid = spend_one_input(rbf_node, dest_address)\n     bumped = rbf_node.bumpfee(rbfid, {\"totalFee\": 10000, \"replaceable\": False})\n     assert_raises_rpc_error(-4, \"Transaction is not BIP 125 replaceable\", rbf_node.bumpfee, bumped[\"txid\"],\n-                          {\"totalFee\": 20000})\n+                            {\"totalFee\": 20000})\n \n \n def test_unconfirmed_not_spendable(rbf_node, rbf_node_address):\n@@ -276,7 +273,7 @@ def test_locked_wallet_fails(rbf_node, dest_address):\n     rbfid = spend_one_input(rbf_node, dest_address)\n     rbf_node.walletlock()\n     assert_raises_rpc_error(-13, \"Please enter the wallet passphrase with walletpassphrase first.\",\n-                          rbf_node.bumpfee, rbfid)\n+                            rbf_node.bumpfee, rbfid)\n \n \n def spend_one_input(node, dest_address):"
      },
      {
        "sha": "643289a8c7b007dd3bb5d4e528bfa54c05cdb37a",
        "filename": "test/functional/wallet_dump.py",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67d7d67cf32d3652dc1a06a6835c9c3d8b2f38ff/test/functional/wallet_dump.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67d7d67cf32d3652dc1a06a6835c9c3d8b2f38ff/test/functional/wallet_dump.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_dump.py?ref=67d7d67cf32d3652dc1a06a6835c9c3d8b2f38ff",
        "patch": "@@ -3,7 +3,6 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the dumpwallet RPC.\"\"\"\n-\n import os\n \n from test_framework.test_framework import BitcoinTestFramework\n@@ -107,9 +106,9 @@ def run_test(self):\n         # wallet, we will expect 21 addresses in the dump\n         test_addr_count = 20\n         addrs = []\n-        for i in range(0,test_addr_count):\n+        for i in range(0, test_addr_count):\n             addr = self.nodes[0].getnewaddress()\n-            vaddr= self.nodes[0].getaddressinfo(addr) #required to get hd keypath\n+            vaddr = self.nodes[0].getaddressinfo(addr)  # required to get hd keypath\n             addrs.append(vaddr)\n         # Should be a no-op:\n         self.nodes[0].keypoolrefill()\n@@ -131,7 +130,7 @@ def run_test(self):\n         assert_equal(found_addr_rsv, 90 * 2)  # 90 keys plus 100% internal keys\n         assert_equal(witness_addr_ret, witness_addr)  # p2sh-p2wsh address added to the first key\n \n-        #encrypt wallet, restart, unlock and dump\n+        # encrypt wallet, restart, unlock and dump\n         self.nodes[0].encryptwallet('test')\n         self.nodes[0].walletpassphrase('test', 10)\n         # Should be a no-op:\n@@ -155,13 +154,13 @@ def run_test(self):\n \n         # Make sure the address is not IsMine before import\n         result = self.nodes[0].getaddressinfo(multisig_addr)\n-        assert(result['ismine'] == False)\n+        assert not result['ismine']\n \n         self.nodes[0].importwallet(wallet_unenc_dump)\n \n         # Now check IsMine is true\n         result = self.nodes[0].getaddressinfo(multisig_addr)\n-        assert(result['ismine'] == True)\n+        assert result['ismine']\n \n if __name__ == '__main__':\n     WalletDumpTest().main()"
      }
    ]
  },
  {
    "sha": "bdefc9705d7ea5ba3c0e9b7048c4181f43d8be46",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiZGVmYzk3MDVkN2VhNWJhM2MwZTliNzA0OGM0MTgxZjQzZDhiZTQ2",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-09-22T19:32:53Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-09-23T12:50:52Z"
      },
      "message": "[tests] Remove deprecated addwitnessaddress call from feature_nulldummy\n\naddwitnessaddress is deprecated. Replace the call to addwitnessaddress\nwith a call to getnewaddress(address_type='p2sh-segwit')",
      "tree": {
        "sha": "7b2c5c6e86b74278494bfaba0071eb1eb091eb1f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7b2c5c6e86b74278494bfaba0071eb1eb091eb1f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bdefc9705d7ea5ba3c0e9b7048c4181f43d8be46",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bdefc9705d7ea5ba3c0e9b7048c4181f43d8be46",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bdefc9705d7ea5ba3c0e9b7048c4181f43d8be46",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bdefc9705d7ea5ba3c0e9b7048c4181f43d8be46/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "67d7d67cf32d3652dc1a06a6835c9c3d8b2f38ff",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/67d7d67cf32d3652dc1a06a6835c9c3d8b2f38ff",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/67d7d67cf32d3652dc1a06a6835c9c3d8b2f38ff"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 2,
      "deletions": 2
    },
    "files": [
      {
        "sha": "eb76089d9c49d65754f4416f830bef5107af98ac",
        "filename": "test/functional/feature_nulldummy.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdefc9705d7ea5ba3c0e9b7048c4181f43d8be46/test/functional/feature_nulldummy.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdefc9705d7ea5ba3c0e9b7048c4181f43d8be46/test/functional/feature_nulldummy.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_nulldummy.py?ref=bdefc9705d7ea5ba3c0e9b7048c4181f43d8be46",
        "patch": "@@ -41,15 +41,15 @@ def set_test_params(self):\n         self.setup_clean_chain = True\n         # This script tests NULLDUMMY activation, which is part of the 'segwit' deployment, so we go through\n         # normal segwit activation here (and don't use the default always-on behaviour).\n-        self.extra_args = [['-whitelist=127.0.0.1', '-vbparams=segwit:0:999999999999', '-addresstype=legacy', \"-deprecatedrpc=addwitnessaddress\"]]\n+        self.extra_args = [['-whitelist=127.0.0.1', '-vbparams=segwit:0:999999999999', '-addresstype=legacy']]\n \n     def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()\n \n     def run_test(self):\n         self.address = self.nodes[0].getnewaddress()\n         self.ms_address = self.nodes[0].addmultisigaddress(1, [self.address])['address']\n-        self.wit_address = self.nodes[0].addwitnessaddress(self.address)\n+        self.wit_address = self.nodes[0].getnewaddress(address_type='p2sh-segwit')\n         self.wit_ms_address = self.nodes[0].addmultisigaddress(1, [self.address], '', 'p2sh-segwit')['address']\n \n         self.coinbase_blocks = self.nodes[0].generate(2)  # Block 2"
      }
    ]
  },
  {
    "sha": "3cf77f0b3ee0862e87c98db5363b4da83f9089e0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozY2Y3N2YwYjNlZTA4NjJlODdjOThkYjUzNjNiNGRhODNmOTA4OWUw",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-09-22T19:34:25Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-09-23T12:51:55Z"
      },
      "message": "[tests] Remove deprecated addwitnessaddress call from wallet_dump.py\n\naddwitnessaddress is deprecated. Remove the call to that RPC from\nwallet_dump.py and improve testing of all types of address (legacy,\np2sh-segwit and bech32)",
      "tree": {
        "sha": "c0d9d383e0c55759ae1651f3b433b8c48b4876e0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c0d9d383e0c55759ae1651f3b433b8c48b4876e0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3cf77f0b3ee0862e87c98db5363b4da83f9089e0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3cf77f0b3ee0862e87c98db5363b4da83f9089e0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3cf77f0b3ee0862e87c98db5363b4da83f9089e0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3cf77f0b3ee0862e87c98db5363b4da83f9089e0/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bdefc9705d7ea5ba3c0e9b7048c4181f43d8be46",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bdefc9705d7ea5ba3c0e9b7048c4181f43d8be46",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bdefc9705d7ea5ba3c0e9b7048c4181f43d8be46"
      }
    ],
    "stats": {
      "total": 76,
      "additions": 41,
      "deletions": 35
    },
    "files": [
      {
        "sha": "20cb816ee81da1af934f5a19ec0e2ee27c25e434",
        "filename": "test/functional/wallet_dump.py",
        "status": "modified",
        "additions": 41,
        "deletions": 35,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3cf77f0b3ee0862e87c98db5363b4da83f9089e0/test/functional/wallet_dump.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3cf77f0b3ee0862e87c98db5363b4da83f9089e0/test/functional/wallet_dump.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_dump.py?ref=3cf77f0b3ee0862e87c98db5363b4da83f9089e0",
        "patch": "@@ -18,11 +18,12 @@ def read_dump(file_name, addrs, script_addrs, hd_master_addr_old):\n     Also check that the old hd_master is inactive\n     \"\"\"\n     with open(file_name, encoding='utf8') as inputfile:\n-        found_addr = 0\n+        found_legacy_addr = 0\n+        found_p2sh_segwit_addr = 0\n+        found_bech32_addr = 0\n         found_script_addr = 0\n         found_addr_chg = 0\n         found_addr_rsv = 0\n-        witness_addr_ret = None\n         hd_master_addr_ret = None\n         for line in inputfile:\n             # only read non comment lines\n@@ -59,14 +60,14 @@ def read_dump(file_name, addrs, script_addrs, hd_master_addr_old):\n                 # count key types\n                 for addrObj in addrs:\n                     if addrObj['address'] == addr.split(\",\")[0] and addrObj['hdkeypath'] == keypath and keytype == \"label=\":\n-                        # a labeled entry in the wallet should contain both a native address\n-                        # and the p2sh-p2wpkh address that was added at wallet setup\n-                        if len(addr.split(\",\")) == 2:\n-                            addr_list = addr.split(\",\")\n-                            # the entry should be of the first key in the wallet\n-                            assert_equal(addrs[0]['address'], addr_list[0])\n-                            witness_addr_ret = addr_list[1]\n-                        found_addr += 1\n+                        if addr.startswith('m') or addr.startswith('n'):\n+                            # P2PKH address\n+                            found_legacy_addr += 1\n+                        elif addr.startswith('2'):\n+                            # P2SH-segwit address\n+                            found_p2sh_segwit_addr += 1\n+                        elif addr.startswith('bcrt1'):\n+                            found_bech32_addr += 1\n                         break\n                     elif keytype == \"change=1\":\n                         found_addr_chg += 1\n@@ -81,13 +82,13 @@ def read_dump(file_name, addrs, script_addrs, hd_master_addr_old):\n                         found_script_addr += 1\n                         break\n \n-        return found_addr, found_script_addr, found_addr_chg, found_addr_rsv, hd_master_addr_ret, witness_addr_ret\n+        return found_legacy_addr, found_p2sh_segwit_addr, found_bech32_addr, found_script_addr, found_addr_chg, found_addr_rsv, hd_master_addr_ret\n \n \n class WalletDumpTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 1\n-        self.extra_args = [[\"-keypool=90\", \"-addresstype=legacy\", \"-deprecatedrpc=addwitnessaddress\"]]\n+        self.extra_args = [[\"-keypool=90\", \"-addresstype=legacy\"]]\n         self.rpc_timeout = 120\n \n     def skip_test_if_missing_module(self):\n@@ -101,34 +102,38 @@ def run_test(self):\n         wallet_unenc_dump = os.path.join(self.nodes[0].datadir, \"wallet.unencrypted.dump\")\n         wallet_enc_dump = os.path.join(self.nodes[0].datadir, \"wallet.encrypted.dump\")\n \n-        # generate 20 addresses to compare against the dump\n-        # but since we add a p2sh-p2wpkh address for the first pubkey in the\n-        # wallet, we will expect 21 addresses in the dump\n-        test_addr_count = 20\n+        # generate 30 addresses to compare against the dump\n+        # - 10 legacy P2PKH\n+        # - 10 P2SH-segwit\n+        # - 10 bech32\n+        test_addr_count = 10\n         addrs = []\n-        for i in range(0, test_addr_count):\n-            addr = self.nodes[0].getnewaddress()\n-            vaddr = self.nodes[0].getaddressinfo(addr)  # required to get hd keypath\n-            addrs.append(vaddr)\n-        # Should be a no-op:\n-        self.nodes[0].keypoolrefill()\n+        for address_type in ['legacy', 'p2sh-segwit', 'bech32']:\n+            for i in range(0, test_addr_count):\n+                addr = self.nodes[0].getnewaddress(address_type=address_type)\n+                vaddr = self.nodes[0].getaddressinfo(addr)  # required to get hd keypath\n+                addrs.append(vaddr)\n \n-        # Test scripts dump by adding a P2SH witness and a 1-of-1 multisig address\n-        witness_addr = self.nodes[0].addwitnessaddress(addrs[0][\"address\"], True)\n+        # Test scripts dump by adding a 1-of-1 multisig address\n         multisig_addr = self.nodes[0].addmultisigaddress(1, [addrs[1][\"address\"]])[\"address\"]\n-        script_addrs = [witness_addr, multisig_addr]\n+\n+        # Refill the keypool. getnewaddress() refills the keypool *before* taking a key from\n+        # the keypool, so the final call to getnewaddress leaves the keypool with one key below\n+        # its capacity\n+        self.nodes[0].keypoolrefill()\n \n         # dump unencrypted wallet\n         result = self.nodes[0].dumpwallet(wallet_unenc_dump)\n         assert_equal(result['filename'], wallet_unenc_dump)\n \n-        found_addr, found_script_addr, found_addr_chg, found_addr_rsv, hd_master_addr_unenc, witness_addr_ret = \\\n-            read_dump(wallet_unenc_dump, addrs, script_addrs, None)\n-        assert_equal(found_addr, test_addr_count)  # all keys must be in the dump\n-        assert_equal(found_script_addr, 2)  # all scripts must be in the dump\n+        found_legacy_addr, found_p2sh_segwit_addr, found_bech32_addr, found_script_addr, found_addr_chg, found_addr_rsv, hd_master_addr_unenc = \\\n+            read_dump(wallet_unenc_dump, addrs, [multisig_addr], None)\n+        assert_equal(found_legacy_addr, test_addr_count)  # all keys must be in the dump\n+        assert_equal(found_p2sh_segwit_addr, test_addr_count)  # all keys must be in the dump\n+        assert_equal(found_bech32_addr, test_addr_count)  # all keys must be in the dump\n+        assert_equal(found_script_addr, 1)  # all scripts must be in the dump\n         assert_equal(found_addr_chg, 0)  # 0 blocks where mined\n         assert_equal(found_addr_rsv, 90 * 2)  # 90 keys plus 100% internal keys\n-        assert_equal(witness_addr_ret, witness_addr)  # p2sh-p2wsh address added to the first key\n \n         # encrypt wallet, restart, unlock and dump\n         self.nodes[0].encryptwallet('test')\n@@ -137,13 +142,14 @@ def run_test(self):\n         self.nodes[0].keypoolrefill()\n         self.nodes[0].dumpwallet(wallet_enc_dump)\n \n-        found_addr, found_script_addr, found_addr_chg, found_addr_rsv, _, witness_addr_ret = \\\n-            read_dump(wallet_enc_dump, addrs, script_addrs, hd_master_addr_unenc)\n-        assert_equal(found_addr, test_addr_count)\n-        assert_equal(found_script_addr, 2)\n+        found_legacy_addr, found_p2sh_segwit_addr, found_bech32_addr, found_script_addr, found_addr_chg, found_addr_rsv, _ = \\\n+            read_dump(wallet_enc_dump, addrs, [multisig_addr], hd_master_addr_unenc)\n+        assert_equal(found_legacy_addr, test_addr_count)  # all keys must be in the dump\n+        assert_equal(found_p2sh_segwit_addr, test_addr_count)  # all keys must be in the dump\n+        assert_equal(found_bech32_addr, test_addr_count)  # all keys must be in the dump\n+        assert_equal(found_script_addr, 1)\n         assert_equal(found_addr_chg, 90 * 2)  # old reserve keys are marked as change now\n         assert_equal(found_addr_rsv, 90 * 2)\n-        assert_equal(witness_addr_ret, witness_addr)\n \n         # Overwriting should fail\n         assert_raises_rpc_error(-8, \"already exists\", lambda: self.nodes[0].dumpwallet(wallet_enc_dump))"
      }
    ]
  },
  {
    "sha": "9d7ee187a3ceb9270af316ae3eb8f2de27d70b1f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZDdlZTE4N2EzY2ViOTI3MGFmMzE2YWUzZWI4ZjJkZTI3ZDcwYjFm",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-09-23T02:57:40Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-09-23T12:51:57Z"
      },
      "message": "[test] Remove deprecated addwitnessaddress from p2p_compactblocks.py",
      "tree": {
        "sha": "2e78cc28a032d3f9ff4efbfb42beac6dc78860c8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2e78cc28a032d3f9ff4efbfb42beac6dc78860c8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9d7ee187a3ceb9270af316ae3eb8f2de27d70b1f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9d7ee187a3ceb9270af316ae3eb8f2de27d70b1f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9d7ee187a3ceb9270af316ae3eb8f2de27d70b1f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9d7ee187a3ceb9270af316ae3eb8f2de27d70b1f/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3cf77f0b3ee0862e87c98db5363b4da83f9089e0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3cf77f0b3ee0862e87c98db5363b4da83f9089e0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3cf77f0b3ee0862e87c98db5363b4da83f9089e0"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 2,
      "deletions": 2
    },
    "files": [
      {
        "sha": "04353ae96fd88938a51091a78751a13de5ff7657",
        "filename": "test/functional/p2p_compactblocks.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9d7ee187a3ceb9270af316ae3eb8f2de27d70b1f/test/functional/p2p_compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9d7ee187a3ceb9270af316ae3eb8f2de27d70b1f/test/functional/p2p_compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_compactblocks.py?ref=9d7ee187a3ceb9270af316ae3eb8f2de27d70b1f",
        "patch": "@@ -98,7 +98,7 @@ def set_test_params(self):\n         self.num_nodes = 2\n         # This test was written assuming SegWit is activated using BIP9 at height 432 (3x confirmation window).\n         # TODO: Rewrite this test to support SegWit being always active.\n-        self.extra_args = [[\"-vbparams=segwit:0:0\"], [\"-vbparams=segwit:0:999999999999\", \"-txindex\", \"-deprecatedrpc=addwitnessaddress\"]]\n+        self.extra_args = [[\"-vbparams=segwit:0:0\"], [\"-vbparams=segwit:0:999999999999\", \"-txindex\"]]\n         self.utxos = []\n \n     def skip_test_if_missing_module(self):\n@@ -264,7 +264,7 @@ def test_compactblock_construction(self, node, test_node, version, use_witness_a\n         if use_witness_address:\n             # Want at least one segwit spend, so move all funds to\n             # a witness address.\n-            address = node.addwitnessaddress(address)\n+            address = node.getnewaddress(address_type='bech32')\n             value_to_send = node.getbalance()\n             node.sendtoaddress(address, satoshi_round(value_to_send - Decimal(0.1)))\n             node.generate(1)"
      }
    ]
  },
  {
    "sha": "82f2fa03a58df7418f88f176e94c3aa70d7a6c64",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4MmYyZmEwM2E1OGRmNzQxOGY4OGYxNzZlOTRjM2FhNzBkN2E2YzY0",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-09-23T03:01:32Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-09-23T12:51:57Z"
      },
      "message": "[test] Remove deprecated addwitnessaddress from wallet_bumpfee.py",
      "tree": {
        "sha": "643348aad70dc4ad964e19908fd7e3f2bd280a89",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/643348aad70dc4ad964e19908fd7e3f2bd280a89"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/82f2fa03a58df7418f88f176e94c3aa70d7a6c64",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/82f2fa03a58df7418f88f176e94c3aa70d7a6c64",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/82f2fa03a58df7418f88f176e94c3aa70d7a6c64",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/82f2fa03a58df7418f88f176e94c3aa70d7a6c64/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9d7ee187a3ceb9270af316ae3eb8f2de27d70b1f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9d7ee187a3ceb9270af316ae3eb8f2de27d70b1f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9d7ee187a3ceb9270af316ae3eb8f2de27d70b1f"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 1,
      "deletions": 3
    },
    "files": [
      {
        "sha": "7d3d9b61e2765a754aa734f9dc5fbbd50de5210d",
        "filename": "test/functional/wallet_bumpfee.py",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/82f2fa03a58df7418f88f176e94c3aa70d7a6c64/test/functional/wallet_bumpfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/82f2fa03a58df7418f88f176e94c3aa70d7a6c64/test/functional/wallet_bumpfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_bumpfee.py?ref=82f2fa03a58df7418f88f176e94c3aa70d7a6c64",
        "patch": "@@ -29,7 +29,6 @@ def set_test_params(self):\n         self.num_nodes = 2\n         self.setup_clean_chain = True\n         self.extra_args = [[\n-            \"-deprecatedrpc=addwitnessaddress\",\n             \"-walletrbf={}\".format(i),\n             \"-mintxfee=0.00002\",\n         ] for i in range(self.num_nodes)]\n@@ -104,8 +103,7 @@ def test_segwit_bumpfee_succeeds(rbf_node, dest_address):\n     # which spends it, and make sure bumpfee can be called on it.\n \n     segwit_in = next(u for u in rbf_node.listunspent() if u[\"amount\"] == Decimal(\"0.001\"))\n-    segwit_out = rbf_node.getaddressinfo(rbf_node.getnewaddress())\n-    rbf_node.addwitnessaddress(segwit_out[\"address\"])\n+    segwit_out = rbf_node.getaddressinfo(rbf_node.getnewaddress(address_type='p2sh-segwit'))\n     segwitid = send_to_witness(\n         use_p2wsh=False,\n         node=rbf_node,"
      }
    ]
  },
  {
    "sha": "07e3f585abcee10c0283f2bd2f50eaa953df4d41",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowN2UzZjU4NWFiY2VlMTBjMDI4M2YyYmQyZjUwZWFhOTUzZGY0ZDQx",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-09-23T03:15:49Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-09-23T12:53:14Z"
      },
      "message": "[test] Remove deprecated addwitnessaddress from feature_segwit.py",
      "tree": {
        "sha": "6febd088e0e916aafde9314557c603cffa76678f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6febd088e0e916aafde9314557c603cffa76678f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/07e3f585abcee10c0283f2bd2f50eaa953df4d41",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/07e3f585abcee10c0283f2bd2f50eaa953df4d41",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/07e3f585abcee10c0283f2bd2f50eaa953df4d41",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/07e3f585abcee10c0283f2bd2f50eaa953df4d41/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "82f2fa03a58df7418f88f176e94c3aa70d7a6c64",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/82f2fa03a58df7418f88f176e94c3aa70d7a6c64",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/82f2fa03a58df7418f88f176e94c3aa70d7a6c64"
      }
    ],
    "stats": {
      "total": 50,
      "additions": 1,
      "deletions": 49
    },
    "files": [
      {
        "sha": "7098a03f1ec0ea3a4c2935b26ccf0896342a6167",
        "filename": "test/functional/feature_segwit.py",
        "status": "modified",
        "additions": 1,
        "deletions": 49,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/07e3f585abcee10c0283f2bd2f50eaa953df4d41/test/functional/feature_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/07e3f585abcee10c0283f2bd2f50eaa953df4d41/test/functional/feature_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_segwit.py?ref=07e3f585abcee10c0283f2bd2f50eaa953df4d41",
        "patch": "@@ -9,8 +9,6 @@\n \n from test_framework.address import (\n     key_to_p2pkh,\n-    key_to_p2sh_p2wpkh,\n-    key_to_p2wpkh,\n     program_to_witness,\n     script_to_p2sh,\n     script_to_p2sh_p2wsh,\n@@ -50,20 +48,17 @@ def set_test_params(self):\n                 \"-rpcserialversion=0\",\n                 \"-vbparams=segwit:0:999999999999\",\n                 \"-addresstype=legacy\",\n-                \"-deprecatedrpc=addwitnessaddress\",\n             ],\n             [\n                 \"-blockversion=4\",\n                 \"-rpcserialversion=1\",\n                 \"-vbparams=segwit:0:999999999999\",\n                 \"-addresstype=legacy\",\n-                \"-deprecatedrpc=addwitnessaddress\",\n             ],\n             [\n                 \"-blockversion=536870915\",\n                 \"-vbparams=segwit:0:999999999999\",\n                 \"-addresstype=legacy\",\n-                \"-deprecatedrpc=addwitnessaddress\",\n             ],\n         ]\n \n@@ -117,12 +112,8 @@ def run_test(self):\n             newaddress = self.nodes[i].getnewaddress()\n             self.pubkey.append(self.nodes[i].getaddressinfo(newaddress)[\"pubkey\"])\n             multiscript = CScript([OP_1, hex_str_to_bytes(self.pubkey[-1]), OP_1, OP_CHECKMULTISIG])\n-            p2sh_addr = self.nodes[i].addwitnessaddress(newaddress)\n-            bip173_addr = self.nodes[i].addwitnessaddress(newaddress, False)\n             p2sh_ms_addr = self.nodes[i].addmultisigaddress(1, [self.pubkey[-1]], '', 'p2sh-segwit')['address']\n             bip173_ms_addr = self.nodes[i].addmultisigaddress(1, [self.pubkey[-1]], '', 'bech32')['address']\n-            assert_equal(p2sh_addr, key_to_p2sh_p2wpkh(self.pubkey[-1]))\n-            assert_equal(bip173_addr, key_to_p2wpkh(self.pubkey[-1]))\n             assert_equal(p2sh_ms_addr, script_to_p2sh_p2wsh(multiscript))\n             assert_equal(bip173_ms_addr, script_to_p2wsh(multiscript))\n             p2sh_ids.append([])\n@@ -262,7 +253,7 @@ def run_test(self):\n         # Mine a block to clear the gbt cache again.\n         self.nodes[0].generate(1)\n \n-        self.log.info(\"Verify behaviour of importaddress, addwitnessaddress and listunspent\")\n+        self.log.info(\"Verify behaviour of importaddress and listunspent\")\n \n         # Some public keys to be used later\n         pubkeys = [\n@@ -303,7 +294,6 @@ def run_test(self):\n         uncompressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], uncompressed_solvable_address[0]])['address'])\n         compressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_solvable_address[0]])['address'])\n         compressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_solvable_address[0], compressed_solvable_address[1]])['address'])\n-        unknown_address = [\"mtKKyoHabkk6e4ppT7NaM7THqPUt7AzPrT\", \"2NDP3jLWAFT8NDAiUa9qiE6oBt2awmMq7Dx\"]\n \n         # Test multisig_without_privkey\n         # We have 2 public keys without private keys, use addmultisigaddress to add to wallet.\n@@ -384,7 +374,6 @@ def run_test(self):\n         op1 = CScript([OP_1])\n         op0 = CScript([OP_0])\n         # 2N7MGY19ti4KDMSzRfPAssP6Pxyuxoi6jLe is the P2SH(P2PKH) version of mjoE3sSrb8ByYEvgnC3Aox86u1CHnfJA4V\n-        unsolvable_address = [\"mjoE3sSrb8ByYEvgnC3Aox86u1CHnfJA4V\", \"2N7MGY19ti4KDMSzRfPAssP6Pxyuxoi6jLe\", script_to_p2sh(op1), script_to_p2sh(op0)]\n         unsolvable_address_key = hex_str_to_bytes(\"02341AEC7587A51CDE5279E0630A531AEA2615A9F80B17E8D9376327BAEAA59E3D\")\n         unsolvablep2pkh = CScript([OP_DUP, OP_HASH160, hash160(unsolvable_address_key), OP_EQUALVERIFY, OP_CHECKSIG])\n         unsolvablep2wshp2pkh = CScript([OP_0, sha256(unsolvablep2pkh)])\n@@ -438,19 +427,6 @@ def run_test(self):\n         self.mine_and_test_listunspent(unsolvable_after_importaddress, 1)\n         self.mine_and_test_listunspent(unseen_anytime, 0)\n \n-        # addwitnessaddress should refuse to return a witness address if an uncompressed key is used\n-        # note that no witness address should be returned by unsolvable addresses\n-        for i in uncompressed_spendable_address + uncompressed_solvable_address + unknown_address + unsolvable_address:\n-            assert_raises_rpc_error(-4, \"Public key or redeemscript not known to wallet, or the key is uncompressed\", self.nodes[0].addwitnessaddress, i)\n-\n-        # addwitnessaddress should return a witness addresses even if keys are not in the wallet\n-        self.nodes[0].addwitnessaddress(multisig_without_privkey_address)\n-\n-        for i in compressed_spendable_address + compressed_solvable_address:\n-            witaddress = self.nodes[0].addwitnessaddress(i)\n-            # addwitnessaddress should return the same address if it is a known P2SH-witness address\n-            assert_equal(witaddress, self.nodes[0].addwitnessaddress(witaddress))\n-\n         spendable_txid.append(self.mine_and_test_listunspent(spendable_anytime + spendable_after_importaddress, 2))\n         solvable_txid.append(self.mine_and_test_listunspent(solvable_anytime + solvable_after_importaddress, 1))\n         self.mine_and_test_listunspent(unsolvable_after_importaddress, 1)\n@@ -468,8 +444,6 @@ def run_test(self):\n         self.nodes[0].importpubkey(pubkeys[6])\n         uncompressed_solvable_address = [key_to_p2pkh(pubkeys[6])]\n \n-        spendable_after_addwitnessaddress = []      # These outputs should be seen after importaddress\n-        solvable_after_addwitnessaddress = []       # These outputs should be seen after importaddress but not spendable\n         unseen_anytime = []                         # These outputs should never be seen\n         solvable_anytime = []                       # These outputs should be solvable after importpubkey\n         unseen_anytime = []                         # These outputs should never be seen\n@@ -486,8 +460,6 @@ def run_test(self):\n             v = self.nodes[0].getaddressinfo(i)\n             if (v['isscript']):\n                 [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n-                # P2WSH and P2SH(P2WSH) multisig with compressed keys are spendable after addwitnessaddress\n-                spendable_after_addwitnessaddress.extend([p2wsh, p2sh_p2wsh])\n                 premature_witaddress.append(script_to_p2sh(p2wsh))\n             else:\n                 [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n@@ -508,9 +480,7 @@ def run_test(self):\n         for i in compressed_solvable_address:\n             v = self.nodes[0].getaddressinfo(i)\n             if (v['isscript']):\n-                # P2WSH multisig without private key are seen after addwitnessaddress\n                 [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n-                solvable_after_addwitnessaddress.extend([p2wsh, p2sh_p2wsh])\n                 premature_witaddress.append(script_to_p2sh(p2wsh))\n             else:\n                 [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n@@ -519,24 +489,6 @@ def run_test(self):\n \n         self.mine_and_test_listunspent(spendable_anytime, 2)\n         self.mine_and_test_listunspent(solvable_anytime, 1)\n-        self.mine_and_test_listunspent(spendable_after_addwitnessaddress + solvable_after_addwitnessaddress + unseen_anytime, 0)\n-\n-        # addwitnessaddress should refuse to return a witness address if an uncompressed key is used\n-        # note that a multisig address returned by addmultisigaddress is not solvable until it is added with importaddress\n-        # premature_witaddress are not accepted until the script is added with addwitnessaddress first\n-        for i in uncompressed_spendable_address + uncompressed_solvable_address + premature_witaddress:\n-            # This will raise an exception\n-            assert_raises_rpc_error(-4, \"Public key or redeemscript not known to wallet, or the key is uncompressed\", self.nodes[0].addwitnessaddress, i)\n-\n-        # after importaddress it should pass addwitnessaddress\n-        v = self.nodes[0].getaddressinfo(compressed_solvable_address[1])\n-        self.nodes[0].importaddress(v['hex'], \"\", False, True)\n-        for i in compressed_spendable_address + compressed_solvable_address + premature_witaddress:\n-            witaddress = self.nodes[0].addwitnessaddress(i)\n-            assert_equal(witaddress, self.nodes[0].addwitnessaddress(witaddress))\n-\n-        spendable_txid.append(self.mine_and_test_listunspent(spendable_after_addwitnessaddress + spendable_anytime, 2))\n-        solvable_txid.append(self.mine_and_test_listunspent(solvable_after_addwitnessaddress + solvable_anytime, 1))\n         self.mine_and_test_listunspent(unseen_anytime, 0)\n \n         # Check that createrawtransaction/decoderawtransaction with non-v0 Bech32 works"
      }
    ]
  },
  {
    "sha": "ebec90ac9731f8955d120a5d8419948d500b31c9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplYmVjOTBhYzk3MzFmODk1NWQxMjBhNWQ4NDE5OTQ4ZDUwMGIzMWM5",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-09-23T03:19:57Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-09-23T12:53:16Z"
      },
      "message": "[wallet] Remove deprecated addwitnessaddress RPC method",
      "tree": {
        "sha": "4dfb5f88de402d06109d8f81f75e12e832795052",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4dfb5f88de402d06109d8f81f75e12e832795052"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ebec90ac9731f8955d120a5d8419948d500b31c9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ebec90ac9731f8955d120a5d8419948d500b31c9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ebec90ac9731f8955d120a5d8419948d500b31c9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ebec90ac9731f8955d120a5d8419948d500b31c9/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "07e3f585abcee10c0283f2bd2f50eaa953df4d41",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/07e3f585abcee10c0283f2bd2f50eaa953df4d41",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/07e3f585abcee10c0283f2bd2f50eaa953df4d41"
      }
    ],
    "stats": {
      "total": 127,
      "additions": 0,
      "deletions": 127
    },
    "files": [
      {
        "sha": "c6570625ca02c4e587d098133a6a0b9adeb34e24",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ebec90ac9731f8955d120a5d8419948d500b31c9/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ebec90ac9731f8955d120a5d8419948d500b31c9/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=ebec90ac9731f8955d120a5d8419948d500b31c9",
        "patch": "@@ -148,7 +148,6 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"logging\", 0, \"include\" },\n     { \"logging\", 1, \"exclude\" },\n     { \"disconnectnode\", 1, \"nodeid\" },\n-    { \"addwitnessaddress\", 1, \"p2sh\" },\n     // Echo with conversion (For testing only)\n     { \"echojson\", 0, \"arg0\" },\n     { \"echojson\", 1, \"arg1\" },"
      },
      {
        "sha": "a36bad4512739e83dda8d49870b185ff9cc69431",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 126,
        "changes": 126,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ebec90ac9731f8955d120a5d8419948d500b31c9/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ebec90ac9731f8955d120a5d8419948d500b31c9/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=ebec90ac9731f8955d120a5d8419948d500b31c9",
        "patch": "@@ -982,131 +982,6 @@ static UniValue addmultisigaddress(const JSONRPCRequest& request)\n     return result;\n }\n \n-class Witnessifier : public boost::static_visitor<bool>\n-{\n-public:\n-    CWallet * const pwallet;\n-    CTxDestination result;\n-    bool already_witness;\n-\n-    explicit Witnessifier(CWallet *_pwallet) : pwallet(_pwallet), already_witness(false) {}\n-\n-    bool operator()(const CKeyID &keyID) {\n-        if (pwallet) {\n-            CScript basescript = GetScriptForDestination(keyID);\n-            CScript witscript = GetScriptForWitness(basescript);\n-            if (!IsSolvable(*pwallet, witscript)) {\n-                return false;\n-            }\n-            return ExtractDestination(witscript, result);\n-        }\n-        return false;\n-    }\n-\n-    bool operator()(const CScriptID &scriptID) {\n-        CScript subscript;\n-        if (pwallet && pwallet->GetCScript(scriptID, subscript)) {\n-            int witnessversion;\n-            std::vector<unsigned char> witprog;\n-            if (subscript.IsWitnessProgram(witnessversion, witprog)) {\n-                ExtractDestination(subscript, result);\n-                already_witness = true;\n-                return true;\n-            }\n-            CScript witscript = GetScriptForWitness(subscript);\n-            if (!IsSolvable(*pwallet, witscript)) {\n-                return false;\n-            }\n-            return ExtractDestination(witscript, result);\n-        }\n-        return false;\n-    }\n-\n-    bool operator()(const WitnessV0KeyHash& id)\n-    {\n-        already_witness = true;\n-        result = id;\n-        return true;\n-    }\n-\n-    bool operator()(const WitnessV0ScriptHash& id)\n-    {\n-        already_witness = true;\n-        result = id;\n-        return true;\n-    }\n-\n-    template<typename T>\n-    bool operator()(const T& dest) { return false; }\n-};\n-\n-static UniValue addwitnessaddress(const JSONRPCRequest& request)\n-{\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    CWallet* const pwallet = wallet.get();\n-\n-    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n-        return NullUniValue;\n-    }\n-\n-    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-    {\n-        std::string msg = \"addwitnessaddress \\\"address\\\" ( p2sh )\\n\"\n-            \"\\nDEPRECATED: set the address_type argument of getnewaddress, or option -addresstype=[bech32|p2sh-segwit] instead.\\n\"\n-            \"Add a witness address for a script (with pubkey or redeemscript known). Requires a new wallet backup.\\n\"\n-            \"It returns the witness script.\\n\"\n-\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"address\\\"       (string, required) An address known to the wallet\\n\"\n-            \"2. p2sh            (bool, optional, default=true) Embed inside P2SH\\n\"\n-\n-            \"\\nResult:\\n\"\n-            \"\\\"witnessaddress\\\",  (string) The value of the new address (P2SH or BIP173).\\n\"\n-            \"}\\n\"\n-        ;\n-        throw std::runtime_error(msg);\n-    }\n-\n-    if (!IsDeprecatedRPCEnabled(\"addwitnessaddress\")) {\n-        throw JSONRPCError(RPC_METHOD_DEPRECATED, \"addwitnessaddress is deprecated and will be fully removed in v0.17. \"\n-            \"To use addwitnessaddress in v0.16, restart bitcoind with -deprecatedrpc=addwitnessaddress.\\n\"\n-            \"Projects should transition to using the address_type argument of getnewaddress, or option -addresstype=[bech32|p2sh-segwit] instead.\\n\");\n-    }\n-\n-    CTxDestination dest = DecodeDestination(request.params[0].get_str());\n-    if (!IsValidDestination(dest)) {\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n-    }\n-\n-    bool p2sh = true;\n-    if (!request.params[1].isNull()) {\n-        p2sh = request.params[1].get_bool();\n-    }\n-\n-    Witnessifier w(pwallet);\n-    bool ret = boost::apply_visitor(w, dest);\n-    if (!ret) {\n-        throw JSONRPCError(RPC_WALLET_ERROR, \"Public key or redeemscript not known to wallet, or the key is uncompressed\");\n-    }\n-\n-    CScript witprogram = GetScriptForDestination(w.result);\n-\n-    if (p2sh) {\n-        w.result = CScriptID(witprogram);\n-    }\n-\n-    if (w.already_witness) {\n-        if (!(dest == w.result)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot convert between witness address types\");\n-        }\n-    } else {\n-        pwallet->AddCScript(witprogram); // Implicit for single-key now, but necessary for multisig and for compatibility with older software\n-        pwallet->SetAddressBook(w.result, \"\", \"receive\");\n-    }\n-\n-    return EncodeDestination(w.result);\n-}\n-\n struct tallyitem\n {\n     CAmount nAmount;\n@@ -4065,7 +3940,6 @@ static const CRPCCommand commands[] =\n { //  category              name                                actor (function)                argNames\n     //  --------------------- ------------------------          -----------------------         ----------\n     { \"generating\",         \"generate\",                         &generate,                      {\"nblocks\",\"maxtries\"} },\n-    { \"hidden\",             \"addwitnessaddress\",                &addwitnessaddress,             {\"address\",\"p2sh\"} },\n     { \"hidden\",             \"resendwallettransactions\",         &resendwallettransactions,      {} },\n     { \"rawtransactions\",    \"fundrawtransaction\",               &fundrawtransaction,            {\"hexstring\",\"options\",\"iswitness\"} },\n     { \"wallet\",             \"abandontransaction\",               &abandontransaction,            {\"txid\"} },"
      }
    ]
  },
  {
    "sha": "2b91e42ece78c3f2ae4bf12fa71f461d05426a19",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyYjkxZTQyZWNlNzhjM2YyYWU0YmYxMmZhNzFmNDYxZDA1NDI2YTE5",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-09-23T03:24:37Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-10-17T19:00:50Z"
      },
      "message": "[docs] Add release note for removing getwitnessaddress",
      "tree": {
        "sha": "a38ffc1cdd98eb143d6534254eac449311383c4b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a38ffc1cdd98eb143d6534254eac449311383c4b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2b91e42ece78c3f2ae4bf12fa71f461d05426a19",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2b91e42ece78c3f2ae4bf12fa71f461d05426a19",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2b91e42ece78c3f2ae4bf12fa71f461d05426a19",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2b91e42ece78c3f2ae4bf12fa71f461d05426a19/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ebec90ac9731f8955d120a5d8419948d500b31c9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ebec90ac9731f8955d120a5d8419948d500b31c9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ebec90ac9731f8955d120a5d8419948d500b31c9"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 5,
      "deletions": 0
    },
    "files": [
      {
        "sha": "f7c52baacefae9cf63549197e45d70c373f3a985",
        "filename": "doc/release-notes-14296.md",
        "status": "added",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b91e42ece78c3f2ae4bf12fa71f461d05426a19/doc/release-notes-14296.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b91e42ece78c3f2ae4bf12fa71f461d05426a19/doc/release-notes-14296.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-14296.md?ref=2b91e42ece78c3f2ae4bf12fa71f461d05426a19",
        "patch": "@@ -0,0 +1,5 @@\n+addwitnessaddress RPC method removed\n+------------------------------------\n+\n+The `addwitnessaddress` RPC was added for segwit testing in version 0.13.0. It\n+was deprecated in version 0.16.0. This version fully removes the RPC method."
      }
    ]
  }
]