[
  {
    "sha": "32862e54af6645c9c490e0ad47ba34bf6a6a2da2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozMjg2MmU1NGFmNjY0NWM5YzQ5MGUwYWQ0N2JhMzRiZjZhNmEyZGEy",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "j@rubin.io",
        "date": "2019-11-05T00:14:58Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "j@rubin.io",
        "date": "2019-11-11T19:44:56Z"
      },
      "message": "Add asymptotes for benchmarking framework",
      "tree": {
        "sha": "522cc7f87ad1f89e834ba6062b702d081db78045",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/522cc7f87ad1f89e834ba6062b702d081db78045"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/32862e54af6645c9c490e0ad47ba34bf6a6a2da2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/32862e54af6645c9c490e0ad47ba34bf6a6a2da2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/32862e54af6645c9c490e0ad47ba34bf6a6a2da2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/32862e54af6645c9c490e0ad47ba34bf6a6a2da2/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bc38bb9a6036d73f507e66a2f588547f3f17e4b1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bc38bb9a6036d73f507e66a2f588547f3f17e4b1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bc38bb9a6036d73f507e66a2f588547f3f17e4b1"
      }
    ],
    "stats": {
      "total": 138,
      "additions": 109,
      "deletions": 29
    },
    "files": [
      {
        "sha": "8f42eb148232f6712c465b731bae53fd1aad8e58",
        "filename": "src/bench/bench.cpp",
        "status": "modified",
        "additions": 54,
        "deletions": 21,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32862e54af6645c9c490e0ad47ba34bf6a6a2da2/src/bench/bench.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32862e54af6645c9c490e0ad47ba34bf6a6a2da2/src/bench/bench.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.cpp?ref=32862e54af6645c9c490e0ad47ba34bf6a6a2da2",
        "patch": "@@ -92,12 +92,23 @@ benchmark::BenchRunner::BenchmarkMap& benchmark::BenchRunner::benchmarks()\n     return benchmarks_map;\n }\n \n+benchmark::BenchRunner::BenchmarkAsymptoteMap& benchmark::BenchRunner::asymptotic_benchmarks()\n+{\n+    static std::map<std::string, BenchAsymptote> benchmarks_map;\n+    return benchmarks_map;\n+}\n+\n benchmark::BenchRunner::BenchRunner(std::string name, benchmark::BenchFunction func, uint64_t num_iters_for_one_second)\n {\n     benchmarks().insert(std::make_pair(name, Bench{func, num_iters_for_one_second}));\n }\n \n-void benchmark::BenchRunner::RunAll(Printer& printer, uint64_t num_evals, double scaling, const std::string& filter, bool is_list_only)\n+benchmark::BenchRunner::BenchRunner(std::string name, benchmark::BenchAsymptoteFunction func)\n+{\n+    asymptotic_benchmarks().insert(std::make_pair(name, BenchAsymptote{func}));\n+}\n+\n+void benchmark::BenchRunner::RunAll(Printer& printer, uint64_t num_evals, double scaling, const std::string& filter, bool is_list_only, const std::vector<size_t>& asymptotic_factors)\n {\n     if (!std::ratio_less_equal<benchmark::clock::period, std::micro>::value) {\n         std::cerr << \"WARNING: Clock precision is worse than microsecond - benchmarks may be less accurate!\\n\";\n@@ -111,28 +122,50 @@ void benchmark::BenchRunner::RunAll(Printer& printer, uint64_t num_evals, double\n \n     printer.header();\n \n-    for (const auto& p : benchmarks()) {\n-        RegTestingSetup test{};\n-        {\n-            LOCK(cs_main);\n-            assert(::ChainActive().Height() == 0);\n-            const bool witness_enabled{IsWitnessEnabled(::ChainActive().Tip(), Params().GetConsensus())};\n-            assert(witness_enabled);\n-        }\n-\n-        if (!std::regex_match(p.first, baseMatch, reFilter)) {\n-            continue;\n-        }\n-\n-        uint64_t num_iters = static_cast<uint64_t>(p.second.num_iters_for_one_second * scaling);\n-        if (0 == num_iters) {\n-            num_iters = 1;\n+    if (asymptotic_factors.empty()) {\n+        for (const auto& p : benchmarks()) {\n+            RegTestingSetup test{};\n+            {\n+                LOCK(cs_main);\n+                assert(::ChainActive().Height() == 0);\n+                const bool witness_enabled{IsWitnessEnabled(::ChainActive().Tip(), Params().GetConsensus())};\n+                assert(witness_enabled);\n+            }\n+\n+            if (!std::regex_match(p.first, baseMatch, reFilter)) {\n+                continue;\n+            }\n+\n+            uint64_t num_iters = static_cast<uint64_t>(p.second.num_iters_for_one_second * scaling);\n+            if (0 == num_iters) {\n+                num_iters = 1;\n+            }\n+            State state(p.first, num_evals, num_iters, printer);\n+            if (!is_list_only) {\n+                p.second.func(state);\n+            }\n+            printer.result(state);\n         }\n-        State state(p.first, num_evals, num_iters, printer);\n-        if (!is_list_only) {\n-            p.second.func(state);\n+    } else {\n+        for (const auto& p : asymptotic_benchmarks()) {\n+            RegTestingSetup test{};\n+            {\n+                LOCK(cs_main);\n+                assert(::ChainActive().Height() == 0);\n+                const bool witness_enabled{IsWitnessEnabled(::ChainActive().Tip(), Params().GetConsensus())};\n+                assert(witness_enabled);\n+            }\n+\n+            if (!std::regex_match(p.first, baseMatch, reFilter)) {\n+                continue;\n+            }\n+\n+            State state(p.first, num_evals, 1, printer);\n+            if (!is_list_only) {\n+                p.second.func(state, &asymptotic_factors);\n+            }\n+            printer.result(state);\n         }\n-        printer.result(state);\n     }\n \n     printer.footer();"
      },
      {
        "sha": "136dbd554a828e7896a13fbdca2266e4f0198930",
        "filename": "src/bench/bench.h",
        "status": "modified",
        "additions": 12,
        "deletions": 1,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32862e54af6645c9c490e0ad47ba34bf6a6a2da2/src/bench/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32862e54af6645c9c490e0ad47ba34bf6a6a2da2/src/bench/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.h?ref=32862e54af6645c9c490e0ad47ba34bf6a6a2da2",
        "patch": "@@ -80,20 +80,27 @@ class State\n };\n \n typedef std::function<void(State&)> BenchFunction;\n+typedef std::function<void(State&, const std::vector<size_t>*)> BenchAsymptoteFunction;\n \n class BenchRunner\n {\n     struct Bench {\n         BenchFunction func;\n         uint64_t num_iters_for_one_second;\n     };\n+    struct BenchAsymptote {\n+        BenchAsymptoteFunction func;\n+    };\n     typedef std::map<std::string, Bench> BenchmarkMap;\n     static BenchmarkMap& benchmarks();\n+    typedef std::map<std::string, BenchAsymptote> BenchmarkAsymptoteMap;\n+    static BenchmarkAsymptoteMap& asymptotic_benchmarks();\n \n public:\n     BenchRunner(std::string name, BenchFunction func, uint64_t num_iters_for_one_second);\n+    BenchRunner(std::string name, BenchAsymptoteFunction func);\n \n-    static void RunAll(Printer& printer, uint64_t num_evals, double scaling, const std::string& filter, bool is_list_only);\n+    static void RunAll(Printer& printer, uint64_t num_evals, double scaling, const std::string& filter, bool is_list_only, const std::vector<size_t>& asymptotic_factors);\n };\n \n // interface to output benchmark results.\n@@ -138,4 +145,8 @@ class PlotlyPrinter : public Printer\n #define BENCHMARK(n, num_iters_for_one_second) \\\n     benchmark::BenchRunner BOOST_PP_CAT(bench_, BOOST_PP_CAT(__LINE__, n))(BOOST_PP_STRINGIZE(n), n, (num_iters_for_one_second));\n \n+#define BENCHMARK_ASYMPTOTE(n) \\\n+    benchmark::BenchRunner BOOST_PP_CAT(asymptote_bench_, BOOST_PP_CAT(__LINE__, n))(BOOST_PP_STRINGIZE(n), n);\n+\n+\n #endif // BITCOIN_BENCH_BENCH_H"
      },
      {
        "sha": "fe63487dac0442fe4a2bc66e35261015f28aa11f",
        "filename": "src/bench/bench_bitcoin.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 1,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32862e54af6645c9c490e0ad47ba34bf6a6a2da2/src/bench/bench_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32862e54af6645c9c490e0ad47ba34bf6a6a2da2/src/bench/bench_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench_bitcoin.cpp?ref=32862e54af6645c9c490e0ad47ba34bf6a6a2da2",
        "patch": "@@ -16,6 +16,7 @@ static const char* DEFAULT_BENCH_PRINTER = \"console\";\n static const char* DEFAULT_PLOT_PLOTLYURL = \"https://cdn.plot.ly/plotly-latest.min.js\";\n static const int64_t DEFAULT_PLOT_WIDTH = 1024;\n static const int64_t DEFAULT_PLOT_HEIGHT = 768;\n+static const std::vector<size_t> DEFAULT_ASYMPTOTIC_FACTORS;\n \n static void SetupBenchArgs()\n {\n@@ -25,6 +26,14 @@ static void SetupBenchArgs()\n     gArgs.AddArg(\"-evals=<n>\", strprintf(\"Number of measurement evaluations to perform. (default: %u)\", DEFAULT_BENCH_EVALUATIONS), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-filter=<regex>\", strprintf(\"Regular expression filter to select benchmark by name (default: %s)\", DEFAULT_BENCH_FILTER), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-scaling=<n>\", strprintf(\"Scaling factor for benchmark's runtime (default: %u)\", DEFAULT_BENCH_SCALING), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-asymptote=n\", \n+            strprintf(\"Certain benchmarks can have tunable parameters (e.g, number of transactions) to test the \"\n+                      \"asymptotic growth of the runtime of an algorithm easily. \"\n+                      \"These arguments are positional and are defined differently per benchmark. \"\n+                      \"Thus asymptote should be used with a narrowly scoped filter to a single test case. \"\n+                      \"For example, this script tests ComplexMemPoolAsymptotic's max descendants per tx parameter \"\n+                      \"growing by powers of 2 and prints out the median: \"\n+                      \"`for x in {1..10}; do ./src/bench/bench_bitcoin -filter=ComplexMemPoolAsymptotic -asymptote=100 -asymptote=100 -asymptote=$((2**$x)); done | grep ComplexMemPoolAsymptotic --line-buffered | cut -d, -f7`\"), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-printer=(console|plot)\", strprintf(\"Choose printer format. console: print data to console. plot: Print results as HTML graph (default: %s)\", DEFAULT_BENCH_PRINTER), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-plot-plotlyurl=<uri>\", strprintf(\"URL to use for plotly.js (default: %s)\", DEFAULT_PLOT_PLOTLYURL), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-plot-width=<x>\", strprintf(\"Plot width in pixel (default: %u)\", DEFAULT_PLOT_WIDTH), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n@@ -50,6 +59,7 @@ int main(int argc, char** argv)\n     std::string regex_filter = gArgs.GetArg(\"-filter\", DEFAULT_BENCH_FILTER);\n     std::string scaling_str = gArgs.GetArg(\"-scaling\", DEFAULT_BENCH_SCALING);\n     bool is_list_only = gArgs.GetBoolArg(\"-list\", false);\n+    std::vector<std::string> asymptotes = gArgs.GetArgs(\"-asymptote\");\n \n     if (evaluations == 0) {\n         return EXIT_SUCCESS;\n@@ -73,7 +83,17 @@ int main(int argc, char** argv)\n             gArgs.GetArg(\"-plot-height\", DEFAULT_PLOT_HEIGHT)));\n     }\n \n-    benchmark::BenchRunner::RunAll(*printer, evaluations, scaling_factor, regex_filter, is_list_only);\n+    std::vector<size_t> asymptotic_factors;\n+    for (auto& s: asymptotes) {\n+        uint64_t arg;\n+        if (!ParseUInt64(s, &arg))\n+            tfm::format(std::cerr, \"Error parsing scaling factor as double: %s\\n\", s);\n+        if (arg > std::numeric_limits<size_t>::max())\n+            tfm::format(std::cerr, \"Error parsing scaling factor as size_t: %s\\n\", s);\n+        asymptotic_factors.emplace_back((size_t)arg);\n+    }\n+\n+    benchmark::BenchRunner::RunAll(*printer, evaluations, scaling_factor, regex_filter, is_list_only, asymptotic_factors);\n \n     return EXIT_SUCCESS;\n }"
      },
      {
        "sha": "d55294be7ae9055d7be10db1a6e7546a98c7aea1",
        "filename": "src/bench/mempool_stress.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 6,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32862e54af6645c9c490e0ad47ba34bf6a6a2da2/src/bench/mempool_stress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32862e54af6645c9c490e0ad47ba34bf6a6a2da2/src/bench/mempool_stress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/mempool_stress.cpp?ref=32862e54af6645c9c490e0ad47ba34bf6a6a2da2",
        "patch": "@@ -25,29 +25,41 @@ struct Available {\n     Available(CTransactionRef& ref, size_t tx_count) : ref(ref), tx_count(tx_count){}\n };\n \n-static void ComplexMemPool(benchmark::State& state)\n+static void ComplexMemPoolAsymptotic(benchmark::State& state, const std::vector<size_t>* asymptotic_factors)\n {\n+    const std::vector<size_t> DEFAULTS {};\n+    const std::vector<size_t> scaling_factors = asymptotic_factors ? *asymptotic_factors : DEFAULTS;\n+    size_t CHILD_TXS = 800;\n+    size_t STARTING_TXS = 100;\n+    size_t DESCENDANTS_COUNT_MAX = 10;\n+    size_t ANCESTORS_COUNT_MAX = 10;\n+    if (scaling_factors.size() > 0) CHILD_TXS = scaling_factors[0];\n+    if (scaling_factors.size() > 1) STARTING_TXS = scaling_factors[1];\n+    if (scaling_factors.size() > 2) DESCENDANTS_COUNT_MAX = scaling_factors[2];\n+    if (scaling_factors.size() > 3) ANCESTORS_COUNT_MAX = scaling_factors[3];\n+\n+\n     FastRandomContext det_rand{true};\n     std::vector<Available> available_coins;\n     std::vector<CTransactionRef> ordered_coins;\n     // Create some base transactions\n     size_t tx_counter = 1;\n-    for (auto x = 0; x < 100; ++x) {\n+    for (size_t x = 0; x < STARTING_TXS; ++x) {\n         CMutableTransaction tx = CMutableTransaction();\n         tx.vin.resize(1);\n         tx.vin[0].scriptSig = CScript() << CScriptNum(tx_counter);\n         tx.vin[0].scriptWitness.stack.push_back(CScriptNum(x).getvch());\n-        tx.vout.resize(det_rand.randrange(10)+2);\n+        tx.vout.resize(det_rand.randrange(DESCENDANTS_COUNT_MAX)+2);\n         for (auto& out : tx.vout) {\n             out.scriptPubKey = CScript() << CScriptNum(tx_counter) << OP_EQUAL;\n             out.nValue = 10 * COIN;\n         }\n         ordered_coins.emplace_back(MakeTransactionRef(tx));\n         available_coins.emplace_back(ordered_coins.back(), tx_counter++);\n     }\n-    for (auto x = 0; x < 800 && !available_coins.empty(); ++x) {\n+    for (size_t x = 0; x < CHILD_TXS && !available_coins.empty(); ++x) {\n         CMutableTransaction tx = CMutableTransaction();\n-        size_t n_ancestors = det_rand.randrange(10)+1;\n+        size_t n_ancestors = det_rand.randrange(ANCESTORS_COUNT_MAX)+1;\n         for (size_t ancestor = 0; ancestor < n_ancestors && !available_coins.empty(); ++ancestor){\n             size_t idx = det_rand.randrange(available_coins.size());\n             Available coin = available_coins[idx];\n@@ -64,7 +76,7 @@ static void ComplexMemPool(benchmark::State& state)\n                 coin = available_coins.back();\n                 available_coins.pop_back();\n             }\n-            tx.vout.resize(det_rand.randrange(10)+2);\n+            tx.vout.resize(det_rand.randrange(DESCENDANTS_COUNT_MAX)+2);\n             for (auto& out : tx.vout) {\n                 out.scriptPubKey = CScript() << CScriptNum(tx_counter) << OP_EQUAL;\n                 out.nValue = 10 * COIN;\n@@ -83,5 +95,9 @@ static void ComplexMemPool(benchmark::State& state)\n         pool.TrimToSize(GetVirtualTransactionSize(*ordered_coins.front()));\n     }\n }\n+static void ComplexMemPool(benchmark::State& state) {\n+    ComplexMemPoolAsymptotic(state, nullptr);\n+}\n \n BENCHMARK(ComplexMemPool, 1);\n+BENCHMARK_ASYMPTOTE(ComplexMemPoolAsymptotic);"
      }
    ]
  }
]