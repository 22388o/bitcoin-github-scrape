[
  {
    "sha": "096e06dbb5241737e2f0f1ba1c4f969d68e6e7c5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowOTZlMDZkYmI1MjQxNzM3ZTJmMGYxYmExYzRmOTY5ZDY4ZTZlN2M1",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-05-16T16:36:38Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-05-17T20:33:26Z"
      },
      "message": "Refactor: move code from key.h to key.cpp",
      "tree": {
        "sha": "124ccdf408c44ad289f0bb5a2241830e75a498f5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/124ccdf408c44ad289f0bb5a2241830e75a498f5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/096e06dbb5241737e2f0f1ba1c4f969d68e6e7c5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/096e06dbb5241737e2f0f1ba1c4f969d68e6e7c5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/096e06dbb5241737e2f0f1ba1c4f969d68e6e7c5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/096e06dbb5241737e2f0f1ba1c4f969d68e6e7c5/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "397737b9133118d71d2c8ba6a95afea0ba7d4350",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/397737b9133118d71d2c8ba6a95afea0ba7d4350",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/397737b9133118d71d2c8ba6a95afea0ba7d4350"
      }
    ],
    "stats": {
      "total": 531,
      "additions": 285,
      "deletions": 246
    },
    "files": [
      {
        "sha": "ece835d1472412b02841dcedc03043b02f4bb24f",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 262,
        "deletions": 1,
        "changes": 263,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/096e06dbb5241737e2f0f1ba1c4f969d68e6e7c5/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/096e06dbb5241737e2f0f1ba1c4f969d68e6e7c5/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=096e06dbb5241737e2f0f1ba1c4f969d68e6e7c5",
        "patch": "@@ -2,8 +2,10 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file license.txt or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <openssl/ec.h>\n #include <openssl/ecdsa.h>\n+#include <openssl/obj_mac.h>\n+\n+#include \"key.h\"\n \n // Generate a private key from just the secret parameter\n int EC_KEY_regenerate_key(EC_KEY *eckey, BIGNUM *priv_key)\n@@ -115,3 +117,262 @@ int ECDSA_SIG_recover_key_GFp(EC_KEY *eckey, ECDSA_SIG *ecsig, const unsigned ch\n     if (Q != NULL) EC_POINT_free(Q);\n     return ret;\n }\n+\n+void CKey::SetCompressedPubKey()\n+{\n+    EC_KEY_set_conv_form(pkey, POINT_CONVERSION_COMPRESSED);\n+    fCompressedPubKey = true;\n+}\n+\n+void CKey::Reset()\n+{\n+    fCompressedPubKey = false;\n+    pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n+    if (pkey == NULL)\n+        throw key_error(\"CKey::CKey() : EC_KEY_new_by_curve_name failed\");\n+    fSet = false;\n+}\n+\n+CKey::CKey()\n+{\n+    Reset();\n+}\n+\n+CKey::CKey(const CKey& b)\n+{\n+    pkey = EC_KEY_dup(b.pkey);\n+    if (pkey == NULL)\n+        throw key_error(\"CKey::CKey(const CKey&) : EC_KEY_dup failed\");\n+    fSet = b.fSet;\n+}\n+\n+CKey& CKey::operator=(const CKey& b)\n+{\n+    if (!EC_KEY_copy(pkey, b.pkey))\n+        throw key_error(\"CKey::operator=(const CKey&) : EC_KEY_copy failed\");\n+    fSet = b.fSet;\n+    return (*this);\n+}\n+\n+CKey::~CKey()\n+{\n+    EC_KEY_free(pkey);\n+}\n+\n+bool CKey::IsNull() const\n+{\n+    return !fSet;\n+}\n+\n+bool CKey::IsCompressed() const\n+{\n+    return fCompressedPubKey;\n+}\n+\n+void CKey::MakeNewKey(bool fCompressed)\n+{\n+    if (!EC_KEY_generate_key(pkey))\n+        throw key_error(\"CKey::MakeNewKey() : EC_KEY_generate_key failed\");\n+    if (fCompressed)\n+        SetCompressedPubKey();\n+    fSet = true;\n+}\n+\n+bool CKey::SetPrivKey(const CPrivKey& vchPrivKey)\n+{\n+    const unsigned char* pbegin = &vchPrivKey[0];\n+    if (!d2i_ECPrivateKey(&pkey, &pbegin, vchPrivKey.size()))\n+        return false;\n+    fSet = true;\n+    return true;\n+}\n+\n+bool CKey::SetSecret(const CSecret& vchSecret, bool fCompressed)\n+{\n+    EC_KEY_free(pkey);\n+    pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n+    if (pkey == NULL)\n+        throw key_error(\"CKey::SetSecret() : EC_KEY_new_by_curve_name failed\");\n+    if (vchSecret.size() != 32)\n+        throw key_error(\"CKey::SetSecret() : secret must be 32 bytes\");\n+    BIGNUM *bn = BN_bin2bn(&vchSecret[0],32,BN_new());\n+    if (bn == NULL)\n+        throw key_error(\"CKey::SetSecret() : BN_bin2bn failed\");\n+    if (!EC_KEY_regenerate_key(pkey,bn))\n+    {\n+        BN_clear_free(bn);\n+        throw key_error(\"CKey::SetSecret() : EC_KEY_regenerate_key failed\");\n+    }\n+    BN_clear_free(bn);\n+    fSet = true;\n+    if (fCompressed || fCompressedPubKey)\n+        SetCompressedPubKey();\n+    return true;\n+}\n+\n+CSecret CKey::GetSecret(bool &fCompressed) const\n+{\n+    CSecret vchRet;\n+    vchRet.resize(32);\n+    const BIGNUM *bn = EC_KEY_get0_private_key(pkey);\n+    int nBytes = BN_num_bytes(bn);\n+    if (bn == NULL)\n+        throw key_error(\"CKey::GetSecret() : EC_KEY_get0_private_key failed\");\n+    int n=BN_bn2bin(bn,&vchRet[32 - nBytes]);\n+    if (n != nBytes)\n+        throw key_error(\"CKey::GetSecret(): BN_bn2bin failed\");\n+    fCompressed = fCompressedPubKey;\n+    return vchRet;\n+}\n+\n+CPrivKey CKey::GetPrivKey() const\n+{\n+    int nSize = i2d_ECPrivateKey(pkey, NULL);\n+    if (!nSize)\n+        throw key_error(\"CKey::GetPrivKey() : i2d_ECPrivateKey failed\");\n+    CPrivKey vchPrivKey(nSize, 0);\n+    unsigned char* pbegin = &vchPrivKey[0];\n+    if (i2d_ECPrivateKey(pkey, &pbegin) != nSize)\n+        throw key_error(\"CKey::GetPrivKey() : i2d_ECPrivateKey returned unexpected size\");\n+    return vchPrivKey;\n+}\n+\n+bool CKey::SetPubKey(const std::vector<unsigned char>& vchPubKey)\n+{\n+    const unsigned char* pbegin = &vchPubKey[0];\n+    if (!o2i_ECPublicKey(&pkey, &pbegin, vchPubKey.size()))\n+        return false;\n+    fSet = true;\n+    if (vchPubKey.size() == 33)\n+        SetCompressedPubKey();\n+    return true;\n+}\n+\n+std::vector<unsigned char> CKey::GetPubKey() const\n+{\n+    int nSize = i2o_ECPublicKey(pkey, NULL);\n+    if (!nSize)\n+        throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey failed\");\n+    std::vector<unsigned char> vchPubKey(nSize, 0);\n+    unsigned char* pbegin = &vchPubKey[0];\n+    if (i2o_ECPublicKey(pkey, &pbegin) != nSize)\n+        throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\");\n+    return vchPubKey;\n+}\n+\n+bool CKey::Sign(uint256 hash, std::vector<unsigned char>& vchSig)\n+{\n+    unsigned int nSize = ECDSA_size(pkey);\n+    vchSig.resize(nSize); // Make sure it is big enough\n+    if (!ECDSA_sign(0, (unsigned char*)&hash, sizeof(hash), &vchSig[0], &nSize, pkey))\n+    {\n+        vchSig.clear();\n+        return false;\n+    }\n+    vchSig.resize(nSize); // Shrink to fit actual size\n+    return true;\n+}\n+\n+// create a compact signature (65 bytes), which allows reconstructing the used public key\n+// The format is one header byte, followed by two times 32 bytes for the serialized r and s values.\n+// The header byte: 0x1B = first key with even y, 0x1C = first key with odd y,\n+//                  0x1D = second key with even y, 0x1E = second key with odd y\n+bool CKey::SignCompact(uint256 hash, std::vector<unsigned char>& vchSig)\n+{\n+    bool fOk = false;\n+    ECDSA_SIG *sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n+    if (sig==NULL)\n+        return false;\n+    vchSig.clear();\n+    vchSig.resize(65,0);\n+    int nBitsR = BN_num_bits(sig->r);\n+    int nBitsS = BN_num_bits(sig->s);\n+    if (nBitsR <= 256 && nBitsS <= 256)\n+    {\n+        int nRecId = -1;\n+        for (int i=0; i<4; i++)\n+        {\n+            CKey keyRec;\n+            keyRec.fSet = true;\n+            if (fCompressedPubKey)\n+                keyRec.SetCompressedPubKey();\n+            if (ECDSA_SIG_recover_key_GFp(keyRec.pkey, sig, (unsigned char*)&hash, sizeof(hash), i, 1) == 1)\n+                if (keyRec.GetPubKey() == this->GetPubKey())\n+                {\n+                    nRecId = i;\n+                    break;\n+                }\n+        }\n+\n+        if (nRecId == -1)\n+            throw key_error(\"CKey::SignCompact() : unable to construct recoverable key\");\n+\n+        vchSig[0] = nRecId+27+(fCompressedPubKey ? 4 : 0);\n+        BN_bn2bin(sig->r,&vchSig[33-(nBitsR+7)/8]);\n+        BN_bn2bin(sig->s,&vchSig[65-(nBitsS+7)/8]);\n+        fOk = true;\n+    }\n+    ECDSA_SIG_free(sig);\n+    return fOk;\n+}\n+\n+// reconstruct public key from a compact signature\n+// This is only slightly more CPU intensive than just verifying it.\n+// If this function succeeds, the recovered public key is guaranteed to be valid\n+// (the signature is a valid signature of the given data for that key)\n+bool CKey::SetCompactSignature(uint256 hash, const std::vector<unsigned char>& vchSig)\n+{\n+    if (vchSig.size() != 65)\n+        return false;\n+    int nV = vchSig[0];\n+    if (nV<27 || nV>=35)\n+        return false;\n+    ECDSA_SIG *sig = ECDSA_SIG_new();\n+    BN_bin2bn(&vchSig[1],32,sig->r);\n+    BN_bin2bn(&vchSig[33],32,sig->s);\n+\n+    EC_KEY_free(pkey);\n+    pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n+    if (nV >= 31)\n+    {\n+        SetCompressedPubKey();\n+        nV -= 4;\n+    }\n+    if (ECDSA_SIG_recover_key_GFp(pkey, sig, (unsigned char*)&hash, sizeof(hash), nV - 27, 0) == 1)\n+    {\n+        fSet = true;\n+        ECDSA_SIG_free(sig);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+bool CKey::Verify(uint256 hash, const std::vector<unsigned char>& vchSig)\n+{\n+    // -1 = error, 0 = bad sig, 1 = good\n+    if (ECDSA_verify(0, (unsigned char*)&hash, sizeof(hash), &vchSig[0], vchSig.size(), pkey) != 1)\n+        return false;\n+    return true;\n+}\n+\n+bool CKey::VerifyCompact(uint256 hash, const std::vector<unsigned char>& vchSig)\n+{\n+    CKey key;\n+    if (!key.SetCompactSignature(hash, vchSig))\n+        return false;\n+    if (GetPubKey() != key.GetPubKey())\n+        return false;\n+    return true;\n+}\n+\n+bool CKey::IsValid()\n+{\n+    if (!fSet)\n+        return false;\n+\n+    bool fCompr;\n+    CSecret secret = GetSecret(fCompr);\n+    CKey key2;\n+    key2.SetSecret(secret, fCompr);\n+    return GetPubKey() == key2.GetPubKey();\n+}"
      },
      {
        "sha": "f7255fcaf567bd601d6df81ce600c026d339353c",
        "filename": "src/key.h",
        "status": "modified",
        "additions": 23,
        "deletions": 245,
        "changes": 268,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/096e06dbb5241737e2f0f1ba1c4f969d68e6e7c5/src/key.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/096e06dbb5241737e2f0f1ba1c4f969d68e6e7c5/src/key.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.h?ref=096e06dbb5241737e2f0f1ba1c4f969d68e6e7c5",
        "patch": "@@ -8,13 +8,11 @@\n #include <stdexcept>\n #include <vector>\n \n-#include <openssl/ec.h>\n-#include <openssl/ecdsa.h>\n-#include <openssl/obj_mac.h>\n-\n #include \"allocators.h\"\n #include \"uint256.h\"\n \n+#include <openssl/ec.h> // for EC_KEY definition\n+\n // secp160k1\n // const unsigned int PRIVATE_KEY_SIZE = 192;\n // const unsigned int PUBLIC_KEY_SIZE  = 41;\n@@ -38,9 +36,6 @@\n // see www.keylength.com\n // script supports up to 75 for single byte push\n \n-int extern EC_KEY_regenerate_key(EC_KEY *eckey, BIGNUM *priv_key);\n-int extern ECDSA_SIG_recover_key_GFp(EC_KEY *eckey, ECDSA_SIG *ecsig, const unsigned char *msg, int msglen, int recid, int check);\n-\n class key_error : public std::runtime_error\n {\n public:\n@@ -62,267 +57,50 @@ class CKey\n     bool fSet;\n     bool fCompressedPubKey;\n \n-    void SetCompressedPubKey()\n-    {\n-        EC_KEY_set_conv_form(pkey, POINT_CONVERSION_COMPRESSED);\n-        fCompressedPubKey = true;\n-    }\n+    void SetCompressedPubKey();\n \n public:\n \n-    void Reset()\n-    {\n-        fCompressedPubKey = false;\n-        pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n-        if (pkey == NULL)\n-            throw key_error(\"CKey::CKey() : EC_KEY_new_by_curve_name failed\");\n-        fSet = false;\n-    }\n-\n-    CKey()\n-    {\n-        Reset();\n-    }\n-\n-    CKey(const CKey& b)\n-    {\n-        pkey = EC_KEY_dup(b.pkey);\n-        if (pkey == NULL)\n-            throw key_error(\"CKey::CKey(const CKey&) : EC_KEY_dup failed\");\n-        fSet = b.fSet;\n-    }\n-\n-    CKey& operator=(const CKey& b)\n-    {\n-        if (!EC_KEY_copy(pkey, b.pkey))\n-            throw key_error(\"CKey::operator=(const CKey&) : EC_KEY_copy failed\");\n-        fSet = b.fSet;\n-        return (*this);\n-    }\n-\n-    ~CKey()\n-    {\n-        EC_KEY_free(pkey);\n-    }\n-\n-    bool IsNull() const\n-    {\n-        return !fSet;\n-    }\n+    void Reset();\n \n-    bool IsCompressed() const\n-    {\n-        return fCompressedPubKey;\n-    }\n+    CKey();\n+    CKey(const CKey& b);\n \n-    void MakeNewKey(bool fCompressed)\n-    {\n-        if (!EC_KEY_generate_key(pkey))\n-            throw key_error(\"CKey::MakeNewKey() : EC_KEY_generate_key failed\");\n-        if (fCompressed)\n-            SetCompressedPubKey();\n-        fSet = true;\n-    }\n+    CKey& operator=(const CKey& b);\n \n-    bool SetPrivKey(const CPrivKey& vchPrivKey)\n-    {\n-        const unsigned char* pbegin = &vchPrivKey[0];\n-        if (!d2i_ECPrivateKey(&pkey, &pbegin, vchPrivKey.size()))\n-            return false;\n-        fSet = true;\n-        return true;\n-    }\n+    ~CKey();\n \n-    bool SetSecret(const CSecret& vchSecret, bool fCompressed = false)\n-    {\n-        EC_KEY_free(pkey);\n-        pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n-        if (pkey == NULL)\n-            throw key_error(\"CKey::SetSecret() : EC_KEY_new_by_curve_name failed\");\n-        if (vchSecret.size() != 32)\n-            throw key_error(\"CKey::SetSecret() : secret must be 32 bytes\");\n-        BIGNUM *bn = BN_bin2bn(&vchSecret[0],32,BN_new());\n-        if (bn == NULL)\n-            throw key_error(\"CKey::SetSecret() : BN_bin2bn failed\");\n-        if (!EC_KEY_regenerate_key(pkey,bn))\n-        {\n-            BN_clear_free(bn);\n-            throw key_error(\"CKey::SetSecret() : EC_KEY_regenerate_key failed\");\n-        }\n-        BN_clear_free(bn);\n-        fSet = true;\n-        if (fCompressed || fCompressedPubKey)\n-            SetCompressedPubKey();\n-        return true;\n-    }\n+    bool IsNull() const;\n+    bool IsCompressed() const;\n \n-    CSecret GetSecret(bool &fCompressed) const\n-    {\n-        CSecret vchRet;\n-        vchRet.resize(32);\n-        const BIGNUM *bn = EC_KEY_get0_private_key(pkey);\n-        int nBytes = BN_num_bytes(bn);\n-        if (bn == NULL)\n-            throw key_error(\"CKey::GetSecret() : EC_KEY_get0_private_key failed\");\n-        int n=BN_bn2bin(bn,&vchRet[32 - nBytes]);\n-        if (n != nBytes) \n-            throw key_error(\"CKey::GetSecret(): BN_bn2bin failed\");\n-        fCompressed = fCompressedPubKey;\n-        return vchRet;\n-    }\n+    void MakeNewKey(bool fCompressed);\n+    bool SetPrivKey(const CPrivKey& vchPrivKey);\n+    bool SetSecret(const CSecret& vchSecret, bool fCompressed = false);\n+    CSecret GetSecret(bool &fCompressed) const;\n+    CPrivKey GetPrivKey() const;\n+    bool SetPubKey(const std::vector<unsigned char>& vchPubKey);\n+    std::vector<unsigned char> GetPubKey() const;\n \n-    CPrivKey GetPrivKey() const\n-    {\n-        int nSize = i2d_ECPrivateKey(pkey, NULL);\n-        if (!nSize)\n-            throw key_error(\"CKey::GetPrivKey() : i2d_ECPrivateKey failed\");\n-        CPrivKey vchPrivKey(nSize, 0);\n-        unsigned char* pbegin = &vchPrivKey[0];\n-        if (i2d_ECPrivateKey(pkey, &pbegin) != nSize)\n-            throw key_error(\"CKey::GetPrivKey() : i2d_ECPrivateKey returned unexpected size\");\n-        return vchPrivKey;\n-    }\n-\n-    bool SetPubKey(const std::vector<unsigned char>& vchPubKey)\n-    {\n-        const unsigned char* pbegin = &vchPubKey[0];\n-        if (!o2i_ECPublicKey(&pkey, &pbegin, vchPubKey.size()))\n-            return false;\n-        fSet = true;\n-        if (vchPubKey.size() == 33)\n-            SetCompressedPubKey();\n-        return true;\n-    }\n-\n-    std::vector<unsigned char> GetPubKey() const\n-    {\n-        int nSize = i2o_ECPublicKey(pkey, NULL);\n-        if (!nSize)\n-            throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey failed\");\n-        std::vector<unsigned char> vchPubKey(nSize, 0);\n-        unsigned char* pbegin = &vchPubKey[0];\n-        if (i2o_ECPublicKey(pkey, &pbegin) != nSize)\n-            throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\");\n-        return vchPubKey;\n-    }\n-\n-    bool Sign(uint256 hash, std::vector<unsigned char>& vchSig)\n-    {\n-        unsigned int nSize = ECDSA_size(pkey);\n-        vchSig.resize(nSize); // Make sure it is big enough\n-        if (!ECDSA_sign(0, (unsigned char*)&hash, sizeof(hash), &vchSig[0], &nSize, pkey))\n-        {\n-            vchSig.clear();\n-            return false;\n-        }\n-        vchSig.resize(nSize); // Shrink to fit actual size\n-        return true;\n-    }\n+    bool Sign(uint256 hash, std::vector<unsigned char>& vchSig);\n \n     // create a compact signature (65 bytes), which allows reconstructing the used public key\n     // The format is one header byte, followed by two times 32 bytes for the serialized r and s values.\n     // The header byte: 0x1B = first key with even y, 0x1C = first key with odd y,\n     //                  0x1D = second key with even y, 0x1E = second key with odd y\n-    bool SignCompact(uint256 hash, std::vector<unsigned char>& vchSig)\n-    {\n-        bool fOk = false;\n-        ECDSA_SIG *sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n-        if (sig==NULL)\n-            return false;\n-        vchSig.clear();\n-        vchSig.resize(65,0);\n-        int nBitsR = BN_num_bits(sig->r);\n-        int nBitsS = BN_num_bits(sig->s);\n-        if (nBitsR <= 256 && nBitsS <= 256)\n-        {\n-            int nRecId = -1;\n-            for (int i=0; i<4; i++)\n-            {\n-                CKey keyRec;\n-                keyRec.fSet = true;\n-                if (fCompressedPubKey)\n-                    keyRec.SetCompressedPubKey();\n-                if (ECDSA_SIG_recover_key_GFp(keyRec.pkey, sig, (unsigned char*)&hash, sizeof(hash), i, 1) == 1)\n-                    if (keyRec.GetPubKey() == this->GetPubKey())\n-                    {\n-                        nRecId = i;\n-                        break;\n-                    }\n-            }\n-\n-            if (nRecId == -1)\n-                throw key_error(\"CKey::SignCompact() : unable to construct recoverable key\");\n-\n-            vchSig[0] = nRecId+27+(fCompressedPubKey ? 4 : 0);\n-            BN_bn2bin(sig->r,&vchSig[33-(nBitsR+7)/8]);\n-            BN_bn2bin(sig->s,&vchSig[65-(nBitsS+7)/8]);\n-            fOk = true;\n-        }\n-        ECDSA_SIG_free(sig);\n-        return fOk;\n-    }\n+    bool SignCompact(uint256 hash, std::vector<unsigned char>& vchSig);\n \n     // reconstruct public key from a compact signature\n     // This is only slightly more CPU intensive than just verifying it.\n     // If this function succeeds, the recovered public key is guaranteed to be valid\n     // (the signature is a valid signature of the given data for that key)\n-    bool SetCompactSignature(uint256 hash, const std::vector<unsigned char>& vchSig)\n-    {\n-        if (vchSig.size() != 65)\n-            return false;\n-        int nV = vchSig[0];\n-        if (nV<27 || nV>=35)\n-            return false;\n-        ECDSA_SIG *sig = ECDSA_SIG_new();\n-        BN_bin2bn(&vchSig[1],32,sig->r);\n-        BN_bin2bn(&vchSig[33],32,sig->s);\n-\n-        EC_KEY_free(pkey);\n-        pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n-        if (nV >= 31)\n-        {\n-            SetCompressedPubKey();\n-            nV -= 4;\n-        }\n-        if (ECDSA_SIG_recover_key_GFp(pkey, sig, (unsigned char*)&hash, sizeof(hash), nV - 27, 0) == 1)\n-        {\n-            fSet = true;\n-            ECDSA_SIG_free(sig);\n-            return true;\n-        }\n-        return false;\n-    }\n+    bool SetCompactSignature(uint256 hash, const std::vector<unsigned char>& vchSig);\n \n-    bool Verify(uint256 hash, const std::vector<unsigned char>& vchSig)\n-    {\n-        // -1 = error, 0 = bad sig, 1 = good\n-        if (ECDSA_verify(0, (unsigned char*)&hash, sizeof(hash), &vchSig[0], vchSig.size(), pkey) != 1)\n-            return false;\n-        return true;\n-    }\n+    bool Verify(uint256 hash, const std::vector<unsigned char>& vchSig);\n \n     // Verify a compact signature\n-    bool VerifyCompact(uint256 hash, const std::vector<unsigned char>& vchSig)\n-    {\n-        CKey key;\n-        if (!key.SetCompactSignature(hash, vchSig))\n-            return false;\n-        if (GetPubKey() != key.GetPubKey())\n-            return false;\n-        return true;\n-    }\n-\n-    bool IsValid()\n-    {\n-        if (!fSet)\n-            return false;\n+    bool VerifyCompact(uint256 hash, const std::vector<unsigned char>& vchSig);\n \n-        bool fCompr;\n-        CSecret secret = GetSecret(fCompr);\n-        CKey key2;\n-        key2.SetSecret(secret, fCompr);\n-        return GetPubKey() == key2.GetPubKey();\n-    }\n+    bool IsValid();\n };\n \n #endif"
      }
    ]
  },
  {
    "sha": "f718aedd9f244ee77a40f182bf6c6737730d975c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNzE4YWVkZDlmMjQ0ZWU3N2E0MGYxODJiZjZjNjczNzczMGQ5NzVj",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-05-17T16:13:14Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-05-17T20:33:27Z"
      },
      "message": "Refactor: GetRandHash() method for util",
      "tree": {
        "sha": "087a1464b04bb598e1bda62224495b90e821d3af",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/087a1464b04bb598e1bda62224495b90e821d3af"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f718aedd9f244ee77a40f182bf6c6737730d975c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f718aedd9f244ee77a40f182bf6c6737730d975c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f718aedd9f244ee77a40f182bf6c6737730d975c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f718aedd9f244ee77a40f182bf6c6737730d975c/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "096e06dbb5241737e2f0f1ba1c4f969d68e6e7c5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/096e06dbb5241737e2f0f1ba1c4f969d68e6e7c5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/096e06dbb5241737e2f0f1ba1c4f969d68e6e7c5"
      }
    ],
    "stats": {
      "total": 27,
      "additions": 12,
      "deletions": 15
    },
    "files": [
      {
        "sha": "d006510d1a4fc899ff92814e8058fd44b7499eee",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f718aedd9f244ee77a40f182bf6c6737730d975c/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f718aedd9f244ee77a40f182bf6c6737730d975c/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=f718aedd9f244ee77a40f182bf6c6737730d975c",
        "patch": "@@ -201,9 +201,7 @@ unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)\n     while (mapOrphanTransactions.size() > nMaxOrphans)\n     {\n         // Evict a random orphan:\n-        std::vector<unsigned char> randbytes(32);\n-        RAND_bytes(&randbytes[0], 32);\n-        uint256 randomhash(randbytes);\n+        uint256 randomhash = GetRandHash();\n         map<uint256, CDataStream*>::iterator it = mapOrphanTransactions.lower_bound(randomhash);\n         if (it == mapOrphanTransactions.end())\n             it = mapOrphanTransactions.begin();\n@@ -2354,7 +2352,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                     // at a time so the setAddrKnowns of the chosen nodes prevent repeats\n                     static uint256 hashSalt;\n                     if (hashSalt == 0)\n-                        RAND_bytes((unsigned char*)&hashSalt, sizeof(hashSalt));\n+                        hashSalt = GetRandHash();\n                     int64 hashAddr = addr.GetHash();\n                     uint256 hashRand = hashSalt ^ (hashAddr<<32) ^ ((GetTime()+hashAddr)/(24*60*60));\n                     hashRand = Hash(BEGIN(hashRand), END(hashRand));\n@@ -2945,7 +2943,7 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n                     // 1/4 of tx invs blast to all immediately\n                     static uint256 hashSalt;\n                     if (hashSalt == 0)\n-                        RAND_bytes((unsigned char*)&hashSalt, sizeof(hashSalt));\n+                        hashSalt = GetRandHash();\n                     uint256 hashRand = inv.hash ^ hashSalt;\n                     hashRand = Hash(BEGIN(hashRand), END(hashRand));\n                     bool fTrickleWait = ((hashRand & 3) != 0);"
      },
      {
        "sha": "3a2b1d9d54f08228f6e6b70a7c7ed29655171657",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 10,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f718aedd9f244ee77a40f182bf6c6737730d975c/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f718aedd9f244ee77a40f182bf6c6737730d975c/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=f718aedd9f244ee77a40f182bf6c6737730d975c",
        "patch": "@@ -129,18 +129,10 @@ BOOST_AUTO_TEST_CASE(DoS_checknbits)\n     \n }\n \n-static uint256 RandomHash()\n-{\n-    std::vector<unsigned char> randbytes(32);\n-    RAND_bytes(&randbytes[0], 32);\n-    uint256 randomhash(randbytes);\n-    return randomhash;\n-}\n-\n CTransaction RandomOrphan()\n {\n     std::map<uint256, CDataStream*>::iterator it;\n-    it = mapOrphanTransactions.lower_bound(RandomHash());\n+    it = mapOrphanTransactions.lower_bound(GetRandHash());\n     if (it == mapOrphanTransactions.end())\n         it = mapOrphanTransactions.begin();\n     const CDataStream* pvMsg = it->second;\n@@ -162,7 +154,7 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n         CTransaction tx;\n         tx.vin.resize(1);\n         tx.vin[0].prevout.n = 0;\n-        tx.vin[0].prevout.hash = RandomHash();\n+        tx.vin[0].prevout.hash = GetRandHash();\n         tx.vin[0].scriptSig << OP_1;\n         tx.vout.resize(1);\n         tx.vout[0].nValue = 1*CENT;"
      },
      {
        "sha": "d8804c729125aa5d2a5b120df58b5c05bfe0c82a",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f718aedd9f244ee77a40f182bf6c6737730d975c/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f718aedd9f244ee77a40f182bf6c6737730d975c/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=f718aedd9f244ee77a40f182bf6c6737730d975c",
        "patch": "@@ -174,6 +174,12 @@ int GetRandInt(int nMax)\n     return GetRand(nMax);\n }\n \n+uint256 GetRandHash()\n+{\n+    uint256 hash;\n+    RAND_bytes((unsigned char*)&hash, sizeof(hash));\n+    return hash;\n+}\n \n \n "
      },
      {
        "sha": "01f09747c4c569697fe198047eb906cc348548a1",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f718aedd9f244ee77a40f182bf6c6737730d975c/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f718aedd9f244ee77a40f182bf6c6737730d975c/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=f718aedd9f244ee77a40f182bf6c6737730d975c",
        "patch": "@@ -168,6 +168,7 @@ bool SetStartOnSystemStartup(bool fAutoStart);\n void ShrinkDebugFile();\n int GetRandInt(int nMax);\n uint64 GetRand(uint64 nMax);\n+uint256 GetRandHash();\n int64 GetTime();\n void SetMockTime(int64 nMockTimeIn);\n int64 GetAdjustedTime();"
      }
    ]
  },
  {
    "sha": "77b99cf7ad8f15f6228b07d5d01cb20c849519b8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3N2I5OWNmN2FkOGYxNWY2MjI4YjA3ZDVkMDFjYjIwYzg0OTUxOWI4",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-05-15T19:53:30Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-05-18T14:13:21Z"
      },
      "message": "Optimize orphan transaction handling\n\nChanges suggested by Sergio Demian Lerner to\nhelp prevent potential DoS attacks.",
      "tree": {
        "sha": "67ce38adebe3b5cd8b22a4c432d0282f40d45d54",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/67ce38adebe3b5cd8b22a4c432d0282f40d45d54"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/77b99cf7ad8f15f6228b07d5d01cb20c849519b8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/77b99cf7ad8f15f6228b07d5d01cb20c849519b8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/77b99cf7ad8f15f6228b07d5d01cb20c849519b8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/77b99cf7ad8f15f6228b07d5d01cb20c849519b8/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f718aedd9f244ee77a40f182bf6c6737730d975c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f718aedd9f244ee77a40f182bf6c6737730d975c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f718aedd9f244ee77a40f182bf6c6737730d975c"
      }
    ],
    "stats": {
      "total": 76,
      "additions": 58,
      "deletions": 18
    },
    "files": [
      {
        "sha": "59d8bc80107e9f3c296df2e6abbfdd2c05214e55",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 16,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77b99cf7ad8f15f6228b07d5d01cb20c849519b8/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77b99cf7ad8f15f6228b07d5d01cb20c849519b8/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=77b99cf7ad8f15f6228b07d5d01cb20c849519b8",
        "patch": "@@ -43,7 +43,7 @@ map<uint256, CBlock*> mapOrphanBlocks;\n multimap<uint256, CBlock*> mapOrphanBlocksByPrev;\n \n map<uint256, CDataStream*> mapOrphanTransactions;\n-multimap<uint256, CDataStream*> mapOrphanTransactionsByPrev;\n+map<uint256, map<uint256, CDataStream*> > mapOrphanTransactionsByPrev;\n \n // Constant stuff for coinbase transactions we create:\n CScript COINBASE_FLAGS;\n@@ -160,17 +160,37 @@ void static ResendWalletTransactions()\n // mapOrphanTransactions\n //\n \n-void AddOrphanTx(const CDataStream& vMsg)\n+bool AddOrphanTx(const CDataStream& vMsg)\n {\n     CTransaction tx;\n     CDataStream(vMsg) >> tx;\n     uint256 hash = tx.GetHash();\n     if (mapOrphanTransactions.count(hash))\n-        return;\n+        return false;\n+\n+    CDataStream* pvMsg = new CDataStream(vMsg);\n+\n+    // Ignore big transactions, to avoid a\n+    // send-big-orphans memory exhaustion attack. If a peer has a legitimate\n+    // large transaction with a missing parent then we assume\n+    // it will rebroadcast it later, after the parent transaction(s)\n+    // have been mined or received.\n+    // 10,000 orphans, each of which is at most 5,000 bytes big is\n+    // at most 500 megabytes of orphans:\n+    if (pvMsg->size() > 5000)\n+    {\n+        delete pvMsg;\n+        printf(\"ignoring large orphan tx (size: %u, hash: %s)\\n\", pvMsg->size(), hash.ToString().substr(0,10).c_str());\n+        return false;\n+    }\n \n-    CDataStream* pvMsg = mapOrphanTransactions[hash] = new CDataStream(vMsg);\n+    mapOrphanTransactions[hash] = pvMsg;\n     BOOST_FOREACH(const CTxIn& txin, tx.vin)\n-        mapOrphanTransactionsByPrev.insert(make_pair(txin.prevout.hash, pvMsg));\n+        mapOrphanTransactionsByPrev[txin.prevout.hash].insert(make_pair(hash, pvMsg));\n+\n+    printf(\"stored orphan tx %s (mapsz %u)\\n\", hash.ToString().substr(0,10).c_str(),\n+        mapOrphanTransactions.size());\n+    return true;\n }\n \n void static EraseOrphanTx(uint256 hash)\n@@ -182,14 +202,9 @@ void static EraseOrphanTx(uint256 hash)\n     CDataStream(*pvMsg) >> tx;\n     BOOST_FOREACH(const CTxIn& txin, tx.vin)\n     {\n-        for (multimap<uint256, CDataStream*>::iterator mi = mapOrphanTransactionsByPrev.lower_bound(txin.prevout.hash);\n-             mi != mapOrphanTransactionsByPrev.upper_bound(txin.prevout.hash);)\n-        {\n-            if ((*mi).second == pvMsg)\n-                mapOrphanTransactionsByPrev.erase(mi++);\n-            else\n-                mi++;\n-        }\n+        mapOrphanTransactionsByPrev[txin.prevout.hash].erase(hash);\n+        if (mapOrphanTransactionsByPrev[txin.prevout.hash].empty())\n+            mapOrphanTransactionsByPrev.erase(txin.prevout.hash);\n     }\n     delete pvMsg;\n     mapOrphanTransactions.erase(hash);\n@@ -2569,8 +2584,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n             for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n             {\n                 uint256 hashPrev = vWorkQueue[i];\n-                for (multimap<uint256, CDataStream*>::iterator mi = mapOrphanTransactionsByPrev.lower_bound(hashPrev);\n-                     mi != mapOrphanTransactionsByPrev.upper_bound(hashPrev);\n+                for (map<uint256, CDataStream*>::iterator mi = mapOrphanTransactionsByPrev[hashPrev].begin();\n+                     mi != mapOrphanTransactionsByPrev[hashPrev].end();\n                      ++mi)\n                 {\n                     const CDataStream& vMsg = *((*mi).second);\n@@ -2594,7 +2609,6 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         }\n         else if (fMissingInputs)\n         {\n-            printf(\"storing orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n             AddOrphanTx(vMsg);\n \n             // DoS prevention: do not allow mapOrphanTransactions to grow unbounded"
      },
      {
        "sha": "c0d414d0830e36f43fbd6c806712819fab3a3d20",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 2,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77b99cf7ad8f15f6228b07d5d01cb20c849519b8/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77b99cf7ad8f15f6228b07d5d01cb20c849519b8/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=77b99cf7ad8f15f6228b07d5d01cb20c849519b8",
        "patch": "@@ -13,10 +13,10 @@\n #include <stdint.h>\n \n // Tests this internal-to-main.cpp method:\n-extern void AddOrphanTx(const CDataStream& vMsg);\n+extern bool AddOrphanTx(const CDataStream& vMsg);\n extern unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans);\n extern std::map<uint256, CDataStream*> mapOrphanTransactions;\n-extern std::multimap<uint256, CDataStream*> mapOrphanTransactionsByPrev;\n+extern std::map<uint256, std::map<uint256, CDataStream*> > mapOrphanTransactionsByPrev;\n \n CService ip(uint32_t i)\n {\n@@ -184,6 +184,32 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n         AddOrphanTx(ds);\n     }\n \n+    // This really-big orphan should be ignored:\n+    for (int i = 0; i < 10; i++)\n+    {\n+        CTransaction txPrev = RandomOrphan();\n+\n+        CTransaction tx;\n+        tx.vout.resize(1);\n+        tx.vout[0].nValue = 1*CENT;\n+        tx.vout[0].scriptPubKey.SetBitcoinAddress(key.GetPubKey());\n+        tx.vin.resize(500);\n+        for (int j = 0; j < tx.vin.size(); j++)\n+        {\n+            tx.vin[j].prevout.n = j;\n+            tx.vin[j].prevout.hash = txPrev.GetHash();\n+        }\n+        SignSignature(keystore, txPrev, tx, 0);\n+        // Re-use same signature for other inputs\n+        // (they don't have to be valid for this test)\n+        for (int j = 1; j < tx.vin.size(); j++)\n+            tx.vin[j].scriptSig = tx.vin[0].scriptSig;\n+\n+        CDataStream ds(SER_DISK, CLIENT_VERSION);\n+        ds << tx;\n+        BOOST_CHECK(!AddOrphanTx(ds));\n+    }\n+\n     // Test LimitOrphanTxSize() function:\n     LimitOrphanTxSize(40);\n     BOOST_CHECK(mapOrphanTransactions.size() <= 40);"
      }
    ]
  },
  {
    "sha": "7a15109c043f8182cc996bf762f0a62c72646ff9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3YTE1MTA5YzA0M2Y4MTgyY2M5OTZiZjc2MmYwYTYyYzcyNjQ2ZmY5",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-05-17T14:12:04Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-05-18T14:41:17Z"
      },
      "message": "Remove invalid dependent orphans from memory\n\nRemove orphan transactions from memory once\nall of their parent transactions are received\nand they're still not valid.\nThanks to Sergio Demian Lerner for suggesting this fix.",
      "tree": {
        "sha": "16c2d6a1b223b8efa02ac8f5b05bc53555bba53d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/16c2d6a1b223b8efa02ac8f5b05bc53555bba53d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7a15109c043f8182cc996bf762f0a62c72646ff9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7a15109c043f8182cc996bf762f0a62c72646ff9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7a15109c043f8182cc996bf762f0a62c72646ff9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7a15109c043f8182cc996bf762f0a62c72646ff9/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "77b99cf7ad8f15f6228b07d5d01cb20c849519b8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/77b99cf7ad8f15f6228b07d5d01cb20c849519b8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/77b99cf7ad8f15f6228b07d5d01cb20c849519b8"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 12,
      "deletions": 2
    },
    "files": [
      {
        "sha": "a878d1e5be027fa0f7af0505b710594d712e8e21",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 2,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a15109c043f8182cc996bf762f0a62c72646ff9/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a15109c043f8182cc996bf762f0a62c72646ff9/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=7a15109c043f8182cc996bf762f0a62c72646ff9",
        "patch": "@@ -2564,6 +2564,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n     else if (strCommand == \"tx\")\n     {\n         vector<uint256> vWorkQueue;\n+        vector<uint256> vEraseQueue;\n         CDataStream vMsg(vRecv);\n         CTxDB txdb(\"r\");\n         CTransaction tx;\n@@ -2579,6 +2580,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n             RelayMessage(inv, vMsg);\n             mapAlreadyAskedFor.erase(inv);\n             vWorkQueue.push_back(inv.hash);\n+            vEraseQueue.push_back(inv.hash);\n \n             // Recursively process any orphan transactions that depended on this one\n             for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n@@ -2592,19 +2594,27 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                     CTransaction tx;\n                     CDataStream(vMsg) >> tx;\n                     CInv inv(MSG_TX, tx.GetHash());\n+                    bool fMissingInputs2 = false;\n \n-                    if (tx.AcceptToMemoryPool(txdb, true))\n+                    if (tx.AcceptToMemoryPool(txdb, true, &fMissingInputs2))\n                     {\n                         printf(\"   accepted orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n                         SyncWithWallets(tx, NULL, true);\n                         RelayMessage(inv, vMsg);\n                         mapAlreadyAskedFor.erase(inv);\n                         vWorkQueue.push_back(inv.hash);\n+                        vEraseQueue.push_back(inv.hash);\n+                    }\n+                    else if (!fMissingInputs2)\n+                    {\n+                        // invalid orphan\n+                        vEraseQueue.push_back(inv.hash);\n+                        printf(\"   removed invalid orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n                     }\n                 }\n             }\n \n-            BOOST_FOREACH(uint256 hash, vWorkQueue)\n+            BOOST_FOREACH(uint256 hash, vEraseQueue)\n                 EraseOrphanTx(hash);\n         }\n         else if (fMissingInputs)"
      }
    ]
  },
  {
    "sha": "4add41a2a6fa1229277e00e01a8b4111e7cb21d6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0YWRkNDFhMmE2ZmExMjI5Mjc3ZTAwZTAxYThiNDExMWU3Y2IyMWQ2",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-05-16T15:26:56Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-05-18T14:41:18Z"
      },
      "message": "Further DoS prevention: Verify signatures last\n\nLoop over all inputs doing inexpensive validity checks first,\nand then loop over them a second time doing expensive signature\nchecks. This helps prevent possible CPU exhaustion attacks\nwhere an attacker tries to make a victim waste time checking\nsignatures for invalid transactions.",
      "tree": {
        "sha": "e14aa5904fa0d5597074ee80585db52ff3789612",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e14aa5904fa0d5597074ee80585db52ff3789612"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4add41a2a6fa1229277e00e01a8b4111e7cb21d6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4add41a2a6fa1229277e00e01a8b4111e7cb21d6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4add41a2a6fa1229277e00e01a8b4111e7cb21d6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4add41a2a6fa1229277e00e01a8b4111e7cb21d6/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7a15109c043f8182cc996bf762f0a62c72646ff9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7a15109c043f8182cc996bf762f0a62c72646ff9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7a15109c043f8182cc996bf762f0a62c72646ff9"
      }
    ],
    "stats": {
      "total": 21,
      "additions": 16,
      "deletions": 5
    },
    "files": [
      {
        "sha": "263f1e6fee36f45341284aafb4bd415144c9826f",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 5,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4add41a2a6fa1229277e00e01a8b4111e7cb21d6/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4add41a2a6fa1229277e00e01a8b4111e7cb21d6/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=4add41a2a6fa1229277e00e01a8b4111e7cb21d6",
        "patch": "@@ -1142,17 +1142,28 @@ bool CTransaction::ConnectInputs(MapPrevTx inputs,\n                     if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)\n                         return error(\"ConnectInputs() : tried to spend coinbase at depth %d\", pindexBlock->nHeight - pindex->nHeight);\n \n+            // Check for negative or overflow input values\n+            nValueIn += txPrev.vout[prevout.n].nValue;\n+            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n+                return DoS(100, error(\"ConnectInputs() : txin values out of range\"));\n+\n+        }\n+        // The first loop above does all the inexpensive checks.\n+        // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n+        // Helps prevent CPU exhaustion attacks.\n+        for (unsigned int i = 0; i < vin.size(); i++)\n+        {\n+            COutPoint prevout = vin[i].prevout;\n+            assert(inputs.count(prevout.hash) > 0);\n+            CTxIndex& txindex = inputs[prevout.hash].first;\n+            CTransaction& txPrev = inputs[prevout.hash].second;\n+\n             // Check for conflicts (double-spend)\n             // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n             // for an attacker to attempt to split the network.\n             if (!txindex.vSpent[prevout.n].IsNull())\n                 return fMiner ? false : error(\"ConnectInputs() : %s prev tx already used at %s\", GetHash().ToString().substr(0,10).c_str(), txindex.vSpent[prevout.n].ToString().c_str());\n \n-            // Check for negative or overflow input values\n-            nValueIn += txPrev.vout[prevout.n].nValue;\n-            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n-                return DoS(100, error(\"ConnectInputs() : txin values out of range\"));\n-\n             // Skip ECDSA signature verification when connecting blocks (fBlock=true)\n             // before the last blockchain checkpoint. This is safe because block merkle hashes are\n             // still computed and checked, and any change will be caught at the next checkpoint."
      }
    ]
  },
  {
    "sha": "62922c8ab030953f159b9433e8a8703ab64cea02",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MjkyMmM4YWIwMzA5NTNmMTU5Yjk0MzNlOGE4NzAzYWI2NGNlYTAy",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-05-16T19:57:04Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-05-18T14:41:18Z"
      },
      "message": "Cache signature verifications\n\nCreate a maximum-10MB signature verification result cache.\nThis should almost double the number of transactions that\ncan be processed on a given CPU, because before this change\nECDSA signatures were verified when transactions were added\nto the memory pool and then again when they appeared in\na block.",
      "tree": {
        "sha": "325342bf62847bba78a688b37e93ab2098ccdcab",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/325342bf62847bba78a688b37e93ab2098ccdcab"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/62922c8ab030953f159b9433e8a8703ab64cea02",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/62922c8ab030953f159b9433e8a8703ab64cea02",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/62922c8ab030953f159b9433e8a8703ab64cea02",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/62922c8ab030953f159b9433e8a8703ab64cea02/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4add41a2a6fa1229277e00e01a8b4111e7cb21d6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4add41a2a6fa1229277e00e01a8b4111e7cb21d6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4add41a2a6fa1229277e00e01a8b4111e7cb21d6"
      }
    ],
    "stats": {
      "total": 161,
      "additions": 160,
      "deletions": 1
    },
    "files": [
      {
        "sha": "ac7ac4db775670888f3b2a574460708f2bcbbc4d",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 68,
        "deletions": 0,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/62922c8ab030953f159b9433e8a8703ab64cea02/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/62922c8ab030953f159b9433e8a8703ab64cea02/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=62922c8ab030953f159b9433e8a8703ab64cea02",
        "patch": "@@ -2,10 +2,14 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file license.txt or http://www.opensource.org/licenses/mit-license.php.\n \n+#include <map>\n+\n+#include <boost/tuple/tuple.hpp>\n #include <openssl/ecdsa.h>\n #include <openssl/obj_mac.h>\n \n #include \"key.h\"\n+#include \"util.h\"\n \n // Generate a private key from just the secret parameter\n int EC_KEY_regenerate_key(EC_KEY *eckey, BIGNUM *priv_key)\n@@ -347,21 +351,85 @@ bool CKey::SetCompactSignature(uint256 hash, const std::vector<unsigned char>& v\n     return false;\n }\n \n+// Valid signature cache, to avoid doing expensive ECDSA signature checking\n+// twice for every transaction (once when accepted into memory pool, and\n+// again when accepted into the block chain)\n+\n+// sigdata_type is (signature hash, signature, public key):\n+typedef boost::tuple<uint256, std::vector<unsigned char>, std::vector<unsigned char> > sigdata_type;\n+static std::set< sigdata_type> setValidSigCache;\n+static CCriticalSection cs_sigcache;\n+\n+static bool\n+GetValidSigCache(uint256 hash, const std::vector<unsigned char>& vchSig, const std::vector<unsigned char>& pubKey)\n+{\n+    LOCK(cs_sigcache);\n+\n+    sigdata_type k(hash, vchSig, pubKey);\n+    std::set<sigdata_type>::iterator mi = setValidSigCache.find(k);\n+    if (mi != setValidSigCache.end())\n+        return true;\n+    return false;\n+}\n+\n+static void\n+SetValidSigCache(uint256 hash, const std::vector<unsigned char>& vchSig, const std::vector<unsigned char>& pubKey)\n+{\n+    // DoS prevention: limit cache size to less than 10MB\n+    // (~200 bytes per cache entry times 50,000 entries)\n+    // Since there are a maximum of 20,000 signature operations per block\n+    // 50,000 is a reasonable default.\n+    int64 nMaxCacheSize = GetArg(\"-maxsigcachesize\", 50000);\n+    if (nMaxCacheSize <= 0) return;\n+\n+    LOCK(cs_sigcache);\n+\n+    while (setValidSigCache.size() > nMaxCacheSize)\n+    {\n+        // Evict a random entry. Random because that helps\n+        // foil would-be DoS attackers who might try to pre-generate\n+        // and re-use a set of valid signatures just-slightly-greater\n+        // than our cache size.\n+        uint256 randomHash = GetRandHash();\n+        std::vector<unsigned char> unused;\n+        std::set<sigdata_type>::iterator it =\n+            setValidSigCache.lower_bound(sigdata_type(randomHash, unused, unused));\n+        if (it == setValidSigCache.end())\n+            it = setValidSigCache.begin();\n+        setValidSigCache.erase(*it);\n+    }\n+\n+    sigdata_type k(hash, vchSig, pubKey);\n+    setValidSigCache.insert(k);\n+}\n+\n+\n bool CKey::Verify(uint256 hash, const std::vector<unsigned char>& vchSig)\n {\n+    if (GetValidSigCache(hash, vchSig, GetPubKey()))\n+        return true;\n+\n     // -1 = error, 0 = bad sig, 1 = good\n     if (ECDSA_verify(0, (unsigned char*)&hash, sizeof(hash), &vchSig[0], vchSig.size(), pkey) != 1)\n         return false;\n+\n+    // good sig\n+    SetValidSigCache(hash, vchSig, GetPubKey());\n     return true;\n }\n \n bool CKey::VerifyCompact(uint256 hash, const std::vector<unsigned char>& vchSig)\n {\n+    if (GetValidSigCache(hash, vchSig, GetPubKey()))\n+        return true;\n+\n     CKey key;\n     if (!key.SetCompactSignature(hash, vchSig))\n         return false;\n     if (GetPubKey() != key.GetPubKey())\n         return false;\n+\n+    SetValidSigCache(hash, vchSig, GetPubKey());\n     return true;\n }\n "
      },
      {
        "sha": "4ee2e948343b3ea82a2cd2da180bee5da5d1f431",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 92,
        "deletions": 1,
        "changes": 93,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/62922c8ab030953f159b9433e8a8703ab64cea02/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/62922c8ab030953f159b9433e8a8703ab64cea02/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=62922c8ab030953f159b9433e8a8703ab64cea02",
        "patch": "@@ -1,7 +1,10 @@\n //\n // Unit tests for denial-of-service detection/prevention code\n //\n+#include <algorithm>\n+\n #include <boost/assign/list_of.hpp> // for 'map_list_of()'\n+#include <boost/date_time/posix_time/posix_time_types.hpp>\n #include <boost/test/unit_test.hpp>\n #include <boost/foreach.hpp>\n \n@@ -57,7 +60,7 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n     BOOST_CHECK(!CNode::IsBanned(addr1));\n     dummyNode1.Misbehaving(1);\n     BOOST_CHECK(CNode::IsBanned(addr1));\n-    mapArgs[\"-banscore\"] = \"100\";\n+    mapArgs.erase(\"-banscore\");\n }\n \n BOOST_AUTO_TEST_CASE(DoS_bantime)\n@@ -220,4 +223,92 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     BOOST_CHECK(mapOrphanTransactionsByPrev.empty());\n }\n \n+BOOST_AUTO_TEST_CASE(DoS_checkSig)\n+{\n+    // Test signature caching code (see key.cpp Verify() methods)\n+\n+    CKey key;\n+    key.MakeNewKey(true);\n+    CBasicKeyStore keystore;\n+    keystore.AddKey(key);\n+\n+    // 100 orphan transactions:\n+    static const int NPREV=100;\n+    CTransaction orphans[NPREV];\n+    for (int i = 0; i < NPREV; i++)\n+    {\n+        CTransaction& tx = orphans[i];\n+        tx.vin.resize(1);\n+        tx.vin[0].prevout.n = 0;\n+        tx.vin[0].prevout.hash = GetRandHash();\n+        tx.vin[0].scriptSig << OP_1;\n+        tx.vout.resize(1);\n+        tx.vout[0].nValue = 1*CENT;\n+        tx.vout[0].scriptPubKey.SetBitcoinAddress(key.GetPubKey());\n+\n+        CDataStream ds(SER_DISK, CLIENT_VERSION);\n+        ds << tx;\n+        AddOrphanTx(ds);\n+    }\n+\n+    // Create a transaction that depends on orphans:\n+    CTransaction tx;\n+    tx.vout.resize(1);\n+    tx.vout[0].nValue = 1*CENT;\n+    tx.vout[0].scriptPubKey.SetBitcoinAddress(key.GetPubKey());\n+    tx.vin.resize(NPREV);\n+    for (int j = 0; j < tx.vin.size(); j++)\n+    {\n+        tx.vin[j].prevout.n = 0;\n+        tx.vin[j].prevout.hash = orphans[j].GetHash();\n+    }\n+    // Creating signatures primes the cache:\n+    boost::posix_time::ptime mst1 = boost::posix_time::microsec_clock::local_time();\n+    for (int j = 0; j < tx.vin.size(); j++)\n+        BOOST_CHECK(SignSignature(keystore, orphans[j], tx, j));\n+    boost::posix_time::ptime mst2 = boost::posix_time::microsec_clock::local_time();\n+    boost::posix_time::time_duration msdiff = mst2 - mst1;\n+    long nOneValidate = msdiff.total_milliseconds();\n+    if (fDebug) printf(\"DoS_Checksig sign: %ld\\n\", nOneValidate);\n+\n+    // ... now validating repeatedly should be quick:\n+    // 2.8GHz machine, -g build: Sign takes ~760ms,\n+    // uncached Verify takes ~250ms, cached Verify takes ~50ms\n+    // (for 100 single-signature inputs)\n+    mst1 = boost::posix_time::microsec_clock::local_time();\n+    for (int i = 0; i < 5; i++)\n+        for (int j = 0; j < tx.vin.size(); j++)\n+            BOOST_CHECK(VerifySignature(orphans[j], tx, j, true, SIGHASH_ALL));\n+    mst2 = boost::posix_time::microsec_clock::local_time();\n+    msdiff = mst2 - mst1;\n+    long nManyValidate = msdiff.total_milliseconds();\n+    if (fDebug) printf(\"DoS_Checksig five: %ld\\n\", nManyValidate);\n+\n+    BOOST_CHECK_MESSAGE(nManyValidate < nOneValidate, \"Signature cache timing failed\");\n+\n+    // Empty a signature, validation should fail:\n+    CScript save = tx.vin[0].scriptSig;\n+    tx.vin[0].scriptSig = CScript();\n+    BOOST_CHECK(!VerifySignature(orphans[0], tx, 0, true, SIGHASH_ALL));\n+    tx.vin[0].scriptSig = save;\n+\n+    // Swap signatures, validation should fail:\n+    std::swap(tx.vin[0].scriptSig, tx.vin[1].scriptSig);\n+    BOOST_CHECK(!VerifySignature(orphans[0], tx, 0, true, SIGHASH_ALL));\n+    BOOST_CHECK(!VerifySignature(orphans[1], tx, 1, true, SIGHASH_ALL));\n+    std::swap(tx.vin[0].scriptSig, tx.vin[1].scriptSig);\n+\n+    // Exercise -maxsigcachesize code:\n+    mapArgs[\"-maxsigcachesize\"] = \"10\";\n+    // Generate a new, different signature for vin[0] to trigger cache clear:\n+    CScript oldSig = tx.vin[0].scriptSig;\n+    BOOST_CHECK(SignSignature(keystore, orphans[0], tx, 0));\n+    BOOST_CHECK(tx.vin[0].scriptSig != oldSig);\n+    for (int j = 0; j < tx.vin.size(); j++)\n+        BOOST_CHECK(VerifySignature(orphans[j], tx, j, true, SIGHASH_ALL));\n+    mapArgs.erase(\"-maxsigcachesize\");\n+\n+    LimitOrphanTxSize(0);\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  }
]