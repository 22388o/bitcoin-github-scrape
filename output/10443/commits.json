[
  {
    "sha": "f72af48121a361ad46dd8e84a69f6f609296f30e",
    "node_id": "C_kwDOABII59oAKGY3MmFmNDgxMjFhMzYxYWQ0NmRkOGU4NGE2OWY2ZjYwOTI5NmYzMGU",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-05-22T22:09:19Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2021-11-01T13:24:22Z"
      },
      "message": "Add -estlog option for saving live fee estimation data",
      "tree": {
        "sha": "be0397e8dc90aeb15fb170a583d11152e2327a1b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/be0397e8dc90aeb15fb170a583d11152e2327a1b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f72af48121a361ad46dd8e84a69f6f609296f30e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f72af48121a361ad46dd8e84a69f6f609296f30e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f72af48121a361ad46dd8e84a69f6f609296f30e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f72af48121a361ad46dd8e84a69f6f609296f30e/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5adc5c02800f00d1e6e8812a2b0559b1800e82e9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5adc5c02800f00d1e6e8812a2b0559b1800e82e9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5adc5c02800f00d1e6e8812a2b0559b1800e82e9"
      }
    ],
    "stats": {
      "total": 480,
      "additions": 410,
      "deletions": 70
    },
    "files": [
      {
        "sha": "9a9a5d53be3b5488a667013f980ed87e405c5aa9",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f72af48121a361ad46dd8e84a69f6f609296f30e/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f72af48121a361ad46dd8e84a69f6f609296f30e/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=f72af48121a361ad46dd8e84a69f6f609296f30e",
        "patch": "@@ -186,6 +186,7 @@ BITCOIN_CORE_H = \\\n   outputtype.h \\\n   policy/feerate.h \\\n   policy/fees.h \\\n+  policy/fees_input.h \\\n   policy/packages.h \\\n   policy/policy.h \\\n   policy/rbf.h \\\n@@ -346,6 +347,7 @@ libbitcoin_server_a_SOURCES = \\\n   node/ui_interface.cpp \\\n   noui.cpp \\\n   policy/fees.cpp \\\n+  policy/fees_input.cpp \\\n   policy/packages.cpp \\\n   policy/rbf.cpp \\\n   policy/settings.cpp \\"
      },
      {
        "sha": "3983d2362bdad750754697ec6cd73b3f13294a0f",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 3,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f72af48121a361ad46dd8e84a69f6f609296f30e/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f72af48121a361ad46dd8e84a69f6f609296f30e/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=f72af48121a361ad46dd8e84a69f6f609296f30e",
        "patch": "@@ -39,6 +39,7 @@\n #include <node/ui_interface.h>\n #include <policy/feerate.h>\n #include <policy/fees.h>\n+#include <policy/fees_input.h>\n #include <policy/policy.h>\n #include <policy/settings.h>\n #include <protocol.h>\n@@ -224,7 +225,7 @@ void Shutdown(NodeContext& node)\n     }\n \n     // Drop transactions we were still watching, and record fee estimations.\n-    if (node.fee_estimator) node.fee_estimator->Flush();\n+    if (node.fee_estimator_input) node.fee_estimator_input->close();\n \n     // FlushStateToDisk generates a ChainStateFlushed callback, which we should avoid missing\n     if (node.chainman) {\n@@ -515,6 +516,7 @@ void SetupServerArgs(ArgsManager& argsman)\n     argsman.AddArg(\"-limitdescendantsize=<n>\", strprintf(\"Do not accept transactions if any ancestor would have more than <n> kilobytes of in-mempool descendants (default: %u).\", DEFAULT_DESCENDANT_SIZE_LIMIT), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n     argsman.AddArg(\"-addrmantest\", \"Allows to test address relay on localhost\", ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n     argsman.AddArg(\"-capturemessages\", \"Capture all P2P messages to disk\", ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n+    argsman.AddArg(\"-estlog=<est.log>\", \"Generate newline-delimited json file with fee estimation data. See test/fee_est/README.md for more information.\", ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);\n     argsman.AddArg(\"-mocktime=<n>\", \"Replace actual time with \" + UNIX_EPOCH_TIME + \" (default: 0)\", ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n     argsman.AddArg(\"-maxsigcachesize=<n>\", strprintf(\"Limit sum of signature cache and script execution cache sizes to <n> MiB (default: %u)\", DEFAULT_MAX_SIG_CACHE_SIZE), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n     argsman.AddArg(\"-maxtipage=<n>\", strprintf(\"Maximum tip age in seconds to consider node in initial block download (default: %u)\", DEFAULT_MAX_TIP_AGE), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n@@ -1251,11 +1253,17 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n     assert(!node.fee_estimator);\n     // Don't initialize fee estimation with old data if we don't relay transactions,\n     // as they would never get updated.\n-    if (!ignores_incoming_txs) node.fee_estimator = std::make_unique<CBlockPolicyEstimator>();\n+    if (!ignores_incoming_txs) {\n+        node.fee_estimator = std::make_unique<CBlockPolicyEstimator>();\n+        node.fee_estimator_input = std::make_unique<FeeEstInput>(*node.fee_estimator);\n+        if (!node.fee_estimator_input->open(gArgs.GetArg(\"-estlog\", \"\"))) {\n+            return InitError(Untranslated(\"Could not open -estlog file for appending.\"));\n+        }\n+    }\n \n     assert(!node.mempool);\n     int check_ratio = std::min<int>(std::max<int>(args.GetIntArg(\"-checkmempool\", chainparams.DefaultConsistencyChecks() ? 1 : 0), 0), 1000000);\n-    node.mempool = std::make_unique<CTxMemPool>(node.fee_estimator.get(), check_ratio);\n+    node.mempool = std::make_unique<CTxMemPool>(node.fee_estimator_input.get(), check_ratio);\n \n     assert(!node.chainman);\n     node.chainman = std::make_unique<ChainstateManager>();"
      },
      {
        "sha": "806ef317e9d007a442d1f8edffc57c9759c0557b",
        "filename": "src/node/context.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f72af48121a361ad46dd8e84a69f6f609296f30e/src/node/context.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f72af48121a361ad46dd8e84a69f6f609296f30e/src/node/context.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/context.cpp?ref=f72af48121a361ad46dd8e84a69f6f609296f30e",
        "patch": "@@ -10,6 +10,7 @@\n #include <net.h>\n #include <net_processing.h>\n #include <policy/fees.h>\n+#include <policy/fees_input.h>\n #include <scheduler.h>\n #include <txmempool.h>\n #include <validation.h>"
      },
      {
        "sha": "13aadb9b8ecb379b704cb730deac8d2a737855c2",
        "filename": "src/node/context.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f72af48121a361ad46dd8e84a69f6f609296f30e/src/node/context.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f72af48121a361ad46dd8e84a69f6f609296f30e/src/node/context.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/context.h?ref=f72af48121a361ad46dd8e84a69f6f609296f30e",
        "patch": "@@ -18,6 +18,7 @@ class CConnman;\n class CScheduler;\n class CTxMemPool;\n class ChainstateManager;\n+class FeeEstInput;\n class PeerManager;\n namespace interfaces {\n class Chain;\n@@ -42,6 +43,7 @@ struct NodeContext {\n     std::unique_ptr<AddrMan> addrman;\n     std::unique_ptr<CConnman> connman;\n     std::unique_ptr<CTxMemPool> mempool;\n+    std::unique_ptr<FeeEstInput> fee_estimator_input;\n     std::unique_ptr<CBlockPolicyEstimator> fee_estimator;\n     std::unique_ptr<PeerManager> peerman;\n     std::unique_ptr<ChainstateManager> chainman;"
      },
      {
        "sha": "a53a11031e94cc2f5d8ee8024633088a20b8de60",
        "filename": "src/policy/fees.cpp",
        "status": "modified",
        "additions": 46,
        "deletions": 34,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f72af48121a361ad46dd8e84a69f6f609296f30e/src/policy/fees.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f72af48121a361ad46dd8e84a69f6f609296f30e/src/policy/fees.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.cpp?ref=f72af48121a361ad46dd8e84a69f6f609296f30e",
        "patch": "@@ -9,11 +9,10 @@\n #include <fs.h>\n #include <logging.h>\n #include <streams.h>\n-#include <txmempool.h>\n #include <util/serfloat.h>\n #include <util/system.h>\n \n-static const char* FEE_ESTIMATES_FILENAME = \"fee_estimates.dat\";\n+#include <math.h>\n \n static constexpr double INF_FEERATE = 1e99;\n \n@@ -522,24 +521,19 @@ CBlockPolicyEstimator::CBlockPolicyEstimator()\n     feeStats = std::unique_ptr<TxConfirmStats>(new TxConfirmStats(buckets, bucketMap, MED_BLOCK_PERIODS, MED_DECAY, MED_SCALE));\n     shortStats = std::unique_ptr<TxConfirmStats>(new TxConfirmStats(buckets, bucketMap, SHORT_BLOCK_PERIODS, SHORT_DECAY, SHORT_SCALE));\n     longStats = std::unique_ptr<TxConfirmStats>(new TxConfirmStats(buckets, bucketMap, LONG_BLOCK_PERIODS, LONG_DECAY, LONG_SCALE));\n-\n-    // If the fee estimation file is present, read recorded estimations\n-    fs::path est_filepath = gArgs.GetDataDirNet() / FEE_ESTIMATES_FILENAME;\n-    CAutoFile est_file(fsbridge::fopen(est_filepath, \"rb\"), SER_DISK, CLIENT_VERSION);\n-    if (est_file.IsNull() || !Read(est_file)) {\n-        LogPrintf(\"Failed to read fee estimates from %s. Continue anyway.\\n\", fs::PathToString(est_filepath));\n-    }\n }\n \n CBlockPolicyEstimator::~CBlockPolicyEstimator()\n {\n }\n \n-void CBlockPolicyEstimator::processTransaction(const CTxMemPoolEntry& entry, bool validFeeEstimate)\n+void CBlockPolicyEstimator::processTx(const uint256& hash,\n+    unsigned int txHeight,\n+    CAmount fee,\n+    uint32_t size,\n+    bool validFeeEstimate)\n {\n     LOCK(m_cs_fee_estimator);\n-    unsigned int txHeight = entry.GetHeight();\n-    uint256 hash = entry.GetTx().GetHash();\n     if (mapMemPoolTxs.count(hash)) {\n         LogPrint(BCLog::ESTIMATEFEE, \"Blockpolicy error mempool tx %s already being tracked\\n\",\n                  hash.ToString());\n@@ -563,7 +557,7 @@ void CBlockPolicyEstimator::processTransaction(const CTxMemPoolEntry& entry, boo\n     trackedTxs++;\n \n     // Feerates are stored and reported as BTC-per-kb:\n-    CFeeRate feeRate(entry.GetFee(), entry.GetTxSize());\n+    CFeeRate feeRate(fee, size);\n \n     mapMemPoolTxs[hash].blockHeight = txHeight;\n     unsigned int bucketIndex = feeStats->NewTx(txHeight, (double)feeRate.GetFeePerK());\n@@ -574,17 +568,21 @@ void CBlockPolicyEstimator::processTransaction(const CTxMemPoolEntry& entry, boo\n     assert(bucketIndex == bucketIndex3);\n }\n \n-bool CBlockPolicyEstimator::processBlockTx(unsigned int nBlockHeight, const CTxMemPoolEntry* entry)\n+bool CBlockPolicyEstimator::processBlockTx(unsigned int nBlockHeight,\n+    const uint256& hash,\n+    unsigned int height,\n+    CAmount fee,\n+    uint32_t size)\n {\n-    if (!removeTx(entry->GetTx().GetHash(), true)) {\n+    if (!removeTx(hash, true)) {\n         // This transaction wasn't being tracked for fee estimation\n         return false;\n     }\n \n     // How many blocks did it take for miners to include this transaction?\n     // blocksToConfirm is 1-based, so a transaction included in the earliest\n     // possible block has confirmation count of 1\n-    int blocksToConfirm = nBlockHeight - entry->GetHeight();\n+    int blocksToConfirm = nBlockHeight - height;\n     if (blocksToConfirm <= 0) {\n         // This can't happen because we don't process transactions from a block with a height\n         // lower than our greatest seen height\n@@ -593,16 +591,15 @@ bool CBlockPolicyEstimator::processBlockTx(unsigned int nBlockHeight, const CTxM\n     }\n \n     // Feerates are stored and reported as BTC-per-kb:\n-    CFeeRate feeRate(entry->GetFee(), entry->GetTxSize());\n+    CFeeRate feeRate(fee, size);\n \n     feeStats->Record(blocksToConfirm, (double)feeRate.GetFeePerK());\n     shortStats->Record(blocksToConfirm, (double)feeRate.GetFeePerK());\n     longStats->Record(blocksToConfirm, (double)feeRate.GetFeePerK());\n     return true;\n }\n \n-void CBlockPolicyEstimator::processBlock(unsigned int nBlockHeight,\n-                                         std::vector<const CTxMemPoolEntry*>& entries)\n+void CBlockPolicyEstimator::processBlock(unsigned int nBlockHeight, const AddTxsFn& add_txs)\n {\n     LOCK(m_cs_fee_estimator);\n     if (nBlockHeight <= nBestSeenHeight) {\n@@ -630,11 +627,13 @@ void CBlockPolicyEstimator::processBlock(unsigned int nBlockHeight,\n     longStats->UpdateMovingAverages();\n \n     unsigned int countedTxs = 0;\n+    unsigned int block_txs = 0;\n     // Update averages with data points from current block\n-    for (const auto& entry : entries) {\n-        if (processBlockTx(nBlockHeight, entry))\n-            countedTxs++;\n-    }\n+    add_txs([&](const uint256& hash, unsigned int height, CAmount fee, uint32_t size)\n+        EXCLUSIVE_LOCKS_REQUIRED(m_cs_fee_estimator) {\n+            if (processBlockTx(nBlockHeight, hash, height, fee, size)) ++countedTxs;\n+            ++block_txs;\n+        });\n \n     if (firstRecordedHeight == 0 && countedTxs > 0) {\n         firstRecordedHeight = nBestSeenHeight;\n@@ -643,7 +642,7 @@ void CBlockPolicyEstimator::processBlock(unsigned int nBlockHeight,\n \n \n     LogPrint(BCLog::ESTIMATEFEE, \"Blockpolicy estimates updated by %u of %u block txs, since last block %u of %u tracked, mempool map size %u, max target %u from %s\\n\",\n-             countedTxs, entries.size(), trackedTxs, trackedTxs + untrackedTxs, mapMemPoolTxs.size(),\n+             countedTxs, block_txs, trackedTxs, trackedTxs + untrackedTxs, mapMemPoolTxs.size(),\n              MaxUsableEstimate(), HistoricalBlockSpan() > BlockSpan() ? \"historical\" : \"current\");\n \n     trackedTxs = 0;\n@@ -736,6 +735,29 @@ unsigned int CBlockPolicyEstimator::MaxUsableEstimate() const\n     return std::min(longStats->GetMaxConfirms(), std::max(BlockSpan(), HistoricalBlockSpan()) / 2);\n }\n \n+unsigned int CBlockPolicyEstimator::getMaxTarget() const\n+{\n+    LOCK(m_cs_fee_estimator);\n+    return MaxUsableEstimate();\n+}\n+\n+// static\n+std::vector<unsigned int> CBlockPolicyEstimator::GetUniqueTargets()\n+{\n+    std::set<unsigned int> targets;\n+    auto addTargets = [&](unsigned int numTargets, unsigned int scale) {\n+        int target = scale;\n+        for (unsigned int i = 1; i < numTargets; ++i) {\n+            targets.emplace(target);\n+            target += scale;\n+        }\n+    };\n+    addTargets(SHORT_BLOCK_PERIODS, SHORT_SCALE);\n+    addTargets(MED_BLOCK_PERIODS, MED_SCALE);\n+    addTargets(LONG_BLOCK_PERIODS, LONG_SCALE);\n+    return {targets.begin(), targets.end()};\n+}\n+\n /** Return a fee estimate at the required successThreshold from the shortest\n  * time horizon which tracks confirmations up to the desired target.  If\n  * checkShorterHorizon is requested, also allow short time horizon estimates\n@@ -881,16 +903,6 @@ CFeeRate CBlockPolicyEstimator::estimateSmartFee(int confTarget, FeeCalculation\n     return CFeeRate(llround(median));\n }\n \n-void CBlockPolicyEstimator::Flush() {\n-    FlushUnconfirmed();\n-\n-    fs::path est_filepath = gArgs.GetDataDirNet() / FEE_ESTIMATES_FILENAME;\n-    CAutoFile est_file(fsbridge::fopen(est_filepath, \"wb\"), SER_DISK, CLIENT_VERSION);\n-    if (est_file.IsNull() || !Write(est_file)) {\n-        LogPrintf(\"Failed to write fee estimates to %s. Continue anyway.\\n\", fs::PathToString(est_filepath));\n-    }\n-}\n-\n bool CBlockPolicyEstimator::Write(CAutoFile& fileout) const\n {\n     try {"
      },
      {
        "sha": "043a640821f40df7f9201999b940813b5b936d07",
        "filename": "src/policy/fees.h",
        "status": "modified",
        "additions": 16,
        "deletions": 7,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f72af48121a361ad46dd8e84a69f6f609296f30e/src/policy/fees.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f72af48121a361ad46dd8e84a69f6f609296f30e/src/policy/fees.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.h?ref=f72af48121a361ad46dd8e84a69f6f609296f30e",
        "patch": "@@ -12,6 +12,7 @@\n #include <sync.h>\n \n #include <array>\n+#include <functional>\n #include <map>\n #include <memory>\n #include <string>\n@@ -80,6 +81,9 @@ struct FeeCalculation\n     int returnedTarget = 0;\n };\n \n+using AddTxFn = std::function<void(const uint256& hash, unsigned int height, CAmount fee, uint32_t size)>;\n+using AddTxsFn = std::function<void(const AddTxFn&)>;\n+\n /** \\class CBlockPolicyEstimator\n  * The BlockPolicyEstimator is used for estimating the feerate needed\n  * for a transaction to be included in a block within a certain number of\n@@ -185,11 +189,10 @@ class CBlockPolicyEstimator\n     ~CBlockPolicyEstimator();\n \n     /** Process all the transactions that have been included in a block */\n-    void processBlock(unsigned int nBlockHeight,\n-                      std::vector<const CTxMemPoolEntry*>& entries);\n+    void processBlock(unsigned int nBlockHeight, const AddTxsFn& add_txs);\n \n     /** Process a transaction accepted to the mempool*/\n-    void processTransaction(const CTxMemPoolEntry& entry, bool validFeeEstimate);\n+    void processTx(const uint256& hash, unsigned int txHeight, CAmount fee, uint32_t size, bool validFeeEstimate);\n \n     /** Remove a transaction from the mempool tracking stats*/\n     bool removeTx(uint256 hash, bool inBlock);\n@@ -219,12 +222,18 @@ class CBlockPolicyEstimator\n     /** Empty mempool transactions on shutdown to record failure to confirm for txs still in mempool */\n     void FlushUnconfirmed();\n \n+    /** Get highest target that reasonable estimate can be provided for. */\n+    unsigned int getMaxTarget() const;\n+\n+    /**\n+     * Get sorted list of targets the estimator can directly calculate feerates\n+     * for (without rounding up the nearest supported target).\n+     */\n+    static std::vector<unsigned int> GetUniqueTargets();\n+\n     /** Calculation of highest target that estimates are tracked for */\n     unsigned int HighestTargetTracked(FeeEstimateHorizon horizon) const;\n \n-    /** Drop still unconfirmed transactions and record current estimations, if the fee estimation file is present. */\n-    void Flush();\n-\n private:\n     mutable RecursiveMutex m_cs_fee_estimator;\n \n@@ -255,7 +264,7 @@ class CBlockPolicyEstimator\n     std::map<double, unsigned int> bucketMap GUARDED_BY(m_cs_fee_estimator); // Map of bucket upper-bound to index into all vectors by bucket\n \n     /** Process a transaction confirmed in a block*/\n-    bool processBlockTx(unsigned int nBlockHeight, const CTxMemPoolEntry* entry) EXCLUSIVE_LOCKS_REQUIRED(m_cs_fee_estimator);\n+    bool processBlockTx(unsigned int nBlockHeight, const uint256& hash, unsigned int height, CAmount fee, uint32_t size) EXCLUSIVE_LOCKS_REQUIRED(m_cs_fee_estimator);\n \n     /** Helper for estimateSmartFee */\n     double estimateCombinedFee(unsigned int confTarget, double successThreshold, bool checkShorterHorizon, EstimationResult *result) const EXCLUSIVE_LOCKS_REQUIRED(m_cs_fee_estimator);"
      },
      {
        "sha": "f15868512d461eb1d7dc61892524a311cd3be30a",
        "filename": "src/policy/fees_input.cpp",
        "status": "added",
        "additions": 239,
        "deletions": 0,
        "changes": 239,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f72af48121a361ad46dd8e84a69f6f609296f30e/src/policy/fees_input.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f72af48121a361ad46dd8e84a69f6f609296f30e/src/policy/fees_input.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees_input.cpp?ref=f72af48121a361ad46dd8e84a69f6f609296f30e",
        "patch": "@@ -0,0 +1,239 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <policy/fees_input.h>\n+\n+#include <chainparams.h>\n+#include <clientversion.h>\n+#include <policy/fees.h>\n+#include <streams.h>\n+#include <util/strencodings.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <univalue.h>\n+\n+static const char* FEE_ESTIMATES_FILENAME = \"fee_estimates.dat\";\n+\n+namespace {\n+UniValue TxLog(const uint256& hash, unsigned int height, CAmount fee, uint32_t size)\n+{\n+    UniValue tx(UniValue::VOBJ);\n+    tx.pushKV(\"hash\", hash.ToString());\n+    tx.pushKV(\"height\", int(height));\n+    tx.pushKV(\"fee\", fee);\n+    tx.pushKV(\"size\", uint64_t(size));\n+    return tx;\n+}\n+} // namespace\n+\n+FeeEstInput::FeeEstInput(CBlockPolicyEstimator& estimator) : m_estimator(estimator) {}\n+\n+bool FeeEstInput::open(const std::string& log_filename) {\n+    if (!writeLog(log_filename)) return false;\n+\n+    // If the fee estimation file is present, read recorded estimations\n+    fs::path est_filepath = gArgs.GetDataDirNet() / FEE_ESTIMATES_FILENAME;\n+    if (!readData(est_filepath)) {\n+        LogPrintf(\"Failed to read fee estimates from %s. Continue anyway.\\n\", fs::PathToString(est_filepath));\n+    }\n+\n+    return true;\n+}\n+\n+bool FeeEstInput::close()\n+{\n+    m_estimator.FlushUnconfirmed();\n+\n+    fs::path est_filepath = gArgs.GetDataDirNet() / FEE_ESTIMATES_FILENAME;\n+    if (!writeData(est_filepath)) {\n+        LogPrintf(\"Failed to write fee estimates to %s. Continue anyway.\\n\", fs::PathToString(est_filepath));\n+    }\n+    return writeLog({});\n+}\n+\n+void FeeEstInput::processTx(const uint256& hash, unsigned int height, CAmount fee, uint32_t size, bool valid)\n+{\n+    m_estimator.processTx(hash, height, fee, size, valid);\n+    if (m_log) {\n+        UniValue value(UniValue::VOBJ);\n+        value.pushKV(\"tx\", TxLog(hash, height, fee, size));\n+        value.pushKV(\"valid\", UniValue(valid));\n+        value.pushKV(\"time\", GetTime());\n+        *m_log << value.write() << std::endl;\n+    }\n+}\n+\n+void FeeEstInput::processBlock(unsigned int block_height, const AddTxsFn& add_txs)\n+{\n+    UniValue json_txs{UniValue::VARR};\n+    m_estimator.processBlock(block_height, [&](const AddTxFn& add_tx) {\n+        add_txs([&](const uint256& hash, unsigned int height, CAmount fee, uint32_t size) {\n+            add_tx(hash, height, fee, size);\n+            if (m_log) json_txs.push_back(TxLog(hash, height, fee, size));\n+        });\n+    });\n+    if (m_log) {\n+        UniValue json(UniValue::VOBJ);\n+        UniValue json_block(UniValue::VOBJ);\n+        json_block.pushKV(\"height\", int64_t(block_height));\n+        json.pushKV(\"block\", json_block);\n+        json.pushKV(\"txs\", std::move(json_txs));\n+        json.pushKV(\"time\", GetTime());\n+        *m_log << json.write() << std::endl;\n+    }\n+}\n+\n+void FeeEstInput::removeTx(const uint256& hash, bool in_block)\n+{\n+    m_estimator.removeTx(hash, in_block);\n+\n+    if (m_log) {\n+        UniValue value(UniValue::VOBJ);\n+        UniValue removeTx(UniValue::VOBJ);\n+        removeTx.pushKV(\"hash\", hash.ToString());\n+        removeTx.pushKV(\"inBlock\", UniValue(in_block));\n+        value.pushKV(\"removeTx\", removeTx);\n+        value.pushKV(\"time\", GetTime());\n+        *m_log << value.write() << std::endl;\n+    }\n+}\n+\n+bool FeeEstInput::writeData(const fs::path& filename)\n+{\n+    CAutoFile file(fsbridge::fopen(filename, \"wb\"), SER_DISK, CLIENT_VERSION);\n+    if (file.IsNull()) return false;\n+    m_estimator.Write(file);\n+\n+    if (m_log) {\n+        UniValue value(UniValue::VOBJ);\n+        UniValue flush(UniValue::VARR);\n+        value.pushKV(\"flush\", flush);\n+        value.pushKV(\"time\", GetTime());\n+        *m_log << value.write() << std::endl;\n+    }\n+    return true;\n+}\n+\n+bool FeeEstInput::readData(const fs::path& filename)\n+{\n+    CAutoFile file(fsbridge::fopen(filename, \"rb\"), SER_DISK, CLIENT_VERSION);\n+    if (file.IsNull() || !m_estimator.Read(file)) return false;\n+\n+    if (m_log) {\n+        UniValue value(UniValue::VOBJ);\n+        std::ifstream data(filename.c_str(), std::ifstream::binary);\n+        value.pushKV(\n+            \"read\", HexStr(std::string(std::istreambuf_iterator<char>(data), std::istreambuf_iterator<char>())));\n+        value.pushKV(\"time\", GetTime());\n+        *m_log << value.write() << std::endl;\n+    }\n+    return true;\n+}\n+\n+bool FeeEstInput::writeLog(const std::string& filename)\n+{\n+    if (m_log) {\n+        UniValue value(UniValue::VOBJ);\n+        value.pushKV(\"stop\", Params().NetworkIDString());\n+        value.pushKV(\"time\", GetTime());\n+        *m_log << value.write() << std::endl;\n+    }\n+\n+    if (filename.empty()) {\n+        m_log.reset();\n+    } else {\n+        m_log = std::make_unique<std::ofstream>((gArgs.GetDataDirNet() / filename).string(), std::ofstream::out | std::ofstream::app);\n+        if (!*m_log) {\n+            m_log.reset();\n+            return false;\n+        }\n+    }\n+\n+    if (m_log) {\n+        UniValue value(UniValue::VOBJ);\n+        value.pushKV(\"start\", Params().NetworkIDString());\n+        value.pushKV(\"time\", GetTime());\n+        *m_log << value.write() << std::endl;\n+    }\n+\n+    return true;\n+}\n+\n+bool FeeEstInput::readLog(const std::string& filename, const std::function<bool(UniValue&)>& filter)\n+{\n+    std::ifstream file(filename);\n+    if (!file) {\n+        LogPrintf(\"%s: Failed to open log file %s\\n\", __func__, filename);\n+        return false;\n+    }\n+\n+    std::string line;\n+    while (std::getline(file, line)) {\n+        UniValue value;\n+        if (!value.read(line)) {\n+            throw std::runtime_error(\"Failed to parse fee estimate log line.\");\n+        }\n+\n+        if (filter && !filter(value)) {\n+            continue;\n+        }\n+\n+        const UniValue& tx = value[\"tx\"];\n+        if (tx.isObject()) {\n+            m_estimator.processTx(uint256S(tx[\"hash\"].get_str()), tx[\"height\"].get_int(), tx[\"fee\"].get_int64(),\n+                tx[\"size\"].get_int(), value[\"valid\"].get_bool());\n+            continue;\n+        }\n+\n+        const UniValue& block = value[\"block\"];\n+        if (block.isObject()) {\n+            int height = block[\"height\"].get_int();\n+            m_estimator.processBlock(height, [&](const AddTxFn& add_tx) {\n+                const auto& block_txs = value[\"txs\"].getValues();\n+                for (const UniValue& block_tx : block_txs) {\n+                    add_tx(uint256S(block_tx[\"hash\"].get_str()), block_tx[\"height\"].get_int(),\n+                        block_tx[\"fee\"].get_int64(), block_tx[\"size\"].get_int());\n+                }\n+                return block_txs.size();\n+            });\n+            continue;\n+        }\n+\n+        const UniValue& removeTx = value[\"removeTx\"];\n+        if (removeTx.isObject()) {\n+            m_estimator.removeTx(uint256S(removeTx[\"hash\"].get_str()), removeTx[\"inBlock\"].get_bool());\n+            continue;\n+        }\n+\n+        const UniValue& flush = value[\"flush\"];\n+        if (flush.isArray()) {\n+            m_estimator.FlushUnconfirmed();\n+            continue;\n+        }\n+\n+        const UniValue& read = value[\"read\"];\n+        if (read.isStr()) {\n+            std::vector<unsigned char> data = ParseHex(read.get_str());\n+            uint16_t randv = 0;\n+            GetRandBytes((unsigned char*)&randv, sizeof(randv));\n+            fs::path data_filename = fs::PathFromString(strprintf(\"fee_estimates.tmp.%04x\", randv));\n+            CAutoFile(fsbridge::fopen(data_filename, \"wb\"), SER_DISK, CLIENT_VERSION)\n+                .write((const char*)data.data(), data.size());\n+            {\n+                CAutoFile data(fsbridge::fopen(data_filename, \"rb\"), SER_DISK, CLIENT_VERSION);\n+                m_estimator.Read(data);\n+            }\n+            fs::remove(data_filename);\n+            continue;\n+        }\n+    }\n+\n+    if (file.bad()) {\n+        LogPrintf(\"%s: Failure reading log file %s\\n\", __func__, filename);\n+        return false;\n+    }\n+\n+    return true;\n+}"
      },
      {
        "sha": "e66fd3d83e788a5a214e65f57af077a212b12a98",
        "filename": "src/policy/fees_input.h",
        "status": "added",
        "additions": 58,
        "deletions": 0,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f72af48121a361ad46dd8e84a69f6f609296f30e/src/policy/fees_input.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f72af48121a361ad46dd8e84a69f6f609296f30e/src/policy/fees_input.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees_input.h?ref=f72af48121a361ad46dd8e84a69f6f609296f30e",
        "patch": "@@ -0,0 +1,58 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef BITCOIN_POLICY_FEES_INPUT_H\n+#define BITCOIN_POLICY_FEES_INPUT_H\n+\n+#include <consensus/amount.h>\n+#include <fs.h>\n+#include <policy/fees.h>\n+\n+#include <map>\n+#include <memory>\n+#include <vector>\n+\n+class CAutoFile;\n+class CBlockPolicyEstimator;\n+class UniValue;\n+class uint256;\n+\n+class FeeEstInput\n+{\n+public:\n+    explicit FeeEstInput(CBlockPolicyEstimator& estimator);\n+\n+    /** Open fee estimator input after construction. Load fee estimation data file and open optional log file. */\n+    bool open(const std::string& log_filename);\n+\n+    /** Drop still unconfirmed transactions and record current estimations, if the fee estimation file is present. */\n+    bool close();\n+\n+    /** Process all the transactions that have been included in a block */\n+    void processBlock(unsigned int height, const AddTxsFn& add_txs);\n+\n+    /** Process a transaction added the mempool or a block */\n+    void processTx(const uint256& hash, unsigned int height, CAmount fee, uint32_t size, bool valid);\n+\n+    /** Remove a transaction from the mempool tracking stats */\n+    void removeTx(const uint256& hash, bool in_block);\n+\n+    /** Write estimation data to a file */\n+    bool writeData(const fs::path& filename);\n+\n+    /** Read estimation data from a file */\n+    bool readData(const fs::path& filename);\n+\n+    /** Write incoming block and transaction events to log file. */\n+    bool writeLog(const std::string& filename);\n+\n+    /** Read block and transaction events from log file. */\n+    bool readLog(const std::string& filename, const std::function<bool(UniValue&)>& filter);\n+\n+private:\n+    CBlockPolicyEstimator& m_estimator;\n+    std::unique_ptr<std::basic_ostream<char>> m_log;\n+};\n+\n+#endif /*BITCOIN_POLICY_FEES_INPUT_H */"
      },
      {
        "sha": "f41309bf6e7fef8f6f7349e112a535d870af467e",
        "filename": "src/test/fuzz/policy_estimator.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 7,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f72af48121a361ad46dd8e84a69f6f609296f30e/src/test/fuzz/policy_estimator.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f72af48121a361ad46dd8e84a69f6f609296f30e/src/test/fuzz/policy_estimator.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/policy_estimator.cpp?ref=f72af48121a361ad46dd8e84a69f6f609296f30e",
        "patch": "@@ -33,7 +33,11 @@ FUZZ_TARGET_INIT(policy_estimator, initialize_policy_estimator)\n                     return;\n                 }\n                 const CTransaction tx{*mtx};\n-                block_policy_estimator.processTransaction(ConsumeTxMemPoolEntry(fuzzed_data_provider, tx), fuzzed_data_provider.ConsumeBool());\n+                block_policy_estimator.processTx(\n+                    tx.GetHash(),\n+                    fuzzed_data_provider.ConsumeIntegral<unsigned>(),\n+                    fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(1, std::numeric_limits<CAmount>::max() / static_cast<CAmount>(100000)), fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, std::numeric_limits<uint32_t>::max()),\n+                    fuzzed_data_provider.ConsumeBool());\n                 if (fuzzed_data_provider.ConsumeBool()) {\n                     (void)block_policy_estimator.removeTx(tx.GetHash(), /* inBlock */ fuzzed_data_provider.ConsumeBool());\n                 }\n@@ -48,12 +52,11 @@ FUZZ_TARGET_INIT(policy_estimator, initialize_policy_estimator)\n                     const CTransaction tx{*mtx};\n                     mempool_entries.push_back(ConsumeTxMemPoolEntry(fuzzed_data_provider, tx));\n                 }\n-                std::vector<const CTxMemPoolEntry*> ptrs;\n-                ptrs.reserve(mempool_entries.size());\n-                for (const CTxMemPoolEntry& mempool_entry : mempool_entries) {\n-                    ptrs.push_back(&mempool_entry);\n-                }\n-                block_policy_estimator.processBlock(fuzzed_data_provider.ConsumeIntegral<unsigned int>(), ptrs);\n+                block_policy_estimator.processBlock(fuzzed_data_provider.ConsumeIntegral<unsigned int>(), [&](const AddTxFn& add_tx) {\n+                    for (const CTxMemPoolEntry& mempool_entry : mempool_entries) {\n+                        add_tx(mempool_entry.GetTx().GetHash(), mempool_entry.GetHeight(), mempool_entry.GetFee(), mempool_entry.GetTxSize());\n+                    }\n+                });\n             },\n             [&] {\n                 (void)block_policy_estimator.removeTx(ConsumeUInt256(fuzzed_data_provider), /* inBlock */ fuzzed_data_provider.ConsumeBool());"
      },
      {
        "sha": "9bc29ff6edfac071531c4bc872497762adf12078",
        "filename": "src/test/policyestimator_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f72af48121a361ad46dd8e84a69f6f609296f30e/src/test/policyestimator_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f72af48121a361ad46dd8e84a69f6f609296f30e/src/test/policyestimator_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/policyestimator_tests.cpp?ref=f72af48121a361ad46dd8e84a69f6f609296f30e",
        "patch": "@@ -3,6 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <policy/fees.h>\n+#include <policy/fees_input.h>\n #include <policy/policy.h>\n #include <txmempool.h>\n #include <uint256.h>\n@@ -17,7 +18,8 @@ BOOST_FIXTURE_TEST_SUITE(policyestimator_tests, BasicTestingSetup)\n BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n {\n     CBlockPolicyEstimator feeEst;\n-    CTxMemPool mpool(&feeEst);\n+    FeeEstInput feeEstInput(feeEst);\n+    CTxMemPool mpool(&feeEstInput);\n     LOCK2(cs_main, mpool.cs);\n     TestMemPoolEntryHelper entry;\n     CAmount basefee(2000);"
      },
      {
        "sha": "300345b37d26f58856afc78bb66adf638ef97396",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f72af48121a361ad46dd8e84a69f6f609296f30e/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f72af48121a361ad46dd8e84a69f6f609296f30e/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=f72af48121a361ad46dd8e84a69f6f609296f30e",
        "patch": "@@ -18,6 +18,7 @@\n #include <net_processing.h>\n #include <noui.h>\n #include <policy/fees.h>\n+#include <policy/fees_input.h>\n #include <pow.h>\n #include <rpc/blockchain.h>\n #include <rpc/register.h>\n@@ -141,7 +142,8 @@ ChainTestingSetup::ChainTestingSetup(const std::string& chainName, const std::ve\n     GetMainSignals().RegisterBackgroundSignalScheduler(*m_node.scheduler);\n \n     m_node.fee_estimator = std::make_unique<CBlockPolicyEstimator>();\n-    m_node.mempool = std::make_unique<CTxMemPool>(m_node.fee_estimator.get(), 1);\n+    m_node.fee_estimator_input = std::make_unique<FeeEstInput>(*m_node.fee_estimator);\n+    m_node.mempool = std::make_unique<CTxMemPool>(m_node.fee_estimator_input.get(), 1);\n \n     m_node.chainman = std::make_unique<ChainstateManager>();\n     m_node.chainman->m_blockman.m_block_tree_db = std::make_unique<CBlockTreeDB>(1 << 20, true);"
      },
      {
        "sha": "0be1f99c591e35493a51e1ff9b854895e775b298",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 13,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f72af48121a361ad46dd8e84a69f6f609296f30e/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f72af48121a361ad46dd8e84a69f6f609296f30e/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=f72af48121a361ad46dd8e84a69f6f609296f30e",
        "patch": "@@ -9,7 +9,7 @@\n #include <consensus/consensus.h>\n #include <consensus/tx_verify.h>\n #include <consensus/validation.h>\n-#include <policy/fees.h>\n+#include <policy/fees_input.h>\n #include <policy/policy.h>\n #include <policy/settings.h>\n #include <reverse_iterator.h>\n@@ -392,7 +392,7 @@ void CTxMemPoolEntry::UpdateAncestorState(int64_t modifySize, CAmount modifyFee,\n     assert(int(nSigOpCostWithAncestors) >= 0);\n }\n \n-CTxMemPool::CTxMemPool(CBlockPolicyEstimator* estimator, int check_ratio)\n+CTxMemPool::CTxMemPool(FeeEstInput* estimator, int check_ratio)\n     : m_check_ratio(check_ratio), minerPolicyEstimator(estimator)\n {\n     _clear(); //lock free clear\n@@ -459,7 +459,8 @@ void CTxMemPool::addUnchecked(const CTxMemPoolEntry &entry, setEntries &setAnces\n     totalTxSize += entry.GetTxSize();\n     m_total_fee += entry.GetFee();\n     if (minerPolicyEstimator) {\n-        minerPolicyEstimator->processTransaction(entry, validFeeEstimate);\n+        minerPolicyEstimator->processTx(\n+            entry.GetTx().GetHash(), entry.GetHeight(), entry.GetFee(), entry.GetTxSize(), validFeeEstimate);\n     }\n \n     vTxHashes.emplace_back(tx.GetWitnessHash(), newit);\n@@ -627,17 +628,18 @@ void CTxMemPool::removeConflicts(const CTransaction &tx)\n void CTxMemPool::removeForBlock(const std::vector<CTransactionRef>& vtx, unsigned int nBlockHeight)\n {\n     AssertLockHeld(cs);\n-    std::vector<const CTxMemPoolEntry*> entries;\n-    for (const auto& tx : vtx)\n-    {\n-        uint256 hash = tx->GetHash();\n-\n-        indexed_transaction_set::iterator i = mapTx.find(hash);\n-        if (i != mapTx.end())\n-            entries.push_back(&*i);\n-    }\n     // Before the txs in the new block have been removed from the mempool, update policy estimates\n-    if (minerPolicyEstimator) {minerPolicyEstimator->processBlock(nBlockHeight, entries);}\n+    if (minerPolicyEstimator) {\n+        minerPolicyEstimator->processBlock(nBlockHeight, [&](const AddTxFn& add_tx) EXCLUSIVE_LOCKS_REQUIRED(cs) {\n+            for (const auto& tx : vtx) {\n+                const auto& hash = tx->GetHash();\n+                indexed_transaction_set::iterator i = mapTx.find(hash);\n+                if (i != mapTx.end()) {\n+                    add_tx(i->GetTx().GetHash(), i->GetHeight(), i->GetFee(), i->GetTxSize());\n+                }\n+            }\n+        });\n+    }\n     for (const auto& tx : vtx)\n     {\n         txiter it = mapTx.find(tx->GetHash());"
      },
      {
        "sha": "2f7904525b249320ec7e519cb2c702f56dc674a7",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f72af48121a361ad46dd8e84a69f6f609296f30e/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f72af48121a361ad46dd8e84a69f6f609296f30e/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=f72af48121a361ad46dd8e84a69f6f609296f30e",
        "patch": "@@ -364,7 +364,7 @@ struct entry_time {};\n struct ancestor_score {};\n struct index_by_wtxid {};\n \n-class CBlockPolicyEstimator;\n+class FeeEstInput;\n \n /**\n  * Information about a mempool transaction.\n@@ -477,7 +477,7 @@ class CTxMemPool\n protected:\n     const int m_check_ratio; //!< Value n means that 1 times in n we check.\n     std::atomic<unsigned int> nTransactionsUpdated{0}; //!< Used by getblocktemplate to trigger CreateNewBlock() invocation\n-    CBlockPolicyEstimator* const minerPolicyEstimator;\n+    FeeEstInput* const minerPolicyEstimator;\n \n     uint64_t totalTxSize GUARDED_BY(cs);      //!< sum of all mempool tx's virtual sizes. Differs from serialized tx size since witness data is discounted. Defined in BIP 141.\n     CAmount m_total_fee GUARDED_BY(cs);       //!< sum of all mempool tx's fees (NOT modified fee)\n@@ -614,7 +614,7 @@ class CTxMemPool\n      * @param[in] estimator is used to estimate appropriate transaction fees.\n      * @param[in] check_ratio is the ratio used to determine how often sanity checks will run.\n      */\n-    explicit CTxMemPool(CBlockPolicyEstimator* estimator = nullptr, int check_ratio = 0);\n+    explicit CTxMemPool(FeeEstInput* estimator = nullptr, int check_ratio = 0);\n \n     /**\n      * If sanity-checking is turned on, check makes sure the pool is"
      },
      {
        "sha": "b6fc3790a5afaf6e09a50fa61eeabc95d3989ed7",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f72af48121a361ad46dd8e84a69f6f609296f30e/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f72af48121a361ad46dd8e84a69f6f609296f30e/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=f72af48121a361ad46dd8e84a69f6f609296f30e",
        "patch": "@@ -43,6 +43,7 @@ class CChainParams;\n struct CCheckpointData;\n class CTxMemPool;\n class ChainstateManager;\n+class FeeEstInput;\n class SnapshotMetadata;\n struct ChainTxData;\n struct DisconnectedBlockTransactions;"
      },
      {
        "sha": "27a01008d9651fc49b65123144167639647058d0",
        "filename": "test/lint/lint-circular-dependencies.sh",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f72af48121a361ad46dd8e84a69f6f609296f30e/test/lint/lint-circular-dependencies.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f72af48121a361ad46dd8e84a69f6f609296f30e/test/lint/lint-circular-dependencies.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-circular-dependencies.sh?ref=f72af48121a361ad46dd8e84a69f6f609296f30e",
        "patch": "@@ -14,7 +14,6 @@ EXPECTED_CIRCULAR_DEPENDENCIES=(\n     \"index/blockfilterindex -> node/blockstorage -> validation -> index/blockfilterindex\"\n     \"index/base -> validation -> index/blockfilterindex -> index/base\"\n     \"index/coinstatsindex -> node/coinstats -> index/coinstatsindex\"\n-    \"policy/fees -> txmempool -> policy/fees\"\n     \"policy/rbf -> txmempool -> validation -> policy/rbf\"\n     \"qt/addresstablemodel -> qt/walletmodel -> qt/addresstablemodel\"\n     \"qt/recentrequeststablemodel -> qt/walletmodel -> qt/recentrequeststablemodel\""
      }
    ]
  },
  {
    "sha": "84f5df64005de6b6c0f651f2f6b0e470737fed4e",
    "node_id": "C_kwDOABII59oAKDg0ZjVkZjY0MDA1ZGU2YjZjMGY2NTFmMmY2YjBlNDcwNzM3ZmVkNGU",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-05-22T22:10:40Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2021-11-01T13:24:22Z"
      },
      "message": "Add fee_est tool for debugging fee estimation code",
      "tree": {
        "sha": "fb79101c47c30d950397fbef9dba9869f50fb149",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fb79101c47c30d950397fbef9dba9869f50fb149"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/84f5df64005de6b6c0f651f2f6b0e470737fed4e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/84f5df64005de6b6c0f651f2f6b0e470737fed4e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/84f5df64005de6b6c0f651f2f6b0e470737fed4e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/84f5df64005de6b6c0f651f2f6b0e470737fed4e/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f72af48121a361ad46dd8e84a69f6f609296f30e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f72af48121a361ad46dd8e84a69f6f609296f30e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f72af48121a361ad46dd8e84a69f6f609296f30e"
      }
    ],
    "stats": {
      "total": 425,
      "additions": 415,
      "deletions": 10
    },
    "files": [
      {
        "sha": "5f7cf2a34eec9a905f7c0088480cf6bb5849373d",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 38,
        "deletions": 0,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/84f5df64005de6b6c0f651f2f6b0e470737fed4e/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/84f5df64005de6b6c0f651f2f6b0e470737fed4e/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=84f5df64005de6b6c0f651f2f6b0e470737fed4e",
        "patch": "@@ -7,7 +7,11 @@ noinst_PROGRAMS += test/fuzz/fuzz\n endif\n \n if !ENABLE_FUZZ\n+# Avoid link errors (multiple defintion of `main', undefined reference to\n+# `LLVMFuzzerTestOneInput') trying to build these binaries when fuzzing is\n+# enabled, by excluding them from the default make target.\n bin_PROGRAMS += test/test_bitcoin\n+noinst_PROGRAMS += test/fee_est/fee_est\n endif\n \n TEST_SRCDIR = test\n@@ -311,6 +315,40 @@ test_fuzz_fuzz_SOURCES = \\\n  test/fuzz/versionbits.cpp\n endif # ENABLE_FUZZ_BINARY\n \n+# fee_est/fee_est binary #\n+test_fee_est_fee_est_SOURCES = test/fee_est/fee_est.cpp\n+test_fee_est_fee_est_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n+test_fee_est_fee_est_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+test_fee_est_fee_est_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+test_fee_est_fee_est_LDADD = \\\n+  $(LIBBITCOIN_SERVER)\n+\n+if ENABLE_WALLET\n+test_fee_est_fee_est_LDADD += \\\n+  $(LIBBITCOIN_WALLET)\n+endif\n+\n+test_fee_est_fee_est_LDADD += \\\n+  $(LIBBITCOIN_COMMON) \\\n+  $(LIBBITCOIN_UTIL) \\\n+  $(LIBBITCOIN_CONSENSUS) \\\n+  $(LIBBITCOIN_CRYPTO) \\\n+  $(LIBBITCOIN_CRYPTO_SSE41) \\\n+  $(LIBBITCOIN_CRYPTO_AVX2) \\\n+  $(LIBLEVELDB) $(LIBLEVELDB_SSE42) $(LIBMEMENV) \\\n+  $(LIBSECP256K1) \\\n+  $(LIBUNIVALUE) \\\n+  $(BDB_LIBS) \\\n+  $(BOOST_LIBS) \\\n+  $(CRYPTO_LIBS) \\\n+  $(EVENT_LIBS) $(EVENT_PTHREADS_LIBS) \\\n+  $(MINIUPNPC_LIBS)\n+\n+if ENABLE_ZMQ\n+test_fee_est_fee_est_LDADD += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)\n+endif\n+#\n+\n nodist_test_test_bitcoin_SOURCES = $(GENERATED_TEST_FILES)\n \n $(BITCOIN_TESTS): $(GENERATED_TEST_FILES)"
      },
      {
        "sha": "5e3434ad5883dc8a251409a648c09a479382ab7a",
        "filename": "src/test/fee_est/README.md",
        "status": "added",
        "additions": 38,
        "deletions": 0,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/84f5df64005de6b6c0f651f2f6b0e470737fed4e/src/test/fee_est/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/84f5df64005de6b6c0f651f2f6b0e470737fed4e/src/test/fee_est/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fee_est/README.md?ref=84f5df64005de6b6c0f651f2f6b0e470737fed4e",
        "patch": "@@ -0,0 +1,38 @@\n+src/test/fee_est -- Fee estimation offline testing tool\n+=======================================================\n+\n+The `fee_est` tool is intended to help debug and test changes in bitcoin fee\n+estimation code using transaction data gathered from live bitcoin nodes.\n+\n+Transaction data can be collected by running bitcoind with `-estlog` parameter\n+which will produce newline-delimited json file\n+([ndjson.org](http://ndjson.org/), [jsonlines.org](http://jsonlines.org/))\n+which logs relevant transaction information. The `fee_est` tool can parse the\n+log to produce graphs of fee estimation data and do some basic analysis of the\n+results. The implementation is intended to be simple enough that it can be\n+easily customized to do more specific analysis.\n+\n+Example usage:\n+\n+Run bitcoind collecting fee estimation data:\n+\n+```\n+$ make -C src bitcoind test/fee_est/fee_est\n+$ src/bitcoind -estlog=est.log &\n+```\n+\n+Run fee estimation tool producing graph of estimates:\n+\n+```\n+$ src/test/fee_est/fee_est -ograph=graph.html est.log\n+$ chrome graph.html\n+```\n+\n+Run fee estimation tool computing some basic statistics:\n+\n+```\n+$ src/test/fee_est/fee_est -cross est.log\n+Non-test txs: 1407226\n+Test txs: 5603 total (4345 kept, 631 discarded unconfirmed, 627 discarded outliers)\n+Mean squared error: 71.0651\n+```"
      },
      {
        "sha": "621c5b447b7ce15f85b7040ecd0ceda67ca97a81",
        "filename": "src/test/fee_est/fee_est.cpp",
        "status": "added",
        "additions": 331,
        "deletions": 0,
        "changes": 331,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/84f5df64005de6b6c0f651f2f6b0e470737fed4e/src/test/fee_est/fee_est.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/84f5df64005de6b6c0f651f2f6b0e470737fed4e/src/test/fee_est/fee_est.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fee_est/fee_est.cpp?ref=84f5df64005de6b6c0f651f2f6b0e470737fed4e",
        "patch": "@@ -0,0 +1,331 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <policy/fees.h>\n+#include <policy/fees_input.h>\n+#include <util/system.h>\n+#include <util/translation.h>\n+\n+#include <univalue.h>\n+\n+#include <fstream>\n+#include <random>\n+#include <stdio.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n+\n+std::string Usage()\n+{\n+    std::string usage = \"Usage: fee_est [options] <estlog.txt>\\n\";\n+    usage += HelpMessageGroup(\"Options:\");\n+    usage += HelpMessageOpt(\"-?, -help\", \"This help message\");\n+    usage += HelpMessageOpt(\"-ograph=<graph.html>\", \"Generate target vs feerate graph output after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-odat=<fee_estimates.dat>\", \"Save fee estimator state after after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-idat=<fee_estimates.dat>\", \"Load fee estimator state after before replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-dat=<fee_estimates.dat>\", \"Shortcut for -idat=<fee_estimates.dat> -odat=<fee_estimates.dat>\");\n+    usage += HelpMessageOpt(\"-cross\", \"Treat half the transactions from the log as test data and print cross-validation statistics.\");\n+    return usage;\n+}\n+\n+struct Options {\n+    std::string logFileIn;\n+    std::string dataFileIn;\n+    std::string dataFileOut;\n+    std::string graphFileOut;\n+    bool cross = false;\n+    bool help = false;\n+    bool error = false;\n+};\n+\n+Options ParseCommandLine(int argc, char** argv)\n+{\n+    auto match = [&](const char* arg, const char* name, const char** value = nullptr) {\n+        if (arg[0] != '-') return false;\n+        size_t n = strlen(name);\n+        if (strncmp(arg + 1, name, n) != 0) return false;\n+        if (value) return (*value = arg[n + 1] == '=' ? arg + n + 2 : nullptr) != nullptr;\n+        return arg[n + 1] == '\\0';\n+    };\n+\n+    Options options;\n+    for (int i = 1; i < argc; ++i) {\n+        const char* arg = argv[i];\n+        const char* value;\n+        if (match(arg, \"ograph\", &value)) {\n+            options.graphFileOut = value;\n+        } else if (match(arg, \"odat\", &value)) {\n+            options.dataFileOut = value;\n+        } else if (match(arg, \"idat\", &value)) {\n+            options.dataFileIn = value;\n+        } else if (match(arg, \"dat\", &value)) {\n+            options.dataFileIn = options.dataFileOut = value;\n+        } else if (match(arg, \"cross\")) {\n+            options.cross = true;\n+        } else if (match(arg, \"help\") || match(arg, \"h\") || match(arg, \"?\")) {\n+            options.help = true;\n+        } else if (arg[0] != '-' && options.logFileIn.empty()) {\n+            options.logFileIn = arg;\n+        } else {\n+            fprintf(stderr, \"Error: unexpected argument: '%s'\\n\", arg);\n+            options.error = true;\n+        }\n+    }\n+\n+    if (options.logFileIn.empty() && !options.help) {\n+        fprintf(stderr, \"Error: missing required log file argument.\\n\");\n+        options.error = true;\n+    }\n+\n+    return options;\n+}\n+\n+struct TxData {\n+    TxData(CAmount fee, size_t size, int height) : fee(fee), size(size), height(height) {}\n+    CAmount fee;\n+    size_t size;\n+    int height;\n+    int expectedBlocks = -1;\n+    int actualBlocks = -1;\n+};\n+\n+using TxMap = std::map<uint256, TxData>;\n+\n+const char* const GRAPH_HTML = R\"(<!DOCTYPE html>\n+<meta charset=\"utf-8\">\n+<title>Fee Graph</title>\n+<script src=\"https://d3js.org/d3.v3.min.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega/3.0.0-beta.30/vega.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-lite/2.0.0-beta.2/vega-lite.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-embed/3.0.0-beta.14/vega-embed.js\"></script>\n+<style media=\"screen\">\n+.vega-actions a {\n+    margin-right: 5px;\n+}\n+</style>\n+<div id=vis></div>\n+<script>\n+var spec = {\n+  \"$schema\": \"https://vega.github.io/schema/vega-lite/v2.json\",\n+  \"width\": 800,\n+  \"height\": 600,\n+  \"layer\": [\n+    {\n+        \"data\": {\n+            \"values\": %s\n+        },\n+        \"mark\": \"tick\",\n+        \"encoding\": {\n+            \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+            \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+            \"color\": {\"field\": \"height\", \"type\": \"quantitative\"}\n+        }\n+    },\n+    {\n+      \"data\": {\n+        \"values\": %s\n+      },\n+      \"encoding\": {\n+        \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+        \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+        \"color\": {\"field\": \"mode\", \"type\": \"nominal\"}\n+      },\n+      \"mark\": \"line\",\n+    }\n+  ]\n+}\n+vega.embed(\"#vis\", spec);\n+</script>\n+)\";\n+\n+// Maximum number of randomly sampled transactions to show on graph.\n+const size_t SAMPLE_TXS = 50000;\n+\n+// Drop 1/20th of sampled transactions with highest feerates if they are\n+// outliers that would change the scale of the graph.\n+const int DROP_FRAC = 20;\n+\n+void WriteGraph(const std::string& filename,\n+    const TxMap& txMap,\n+    const std::vector<unsigned int>& targets,\n+    CBlockPolicyEstimator& estimator)\n+{\n+    UniValue fees(UniValue::VARR);\n+\n+    int64_t maxFeeRate = 0;\n+    const unsigned int maxTarget = estimator.getMaxTarget();\n+    for (bool conservative : {false, true}) {\n+        for (unsigned int target : targets) {\n+            if (target > maxTarget) continue;\n+            UniValue fee(UniValue::VOBJ);\n+            fee.pushKV(\"mode\", conservative ? \"conservative\" : \"default\");\n+            fee.pushKV(\"blocks\", int(target));\n+            CAmount feeRate = estimator.estimateSmartFee(target, nullptr /* fee_calc */, conservative).GetFeePerK();\n+            fee.pushKV(\"feeRate\", feeRate);\n+            fees.push_back(fee);\n+            maxFeeRate = std::max(maxFeeRate, feeRate);\n+        }\n+    }\n+\n+    std::vector<const TxMap::value_type*> sample;\n+    sample.reserve(SAMPLE_TXS);\n+    int i = 0;\n+    std::minstd_rand randint;\n+    for (const auto& entry : txMap) {\n+        if (entry.second.actualBlocks > int(maxTarget)) {\n+            continue;\n+        } else if (sample.size() < SAMPLE_TXS) {\n+            sample.emplace_back(&entry);\n+        } else {\n+            size_t j = randint() % i;\n+            if (j < SAMPLE_TXS) {\n+                sample[j] = &entry;\n+            }\n+        }\n+        ++i;\n+    }\n+\n+    if (!sample.empty()) {\n+        std::vector<CAmount> feeRates;\n+        feeRates.reserve(sample.size());\n+        for (const auto& entry : sample) {\n+            feeRates.emplace_back(CFeeRate(entry->second.fee, entry->second.size).GetFeePerK());\n+        }\n+        auto nth = feeRates.begin() + sample.size() / DROP_FRAC;\n+        std::nth_element(feeRates.begin(), nth, feeRates.end(), std::greater<int64_t>());\n+        maxFeeRate = std::max(maxFeeRate, *nth);\n+    }\n+\n+    UniValue txs(UniValue::VARR);\n+    for (const auto& entry : sample) {\n+        if (entry->second.actualBlocks > 0) {\n+            CAmount feeRate = CFeeRate(entry->second.fee, entry->second.size).GetFeePerK();\n+            if (feeRate <= maxFeeRate) {\n+                UniValue tx(UniValue::VOBJ);\n+                tx.pushKV(\"feeRate\", feeRate);\n+                tx.pushKV(\"blocks\", entry->second.actualBlocks);\n+                tx.pushKV(\"height\", entry->second.height);\n+                txs.push_back(std::move(tx));\n+            }\n+        }\n+    }\n+\n+    std::ofstream file(filename);\n+    file << strprintf(GRAPH_HTML, txs.write(), fees.write());\n+}\n+\n+bool UpdateCross(TxMap::value_type& tx, const std::vector<unsigned int>& targets, CBlockPolicyEstimator& estimator)\n+{\n+    if (*tx.first.begin() == 0) {\n+        auto it = std::lower_bound(targets.begin(), targets.end(), nullptr, [&](unsigned int target, std::nullptr_t) {\n+            CAmount estFee = estimator.estimateSmartFee(target, nullptr /* fee_calc */, false /* conservative */)\n+                                 .GetFee(tx.second.size);\n+            return estFee <= 1 || tx.second.fee < estFee;\n+        });\n+        tx.second.expectedBlocks = it == targets.end() ? std::numeric_limits<int>::max() : int(*it);\n+        return false;\n+    }\n+    return true;\n+}\n+\n+void PrintCross(const TxMap& txMap, CBlockPolicyEstimator&)\n+{\n+    int nonTestTxs = 0;\n+    int unconfirmedTestTxs = 0;\n+    int outlierTestTxs = 0;\n+    int keptTestTxs = 0;\n+    int64_t errsq = 0;\n+    for (const auto& entry : txMap) {\n+        if (entry.second.expectedBlocks == -1) {\n+            ++nonTestTxs;\n+        } else if (entry.second.actualBlocks == -1) {\n+            ++unconfirmedTestTxs;\n+        } else if (entry.second.expectedBlocks == std::numeric_limits<int>::max()) {\n+            ++outlierTestTxs;\n+        } else {\n+            ++keptTestTxs;\n+            int err = entry.second.expectedBlocks - entry.second.actualBlocks;\n+            errsq += err * err;\n+        }\n+    }\n+    printf(\"Non-test txs: %i\\n\", nonTestTxs);\n+    printf(\"Test txs: %i total (%i kept, %i discarded unconfirmed, %i discarded outliers)\\n\",\n+        keptTestTxs + unconfirmedTestTxs + outlierTestTxs, keptTestTxs, unconfirmedTestTxs, outlierTestTxs);\n+    if (keptTestTxs > 0) {\n+        printf(\"Mean squared error: %g\\n\", double(errsq) / double(keptTestTxs));\n+    }\n+}\n+\n+int main(int argc, char** argv)\n+{\n+    Options options = ParseCommandLine(argc, argv);\n+\n+    if (options.help) {\n+        printf(\"%s\", Usage().c_str());\n+        return EXIT_SUCCESS;\n+    } else if (options.error) {\n+        fprintf(stderr, \"Try `fee_est -h` for more information.\\n\");\n+        return EXIT_FAILURE;\n+    } else if (options.dataFileOut.empty() && options.graphFileOut.empty() && !options.cross) {\n+        fprintf(stderr, \"Warning: No output options specified. Try -ograph, -odat, -cross options, or `fee_est -h` \"\n+                        \"for more information.\\n\");\n+    }\n+\n+    CBlockPolicyEstimator estimator;\n+    FeeEstInput input(estimator);\n+\n+    if (!options.dataFileIn.empty() && !input.readData(fs::PathFromString(options.dataFileIn))) {\n+        fprintf(stderr, \"Error: failed to load fee estimate data file '%s'\\n\", options.dataFileOut.c_str());\n+        return 1;\n+    }\n+\n+    const std::vector<unsigned int> targets = estimator.GetUniqueTargets();\n+    TxMap txMap;\n+\n+    auto filter = [&](UniValue& value) {\n+        bool keep = true;\n+        const UniValue& tx = value[\"tx\"];\n+        if (tx.isObject()) {\n+            auto inserted = txMap.emplace(uint256S(tx[\"hash\"].get_str()),\n+                TxData(tx[\"fee\"].get_int64(), tx[\"size\"].get_int(), tx[\"height\"].get_int()));\n+            if (options.cross && !UpdateCross(*inserted.first, targets, estimator)) {\n+                keep = false;\n+            }\n+        }\n+\n+        const UniValue& block = value[\"block\"];\n+        if (block.isObject()) {\n+            int blockHeight = block[\"height\"].get_int();\n+            const auto& block_txs = value[\"txs\"].getValues();\n+            for (const UniValue& block_tx : block_txs) {\n+                auto it = txMap.find(uint256S(block_tx[\"hash\"].get_str()));\n+                if (it != txMap.end()) {\n+                    it->second.actualBlocks = blockHeight - block_tx[\"height\"].get_int();\n+                }\n+            }\n+        }\n+\n+        return keep;\n+    };\n+\n+    if (!input.readLog(options.logFileIn, std::ref(filter))) {\n+        fprintf(stderr, \"Error: failed to load fee data log file '%s'\\n\", options.logFileIn.c_str());\n+        return EXIT_FAILURE;\n+    }\n+\n+    if (!options.dataFileOut.empty() && !input.writeData(fs::PathFromString(options.dataFileOut))) {\n+        fprintf(stderr, \"Error: failed to write fee estimate data file '%s'\\n\", options.dataFileOut.c_str());\n+        return EXIT_FAILURE;\n+    }\n+\n+    if (!options.graphFileOut.empty()) {\n+        WriteGraph(options.graphFileOut, txMap, targets, estimator);\n+        return EXIT_FAILURE;\n+    }\n+\n+    if (options.cross) {\n+        PrintCross(txMap, estimator);\n+    }\n+\n+    return EXIT_SUCCESS;\n+}"
      },
      {
        "sha": "45832c1b23004790927667586e27e59653e3dd7f",
        "filename": "test/lint/lint-format-strings.py",
        "status": "modified",
        "additions": 7,
        "deletions": 10,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/84f5df64005de6b6c0f651f2f6b0e470737fed4e/test/lint/lint-format-strings.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/84f5df64005de6b6c0f651f2f6b0e470737fed4e/test/lint/lint-format-strings.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-format-strings.py?ref=84f5df64005de6b6c0f651f2f6b0e470737fed4e",
        "patch": "@@ -13,16 +13,11 @@\n import sys\n \n FALSE_POSITIVES = [\n-    (\"src/dbwrapper.cpp\", \"vsnprintf(p, limit - p, format, backup_ap)\"),\n-    (\"src/index/base.cpp\", \"FatalError(const char* fmt, const Args&... args)\"),\n-    (\"src/netbase.cpp\", \"LogConnectFailure(bool manual_connection, const char* fmt, const Args&... args)\"),\n-    (\"src/util/system.cpp\", \"strprintf(_(COPYRIGHT_HOLDERS).translated, COPYRIGHT_HOLDERS_SUBSTITUTION)\"),\n-    (\"src/validationinterface.cpp\", \"LogPrint(BCLog::VALIDATION, fmt \\\"\\\\n\\\", __VA_ARGS__)\"),\n-    (\"src/wallet/wallet.h\",  \"WalletLogPrintf(std::string fmt, Params... parameters)\"),\n     (\"src/wallet/wallet.h\", \"LogPrintf((\\\"%s \\\" + fmt).c_str(), GetDisplayName(), parameters...)\"),\n     (\"src/wallet/scriptpubkeyman.h\",  \"WalletLogPrintf(std::string fmt, Params... parameters)\"),\n     (\"src/wallet/scriptpubkeyman.h\", \"LogPrintf((\\\"%s \\\" + fmt).c_str(), m_storage.GetDisplayName(), parameters...)\"),\n     (\"src/logging.h\", \"LogPrintf(const char* fmt, const Args&... args)\"),\n+    (\"src/validationinterface.cpp\", \"LogPrint(BCLog::VALIDATION, fmt \\\"\\\\n\\\", __VA_ARGS__)\"),\n     (\"src/wallet/scriptpubkeyman.h\", \"WalletLogPrintf(const std::string& fmt, const Params&... parameters)\"),\n ]\n \n@@ -197,12 +192,12 @@ def parse_function_call_and_arguments(function_name, function_call):\n \n \n def parse_string_content(argument):\n-    \"\"\"Return the text within quotes in string argument.\n+    \"\"\"Return the text within quotes in string argument, or None if the\n+    argument does not contain a quoted string.\n \n     >>> parse_string_content('1 \"foo %d bar\" 2')\n     'foo %d bar'\n     >>> parse_string_content('1 foobar 2')\n-    ''\n     >>> parse_string_content('1 \"bar\" 2')\n     'bar'\n     >>> parse_string_content('1 \"foo\" 2 \"bar\" 3')\n@@ -212,11 +207,11 @@ def parse_string_content(argument):\n     >>> parse_string_content('\"\"')\n     ''\n     >>> parse_string_content('')\n-    ''\n     >>> parse_string_content('1 2 3')\n-    ''\n     \"\"\"\n     assert type(argument) is str\n+    if \"\\\"\" not in argument:\n+        return None\n     string_content = \"\"\n     in_string = False\n     for char in normalize(escape(argument)):\n@@ -281,6 +276,8 @@ def main():\n                     continue\n                 argument_count = len(parts) - 3 - args.skip_arguments\n                 format_str = parse_string_content(parts[1 + args.skip_arguments])\n+                if format_str is None:\n+                    continue\n                 format_specifier_count = count_format_specifiers(format_str)\n                 if format_specifier_count != argument_count:\n                     exit_code = 1"
      },
      {
        "sha": "4dc9001397d23ab86e7aed5b4d92389ea9e97dae",
        "filename": "test/lint/lint-locale-dependence.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/84f5df64005de6b6c0f651f2f6b0e470737fed4e/test/lint/lint-locale-dependence.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/84f5df64005de6b6c0f651f2f6b0e470737fed4e/test/lint/lint-locale-dependence.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-locale-dependence.sh?ref=84f5df64005de6b6c0f651f2f6b0e470737fed4e",
        "patch": "@@ -43,6 +43,7 @@ export LC_ALL=C\n KNOWN_VIOLATIONS=(\n     \"src/dbwrapper.cpp:.*vsnprintf\"\n     \"src/test/dbwrapper_tests.cpp:.*snprintf\"\n+    \"src/test/fee_est/fee_est.cpp:.*printf\"\n     \"src/test/fuzz/locale.cpp\"\n     \"src/test/fuzz/string.cpp\"\n     \"src/torcontrol.cpp:.*strtol\""
      }
    ]
  }
]