[
  {
    "sha": "1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxZGZlNGEwYmJkMWY5MDEyZDgwMWY4ZTFmNmMyZDc4NDExY2E1ODNl",
    "commit": {
      "author": {
        "name": "awelch83",
        "email": "sends2aaron@gmail.com",
        "date": "2015-12-09T23:23:02Z"
      },
      "committer": {
        "name": "awelch83",
        "email": "sends2aaron@gmail.com",
        "date": "2015-12-09T23:23:02Z"
      },
      "message": "I made changes to *.cpp files beginning with the letter 'A'. I updated comments, where necessary, to Doxygen standards.",
      "tree": {
        "sha": "498f1533ef1511aabbd3ae93513968b63ad7b00e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/498f1533ef1511aabbd3ae93513968b63ad7b00e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e/comments",
    "author": {
      "login": "awelch83",
      "id": 10424723,
      "node_id": "MDQ6VXNlcjEwNDI0NzIz",
      "avatar_url": "https://avatars.githubusercontent.com/u/10424723?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/awelch83",
      "html_url": "https://github.com/awelch83",
      "followers_url": "https://api.github.com/users/awelch83/followers",
      "following_url": "https://api.github.com/users/awelch83/following{/other_user}",
      "gists_url": "https://api.github.com/users/awelch83/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/awelch83/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/awelch83/subscriptions",
      "organizations_url": "https://api.github.com/users/awelch83/orgs",
      "repos_url": "https://api.github.com/users/awelch83/repos",
      "events_url": "https://api.github.com/users/awelch83/events{/privacy}",
      "received_events_url": "https://api.github.com/users/awelch83/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "awelch83",
      "id": 10424723,
      "node_id": "MDQ6VXNlcjEwNDI0NzIz",
      "avatar_url": "https://avatars.githubusercontent.com/u/10424723?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/awelch83",
      "html_url": "https://github.com/awelch83",
      "followers_url": "https://api.github.com/users/awelch83/followers",
      "following_url": "https://api.github.com/users/awelch83/following{/other_user}",
      "gists_url": "https://api.github.com/users/awelch83/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/awelch83/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/awelch83/subscriptions",
      "organizations_url": "https://api.github.com/users/awelch83/orgs",
      "repos_url": "https://api.github.com/users/awelch83/repos",
      "events_url": "https://api.github.com/users/awelch83/events{/privacy}",
      "received_events_url": "https://api.github.com/users/awelch83/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "00b4b8d1c47a2189d085140cfb45be492de16db5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00b4b8d1c47a2189d085140cfb45be492de16db5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/00b4b8d1c47a2189d085140cfb45be492de16db5"
      }
    ],
    "stats": {
      "total": 518,
      "additions": 264,
      "deletions": 254
    },
    "files": [
      {
        "sha": "a58f6a1ade30fbdfe209106df3fc2b9f94ed4715",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 50,
        "deletions": 45,
        "changes": 95,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e",
        "patch": "@@ -1,6 +1,6 @@\n-// Copyright (c) 2012 Pieter Wuille\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+/// Copyright (c) 2012 Pieter Wuille\n+/// Distributed under the MIT software license, see the accompanying\n+/// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"addrman.h\"\n \n@@ -31,19 +31,24 @@ int CAddrInfo::GetBucketPosition(const uint256 &nKey, bool fNew, int nBucket) co\n \n bool CAddrInfo::IsTerrible(int64_t nNow) const\n {\n-    if (nLastTry && nLastTry >= nNow - 60) // never remove things tried in the last minute\n+    /// never remove things tried in the last minute\n+    if (nLastTry && nLastTry >= nNow - 60)\n         return false;\n \n-    if (nTime > nNow + 10 * 60) // came in a flying DeLorean\n+    /// came in a flying DeLorean\n+    if (nTime > nNow + 10 * 60)\n         return true;\n \n-    if (nTime == 0 || nNow - nTime > ADDRMAN_HORIZON_DAYS * 24 * 60 * 60) // not seen in recent history\n+    /// not seen in recent history\n+    if (nTime == 0 || nNow - nTime > ADDRMAN_HORIZON_DAYS * 24 * 60 * 60)\n         return true;\n \n-    if (nLastSuccess == 0 && nAttempts >= ADDRMAN_RETRIES) // tried N times and never a success\n+    /// tried N times and never a success\n+    if (nLastSuccess == 0 && nAttempts >= ADDRMAN_RETRIES)\n         return true;\n \n-    if (nNow - nLastSuccess > ADDRMAN_MIN_FAIL_DAYS * 24 * 60 * 60 && nAttempts >= ADDRMAN_MAX_FAILURES) // N successive failures in the last week\n+    /// N successive failures in the last week\n+    if (nNow - nLastSuccess > ADDRMAN_MIN_FAIL_DAYS * 24 * 60 * 60 && nAttempts >= ADDRMAN_MAX_FAILURES)\n         return true;\n \n     return false;\n@@ -61,11 +66,11 @@ double CAddrInfo::GetChance(int64_t nNow) const\n     if (nSinceLastTry < 0)\n         nSinceLastTry = 0;\n \n-    // deprioritize very recent attempts away\n+    /// deprioritize very recent attempts away\n     if (nSinceLastTry < 60 * 10)\n         fChance *= 0.01;\n \n-    // deprioritize 66% after each failed attempt, but at most 1/28th to avoid the search taking forever or overly penalizing outages.\n+    /// deprioritize 66% after each failed attempt, but at most 1/28th to avoid the search taking forever or overly penalizing outages.\n     fChance *= pow(0.66, std::min(nAttempts, 8));\n \n     return fChance;\n@@ -132,7 +137,7 @@ void CAddrMan::Delete(int nId)\n \n void CAddrMan::ClearNew(int nUBucket, int nUBucketPos)\n {\n-    // if there is an entry in the specified bucket, delete it.\n+    /// if there is an entry in the specified bucket, delete it.\n     if (vvNew[nUBucket][nUBucketPos] != -1) {\n         int nIdDelete = vvNew[nUBucket][nUBucketPos];\n         CAddrInfo& infoDelete = mapInfo[nIdDelete];\n@@ -147,7 +152,7 @@ void CAddrMan::ClearNew(int nUBucket, int nUBucketPos)\n \n void CAddrMan::MakeTried(CAddrInfo& info, int nId)\n {\n-    // remove the entry from all new buckets\n+    /// remove the entry from all new buckets\n     for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {\n         int pos = info.GetBucketPosition(nKey, true, bucket);\n         if (vvNew[bucket][pos] == nId) {\n@@ -159,29 +164,29 @@ void CAddrMan::MakeTried(CAddrInfo& info, int nId)\n \n     assert(info.nRefCount == 0);\n \n-    // which tried bucket to move the entry to\n+    /// which tried bucket to move the entry to\n     int nKBucket = info.GetTriedBucket(nKey);\n     int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);\n \n-    // first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).\n+    /// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).\n     if (vvTried[nKBucket][nKBucketPos] != -1) {\n-        // find an item to evict\n+        /// find an item to evict\n         int nIdEvict = vvTried[nKBucket][nKBucketPos];\n         assert(mapInfo.count(nIdEvict) == 1);\n         CAddrInfo& infoOld = mapInfo[nIdEvict];\n \n-        // Remove the to-be-evicted item from the tried set.\n+        /// Remove the to-be-evicted item from the tried set.\n         infoOld.fInTried = false;\n         vvTried[nKBucket][nKBucketPos] = -1;\n         nTried--;\n \n-        // find which new bucket it belongs to\n+        /// find which new bucket it belongs to\n         int nUBucket = infoOld.GetNewBucket(nKey);\n         int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);\n         ClearNew(nUBucket, nUBucketPos);\n         assert(vvNew[nUBucket][nUBucketPos] == -1);\n \n-        // Enter it into the new set again.\n+        /// Enter it into the new set again.\n         infoOld.nRefCount = 1;\n         vvNew[nUBucket][nUBucketPos] = nIdEvict;\n         nNew++;\n@@ -198,28 +203,28 @@ void CAddrMan::Good_(const CService& addr, int64_t nTime)\n     int nId;\n     CAddrInfo* pinfo = Find(addr, &nId);\n \n-    // if not found, bail out\n+    /// if not found, bail out\n     if (!pinfo)\n         return;\n \n     CAddrInfo& info = *pinfo;\n \n-    // check whether we are talking about the exact same CService (including same port)\n+    /// check whether we are talking about the exact same CService (including same port)\n     if (info != addr)\n         return;\n \n-    // update info\n+    /// update info\n     info.nLastSuccess = nTime;\n     info.nLastTry = nTime;\n     info.nAttempts = 0;\n-    // nTime is not updated here, to avoid leaking information about\n-    // currently-connected peers.\n+    /// nTime is not updated here, to avoid leaking information about\n+    /// currently-connected peers.\n \n-    // if it is already in the tried set, don't do anything else\n+    /// if it is already in the tried set, don't do anything else\n     if (info.fInTried)\n         return;\n \n-    // find a bucket it is in now\n+    /// find a bucket it is in now\n     int nRnd = GetRandInt(ADDRMAN_NEW_BUCKET_COUNT);\n     int nUBucket = -1;\n     for (unsigned int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {\n@@ -231,14 +236,14 @@ void CAddrMan::Good_(const CService& addr, int64_t nTime)\n         }\n     }\n \n-    // if no bucket is found, something bad happened;\n-    // TODO: maybe re-add the node, but for now, just bail out\n+    /// if no bucket is found, something bad happened;\n+    /// TODO: maybe re-add the node, but for now, just bail out\n     if (nUBucket == -1)\n         return;\n \n     LogPrint(\"addrman\", \"Moving %s to tried\\n\", addr.ToString());\n \n-    // move nId to the tried tables\n+    /// move nId to the tried tables\n     MakeTried(info, nId);\n }\n \n@@ -252,28 +257,28 @@ bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimeP\n     CAddrInfo* pinfo = Find(addr, &nId);\n \n     if (pinfo) {\n-        // periodically update nTime\n+        /// periodically update nTime\n         bool fCurrentlyOnline = (GetAdjustedTime() - addr.nTime < 24 * 60 * 60);\n         int64_t nUpdateInterval = (fCurrentlyOnline ? 60 * 60 : 24 * 60 * 60);\n         if (addr.nTime && (!pinfo->nTime || pinfo->nTime < addr.nTime - nUpdateInterval - nTimePenalty))\n             pinfo->nTime = std::max((int64_t)0, addr.nTime - nTimePenalty);\n \n-        // add services\n+        /// add services\n         pinfo->nServices |= addr.nServices;\n \n-        // do not update if no new information is present\n+        /// do not update if no new information is present\n         if (!addr.nTime || (pinfo->nTime && addr.nTime <= pinfo->nTime))\n             return false;\n \n-        // do not update if the entry was already in the \"tried\" table\n+        /// do not update if the entry was already in the \"tried\" table\n         if (pinfo->fInTried)\n             return false;\n \n-        // do not update if the max reference count is reached\n+        /// do not update if the max reference count is reached\n         if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)\n             return false;\n \n-        // stochastic test: previous nRefCount == N: 2^N times harder to increase it\n+        /// stochastic test: previous nRefCount == N: 2^N times harder to increase it\n         int nFactor = 1;\n         for (int n = 0; n < pinfo->nRefCount; n++)\n             nFactor *= 2;\n@@ -293,7 +298,7 @@ bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimeP\n         if (!fInsert) {\n             CAddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];\n             if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {\n-                // Overwrite the existing new table entry.\n+                /// Overwrite the existing new table entry.\n                 fInsert = true;\n             }\n         }\n@@ -314,17 +319,17 @@ void CAddrMan::Attempt_(const CService& addr, int64_t nTime)\n {\n     CAddrInfo* pinfo = Find(addr);\n \n-    // if not found, bail out\n+    /// if not found, bail out\n     if (!pinfo)\n         return;\n \n     CAddrInfo& info = *pinfo;\n \n-    // check whether we are talking about the exact same CService (including same port)\n+    /// check whether we are talking about the exact same CService (including same port)\n     if (info != addr)\n         return;\n \n-    // update info\n+    /// update info\n     info.nLastTry = nTime;\n     info.nAttempts++;\n }\n@@ -337,10 +342,10 @@ CAddrInfo CAddrMan::Select_(bool newOnly)\n     if (newOnly && nNew == 0)\n         return CAddrInfo();\n \n-    // Use a 50% chance for choosing between tried and new table entries.\n+    /// Use a 50% chance for choosing between tried and new table entries.\n     if (!newOnly &&\n        (nTried > 0 && (nNew == 0 || GetRandInt(2) == 0))) { \n-        // use a tried node\n+        /// use a tried node\n         double fChanceFactor = 1.0;\n         while (1) {\n             int nKBucket = GetRandInt(ADDRMAN_TRIED_BUCKET_COUNT);\n@@ -357,7 +362,7 @@ CAddrInfo CAddrMan::Select_(bool newOnly)\n             fChanceFactor *= 1.2;\n         }\n     } else {\n-        // use a new node\n+        /// use a new node\n         double fChanceFactor = 1.0;\n         while (1) {\n             int nUBucket = GetRandInt(ADDRMAN_NEW_BUCKET_COUNT);\n@@ -460,7 +465,7 @@ void CAddrMan::GetAddr_(std::vector<CAddress>& vAddr)\n     if (nNodes > ADDRMAN_GETADDR_MAX)\n         nNodes = ADDRMAN_GETADDR_MAX;\n \n-    // gather a list of random nodes, skipping those of low quality\n+    /// gather a list of random nodes, skipping those of low quality\n     for (unsigned int n = 0; n < vRandom.size(); n++) {\n         if (vAddr.size() >= nNodes)\n             break;\n@@ -479,17 +484,17 @@ void CAddrMan::Connected_(const CService& addr, int64_t nTime)\n {\n     CAddrInfo* pinfo = Find(addr);\n \n-    // if not found, bail out\n+    /// if not found, bail out\n     if (!pinfo)\n         return;\n \n     CAddrInfo& info = *pinfo;\n \n-    // check whether we are talking about the exact same CService (including same port)\n+    /// check whether we are talking about the exact same CService (including same port)\n     if (info != addr)\n         return;\n \n-    // update info\n+    /// update info\n     int64_t nUpdateInterval = 20 * 60;\n     if (nTime - info.nTime > nUpdateInterval)\n         info.nTime = nTime;"
      },
      {
        "sha": "6b5214490b2347b8ead20ae6a4a7de7d8d583599",
        "filename": "src/alert.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 24,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e/src/alert.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e/src/alert.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/alert.cpp?ref=1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e",
        "patch": "@@ -1,7 +1,7 @@\n-// Copyright (c) 2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2014 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+/// Copyright (c) 2010 Satoshi Nakamoto\n+/// Copyright (c) 2009-2014 The Bitcoin Core developers\n+/// Distributed under the MIT software license, see the accompanying\n+/// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"alert.h\"\n \n@@ -107,13 +107,13 @@ bool CAlert::IsInEffect() const\n bool CAlert::Cancels(const CAlert& alert) const\n {\n     if (!IsInEffect())\n-        return false; // this was a no-op before 31403\n+        return false; /// this was a no-op before 31403\n     return (alert.nID <= nCancel || setCancel.count(alert.nID));\n }\n \n bool CAlert::AppliesTo(int nVersion, const std::string& strSubVerIn) const\n {\n-    // TODO: rework for client-version-embedded-in-strSubVer ?\n+    /// TODO: rework for client-version-embedded-in-strSubVer ?\n     return (IsInEffect() &&\n             nMinVer <= nVersion && nVersion <= nMaxVer &&\n             (setSubVer.empty() || setSubVer.count(strSubVerIn)));\n@@ -128,10 +128,10 @@ bool CAlert::RelayTo(CNode* pnode) const\n {\n     if (!IsInEffect())\n         return false;\n-    // don't relay to nodes which haven't sent their version message\n+    /// don't relay to nodes which haven't sent their version message\n     if (pnode->nVersion == 0)\n         return false;\n-    // returns true if wasn't already contained in the set\n+    /// returns true if wasn't already contained in the set\n     if (pnode->setKnown.insert(GetHash()).second)\n     {\n         if (AppliesTo(pnode->nVersion, pnode->strSubVer) ||\n@@ -151,7 +151,7 @@ bool CAlert::CheckSignature(const std::vector<unsigned char>& alertKey) const\n     if (!key.Verify(Hash(vchMsg.begin(), vchMsg.end()), vchSig))\n         return error(\"CAlert::CheckSignature(): verify signature failed\");\n \n-    // Now unserialize the data\n+    /// Now unserialize the data\n     CDataStream sMsg(vchMsg, SER_NETWORK, PROTOCOL_VERSION);\n     sMsg >> *(CUnsignedAlert*)this;\n     return true;\n@@ -176,13 +176,13 @@ bool CAlert::ProcessAlert(const std::vector<unsigned char>& alertKey, bool fThre\n     if (!IsInEffect())\n         return false;\n \n-    // alert.nID=max is reserved for if the alert key is\n-    // compromised. It must have a pre-defined message,\n-    // must never expire, must apply to all versions,\n-    // and must cancel all previous\n-    // alerts or it will be ignored (so an attacker can't\n-    // send an \"everything is OK, don't panic\" version that\n-    // cannot be overridden):\n+    /// alert.nID=max is reserved for if the alert key is\n+    /// compromised. It must have a pre-defined message,\n+    /// must never expire, must apply to all versions,\n+    /// and must cancel all previous\n+    /// alerts or it will be ignored (so an attacker can't\n+    /// send an \"everything is OK, don't panic\" version that\n+    /// cannot be overridden):\n     int maxInt = std::numeric_limits<int>::max();\n     if (nID == maxInt)\n     {\n@@ -200,7 +200,7 @@ bool CAlert::ProcessAlert(const std::vector<unsigned char>& alertKey, bool fThre\n \n     {\n         LOCK(cs_mapAlerts);\n-        // Cancel previous alerts\n+        /// Cancel previous alerts\n         for (map<uint256, CAlert>::iterator mi = mapAlerts.begin(); mi != mapAlerts.end();)\n         {\n             const CAlert& alert = (*mi).second;\n@@ -220,7 +220,7 @@ bool CAlert::ProcessAlert(const std::vector<unsigned char>& alertKey, bool fThre\n                 mi++;\n         }\n \n-        // Check if this alert has been cancelled\n+        /// Check if this alert has been cancelled\n         BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n         {\n             const CAlert& alert = item.second;\n@@ -231,9 +231,9 @@ bool CAlert::ProcessAlert(const std::vector<unsigned char>& alertKey, bool fThre\n             }\n         }\n \n-        // Add to mapAlerts\n+        /// Add to mapAlerts\n         mapAlerts.insert(make_pair(GetHash(), *this));\n-        // Notify UI and -alertnotify if it applies to me\n+        /// Notify UI and -alertnotify if it applies to me\n         if(AppliesToMe())\n         {\n             uiInterface.NotifyAlertChanged(GetHash(), CT_NEW);\n@@ -251,16 +251,16 @@ CAlert::Notify(const std::string& strMessage, bool fThread)\n     std::string strCmd = GetArg(\"-alertnotify\", \"\");\n     if (strCmd.empty()) return;\n \n-    // Alert text should be plain ascii coming from a trusted source, but to\n-    // be safe we first strip anything not in safeChars, then add single quotes around\n-    // the whole string before passing it to the shell:\n+    /// Alert text should be plain ascii coming from a trusted source, but to\n+    /// be safe we first strip anything not in safeChars, then add single quotes around\n+    /// the whole string before passing it to the shell:\n     std::string singleQuote(\"'\");\n     std::string safeStatus = SanitizeString(strMessage);\n     safeStatus = singleQuote+safeStatus+singleQuote;\n     boost::replace_all(strCmd, \"%s\", safeStatus);\n \n     if (fThread)\n-        boost::thread t(runCommand, strCmd); // thread runs free\n+        boost::thread t(runCommand, strCmd); /// thread runs free\n     else\n         runCommand(strCmd);\n }"
      },
      {
        "sha": "a8e607699233b54cdda166d42219f5ba73c0e896",
        "filename": "src/amount.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e/src/amount.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e/src/amount.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/amount.cpp?ref=1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e",
        "patch": "@@ -1,7 +1,7 @@\n-// Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2014 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+/// Copyright (c) 2009-2010 Satoshi Nakamoto\n+/// Copyright (c) 2009-2014 The Bitcoin Core developers\n+/// Distributed under the MIT software license, see the accompanying\n+/// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"amount.h\"\n "
      },
      {
        "sha": "3f468a8dacaba86e37440085d8834de131f189e7",
        "filename": "src/arith_uint256.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 17,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e/src/arith_uint256.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e/src/arith_uint256.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/arith_uint256.cpp?ref=1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e",
        "patch": "@@ -1,7 +1,7 @@\n-// Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2014 The Bitcoin developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+/// Copyright (c) 2009-2010 Satoshi Nakamoto\n+/// Copyright (c) 2009-2014 The Bitcoin developers\n+/// Distributed under the MIT software license, see the accompanying\n+/// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"arith_uint256.h\"\n \n@@ -83,26 +83,26 @@ base_uint<BITS>& base_uint<BITS>::operator*=(const base_uint& b)\n template <unsigned int BITS>\n base_uint<BITS>& base_uint<BITS>::operator/=(const base_uint& b)\n {\n-    base_uint<BITS> div = b;     // make a copy, so we can shift.\n-    base_uint<BITS> num = *this; // make a copy, so we can subtract.\n-    *this = 0;                   // the quotient.\n+    base_uint<BITS> div = b;     /// make a copy, so we can shift.\n+    base_uint<BITS> num = *this; /// make a copy, so we can subtract.\n+    *this = 0;                   /// the quotient.\n     int num_bits = num.bits();\n     int div_bits = div.bits();\n     if (div_bits == 0)\n         throw uint_error(\"Division by zero\");\n-    if (div_bits > num_bits) // the result is certainly 0.\n+    if (div_bits > num_bits) /// the result is certainly 0.\n         return *this;\n     int shift = num_bits - div_bits;\n-    div <<= shift; // shift so that div and num align.\n+    div <<= shift; /// shift so that div and num align.\n     while (shift >= 0) {\n         if (num >= div) {\n             num -= div;\n-            pn[shift / 32] |= (1 << (shift & 31)); // set a bit of the result.\n+            pn[shift / 32] |= (1 << (shift & 31)); /// set a bit of the result.\n         }\n-        div >>= 1; // shift back.\n+        div >>= 1; /// shift back.\n         shift--;\n     }\n-    // num now contains the remainder of the division.\n+    /// num now contains the remainder of the division.\n     return *this;\n }\n \n@@ -183,7 +183,7 @@ unsigned int base_uint<BITS>::bits() const\n     return 0;\n }\n \n-// Explicit instantiations for base_uint<256>\n+/// Explicit instantiations for base_uint<256>\n template base_uint<256>::base_uint(const std::string&);\n template base_uint<256>& base_uint<256>::operator<<=(unsigned int);\n template base_uint<256>& base_uint<256>::operator>>=(unsigned int);\n@@ -199,8 +199,8 @@ template void base_uint<256>::SetHex(const char*);\n template void base_uint<256>::SetHex(const std::string&);\n template unsigned int base_uint<256>::bits() const;\n \n-// This implementation directly uses shifts instead of going\n-// through an intermediate MPI representation.\n+/// This implementation directly uses shifts instead of going\n+/// through an intermediate MPI representation.\n arith_uint256& arith_uint256::SetCompact(uint32_t nCompact, bool* pfNegative, bool* pfOverflow)\n {\n     int nSize = nCompact >> 24;\n@@ -231,8 +231,8 @@ uint32_t arith_uint256::GetCompact(bool fNegative) const\n         arith_uint256 bn = *this >> 8 * (nSize - 3);\n         nCompact = bn.GetLow64();\n     }\n-    // The 0x00800000 bit denotes the sign.\n-    // Thus, if it is already set, divide the mantissa by 256 and increase the exponent.\n+    /// The 0x00800000 bit denotes the sign.\n+    /// Thus, if it is already set, divide the mantissa by 256 and increase the exponent.\n     if (nCompact & 0x00800000) {\n         nCompact >>= 8;\n         nSize++;"
      },
      {
        "sha": "ef9931c147884a91a738dd245e3d29e220d36d64",
        "filename": "src/qt/addressbookpage.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 18,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e/src/qt/addressbookpage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e/src/qt/addressbookpage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addressbookpage.cpp?ref=1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e",
        "patch": "@@ -1,6 +1,6 @@\n-// Copyright (c) 2011-2013 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+/// Copyright (c) 2011-2013 The Bitcoin Core developers\n+/// Distributed under the MIT software license, see the accompanying\n+/// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #if defined(HAVE_CONFIG_H)\n #include \"config/bitcoin-config.h\"\n@@ -76,13 +76,13 @@ AddressBookPage::AddressBookPage(const PlatformStyle *platformStyle, Mode mode,\n         break;\n     }\n \n-    // Context menu actions\n+    /// Context menu actions\n     QAction *copyAddressAction = new QAction(tr(\"&Copy Address\"), this);\n     QAction *copyLabelAction = new QAction(tr(\"Copy &Label\"), this);\n     QAction *editAction = new QAction(tr(\"&Edit\"), this);\n     deleteAction = new QAction(ui->deleteAddress->text(), this);\n \n-    // Build context menu\n+    /// Build context menu\n     contextMenu = new QMenu();\n     contextMenu->addAction(copyAddressAction);\n     contextMenu->addAction(copyLabelAction);\n@@ -91,7 +91,7 @@ AddressBookPage::AddressBookPage(const PlatformStyle *platformStyle, Mode mode,\n         contextMenu->addAction(deleteAction);\n     contextMenu->addSeparator();\n \n-    // Connect signals for context menu actions\n+    /// Connect signals for context menu actions\n     connect(copyAddressAction, SIGNAL(triggered()), this, SLOT(on_copyAddress_clicked()));\n     connect(copyLabelAction, SIGNAL(triggered()), this, SLOT(onCopyLabelAction()));\n     connect(editAction, SIGNAL(triggered()), this, SLOT(onEditAction()));\n@@ -121,20 +121,20 @@ void AddressBookPage::setModel(AddressTableModel *model)\n     switch(tab)\n     {\n     case ReceivingTab:\n-        // Receive filter\n+        /// Receive filter\n         proxyModel->setFilterRole(AddressTableModel::TypeRole);\n         proxyModel->setFilterFixedString(AddressTableModel::Receive);\n         break;\n     case SendingTab:\n-        // Send filter\n+        /// Send filter\n         proxyModel->setFilterRole(AddressTableModel::TypeRole);\n         proxyModel->setFilterFixedString(AddressTableModel::Send);\n         break;\n     }\n     ui->tableView->setModel(proxyModel);\n     ui->tableView->sortByColumn(0, Qt::AscendingOrder);\n \n-    // Set column widths\n+    /// Set column widths\n #if QT_VERSION < 0x050000\n     ui->tableView->horizontalHeader()->setResizeMode(AddressTableModel::Label, QHeaderView::Stretch);\n     ui->tableView->horizontalHeader()->setResizeMode(AddressTableModel::Address, QHeaderView::ResizeToContents);\n@@ -146,7 +146,7 @@ void AddressBookPage::setModel(AddressTableModel *model)\n     connect(ui->tableView->selectionModel(), SIGNAL(selectionChanged(QItemSelection,QItemSelection)),\n         this, SLOT(selectionChanged()));\n \n-    // Select row for newly created address\n+    /// Select row for newly created address\n     connect(model, SIGNAL(rowsInserted(QModelIndex,int,int)), this, SLOT(selectNewAddress(QModelIndex,int,int)));\n \n     selectionChanged();\n@@ -214,7 +214,7 @@ void AddressBookPage::on_deleteAddress_clicked()\n \n void AddressBookPage::selectionChanged()\n {\n-    // Set button states based on selected tab and selection\n+    /// Set button states based on selected tab and selection\n     QTableView *table = ui->tableView;\n     if(!table->selectionModel())\n         return;\n@@ -224,13 +224,13 @@ void AddressBookPage::selectionChanged()\n         switch(tab)\n         {\n         case SendingTab:\n-            // In sending tab, allow deletion of selection\n+            /// In sending tab, allow deletion of selection\n             ui->deleteAddress->setEnabled(true);\n             ui->deleteAddress->setVisible(true);\n             deleteAction->setEnabled(true);\n             break;\n         case ReceivingTab:\n-            // Deleting receiving addresses, however, is not allowed\n+            /// Deleting receiving addresses, however, is not allowed\n             ui->deleteAddress->setEnabled(false);\n             ui->deleteAddress->setVisible(false);\n             deleteAction->setEnabled(false);\n@@ -251,7 +251,7 @@ void AddressBookPage::done(int retval)\n     if(!table->selectionModel() || !table->model())\n         return;\n \n-    // Figure out which address was selected, and return it\n+    /// Figure out which address was selected, and return it\n     QModelIndexList indexes = table->selectionModel()->selectedRows(AddressTableModel::Address);\n \n     Q_FOREACH (const QModelIndex& index, indexes) {\n@@ -261,7 +261,7 @@ void AddressBookPage::done(int retval)\n \n     if(returnValue.isEmpty())\n     {\n-        // If no address entry selected, return rejected\n+        /// If no address entry selected, return rejected\n         retval = Rejected;\n     }\n \n@@ -270,7 +270,7 @@ void AddressBookPage::done(int retval)\n \n void AddressBookPage::on_exportButton_clicked()\n {\n-    // CSV is currently the only supported format\n+    /// CSV is currently the only supported format\n     QString filename = GUIUtil::getSaveFileName(this,\n         tr(\"Export Address List\"), QString(),\n         tr(\"Comma separated file (*.csv)\"), NULL);\n@@ -280,7 +280,7 @@ void AddressBookPage::on_exportButton_clicked()\n \n     CSVModelWriter writer(filename);\n \n-    // name, column, role\n+    /// name, column, role\n     writer.setModel(proxyModel);\n     writer.addColumn(\"Label\", AddressTableModel::Label, Qt::EditRole);\n     writer.addColumn(\"Address\", AddressTableModel::Address, Qt::EditRole);\n@@ -305,7 +305,7 @@ void AddressBookPage::selectNewAddress(const QModelIndex &parent, int begin, int\n     QModelIndex idx = proxyModel->mapFromSource(model->index(begin, AddressTableModel::Address, parent));\n     if(idx.isValid() && (idx.data(Qt::EditRole).toString() == newAddressToSelect))\n     {\n-        // Select row of newly created address, once\n+        /// Select row of newly created address, once\n         ui->tableView->setFocus();\n         ui->tableView->selectRow(idx.row());\n         newAddressToSelect.clear();"
      },
      {
        "sha": "77ae3343297a958a8ae5afb3d4c754fec2623836",
        "filename": "src/qt/addresstablemodel.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 30,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e/src/qt/addresstablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e/src/qt/addresstablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addresstablemodel.cpp?ref=1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e",
        "patch": "@@ -1,6 +1,6 @@\n-// Copyright (c) 2011-2013 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+/// Copyright (c) 2011-2013 The Bitcoin Core developers\n+/// Distributed under the MIT software license, see the accompanying\n+/// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"addresstablemodel.h\"\n \n@@ -23,7 +23,7 @@ struct AddressTableEntry\n     enum Type {\n         Sending,\n         Receiving,\n-        Hidden /* QSortFilterProxyModel will filter these out */\n+        Hidden //!< QSortFilterProxyModel will filter these out\n     };\n \n     Type type;\n@@ -51,11 +51,13 @@ struct AddressTableEntryLessThan\n     }\n };\n \n-/* Determine address type from address purpose */\n+/**\n+ * Determine address type from address purpose\n+ */\n static AddressTableEntry::Type translateTransactionType(const QString &strPurpose, bool isMine)\n {\n     AddressTableEntry::Type addressType = AddressTableEntry::Hidden;\n-    // \"refund\" addresses aren't shown, and change addresses aren't in mapAddressBook at all.\n+    /// \"refund\" addresses aren't shown, and change addresses aren't in mapAddressBook at all.\n     if (strPurpose == \"send\")\n         addressType = AddressTableEntry::Sending;\n     else if (strPurpose == \"receive\")\n@@ -65,7 +67,7 @@ static AddressTableEntry::Type translateTransactionType(const QString &strPurpos\n     return addressType;\n }\n \n-// Private implementation\n+/// Private implementation\n class AddressTablePriv\n {\n public:\n@@ -93,15 +95,15 @@ class AddressTablePriv\n                                   QString::fromStdString(address.ToString())));\n             }\n         }\n-        // qLowerBound() and qUpperBound() require our cachedAddressTable list to be sorted in asc order\n-        // Even though the map is already sorted this re-sorting step is needed because the originating map\n-        // is sorted by binary address, not by base58() address.\n+        /// qLowerBound() and qUpperBound() require our cachedAddressTable list to be sorted in asc order\n+        /// Even though the map is already sorted this re-sorting step is needed because the originating map\n+        /// is sorted by binary address, not by base58() address.\n         qSort(cachedAddressTable.begin(), cachedAddressTable.end(), AddressTableEntryLessThan());\n     }\n \n     void updateEntry(const QString &address, const QString &label, bool isMine, const QString &purpose, int status)\n     {\n-        // Find address / label in model\n+        /// Find address / label in model\n         QList<AddressTableEntry>::iterator lower = qLowerBound(\n             cachedAddressTable.begin(), cachedAddressTable.end(), address, AddressTableEntryLessThan());\n         QList<AddressTableEntry>::iterator upper = qUpperBound(\n@@ -246,11 +248,11 @@ bool AddressTableModel::setData(const QModelIndex &index, const QVariant &value,\n \n     if(role == Qt::EditRole)\n     {\n-        LOCK(wallet->cs_wallet); /* For SetAddressBook / DelAddressBook */\n+        LOCK(wallet->cs_wallet); /// For SetAddressBook / DelAddressBook\n         CTxDestination curAddress = CBitcoinAddress(rec->address.toStdString()).Get();\n         if(index.column() == Label)\n         {\n-            // Do nothing, if old label == new label\n+            /// Do nothing, if old label == new label\n             if(rec->label == value.toString())\n             {\n                 editStatus = NO_CHANGES;\n@@ -259,31 +261,31 @@ bool AddressTableModel::setData(const QModelIndex &index, const QVariant &value,\n             wallet->SetAddressBook(curAddress, value.toString().toStdString(), strPurpose);\n         } else if(index.column() == Address) {\n             CTxDestination newAddress = CBitcoinAddress(value.toString().toStdString()).Get();\n-            // Refuse to set invalid address, set error status and return false\n+            /// Refuse to set invalid address, set error status and return false\n             if(boost::get<CNoDestination>(&newAddress))\n             {\n                 editStatus = INVALID_ADDRESS;\n                 return false;\n             }\n-            // Do nothing, if old address == new address\n+            /// Do nothing, if old address == new address\n             else if(newAddress == curAddress)\n             {\n                 editStatus = NO_CHANGES;\n                 return false;\n             }\n-            // Check for duplicate addresses to prevent accidental deletion of addresses, if you try\n-            // to paste an existing address over another address (with a different label)\n+            /// Check for duplicate addresses to prevent accidental deletion of addresses, if you try\n+            /// to paste an existing address over another address (with a different label)\n             else if(wallet->mapAddressBook.count(newAddress))\n             {\n                 editStatus = DUPLICATE_ADDRESS;\n                 return false;\n             }\n-            // Double-check that we're not overwriting a receiving address\n+            /// Double-check that we're not overwriting a receiving address\n             else if(rec->type == AddressTableEntry::Sending)\n             {\n-                // Remove old entry\n+                /// Remove old entry\n                 wallet->DelAddressBook(curAddress);\n-                // Add new entry with new address\n+                /// Add new entry with new address\n                 wallet->SetAddressBook(newAddress, rec->label.toStdString(), strPurpose);\n             }\n         }\n@@ -311,8 +313,8 @@ Qt::ItemFlags AddressTableModel::flags(const QModelIndex &index) const\n     AddressTableEntry *rec = static_cast<AddressTableEntry*>(index.internalPointer());\n \n     Qt::ItemFlags retval = Qt::ItemIsSelectable | Qt::ItemIsEnabled;\n-    // Can edit address and label for sending addresses,\n-    // and only label for receiving addresses.\n+    /// Can edit address and label for sending addresses,\n+    /// and only label for receiving addresses.\n     if(rec->type == AddressTableEntry::Sending ||\n       (rec->type == AddressTableEntry::Receiving && index.column()==Label))\n     {\n@@ -338,7 +340,7 @@ QModelIndex AddressTableModel::index(int row, int column, const QModelIndex &par\n void AddressTableModel::updateEntry(const QString &address,\n         const QString &label, bool isMine, const QString &purpose, int status)\n {\n-    // Update address book model from Bitcoin core\n+    /// Update address book model from Bitcoin core\n     priv->updateEntry(address, label, isMine, purpose, status);\n }\n \n@@ -356,7 +358,7 @@ QString AddressTableModel::addRow(const QString &type, const QString &label, con\n             editStatus = INVALID_ADDRESS;\n             return QString();\n         }\n-        // Check for duplicate addresses\n+        /// Check for duplicate addresses\n         {\n             LOCK(wallet->cs_wallet);\n             if(wallet->mapAddressBook.count(CBitcoinAddress(strAddress).Get()))\n@@ -368,14 +370,14 @@ QString AddressTableModel::addRow(const QString &type, const QString &label, con\n     }\n     else if(type == Receive)\n     {\n-        // Generate a new address to associate with given label\n+        /// Generate a new address to associate with given label\n         CPubKey newKey;\n         if(!wallet->GetKeyFromPool(newKey))\n         {\n             WalletModel::UnlockContext ctx(walletModel->requestUnlock());\n             if(!ctx.isValid())\n             {\n-                // Unlock wallet failed or was cancelled\n+                /// Unlock wallet failed or was cancelled\n                 editStatus = WALLET_UNLOCK_FAILURE;\n                 return QString();\n             }\n@@ -392,7 +394,7 @@ QString AddressTableModel::addRow(const QString &type, const QString &label, con\n         return QString();\n     }\n \n-    // Add entry\n+    /// Add entry\n     {\n         LOCK(wallet->cs_wallet);\n         wallet->SetAddressBook(CBitcoinAddress(strAddress).Get(), strLabel,\n@@ -407,8 +409,8 @@ bool AddressTableModel::removeRows(int row, int count, const QModelIndex &parent\n     AddressTableEntry *rec = priv->index(row);\n     if(count != 1 || !rec || rec->type == AddressTableEntry::Receiving)\n     {\n-        // Can only remove one row at a time, and cannot remove rows not in model.\n-        // Also refuse to remove receiving addresses.\n+        /// Can only remove one row at a time, and cannot remove rows not in model.\n+        /// Also refuse to remove receiving addresses.\n         return false;\n     }\n     {\n@@ -418,7 +420,8 @@ bool AddressTableModel::removeRows(int row, int count, const QModelIndex &parent\n     return true;\n }\n \n-/* Look up label for address in address book, if not found return empty string.\n+/**\n+ * Look up label for address in address book, if not found return empty string.\n  */\n QString AddressTableModel::labelForAddress(const QString &address) const\n {"
      },
      {
        "sha": "619d5e2dccb291078b316f134f62d3471447fa46",
        "filename": "src/qt/askpassphrasedialog.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 23,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e/src/qt/askpassphrasedialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e/src/qt/askpassphrasedialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/askpassphrasedialog.cpp?ref=1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e",
        "patch": "@@ -1,6 +1,6 @@\n-// Copyright (c) 2011-2013 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+/// Copyright (c) 2011-2013 The Bitcoin Core developers\n+/// Distributed under the MIT software license, see the accompanying\n+/// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"askpassphrasedialog.h\"\n #include \"ui_askpassphrasedialog.h\"\n@@ -31,36 +31,36 @@ AskPassphraseDialog::AskPassphraseDialog(Mode mode, QWidget *parent) :\n     ui->passEdit2->setMaxLength(MAX_PASSPHRASE_SIZE);\n     ui->passEdit3->setMaxLength(MAX_PASSPHRASE_SIZE);\n \n-    // Setup Caps Lock detection.\n+    /// Setup Caps Lock detection.\n     ui->passEdit1->installEventFilter(this);\n     ui->passEdit2->installEventFilter(this);\n     ui->passEdit3->installEventFilter(this);\n \n     switch(mode)\n     {\n-        case Encrypt: // Ask passphrase x2\n+        case Encrypt: /// Ask passphrase x2\n             ui->warningLabel->setText(tr(\"Enter the new passphrase to the wallet.<br/>Please use a passphrase of <b>ten or more random characters</b>, or <b>eight or more words</b>.\"));\n             ui->passLabel1->hide();\n             ui->passEdit1->hide();\n             setWindowTitle(tr(\"Encrypt wallet\"));\n             break;\n-        case Unlock: // Ask passphrase\n+        case Unlock: /// Ask passphrase\n             ui->warningLabel->setText(tr(\"This operation needs your wallet passphrase to unlock the wallet.\"));\n             ui->passLabel2->hide();\n             ui->passEdit2->hide();\n             ui->passLabel3->hide();\n             ui->passEdit3->hide();\n             setWindowTitle(tr(\"Unlock wallet\"));\n             break;\n-        case Decrypt:   // Ask passphrase\n+        case Decrypt:   /// Ask passphrase\n             ui->warningLabel->setText(tr(\"This operation needs your wallet passphrase to decrypt the wallet.\"));\n             ui->passLabel2->hide();\n             ui->passEdit2->hide();\n             ui->passLabel3->hide();\n             ui->passEdit3->hide();\n             setWindowTitle(tr(\"Decrypt wallet\"));\n             break;\n-        case ChangePass: // Ask old passphrase + new passphrase x2\n+        case ChangePass: /// Ask old passphrase + new passphrase x2\n             setWindowTitle(tr(\"Change passphrase\"));\n             ui->warningLabel->setText(tr(\"Enter the old passphrase and new passphrase to the wallet.\"));\n             break;\n@@ -73,7 +73,7 @@ AskPassphraseDialog::AskPassphraseDialog(Mode mode, QWidget *parent) :\n \n AskPassphraseDialog::~AskPassphraseDialog()\n {\n-    // Attempt to overwrite text so that they do not linger around in memory\n+    /// Attempt to overwrite text so that they do not linger around in memory\n     ui->passEdit1->setText(QString(\" \").repeated(ui->passEdit1->text().size()));\n     ui->passEdit2->setText(QString(\" \").repeated(ui->passEdit2->text().size()));\n     ui->passEdit3->setText(QString(\" \").repeated(ui->passEdit3->text().size()));\n@@ -93,8 +93,8 @@ void AskPassphraseDialog::accept()\n     oldpass.reserve(MAX_PASSPHRASE_SIZE);\n     newpass1.reserve(MAX_PASSPHRASE_SIZE);\n     newpass2.reserve(MAX_PASSPHRASE_SIZE);\n-    // TODO: get rid of this .c_str() by implementing SecureString::operator=(std::string)\n-    // Alternately, find a way to make this input mlock()'d to begin with.\n+    /// TODO: get rid of this .c_str() by implementing SecureString::operator=(std::string)\n+    /// Alternately, find a way to make this input mlock()'d to begin with.\n     oldpass.assign(ui->passEdit1->text().toStdString().c_str());\n     newpass1.assign(ui->passEdit2->text().toStdString().c_str());\n     newpass2.assign(ui->passEdit3->text().toStdString().c_str());\n@@ -104,7 +104,7 @@ void AskPassphraseDialog::accept()\n     case Encrypt: {\n         if(newpass1.empty() || newpass2.empty())\n         {\n-            // Cannot encrypt with empty passphrase\n+            /// Cannot encrypt with empty passphrase\n             break;\n         }\n         QMessageBox::StandardButton retval = QMessageBox::question(this, tr(\"Confirm wallet encryption\"),\n@@ -135,7 +135,7 @@ void AskPassphraseDialog::accept()\n                     QMessageBox::critical(this, tr(\"Wallet encryption failed\"),\n                                          tr(\"Wallet encryption failed due to an internal error. Your wallet was not encrypted.\"));\n                 }\n-                QDialog::accept(); // Success\n+                QDialog::accept(); /// Success\n             }\n             else\n             {\n@@ -145,7 +145,7 @@ void AskPassphraseDialog::accept()\n         }\n         else\n         {\n-            QDialog::reject(); // Cancelled\n+            QDialog::reject(); /// Cancelled\n         }\n         } break;\n     case Unlock:\n@@ -156,7 +156,7 @@ void AskPassphraseDialog::accept()\n         }\n         else\n         {\n-            QDialog::accept(); // Success\n+            QDialog::accept(); /// Success\n         }\n         break;\n     case Decrypt:\n@@ -167,7 +167,7 @@ void AskPassphraseDialog::accept()\n         }\n         else\n         {\n-            QDialog::accept(); // Success\n+            QDialog::accept(); /// Success\n         }\n         break;\n     case ChangePass:\n@@ -177,7 +177,7 @@ void AskPassphraseDialog::accept()\n             {\n                 QMessageBox::information(this, tr(\"Wallet encrypted\"),\n                                      tr(\"Wallet passphrase was successfully changed.\"));\n-                QDialog::accept(); // Success\n+                QDialog::accept(); /// Success\n             }\n             else\n             {\n@@ -196,18 +196,18 @@ void AskPassphraseDialog::accept()\n \n void AskPassphraseDialog::textChanged()\n {\n-    // Validate input, set Ok button to enabled when acceptable\n+    /// Validate input, set Ok button to enabled when acceptable\n     bool acceptable = false;\n     switch(mode)\n     {\n-    case Encrypt: // New passphrase x2\n+    case Encrypt: /// New passphrase x2\n         acceptable = !ui->passEdit2->text().isEmpty() && !ui->passEdit3->text().isEmpty();\n         break;\n-    case Unlock: // Old passphrase x1\n+    case Unlock: /// Old passphrase x1\n     case Decrypt:\n         acceptable = !ui->passEdit1->text().isEmpty();\n         break;\n-    case ChangePass: // Old passphrase x1, new passphrase x2\n+    case ChangePass: /// Old passphrase x1, new passphrase x2\n         acceptable = !ui->passEdit1->text().isEmpty() && !ui->passEdit2->text().isEmpty() && !ui->passEdit3->text().isEmpty();\n         break;\n     }\n@@ -216,7 +216,7 @@ void AskPassphraseDialog::textChanged()\n \n bool AskPassphraseDialog::event(QEvent *event)\n {\n-    // Detect Caps Lock key press.\n+    /// Detect Caps Lock key press.\n     if (event->type() == QEvent::KeyPress) {\n         QKeyEvent *ke = static_cast<QKeyEvent *>(event);\n         if (ke->key() == Qt::Key_CapsLock) {\n@@ -233,7 +233,8 @@ bool AskPassphraseDialog::event(QEvent *event)\n \n bool AskPassphraseDialog::eventFilter(QObject *object, QEvent *event)\n {\n-    /* Detect Caps Lock.\n+    /**\n+     * Detect Caps Lock.\n      * There is no good OS-independent way to check a key state in Qt, but we\n      * can detect Caps Lock by checking for the following condition:\n      * Shift key is down and the result is a lower case character, or"
      },
      {
        "sha": "71777603771241e4c9217681aad725267d843cf4",
        "filename": "src/test/accounting_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e/src/test/accounting_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e/src/test/accounting_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/accounting_tests.cpp?ref=1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e",
        "patch": "@@ -1,6 +1,6 @@\n-// Copyright (c) 2012-2014 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+/// Copyright (c) 2012-2014 The Bitcoin Core developers\n+/// Distributed under the MIT software license, see the accompanying\n+/// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"wallet/wallet.h\"\n #include \"wallet/walletdb.h\"\n@@ -87,7 +87,7 @@ BOOST_AUTO_TEST_CASE(acc_orderupgrade)\n     wtx.mapValue[\"comment\"] = \"y\";\n     {\n         CMutableTransaction tx(wtx);\n-        --tx.nLockTime;  // Just to change the hash :)\n+        --tx.nLockTime;  /// Just to change the hash :)\n         *static_cast<CTransaction*>(&wtx) = CTransaction(tx);\n     }\n     pwalletMain->AddToWallet(wtx, false, &walletdb);\n@@ -97,7 +97,7 @@ BOOST_AUTO_TEST_CASE(acc_orderupgrade)\n     wtx.mapValue[\"comment\"] = \"x\";\n     {\n         CMutableTransaction tx(wtx);\n-        --tx.nLockTime;  // Just to change the hash :)\n+        --tx.nLockTime;  /// Just to change the hash :)\n         *static_cast<CTransaction*>(&wtx) = CTransaction(tx);\n     }\n     pwalletMain->AddToWallet(wtx, false, &walletdb);"
      },
      {
        "sha": "f9787eae24f275f888c38fceb15431570a2b2ac2",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 24,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e",
        "patch": "@@ -1,6 +1,6 @@\n-// Copyright (c) 2012-2013 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+/// Copyright (c) 2012-2013 The Bitcoin Core developers\n+/// Distributed under the MIT software license, see the accompanying\n+/// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n #include \"addrman.h\"\n #include \"test/test_bitcoin.h\"\n #include <string>\n@@ -18,37 +18,37 @@ BOOST_AUTO_TEST_CASE(addrman_simple)\n {\n     CAddrManTest addrman;\n \n-    // Set addrman addr placement to be deterministic.\n+    /// Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n     CNetAddr source = CNetAddr(\"252.2.2.2:8333\");\n \n-    // Test 1: Does Addrman respond correctly when empty.\n+    /// Test 1: Does Addrman respond correctly when empty.\n     BOOST_CHECK(addrman.size() == 0);\n     CAddrInfo addr_null = addrman.Select();\n     BOOST_CHECK(addr_null.ToString() == \"[::]:0\");\n \n-    // Test 2: Does Addrman::Add work as expected.\n+    /// Test 2: Does Addrman::Add work as expected.\n     CService addr1 = CService(\"250.1.1.1:8333\");\n     addrman.Add(CAddress(addr1), source);\n     BOOST_CHECK(addrman.size() == 1);\n     CAddrInfo addr_ret1 = addrman.Select();\n     BOOST_CHECK(addr_ret1.ToString() == \"250.1.1.1:8333\");\n \n-    // Test 3: Does IP address deduplication work correctly. \n-    //  Expected dup IP should not be added.\n+    /// Test 3: Does IP address deduplication work correctly. \n+    /// Expected dup IP should not be added.\n     CService addr1_dup = CService(\"250.1.1.1:8333\");\n     addrman.Add(CAddress(addr1_dup), source);\n     BOOST_CHECK(addrman.size() == 1);\n \n \n-    // Test 5: New table has one addr and we add a diff addr we should\n-    //  have two addrs.\n+    /// Test 5: New table has one addr and we add a diff addr we should\n+    /// have two addrs.\n     CService addr2 = CService(\"250.1.1.2:8333\");\n     addrman.Add(CAddress(addr2), source);\n     BOOST_CHECK(addrman.size() == 2);\n \n-    // Test 6: AddrMan::Clear() should empty the new table. \n+    /// Test 6: AddrMan::Clear() should empty the new table. \n     addrman.Clear();\n     BOOST_CHECK(addrman.size() == 0);\n     CAddrInfo addr_null2 = addrman.Select();\n@@ -59,14 +59,14 @@ BOOST_AUTO_TEST_CASE(addrman_ports)\n {\n     CAddrManTest addrman;\n \n-    // Set addrman addr placement to be deterministic.\n+    /// Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n     CNetAddr source = CNetAddr(\"252.2.2.2:8333\");\n \n     BOOST_CHECK(addrman.size() == 0);\n \n-    // Test 7; Addr with same IP but diff port does not replace existing addr.\n+    /// Test 7; Addr with same IP but diff port does not replace existing addr.\n     CService addr1 = CService(\"250.1.1.1:8333\");\n     addrman.Add(CAddress(addr1), source);\n     BOOST_CHECK(addrman.size() == 1);\n@@ -77,8 +77,8 @@ BOOST_AUTO_TEST_CASE(addrman_ports)\n     CAddrInfo addr_ret2 = addrman.Select();\n     BOOST_CHECK(addr_ret2.ToString() == \"250.1.1.1:8333\");\n \n-    // Test 8: Add same IP but diff port to tried table, it doesn't get added.\n-    //  Perhaps this is not ideal behavior but it is the current behavior.\n+    /// Test 8: Add same IP but diff port to tried table, it doesn't get added.\n+    /// Perhaps this is not ideal behavior but it is the current behavior.\n     addrman.Good(CAddress(addr1_port));\n     BOOST_CHECK(addrman.size() == 1);\n     bool newOnly = true;\n@@ -91,12 +91,12 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n {\n     CAddrManTest addrman;\n \n-    // Set addrman addr placement to be deterministic.\n+    /// Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n     CNetAddr source = CNetAddr(\"252.2.2.2:8333\");\n \n-    // Test 9: Select from new with 1 addr in new.\n+    /// Test 9: Select from new with 1 addr in new.\n     CService addr1 = CService(\"250.1.1.1:8333\");\n     addrman.Add(CAddress(addr1), source);\n     BOOST_CHECK(addrman.size() == 1);\n@@ -106,7 +106,7 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addr_ret1.ToString() == \"250.1.1.1:8333\");\n \n \n-    // Test 10: move addr to tried, select from new expected nothing returned.\n+    /// Test 10: move addr to tried, select from new expected nothing returned.\n     addrman.Good(CAddress(addr1));\n     BOOST_CHECK(addrman.size() == 1);\n     CAddrInfo addr_ret2 = addrman.Select(newOnly);\n@@ -120,7 +120,7 @@ BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n {\n     CAddrManTest addrman;\n \n-    // Set addrman addr placement to be deterministic.\n+    /// Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n     CNetAddr source = CNetAddr(\"252.2.2.2:8333\");\n@@ -131,11 +131,11 @@ BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n         CService addr = CService(\"250.1.1.\"+boost::to_string(i));\n         addrman.Add(CAddress(addr), source);\n \n-        //Test 11: No collision in new table yet.\n+        ///Test 11: No collision in new table yet.\n         BOOST_CHECK(addrman.size() == i);\n     }\n \n-    //Test 12: new table collision!\n+    /// Test 12: new table collision!\n     CService addr1 = CService(\"250.1.1.4\");\n     addrman.Add(CAddress(addr1), source);\n     BOOST_CHECK(addrman.size() == 3);\n@@ -149,7 +149,7 @@ BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n {\n     CAddrManTest addrman;\n \n-    // Set addrman addr placement to be deterministic.\n+    /// Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n     CNetAddr source = CNetAddr(\"252.2.2.2:8333\");\n@@ -166,7 +166,7 @@ BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n         BOOST_CHECK(addrman.size() == i);\n     }\n \n-    //Test 14: tried table collision!\n+    /// Test 14: tried table collision!\n     CService addr1 = CService(\"250.1.1.76\");\n     addrman.Add(CAddress(addr1), source);\n     BOOST_CHECK(addrman.size() == 74);\n@@ -176,5 +176,4 @@ BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n     BOOST_CHECK(addrman.size() == 75);\n }\n \n-\n BOOST_AUTO_TEST_SUITE_END()\n\\ No newline at end of file"
      },
      {
        "sha": "a87d7e3c60a819cda207c4559a18b9860371e1a5",
        "filename": "src/test/alert_tests.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 27,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e/src/test/alert_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e/src/test/alert_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/alert_tests.cpp?ref=1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e",
        "patch": "@@ -1,8 +1,8 @@\n-// Copyright (c) 2013 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+/// Copyright (c) 2013 The Bitcoin Core developers\n+/// Distributed under the MIT software license, see the accompanying\n+/// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-// Unit tests for alert system\n+/// Unit tests for alert system\n \n #include \"alert.h\"\n #include \"chain.h\"\n@@ -24,17 +24,17 @@\n #include <boost/test/unit_test.hpp>\n \n #if 0\n-//\n-// alertTests contains 7 alerts, generated with this code:\n-// (SignAndSave code not shown, alert signing key is secret)\n-//\n+///\n+/// alertTests contains 7 alerts, generated with this code:\n+/// (SignAndSave code not shown, alert signing key is secret)\n+///\n {\n     CAlert alert;\n     alert.nRelayUntil   = 60;\n     alert.nExpiration   = 24 * 60 * 60;\n     alert.nID           = 1;\n-    alert.nCancel       = 0;   // cancels previous messages up to this ID number\n-    alert.nMinVer       = 0;  // These versions are protocol versions\n+    alert.nCancel       = 0; /// cancels previous messages up to this ID number\n+    alert.nMinVer       = 0; /// These versions are protocol versions\n     alert.nMaxVer       = 999001;\n     alert.nPriority     = 1;\n     alert.strComment    = \"Alert comment\";\n@@ -128,7 +128,7 @@ BOOST_AUTO_TEST_CASE(AlertApplies)\n \n     BOOST_CHECK(alerts.size() >= 3);\n \n-    // Matches:\n+    /// Matches:\n     BOOST_CHECK(alerts[0].AppliesTo(1, \"\"));\n     BOOST_CHECK(alerts[0].AppliesTo(999001, \"\"));\n     BOOST_CHECK(alerts[0].AppliesTo(1, \"/Satoshi:11.11.11/\"));\n@@ -139,7 +139,7 @@ BOOST_AUTO_TEST_CASE(AlertApplies)\n     BOOST_CHECK(alerts[2].AppliesTo(1, \"/Satoshi:0.1.0/\"));\n     BOOST_CHECK(alerts[2].AppliesTo(1, \"/Satoshi:0.2.0/\"));\n \n-    // Don't match:\n+    /// Don't match:\n     BOOST_CHECK(!alerts[0].AppliesTo(-1, \"\"));\n     BOOST_CHECK(!alerts[0].AppliesTo(999002, \"\"));\n \n@@ -173,8 +173,8 @@ BOOST_AUTO_TEST_CASE(AlertNotify)\n     std::vector<std::string> r = read_lines(temp);\n     BOOST_CHECK_EQUAL(r.size(), 4u);\n \n-// Windows built-in echo semantics are different than posixy shells. Quotes and\n-// whitespace are printed literally.\n+/// Windows built-in echo semantics are different than posixy shells. Quotes and\n+/// whitespace are printed literally.\n \n #ifndef WIN32\n     BOOST_CHECK_EQUAL(r[0], \"Alert 1\");\n@@ -196,14 +196,14 @@ static bool falseFunc() { return false; }\n \n BOOST_AUTO_TEST_CASE(PartitionAlert)\n {\n-    // Test PartitionCheck\n+    /// Test PartitionCheck\n     CCriticalSection csDummy;\n     CBlockIndex indexDummy[100];\n     CChainParams& params = Params(CBaseChainParams::MAIN);\n     int64_t nPowTargetSpacing = params.GetConsensus().nPowTargetSpacing;\n \n-    // Generate fake blockchain timestamps relative to\n-    // an arbitrary time:\n+    /// Generate fake blockchain timestamps relative to\n+    /// an arbitrary time:\n     int64_t now = 1427379054;\n     SetMockTime(now);\n     for (int i = 0; i < 100; i++)\n@@ -213,37 +213,37 @@ BOOST_AUTO_TEST_CASE(PartitionAlert)\n         else indexDummy[i].pprev = &indexDummy[i-1];\n         indexDummy[i].nHeight = i;\n         indexDummy[i].nTime = now - (100-i)*nPowTargetSpacing;\n-        // Other members don't matter, the partition check code doesn't\n-        // use them\n+        /// Other members don't matter, the partition check code doesn't\n+        /// use them\n     }\n \n     strMiscWarning = \"\";\n \n-    // Test 1: chain with blocks every nPowTargetSpacing seconds,\n-    // as normal, no worries:\n+    /// Test 1: chain with blocks every nPowTargetSpacing seconds,\n+    /// as normal, no worries:\n     PartitionCheck(falseFunc, csDummy, &indexDummy[99], nPowTargetSpacing);\n     BOOST_CHECK_MESSAGE(strMiscWarning.empty(), strMiscWarning);\n \n-    // Test 2: go 3.5 hours without a block, expect a warning:\n+    /// Test 2: go 3.5 hours without a block, expect a warning:\n     now += 3*60*60+30*60;\n     SetMockTime(now);\n     PartitionCheck(falseFunc, csDummy, &indexDummy[99], nPowTargetSpacing);\n     BOOST_CHECK(!strMiscWarning.empty());\n     BOOST_TEST_MESSAGE(std::string(\"Got alert text: \")+strMiscWarning);\n     strMiscWarning = \"\";\n \n-    // Test 3: test the \"partition alerts only go off once per day\"\n-    // code:\n+    /// Test 3: test the \"partition alerts only go off once per day\"\n+    /// code:\n     now += 60*10;\n     SetMockTime(now);\n     PartitionCheck(falseFunc, csDummy, &indexDummy[99], nPowTargetSpacing);\n     BOOST_CHECK(strMiscWarning.empty());\n \n-    // Test 4: get 2.5 times as many blocks as expected:\n-    now += 60*60*24; // Pretend it is a day later\n+    /// Test 4: get 2.5 times as many blocks as expected:\n+    now += 60*60*24; /// Pretend it is a day later\n     SetMockTime(now);\n     int64_t quickSpacing = nPowTargetSpacing*2/5;\n-    for (int i = 0; i < 100; i++) // Tweak chain timestamps:\n+    for (int i = 0; i < 100; i++) /// Tweak chain timestamps:\n         indexDummy[i].nTime = now - (100-i)*quickSpacing;\n     PartitionCheck(falseFunc, csDummy, &indexDummy[99], nPowTargetSpacing);\n     BOOST_CHECK(!strMiscWarning.empty());"
      },
      {
        "sha": "4684fd6f6e0d806f56e088c66bb544dd2faa36d0",
        "filename": "src/test/allocator_tests.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 18,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e/src/test/allocator_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e/src/test/allocator_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/allocator_tests.cpp?ref=1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e",
        "patch": "@@ -1,6 +1,6 @@\n-// Copyright (c) 2012-2013 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+/// Copyright (c) 2012-2013 The Bitcoin Core developers\n+/// Distributed under the MIT software license, see the accompanying\n+/// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"util.h\"\n \n@@ -11,7 +11,7 @@\n \n BOOST_FIXTURE_TEST_SUITE(allocator_tests, BasicTestingSetup)\n \n-// Dummy memory page locker for platform independent tests\n+/// Dummy memory page locker for platform independent tests\n static const void *last_lock_addr, *last_unlock_addr;\n static size_t last_lock_len, last_unlock_len;\n class TestLocker\n@@ -39,42 +39,44 @@ BOOST_AUTO_TEST_CASE(test_LockedPageManagerBase)\n     last_lock_addr = last_unlock_addr = 0;\n     last_lock_len = last_unlock_len = 0;\n \n-    /* Try large number of small objects */\n+    /// Try large number of small objects\n     addr = 0;\n     for(int i=0; i<1000; ++i)\n     {\n         lpm.LockRange(reinterpret_cast<void*>(addr), 33);\n         addr += 33;\n     }\n-    /* Try small number of page-sized objects, straddling two pages */\n+    \n+    /// Try small number of page-sized objects, straddling two pages\n     addr = test_page_size*100 + 53;\n     for(int i=0; i<100; ++i)\n     {\n         lpm.LockRange(reinterpret_cast<void*>(addr), test_page_size);\n         addr += test_page_size;\n     }\n-    /* Try small number of page-sized objects aligned to exactly one page */\n+    \n+    /// Try small number of page-sized objects aligned to exactly one page\n     addr = test_page_size*300;\n     for(int i=0; i<100; ++i)\n     {\n         lpm.LockRange(reinterpret_cast<void*>(addr), test_page_size);\n         addr += test_page_size;\n     }\n-    /* one very large object, straddling pages */\n+    /// one very large object, straddling pages\n     lpm.LockRange(reinterpret_cast<void*>(test_page_size*600+1), test_page_size*500);\n     BOOST_CHECK(last_lock_addr == reinterpret_cast<void*>(test_page_size*(600+500)));\n-    /* one very large object, page aligned */\n+    /// one very large object, page aligned\n     lpm.LockRange(reinterpret_cast<void*>(test_page_size*1200), test_page_size*500-1);\n     BOOST_CHECK(last_lock_addr == reinterpret_cast<void*>(test_page_size*(1200+500-1)));\n \n     BOOST_CHECK(lpm.GetLockedPageCount() == (\n-        (1000*33+test_page_size-1)/test_page_size + // small objects\n-        101 + 100 +  // page-sized objects\n-        501 + 500)); // large objects\n-    BOOST_CHECK((last_lock_len & (test_page_size-1)) == 0); // always lock entire pages\n-    BOOST_CHECK(last_unlock_len == 0); // nothing unlocked yet\n+        (1000*33+test_page_size-1)/test_page_size + /// small objects\n+        101 + 100 +  /// page-sized objects\n+        501 + 500)); /// large objects\n+    BOOST_CHECK((last_lock_len & (test_page_size-1)) == 0); /// always lock entire pages\n+    BOOST_CHECK(last_unlock_len == 0); /// nothing unlocked yet\n \n-    /* And unlock again */\n+    /// And unlock again\n     addr = 0;\n     for(int i=0; i<1000; ++i)\n     {\n@@ -96,10 +98,10 @@ BOOST_AUTO_TEST_CASE(test_LockedPageManagerBase)\n     lpm.UnlockRange(reinterpret_cast<void*>(test_page_size*600+1), test_page_size*500);\n     lpm.UnlockRange(reinterpret_cast<void*>(test_page_size*1200), test_page_size*500-1);\n \n-    /* Check that everything is released */\n+    /// Check that everything is released\n     BOOST_CHECK(lpm.GetLockedPageCount() == 0);\n \n-    /* A few and unlocks of size zero (should have no effect) */\n+    /// A few and unlocks of size zero (should have no effect)\n     addr = 0;\n     for(int i=0; i<1000; ++i)\n     {\n@@ -114,7 +116,7 @@ BOOST_AUTO_TEST_CASE(test_LockedPageManagerBase)\n         addr += 1;\n     }\n     BOOST_CHECK(lpm.GetLockedPageCount() == 0);\n-    BOOST_CHECK((last_unlock_len & (test_page_size-1)) == 0); // always unlock entire pages\n+    BOOST_CHECK((last_unlock_len & (test_page_size-1)) == 0); /// always unlock entire pages\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "c09deb6a2be94445cc0a200ceb0b2b735354b0e6",
        "filename": "src/test/arith_uint256_tests.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 19,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e/src/test/arith_uint256_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e/src/test/arith_uint256_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/arith_uint256_tests.cpp?ref=1dfe4a0bbd1f9012d801f8e1f6c2d78411ca583e",
        "patch": "@@ -1,6 +1,6 @@\n-// Copyright (c) 2011-2013 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+/// Copyright (c) 2011-2013 The Bitcoin Core developers\n+/// Distributed under the MIT software license, see the accompanying\n+/// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <boost/test/unit_test.hpp>\n #include <stdint.h>\n@@ -64,18 +64,18 @@ std::string ArrayToString(const unsigned char A[], unsigned int width)\n     return Stream.str();\n }\n \n-BOOST_AUTO_TEST_CASE( basics ) // constructors, equality, inequality\n+BOOST_AUTO_TEST_CASE( basics ) /// constructors, equality, inequality\n {\n     BOOST_CHECK(1 == 0+1);\n-    // constructor arith_uint256(vector<char>):\n+    /// constructor arith_uint256(vector<char>):\n     BOOST_CHECK(R1L.ToString() == ArrayToString(R1Array,32));\n     BOOST_CHECK(R2L.ToString() == ArrayToString(R2Array,32));\n     BOOST_CHECK(ZeroL.ToString() == ArrayToString(ZeroArray,32));\n     BOOST_CHECK(OneL.ToString() == ArrayToString(OneArray,32));\n     BOOST_CHECK(MaxL.ToString() == ArrayToString(MaxArray,32));\n     BOOST_CHECK(OneL.ToString() != ArrayToString(ZeroArray,32));\n \n-    // == and !=\n+    /// == and !=\n     BOOST_CHECK(R1L != R2L);\n     BOOST_CHECK(ZeroL != OneL);\n     BOOST_CHECK(OneL != ZeroL);\n@@ -93,7 +93,7 @@ BOOST_AUTO_TEST_CASE( basics ) // constructors, equality, inequality\n     }\n     BOOST_CHECK(ZeroL == (OneL << 256));\n \n-    // String Constructor and Copy Constructor\n+    /// String Constructor and Copy Constructor\n     BOOST_CHECK(arith_uint256(\"0x\"+R1L.ToString()) == R1L);\n     BOOST_CHECK(arith_uint256(\"0x\"+R2L.ToString()) == R2L);\n     BOOST_CHECK(arith_uint256(\"0x\"+ZeroL.ToString()) == ZeroL);\n@@ -108,13 +108,13 @@ BOOST_AUTO_TEST_CASE( basics ) // constructors, equality, inequality\n     BOOST_CHECK(arith_uint256(ZeroL) == ZeroL);\n     BOOST_CHECK(arith_uint256(OneL) == OneL);\n \n-    // uint64_t constructor\n+    /// uint64_t constructor\n     BOOST_CHECK( (R1L & arith_uint256(\"0xffffffffffffffff\")) == arith_uint256(R1LLow64));\n     BOOST_CHECK(ZeroL == arith_uint256(0));\n     BOOST_CHECK(OneL == arith_uint256(1));\n     BOOST_CHECK(arith_uint256(\"0xffffffffffffffff\") = arith_uint256(0xffffffffffffffffULL));\n \n-    // Assignment (from base_uint)\n+    /// Assignment (from base_uint)\n     arith_uint256 tmpL = ~ZeroL; BOOST_CHECK(tmpL == ~ZeroL);\n     tmpL = ~OneL; BOOST_CHECK(tmpL == ~OneL);\n     tmpL = ~R1L; BOOST_CHECK(tmpL == ~R1L);\n@@ -153,7 +153,7 @@ void shiftArrayLeft(unsigned char* to, const unsigned char* from, unsigned int a\n     }\n }\n \n-BOOST_AUTO_TEST_CASE( shifts ) { // \"<<\"  \">>\"  \"<<=\"  \">>=\"\n+BOOST_AUTO_TEST_CASE( shifts ) { /// \"<<\"  \">>\"  \"<<=\"  \">>=\"\n     unsigned char TmpArray[32];\n     arith_uint256 TmpL;\n     for (unsigned int i = 0; i < 256; ++i)\n@@ -196,7 +196,7 @@ BOOST_AUTO_TEST_CASE( shifts ) { // \"<<\"  \">>\"  \"<<=\"  \">>=\"\n     }\n }\n \n-BOOST_AUTO_TEST_CASE( unaryOperators ) // !    ~    -\n+BOOST_AUTO_TEST_CASE( unaryOperators ) /// !    ~    -\n {\n     BOOST_CHECK(!ZeroL);\n     BOOST_CHECK(!(!OneL));\n@@ -218,8 +218,8 @@ BOOST_AUTO_TEST_CASE( unaryOperators ) // !    ~    -\n }\n \n \n-// Check if doing _A_ _OP_ _B_ results in the same as applying _OP_ onto each\n-// element of Aarray and Barray, and then converting the result into a arith_uint256.\n+/// Check if doing _A_ _OP_ _B_ results in the same as applying _OP_ onto each\n+/// element of Aarray and Barray, and then converting the result into a arith_uint256.\n #define CHECKBITWISEOPERATOR(_A_,_B_,_OP_)                              \\\n     for (unsigned int i = 0; i < 32; ++i) { TmpArray[i] = _A_##Array[i] _OP_ _B_##Array[i]; } \\\n     BOOST_CHECK(arith_uint256V(std::vector<unsigned char>(TmpArray,TmpArray+32)) == (_A_##L _OP_ _B_##L));\n@@ -271,7 +271,7 @@ BOOST_AUTO_TEST_CASE( bitwiseOperators )\n     TmpL ^= Tmp64;  BOOST_CHECK(TmpL == (R1L ^ arith_uint256(Tmp64)));\n }\n \n-BOOST_AUTO_TEST_CASE( comparison ) // <= >= < >\n+BOOST_AUTO_TEST_CASE( comparison ) /// <= >= < >\n {\n     arith_uint256 TmpL;\n     for (unsigned int i = 0; i < 256; ++i) {\n@@ -374,7 +374,7 @@ bool almostEqual(double d1, double d2)\n     return fabs(d1-d2) <= 4*fabs(d1)*std::numeric_limits<double>::epsilon();\n }\n \n-BOOST_AUTO_TEST_CASE( methods ) // GetHex SetHex size() GetLow64 GetSerializeSize, Serialize, Unserialize\n+BOOST_AUTO_TEST_CASE( methods ) /// GetHex SetHex size() GetLow64 GetSerializeSize, Serialize, Unserialize\n {\n     BOOST_CHECK(R1L.GetHex() == R1L.ToString());\n     BOOST_CHECK(R2L.GetHex() == R2L.ToString());\n@@ -403,7 +403,7 @@ BOOST_AUTO_TEST_CASE( methods ) // GetHex SetHex size() GetLow64 GetSerializeSiz\n     for (int i = 256; i > 53; --i)\n         BOOST_CHECK(almostEqual((R1L>>(256-i)).getdouble(), ldexp(R1Ldouble,i)));\n     uint64_t R1L64part = (R1L>>192).GetLow64();\n-    for (int i = 53; i > 0; --i) // doubles can store all integers in {0,...,2^54-1} exactly\n+    for (int i = 53; i > 0; --i) /// doubles can store all integers in {0,...,2^54-1} exactly\n     {\n         BOOST_CHECK((R1L>>(256-i)).getdouble() == (double)(R1L64part >> (64-i)));\n     }\n@@ -486,7 +486,7 @@ BOOST_AUTO_TEST_CASE(bignum_SetCompact)\n     BOOST_CHECK_EQUAL(fNegative, false);\n     BOOST_CHECK_EQUAL(fOverflow, false);\n \n-    // Make sure that we don't generate compacts with the 0x00800000 bit set\n+    /// Make sure that we don't generate compacts with the 0x00800000 bit set\n     num = 0x80;\n     BOOST_CHECK_EQUAL(num.GetCompact(), 0x02008000U);\n \n@@ -538,9 +538,9 @@ BOOST_AUTO_TEST_CASE(bignum_SetCompact)\n }\n \n \n-BOOST_AUTO_TEST_CASE( getmaxcoverage ) // some more tests just to get 100% coverage\n+BOOST_AUTO_TEST_CASE( getmaxcoverage ) /// some more tests just to get 100% coverage\n {\n-    // ~R1L give a base_uint<256>\n+    /// ~R1L give a base_uint<256>\n     BOOST_CHECK((~~R1L >> 10) == (R1L >> 10));\n     BOOST_CHECK((~~R1L << 10) == (R1L << 10));\n     BOOST_CHECK(!(~~R1L < R1L));"
      }
    ]
  }
]