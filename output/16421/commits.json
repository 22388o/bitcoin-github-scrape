[
  {
    "sha": "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1Y2U4MjJlZmJlNDU1MTNjZTM1MTdjMWNhNzMxYWM2ZDZhMGMzYjU0",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-07-11T19:54:17Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-09-04T19:53:14Z"
      },
      "message": "Conservatively accept RBF bumps bumping one tx at the package limits\n\nAccept RBF bumps of single transactions (ie which conflict with one\ntransaction) even when that transaction is a member of a package\nwhich is currently at the package limit iff the new transaction\ndoes not add any additional mempool dependencies from the original.\n\nThis could be made a bit looser in the future and still be safe,\nbut for now this fixes the case that a transaction which was\naccepted by the carve-out rule will not be directly RBF'able.",
      "tree": {
        "sha": "1086ceb0eb1b60e075f2d162f3a6be91acf87dc4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1086ceb0eb1b60e075f2d162f3a6be91acf87dc4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5ce822efbe45513ce3517c1ca731ac6d6a0c3b54/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "68da54987df4d4b76d0696b8139ae2bb32394214",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/68da54987df4d4b76d0696b8139ae2bb32394214",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/68da54987df4d4b76d0696b8139ae2bb32394214"
      }
    ],
    "stats": {
      "total": 54,
      "additions": 51,
      "deletions": 3
    },
    "files": [
      {
        "sha": "4eacb9e3d4bcf96b46d2ee2e9d39e47f23550b1b",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 43,
        "deletions": 1,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5ce822efbe45513ce3517c1ca731ac6d6a0c3b54/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5ce822efbe45513ce3517c1ca731ac6d6a0c3b54/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
        "patch": "@@ -609,17 +609,55 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n+        const CTxMemPool::setEntries setIterConflicting = pool.GetIterSet(setConflicts);\n         // Calculate in-mempool ancestors, up to a limit.\n         CTxMemPool::setEntries setAncestors;\n         size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n         size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n         size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n         size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+\n+        if (setConflicts.size() == 1) {\n+            // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n+            // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n+            // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n+            // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n+            // very realistic, thus we only ensure a limited set of transactions are RBF'able despite mempool\n+            // conflicts here. Importantly, we need to ensure that some transactions which were accepted using\n+            // the below carve-out are able to be RBF'ed, without impacting the security the carve-out provides\n+            // for off-chain contract systems (see link in the comment below).\n+            //\n+            // Specifically, the subset of RBF transactions which we allow despite chain limits are those which\n+            // conflict directly with exactly one other transaction (but may evict children of said transaction),\n+            // and which are not adding any new mempool dependencies. Note that the \"no new mempool dependencies\"\n+            // check is accomplished later, so we don't bother doing anything about it here, but if BIP 125 is\n+            // amended, we may need to move that check to here instead of removing it wholesale.\n+            //\n+            // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+            // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+            // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+            // to.\n+            //\n+            // To check these we first check if we meet the RBF criteria, above, and increment the descendant\n+            // limits by the direct conflict and its descendants (as these are recalculated in\n+            // CalculateMempoolAncestors by assuming the new transaction being added is a new descendant, with no\n+            // removals, of each parent's existing dependant set). The ancestor count limits are unmodified (as\n+            // the ancestor limits should be the same for both our new transaction and any conflicts).\n+            // We don't bother incrementing nLimitDescendants by the full removal count as that limit never comes\n+            // into force here (as we're only adding a single transaction).\n+            assert(setIterConflicting.size() == 1);\n+            CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+            nLimitDescendants += 1;\n+            nLimitDescendantSize += conflict->GetSizeWithDescendants();\n+        }\n+\n         std::string errString;\n         if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n+            // Contracting/payment channels CPFP carve-out:\n             // If the new transaction is relatively small (up to 40k weight)\n             // and has at most one ancestor (ie ancestor limit of 2, including\n             // the new transaction), allow it if its parent has exactly the\n@@ -668,7 +706,6 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             CFeeRate newFeeRate(nModifiedFees, nSize);\n             std::set<uint256> setConflictsParents;\n             const int maxDescendantsToVisit = 100;\n-            const CTxMemPool::setEntries setIterConflicting = pool.GetIterSet(setConflicts);\n             for (const auto& mi : setIterConflicting) {\n                 // Don't allow the replacement to reduce the feerate of the\n                 // mempool.\n@@ -728,6 +765,11 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 // feerate junk to be mined first. Ideally we'd keep track of\n                 // the ancestor feerates and make the decision based on that,\n                 // but for now requiring all new inputs to be confirmed works.\n+                //\n+                // Note that if you relax this to make RBF a little more useful,\n+                // this may break the CalculateMempoolAncestors RBF relaxation,\n+                // above. See the comment above the first CalculateMempoolAncestors\n+                // call for more info.\n                 if (!setConflictsParents.count(tx.vin[j].prevout.hash))\n                 {\n                     // Rather than check the UTXO set - potentially expensive -"
      },
      {
        "sha": "0739d7e29b373eb70ef99613413a296ae280b135",
        "filename": "test/functional/mempool_package_onemore.py",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5ce822efbe45513ce3517c1ca731ac6d6a0c3b54/test/functional/mempool_package_onemore.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5ce822efbe45513ce3517c1ca731ac6d6a0c3b54/test/functional/mempool_package_onemore.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_package_onemore.py?ref=5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
        "patch": "@@ -33,7 +33,7 @@ def chain_transaction(self, node, parent_txids, vouts, value, fee, num_outputs):\n         outputs = {}\n         for i in range(num_outputs):\n             outputs[node.getnewaddress()] = send_value\n-        rawtx = node.createrawtransaction(inputs, outputs)\n+        rawtx = node.createrawtransaction(inputs, outputs, 0, True)\n         signedtx = node.signrawtransactionwithwallet(rawtx)\n         txid = node.sendrawtransaction(signedtx['hex'])\n         fulltx = node.getrawtransaction(txid, 1)\n@@ -75,10 +75,16 @@ def run_test(self):\n         # ...especially if its > 40k weight\n         assert_raises_rpc_error(-26, \"too-long-mempool-chain, too many descendants\", self.chain_transaction, self.nodes[0], [chain[0][0]], [1], chain[0][1], fee, 350)\n         # But not if it chains directly off the first transaction\n-        self.chain_transaction(self.nodes[0], [chain[0][0]], [1], chain[0][1], fee, 1)\n+        (replacable_txid, replacable_orig_value) = self.chain_transaction(self.nodes[0], [chain[0][0]], [1], chain[0][1], fee, 1)\n         # and the second chain should work just fine\n         self.chain_transaction(self.nodes[0], [second_chain], [0], second_chain_value, fee, 1)\n \n+        # Make sure we can RBF the chain which used our carve-out rule\n+        second_tx_outputs = {self.nodes[0].getrawtransaction(replacable_txid, True)[\"vout\"][0]['scriptPubKey']['addresses'][0]: replacable_orig_value - (Decimal(1) / Decimal(100))}\n+        second_tx = self.nodes[0].createrawtransaction([{'txid': chain[0][0], 'vout': 1}], second_tx_outputs)\n+        signed_second_tx = self.nodes[0].signrawtransactionwithwallet(second_tx)\n+        self.nodes[0].sendrawtransaction(signed_second_tx['hex'])\n+\n         # Finally, check that we added two transactions\n         assert_equal(len(self.nodes[0].getrawmempool(True)), MAX_ANCESTORS + 3)\n "
      }
    ]
  }
]