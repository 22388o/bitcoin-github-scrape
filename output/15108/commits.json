[
  {
    "sha": "6be64ef02ca0832dfb74f74e5b026ead4cd7ef72",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2YmU2NGVmMDJjYTA4MzJkZmI3NGY3NGU1YjAyNmVhZDRjZDdlZjcy",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-12-13T17:32:50Z"
      },
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti.uttarwar@coinbase.com",
        "date": "2019-01-05T01:46:33Z"
      },
      "message": "[tests] tidy up wallet_importmulti.py\n\nFixes review comments from PR 14886.",
      "tree": {
        "sha": "24a1bdce58fc4646547a9acd31c896c717afee35",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/24a1bdce58fc4646547a9acd31c896c717afee35"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6be64ef02ca0832dfb74f74e5b026ead4cd7ef72",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6be64ef02ca0832dfb74f74e5b026ead4cd7ef72",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6be64ef02ca0832dfb74f74e5b026ead4cd7ef72",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6be64ef02ca0832dfb74f74e5b026ead4cd7ef72/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": null,
    "parents": [
      {
        "sha": "fe5a70b9fefa0548f497a749746f53f3d7fd0ebb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fe5a70b9fefa0548f497a749746f53f3d7fd0ebb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fe5a70b9fefa0548f497a749746f53f3d7fd0ebb"
      }
    ],
    "stats": {
      "total": 189,
      "additions": 85,
      "deletions": 104
    },
    "files": [
      {
        "sha": "4de459d99bd389761223d72717ae0114da3fce09",
        "filename": "test/functional/wallet_importmulti.py",
        "status": "modified",
        "additions": 85,
        "deletions": 104,
        "changes": 189,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6be64ef02ca0832dfb74f74e5b026ead4cd7ef72/test/functional/wallet_importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6be64ef02ca0832dfb74f74e5b026ead4cd7ef72/test/functional/wallet_importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importmulti.py?ref=6be64ef02ca0832dfb74f74e5b026ead4cd7ef72",
        "patch": "@@ -87,18 +87,18 @@ def get_key(self):\n         addr = self.nodes[0].getnewaddress()\n         pubkey = self.nodes[0].getaddressinfo(addr)['pubkey']\n         pkh = hash160(hex_str_to_bytes(pubkey))\n-        return Key(self.nodes[0].dumpprivkey(addr),\n-                   pubkey,\n-                   CScript([OP_DUP, OP_HASH160, pkh, OP_EQUALVERIFY, OP_CHECKSIG]).hex(),  # p2pkh\n-                   key_to_p2pkh(pubkey),  # p2pkh addr\n-                   CScript([OP_0, pkh]).hex(),  # p2wpkh\n-                   key_to_p2wpkh(pubkey),  # p2wpkh addr\n-                   CScript([OP_HASH160, hash160(CScript([OP_0, pkh])), OP_EQUAL]).hex(),  # p2sh-p2wpkh\n-                   CScript([OP_0, pkh]).hex(),  # p2sh-p2wpkh redeem script\n-                   key_to_p2sh_p2wpkh(pubkey))  # p2sh-p2wpkh addr\n+        return Key(privkey=self.nodes[0].dumpprivkey(addr),\n+                   pubkey=pubkey,\n+                   p2pkh_script=CScript([OP_DUP, OP_HASH160, pkh, OP_EQUALVERIFY, OP_CHECKSIG]).hex(),\n+                   p2pkh_addr=key_to_p2pkh(pubkey),\n+                   p2wpkh_script=CScript([OP_0, pkh]).hex(),\n+                   p2wpkh_addr=key_to_p2wpkh(pubkey),\n+                   p2sh_p2wpkh_script=CScript([OP_HASH160, hash160(CScript([OP_0, pkh])), OP_EQUAL]).hex(),\n+                   p2sh_p2wpkh_redeem_script=CScript([OP_0, pkh]).hex(),\n+                   p2sh_p2wpkh_addr=key_to_p2sh_p2wpkh(pubkey))\n \n     def get_multisig(self):\n-        \"\"\"Generate a fresh multisig on node0\n+        \"\"\"Generate a fresh 2-of-3 multisig on node0\n \n         Returns a named tuple of privkeys, pubkeys and all address and scripts.\"\"\"\n         addrs = []\n@@ -109,15 +109,15 @@ def get_multisig(self):\n             pubkeys.append(addr['pubkey'])\n         script_code = CScript([OP_2] + [hex_str_to_bytes(pubkey) for pubkey in pubkeys] + [OP_3, OP_CHECKMULTISIG])\n         witness_script = CScript([OP_0, sha256(script_code)])\n-        return Multisig([self.nodes[0].dumpprivkey(addr) for addr in addrs],\n-                        pubkeys,\n-                        CScript([OP_HASH160, hash160(script_code), OP_EQUAL]).hex(),  # p2sh\n-                        script_to_p2sh(script_code),  # p2sh addr\n-                        script_code.hex(),  # redeem script\n-                        witness_script.hex(),  # p2wsh\n-                        script_to_p2wsh(script_code),  # p2wsh addr\n-                        CScript([OP_HASH160, witness_script, OP_EQUAL]).hex(),  # p2sh-p2wsh\n-                        script_to_p2sh_p2wsh(script_code))  # p2sh-p2wsh addr\n+        return Multisig(privkeys=[self.nodes[0].dumpprivkey(addr) for addr in addrs],\n+                        pubkeys=pubkeys,\n+                        p2sh_script=CScript([OP_HASH160, hash160(script_code), OP_EQUAL]).hex(),\n+                        p2sh_addr=script_to_p2sh(script_code),\n+                        redeem_script=script_code.hex(),\n+                        p2wsh_script=witness_script.hex(),\n+                        p2wsh_addr=script_to_p2wsh(script_code),\n+                        p2sh_p2wsh_script=CScript([OP_HASH160, witness_script, OP_EQUAL]).hex(),\n+                        p2sh_p2wsh_addr=script_to_p2sh_p2wsh(script_code))\n \n     def test_importmulti(self, req, success, error_code=None, error_message=None, warnings=[]):\n         \"\"\"Run importmulti and assert success\"\"\"\n@@ -165,22 +165,21 @@ def run_test(self):\n         # Bitcoin Address (implicit non-internal)\n         self.log.info(\"Should import an address\")\n         key = self.get_key()\n-        address = key.p2pkh_addr\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\"},\n-                              True)\n-        self.test_address(address,\n+                              success=True)\n+        self.test_address(key.p2pkh_addr,\n                           iswatchonly=True,\n                           ismine=False,\n                           timestamp=timestamp,\n                           ischange=False)\n-        watchonly_address = address\n+        watchonly_address = key.p2pkh_addr\n         watchonly_timestamp = timestamp\n \n         self.log.info(\"Should not import an invalid address\")\n         self.test_importmulti({\"scriptPubKey\": {\"address\": \"not valid address\"},\n                                \"timestamp\": \"now\"},\n-                              False,\n+                              success=False,\n                               error_code=-5,\n                               error_message='Invalid address \\\"not valid address\\\"')\n \n@@ -190,7 +189,7 @@ def run_test(self):\n         self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n                                \"timestamp\": \"now\",\n                                \"internal\": True},\n-                              True)\n+                              success=True)\n         self.test_address(key.p2pkh_addr,\n                           iswatchonly=True,\n                           ismine=False,\n@@ -204,131 +203,123 @@ def run_test(self):\n                                \"timestamp\": \"now\",\n                                \"internal\": True,\n                                \"label\": \"Example label\"},\n-                              False,\n+                              success=False,\n                               error_code=-8,\n                               error_message='Internal addresses should not have a label')\n \n         # Nonstandard scriptPubKey + !internal\n         self.log.info(\"Should not import a nonstandard scriptPubKey without internal flag\")\n         nonstandardScriptPubKey = key.p2pkh_script + bytes_to_hex_str(CScript([OP_NOP]))\n         key = self.get_key()\n-        address = key.p2pkh_addr\n         self.test_importmulti({\"scriptPubKey\": nonstandardScriptPubKey,\n                                \"timestamp\": \"now\"},\n-                              False,\n+                              success=False,\n                               error_code=-8,\n                               error_message='Internal must be set to true for nonstandard scriptPubKey imports.')\n-        self.test_address(address,\n+        self.test_address(key.p2pkh_addr,\n                           iswatchonly=False,\n                           ismine=False,\n                           timestamp=None)\n \n         # Address + Public key + !Internal(explicit)\n         self.log.info(\"Should import an address with public key\")\n         key = self.get_key()\n-        address = key.p2pkh_addr\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [key.pubkey],\n                                \"internal\": False},\n-                              True,\n+                              success=True,\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(address,\n+        self.test_address(key.p2pkh_addr,\n                           iswatchonly=True,\n                           ismine=False,\n                           timestamp=timestamp)\n \n         # ScriptPubKey + Public key + internal\n         self.log.info(\"Should import a scriptPubKey with internal and with public key\")\n         key = self.get_key()\n-        address = key.p2pkh_addr\n         self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [key.pubkey],\n                                \"internal\": True},\n-                              True,\n+                              success=True,\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(address,\n+        self.test_address(key.p2pkh_addr,\n                           iswatchonly=True,\n                           ismine=False,\n                           timestamp=timestamp)\n \n         # Nonstandard scriptPubKey + Public key + !internal\n         self.log.info(\"Should not import a nonstandard scriptPubKey without internal and with public key\")\n         key = self.get_key()\n-        address = key.p2pkh_addr\n         self.test_importmulti({\"scriptPubKey\": nonstandardScriptPubKey,\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [key.pubkey]},\n-                              False,\n+                              success=False,\n                               error_code=-8,\n                               error_message='Internal must be set to true for nonstandard scriptPubKey imports.')\n-        self.test_address(address,\n+        self.test_address(key.p2pkh_addr,\n                           iswatchonly=False,\n                           ismine=False,\n                           timestamp=None)\n \n         # Address + Private key + !watchonly\n         self.log.info(\"Should import an address with private key\")\n         key = self.get_key()\n-        address = key.p2pkh_addr\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\",\n                                \"keys\": [key.privkey]},\n-                              True)\n-        self.test_address(address,\n+                              success=True)\n+        self.test_address(key.p2pkh_addr,\n                           iswatchonly=False,\n                           ismine=True,\n                           timestamp=timestamp)\n \n         self.log.info(\"Should not import an address with private key if is already imported\")\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\",\n                                \"keys\": [key.privkey]},\n-                              False,\n+                              success=False,\n                               error_code=-4,\n                               error_message='The wallet already contains the private key for this address or script')\n \n         # Address + Private key + watchonly\n         self.log.info(\"Should import an address with private key and with watchonly\")\n         key = self.get_key()\n-        address = key.p2pkh_addr\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\",\n                                \"keys\": [key.privkey],\n                                \"watchonly\": True},\n-                              True,\n+                              success=True,\n                               warnings=[\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\"])\n-        self.test_address(address,\n+        self.test_address(key.p2pkh_addr,\n                           iswatchonly=False,\n                           ismine=True,\n                           timestamp=timestamp)\n \n         # ScriptPubKey + Private key + internal\n         self.log.info(\"Should import a scriptPubKey with internal and with private key\")\n         key = self.get_key()\n-        address = key.p2pkh_addr\n         self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n                                \"timestamp\": \"now\",\n                                \"keys\": [key.privkey],\n                                \"internal\": True},\n-                              True)\n-        self.test_address(address,\n+                              success=True)\n+        self.test_address(key.p2pkh_addr,\n                           iswatchonly=False,\n                           ismine=True,\n                           timestamp=timestamp)\n \n         # Nonstandard scriptPubKey + Private key + !internal\n         self.log.info(\"Should not import a nonstandard scriptPubKey without internal and with private key\")\n         key = self.get_key()\n-        address = key.p2pkh_addr\n         self.test_importmulti({\"scriptPubKey\": nonstandardScriptPubKey,\n                                \"timestamp\": \"now\",\n                                \"keys\": [key.privkey]},\n-                              False,\n+                              success=False,\n                               error_code=-8,\n                               error_message='Internal must be set to true for nonstandard scriptPubKey imports.')\n-        self.test_address(address,\n+        self.test_address(key.p2pkh_addr,\n                           iswatchonly=False,\n                           ismine=False,\n                           timestamp=None)\n@@ -343,7 +334,7 @@ def run_test(self):\n         self.log.info(\"Should import a p2sh\")\n         self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2sh_addr},\n                                \"timestamp\": \"now\"},\n-                              True)\n+                              success=True)\n         self.test_address(multisig.p2sh_addr,\n                           isscript=True,\n                           iswatchonly=True,\n@@ -363,7 +354,7 @@ def run_test(self):\n         self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2sh_addr},\n                                \"timestamp\": \"now\",\n                                \"redeemscript\": multisig.redeem_script},\n-                              True,\n+                              success=True,\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n         self.test_address(multisig.p2sh_addr, timestamp=timestamp, iswatchonly=True, ismine=False, solvable=True)\n \n@@ -383,7 +374,7 @@ def run_test(self):\n                                \"timestamp\": \"now\",\n                                \"redeemscript\": multisig.redeem_script,\n                                \"keys\": multisig.privkeys[0:2]},\n-                              True,\n+                              success=True,\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n         self.test_address(multisig.p2sh_addr,\n                           timestamp=timestamp,\n@@ -408,7 +399,7 @@ def run_test(self):\n                                \"redeemscript\": multisig.redeem_script,\n                                \"keys\": multisig.privkeys[0:2],\n                                \"watchonly\": True},\n-                              True)\n+                              success=True)\n         self.test_address(multisig.p2sh_addr,\n                           iswatchonly=True,\n                           ismine=False,\n@@ -418,14 +409,13 @@ def run_test(self):\n         # Address + Public key + !Internal + Wrong pubkey\n         self.log.info(\"Should not import an address with the wrong public key as non-solvable\")\n         key = self.get_key()\n-        address = key.p2pkh_addr\n         wrong_key = self.get_key().pubkey\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [wrong_key]},\n-                              True,\n+                              success=True,\n                               warnings=[\"Importing as non-solvable: some required keys are missing. If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(address,\n+        self.test_address(key.p2pkh_addr,\n                           iswatchonly=True,\n                           ismine=False,\n                           solvable=False,\n@@ -434,15 +424,14 @@ def run_test(self):\n         # ScriptPubKey + Public key + internal + Wrong pubkey\n         self.log.info(\"Should import a scriptPubKey with internal and with a wrong public key as non-solvable\")\n         key = self.get_key()\n-        address = key.p2pkh_addr\n         wrong_key = self.get_key().pubkey\n         self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [wrong_key],\n                                \"internal\": True},\n-                              True,\n+                              success=True,\n                               warnings=[\"Importing as non-solvable: some required keys are missing. If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(address,\n+        self.test_address(key.p2pkh_addr,\n                           iswatchonly=True,\n                           ismine=False,\n                           solvable=False,\n@@ -451,14 +440,13 @@ def run_test(self):\n         # Address + Private key + !watchonly + Wrong private key\n         self.log.info(\"Should import an address with a wrong private key as non-solvable\")\n         key = self.get_key()\n-        address = key.p2pkh_addr\n         wrong_privkey = self.get_key().privkey\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\",\n                                \"keys\": [wrong_privkey]},\n-                               True,\n+                               success=True,\n                                warnings=[\"Importing as non-solvable: some required keys are missing. If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(address,\n+        self.test_address(key.p2pkh_addr,\n                           iswatchonly=True,\n                           ismine=False,\n                           solvable=False,\n@@ -467,15 +455,14 @@ def run_test(self):\n         # ScriptPubKey + Private key + internal + Wrong private key\n         self.log.info(\"Should import a scriptPubKey with internal and with a wrong private key as non-solvable\")\n         key = self.get_key()\n-        address = key.p2pkh_addr\n         wrong_privkey = self.get_key().privkey\n         self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n                                \"timestamp\": \"now\",\n                                \"keys\": [wrong_privkey],\n                                \"internal\": True},\n-                              True,\n+                              success=True,\n                               warnings=[\"Importing as non-solvable: some required keys are missing. If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(address,\n+        self.test_address(key.p2pkh_addr,\n                           iswatchonly=True,\n                           ismine=False,\n                           solvable=False,\n@@ -486,7 +473,7 @@ def run_test(self):\n         self.log.info(\"Should replace previously saved watch only timestamp.\")\n         self.test_importmulti({\"scriptPubKey\": {\"address\": watchonly_address},\n                                \"timestamp\": \"now\"},\n-                              True)\n+                              success=True)\n         self.test_address(watchonly_address,\n                           iswatchonly=True,\n                           ismine=False,\n@@ -514,36 +501,33 @@ def run_test(self):\n         # Import P2WPKH address as watch only\n         self.log.info(\"Should import a P2WPKH address as watch only\")\n         key = self.get_key()\n-        address = key.p2wpkh_addr\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2wpkh_addr},\n                                \"timestamp\": \"now\"},\n-                              True)\n-        self.test_address(address,\n+                              success=True)\n+        self.test_address(key.p2wpkh_addr,\n                           iswatchonly=True,\n                           solvable=False)\n \n         # Import P2WPKH address with public key but no private key\n         self.log.info(\"Should import a P2WPKH address and public key as solvable but not spendable\")\n         key = self.get_key()\n-        address = key.p2wpkh_addr\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2wpkh_addr},\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [key.pubkey]},\n-                              True,\n+                              success=True,\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(address,\n+        self.test_address(key.p2wpkh_addr,\n                           ismine=False,\n                           solvable=True)\n \n         # Import P2WPKH address with key and check it is spendable\n         self.log.info(\"Should import a P2WPKH address with key\")\n         key = self.get_key()\n-        address = key.p2wpkh_addr\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2wpkh_addr},\n                                \"timestamp\": \"now\",\n                                \"keys\": [key.privkey]},\n-                              True)\n-        self.test_address(address,\n+                              success=True)\n+        self.test_address(key.p2wpkh_addr,\n                           iswatchonly=False,\n                           ismine=True)\n \n@@ -552,7 +536,7 @@ def run_test(self):\n         self.log.info(\"Should import a p2wsh multisig as watch only without respective redeem script and private keys\")\n         self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2wsh_addr},\n                                \"timestamp\": \"now\"},\n-                              True)\n+                              success=True)\n         self.test_address(multisig.p2sh_addr,\n                           solvable=False)\n \n@@ -562,59 +546,56 @@ def run_test(self):\n                                \"timestamp\": \"now\",\n                                \"witnessscript\": multisig.redeem_script,\n                                \"keys\": multisig.privkeys},\n-                              True)\n+                              success=True)\n         self.test_address(multisig.p2sh_addr,\n                           solvable=True,\n                           ismine=True,\n                           sigsrequired=2)\n \n         # P2SH-P2WPKH address with no redeemscript or public or private key\n         key = self.get_key()\n-        address = key.p2sh_p2wpkh_addr\n         self.log.info(\"Should import a p2sh-p2wpkh without redeem script or keys\")\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2sh_p2wpkh_addr},\n                                \"timestamp\": \"now\"},\n-                              True)\n-        self.test_address(address,\n+                              success=True)\n+        self.test_address(key.p2sh_p2wpkh_addr,\n                           solvable=False,\n                           ismine=False)\n \n         # P2SH-P2WPKH address + redeemscript + public key with no private key\n         self.log.info(\"Should import a p2sh-p2wpkh with respective redeem script and pubkey as solvable\")\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2sh_p2wpkh_addr},\n                                \"timestamp\": \"now\",\n                                \"redeemscript\": key.p2sh_p2wpkh_redeem_script,\n                                \"pubkeys\": [key.pubkey]},\n-                              True,\n+                              success=True,\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(address,\n+        self.test_address(key.p2sh_p2wpkh_addr,\n                           solvable=True,\n                           ismine=False)\n \n         # P2SH-P2WPKH address + redeemscript + private key\n         key = self.get_key()\n-        address = key.p2sh_p2wpkh_addr\n         self.log.info(\"Should import a p2sh-p2wpkh with respective redeem script and private keys\")\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2sh_p2wpkh_addr},\n                                \"timestamp\": \"now\",\n                                \"redeemscript\": key.p2sh_p2wpkh_redeem_script,\n                                \"keys\": [key.privkey]},\n-                              True)\n-        self.test_address(address,\n+                              success=True)\n+        self.test_address(key.p2sh_p2wpkh_addr,\n                           solvable=True,\n                           ismine=True)\n \n         # P2SH-P2WSH multisig + redeemscript with no private key\n         multisig = self.get_multisig()\n-        address = multisig.p2sh_p2wsh_addr\n         self.log.info(\"Should import a p2sh-p2wsh with respective redeem script but no private key\")\n-        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2sh_p2wsh_addr},\n                                \"timestamp\": \"now\",\n                                \"redeemscript\": multisig.p2wsh_script,\n                                \"witnessscript\": multisig.redeem_script},\n-                              True,\n+                              success=True,\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(address,\n+        self.test_address(multisig.p2sh_p2wsh_addr,\n                           solvable=True,\n                           ismine=False)\n "
      }
    ]
  },
  {
    "sha": "2d5f1ea2e3f9629d313f1d2aff94a15ef8e1128a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyZDVmMWVhMmUzZjk2MjlkMzEzZjFkMmFmZjk0YTE1ZWY4ZTExMjhh",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-12-13T17:43:35Z"
      },
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti.uttarwar@coinbase.com",
        "date": "2019-01-05T01:49:17Z"
      },
      "message": "[tests] move wallet util functions to wallet_util.py\n\nAdds a new wallet_util.py module and moves generic helper functions\nthere:\n\n- get_key\n- get_multisig\n- test_address",
      "tree": {
        "sha": "2751d6539da4cc3b350da333f5a5214e3d1dd2d7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2751d6539da4cc3b350da333f5a5214e3d1dd2d7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2d5f1ea2e3f9629d313f1d2aff94a15ef8e1128a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2d5f1ea2e3f9629d313f1d2aff94a15ef8e1128a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2d5f1ea2e3f9629d313f1d2aff94a15ef8e1128a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2d5f1ea2e3f9629d313f1d2aff94a15ef8e1128a/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": null,
    "parents": [
      {
        "sha": "6be64ef02ca0832dfb74f74e5b026ead4cd7ef72",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6be64ef02ca0832dfb74f74e5b026ead4cd7ef72",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6be64ef02ca0832dfb74f74e5b026ead4cd7ef72"
      }
    ],
    "stats": {
      "total": 586,
      "additions": 315,
      "deletions": 271
    },
    "files": [
      {
        "sha": "c0dfa4c3f00c35a8ba401818de79a7b21589321e",
        "filename": "test/functional/test_framework/wallet_util.py",
        "status": "added",
        "additions": 99,
        "deletions": 0,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2d5f1ea2e3f9629d313f1d2aff94a15ef8e1128a/test/functional/test_framework/wallet_util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2d5f1ea2e3f9629d313f1d2aff94a15ef8e1128a/test/functional/test_framework/wallet_util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/wallet_util.py?ref=2d5f1ea2e3f9629d313f1d2aff94a15ef8e1128a",
        "patch": "@@ -0,0 +1,99 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Useful util functions for testing the wallet\"\"\"\n+from collections import namedtuple\n+\n+from test_framework.address import (\n+    key_to_p2pkh,\n+    key_to_p2sh_p2wpkh,\n+    key_to_p2wpkh,\n+    script_to_p2sh,\n+    script_to_p2sh_p2wsh,\n+    script_to_p2wsh,\n+)\n+from test_framework.script import (\n+    CScript,\n+    OP_0,\n+    OP_2,\n+    OP_3,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKSIG,\n+    OP_DUP,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    hash160,\n+    sha256,\n+)\n+from test_framework.util import hex_str_to_bytes\n+\n+Key = namedtuple('Key', ['privkey',\n+                         'pubkey',\n+                         'p2pkh_script',\n+                         'p2pkh_addr',\n+                         'p2wpkh_script',\n+                         'p2wpkh_addr',\n+                         'p2sh_p2wpkh_script',\n+                         'p2sh_p2wpkh_redeem_script',\n+                         'p2sh_p2wpkh_addr'])\n+\n+Multisig = namedtuple('Multisig', ['privkeys',\n+                                   'pubkeys',\n+                                   'p2sh_script',\n+                                   'p2sh_addr',\n+                                   'redeem_script',\n+                                   'p2wsh_script',\n+                                   'p2wsh_addr',\n+                                   'p2sh_p2wsh_script',\n+                                   'p2sh_p2wsh_addr'])\n+\n+def get_key(node):\n+    \"\"\"Generate a fresh key on node\n+\n+    Returns a named tuple of privkey, pubkey and all address and scripts.\"\"\"\n+    addr = node.getnewaddress()\n+    pubkey = node.getaddressinfo(addr)['pubkey']\n+    pkh = hash160(hex_str_to_bytes(pubkey))\n+    return Key(privkey=node.dumpprivkey(addr),\n+               pubkey=pubkey,\n+               p2pkh_script=CScript([OP_DUP, OP_HASH160, pkh, OP_EQUALVERIFY, OP_CHECKSIG]).hex(),\n+               p2pkh_addr=key_to_p2pkh(pubkey),\n+               p2wpkh_script=CScript([OP_0, pkh]).hex(),\n+               p2wpkh_addr=key_to_p2wpkh(pubkey),\n+               p2sh_p2wpkh_script=CScript([OP_HASH160, hash160(CScript([OP_0, pkh])), OP_EQUAL]).hex(),\n+               p2sh_p2wpkh_redeem_script=CScript([OP_0, pkh]).hex(),\n+               p2sh_p2wpkh_addr=key_to_p2sh_p2wpkh(pubkey))\n+\n+def get_multisig(node):\n+    \"\"\"Generate a fresh 2-of-3 multisig on node\n+\n+    Returns a named tuple of privkeys, pubkeys and all address and scripts.\"\"\"\n+    addrs = []\n+    pubkeys = []\n+    for _ in range(3):\n+        addr = node.getaddressinfo(node.getnewaddress())\n+        addrs.append(addr['address'])\n+        pubkeys.append(addr['pubkey'])\n+    script_code = CScript([OP_2] + [hex_str_to_bytes(pubkey) for pubkey in pubkeys] + [OP_3, OP_CHECKMULTISIG])\n+    witness_script = CScript([OP_0, sha256(script_code)])\n+    return Multisig(privkeys=[node.dumpprivkey(addr) for addr in addrs],\n+                    pubkeys=pubkeys,\n+                    p2sh_script=CScript([OP_HASH160, hash160(script_code), OP_EQUAL]).hex(),\n+                    p2sh_addr=script_to_p2sh(script_code),\n+                    redeem_script=script_code.hex(),\n+                    p2wsh_script=witness_script.hex(),\n+                    p2wsh_addr=script_to_p2wsh(script_code),\n+                    p2sh_p2wsh_script=CScript([OP_HASH160, witness_script, OP_EQUAL]).hex(),\n+                    p2sh_p2wsh_addr=script_to_p2sh_p2wsh(script_code))\n+\n+def test_address(node, address, **kwargs):\n+    \"\"\"Get address info for `address` and test whether the returned values are as expected.\"\"\"\n+    addr_info = node.getaddressinfo(address)\n+    for key, value in kwargs.items():\n+        if value is None:\n+            if key in addr_info.keys():\n+                raise AssertionError(\"key {} unexpectedly returned in getaddressinfo.\".format(key))\n+        elif addr_info[key] != value:\n+            raise AssertionError(\"key {} value {} did not match expected value {}\".format(key, addr_info[key], value))"
      },
      {
        "sha": "a623b75606c1f5c169049a0f10ff53c0534a65ce",
        "filename": "test/functional/wallet_import_with_label.py",
        "status": "modified",
        "additions": 39,
        "deletions": 38,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2d5f1ea2e3f9629d313f1d2aff94a15ef8e1128a/test/functional/wallet_import_with_label.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2d5f1ea2e3f9629d313f1d2aff94a15ef8e1128a/test/functional/wallet_import_with_label.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_import_with_label.py?ref=2d5f1ea2e3f9629d313f1d2aff94a15ef8e1128a",
        "patch": "@@ -11,7 +11,7 @@\n \"\"\"\n \n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal\n+from test_framework.wallet_util import test_address\n \n \n class ImportWithLabel(BitcoinTestFramework):\n@@ -32,11 +32,11 @@ def run_test(self):\n         address = self.nodes[0].getnewaddress()\n         label = \"Test Label\"\n         self.nodes[1].importaddress(address, label)\n-        address_assert = self.nodes[1].getaddressinfo(address)\n-\n-        assert_equal(address_assert[\"iswatchonly\"], True)\n-        assert_equal(address_assert[\"ismine\"], False)\n-        assert_equal(address_assert[\"label\"], label)\n+        test_address(self.nodes[1],\n+                     address,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     label=label)\n \n         self.log.info(\n             \"Import the watch-only address's private key without a \"\n@@ -45,19 +45,21 @@ def run_test(self):\n         priv_key = self.nodes[0].dumpprivkey(address)\n         self.nodes[1].importprivkey(priv_key)\n \n-        assert_equal(label, self.nodes[1].getaddressinfo(address)[\"label\"])\n+        test_address(self.nodes[1],\n+                     address,\n+                     label=label)\n \n         self.log.info(\n             \"Test importaddress without label and importprivkey with label.\"\n         )\n         self.log.info(\"Import a watch-only address without a label.\")\n         address2 = self.nodes[0].getnewaddress()\n         self.nodes[1].importaddress(address2)\n-        address_assert2 = self.nodes[1].getaddressinfo(address2)\n-\n-        assert_equal(address_assert2[\"iswatchonly\"], True)\n-        assert_equal(address_assert2[\"ismine\"], False)\n-        assert_equal(address_assert2[\"label\"], \"\")\n+        test_address(self.nodes[1],\n+                     address2,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     label=\"\")\n \n         self.log.info(\n             \"Import the watch-only address's private key with a \"\n@@ -67,18 +69,20 @@ def run_test(self):\n         label2 = \"Test Label 2\"\n         self.nodes[1].importprivkey(priv_key2, label2)\n \n-        assert_equal(label2, self.nodes[1].getaddressinfo(address2)[\"label\"])\n+        test_address(self.nodes[1],\n+                     address2,\n+                     label=label2)\n \n         self.log.info(\"Test importaddress with label and importprivkey with label.\")\n         self.log.info(\"Import a watch-only address with a label.\")\n         address3 = self.nodes[0].getnewaddress()\n         label3_addr = \"Test Label 3 for importaddress\"\n         self.nodes[1].importaddress(address3, label3_addr)\n-        address_assert3 = self.nodes[1].getaddressinfo(address3)\n-\n-        assert_equal(address_assert3[\"iswatchonly\"], True)\n-        assert_equal(address_assert3[\"ismine\"], False)\n-        assert_equal(address_assert3[\"label\"], label3_addr)\n+        test_address(self.nodes[1],\n+                     address3,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     label=label3_addr)\n \n         self.log.info(\n             \"Import the watch-only address's private key with a \"\n@@ -88,7 +92,9 @@ def run_test(self):\n         label3_priv = \"Test Label 3 for importprivkey\"\n         self.nodes[1].importprivkey(priv_key3, label3_priv)\n \n-        assert_equal(label3_priv, self.nodes[1].getaddressinfo(address3)[\"label\"])\n+        test_address(self.nodes[1],\n+                     address3,\n+                     label=label3_priv)\n \n         self.log.info(\n             \"Test importprivkey won't label new dests with the same \"\n@@ -98,15 +104,12 @@ def run_test(self):\n         address4 = self.nodes[0].getnewaddress()\n         label4_addr = \"Test Label 4 for importaddress\"\n         self.nodes[1].importaddress(address4, label4_addr)\n-        address_assert4 = self.nodes[1].getaddressinfo(address4)\n-\n-        assert_equal(address_assert4[\"iswatchonly\"], True)\n-        assert_equal(address_assert4[\"ismine\"], False)\n-        assert_equal(address_assert4[\"label\"], label4_addr)\n-\n-        self.log.info(\"Asserts address has no embedded field with dests.\")\n-\n-        assert_equal(address_assert4.get(\"embedded\"), None)\n+        test_address(self.nodes[1],\n+                     address4,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     label=label4_addr,\n+                     embedded=None)\n \n         self.log.info(\n             \"Import the watch-only address's private key without a \"\n@@ -116,16 +119,14 @@ def run_test(self):\n         )\n         priv_key4 = self.nodes[0].dumpprivkey(address4)\n         self.nodes[1].importprivkey(priv_key4)\n-        address_assert4 = self.nodes[1].getaddressinfo(address4)\n-\n-        assert address_assert4.get(\"embedded\")\n-\n-        bcaddress_assert = self.nodes[1].getaddressinfo(\n-            address_assert4[\"embedded\"][\"address\"]\n-        )\n-\n-        assert_equal(address_assert4[\"label\"], label4_addr)\n-        assert_equal(bcaddress_assert[\"label\"], \"\")\n+        embedded_addr = self.nodes[1].getaddressinfo(address4)['embedded']['address']\n+\n+        test_address(self.nodes[1],\n+                     embedded_addr,\n+                     label=\"\")\n+        test_address(self.nodes[1],\n+                     address4,\n+                     label=label4_addr)\n \n         self.stop_nodes()\n "
      },
      {
        "sha": "f122f19e3ab6c6a64f4efbdfccf15d613a07e791",
        "filename": "test/functional/wallet_importmulti.py",
        "status": "modified",
        "additions": 177,
        "deletions": 233,
        "changes": 410,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2d5f1ea2e3f9629d313f1d2aff94a15ef8e1128a/test/functional/wallet_importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2d5f1ea2e3f9629d313f1d2aff94a15ef8e1128a/test/functional/wallet_importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importmulti.py?ref=2d5f1ea2e3f9629d313f1d2aff94a15ef8e1128a",
        "patch": "@@ -14,59 +14,23 @@\n   success, and (if unsuccessful) test the error code and error message returned.\n - `test_address()` is called to call getaddressinfo for an address on node1\n   and test the values returned.\"\"\"\n-from collections import namedtuple\n-\n-from test_framework.address import (\n-    key_to_p2pkh,\n-    key_to_p2sh_p2wpkh,\n-    key_to_p2wpkh,\n-    script_to_p2sh,\n-    script_to_p2sh_p2wsh,\n-    script_to_p2wsh,\n-)\n+\n from test_framework.script import (\n     CScript,\n-    OP_0,\n-    OP_2,\n-    OP_3,\n-    OP_CHECKMULTISIG,\n-    OP_CHECKSIG,\n-    OP_DUP,\n-    OP_EQUAL,\n-    OP_EQUALVERIFY,\n-    OP_HASH160,\n     OP_NOP,\n-    hash160,\n-    sha256,\n )\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n     assert_greater_than,\n     assert_raises_rpc_error,\n     bytes_to_hex_str,\n-    hex_str_to_bytes\n )\n-\n-Key = namedtuple('Key', ['privkey',\n-                         'pubkey',\n-                         'p2pkh_script',\n-                         'p2pkh_addr',\n-                         'p2wpkh_script',\n-                         'p2wpkh_addr',\n-                         'p2sh_p2wpkh_script',\n-                         'p2sh_p2wpkh_redeem_script',\n-                         'p2sh_p2wpkh_addr'])\n-\n-Multisig = namedtuple('Multisig', ['privkeys',\n-                                   'pubkeys',\n-                                   'p2sh_script',\n-                                   'p2sh_addr',\n-                                   'redeem_script',\n-                                   'p2wsh_script',\n-                                   'p2wsh_addr',\n-                                   'p2sh_p2wsh_script',\n-                                   'p2sh_p2wsh_addr'])\n+from test_framework.wallet_util import (\n+    get_key,\n+    get_multisig,\n+    test_address,\n+)\n \n class ImportMultiTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -80,45 +44,6 @@ def skip_test_if_missing_module(self):\n     def setup_network(self):\n         self.setup_nodes()\n \n-    def get_key(self):\n-        \"\"\"Generate a fresh key on node0\n-\n-        Returns a named tuple of privkey, pubkey and all address and scripts.\"\"\"\n-        addr = self.nodes[0].getnewaddress()\n-        pubkey = self.nodes[0].getaddressinfo(addr)['pubkey']\n-        pkh = hash160(hex_str_to_bytes(pubkey))\n-        return Key(privkey=self.nodes[0].dumpprivkey(addr),\n-                   pubkey=pubkey,\n-                   p2pkh_script=CScript([OP_DUP, OP_HASH160, pkh, OP_EQUALVERIFY, OP_CHECKSIG]).hex(),\n-                   p2pkh_addr=key_to_p2pkh(pubkey),\n-                   p2wpkh_script=CScript([OP_0, pkh]).hex(),\n-                   p2wpkh_addr=key_to_p2wpkh(pubkey),\n-                   p2sh_p2wpkh_script=CScript([OP_HASH160, hash160(CScript([OP_0, pkh])), OP_EQUAL]).hex(),\n-                   p2sh_p2wpkh_redeem_script=CScript([OP_0, pkh]).hex(),\n-                   p2sh_p2wpkh_addr=key_to_p2sh_p2wpkh(pubkey))\n-\n-    def get_multisig(self):\n-        \"\"\"Generate a fresh 2-of-3 multisig on node0\n-\n-        Returns a named tuple of privkeys, pubkeys and all address and scripts.\"\"\"\n-        addrs = []\n-        pubkeys = []\n-        for _ in range(3):\n-            addr = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-            addrs.append(addr['address'])\n-            pubkeys.append(addr['pubkey'])\n-        script_code = CScript([OP_2] + [hex_str_to_bytes(pubkey) for pubkey in pubkeys] + [OP_3, OP_CHECKMULTISIG])\n-        witness_script = CScript([OP_0, sha256(script_code)])\n-        return Multisig(privkeys=[self.nodes[0].dumpprivkey(addr) for addr in addrs],\n-                        pubkeys=pubkeys,\n-                        p2sh_script=CScript([OP_HASH160, hash160(script_code), OP_EQUAL]).hex(),\n-                        p2sh_addr=script_to_p2sh(script_code),\n-                        redeem_script=script_code.hex(),\n-                        p2wsh_script=witness_script.hex(),\n-                        p2wsh_addr=script_to_p2wsh(script_code),\n-                        p2sh_p2wsh_script=CScript([OP_HASH160, witness_script, OP_EQUAL]).hex(),\n-                        p2sh_p2wsh_addr=script_to_p2sh_p2wsh(script_code))\n-\n     def test_importmulti(self, req, success, error_code=None, error_message=None, warnings=[]):\n         \"\"\"Run importmulti and assert success\"\"\"\n         result = self.nodes[1].importmulti([req])\n@@ -131,16 +56,6 @@ def test_importmulti(self, req, success, error_code=None, error_message=None, wa\n             assert_equal(result[0]['error']['code'], error_code)\n             assert_equal(result[0]['error']['message'], error_message)\n \n-    def test_address(self, address, **kwargs):\n-        \"\"\"Get address info for `address` and test whether the returned values are as expected.\"\"\"\n-        addr_info = self.nodes[1].getaddressinfo(address)\n-        for key, value in kwargs.items():\n-            if value is None:\n-                if key in addr_info.keys():\n-                    raise AssertionError(\"key {} unexpectedly returned in getaddressinfo.\".format(key))\n-            elif addr_info[key] != value:\n-                raise AssertionError(\"key {} value {} did not match expected value {}\".format(key, addr_info[key], value))\n-\n     def run_test(self):\n         self.log.info(\"Mining blocks...\")\n         self.nodes[0].generate(1)\n@@ -164,15 +79,16 @@ def run_test(self):\n \n         # Bitcoin Address (implicit non-internal)\n         self.log.info(\"Should import an address\")\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\"},\n                               success=True)\n-        self.test_address(key.p2pkh_addr,\n-                          iswatchonly=True,\n-                          ismine=False,\n-                          timestamp=timestamp,\n-                          ischange=False)\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     timestamp=timestamp,\n+                     ischange=False)\n         watchonly_address = key.p2pkh_addr\n         watchonly_timestamp = timestamp\n \n@@ -185,20 +101,21 @@ def run_test(self):\n \n         # ScriptPubKey + internal\n         self.log.info(\"Should import a scriptPubKey with internal flag\")\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n                                \"timestamp\": \"now\",\n                                \"internal\": True},\n                               success=True)\n-        self.test_address(key.p2pkh_addr,\n-                          iswatchonly=True,\n-                          ismine=False,\n-                          timestamp=timestamp,\n-                          ischange=True)\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     timestamp=timestamp,\n+                     ischange=True)\n \n         # ScriptPubKey + internal + label\n         self.log.info(\"Should not allow a label to be specified when internal is true\")\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n                                \"timestamp\": \"now\",\n                                \"internal\": True,\n@@ -210,70 +127,75 @@ def run_test(self):\n         # Nonstandard scriptPubKey + !internal\n         self.log.info(\"Should not import a nonstandard scriptPubKey without internal flag\")\n         nonstandardScriptPubKey = key.p2pkh_script + bytes_to_hex_str(CScript([OP_NOP]))\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": nonstandardScriptPubKey,\n                                \"timestamp\": \"now\"},\n                               success=False,\n                               error_code=-8,\n                               error_message='Internal must be set to true for nonstandard scriptPubKey imports.')\n-        self.test_address(key.p2pkh_addr,\n-                          iswatchonly=False,\n-                          ismine=False,\n-                          timestamp=None)\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     iswatchonly=False,\n+                     ismine=False,\n+                     timestamp=None)\n \n         # Address + Public key + !Internal(explicit)\n         self.log.info(\"Should import an address with public key\")\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [key.pubkey],\n                                \"internal\": False},\n                               success=True,\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(key.p2pkh_addr,\n-                          iswatchonly=True,\n-                          ismine=False,\n-                          timestamp=timestamp)\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     timestamp=timestamp)\n \n         # ScriptPubKey + Public key + internal\n         self.log.info(\"Should import a scriptPubKey with internal and with public key\")\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [key.pubkey],\n                                \"internal\": True},\n                               success=True,\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(key.p2pkh_addr,\n-                          iswatchonly=True,\n-                          ismine=False,\n-                          timestamp=timestamp)\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     timestamp=timestamp)\n \n         # Nonstandard scriptPubKey + Public key + !internal\n         self.log.info(\"Should not import a nonstandard scriptPubKey without internal and with public key\")\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": nonstandardScriptPubKey,\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [key.pubkey]},\n                               success=False,\n                               error_code=-8,\n                               error_message='Internal must be set to true for nonstandard scriptPubKey imports.')\n-        self.test_address(key.p2pkh_addr,\n-                          iswatchonly=False,\n-                          ismine=False,\n-                          timestamp=None)\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     iswatchonly=False,\n+                     ismine=False,\n+                     timestamp=None)\n \n         # Address + Private key + !watchonly\n         self.log.info(\"Should import an address with private key\")\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\",\n                                \"keys\": [key.privkey]},\n                               success=True)\n-        self.test_address(key.p2pkh_addr,\n-                          iswatchonly=False,\n-                          ismine=True,\n-                          timestamp=timestamp)\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     iswatchonly=False,\n+                     ismine=True,\n+                     timestamp=timestamp)\n \n         self.log.info(\"Should not import an address with private key if is already imported\")\n         self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n@@ -285,47 +207,50 @@ def run_test(self):\n \n         # Address + Private key + watchonly\n         self.log.info(\"Should import an address with private key and with watchonly\")\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\",\n                                \"keys\": [key.privkey],\n                                \"watchonly\": True},\n                               success=True,\n                               warnings=[\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\"])\n-        self.test_address(key.p2pkh_addr,\n-                          iswatchonly=False,\n-                          ismine=True,\n-                          timestamp=timestamp)\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     iswatchonly=False,\n+                     ismine=True,\n+                     timestamp=timestamp)\n \n         # ScriptPubKey + Private key + internal\n         self.log.info(\"Should import a scriptPubKey with internal and with private key\")\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n                                \"timestamp\": \"now\",\n                                \"keys\": [key.privkey],\n                                \"internal\": True},\n                               success=True)\n-        self.test_address(key.p2pkh_addr,\n-                          iswatchonly=False,\n-                          ismine=True,\n-                          timestamp=timestamp)\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     iswatchonly=False,\n+                     ismine=True,\n+                     timestamp=timestamp)\n \n         # Nonstandard scriptPubKey + Private key + !internal\n         self.log.info(\"Should not import a nonstandard scriptPubKey without internal and with private key\")\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": nonstandardScriptPubKey,\n                                \"timestamp\": \"now\",\n                                \"keys\": [key.privkey]},\n                               success=False,\n                               error_code=-8,\n                               error_message='Internal must be set to true for nonstandard scriptPubKey imports.')\n-        self.test_address(key.p2pkh_addr,\n-                          iswatchonly=False,\n-                          ismine=False,\n-                          timestamp=None)\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     iswatchonly=False,\n+                     ismine=False,\n+                     timestamp=None)\n \n         # P2SH address\n-        multisig = self.get_multisig()\n+        multisig = get_multisig(self.nodes[0])\n         self.nodes[1].generate(100)\n         self.nodes[1].sendtoaddress(multisig.p2sh_addr, 10.00)\n         self.nodes[1].generate(1)\n@@ -335,16 +260,17 @@ def run_test(self):\n         self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2sh_addr},\n                                \"timestamp\": \"now\"},\n                               success=True)\n-        self.test_address(multisig.p2sh_addr,\n-                          isscript=True,\n-                          iswatchonly=True,\n-                          timestamp=timestamp)\n+        test_address(self.nodes[1],\n+                     multisig.p2sh_addr,\n+                     isscript=True,\n+                     iswatchonly=True,\n+                     timestamp=timestamp)\n         p2shunspent = self.nodes[1].listunspent(0, 999999, [multisig.p2sh_addr])[0]\n         assert_equal(p2shunspent['spendable'], False)\n         assert_equal(p2shunspent['solvable'], False)\n \n         # P2SH + Redeem script\n-        multisig = self.get_multisig()\n+        multisig = get_multisig(self.nodes[0])\n         self.nodes[1].generate(100)\n         self.nodes[1].sendtoaddress(multisig.p2sh_addr, 10.00)\n         self.nodes[1].generate(1)\n@@ -356,14 +282,15 @@ def run_test(self):\n                                \"redeemscript\": multisig.redeem_script},\n                               success=True,\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(multisig.p2sh_addr, timestamp=timestamp, iswatchonly=True, ismine=False, solvable=True)\n+        test_address(self.nodes[1],\n+                     multisig.p2sh_addr, timestamp=timestamp, iswatchonly=True, ismine=False, solvable=True)\n \n         p2shunspent = self.nodes[1].listunspent(0, 999999, [multisig.p2sh_addr])[0]\n         assert_equal(p2shunspent['spendable'], False)\n         assert_equal(p2shunspent['solvable'], True)\n \n         # P2SH + Redeem script + Private Keys + !Watchonly\n-        multisig = self.get_multisig()\n+        multisig = get_multisig(self.nodes[0])\n         self.nodes[1].generate(100)\n         self.nodes[1].sendtoaddress(multisig.p2sh_addr, 10.00)\n         self.nodes[1].generate(1)\n@@ -376,18 +303,19 @@ def run_test(self):\n                                \"keys\": multisig.privkeys[0:2]},\n                               success=True,\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(multisig.p2sh_addr,\n-                          timestamp=timestamp,\n-                          ismine=False,\n-                          iswatchonly=True,\n-                          solvable=True)\n+        test_address(self.nodes[1],\n+                     multisig.p2sh_addr,\n+                     timestamp=timestamp,\n+                     ismine=False,\n+                     iswatchonly=True,\n+                     solvable=True)\n \n         p2shunspent = self.nodes[1].listunspent(0, 999999, [multisig.p2sh_addr])[0]\n         assert_equal(p2shunspent['spendable'], False)\n         assert_equal(p2shunspent['solvable'], True)\n \n         # P2SH + Redeem script + Private Keys + Watchonly\n-        multisig = self.get_multisig()\n+        multisig = get_multisig(self.nodes[0])\n         self.nodes[1].generate(100)\n         self.nodes[1].sendtoaddress(multisig.p2sh_addr, 10.00)\n         self.nodes[1].generate(1)\n@@ -400,93 +328,100 @@ def run_test(self):\n                                \"keys\": multisig.privkeys[0:2],\n                                \"watchonly\": True},\n                               success=True)\n-        self.test_address(multisig.p2sh_addr,\n-                          iswatchonly=True,\n-                          ismine=False,\n-                          solvable=True,\n-                          timestamp=timestamp)\n+        test_address(self.nodes[1],\n+                     multisig.p2sh_addr,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     solvable=True,\n+                     timestamp=timestamp)\n \n         # Address + Public key + !Internal + Wrong pubkey\n         self.log.info(\"Should not import an address with the wrong public key as non-solvable\")\n-        key = self.get_key()\n-        wrong_key = self.get_key().pubkey\n+        key = get_key(self.nodes[0])\n+        wrong_key = get_key(self.nodes[0]).pubkey\n         self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [wrong_key]},\n                               success=True,\n                               warnings=[\"Importing as non-solvable: some required keys are missing. If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(key.p2pkh_addr,\n-                          iswatchonly=True,\n-                          ismine=False,\n-                          solvable=False,\n-                          timestamp=timestamp)\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     solvable=False,\n+                     timestamp=timestamp)\n \n         # ScriptPubKey + Public key + internal + Wrong pubkey\n         self.log.info(\"Should import a scriptPubKey with internal and with a wrong public key as non-solvable\")\n-        key = self.get_key()\n-        wrong_key = self.get_key().pubkey\n+        key = get_key(self.nodes[0])\n+        wrong_key = get_key(self.nodes[0]).pubkey\n         self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [wrong_key],\n                                \"internal\": True},\n                               success=True,\n                               warnings=[\"Importing as non-solvable: some required keys are missing. If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(key.p2pkh_addr,\n-                          iswatchonly=True,\n-                          ismine=False,\n-                          solvable=False,\n-                          timestamp=timestamp)\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     solvable=False,\n+                     timestamp=timestamp)\n \n         # Address + Private key + !watchonly + Wrong private key\n         self.log.info(\"Should import an address with a wrong private key as non-solvable\")\n-        key = self.get_key()\n-        wrong_privkey = self.get_key().privkey\n+        key = get_key(self.nodes[0])\n+        wrong_privkey = get_key(self.nodes[0]).privkey\n         self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\",\n                                \"keys\": [wrong_privkey]},\n                                success=True,\n                                warnings=[\"Importing as non-solvable: some required keys are missing. If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(key.p2pkh_addr,\n-                          iswatchonly=True,\n-                          ismine=False,\n-                          solvable=False,\n-                          timestamp=timestamp)\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     solvable=False,\n+                     timestamp=timestamp)\n \n         # ScriptPubKey + Private key + internal + Wrong private key\n         self.log.info(\"Should import a scriptPubKey with internal and with a wrong private key as non-solvable\")\n-        key = self.get_key()\n-        wrong_privkey = self.get_key().privkey\n+        key = get_key(self.nodes[0])\n+        wrong_privkey = get_key(self.nodes[0]).privkey\n         self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n                                \"timestamp\": \"now\",\n                                \"keys\": [wrong_privkey],\n                                \"internal\": True},\n                               success=True,\n                               warnings=[\"Importing as non-solvable: some required keys are missing. If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(key.p2pkh_addr,\n-                          iswatchonly=True,\n-                          ismine=False,\n-                          solvable=False,\n-                          timestamp=timestamp)\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     solvable=False,\n+                     timestamp=timestamp)\n \n         # Importing existing watch only address with new timestamp should replace saved timestamp.\n         assert_greater_than(timestamp, watchonly_timestamp)\n         self.log.info(\"Should replace previously saved watch only timestamp.\")\n         self.test_importmulti({\"scriptPubKey\": {\"address\": watchonly_address},\n                                \"timestamp\": \"now\"},\n                               success=True)\n-        self.test_address(watchonly_address,\n-                          iswatchonly=True,\n-                          ismine=False,\n-                          timestamp=timestamp)\n+        test_address(self.nodes[1],\n+                     watchonly_address,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     timestamp=timestamp)\n         watchonly_timestamp = timestamp\n \n         # restart nodes to check for proper serialization/deserialization of watch only address\n         self.stop_nodes()\n         self.start_nodes()\n-        self.test_address(watchonly_address,\n-                          iswatchonly=True,\n-                          ismine=False,\n-                          timestamp=watchonly_timestamp)\n+        test_address(self.nodes[1],\n+                     watchonly_address,\n+                     iswatchonly=True,\n+                     ismine=False,\n+                     timestamp=watchonly_timestamp)\n \n         # Bad or missing timestamps\n         self.log.info(\"Should throw on invalid or missing timestamp values\")\n@@ -500,45 +435,49 @@ def run_test(self):\n \n         # Import P2WPKH address as watch only\n         self.log.info(\"Should import a P2WPKH address as watch only\")\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2wpkh_addr},\n                                \"timestamp\": \"now\"},\n                               success=True)\n-        self.test_address(key.p2wpkh_addr,\n-                          iswatchonly=True,\n-                          solvable=False)\n+        test_address(self.nodes[1],\n+                     key.p2wpkh_addr,\n+                     iswatchonly=True,\n+                     solvable=False)\n \n         # Import P2WPKH address with public key but no private key\n         self.log.info(\"Should import a P2WPKH address and public key as solvable but not spendable\")\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2wpkh_addr},\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [key.pubkey]},\n                               success=True,\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(key.p2wpkh_addr,\n-                          ismine=False,\n-                          solvable=True)\n+        test_address(self.nodes[1],\n+                     key.p2wpkh_addr,\n+                     ismine=False,\n+                     solvable=True)\n \n         # Import P2WPKH address with key and check it is spendable\n         self.log.info(\"Should import a P2WPKH address with key\")\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2wpkh_addr},\n                                \"timestamp\": \"now\",\n                                \"keys\": [key.privkey]},\n                               success=True)\n-        self.test_address(key.p2wpkh_addr,\n-                          iswatchonly=False,\n-                          ismine=True)\n+        test_address(self.nodes[1],\n+                     key.p2wpkh_addr,\n+                     iswatchonly=False,\n+                     ismine=True)\n \n         # P2WSH multisig address without scripts or keys\n-        multisig = self.get_multisig()\n+        multisig = get_multisig(self.nodes[0])\n         self.log.info(\"Should import a p2wsh multisig as watch only without respective redeem script and private keys\")\n         self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2wsh_addr},\n                                \"timestamp\": \"now\"},\n                               success=True)\n-        self.test_address(multisig.p2sh_addr,\n-                          solvable=False)\n+        test_address(self.nodes[1],\n+                     multisig.p2sh_addr,\n+                     solvable=False)\n \n         # Same P2WSH multisig address as above, but now with witnessscript + private keys\n         self.log.info(\"Should import a p2wsh with respective witness script and private keys\")\n@@ -547,20 +486,22 @@ def run_test(self):\n                                \"witnessscript\": multisig.redeem_script,\n                                \"keys\": multisig.privkeys},\n                               success=True)\n-        self.test_address(multisig.p2sh_addr,\n-                          solvable=True,\n-                          ismine=True,\n-                          sigsrequired=2)\n+        test_address(self.nodes[1],\n+                     multisig.p2sh_addr,\n+                     solvable=True,\n+                     ismine=True,\n+                     sigsrequired=2)\n \n         # P2SH-P2WPKH address with no redeemscript or public or private key\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.log.info(\"Should import a p2sh-p2wpkh without redeem script or keys\")\n         self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2sh_p2wpkh_addr},\n                                \"timestamp\": \"now\"},\n                               success=True)\n-        self.test_address(key.p2sh_p2wpkh_addr,\n-                          solvable=False,\n-                          ismine=False)\n+        test_address(self.nodes[1],\n+                     key.p2sh_p2wpkh_addr,\n+                     solvable=False,\n+                     ismine=False)\n \n         # P2SH-P2WPKH address + redeemscript + public key with no private key\n         self.log.info(\"Should import a p2sh-p2wpkh with respective redeem script and pubkey as solvable\")\n@@ -570,34 +511,37 @@ def run_test(self):\n                                \"pubkeys\": [key.pubkey]},\n                               success=True,\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(key.p2sh_p2wpkh_addr,\n-                          solvable=True,\n-                          ismine=False)\n+        test_address(self.nodes[1],\n+                     key.p2sh_p2wpkh_addr,\n+                     solvable=True,\n+                     ismine=False)\n \n         # P2SH-P2WPKH address + redeemscript + private key\n-        key = self.get_key()\n+        key = get_key(self.nodes[0])\n         self.log.info(\"Should import a p2sh-p2wpkh with respective redeem script and private keys\")\n         self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2sh_p2wpkh_addr},\n                                \"timestamp\": \"now\",\n                                \"redeemscript\": key.p2sh_p2wpkh_redeem_script,\n                                \"keys\": [key.privkey]},\n                               success=True)\n-        self.test_address(key.p2sh_p2wpkh_addr,\n-                          solvable=True,\n-                          ismine=True)\n+        test_address(self.nodes[1],\n+                     key.p2sh_p2wpkh_addr,\n+                     solvable=True,\n+                     ismine=True)\n \n         # P2SH-P2WSH multisig + redeemscript with no private key\n-        multisig = self.get_multisig()\n+        multisig = get_multisig(self.nodes[0])\n         self.log.info(\"Should import a p2sh-p2wsh with respective redeem script but no private key\")\n         self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2sh_p2wsh_addr},\n                                \"timestamp\": \"now\",\n                                \"redeemscript\": multisig.p2wsh_script,\n                                \"witnessscript\": multisig.redeem_script},\n                               success=True,\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n-        self.test_address(multisig.p2sh_p2wsh_addr,\n-                          solvable=True,\n-                          ismine=False)\n+        test_address(self.nodes[1],\n+                     multisig.p2sh_p2wsh_addr,\n+                     solvable=True,\n+                     ismine=False)\n \n if __name__ == '__main__':\n     ImportMultiTest().main()"
      }
    ]
  }
]