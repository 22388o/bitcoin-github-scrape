[
  {
    "sha": "7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3YzZlMmQwMGQ0ZWZkNzU1M2RkODJiMGU3NzY1YTEyNDc3YzhiZmYx",
    "commit": {
      "author": {
        "name": "tom19990101",
        "email": "42231085+tom19990101@users.noreply.github.com",
        "date": "2018-11-15T05:21:42Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2018-11-15T05:21:42Z"
      },
      "message": "Merge pull request #1 from bitcoin/master\n\nUpdate",
      "tree": {
        "sha": "08c8af45b8150caa550722cef8b392634c17844d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/08c8af45b8150caa550722cef8b392634c17844d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJb7QJmCRBK7hj4Ov3rIwAAdHIIABa7SBXI/Awd+s7RdPc/m9ok\nGGdnlx5QiSrka+EIUhS6/suKL4r9RYEof1f8LPq1BwpIX6VnWZMyeMRYwZlBxlDk\nHx/LZB7tA0jr4LfQeydl4TZC4tQroJar7ICUcadoQqGLz5F4ZqZIaNt3uI44iqnQ\nxsCFUB3ISixr/L6OofdGX4ZCVRcU5fO0lj0ht749fi8rrSO75JIsC3rCaRhupluW\nNiYDl8jzPIa14h3W92p2+0XCkxBdxJqX1bbaHK+QPQrQyOKTf3txoQpKNPilO4KR\nDQHjvUq3lS2LT+t1Flb2u4rS8VdUgtOwurDCdb6qVRp/vQ9jUq7jOH5BNtjJ9hU=\n=T9wY\n-----END PGP SIGNATURE-----\n",
        "payload": "tree 08c8af45b8150caa550722cef8b392634c17844d\nparent 5473e255f6876ea457a03cbc97844fcf144f79cf\nparent e74649e95122c9c61aadf607461cf701c3953f88\nauthor tom19990101 <42231085+tom19990101@users.noreply.github.com> 1542259302 +0800\ncommitter GitHub <noreply@github.com> 1542259302 +0800\n\nMerge pull request #1 from bitcoin/master\n\nUpdate"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/comments",
    "author": {
      "login": "tom19990101",
      "id": 42231085,
      "node_id": "MDQ6VXNlcjQyMjMxMDg1",
      "avatar_url": "https://avatars.githubusercontent.com/u/42231085?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tom19990101",
      "html_url": "https://github.com/tom19990101",
      "followers_url": "https://api.github.com/users/tom19990101/followers",
      "following_url": "https://api.github.com/users/tom19990101/following{/other_user}",
      "gists_url": "https://api.github.com/users/tom19990101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tom19990101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tom19990101/subscriptions",
      "organizations_url": "https://api.github.com/users/tom19990101/orgs",
      "repos_url": "https://api.github.com/users/tom19990101/repos",
      "events_url": "https://api.github.com/users/tom19990101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tom19990101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5473e255f6876ea457a03cbc97844fcf144f79cf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5473e255f6876ea457a03cbc97844fcf144f79cf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5473e255f6876ea457a03cbc97844fcf144f79cf"
      },
      {
        "sha": "e74649e95122c9c61aadf607461cf701c3953f88",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e74649e95122c9c61aadf607461cf701c3953f88",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e74649e95122c9c61aadf607461cf701c3953f88"
      }
    ],
    "stats": {
      "total": 6550,
      "additions": 4266,
      "deletions": 2284
    },
    "files": [
      {
        "sha": "2aebf1cd5425d992920379594c60ca04bb4ae3ba",
        "filename": ".appveyor.yml",
        "status": "modified",
        "additions": 9,
        "deletions": 16,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/.appveyor.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/.appveyor.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.appveyor.yml?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -3,28 +3,21 @@ skip_tags: true\n image: Visual Studio 2017\n configuration: Release\n platform: x64\n+clone_depth: 5\n environment:\n   APPVEYOR_SAVE_CACHE_ON_ERROR: true\n   CLCACHE_SERVER: 1\n   PACKAGES: boost-filesystem boost-signals2 boost-test libevent openssl zeromq berkeleydb secp256k1 leveldb\n-  PYTHONIOENCODING: utf-8\n+  PATH: 'C:\\Python37-x64;C:\\Python37-x64\\Scripts;%PATH%'\n+  PYTHONUTF8: 1\n cache:\n - C:\\tools\\vcpkg\\installed\n - C:\\Users\\appveyor\\clcache\n-init:\n-- cmd: set PATH=C:\\Python36-x64;C:\\Python36-x64\\Scripts;%PATH%\n install:\n-- cmd: pip install git+https://github.com/frerich/clcache.git\n+- cmd: pip install --quiet git+https://github.com/frerich/clcache.git@v4.2.0\n # Disable zmq test for now since python zmq library on Windows would cause Access violation sometimes.\n # - cmd: pip install zmq\n-- ps:  $packages = $env:PACKAGES -Split ' '\n-- ps:  for ($i=0; $i -lt $packages.length; $i++) {\n-           $env:ALL_PACKAGES += $packages[$i] + \":\" + $env:PLATFORM + \"-windows-static \"\n-       }\n-- cmd: git -C C:\\Tools\\vcpkg pull # This is a temporary fix, can be removed after appveyor update its image to include Microsoft/vcpkg#4046\n-- cmd: C:\\Tools\\vcpkg\\bootstrap-vcpkg.bat\n-- cmd: vcpkg remove --recurse --outdated\n-- cmd: vcpkg install %ALL_PACKAGES%\n+- cmd: vcpkg install --triplet %PLATFORM%-windows-static %PACKAGES% > NUL\n - cmd: del /s /q C:\\Tools\\vcpkg\\installed\\%PLATFORM%-windows-static\\debug # Remove unused debug library\n before_build:\n - ps:  clcache -M 536870912\n@@ -42,7 +35,7 @@ before_build:\n build_script:\n - cmd: msbuild /p:TrackFileAccess=false /p:CLToolExe=clcache.exe build_msvc\\bitcoin.sln /m /v:q /nowarn:C4244;C4267;C4715 /nologo\n after_build:\n-- ps:  fsutil behavior set disablelastaccess 0 # Disable Access time feature on Windows (better performance)\n+- ps:  fsutil behavior set disablelastaccess 1 # Disable Access time feature on Windows (better performance)\n - ps:  clcache -z\n before_test:\n - ps:  ${conf_ini} = (Get-Content([IO.Path]::Combine(${env:APPVEYOR_BUILD_FOLDER}, \"test\", \"config.ini.in\")))\n@@ -57,9 +50,9 @@ before_test:\n - ps:  '[IO.File]::WriteAllLines([IO.Path]::Combine(${env:APPVEYOR_BUILD_FOLDER}, \"test\", \"config.ini\"), ${conf_ini}, ${utf8})'\n - ps:  move \"build_msvc\\${env:PLATFORM}\\${env:CONFIGURATION}\\*.exe\" src\n test_script:\n-- cmd: src\\test_bitcoin.exe\n-- ps:  src\\bench_bitcoin.exe -evals=1 -scaling=0\n+- cmd: src\\test_bitcoin.exe -k stdout -e stdout 2> NUL\n+- cmd: src\\bench_bitcoin.exe -evals=1 -scaling=0 > NUL\n - ps:  python test\\util\\bitcoin-util-test.py\n - cmd: python test\\util\\rpcauth-test.py\n-- cmd: python test\\functional\\test_runner.py --force --quiet --combinedlogslen=4000 --exclude wallet_multiwallet\n+- cmd: python test\\functional\\test_runner.py --ci --force --quiet --combinedlogslen=4000 --failfast\n deploy: off"
      },
      {
        "sha": "380d2eab9847fe3e6a23679f154e9567bf27abc0",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -116,3 +116,6 @@ test/cache/*\n \n libbitcoinconsensus.pc\n contrib/devtools/split-debug.sh\n+\n+# Output from running db4 installation\n+db4/"
      },
      {
        "sha": "1bf560fc4c8f1ca789e398e961c27c98e4027874",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 13,
        "deletions": 19,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -16,7 +16,6 @@ env:\n     - MAKEJOBS=-j3\n     - RUN_UNIT_TESTS=true\n     - RUN_FUNCTIONAL_TESTS=true\n-    - RUN_BENCH=false  # Set to true for any one job that has debug enabled, to quickly check bench is not crashing or hitting assertions\n     - DOCKER_NAME_TAG=ubuntu:18.04\n     - BOOST_TEST_RANDOM=1$TRAVIS_BUILD_ID\n     - CCACHE_SIZE=100M\n@@ -34,7 +33,7 @@ install:\n before_script:\n   - set -o errexit; source .travis/test_05_before_script.sh\n script:\n-  - set -o errexit; source .travis/test_06_script.sh\n+  - if [ $SECONDS -gt 1200 ]; then set +o errexit; echo \"Travis early exit to cache current state\"; false; else set -o errexit; source .travis/test_06_script.sh; fi\n after_script:\n   - echo $TRAVIS_COMMIT_RANGE\n   - echo $TRAVIS_COMMIT_LOG\n@@ -57,8 +56,7 @@ jobs:\n     - stage: test\n       env: >-\n         HOST=arm-linux-gnueabihf\n-        PACKAGES=\"g++-arm-linux-gnueabihf\"\n-        DEP_OPTS=\"NO_QT=1\"\n+        PACKAGES=\"python3 g++-arm-linux-gnueabihf\"\n         RUN_UNIT_TESTS=false\n         RUN_FUNCTIONAL_TESTS=false\n         GOAL=\"install\"\n@@ -70,24 +68,21 @@ jobs:\n       env: >-\n         HOST=i686-w64-mingw32\n         DPKG_ADD_ARCH=\"i386\"\n-        DEP_OPTS=\"NO_QT=1\"\n         PACKAGES=\"python3 nsis g++-mingw-w64-i686 wine-binfmt wine32\"\n-        GOAL=\"install\"\n-        BITCOIN_CONFIG=\"--enable-reduce-exports\"\n+        GOAL=\"deploy\"\n+        BITCOIN_CONFIG=\"--enable-reduce-exports --disable-gui-tests\"\n # Win64\n     - stage: test\n       env: >-\n         HOST=x86_64-w64-mingw32\n-        DEP_OPTS=\"NO_QT=1\"\n         PACKAGES=\"python3 nsis g++-mingw-w64-x86-64 wine-binfmt wine64\"\n-        GOAL=\"install\"\n-        BITCOIN_CONFIG=\"--enable-reduce-exports\"\n+        GOAL=\"deploy\"\n+        BITCOIN_CONFIG=\"--enable-reduce-exports --disable-gui-tests\"\n # 32-bit + dash\n     - stage: test\n       env: >-\n         HOST=i686-pc-linux-gnu\n         PACKAGES=\"g++-multilib python3-zmq\"\n-        DEP_OPTS=\"NO_QT=1\"\n         GOAL=\"install\"\n         BITCOIN_CONFIG=\"--enable-zmq --enable-glibc-back-compat --enable-reduce-exports LDFLAGS=-static-libstdc++\"\n         CONFIG_SHELL=\"/bin/dash\"\n@@ -99,24 +94,23 @@ jobs:\n         DEP_OPTS=\"NO_QT=1 NO_UPNP=1 DEBUG=1 ALLOW_HOST_PACKAGES=1\"\n         GOAL=\"install\"\n         BITCOIN_CONFIG=\"--enable-zmq --with-gui=qt5 --enable-glibc-back-compat --enable-reduce-exports --enable-debug CXXFLAGS=\\\"-g0 -O2\\\"\"\n-# x86_64 Linux (no depends, only system libs)\n+# x86_64 Linux (xenial, no depends, only system libs)\n     - stage: test\n       env: >-\n         HOST=x86_64-unknown-linux-gnu\n-        PACKAGES=\"python3-zmq qtbase5-dev qttools5-dev-tools libssl1.0-dev libevent-dev bsdmainutils libboost-system-dev libboost-filesystem-dev libboost-chrono-dev libboost-test-dev libboost-thread-dev libdb5.3++-dev libminiupnpc-dev libzmq3-dev libprotobuf-dev protobuf-compiler libqrencode-dev\"\n+        DOCKER_NAME_TAG=ubuntu:16.04\n+        PACKAGES=\"python3-zmq qtbase5-dev qttools5-dev-tools libssl-dev libevent-dev bsdmainutils libboost-system-dev libboost-filesystem-dev libboost-chrono-dev libboost-test-dev libboost-thread-dev libdb5.3++-dev libminiupnpc-dev libzmq3-dev libprotobuf-dev protobuf-compiler libqrencode-dev\"\n         NO_DEPENDS=1\n         GOAL=\"install\"\n         BITCOIN_CONFIG=\"--enable-zmq --with-incompatible-bdb --enable-glibc-back-compat --enable-reduce-exports --with-gui=qt5 CPPFLAGS=-DDEBUG_LOCKORDER\"\n-# x86_64 Linux (sanitizers)\n+# x86_64 Linux (no depends, only system libs, sanitizers: undefined (UBSAN) + integer)\n     - stage: test\n       env: >-\n         HOST=x86_64-unknown-linux-gnu\n-        PACKAGES=\"clang python3-zmq qtbase5-dev qttools5-dev-tools libssl1.0-dev libevent-dev bsdmainutils libboost-system-dev libboost-filesystem-dev libboost-chrono-dev libboost-test-dev libboost-thread-dev libdb5.3++-dev libminiupnpc-dev libzmq3-dev libprotobuf-dev protobuf-compiler libqrencode-dev\"\n+        PACKAGES=\"clang llvm python3-zmq qtbase5-dev qttools5-dev-tools libssl1.0-dev libevent-dev bsdmainutils libboost-system-dev libboost-filesystem-dev libboost-chrono-dev libboost-test-dev libboost-thread-dev libdb5.3++-dev libminiupnpc-dev libzmq3-dev libprotobuf-dev protobuf-compiler libqrencode-dev\"\n         NO_DEPENDS=1\n-        RUN_BENCH=true\n-        RUN_FUNCTIONAL_TESTS=false # Disabled for now, can be combined with the other x86_64 linux NO_DEPENDS job when functional tests pass the sanitizers\n         GOAL=\"install\"\n-        BITCOIN_CONFIG=\"--enable-zmq --with-incompatible-bdb --enable-glibc-back-compat --enable-reduce-exports --with-gui=qt5 CPPFLAGS=-DDEBUG_LOCKORDER --with-sanitizers=undefined CC=clang CXX=clang++\"\n+        BITCOIN_CONFIG=\"--enable-zmq --with-incompatible-bdb --enable-glibc-back-compat --enable-reduce-exports --with-gui=qt5 CPPFLAGS=-DDEBUG_LOCKORDER --with-sanitizers=integer,undefined CC=clang CXX=clang++\"\n # x86_64 Linux, No wallet\n     - stage: test\n       env: >-\n@@ -133,5 +127,5 @@ jobs:\n         OSX_SDK=10.11\n         RUN_UNIT_TESTS=false\n         RUN_FUNCTIONAL_TESTS=false\n-        GOAL=\"all deploy\"\n+        GOAL=\"deploy\"\n         BITCOIN_CONFIG=\"--enable-gui --enable-reduce-exports --enable-werror\""
      },
      {
        "sha": "723e7c56f1d9e7817b0913219c9747c6f02a6b8c",
        "filename": ".travis/lint_04_install.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/.travis/lint_04_install.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/.travis/lint_04_install.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis/lint_04_install.sh?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -8,3 +8,4 @@ export LC_ALL=C\n \n travis_retry pip install codespell==1.13.0\n travis_retry pip install flake8==3.5.0\n+travis_retry pip install vulture==0.29"
      },
      {
        "sha": "701e6d8005c8f9a1b27bce308b0aad65e2b46d99",
        "filename": ".travis/lint_06_script.sh",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/.travis/lint_06_script.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/.travis/lint_06_script.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis/lint_06_script.sh?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -19,6 +19,7 @@ test/lint/check-rpc-mappings.py .\n test/lint/lint-all.sh\n \n if [ \"$TRAVIS_REPO_SLUG\" = \"bitcoin/bitcoin\" -a \"$TRAVIS_EVENT_TYPE\" = \"cron\" ]; then\n+    git log --merges --before=\"2 days ago\" -1 --format='%H' > ./contrib/verify-commits/trusted-sha512-root-commit\n     while read -r LINE; do travis_retry gpg --keyserver hkp://subset.pool.sks-keyservers.net --recv-keys $LINE; done < contrib/verify-commits/trusted-keys &&\n-    travis_wait 50 contrib/verify-commits/verify-commits.py;\n+    travis_wait 50 contrib/verify-commits/verify-commits.py --clean-merge=2;\n fi"
      },
      {
        "sha": "3c9fcf3f983ae0cd200bc86a9b10b603ee3e6a4f",
        "filename": ".travis/test_03_before_install.sh",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/.travis/test_03_before_install.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/.travis/test_03_before_install.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis/test_03_before_install.sh?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -7,6 +7,8 @@\n export LC_ALL=C.UTF-8\n \n PATH=$(echo $PATH | tr ':' \"\\n\" | sed '/\\/opt\\/python/d' | tr \"\\n\" \":\" | sed \"s|::|:|g\")\n+# Add llvm-symbolizer directory to PATH. Needed to get symbolized stack traces from the sanitizers.\n+PATH=$PATH:/usr/lib/llvm-6.0/bin/\n export PATH\n \n BEGIN_FOLD () {"
      },
      {
        "sha": "4cf0ba8984aec2fb3629ecd9565d5077098aae57",
        "filename": ".travis/test_04_install.sh",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/.travis/test_04_install.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/.travis/test_04_install.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis/test_04_install.sh?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -7,7 +7,8 @@\n export LC_ALL=C.UTF-8\n \n travis_retry docker pull \"$DOCKER_NAME_TAG\"\n-env | grep -E '^(CCACHE_|WINEDEBUG|LC_ALL|BOOST_TEST_RANDOM|CONFIG_SHELL)' | tee /tmp/env\n+export UBSAN_OPTIONS=\"suppressions=${TRAVIS_BUILD_DIR}/contrib/sanitizers-ubsan.suppressions:print_stacktrace=1:halt_on_error=1\"\n+env | grep -E '^(CCACHE_|WINEDEBUG|LC_ALL|BOOST_TEST_RANDOM|CONFIG_SHELL|UBSAN_OPTIONS)' | tee /tmp/env\n if [[ $HOST = *-mingw32 ]]; then\n   DOCKER_ADMIN=\"--cap-add SYS_ADMIN\"\n fi"
      },
      {
        "sha": "62d58ecf4d724ad3f13315bbe286e9c1f4d494e0",
        "filename": ".travis/test_06_script.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 7,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/.travis/test_06_script.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/.travis/test_06_script.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis/test_06_script.sh?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -50,18 +50,12 @@ if [ \"$RUN_UNIT_TESTS\" = \"true\" ]; then\n   END_FOLD\n fi\n \n-if [ \"$RUN_BENCH\" = \"true\" ]; then\n-  BEGIN_FOLD bench\n-  DOCKER_EXEC LD_LIBRARY_PATH=$TRAVIS_BUILD_DIR/depends/$HOST/lib $OUTDIR/bin/bench_bitcoin -scaling=0.001\n-  END_FOLD\n-fi\n-\n if [ \"$TRAVIS_EVENT_TYPE\" = \"cron\" ]; then\n   extended=\"--extended --exclude feature_pruning\"\n fi\n \n if [ \"$RUN_FUNCTIONAL_TESTS\" = \"true\" ]; then\n   BEGIN_FOLD functional-tests\n-  DOCKER_EXEC test/functional/test_runner.py --combinedlogslen=4000 --coverage --quiet --failfast ${extended}\n+  DOCKER_EXEC test/functional/test_runner.py --ci --combinedlogslen=4000 --coverage --quiet --failfast ${extended}\n   END_FOLD\n fi"
      },
      {
        "sha": "08b2fa609e589c03bfa4831a7eb31ca3ed645fa6",
        "filename": "CONTRIBUTING.md",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/CONTRIBUTING.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/CONTRIBUTING.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/CONTRIBUTING.md?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -67,6 +67,8 @@ If a particular commit references another issue, please add the reference. For\n example: `refs #1234` or `fixes #4321`. Using the `fixes` or `closes` keywords\n will cause the corresponding issue to be closed when the pull request is merged.\n \n+Commit messages should never contain any `@` mentions.\n+\n Please refer to the [Git manual](https://git-scm.com/doc) for more information\n about Git.\n \n@@ -135,6 +137,10 @@ before it will be merged. The basic squashing workflow is shown below.\n     # Save and quit.\n     git push -f # (force push to GitHub)\n \n+Please update the resulting commit message if needed, it should read as a\n+coherent message. In most cases this means that you should not just list the\n+interim commits.\n+\n If you have problems with squashing (or other workflows with `git`), you can\n alternatively enable \"Allow edits from maintainers\" in the right GitHub\n sidebar and ask for help in the pull request."
      },
      {
        "sha": "9a6e15f0dd7727b779fb1376a159f714ed22d88b",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -19,6 +19,7 @@ endif\n BITCOIND_BIN=$(top_builddir)/src/$(BITCOIN_DAEMON_NAME)$(EXEEXT)\n BITCOIN_QT_BIN=$(top_builddir)/src/qt/$(BITCOIN_GUI_NAME)$(EXEEXT)\n BITCOIN_CLI_BIN=$(top_builddir)/src/$(BITCOIN_CLI_NAME)$(EXEEXT)\n+BITCOIN_TX_BIN=$(top_builddir)/src/$(BITCOIN_TX_NAME)$(EXEEXT)\n BITCOIN_WIN_INSTALLER=$(PACKAGE)-$(PACKAGE_VERSION)-win$(WINDOWS_BITS)-setup$(EXEEXT)\n \n empty :=\n@@ -74,6 +75,7 @@ $(BITCOIN_WIN_INSTALLER): all-recursive\n \tSTRIPPROG=\"$(STRIP)\" $(INSTALL_STRIP_PROGRAM) $(BITCOIND_BIN) $(top_builddir)/release\n \tSTRIPPROG=\"$(STRIP)\" $(INSTALL_STRIP_PROGRAM) $(BITCOIN_QT_BIN) $(top_builddir)/release\n \tSTRIPPROG=\"$(STRIP)\" $(INSTALL_STRIP_PROGRAM) $(BITCOIN_CLI_BIN) $(top_builddir)/release\n+\tSTRIPPROG=\"$(STRIP)\" $(INSTALL_STRIP_PROGRAM) $(BITCOIN_TX_BIN) $(top_builddir)/release\n \t@test -f $(MAKENSIS) && $(MAKENSIS) -V2 $(top_builddir)/share/setup.nsi || \\\n \t  echo error: could not build $@\n \t@echo built $@\n@@ -167,6 +169,9 @@ $(BITCOIND_BIN): FORCE\n $(BITCOIN_CLI_BIN): FORCE\n \t$(MAKE) -C src $(@F)\n \n+$(BITCOIN_TX_BIN): FORCE\n+\t$(MAKE) -C src $(@F)\n+\n if USE_LCOV\n LCOV_FILTER_PATTERN=-p \"/usr/include/\" -p \"/usr/lib/\" -p \"src/leveldb/\" -p \"src/bench/\" -p \"src/univalue\" -p \"src/crypto/ctaes\" -p \"src/secp256k1\"\n "
      },
      {
        "sha": "23577d54f917a7179197811fcdd4579e1827cbe5",
        "filename": "README.md",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/README.md?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -31,7 +31,8 @@ The `master` branch is regularly built and tested, but is not guaranteed to be\n completely stable. [Tags](https://github.com/bitcoin/bitcoin/tags) are created\n regularly to indicate new official, stable release versions of Bitcoin Core.\n \n-The contribution workflow is described in [CONTRIBUTING.md](CONTRIBUTING.md).\n+The contribution workflow is described in [CONTRIBUTING.md](CONTRIBUTING.md)\n+and useful hints for developers can be found in [doc/developer-notes.md](doc/developer-notes.md).\n \n Testing\n -------"
      },
      {
        "sha": "90a2cd98759be82e1ae5babeedc2ad2772da2130",
        "filename": "build-aux/m4/bitcoin_qt.m4",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/build-aux/m4/bitcoin_qt.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/build-aux/m4/bitcoin_qt.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/bitcoin_qt.m4?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -276,7 +276,7 @@ AC_DEFUN([_BITCOIN_QT_CHECK_QT5],[\n       #endif\n     ]],\n     [[\n-      #if QT_VERSION < 0x050000 || QT_VERSION_MAJOR < 5\n+      #if QT_VERSION < 0x050200 || QT_VERSION_MAJOR < 5\n       choke\n       #endif\n     ]])],"
      },
      {
        "sha": "2c6c0a8b7c59397147b997dbc15f4bc2f9445e6c",
        "filename": "build_msvc/libbitcoinconsensus/libbitcoinconsensus.vcxproj",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/build_msvc/libbitcoinconsensus/libbitcoinconsensus.vcxproj",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/build_msvc/libbitcoinconsensus/libbitcoinconsensus.vcxproj",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/libbitcoinconsensus/libbitcoinconsensus.vcxproj?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -40,7 +40,7 @@\n     <ClCompile Include=\"..\\..\\src\\script\\script.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\script\\script_error.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\uint256.cpp\" />\n-    <ClCompile Include=\"..\\..\\src\\utilstrencodings.cpp\" />\n+    <ClCompile Include=\"..\\..\\src\\util\\strencodings.cpp\" />\n   </ItemGroup>\n   <ItemGroup>\n     <None Include=\"packages.config\" />"
      },
      {
        "sha": "f351532f9d40ff10c7692b3090fae58f459295c9",
        "filename": "build_msvc/msvc-autogen.py",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/build_msvc/msvc-autogen.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/build_msvc/msvc-autogen.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/msvc-autogen.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -16,10 +16,6 @@\n ]\n \n ignore_list = [\n-    'rpc/net.cpp',\n-    'interfaces/handler.cpp',\n-    'interfaces/node.cpp',\n-    'interfaces/wallet.cpp',\n ]\n \n lib_sources = {}\n@@ -32,7 +28,9 @@ def parse_makefile(makefile):\n             if current_lib:\n                 source = line.split()[0]\n                 if source.endswith('.cpp') and not source.startswith('$') and source not in ignore_list:\n-                    lib_sources[current_lib].append(source.replace('/', '\\\\'))\n+                    source_filename = source.replace('/', '\\\\')\n+                    object_filename = source.replace('/', '_')[:-4] + \".obj\"\n+                    lib_sources[current_lib].append((source_filename, object_filename))\n                 if not line.endswith('\\\\'):\n                     current_lib = ''\n                 continue\n@@ -51,8 +49,10 @@ def main():\n     for key, value in lib_sources.items():\n         vcxproj_filename = os.path.abspath(os.path.join(os.path.dirname(__file__), key, key + '.vcxproj'))\n         content = ''\n-        for source_filename in value:\n-            content += '    <ClCompile Include=\"..\\\\..\\\\src\\\\' + source_filename + '\" />\\n'\n+        for source_filename, object_filename in value:\n+            content += '    <ClCompile Include=\"..\\\\..\\\\src\\\\' + source_filename + '\">\\n'\n+            content += '      <ObjectFileName>$(IntDir)' + object_filename + '</ObjectFileName>\\n'\n+            content += '    </ClCompile>\\n'\n         with open(vcxproj_filename + '.in', 'r', encoding='utf-8') as vcxproj_in_file:\n             with open(vcxproj_filename, 'w', encoding='utf-8') as vcxproj_file:\n                 vcxproj_file.write(vcxproj_in_file.read().replace("
      },
      {
        "sha": "7141a9a03af35f5f3edaa624c490941422bed008",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 24,
        "deletions": 2,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -209,6 +209,11 @@ AC_ARG_ENABLE([zmq],\n   [disable ZMQ notifications])],\n   [use_zmq=$enableval],\n   [use_zmq=yes])\n+AC_ARG_ENABLE([bip70],\n+  [AS_HELP_STRING([--disable-bip70],\n+  [disable BIP70 (payment protocol) support in GUI (enabled by default)])],\n+  [enable_bip70=$enableval],\n+  [enable_bip70=yes])\n \n AC_ARG_WITH([protoc-bindir],[AS_HELP_STRING([--with-protoc-bindir=BIN_DIR],[specify protoc bin path])], [protoc_bin_path=$withval], [])\n \n@@ -1082,7 +1087,9 @@ if test x$use_pkgconfig = xyes; then\n     [\n       PKG_CHECK_MODULES([SSL], [libssl],, [AC_MSG_ERROR(openssl not found.)])\n       PKG_CHECK_MODULES([CRYPTO], [libcrypto],,[AC_MSG_ERROR(libcrypto not found.)])\n-      BITCOIN_QT_CHECK([PKG_CHECK_MODULES([PROTOBUF], [protobuf], [have_protobuf=yes], [BITCOIN_QT_FAIL(libprotobuf not found)])])\n+      if test x$enable_bip70 != xno; then\n+        BITCOIN_QT_CHECK([PKG_CHECK_MODULES([PROTOBUF], [protobuf], [have_protobuf=yes], [BITCOIN_QT_FAIL(libprotobuf not found)])])\n+      fi\n       if test x$use_qr != xno; then\n         BITCOIN_QT_CHECK([PKG_CHECK_MODULES([QR], [libqrencode], [have_qrencode=yes], [have_qrencode=no])])\n       fi\n@@ -1142,7 +1149,9 @@ else\n     esac\n   fi\n \n-  BITCOIN_QT_CHECK(AC_CHECK_LIB([protobuf] ,[main],[PROTOBUF_LIBS=-lprotobuf], BITCOIN_QT_FAIL(libprotobuf not found)))\n+  if test x$enable_bip70 != xno; then\n+    BITCOIN_QT_CHECK(AC_CHECK_LIB([protobuf] ,[main],[PROTOBUF_LIBS=-lprotobuf], BITCOIN_QT_FAIL(libprotobuf not found)))\n+  fi\n   if test x$use_qr != xno; then\n     BITCOIN_QT_CHECK([AC_CHECK_LIB([qrencode], [main],[QR_LIBS=-lqrencode], [have_qrencode=no])])\n     BITCOIN_QT_CHECK([AC_CHECK_HEADER([qrencode.h],, have_qrencode=no)])\n@@ -1220,7 +1229,9 @@ AM_CONDITIONAL([EMBEDDED_UNIVALUE],[test x$need_bundled_univalue = xyes])\n AC_SUBST(UNIVALUE_CFLAGS)\n AC_SUBST(UNIVALUE_LIBS)\n \n+if test x$enable_bip70 != xno; then\n BITCOIN_QT_PATH_PROGS([PROTOC], [protoc],$protoc_bin_path)\n+fi\n \n AC_MSG_CHECKING([whether to build bitcoind])\n AM_CONDITIONAL([BUILD_BITCOIND], [test x$build_bitcoind = xyes])\n@@ -1338,6 +1349,15 @@ if test x$bitcoin_enable_qt != xno; then\n   else\n     AC_MSG_RESULT([no])\n   fi\n+\n+  AC_MSG_CHECKING([whether to build BIP70 support])\n+  if test x$enable_bip70 != xno; then\n+    AC_DEFINE([ENABLE_BIP70],[1],[Define if BIP70 support should be compiled in])\n+    enable_bip70=yes\n+    AC_MSG_RESULT([yes])\n+  else\n+    AC_MSG_RESULT([no])\n+  fi\n fi\n \n AM_CONDITIONAL([ENABLE_ZMQ], [test \"x$use_zmq\" = \"xyes\"])\n@@ -1369,6 +1389,7 @@ AM_CONDITIONAL([ENABLE_WALLET],[test x$enable_wallet = xyes])\n AM_CONDITIONAL([ENABLE_TESTS],[test x$BUILD_TEST = xyes])\n AM_CONDITIONAL([ENABLE_QT],[test x$bitcoin_enable_qt = xyes])\n AM_CONDITIONAL([ENABLE_QT_TESTS],[test x$BUILD_TEST_QT = xyes])\n+AM_CONDITIONAL([ENABLE_BIP70],[test x$enable_bip70 = xyes])\n AM_CONDITIONAL([ENABLE_BENCH],[test x$use_bench = xyes])\n AM_CONDITIONAL([USE_QRCODE], [test x$use_qr = xyes])\n AM_CONDITIONAL([USE_LCOV],[test x$use_lcov = xyes])\n@@ -1503,6 +1524,7 @@ echo \"Options used to compile and link:\"\n echo \"  with wallet   = $enable_wallet\"\n echo \"  with gui / qt = $bitcoin_enable_qt\"\n if test x$bitcoin_enable_qt != xno; then\n+    echo \"    with bip70  = $enable_bip70\"\n     echo \"    with qr     = $use_qr\"\n fi\n echo \"  with zmq      = $use_zmq\""
      },
      {
        "sha": "306a37f75ab7018b0ce015064a7ae0159fd6e015",
        "filename": "contrib/init/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/contrib/init/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/contrib/init/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/init/README.md?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -5,7 +5,7 @@ Upstart: bitcoind.conf\n OpenRC:  bitcoind.openrc\n          bitcoind.openrcconf\n CentOS:  bitcoind.init\n-macOS:    org.bitcoin.bitcoind.plist\n+macOS:   org.bitcoin.bitcoind.plist\n ```\n have been made available to assist packagers in creating node packages here.\n "
      },
      {
        "sha": "c29f83a91e52b90f0a0eb726f247d308ce2b2dc3",
        "filename": "contrib/macdeploy/custom_dsstore.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/contrib/macdeploy/custom_dsstore.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/contrib/macdeploy/custom_dsstore.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/custom_dsstore.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -13,7 +13,7 @@\n ds = DSStore.open(output_file, 'w+')\n ds['.']['bwsp'] = {\n     'ShowStatusBar': False,\n-    'WindowBounds': b'{{300, 280}, {500, 343}}',\n+    'WindowBounds': '{{300, 280}, {500, 343}}',\n     'ContainerShowSidebar': False,\n     'SidebarWidth': 0,\n     'ShowTabView': False,"
      },
      {
        "sha": "e90d5c2ac0ea2028578862a390c64b22b2504a53",
        "filename": "contrib/sanitizers-ubsan.suppressions",
        "status": "added",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/contrib/sanitizers-ubsan.suppressions",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/contrib/sanitizers-ubsan.suppressions",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/sanitizers-ubsan.suppressions?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -0,0 +1,36 @@\n+alignment:move.h\n+alignment:prevector.h\n+bool:wallet/wallet.cpp\n+float-divide-by-zero:policy/fees.cpp\n+float-divide-by-zero:validation.cpp\n+float-divide-by-zero:wallet/wallet.cpp\n+nonnull-attribute:support/cleanse.cpp\n+unsigned-integer-overflow:arith_uint256.h\n+unsigned-integer-overflow:basic_string.h\n+unsigned-integer-overflow:bench/bench.h\n+unsigned-integer-overflow:bitcoin-tx.cpp\n+unsigned-integer-overflow:bloom.cpp\n+unsigned-integer-overflow:chain.cpp\n+unsigned-integer-overflow:chain.h\n+unsigned-integer-overflow:coded_stream.h\n+unsigned-integer-overflow:core_write.cpp\n+unsigned-integer-overflow:crypto/chacha20.cpp\n+unsigned-integer-overflow:crypto/ctaes/ctaes.c\n+unsigned-integer-overflow:crypto/ripemd160.cpp\n+unsigned-integer-overflow:crypto/sha1.cpp\n+unsigned-integer-overflow:crypto/sha256.cpp\n+unsigned-integer-overflow:crypto/sha512.cpp\n+unsigned-integer-overflow:hash.cpp\n+unsigned-integer-overflow:leveldb/db/log_reader.cc\n+unsigned-integer-overflow:leveldb/util/bloom.cc\n+unsigned-integer-overflow:leveldb/util/crc32c.h\n+unsigned-integer-overflow:leveldb/util/hash.cc\n+unsigned-integer-overflow:policy/fees.cpp\n+unsigned-integer-overflow:prevector.h\n+unsigned-integer-overflow:script/interpreter.cpp\n+unsigned-integer-overflow:stl_bvector.h\n+unsigned-integer-overflow:streams.h\n+unsigned-integer-overflow:txmempool.cpp\n+unsigned-integer-overflow:util/strencodings.cpp\n+unsigned-integer-overflow:validation.cpp\n+vptr:fs.cpp"
      },
      {
        "sha": "06893407f5fef454ad17da0eabdfa0c0947a6b8d",
        "filename": "contrib/zmq/zmq_sub.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/contrib/zmq/zmq_sub.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/contrib/zmq/zmq_sub.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/zmq/zmq_sub.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -42,6 +42,7 @@ def __init__(self):\n         self.zmqContext = zmq.asyncio.Context()\n \n         self.zmqSubSocket = self.zmqContext.socket(zmq.SUB)\n+        self.zmqSubSocket.setsockopt(zmq.RCVHWM, 0)\n         self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"hashblock\")\n         self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"hashtx\")\n         self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawblock\")"
      },
      {
        "sha": "66fdf7887fe97d829270513e83ac2de67f08c0a1",
        "filename": "contrib/zmq/zmq_sub3.4.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/contrib/zmq/zmq_sub3.4.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/contrib/zmq/zmq_sub3.4.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/zmq/zmq_sub3.4.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -46,6 +46,7 @@ def __init__(self):\n         self.zmqContext = zmq.asyncio.Context()\n \n         self.zmqSubSocket = self.zmqContext.socket(zmq.SUB)\n+        self.zmqSubSocket.setsockopt(zmq.RCVHWM, 0)\n         self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"hashblock\")\n         self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"hashtx\")\n         self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawblock\")"
      },
      {
        "sha": "c7671c1548b777aa7db26d303e15d04cfc019642",
        "filename": "depends/builders/darwin.mk",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/depends/builders/darwin.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/depends/builders/darwin.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/builders/darwin.mk?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -1,13 +1,13 @@\n-build_darwin_CC: = $(shell xcrun -f clang)\n-build_darwin_CXX: = $(shell xcrun -f clang++)\n-build_darwin_AR: = $(shell xcrun -f ar)\n-build_darwin_RANLIB: = $(shell xcrun -f ranlib)\n-build_darwin_STRIP: = $(shell xcrun -f strip)\n-build_darwin_OTOOL: = $(shell xcrun -f otool)\n-build_darwin_NM: = $(shell xcrun -f nm)\n+build_darwin_CC:=$(shell xcrun -f clang)\n+build_darwin_CXX:=$(shell xcrun -f clang++)\n+build_darwin_AR:=$(shell xcrun -f ar)\n+build_darwin_RANLIB:=$(shell xcrun -f ranlib)\n+build_darwin_STRIP:=$(shell xcrun -f strip)\n+build_darwin_OTOOL:=$(shell xcrun -f otool)\n+build_darwin_NM:=$(shell xcrun -f nm)\n build_darwin_INSTALL_NAME_TOOL:=$(shell xcrun -f install_name_tool)\n-build_darwin_SHA256SUM = shasum -a 256\n-build_darwin_DOWNLOAD = curl --location --fail --connect-timeout $(DOWNLOAD_CONNECT_TIMEOUT) --retry $(DOWNLOAD_RETRIES) -o\n+build_darwin_SHA256SUM=shasum -a 256\n+build_darwin_DOWNLOAD=curl --location --fail --connect-timeout $(DOWNLOAD_CONNECT_TIMEOUT) --retry $(DOWNLOAD_RETRIES) -o\n \n #darwin host on darwin builder. overrides darwin host preferences.\n darwin_CC=$(shell xcrun -f clang) -mmacosx-version-min=$(OSX_MIN_VERSION)"
      },
      {
        "sha": "59df541567fbcb5b195e3f4fc294f9111d5ba48a",
        "filename": "doc/JSON-RPC-interface.md",
        "status": "added",
        "additions": 38,
        "deletions": 0,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/doc/JSON-RPC-interface.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/doc/JSON-RPC-interface.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/JSON-RPC-interface.md?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -0,0 +1,38 @@\n+# JSON-RPC Interface\n+\n+The headless daemon `bitcoind` has the JSON-RPC API enabled by default, the GUI\n+`bitcoin-qt` has it disabled by default. This can be changed with the `-server`\n+option. In the GUI it is possible to execute RPC methods in the Debug Console\n+Dialog.\n+\n+## RPC consistency guarantees\n+\n+State that can be queried via RPCs is guaranteed to be at least up-to-date with\n+the chain state immediately prior to the call's execution. However, the state\n+returned by RPCs that reflect the mempool may not be up-to-date with the\n+current mempool state.\n+\n+### Transaction Pool\n+\n+The mempool state returned via an RPC is consistent with itself and with the\n+chain state at the time of the call. Thus, the mempool state only encompasses\n+transactions that are considered mine-able by the node at the time of the RPC.\n+\n+The mempool state returned via an RPC reflects all effects of mempool and chain\n+state related RPCs that returned prior to this call.\n+\n+### Wallet\n+\n+The wallet state returned via an RPC is consistent with itself and with the\n+chain state at the time of the call.\n+\n+Wallet RPCs will return the latest chain state consistent with prior non-wallet\n+RPCs. The effects of all blocks (and transactions in blocks) at the time of the\n+call is reflected in the state of all wallet transactions. For example, if a\n+block contains transactions that conflicted with mempool transactions, the\n+wallet would reflect the removal of these mempool transactions in the state.\n+\n+However, the wallet may not be up-to-date with the current state of the mempool\n+or the state of the mempool by an RPC that returned before this RPC. For\n+example, a wallet transaction that was BIP-125-replaced in the mempool prior to\n+this RPC may not yet be reflected as such in this RPC response."
      },
      {
        "sha": "344b1be5c45e39d339a7ada835e4ac5fa0e1cbe2",
        "filename": "doc/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/doc/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/doc/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/README.md?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -56,6 +56,7 @@ The Bitcoin repo's [root README](/README.md) contains relevant information on th\n - [Translation Process](translation_process.md)\n - [Translation Strings Policy](translation_strings_policy.md)\n - [Travis CI](travis-ci.md)\n+- [JSON-RPC Interface](JSON-RPC-interface.md)\n - [Unauthenticated REST Interface](REST-interface.md)\n - [Shared Libraries](shared-libraries.md)\n - [BIPS](bips.md)"
      },
      {
        "sha": "44df698382a57643bb0546084d0afa04ca927da9",
        "filename": "doc/REST-interface.md",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/doc/REST-interface.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/doc/REST-interface.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/REST-interface.md?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -6,6 +6,12 @@ The REST API can be enabled with the `-rest` option.\n The interface runs on the same port as the JSON-RPC interface, by default port 8332 for mainnet, port 18332 for testnet,\n and port 18443 for regtest.\n \n+REST Interface consistency guarantees\n+-------------------------------------\n+\n+The [same guarantees as for the RPC Interface](/doc/JSON-RPC-interface.md#rpc-consistency-guarantees)\n+apply.\n+\n Supported API\n -------------\n "
      },
      {
        "sha": "70f5dfc882e7ffe52eac63ff9dd6c291f5c41757",
        "filename": "doc/build-freebsd.md",
        "status": "modified",
        "additions": 19,
        "deletions": 1,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/doc/build-freebsd.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/doc/build-freebsd.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-freebsd.md?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -14,6 +14,12 @@ You will need the following dependencies, which can be installed as root via pkg\n pkg install autoconf automake boost-libs git gmake libevent libtool openssl pkgconf\n ```\n \n+In order to run the test suite (recommended), you will need to have Python 3 installed:\n+\n+```\n+pkg install python3\n+```\n+\n For the wallet (optional):\n ```\n ./contrib/install_db4.sh `pwd`\n@@ -29,17 +35,29 @@ git clone https://github.com/bitcoin/bitcoin\n \n ## Building Bitcoin Core\n \n-**Important**: Use `gmake` (the non-GNU `make` will exit with an error).\n+**Important**: Use `gmake` (the non-GNU `make` will exit with an error):\n \n ```\n ./autogen.sh\n \n ./configure                  # to build with wallet OR\n ./configure --disable-wallet # to build without wallet\n+```\n+\n+followed by either:\n \n+```\n gmake\n ```\n \n+to build without testing, or\n+\n+```\n+gmake check\n+```\n+\n+to also run the test suite (recommended, if Python 3 is installed).\n+\n *Note on debugging*: The version of `gdb` installed by default is [ancient and considered harmful](https://wiki.freebsd.org/GdbRetirement).\n It is not suitable for debugging a multi-threaded C++ program, not even for getting backtraces. Please install the package `gdb` and\n use the versioned gdb command (e.g. `gdb7111`)."
      },
      {
        "sha": "dad2566a6c5c61476f5e1ebb42e4cd44da31b68b",
        "filename": "doc/build-openbsd.md",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/doc/build-openbsd.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/doc/build-openbsd.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-openbsd.md?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -1,6 +1,6 @@\n OpenBSD build guide\n ======================\n-(updated for OpenBSD 6.3)\n+(updated for OpenBSD 6.4)\n \n This guide describes how to build bitcoind and command-line utilities on OpenBSD.\n \n@@ -14,7 +14,7 @@ Run the following as root to install the base dependencies for building:\n ```bash\n pkg_add git gmake libevent libtool boost\n pkg_add autoconf # (select highest version, e.g. 2.69)\n-pkg_add automake # (select highest version, e.g. 1.15)\n+pkg_add automake # (select highest version, e.g. 1.16)\n pkg_add python # (select highest version, e.g. 3.6)\n \n git clone https://github.com/bitcoin/bitcoin.git\n@@ -36,7 +36,7 @@ BerkeleyDB is only necessary for the wallet functionality. To skip this, pass\n It is recommended to use Berkeley DB 4.8. You cannot use the BerkeleyDB library\n from ports, for the same reason as boost above (g++/libstd++ incompatibility).\n If you have to build it yourself, you can use [the installation script included\n-in contrib/](/contrib/install_db4.sh) like so\n+in contrib/](/contrib/install_db4.sh) like so:\n \n ```shell\n ./contrib/install_db4.sh `pwd` CC=cc CXX=c++\n@@ -60,8 +60,8 @@ Preparation:\n export AUTOCONF_VERSION=2.69\n \n # Replace this with the automake version that you installed. Include only\n-# the major and minor parts of the version: use \"1.15\" for \"automake-1.15.1\".\n-export AUTOMAKE_VERSION=1.15\n+# the major and minor parts of the version: use \"1.16\" for \"automake-1.16.1\".\n+export AUTOMAKE_VERSION=1.16\n \n ./autogen.sh\n ```\n@@ -94,7 +94,7 @@ The standard ulimit restrictions in OpenBSD are very strict:\n \n     data(kbytes)         1572864\n \n-This, unfortunately, in some cases not enough to compile some `.cpp` files in the project,\n+This is, unfortunately, in some cases not enough to compile some `.cpp` files in the project,\n (see issue [#6658](https://github.com/bitcoin/bitcoin/issues/6658)).\n If your user is in the `staff` group the limit can be raised with:\n "
      },
      {
        "sha": "c9a59bab838acf31dc3ce117828bb2f7ab8323cf",
        "filename": "doc/build-osx.md",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/doc/build-osx.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/doc/build-osx.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-osx.md?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -20,28 +20,28 @@ Dependencies\n \n See [dependencies.md](dependencies.md) for a complete overview.\n \n-If you want to build the disk image with `make deploy` (.dmg / optional), you need RSVG\n+If you want to build the disk image with `make deploy` (.dmg / optional), you need RSVG:\n \n     brew install librsvg\n \n Berkeley DB\n -----------\n It is recommended to use Berkeley DB 4.8. If you have to build it yourself,\n you can use [the installation script included in contrib/](/contrib/install_db4.sh)\n-like so\n+like so:\n \n ```shell\n ./contrib/install_db4.sh .\n ```\n \n from the root of the repository.\n \n-**Note**: You only need Berkeley DB if the wallet is enabled (see the section *Disable-Wallet mode* below).\n+**Note**: You only need Berkeley DB if the wallet is enabled (see [*Disable-wallet mode*](/doc/build-osx.md#disable-wallet-mode)).\n \n Build Bitcoin Core\n ------------------------\n \n-1. Clone the Bitcoin Core source code and cd into `bitcoin`\n+1. Clone the Bitcoin Core source code:\n \n         git clone https://github.com/bitcoin/bitcoin\n         cd bitcoin\n@@ -80,13 +80,13 @@ Running\n \n Bitcoin Core is now available at `./src/bitcoind`\n \n-Before running, it's recommended that you create an RPC configuration file.\n+Before running, you may create an empty configuration file:\n \n-    echo -e \"rpcuser=bitcoinrpc\\nrpcpassword=$(xxd -l 16 -p /dev/urandom)\" > \"/Users/${USER}/Library/Application Support/Bitcoin/bitcoin.conf\"\n+    touch \"/Users/${USER}/Library/Application Support/Bitcoin/bitcoin.conf\"\n \n     chmod 600 \"/Users/${USER}/Library/Application Support/Bitcoin/bitcoin.conf\"\n \n-The first time you run bitcoind, it will start downloading the blockchain. This process could take several hours.\n+The first time you run bitcoind, it will start downloading the blockchain. This process could take many hours, or even days on slower than average systems.\n \n You can monitor the download process by looking at the debug.log file:\n "
      },
      {
        "sha": "522e3069ce4b767bb6433ec62b5f2ce41c351610",
        "filename": "doc/build-unix.md",
        "status": "modified",
        "additions": 10,
        "deletions": 12,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/doc/build-unix.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/doc/build-unix.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-unix.md?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -6,8 +6,8 @@ Some notes on how to build Bitcoin Core in Unix.\n \n Note\n ---------------------\n-Always use absolute paths to configure and compile Bitcoin Core and the dependencies,\n-for example, when specifying the path of the dependency:\n+Always use absolute paths to configure and compile Bitcoin Core and the dependencies.\n+For example, when specifying the path of the dependency:\n \n \t../dist/configure --enable-cxx --disable-shared --with-pic --prefix=$BDB_PREFIX\n \n@@ -24,7 +24,7 @@ make\n make install # optional\n ```\n \n-This will build bitcoin-qt as well if the dependencies are met.\n+This will build bitcoin-qt as well, if the dependencies are met.\n \n Dependencies\n ---------------------\n@@ -87,11 +87,12 @@ You can add the repository and install using the following commands:\n     sudo apt-get install libdb4.8-dev libdb4.8++-dev\n \n Ubuntu and Debian have their own libdb-dev and libdb++-dev packages, but these will install\n-BerkeleyDB 5.1 or later, which break binary wallet compatibility with the distributed executables which\n+BerkeleyDB 5.1 or later. This will break binary wallet compatibility with the distributed executables, which\n are based on BerkeleyDB 4.8. If you do not care about wallet compatibility,\n pass `--with-incompatible-bdb` to configure.\n \n-See the section \"Disable-wallet mode\" to build Bitcoin Core without wallet.\n+To build Bitcoin Core without wallet, see [*Disable-wallet mode*](/doc/build-unix.md#disable-wallet-mode)\n+\n \n Optional (see --with-miniupnpc and --enable-upnp-default):\n \n@@ -161,15 +162,15 @@ Berkeley DB\n -----------\n It is recommended to use Berkeley DB 4.8. If you have to build it yourself,\n you can use [the installation script included in contrib/](/contrib/install_db4.sh)\n-like so\n+like so:\n \n ```shell\n ./contrib/install_db4.sh `pwd`\n ```\n \n from the root of the repository.\n \n-**Note**: You only need Berkeley DB if the wallet is enabled (see the section *Disable-Wallet mode* below).\n+**Note**: You only need Berkeley DB if the wallet is enabled (see [*Disable-wallet mode*](/doc/build-unix.md#disable-wallet-mode)).\n \n Boost\n -----\n@@ -193,9 +194,7 @@ Hardening Flags:\n \n \n Hardening enables the following features:\n-\n-* Position Independent Executable\n-    Build position independent code to take advantage of Address Space Layout Randomization\n+* _Position Independent Executable_: Build position independent code to take advantage of Address Space Layout Randomization\n     offered by some kernels. Attackers who can cause execution of code at an arbitrary memory\n     location are thwarted if they don't know where anything useful is located.\n     The stack and heap are randomly located by default, but this allows the code section to be\n@@ -213,8 +212,7 @@ Hardening enables the following features:\n      TYPE\n     ET_DYN\n \n-* Non-executable Stack\n-    If the stack is executable then trivial stack-based buffer overflow exploits are possible if\n+* _Non-executable Stack_: If the stack is executable then trivial stack-based buffer overflow exploits are possible if\n     vulnerable buffers are found. By default, Bitcoin Core should be built with a non-executable stack,\n     but if one of the libraries it uses asks for an executable stack or someone makes a mistake\n     and uses a compiler extension which requires an executable stack, it will silently build an"
      },
      {
        "sha": "fc93a0c6e4ced53ab4b972a9a4444f578cf5a6fd",
        "filename": "doc/build-windows.md",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/doc/build-windows.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/doc/build-windows.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-windows.md?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -5,15 +5,15 @@ Below are some notes on how to build Bitcoin Core for Windows.\n \n The options known to work for building Bitcoin Core on Windows are:\n \n-* On Linux using the [Mingw-w64](https://mingw-w64.org/doku.php) cross compiler tool chain. Ubuntu Bionic 18.04 is required\n+* On Linux, using the [Mingw-w64](https://mingw-w64.org/doku.php) cross compiler tool chain. Ubuntu Bionic 18.04 is required\n and is the platform used to build the Bitcoin Core Windows release binaries.\n-* On Windows using [Windows\n+* On Windows, using [Windows\n Subsystem for Linux (WSL)](https://msdn.microsoft.com/commandline/wsl/about) and the Mingw-w64 cross compiler tool chain.\n \n Other options which may work, but which have not been extensively tested are (please contribute instructions):\n \n-* On Windows using a POSIX compatibility layer application such as [cygwin](http://www.cygwin.com/) or [msys2](http://www.msys2.org/).\n-* On Windows using a native compiler tool chain such as [Visual Studio](https://www.visualstudio.com).\n+* On Windows, using a POSIX compatibility layer application such as [cygwin](http://www.cygwin.com/) or [msys2](http://www.msys2.org/).\n+* On Windows, using a native compiler tool chain such as [Visual Studio](https://www.visualstudio.com).\n \n Installing Windows Subsystem for Linux\n ---------------------------------------\n@@ -69,7 +69,7 @@ See also: [dependencies.md](dependencies.md).\n \n ## Building for 64-bit Windows\n \n-The first step is to install the mingw-w64 cross-compilation tool chain.\n+The first step is to install the mingw-w64 cross-compilation tool chain:\n \n     sudo apt install g++-mingw-w64-x86-64\n \n@@ -81,13 +81,13 @@ Once the toolchain is installed the build steps are common:\n \n Note that for WSL the Bitcoin Core source path MUST be somewhere in the default mount file system, for\n example /usr/src/bitcoin, AND not under /mnt/d/. If this is not the case the dependency autoconf scripts will fail.\n-This means you cannot use a directory that located directly on the host Windows file system to perform the build.\n+This means you cannot use a directory that is located directly on the host Windows file system to perform the build.\n \n Acquire the source in the usual way:\n \n     git clone https://github.com/bitcoin/bitcoin.git\n \n-Once the source code is ready the build steps are below.\n+Once the source code is ready the build steps are below:\n \n     PATH=$(echo \"$PATH\" | sed -e 's/:\\/mnt.*//g') # strip out problematic Windows %PATH% imported var\n     cd depends\n@@ -142,9 +142,9 @@ way. This will install to `c:\\workspace\\bitcoin`, for example:\n Footnotes\n ---------\n \n-<a name=\"footnote1\">1</a>: Starting from Ubuntu Xenial 16.04 both the 32 and 64 bit Mingw-w64 packages install two different\n+<a name=\"footnote1\">1</a>: Starting from Ubuntu Xenial 16.04, both the 32 and 64 bit Mingw-w64 packages install two different\n compiler options to allow a choice between either posix or win32 threads. The default option is win32 threads which is the more\n efficient since it will result in binary code that links directly with the Windows kernel32.lib. Unfortunately, the headers\n-required to support win32 threads conflict with some of the classes in the C++11 standard library in particular std::mutex.\n+required to support win32 threads conflict with some of the classes in the C++11 standard library, in particular std::mutex.\n It's not possible to build the Bitcoin Core code using the win32 version of the Mingw-w64 cross compilers (at least not without\n modifying headers in the Bitcoin Core source code)."
      },
      {
        "sha": "fd5cc782971340c9751efce497f67472920060fe",
        "filename": "doc/developer-notes.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/doc/developer-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/doc/developer-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/developer-notes.md?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -69,7 +69,7 @@ tool to clean up patches automatically before submission.\n - **Symbol naming conventions**. These are preferred in new code, but are not\n required when doing so would need changes to significant pieces of existing\n code.\n-  - Variable and namespace names are all lowercase, and may use `_` to\n+  - Variable (including function arguments) and namespace names are all lowercase, and may use `_` to\n     separate words (snake_case).\n     - Class member variables have a `m_` prefix.\n     - Global variables have a `g_` prefix."
      },
      {
        "sha": "ace56f4d1b44206d6a790151a295a563ed49396e",
        "filename": "doc/release-notes-13152.md",
        "status": "removed",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5473e255f6876ea457a03cbc97844fcf144f79cf/doc/release-notes-13152.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5473e255f6876ea457a03cbc97844fcf144f79cf/doc/release-notes-13152.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-13152.md?ref=5473e255f6876ea457a03cbc97844fcf144f79cf",
        "patch": "@@ -1,5 +0,0 @@\n-New RPC methods\n-------------\n-\n-- `getnodeaddresses` returns peer addresses known to this node. It may be used to connect to nodes over TCP without using the DNS seeds.\n-- `listwalletdir` returns a list of wallets in the wallet directory which is configured with `-walletdir` parameter."
      },
      {
        "sha": "18ea6f26d0e883e24dd8d8433be9f2c2c6d6e899",
        "filename": "doc/release-notes-14023.md",
        "status": "removed",
        "additions": 0,
        "deletions": 8,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5473e255f6876ea457a03cbc97844fcf144f79cf/doc/release-notes-14023.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5473e255f6876ea457a03cbc97844fcf144f79cf/doc/release-notes-14023.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-14023.md?ref=5473e255f6876ea457a03cbc97844fcf144f79cf",
        "patch": "@@ -1,8 +0,0 @@\n-Account API removed\n--------------------\n-\n-The 'account' API was deprecated in v0.17 and has been fully removed in v0.18.\n-The 'label' API was introduced in v0.17 as a replacement for accounts.\n-\n-See the release notes from v0.17 for a full description of the changes from the\n-'account' API to the 'label' API."
      },
      {
        "sha": "2cc5ab49fbf8b4bedc3b4f9cff27f627b5459c3d",
        "filename": "doc/release-notes-14060.md",
        "status": "added",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/doc/release-notes-14060.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/doc/release-notes-14060.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-14060.md?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -0,0 +1,21 @@\n+Configuration\n+-------------\n+\n+The outbound message high water mark of the ZMQ PUB sockets are now\n+configurable via the options:\n+\n+`-zmqpubhashtxhwm=n`\n+\n+`-zmqpubhashblockhwm=n`\n+\n+`-zmqpubrawblockhwm=n`\n+\n+`-zmqpubrawtxhwm=n`\n+\n+Each high water mark value must be an integer greater than or equal to 0.\n+The high water mark limits the maximum number of messages that ZMQ will\n+queue in memory for any single subscriber. A value of 0 means no limit.\n+When not specified, the default value continues to be 1000.\n+When a ZMQ PUB socket reaches its high water mark for a subscriber, then\n+additional messages to the subscriber are dropped until the number of\n+queued messages again falls below the high water mark value."
      },
      {
        "sha": "e6d8e0b70cde42e70bed177566119eb05e314b5f",
        "filename": "doc/release-notes-14282.md",
        "status": "removed",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5473e255f6876ea457a03cbc97844fcf144f79cf/doc/release-notes-14282.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5473e255f6876ea457a03cbc97844fcf144f79cf/doc/release-notes-14282.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-14282.md?ref=5473e255f6876ea457a03cbc97844fcf144f79cf",
        "patch": "@@ -1,6 +0,0 @@\n-Low-level RPC changes\n-----------------------\n-\n-`-usehd` was removed in version 0.16. From that version onwards, all new\n-wallets created are hierarchical deterministic wallets. Version 0.18 makes\n-specifying `-usehd` invalid config."
      },
      {
        "sha": "fb0243aba80a4134b8738f688ae6127cc657a24d",
        "filename": "doc/release-notes-14468.md",
        "status": "removed",
        "additions": 0,
        "deletions": 15,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5473e255f6876ea457a03cbc97844fcf144f79cf/doc/release-notes-14468.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5473e255f6876ea457a03cbc97844fcf144f79cf/doc/release-notes-14468.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-14468.md?ref=5473e255f6876ea457a03cbc97844fcf144f79cf",
        "patch": "@@ -1,15 +0,0 @@\n-Wallet `generate` RPC method deprecated\n----------------------------------------\n-\n-The wallet's `generate` RPC method has been deprecated and will be fully\n-removed in v0.19.\n-\n-`generate` is only used for testing. The RPC call reaches across multiple\n-subsystems (wallet and mining), so is deprecated to simplify the wallet-node\n-interface. Projects that are using `generate` for testing purposes should\n-transition to using the `generatetoaddress` call, which does not require or use\n-the wallet component. Calling `generatetoaddress` with an address returned by\n-`getnewaddress` gives the same functionality as the old `generate` method.\n-\n-To continue using `generate` in v0.18, restart bitcoind with the\n-`-deprecatedrpc=generate` configuration."
      },
      {
        "sha": "75faad99060f59fcb33a7f8fd0696a1c98d5363f",
        "filename": "doc/release-notes-pr13381.md",
        "status": "added",
        "additions": 29,
        "deletions": 0,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/doc/release-notes-pr13381.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/doc/release-notes-pr13381.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-pr13381.md?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -0,0 +1,29 @@\n+RPC importprivkey: new label behavior\n+-------------------------------------\n+\n+Previously, `importprivkey` automatically added the default empty label\n+(\"\") to all addresses associated with the imported private key.  Now it\n+defaults to using any existing label for those addresses.  For example:\n+\n+- Old behavior: you import a watch-only address with the label \"cold\n+  wallet\".  Later, you import the corresponding private key using the\n+  default settings.  The address's label is changed from \"cold wallet\"\n+  to \"\".\n+\n+- New behavior: you import a watch-only address with the label \"cold\n+  wallet\".  Later, you import the corresponding private key using the\n+  default settings.  The address's label remains \"cold wallet\".\n+\n+In both the previous and current case, if you directly specify a label\n+during the import, that label will override whatever previous label the\n+addresses may have had.  Also in both cases, if none of the addresses\n+previously had a label, they will still receive the default empty label\n+(\"\").  Examples:\n+\n+- You import a watch-only address with the label \"temporary\".  Later you\n+  import the corresponding private key with the label \"final\".  The\n+  address's label will be changed to \"final\".\n+\n+- You use the default settings to import a private key for an address that\n+  was not previously in the wallet.  Its addresses will receive the default\n+  empty label (\"\")."
      },
      {
        "sha": "f5c139e3f142b195b778c15de21648ca5f76d8de",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 137,
        "deletions": 3,
        "changes": 140,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -53,8 +53,14 @@ the Linux kernel, macOS 10.10+, and Windows 7 and newer (Windows XP is not suppo\n Bitcoin Core should also work on most other Unix-like systems but is not\n frequently tested on them.\n \n-From 0.17.0 onwards macOS <10.10 is no longer supported. 0.17.0 is built using Qt 5.9.x, which doesn't\n-support versions of macOS older than 10.10.\n+From 0.17.0 onwards, macOS <10.10 is no longer supported.  0.17.0 is\n+built using Qt 5.9.x, which doesn't support versions of macOS older than\n+10.10.  Additionally, Bitcoin Core does not yet change appearance when\n+macOS \"dark mode\" is activated.\n+\n+In addition to previously-supported CPU platforms, this release's\n+pre-compiled distribution also provides binaries for the RISC-V\n+platform.\n \n Notable changes\n ===============\n@@ -69,9 +75,137 @@ nodes. The option will now by default be off for improved privacy and security\n as well as reduced upload usage. The option can explicitly be turned on for\n local-network debugging purposes.\n \n-Example item\n+Documentation\n+-------------\n+\n+- A new short\n+  [document](https://github.com/bitcoin/bitcoin/blob/master/doc/JSON-RPC-interface.md)\n+  about the JSON-RPC interface describes cases where the results of an\n+  RPC might contain inconsistencies between data sourced from different\n+  subsystems, such as wallet state and mempool state.  A note is added\n+  to the [REST interface documentation](https://github.com/bitcoin/bitcoin/blob/master/doc/REST-interface.md)\n+  indicating that the same rules apply.\n+\n+- A new [document](https://github.com/bitcoin/bitcoin/blob/master/doc/bitcoin-conf.md)\n+  about the `bitcoin.conf` file describes how to use it to configure\n+  Bitcoin Core.\n+\n+- A new document introduces Bitcoin Core's BIP174\n+  [Partially-Signed Bitcoin Transactions (PSBT)](https://github.com/bitcoin/bitcoin/blob/master/doc/psbt.md)\n+  interface, which is used to allow multiple programs to collaboratively\n+  work to create, sign, and broadcast new transactions.  This is useful\n+  for offline (cold storage) wallets, multisig wallets, coinjoin\n+  implementations, and many other cases where two or more programs need\n+  to interact to generate a complete transaction.\n+\n+- The [output script descriptor](https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md)\n+  documentation has been updated with information about new features in\n+  this still-developing language for describing the output scripts that\n+  a wallet or other program wants to receive notifications for, such as\n+  which addresses it wants to know received payments.  The language is\n+  currently used in the `scantxoutset` RPC and is expected to be adapted\n+  to other RPCs and to the underlying wallet structure.\n+\n+Build system changes\n+--------------------\n+\n+- A new `--disable-bip70` option may be passed to `./configure` to\n+  prevent Bitcoin-Qt from being built with support for the BIP70 payment\n+  protocol or from linking libssl.  As the payment protocol has exposed\n+  Bitcoin Core to libssl vulnerabilities in the past, builders who don't\n+  need BIP70 support are encouraged to use this option to reduce their\n+  exposure to future vulnerabilities.\n+\n+Deprecated or removed RPCs\n+--------------------------\n+\n+- The `signrawtransaction` RPC is removed after being deprecated and\n+  hidden behind a special configuration option in version 0.17.0.\n+\n+- The 'account' API is removed after being deprecated in v0.17.  The\n+  'label' API was introduced in v0.17 as a replacement for accounts.\n+  See the [release notes from v0.17](https://github.com/bitcoin/bitcoin/blob/master/doc/release-notes/release-notes-0.17.0.md#label-and-account-apis-for-wallet)\n+  for a full description of the changes from the 'account' API to the\n+  'label' API.\n+\n+- The `addwitnessaddress` RPC is removed after being deprecated in\n+  version 0.13.0.\n+\n+- The wallet's `generate` RPC method is deprecated and will be fully\n+  removed in a subsequent major version.  This RPC is only used for\n+  testing, but its implementation reached across multiple subsystems\n+  (wallet and mining), so it is being deprecated to simplify the\n+  wallet-node interface.  Projects that are using `generate` for testing\n+  purposes should transition to using the `generatetoaddress` RPC, which\n+  does not require or use the wallet component. Calling\n+  `generatetoaddress` with an address returned by the `getnewaddress`\n+  RPC gives the same functionality as the old `generate` RPC.  To\n+  continue using `generate` in this version, restart bitcoind with the\n+  `-deprecatedrpc=generate` configuration option.\n+\n+New RPCs\n+--------\n+\n+- A new `getnodeaddresses` RPC returns peer addresses known to this\n+  node. It may be used to find nodes to connect to without using a DNS\n+  seeder.\n+\n+- A new `listwalletdir` RPC returns a list of wallets in the wallet\n+  directory (either the default wallet directory or the directory\n+  configured by the `-walletdir` parameter).\n+\n+Updated RPCs\n ------------\n \n+Note: some low-level RPC changes mainly useful for testing are described\n+in the Low-level Changes section below.\n+\n+- The `getpeerinfo` RPC now returns an additional \"minfeefilter\" field\n+  set to the peer's BIP133 fee filter.  You can use this to detect that\n+  you have peers that are willing to accept transactions below the\n+  default minimum relay fee.\n+\n+- The mempool RPCs, such as `getrawmempool` with `verbose=true`, now\n+  return an additional \"bip125-replaceable\" value indicating whether the\n+  transaction (or its unconfirmed ancestors) opts-in to asking nodes and\n+  miners to replace it with a higher-feerate transaction spending any of\n+  the same inputs.\n+\n+- The `settxfee` RPC previously silently ignored attempts to set the fee\n+  below the allowed minimums.  It now prints a warning.  The special\n+  value of \"0\" may still be used to request the minimum value.\n+\n+- The `getaddressinfo` RPC now provides an `ischange` field indicating\n+  whether the wallet used the address in a change output.\n+\n+- The `importmulti` RPC has been updated to support P2WSH, P2WPKH,\n+  P2SH-P2WPKH, and P2SH-P2WSH. Requests for P2WSH and P2SH-P2WSH accept\n+  an additional `witnessscript` parameter.\n+\n+Low-level changes\n+=================\n+\n+RPC\n+---\n+\n+- The `submitblock` RPC previously returned the reason a rejected block\n+  was invalid the first time it processed that block but returned a\n+  generic \"duplicate\" rejection message on subsequent occasions it\n+  processed the same block.  It now always returns the fundamental\n+  reason for rejecting an invalid block and only returns \"duplicate\" for\n+  valid blocks it has already accepted.\n+\n+- A new `submitheader` RPC allows submitting block headers independently\n+  from their block.  This is likely only useful for testing.\n+\n+Configuration\n+-------------\n+\n+- The `-usehd` configuration option was removed in version 0.16. From\n+  that version onwards, all new wallets created are hierarchical\n+  deterministic wallets. This release makes specifying `-usehd` an\n+  invalid configuration option.\n+\n Credits\n =======\n "
      },
      {
        "sha": "92db7dac7d7e55ada749f50c2c5737b3ee50ff0e",
        "filename": "doc/release-notes/release-notes-0.17.0.1.md",
        "status": "added",
        "additions": 41,
        "deletions": 0,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/doc/release-notes/release-notes-0.17.0.1.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/doc/release-notes/release-notes-0.17.0.1.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.17.0.1.md?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -0,0 +1,41 @@\n+Bitcoin Core version 0.17.0.1 is now available from:\n+\n+  <https://bitcoincore.org/bin/bitcoin-core-0.17.0.1/>\n+\n+This release provides a minor bug fix for 0.17.0.\n+\n+Please report bugs using the issue tracker at GitHub:\n+\n+  <https://github.com/bitcoin/bitcoin/issues>\n+\n+To receive security and update notifications, please subscribe to:\n+\n+  <https://bitcoincore.org/en/list/announcements/join/>\n+\n+Notable changes\n+===============\n+\n+An issue was solved with OSX dmg generation, affecting macOS 10.12 to 10.14,\n+which could cause Finder to crash on install.\n+\n+There are no significant changes for other operating systems.\n+\n+0.17.0.1 change log\n+===================\n+\n+### Build system\n+- #14416 `eb2cc84` Fix OSX dmg issue (10.12 to 10.14) (jonasschnelli)\n+\n+### Documentation\n+- #14509 `1b5af2c` [0.17] doc: use SegWit in getblocktemplate example (Sjors)\n+\n+Credits\n+=======\n+\n+Thanks to everyone who directly contributed to this release:\n+\n+- Jonas Schnelli\n+- Pieter Wuille\n+- Sjors Provoost\n+- Wladimir J. van der Laan\n+"
      },
      {
        "sha": "7ffc5623b63abcd3f205e308628305994fed7bcc",
        "filename": "doc/zmq.md",
        "status": "modified",
        "additions": 12,
        "deletions": 1,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/doc/zmq.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/doc/zmq.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/zmq.md?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -66,10 +66,21 @@ Currently, the following notifications are supported:\n The socket type is PUB and the address must be a valid ZeroMQ socket\n address. The same address can be used in more than one notification.\n \n+The option to set the PUB socket's outbound message high water mark\n+(SNDHWM) may be set individually for each notification:\n+\n+    -zmqpubhashtxhwm=n\n+    -zmqpubhashblockhwm=n\n+    -zmqpubrawblockhwm=n\n+    -zmqpubrawtxhwm=n\n+\n+The high water mark value must be an integer greater than or equal to 0.\n+\n For instance:\n \n     $ bitcoind -zmqpubhashtx=tcp://127.0.0.1:28332 \\\n-               -zmqpubrawtx=ipc:///tmp/bitcoind.tx.raw\n+               -zmqpubrawtx=ipc:///tmp/bitcoind.tx.raw \\\n+               -zmqpubhashtxhwm=10000\n \n Each PUB notification has a topic and body, where the header\n corresponds to the notification type. For instance, for the"
      },
      {
        "sha": "6062d49c4064dcb3f8d1a7273267ad299d170e0c",
        "filename": "share/examples/bitcoin.conf",
        "status": "modified",
        "additions": 7,
        "deletions": 10,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/share/examples/bitcoin.conf",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/share/examples/bitcoin.conf",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/examples/bitcoin.conf?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -71,12 +71,9 @@\n # is .cookie and found in the `-datadir` being used for bitcoind. This option is typically used\n # when the server and client are run as the same user.\n #\n-# If not, you must set rpcuser and rpcpassword to secure the JSON-RPC api. The first\n-# method(DEPRECATED) is to set this pair for the server and client:\n-#rpcuser=Ulysseys\n-#rpcpassword=YourSuperGreatPasswordNumber_DO_NOT_USE_THIS_OR_YOU_WILL_GET_ROBBED_385593\n+# If not, you must set rpcuser and rpcpassword to secure the JSON-RPC API.\n #\n-# The second method `rpcauth` can be added to server startup argument. It is set at initialization time\n+# The config option `rpcauth` can be added to server startup argument. It is set at initialization time\n # using the output from the script in share/rpcauth/rpcauth.py after providing a username:\n #\n # ./share/rpcauth/rpcauth.py alice\n@@ -116,21 +113,21 @@\n # running on another host using this option:\n #rpcconnect=127.0.0.1\n \n+# Wallet options\n+\n # Create transactions that have enough fees so they are likely to begin confirmation within n blocks (default: 6).\n # This setting is over-ridden by the -paytxfee option.\n #txconfirmtarget=n\n \n+# Pay a transaction fee every time you send bitcoins.\n+#paytxfee=0.000x\n+\n # Miscellaneous options\n \n # Pre-generate this many public/private key pairs, so wallet backups will be valid for\n # both prior transactions and several dozen future transactions.\n #keypool=100\n \n-# Pay an optional transaction fee every time you send bitcoins.  Transactions with fees\n-# are more likely than free transactions to be included in generated blocks, so may\n-# be validated sooner.\n-#paytxfee=0.00\n-\n # Enable pruning to reduce storage requirements by deleting old blocks. \n # This mode is incompatible with -txindex and -rescan.\n # 0 = default (no pruning)."
      },
      {
        "sha": "abe605efd0a3278efd6da2017bc13b85ff3722df",
        "filename": "share/qt/Info.plist.in",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/share/qt/Info.plist.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/share/qt/Info.plist.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/qt/Info.plist.in?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -97,7 +97,7 @@\n   <key>NSHighResolutionCapable</key>\n     <string>True</string>\n \n-  <key>LSAppNapIsDisabled</key>\n+  <key>NSRequiresAquaSystemAppearance</key>\n     <string>True</string>\n   \n   <key>LSApplicationCategoryType</key>"
      },
      {
        "sha": "6542370f97e77f0b523ff0e50e62c18a5061bd64",
        "filename": "share/setup.nsi.in",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/share/setup.nsi.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/share/setup.nsi.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/setup.nsi.in?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -80,6 +80,7 @@ Section -Main SEC0000\n     SetOutPath $INSTDIR\\daemon\n     File @abs_top_srcdir@/release/@BITCOIN_DAEMON_NAME@@EXEEXT@\n     File @abs_top_srcdir@/release/@BITCOIN_CLI_NAME@@EXEEXT@\n+    File @abs_top_srcdir@/release/@BITCOIN_TX_NAME@@EXEEXT@\n     SetOutPath $INSTDIR\\doc\n     File /r /x Makefile* @abs_top_srcdir@/doc\\*.*\n     SetOutPath $INSTDIR"
      },
      {
        "sha": "8dd0d31839e6ab963014bb0bb1e136eaabc5a3f5",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 20,
        "deletions": 11,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -125,6 +125,7 @@ BITCOIN_CORE_H = \\\n   index/txindex.h \\\n   indirectmap.h \\\n   init.h \\\n+  interfaces/chain.h \\\n   interfaces/handler.h \\\n   interfaces/node.h \\\n   interfaces/wallet.h \\\n@@ -183,10 +184,11 @@ BITCOIN_CORE_H = \\\n   txmempool.h \\\n   ui_interface.h \\\n   undo.h \\\n-  util.h \\\n-  utilmemory.h \\\n-  utilmoneystr.h \\\n-  utiltime.h \\\n+  util/bytevectorhash.h \\\n+  util/system.h \\\n+  util/memory.h \\\n+  util/moneystr.h \\\n+  util/time.h \\\n   validation.h \\\n   validationinterface.h \\\n   versionbits.h \\\n@@ -232,6 +234,7 @@ libbitcoin_server_a_SOURCES = \\\n   httpserver.cpp \\\n   index/base.cpp \\\n   index/txindex.cpp \\\n+  interfaces/chain.cpp \\\n   interfaces/handler.cpp \\\n   interfaces/node.cpp \\\n   init.cpp \\\n@@ -321,7 +324,9 @@ crypto_libbitcoin_crypto_base_a_SOURCES = \\\n   crypto/sha256.cpp \\\n   crypto/sha256.h \\\n   crypto/sha512.cpp \\\n-  crypto/sha512.h\n+  crypto/sha512.h \\\n+  crypto/siphash.cpp \\\n+  crypto/siphash.h\n \n if USE_ASM\n crypto_libbitcoin_crypto_base_a_SOURCES += crypto/sha256_sse4.cpp\n@@ -377,8 +382,8 @@ libbitcoin_consensus_a_SOURCES = \\\n   tinyformat.h \\\n   uint256.cpp \\\n   uint256.h \\\n-  utilstrencodings.cpp \\\n-  utilstrencodings.h \\\n+  util/strencodings.cpp \\\n+  util/strencodings.h \\\n   version.h\n \n # common: shared between bitcoind, and bitcoin-qt and non-server tools\n@@ -427,10 +432,11 @@ libbitcoin_util_a_SOURCES = \\\n   support/cleanse.cpp \\\n   sync.cpp \\\n   threadinterrupt.cpp \\\n-  util.cpp \\\n-  utilmoneystr.cpp \\\n-  utilstrencodings.cpp \\\n-  utiltime.cpp \\\n+  util/bytevectorhash.cpp \\\n+  util/system.cpp \\\n+  util/moneystr.cpp \\\n+  util/strencodings.cpp \\\n+  util/time.cpp \\\n   $(BITCOIN_CORE_H)\n \n if GLIBC_BACK_COMPAT\n@@ -461,6 +467,7 @@ endif\n bitcoind_LDADD = \\\n   $(LIBBITCOIN_SERVER) \\\n   $(LIBBITCOIN_WALLET) \\\n+  $(LIBBITCOIN_SERVER) \\\n   $(LIBBITCOIN_COMMON) \\\n   $(LIBUNIVALUE) \\\n   $(LIBBITCOIN_UTIL) \\\n@@ -587,9 +594,11 @@ if HARDEN\n \t$(AM_V_at) READELF=$(READELF) OBJDUMP=$(OBJDUMP) $(top_srcdir)/contrib/devtools/security-check.py < $(bin_PROGRAMS)\n endif\n \n+if ENABLE_BIP70\n %.pb.cc %.pb.h: %.proto\n \t@test -f $(PROTOC)\n \t$(AM_V_GEN) $(PROTOC) --cpp_out=$(@D) --proto_path=$(<D) $<\n+endif\n \n if EMBEDDED_LEVELDB\n include Makefile.leveldb.include"
      },
      {
        "sha": "445849e3d81eedcb4305a69857dfdea0afc0684c",
        "filename": "src/Makefile.qt.include",
        "status": "modified",
        "additions": 25,
        "deletions": 4,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/Makefile.qt.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/Makefile.qt.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qt.include?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -162,7 +162,8 @@ QT_MOC_CPP = \\\n \n BITCOIN_MM = \\\n   qt/macdockiconhandler.mm \\\n-  qt/macnotificationhandler.mm\n+  qt/macnotificationhandler.mm \\\n+  qt/macos_appnap.mm\n \n QT_MOC = \\\n   qt/bitcoin.moc \\\n@@ -176,9 +177,15 @@ QT_QRC = qt/bitcoin.qrc\n QT_QRC_LOCALE_CPP = qt/qrc_bitcoin_locale.cpp\n QT_QRC_LOCALE = qt/bitcoin_locale.qrc\n \n+if ENABLE_BIP70\n PROTOBUF_CC = qt/paymentrequest.pb.cc\n PROTOBUF_H = qt/paymentrequest.pb.h\n PROTOBUF_PROTO = qt/paymentrequest.proto\n+else\n+PROTOBUF_CC =\n+PROTOBUF_H =\n+PROTOBUF_PROTO =\n+endif\n \n BITCOIN_QT_H = \\\n   qt/addressbookpage.h \\\n@@ -199,6 +206,7 @@ BITCOIN_QT_H = \\\n   qt/intro.h \\\n   qt/macdockiconhandler.h \\\n   qt/macnotificationhandler.h \\\n+  qt/macos_appnap.h \\\n   qt/modaloverlay.h \\\n   qt/networkstyle.h \\\n   qt/notificator.h \\\n@@ -327,7 +335,6 @@ BITCOIN_QT_WALLET_CPP = \\\n   qt/editaddressdialog.cpp \\\n   qt/openuridialog.cpp \\\n   qt/overviewpage.cpp \\\n-  qt/paymentrequestplus.cpp \\\n   qt/paymentserver.cpp \\\n   qt/receivecoinsdialog.cpp \\\n   qt/receiverequestdialog.cpp \\\n@@ -346,13 +353,19 @@ BITCOIN_QT_WALLET_CPP = \\\n   qt/walletmodeltransaction.cpp \\\n   qt/walletview.cpp\n \n+BITCOIN_QT_WALLET_BIP70_CPP = \\\n+  qt/paymentrequestplus.cpp\n+\n BITCOIN_QT_CPP = $(BITCOIN_QT_BASE_CPP)\n if TARGET_WINDOWS\n BITCOIN_QT_CPP += $(BITCOIN_QT_WINDOWS_CPP)\n endif\n if ENABLE_WALLET\n BITCOIN_QT_CPP += $(BITCOIN_QT_WALLET_CPP)\n-endif\n+if ENABLE_BIP70\n+BITCOIN_QT_CPP += $(BITCOIN_QT_WALLET_BIP70_CPP)\n+endif # ENABLE_BIP70\n+endif # ENABLE_WALLET\n \n RES_IMAGES =\n \n@@ -406,8 +419,16 @@ if ENABLE_ZMQ\n qt_bitcoin_qt_LDADD += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)\n endif\n qt_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) $(LIBLEVELDB_SSE42) $(LIBMEMENV) \\\n-  $(BOOST_LIBS) $(QT_LIBS) $(QT_DBUS_LIBS) $(QR_LIBS) $(PROTOBUF_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(LIBSECP256K1) \\\n+  $(BOOST_LIBS) $(QT_LIBS) $(QT_DBUS_LIBS) $(QR_LIBS) $(PROTOBUF_LIBS) $(BDB_LIBS) $(MINIUPNPC_LIBS) $(LIBSECP256K1) \\\n   $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS)\n+if ENABLE_BIP70\n+qt_bitcoin_qt_LDADD += $(SSL_LIBS)\n+else\n+if TARGET_WINDOWS\n+qt_bitcoin_qt_LDADD += $(SSL_LIBS)\n+endif\n+endif\n+qt_bitcoin_qt_LDADD += $(CRYPTO_LIBS)\n qt_bitcoin_qt_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(QT_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n qt_bitcoin_qt_LIBTOOLFLAGS = $(AM_LIBTOOLFLAGS) --tag CXX\n "
      },
      {
        "sha": "db7873e8b75952efdf11cda81ca66c7f75e08824",
        "filename": "src/Makefile.qttest.include",
        "status": "modified",
        "additions": 10,
        "deletions": 4,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/Makefile.qttest.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/Makefile.qttest.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qttest.include?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -13,9 +13,12 @@ TEST_QT_MOC_CPP = \\\n if ENABLE_WALLET\n TEST_QT_MOC_CPP += \\\n   qt/test/moc_addressbooktests.cpp \\\n-  qt/test/moc_paymentservertests.cpp \\\n   qt/test/moc_wallettests.cpp\n-endif\n+if ENABLE_BIP70\n+TEST_QT_MOC_CPP += \\\n+  qt/test/moc_paymentservertests.cpp\n+endif # ENABLE_BIP70\n+endif # ENABLE_WALLET\n \n TEST_QT_H = \\\n   qt/test/addressbooktests.h \\\n@@ -48,10 +51,13 @@ qt_test_test_bitcoin_qt_SOURCES = \\\n if ENABLE_WALLET\n qt_test_test_bitcoin_qt_SOURCES += \\\n   qt/test/addressbooktests.cpp \\\n-  qt/test/paymentservertests.cpp \\\n   qt/test/wallettests.cpp \\\n   wallet/test/wallet_test_fixture.cpp\n-endif\n+if ENABLE_BIP70\n+qt_test_test_bitcoin_qt_SOURCES += \\\n+  qt/test/paymentservertests.cpp\n+endif # ENABLE_BIP70\n+endif # ENABLE_WALLET\n \n nodist_qt_test_test_bitcoin_qt_SOURCES = $(TEST_QT_MOC_CPP)\n "
      },
      {
        "sha": "a31852c94f69fd6b36fa30d3768e799cd1c6e0df",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -169,7 +169,15 @@ CLEAN_BITCOIN_TEST = test/*.gcda test/*.gcno $(GENERATED_TEST_FILES) $(BITCOIN_T\n \n CLEANFILES += $(CLEAN_BITCOIN_TEST)\n \n+if TARGET_WINDOWS\n bitcoin_test: $(TEST_BINARY)\n+else\n+if ENABLE_BENCH\n+bitcoin_test: $(TEST_BINARY) $(BENCH_BINARY)\n+else\n+bitcoin_test: $(TEST_BINARY)\n+endif\n+endif\n \n bitcoin_test_check: $(TEST_BINARY) FORCE\n \t$(MAKE) check-TESTS TESTS=$^\n@@ -184,6 +192,13 @@ if BUILD_BITCOIN_TX\n endif\n \t@echo \"Running test/util/rpcauth-test.py...\"\n \t$(PYTHON) $(top_builddir)/test/util/rpcauth-test.py\n+if TARGET_WINDOWS\n+else\n+if ENABLE_BENCH\n+\t@echo \"Running bench/bench_bitcoin -evals=1 -scaling=0...\"\n+\t$(BENCH_BINARY) -evals=1 -scaling=0 > /dev/null\n+endif\n+endif\n \t$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C secp256k1 check\n if EMBEDDED_UNIVALUE\n \t$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C univalue check"
      },
      {
        "sha": "1590bce074dde76d0e399760494f1507adfd5217",
        "filename": "src/addrdb.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/addrdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/addrdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -12,7 +12,7 @@\n #include <random.h>\n #include <streams.h>\n #include <tinyformat.h>\n-#include <util.h>\n+#include <util/system.h>\n \n namespace {\n "
      },
      {
        "sha": "b97feb6f086fe98db2797e15724b9b275bf12f41",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -11,7 +11,7 @@\n #include <random.h>\n #include <sync.h>\n #include <timedata.h>\n-#include <util.h>\n+#include <util/system.h>\n \n #include <map>\n #include <set>"
      },
      {
        "sha": "aa66d131021c875a9092650bfc1c4f8a99a7a15f",
        "filename": "src/arith_uint256.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/arith_uint256.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/arith_uint256.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/arith_uint256.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -6,7 +6,7 @@\n #include <arith_uint256.h>\n \n #include <uint256.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n #include <crypto/common.h>\n \n #include <stdio.h>"
      },
      {
        "sha": "e3d28533999b4928b6e706fb6131222b4deb553e",
        "filename": "src/base58.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/base58.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/base58.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -6,6 +6,7 @@\n \n #include <hash.h>\n #include <uint256.h>\n+#include <util/strencodings.h>\n \n #include <assert.h>\n #include <string.h>\n@@ -34,7 +35,7 @@ static const int8_t mapBase58[256] = {\n bool DecodeBase58(const char* psz, std::vector<unsigned char>& vch)\n {\n     // Skip leading spaces.\n-    while (*psz && isspace(*psz))\n+    while (*psz && IsSpace(*psz))\n         psz++;\n     // Skip and count leading '1's.\n     int zeroes = 0;\n@@ -48,7 +49,7 @@ bool DecodeBase58(const char* psz, std::vector<unsigned char>& vch)\n     std::vector<unsigned char> b256(size);\n     // Process the characters.\n     static_assert(sizeof(mapBase58)/sizeof(mapBase58[0]) == 256, \"mapBase58.size() should be 256\"); // guarantee not out of range\n-    while (*psz && !isspace(*psz)) {\n+    while (*psz && !IsSpace(*psz)) {\n         // Decode base58 character\n         int carry = mapBase58[(uint8_t)*psz];\n         if (carry == -1)  // Invalid b58 character\n@@ -64,7 +65,7 @@ bool DecodeBase58(const char* psz, std::vector<unsigned char>& vch)\n         psz++;\n     }\n     // Skip trailing spaces.\n-    while (isspace(*psz))\n+    while (IsSpace(*psz))\n         psz++;\n     if (*psz != 0)\n         return false;"
      },
      {
        "sha": "3c4b453a23aeffb863a65817ad3c5ca9486ea7bb",
        "filename": "src/bench/bech32.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/bench/bech32.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/bench/bech32.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bech32.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -6,7 +6,7 @@\n \n #include <validation.h>\n #include <bech32.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n \n #include <vector>\n #include <string>"
      },
      {
        "sha": "32faba86b47aaf6489e811116241249a3fe8a78b",
        "filename": "src/bench/bench_bitcoin.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/bench/bench_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/bench/bench_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench_bitcoin.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -7,8 +7,8 @@\n #include <crypto/sha256.h>\n #include <key.h>\n #include <random.h>\n-#include <util.h>\n-#include <utilstrencodings.h>\n+#include <util/system.h>\n+#include <util/strencodings.h>\n #include <validation.h>\n \n #include <memory>"
      },
      {
        "sha": "2def0b23e2e83460d989861681bd834da26eb24b",
        "filename": "src/bench/block_assemble.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/bench/block_assemble.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/bench/block_assemble.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/block_assemble.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -7,13 +7,14 @@\n #include <coins.h>\n #include <consensus/merkle.h>\n #include <consensus/validation.h>\n+#include <crypto/sha256.h>\n #include <miner.h>\n #include <policy/policy.h>\n #include <pow.h>\n #include <scheduler.h>\n #include <txdb.h>\n #include <txmempool.h>\n-#include <utiltime.h>\n+#include <util/time.h>\n #include <validation.h>\n #include <validationinterface.h>\n "
      },
      {
        "sha": "6ab542067aac3d6bc24eccf72acad1a5e15a6b38",
        "filename": "src/bench/checkqueue.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/bench/checkqueue.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/bench/checkqueue.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkqueue.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -3,7 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <bench/bench.h>\n-#include <util.h>\n+#include <util/system.h>\n #include <validation.h>\n #include <checkqueue.h>\n #include <prevector.h>"
      },
      {
        "sha": "8552ed34fd83d20cd436c859f3c78c5e61996f7b",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -3,6 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <bench/bench.h>\n+#include <interfaces/chain.h>\n #include <wallet/wallet.h>\n #include <wallet/coinselection.h>\n \n@@ -33,7 +34,8 @@ static void addCoin(const CAmount& nValue, const CWallet& wallet, std::vector<Ou\n // (https://github.com/bitcoin/bitcoin/issues/7883#issuecomment-224807484)\n static void CoinSelection(benchmark::State& state)\n {\n-    const CWallet wallet(\"dummy\", WalletDatabase::CreateDummy());\n+    auto chain = interfaces::MakeChain();\n+    const CWallet wallet(*chain, WalletLocation(), WalletDatabase::CreateDummy());\n     LOCK(wallet.cs_wallet);\n \n     // Add coins.\n@@ -57,7 +59,8 @@ static void CoinSelection(benchmark::State& state)\n }\n \n typedef std::set<CInputCoin> CoinSet;\n-static const CWallet testWallet(\"dummy\", WalletDatabase::CreateDummy());\n+static auto testChain = interfaces::MakeChain();\n+static const CWallet testWallet(*testChain, WalletLocation(), WalletDatabase::CreateDummy());\n std::vector<std::unique_ptr<CWalletTx>> wtxn;\n \n // Copied from src/wallet/test/coinselector_tests.cpp"
      },
      {
        "sha": "dc0b05442027921e1968ecc1775c24520f623172",
        "filename": "src/bench/crypto_hash.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/bench/crypto_hash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/bench/crypto_hash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/crypto_hash.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -9,11 +9,12 @@\n #include <hash.h>\n #include <random.h>\n #include <uint256.h>\n-#include <utiltime.h>\n+#include <util/time.h>\n #include <crypto/ripemd160.h>\n #include <crypto/sha1.h>\n #include <crypto/sha256.h>\n #include <crypto/sha512.h>\n+#include <crypto/siphash.h>\n \n /* Number of bytes to hash per iteration */\n static const uint64_t BUFFER_SIZE = 1000*1000;"
      },
      {
        "sha": "e7ddd5a938ddbd603c8ba623e5be0722b93935e3",
        "filename": "src/bench/examples.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/bench/examples.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/bench/examples.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/examples.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -4,7 +4,7 @@\n \n #include <bench/bench.h>\n #include <validation.h>\n-#include <utiltime.h>\n+#include <util/time.h>\n \n // Sanity test: this should loop ten times, and\n // min/max/average should be close to 100ms."
      },
      {
        "sha": "dc1b46faf12655c75bdc2ee0e2a876baf12e4580",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -12,8 +12,8 @@\n #include <fs.h>\n #include <rpc/client.h>\n #include <rpc/protocol.h>\n-#include <util.h>\n-#include <utilstrencodings.h>\n+#include <util/system.h>\n+#include <util/strencodings.h>\n \n #include <memory>\n #include <stdio.h>"
      },
      {
        "sha": "bc91ca36417686a48f6ea0651e8c40aef2ec1cd2",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -18,9 +18,9 @@\n #include <script/script.h>\n #include <script/sign.h>\n #include <univalue.h>\n-#include <util.h>\n-#include <utilmoneystr.h>\n-#include <utilstrencodings.h>\n+#include <util/system.h>\n+#include <util/moneystr.h>\n+#include <util/strencodings.h>\n \n #include <memory>\n #include <stdio.h>\n@@ -255,7 +255,7 @@ static void MutateTxAddInput(CMutableTransaction& tx, const std::string& strInpu\n         throw std::runtime_error(\"invalid TX input vout '\" + strVout + \"'\");\n \n     // extract the optional sequence number\n-    uint32_t nSequenceIn=std::numeric_limits<unsigned int>::max();\n+    uint32_t nSequenceIn = CTxIn::SEQUENCE_FINAL;\n     if (vStrInputParts.size() > 2)\n         nSequenceIn = std::stoul(vStrInputParts[2]);\n "
      },
      {
        "sha": "1306ba3821fde8bd80c1e6974544bd1e163a1b0d",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 4,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -11,14 +11,15 @@\n #include <clientversion.h>\n #include <compat.h>\n #include <fs.h>\n+#include <interfaces/chain.h>\n #include <rpc/server.h>\n #include <init.h>\n #include <noui.h>\n #include <shutdown.h>\n-#include <util.h>\n+#include <util/system.h>\n #include <httpserver.h>\n #include <httprpc.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n #include <walletinitinterface.h>\n \n #include <stdio.h>\n@@ -58,6 +59,9 @@ static void WaitForShutdown()\n //\n static bool AppInit(int argc, char* argv[])\n {\n+    InitInterfaces interfaces;\n+    interfaces.chain = interfaces::MakeChain();\n+\n     bool fRet = false;\n \n     //\n@@ -164,7 +168,7 @@ static bool AppInit(int argc, char* argv[])\n             // If locking the data directory failed, exit immediately\n             return false;\n         }\n-        fRet = AppInitMain();\n+        fRet = AppInitMain(interfaces);\n     }\n     catch (const std::exception& e) {\n         PrintExceptionContinue(&e, \"AppInit()\");\n@@ -178,7 +182,7 @@ static bool AppInit(int argc, char* argv[])\n     } else {\n         WaitForShutdown();\n     }\n-    Shutdown();\n+    Shutdown(interfaces);\n \n     return fRet;\n }"
      },
      {
        "sha": "10f51931f08ff6ebdc29138433baa7e17888cb07",
        "filename": "src/blockencodings.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/blockencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/blockencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockencodings.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -6,12 +6,13 @@\n #include <consensus/consensus.h>\n #include <consensus/validation.h>\n #include <chainparams.h>\n-#include <hash.h>\n+#include <crypto/sha256.h>\n+#include <crypto/siphash.h>\n #include <random.h>\n #include <streams.h>\n #include <txmempool.h>\n #include <validation.h>\n-#include <util.h>\n+#include <util/system.h>\n \n #include <unordered_map>\n "
      },
      {
        "sha": "163e2a52eff5f6779e76feb379fd420098d6be26",
        "filename": "src/blockfilter.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/blockfilter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/blockfilter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockfilter.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -3,6 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <blockfilter.h>\n+#include <crypto/siphash.h>\n #include <hash.h>\n #include <primitives/transaction.h>\n #include <script/script.h>"
      },
      {
        "sha": "871be11769afa56d52cf324c6b0aa8f71f85b827",
        "filename": "src/blockfilter.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/blockfilter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/blockfilter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockfilter.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -5,14 +5,15 @@\n #ifndef BITCOIN_BLOCKFILTER_H\n #define BITCOIN_BLOCKFILTER_H\n \n-#include <set>\n #include <stdint.h>\n+#include <unordered_set>\n #include <vector>\n \n #include <primitives/block.h>\n #include <serialize.h>\n #include <uint256.h>\n #include <undo.h>\n+#include <util/bytevectorhash.h>\n \n /**\n  * This implements a Golomb-coded set as defined in BIP 158. It is a\n@@ -22,7 +23,7 @@ class GCSFilter\n {\n public:\n     typedef std::vector<unsigned char> Element;\n-    typedef std::set<Element> ElementSet;\n+    typedef std::unordered_set<Element, ByteVectorHash> ElementSet;\n \n private:\n     uint64_t m_siphash_k0;"
      },
      {
        "sha": "4ce1b538804a2997d0f97d2edf6d3f96990d7393",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -8,8 +8,8 @@\n #include <chainparamsseeds.h>\n #include <consensus/merkle.h>\n #include <tinyformat.h>\n-#include <util.h>\n-#include <utilstrencodings.h>\n+#include <util/system.h>\n+#include <util/strencodings.h>\n #include <versionbitsinfo.h>\n \n #include <assert.h>"
      },
      {
        "sha": "f0559a319acb7c419da37be6e087e557d735d10c",
        "filename": "src/chainparamsbase.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/chainparamsbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/chainparamsbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsbase.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -6,8 +6,8 @@\n #include <chainparamsbase.h>\n \n #include <tinyformat.h>\n-#include <util.h>\n-#include <utilmemory.h>\n+#include <util/system.h>\n+#include <util/memory.h>\n \n #include <assert.h>\n "
      },
      {
        "sha": "3ef9e0463c45de85727405233d6adb297efbda8b",
        "filename": "src/coins.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -6,6 +6,7 @@\n \n #include <consensus/consensus.h>\n #include <random.h>\n+#include <version.h>\n \n bool CCoinsView::GetCoin(const COutPoint &outpoint, Coin &coin) const { return false; }\n uint256 CCoinsView::GetBestBlock() const { return uint256(); }"
      },
      {
        "sha": "94493453f0ddc97e25b8df5dc1ac0117b96c850d",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -9,7 +9,7 @@\n #include <primitives/transaction.h>\n #include <compressor.h>\n #include <core_memusage.h>\n-#include <hash.h>\n+#include <crypto/siphash.h>\n #include <memusage.h>\n #include <serialize.h>\n #include <uint256.h>"
      },
      {
        "sha": "b47d9774ca62be6a4b78d3181d68fd153862f67c",
        "filename": "src/consensus/merkle.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/consensus/merkle.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/consensus/merkle.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/merkle.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -4,7 +4,7 @@\n \n #include <consensus/merkle.h>\n #include <hash.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n \n /*     WARNING! If you're reading this because you're learning about crypto\n        and/or designing a new system that will use merkle trees, keep in mind"
      },
      {
        "sha": "b17a8bb31dc037537974b8236acb6fc00220e6c2",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -12,7 +12,7 @@\n // TODO remove the following dependencies\n #include <chain.h>\n #include <coins.h>\n-#include <utilmoneystr.h>\n+#include <util/moneystr.h>\n \n bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64_t nBlockTime)\n {"
      },
      {
        "sha": "3b82b2853c849cd569d283015ae01b5a6ea33b1a",
        "filename": "src/core_read.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/core_read.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/core_read.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_read.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -11,8 +11,8 @@\n #include <serialize.h>\n #include <streams.h>\n #include <univalue.h>\n-#include <util.h>\n-#include <utilstrencodings.h>\n+#include <util/system.h>\n+#include <util/strencodings.h>\n #include <version.h>\n \n #include <boost/algorithm/string/classification.hpp>"
      },
      {
        "sha": "765a170307e31b21b5aa62915385fe103e232c9a",
        "filename": "src/core_write.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/core_write.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/core_write.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_write.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -12,9 +12,9 @@\n #include <serialize.h>\n #include <streams.h>\n #include <univalue.h>\n-#include <util.h>\n-#include <utilmoneystr.h>\n-#include <utilstrencodings.h>\n+#include <util/system.h>\n+#include <util/moneystr.h>\n+#include <util/strencodings.h>\n \n UniValue ValueFromAmount(const CAmount& amount)\n {"
      },
      {
        "sha": "e81957111ad26b85e3faf17edf0a1268cc5995c9",
        "filename": "src/crypto/siphash.cpp",
        "status": "added",
        "additions": 173,
        "deletions": 0,
        "changes": 173,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/crypto/siphash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/crypto/siphash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/siphash.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -0,0 +1,173 @@\n+// Copyright (c) 2016-2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/siphash.h>\n+\n+#define ROTL(x, b) (uint64_t)(((x) << (b)) | ((x) >> (64 - (b))))\n+\n+#define SIPROUND do { \\\n+    v0 += v1; v1 = ROTL(v1, 13); v1 ^= v0; \\\n+    v0 = ROTL(v0, 32); \\\n+    v2 += v3; v3 = ROTL(v3, 16); v3 ^= v2; \\\n+    v0 += v3; v3 = ROTL(v3, 21); v3 ^= v0; \\\n+    v2 += v1; v1 = ROTL(v1, 17); v1 ^= v2; \\\n+    v2 = ROTL(v2, 32); \\\n+} while (0)\n+\n+CSipHasher::CSipHasher(uint64_t k0, uint64_t k1)\n+{\n+    v[0] = 0x736f6d6570736575ULL ^ k0;\n+    v[1] = 0x646f72616e646f6dULL ^ k1;\n+    v[2] = 0x6c7967656e657261ULL ^ k0;\n+    v[3] = 0x7465646279746573ULL ^ k1;\n+    count = 0;\n+    tmp = 0;\n+}\n+\n+CSipHasher& CSipHasher::Write(uint64_t data)\n+{\n+    uint64_t v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3];\n+\n+    assert(count % 8 == 0);\n+\n+    v3 ^= data;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= data;\n+\n+    v[0] = v0;\n+    v[1] = v1;\n+    v[2] = v2;\n+    v[3] = v3;\n+\n+    count += 8;\n+    return *this;\n+}\n+\n+CSipHasher& CSipHasher::Write(const unsigned char* data, size_t size)\n+{\n+    uint64_t v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3];\n+    uint64_t t = tmp;\n+    int c = count;\n+\n+    while (size--) {\n+        t |= ((uint64_t)(*(data++))) << (8 * (c % 8));\n+        c++;\n+        if ((c & 7) == 0) {\n+            v3 ^= t;\n+            SIPROUND;\n+            SIPROUND;\n+            v0 ^= t;\n+            t = 0;\n+        }\n+    }\n+\n+    v[0] = v0;\n+    v[1] = v1;\n+    v[2] = v2;\n+    v[3] = v3;\n+    count = c;\n+    tmp = t;\n+\n+    return *this;\n+}\n+\n+uint64_t CSipHasher::Finalize() const\n+{\n+    uint64_t v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3];\n+\n+    uint64_t t = tmp | (((uint64_t)count) << 56);\n+\n+    v3 ^= t;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= t;\n+    v2 ^= 0xFF;\n+    SIPROUND;\n+    SIPROUND;\n+    SIPROUND;\n+    SIPROUND;\n+    return v0 ^ v1 ^ v2 ^ v3;\n+}\n+\n+uint64_t SipHashUint256(uint64_t k0, uint64_t k1, const uint256& val)\n+{\n+    /* Specialized implementation for efficiency */\n+    uint64_t d = val.GetUint64(0);\n+\n+    uint64_t v0 = 0x736f6d6570736575ULL ^ k0;\n+    uint64_t v1 = 0x646f72616e646f6dULL ^ k1;\n+    uint64_t v2 = 0x6c7967656e657261ULL ^ k0;\n+    uint64_t v3 = 0x7465646279746573ULL ^ k1 ^ d;\n+\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    d = val.GetUint64(1);\n+    v3 ^= d;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    d = val.GetUint64(2);\n+    v3 ^= d;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    d = val.GetUint64(3);\n+    v3 ^= d;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    v3 ^= ((uint64_t)4) << 59;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= ((uint64_t)4) << 59;\n+    v2 ^= 0xFF;\n+    SIPROUND;\n+    SIPROUND;\n+    SIPROUND;\n+    SIPROUND;\n+    return v0 ^ v1 ^ v2 ^ v3;\n+}\n+\n+uint64_t SipHashUint256Extra(uint64_t k0, uint64_t k1, const uint256& val, uint32_t extra)\n+{\n+    /* Specialized implementation for efficiency */\n+    uint64_t d = val.GetUint64(0);\n+\n+    uint64_t v0 = 0x736f6d6570736575ULL ^ k0;\n+    uint64_t v1 = 0x646f72616e646f6dULL ^ k1;\n+    uint64_t v2 = 0x6c7967656e657261ULL ^ k0;\n+    uint64_t v3 = 0x7465646279746573ULL ^ k1 ^ d;\n+\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    d = val.GetUint64(1);\n+    v3 ^= d;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    d = val.GetUint64(2);\n+    v3 ^= d;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    d = val.GetUint64(3);\n+    v3 ^= d;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    d = (((uint64_t)36) << 56) | extra;\n+    v3 ^= d;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    v2 ^= 0xFF;\n+    SIPROUND;\n+    SIPROUND;\n+    SIPROUND;\n+    SIPROUND;\n+    return v0 ^ v1 ^ v2 ^ v3;\n+}"
      },
      {
        "sha": "b312f913f9360abe5295afcbc737489ff9ab4450",
        "filename": "src/crypto/siphash.h",
        "status": "added",
        "additions": 47,
        "deletions": 0,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/crypto/siphash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/crypto/siphash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/siphash.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -0,0 +1,47 @@\n+// Copyright (c) 2016-2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CRYPTO_SIPHASH_H\n+#define BITCOIN_CRYPTO_SIPHASH_H\n+\n+#include <stdint.h>\n+\n+#include <uint256.h>\n+\n+/** SipHash-2-4 */\n+class CSipHasher\n+{\n+private:\n+    uint64_t v[4];\n+    uint64_t tmp;\n+    int count;\n+\n+public:\n+    /** Construct a SipHash calculator initialized with 128-bit key (k0, k1) */\n+    CSipHasher(uint64_t k0, uint64_t k1);\n+    /** Hash a 64-bit integer worth of data\n+     *  It is treated as if this was the little-endian interpretation of 8 bytes.\n+     *  This function can only be used when a multiple of 8 bytes have been written so far.\n+     */\n+    CSipHasher& Write(uint64_t data);\n+    /** Hash arbitrary bytes. */\n+    CSipHasher& Write(const unsigned char* data, size_t size);\n+    /** Compute the 64-bit SipHash-2-4 of the data written so far. The object remains untouched. */\n+    uint64_t Finalize() const;\n+};\n+\n+/** Optimized SipHash-2-4 implementation for uint256.\n+ *\n+ *  It is identical to:\n+ *    SipHasher(k0, k1)\n+ *      .Write(val.GetUint64(0))\n+ *      .Write(val.GetUint64(1))\n+ *      .Write(val.GetUint64(2))\n+ *      .Write(val.GetUint64(3))\n+ *      .Finalize()\n+ */\n+uint64_t SipHashUint256(uint64_t k0, uint64_t k1, const uint256& val);\n+uint64_t SipHashUint256Extra(uint64_t k0, uint64_t k1, const uint256& val, uint32_t extra);\n+\n+#endif // BITCOIN_CRYPTO_SIPHASH_H"
      },
      {
        "sha": "416f5e83997a6c69edf3989c317b0c7f1350c6e4",
        "filename": "src/dbwrapper.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/dbwrapper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/dbwrapper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dbwrapper.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -9,8 +9,8 @@\n #include <fs.h>\n #include <serialize.h>\n #include <streams.h>\n-#include <util.h>\n-#include <utilstrencodings.h>\n+#include <util/system.h>\n+#include <util/strencodings.h>\n #include <version.h>\n \n #include <leveldb/db.h>"
      },
      {
        "sha": "9211a7596b8a47d10362809d2534d2c29cad9623",
        "filename": "src/dummywallet.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 8,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/dummywallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/dummywallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dummywallet.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -3,7 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <stdio.h>\n-#include <util.h>\n+#include <util/system.h>\n #include <walletinitinterface.h>\n \n class CWallet;\n@@ -14,13 +14,7 @@ class DummyWalletInit : public WalletInitInterface {\n     bool HasWalletSupport() const override {return false;}\n     void AddWalletOptions() const override;\n     bool ParameterInteraction() const override {return true;}\n-    void RegisterRPC(CRPCTable &) const override {}\n-    bool Verify() const override {return true;}\n-    bool Open() const override {LogPrintf(\"No wallet support compiled in!\\n\"); return true;}\n-    void Start(CScheduler& scheduler) const override {}\n-    void Flush() const override {}\n-    void Stop() const override {}\n-    void Close() const override {}\n+    void Construct(InitInterfaces& interfaces) const override {LogPrintf(\"No wallet support compiled in!\\n\");}\n };\n \n void DummyWalletInit::AddWalletOptions() const"
      },
      {
        "sha": "26150e5ca8aaa0f5f42b820a7d4e12f12617bacc",
        "filename": "src/hash.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 168,
        "changes": 168,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/hash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/hash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -77,171 +77,3 @@ void BIP32Hash(const ChainCode &chainCode, unsigned int nChild, unsigned char he\n     num[3] = (nChild >>  0) & 0xFF;\n     CHMAC_SHA512(chainCode.begin(), chainCode.size()).Write(&header, 1).Write(data, 32).Write(num, 4).Finalize(output);\n }\n-\n-#define ROTL(x, b) (uint64_t)(((x) << (b)) | ((x) >> (64 - (b))))\n-\n-#define SIPROUND do { \\\n-    v0 += v1; v1 = ROTL(v1, 13); v1 ^= v0; \\\n-    v0 = ROTL(v0, 32); \\\n-    v2 += v3; v3 = ROTL(v3, 16); v3 ^= v2; \\\n-    v0 += v3; v3 = ROTL(v3, 21); v3 ^= v0; \\\n-    v2 += v1; v1 = ROTL(v1, 17); v1 ^= v2; \\\n-    v2 = ROTL(v2, 32); \\\n-} while (0)\n-\n-CSipHasher::CSipHasher(uint64_t k0, uint64_t k1)\n-{\n-    v[0] = 0x736f6d6570736575ULL ^ k0;\n-    v[1] = 0x646f72616e646f6dULL ^ k1;\n-    v[2] = 0x6c7967656e657261ULL ^ k0;\n-    v[3] = 0x7465646279746573ULL ^ k1;\n-    count = 0;\n-    tmp = 0;\n-}\n-\n-CSipHasher& CSipHasher::Write(uint64_t data)\n-{\n-    uint64_t v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3];\n-\n-    assert(count % 8 == 0);\n-\n-    v3 ^= data;\n-    SIPROUND;\n-    SIPROUND;\n-    v0 ^= data;\n-\n-    v[0] = v0;\n-    v[1] = v1;\n-    v[2] = v2;\n-    v[3] = v3;\n-\n-    count += 8;\n-    return *this;\n-}\n-\n-CSipHasher& CSipHasher::Write(const unsigned char* data, size_t size)\n-{\n-    uint64_t v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3];\n-    uint64_t t = tmp;\n-    int c = count;\n-\n-    while (size--) {\n-        t |= ((uint64_t)(*(data++))) << (8 * (c % 8));\n-        c++;\n-        if ((c & 7) == 0) {\n-            v3 ^= t;\n-            SIPROUND;\n-            SIPROUND;\n-            v0 ^= t;\n-            t = 0;\n-        }\n-    }\n-\n-    v[0] = v0;\n-    v[1] = v1;\n-    v[2] = v2;\n-    v[3] = v3;\n-    count = c;\n-    tmp = t;\n-\n-    return *this;\n-}\n-\n-uint64_t CSipHasher::Finalize() const\n-{\n-    uint64_t v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3];\n-\n-    uint64_t t = tmp | (((uint64_t)count) << 56);\n-\n-    v3 ^= t;\n-    SIPROUND;\n-    SIPROUND;\n-    v0 ^= t;\n-    v2 ^= 0xFF;\n-    SIPROUND;\n-    SIPROUND;\n-    SIPROUND;\n-    SIPROUND;\n-    return v0 ^ v1 ^ v2 ^ v3;\n-}\n-\n-uint64_t SipHashUint256(uint64_t k0, uint64_t k1, const uint256& val)\n-{\n-    /* Specialized implementation for efficiency */\n-    uint64_t d = val.GetUint64(0);\n-\n-    uint64_t v0 = 0x736f6d6570736575ULL ^ k0;\n-    uint64_t v1 = 0x646f72616e646f6dULL ^ k1;\n-    uint64_t v2 = 0x6c7967656e657261ULL ^ k0;\n-    uint64_t v3 = 0x7465646279746573ULL ^ k1 ^ d;\n-\n-    SIPROUND;\n-    SIPROUND;\n-    v0 ^= d;\n-    d = val.GetUint64(1);\n-    v3 ^= d;\n-    SIPROUND;\n-    SIPROUND;\n-    v0 ^= d;\n-    d = val.GetUint64(2);\n-    v3 ^= d;\n-    SIPROUND;\n-    SIPROUND;\n-    v0 ^= d;\n-    d = val.GetUint64(3);\n-    v3 ^= d;\n-    SIPROUND;\n-    SIPROUND;\n-    v0 ^= d;\n-    v3 ^= ((uint64_t)4) << 59;\n-    SIPROUND;\n-    SIPROUND;\n-    v0 ^= ((uint64_t)4) << 59;\n-    v2 ^= 0xFF;\n-    SIPROUND;\n-    SIPROUND;\n-    SIPROUND;\n-    SIPROUND;\n-    return v0 ^ v1 ^ v2 ^ v3;\n-}\n-\n-uint64_t SipHashUint256Extra(uint64_t k0, uint64_t k1, const uint256& val, uint32_t extra)\n-{\n-    /* Specialized implementation for efficiency */\n-    uint64_t d = val.GetUint64(0);\n-\n-    uint64_t v0 = 0x736f6d6570736575ULL ^ k0;\n-    uint64_t v1 = 0x646f72616e646f6dULL ^ k1;\n-    uint64_t v2 = 0x6c7967656e657261ULL ^ k0;\n-    uint64_t v3 = 0x7465646279746573ULL ^ k1 ^ d;\n-\n-    SIPROUND;\n-    SIPROUND;\n-    v0 ^= d;\n-    d = val.GetUint64(1);\n-    v3 ^= d;\n-    SIPROUND;\n-    SIPROUND;\n-    v0 ^= d;\n-    d = val.GetUint64(2);\n-    v3 ^= d;\n-    SIPROUND;\n-    SIPROUND;\n-    v0 ^= d;\n-    d = val.GetUint64(3);\n-    v3 ^= d;\n-    SIPROUND;\n-    SIPROUND;\n-    v0 ^= d;\n-    d = (((uint64_t)36) << 56) | extra;\n-    v3 ^= d;\n-    SIPROUND;\n-    SIPROUND;\n-    v0 ^= d;\n-    v2 ^= 0xFF;\n-    SIPROUND;\n-    SIPROUND;\n-    SIPROUND;\n-    SIPROUND;\n-    return v0 ^ v1 ^ v2 ^ v3;\n-}"
      },
      {
        "sha": "6acab0b1610dfae19e30905a5a40a7a7b7223f50",
        "filename": "src/hash.h",
        "status": "modified",
        "additions": 0,
        "deletions": 35,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -194,39 +194,4 @@ unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char\n \n void BIP32Hash(const ChainCode &chainCode, unsigned int nChild, unsigned char header, const unsigned char data[32], unsigned char output[64]);\n \n-/** SipHash-2-4 */\n-class CSipHasher\n-{\n-private:\n-    uint64_t v[4];\n-    uint64_t tmp;\n-    int count;\n-\n-public:\n-    /** Construct a SipHash calculator initialized with 128-bit key (k0, k1) */\n-    CSipHasher(uint64_t k0, uint64_t k1);\n-    /** Hash a 64-bit integer worth of data\n-     *  It is treated as if this was the little-endian interpretation of 8 bytes.\n-     *  This function can only be used when a multiple of 8 bytes have been written so far.\n-     */\n-    CSipHasher& Write(uint64_t data);\n-    /** Hash arbitrary bytes. */\n-    CSipHasher& Write(const unsigned char* data, size_t size);\n-    /** Compute the 64-bit SipHash-2-4 of the data written so far. The object remains untouched. */\n-    uint64_t Finalize() const;\n-};\n-\n-/** Optimized SipHash-2-4 implementation for uint256.\n- *\n- *  It is identical to:\n- *    SipHasher(k0, k1)\n- *      .Write(val.GetUint64(0))\n- *      .Write(val.GetUint64(1))\n- *      .Write(val.GetUint64(2))\n- *      .Write(val.GetUint64(3))\n- *      .Finalize()\n- */\n-uint64_t SipHashUint256(uint64_t k0, uint64_t k1, const uint256& val);\n-uint64_t SipHashUint256Extra(uint64_t k0, uint64_t k1, const uint256& val, uint32_t extra);\n-\n #endif // BITCOIN_HASH_H"
      },
      {
        "sha": "fcf760a4c6fe68878b78aba6c7b2ac811ca46b99",
        "filename": "src/httprpc.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/httprpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/httprpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httprpc.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -11,8 +11,8 @@\n #include <rpc/server.h>\n #include <random.h>\n #include <sync.h>\n-#include <util.h>\n-#include <utilstrencodings.h>\n+#include <util/system.h>\n+#include <util/strencodings.h>\n #include <ui_interface.h>\n #include <walletinitinterface.h>\n #include <crypto/hmac_sha256.h>"
      },
      {
        "sha": "91ebc4680c50b027a86da606d72997aef5859ae9",
        "filename": "src/httpserver.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 11,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/httpserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/httpserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -6,8 +6,8 @@\n \n #include <chainparamsbase.h>\n #include <compat.h>\n-#include <util.h>\n-#include <utilstrencodings.h>\n+#include <util/system.h>\n+#include <util/strencodings.h>\n #include <netbase.h>\n #include <rpc/protocol.h> // For HTTP status codes\n #include <sync.h>\n@@ -224,21 +224,25 @@ static void http_request_cb(struct evhttp_request* req, void* arg)\n     }\n     std::unique_ptr<HTTPRequest> hreq(new HTTPRequest(req));\n \n-    LogPrint(BCLog::HTTP, \"Received a %s request for %s from %s\\n\",\n-             RequestMethodString(hreq->GetRequestMethod()), hreq->GetURI(), hreq->GetPeer().ToString());\n-\n     // Early address-based allow check\n     if (!ClientAllowed(hreq->GetPeer())) {\n+        LogPrint(BCLog::HTTP, \"HTTP request from %s rejected: Client network is not allowed RPC access\\n\",\n+                 hreq->GetPeer().ToString());\n         hreq->WriteReply(HTTP_FORBIDDEN);\n         return;\n     }\n \n     // Early reject unknown HTTP methods\n     if (hreq->GetRequestMethod() == HTTPRequest::UNKNOWN) {\n+        LogPrint(BCLog::HTTP, \"HTTP request from %s rejected: Unknown HTTP request method\\n\",\n+                 hreq->GetPeer().ToString());\n         hreq->WriteReply(HTTP_BADMETHOD);\n         return;\n     }\n \n+    LogPrint(BCLog::HTTP, \"Received a %s request for %s from %s\\n\",\n+             RequestMethodString(hreq->GetRequestMethod()), SanitizeString(hreq->GetURI(), SAFE_CHARS_URI).substr(0, 100), hreq->GetPeer().ToString());\n+\n     // Find registered handler for prefix\n     std::string strURI = hreq->GetURI();\n     std::string path;\n@@ -292,26 +296,26 @@ static bool ThreadHTTP(struct event_base* base)\n /** Bind HTTP server to specified addresses */\n static bool HTTPBindAddresses(struct evhttp* http)\n {\n-    int defaultPort = gArgs.GetArg(\"-rpcport\", BaseParams().RPCPort());\n+    int http_port = gArgs.GetArg(\"-rpcport\", BaseParams().RPCPort());\n     std::vector<std::pair<std::string, uint16_t> > endpoints;\n \n     // Determine what addresses to bind to\n     if (!gArgs.IsArgSet(\"-rpcallowip\")) { // Default to loopback if not allowing external IPs\n-        endpoints.push_back(std::make_pair(\"::1\", defaultPort));\n-        endpoints.push_back(std::make_pair(\"127.0.0.1\", defaultPort));\n+        endpoints.push_back(std::make_pair(\"::1\", http_port));\n+        endpoints.push_back(std::make_pair(\"127.0.0.1\", http_port));\n         if (gArgs.IsArgSet(\"-rpcbind\")) {\n             LogPrintf(\"WARNING: option -rpcbind was ignored because -rpcallowip was not specified, refusing to allow everyone to connect\\n\");\n         }\n     } else if (gArgs.IsArgSet(\"-rpcbind\")) { // Specific bind address\n         for (const std::string& strRPCBind : gArgs.GetArgs(\"-rpcbind\")) {\n-            int port = defaultPort;\n+            int port = http_port;\n             std::string host;\n             SplitHostPort(strRPCBind, port, host);\n             endpoints.push_back(std::make_pair(host, port));\n         }\n     } else { // No specific bind address specified, bind to any\n-        endpoints.push_back(std::make_pair(\"::\", defaultPort));\n-        endpoints.push_back(std::make_pair(\"0.0.0.0\", defaultPort));\n+        endpoints.push_back(std::make_pair(\"::\", http_port));\n+        endpoints.push_back(std::make_pair(\"0.0.0.0\", http_port));\n     }\n \n     // Bind addresses"
      },
      {
        "sha": "4d4a7e1502336832e2e3beee7d60de5be539f393",
        "filename": "src/index/base.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/index/base.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/index/base.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/base.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -7,7 +7,7 @@\n #include <shutdown.h>\n #include <tinyformat.h>\n #include <ui_interface.h>\n-#include <util.h>\n+#include <util/system.h>\n #include <validation.h>\n #include <warnings.h>\n "
      },
      {
        "sha": "ba1c44765f0db9185a577db2e726920535275aeb",
        "filename": "src/index/txindex.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/index/txindex.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/index/txindex.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/txindex.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -5,7 +5,7 @@\n #include <index/txindex.h>\n #include <shutdown.h>\n #include <ui_interface.h>\n-#include <util.h>\n+#include <util/system.h>\n #include <validation.h>\n \n #include <boost/thread.hpp>"
      },
      {
        "sha": "3ab97be329613298d91df034d2fad0d7dd0dad14",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 11,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -19,6 +19,7 @@\n #include <fs.h>\n #include <httpserver.h>\n #include <httprpc.h>\n+#include <interfaces/chain.h>\n #include <index/txindex.h>\n #include <key.h>\n #include <validation.h>\n@@ -32,6 +33,7 @@\n #include <rpc/server.h>\n #include <rpc/register.h>\n #include <rpc/blockchain.h>\n+#include <rpc/util.h>\n #include <script/standard.h>\n #include <script/sigcache.h>\n #include <scheduler.h>\n@@ -41,8 +43,8 @@\n #include <txmempool.h>\n #include <torcontrol.h>\n #include <ui_interface.h>\n-#include <util.h>\n-#include <utilmoneystr.h>\n+#include <util/system.h>\n+#include <util/moneystr.h>\n #include <validationinterface.h>\n #include <warnings.h>\n #include <walletinitinterface.h>\n@@ -62,6 +64,7 @@\n #include <openssl/crypto.h>\n \n #if ENABLE_ZMQ\n+#include <zmq/zmqabstractnotifier.h>\n #include <zmq/zmqnotificationinterface.h>\n #include <zmq/zmqrpc.h>\n #endif\n@@ -156,7 +159,7 @@ void Interrupt()\n     }\n }\n \n-void Shutdown()\n+void Shutdown(InitInterfaces& interfaces)\n {\n     LogPrintf(\"%s: In progress...\\n\", __func__);\n     static CCriticalSection cs_Shutdown;\n@@ -175,7 +178,9 @@ void Shutdown()\n     StopREST();\n     StopRPC();\n     StopHTTPServer();\n-    g_wallet_init_interface.Flush();\n+    for (const auto& client : interfaces.chain_clients) {\n+        client->flush();\n+    }\n     StopMapPort();\n \n     // Because these depend on each-other, we make sure that neither can be\n@@ -238,7 +243,9 @@ void Shutdown()\n         pcoinsdbview.reset();\n         pblocktree.reset();\n     }\n-    g_wallet_init_interface.Stop();\n+    for (const auto& client : interfaces.chain_clients) {\n+        client->stop();\n+    }\n \n #if ENABLE_ZMQ\n     if (g_zmq_notification_interface) {\n@@ -258,7 +265,7 @@ void Shutdown()\n     UnregisterAllValidationInterfaces();\n     GetMainSignals().UnregisterBackgroundSignalScheduler();\n     GetMainSignals().UnregisterWithMempoolSignals(mempool);\n-    g_wallet_init_interface.Close();\n+    interfaces.chain_clients.clear();\n     globalVerifyHandle.reset();\n     ECC_Stop();\n     LogPrintf(\"%s: done\\n\", __func__);\n@@ -418,11 +425,19 @@ void SetupServerArgs()\n     gArgs.AddArg(\"-zmqpubhashtx=<address>\", \"Enable publish hash transaction in <address>\", false, OptionsCategory::ZMQ);\n     gArgs.AddArg(\"-zmqpubrawblock=<address>\", \"Enable publish raw block in <address>\", false, OptionsCategory::ZMQ);\n     gArgs.AddArg(\"-zmqpubrawtx=<address>\", \"Enable publish raw transaction in <address>\", false, OptionsCategory::ZMQ);\n+    gArgs.AddArg(\"-zmqpubhashblockhwm=<n>\", strprintf(\"Set publish hash block outbound message high water mark (default: %d)\", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), false, OptionsCategory::ZMQ);\n+    gArgs.AddArg(\"-zmqpubhashtxhwm=<n>\", strprintf(\"Set publish hash transaction outbound message high water mark (default: %d)\", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), false, OptionsCategory::ZMQ);\n+    gArgs.AddArg(\"-zmqpubrawblockhwm=<n>\", strprintf(\"Set publish raw block outbound message high water mark (default: %d)\", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), false, OptionsCategory::ZMQ);\n+    gArgs.AddArg(\"-zmqpubrawtxhwm=<n>\", strprintf(\"Set publish raw transaction outbound message high water mark (default: %d)\", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), false, OptionsCategory::ZMQ);\n #else\n     hidden_args.emplace_back(\"-zmqpubhashblock=<address>\");\n     hidden_args.emplace_back(\"-zmqpubhashtx=<address>\");\n     hidden_args.emplace_back(\"-zmqpubrawblock=<address>\");\n     hidden_args.emplace_back(\"-zmqpubrawtx=<address>\");\n+    hidden_args.emplace_back(\"-zmqpubhashblockhwm=<n>\");\n+    hidden_args.emplace_back(\"-zmqpubhashtxhwm=<n>\");\n+    hidden_args.emplace_back(\"-zmqpubrawblockhwm=<n>\");\n+    hidden_args.emplace_back(\"-zmqpubrawtxhwm=<n>\");\n #endif\n \n     gArgs.AddArg(\"-checkblocks=<n>\", strprintf(\"How many blocks to check at startup (default: %u, 0 = all)\", DEFAULT_CHECKBLOCKS), true, OptionsCategory::DEBUG_TEST);\n@@ -1149,7 +1164,7 @@ bool AppInitLockDataDirectory()\n     return true;\n }\n \n-bool AppInitMain()\n+bool AppInitMain(InitInterfaces& interfaces)\n {\n     const CChainParams& chainparams = Params();\n     // ********************************************************* Step 4a: application initialization\n@@ -1212,11 +1227,20 @@ bool AppInitMain()\n     GetMainSignals().RegisterBackgroundSignalScheduler(scheduler);\n     GetMainSignals().RegisterWithMempoolSignals(mempool);\n \n+    // Create client interfaces for wallets that are supposed to be loaded\n+    // according to -wallet and -disablewallet options. This only constructs\n+    // the interfaces, it doesn't load wallet data. Wallets actually get loaded\n+    // when load() and start() interface methods are called below.\n+    g_wallet_init_interface.Construct(interfaces);\n+\n     /* Register RPC commands regardless of -server setting so they will be\n      * available in the GUI RPC console even if external calls are disabled.\n      */\n     RegisterAllCoreRPCCommands(tableRPC);\n-    g_wallet_init_interface.RegisterRPC(tableRPC);\n+    for (const auto& client : interfaces.chain_clients) {\n+        client->registerRpcs();\n+    }\n+    g_rpc_interfaces = &interfaces;\n #if ENABLE_ZMQ\n     RegisterZMQRPCCommands(tableRPC);\n #endif\n@@ -1234,7 +1258,11 @@ bool AppInitMain()\n     }\n \n     // ********************************************************* Step 5: verify wallet database integrity\n-    if (!g_wallet_init_interface.Verify()) return false;\n+    for (const auto& client : interfaces.chain_clients) {\n+        if (!client->verify()) {\n+            return false;\n+        }\n+    }\n \n     // ********************************************************* Step 6: network initialization\n     // Note that we absolutely cannot open any actual connections\n@@ -1553,7 +1581,11 @@ bool AppInitMain()\n     }\n \n     // ********************************************************* Step 9: load wallet\n-    if (!g_wallet_init_interface.Open()) return false;\n+    for (const auto& client : interfaces.chain_clients) {\n+        if (!client->load()) {\n+            return false;\n+        }\n+    }\n \n     // ********************************************************* Step 10: data directory maintenance\n \n@@ -1699,7 +1731,9 @@ bool AppInitMain()\n     SetRPCWarmupFinished();\n     uiInterface.InitMessage(_(\"Done loading\"));\n \n-    g_wallet_init_interface.Start(scheduler);\n+    for (const auto& client : interfaces.chain_clients) {\n+        client->start(scheduler);\n+    }\n \n     return true;\n }"
      },
      {
        "sha": "1c59ca069edf2d706bc5c1bd5a36380e42bc1784",
        "filename": "src/init.h",
        "status": "modified",
        "additions": 14,
        "deletions": 5,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/init.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/init.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -8,10 +8,19 @@\n \n #include <memory>\n #include <string>\n-#include <util.h>\n+#include <util/system.h>\n \n-class CScheduler;\n-class CWallet;\n+namespace interfaces {\n+class Chain;\n+class ChainClient;\n+} // namespace interfaces\n+\n+//! Pointers to interfaces used during init and destroyed on shutdown.\n+struct InitInterfaces\n+{\n+    std::unique_ptr<interfaces::Chain> chain;\n+    std::vector<std::unique_ptr<interfaces::ChainClient>> chain_clients;\n+};\n \n namespace boost\n {\n@@ -20,7 +29,7 @@ class thread_group;\n \n /** Interrupt threads */\n void Interrupt();\n-void Shutdown();\n+void Shutdown(InitInterfaces& interfaces);\n //!Initialize the logging infrastructure\n void InitLogging();\n //!Parameter interaction: change current parameters depending on various rules\n@@ -54,7 +63,7 @@ bool AppInitLockDataDirectory();\n  * @note This should only be done after daemonization. Call Shutdown() if this function fails.\n  * @pre Parameters should be parsed and config file should be read, AppInitLockDataDirectory should have been called.\n  */\n-bool AppInitMain();\n+bool AppInitMain(InitInterfaces& interfaces);\n \n /**\n  * Setup the arguments for gArgs"
      },
      {
        "sha": "57d41df746b1d786708c6b107b487e687e33cd92",
        "filename": "src/interfaces/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/interfaces/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/interfaces/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/README.md?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -4,7 +4,7 @@ The following interfaces are defined here:\n \n * [`Chain`](chain.h) \u2014 used by wallet to access blockchain and mempool state. Added in [#10973](https://github.com/bitcoin/bitcoin/pull/10973).\n \n-* [`Chain::Client`](chain.h) \u2014 used by node to start & stop `Chain` clients. Added in [#10973](https://github.com/bitcoin/bitcoin/pull/10973).\n+* [`ChainClient`](chain.h) \u2014 used by node to start & stop `Chain` clients. Added in [#10973](https://github.com/bitcoin/bitcoin/pull/10973).\n \n * [`Node`](node.h) \u2014 used by GUI to start & stop bitcoin node. Added in [#10244](https://github.com/bitcoin/bitcoin/pull/10244).\n "
      },
      {
        "sha": "2571a91031f98c3c475b7957fe746c7a9e49ab6c",
        "filename": "src/interfaces/chain.cpp",
        "status": "added",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/interfaces/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/interfaces/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -0,0 +1,44 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <interfaces/chain.h>\n+\n+#include <sync.h>\n+#include <util/system.h>\n+#include <validation.h>\n+\n+#include <memory>\n+#include <utility>\n+\n+namespace interfaces {\n+namespace {\n+\n+class LockImpl : public Chain::Lock\n+{\n+};\n+\n+class LockingStateImpl : public LockImpl, public UniqueLock<CCriticalSection>\n+{\n+    using UniqueLock::UniqueLock;\n+};\n+\n+class ChainImpl : public Chain\n+{\n+public:\n+    std::unique_ptr<Chain::Lock> lock(bool try_lock) override\n+    {\n+        auto result = MakeUnique<LockingStateImpl>(::cs_main, \"cs_main\", __FILE__, __LINE__, try_lock);\n+        if (try_lock && result && !*result) return {};\n+        // std::move necessary on some compilers due to conversion from\n+        // LockingStateImpl to Lock pointer\n+        return std::move(result);\n+    }\n+    std::unique_ptr<Chain::Lock> assumeLocked() override { return MakeUnique<LockImpl>(); }\n+};\n+\n+} // namespace\n+\n+std::unique_ptr<Chain> MakeChain() { return MakeUnique<ChainImpl>(); }\n+\n+} // namespace interfaces"
      },
      {
        "sha": "fe5658de4b73c78ff2f14080b78b0f1fc6c16d23",
        "filename": "src/interfaces/chain.h",
        "status": "added",
        "additions": 84,
        "deletions": 0,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/interfaces/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/interfaces/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -0,0 +1,84 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INTERFACES_CHAIN_H\n+#define BITCOIN_INTERFACES_CHAIN_H\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+class CScheduler;\n+\n+namespace interfaces {\n+\n+//! Interface for giving wallet processes access to blockchain state.\n+class Chain\n+{\n+public:\n+    virtual ~Chain() {}\n+\n+    //! Interface for querying locked chain state, used by legacy code that\n+    //! assumes state won't change between calls. New code should avoid using\n+    //! the Lock interface and instead call higher-level Chain methods\n+    //! that return more information so the chain doesn't need to stay locked\n+    //! between calls.\n+    class Lock\n+    {\n+    public:\n+        virtual ~Lock() {}\n+    };\n+\n+    //! Return Lock interface. Chain is locked when this is called, and\n+    //! unlocked when the returned interface is freed.\n+    virtual std::unique_ptr<Lock> lock(bool try_lock = false) = 0;\n+\n+    //! Return Lock interface assuming chain is already locked. This\n+    //! method is temporary and is only used in a few places to avoid changing\n+    //! behavior while code is transitioned to use the Chain::Lock interface.\n+    virtual std::unique_ptr<Lock> assumeLocked() = 0;\n+};\n+\n+//! Interface to let node manage chain clients (wallets, or maybe tools for\n+//! monitoring and analysis in the future).\n+class ChainClient\n+{\n+public:\n+    virtual ~ChainClient() {}\n+\n+    //! Register rpcs.\n+    virtual void registerRpcs() = 0;\n+\n+    //! Check for errors before loading.\n+    virtual bool verify() = 0;\n+\n+    //! Load saved state.\n+    virtual bool load() = 0;\n+\n+    //! Start client execution and provide a scheduler.\n+    virtual void start(CScheduler& scheduler) = 0;\n+\n+    //! Save state to disk.\n+    virtual void flush() = 0;\n+\n+    //! Shut down client.\n+    virtual void stop() = 0;\n+};\n+\n+//! Return implementation of Chain interface.\n+std::unique_ptr<Chain> MakeChain();\n+\n+//! Return implementation of ChainClient interface for a wallet client. This\n+//! function will be undefined in builds where ENABLE_WALLET is false.\n+//!\n+//! Currently, wallets are the only chain clients. But in the future, other\n+//! types of chain clients could be added, such as tools for monitoring,\n+//! analysis, or fee estimation. These clients need to expose their own\n+//! MakeXXXClient functions returning their implementations of the ChainClient\n+//! interface.\n+std::unique_ptr<ChainClient> MakeWalletClient(Chain& chain, std::vector<std::string> wallet_filenames);\n+\n+} // namespace interfaces\n+\n+#endif // BITCOIN_INTERFACES_CHAIN_H"
      },
      {
        "sha": "92601fc4e99c88579e6761687edf4b06d82e16bd",
        "filename": "src/interfaces/handler.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/interfaces/handler.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/interfaces/handler.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/handler.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -4,7 +4,7 @@\n \n #include <interfaces/handler.h>\n \n-#include <utilmemory.h>\n+#include <util/memory.h>\n \n #include <boost/signals2/connection.hpp>\n #include <utility>"
      },
      {
        "sha": "1919e16a66761539a39f74627b91646e9f57d47b",
        "filename": "src/interfaces/node.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 3,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/interfaces/node.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/interfaces/node.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/node.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -9,6 +9,7 @@\n #include <chain.h>\n #include <chainparams.h>\n #include <init.h>\n+#include <interfaces/chain.h>\n #include <interfaces/handler.h>\n #include <interfaces/wallet.h>\n #include <net.h>\n@@ -25,7 +26,7 @@\n #include <sync.h>\n #include <txmempool.h>\n #include <ui_interface.h>\n-#include <util.h>\n+#include <util/system.h>\n #include <validation.h>\n #include <warnings.h>\n \n@@ -50,6 +51,8 @@ namespace {\n \n class NodeImpl : public Node\n {\n+public:\n+    NodeImpl() { m_interfaces.chain = MakeChain(); }\n     bool parseParameters(int argc, const char* const argv[], std::string& error) override\n     {\n         return gArgs.ParseParameters(argc, argv, error);\n@@ -68,11 +71,11 @@ class NodeImpl : public Node\n         return AppInitBasicSetup() && AppInitParameterInteraction() && AppInitSanityChecks() &&\n                AppInitLockDataDirectory();\n     }\n-    bool appInitMain() override { return AppInitMain(); }\n+    bool appInitMain() override { return AppInitMain(m_interfaces); }\n     void appShutdown() override\n     {\n         Interrupt();\n-        Shutdown();\n+        Shutdown(m_interfaces);\n     }\n     void startShutdown() override { StartShutdown(); }\n     bool shutdownRequested() override { return ShutdownRequested(); }\n@@ -291,6 +294,7 @@ class NodeImpl : public Node\n                     GuessVerificationProgress(Params().TxData(), block));\n             }));\n     }\n+    InitInterfaces m_interfaces;\n };\n \n } // namespace"
      },
      {
        "sha": "672a557d4165cd59ce449eb5d5b137f1bbec70dc",
        "filename": "src/interfaces/wallet.cpp",
        "status": "modified",
        "additions": 101,
        "deletions": 46,
        "changes": 147,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/interfaces/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/interfaces/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/wallet.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -7,23 +7,35 @@\n #include <amount.h>\n #include <chain.h>\n #include <consensus/validation.h>\n+#include <init.h>\n+#include <interfaces/chain.h>\n #include <interfaces/handler.h>\n #include <net.h>\n #include <policy/feerate.h>\n #include <policy/fees.h>\n #include <policy/policy.h>\n #include <primitives/transaction.h>\n+#include <rpc/server.h>\n+#include <scheduler.h>\n #include <script/ismine.h>\n #include <script/standard.h>\n #include <support/allocators/secure.h>\n #include <sync.h>\n #include <timedata.h>\n #include <ui_interface.h>\n #include <uint256.h>\n+#include <util/system.h>\n #include <validation.h>\n #include <wallet/feebumper.h>\n #include <wallet/fees.h>\n+#include <wallet/rpcwallet.h>\n #include <wallet/wallet.h>\n+#include <wallet/walletutil.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n \n namespace interfaces {\n namespace {\n@@ -41,7 +53,8 @@ class PendingWalletTxImpl : public PendingWalletTx\n         WalletOrderForm order_form,\n         std::string& reject_reason) override\n     {\n-        LOCK2(cs_main, m_wallet.cs_wallet);\n+        auto locked_chain = m_wallet.chain().lock();\n+        LOCK(m_wallet.cs_wallet);\n         CValidationState state;\n         if (!m_wallet.CommitTransaction(m_tx, std::move(value_map), std::move(order_form), m_key, g_connman.get(), state)) {\n             reject_reason = state.GetRejectReason();\n@@ -56,7 +69,7 @@ class PendingWalletTxImpl : public PendingWalletTx\n };\n \n //! Construct wallet tx struct.\n-static WalletTx MakeWalletTx(CWallet& wallet, const CWalletTx& wtx) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+WalletTx MakeWalletTx(interfaces::Chain::Lock& locked_chain, CWallet& wallet, const CWalletTx& wtx)\n {\n     WalletTx result;\n     result.tx = wtx.tx;\n@@ -74,7 +87,7 @@ static WalletTx MakeWalletTx(CWallet& wallet, const CWalletTx& wtx) EXCLUSIVE_LO\n                                                       IsMine(wallet, result.txout_address.back()) :\n                                                       ISMINE_NO);\n     }\n-    result.credit = wtx.GetCredit(ISMINE_ALL);\n+    result.credit = wtx.GetCredit(locked_chain, ISMINE_ALL);\n     result.debit = wtx.GetDebit(ISMINE_ALL);\n     result.change = wtx.GetChange();\n     result.time = wtx.GetTxTime();\n@@ -84,32 +97,38 @@ static WalletTx MakeWalletTx(CWallet& wallet, const CWalletTx& wtx) EXCLUSIVE_LO\n }\n \n //! Construct wallet tx status struct.\n-static WalletTxStatus MakeWalletTxStatus(const CWalletTx& wtx) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+WalletTxStatus MakeWalletTxStatus(interfaces::Chain::Lock& locked_chain, const CWalletTx& wtx)\n {\n+    LockAnnotation lock(::cs_main); // Temporary, for CheckFinalTx below. Removed in upcoming commit.\n+\n     WalletTxStatus result;\n     auto mi = ::mapBlockIndex.find(wtx.hashBlock);\n     CBlockIndex* block = mi != ::mapBlockIndex.end() ? mi->second : nullptr;\n     result.block_height = (block ? block->nHeight : std::numeric_limits<int>::max());\n-    result.blocks_to_maturity = wtx.GetBlocksToMaturity();\n-    result.depth_in_main_chain = wtx.GetDepthInMainChain();\n+    result.blocks_to_maturity = wtx.GetBlocksToMaturity(locked_chain);\n+    result.depth_in_main_chain = wtx.GetDepthInMainChain(locked_chain);\n     result.time_received = wtx.nTimeReceived;\n     result.lock_time = wtx.tx->nLockTime;\n     result.is_final = CheckFinalTx(*wtx.tx);\n-    result.is_trusted = wtx.IsTrusted();\n+    result.is_trusted = wtx.IsTrusted(locked_chain);\n     result.is_abandoned = wtx.isAbandoned();\n     result.is_coinbase = wtx.IsCoinBase();\n-    result.is_in_main_chain = wtx.IsInMainChain();\n+    result.is_in_main_chain = wtx.IsInMainChain(locked_chain);\n     return result;\n }\n \n //! Construct wallet TxOut struct.\n-static WalletTxOut MakeWalletTxOut(CWallet& wallet, const CWalletTx& wtx, int n, int depth) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+WalletTxOut MakeWalletTxOut(interfaces::Chain::Lock& locked_chain,\n+    CWallet& wallet,\n+    const CWalletTx& wtx,\n+    int n,\n+    int depth) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet)\n {\n     WalletTxOut result;\n     result.txout = wtx.tx->vout[n];\n     result.time = wtx.GetTxTime();\n     result.depth_in_main_chain = depth;\n-    result.is_spent = wallet.IsSpent(wtx.GetHash(), n);\n+    result.is_spent = wallet.IsSpent(locked_chain, wtx.GetHash(), n);\n     return result;\n }\n \n@@ -197,22 +216,26 @@ class WalletImpl : public Wallet\n     }\n     void lockCoin(const COutPoint& output) override\n     {\n-        LOCK2(cs_main, m_wallet.cs_wallet);\n+        auto locked_chain = m_wallet.chain().lock();\n+        LOCK(m_wallet.cs_wallet);\n         return m_wallet.LockCoin(output);\n     }\n     void unlockCoin(const COutPoint& output) override\n     {\n-        LOCK2(cs_main, m_wallet.cs_wallet);\n+        auto locked_chain = m_wallet.chain().lock();\n+        LOCK(m_wallet.cs_wallet);\n         return m_wallet.UnlockCoin(output);\n     }\n     bool isLockedCoin(const COutPoint& output) override\n     {\n-        LOCK2(cs_main, m_wallet.cs_wallet);\n+        auto locked_chain = m_wallet.chain().lock();\n+        LOCK(m_wallet.cs_wallet);\n         return m_wallet.IsLockedCoin(output.hash, output.n);\n     }\n     void listLockedCoins(std::vector<COutPoint>& outputs) override\n     {\n-        LOCK2(cs_main, m_wallet.cs_wallet);\n+        auto locked_chain = m_wallet.chain().lock();\n+        LOCK(m_wallet.cs_wallet);\n         return m_wallet.ListLockedCoins(outputs);\n     }\n     std::unique_ptr<PendingWalletTx> createTransaction(const std::vector<CRecipient>& recipients,\n@@ -222,9 +245,10 @@ class WalletImpl : public Wallet\n         CAmount& fee,\n         std::string& fail_reason) override\n     {\n-        LOCK2(cs_main, m_wallet.cs_wallet);\n+        auto locked_chain = m_wallet.chain().lock();\n+        LOCK(m_wallet.cs_wallet);\n         auto pending = MakeUnique<PendingWalletTxImpl>(m_wallet);\n-        if (!m_wallet.CreateTransaction(recipients, pending->m_tx, pending->m_key, fee, change_pos,\n+        if (!m_wallet.CreateTransaction(*locked_chain, recipients, pending->m_tx, pending->m_key, fee, change_pos,\n                 fail_reason, coin_control, sign)) {\n             return {};\n         }\n@@ -233,8 +257,9 @@ class WalletImpl : public Wallet\n     bool transactionCanBeAbandoned(const uint256& txid) override { return m_wallet.TransactionCanBeAbandoned(txid); }\n     bool abandonTransaction(const uint256& txid) override\n     {\n-        LOCK2(cs_main, m_wallet.cs_wallet);\n-        return m_wallet.AbandonTransaction(txid);\n+        auto locked_chain = m_wallet.chain().lock();\n+        LOCK(m_wallet.cs_wallet);\n+        return m_wallet.AbandonTransaction(*locked_chain, txid);\n     }\n     bool transactionCanBeBumped(const uint256& txid) override\n     {\n@@ -262,7 +287,8 @@ class WalletImpl : public Wallet\n     }\n     CTransactionRef getTx(const uint256& txid) override\n     {\n-        LOCK2(::cs_main, m_wallet.cs_wallet);\n+        auto locked_chain = m_wallet.chain().lock();\n+        LOCK(m_wallet.cs_wallet);\n         auto mi = m_wallet.mapWallet.find(txid);\n         if (mi != m_wallet.mapWallet.end()) {\n             return mi->second.tx;\n@@ -271,29 +297,30 @@ class WalletImpl : public Wallet\n     }\n     WalletTx getWalletTx(const uint256& txid) override\n     {\n-        LOCK2(::cs_main, m_wallet.cs_wallet);\n+        auto locked_chain = m_wallet.chain().lock();\n+        LOCK(m_wallet.cs_wallet);\n         auto mi = m_wallet.mapWallet.find(txid);\n         if (mi != m_wallet.mapWallet.end()) {\n-            return MakeWalletTx(m_wallet, mi->second);\n+            return MakeWalletTx(*locked_chain, m_wallet, mi->second);\n         }\n         return {};\n     }\n     std::vector<WalletTx> getWalletTxs() override\n     {\n-        LOCK2(::cs_main, m_wallet.cs_wallet);\n+        auto locked_chain = m_wallet.chain().lock();\n+        LOCK(m_wallet.cs_wallet);\n         std::vector<WalletTx> result;\n         result.reserve(m_wallet.mapWallet.size());\n         for (const auto& entry : m_wallet.mapWallet) {\n-            result.emplace_back(MakeWalletTx(m_wallet, entry.second));\n+            result.emplace_back(MakeWalletTx(*locked_chain, m_wallet, entry.second));\n         }\n         return result;\n     }\n     bool tryGetTxStatus(const uint256& txid,\n         interfaces::WalletTxStatus& tx_status,\n-        int& num_blocks,\n-        int64_t& adjusted_time) override\n+        int& num_blocks) override\n     {\n-        TRY_LOCK(::cs_main, locked_chain);\n+        auto locked_chain = m_wallet.chain().lock(true /* try_lock */);\n         if (!locked_chain) {\n             return false;\n         }\n@@ -306,26 +333,24 @@ class WalletImpl : public Wallet\n             return false;\n         }\n         num_blocks = ::chainActive.Height();\n-        adjusted_time = GetAdjustedTime();\n-        tx_status = MakeWalletTxStatus(mi->second);\n+        tx_status = MakeWalletTxStatus(*locked_chain, mi->second);\n         return true;\n     }\n     WalletTx getWalletTxDetails(const uint256& txid,\n         WalletTxStatus& tx_status,\n         WalletOrderForm& order_form,\n         bool& in_mempool,\n-        int& num_blocks,\n-        int64_t& adjusted_time) override\n+        int& num_blocks) override\n     {\n-        LOCK2(::cs_main, m_wallet.cs_wallet);\n+        auto locked_chain = m_wallet.chain().lock();\n+        LOCK(m_wallet.cs_wallet);\n         auto mi = m_wallet.mapWallet.find(txid);\n         if (mi != m_wallet.mapWallet.end()) {\n             num_blocks = ::chainActive.Height();\n-            adjusted_time = GetAdjustedTime();\n             in_mempool = mi->second.InMempool();\n             order_form = mi->second.vOrderForm;\n-            tx_status = MakeWalletTxStatus(mi->second);\n-            return MakeWalletTx(m_wallet, mi->second);\n+            tx_status = MakeWalletTxStatus(*locked_chain, mi->second);\n+            return MakeWalletTx(*locked_chain, m_wallet, mi->second);\n         }\n         return {};\n     }\n@@ -345,7 +370,7 @@ class WalletImpl : public Wallet\n     }\n     bool tryGetBalances(WalletBalances& balances, int& num_blocks) override\n     {\n-        TRY_LOCK(cs_main, locked_chain);\n+        auto locked_chain = m_wallet.chain().lock(true /* try_lock */);\n         if (!locked_chain) return false;\n         TRY_LOCK(m_wallet.cs_wallet, locked_wallet);\n         if (!locked_wallet) {\n@@ -362,49 +387,55 @@ class WalletImpl : public Wallet\n     }\n     isminetype txinIsMine(const CTxIn& txin) override\n     {\n-        LOCK2(::cs_main, m_wallet.cs_wallet);\n+        auto locked_chain = m_wallet.chain().lock();\n+        LOCK(m_wallet.cs_wallet);\n         return m_wallet.IsMine(txin);\n     }\n     isminetype txoutIsMine(const CTxOut& txout) override\n     {\n-        LOCK2(::cs_main, m_wallet.cs_wallet);\n+        auto locked_chain = m_wallet.chain().lock();\n+        LOCK(m_wallet.cs_wallet);\n         return m_wallet.IsMine(txout);\n     }\n     CAmount getDebit(const CTxIn& txin, isminefilter filter) override\n     {\n-        LOCK2(::cs_main, m_wallet.cs_wallet);\n+        auto locked_chain = m_wallet.chain().lock();\n+        LOCK(m_wallet.cs_wallet);\n         return m_wallet.GetDebit(txin, filter);\n     }\n     CAmount getCredit(const CTxOut& txout, isminefilter filter) override\n     {\n-        LOCK2(::cs_main, m_wallet.cs_wallet);\n+        auto locked_chain = m_wallet.chain().lock();\n+        LOCK(m_wallet.cs_wallet);\n         return m_wallet.GetCredit(txout, filter);\n     }\n     CoinsList listCoins() override\n     {\n-        LOCK2(::cs_main, m_wallet.cs_wallet);\n+        auto locked_chain = m_wallet.chain().lock();\n+        LOCK(m_wallet.cs_wallet);\n         CoinsList result;\n-        for (const auto& entry : m_wallet.ListCoins()) {\n+        for (const auto& entry : m_wallet.ListCoins(*locked_chain)) {\n             auto& group = result[entry.first];\n             for (const auto& coin : entry.second) {\n-                group.emplace_back(\n-                    COutPoint(coin.tx->GetHash(), coin.i), MakeWalletTxOut(m_wallet, *coin.tx, coin.i, coin.nDepth));\n+                group.emplace_back(COutPoint(coin.tx->GetHash(), coin.i),\n+                    MakeWalletTxOut(*locked_chain, m_wallet, *coin.tx, coin.i, coin.nDepth));\n             }\n         }\n         return result;\n     }\n     std::vector<WalletTxOut> getCoins(const std::vector<COutPoint>& outputs) override\n     {\n-        LOCK2(::cs_main, m_wallet.cs_wallet);\n+        auto locked_chain = m_wallet.chain().lock();\n+        LOCK(m_wallet.cs_wallet);\n         std::vector<WalletTxOut> result;\n         result.reserve(outputs.size());\n         for (const auto& output : outputs) {\n             result.emplace_back();\n             auto it = m_wallet.mapWallet.find(output.hash);\n             if (it != m_wallet.mapWallet.end()) {\n-                int depth = it->second.GetDepthInMainChain();\n+                int depth = it->second.GetDepthInMainChain(*locked_chain);\n                 if (depth >= 0) {\n-                    result.back() = MakeWalletTxOut(m_wallet, it->second, output.n, depth);\n+                    result.back() = MakeWalletTxOut(*locked_chain, m_wallet, it->second, output.n, depth);\n                 }\n             }\n         }\n@@ -460,8 +491,32 @@ class WalletImpl : public Wallet\n     CWallet& m_wallet;\n };\n \n+class WalletClientImpl : public ChainClient\n+{\n+public:\n+    WalletClientImpl(Chain& chain, std::vector<std::string> wallet_filenames)\n+        : m_chain(chain), m_wallet_filenames(std::move(wallet_filenames))\n+    {\n+    }\n+    void registerRpcs() override { return RegisterWalletRPCCommands(::tableRPC); }\n+    bool verify() override { return VerifyWallets(m_chain, m_wallet_filenames); }\n+    bool load() override { return LoadWallets(m_chain, m_wallet_filenames); }\n+    void start(CScheduler& scheduler) override { return StartWallets(scheduler); }\n+    void flush() override { return FlushWallets(); }\n+    void stop() override { return StopWallets(); }\n+    ~WalletClientImpl() override { UnloadWallets(); }\n+\n+    Chain& m_chain;\n+    std::vector<std::string> m_wallet_filenames;\n+};\n+\n } // namespace\n \n std::unique_ptr<Wallet> MakeWallet(const std::shared_ptr<CWallet>& wallet) { return MakeUnique<WalletImpl>(wallet); }\n \n+std::unique_ptr<ChainClient> MakeWalletClient(Chain& chain, std::vector<std::string> wallet_filenames)\n+{\n+    return MakeUnique<WalletClientImpl>(chain, std::move(wallet_filenames));\n+}\n+\n } // namespace interfaces"
      },
      {
        "sha": "c79b9afce3090971a1d0387f041f5303367e5c7f",
        "filename": "src/interfaces/wallet.h",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/interfaces/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/interfaces/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/wallet.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -178,16 +178,14 @@ class Wallet\n     //! Try to get updated status for a particular transaction, if possible without blocking.\n     virtual bool tryGetTxStatus(const uint256& txid,\n         WalletTxStatus& tx_status,\n-        int& num_blocks,\n-        int64_t& adjusted_time) = 0;\n+        int& num_blocks) = 0;\n \n     //! Get transaction details.\n     virtual WalletTx getWalletTxDetails(const uint256& txid,\n         WalletTxStatus& tx_status,\n         WalletOrderForm& order_form,\n         bool& in_mempool,\n-        int& num_blocks,\n-        int64_t& adjusted_time) = 0;\n+        int& num_blocks) = 0;\n \n     //! Get balances.\n     virtual WalletBalances getBalances() = 0;"
      },
      {
        "sha": "282385f50dcccccd3a47b84f076bedcbd7f213e1",
        "filename": "src/key_io.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/key_io.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/key_io.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key_io.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -7,7 +7,7 @@\n #include <base58.h>\n #include <bech32.h>\n #include <script/script.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n \n #include <boost/variant/apply_visitor.hpp>\n #include <boost/variant/static_visitor.hpp>"
      },
      {
        "sha": "148979cf3598c4bf4c1d0abac1d623f0c62c1338",
        "filename": "src/keystore.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/keystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/keystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -5,7 +5,7 @@\n \n #include <keystore.h>\n \n-#include <util.h>\n+#include <util/system.h>\n \n void CBasicKeyStore::ImplicitlyLearnRelatedKeyScripts(const CPubKey& pubkey)\n {"
      },
      {
        "sha": "77dc2d093941ea8ab2d95f51e25ca881e6086310",
        "filename": "src/logging.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/logging.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/logging.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -4,7 +4,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <logging.h>\n-#include <utiltime.h>\n+#include <util/time.h>\n \n const char * const DEFAULT_DEBUGLOGFILE = \"debug.log\";\n "
      },
      {
        "sha": "0c37bab1f865469499e6feea7c7abd5d2968a888",
        "filename": "src/merkleblock.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/merkleblock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/merkleblock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/merkleblock.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -7,7 +7,7 @@\n \n #include <hash.h>\n #include <consensus/consensus.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n \n \n CMerkleBlock::CMerkleBlock(const CBlock& block, CBloomFilter* filter, const std::set<uint256>* txids)"
      },
      {
        "sha": "feb86cab6683d2c234029ca593ebd1fd8232809b",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -21,8 +21,8 @@\n #include <primitives/transaction.h>\n #include <script/standard.h>\n #include <timedata.h>\n-#include <util.h>\n-#include <utilmoneystr.h>\n+#include <util/system.h>\n+#include <util/moneystr.h>\n #include <validationinterface.h>\n \n #include <algorithm>"
      },
      {
        "sha": "65a308780ade9abc251089f9a2a90367abed13da",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -18,7 +18,7 @@\n #include <netbase.h>\n #include <scheduler.h>\n #include <ui_interface.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n \n #ifdef WIN32\n #include <string.h>"
      },
      {
        "sha": "164ec9080c187a42e64439379f654994cba933e4",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -11,6 +11,7 @@\n #include <amount.h>\n #include <bloom.h>\n #include <compat.h>\n+#include <crypto/siphash.h>\n #include <hash.h>\n #include <limitedmap.h>\n #include <netaddress.h>"
      },
      {
        "sha": "f4ab3aa153fdc2b3ff57092deda8a629a13da9d9",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 3,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -25,9 +25,9 @@\n #include <tinyformat.h>\n #include <txmempool.h>\n #include <ui_interface.h>\n-#include <util.h>\n-#include <utilmoneystr.h>\n-#include <utilstrencodings.h>\n+#include <util/system.h>\n+#include <util/moneystr.h>\n+#include <util/strencodings.h>\n \n #include <memory>\n \n@@ -2357,6 +2357,23 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         for (const CTransactionRef& removedTx : lRemovedTxn)\n             AddToCompactExtraTransactions(removedTx);\n \n+        // If a tx has been detected by recentRejects, we will have reached\n+        // this point and the tx will have been ignored. Because we haven't run\n+        // the tx through AcceptToMemoryPool, we won't have computed a DoS\n+        // score for it or determined exactly why we consider it invalid.\n+        //\n+        // This means we won't penalize any peer subsequently relaying a DoSy\n+        // tx (even if we penalized the first peer who gave it to us) because\n+        // we have to account for recentRejects showing false positives. In\n+        // other words, we shouldn't penalize a peer if we aren't *sure* they\n+        // submitted a DoSy tx.\n+        //\n+        // Note that recentRejects doesn't just record DoSy or invalid\n+        // transactions, but any tx not accepted by the mempool, which may be\n+        // due to node policy (vs. consensus). So we can't blanket penalize a\n+        // peer simply for relaying a tx that our recentRejects has caught,\n+        // regardless of false positives.\n+\n         int nDoS = 0;\n         if (state.IsInvalid(nDoS))\n         {"
      },
      {
        "sha": "e1af4eff6263a783525322ce190ca775aa61e7bc",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -5,7 +5,7 @@\n \n #include <netaddress.h>\n #include <hash.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n #include <tinyformat.h>\n \n static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
      },
      {
        "sha": "6a750d5141060527b887def2c957c1f9a44f0e49",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -10,8 +10,8 @@\n #include <uint256.h>\n #include <random.h>\n #include <tinyformat.h>\n-#include <util.h>\n-#include <utilstrencodings.h>\n+#include <util/system.h>\n+#include <util/strencodings.h>\n \n #include <atomic>\n "
      },
      {
        "sha": "c7d8fee0ba70c5cc30b1b2bd67a2bf5c777cc2e5",
        "filename": "src/noui.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/noui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/noui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/noui.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -6,7 +6,7 @@\n #include <noui.h>\n \n #include <ui_interface.h>\n-#include <util.h>\n+#include <util/system.h>\n \n #include <cstdio>\n #include <stdint.h>"
      },
      {
        "sha": "3afe6fe1b795099e536576a4f2636db42b99d783",
        "filename": "src/policy/fees.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/policy/fees.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/policy/fees.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -10,7 +10,7 @@\n #include <primitives/transaction.h>\n #include <streams.h>\n #include <txmempool.h>\n-#include <util.h>\n+#include <util/system.h>\n \n static constexpr double INF_FEERATE = 1e99;\n "
      },
      {
        "sha": "d4cc538492b322b9a595bca87d8c187655062c10",
        "filename": "src/policy/policy.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/policy/policy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/policy/policy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -11,8 +11,8 @@\n #include <validation.h>\n #include <coins.h>\n #include <tinyformat.h>\n-#include <util.h>\n-#include <utilstrencodings.h>\n+#include <util/system.h>\n+#include <util/strencodings.h>\n \n \n CAmount GetDustThreshold(const CTxOut& txout, const CFeeRate& dustRelayFeeIn)"
      },
      {
        "sha": "0dc130d104b3e2bfccb098fcaa77284f3c775e4c",
        "filename": "src/policy/rbf.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/policy/rbf.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/policy/rbf.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/rbf.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -7,7 +7,7 @@\n bool SignalsOptInRBF(const CTransaction &tx)\n {\n     for (const CTxIn &txin : tx.vin) {\n-        if (txin.nSequence < std::numeric_limits<unsigned int>::max()-1) {\n+        if (txin.nSequence <= MAX_BIP125_RBF_SEQUENCE) {\n             return true;\n         }\n     }"
      },
      {
        "sha": "aa77573746f6a1b573f3748aaa986cbf40acd50b",
        "filename": "src/prevector.h",
        "status": "modified",
        "additions": 3,
        "deletions": 13,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/prevector.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/prevector.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/prevector.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -10,6 +10,7 @@\n #include <stdint.h>\n #include <string.h>\n \n+#include <algorithm>\n #include <cstddef>\n #include <iterator>\n #include <type_traits>\n@@ -198,22 +199,11 @@ class prevector {\n     const T* item_ptr(difference_type pos) const { return is_direct() ? direct_ptr(pos) : indirect_ptr(pos); }\n \n     void fill(T* dst, ptrdiff_t count) {\n-        if (IS_TRIVIALLY_CONSTRUCTIBLE<T>::value) {\n-            // The most common use of prevector is where T=unsigned char. For\n-            // trivially constructible types, we can use memset() to avoid\n-            // looping.\n-            ::memset(dst, 0, count * sizeof(T));\n-        } else {\n-            for (auto i = 0; i < count; ++i) {\n-                new(static_cast<void*>(dst + i)) T();\n-            }\n-        }\n+        std::fill_n(dst, count, T{});\n     }\n \n     void fill(T* dst, ptrdiff_t count, const T& value) {\n-        for (auto i = 0; i < count; ++i) {\n-            new(static_cast<void*>(dst + i)) T(value);\n-        }\n+        std::fill_n(dst, count, value);\n     }\n \n     template<typename InputIterator>"
      },
      {
        "sha": "a0c2e3f1257497e4bcb9e4eb7add10e41d0e625c",
        "filename": "src/primitives/block.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/primitives/block.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/primitives/block.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/block.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -7,7 +7,7 @@\n \n #include <hash.h>\n #include <tinyformat.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n #include <crypto/common.h>\n \n uint256 CBlockHeader::GetHash() const"
      },
      {
        "sha": "28c145f71d0c795d210b2863ae2440a7dbe56fba",
        "filename": "src/primitives/transaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/primitives/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/primitives/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -7,7 +7,7 @@\n \n #include <hash.h>\n #include <tinyformat.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n \n std::string COutPoint::ToString() const\n {"
      },
      {
        "sha": "bdf236c2c76b203391a637ee383b9bf340727f1b",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -5,8 +5,8 @@\n \n #include <protocol.h>\n \n-#include <util.h>\n-#include <utilstrencodings.h>\n+#include <util/system.h>\n+#include <util/strencodings.h>\n \n #ifndef WIN32\n # include <arpa/inet.h>"
      },
      {
        "sha": "821c23c4674623662b89f8ae6ece025a476fd619",
        "filename": "src/qt/askpassphrasedialog.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 8,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/askpassphrasedialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/askpassphrasedialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/askpassphrasedialog.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -152,14 +152,15 @@ void AskPassphraseDialog::accept()\n         }\n         } break;\n     case Unlock:\n-        if(!model->setWalletLocked(false, oldpass))\n-        {\n-            QMessageBox::critical(this, tr(\"Wallet unlock failed\"),\n-                                  tr(\"The passphrase entered for the wallet decryption was incorrect.\"));\n-        }\n-        else\n-        {\n-            QDialog::accept(); // Success\n+        try {\n+            if (!model->setWalletLocked(false, oldpass)) {\n+                QMessageBox::critical(this, tr(\"Wallet unlock failed\"),\n+                                      tr(\"The passphrase entered for the wallet decryption was incorrect.\"));\n+            } else {\n+                QDialog::accept(); // Success\n+            }\n+        } catch (const std::runtime_error& e) {\n+            QMessageBox::critical(this, tr(\"Wallet unlock failed\"), e.what());\n         }\n         break;\n     case Decrypt:"
      },
      {
        "sha": "dcfe3dcc57e71c8c389e7bd9eaaa2c5342fcc452",
        "filename": "src/qt/bantablemodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/bantablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/bantablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bantablemodel.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -10,7 +10,7 @@\n \n #include <interfaces/node.h>\n #include <sync.h>\n-#include <utiltime.h>\n+#include <util/time.h>\n \n #include <QDebug>\n #include <QList>"
      },
      {
        "sha": "de236a016f6186c0d147816b82c418c2d5264e86",
        "filename": "src/qt/bitcoin.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -32,7 +32,7 @@\n #include <rpc/server.h>\n #include <ui_interface.h>\n #include <uint256.h>\n-#include <util.h>\n+#include <util/system.h>\n #include <warnings.h>\n \n #include <walletinitinterface.h>\n@@ -439,8 +439,10 @@ void BitcoinApplication::addWallet(WalletModel* walletModel)\n         window->setCurrentWallet(walletModel->getWalletName());\n     }\n \n+#ifdef ENABLE_BIP70\n     connect(walletModel, &WalletModel::coinsSent,\n         paymentServer, &PaymentServer::fetchPaymentACK);\n+#endif\n     connect(walletModel, &WalletModel::unload, this, &BitcoinApplication::removeWallet);\n \n     m_wallet_models.push_back(walletModel);\n@@ -467,7 +469,9 @@ void BitcoinApplication::initializeResult(bool success)\n         // Log this only after AppInitMain finishes, as then logging setup is guaranteed complete\n         qWarning() << \"Platform customization:\" << platformStyle->getName();\n #ifdef ENABLE_WALLET\n+#ifdef ENABLE_BIP70\n         PaymentServer::LoadRootCAs();\n+#endif\n         paymentServer->setOptionsModel(optionsModel);\n #endif\n \n@@ -536,7 +540,7 @@ WId BitcoinApplication::getMainWinId() const\n \n static void SetupUIArgs()\n {\n-#ifdef ENABLE_WALLET\n+#if defined(ENABLE_WALLET) && defined(ENABLE_BIP70)\n     gArgs.AddArg(\"-allowselfsignedrootcertificates\", strprintf(\"Allow self signed root certificates (default: %u)\", DEFAULT_SELFSIGNED_ROOTCERTS), true, OptionsCategory::GUI);\n #endif\n     gArgs.AddArg(\"-choosedatadir\", strprintf(\"Choose data directory on startup (default: %u)\", DEFAULT_CHOOSE_DATADIR), false, OptionsCategory::GUI);\n@@ -566,10 +570,8 @@ int main(int argc, char *argv[])\n     Q_INIT_RESOURCE(bitcoin_locale);\n \n     BitcoinApplication app(*node, argc, argv);\n-#if QT_VERSION > 0x050100\n     // Generate high-dpi pixmaps\n     QApplication::setAttribute(Qt::AA_UseHighDpiPixmaps);\n-#endif\n #if QT_VERSION >= 0x050600\n     QGuiApplication::setAttribute(Qt::AA_EnableHighDpiScaling);\n #endif"
      },
      {
        "sha": "558fcf50bab7f7288c7824a6e997f95e36999ffd",
        "filename": "src/qt/bitcoinamountfield.cpp",
        "status": "modified",
        "additions": 53,
        "deletions": 14,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/bitcoinamountfield.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/bitcoinamountfield.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoinamountfield.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -23,9 +23,7 @@ class AmountSpinBox: public QAbstractSpinBox\n \n public:\n     explicit AmountSpinBox(QWidget *parent):\n-        QAbstractSpinBox(parent),\n-        currentUnit(BitcoinUnits::BTC),\n-        singleStep(100000) // satoshis\n+        QAbstractSpinBox(parent)\n     {\n         setAlignment(Qt::AlignRight);\n \n@@ -44,10 +42,19 @@ class AmountSpinBox: public QAbstractSpinBox\n \n     void fixup(QString &input) const\n     {\n-        bool valid = false;\n-        CAmount val = parse(input, &valid);\n-        if(valid)\n-        {\n+        bool valid;\n+        CAmount val;\n+\n+        if (input.isEmpty() && !m_allow_empty) {\n+            valid = true;\n+            val = m_min_amount;\n+        } else {\n+            valid = false;\n+            val = parse(input, &valid);\n+        }\n+\n+        if (valid) {\n+            val = qBound(m_min_amount, val, m_max_amount);\n             input = BitcoinUnits::format(currentUnit, val, false, BitcoinUnits::separatorAlways);\n             lineEdit()->setText(input);\n         }\n@@ -64,12 +71,27 @@ class AmountSpinBox: public QAbstractSpinBox\n         Q_EMIT valueChanged();\n     }\n \n+    void SetAllowEmpty(bool allow)\n+    {\n+        m_allow_empty = allow;\n+    }\n+\n+    void SetMinValue(const CAmount& value)\n+    {\n+        m_min_amount = value;\n+    }\n+\n+    void SetMaxValue(const CAmount& value)\n+    {\n+        m_max_amount = value;\n+    }\n+\n     void stepBy(int steps)\n     {\n         bool valid = false;\n         CAmount val = value(&valid);\n         val = val + steps * singleStep;\n-        val = qMin(qMax(val, CAmount(0)), BitcoinUnits::maxMoney());\n+        val = qBound(m_min_amount, val, m_max_amount);\n         setValue(val);\n     }\n \n@@ -125,9 +147,12 @@ class AmountSpinBox: public QAbstractSpinBox\n     }\n \n private:\n-    int currentUnit;\n-    CAmount singleStep;\n+    int currentUnit{BitcoinUnits::BTC};\n+    CAmount singleStep{CAmount(100000)}; // satoshis\n     mutable QSize cachedMinimumSizeHint;\n+    bool m_allow_empty{true};\n+    CAmount m_min_amount{CAmount(0)};\n+    CAmount m_max_amount{BitcoinUnits::maxMoney()};\n \n     /**\n      * Parse a string into a number of base monetary units and\n@@ -174,11 +199,10 @@ class AmountSpinBox: public QAbstractSpinBox\n         StepEnabled rv = 0;\n         bool valid = false;\n         CAmount val = value(&valid);\n-        if(valid)\n-        {\n-            if(val > 0)\n+        if (valid) {\n+            if (val > m_min_amount)\n                 rv |= StepDownEnabled;\n-            if(val < BitcoinUnits::maxMoney())\n+            if (val < m_max_amount)\n                 rv |= StepUpEnabled;\n         }\n         return rv;\n@@ -275,6 +299,21 @@ void BitcoinAmountField::setValue(const CAmount& value)\n     amount->setValue(value);\n }\n \n+void BitcoinAmountField::SetAllowEmpty(bool allow)\n+{\n+    amount->SetAllowEmpty(allow);\n+}\n+\n+void BitcoinAmountField::SetMinValue(const CAmount& value)\n+{\n+    amount->SetMinValue(value);\n+}\n+\n+void BitcoinAmountField::SetMaxValue(const CAmount& value)\n+{\n+    amount->SetMaxValue(value);\n+}\n+\n void BitcoinAmountField::setReadOnly(bool fReadOnly)\n {\n     amount->setReadOnly(fReadOnly);"
      },
      {
        "sha": "650481e30d514e370671c19aac0323184ee0672a",
        "filename": "src/qt/bitcoinamountfield.h",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/bitcoinamountfield.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/bitcoinamountfield.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoinamountfield.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -31,6 +31,15 @@ class BitcoinAmountField: public QWidget\n     CAmount value(bool *value=0) const;\n     void setValue(const CAmount& value);\n \n+    /** If allow empty is set to false the field will be set to the minimum allowed value if left empty. **/\n+    void SetAllowEmpty(bool allow);\n+\n+    /** Set the minimum value in satoshis **/\n+    void SetMinValue(const CAmount& value);\n+\n+    /** Set the maximum value in satoshis **/\n+    void SetMaxValue(const CAmount& value);\n+\n     /** Set single step in satoshis **/\n     void setSingleStep(const CAmount& step);\n "
      },
      {
        "sha": "ef82351551f92bc550fb94b849d19970400b64c0",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 44,
        "deletions": 40,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -33,7 +33,7 @@\n #include <interfaces/node.h>\n #include <noui.h>\n #include <ui_interface.h>\n-#include <util.h>\n+#include <util/system.h>\n \n #include <iostream>\n \n@@ -92,12 +92,8 @@ BitcoinGUI::BitcoinGUI(interfaces::Node& node, const PlatformStyle *_platformSty\n         windowTitle += tr(\"Node\");\n     }\n     windowTitle += \" \" + networkStyle->getTitleAddText();\n-#ifndef Q_OS_MAC\n     QApplication::setWindowIcon(networkStyle->getTrayAndWindowIcon());\n     setWindowIcon(networkStyle->getTrayAndWindowIcon());\n-#else\n-    MacDockIconHandler::instance()->setIcon(networkStyle->getAppIcon());\n-#endif\n     setWindowTitle(windowTitle);\n \n     rpcConsole = new RPCConsole(node, _platformStyle, 0);\n@@ -131,7 +127,9 @@ BitcoinGUI::BitcoinGUI(interfaces::Node& node, const PlatformStyle *_platformSty\n     createToolBars();\n \n     // Create system tray icon and notification\n-    createTrayIcon(networkStyle);\n+    if (QSystemTrayIcon::isSystemTrayAvailable()) {\n+        createTrayIcon(networkStyle);\n+    }\n \n     // Create status bar\n     statusBar();\n@@ -211,6 +209,10 @@ BitcoinGUI::BitcoinGUI(interfaces::Node& node, const PlatformStyle *_platformSty\n         connect(progressBar, &GUIUtil::ClickableProgressBar::clicked, this, &BitcoinGUI::showModalOverlay);\n     }\n #endif\n+\n+#ifdef Q_OS_MAC\n+    m_app_nap_inhibitor = new CAppNapInhibitor;\n+#endif\n }\n \n BitcoinGUI::~BitcoinGUI()\n@@ -223,6 +225,7 @@ BitcoinGUI::~BitcoinGUI()\n     if(trayIcon) // Hide tray icon, as deleting will let it linger until quit (on Ubuntu)\n         trayIcon->hide();\n #ifdef Q_OS_MAC\n+    delete m_app_nap_inhibitor;\n     delete appMenuBar;\n     MacDockIconHandler::cleanup();\n #endif\n@@ -273,17 +276,17 @@ void BitcoinGUI::createActions()\n #ifdef ENABLE_WALLET\n     // These showNormalIfMinimized are needed because Send Coins and Receive Coins\n     // can be triggered from the tray menu, and need to show the GUI to be useful.\n-    connect(overviewAction, &QAction::triggered, this, static_cast<void (BitcoinGUI::*)()>(&BitcoinGUI::showNormalIfMinimized));\n+    connect(overviewAction, &QAction::triggered, [this]{ showNormalIfMinimized(); });\n     connect(overviewAction, &QAction::triggered, this, &BitcoinGUI::gotoOverviewPage);\n-    connect(sendCoinsAction, &QAction::triggered, this, static_cast<void (BitcoinGUI::*)()>(&BitcoinGUI::showNormalIfMinimized));\n+    connect(sendCoinsAction, &QAction::triggered, [this]{ showNormalIfMinimized(); });\n     connect(sendCoinsAction, &QAction::triggered, [this]{ gotoSendCoinsPage(); });\n-    connect(sendCoinsMenuAction, &QAction::triggered, this, static_cast<void (BitcoinGUI::*)()>(&BitcoinGUI::showNormalIfMinimized));\n+    connect(sendCoinsMenuAction, &QAction::triggered, [this]{ showNormalIfMinimized(); });\n     connect(sendCoinsMenuAction, &QAction::triggered, [this]{ gotoSendCoinsPage(); });\n-    connect(receiveCoinsAction, &QAction::triggered, this, static_cast<void (BitcoinGUI::*)()>(&BitcoinGUI::showNormalIfMinimized));\n+    connect(receiveCoinsAction, &QAction::triggered, [this]{ showNormalIfMinimized(); });\n     connect(receiveCoinsAction, &QAction::triggered, this, &BitcoinGUI::gotoReceiveCoinsPage);\n-    connect(receiveCoinsMenuAction, &QAction::triggered, this, static_cast<void (BitcoinGUI::*)()>(&BitcoinGUI::showNormalIfMinimized));\n+    connect(receiveCoinsMenuAction, &QAction::triggered, [this]{ showNormalIfMinimized(); });\n     connect(receiveCoinsMenuAction, &QAction::triggered, this, &BitcoinGUI::gotoReceiveCoinsPage);\n-    connect(historyAction, &QAction::triggered, this, static_cast<void (BitcoinGUI::*)()>(&BitcoinGUI::showNormalIfMinimized));\n+    connect(historyAction, &QAction::triggered, [this]{ showNormalIfMinimized(); });\n     connect(historyAction, &QAction::triggered, this, &BitcoinGUI::gotoHistoryPage);\n #endif // ENABLE_WALLET\n \n@@ -350,7 +353,9 @@ void BitcoinGUI::createActions()\n         connect(encryptWalletAction, &QAction::triggered, walletFrame, &WalletFrame::encryptWallet);\n         connect(backupWalletAction, &QAction::triggered, walletFrame, &WalletFrame::backupWallet);\n         connect(changePassphraseAction, &QAction::triggered, walletFrame, &WalletFrame::changePassphrase);\n+        connect(signMessageAction, &QAction::triggered, [this]{ showNormalIfMinimized(); });\n         connect(signMessageAction, &QAction::triggered, [this]{ gotoSignMessageTab(); });\n+        connect(verifyMessageAction, &QAction::triggered, [this]{ showNormalIfMinimized(); });\n         connect(verifyMessageAction, &QAction::triggered, [this]{ gotoVerifyMessageTab(); });\n         connect(usedSendingAddressesAction, &QAction::triggered, walletFrame, &WalletFrame::usedSendingAddresses);\n         connect(usedReceivingAddressesAction, &QAction::triggered, walletFrame, &WalletFrame::usedReceivingAddresses);\n@@ -585,6 +590,8 @@ void BitcoinGUI::setWalletActionsEnabled(bool enabled)\n \n void BitcoinGUI::createTrayIcon(const NetworkStyle *networkStyle)\n {\n+    assert(QSystemTrayIcon::isSystemTrayAvailable());\n+\n #ifndef Q_OS_MAC\n     trayIcon = new QSystemTrayIcon(this);\n     QString toolTip = tr(\"%1 client\").arg(tr(PACKAGE_NAME)) + \" \" + networkStyle->getTitleAddText();\n@@ -599,7 +606,7 @@ void BitcoinGUI::createTrayIcon(const NetworkStyle *networkStyle)\n void BitcoinGUI::createTrayIconMenu()\n {\n #ifndef Q_OS_MAC\n-    // return if trayIcon is unset (only on non-Mac OSes)\n+    // return if trayIcon is unset (only on non-macOSes)\n     if (!trayIcon)\n         return;\n \n@@ -608,15 +615,17 @@ void BitcoinGUI::createTrayIconMenu()\n \n     connect(trayIcon, &QSystemTrayIcon::activated, this, &BitcoinGUI::trayIconActivated);\n #else\n-    // Note: On Mac, the dock icon is used to provide the tray's functionality.\n+    // Note: On macOS, the Dock icon is used to provide the tray's functionality.\n     MacDockIconHandler *dockIconHandler = MacDockIconHandler::instance();\n-    dockIconHandler->setMainWindow(static_cast<QMainWindow*>(this));\n-    trayIconMenu = dockIconHandler->dockMenu();\n+    connect(dockIconHandler, &MacDockIconHandler::dockIconClicked, this, &BitcoinGUI::macosDockIconActivated);\n+\n+    trayIconMenu = new QMenu(this);\n+    trayIconMenu->setAsDockMenu();\n #endif\n \n-    // Configuration of the tray icon (or dock icon) icon menu\n+    // Configuration of the tray icon (or Dock icon) menu\n #ifndef Q_OS_MAC\n-    // Note: On Mac, the dock icon's menu already has show / hide action.\n+    // Note: On macOS, the Dock icon's menu already has Show / Hide action.\n     trayIconMenu->addAction(toggleHideAction);\n     trayIconMenu->addSeparator();\n #endif\n@@ -630,7 +639,7 @@ void BitcoinGUI::createTrayIconMenu()\n         trayIconMenu->addAction(openRPCConsoleAction);\n     }\n     trayIconMenu->addAction(optionsAction);\n-#ifndef Q_OS_MAC // This is built-in on Mac\n+#ifndef Q_OS_MAC // This is built-in on macOS\n     trayIconMenu->addSeparator();\n     trayIconMenu->addAction(quitAction);\n #endif\n@@ -645,6 +654,12 @@ void BitcoinGUI::trayIconActivated(QSystemTrayIcon::ActivationReason reason)\n         toggleHidden();\n     }\n }\n+#else\n+void BitcoinGUI::macosDockIconActivated()\n+{\n+    show();\n+    activateWindow();\n+}\n #endif\n \n void BitcoinGUI::optionsClicked()\n@@ -663,10 +678,7 @@ void BitcoinGUI::aboutClicked()\n \n void BitcoinGUI::showDebugWindow()\n {\n-    rpcConsole->showNormal();\n-    rpcConsole->show();\n-    rpcConsole->raise();\n-    rpcConsole->activateWindow();\n+    GUIUtil::bringToFront(rpcConsole);\n }\n \n void BitcoinGUI::showDebugWindowActivateConsole()\n@@ -786,6 +798,11 @@ void BitcoinGUI::openOptionsDialogWithTab(OptionsDialog::Tab tab)\n \n void BitcoinGUI::setNumBlocks(int count, const QDateTime& blockDate, double nVerificationProgress, bool header)\n {\n+// Disabling macOS App Nap on initial sync, disk and reindex operations.\n+#ifdef Q_OS_MAC\n+    (m_node.isInitialBlockDownload() || m_node.getReindex() || m_node.getImporting()) ? m_app_nap_inhibitor->disableAppNap() : m_app_nap_inhibitor->enableAppNap();\n+#endif\n+\n     if (modalOverlay)\n     {\n         if (header)\n@@ -1148,24 +1165,11 @@ void BitcoinGUI::showNormalIfMinimized(bool fToggleHidden)\n     if(!clientModel)\n         return;\n \n-    // activateWindow() (sometimes) helps with keyboard focus on Windows\n-    if (isHidden())\n-    {\n-        show();\n-        activateWindow();\n-    }\n-    else if (isMinimized())\n-    {\n-        showNormal();\n-        activateWindow();\n-    }\n-    else if (GUIUtil::isObscured(this))\n-    {\n-        raise();\n-        activateWindow();\n-    }\n-    else if(fToggleHidden)\n+    if (!isHidden() && !isMinimized() && !GUIUtil::isObscured(this) && fToggleHidden) {\n         hide();\n+    } else {\n+        GUIUtil::bringToFront(this);\n+    }\n }\n \n void BitcoinGUI::toggleHidden()"
      },
      {
        "sha": "e8b857c17cd795a583e864def210be47ce342952",
        "filename": "src/qt/bitcoingui.h",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/bitcoingui.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/bitcoingui.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -20,6 +20,10 @@\n #include <QPoint>\n #include <QSystemTrayIcon>\n \n+#ifdef Q_OS_MAC\n+#include <qt/macos_appnap.h>\n+#endif\n+\n #include <memory>\n \n class ClientModel;\n@@ -143,6 +147,10 @@ class BitcoinGUI : public QMainWindow\n     HelpMessageDialog* helpMessageDialog = nullptr;\n     ModalOverlay* modalOverlay = nullptr;\n \n+#ifdef Q_OS_MAC\n+    CAppNapInhibitor* m_app_nap_inhibitor = nullptr;\n+#endif\n+\n     /** Keep track of previous number of blocks, to detect progress */\n     int prevBlocks = 0;\n     int spinnerFrame = 0;\n@@ -260,6 +268,9 @@ public Q_SLOTS:\n #ifndef Q_OS_MAC\n     /** Handle tray icon clicked */\n     void trayIconActivated(QSystemTrayIcon::ActivationReason reason);\n+#else\n+    /** Handle macOS Dock icon clicked */\n+    void macosDockIconActivated();\n #endif\n \n     /** Show window if hidden, unminimize when minimized, rise when obscured or show if hidden and fToggleHidden is true */"
      },
      {
        "sha": "75012b279cb81f8c67620f091d51cc3f6ca4bdc1",
        "filename": "src/qt/clientmodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/clientmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/clientmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -20,7 +20,7 @@\n #include <netbase.h>\n #include <txmempool.h>\n #include <ui_interface.h>\n-#include <util.h>\n+#include <util/system.h>\n #include <warnings.h>\n \n #include <stdint.h>"
      },
      {
        "sha": "ea970c0bc9a40b3975a4e50d50d616fd66829d7f",
        "filename": "src/qt/coincontroldialog.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/coincontroldialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/coincontroldialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroldialog.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -2,10 +2,15 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n #include <qt/coincontroldialog.h>\n #include <qt/forms/ui_coincontroldialog.h>\n \n #include <qt/addresstablemodel.h>\n+#include <base58.h>\n #include <qt/bitcoinunits.h>\n #include <qt/guiutil.h>\n #include <qt/optionsmodel.h>"
      },
      {
        "sha": "386d5592818b1ca889f41cfda8b7d9650f515168",
        "filename": "src/qt/forms/sendcoinsdialog.ui",
        "status": "modified",
        "additions": 3,
        "deletions": 38,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/forms/sendcoinsdialog.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/forms/sendcoinsdialog.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/sendcoinsdialog.ui?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -878,28 +878,15 @@ Note:  Since the fee is calculated on a per-byte basis, a fee of \"100 satoshis p\n                <item>\n                 <layout class=\"QHBoxLayout\" name=\"horizontalLayoutFee8\">\n                  <item>\n-                  <widget class=\"QCheckBox\" name=\"checkBoxMinimumFee\">\n-                   <property name=\"toolTip\">\n-                    <string>Paying only the minimum fee is just fine as long as there is less transaction volume than space in the blocks. But be aware that this can end up in a never confirming transaction once there is more demand for bitcoin transactions than the network can process.</string>\n-                   </property>\n-                   <property name=\"text\">\n-                    <string/>\n-                   </property>\n-                  </widget>\n-                 </item>\n-                 <item>\n-                  <widget class=\"QLabel\" name=\"labelMinFeeWarning\">\n+                  <widget class=\"QLabel\" name=\"labelCustomFeeWarning\">\n                    <property name=\"enabled\">\n                     <bool>true</bool>\n                    </property>\n                    <property name=\"toolTip\">\n-                    <string>Paying only the minimum fee is just fine as long as there is less transaction volume than space in the blocks. But be aware that this can end up in a never confirming transaction once there is more demand for bitcoin transactions than the network can process.</string>\n+                    <string>When there is less transaction volume than space in the blocks, miners as well as relaying nodes may enforce a minimum fee. Paying only this minimum fee is just fine, but be aware that this can result in a never confirming transaction once there is more demand for bitcoin transactions than the network can process.</string>\n                    </property>\n                    <property name=\"text\">\n-                    <string>(read the tooltip)</string>\n-                   </property>\n-                   <property name=\"margin\">\n-                    <number>5</number>\n+                    <string>A too low fee might result in a never confirming transaction (read the tooltip)</string>\n                    </property>\n                   </widget>\n                  </item>\n@@ -992,9 +979,6 @@ Note:  Since the fee is calculated on a per-byte basis, a fee of \"100 satoshis p\n                    <property name=\"text\">\n                     <string/>\n                    </property>\n-                   <property name=\"margin\">\n-                    <number>2</number>\n-                   </property>\n                   </widget>\n                  </item>\n                  <item>\n@@ -1009,9 +993,6 @@ Note:  Since the fee is calculated on a per-byte basis, a fee of \"100 satoshis p\n                    <property name=\"text\">\n                     <string>(Smart fee not initialized yet. This usually takes a few blocks...)</string>\n                    </property>\n-                   <property name=\"margin\">\n-                    <number>2</number>\n-                   </property>\n                   </widget>\n                  </item>\n                  <item>\n@@ -1038,24 +1019,8 @@ Note:  Since the fee is calculated on a per-byte basis, a fee of \"100 satoshis p\n                      <property name=\"text\">\n                       <string>Confirmation time target:</string>\n                      </property>\n-                     <property name=\"margin\">\n-                      <number>2</number>\n-                     </property>\n                     </widget>\n                    </item>\n-                   <item>\n-                    <spacer name=\"verticalSpacer_3\">\n-                     <property name=\"orientation\">\n-                      <enum>Qt::Vertical</enum>\n-                     </property>\n-                     <property name=\"sizeHint\" stdset=\"0\">\n-                      <size>\n-                       <width>1</width>\n-                       <height>1</height>\n-                      </size>\n-                     </property>\n-                    </spacer>\n-                   </item>\n                   </layout>\n                  </item>\n                  <item>"
      },
      {
        "sha": "0e9aca21b1da4803cfb5023f867d939b64ae7eb3",
        "filename": "src/qt/guiutil.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 14,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/guiutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/guiutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -18,7 +18,7 @@\n #include <protocol.h>\n #include <script/script.h>\n #include <script/standard.h>\n-#include <util.h>\n+#include <util/system.h>\n \n #ifdef WIN32\n #ifdef _WIN32_WINNT\n@@ -47,6 +47,7 @@\n #include <QDoubleValidator>\n #include <QFileDialog>\n #include <QFont>\n+#include <QFontDatabase>\n #include <QKeyEvent>\n #include <QLineEdit>\n #include <QSettings>\n@@ -55,9 +56,12 @@\n #include <QUrlQuery>\n #include <QMouseEvent>\n \n+#if defined(Q_OS_MAC)\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n \n-#if QT_VERSION >= 0x50200\n-#include <QFontDatabase>\n+#include <objc/objc-runtime.h>\n+#include <CoreServices/CoreServices.h>\n #endif\n \n namespace GUIUtil {\n@@ -74,13 +78,7 @@ QString dateTimeStr(qint64 nTime)\n \n QFont fixedPitchFont()\n {\n-#if QT_VERSION >= 0x50200\n     return QFontDatabase::systemFont(QFontDatabase::FixedFont);\n-#else\n-    QFont font(\"Monospace\");\n-    font.setStyleHint(QFont::Monospace);\n-    return font;\n-#endif\n }\n \n // Just some dummy data to generate a convincing random-looking (but consistent) address\n@@ -353,6 +351,27 @@ bool isObscured(QWidget *w)\n         && checkPoint(QPoint(w->width() / 2, w->height() / 2), w));\n }\n \n+void bringToFront(QWidget* w)\n+{\n+#ifdef Q_OS_MAC\n+    // Force application activation on macOS. With Qt 5.4 this is required when\n+    // an action in the dock menu is triggered.\n+    id app = objc_msgSend((id) objc_getClass(\"NSApplication\"), sel_registerName(\"sharedApplication\"));\n+    objc_msgSend(app, sel_registerName(\"activateIgnoringOtherApps:\"), YES);\n+#endif\n+\n+    if (w) {\n+        // activateWindow() (sometimes) helps with keyboard focus on Windows\n+        if (w->isMinimized()) {\n+            w->showNormal();\n+        } else {\n+            w->show();\n+        }\n+        w->activateWindow();\n+        w->raise();\n+    }\n+}\n+\n void openDebugLogfile()\n {\n     fs::path pathDebug = GetDataDir() / \"debug.log\";\n@@ -663,13 +682,8 @@ bool SetStartOnSystemStartup(bool fAutoStart)\n \n \n #elif defined(Q_OS_MAC)\n-#pragma GCC diagnostic push\n-#pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n // based on: https://github.com/Mozketo/LaunchAtLoginController/blob/master/LaunchAtLoginController.m\n \n-#include <CoreFoundation/CoreFoundation.h>\n-#include <CoreServices/CoreServices.h>\n-\n LSSharedFileListItemRef findStartupItemInList(LSSharedFileListRef list, CFURLRef findUrl);\n LSSharedFileListItemRef findStartupItemInList(LSSharedFileListRef list, CFURLRef findUrl)\n {"
      },
      {
        "sha": "f1d0aa48efc79cc4d7efc62f9e78f834929ad34c",
        "filename": "src/qt/guiutil.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/guiutil.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/guiutil.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -115,6 +115,9 @@ namespace GUIUtil\n     // Determine whether a widget is hidden behind other windows\n     bool isObscured(QWidget *w);\n \n+    // Activate, show and raise the widget\n+    void bringToFront(QWidget* w);\n+\n     // Open debug.log\n     void openDebugLogfile();\n "
      },
      {
        "sha": "0b61b05318dbf9c0b584a6900de81c5c9a07c1b4",
        "filename": "src/qt/intro.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/intro.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/intro.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/intro.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -13,7 +13,7 @@\n #include <qt/guiutil.h>\n \n #include <interfaces/node.h>\n-#include <util.h>\n+#include <util/system.h>\n \n #include <QFileDialog>\n #include <QSettings>"
      },
      {
        "sha": "ff867e21a79c010f70c473978f85f10a22e55972",
        "filename": "src/qt/macdockiconhandler.h",
        "status": "modified",
        "additions": 2,
        "deletions": 19,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/macdockiconhandler.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/macdockiconhandler.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/macdockiconhandler.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -1,44 +1,27 @@\n-// Copyright (c) 2011-2015 The Bitcoin Core developers\n+// Copyright (c) 2011-2018 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #ifndef BITCOIN_QT_MACDOCKICONHANDLER_H\n #define BITCOIN_QT_MACDOCKICONHANDLER_H\n \n-#include <QMainWindow>\n #include <QObject>\n \n-QT_BEGIN_NAMESPACE\n-class QIcon;\n-class QMenu;\n-class QWidget;\n-QT_END_NAMESPACE\n-\n-/** Macintosh-specific dock icon handler.\n+/** macOS-specific Dock icon handler.\n  */\n class MacDockIconHandler : public QObject\n {\n     Q_OBJECT\n \n public:\n-    ~MacDockIconHandler();\n-\n-    QMenu *dockMenu();\n-    void setIcon(const QIcon &icon);\n-    void setMainWindow(QMainWindow *window);\n     static MacDockIconHandler *instance();\n     static void cleanup();\n-    void handleDockIconClickEvent();\n \n Q_SIGNALS:\n     void dockIconClicked();\n \n private:\n     MacDockIconHandler();\n-\n-    QWidget *m_dummyWidget;\n-    QMenu *m_dockMenu;\n-    QMainWindow *mainWindow;\n };\n \n #endif // BITCOIN_QT_MACDOCKICONHANDLER_H"
      },
      {
        "sha": "102adce6c5fb61159b5f8b0df94f500aa38f23b9",
        "filename": "src/qt/macdockiconhandler.mm",
        "status": "modified",
        "additions": 9,
        "deletions": 91,
        "changes": 100,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/macdockiconhandler.mm",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/macdockiconhandler.mm",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/macdockiconhandler.mm?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -1,107 +1,36 @@\n-// Copyright (c) 2011-2013 The Bitcoin Core developers\n+// Copyright (c) 2011-2018 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"macdockiconhandler.h\"\n \n-#include <QImageWriter>\n-#include <QMenu>\n-#include <QBuffer>\n-#include <QWidget>\n-\n #undef slots\n-#include <Cocoa/Cocoa.h>\n #include <objc/objc.h>\n #include <objc/message.h>\n \n static MacDockIconHandler *s_instance = nullptr;\n \n-bool dockClickHandler(id self,SEL _cmd,...) {\n+bool dockClickHandler(id self, SEL _cmd, ...) {\n     Q_UNUSED(self)\n     Q_UNUSED(_cmd)\n \n-    s_instance->handleDockIconClickEvent();\n+    Q_EMIT s_instance->dockIconClicked();\n \n-    // Return NO (false) to suppress the default OS X actions\n+    // Return NO (false) to suppress the default macOS actions\n     return false;\n }\n \n void setupDockClickHandler() {\n-    Class cls = objc_getClass(\"NSApplication\");\n-    id appInst = objc_msgSend((id)cls, sel_registerName(\"sharedApplication\"));\n-\n-    if (appInst != nullptr) {\n-        id delegate = objc_msgSend(appInst, sel_registerName(\"delegate\"));\n-        Class delClass = (Class)objc_msgSend(delegate,  sel_registerName(\"class\"));\n-        SEL shouldHandle = sel_registerName(\"applicationShouldHandleReopen:hasVisibleWindows:\");\n-        if (class_getInstanceMethod(delClass, shouldHandle))\n-            class_replaceMethod(delClass, shouldHandle, (IMP)dockClickHandler, \"B@:\");\n-        else\n-            class_addMethod(delClass, shouldHandle, (IMP)dockClickHandler,\"B@:\");\n-    }\n+    id app = objc_msgSend((id)objc_getClass(\"NSApplication\"), sel_registerName(\"sharedApplication\"));\n+    id delegate = objc_msgSend(app, sel_registerName(\"delegate\"));\n+    Class delClass = (Class)objc_msgSend(delegate, sel_registerName(\"class\"));\n+    SEL shouldHandle = sel_registerName(\"applicationShouldHandleReopen:hasVisibleWindows:\");\n+    class_replaceMethod(delClass, shouldHandle, (IMP)dockClickHandler, \"B@:\");\n }\n \n-\n MacDockIconHandler::MacDockIconHandler() : QObject()\n {\n-    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n-\n     setupDockClickHandler();\n-    this->m_dummyWidget = new QWidget();\n-    this->m_dockMenu = new QMenu(this->m_dummyWidget);\n-    this->setMainWindow(nullptr);\n-#if QT_VERSION >= 0x050200\n-    this->m_dockMenu->setAsDockMenu();\n-#endif\n-    [pool release];\n-}\n-\n-void MacDockIconHandler::setMainWindow(QMainWindow *window) {\n-    this->mainWindow = window;\n-}\n-\n-MacDockIconHandler::~MacDockIconHandler()\n-{\n-    delete this->m_dummyWidget;\n-    this->setMainWindow(nullptr);\n-}\n-\n-QMenu *MacDockIconHandler::dockMenu()\n-{\n-    return this->m_dockMenu;\n-}\n-\n-void MacDockIconHandler::setIcon(const QIcon &icon)\n-{\n-    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n-    NSImage *image = nil;\n-    if (icon.isNull())\n-        image = [[NSImage imageNamed:@\"NSApplicationIcon\"] retain];\n-    else {\n-        // generate NSImage from QIcon and use this as dock icon.\n-        QSize size = icon.actualSize(QSize(128, 128));\n-        QPixmap pixmap = icon.pixmap(size);\n-\n-        // Write image into a R/W buffer from raw pixmap, then save the image.\n-        QBuffer notificationBuffer;\n-        if (!pixmap.isNull() && notificationBuffer.open(QIODevice::ReadWrite)) {\n-            QImageWriter writer(&notificationBuffer, \"PNG\");\n-            if (writer.write(pixmap.toImage())) {\n-                NSData* macImgData = [NSData dataWithBytes:notificationBuffer.buffer().data()\n-                                             length:notificationBuffer.buffer().size()];\n-                image =  [[NSImage alloc] initWithData:macImgData];\n-            }\n-        }\n-\n-        if(!image) {\n-            // if testnet image could not be created, load std. app icon\n-            image = [[NSImage imageNamed:@\"NSApplicationIcon\"] retain];\n-        }\n-    }\n-\n-    [NSApp setApplicationIconImage:image];\n-    [image release];\n-    [pool release];\n }\n \n MacDockIconHandler *MacDockIconHandler::instance()\n@@ -115,14 +44,3 @@ void setupDockClickHandler() {\n {\n     delete s_instance;\n }\n-\n-void MacDockIconHandler::handleDockIconClickEvent()\n-{\n-    if (this->mainWindow)\n-    {\n-        this->mainWindow->activateWindow();\n-        this->mainWindow->show();\n-    }\n-\n-    Q_EMIT this->dockIconClicked();\n-}"
      },
      {
        "sha": "8c2cd840b01c8738e94a58188aff008adc3d2be3",
        "filename": "src/qt/macos_appnap.h",
        "status": "added",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/macos_appnap.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/macos_appnap.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/macos_appnap.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -0,0 +1,24 @@\n+// Copyright (c) 2011-2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_QT_MACOS_APPNAP_H\n+#define BITCOIN_QT_MACOS_APPNAP_H\n+\n+#include <memory>\n+\n+class CAppNapInhibitor final\n+{\n+public:\n+    explicit CAppNapInhibitor();\n+    ~CAppNapInhibitor();\n+\n+    void disableAppNap();\n+    void enableAppNap();\n+\n+private:\n+    class CAppNapImpl;\n+    std::unique_ptr<CAppNapImpl> impl;\n+};\n+\n+#endif // BITCOIN_QT_MACOS_APPNAP_H"
      },
      {
        "sha": "22a88782abe39d978ee6f4207c81f5df3b54e338",
        "filename": "src/qt/macos_appnap.mm",
        "status": "added",
        "additions": 71,
        "deletions": 0,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/macos_appnap.mm",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/macos_appnap.mm",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/macos_appnap.mm?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -0,0 +1,71 @@\n+// Copyright (c) 2011-2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"macos_appnap.h\"\n+\n+#include <AvailabilityMacros.h>\n+#include <Foundation/NSProcessInfo.h>\n+#include <Foundation/Foundation.h>\n+\n+class CAppNapInhibitor::CAppNapImpl\n+{\n+public:\n+    ~CAppNapImpl()\n+    {\n+        if(activityId)\n+            enableAppNap();\n+    }\n+\n+    void disableAppNap()\n+    {\n+        if (!activityId)\n+        {\n+            @autoreleasepool {\n+                const NSActivityOptions activityOptions =\n+                NSActivityUserInitiatedAllowingIdleSystemSleep &\n+                ~(NSActivitySuddenTerminationDisabled |\n+                NSActivityAutomaticTerminationDisabled);\n+\n+                id processInfo = [NSProcessInfo processInfo];\n+                if ([processInfo respondsToSelector:@selector(beginActivityWithOptions:reason:)])\n+                {\n+                    activityId = [processInfo beginActivityWithOptions: activityOptions reason:@\"Temporarily disable App Nap for bitcoin-qt.\"];\n+                    [activityId retain];\n+                }\n+            }\n+        }\n+    }\n+\n+    void enableAppNap()\n+    {\n+        if(activityId)\n+        {\n+            @autoreleasepool {\n+                id processInfo = [NSProcessInfo processInfo];\n+                if ([processInfo respondsToSelector:@selector(endActivity:)])\n+                    [processInfo endActivity:activityId];\n+\n+                [activityId release];\n+                activityId = nil;\n+            }\n+        }\n+    }\n+\n+private:\n+    NSObject* activityId;\n+};\n+\n+CAppNapInhibitor::CAppNapInhibitor() : impl(new CAppNapImpl()) {}\n+\n+CAppNapInhibitor::~CAppNapInhibitor() = default;\n+\n+void CAppNapInhibitor::disableAppNap()\n+{\n+    impl->disableAppNap();\n+}\n+\n+void CAppNapInhibitor::enableAppNap()\n+{\n+    impl->enableAppNap();\n+}"
      },
      {
        "sha": "c9871f6c669526e6ea6d7550db1d79904aaeb90c",
        "filename": "src/qt/optionsdialog.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 2,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/optionsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/optionsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsdialog.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -23,6 +23,7 @@\n #include <QIntValidator>\n #include <QLocale>\n #include <QMessageBox>\n+#include <QSystemTrayIcon>\n #include <QTimer>\n \n OptionsDialog::OptionsDialog(QWidget *parent, bool enableWallet) :\n@@ -126,6 +127,13 @@ OptionsDialog::OptionsDialog(QWidget *parent, bool enableWallet) :\n     connect(ui->proxyIpTor, &QValidatedLineEdit::validationDidChange, this, &OptionsDialog::updateProxyValidationState);\n     connect(ui->proxyPort, &QLineEdit::textChanged, this, &OptionsDialog::updateProxyValidationState);\n     connect(ui->proxyPortTor, &QLineEdit::textChanged, this, &OptionsDialog::updateProxyValidationState);\n+\n+    if (!QSystemTrayIcon::isSystemTrayAvailable()) {\n+        ui->hideTrayIcon->setChecked(true);\n+        ui->hideTrayIcon->setEnabled(false);\n+        ui->minimizeToTray->setChecked(false);\n+        ui->minimizeToTray->setEnabled(false);\n+    }\n }\n \n OptionsDialog::~OptionsDialog()\n@@ -211,8 +219,10 @@ void OptionsDialog::setMapper()\n \n     /* Window */\n #ifndef Q_OS_MAC\n-    mapper->addMapping(ui->hideTrayIcon, OptionsModel::HideTrayIcon);\n-    mapper->addMapping(ui->minimizeToTray, OptionsModel::MinimizeToTray);\n+    if (QSystemTrayIcon::isSystemTrayAvailable()) {\n+        mapper->addMapping(ui->hideTrayIcon, OptionsModel::HideTrayIcon);\n+        mapper->addMapping(ui->minimizeToTray, OptionsModel::MinimizeToTray);\n+    }\n     mapper->addMapping(ui->minimizeOnClose, OptionsModel::MinimizeOnClose);\n #endif\n "
      },
      {
        "sha": "b962ab1ef210b1145da6651bec8abda0f59ff44a",
        "filename": "src/qt/paymentrequestplus.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/paymentrequestplus.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/paymentrequestplus.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentrequestplus.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -9,7 +9,7 @@\n \n #include <qt/paymentrequestplus.h>\n \n-#include <util.h>\n+#include <util/system.h>\n \n #include <stdexcept>\n "
      },
      {
        "sha": "8148986b51dee0143e77950a1c85dd95fdb2e10b",
        "filename": "src/qt/paymentserver.cpp",
        "status": "modified",
        "additions": 166,
        "deletions": 135,
        "changes": 301,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/paymentserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/paymentserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentserver.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -2,6 +2,10 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n #include <qt/paymentserver.h>\n \n #include <qt/bitcoinunits.h>\n@@ -13,7 +17,7 @@\n #include <policy/policy.h>\n #include <key_io.h>\n #include <ui_interface.h>\n-#include <util.h>\n+#include <util/system.h>\n #include <wallet/wallet.h>\n \n #include <cstdlib>\n@@ -45,28 +49,15 @@\n \n const int BITCOIN_IPC_CONNECT_TIMEOUT = 1000; // milliseconds\n const QString BITCOIN_IPC_PREFIX(\"bitcoin:\");\n+#ifdef ENABLE_BIP70\n // BIP70 payment protocol messages\n const char* BIP70_MESSAGE_PAYMENTACK = \"PaymentACK\";\n const char* BIP70_MESSAGE_PAYMENTREQUEST = \"PaymentRequest\";\n // BIP71 payment protocol media types\n const char* BIP71_MIMETYPE_PAYMENT = \"application/bitcoin-payment\";\n const char* BIP71_MIMETYPE_PAYMENTACK = \"application/bitcoin-paymentack\";\n const char* BIP71_MIMETYPE_PAYMENTREQUEST = \"application/bitcoin-paymentrequest\";\n-\n-struct X509StoreDeleter {\n-      void operator()(X509_STORE* b) {\n-          X509_STORE_free(b);\n-      }\n-};\n-\n-struct X509Deleter {\n-      void operator()(X509* b) { X509_free(b); }\n-};\n-\n-namespace // Anon namespace\n-{\n-    std::unique_ptr<X509_STORE, X509StoreDeleter> certStore;\n-}\n+#endif\n \n //\n // Create a name that is unique for:\n@@ -93,94 +84,6 @@ static QString ipcServerName()\n \n static QList<QString> savedPaymentRequests;\n \n-static void ReportInvalidCertificate(const QSslCertificate& cert)\n-{\n-    qDebug() << QString(\"%1: Payment server found an invalid certificate: \").arg(__func__) << cert.serialNumber() << cert.subjectInfo(QSslCertificate::CommonName) << cert.subjectInfo(QSslCertificate::DistinguishedNameQualifier) << cert.subjectInfo(QSslCertificate::OrganizationalUnitName);\n-}\n-\n-//\n-// Load OpenSSL's list of root certificate authorities\n-//\n-void PaymentServer::LoadRootCAs(X509_STORE* _store)\n-{\n-    // Unit tests mostly use this, to pass in fake root CAs:\n-    if (_store)\n-    {\n-        certStore.reset(_store);\n-        return;\n-    }\n-\n-    // Normal execution, use either -rootcertificates or system certs:\n-    certStore.reset(X509_STORE_new());\n-\n-    // Note: use \"-system-\" default here so that users can pass -rootcertificates=\"\"\n-    // and get 'I don't like X.509 certificates, don't trust anybody' behavior:\n-    QString certFile = QString::fromStdString(gArgs.GetArg(\"-rootcertificates\", \"-system-\"));\n-\n-    // Empty store\n-    if (certFile.isEmpty()) {\n-        qDebug() << QString(\"PaymentServer::%1: Payment request authentication via X.509 certificates disabled.\").arg(__func__);\n-        return;\n-    }\n-\n-    QList<QSslCertificate> certList;\n-\n-    if (certFile != \"-system-\") {\n-            qDebug() << QString(\"PaymentServer::%1: Using \\\"%2\\\" as trusted root certificate.\").arg(__func__).arg(certFile);\n-\n-        certList = QSslCertificate::fromPath(certFile);\n-        // Use those certificates when fetching payment requests, too:\n-        QSslSocket::setDefaultCaCertificates(certList);\n-    } else\n-        certList = QSslSocket::systemCaCertificates();\n-\n-    int nRootCerts = 0;\n-    const QDateTime currentTime = QDateTime::currentDateTime();\n-\n-    for (const QSslCertificate& cert : certList) {\n-        // Don't log NULL certificates\n-        if (cert.isNull())\n-            continue;\n-\n-        // Not yet active/valid, or expired certificate\n-        if (currentTime < cert.effectiveDate() || currentTime > cert.expiryDate()) {\n-            ReportInvalidCertificate(cert);\n-            continue;\n-        }\n-\n-        // Blacklisted certificate\n-        if (cert.isBlacklisted()) {\n-            ReportInvalidCertificate(cert);\n-            continue;\n-        }\n-        QByteArray certData = cert.toDer();\n-        const unsigned char *data = (const unsigned char *)certData.data();\n-\n-        std::unique_ptr<X509, X509Deleter> x509(d2i_X509(0, &data, certData.size()));\n-        if (x509 && X509_STORE_add_cert(certStore.get(), x509.get()))\n-        {\n-            // Note: X509_STORE increases the reference count to the X509 object,\n-            // we still have to release our reference to it.\n-            ++nRootCerts;\n-        }\n-        else\n-        {\n-            ReportInvalidCertificate(cert);\n-            continue;\n-        }\n-    }\n-    qWarning() << \"PaymentServer::LoadRootCAs: Loaded \" << nRootCerts << \" root certificates\";\n-\n-    // Project for another day:\n-    // Fetch certificate revocation lists, and add them to certStore.\n-    // Issues to consider:\n-    //   performance (start a thread to fetch in background?)\n-    //   privacy (fetch through tor/proxy so IP address isn't revealed)\n-    //   would it be easier to just use a compiled-in blacklist?\n-    //    or use Qt's blacklist?\n-    //   \"certificate stapling\" with server-side caching is more efficient\n-}\n-\n //\n // Sending to the server is done synchronously, at startup.\n // If the server isn't already running, startup continues,\n@@ -221,6 +124,7 @@ void PaymentServer::ipcParseCommandLine(interfaces::Node& node, int argc, char*\n                 }\n             }\n         }\n+#ifdef ENABLE_BIP70\n         else if (QFile::exists(arg)) // Filename\n         {\n             savedPaymentRequests.append(arg);\n@@ -244,6 +148,7 @@ void PaymentServer::ipcParseCommandLine(interfaces::Node& node, int argc, char*\n             // GUI hasn't started yet so we can't pop up a message box.\n             qWarning() << \"PaymentServer::ipcSendCommandLine: Payment request file does not exist: \" << arg;\n         }\n+#endif\n     }\n }\n \n@@ -290,12 +195,16 @@ PaymentServer::PaymentServer(QObject* parent, bool startLocalServer) :\n     QObject(parent),\n     saveURIs(true),\n     uriServer(0),\n-    netManager(0),\n     optionsModel(0)\n+#ifdef ENABLE_BIP70\n+    ,netManager(0)\n+#endif\n {\n+#ifdef ENABLE_BIP70\n     // Verify that the version of the library that we linked against is\n     // compatible with the version of the headers we compiled against.\n     GOOGLE_PROTOBUF_VERIFY_VERSION;\n+#endif\n \n     // Install global event filter to catch QFileOpenEvents\n     // on Mac: sent when you click bitcoin: links\n@@ -319,14 +228,18 @@ PaymentServer::PaymentServer(QObject* parent, bool startLocalServer) :\n         }\n         else {\n             connect(uriServer, &QLocalServer::newConnection, this, &PaymentServer::handleURIConnection);\n+#ifdef ENABLE_BIP70\n             connect(this, &PaymentServer::receivedPaymentACK, this, &PaymentServer::handlePaymentACK);\n+#endif\n         }\n     }\n }\n \n PaymentServer::~PaymentServer()\n {\n+#ifdef ENABLE_BIP70\n     google::protobuf::ShutdownProtobufLibrary();\n+#endif\n }\n \n //\n@@ -349,33 +262,11 @@ bool PaymentServer::eventFilter(QObject *object, QEvent *event)\n     return QObject::eventFilter(object, event);\n }\n \n-void PaymentServer::initNetManager()\n-{\n-    if (!optionsModel)\n-        return;\n-    delete netManager;\n-\n-    // netManager is used to fetch paymentrequests given in bitcoin: URIs\n-    netManager = new QNetworkAccessManager(this);\n-\n-    QNetworkProxy proxy;\n-\n-    // Query active SOCKS5 proxy\n-    if (optionsModel->getProxySettings(proxy)) {\n-        netManager->setProxy(proxy);\n-\n-        qDebug() << \"PaymentServer::initNetManager: Using SOCKS5 proxy\" << proxy.hostName() << \":\" << proxy.port();\n-    }\n-    else\n-        qDebug() << \"PaymentServer::initNetManager: No active proxy server found.\";\n-\n-    connect(netManager, &QNetworkAccessManager::finished, this, &PaymentServer::netRequestFinished);\n-    connect(netManager, &QNetworkAccessManager::sslErrors, this, &PaymentServer::reportSslErrors);\n-}\n-\n void PaymentServer::uiReady()\n {\n+#ifdef ENABLE_BIP70\n     initNetManager();\n+#endif\n \n     saveURIs = false;\n     for (const QString& s : savedPaymentRequests)\n@@ -403,6 +294,10 @@ void PaymentServer::handleURIOrFile(const QString& s)\n         QUrlQuery uri((QUrl(s)));\n         if (uri.hasQueryItem(\"r\")) // payment request URI\n         {\n+#ifdef ENABLE_BIP70\n+            Q_EMIT message(tr(\"URI handling\"),\n+                tr(\"You are using a BIP70 URL which will be unsupported in the future.\"),\n+                CClientUIInterface::ICON_WARNING);\n             QByteArray temp;\n             temp.append(uri.queryItemValue(\"r\"));\n             QString decoded = QUrl::fromPercentEncoding(temp);\n@@ -420,7 +315,11 @@ void PaymentServer::handleURIOrFile(const QString& s)\n                     tr(\"Payment request fetch URL is invalid: %1\").arg(fetchUrl.toString()),\n                     CClientUIInterface::ICON_WARNING);\n             }\n-\n+#else\n+            Q_EMIT message(tr(\"URI handling\"),\n+                tr(\"Cannot process payment request because BIP70 support was not compiled in.\"),\n+                CClientUIInterface::ICON_WARNING);\n+#endif\n             return;\n         }\n         else // normal URI\n@@ -444,6 +343,7 @@ void PaymentServer::handleURIOrFile(const QString& s)\n         }\n     }\n \n+#ifdef ENABLE_BIP70\n     if (QFile::exists(s)) // payment request file\n     {\n         PaymentRequestPlus request;\n@@ -459,6 +359,7 @@ void PaymentServer::handleURIOrFile(const QString& s)\n \n         return;\n     }\n+#endif\n }\n \n void PaymentServer::handleURIConnection()\n@@ -481,6 +382,140 @@ void PaymentServer::handleURIConnection()\n     handleURIOrFile(msg);\n }\n \n+void PaymentServer::setOptionsModel(OptionsModel *_optionsModel)\n+{\n+    this->optionsModel = _optionsModel;\n+}\n+\n+#ifdef ENABLE_BIP70\n+struct X509StoreDeleter {\n+      void operator()(X509_STORE* b) {\n+          X509_STORE_free(b);\n+      }\n+};\n+\n+struct X509Deleter {\n+      void operator()(X509* b) { X509_free(b); }\n+};\n+\n+namespace // Anon namespace\n+{\n+    std::unique_ptr<X509_STORE, X509StoreDeleter> certStore;\n+}\n+\n+static void ReportInvalidCertificate(const QSslCertificate& cert)\n+{\n+    qDebug() << QString(\"%1: Payment server found an invalid certificate: \").arg(__func__) << cert.serialNumber() << cert.subjectInfo(QSslCertificate::CommonName) << cert.subjectInfo(QSslCertificate::DistinguishedNameQualifier) << cert.subjectInfo(QSslCertificate::OrganizationalUnitName);\n+}\n+\n+//\n+// Load OpenSSL's list of root certificate authorities\n+//\n+void PaymentServer::LoadRootCAs(X509_STORE* _store)\n+{\n+    // Unit tests mostly use this, to pass in fake root CAs:\n+    if (_store)\n+    {\n+        certStore.reset(_store);\n+        return;\n+    }\n+\n+    // Normal execution, use either -rootcertificates or system certs:\n+    certStore.reset(X509_STORE_new());\n+\n+    // Note: use \"-system-\" default here so that users can pass -rootcertificates=\"\"\n+    // and get 'I don't like X.509 certificates, don't trust anybody' behavior:\n+    QString certFile = QString::fromStdString(gArgs.GetArg(\"-rootcertificates\", \"-system-\"));\n+\n+    // Empty store\n+    if (certFile.isEmpty()) {\n+        qDebug() << QString(\"PaymentServer::%1: Payment request authentication via X.509 certificates disabled.\").arg(__func__);\n+        return;\n+    }\n+\n+    QList<QSslCertificate> certList;\n+\n+    if (certFile != \"-system-\") {\n+            qDebug() << QString(\"PaymentServer::%1: Using \\\"%2\\\" as trusted root certificate.\").arg(__func__).arg(certFile);\n+\n+        certList = QSslCertificate::fromPath(certFile);\n+        // Use those certificates when fetching payment requests, too:\n+        QSslSocket::setDefaultCaCertificates(certList);\n+    } else\n+        certList = QSslSocket::systemCaCertificates();\n+\n+    int nRootCerts = 0;\n+    const QDateTime currentTime = QDateTime::currentDateTime();\n+\n+    for (const QSslCertificate& cert : certList) {\n+        // Don't log NULL certificates\n+        if (cert.isNull())\n+            continue;\n+\n+        // Not yet active/valid, or expired certificate\n+        if (currentTime < cert.effectiveDate() || currentTime > cert.expiryDate()) {\n+            ReportInvalidCertificate(cert);\n+            continue;\n+        }\n+\n+        // Blacklisted certificate\n+        if (cert.isBlacklisted()) {\n+            ReportInvalidCertificate(cert);\n+            continue;\n+        }\n+\n+        QByteArray certData = cert.toDer();\n+        const unsigned char *data = (const unsigned char *)certData.data();\n+\n+        std::unique_ptr<X509, X509Deleter> x509(d2i_X509(0, &data, certData.size()));\n+        if (x509 && X509_STORE_add_cert(certStore.get(), x509.get()))\n+        {\n+            // Note: X509_STORE increases the reference count to the X509 object,\n+            // we still have to release our reference to it.\n+            ++nRootCerts;\n+        }\n+        else\n+        {\n+            ReportInvalidCertificate(cert);\n+            continue;\n+        }\n+    }\n+    qWarning() << \"PaymentServer::LoadRootCAs: Loaded \" << nRootCerts << \" root certificates\";\n+\n+    // Project for another day:\n+    // Fetch certificate revocation lists, and add them to certStore.\n+    // Issues to consider:\n+    //   performance (start a thread to fetch in background?)\n+    //   privacy (fetch through tor/proxy so IP address isn't revealed)\n+    //   would it be easier to just use a compiled-in blacklist?\n+    //    or use Qt's blacklist?\n+    //   \"certificate stapling\" with server-side caching is more efficient\n+}\n+\n+void PaymentServer::initNetManager()\n+{\n+    if (!optionsModel)\n+        return;\n+    delete netManager;\n+\n+    // netManager is used to fetch paymentrequests given in bitcoin: URIs\n+    netManager = new QNetworkAccessManager(this);\n+\n+    QNetworkProxy proxy;\n+\n+    // Query active SOCKS5 proxy\n+    if (optionsModel->getProxySettings(proxy)) {\n+        netManager->setProxy(proxy);\n+\n+        qDebug() << \"PaymentServer::initNetManager: Using SOCKS5 proxy\" << proxy.hostName() << \":\" << proxy.port();\n+    }\n+    else\n+        qDebug() << \"PaymentServer::initNetManager: No active proxy server found.\";\n+\n+    connect(netManager, &QNetworkAccessManager::finished, this, &PaymentServer::netRequestFinished);\n+    connect(netManager, &QNetworkAccessManager::sslErrors, this, &PaymentServer::reportSslErrors);\n+}\n+\n //\n // Warning: readPaymentRequestFromFile() is used in ipcSendCommandLine()\n // so don't use \"Q_EMIT message()\", but \"QMessageBox::\"!\n@@ -731,11 +766,6 @@ void PaymentServer::reportSslErrors(QNetworkReply* reply, const QList<QSslError>\n     Q_EMIT message(tr(\"Network request error\"), errString, CClientUIInterface::MSG_ERROR);\n }\n \n-void PaymentServer::setOptionsModel(OptionsModel *_optionsModel)\n-{\n-    this->optionsModel = _optionsModel;\n-}\n-\n void PaymentServer::handlePaymentACK(const QString& paymentACKMsg)\n {\n     // currently we don't further process or store the paymentACK message\n@@ -794,3 +824,4 @@ X509_STORE* PaymentServer::getCertStore()\n {\n     return certStore.get();\n }\n+#endif"
      },
      {
        "sha": "30b5bc3b6d6d74fc9fd9486d58abf8172e8bcd66",
        "filename": "src/qt/paymentserver.h",
        "status": "modified",
        "additions": 29,
        "deletions": 15,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/paymentserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/paymentserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentserver.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -32,7 +32,13 @@\n // sends them to the server.\n //\n \n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#ifdef ENABLE_BIP70\n #include <qt/paymentrequestplus.h>\n+#endif\n #include <qt/walletmodel.h>\n \n #include <QObject>\n@@ -73,6 +79,10 @@ class PaymentServer : public QObject\n     explicit PaymentServer(QObject* parent, bool startLocalServer = true);\n     ~PaymentServer();\n \n+    // OptionsModel is used for getting proxy settings and display unit\n+    void setOptionsModel(OptionsModel *optionsModel);\n+\n+#ifdef ENABLE_BIP70\n     // Load root certificate authorities. Pass nullptr (default)\n     // to read from the file specified in the -rootcertificates setting,\n     // or, if that's not set, to use the system default root certificates.\n@@ -83,9 +93,6 @@ class PaymentServer : public QObject\n     // Return certificate store\n     static X509_STORE* getCertStore();\n \n-    // OptionsModel is used for getting proxy settings and display unit\n-    void setOptionsModel(OptionsModel *optionsModel);\n-\n     // Verify that the payment request network matches the client network\n     static bool verifyNetwork(interfaces::Node& node, const payments::PaymentDetails& requestDetails);\n     // Verify if the payment request is expired\n@@ -94,53 +101,60 @@ class PaymentServer : public QObject\n     static bool verifySize(qint64 requestSize);\n     // Verify the payment request amount is valid\n     static bool verifyAmount(const CAmount& requestAmount);\n+#endif\n \n Q_SIGNALS:\n     // Fired when a valid payment request is received\n     void receivedPaymentRequest(SendCoinsRecipient);\n \n-    // Fired when a valid PaymentACK is received\n-    void receivedPaymentACK(const QString &paymentACKMsg);\n-\n     // Fired when a message should be reported to the user\n     void message(const QString &title, const QString &message, unsigned int style);\n \n+#ifdef ENABLE_BIP70\n+    // Fired when a valid PaymentACK is received\n+    void receivedPaymentACK(const QString &paymentACKMsg);\n+#endif\n+\n public Q_SLOTS:\n     // Signal this when the main window's UI is ready\n     // to display payment requests to the user\n     void uiReady();\n \n-    // Submit Payment message to a merchant, get back PaymentACK:\n-    void fetchPaymentACK(WalletModel* walletModel, const SendCoinsRecipient& recipient, QByteArray transaction);\n-\n     // Handle an incoming URI, URI with local file scheme or file\n     void handleURIOrFile(const QString& s);\n \n+#ifdef ENABLE_BIP70\n+    // Submit Payment message to a merchant, get back PaymentACK:\n+    void fetchPaymentACK(WalletModel* walletModel, const SendCoinsRecipient& recipient, QByteArray transaction);\n+#endif\n+\n private Q_SLOTS:\n     void handleURIConnection();\n+#ifdef ENABLE_BIP70\n     void netRequestFinished(QNetworkReply*);\n     void reportSslErrors(QNetworkReply*, const QList<QSslError> &);\n     void handlePaymentACK(const QString& paymentACKMsg);\n+#endif\n \n protected:\n     // Constructor registers this on the parent QApplication to\n     // receive QEvent::FileOpen and QEvent:Drop events\n     bool eventFilter(QObject *object, QEvent *event);\n \n private:\n+    bool saveURIs;                      // true during startup\n+    QLocalServer* uriServer;\n+    OptionsModel *optionsModel;\n+\n+#ifdef ENABLE_BIP70\n     static bool readPaymentRequestFromFile(const QString& filename, PaymentRequestPlus& request);\n     bool processPaymentRequest(const PaymentRequestPlus& request, SendCoinsRecipient& recipient);\n     void fetchRequest(const QUrl& url);\n \n     // Setup networking\n     void initNetManager();\n-\n-    bool saveURIs;                      // true during startup\n-    QLocalServer* uriServer;\n-\n     QNetworkAccessManager* netManager;  // Used to fetch payment requests\n-\n-    OptionsModel *optionsModel;\n+#endif\n };\n \n #endif // BITCOIN_QT_PAYMENTSERVER_H"
      },
      {
        "sha": "606f1d2910ef2dc066264a371ef44269e5beb9b6",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -18,7 +18,7 @@\n #include <netbase.h>\n #include <rpc/server.h>\n #include <rpc/client.h>\n-#include <util.h>\n+#include <util/system.h>\n \n #include <openssl/crypto.h>\n "
      },
      {
        "sha": "65db0280b70e7bceda3d17399d3458bd632b4a32",
        "filename": "src/qt/sendcoinsdialog.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 27,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/sendcoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/sendcoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -2,6 +2,10 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n #include <qt/sendcoinsdialog.h>\n #include <qt/forms/ui_sendcoinsdialog.h>\n \n@@ -115,13 +119,11 @@ SendCoinsDialog::SendCoinsDialog(const PlatformStyle *_platformStyle, QWidget *p\n         settings.setValue(\"nSmartFeeSliderPosition\", 0);\n     if (!settings.contains(\"nTransactionFee\"))\n         settings.setValue(\"nTransactionFee\", (qint64)DEFAULT_PAY_TX_FEE);\n-    if (!settings.contains(\"fPayOnlyMinFee\"))\n-        settings.setValue(\"fPayOnlyMinFee\", false);\n     ui->groupFee->setId(ui->radioSmartFee, 0);\n     ui->groupFee->setId(ui->radioCustomFee, 1);\n     ui->groupFee->button((int)std::max(0, std::min(1, settings.value(\"nFeeRadio\").toInt())))->setChecked(true);\n+    ui->customFee->SetAllowEmpty(false);\n     ui->customFee->setValue(settings.value(\"nTransactionFee\").toLongLong());\n-    ui->checkBoxMinimumFee->setChecked(settings.value(\"fPayOnlyMinFee\").toBool());\n     minimizeFeeSection(settings.value(\"fFeeSectionMinimized\").toBool());\n }\n \n@@ -170,14 +172,15 @@ void SendCoinsDialog::setModel(WalletModel *_model)\n         connect(ui->groupFee, static_cast<void (QButtonGroup::*)(int)>(&QButtonGroup::buttonClicked), this, &SendCoinsDialog::updateFeeSectionControls);\n         connect(ui->groupFee, static_cast<void (QButtonGroup::*)(int)>(&QButtonGroup::buttonClicked), this, &SendCoinsDialog::coinControlUpdateLabels);\n         connect(ui->customFee, &BitcoinAmountField::valueChanged, this, &SendCoinsDialog::coinControlUpdateLabels);\n-        connect(ui->checkBoxMinimumFee, &QCheckBox::stateChanged, this, &SendCoinsDialog::setMinimumFee);\n-        connect(ui->checkBoxMinimumFee, &QCheckBox::stateChanged, this, &SendCoinsDialog::updateFeeSectionControls);\n-        connect(ui->checkBoxMinimumFee, &QCheckBox::stateChanged, this, &SendCoinsDialog::coinControlUpdateLabels);\n         connect(ui->optInRBF, &QCheckBox::stateChanged, this, &SendCoinsDialog::updateSmartFeeLabel);\n         connect(ui->optInRBF, &QCheckBox::stateChanged, this, &SendCoinsDialog::coinControlUpdateLabels);\n-        ui->customFee->setSingleStep(model->wallet().getRequiredFee(1000));\n+        CAmount requiredFee = model->wallet().getRequiredFee(1000);\n+        ui->customFee->SetMinValue(requiredFee);\n+        if (ui->customFee->value() < requiredFee) {\n+            ui->customFee->setValue(requiredFee);\n+        }\n+        ui->customFee->setSingleStep(requiredFee);\n         updateFeeSectionControls();\n-        updateMinFeeLabel();\n         updateSmartFeeLabel();\n \n         // set default rbf checkbox state\n@@ -206,7 +209,6 @@ SendCoinsDialog::~SendCoinsDialog()\n     settings.setValue(\"nFeeRadio\", ui->groupFee->checkedId());\n     settings.setValue(\"nConfTarget\", getConfTargetForIndex(ui->confTargetSelector->currentIndex()));\n     settings.setValue(\"nTransactionFee\", (qint64)ui->customFee->value());\n-    settings.setValue(\"fPayOnlyMinFee\", ui->checkBoxMinimumFee->isChecked());\n \n     delete ui;\n }\n@@ -290,7 +292,9 @@ void SendCoinsDialog::on_sendButton_clicked()\n         QString recipientElement;\n         recipientElement = \"<br />\";\n \n+#ifdef ENABLE_BIP70\n         if (!rcp.paymentRequest.IsInitialized()) // normal payment\n+#endif\n         {\n             if(rcp.label.length() > 0) // label with address\n             {\n@@ -302,6 +306,7 @@ void SendCoinsDialog::on_sendButton_clicked()\n                 recipientElement.append(tr(\"%1 to %2\").arg(amount, address));\n             }\n         }\n+#ifdef ENABLE_BIP70\n         else if(!rcp.authenticatedMerchant.isEmpty()) // authenticated payment request\n         {\n             recipientElement.append(tr(\"%1 to %2\").arg(amount, GUIUtil::HtmlEscape(rcp.authenticatedMerchant)));\n@@ -310,6 +315,7 @@ void SendCoinsDialog::on_sendButton_clicked()\n         {\n             recipientElement.append(tr(\"%1 to %2\").arg(amount, address));\n         }\n+#endif\n \n         formatted.append(recipientElement);\n     }\n@@ -534,7 +540,6 @@ void SendCoinsDialog::updateDisplayUnit()\n {\n     setBalance(model->wallet().getBalances());\n     ui->customFee->setDisplayUnit(model->getOptionsModel()->getDisplayUnit());\n-    updateMinFeeLabel();\n     updateSmartFeeLabel();\n }\n \n@@ -634,22 +639,16 @@ void SendCoinsDialog::useAvailableBalance(SendCoinsEntry* entry)\n     }\n }\n \n-void SendCoinsDialog::setMinimumFee()\n-{\n-    ui->customFee->setValue(model->wallet().getRequiredFee(1000));\n-}\n-\n void SendCoinsDialog::updateFeeSectionControls()\n {\n     ui->confTargetSelector      ->setEnabled(ui->radioSmartFee->isChecked());\n     ui->labelSmartFee           ->setEnabled(ui->radioSmartFee->isChecked());\n     ui->labelSmartFee2          ->setEnabled(ui->radioSmartFee->isChecked());\n     ui->labelSmartFee3          ->setEnabled(ui->radioSmartFee->isChecked());\n     ui->labelFeeEstimation      ->setEnabled(ui->radioSmartFee->isChecked());\n-    ui->checkBoxMinimumFee      ->setEnabled(ui->radioCustomFee->isChecked());\n-    ui->labelMinFeeWarning      ->setEnabled(ui->radioCustomFee->isChecked());\n-    ui->labelCustomPerKilobyte  ->setEnabled(ui->radioCustomFee->isChecked() && !ui->checkBoxMinimumFee->isChecked());\n-    ui->customFee               ->setEnabled(ui->radioCustomFee->isChecked() && !ui->checkBoxMinimumFee->isChecked());\n+    ui->labelCustomFeeWarning   ->setEnabled(ui->radioCustomFee->isChecked());\n+    ui->labelCustomPerKilobyte  ->setEnabled(ui->radioCustomFee->isChecked());\n+    ui->customFee               ->setEnabled(ui->radioCustomFee->isChecked());\n }\n \n void SendCoinsDialog::updateFeeMinimizedLabel()\n@@ -664,14 +663,6 @@ void SendCoinsDialog::updateFeeMinimizedLabel()\n     }\n }\n \n-void SendCoinsDialog::updateMinFeeLabel()\n-{\n-    if (model && model->getOptionsModel())\n-        ui->checkBoxMinimumFee->setText(tr(\"Pay only the required fee of %1\").arg(\n-            BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(), model->wallet().getRequiredFee(1000)) + \"/kB\")\n-        );\n-}\n-\n void SendCoinsDialog::updateCoinControlState(CCoinControl& ctrl)\n {\n     if (ui->radioCustomFee->isChecked()) {"
      },
      {
        "sha": "e1ebc77d59c9e71e527e7028e948bb15757ebb65",
        "filename": "src/qt/sendcoinsdialog.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/sendcoinsdialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/sendcoinsdialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -92,9 +92,7 @@ private Q_SLOTS:\n     void coinControlClipboardBytes();\n     void coinControlClipboardLowOutput();\n     void coinControlClipboardChange();\n-    void setMinimumFee();\n     void updateFeeSectionControls();\n-    void updateMinFeeLabel();\n     void updateSmartFeeLabel();\n \n Q_SIGNALS:"
      },
      {
        "sha": "76c942c8b9c0b9fc44c08eccef12f28da333024c",
        "filename": "src/qt/sendcoinsentry.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/sendcoinsentry.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/sendcoinsentry.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsentry.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -2,6 +2,10 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n #include <qt/sendcoinsentry.h>\n #include <qt/forms/ui_sendcoinsentry.h>\n \n@@ -133,9 +137,11 @@ bool SendCoinsEntry::validate(interfaces::Node& node)\n     // Check input validity\n     bool retval = true;\n \n+#ifdef ENABLE_BIP70\n     // Skip checks for payment request\n     if (recipient.paymentRequest.IsInitialized())\n         return retval;\n+#endif\n \n     if (!model->validateAddress(ui->payTo->text()))\n     {\n@@ -166,9 +172,11 @@ bool SendCoinsEntry::validate(interfaces::Node& node)\n \n SendCoinsRecipient SendCoinsEntry::getValue()\n {\n+#ifdef ENABLE_BIP70\n     // Payment request\n     if (recipient.paymentRequest.IsInitialized())\n         return recipient;\n+#endif\n \n     // Normal payment\n     recipient.address = ui->payTo->text();\n@@ -196,6 +204,7 @@ void SendCoinsEntry::setValue(const SendCoinsRecipient &value)\n {\n     recipient = value;\n \n+#ifdef ENABLE_BIP70\n     if (recipient.paymentRequest.IsInitialized()) // payment request\n     {\n         if (recipient.authenticatedMerchant.isEmpty()) // unauthenticated\n@@ -216,6 +225,7 @@ void SendCoinsEntry::setValue(const SendCoinsRecipient &value)\n         }\n     }\n     else // normal payment\n+#endif\n     {\n         // message\n         ui->messageTextLabel->setText(recipient.message);"
      },
      {
        "sha": "df38285d087f09ef9c49db8391a99dd7ee60a243",
        "filename": "src/qt/splashscreen.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 5,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/splashscreen.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/splashscreen.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/splashscreen.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -15,7 +15,7 @@\n #include <interfaces/node.h>\n #include <interfaces/wallet.h>\n #include <ui_interface.h>\n-#include <util.h>\n+#include <util/system.h>\n #include <version.h>\n \n #include <QApplication>\n@@ -37,9 +37,7 @@ SplashScreen::SplashScreen(interfaces::Node& node, Qt::WindowFlags f, const Netw\n \n     float fontFactor            = 1.0;\n     float devicePixelRatio      = 1.0;\n-#if QT_VERSION > 0x050100\n     devicePixelRatio = static_cast<QGuiApplication*>(QCoreApplication::instance())->devicePixelRatio();\n-#endif\n \n     // define text to place\n     QString titleText       = tr(PACKAGE_NAME);\n@@ -53,10 +51,8 @@ SplashScreen::SplashScreen(interfaces::Node& node, Qt::WindowFlags f, const Netw\n     QSize splashSize(480*devicePixelRatio,320*devicePixelRatio);\n     pixmap = QPixmap(splashSize);\n \n-#if QT_VERSION > 0x050100\n     // change to HiDPI if it makes sense\n     pixmap.setDevicePixelRatio(devicePixelRatio);\n-#endif\n \n     QPainter pixPaint(&pixmap);\n     pixPaint.setPen(QColor(100,100,100));"
      },
      {
        "sha": "3e414df1f0acfac3add1a8ec6e1d089bbed0c12c",
        "filename": "src/qt/test/addressbooktests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/test/addressbooktests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/test/addressbooktests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/addressbooktests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -2,6 +2,7 @@\n #include <qt/test/util.h>\n #include <test/test_bitcoin.h>\n \n+#include <interfaces/chain.h>\n #include <interfaces/node.h>\n #include <qt/addressbookpage.h>\n #include <qt/addresstablemodel.h>\n@@ -56,7 +57,8 @@ void EditAddressAndSubmit(\n void TestAddAddressesToSendBook()\n {\n     TestChain100Setup test;\n-    std::shared_ptr<CWallet> wallet = std::make_shared<CWallet>(\"mock\", WalletDatabase::CreateMock());\n+    auto chain = interfaces::MakeChain();\n+    std::shared_ptr<CWallet> wallet = std::make_shared<CWallet>(*chain, WalletLocation(), WalletDatabase::CreateMock());\n     bool firstRun;\n     wallet->LoadWallet(firstRun);\n "
      },
      {
        "sha": "6750c543da2f1291f9a229a58b5546e7116219d2",
        "filename": "src/qt/test/compattests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/test/compattests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/test/compattests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/compattests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -2,7 +2,13 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#if defined(ENABLE_WALLET) && defined(ENABLE_BIP70)\n #include <qt/paymentrequestplus.h> // this includes protobuf's port.h which defines its own bswap macos\n+#endif\n \n #include <qt/test/compattests.h>\n "
      },
      {
        "sha": "94907595f54bebaa7ac98316422a2efb5e094d7f",
        "filename": "src/qt/test/paymentservertests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/test/paymentservertests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/test/paymentservertests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/paymentservertests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -13,8 +13,8 @@\n #include <random.h>\n #include <script/script.h>\n #include <script/standard.h>\n-#include <util.h>\n-#include <utilstrencodings.h>\n+#include <util/system.h>\n+#include <util/strencodings.h>\n \n #include <openssl/x509.h>\n #include <openssl/x509_vfy.h>"
      },
      {
        "sha": "ed453336daef4cdfe128147a058b10cf5ad1140c",
        "filename": "src/qt/test/rpcnestedtests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/test/rpcnestedtests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/test/rpcnestedtests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/rpcnestedtests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -14,7 +14,7 @@\n #include <qt/rpcconsole.h>\n #include <test/test_bitcoin.h>\n #include <univalue.h>\n-#include <util.h>\n+#include <util/system.h>\n \n #include <QDir>\n #include <QtGlobal>"
      },
      {
        "sha": "b6523604fda52498d4422f54512bec52dc6cdd7d",
        "filename": "src/qt/test/test_main.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/test/test_main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/test/test_main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/test_main.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -8,15 +8,17 @@\n \n #include <chainparams.h>\n #include <qt/test/rpcnestedtests.h>\n-#include <util.h>\n+#include <util/system.h>\n #include <qt/test/uritests.h>\n #include <qt/test/compattests.h>\n \n #ifdef ENABLE_WALLET\n #include <qt/test/addressbooktests.h>\n+#ifdef ENABLE_BIP70\n #include <qt/test/paymentservertests.h>\n+#endif // ENABLE_BIP70\n #include <qt/test/wallettests.h>\n-#endif\n+#endif // ENABLE_WALLET\n \n #include <QApplication>\n #include <QObject>\n@@ -74,7 +76,7 @@ int main(int argc, char *argv[])\n     if (QTest::qExec(&test1) != 0) {\n         fInvalid = true;\n     }\n-#ifdef ENABLE_WALLET\n+#if defined(ENABLE_WALLET) && defined(ENABLE_BIP70)\n     PaymentServerTests test2;\n     if (QTest::qExec(&test2) != 0) {\n         fInvalid = true;"
      },
      {
        "sha": "377f07dcba9c8873cc92ec803ebcae32772b4e6b",
        "filename": "src/qt/test/util.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/test/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/test/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/util.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -1,6 +1,8 @@\n #ifndef BITCOIN_QT_TEST_UTIL_H\n #define BITCOIN_QT_TEST_UTIL_H\n \n+#include <QString>\n+\n /**\n  * Press \"Ok\" button in message box dialog.\n  *"
      },
      {
        "sha": "f02fd8aea7f7fc06de1760fea09dffe655cbdd67",
        "filename": "src/qt/test/wallettests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/test/wallettests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/test/wallettests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/wallettests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -1,7 +1,9 @@\n #include <qt/test/wallettests.h>\n #include <qt/test/util.h>\n \n+#include <interfaces/chain.h>\n #include <interfaces/node.h>\n+#include <base58.h>\n #include <qt/bitcoinamountfield.h>\n #include <qt/optionsmodel.h>\n #include <qt/platformstyle.h>\n@@ -131,7 +133,8 @@ void TestGUI()\n     for (int i = 0; i < 5; ++i) {\n         test.CreateAndProcessBlock({}, GetScriptForRawPubKey(test.coinbaseKey.GetPubKey()));\n     }\n-    std::shared_ptr<CWallet> wallet = std::make_shared<CWallet>(\"mock\", WalletDatabase::CreateMock());\n+    auto chain = interfaces::MakeChain();\n+    std::shared_ptr<CWallet> wallet = std::make_shared<CWallet>(*chain, WalletLocation(), WalletDatabase::CreateMock());\n     bool firstRun;\n     wallet->LoadWallet(firstRun);\n     {\n@@ -140,7 +143,7 @@ void TestGUI()\n         wallet->AddKeyPubKey(test.coinbaseKey, test.coinbaseKey.GetPubKey());\n     }\n     {\n-        LOCK(cs_main);\n+        auto locked_chain = wallet->chain().lock();\n         WalletRescanReserver reserver(wallet.get());\n         reserver.reserve();\n         wallet->ScanForWalletTransactions(chainActive.Genesis(), nullptr, reserver, true);"
      },
      {
        "sha": "0d070d9e87cd70d1a377ea03364ce741da4b05cd",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 5,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -2,6 +2,10 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#ifdef HAVE_CONFIG_H\n+#include <config/bitcoin-config.h>\n+#endif\n+\n #include <qt/transactiondesc.h>\n \n #include <qt/bitcoinunits.h>\n@@ -15,15 +19,15 @@\n #include <validation.h>\n #include <script/script.h>\n #include <timedata.h>\n-#include <util.h>\n+#include <util/system.h>\n #include <wallet/db.h>\n #include <wallet/wallet.h>\n #include <policy/policy.h>\n \n #include <stdint.h>\n #include <string>\n \n-QString TransactionDesc::FormatTxStatus(const interfaces::WalletTx& wtx, const interfaces::WalletTxStatus& status, bool inMempool, int numBlocks, int64_t adjustedTime)\n+QString TransactionDesc::FormatTxStatus(const interfaces::WalletTx& wtx, const interfaces::WalletTxStatus& status, bool inMempool, int numBlocks)\n {\n     if (!status.is_final)\n     {\n@@ -49,11 +53,10 @@ QString TransactionDesc::FormatTxStatus(const interfaces::WalletTx& wtx, const i\n QString TransactionDesc::toHTML(interfaces::Node& node, interfaces::Wallet& wallet, TransactionRecord *rec, int unit)\n {\n     int numBlocks;\n-    int64_t adjustedTime;\n     interfaces::WalletTxStatus status;\n     interfaces::WalletOrderForm orderForm;\n     bool inMempool;\n-    interfaces::WalletTx wtx = wallet.getWalletTxDetails(rec->hash, status, orderForm, inMempool, numBlocks, adjustedTime);\n+    interfaces::WalletTx wtx = wallet.getWalletTxDetails(rec->hash, status, orderForm, inMempool, numBlocks);\n \n     QString strHTML;\n \n@@ -65,7 +68,7 @@ QString TransactionDesc::toHTML(interfaces::Node& node, interfaces::Wallet& wall\n     CAmount nDebit = wtx.debit;\n     CAmount nNet = nCredit - nDebit;\n \n-    strHTML += \"<b>\" + tr(\"Status\") + \":</b> \" + FormatTxStatus(wtx, status, inMempool, numBlocks, adjustedTime);\n+    strHTML += \"<b>\" + tr(\"Status\") + \":</b> \" + FormatTxStatus(wtx, status, inMempool, numBlocks);\n     strHTML += \"<br>\";\n \n     strHTML += \"<b>\" + tr(\"Date\") + \":</b> \" + (nTime ? GUIUtil::dateTimeStr(nTime) : \"\") + \"<br>\";\n@@ -257,6 +260,7 @@ QString TransactionDesc::toHTML(interfaces::Node& node, interfaces::Wallet& wall\n         if (r.first == \"Message\")\n             strHTML += \"<br><b>\" + tr(\"Message\") + \":</b><br>\" + GUIUtil::HtmlEscape(r.second, true) + \"<br>\";\n \n+#ifdef ENABLE_BIP70\n     //\n     // PaymentRequest info:\n     //\n@@ -271,6 +275,7 @@ QString TransactionDesc::toHTML(interfaces::Node& node, interfaces::Wallet& wall\n                 strHTML += \"<b>\" + tr(\"Merchant\") + \":</b> \" + GUIUtil::HtmlEscape(merchant) + \"<br>\";\n         }\n     }\n+#endif\n \n     if (wtx.is_coinbase)\n     {"
      },
      {
        "sha": "cf955a433c86f2de2b885587d2d45f509b788bf3",
        "filename": "src/qt/transactiondesc.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/transactiondesc.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/transactiondesc.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -29,7 +29,7 @@ class TransactionDesc: public QObject\n private:\n     TransactionDesc() {}\n \n-    static QString FormatTxStatus(const interfaces::WalletTx& wtx, const interfaces::WalletTxStatus& status, bool inMempool, int numBlocks, int64_t adjustedTime);\n+    static QString FormatTxStatus(const interfaces::WalletTx& wtx, const interfaces::WalletTxStatus& status, bool inMempool, int numBlocks);\n };\n \n #endif // BITCOIN_QT_TRANSACTIONDESC_H"
      },
      {
        "sha": "d88cfe52ed81d7a121d2644d886b2db728e86f76",
        "filename": "src/qt/transactionrecord.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/transactionrecord.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/transactionrecord.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -158,7 +158,7 @@ QList<TransactionRecord> TransactionRecord::decomposeTransaction(const interface\n     return parts;\n }\n \n-void TransactionRecord::updateStatus(const interfaces::WalletTxStatus& wtx, int numBlocks, int64_t adjustedTime)\n+void TransactionRecord::updateStatus(const interfaces::WalletTxStatus& wtx, int numBlocks)\n {\n     // Determine transaction status\n "
      },
      {
        "sha": "470f70e2ab424e04eda096693b83a2e4d1b1de11",
        "filename": "src/qt/transactionrecord.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/transactionrecord.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/transactionrecord.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -138,7 +138,7 @@ class TransactionRecord\n \n     /** Update status from core wallet tx.\n      */\n-    void updateStatus(const interfaces::WalletTxStatus& wtx, int numBlocks, int64_t adjustedTime);\n+    void updateStatus(const interfaces::WalletTxStatus& wtx, int numBlocks);\n \n     /** Return whether a status update is needed.\n      */"
      },
      {
        "sha": "1983c3bc9244aa08adc9c30d66658bd1fa648808",
        "filename": "src/qt/transactiontablemodel.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/transactiontablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/transactiontablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiontablemodel.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -18,7 +18,7 @@\n #include <interfaces/node.h>\n #include <sync.h>\n #include <uint256.h>\n-#include <util.h>\n+#include <util/system.h>\n #include <validation.h>\n \n #include <QColor>\n@@ -193,9 +193,8 @@ class TransactionTablePriv\n             // simply re-use the cached status.\n             interfaces::WalletTxStatus wtx;\n             int numBlocks;\n-            int64_t adjustedTime;\n-            if (wallet.tryGetTxStatus(rec->hash, wtx, numBlocks, adjustedTime) && rec->statusUpdateNeeded(numBlocks)) {\n-                rec->updateStatus(wtx, numBlocks, adjustedTime);\n+            if (wallet.tryGetTxStatus(rec->hash, wtx, numBlocks) && rec->statusUpdateNeeded(numBlocks)) {\n+                rec->updateStatus(wtx, numBlocks);\n             }\n             return rec;\n         }"
      },
      {
        "sha": "ebf7bad7957a5282e2e9ec3c425c83ff1351a7e2",
        "filename": "src/qt/utilitydialog.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/utilitydialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/utilitydialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/utilitydialog.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -14,13 +14,15 @@\n #include <qt/clientmodel.h>\n #include <qt/guiconstants.h>\n #include <qt/intro.h>\n+#ifdef ENABLE_BIP70\n #include <qt/paymentrequestplus.h>\n+#endif\n #include <qt/guiutil.h>\n \n #include <clientversion.h>\n #include <init.h>\n #include <interfaces/node.h>\n-#include <util.h>\n+#include <util/system.h>\n \n #include <stdio.h>\n "
      },
      {
        "sha": "353da0c9b4441e6be0e86648f9c61f2e4a7f3961",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 2,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -2,6 +2,10 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n #include <qt/walletmodel.h>\n \n #include <qt/addresstablemodel.h>\n@@ -16,7 +20,7 @@\n #include <interfaces/node.h>\n #include <key_io.h>\n #include <ui_interface.h>\n-#include <util.h> // for GetBoolArg\n+#include <util/system.h> // for GetBoolArg\n #include <wallet/coincontrol.h>\n #include <wallet/wallet.h>\n \n@@ -142,6 +146,7 @@ WalletModel::SendCoinsReturn WalletModel::prepareTransaction(WalletModelTransact\n         if (rcp.fSubtractFeeFromAmount)\n             fSubtractFeeFromAmount = true;\n \n+#ifdef ENABLE_BIP70\n         if (rcp.paymentRequest.IsInitialized())\n         {   // PaymentRequest...\n             CAmount subtotal = 0;\n@@ -164,6 +169,7 @@ WalletModel::SendCoinsReturn WalletModel::prepareTransaction(WalletModelTransact\n             total += subtotal;\n         }\n         else\n+#endif\n         {   // User-entered bitcoin address / amount:\n             if(!validateAddress(rcp.address))\n             {\n@@ -235,6 +241,7 @@ WalletModel::SendCoinsReturn WalletModel::sendCoins(WalletModelTransaction &tran\n         std::vector<std::pair<std::string, std::string>> vOrderForm;\n         for (const SendCoinsRecipient &rcp : transaction.getRecipients())\n         {\n+#ifdef ENABLE_BIP70\n             if (rcp.paymentRequest.IsInitialized())\n             {\n                 // Make sure any payment requests involved are still valid.\n@@ -247,7 +254,9 @@ WalletModel::SendCoinsReturn WalletModel::sendCoins(WalletModelTransaction &tran\n                 rcp.paymentRequest.SerializeToString(&value);\n                 vOrderForm.emplace_back(\"PaymentRequest\", std::move(value));\n             }\n-            else if (!rcp.message.isEmpty()) // Message from normal bitcoin:URI (bitcoin:123...?message=example)\n+            else\n+#endif\n+            if (!rcp.message.isEmpty()) // Message from normal bitcoin:URI (bitcoin:123...?message=example)\n                 vOrderForm.emplace_back(\"Message\", rcp.message.toStdString());\n         }\n \n@@ -266,7 +275,9 @@ WalletModel::SendCoinsReturn WalletModel::sendCoins(WalletModelTransaction &tran\n     for (const SendCoinsRecipient &rcp : transaction.getRecipients())\n     {\n         // Don't touch the address book when we have a payment request\n+#ifdef ENABLE_BIP70\n         if (!rcp.paymentRequest.IsInitialized())\n+#endif\n         {\n             std::string strAddress = rcp.address.toStdString();\n             CTxDestination dest = DecodeDestination(strAddress);"
      },
      {
        "sha": "ec4c5a2a6c4d3d338f8b702ca15e7874abc869b1",
        "filename": "src/qt/walletmodel.h",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/walletmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/walletmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -10,7 +10,13 @@\n #include <serialize.h>\n #include <script/standard.h>\n \n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#ifdef ENABLE_BIP70\n #include <qt/paymentrequestplus.h>\n+#endif\n #include <qt/walletmodeltransaction.h>\n \n #include <interfaces/wallet.h>\n@@ -63,8 +69,14 @@ class SendCoinsRecipient\n     // If from a payment request, this is used for storing the memo\n     QString message;\n \n+#ifdef ENABLE_BIP70\n     // If from a payment request, paymentRequest.IsInitialized() will be true\n     PaymentRequestPlus paymentRequest;\n+#else\n+    // If building with BIP70 is disabled, keep the payment request around as\n+    // serialized string to ensure load/store is lossless\n+    std::string sPaymentRequest;\n+#endif\n     // Empty if no authentication or invalid signature/cert/etc.\n     QString authenticatedMerchant;\n \n@@ -80,9 +92,11 @@ class SendCoinsRecipient\n         std::string sAddress = address.toStdString();\n         std::string sLabel = label.toStdString();\n         std::string sMessage = message.toStdString();\n+#ifdef ENABLE_BIP70\n         std::string sPaymentRequest;\n         if (!ser_action.ForRead() && paymentRequest.IsInitialized())\n             paymentRequest.SerializeToString(&sPaymentRequest);\n+#endif\n         std::string sAuthenticatedMerchant = authenticatedMerchant.toStdString();\n \n         READWRITE(this->nVersion);\n@@ -98,8 +112,10 @@ class SendCoinsRecipient\n             address = QString::fromStdString(sAddress);\n             label = QString::fromStdString(sLabel);\n             message = QString::fromStdString(sMessage);\n+#ifdef ENABLE_BIP70\n             if (!sPaymentRequest.empty())\n                 paymentRequest.parse(QByteArray::fromRawData(sPaymentRequest.data(), sPaymentRequest.size()));\n+#endif\n             authenticatedMerchant = QString::fromStdString(sAuthenticatedMerchant);\n         }\n     }"
      },
      {
        "sha": "eb3b0baf088c530a8a624b7afb9f7ff76159ea2e",
        "filename": "src/qt/walletmodeltransaction.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/walletmodeltransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/walletmodeltransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodeltransaction.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -2,6 +2,10 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#ifdef HAVE_CONFIG_H\n+#include <config/bitcoin-config.h>\n+#endif\n+\n #include <qt/walletmodeltransaction.h>\n \n #include <interfaces/node.h>\n@@ -46,6 +50,7 @@ void WalletModelTransaction::reassignAmounts(int nChangePosRet)\n     {\n         SendCoinsRecipient& rcp = (*it);\n \n+#ifdef ENABLE_BIP70\n         if (rcp.paymentRequest.IsInitialized())\n         {\n             CAmount subtotal = 0;\n@@ -62,6 +67,7 @@ void WalletModelTransaction::reassignAmounts(int nChangePosRet)\n             rcp.amount = subtotal;\n         }\n         else // normal recipient (no payment request)\n+#endif\n         {\n             if (i == nChangePosRet)\n                 i++;"
      },
      {
        "sha": "289aee847b0754f0b083f3e50f61dd50f99499d3",
        "filename": "src/qt/walletmodeltransaction.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/walletmodeltransaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/walletmodeltransaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodeltransaction.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -8,6 +8,7 @@\n #include <qt/walletmodel.h>\n \n #include <memory>\n+#include <amount.h>\n \n #include <QObject>\n "
      },
      {
        "sha": "a6199923440b40ccf1f4e3a0b069177eaac615be",
        "filename": "src/qt/walletview.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 6,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/walletview.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/walletview.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletview.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -292,19 +292,15 @@ void WalletView::usedSendingAddresses()\n     if(!walletModel)\n         return;\n \n-    usedSendingAddressesPage->show();\n-    usedSendingAddressesPage->raise();\n-    usedSendingAddressesPage->activateWindow();\n+    GUIUtil::bringToFront(usedSendingAddressesPage);\n }\n \n void WalletView::usedReceivingAddresses()\n {\n     if(!walletModel)\n         return;\n \n-    usedReceivingAddressesPage->show();\n-    usedReceivingAddressesPage->raise();\n-    usedReceivingAddressesPage->activateWindow();\n+    GUIUtil::bringToFront(usedReceivingAddressesPage);\n }\n \n void WalletView::showProgress(const QString &title, int nProgress)"
      },
      {
        "sha": "08cae76addc94eba9d9cad04e61056c7bc4efc1c",
        "filename": "src/qt/winshutdownmonitor.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/winshutdownmonitor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/qt/winshutdownmonitor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/winshutdownmonitor.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -6,7 +6,7 @@\n \n #if defined(Q_OS_WIN)\n #include <shutdown.h>\n-#include <util.h>\n+#include <util/system.h>\n \n #include <windows.h>\n "
      },
      {
        "sha": "a34c70e1d50c39314759e3bf68bac70369cd7822",
        "filename": "src/random.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/random.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/random.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -13,7 +13,7 @@\n #endif\n #include <logging.h>  // for LogPrint()\n #include <sync.h>     // for WAIT_LOCK\n-#include <utiltime.h> // for GetTime()\n+#include <util/time.h> // for GetTime()\n \n #include <stdlib.h>\n #include <chrono>\n@@ -35,7 +35,7 @@\n #include <sys/random.h>\n #endif\n #ifdef HAVE_SYSCTL_ARND\n-#include <utilstrencodings.h> // for ARRAYLEN\n+#include <util/strencodings.h> // for ARRAYLEN\n #include <sys/sysctl.h>\n #endif\n "
      },
      {
        "sha": "6c7e0384cb8a3d89afc1a06f52f7cac8a97a6e75",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -16,7 +16,7 @@\n #include <streams.h>\n #include <sync.h>\n #include <txmempool.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n #include <version.h>\n \n #include <boost/algorithm/string.hpp>"
      },
      {
        "sha": "95915b548880841df2faecb91a9107b6dfa74492",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 15,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -12,23 +12,24 @@\n #include <checkpoints.h>\n #include <coins.h>\n #include <consensus/validation.h>\n-#include <validation.h>\n #include <core_io.h>\n+#include <hash.h>\n #include <index/txindex.h>\n #include <key_io.h>\n #include <policy/feerate.h>\n #include <policy/policy.h>\n #include <policy/rbf.h>\n #include <primitives/transaction.h>\n #include <rpc/server.h>\n+#include <rpc/util.h>\n #include <script/descriptor.h>\n #include <streams.h>\n #include <sync.h>\n #include <txdb.h>\n #include <txmempool.h>\n-#include <util.h>\n-#include <utilstrencodings.h>\n-#include <hash.h>\n+#include <util/strencodings.h>\n+#include <util/system.h>\n+#include <validation.h>\n #include <validationinterface.h>\n #include <versionbitsinfo.h>\n #include <warnings.h>\n@@ -286,12 +287,12 @@ static UniValue waitforblockheight(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n-            \"waitforblockheight <height> (timeout)\\n\"\n+            \"waitforblockheight height ( timeout )\\n\"\n             \"\\nWaits for (at least) block height and returns the height and hash\\n\"\n             \"of the current tip.\\n\"\n             \"\\nReturns the current block on timeout or exit.\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. height  (required, int) Block height to wait for (int)\\n\"\n+            \"1. height  (int, required) Block height to wait for.\\n\"\n             \"2. timeout (int, optional, default=0) Time in milliseconds to wait for a response. 0 indicates no timeout.\\n\"\n             \"\\nResult:\\n\"\n             \"{                           (json object)\\n\"\n@@ -695,11 +696,11 @@ static UniValue getblockheader(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n-            \"getblockheader \\\"hash\\\" ( verbose )\\n\"\n+            \"getblockheader \\\"blockhash\\\" ( verbose )\\n\"\n             \"\\nIf verbose is false, returns a string that is serialized, hex-encoded data for blockheader 'hash'.\\n\"\n             \"If verbose is true, returns an Object with information about blockheader <hash>.\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. \\\"hash\\\"          (string, required) The block hash\\n\"\n+            \"1. \\\"blockhash\\\"     (string, required) The block hash\\n\"\n             \"2. verbose           (boolean, optional, default=true) true for a json object, false for the hex-encoded data\\n\"\n             \"\\nResult (for verbose = true):\\n\"\n             \"{\\n\"\n@@ -925,7 +926,7 @@ static UniValue pruneblockchain(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n         throw std::runtime_error(\n-            \"pruneblockchain\\n\"\n+            \"pruneblockchain height\\n\"\n             \"\\nArguments:\\n\"\n             \"1. \\\"height\\\"       (numeric, required) The block height to prune up to. May be set to a discrete height, or a unix timestamp\\n\"\n             \"                  to prune blocks whose block time is at least 2 hours older than the provided timestamp.\\n\"\n@@ -1562,7 +1563,7 @@ static UniValue getchaintxstats(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() > 2)\n         throw std::runtime_error(\n-            \"getchaintxstats ( nblocks blockhash )\\n\"\n+            \"getchaintxstats ( nblocks \\\"blockhash\\\" )\\n\"\n             \"\\nCompute statistics about the total number and rate of transactions in the chain.\\n\"\n             \"\\nArguments:\\n\"\n             \"1. nblocks      (numeric, optional) Size of the window in number of blocks (default: one month).\\n\"\n@@ -1798,6 +1799,10 @@ static UniValue getblockstats(const JSONRPCRequest& request)\n     const bool do_calculate_weight = do_all || SetHasKeys(stats, \"total_weight\", \"avgfeerate\", \"swtotal_weight\", \"avgfeerate\", \"feerate_percentiles\", \"minfeerate\", \"maxfeerate\");\n     const bool do_calculate_sw = do_all || SetHasKeys(stats, \"swtxs\", \"swtotal_size\", \"swtotal_weight\");\n \n+    if (loop_inputs && !g_txindex) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"One or more of the selected stats requires -txindex enabled\");\n+    }\n+\n     CAmount maxfee = 0;\n     CAmount maxfeerate = 0;\n     CAmount minfee = MAX_MONEY;\n@@ -1861,10 +1866,6 @@ static UniValue getblockstats(const JSONRPCRequest& request)\n         }\n \n         if (loop_inputs) {\n-\n-            if (!g_txindex) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"One or more of the selected stats requires -txindex enabled\");\n-            }\n             CAmount tx_total_in = 0;\n             for (const CTxIn& in : tx->vin) {\n                 CTransactionRef tx_in;\n@@ -2039,7 +2040,7 @@ UniValue scantxoutset(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n-            \"scantxoutset <action> ( <scanobjects> )\\n\"\n+            \"scantxoutset \\\"action\\\" [scanobjects,...]\\n\"\n             \"\\nEXPERIMENTAL warning: this call may be removed or changed in future releases.\\n\"\n             \"\\nScans the unspent transaction output set for entries that match certain output descriptors.\\n\"\n             \"Examples of output descriptors are:\\n\""
      },
      {
        "sha": "2b99808c07d58adaf951cc5d5621dfcaf1597433",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -5,7 +5,7 @@\n \n #include <rpc/client.h>\n #include <rpc/protocol.h>\n-#include <util.h>\n+#include <util/system.h>\n \n #include <set>\n #include <stdint.h>\n@@ -147,7 +147,6 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"logging\", 0, \"include\" },\n     { \"logging\", 1, \"exclude\" },\n     { \"disconnectnode\", 1, \"nodeid\" },\n-    { \"addwitnessaddress\", 1, \"p2sh\" },\n     // Echo with conversion (For testing only)\n     { \"echojson\", 0, \"arg0\" },\n     { \"echojson\", 1, \"arg1\" },"
      },
      {
        "sha": "4f314ef215ceeb28e0db4d6de5dea958809beb40",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -18,10 +18,11 @@\n #include <rpc/blockchain.h>\n #include <rpc/mining.h>\n #include <rpc/server.h>\n+#include <rpc/util.h>\n #include <shutdown.h>\n #include <txmempool.h>\n-#include <util.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n+#include <util/system.h>\n #include <validation.h>\n #include <validationinterface.h>\n #include <versionbitsinfo.h>\n@@ -231,7 +232,7 @@ static UniValue prioritisetransaction(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 3)\n         throw std::runtime_error(\n-            \"prioritisetransaction <txid> <dummy value> <fee delta>\\n\"\n+            \"prioritisetransaction \\\"txid\\\" dummy fee_delta\\n\"\n             \"Accepts the transaction into mined blocks at a higher (or lower) priority\\n\"\n             \"\\nArguments:\\n\"\n             \"1. \\\"txid\\\"       (string, required) The transaction id.\\n\"\n@@ -294,7 +295,7 @@ static UniValue getblocktemplate(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() > 1)\n         throw std::runtime_error(\n-            \"getblocktemplate ( TemplateRequest )\\n\"\n+            \"getblocktemplate ( \\\"template_request\\\" )\\n\"\n             \"\\nIf the request parameters include a 'mode' key, that is used to explicitly select between the default 'template' request or a 'proposal'.\\n\"\n             \"It returns data needed to construct a block to work on.\\n\"\n             \"For full specification, see BIPs 22, 23, 9, and 145:\\n\""
      },
      {
        "sha": "cebf12bb34190ae96436e50645eb3bbd4f1d682d",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -17,8 +17,8 @@\n #include <rpc/server.h>\n #include <rpc/util.h>\n #include <timedata.h>\n-#include <util.h>\n-#include <utilstrencodings.h>\n+#include <util/system.h>\n+#include <util/strencodings.h>\n #include <warnings.h>\n \n #include <stdint.h>\n@@ -446,7 +446,7 @@ static const CRPCCommand commands[] =\n     { \"control\",            \"getmemoryinfo\",          &getmemoryinfo,          {\"mode\"} },\n     { \"control\",            \"logging\",                &logging,                {\"include\", \"exclude\"}},\n     { \"util\",               \"validateaddress\",        &validateaddress,        {\"address\"} },\n-    { \"util\",               \"createmultisig\",         &createmultisig,         {\"nrequired\",\"keys\"} },\n+    { \"util\",               \"createmultisig\",         &createmultisig,         {\"nrequired\",\"keys\",\"address_type\"} },\n     { \"util\",               \"verifymessage\",          &verifymessage,          {\"address\",\"signature\",\"message\"} },\n     { \"util\",               \"signmessagewithprivkey\", &signmessagewithprivkey, {\"privkey\",\"message\"} },\n "
      },
      {
        "sha": "fc1498a22471a2359000bfb1d6da910ec511a148",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 8,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -7,17 +7,18 @@\n #include <chainparams.h>\n #include <clientversion.h>\n #include <core_io.h>\n-#include <validation.h>\n #include <net.h>\n #include <net_processing.h>\n #include <netbase.h>\n #include <policy/policy.h>\n #include <rpc/protocol.h>\n+#include <rpc/util.h>\n #include <sync.h>\n #include <timedata.h>\n #include <ui_interface.h>\n-#include <util.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n+#include <util/system.h>\n+#include <validation.h>\n #include <version.h>\n #include <warnings.h>\n \n@@ -200,7 +201,7 @@ static UniValue addnode(const JSONRPCRequest& request)\n     if (request.fHelp || request.params.size() != 2 ||\n         (strCommand != \"onetry\" && strCommand != \"add\" && strCommand != \"remove\"))\n         throw std::runtime_error(\n-            \"addnode \\\"node\\\" \\\"add|remove|onetry\\\"\\n\"\n+            \"addnode \\\"node\\\" \\\"command\\\"\\n\"\n             \"\\nAttempts to add or remove a node from the addnode list.\\n\"\n             \"Or try a connection to a node once.\\n\"\n             \"Nodes added using addnode (or -connect) are protected from DoS disconnection and are not required to be\\n\"\n@@ -243,13 +244,13 @@ static UniValue disconnectnode(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() == 0 || request.params.size() >= 3)\n         throw std::runtime_error(\n-            \"disconnectnode \\\"[address]\\\" [nodeid]\\n\"\n+            \"disconnectnode ( \\\"address\\\" nodeid )\\n\"\n             \"\\nImmediately disconnects from the specified peer node.\\n\"\n             \"\\nStrictly one out of 'address' and 'nodeid' can be provided to identify the node.\\n\"\n             \"\\nTo disconnect by nodeid, either set 'address' to the empty string, or call using the named 'nodeid' argument only.\\n\"\n             \"\\nArguments:\\n\"\n             \"1. \\\"address\\\"     (string, optional) The IP address/port of the node\\n\"\n-            \"2. \\\"nodeid\\\"      (number, optional) The node ID (see getpeerinfo for node IDs)\\n\"\n+            \"2. nodeid        (number, optional) The node ID (see getpeerinfo for node IDs)\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"disconnectnode\", \"\\\"192.168.0.6:8333\\\"\")\n             + HelpExampleCli(\"disconnectnode\", \"\\\"\\\" 1\")\n@@ -499,7 +500,7 @@ static UniValue setban(const JSONRPCRequest& request)\n     if (request.fHelp || request.params.size() < 2 ||\n         (strCommand != \"add\" && strCommand != \"remove\"))\n         throw std::runtime_error(\n-                            \"setban \\\"subnet\\\" \\\"add|remove\\\" (bantime) (absolute)\\n\"\n+                            \"setban \\\"subnet\\\" \\\"command\\\" ( bantime absolute )\\n\"\n                             \"\\nAttempts to add or remove an IP/Subnet from the banned list.\\n\"\n                             \"\\nArguments:\\n\"\n                             \"1. \\\"subnet\\\"       (string, required) The IP/Subnet (see getpeerinfo for nodes IP) with an optional netmask (default is /32 = single IP)\\n\"\n@@ -610,7 +611,7 @@ static UniValue setnetworkactive(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1) {\n         throw std::runtime_error(\n-            \"setnetworkactive true|false\\n\"\n+            \"setnetworkactive state\\n\"\n             \"\\nDisable/enable all p2p network activity.\\n\"\n             \"\\nArguments:\\n\"\n             \"1. \\\"state\\\"        (boolean, required) true to enable networking, false to disable\\n\""
      },
      {
        "sha": "23999b305a0ded59419eb9fb6fe2ba752441c3a4",
        "filename": "src/rpc/protocol.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/rpc/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/rpc/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/protocol.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -7,9 +7,9 @@\n \n #include <random.h>\n #include <tinyformat.h>\n-#include <util.h>\n-#include <utilstrencodings.h>\n-#include <utiltime.h>\n+#include <util/system.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n #include <version.h>\n \n /**"
      },
      {
        "sha": "480cb0b9d28be874edab20a91fe2594928628d53",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 104,
        "deletions": 24,
        "changes": 128,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -9,24 +9,26 @@\n #include <consensus/validation.h>\n #include <core_io.h>\n #include <index/txindex.h>\n-#include <keystore.h>\n-#include <validation.h>\n-#include <validationinterface.h>\n+#include <init.h>\n #include <key_io.h>\n+#include <keystore.h>\n #include <merkleblock.h>\n #include <net.h>\n #include <policy/policy.h>\n #include <policy/rbf.h>\n #include <primitives/transaction.h>\n #include <rpc/rawtransaction.h>\n #include <rpc/server.h>\n+#include <rpc/util.h>\n #include <script/script.h>\n #include <script/script_error.h>\n #include <script/sign.h>\n #include <script/standard.h>\n #include <txmempool.h>\n #include <uint256.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n #include <future>\n #include <stdint.h>\n@@ -204,7 +206,16 @@ static UniValue gettxoutproof(const JSONRPCRequest& request)\n {\n     if (request.fHelp || (request.params.size() != 1 && request.params.size() != 2))\n         throw std::runtime_error(\n-            \"gettxoutproof [\\\"txid\\\",...] ( blockhash )\\n\"\n+            RPCHelpMan{\"gettxoutproof\",\n+                {\n+                    {\"txids\", RPCArg::Type::ARR,\n+                        {\n+                            {\"txid\", RPCArg::Type::STR_HEX, false},\n+                        },\n+                        false},\n+                    {\"blockhash\", RPCArg::Type::STR_HEX, true},\n+                }}\n+                .ToString() +\n             \"\\nReturns a hex-encoded proof that \\\"txid\\\" was included in a block.\\n\"\n             \"\\nNOTE: By default this function only works sometimes. This is when there is an\\n\"\n             \"unspent output in the utxo for this transaction. To make it always work,\\n\"\n@@ -346,7 +357,7 @@ CMutableTransaction ConstructTransaction(const UniValue& inputs_in, const UniVal\n \n     if (!locktime.isNull()) {\n         int64_t nLockTime = locktime.get_int64();\n-        if (nLockTime < 0 || nLockTime > std::numeric_limits<uint32_t>::max())\n+        if (nLockTime < 0 || nLockTime > LOCKTIME_MAX)\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, locktime out of range\");\n         rawTx.nLockTime = nLockTime;\n     }\n@@ -368,18 +379,18 @@ CMutableTransaction ConstructTransaction(const UniValue& inputs_in, const UniVal\n \n         uint32_t nSequence;\n         if (rbfOptIn) {\n-            nSequence = MAX_BIP125_RBF_SEQUENCE;\n+            nSequence = MAX_BIP125_RBF_SEQUENCE; /* CTxIn::SEQUENCE_FINAL - 2 */\n         } else if (rawTx.nLockTime) {\n-            nSequence = std::numeric_limits<uint32_t>::max() - 1;\n+            nSequence = CTxIn::SEQUENCE_FINAL - 1;\n         } else {\n-            nSequence = std::numeric_limits<uint32_t>::max();\n+            nSequence = CTxIn::SEQUENCE_FINAL;\n         }\n \n         // set the sequence number if passed in the parameters object\n         const UniValue& sequenceObj = find_value(o, \"sequence\");\n         if (sequenceObj.isNum()) {\n             int64_t seqNr64 = sequenceObj.get_int64();\n-            if (seqNr64 < 0 || seqNr64 > std::numeric_limits<uint32_t>::max()) {\n+            if (seqNr64 < 0 || seqNr64 > CTxIn::SEQUENCE_FINAL) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, sequence number is out of range\");\n             } else {\n                 nSequence = (uint32_t)seqNr64;\n@@ -671,10 +682,17 @@ static void TxInErrorToJSON(const CTxIn& txin, UniValue& vErrorsRet, const std::\n \n static UniValue combinerawtransaction(const JSONRPCRequest& request)\n {\n-\n     if (request.fHelp || request.params.size() != 1)\n         throw std::runtime_error(\n-            \"combinerawtransaction [\\\"hexstring\\\",...]\\n\"\n+            RPCHelpMan{\"combinerawtransaction\",\n+                {\n+                    {\"txs\", RPCArg::Type::ARR,\n+                        {\n+                            {\"hexstring\", RPCArg::Type::STR_HEX, false},\n+                        },\n+                        false},\n+                }}\n+                .ToString() +\n             \"\\nCombine multiple partially signed transactions into one transaction.\\n\"\n             \"The combined transaction may be another partially signed transaction or a \\n\"\n             \"fully signed transaction.\"\n@@ -754,7 +772,7 @@ static UniValue combinerawtransaction(const JSONRPCRequest& request)\n     return EncodeHexTx(mergedTx);\n }\n \n-UniValue SignTransaction(CMutableTransaction& mtx, const UniValue& prevTxsUnival, CBasicKeyStore *keystore, bool is_temp_keystore, const UniValue& hashType)\n+UniValue SignTransaction(interfaces::Chain& chain, CMutableTransaction& mtx, const UniValue& prevTxsUnival, CBasicKeyStore *keystore, bool is_temp_keystore, const UniValue& hashType)\n {\n     // Fetch previous transactions (inputs):\n     CCoinsView viewDummy;\n@@ -897,7 +915,30 @@ static UniValue signrawtransactionwithkey(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n         throw std::runtime_error(\n-            \"signrawtransactionwithkey \\\"hexstring\\\" [\\\"privatekey1\\\",...] ( [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n,\\\"scriptPubKey\\\":\\\"hex\\\",\\\"redeemScript\\\":\\\"hex\\\"},...] sighashtype )\\n\"\n+            RPCHelpMan{\"signrawtransactionwithkey\",\n+                {\n+                    {\"hexstring\", RPCArg::Type::STR, false},\n+                    {\"privkyes\", RPCArg::Type::ARR,\n+                        {\n+                            {\"privatekey\", RPCArg::Type::STR_HEX, false},\n+                        },\n+                        false},\n+                    {\"prevtxs\", RPCArg::Type::ARR,\n+                        {\n+                            {\"\", RPCArg::Type::OBJ,\n+                                {\n+                                    {\"txid\", RPCArg::Type::STR_HEX, false},\n+                                    {\"vout\", RPCArg::Type::NUM, false},\n+                                    {\"scriptPubKey\", RPCArg::Type::STR_HEX, false},\n+                                    {\"redeemScript\", RPCArg::Type::STR_HEX, false},\n+                                    {\"amount\", RPCArg::Type::AMOUNT, false},\n+                                },\n+                                true},\n+                        },\n+                        true},\n+                    {\"sighashtype\", RPCArg::Type::STR, true},\n+                }}\n+                .ToString() +\n             \"\\nSign inputs for raw transaction (serialized, hex-encoded).\\n\"\n             \"The second argument is an array of base58-encoded private\\n\"\n             \"keys that will be the only keys used to sign the transaction.\\n\"\n@@ -969,7 +1010,7 @@ static UniValue signrawtransactionwithkey(const JSONRPCRequest& request)\n         keystore.AddKey(key);\n     }\n \n-    return SignTransaction(mtx, request.params[2], &keystore, true, request.params[3]);\n+    return SignTransaction(*g_rpc_interfaces->chain, mtx, request.params[2], &keystore, true, request.params[3]);\n }\n \n UniValue signrawtransaction(const JSONRPCRequest& request)\n@@ -1452,7 +1493,15 @@ UniValue combinepsbt(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n         throw std::runtime_error(\n-            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            RPCHelpMan{\"combinepsbt\",\n+                {\n+                    {\"txs\", RPCArg::Type::ARR,\n+                        {\n+                            {\"psbt\", RPCArg::Type::STR_HEX, false},\n+                        },\n+                        false},\n+                }}\n+                .ToString() +\n             \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n             \"Implements the Combiner role.\\n\"\n             \"\\nArguments:\\n\"\n@@ -1536,12 +1585,13 @@ UniValue finalizepsbt(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n     }\n \n-    // Get all of the previous transactions\n+    // Finalize input signatures -- in case we have partial signatures that add up to a complete\n+    //   signature, but have not combined them yet (e.g. because the combiner that created this\n+    //   PartiallySignedTransaction did not understand them), this will combine them into a final\n+    //   script.\n     bool complete = true;\n     for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n-        PSBTInput& input = psbtx.inputs.at(i);\n-\n-        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, i, 1);\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, psbtx, i, SIGHASH_ALL);\n     }\n \n     UniValue result(UniValue::VOBJ);\n@@ -1554,10 +1604,10 @@ UniValue finalizepsbt(const JSONRPCRequest& request)\n             mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n         }\n         ssTx << mtx;\n-        result.pushKV(\"hex\", HexStr(ssTx.begin(), ssTx.end()));\n+        result.pushKV(\"hex\", HexStr(ssTx.str()));\n     } else {\n         ssTx << psbtx;\n-        result.pushKV(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size()));\n+        result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));\n     }\n     result.pushKV(\"complete\", complete);\n \n@@ -1568,7 +1618,37 @@ UniValue createpsbt(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n         throw std::runtime_error(\n-                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+            RPCHelpMan{\"createpsbt\",\n+                {\n+                    {\"inputs\", RPCArg::Type::ARR,\n+                        {\n+                            {\"\", RPCArg::Type::OBJ,\n+                                {\n+                                    {\"txid\", RPCArg::Type::STR_HEX, false},\n+                                    {\"vout\", RPCArg::Type::NUM, false},\n+                                    {\"sequence\", RPCArg::Type::NUM, true},\n+                                },\n+                                false},\n+                        },\n+                        false},\n+                    {\"outputs\", RPCArg::Type::ARR,\n+                        {\n+                            {\"\", RPCArg::Type::OBJ,\n+                                {\n+                                    {\"address\", RPCArg::Type::AMOUNT, false},\n+                                },\n+                                true},\n+                            {\"\", RPCArg::Type::OBJ,\n+                                {\n+                                    {\"data\", RPCArg::Type::STR_HEX, false},\n+                                },\n+                                true},\n+                        },\n+                        false},\n+                    {\"locktime\", RPCArg::Type::NUM, true},\n+                    {\"replaceable\", RPCArg::Type::BOOL, true},\n+                }}\n+                .ToString() +\n                             \"\\nCreates a transaction in the Partially Signed Transaction format.\\n\"\n                             \"Implements the Creator role.\\n\"\n                             \"\\nArguments:\\n\"\n@@ -1669,7 +1749,7 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n \n     // Remove all scriptSigs and scriptWitnesses from inputs\n     for (CTxIn& input : tx.vin) {\n-        if ((!input.scriptSig.empty() || !input.scriptWitness.IsNull()) && (request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool()))) {\n+        if ((!input.scriptSig.empty() || !input.scriptWitness.IsNull()) && !permitsigdata) {\n             throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Inputs must not have scriptSigs and scriptWitnesses\");\n         }\n         input.scriptSig.clear();"
      },
      {
        "sha": "52d701d1c38839403228e511c3f67fc2ff0fc5b0",
        "filename": "src/rpc/rawtransaction.h",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/rpc/rawtransaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/rpc/rawtransaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -9,8 +9,12 @@ class CBasicKeyStore;\n struct CMutableTransaction;\n class UniValue;\n \n+namespace interfaces {\n+class Chain;\n+} // namespace interfaces\n+\n /** Sign a transaction with the given keystore and previous transactions */\n-UniValue SignTransaction(CMutableTransaction& mtx, const UniValue& prevTxs, CBasicKeyStore *keystore, bool tempKeystore, const UniValue& hashType);\n+UniValue SignTransaction(interfaces::Chain& chain, CMutableTransaction& mtx, const UniValue& prevTxs, CBasicKeyStore *keystore, bool tempKeystore, const UniValue& hashType);\n \n /** Create a transaction from univalue parameters */\n CMutableTransaction ConstructTransaction(const UniValue& inputs_in, const UniValue& outputs_in, const UniValue& locktime, const UniValue& rbf);"
      },
      {
        "sha": "f890baba516ff3403578f5903ceea66d7051f639",
        "filename": "src/rpc/server.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/rpc/server.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/rpc/server.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -8,11 +8,12 @@\n #include <fs.h>\n #include <key_io.h>\n #include <random.h>\n+#include <rpc/util.h>\n #include <shutdown.h>\n #include <sync.h>\n #include <ui_interface.h>\n-#include <util.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n+#include <util/system.h>\n \n #include <boost/bind.hpp>\n #include <boost/signals2/signal.hpp>\n@@ -234,7 +235,7 @@ UniValue stop(const JSONRPCRequest& jsonRequest)\n \n static UniValue uptime(const JSONRPCRequest& jsonRequest)\n {\n-    if (jsonRequest.fHelp || jsonRequest.params.size() > 1)\n+    if (jsonRequest.fHelp || jsonRequest.params.size() > 0)\n         throw std::runtime_error(\n                 \"uptime\\n\"\n                         \"\\nReturns the total uptime of the server.\\n\""
      },
      {
        "sha": "6f2450708add9737fb938807700c255595d6d579",
        "filename": "src/rpc/util.cpp",
        "status": "modified",
        "additions": 95,
        "deletions": 1,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/rpc/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/rpc/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -7,7 +7,9 @@\n #include <rpc/protocol.h>\n #include <rpc/util.h>\n #include <tinyformat.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n+\n+InitInterfaces* g_rpc_interfaces = nullptr;\n \n // Converts a hex string to a public key if possible\n CPubKey HexToPubKey(const std::string& hex_in)\n@@ -126,3 +128,95 @@ UniValue DescribeAddress(const CTxDestination& dest)\n {\n     return boost::apply_visitor(DescribeAddressVisitor(), dest);\n }\n+\n+std::string RPCHelpMan::ToString() const\n+{\n+    std::string ret;\n+\n+    ret += m_name;\n+    bool is_optional{false};\n+    for (const auto& arg : m_args) {\n+        ret += \" \";\n+        if (arg.m_optional) {\n+            if (!is_optional) ret += \"( \";\n+            is_optional = true;\n+        } else {\n+            // Currently we still support unnamed arguments, so any argument following an optional argument must also be optional\n+            // If support for positional arguments is deprecated in the future, remove this line\n+            assert(!is_optional);\n+        }\n+        ret += arg.ToString();\n+    }\n+    if (is_optional) ret += \" )\";\n+    ret += \"\\n\";\n+\n+    return ret;\n+}\n+\n+std::string RPCArg::ToStringObj() const\n+{\n+    std::string res = \"\\\"\" + m_name + \"\\\":\";\n+    switch (m_type) {\n+    case Type::STR:\n+        return res + \"\\\"str\\\"\";\n+    case Type::STR_HEX:\n+        return res + \"\\\"hex\\\"\";\n+    case Type::NUM:\n+        return res + \"n\";\n+    case Type::AMOUNT:\n+        return res + \"amount\";\n+    case Type::BOOL:\n+        return res + \"bool\";\n+    case Type::ARR:\n+        res += \"[\";\n+        for (const auto& i : m_inner) {\n+            res += i.ToString() + \",\";\n+        }\n+        return res + \"...]\";\n+    case Type::OBJ:\n+    case Type::OBJ_USER_KEYS:\n+        // Currently unused, so avoid writing dead code\n+        assert(false);\n+\n+        // no default case, so the compiler can warn about missing cases\n+    }\n+    assert(false);\n+}\n+\n+std::string RPCArg::ToString() const\n+{\n+    switch (m_type) {\n+    case Type::STR_HEX:\n+    case Type::STR: {\n+        return \"\\\"\" + m_name + \"\\\"\";\n+    }\n+    case Type::NUM:\n+    case Type::AMOUNT:\n+    case Type::BOOL: {\n+        return m_name;\n+    }\n+    case Type::OBJ:\n+    case Type::OBJ_USER_KEYS: {\n+        std::string res;\n+        for (size_t i = 0; i < m_inner.size();) {\n+            res += m_inner[i].ToStringObj();\n+            if (++i < m_inner.size()) res += \",\";\n+        }\n+        if (m_type == Type::OBJ) {\n+            return \"{\" + res + \"}\";\n+        } else {\n+            return \"{\" + res + \",...}\";\n+        }\n+    }\n+    case Type::ARR: {\n+        std::string res;\n+        for (const auto& i : m_inner) {\n+            res += i.ToString() + \",\";\n+        }\n+        return \"[\" + res + \"...]\";\n+    }\n+\n+        // no default case, so the compiler can warn about missing cases\n+    }\n+    assert(false);\n+}"
      },
      {
        "sha": "55ae2fa3632b597be1f38887fb0c7ba8351337dd",
        "filename": "src/rpc/util.h",
        "status": "modified",
        "additions": 55,
        "deletions": 0,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/rpc/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/rpc/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -17,11 +17,66 @@\n class CKeyStore;\n class CPubKey;\n class CScript;\n+struct InitInterfaces;\n+\n+//! Pointers to interfaces that need to be accessible from RPC methods. Due to\n+//! limitations of the RPC framework, there's currently no direct way to pass in\n+//! state to RPC method implementations.\n+extern InitInterfaces* g_rpc_interfaces;\n \n CPubKey HexToPubKey(const std::string& hex_in);\n CPubKey AddrToPubKey(CKeyStore* const keystore, const std::string& addr_in);\n CScript CreateMultisigRedeemscript(const int required, const std::vector<CPubKey>& pubkeys);\n \n UniValue DescribeAddress(const CTxDestination& dest);\n \n+struct RPCArg {\n+    enum class Type {\n+        OBJ,\n+        ARR,\n+        STR,\n+        NUM,\n+        BOOL,\n+        OBJ_USER_KEYS, //!< Special type where the user must set the keys e.g. to define multiple addresses; as opposed to e.g. an options object where the keys are predefined\n+        AMOUNT,        //!< Special type representing a floating point amount (can be either NUM or STR)\n+        STR_HEX,       //!< Special type that is a STR with only hex chars\n+    };\n+    const std::string m_name; //!< The name of the arg (can be empty for inner args)\n+    const Type m_type;\n+    const std::vector<RPCArg> m_inner; //!< Only used for arrays or dicts\n+    const bool m_optional;\n+\n+    RPCArg(const std::string& name, const Type& type, const bool optional)\n+        : m_name{name}, m_type{type}, m_optional{optional}\n+    {\n+        assert(type != Type::ARR && type != Type::OBJ);\n+    }\n+\n+    RPCArg(const std::string& name, const Type& type, const std::vector<RPCArg>& inner, const bool optional)\n+        : m_name{name}, m_type{type}, m_inner{inner}, m_optional{optional}\n+    {\n+        assert(type == Type::ARR || type == Type::OBJ);\n+    }\n+\n+    std::string ToString() const;\n+\n+private:\n+    std::string ToStringObj() const;\n+};\n+\n+class RPCHelpMan\n+{\n+public:\n+    RPCHelpMan(const std::string& name, const std::vector<RPCArg>& args)\n+        : m_name{name}, m_args{args}\n+    {\n+    }\n+\n+    std::string ToString() const;\n+\n+private:\n+    const std::string m_name;\n+    const std::vector<RPCArg> m_args;\n+};\n+\n #endif // BITCOIN_RPC_UTIL_H"
      },
      {
        "sha": "90c4ddcc1182446a10459e30d228256db2531a99",
        "filename": "src/script/descriptor.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/script/descriptor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/script/descriptor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -10,8 +10,8 @@\n #include <script/standard.h>\n \n #include <span.h>\n-#include <util.h>\n-#include <utilstrencodings.h>\n+#include <util/system.h>\n+#include <util/strencodings.h>\n \n #include <memory>\n #include <string>"
      },
      {
        "sha": "982aa241e7de6ce8ca2259d8167a5ccaf90dc633",
        "filename": "src/script/script.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/script/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/script/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -6,7 +6,7 @@\n #include <script/script.h>\n \n #include <tinyformat.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n \n const char* GetOpName(opcodetype opcode)\n {"
      },
      {
        "sha": "1d8ddba2f2d7a30598eee2d5544813f692b88ed2",
        "filename": "src/script/script.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -38,6 +38,12 @@ static const int MAX_STACK_SIZE = 1000;\n // otherwise as UNIX timestamp.\n static const unsigned int LOCKTIME_THRESHOLD = 500000000; // Tue Nov  5 00:53:20 1985 UTC\n \n+// Maximum nLockTime. Since a lock time indicates the last invalid timestamp, a\n+// transaction with this lock time will never be valid unless lock time\n+// checking is disabled (by setting all input sequence numbers to\n+// SEQUENCE_FINAL).\n+static const uint32_t LOCKTIME_MAX = 0xFFFFFFFFU;\n+\n template <typename T>\n std::vector<unsigned char> ToByteVector(const T& in)\n {"
      },
      {
        "sha": "94005cf6f35bd8c789f7b9819337eaef3ef59809",
        "filename": "src/script/sigcache.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/script/sigcache.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/script/sigcache.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sigcache.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -9,7 +9,7 @@\n #include <pubkey.h>\n #include <random.h>\n #include <uint256.h>\n-#include <util.h>\n+#include <util/system.h>\n \n #include <cuckoocache.h>\n #include <boost/thread.hpp>"
      },
      {
        "sha": "2795dc96d30e925f7c758234501f2995563d6f35",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 18,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -123,7 +123,7 @@ static bool SignStep(const SigningProvider& provider, const BaseSignatureCreator\n     case TX_PUBKEYHASH: {\n         CKeyID keyID = CKeyID(uint160(vSolutions[0]));\n         CPubKey pubkey;\n-        GetPubKey(provider, sigdata, keyID, pubkey);\n+        if (!GetPubKey(provider, sigdata, keyID, pubkey)) return false;\n         if (!CreateSig(creator, sigdata, provider, sig, pubkey, scriptPubKey, sigversion)) return false;\n         ret.push_back(std::move(sig));\n         ret.push_back(ToByteVector(pubkey));\n@@ -239,10 +239,17 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n     return sigdata.complete;\n }\n \n-bool SignPSBTInput(const SigningProvider& provider, const CMutableTransaction& tx, PSBTInput& input, int index, int sighash)\n+bool PSBTInputSigned(PSBTInput& input)\n {\n-    // if this input has a final scriptsig or scriptwitness, don't do anything with it\n-    if (!input.final_script_sig.empty() || !input.final_script_witness.IsNull()) {\n+    return !input.final_script_sig.empty() || !input.final_script_witness.IsNull();\n+}\n+\n+bool SignPSBTInput(const SigningProvider& provider, PartiallySignedTransaction& psbt, int index, int sighash)\n+{\n+    PSBTInput& input = psbt.inputs.at(index);\n+    const CMutableTransaction& tx = *psbt.tx;\n+\n+    if (PSBTInputSigned(input)) {\n         return true;\n     }\n \n@@ -253,15 +260,19 @@ bool SignPSBTInput(const SigningProvider& provider, const CMutableTransaction& t\n     // Get UTXO\n     bool require_witness_sig = false;\n     CTxOut utxo;\n+\n+    // Verify input sanity, which checks that at most one of witness or non-witness utxos is provided.\n+    if (!input.IsSane()) {\n+        return false;\n+    }\n+\n     if (input.non_witness_utxo) {\n         // If we're taking our information from a non-witness UTXO, verify that it matches the prevout.\n-        if (input.non_witness_utxo->GetHash() != tx.vin[index].prevout.hash) return false;\n-        // If both witness and non-witness UTXO are provided, verify that they match. This check shouldn't\n-        // matter, as the PSBT deserializer enforces only one of both is provided, and the only way both\n-        // can be present is when they're added simultaneously by FillPSBT (in which case they always match).\n-        // Still, check in order to not rely on callers to enforce this.\n-        if (!input.witness_utxo.IsNull() && input.non_witness_utxo->vout[tx.vin[index].prevout.n] != input.witness_utxo) return false;\n-        utxo = input.non_witness_utxo->vout[tx.vin[index].prevout.n];\n+        COutPoint prevout = tx.vin[index].prevout;\n+        if (input.non_witness_utxo->GetHash() != prevout.hash) {\n+            return false;\n+        }\n+        utxo = input.non_witness_utxo->vout[prevout.n];\n     } else if (!input.witness_utxo.IsNull()) {\n         utxo = input.witness_utxo;\n         // When we're taking our information from a witness UTXO, we can't verify it is actually data from\n@@ -280,13 +291,10 @@ bool SignPSBTInput(const SigningProvider& provider, const CMutableTransaction& t\n     if (require_witness_sig && !sigdata.witness) return false;\n     input.FromSignatureData(sigdata);\n \n-    // If both UTXO types are present, drop the unnecessary one.\n-    if (input.non_witness_utxo && !input.witness_utxo.IsNull()) {\n-        if (sigdata.witness) {\n-            input.non_witness_utxo = nullptr;\n-        } else {\n-            input.witness_utxo.SetNull();\n-        }\n+    // If we have a witness signature, use the smaller witness UTXO.\n+    if (sigdata.witness) {\n+        input.witness_utxo = utxo;\n+        input.non_witness_utxo = nullptr;\n     }\n \n     return sig_complete;\n@@ -508,6 +516,12 @@ bool IsSolvable(const SigningProvider& provider, const CScript& script)\n     return false;\n }\n \n+PartiallySignedTransaction::PartiallySignedTransaction(const CTransaction& tx) : tx(tx)\n+{\n+    inputs.resize(tx.vin.size());\n+    outputs.resize(tx.vout.size());\n+}\n+\n bool PartiallySignedTransaction::IsNull() const\n {\n     return !tx && inputs.empty() && outputs.empty() && unknown.empty();"
      },
      {
        "sha": "a478f49789f6b48e15d07a8a8cd6fd46ce81e0de",
        "filename": "src/script/sign.h",
        "status": "modified",
        "additions": 35,
        "deletions": 4,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -206,6 +206,9 @@ template<typename Stream>\n void SerializeHDKeypaths(Stream& s, const std::map<CPubKey, KeyOriginInfo>& hd_keypaths, uint8_t type)\n {\n     for (auto keypath_pair : hd_keypaths) {\n+        if (!keypath_pair.first.IsValid()) {\n+            throw std::ios_base::failure(\"Invalid CPubKey being serialized\");\n+        }\n         SerializeToVector(s, type, MakeSpan(keypath_pair.first));\n         WriteCompactSize(s, (keypath_pair.second.path.size() + 1) * sizeof(uint32_t));\n         s << keypath_pair.second.fingerprint;\n@@ -302,14 +305,18 @@ struct PSBTInput\n     template <typename Stream>\n     inline void Unserialize(Stream& s) {\n         // Read loop\n+        bool found_sep = false;\n         while(!s.empty()) {\n             // Read\n             std::vector<unsigned char> key;\n             s >> key;\n \n             // the key is empty if that was actually a separator byte\n             // This is a special case for key lengths 0 as those are not allowed (except for separator)\n-            if (key.empty()) return;\n+            if (key.empty()) {\n+                found_sep = true;\n+                break;\n+            }\n \n             // First byte of key is the type\n             unsigned char type = key[0];\n@@ -424,6 +431,10 @@ struct PSBTInput\n                     break;\n             }\n         }\n+\n+        if (!found_sep) {\n+            throw std::ios_base::failure(\"Separator is missing at the end of an input map\");\n+        }\n     }\n \n     template <typename Stream>\n@@ -477,14 +488,18 @@ struct PSBTOutput\n     template <typename Stream>\n     inline void Unserialize(Stream& s) {\n         // Read loop\n+        bool found_sep = false;\n         while(!s.empty()) {\n             // Read\n             std::vector<unsigned char> key;\n             s >> key;\n \n             // the key is empty if that was actually a separator byte\n             // This is a special case for key lengths 0 as those are not allowed (except for separator)\n-            if (key.empty()) return;\n+            if (key.empty()) {\n+                found_sep = true;\n+                break;\n+            }\n \n             // First byte of key is the type\n             unsigned char type = key[0];\n@@ -529,6 +544,10 @@ struct PSBTOutput\n                 }\n             }\n         }\n+\n+        if (!found_sep) {\n+            throw std::ios_base::failure(\"Separator is missing at the end of an output map\");\n+        }\n     }\n \n     template <typename Stream>\n@@ -550,6 +569,7 @@ struct PartiallySignedTransaction\n     bool IsSane() const;\n     PartiallySignedTransaction() {}\n     PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in) : tx(psbt_in.tx), inputs(psbt_in.inputs), outputs(psbt_in.outputs), unknown(psbt_in.unknown) {}\n+    explicit PartiallySignedTransaction(const CTransaction& tx);\n \n     // Only checks if they refer to the same transaction\n     friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n@@ -604,14 +624,18 @@ struct PartiallySignedTransaction\n         }\n \n         // Read global data\n+        bool found_sep = false;\n         while(!s.empty()) {\n             // Read\n             std::vector<unsigned char> key;\n             s >> key;\n \n             // the key is empty if that was actually a separator byte\n             // This is a special case for key lengths 0 as those are not allowed (except for separator)\n-            if (key.empty()) break;\n+            if (key.empty()) {\n+                found_sep = true;\n+                break;\n+            }\n \n             // First byte of key is the type\n             unsigned char type = key[0];\n@@ -651,6 +675,10 @@ struct PartiallySignedTransaction\n             }\n         }\n \n+        if (!found_sep) {\n+            throw std::ios_base::failure(\"Separator is missing at the end of the global map\");\n+        }\n+\n         // Make sure that we got an unsigned tx\n         if (!tx) {\n             throw std::ios_base::failure(\"No unsigned transcation was provided\");\n@@ -705,8 +733,11 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n bool SignSignature(const SigningProvider &provider, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, const CAmount& amount, int nHashType);\n bool SignSignature(const SigningProvider &provider, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType);\n \n+/** Checks whether a PSBTInput is already signed. */\n+bool PSBTInputSigned(PSBTInput& input);\n+\n /** Signs a PSBTInput, verifying that all provided data matches what is being signed. */\n-bool SignPSBTInput(const SigningProvider& provider, const CMutableTransaction& tx, PSBTInput& input, int index, int sighash = SIGHASH_ALL);\n+bool SignPSBTInput(const SigningProvider& provider, PartiallySignedTransaction& psbt, int index, int sighash = SIGHASH_ALL);\n \n /** Extract signature data from a transaction input, and insert it. */\n SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn, const CTxOut& txout);"
      },
      {
        "sha": "31bfd04b0f4d7715eab6c580b673f8428ee38559",
        "filename": "src/script/standard.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/script/standard.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/script/standard.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -8,8 +8,8 @@\n #include <crypto/sha256.h>\n #include <pubkey.h>\n #include <script/script.h>\n-#include <util.h>\n-#include <utilstrencodings.h>\n+#include <util/system.h>\n+#include <util/strencodings.h>\n \n \n typedef std::vector<unsigned char> valtype;"
      },
      {
        "sha": "30811f5f898f4e56778c914d2f4303c72a7c1f58",
        "filename": "src/sync.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/sync.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/sync.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -5,7 +5,7 @@\n #include <sync.h>\n \n #include <logging.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n \n #include <stdio.h>\n "
      },
      {
        "sha": "5a108dcdadf9696f6c1f1b00b1ce4747a8d6f9b2",
        "filename": "src/test/allocator_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/allocator_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/allocator_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/allocator_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -2,7 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <util.h>\n+#include <util/system.h>\n \n #include <support/allocators/secure.h>\n #include <test/test_bitcoin.h>"
      },
      {
        "sha": "32af843bf6ebb04fe958f61ab4e262a4cb3e1696",
        "filename": "src/test/base32_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/base32_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/base32_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/base32_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -2,7 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n #include <test/test_bitcoin.h>\n \n #include <boost/test/unit_test.hpp>"
      },
      {
        "sha": "f8f9b3c1a7e3554a01b1e89b9236f53b67f5c252",
        "filename": "src/test/base58_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/base58_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/base58_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/base58_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -6,7 +6,7 @@\n \n #include <base58.h>\n #include <test/test_bitcoin.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n \n #include <univalue.h>\n "
      },
      {
        "sha": "0abbb682a7c452dfb9890c8ce1886b5682e105ff",
        "filename": "src/test/base64_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/base64_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/base64_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/base64_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -2,7 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n #include <test/test_bitcoin.h>\n \n #include <boost/test/unit_test.hpp>"
      },
      {
        "sha": "c9951f4b7e50af3c376f1ce87fcad422312b4f0a",
        "filename": "src/test/bip32_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/bip32_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/bip32_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bip32_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -7,8 +7,8 @@\n #include <key.h>\n #include <key_io.h>\n #include <uint256.h>\n-#include <util.h>\n-#include <utilstrencodings.h>\n+#include <util/system.h>\n+#include <util/strencodings.h>\n #include <test/test_bitcoin.h>\n \n #include <string>"
      },
      {
        "sha": "2144202b8d5411f56d76062bc853741c47b010c0",
        "filename": "src/test/blockfilter_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/blockfilter_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/blockfilter_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/blockfilter_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -10,7 +10,7 @@\n #include <serialize.h>\n #include <streams.h>\n #include <univalue.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n \n #include <boost/test/unit_test.hpp>\n "
      },
      {
        "sha": "c900bee199e19498ce96571aaa4d1f865510caef",
        "filename": "src/test/bloom_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/bloom_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/bloom_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bloom_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -13,8 +13,8 @@\n #include <serialize.h>\n #include <streams.h>\n #include <uint256.h>\n-#include <util.h>\n-#include <utilstrencodings.h>\n+#include <util/system.h>\n+#include <util/strencodings.h>\n #include <test/test_bitcoin.h>\n \n #include <vector>"
      },
      {
        "sha": "a757e06a9d4e6f6dbae2a0172418619b98e0a1f3",
        "filename": "src/test/checkqueue_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/checkqueue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/checkqueue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkqueue_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -2,8 +2,8 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <util.h>\n-#include <utiltime.h>\n+#include <util/system.h>\n+#include <util/time.h>\n #include <validation.h>\n \n #include <test/test_bitcoin.h>"
      },
      {
        "sha": "521312f1b7968298a87fcf7fdaaa0adbe81cc93a",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -6,7 +6,7 @@\n #include <script/standard.h>\n #include <uint256.h>\n #include <undo.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n #include <test/test_bitcoin.h>\n #include <validation.h>\n #include <consensus/validation.h>"
      },
      {
        "sha": "e686c05165ca45cf081106edb2b2aaa64a1c03fe",
        "filename": "src/test/compress_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/compress_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/compress_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/compress_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -3,7 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <compressor.h>\n-#include <util.h>\n+#include <util/system.h>\n #include <test/test_bitcoin.h>\n \n #include <stdint.h>"
      },
      {
        "sha": "f3fd83a0cc072498f895c0139c275bc47e0ce5e8",
        "filename": "src/test/crypto_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/crypto_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/crypto_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/crypto_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -11,7 +11,7 @@\n #include <crypto/hmac_sha256.h>\n #include <crypto/hmac_sha512.h>\n #include <random.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n #include <test/test_bitcoin.h>\n \n #include <vector>"
      },
      {
        "sha": "97cf5ed34527142035d361041625a8ca6eb8a878",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -11,7 +11,7 @@\n #include <pow.h>\n #include <script/sign.h>\n #include <serialize.h>\n-#include <util.h>\n+#include <util/system.h>\n #include <validation.h>\n \n #include <test/test_bitcoin.h>"
      },
      {
        "sha": "57e4b067c0302b99c6d68bd9355b4c799054a9bf",
        "filename": "src/test/descriptor_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/descriptor_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/descriptor_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/descriptor_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -9,7 +9,7 @@\n #include <test/test_bitcoin.h>\n #include <boost/test/unit_test.hpp>\n #include <script/descriptor.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n \n namespace {\n "
      },
      {
        "sha": "0432ede3e0046d01431f3398b9c25cd7ff344116",
        "filename": "src/test/getarg_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/getarg_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/getarg_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/getarg_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -2,7 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <util.h>\n+#include <util/system.h>\n #include <test/test_bitcoin.h>\n \n #include <string>"
      },
      {
        "sha": "e8e50408550bdc0d218e454ef6bb009070a8bc80",
        "filename": "src/test/hash_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/hash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/hash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/hash_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -2,8 +2,9 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include <crypto/siphash.h>\n #include <hash.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n #include <test/test_bitcoin.h>\n \n #include <vector>"
      },
      {
        "sha": "5db62f4bbabe319ad24ff29ee10ad5931c13a74b",
        "filename": "src/test/key_io_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/key_io_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/key_io_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/key_io_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -8,7 +8,7 @@\n #include <key.h>\n #include <key_io.h>\n #include <script/script.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n #include <test/test_bitcoin.h>\n \n #include <boost/test/unit_test.hpp>"
      },
      {
        "sha": "c564b4eab82777b4fee48a3cfea8112a56b2cdf1",
        "filename": "src/test/key_properties.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/key_properties.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/key_properties.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/key_properties.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -6,8 +6,8 @@\n #include <base58.h>\n #include <script/script.h>\n #include <uint256.h>\n-#include <util.h>\n-#include <utilstrencodings.h>\n+#include <util/system.h>\n+#include <util/strencodings.h>\n #include <test/test_bitcoin.h>\n #include <string>\n #include <vector>"
      },
      {
        "sha": "91cafd05d987427126bf8ee7bffafc84e1dd57a3",
        "filename": "src/test/key_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/key_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/key_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/key_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -7,8 +7,8 @@\n #include <key_io.h>\n #include <script/script.h>\n #include <uint256.h>\n-#include <util.h>\n-#include <utilstrencodings.h>\n+#include <util/system.h>\n+#include <util/strencodings.h>\n #include <test/test_bitcoin.h>\n \n #include <string>"
      },
      {
        "sha": "db38c9623c7c9dd6f24df6af37e2284e1d3c3fd2",
        "filename": "src/test/mempool_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/mempool_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/mempool_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/mempool_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -4,7 +4,7 @@\n \n #include <policy/policy.h>\n #include <txmempool.h>\n-#include <util.h>\n+#include <util/system.h>\n \n #include <test/test_bitcoin.h>\n "
      },
      {
        "sha": "a7074a5e43a4da3b62b84f56656ba003237c0078",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -15,8 +15,8 @@\n #include <script/standard.h>\n #include <txmempool.h>\n #include <uint256.h>\n-#include <util.h>\n-#include <utilstrencodings.h>\n+#include <util/system.h>\n+#include <util/strencodings.h>\n \n #include <test/test_bitcoin.h>\n \n@@ -92,8 +92,8 @@ static CBlockIndex CreateBlockIndex(int nHeight)\n \n static bool TestSequenceLocks(const CTransaction &tx, int flags) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    LOCK(mempool.cs);\n-    return CheckSequenceLocks(tx, flags);\n+    LOCK(::mempool.cs);\n+    return CheckSequenceLocks(::mempool, tx, flags);\n }\n \n // Test suite for ancestor feerate transaction selection."
      },
      {
        "sha": "213afed7301d8c3869fd27da192fa988ec798b63",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -11,7 +11,7 @@\n #include <net.h>\n #include <netbase.h>\n #include <chainparams.h>\n-#include <util.h>\n+#include <util/system.h>\n \n #include <memory>\n "
      },
      {
        "sha": "0d557cff13e4552f2bfdd6ecf4168d0cc21a25b4",
        "filename": "src/test/netbase_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/netbase_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/netbase_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/netbase_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -4,7 +4,7 @@\n \n #include <netbase.h>\n #include <test/test_bitcoin.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n \n #include <string>\n "
      },
      {
        "sha": "51668cbe6475dd52541730c517d51a4944d9926e",
        "filename": "src/test/policyestimator_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/policyestimator_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/policyestimator_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/policyestimator_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -6,7 +6,7 @@\n #include <policy/fees.h>\n #include <txmempool.h>\n #include <uint256.h>\n-#include <util.h>\n+#include <util/system.h>\n \n #include <test/test_bitcoin.h>\n "
      },
      {
        "sha": "26cdc9bc5c189f9842b568eafbc48eff5d3ab628",
        "filename": "src/test/pow_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/pow_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/pow_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/pow_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -1,12 +1,12 @@\n // Copyright (c) 2015-2018 The Bitcoin Core developers\n-// Distributed under the MIT/X11 software license, see the accompanying\n+// Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <chain.h>\n #include <chainparams.h>\n #include <pow.h>\n #include <random.h>\n-#include <util.h>\n+#include <util/system.h>\n #include <test/test_bitcoin.h>\n \n #include <boost/test/unit_test.hpp>"
      },
      {
        "sha": "121b72a5f7fe9572fb0ad34ba31d53baea5b3996",
        "filename": "src/test/rpc_tests.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/rpc_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/rpc_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/rpc_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -4,8 +4,11 @@\n \n #include <rpc/server.h>\n #include <rpc/client.h>\n+#include <rpc/util.h>\n \n #include <core_io.h>\n+#include <init.h>\n+#include <interfaces/chain.h>\n #include <key_io.h>\n #include <netbase.h>\n \n@@ -112,10 +115,14 @@ BOOST_AUTO_TEST_CASE(rpc_rawsign)\n     std::string notsigned = r.get_str();\n     std::string privkey1 = \"\\\"KzsXybp9jX64P5ekX1KUxRQ79Jht9uzW7LorgwE65i5rWACL6LQe\\\"\";\n     std::string privkey2 = \"\\\"Kyhdf5LuKTRx4ge69ybABsiUAWjVRK4XGxAKk2FQLp2HjGMy87Z4\\\"\";\n+    InitInterfaces interfaces;\n+    interfaces.chain = interfaces::MakeChain();\n+    g_rpc_interfaces = &interfaces;\n     r = CallRPC(std::string(\"signrawtransactionwithkey \")+notsigned+\" [] \"+prevout);\n     BOOST_CHECK(find_value(r.get_obj(), \"complete\").get_bool() == false);\n     r = CallRPC(std::string(\"signrawtransactionwithkey \")+notsigned+\" [\"+privkey1+\",\"+privkey2+\"] \"+prevout);\n     BOOST_CHECK(find_value(r.get_obj(), \"complete\").get_bool() == true);\n+    g_rpc_interfaces = nullptr;\n }\n \n BOOST_AUTO_TEST_CASE(rpc_createraw_op_return)"
      },
      {
        "sha": "1c70fdcce671ad153835744823715231a365c318",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -10,8 +10,8 @@\n #include <script/script.h>\n #include <script/script_error.h>\n #include <script/sign.h>\n-#include <util.h>\n-#include <utilstrencodings.h>\n+#include <util/system.h>\n+#include <util/strencodings.h>\n #include <test/test_bitcoin.h>\n #include <rpc/server.h>\n "
      },
      {
        "sha": "c329844341057067dc2030f122a1b58bd4cbd1bc",
        "filename": "src/test/sighash_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/sighash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/sighash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sighash_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -11,8 +11,8 @@\n #include <serialize.h>\n #include <streams.h>\n #include <test/test_bitcoin.h>\n-#include <util.h>\n-#include <utilstrencodings.h>\n+#include <util/system.h>\n+#include <util/strencodings.h>\n #include <version.h>\n \n #include <iostream>"
      },
      {
        "sha": "5c46976ace79ef712dac1e95cb5bc9cf077269db",
        "filename": "src/test/skiplist_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/skiplist_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/skiplist_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/skiplist_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -3,7 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <chain.h>\n-#include <util.h>\n+#include <util/system.h>\n #include <test/test_bitcoin.h>\n \n #include <vector>\n@@ -170,7 +170,6 @@ BOOST_AUTO_TEST_CASE(findearliestatleast_edge_test)\n     BOOST_CHECK_EQUAL(chain.FindEarliestAtLeast(-1)->nHeight, 0);\n \n     BOOST_CHECK_EQUAL(chain.FindEarliestAtLeast(std::numeric_limits<int64_t>::min())->nHeight, 0);\n-    BOOST_CHECK_EQUAL(chain.FindEarliestAtLeast(std::numeric_limits<unsigned int>::min())->nHeight, 0);\n     BOOST_CHECK_EQUAL(chain.FindEarliestAtLeast(-int64_t(std::numeric_limits<unsigned int>::max()) - 1)->nHeight, 0);\n     BOOST_CHECK(!chain.FindEarliestAtLeast(std::numeric_limits<int64_t>::max()));\n     BOOST_CHECK(!chain.FindEarliestAtLeast(std::numeric_limits<unsigned int>::max()));"
      },
      {
        "sha": "9978c71661f4be005f36682fc7376da2990eb23c",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -19,7 +19,7 @@\n #include <script/sign.h>\n #include <script/script_error.h>\n #include <script/standard.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n \n #include <map>\n #include <string>"
      },
      {
        "sha": "43e025c58faa9aa5160ceb19de023c1e8c36c32a",
        "filename": "src/test/txindex_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/txindex_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/txindex_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txindex_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -5,8 +5,8 @@\n #include <index/txindex.h>\n #include <script/standard.h>\n #include <test/test_bitcoin.h>\n-#include <util.h>\n-#include <utiltime.h>\n+#include <util/system.h>\n+#include <util/time.h>\n #include <validation.h>\n \n #include <boost/test/unit_test.hpp>"
      },
      {
        "sha": "506a60d173c1b8381fa5f245a1720c6510df4398",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -12,7 +12,7 @@\n #include <script/standard.h>\n #include <script/sign.h>\n #include <test/test_bitcoin.h>\n-#include <utiltime.h>\n+#include <util/time.h>\n #include <core_io.h>\n #include <keystore.h>\n #include <policy/policy.h>"
      },
      {
        "sha": "ff19b12a9c04ff5f0ea87a742963f57e63a64c3a",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -2,13 +2,13 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <util.h>\n+#include <util/system.h>\n \n #include <clientversion.h>\n #include <primitives/transaction.h>\n #include <sync.h>\n-#include <utilstrencodings.h>\n-#include <utilmoneystr.h>\n+#include <util/strencodings.h>\n+#include <util/moneystr.h>\n #include <test/test_bitcoin.h>\n \n #include <stdint.h>"
      },
      {
        "sha": "33acddc65cf462c6de5fc84a9301ddfce16993de",
        "filename": "src/threadsafety.h",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/threadsafety.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/threadsafety.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/threadsafety.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -54,4 +54,15 @@\n #define ASSERT_EXCLUSIVE_LOCK(...)\n #endif // __GNUC__\n \n+// Utility class for indicating to compiler thread analysis that a mutex is\n+// locked (when it couldn't be determined otherwise).\n+struct SCOPED_LOCKABLE LockAnnotation\n+{\n+    template <typename Mutex>\n+    explicit LockAnnotation(Mutex& mutex) EXCLUSIVE_LOCK_FUNCTION(mutex)\n+    {\n+    }\n+    ~LockAnnotation() UNLOCK_FUNCTION() {}\n+};\n+\n #endif // BITCOIN_THREADSAFETY_H"
      },
      {
        "sha": "9c022c9ad1bb816ac48422e2214d0acdf83bc8a1",
        "filename": "src/timedata.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/timedata.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/timedata.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -11,8 +11,8 @@\n #include <netaddress.h>\n #include <sync.h>\n #include <ui_interface.h>\n-#include <util.h>\n-#include <utilstrencodings.h>\n+#include <util/system.h>\n+#include <util/strencodings.h>\n #include <warnings.h>\n \n "
      },
      {
        "sha": "229cc7d553eba02949344019f587d5bfeaa363e5",
        "filename": "src/torcontrol.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/torcontrol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/torcontrol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/torcontrol.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -4,10 +4,10 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <torcontrol.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n #include <netbase.h>\n #include <net.h>\n-#include <util.h>\n+#include <util/system.h>\n #include <crypto/hmac_sha256.h>\n \n #include <vector>"
      },
      {
        "sha": "8447352c54136896f670aaff51ce02d9c2f20b32",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -11,7 +11,7 @@\n #include <pow.h>\n #include <shutdown.h>\n #include <uint256.h>\n-#include <util.h>\n+#include <util/system.h>\n #include <ui_interface.h>\n \n #include <stdint.h>"
      },
      {
        "sha": "68f47d5cce39e349860e41882c48b873b7a9f89e",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -14,9 +14,9 @@\n #include <reverse_iterator.h>\n #include <streams.h>\n #include <timedata.h>\n-#include <util.h>\n-#include <utilmoneystr.h>\n-#include <utiltime.h>\n+#include <util/system.h>\n+#include <util/moneystr.h>\n+#include <util/time.h>\n \n CTxMemPoolEntry::CTxMemPoolEntry(const CTransactionRef& _tx, const CAmount& _nFee,\n                                  int64_t _nTime, unsigned int _entryHeight,\n@@ -498,7 +498,7 @@ void CTxMemPool::removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMem\n         const CTransaction& tx = it->GetTx();\n         LockPoints lp = it->GetLockPoints();\n         bool validLP =  TestLockPointValidity(&lp);\n-        if (!CheckFinalTx(tx, flags) || !CheckSequenceLocks(tx, flags, &lp, validLP)) {\n+        if (!CheckFinalTx(tx, flags) || !CheckSequenceLocks(*this, tx, flags, &lp, validLP)) {\n             // Note if CheckSequenceLocks fails the LockPoints may still be invalid\n             // So it's critical that we remove the tx and not depend on the LockPoints.\n             txToRemove.insert(it);"
      },
      {
        "sha": "fadb55472312bce42cbab840662e334cf600a251",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -15,6 +15,7 @@\n \n #include <amount.h>\n #include <coins.h>\n+#include <crypto/siphash.h>\n #include <indirectmap.h>\n #include <policy/feerate.h>\n #include <primitives/transaction.h>"
      },
      {
        "sha": "947d7e2308d11c74938e4545989a02f65869839f",
        "filename": "src/ui_interface.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/ui_interface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/ui_interface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ui_interface.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -3,7 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <ui_interface.h>\n-#include <util.h>\n+#include <util/system.h>\n \n #include <boost/signals2/last_value.hpp>\n #include <boost/signals2/signal.hpp>"
      },
      {
        "sha": "d9da66803604521a887b63a937ccc79c98ff26f7",
        "filename": "src/uint256.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/uint256.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/uint256.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/uint256.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -5,7 +5,7 @@\n \n #include <uint256.h>\n \n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n \n #include <stdio.h>\n #include <string.h>\n@@ -29,7 +29,7 @@ void base_blob<BITS>::SetHex(const char* psz)\n     memset(data, 0, sizeof(data));\n \n     // skip leading spaces\n-    while (isspace(*psz))\n+    while (IsSpace(*psz))\n         psz++;\n \n     // skip 0x"
      },
      {
        "sha": "3f50f4caad90e77cc3f362e65fc7bb399deeda1e",
        "filename": "src/undo.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/undo.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/undo.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/undo.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -11,6 +11,7 @@\n #include <consensus/consensus.h>\n #include <primitives/transaction.h>\n #include <serialize.h>\n+#include <version.h>\n \n /** Undo information for a CTxIn\n  *"
      },
      {
        "sha": "f87d0e04b32f21925fd2157ab509dfba715decf7",
        "filename": "src/util/bytevectorhash.cpp",
        "status": "added",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/util/bytevectorhash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/util/bytevectorhash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/bytevectorhash.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -0,0 +1,18 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/siphash.h>\n+#include <random.h>\n+#include <util/bytevectorhash.h>\n+\n+ByteVectorHash::ByteVectorHash()\n+{\n+    GetRandBytes(reinterpret_cast<unsigned char*>(&m_k0), sizeof(m_k0));\n+    GetRandBytes(reinterpret_cast<unsigned char*>(&m_k1), sizeof(m_k1));\n+}\n+\n+size_t ByteVectorHash::operator()(const std::vector<unsigned char>& input) const\n+{\n+    return CSipHasher(m_k0, m_k1).Write(input.data(), input.size()).Finalize();\n+}"
      },
      {
        "sha": "b88c17460b494e3d6a136ea61818b43e2bd1c0fe",
        "filename": "src/util/bytevectorhash.h",
        "status": "added",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/util/bytevectorhash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/util/bytevectorhash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/bytevectorhash.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -0,0 +1,26 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BYTEVECTORHASH_H\n+#define BITCOIN_UTIL_BYTEVECTORHASH_H\n+\n+#include <stdint.h>\n+#include <vector>\n+\n+/**\n+ * Implementation of Hash named requirement for types that internally store a byte array. This may\n+ * be used as the hash function in std::unordered_set or std::unordered_map over such types.\n+ * Internally, this uses a random instance of SipHash-2-4.\n+ */\n+class ByteVectorHash final\n+{\n+private:\n+    uint64_t m_k0, m_k1;\n+\n+public:\n+    ByteVectorHash();\n+    size_t operator()(const std::vector<unsigned char>& input) const;\n+};\n+\n+#endif // BITCOIN_UTIL_BYTEVECTORHASH_H"
      },
      {
        "sha": "15ecf8f80d4d980a232bc6afa6b3d32ed237743d",
        "filename": "src/util/memory.h",
        "status": "renamed",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/util/memory.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/util/memory.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/memory.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -3,8 +3,8 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#ifndef BITCOIN_UTILMEMORY_H\n-#define BITCOIN_UTILMEMORY_H\n+#ifndef BITCOIN_UTIL_MEMORY_H\n+#define BITCOIN_UTIL_MEMORY_H\n \n #include <memory>\n #include <utility>",
        "previous_filename": "src/utilmemory.h"
      },
      {
        "sha": "4c4de7b729207452e10408e39774c511204b1dec",
        "filename": "src/util/moneystr.cpp",
        "status": "renamed",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/util/moneystr.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/util/moneystr.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/moneystr.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -3,11 +3,11 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <utilmoneystr.h>\n+#include <util/moneystr.h>\n \n #include <primitives/transaction.h>\n #include <tinyformat.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n \n std::string FormatMoney(const CAmount& n)\n {\n@@ -41,7 +41,7 @@ bool ParseMoney(const char* pszIn, CAmount& nRet)\n     std::string strWhole;\n     int64_t nUnits = 0;\n     const char* p = pszIn;\n-    while (isspace(*p))\n+    while (IsSpace(*p))\n         p++;\n     for (; *p; p++)\n     {\n@@ -56,14 +56,14 @@ bool ParseMoney(const char* pszIn, CAmount& nRet)\n             }\n             break;\n         }\n-        if (isspace(*p))\n+        if (IsSpace(*p))\n             break;\n         if (!isdigit(*p))\n             return false;\n         strWhole.insert(strWhole.end(), *p);\n     }\n     for (; *p; p++)\n-        if (!isspace(*p))\n+        if (!IsSpace(*p))\n             return false;\n     if (strWhole.size() > 10) // guard against 63 bit overflow\n         return false;",
        "previous_filename": "src/utilmoneystr.cpp"
      },
      {
        "sha": "9133f46d5d9a1ad0453930fed09570f28d6de97c",
        "filename": "src/util/moneystr.h",
        "status": "renamed",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/util/moneystr.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/util/moneystr.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/moneystr.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -6,8 +6,8 @@\n /**\n  * Money parsing/formatting utilities.\n  */\n-#ifndef BITCOIN_UTILMONEYSTR_H\n-#define BITCOIN_UTILMONEYSTR_H\n+#ifndef BITCOIN_UTIL_MONEYSTR_H\n+#define BITCOIN_UTIL_MONEYSTR_H\n \n #include <stdint.h>\n #include <string>\n@@ -21,4 +21,4 @@ std::string FormatMoney(const CAmount& n);\n bool ParseMoney(const std::string& str, CAmount& nRet);\n bool ParseMoney(const char* pszIn, CAmount& nRet);\n \n-#endif // BITCOIN_UTILMONEYSTR_H\n+#endif // BITCOIN_UTIL_MONEYSTR_H",
        "previous_filename": "src/utilmoneystr.h"
      },
      {
        "sha": "2a2df43337ca51847a65f58b30b09b5e2b1c9be5",
        "filename": "src/util/strencodings.cpp",
        "status": "renamed",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/util/strencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/util/strencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/strencodings.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -3,7 +3,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n \n #include <tinyformat.h>\n \n@@ -20,6 +20,7 @@ static const std::string SAFE_CHARS[] =\n     CHARS_ALPHA_NUM + \" .,;-_/:?@()\", // SAFE_CHARS_DEFAULT\n     CHARS_ALPHA_NUM + \" .,;-_?@\", // SAFE_CHARS_UA_COMMENT\n     CHARS_ALPHA_NUM + \".-_\", // SAFE_CHARS_FILENAME\n+    CHARS_ALPHA_NUM + \"!*'();:@&=+$,/?#[]-_.~%\", // SAFE_CHARS_URI\n };\n \n std::string SanitizeString(const std::string& str, int rule)\n@@ -85,7 +86,7 @@ std::vector<unsigned char> ParseHex(const char* psz)\n     std::vector<unsigned char> vch;\n     while (true)\n     {\n-        while (isspace(*psz))\n+        while (IsSpace(*psz))\n             psz++;\n         signed char c = HexDigit(*psz++);\n         if (c == (signed char)-1)\n@@ -266,7 +267,7 @@ static bool ParsePrechecks(const std::string& str)\n {\n     if (str.empty()) // No empty string allowed\n         return false;\n-    if (str.size() >= 1 && (isspace(str[0]) || isspace(str[str.size()-1]))) // No padding allowed\n+    if (str.size() >= 1 && (IsSpace(str[0]) || IsSpace(str[str.size()-1]))) // No padding allowed\n         return false;\n     if (str.size() != strlen(str.c_str())) // No embedded NUL characters allowed\n         return false;",
        "previous_filename": "src/utilstrencodings.cpp"
      },
      {
        "sha": "87ccf40a1b6cfbffa18d2eaa4aeead7f02795e92",
        "filename": "src/util/strencodings.h",
        "status": "renamed",
        "additions": 19,
        "deletions": 3,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/util/strencodings.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/util/strencodings.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/strencodings.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -6,8 +6,8 @@\n /**\n  * Utilities for converting data from/to strings.\n  */\n-#ifndef BITCOIN_UTILSTRENCODINGS_H\n-#define BITCOIN_UTILSTRENCODINGS_H\n+#ifndef BITCOIN_UTIL_STRENCODINGS_H\n+#define BITCOIN_UTIL_STRENCODINGS_H\n \n #include <stdint.h>\n #include <string>\n@@ -25,6 +25,7 @@ enum SafeChars\n     SAFE_CHARS_DEFAULT, //!< The full set of allowed chars\n     SAFE_CHARS_UA_COMMENT, //!< BIP-0014 subset\n     SAFE_CHARS_FILENAME, //!< Chars allowed in filenames\n+    SAFE_CHARS_URI, //!< Chars allowed in URIs (RFC 3986)\n };\n \n /**\n@@ -71,6 +72,21 @@ constexpr bool IsDigit(char c)\n     return c >= '0' && c <= '9';\n }\n \n+/**\n+ * Tests if the given character is a whitespace character. The whitespace characters\n+ * are: space, form-feed ('\\f'), newline ('\\n'), carriage return ('\\r'), horizontal\n+ * tab ('\\t'), and vertical tab ('\\v').\n+ *\n+ * This function is locale independent. Under the C locale this function gives the\n+ * same result as std::isspace.\n+ *\n+ * @param[in] c     character to test\n+ * @return          true if the argument is a whitespace character; otherwise false\n+ */\n+constexpr inline bool IsSpace(char c) noexcept {\n+    return c == ' ' || c == '\\f' || c == '\\n' || c == '\\r' || c == '\\t' || c == '\\v';\n+}\n+\n /**\n  * Convert string to signed 32-bit integer with strict parse error feedback.\n  * @returns true if the entire string could be parsed as valid integer,\n@@ -230,4 +246,4 @@ constexpr unsigned char ToUpper(unsigned char c)\n  */\n std::string Capitalize(std::string str);\n \n-#endif // BITCOIN_UTILSTRENCODINGS_H\n+#endif // BITCOIN_UTIL_STRENCODINGS_H",
        "previous_filename": "src/utilstrencodings.h"
      },
      {
        "sha": "f6f36c22387836e15188b0a8cdf59600bb15f1e3",
        "filename": "src/util/system.cpp",
        "status": "renamed",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/util/system.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/util/system.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/system.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -3,12 +3,12 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <util.h>\n+#include <util/system.h>\n \n #include <chainparamsbase.h>\n #include <random.h>\n #include <serialize.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n \n #include <stdarg.h>\n \n@@ -826,8 +826,10 @@ static bool GetConfigOptions(std::istream& stream, std::string& error, std::vect\n     std::string::size_type pos;\n     int linenr = 1;\n     while (std::getline(stream, str)) {\n+        bool used_hash = false;\n         if ((pos = str.find('#')) != std::string::npos) {\n             str = str.substr(0, pos);\n+            used_hash = true;\n         }\n         const static std::string pattern = \" \\t\\r\\n\";\n         str = TrimString(str, pattern);\n@@ -840,6 +842,10 @@ static bool GetConfigOptions(std::istream& stream, std::string& error, std::vect\n             } else if ((pos = str.find('=')) != std::string::npos) {\n                 std::string name = prefix + TrimString(str.substr(0, pos), pattern);\n                 std::string value = TrimString(str.substr(pos + 1), pattern);\n+                if (used_hash && name == \"rpcpassword\") {\n+                    error = strprintf(\"parse error on line %i, using # in rpcpassword can be ambiguous and should be avoided\", linenr);\n+                    return false;\n+                }\n                 options.emplace_back(name, value);\n             } else {\n                 error = strprintf(\"parse error on line %i: %s\", linenr, str);",
        "previous_filename": "src/util.cpp"
      },
      {
        "sha": "5634b8dd61e1a654c6dc4b0577c60297e7e8feea",
        "filename": "src/util/system.h",
        "status": "renamed",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/util/system.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/util/system.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/system.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -7,8 +7,8 @@\n  * Server/client environment: argument handling, config file parsing,\n  * thread wrappers, startup time\n  */\n-#ifndef BITCOIN_UTIL_H\n-#define BITCOIN_UTIL_H\n+#ifndef BITCOIN_UTIL_SYSTEM_H\n+#define BITCOIN_UTIL_SYSTEM_H\n \n #if defined(HAVE_CONFIG_H)\n #include <config/bitcoin-config.h>\n@@ -19,8 +19,8 @@\n #include <logging.h>\n #include <sync.h>\n #include <tinyformat.h>\n-#include <utilmemory.h>\n-#include <utiltime.h>\n+#include <util/memory.h>\n+#include <util/time.h>\n \n #include <atomic>\n #include <exception>\n@@ -379,4 +379,4 @@ class WinCmdLineArgs\n \n } // namespace util\n \n-#endif // BITCOIN_UTIL_H\n+#endif // BITCOIN_UTIL_SYSTEM_H",
        "previous_filename": "src/util.h"
      },
      {
        "sha": "83a7937d8f61b918cff249153107ebf2990b2b65",
        "filename": "src/util/time.cpp",
        "status": "renamed",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/util/time.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/util/time.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/time.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -7,7 +7,7 @@\n #include <config/bitcoin-config.h>\n #endif\n \n-#include <utiltime.h>\n+#include <util/time.h>\n \n #include <atomic>\n #include <boost/date_time/posix_time/posix_time.hpp>",
        "previous_filename": "src/utiltime.cpp"
      },
      {
        "sha": "f2e27474342b0cf840f13839de0f041a5372e542",
        "filename": "src/util/time.h",
        "status": "renamed",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/util/time.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/util/time.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/time.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -3,8 +3,8 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#ifndef BITCOIN_UTILTIME_H\n-#define BITCOIN_UTILTIME_H\n+#ifndef BITCOIN_UTIL_TIME_H\n+#define BITCOIN_UTIL_TIME_H\n \n #include <stdint.h>\n #include <string>\n@@ -35,4 +35,4 @@ std::string FormatISO8601DateTime(int64_t nTime);\n std::string FormatISO8601Date(int64_t nTime);\n std::string FormatISO8601Time(int64_t nTime);\n \n-#endif // BITCOIN_UTILTIME_H\n+#endif // BITCOIN_UTIL_TIME_H",
        "previous_filename": "src/utiltime.h"
      },
      {
        "sha": "241957878ef240a4b34fde27203e61853cadef50",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 7,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -35,9 +35,9 @@\n #include <txmempool.h>\n #include <ui_interface.h>\n #include <undo.h>\n-#include <util.h>\n-#include <utilmoneystr.h>\n-#include <utilstrencodings.h>\n+#include <util/system.h>\n+#include <util/moneystr.h>\n+#include <util/strencodings.h>\n #include <validationinterface.h>\n #include <warnings.h>\n \n@@ -361,10 +361,10 @@ bool TestLockPointValidity(const LockPoints* lp)\n     return true;\n }\n \n-bool CheckSequenceLocks(const CTransaction &tx, int flags, LockPoints* lp, bool useExistingLockPoints)\n+bool CheckSequenceLocks(const CTxMemPool& pool, const CTransaction& tx, int flags, LockPoints* lp, bool useExistingLockPoints)\n {\n     AssertLockHeld(cs_main);\n-    AssertLockHeld(mempool.cs);\n+    AssertLockHeld(pool.cs);\n \n     CBlockIndex* tip = chainActive.Tip();\n     assert(tip != nullptr);\n@@ -387,7 +387,7 @@ bool CheckSequenceLocks(const CTransaction &tx, int flags, LockPoints* lp, bool\n     }\n     else {\n         // pcoinsTip contains the UTXO set for chainActive.Tip()\n-        CCoinsViewMemPool viewMemPool(pcoinsTip.get(), mempool);\n+        CCoinsViewMemPool viewMemPool(pcoinsTip.get(), pool);\n         std::vector<int> prevheights;\n         prevheights.resize(tx.vin.size());\n         for (size_t txinIndex = 0; txinIndex < tx.vin.size(); txinIndex++) {\n@@ -679,7 +679,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // be mined yet.\n         // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n         // CoinsViewCache instead of create its own\n-        if (!CheckSequenceLocks(tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n+        if (!CheckSequenceLocks(pool, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n             return state.DoS(0, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n \n         CAmount nFees = 0;\n@@ -4766,6 +4766,9 @@ bool DumpMempool()\n     std::map<uint256, CAmount> mapDeltas;\n     std::vector<TxMempoolInfo> vinfo;\n \n+    static Mutex dump_mutex;\n+    LOCK(dump_mutex);\n+\n     {\n         LOCK(mempool.cs);\n         for (const auto &i : mempool.mapDeltas) {"
      },
      {
        "sha": "3e98ebc8668e210c16c080ca3bf0acc54d845967",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -347,7 +347,7 @@ bool TestLockPointValidity(const LockPoints* lp) EXCLUSIVE_LOCKS_REQUIRED(cs_mai\n  *\n  * See consensus/consensus.h for flag definitions.\n  */\n-bool CheckSequenceLocks(const CTransaction &tx, int flags, LockPoints* lp = nullptr, bool useExistingLockPoints = false) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+bool CheckSequenceLocks(const CTxMemPool& pool, const CTransaction& tx, int flags, LockPoints* lp = nullptr, bool useExistingLockPoints = false) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n /**\n  * Closure representing one script verification"
      },
      {
        "sha": "214a9ffba9e1454ee0b3872d356462e41c46af08",
        "filename": "src/validationinterface.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/validationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/validationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -8,7 +8,7 @@\n #include <primitives/block.h>\n #include <scheduler.h>\n #include <txmempool.h>\n-#include <util.h>\n+#include <util/system.h>\n #include <validation.h>\n \n #include <list>"
      },
      {
        "sha": "87d2c4f06e42dff31839e77138c2a7fe42a24f2a",
        "filename": "src/wallet/coincontrol.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/coincontrol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/coincontrol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coincontrol.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -4,7 +4,7 @@\n \n #include <wallet/coincontrol.h>\n \n-#include <util.h>\n+#include <util/system.h>\n \n void CCoinControl::SetNull()\n {"
      },
      {
        "sha": "5e955b849560b9d0bc7b6c1ff4aceefb6eceb080",
        "filename": "src/wallet/coinselection.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/coinselection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/coinselection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -4,8 +4,8 @@\n \n #include <wallet/coinselection.h>\n \n-#include <util.h>\n-#include <utilmoneystr.h>\n+#include <util/system.h>\n+#include <util/moneystr.h>\n \n #include <boost/optional.hpp>\n "
      },
      {
        "sha": "f5ac6e98b2ffb10efd325c71c3a1c5ba683fc06b",
        "filename": "src/wallet/crypter.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/crypter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/crypter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/crypter.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -8,7 +8,7 @@\n #include <crypto/sha512.h>\n #include <script/script.h>\n #include <script/standard.h>\n-#include <util.h>\n+#include <util/system.h>\n \n #include <string>\n #include <vector>\n@@ -202,7 +202,7 @@ bool CCryptoKeyStore::Unlock(const CKeyingMaterial& vMasterKeyIn)\n         if (keyPass && keyFail)\n         {\n             LogPrintf(\"The wallet is probably corrupted: Some keys decrypt but not all.\\n\");\n-            assert(false);\n+            throw std::runtime_error(\"Error unlocking wallet: some keys decrypt but not all. Your wallet file may be corrupt.\");\n         }\n         if (keyFail || !keyPass)\n             return false;"
      },
      {
        "sha": "74787eb5d234bc5c22ecd0243c13ad436b5fbc22",
        "filename": "src/wallet/db.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 13,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -8,7 +8,7 @@\n #include <addrman.h>\n #include <hash.h>\n #include <protocol.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n #include <wallet/walletutil.h>\n \n #include <stdint.h>\n@@ -20,6 +20,7 @@\n #include <boost/thread.hpp>\n \n namespace {\n+\n //! Make sure database has a unique fileid within the environment. If it\n //! doesn't, throw an error. BDB caches do not work properly when more than one\n //! open database has the same fileid (values written to one database may show\n@@ -29,25 +30,19 @@ namespace {\n //! (https://docs.oracle.com/cd/E17275_01/html/programmer_reference/program_copy.html),\n //! so bitcoin should never create different databases with the same fileid, but\n //! this error can be triggered if users manually copy database files.\n-void CheckUniqueFileid(const BerkeleyEnvironment& env, const std::string& filename, Db& db)\n+void CheckUniqueFileid(const BerkeleyEnvironment& env, const std::string& filename, Db& db, WalletDatabaseFileId& fileid)\n {\n     if (env.IsMock()) return;\n \n-    u_int8_t fileid[DB_FILE_ID_LEN];\n-    int ret = db.get_mpf()->get_fileid(fileid);\n+    int ret = db.get_mpf()->get_fileid(fileid.value);\n     if (ret != 0) {\n         throw std::runtime_error(strprintf(\"BerkeleyBatch: Can't open database %s (get_fileid failed with %d)\", filename, ret));\n     }\n \n-    for (const auto& item : env.mapDb) {\n-        u_int8_t item_fileid[DB_FILE_ID_LEN];\n-        if (item.second && item.second->get_mpf()->get_fileid(item_fileid) == 0 &&\n-            memcmp(fileid, item_fileid, sizeof(fileid)) == 0) {\n-            const char* item_filename = nullptr;\n-            item.second->get_dbname(&item_filename, nullptr);\n+    for (const auto& item : env.m_fileids) {\n+        if (fileid == item.second && &fileid != &item.second) {\n             throw std::runtime_error(strprintf(\"BerkeleyBatch: Can't open database %s (duplicates fileid %s from %s)\", filename,\n-                HexStr(std::begin(item_fileid), std::end(item_fileid)),\n-                item_filename ? item_filename : \"(unknown database)\"));\n+                HexStr(std::begin(item.second.value), std::end(item.second.value)), item.first));\n         }\n     }\n }\n@@ -56,6 +51,11 @@ CCriticalSection cs_db;\n std::map<std::string, BerkeleyEnvironment> g_dbenvs GUARDED_BY(cs_db); //!< Map from directory name to open db environment.\n } // namespace\n \n+bool WalletDatabaseFileId::operator==(const WalletDatabaseFileId& rhs) const\n+{\n+    return memcmp(value, &rhs.value, sizeof(value)) == 0;\n+}\n+\n BerkeleyEnvironment* GetWalletEnv(const fs::path& wallet_path, std::string& database_filename)\n {\n     fs::path env_directory;\n@@ -504,7 +504,7 @@ BerkeleyBatch::BerkeleyBatch(BerkeleyDatabase& database, const char* pszMode, bo\n             // versions of BDB have an set_lk_exclusive method for this\n             // purpose, but the older version we use does not.)\n             for (const auto& env : g_dbenvs) {\n-                CheckUniqueFileid(env.second, strFilename, *pdb_temp);\n+                CheckUniqueFileid(env.second, strFilename, *pdb_temp, this->env->m_fileids[strFilename]);\n             }\n \n             pdb = pdb_temp.release();\n@@ -826,6 +826,13 @@ void BerkeleyDatabase::Flush(bool shutdown)\n             LOCK(cs_db);\n             g_dbenvs.erase(env->Directory().string());\n             env = nullptr;\n+        } else {\n+            // TODO: To avoid g_dbenvs.erase erasing the environment prematurely after the\n+            // first database shutdown when multiple databases are open in the same\n+            // environment, should replace raw database `env` pointers with shared or weak\n+            // pointers, or else separate the database and environment shutdowns so\n+            // environments can be shut down after databases.\n+            env->m_fileids.erase(strFile);\n         }\n     }\n }"
      },
      {
        "sha": "8f96483a18bb35d4ff009a949903c14edd6e8368",
        "filename": "src/wallet/db.h",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -11,20 +11,26 @@\n #include <serialize.h>\n #include <streams.h>\n #include <sync.h>\n-#include <util.h>\n+#include <util/system.h>\n #include <version.h>\n \n #include <atomic>\n #include <map>\n #include <memory>\n #include <string>\n+#include <unordered_map>\n #include <vector>\n \n #include <db_cxx.h>\n \n static const unsigned int DEFAULT_WALLET_DBLOGSIZE = 100;\n static const bool DEFAULT_WALLET_PRIVDB = true;\n \n+struct WalletDatabaseFileId {\n+    u_int8_t value[DB_FILE_ID_LEN];\n+    bool operator==(const WalletDatabaseFileId& rhs) const;\n+};\n+\n class BerkeleyEnvironment\n {\n private:\n@@ -38,6 +44,7 @@ class BerkeleyEnvironment\n     std::unique_ptr<DbEnv> dbenv;\n     std::map<std::string, int> mapFileUseCount;\n     std::map<std::string, Db*> mapDb;\n+    std::unordered_map<std::string, WalletDatabaseFileId> m_fileids;\n     std::condition_variable_any m_db_in_use;\n \n     BerkeleyEnvironment(const fs::path& env_directory);"
      },
      {
        "sha": "7a71aea7155995142c64f1bef671d8344c965fb1",
        "filename": "src/wallet/feebumper.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 11,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/feebumper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/feebumper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -3,6 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <consensus/validation.h>\n+#include <interfaces/chain.h>\n #include <wallet/coincontrol.h>\n #include <wallet/feebumper.h>\n #include <wallet/fees.h>\n@@ -12,13 +13,13 @@\n #include <policy/rbf.h>\n #include <validation.h> //for mempool access\n #include <txmempool.h>\n-#include <utilmoneystr.h>\n-#include <util.h>\n+#include <util/moneystr.h>\n+#include <util/system.h>\n #include <net.h>\n \n //! Check whether transaction has descendant in wallet or mempool, or has been\n //! mined, or conflicts with a mined transaction. Return a feebumper::Result.\n-static feebumper::Result PreconditionChecks(const CWallet* wallet, const CWalletTx& wtx, std::vector<std::string>& errors) EXCLUSIVE_LOCKS_REQUIRED(cs_main, wallet->cs_wallet)\n+static feebumper::Result PreconditionChecks(interfaces::Chain::Lock& locked_chain, const CWallet* wallet, const CWalletTx& wtx, std::vector<std::string>& errors) EXCLUSIVE_LOCKS_REQUIRED(wallet->cs_wallet)\n {\n     if (wallet->HasWalletSpend(wtx.GetHash())) {\n         errors.push_back(\"Transaction has descendants in the wallet\");\n@@ -34,7 +35,7 @@ static feebumper::Result PreconditionChecks(const CWallet* wallet, const CWallet\n         }\n     }\n \n-    if (wtx.GetDepthInMainChain() != 0) {\n+    if (wtx.GetDepthInMainChain(locked_chain) != 0) {\n         errors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n         return feebumper::Result::WALLET_ERROR;\n     }\n@@ -64,19 +65,21 @@ namespace feebumper {\n \n bool TransactionCanBeBumped(const CWallet* wallet, const uint256& txid)\n {\n-    LOCK2(cs_main, wallet->cs_wallet);\n+    auto locked_chain = wallet->chain().lock();\n+    LOCK(wallet->cs_wallet);\n     const CWalletTx* wtx = wallet->GetWalletTx(txid);\n     if (wtx == nullptr) return false;\n \n     std::vector<std::string> errors_dummy;\n-    feebumper::Result res = PreconditionChecks(wallet, *wtx, errors_dummy);\n+    feebumper::Result res = PreconditionChecks(*locked_chain, wallet, *wtx, errors_dummy);\n     return res == feebumper::Result::OK;\n }\n \n Result CreateTransaction(const CWallet* wallet, const uint256& txid, const CCoinControl& coin_control, CAmount total_fee, std::vector<std::string>& errors,\n                          CAmount& old_fee, CAmount& new_fee, CMutableTransaction& mtx)\n {\n-    LOCK2(cs_main, wallet->cs_wallet);\n+    auto locked_chain = wallet->chain().lock();\n+    LOCK(wallet->cs_wallet);\n     errors.clear();\n     auto it = wallet->mapWallet.find(txid);\n     if (it == wallet->mapWallet.end()) {\n@@ -85,7 +88,7 @@ Result CreateTransaction(const CWallet* wallet, const uint256& txid, const CCoin\n     }\n     const CWalletTx& wtx = it->second;\n \n-    Result result = PreconditionChecks(wallet, wtx, errors);\n+    Result result = PreconditionChecks(*locked_chain, wallet, wtx, errors);\n     if (result != Result::OK) {\n         return result;\n     }\n@@ -212,13 +215,15 @@ Result CreateTransaction(const CWallet* wallet, const uint256& txid, const CCoin\n }\n \n bool SignTransaction(CWallet* wallet, CMutableTransaction& mtx) {\n-    LOCK2(cs_main, wallet->cs_wallet);\n+    auto locked_chain = wallet->chain().lock();\n+    LOCK(wallet->cs_wallet);\n     return wallet->SignTransaction(mtx);\n }\n \n Result CommitTransaction(CWallet* wallet, const uint256& txid, CMutableTransaction&& mtx, std::vector<std::string>& errors, uint256& bumped_txid)\n {\n-    LOCK2(cs_main, wallet->cs_wallet);\n+    auto locked_chain = wallet->chain().lock();\n+    LOCK(wallet->cs_wallet);\n     if (!errors.empty()) {\n         return Result::MISC_ERROR;\n     }\n@@ -230,7 +235,7 @@ Result CommitTransaction(CWallet* wallet, const uint256& txid, CMutableTransacti\n     CWalletTx& oldWtx = it->second;\n \n     // make sure the transaction still has no descendants and hasn't been mined in the meantime\n-    Result result = PreconditionChecks(wallet, oldWtx, errors);\n+    Result result = PreconditionChecks(*locked_chain, wallet, oldWtx, errors);\n     if (result != Result::OK) {\n         return result;\n     }"
      },
      {
        "sha": "9e2984ff05394124058ea01f39183f3b19738db4",
        "filename": "src/wallet/fees.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/fees.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/fees.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/fees.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -7,7 +7,7 @@\n \n #include <policy/policy.h>\n #include <txmempool.h>\n-#include <util.h>\n+#include <util/system.h>\n #include <validation.h>\n #include <wallet/coincontrol.h>\n #include <wallet/wallet.h>"
      },
      {
        "sha": "14d811c6cd741b549d5b891c7a8517236979666d",
        "filename": "src/wallet/init.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 53,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/init.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -5,11 +5,12 @@\n \n #include <chainparams.h>\n #include <init.h>\n+#include <interfaces/chain.h>\n #include <net.h>\n #include <scheduler.h>\n #include <outputtype.h>\n-#include <util.h>\n-#include <utilmoneystr.h>\n+#include <util/system.h>\n+#include <util/moneystr.h>\n #include <validation.h>\n #include <walletinitinterface.h>\n #include <wallet/rpcwallet.h>\n@@ -28,36 +29,16 @@ class WalletInit : public WalletInitInterface {\n     //! Wallets parameter interaction\n     bool ParameterInteraction() const override;\n \n-    //! Register wallet RPCs.\n-    void RegisterRPC(CRPCTable &tableRPC) const override;\n-\n-    //! Responsible for reading and validating the -wallet arguments and verifying the wallet database.\n-    //  This function will perform salvage on the wallet if requested, as long as only one wallet is\n-    //  being loaded (WalletParameterInteraction forbids -salvagewallet, -zapwallettxes or -upgradewallet with multiwallet).\n-    bool Verify() const override;\n-\n-    //! Load wallet databases.\n-    bool Open() const override;\n-\n-    //! Complete startup of wallets.\n-    void Start(CScheduler& scheduler) const override;\n-\n-    //! Flush all wallets in preparation for shutdown.\n-    void Flush() const override;\n-\n-    //! Stop all wallets. Wallets will be flushed first.\n-    void Stop() const override;\n-\n-    //! Close all wallets.\n-    void Close() const override;\n+    //! Add wallets that should be opened to list of init interfaces.\n+    void Construct(InitInterfaces& interfaces) const override;\n };\n \n const WalletInitInterface& g_wallet_init_interface = WalletInit();\n \n void WalletInit::AddWalletOptions() const\n {\n     gArgs.AddArg(\"-addresstype\", strprintf(\"What type of addresses to use (\\\"legacy\\\", \\\"p2sh-segwit\\\", or \\\"bech32\\\", default: \\\"%s\\\")\", FormatOutputType(DEFAULT_ADDRESS_TYPE)), false, OptionsCategory::WALLET);\n-    gArgs.AddArg(\"-avoidpartialspends\", strprintf(_(\"Group outputs by address, selecting all or none, instead of selecting on a per-output basis. Privacy is improved as an address is only used once (unless someone sends to it after spending from it), but may result in slightly higher fees as suboptimal coin selection may result due to the added limitation (default: %u)\"), DEFAULT_AVOIDPARTIALSPENDS), false, OptionsCategory::WALLET);\n+    gArgs.AddArg(\"-avoidpartialspends\", strprintf(\"Group outputs by address, selecting all or none, instead of selecting on a per-output basis. Privacy is improved as an address is only used once (unless someone sends to it after spending from it), but may result in slightly higher fees as suboptimal coin selection may result due to the added limitation (default: %u)\", DEFAULT_AVOIDPARTIALSPENDS), false, OptionsCategory::WALLET);\n     gArgs.AddArg(\"-changetype\", \"What type of change to use (\\\"legacy\\\", \\\"p2sh-segwit\\\", or \\\"bech32\\\"). Default is same as -addresstype, except when -addresstype=p2sh-segwit a native segwit output is used when sending to a native segwit address)\", false, OptionsCategory::WALLET);\n     gArgs.AddArg(\"-disablewallet\", \"Do not load the wallet and disable wallet RPC calls\", false, OptionsCategory::WALLET);\n     gArgs.AddArg(\"-discardfee=<amt>\", strprintf(\"The fee rate (in %s/kB) that indicates your tolerance for discarding change by adding it to the fee (default: %s). \"\n@@ -99,7 +80,6 @@ bool WalletInit::ParameterInteraction() const\n         return true;\n     }\n \n-    gArgs.SoftSetArg(\"-wallet\", \"\");\n     const bool is_multiwallet = gArgs.GetArgs(\"-wallet\").size() > 1;\n \n     if (gArgs.GetBoolArg(\"-blocksonly\", DEFAULT_BLOCKSONLY) && gArgs.SoftSetBoolArg(\"-walletbroadcast\", false)) {\n@@ -165,21 +145,8 @@ bool WalletInit::ParameterInteraction() const\n     return true;\n }\n \n-void WalletInit::RegisterRPC(CRPCTable &t) const\n-{\n-    if (gArgs.GetBoolArg(\"-disablewallet\", DEFAULT_DISABLE_WALLET)) {\n-        return;\n-    }\n-\n-    RegisterWalletRPCCommands(t);\n-}\n-\n-bool WalletInit::Verify() const\n+bool VerifyWallets(interfaces::Chain& chain, const std::vector<std::string>& wallet_files)\n {\n-    if (gArgs.GetBoolArg(\"-disablewallet\", DEFAULT_DISABLE_WALLET)) {\n-        return true;\n-    }\n-\n     if (gArgs.IsArgSet(\"-walletdir\")) {\n         fs::path wallet_dir = gArgs.GetArg(\"-walletdir\", \"\");\n         boost::system::error_code error;\n@@ -200,8 +167,6 @@ bool WalletInit::Verify() const\n \n     uiInterface.InitMessage(_(\"Verifying wallet(s)...\"));\n \n-    std::vector<std::string> wallet_files = gArgs.GetArgs(\"-wallet\");\n-\n     // Parameter interaction code should have thrown an error if -salvagewallet\n     // was enabled with more than wallet file, so the wallet_files size check\n     // here should have no effect.\n@@ -211,15 +176,15 @@ bool WalletInit::Verify() const\n     std::set<fs::path> wallet_paths;\n \n     for (const auto& wallet_file : wallet_files) {\n-        fs::path wallet_path = fs::absolute(wallet_file, GetWalletDir());\n+        WalletLocation location(wallet_file);\n \n-        if (!wallet_paths.insert(wallet_path).second) {\n+        if (!wallet_paths.insert(location.GetPath()).second) {\n             return InitError(strprintf(_(\"Error loading wallet %s. Duplicate -wallet filename specified.\"), wallet_file));\n         }\n \n         std::string error_string;\n         std::string warning_string;\n-        bool verify_success = CWallet::Verify(wallet_file, salvage_wallet, error_string, warning_string);\n+        bool verify_success = CWallet::Verify(chain, location, salvage_wallet, error_string, warning_string);\n         if (!error_string.empty()) InitError(error_string);\n         if (!warning_string.empty()) InitWarning(warning_string);\n         if (!verify_success) return false;\n@@ -228,15 +193,20 @@ bool WalletInit::Verify() const\n     return true;\n }\n \n-bool WalletInit::Open() const\n+void WalletInit::Construct(InitInterfaces& interfaces) const\n {\n     if (gArgs.GetBoolArg(\"-disablewallet\", DEFAULT_DISABLE_WALLET)) {\n         LogPrintf(\"Wallet disabled!\\n\");\n-        return true;\n+        return;\n     }\n+    gArgs.SoftSetArg(\"-wallet\", \"\");\n+    interfaces.chain_clients.emplace_back(interfaces::MakeWalletClient(*interfaces.chain, gArgs.GetArgs(\"-wallet\")));\n+}\n \n-    for (const std::string& walletFile : gArgs.GetArgs(\"-wallet\")) {\n-        std::shared_ptr<CWallet> pwallet = CWallet::CreateWalletFromFile(walletFile, fs::absolute(walletFile, GetWalletDir()));\n+bool LoadWallets(interfaces::Chain& chain, const std::vector<std::string>& wallet_files)\n+{\n+    for (const std::string& walletFile : wallet_files) {\n+        std::shared_ptr<CWallet> pwallet = CWallet::CreateWalletFromFile(chain, WalletLocation(walletFile));\n         if (!pwallet) {\n             return false;\n         }\n@@ -246,7 +216,7 @@ bool WalletInit::Open() const\n     return true;\n }\n \n-void WalletInit::Start(CScheduler& scheduler) const\n+void StartWallets(CScheduler& scheduler)\n {\n     for (const std::shared_ptr<CWallet>& pwallet : GetWallets()) {\n         pwallet->postInitProcess();\n@@ -256,21 +226,21 @@ void WalletInit::Start(CScheduler& scheduler) const\n     scheduler.scheduleEvery(MaybeCompactWalletDB, 500);\n }\n \n-void WalletInit::Flush() const\n+void FlushWallets()\n {\n     for (const std::shared_ptr<CWallet>& pwallet : GetWallets()) {\n         pwallet->Flush(false);\n     }\n }\n \n-void WalletInit::Stop() const\n+void StopWallets()\n {\n     for (const std::shared_ptr<CWallet>& pwallet : GetWallets()) {\n         pwallet->Flush(true);\n     }\n }\n \n-void WalletInit::Close() const\n+void UnloadWallets()\n {\n     for (const std::shared_ptr<CWallet>& pwallet : GetWallets()) {\n         RemoveWallet(pwallet);"
      },
      {
        "sha": "6269bc9d3cefa5824599c15a384a1032359bafef",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 158,
        "deletions": 174,
        "changes": 332,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -3,17 +3,19 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <chain.h>\n+#include <core_io.h>\n+#include <interfaces/chain.h>\n #include <key_io.h>\n+#include <merkleblock.h>\n #include <rpc/server.h>\n-#include <validation.h>\n+#include <rpc/util.h>\n #include <script/script.h>\n #include <script/standard.h>\n #include <sync.h>\n-#include <util.h>\n-#include <utiltime.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+#include <validation.h>\n #include <wallet/wallet.h>\n-#include <merkleblock.h>\n-#include <core_io.h>\n \n #include <wallet/rpcwallet.h>\n \n@@ -112,7 +114,7 @@ UniValue importprivkey(const JSONRPCRequest& request)\n             \"Hint: use importmulti to import more than one private key.\\n\"\n             \"\\nArguments:\\n\"\n             \"1. \\\"privkey\\\"          (string, required) The private key (see dumpprivkey)\\n\"\n-            \"2. \\\"label\\\"            (string, optional, default=\\\"\\\") An optional label\\n\"\n+            \"2. \\\"label\\\"            (string, optional, default=current label if address exists, otherwise \\\"\\\") An optional label\\n\"\n             \"3. rescan               (boolean, optional, default=true) Rescan the wallet for transactions\\n\"\n             \"\\nNote: This call can take over an hour to complete if rescan is true, during that time, other rpc calls\\n\"\n             \"may report that the imported key exists but related transactions are still missing, leading to temporarily incorrect/bogus balances and unspent outputs until rescan completes.\\n\"\n@@ -133,7 +135,8 @@ UniValue importprivkey(const JSONRPCRequest& request)\n     WalletRescanReserver reserver(pwallet);\n     bool fRescan = true;\n     {\n-        LOCK2(cs_main, pwallet->cs_wallet);\n+        auto locked_chain = pwallet->chain().lock();\n+        LOCK(pwallet->cs_wallet);\n \n         EnsureWalletIsUnlocked(pwallet);\n \n@@ -161,9 +164,14 @@ UniValue importprivkey(const JSONRPCRequest& request)\n         CKeyID vchAddress = pubkey.GetID();\n         {\n             pwallet->MarkDirty();\n-            // We don't know which corresponding address will be used; label them all\n+\n+            // We don't know which corresponding address will be used;\n+            // label all new addresses, and label existing addresses if a\n+            // label was passed.\n             for (const auto& dest : GetAllDestinationsForKey(pubkey)) {\n-                pwallet->SetAddressBook(dest, strLabel, \"receive\");\n+                if (!request.params[1].isNull() || pwallet->mapAddressBook.count(dest) == 0) {\n+                    pwallet->SetAddressBook(dest, strLabel, \"receive\");\n+                }\n             }\n \n             // Don't throw error in case a key is already there\n@@ -305,7 +313,8 @@ UniValue importaddress(const JSONRPCRequest& request)\n         fP2SH = request.params[3].get_bool();\n \n     {\n-        LOCK2(cs_main, pwallet->cs_wallet);\n+        auto locked_chain = pwallet->chain().lock();\n+        LOCK(pwallet->cs_wallet);\n \n         CTxDestination dest = DecodeDestination(request.params[0].get_str());\n         if (IsValidDestination(dest)) {\n@@ -339,7 +348,7 @@ UniValue importprunedfunds(const JSONRPCRequest& request)\n \n     if (request.fHelp || request.params.size() != 2)\n         throw std::runtime_error(\n-            \"importprunedfunds\\n\"\n+            \"importprunedfunds \\\"rawtransaction\\\" \\\"txoutproof\\\"\\n\"\n             \"\\nImports funds without rescan. Corresponding address or script must previously be included in wallet. Aimed towards pruned wallets. The end-user is responsible to import additional transactions that subsequently spend the imported outputs or rescan after the point in the blockchain the transaction is included.\\n\"\n             \"\\nArguments:\\n\"\n             \"1. \\\"rawtransaction\\\" (string, required) A raw transaction in hex funding an already-existing address in wallet\\n\"\n@@ -362,7 +371,7 @@ UniValue importprunedfunds(const JSONRPCRequest& request)\n     unsigned int txnIndex = 0;\n     if (merkleBlock.txn.ExtractMatches(vMatch, vIndex) == merkleBlock.header.hashMerkleRoot) {\n \n-        LOCK(cs_main);\n+        auto locked_chain = pwallet->chain().lock();\n         const CBlockIndex* pindex = LookupBlockIndex(merkleBlock.header.GetHash());\n         if (!pindex || !chainActive.Contains(pindex)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found in chain\");\n@@ -382,7 +391,8 @@ UniValue importprunedfunds(const JSONRPCRequest& request)\n     wtx.nIndex = txnIndex;\n     wtx.hashBlock = merkleBlock.header.GetHash();\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n     if (pwallet->IsMine(*wtx.tx)) {\n         pwallet->AddToWallet(wtx, false);\n@@ -412,7 +422,8 @@ UniValue removeprunedfunds(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"removeprunedfunds\", \"\\\"a8d0c0184dde994a09ec054286f1ce581bebf46446a512166eae7628734ea0a5\\\"\")\n         );\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n     uint256 hash(ParseHashV(request.params[0], \"txid\"));\n     std::vector<uint256> vHash;\n@@ -483,7 +494,8 @@ UniValue importpubkey(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n \n     {\n-        LOCK2(cs_main, pwallet->cs_wallet);\n+        auto locked_chain = pwallet->chain().lock();\n+        LOCK(pwallet->cs_wallet);\n \n         for (const auto& dest : GetAllDestinationsForKey(pubKey)) {\n             ImportAddress(pwallet, dest, strLabel);\n@@ -535,7 +547,8 @@ UniValue importwallet(const JSONRPCRequest& request)\n     int64_t nTimeBegin = 0;\n     bool fGood = true;\n     {\n-        LOCK2(cs_main, pwallet->cs_wallet);\n+        auto locked_chain = pwallet->chain().lock();\n+        LOCK(pwallet->cs_wallet);\n \n         EnsureWalletIsUnlocked(pwallet);\n \n@@ -653,7 +666,8 @@ UniValue dumpprivkey(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"dumpprivkey\", \"\\\"myaddress\\\"\")\n         );\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n     EnsureWalletIsUnlocked(pwallet);\n \n@@ -700,7 +714,8 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"dumpwallet\", \"\\\"test\\\"\")\n         );\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n     EnsureWalletIsUnlocked(pwallet);\n \n@@ -723,7 +738,7 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n \n     std::map<CTxDestination, int64_t> mapKeyBirth;\n     const std::map<CKeyID, int64_t>& mapKeyPool = pwallet->GetAllReserveKeys();\n-    pwallet->GetKeyBirthTimes(mapKeyBirth);\n+    pwallet->GetKeyBirthTimes(*locked_chain, mapKeyBirth);\n \n     std::set<CScriptID> scripts = pwallet->GetCScripts();\n     // TODO: include scripts in GetKeyBirthTimes() output instead of separate\n@@ -808,29 +823,24 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n     try {\n-        bool success = false;\n-\n-        // Required fields.\n+        // First ensure scriptPubKey has either a script or JSON with \"address\" string\n         const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+        if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n         }\n+        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n \n         // Optional fields.\n         const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+        const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n         const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n         const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n         const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n         const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n \n-        // Parse the output.\n+        // Generate the script and destination for the scriptPubKey provided\n         CScript script;\n         CTxDestination dest;\n \n@@ -854,35 +864,38 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n \n         // Watchonly and private keys\n         if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n         }\n \n-        // Internal + Label\n+        // Internal addresses should not have a label\n         if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n-        }\n-\n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n         }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n         }\n \n-        // Process. //\n+        CScript scriptpubkey_script = script;\n+        CTxDestination scriptpubkey_dest = dest;\n+        bool allow_p2wpkh = true;\n \n         // P2SH\n-        if (isP2SH) {\n+        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+            // Check the redeemScript is valid\n+            if (!IsHex(strRedeemScript)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n+            }\n+\n             // Import redeem script.\n             std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n             CScript redeemScript = CScript(vData.begin(), vData.end());\n+            CScriptID redeem_id(redeemScript);\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n+            // Check that the redeemScript and scriptPubKey match\n+            if (GetScriptForDestination(redeem_id) != script) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n             }\n \n             pwallet->MarkDirty();\n@@ -891,103 +904,83 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            CScriptID redeem_id(redeemScript);\n             if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n+            script = redeemScript;\n+            ExtractDestination(script, dest);\n+        }\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        // (P2SH-)P2WSH\n+        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n \n-            pwallet->MarkDirty();\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            // Check that the witnessScript and scriptPubKey match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n+            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n-\n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n-\n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n-\n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+            }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n+            script = witness_script;\n+            ExtractDestination(script, dest);\n+            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+        // (P2SH-)P2PK/P2PKH/P2WPKH\n+        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n             }\n-\n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n+            if (keys.size() > 1 || pubKeys.size() > 1) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+            }\n+            CPubKey pubkey;\n+            if (keys.size()) {\n+                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+            }\n+            if (pubKeys.size()) {\n                 const std::string& strPubKey = pubKeys[0].get_str();\n-\n                 if (!IsHex(strPubKey)) {\n                     throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n                 }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+                CPubKey pubkey_temp(vData.begin(), vData.end());\n+                if (pubkey.size() && pubkey_temp != pubkey) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n                 }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                pubkey = pubkey_temp;\n+            }\n+            if (pubkey.size() > 0) {\n+                if (!pubkey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n                 }\n \n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n+                // Check the key corresponds to the destination given\n+                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n                 }\n \n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+                // This is necessary to force the wallet to import the pubKey\n+                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n                 if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n                     throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n@@ -998,73 +991,62 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n                 if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n                     throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n                 }\n-\n-                success = true;\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n-\n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n-\n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n-\n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n+        // Import the address\n+        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        pwallet->MarkDirty();\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n+        }\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // if not internal add to address book or update label\n+        if (!internal) {\n+            assert(IsValidDestination(scriptpubkey_dest));\n+            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n+        }\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        // Import private keys.\n+        for (size_t i = 0; i < keys.size(); i++) {\n+            const std::string& strPrivkey = keys[i].get_str();\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+            // Checks.\n+            CKey key = DecodeSecret(strPrivkey);\n \n-                success = true;\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            CPubKey pubKey = key.GetPubKey();\n+            assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->MarkDirty();\n+            CKeyID vchAddress = pubKey.GetID();\n+            pwallet->MarkDirty();\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            if (pwallet->HaveKey(vchAddress)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+            }\n \n-                // add to address book or update label\n-                if (IsValidDestination(dest)) {\n-                    pwallet->SetAddressBook(dest, label, \"receive\");\n-                }\n+            pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n+            if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n             }\n+\n+            pwallet->UpdateTimeFirstKey(timestamp);\n         }\n \n         UniValue result = UniValue(UniValue::VOBJ);\n-        result.pushKV(\"success\", UniValue(success));\n+        result.pushKV(\"success\", UniValue(true));\n         return result;\n     } catch (const UniValue& e) {\n         UniValue result = UniValue(UniValue::VOBJ);\n@@ -1104,8 +1086,8 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n     // clang-format off\n     if (mainRequest.fHelp || mainRequest.params.size() < 1 || mainRequest.params.size() > 2)\n         throw std::runtime_error(\n-            \"importmulti \\\"requests\\\" ( \\\"options\\\" )\\n\\n\"\n-            \"Import addresses/scripts (with private or public keys, redeem script (P2SH)), rescanning all addresses in one-shot-only (rescan can be disabled via options). Requires a new wallet backup.\\n\\n\"\n+            \"importmulti \\\"requests\\\" ( \\\"options\\\" )\\n\"\n+            \"\\nImport addresses/scripts (with private or public keys, redeem script (P2SH)), rescanning all addresses in one-shot-only (rescan can be disabled via options). Requires a new wallet backup.\\n\\n\"\n             \"Arguments:\\n\"\n             \"1. requests     (array, required) Data to be imported\\n\"\n             \"  [     (array of json objects)\\n\"\n@@ -1117,10 +1099,11 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n             \"                                                              \\\"now\\\" can be specified to bypass scanning, for keys which are known to never have been used, and\\n\"\n             \"                                                              0 can be specified to scan the entire blockchain. Blocks up to 2 hours before the earliest key\\n\"\n             \"                                                              creation time of all keys being imported by the importmulti call will be scanned.\\n\"\n-            \"      \\\"redeemscript\\\": \\\"<script>\\\"                            , (string, optional) Allowed only if the scriptPubKey is a P2SH address or a P2SH scriptPubKey\\n\"\n+            \"      \\\"redeemscript\\\": \\\"<script>\\\"                            , (string, optional) Allowed only if the scriptPubKey is a P2SH or P2SH-P2WSH address/scriptPubKey\\n\"\n+            \"      \\\"witnessscript\\\": \\\"<script>\\\"                           , (string, optional) Allowed only if the scriptPubKey is a P2SH-P2WSH or P2WSH address/scriptPubKey\\n\"\n             \"      \\\"pubkeys\\\": [\\\"<pubKey>\\\", ... ]                         , (array, optional) Array of strings giving pubkeys that must occur in the output or redeemscript\\n\"\n             \"      \\\"keys\\\": [\\\"<key>\\\", ... ]                               , (array, optional) Array of strings giving private keys whose corresponding public keys must occur in the output or redeemscript\\n\"\n-            \"      \\\"internal\\\": <true>                                    , (boolean, optional, default: false) Stating whether matching outputs should be treated as not incoming payments\\n\"\n+            \"      \\\"internal\\\": <true>                                    , (boolean, optional, default: false) Stating whether matching outputs should be treated as not incoming payments aka change\\n\"\n             \"      \\\"watchonly\\\": <true>                                   , (boolean, optional, default: false) Stating whether matching outputs should be considered watched even when they're not spendable, only allowed if keys are empty\\n\"\n             \"      \\\"label\\\": <label>                                      , (string, optional, default: '') Label to assign to the address, only allowed with internal=false\\n\"\n             \"    }\\n\"\n@@ -1167,7 +1150,8 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n     int64_t nLowestTimestamp = 0;\n     UniValue response(UniValue::VARR);\n     {\n-        LOCK2(cs_main, pwallet->cs_wallet);\n+        auto locked_chain = pwallet->chain().lock();\n+        LOCK(pwallet->cs_wallet);\n         EnsureWalletIsUnlocked(pwallet);\n \n         // Verify all timestamps are present before importing any keys."
      },
      {
        "sha": "0e2f8864b194d990243676cd4751d89c5c7e1044",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 288,
        "deletions": 267,
        "changes": 555,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -8,6 +8,8 @@\n #include <consensus/validation.h>\n #include <core_io.h>\n #include <httpserver.h>\n+#include <init.h>\n+#include <interfaces/chain.h>\n #include <validation.h>\n #include <key_io.h>\n #include <net.h>\n@@ -23,8 +25,8 @@\n #include <script/sign.h>\n #include <shutdown.h>\n #include <timedata.h>\n-#include <util.h>\n-#include <utilmoneystr.h>\n+#include <util/system.h>\n+#include <util/moneystr.h>\n #include <wallet/coincontrol.h>\n #include <wallet/feebumper.h>\n #include <wallet/rpcwallet.h>\n@@ -89,9 +91,9 @@ void EnsureWalletIsUnlocked(CWallet * const pwallet)\n     }\n }\n \n-static void WalletTxToJSON(const CWalletTx& wtx, UniValue& entry) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+static void WalletTxToJSON(interfaces::Chain& chain, interfaces::Chain::Lock& locked_chain, const CWalletTx& wtx, UniValue& entry)\n {\n-    int confirms = wtx.GetDepthInMainChain();\n+    int confirms = wtx.GetDepthInMainChain(locked_chain);\n     entry.pushKV(\"confirmations\", confirms);\n     if (wtx.IsCoinBase())\n         entry.pushKV(\"generated\", true);\n@@ -101,7 +103,7 @@ static void WalletTxToJSON(const CWalletTx& wtx, UniValue& entry) EXCLUSIVE_LOCK\n         entry.pushKV(\"blockindex\", wtx.nIndex);\n         entry.pushKV(\"blocktime\", LookupBlockIndex(wtx.hashBlock)->GetBlockTime());\n     } else {\n-        entry.pushKV(\"trusted\", wtx.IsTrusted());\n+        entry.pushKV(\"trusted\", wtx.IsTrusted(locked_chain));\n     }\n     uint256 hash = wtx.GetHash();\n     entry.pushKV(\"txid\", hash.GetHex());\n@@ -290,7 +292,7 @@ static UniValue setlabel(const JSONRPCRequest& request)\n }\n \n \n-static CTransactionRef SendMoney(CWallet * const pwallet, const CTxDestination &address, CAmount nValue, bool fSubtractFeeFromAmount, const CCoinControl& coin_control, mapValue_t mapValue)\n+static CTransactionRef SendMoney(interfaces::Chain::Lock& locked_chain, CWallet * const pwallet, const CTxDestination &address, CAmount nValue, bool fSubtractFeeFromAmount, const CCoinControl& coin_control, mapValue_t mapValue)\n {\n     CAmount curBalance = pwallet->GetBalance();\n \n@@ -317,7 +319,7 @@ static CTransactionRef SendMoney(CWallet * const pwallet, const CTxDestination &\n     CRecipient recipient = {scriptPubKey, nValue, fSubtractFeeFromAmount};\n     vecSend.push_back(recipient);\n     CTransactionRef tx;\n-    if (!pwallet->CreateTransaction(vecSend, tx, reservekey, nFeeRequired, nChangePosRet, strError, coin_control)) {\n+    if (!pwallet->CreateTransaction(locked_chain, vecSend, tx, reservekey, nFeeRequired, nChangePosRet, strError, coin_control)) {\n         if (!fSubtractFeeFromAmount && nValue + nFeeRequired > curBalance)\n             strError = strprintf(\"Error: This transaction requires a transaction fee of at least %s\", FormatMoney(nFeeRequired));\n         throw JSONRPCError(RPC_WALLET_ERROR, strError);\n@@ -373,7 +375,8 @@ static UniValue sendtoaddress(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n     CTxDestination dest = DecodeDestination(request.params[0].get_str());\n     if (!IsValidDestination(dest)) {\n@@ -415,7 +418,7 @@ static UniValue sendtoaddress(const JSONRPCRequest& request)\n \n     EnsureWalletIsUnlocked(pwallet);\n \n-    CTransactionRef tx = SendMoney(pwallet, dest, nAmount, fSubtractFeeFromAmount, coin_control, std::move(mapValue));\n+    CTransactionRef tx = SendMoney(*locked_chain, pwallet, dest, nAmount, fSubtractFeeFromAmount, coin_control, std::move(mapValue));\n     return tx->GetHash().GetHex();\n }\n \n@@ -455,10 +458,11 @@ static UniValue listaddressgroupings(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n     UniValue jsonGroupings(UniValue::VARR);\n-    std::map<CTxDestination, CAmount> balances = pwallet->GetAddressBalances();\n+    std::map<CTxDestination, CAmount> balances = pwallet->GetAddressBalances(*locked_chain);\n     for (const std::set<CTxDestination>& grouping : pwallet->GetAddressGroupings()) {\n         UniValue jsonGrouping(UniValue::VARR);\n         for (const CTxDestination& address : grouping)\n@@ -508,7 +512,8 @@ static UniValue signmessage(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"signmessage\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\\\", \\\"my message\\\"\")\n         );\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n     EnsureWalletIsUnlocked(pwallet);\n \n@@ -574,7 +579,9 @@ static UniValue getreceivedbyaddress(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    LockAnnotation lock(::cs_main); // Temporary, for CheckFinalTx below. Removed in upcoming commit.\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n     // Bitcoin address\n     CTxDestination dest = DecodeDestination(request.params[0].get_str());\n@@ -600,7 +607,7 @@ static UniValue getreceivedbyaddress(const JSONRPCRequest& request)\n \n         for (const CTxOut& txout : wtx.tx->vout)\n             if (txout.scriptPubKey == scriptPubKey)\n-                if (wtx.GetDepthInMainChain() >= nMinDepth)\n+                if (wtx.GetDepthInMainChain(*locked_chain) >= nMinDepth)\n                     nAmount += txout.nValue;\n     }\n \n@@ -641,7 +648,9 @@ static UniValue getreceivedbylabel(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    LockAnnotation lock(::cs_main); // Temporary, for CheckFinalTx below. Removed in upcoming commit.\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n     // Minimum confirmations\n     int nMinDepth = 1;\n@@ -663,7 +672,7 @@ static UniValue getreceivedbylabel(const JSONRPCRequest& request)\n         {\n             CTxDestination address;\n             if (ExtractDestination(txout.scriptPubKey, address) && IsMine(*pwallet, address) && setAddress.count(address)) {\n-                if (wtx.GetDepthInMainChain() >= nMinDepth)\n+                if (wtx.GetDepthInMainChain(*locked_chain) >= nMinDepth)\n                     nAmount += txout.nValue;\n             }\n         }\n@@ -684,7 +693,7 @@ static UniValue getbalance(const JSONRPCRequest& request)\n \n     if (request.fHelp || (request.params.size() > 3 ))\n         throw std::runtime_error(\n-            \"getbalance ( \\\"(dummy)\\\" minconf include_watchonly )\\n\"\n+            \"getbalance ( \\\"dummy\\\" minconf include_watchonly )\\n\"\n             \"\\nReturns the total available balance.\\n\"\n             \"The available balance is what the wallet considers currently spendable, and is\\n\"\n             \"thus affected by options which limit spendability such as -spendzeroconfchange.\\n\"\n@@ -707,7 +716,8 @@ static UniValue getbalance(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n     const UniValue& dummy_value = request.params[0];\n     if (!dummy_value.isNull() && dummy_value.get_str() != \"*\") {\n@@ -745,7 +755,8 @@ static UniValue getunconfirmedbalance(const JSONRPCRequest &request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n     return ValueFromAmount(pwallet->GetUnconfirmedBalance());\n }\n@@ -806,7 +817,8 @@ static UniValue sendmany(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n     if (pwallet->GetBroadcastTransactions() && !g_connman) {\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n@@ -892,7 +904,7 @@ static UniValue sendmany(const JSONRPCRequest& request)\n     int nChangePosRet = -1;\n     std::string strFailReason;\n     CTransactionRef tx;\n-    bool fCreated = pwallet->CreateTransaction(vecSend, tx, keyChange, nFeeRequired, nChangePosRet, strFailReason, coin_control);\n+    bool fCreated = pwallet->CreateTransaction(*locked_chain, vecSend, tx, keyChange, nFeeRequired, nChangePosRet, strFailReason, coin_control);\n     if (!fCreated)\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, strFailReason);\n     CValidationState state;\n@@ -945,7 +957,8 @@ static UniValue addmultisigaddress(const JSONRPCRequest& request)\n         throw std::runtime_error(msg);\n     }\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n     std::string label;\n     if (!request.params[2].isNull())\n@@ -982,131 +995,6 @@ static UniValue addmultisigaddress(const JSONRPCRequest& request)\n     return result;\n }\n \n-class Witnessifier : public boost::static_visitor<bool>\n-{\n-public:\n-    CWallet * const pwallet;\n-    CTxDestination result;\n-    bool already_witness;\n-\n-    explicit Witnessifier(CWallet *_pwallet) : pwallet(_pwallet), already_witness(false) {}\n-\n-    bool operator()(const CKeyID &keyID) {\n-        if (pwallet) {\n-            CScript basescript = GetScriptForDestination(keyID);\n-            CScript witscript = GetScriptForWitness(basescript);\n-            if (!IsSolvable(*pwallet, witscript)) {\n-                return false;\n-            }\n-            return ExtractDestination(witscript, result);\n-        }\n-        return false;\n-    }\n-\n-    bool operator()(const CScriptID &scriptID) {\n-        CScript subscript;\n-        if (pwallet && pwallet->GetCScript(scriptID, subscript)) {\n-            int witnessversion;\n-            std::vector<unsigned char> witprog;\n-            if (subscript.IsWitnessProgram(witnessversion, witprog)) {\n-                ExtractDestination(subscript, result);\n-                already_witness = true;\n-                return true;\n-            }\n-            CScript witscript = GetScriptForWitness(subscript);\n-            if (!IsSolvable(*pwallet, witscript)) {\n-                return false;\n-            }\n-            return ExtractDestination(witscript, result);\n-        }\n-        return false;\n-    }\n-\n-    bool operator()(const WitnessV0KeyHash& id)\n-    {\n-        already_witness = true;\n-        result = id;\n-        return true;\n-    }\n-\n-    bool operator()(const WitnessV0ScriptHash& id)\n-    {\n-        already_witness = true;\n-        result = id;\n-        return true;\n-    }\n-\n-    template<typename T>\n-    bool operator()(const T& dest) { return false; }\n-};\n-\n-static UniValue addwitnessaddress(const JSONRPCRequest& request)\n-{\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    CWallet* const pwallet = wallet.get();\n-\n-    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n-        return NullUniValue;\n-    }\n-\n-    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-    {\n-        std::string msg = \"addwitnessaddress \\\"address\\\" ( p2sh )\\n\"\n-            \"\\nDEPRECATED: set the address_type argument of getnewaddress, or option -addresstype=[bech32|p2sh-segwit] instead.\\n\"\n-            \"Add a witness address for a script (with pubkey or redeemscript known). Requires a new wallet backup.\\n\"\n-            \"It returns the witness script.\\n\"\n-\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"address\\\"       (string, required) An address known to the wallet\\n\"\n-            \"2. p2sh            (bool, optional, default=true) Embed inside P2SH\\n\"\n-\n-            \"\\nResult:\\n\"\n-            \"\\\"witnessaddress\\\",  (string) The value of the new address (P2SH or BIP173).\\n\"\n-            \"}\\n\"\n-        ;\n-        throw std::runtime_error(msg);\n-    }\n-\n-    if (!IsDeprecatedRPCEnabled(\"addwitnessaddress\")) {\n-        throw JSONRPCError(RPC_METHOD_DEPRECATED, \"addwitnessaddress is deprecated and will be fully removed in v0.17. \"\n-            \"To use addwitnessaddress in v0.16, restart bitcoind with -deprecatedrpc=addwitnessaddress.\\n\"\n-            \"Projects should transition to using the address_type argument of getnewaddress, or option -addresstype=[bech32|p2sh-segwit] instead.\\n\");\n-    }\n-\n-    CTxDestination dest = DecodeDestination(request.params[0].get_str());\n-    if (!IsValidDestination(dest)) {\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n-    }\n-\n-    bool p2sh = true;\n-    if (!request.params[1].isNull()) {\n-        p2sh = request.params[1].get_bool();\n-    }\n-\n-    Witnessifier w(pwallet);\n-    bool ret = boost::apply_visitor(w, dest);\n-    if (!ret) {\n-        throw JSONRPCError(RPC_WALLET_ERROR, \"Public key or redeemscript not known to wallet, or the key is uncompressed\");\n-    }\n-\n-    CScript witprogram = GetScriptForDestination(w.result);\n-\n-    if (p2sh) {\n-        w.result = CScriptID(witprogram);\n-    }\n-\n-    if (w.already_witness) {\n-        if (!(dest == w.result)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot convert between witness address types\");\n-        }\n-    } else {\n-        pwallet->AddCScript(witprogram); // Implicit for single-key now, but necessary for multisig and for compatibility with older software\n-        pwallet->SetAddressBook(w.result, \"\", \"receive\");\n-    }\n-\n-    return EncodeDestination(w.result);\n-}\n-\n struct tallyitem\n {\n     CAmount nAmount;\n@@ -1121,8 +1009,10 @@ struct tallyitem\n     }\n };\n \n-static UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool by_label) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+static UniValue ListReceived(interfaces::Chain::Lock& locked_chain, CWallet * const pwallet, const UniValue& params, bool by_label) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n+    LockAnnotation lock(::cs_main); // Temporary, for CheckFinalTx below. Removed in upcoming commit.\n+\n     // Minimum confirmations\n     int nMinDepth = 1;\n     if (!params[0].isNull())\n@@ -1156,7 +1046,7 @@ static UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bo\n         if (wtx.IsCoinBase() || !CheckFinalTx(*wtx.tx))\n             continue;\n \n-        int nDepth = wtx.GetDepthInMainChain();\n+        int nDepth = wtx.GetDepthInMainChain(locked_chain);\n         if (nDepth < nMinDepth)\n             continue;\n \n@@ -1310,9 +1200,10 @@ static UniValue listreceivedbyaddress(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n-    return ListReceived(pwallet, request.params, false);\n+    return ListReceived(*locked_chain, pwallet, request.params, false);\n }\n \n static UniValue listreceivedbylabel(const JSONRPCRequest& request)\n@@ -1354,9 +1245,10 @@ static UniValue listreceivedbylabel(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n-    return ListReceived(pwallet, request.params, true);\n+    return ListReceived(*locked_chain, pwallet, request.params, true);\n }\n \n static void MaybePushAddress(UniValue & entry, const CTxDestination &dest)\n@@ -1369,25 +1261,26 @@ static void MaybePushAddress(UniValue & entry, const CTxDestination &dest)\n /**\n  * List transactions based on the given criteria.\n  *\n- * @param  pwallet    The wallet.\n- * @param  wtx        The wallet transaction.\n- * @param  nMinDepth  The minimum confirmation depth.\n- * @param  fLong      Whether to include the JSON version of the transaction.\n- * @param  ret        The UniValue into which the result is stored.\n- * @param  filter     The \"is mine\" filter bool.\n+ * @param  pwallet        The wallet.\n+ * @param  wtx            The wallet transaction.\n+ * @param  nMinDepth      The minimum confirmation depth.\n+ * @param  fLong          Whether to include the JSON version of the transaction.\n+ * @param  ret            The UniValue into which the result is stored.\n+ * @param  filter_ismine  The \"is mine\" filter flags.\n+ * @param  filter_label   Optional label string to filter incoming transactions.\n  */\n-static void ListTransactions(CWallet* const pwallet, const CWalletTx& wtx, int nMinDepth, bool fLong, UniValue& ret, const isminefilter& filter) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+static void ListTransactions(interfaces::Chain::Lock& locked_chain, CWallet* const pwallet, const CWalletTx& wtx, int nMinDepth, bool fLong, UniValue& ret, const isminefilter& filter_ismine, const std::string* filter_label)\n {\n     CAmount nFee;\n     std::list<COutputEntry> listReceived;\n     std::list<COutputEntry> listSent;\n \n-    wtx.GetAmounts(listReceived, listSent, nFee, filter);\n+    wtx.GetAmounts(listReceived, listSent, nFee, filter_ismine);\n \n     bool involvesWatchonly = wtx.IsFromMe(ISMINE_WATCH_ONLY);\n \n     // Sent\n-    if ((!listSent.empty() || nFee != 0))\n+    if (!filter_label)\n     {\n         for (const COutputEntry& s : listSent)\n         {\n@@ -1404,31 +1297,34 @@ static void ListTransactions(CWallet* const pwallet, const CWalletTx& wtx, int n\n             entry.pushKV(\"vout\", s.vout);\n             entry.pushKV(\"fee\", ValueFromAmount(-nFee));\n             if (fLong)\n-                WalletTxToJSON(wtx, entry);\n+                WalletTxToJSON(pwallet->chain(), locked_chain, wtx, entry);\n             entry.pushKV(\"abandoned\", wtx.isAbandoned());\n             ret.push_back(entry);\n         }\n     }\n \n     // Received\n-    if (listReceived.size() > 0 && wtx.GetDepthInMainChain() >= nMinDepth)\n+    if (listReceived.size() > 0 && wtx.GetDepthInMainChain(locked_chain) >= nMinDepth)\n     {\n         for (const COutputEntry& r : listReceived)\n         {\n             std::string label;\n             if (pwallet->mapAddressBook.count(r.destination)) {\n                 label = pwallet->mapAddressBook[r.destination].name;\n             }\n+            if (filter_label && label != *filter_label) {\n+                continue;\n+            }\n             UniValue entry(UniValue::VOBJ);\n             if (involvesWatchonly || (::IsMine(*pwallet, r.destination) & ISMINE_WATCH_ONLY)) {\n                 entry.pushKV(\"involvesWatchonly\", true);\n             }\n             MaybePushAddress(entry, r.destination);\n             if (wtx.IsCoinBase())\n             {\n-                if (wtx.GetDepthInMainChain() < 1)\n+                if (wtx.GetDepthInMainChain(locked_chain) < 1)\n                     entry.pushKV(\"category\", \"orphan\");\n-                else if (wtx.IsImmatureCoinBase())\n+                else if (wtx.IsImmatureCoinBase(locked_chain))\n                     entry.pushKV(\"category\", \"immature\");\n                 else\n                     entry.pushKV(\"category\", \"generate\");\n@@ -1443,7 +1339,7 @@ static void ListTransactions(CWallet* const pwallet, const CWalletTx& wtx, int n\n             }\n             entry.pushKV(\"vout\", r.vout);\n             if (fLong)\n-                WalletTxToJSON(wtx, entry);\n+                WalletTxToJSON(pwallet->chain(), locked_chain, wtx, entry);\n             ret.push_back(entry);\n         }\n     }\n@@ -1460,10 +1356,12 @@ UniValue listtransactions(const JSONRPCRequest& request)\n \n     if (request.fHelp || request.params.size() > 4)\n         throw std::runtime_error(\n-            \"listtransactions (dummy count skip include_watchonly)\\n\"\n+            \"listtransactions ( \\\"label\\\" count skip include_watchonly )\\n\"\n+            \"\\nIf a label name is provided, this will return only incoming transactions paying to addresses with the specified label.\\n\"\n             \"\\nReturns up to 'count' most recent transactions skipping the first 'from' transactions.\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. \\\"dummy\\\"    (string, optional) If set, should be \\\"*\\\" for backwards compatibility.\\n\"\n+            \"1. \\\"label\\\"    (string, optional) If set, should be a valid label name to return only incoming transactions\\n\"\n+            \"              with the specified label, or \\\"*\\\" to disable filtering and return all transactions.\\n\"\n             \"2. count          (numeric, optional, default=10) The number of transactions to return\\n\"\n             \"3. skip           (numeric, optional, default=0) The number of transactions to skip\\n\"\n             \"4. include_watchonly (bool, optional, default=false) Include transactions to watch-only addresses (see 'importaddress')\\n\"\n@@ -1508,8 +1406,12 @@ UniValue listtransactions(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n+    const std::string* filter_label = nullptr;\n     if (!request.params[0].isNull() && request.params[0].get_str() != \"*\") {\n-        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Dummy value must be set to \\\"*\\\"\");\n+        filter_label = &request.params[0].get_str();\n+        if (filter_label->empty()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Label argument must be a valid label name or \\\"*\\\".\");\n+        }\n     }\n     int nCount = 10;\n     if (!request.params[1].isNull())\n@@ -1530,15 +1432,16 @@ UniValue listtransactions(const JSONRPCRequest& request)\n     UniValue ret(UniValue::VARR);\n \n     {\n-        LOCK2(cs_main, pwallet->cs_wallet);\n+        auto locked_chain = pwallet->chain().lock();\n+        LOCK(pwallet->cs_wallet);\n \n         const CWallet::TxItems & txOrdered = pwallet->wtxOrdered;\n \n         // iterate backwards until we have nCount items to return:\n         for (CWallet::TxItems::const_reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n         {\n             CWalletTx *const pwtx = (*it).second;\n-            ListTransactions(pwallet, *pwtx, 0, true, ret, filter);\n+            ListTransactions(*locked_chain, pwallet, *pwtx, 0, true, ret, filter, filter_label);\n             if ((int)ret.size() >= (nCount+nFrom)) break;\n         }\n     }\n@@ -1630,7 +1533,8 @@ static UniValue listsinceblock(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n     const CBlockIndex* pindex = nullptr;    // Block index of the specified block or the common ancestor, if the block provided was in a deactivated chain.\n     const CBlockIndex* paltindex = nullptr; // Block index of the specified block, even if it's in a deactivated chain.\n@@ -1673,8 +1577,8 @@ static UniValue listsinceblock(const JSONRPCRequest& request)\n     for (const std::pair<const uint256, CWalletTx>& pairWtx : pwallet->mapWallet) {\n         CWalletTx tx = pairWtx.second;\n \n-        if (depth == -1 || tx.GetDepthInMainChain() < depth) {\n-            ListTransactions(pwallet, tx, 0, true, transactions, filter);\n+        if (depth == -1 || tx.GetDepthInMainChain(*locked_chain) < depth) {\n+            ListTransactions(*locked_chain, pwallet, tx, 0, true, transactions, filter, nullptr /* filter_label */);\n         }\n     }\n \n@@ -1691,7 +1595,7 @@ static UniValue listsinceblock(const JSONRPCRequest& request)\n             if (it != pwallet->mapWallet.end()) {\n                 // We want all transactions regardless of confirmation count to appear here,\n                 // even negative confirmation ones, hence the big negative.\n-                ListTransactions(pwallet, it->second, -100000000, true, removed, filter);\n+                ListTransactions(*locked_chain, pwallet, it->second, -100000000, true, removed, filter, nullptr /* filter_label */);\n             }\n         }\n         paltindex = paltindex->pprev;\n@@ -1765,7 +1669,8 @@ static UniValue gettransaction(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n     uint256 hash(ParseHashV(request.params[0], \"txid\"));\n \n@@ -1781,7 +1686,7 @@ static UniValue gettransaction(const JSONRPCRequest& request)\n     }\n     const CWalletTx& wtx = it->second;\n \n-    CAmount nCredit = wtx.GetCredit(filter);\n+    CAmount nCredit = wtx.GetCredit(*locked_chain, filter);\n     CAmount nDebit = wtx.GetDebit(filter);\n     CAmount nNet = nCredit - nDebit;\n     CAmount nFee = (wtx.IsFromMe(filter) ? wtx.tx->GetValueOut() - nDebit : 0);\n@@ -1790,10 +1695,10 @@ static UniValue gettransaction(const JSONRPCRequest& request)\n     if (wtx.IsFromMe(filter))\n         entry.pushKV(\"fee\", ValueFromAmount(nFee));\n \n-    WalletTxToJSON(wtx, entry);\n+    WalletTxToJSON(pwallet->chain(), *locked_chain, wtx, entry);\n \n     UniValue details(UniValue::VARR);\n-    ListTransactions(pwallet, wtx, 0, false, details, filter);\n+    ListTransactions(*locked_chain, pwallet, wtx, 0, false, details, filter, nullptr /* filter_label */);\n     entry.pushKV(\"details\", details);\n \n     std::string strHex = EncodeHexTx(*wtx.tx, RPCSerializationFlags());\n@@ -1832,14 +1737,15 @@ static UniValue abandontransaction(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n     uint256 hash(ParseHashV(request.params[0], \"txid\"));\n \n     if (!pwallet->mapWallet.count(hash)) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n     }\n-    if (!pwallet->AbandonTransaction(hash)) {\n+    if (!pwallet->AbandonTransaction(*locked_chain, hash)) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction not eligible for abandonment\");\n     }\n \n@@ -1871,7 +1777,8 @@ static UniValue backupwallet(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n     std::string strDest = request.params[0].get_str();\n     if (!pwallet->BackupWallet(strDest)) {\n@@ -1907,7 +1814,8 @@ static UniValue keypoolrefill(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Error: Private keys are disabled for this wallet\");\n     }\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n     // 0 is interpreted by TopUpKeyPool() as the default keypool size given by -keypool\n     unsigned int kpSize = 0;\n@@ -1928,13 +1836,6 @@ static UniValue keypoolrefill(const JSONRPCRequest& request)\n }\n \n \n-static void LockWallet(CWallet* pWallet)\n-{\n-    LOCK(pWallet->cs_wallet);\n-    pWallet->nRelockTime = 0;\n-    pWallet->Lock();\n-}\n-\n static UniValue walletpassphrase(const JSONRPCRequest& request)\n {\n     std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n@@ -1965,7 +1866,8 @@ static UniValue walletpassphrase(const JSONRPCRequest& request)\n         );\n     }\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n     if (!pwallet->IsCrypted()) {\n         throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an unencrypted wallet, but walletpassphrase was called.\");\n@@ -2004,7 +1906,18 @@ static UniValue walletpassphrase(const JSONRPCRequest& request)\n     pwallet->TopUpKeyPool();\n \n     pwallet->nRelockTime = GetTime() + nSleepTime;\n-    RPCRunLater(strprintf(\"lockwallet(%s)\", pwallet->GetName()), std::bind(LockWallet, pwallet), nSleepTime);\n+\n+    // Keep a weak pointer to the wallet so that it is possible to unload the\n+    // wallet before the following callback is called. If a valid shared pointer\n+    // is acquired in the callback then the wallet is still loaded.\n+    std::weak_ptr<CWallet> weak_wallet = wallet;\n+    RPCRunLater(strprintf(\"lockwallet(%s)\", pwallet->GetName()), [weak_wallet] {\n+        if (auto shared_wallet = weak_wallet.lock()) {\n+            LOCK(shared_wallet->cs_wallet);\n+            shared_wallet->Lock();\n+            shared_wallet->nRelockTime = 0;\n+        }\n+    }, nSleepTime);\n \n     return NullUniValue;\n }\n@@ -2032,7 +1945,8 @@ static UniValue walletpassphrasechange(const JSONRPCRequest& request)\n         );\n     }\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n     if (!pwallet->IsCrypted()) {\n         throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an unencrypted wallet, but walletpassphrasechange was called.\");\n@@ -2088,7 +2002,8 @@ static UniValue walletlock(const JSONRPCRequest& request)\n         );\n     }\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n     if (!pwallet->IsCrypted()) {\n         throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an unencrypted wallet, but walletlock was called.\");\n@@ -2134,7 +2049,8 @@ static UniValue encryptwallet(const JSONRPCRequest& request)\n         );\n     }\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n     if (pwallet->IsCrypted()) {\n         throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an encrypted wallet, but encryptwallet was called.\");\n@@ -2169,7 +2085,21 @@ static UniValue lockunspent(const JSONRPCRequest& request)\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n-            \"lockunspent unlock ([{\\\"txid\\\":\\\"txid\\\",\\\"vout\\\":n},...])\\n\"\n+            RPCHelpMan{\"lockunspent\",\n+                {\n+                    {\"unlock\", RPCArg::Type::BOOL, false},\n+                    {\"transactions\", RPCArg::Type::ARR,\n+                        {\n+                            {\"\", RPCArg::Type::OBJ,\n+                                {\n+                                    {\"txid\", RPCArg::Type::STR_HEX, false},\n+                                    {\"vout\", RPCArg::Type::NUM, false},\n+                                },\n+                                true},\n+                        },\n+                        true},\n+                }}\n+                .ToString() +\n             \"\\nUpdates list of temporarily unspendable outputs.\\n\"\n             \"Temporarily lock (unlock=false) or unlock (unlock=true) specified transaction outputs.\\n\"\n             \"If no transaction outputs are specified when unlocking then all current locked transaction outputs are unlocked.\\n\"\n@@ -2208,7 +2138,8 @@ static UniValue lockunspent(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n     RPCTypeCheckArgument(request.params[0], UniValue::VBOOL);\n \n@@ -2257,7 +2188,7 @@ static UniValue lockunspent(const JSONRPCRequest& request)\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, vout index out of bounds\");\n         }\n \n-        if (pwallet->IsSpent(outpt.hash, outpt.n)) {\n+        if (pwallet->IsSpent(*locked_chain, outpt.hash, outpt.n)) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, expected unspent output\");\n         }\n \n@@ -2318,7 +2249,8 @@ static UniValue listlockunspent(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"listlockunspent\", \"\")\n         );\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n     std::vector<COutPoint> vOutpts;\n     pwallet->ListLockedCoins(vOutpts);\n@@ -2359,7 +2291,8 @@ static UniValue settxfee(const JSONRPCRequest& request)\n         );\n     }\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n     CAmount nAmount = AmountFromValue(request.params[0]);\n     CFeeRate tx_fee_rate(nAmount, 1000);\n@@ -2414,7 +2347,8 @@ static UniValue getwalletinfo(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n     UniValue obj(UniValue::VOBJ);\n \n@@ -2526,26 +2460,26 @@ static UniValue loadwallet(const JSONRPCRequest& request)\n             + HelpExampleCli(\"loadwallet\", \"\\\"test.dat\\\"\")\n             + HelpExampleRpc(\"loadwallet\", \"\\\"test.dat\\\"\")\n         );\n-    std::string wallet_file = request.params[0].get_str();\n+\n+    WalletLocation location(request.params[0].get_str());\n     std::string error;\n \n-    fs::path wallet_path = fs::absolute(wallet_file, GetWalletDir());\n-    if (fs::symlink_status(wallet_path).type() == fs::file_not_found) {\n-        throw JSONRPCError(RPC_WALLET_NOT_FOUND, \"Wallet \" + wallet_file + \" not found.\");\n-    } else if (fs::is_directory(wallet_path)) {\n+    if (!location.Exists()) {\n+        throw JSONRPCError(RPC_WALLET_NOT_FOUND, \"Wallet \" + location.GetName() + \" not found.\");\n+    } else if (fs::is_directory(location.GetPath())) {\n         // The given filename is a directory. Check that there's a wallet.dat file.\n-        fs::path wallet_dat_file = wallet_path / \"wallet.dat\";\n+        fs::path wallet_dat_file = location.GetPath() / \"wallet.dat\";\n         if (fs::symlink_status(wallet_dat_file).type() == fs::file_not_found) {\n-            throw JSONRPCError(RPC_WALLET_NOT_FOUND, \"Directory \" + wallet_file + \" does not contain a wallet.dat file.\");\n+            throw JSONRPCError(RPC_WALLET_NOT_FOUND, \"Directory \" + location.GetName() + \" does not contain a wallet.dat file.\");\n         }\n     }\n \n     std::string warning;\n-    if (!CWallet::Verify(wallet_file, false, error, warning)) {\n+    if (!CWallet::Verify(*g_rpc_interfaces->chain, location, false, error, warning)) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Wallet file verification failed: \" + error);\n     }\n \n-    std::shared_ptr<CWallet> const wallet = CWallet::CreateWalletFromFile(wallet_file, fs::absolute(wallet_file, GetWalletDir()));\n+    std::shared_ptr<CWallet> const wallet = CWallet::CreateWalletFromFile(*g_rpc_interfaces->chain, location);\n     if (!wallet) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Wallet loading failed.\");\n     }\n@@ -2579,7 +2513,6 @@ static UniValue createwallet(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"createwallet\", \"\\\"testwallet\\\"\")\n         );\n     }\n-    std::string wallet_name = request.params[0].get_str();\n     std::string error;\n     std::string warning;\n \n@@ -2588,17 +2521,17 @@ static UniValue createwallet(const JSONRPCRequest& request)\n         disable_privatekeys = request.params[1].get_bool();\n     }\n \n-    fs::path wallet_path = fs::absolute(wallet_name, GetWalletDir());\n-    if (fs::symlink_status(wallet_path).type() != fs::file_not_found) {\n-        throw JSONRPCError(RPC_WALLET_ERROR, \"Wallet \" + wallet_name + \" already exists.\");\n+    WalletLocation location(request.params[0].get_str());\n+    if (location.Exists()) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Wallet \" + location.GetName() + \" already exists.\");\n     }\n \n     // Wallet::Verify will check if we're trying to create a wallet with a duplication name.\n-    if (!CWallet::Verify(wallet_name, false, error, warning)) {\n+    if (!CWallet::Verify(*g_rpc_interfaces->chain, location, false, error, warning)) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Wallet file verification failed: \" + error);\n     }\n \n-    std::shared_ptr<CWallet> const wallet = CWallet::CreateWalletFromFile(wallet_name, fs::absolute(wallet_name, GetWalletDir()), (disable_privatekeys ? (uint64_t)WALLET_FLAG_DISABLE_PRIVATE_KEYS : 0));\n+    std::shared_ptr<CWallet> const wallet = CWallet::CreateWalletFromFile(*g_rpc_interfaces->chain, location, (disable_privatekeys ? (uint64_t)WALLET_FLAG_DISABLE_PRIVATE_KEYS : 0));\n     if (!wallet) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Wallet creation failed.\");\n     }\n@@ -2684,13 +2617,14 @@ static UniValue resendwallettransactions(const JSONRPCRequest& request)\n     if (!g_connman)\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n     if (!pwallet->GetBroadcastTransactions()) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Error: Wallet transaction broadcasting is disabled with -walletbroadcast\");\n     }\n \n-    std::vector<uint256> txids = pwallet->ResendWalletTransactionsBefore(GetTime(), g_connman.get());\n+    std::vector<uint256> txids = pwallet->ResendWalletTransactionsBefore(*locked_chain, GetTime(), g_connman.get());\n     UniValue result(UniValue::VARR);\n     for (const uint256& txid : txids)\n     {\n@@ -2710,7 +2644,26 @@ static UniValue listunspent(const JSONRPCRequest& request)\n \n     if (request.fHelp || request.params.size() > 5)\n         throw std::runtime_error(\n-            \"listunspent ( minconf maxconf  [\\\"addresses\\\",...] [include_unsafe] [query_options])\\n\"\n+            RPCHelpMan{\"listunspent\",\n+                {\n+                    {\"minconf\", RPCArg::Type::NUM, true},\n+                    {\"maxconf\", RPCArg::Type::NUM, true},\n+                    {\"addresses\", RPCArg::Type::ARR,\n+                        {\n+                            {\"address\", RPCArg::Type::STR_HEX, true},\n+                        },\n+                        true},\n+                    {\"include_unsafe\", RPCArg::Type::BOOL, true},\n+                    {\"query_options\", RPCArg::Type::OBJ,\n+                        {\n+                            {\"minimumAmount\", RPCArg::Type::AMOUNT, true},\n+                            {\"maximumAmount\", RPCArg::Type::AMOUNT, true},\n+                            {\"maximumCount\", RPCArg::Type::NUM, true},\n+                            {\"minimumSumAmount\", RPCArg::Type::AMOUNT, true},\n+                        },\n+                        true},\n+                }}\n+                .ToString() +\n             \"\\nReturns array of unspent transaction outputs\\n\"\n             \"with between minconf and maxconf (inclusive) confirmations.\\n\"\n             \"Optionally filter to only include txouts paid to specified addresses.\\n\"\n@@ -2821,8 +2774,9 @@ static UniValue listunspent(const JSONRPCRequest& request)\n     UniValue results(UniValue::VARR);\n     std::vector<COutput> vecOutputs;\n     {\n-        LOCK2(cs_main, pwallet->cs_wallet);\n-        pwallet->AvailableCoins(vecOutputs, !include_unsafe, nullptr, nMinimumAmount, nMaximumAmount, nMinimumSumAmount, nMaximumCount, nMinDepth, nMaxDepth);\n+        auto locked_chain = pwallet->chain().lock();\n+        LOCK(pwallet->cs_wallet);\n+        pwallet->AvailableCoins(*locked_chain, vecOutputs, !include_unsafe, nullptr, nMinimumAmount, nMaximumAmount, nMinimumSumAmount, nMaximumCount, nMinDepth, nMaxDepth);\n     }\n \n     LOCK(pwallet->cs_wallet);\n@@ -3084,7 +3038,25 @@ UniValue signrawtransactionwithwallet(const JSONRPCRequest& request)\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n         throw std::runtime_error(\n-            \"signrawtransactionwithwallet \\\"hexstring\\\" ( [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n,\\\"scriptPubKey\\\":\\\"hex\\\",\\\"redeemScript\\\":\\\"hex\\\"},...] sighashtype )\\n\"\n+            RPCHelpMan{\"signrawtransactionwithwallet\",\n+                {\n+                    {\"hexstring\", RPCArg::Type::STR, false},\n+                    {\"prevtxs\", RPCArg::Type::ARR,\n+                        {\n+                            {\"\", RPCArg::Type::OBJ,\n+                                {\n+                                    {\"txid\", RPCArg::Type::STR_HEX, false},\n+                                    {\"vout\", RPCArg::Type::NUM, false},\n+                                    {\"scriptPubKey\", RPCArg::Type::STR_HEX, false},\n+                                    {\"redeemScript\", RPCArg::Type::STR_HEX, false},\n+                                    {\"amount\", RPCArg::Type::AMOUNT, false},\n+                                },\n+                                false},\n+                        },\n+                        true},\n+                    {\"sighashtype\", RPCArg::Type::STR, true},\n+                }}\n+                .ToString() +\n             \"\\nSign inputs for raw transaction (serialized, hex-encoded).\\n\"\n             \"The second optional argument (may be null) is an array of previous transaction outputs that\\n\"\n             \"this transaction depends on but may not yet be in the block chain.\\n\"\n@@ -3140,10 +3112,11 @@ UniValue signrawtransactionwithwallet(const JSONRPCRequest& request)\n     }\n \n     // Sign the transaction\n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n     EnsureWalletIsUnlocked(pwallet);\n \n-    return SignTransaction(mtx, request.params[1], pwallet, false, request.params[2]);\n+    return SignTransaction(pwallet->chain(), mtx, request.params[1], pwallet, false, request.params[2]);\n }\n \n static UniValue bumpfee(const JSONRPCRequest& request)\n@@ -3245,7 +3218,8 @@ static UniValue bumpfee(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n     EnsureWalletIsUnlocked(pwallet);\n \n \n@@ -3385,7 +3359,7 @@ UniValue rescanblockchain(const JSONRPCRequest& request)\n     CBlockIndex *pindexStop = nullptr;\n     CBlockIndex *pChainTip = nullptr;\n     {\n-        LOCK(cs_main);\n+        auto locked_chain = pwallet->chain().lock();\n         pindexStart = chainActive.Genesis();\n         pChainTip = chainActive.Tip();\n \n@@ -3409,7 +3383,7 @@ UniValue rescanblockchain(const JSONRPCRequest& request)\n \n     // We can't rescan beyond non-pruned blocks, stop and throw an error\n     if (fPruneMode) {\n-        LOCK(cs_main);\n+        auto locked_chain = pwallet->chain().lock();\n         CBlockIndex *block = pindexStop ? pindexStop : pChainTip;\n         while (block && block->nHeight >= pindexStart->nHeight) {\n             if (!(block->nStatus & BLOCK_HAVE_DATA)) {\n@@ -3576,8 +3550,10 @@ UniValue getaddressinfo(const JSONRPCRequest& request)\n             \"  \\\"address\\\" : \\\"address\\\",        (string) The bitcoin address validated\\n\"\n             \"  \\\"scriptPubKey\\\" : \\\"hex\\\",       (string) The hex-encoded scriptPubKey generated by the address\\n\"\n             \"  \\\"ismine\\\" : true|false,        (boolean) If the address is yours or not\\n\"\n+            \"  \\\"solvable\\\" : true|false,      (boolean) If the address is solvable by the wallet\\n\"\n             \"  \\\"iswatchonly\\\" : true|false,   (boolean) If the address is watchonly\\n\"\n             \"  \\\"isscript\\\" : true|false,      (boolean) If the key is a script\\n\"\n+            \"  \\\"ischange\\\" : true|false,      (boolean) If the address was used for change output\\n\"\n             \"  \\\"iswitness\\\" : true|false,     (boolean) If the address is a witness address\\n\"\n             \"  \\\"witness_version\\\" : version   (numeric, optional) The version number of the witness program\\n\"\n             \"  \\\"witness_program\\\" : \\\"hex\\\"     (string, optional) The hex value of the witness program\\n\"\n@@ -3630,11 +3606,13 @@ UniValue getaddressinfo(const JSONRPCRequest& request)\n     isminetype mine = IsMine(*pwallet, dest);\n     ret.pushKV(\"ismine\", bool(mine & ISMINE_SPENDABLE));\n     ret.pushKV(\"iswatchonly\", bool(mine & ISMINE_WATCH_ONLY));\n+    ret.pushKV(\"solvable\", IsSolvable(*pwallet, scriptPubKey));\n     UniValue detail = DescribeWalletAddress(pwallet, dest);\n     ret.pushKVs(detail);\n     if (pwallet->mapAddressBook.count(dest)) {\n         ret.pushKV(\"label\", pwallet->mapAddressBook[dest].name);\n     }\n+    ret.pushKV(\"ischange\", pwallet->IsChange(scriptPubKey));\n     const CKeyMetadata* meta = nullptr;\n     CKeyID key_id = GetKeyForDestination(*pwallet, dest);\n     if (!key_id.IsNull()) {\n@@ -3805,7 +3783,8 @@ UniValue sethdseed(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_CLIENT_IN_INITIAL_DOWNLOAD, \"Cannot set a new HD seed while still in Initial Block Download\");\n     }\n \n-    LOCK2(cs_main, pwallet->cs_wallet);\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n \n     // Do not do anything to non-HD wallets\n     if (!pwallet->IsHDEnabled()) {\n@@ -3854,37 +3833,47 @@ void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubK\n     hd_keypaths.emplace(vchPubKey, std::move(info));\n }\n \n-bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign, bool bip32derivs)\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, int sighash_type, bool sign, bool bip32derivs)\n {\n     LOCK(pwallet->cs_wallet);\n     // Get all of the previous transactions\n     bool complete = true;\n-    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n-        const CTxIn& txin = txConst->vin[i];\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        const CTxIn& txin = psbtx.tx->vin[i];\n         PSBTInput& input = psbtx.inputs.at(i);\n \n-        // If we don't know about this input, skip it and let someone else deal with it\n-        const uint256& txhash = txin.prevout.hash;\n-        const auto it = pwallet->mapWallet.find(txhash);\n-        if (it != pwallet->mapWallet.end()) {\n-            const CWalletTx& wtx = it->second;\n-            CTxOut utxo = wtx.tx->vout[txin.prevout.n];\n-            // Update both UTXOs from the wallet.\n-            input.non_witness_utxo = wtx.tx;\n-            input.witness_utxo = utxo;\n+        if (PSBTInputSigned(input)) {\n+            continue;\n+        }\n+\n+        // Verify input looks sane. This will check that we have at most one uxto, witness or non-witness.\n+        if (!input.IsSane()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"PSBT input is not sane.\");\n+        }\n+\n+        // If we have no utxo, grab it from the wallet.\n+        if (!input.non_witness_utxo && input.witness_utxo.IsNull()) {\n+            const uint256& txhash = txin.prevout.hash;\n+            const auto it = pwallet->mapWallet.find(txhash);\n+            if (it != pwallet->mapWallet.end()) {\n+                const CWalletTx& wtx = it->second;\n+                // We only need the non_witness_utxo, which is a superset of the witness_utxo.\n+                //   The signing code will switch to the smaller witness_utxo if this is ok.\n+                input.non_witness_utxo = wtx.tx;\n+            }\n         }\n \n         // Get the Sighash type\n         if (sign && input.sighash_type > 0 && input.sighash_type != sighash_type) {\n             throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Specified Sighash and sighash in PSBT do not match.\");\n         }\n \n-        complete &= SignPSBTInput(HidingSigningProvider(pwallet, !sign, !bip32derivs), *psbtx.tx, input, i, sighash_type);\n+        complete &= SignPSBTInput(HidingSigningProvider(pwallet, !sign, !bip32derivs), psbtx, i, sighash_type);\n     }\n \n     // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n-    for (unsigned int i = 0; i < txConst->vout.size(); ++i) {\n-        const CTxOut& out = txConst->vout.at(i);\n+    for (unsigned int i = 0; i < psbtx.tx->vout.size(); ++i) {\n+        const CTxOut& out = psbtx.tx->vout.at(i);\n         PSBTOutput& psbt_out = psbtx.outputs.at(i);\n \n         // Fill a SignatureData with output info\n@@ -3949,19 +3938,15 @@ UniValue walletprocesspsbt(const JSONRPCRequest& request)\n     // Get the sighash type\n     int nHashType = ParseSighashString(request.params[2]);\n \n-    // Use CTransaction for the constant parts of the\n-    // transaction to avoid rehashing.\n-    const CTransaction txConst(*psbtx.tx);\n-\n     // Fill transaction with our data and also sign\n     bool sign = request.params[1].isNull() ? true : request.params[1].get_bool();\n     bool bip32derivs = request.params[3].isNull() ? false : request.params[3].get_bool();\n-    bool complete = FillPSBT(pwallet, psbtx, &txConst, nHashType, sign, bip32derivs);\n+    bool complete = FillPSBT(pwallet, psbtx, nHashType, sign, bip32derivs);\n \n     UniValue result(UniValue::VOBJ);\n     CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n     ssTx << psbtx;\n-    result.pushKV(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size()));\n+    result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));\n     result.pushKV(\"complete\", complete);\n \n     return result;\n@@ -3978,7 +3963,55 @@ UniValue walletcreatefundedpsbt(const JSONRPCRequest& request)\n \n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 5)\n         throw std::runtime_error(\n-                            \"walletcreatefundedpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable ) ( options bip32derivs )\\n\"\n+            RPCHelpMan{\"walletcreatefundedpsbt\",\n+                {\n+                    {\"inputs\", RPCArg::Type::ARR,\n+                        {\n+                            {\"\", RPCArg::Type::OBJ,\n+                                {\n+                                    {\"txid\", RPCArg::Type::STR_HEX, false},\n+                                    {\"vout\", RPCArg::Type::NUM, false},\n+                                    {\"sequence\", RPCArg::Type::NUM, false},\n+                                },\n+                                false},\n+                        },\n+                        false},\n+                    {\"outputs\", RPCArg::Type::ARR,\n+                        {\n+                            {\"\", RPCArg::Type::OBJ,\n+                                {\n+                                    {\"address\", RPCArg::Type::AMOUNT, true},\n+                                },\n+                                true},\n+                            {\"\", RPCArg::Type::OBJ,\n+                                {\n+                                    {\"data\", RPCArg::Type::STR_HEX, true},\n+                                },\n+                                true},\n+                        },\n+                        false},\n+                    {\"locktime\", RPCArg::Type::NUM, true},\n+                    {\"options\", RPCArg::Type::OBJ,\n+                        {\n+                            {\"changeAddress\", RPCArg::Type::STR_HEX, true},\n+                            {\"changePosition\", RPCArg::Type::NUM, true},\n+                            {\"change_type\", RPCArg::Type::STR, true},\n+                            {\"includeWatching\", RPCArg::Type::BOOL, true},\n+                            {\"lockUnspents\", RPCArg::Type::BOOL, true},\n+                            {\"feeRate\", RPCArg::Type::NUM, true},\n+                            {\"subtractFeeFromOutputs\", RPCArg::Type::ARR,\n+                                {\n+                                    {\"int\", RPCArg::Type::NUM, true},\n+                                },\n+                                true},\n+                            {\"replaceable\", RPCArg::Type::BOOL, true},\n+                            {\"conf_target\", RPCArg::Type::NUM, true},\n+                            {\"estimate_mode\", RPCArg::Type::STR, true},\n+                        },\n+                        true},\n+                    {\"bip32derivs\", RPCArg::Type::BOOL, true},\n+                }}\n+                .ToString() +\n                             \"\\nCreates and funds a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n                             \"Implements the Creator and Updater roles.\\n\"\n                             \"\\nArguments:\\n\"\n@@ -4053,29 +4086,18 @@ UniValue walletcreatefundedpsbt(const JSONRPCRequest& request)\n     FundTransaction(pwallet, rawTx, fee, change_position, request.params[3]);\n \n     // Make a blank psbt\n-    PartiallySignedTransaction psbtx;\n-    psbtx.tx = rawTx;\n-    for (unsigned int i = 0; i < rawTx.vin.size(); ++i) {\n-        psbtx.inputs.push_back(PSBTInput());\n-    }\n-    for (unsigned int i = 0; i < rawTx.vout.size(); ++i) {\n-        psbtx.outputs.push_back(PSBTOutput());\n-    }\n-\n-    // Use CTransaction for the constant parts of the\n-    // transaction to avoid rehashing.\n-    const CTransaction txConst(*psbtx.tx);\n+    PartiallySignedTransaction psbtx(rawTx);\n \n     // Fill transaction with out data but don't sign\n     bool bip32derivs = request.params[4].isNull() ? false : request.params[4].get_bool();\n-    FillPSBT(pwallet, psbtx, &txConst, 1, false, bip32derivs);\n+    FillPSBT(pwallet, psbtx, 1, false, bip32derivs);\n \n     // Serialize the PSBT\n     CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n     ssTx << psbtx;\n \n     UniValue result(UniValue::VOBJ);\n-    result.pushKV(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size()));\n+    result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));\n     result.pushKV(\"fee\", ValueFromAmount(fee));\n     result.pushKV(\"changepos\", change_position);\n     return result;\n@@ -4097,7 +4119,6 @@ static const CRPCCommand commands[] =\n { //  category              name                                actor (function)                argNames\n     //  --------------------- ------------------------          -----------------------         ----------\n     { \"generating\",         \"generate\",                         &generate,                      {\"nblocks\",\"maxtries\"} },\n-    { \"hidden\",             \"addwitnessaddress\",                &addwitnessaddress,             {\"address\",\"p2sh\"} },\n     { \"hidden\",             \"resendwallettransactions\",         &resendwallettransactions,      {} },\n     { \"rawtransactions\",    \"fundrawtransaction\",               &fundrawtransaction,            {\"hexstring\",\"options\",\"iswitness\"} },\n     { \"wallet\",             \"abandontransaction\",               &abandontransaction,            {\"txid\"} },\n@@ -4132,7 +4153,7 @@ static const CRPCCommand commands[] =\n     { \"wallet\",             \"listreceivedbyaddress\",            &listreceivedbyaddress,         {\"minconf\",\"include_empty\",\"include_watchonly\",\"address_filter\"} },\n     { \"wallet\",             \"listreceivedbylabel\",              &listreceivedbylabel,           {\"minconf\",\"include_empty\",\"include_watchonly\"} },\n     { \"wallet\",             \"listsinceblock\",                   &listsinceblock,                {\"blockhash\",\"target_confirmations\",\"include_watchonly\",\"include_removed\"} },\n-    { \"wallet\",             \"listtransactions\",                 &listtransactions,              {\"dummy\",\"count\",\"skip\",\"include_watchonly\"} },\n+    { \"wallet\",             \"listtransactions\",                 &listtransactions,              {\"label|dummy\",\"count\",\"skip\",\"include_watchonly\"} },\n     { \"wallet\",             \"listunspent\",                      &listunspent,                   {\"minconf\",\"maxconf\",\"addresses\",\"include_unsafe\",\"query_options\"} },\n     { \"wallet\",             \"listwalletdir\",                    &listwalletdir,                 {} },\n     { \"wallet\",             \"listwallets\",                      &listwallets,                   {} },"
      },
      {
        "sha": "abd7750874632beb6dd179ae0a3ab72c4c682e6a",
        "filename": "src/wallet/rpcwallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/rpcwallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/rpcwallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -30,5 +30,5 @@ bool EnsureWalletIsAvailable(CWallet *, bool avoidException);\n \n UniValue getaddressinfo(const JSONRPCRequest& request);\n UniValue signrawtransactionwithwallet(const JSONRPCRequest& request);\n-bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type = 1, bool sign = true, bool bip32derivs = false);\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, int sighash_type = 1 /* SIGHASH_ALL */, bool sign = true, bool bip32derivs = false);\n #endif //BITCOIN_WALLET_RPCWALLET_H"
      },
      {
        "sha": "5c65acf6019e5066227070c2303ab752a6a09aef",
        "filename": "src/wallet/test/coinselector_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/test/coinselector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/test/coinselector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/coinselector_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -28,7 +28,8 @@ std::vector<std::unique_ptr<CWalletTx>> wtxn;\n typedef std::set<CInputCoin> CoinSet;\n \n static std::vector<COutput> vCoins;\n-static CWallet testWallet(\"dummy\", WalletDatabase::CreateDummy());\n+static auto testChain = interfaces::MakeChain();\n+static CWallet testWallet(*testChain, WalletLocation(), WalletDatabase::CreateDummy());\n static CAmount balance = 0;\n \n CoinEligibilityFilter filter_standard(1, 6, 0);"
      },
      {
        "sha": "3b828d57f928147b7f16fa58d8a76f1bc898f9d9",
        "filename": "src/wallet/test/init_test_fixture.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/test/init_test_fixture.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/test/init_test_fixture.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/init_test_fixture.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -8,6 +8,8 @@\n \n InitWalletDirTestingSetup::InitWalletDirTestingSetup(const std::string& chainName): BasicTestingSetup(chainName)\n {\n+    m_chain_client = MakeWalletClient(*m_chain, {});\n+\n     std::string sep;\n     sep += fs::path::preferred_separator;\n "
      },
      {
        "sha": "cd47b31da11c9676c5859d810918b478f0e1e144",
        "filename": "src/wallet/test/init_test_fixture.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/test/init_test_fixture.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/test/init_test_fixture.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/init_test_fixture.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -5,6 +5,7 @@\n #ifndef BITCOIN_WALLET_TEST_INIT_TEST_FIXTURE_H\n #define BITCOIN_WALLET_TEST_INIT_TEST_FIXTURE_H\n \n+#include <interfaces/chain.h>\n #include <test/test_bitcoin.h>\n \n \n@@ -16,6 +17,8 @@ struct InitWalletDirTestingSetup: public BasicTestingSetup {\n     fs::path m_datadir;\n     fs::path m_cwd;\n     std::map<std::string, fs::path> m_walletdir_path_cases;\n+    std::unique_ptr<interfaces::Chain> m_chain = interfaces::MakeChain();\n+    std::unique_ptr<interfaces::ChainClient> m_chain_client;\n };\n \n #endif // BITCOIN_WALLET_TEST_INIT_TEST_FIXTURE_H"
      },
      {
        "sha": "5852d3ef84172fc4bd072463acc82352fe1e4fdf",
        "filename": "src/wallet/test/init_tests.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/test/init_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/test/init_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/init_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -17,7 +17,7 @@ BOOST_FIXTURE_TEST_SUITE(init_tests, InitWalletDirTestingSetup)\n BOOST_AUTO_TEST_CASE(walletinit_verify_walletdir_default)\n {\n     SetWalletDir(m_walletdir_path_cases[\"default\"]);\n-    bool result = g_wallet_init_interface.Verify();\n+    bool result = m_chain_client->verify();\n     BOOST_CHECK(result == true);\n     fs::path walletdir = gArgs.GetArg(\"-walletdir\", \"\");\n     fs::path expected_path = fs::canonical(m_walletdir_path_cases[\"default\"]);\n@@ -27,7 +27,7 @@ BOOST_AUTO_TEST_CASE(walletinit_verify_walletdir_default)\n BOOST_AUTO_TEST_CASE(walletinit_verify_walletdir_custom)\n {\n     SetWalletDir(m_walletdir_path_cases[\"custom\"]);\n-    bool result = g_wallet_init_interface.Verify();\n+    bool result = m_chain_client->verify();\n     BOOST_CHECK(result == true);\n     fs::path walletdir = gArgs.GetArg(\"-walletdir\", \"\");\n     fs::path expected_path = fs::canonical(m_walletdir_path_cases[\"custom\"]);\n@@ -37,28 +37,28 @@ BOOST_AUTO_TEST_CASE(walletinit_verify_walletdir_custom)\n BOOST_AUTO_TEST_CASE(walletinit_verify_walletdir_does_not_exist)\n {\n     SetWalletDir(m_walletdir_path_cases[\"nonexistent\"]);\n-    bool result = g_wallet_init_interface.Verify();\n+    bool result = m_chain_client->verify();\n     BOOST_CHECK(result == false);\n }\n \n BOOST_AUTO_TEST_CASE(walletinit_verify_walletdir_is_not_directory)\n {\n     SetWalletDir(m_walletdir_path_cases[\"file\"]);\n-    bool result = g_wallet_init_interface.Verify();\n+    bool result = m_chain_client->verify();\n     BOOST_CHECK(result == false);\n }\n \n BOOST_AUTO_TEST_CASE(walletinit_verify_walletdir_is_not_relative)\n {\n     SetWalletDir(m_walletdir_path_cases[\"relative\"]);\n-    bool result = g_wallet_init_interface.Verify();\n+    bool result = m_chain_client->verify();\n     BOOST_CHECK(result == false);\n }\n \n BOOST_AUTO_TEST_CASE(walletinit_verify_walletdir_no_trailing)\n {\n     SetWalletDir(m_walletdir_path_cases[\"trailing\"]);\n-    bool result = g_wallet_init_interface.Verify();\n+    bool result = m_chain_client->verify();\n     BOOST_CHECK(result == true);\n     fs::path walletdir = gArgs.GetArg(\"-walletdir\", \"\");\n     fs::path expected_path = fs::canonical(m_walletdir_path_cases[\"default\"]);\n@@ -68,7 +68,7 @@ BOOST_AUTO_TEST_CASE(walletinit_verify_walletdir_no_trailing)\n BOOST_AUTO_TEST_CASE(walletinit_verify_walletdir_no_trailing2)\n {\n     SetWalletDir(m_walletdir_path_cases[\"trailing2\"]);\n-    bool result = g_wallet_init_interface.Verify();\n+    bool result = m_chain_client->verify();\n     BOOST_CHECK(result == true);\n     fs::path walletdir = gArgs.GetArg(\"-walletdir\", \"\");\n     fs::path expected_path = fs::canonical(m_walletdir_path_cases[\"default\"]);"
      },
      {
        "sha": "9918eeb89fc5af14c830acdd3cde29785cfbef77",
        "filename": "src/wallet/test/psbt_wallet_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 6,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/test/psbt_wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/test/psbt_wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/psbt_wallet_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -4,7 +4,7 @@\n \n #include <key_io.h>\n #include <script/sign.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n #include <wallet/rpcwallet.h>\n #include <wallet/wallet.h>\n #include <univalue.h>\n@@ -17,6 +17,8 @@ BOOST_FIXTURE_TEST_SUITE(psbt_wallet_tests, WalletTestingSetup)\n \n BOOST_AUTO_TEST_CASE(psbt_updater_test)\n {\n+    LOCK(m_wallet.cs_wallet);\n+\n     // Create prevtxs and add to wallet\n     CDataStream s_prev_tx1(ParseHex(\"0200000000010158e87a21b56daf0c23be8e7070456c336f7cbaa5c8757924f545887bb2abdd7501000000171600145f275f436b09a8cc9a2eb2a2f528485c68a56323feffffff02d8231f1b0100000017a914aed962d6654f9a2b36608eb9d64d2b260db4f1118700c2eb0b0000000017a914b7f5faf40e3d40a5a459b1db3535f2b72fa921e88702483045022100a22edcc6e5bc511af4cc4ae0de0fcd75c7e04d8c1c3a8aa9d820ed4b967384ec02200642963597b9b1bc22c75e9f3e117284a962188bf5e8a74c895089046a20ad770121035509a48eb623e10aace8bfd0212fdb8a8e5af3c94b0b133b95e114cab89e4f7965000000\"), SER_NETWORK, PROTOCOL_VERSION);\n     CTransactionRef prev_tx1;\n@@ -57,12 +59,8 @@ BOOST_AUTO_TEST_CASE(psbt_updater_test)\n     CDataStream ssData(ParseHex(\"70736274ff01009a020000000258e87a21b56daf0c23be8e7070456c336f7cbaa5c8757924f545887bb2abdd750000000000ffffffff838d0427d0ec650a68aa46bb0b098aea4422c071b2ca78352a077959d07cea1d0100000000ffffffff0270aaf00800000000160014d85c2b71d0060b09c9886aeb815e50991dda124d00e1f5050000000016001400aea9a2e5f0f876a588df5546e8742d1d87008f000000000000000000\"), SER_NETWORK, PROTOCOL_VERSION);\n     ssData >> psbtx;\n \n-    // Use CTransaction for the constant parts of the\n-    // transaction to avoid rehashing.\n-    const CTransaction txConst(*psbtx.tx);\n-\n     // Fill transaction with our data\n-    FillPSBT(&m_wallet, psbtx, &txConst, 1, false, true);\n+    FillPSBT(&m_wallet, psbtx, SIGHASH_ALL, false, true);\n \n     // Get the final tx\n     CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);"
      },
      {
        "sha": "ae7092fa898dc3873eb4f49f86138174053fa98d",
        "filename": "src/wallet/test/wallet_crypto_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/test/wallet_crypto_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/test/wallet_crypto_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_crypto_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -3,7 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <test/test_bitcoin.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n #include <wallet/crypter.h>\n \n #include <vector>"
      },
      {
        "sha": "a5fb1db86c428ae58956b6fabdcbdc8e798a813f",
        "filename": "src/wallet/test/wallet_test_fixture.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/test/wallet_test_fixture.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/test/wallet_test_fixture.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_test_fixture.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -6,9 +6,10 @@\n \n #include <rpc/server.h>\n #include <wallet/db.h>\n+#include <wallet/rpcwallet.h>\n \n WalletTestingSetup::WalletTestingSetup(const std::string& chainName):\n-    TestingSetup(chainName), m_wallet(\"mock\", WalletDatabase::CreateMock())\n+    TestingSetup(chainName), m_wallet(*m_chain, WalletLocation(), WalletDatabase::CreateMock())\n {\n     bool fFirstRun;\n     m_wallet.LoadWallet(fFirstRun);"
      },
      {
        "sha": "e6fe8c94735c13fdad1fdff1a1463e964b910599",
        "filename": "src/wallet/test/wallet_test_fixture.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/test/wallet_test_fixture.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/test/wallet_test_fixture.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_test_fixture.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -7,6 +7,8 @@\n \n #include <test/test_bitcoin.h>\n \n+#include <interfaces/chain.h>\n+#include <interfaces/wallet.h>\n #include <wallet/wallet.h>\n \n #include <memory>\n@@ -17,6 +19,7 @@ struct WalletTestingSetup: public TestingSetup {\n     explicit WalletTestingSetup(const std::string& chainName = CBaseChainParams::MAIN);\n     ~WalletTestingSetup();\n \n+    std::unique_ptr<interfaces::Chain> m_chain = interfaces::MakeChain();\n     CWallet m_wallet;\n };\n "
      },
      {
        "sha": "c6aac8aad5666df1fc24ca74cb12f19a5a649abb",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 20,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -11,6 +11,7 @@\n #include <vector>\n \n #include <consensus/validation.h>\n+#include <interfaces/chain.h>\n #include <rpc/server.h>\n #include <test/test_bitcoin.h>\n #include <validation.h>\n@@ -34,19 +35,21 @@ static void AddKey(CWallet& wallet, const CKey& key)\n \n BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n {\n+    auto chain = interfaces::MakeChain();\n+\n     // Cap last block file size, and mine new block in a new block file.\n     CBlockIndex* const nullBlock = nullptr;\n     CBlockIndex* oldTip = chainActive.Tip();\n     GetBlockFileInfo(oldTip->GetBlockPos().nFile)->nSize = MAX_BLOCKFILE_SIZE;\n     CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey()));\n     CBlockIndex* newTip = chainActive.Tip();\n \n-    LOCK(cs_main);\n+    auto locked_chain = chain->lock();\n \n     // Verify ScanForWalletTransactions picks up transactions in both the old\n     // and new block files.\n     {\n-        CWallet wallet(\"dummy\", WalletDatabase::CreateDummy());\n+        CWallet wallet(*chain, WalletLocation(), WalletDatabase::CreateDummy());\n         AddKey(wallet, coinbaseKey);\n         WalletRescanReserver reserver(&wallet);\n         reserver.reserve();\n@@ -61,7 +64,7 @@ BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n     // Verify ScanForWalletTransactions only picks transactions in the new block\n     // file.\n     {\n-        CWallet wallet(\"dummy\", WalletDatabase::CreateDummy());\n+        CWallet wallet(*chain, WalletLocation(), WalletDatabase::CreateDummy());\n         AddKey(wallet, coinbaseKey);\n         WalletRescanReserver reserver(&wallet);\n         reserver.reserve();\n@@ -73,7 +76,7 @@ BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n     // before the missing block, and success for a key whose creation time is\n     // after.\n     {\n-        std::shared_ptr<CWallet> wallet = std::make_shared<CWallet>(\"dummy\", WalletDatabase::CreateDummy());\n+        std::shared_ptr<CWallet> wallet = std::make_shared<CWallet>(*chain, WalletLocation(), WalletDatabase::CreateDummy());\n         AddWallet(wallet);\n         UniValue keys;\n         keys.setArray();\n@@ -115,6 +118,8 @@ BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n // than or equal to key birthday.\n BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n {\n+    auto chain = interfaces::MakeChain();\n+\n     // Create two blocks with same timestamp to verify that importwallet rescan\n     // will pick up both blocks, not just the first.\n     const int64_t BLOCK_TIME = chainActive.Tip()->GetBlockTimeMax() + 5;\n@@ -128,13 +133,13 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n     SetMockTime(KEY_TIME);\n     m_coinbase_txns.emplace_back(CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey())).vtx[0]);\n \n-    LOCK(cs_main);\n+    auto locked_chain = chain->lock();\n \n     std::string backup_file = (SetDataDir(\"importwallet_rescan\") / \"wallet.backup\").string();\n \n     // Import key into wallet and call dumpwallet to create backup file.\n     {\n-        std::shared_ptr<CWallet> wallet = std::make_shared<CWallet>(\"dummy\", WalletDatabase::CreateDummy());\n+        std::shared_ptr<CWallet> wallet = std::make_shared<CWallet>(*chain, WalletLocation(), WalletDatabase::CreateDummy());\n         LOCK(wallet->cs_wallet);\n         wallet->mapKeyMetadata[coinbaseKey.GetPubKey().GetID()].nCreateTime = KEY_TIME;\n         wallet->AddKeyPubKey(coinbaseKey, coinbaseKey.GetPubKey());\n@@ -150,7 +155,7 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n     // Call importwallet RPC and verify all blocks with timestamps >= BLOCK_TIME\n     // were scanned, and no prior blocks were scanned.\n     {\n-        std::shared_ptr<CWallet> wallet = std::make_shared<CWallet>(\"dummy\", WalletDatabase::CreateDummy());\n+        std::shared_ptr<CWallet> wallet = std::make_shared<CWallet>(*chain, WalletLocation(), WalletDatabase::CreateDummy());\n \n         JSONRPCRequest request;\n         request.params.setArray();\n@@ -180,21 +185,23 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n // debit functions.\n BOOST_FIXTURE_TEST_CASE(coin_mark_dirty_immature_credit, TestChain100Setup)\n {\n-    CWallet wallet(\"dummy\", WalletDatabase::CreateDummy());\n+    auto chain = interfaces::MakeChain();\n+    CWallet wallet(*chain, WalletLocation(), WalletDatabase::CreateDummy());\n     CWalletTx wtx(&wallet, m_coinbase_txns.back());\n-    LOCK2(cs_main, wallet.cs_wallet);\n+    auto locked_chain = chain->lock();\n+    LOCK(wallet.cs_wallet);\n     wtx.hashBlock = chainActive.Tip()->GetBlockHash();\n     wtx.nIndex = 0;\n \n     // Call GetImmatureCredit() once before adding the key to the wallet to\n     // cache the current immature credit amount, which is 0.\n-    BOOST_CHECK_EQUAL(wtx.GetImmatureCredit(), 0);\n+    BOOST_CHECK_EQUAL(wtx.GetImmatureCredit(*locked_chain), 0);\n \n     // Invalidate the cached value, add the key, and make sure a new immature\n     // credit amount is calculated.\n     wtx.MarkDirty();\n     wallet.AddKeyPubKey(coinbaseKey, coinbaseKey.GetPubKey());\n-    BOOST_CHECK_EQUAL(wtx.GetImmatureCredit(), 50*COIN);\n+    BOOST_CHECK_EQUAL(wtx.GetImmatureCredit(*locked_chain), 50*COIN);\n }\n \n static int64_t AddTx(CWallet& wallet, uint32_t lockTime, int64_t mockTime, int64_t blockTime)\n@@ -204,7 +211,7 @@ static int64_t AddTx(CWallet& wallet, uint32_t lockTime, int64_t mockTime, int64\n     SetMockTime(mockTime);\n     CBlockIndex* block = nullptr;\n     if (blockTime > 0) {\n-        LOCK(cs_main);\n+        auto locked_chain = wallet.chain().lock();\n         auto inserted = mapBlockIndex.emplace(GetRandHash(), new CBlockIndex);\n         assert(inserted.second);\n         const uint256& hash = inserted.first->first;\n@@ -273,7 +280,7 @@ class ListCoinsTestingSetup : public TestChain100Setup\n     ListCoinsTestingSetup()\n     {\n         CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey()));\n-        wallet = MakeUnique<CWallet>(\"mock\", WalletDatabase::CreateMock());\n+        wallet = MakeUnique<CWallet>(*m_chain, WalletLocation(), WalletDatabase::CreateMock());\n         bool firstRun;\n         wallet->LoadWallet(firstRun);\n         AddKey(*wallet, coinbaseKey);\n@@ -295,7 +302,7 @@ class ListCoinsTestingSetup : public TestChain100Setup\n         int changePos = -1;\n         std::string error;\n         CCoinControl dummy;\n-        BOOST_CHECK(wallet->CreateTransaction({recipient}, tx, reservekey, fee, changePos, error, dummy));\n+        BOOST_CHECK(wallet->CreateTransaction(*m_locked_chain, {recipient}, tx, reservekey, fee, changePos, error, dummy));\n         CValidationState state;\n         BOOST_CHECK(wallet->CommitTransaction(tx, {}, {}, reservekey, nullptr, state));\n         CMutableTransaction blocktx;\n@@ -311,6 +318,8 @@ class ListCoinsTestingSetup : public TestChain100Setup\n         return it->second;\n     }\n \n+    std::unique_ptr<interfaces::Chain> m_chain = interfaces::MakeChain();\n+    std::unique_ptr<interfaces::Chain::Lock> m_locked_chain = m_chain->assumeLocked();  // Temporary. Removed in upcoming lock cleanup\n     std::unique_ptr<CWallet> wallet;\n };\n \n@@ -323,7 +332,7 @@ BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n     std::map<CTxDestination, std::vector<COutput>> list;\n     {\n         LOCK2(cs_main, wallet->cs_wallet);\n-        list = wallet->ListCoins();\n+        list = wallet->ListCoins(*m_locked_chain);\n     }\n     BOOST_CHECK_EQUAL(list.size(), 1U);\n     BOOST_CHECK_EQUAL(boost::get<CKeyID>(list.begin()->first).ToString(), coinbaseAddress);\n@@ -339,7 +348,7 @@ BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n     AddTx(CRecipient{GetScriptForRawPubKey({}), 1 * COIN, false /* subtract fee */});\n     {\n         LOCK2(cs_main, wallet->cs_wallet);\n-        list = wallet->ListCoins();\n+        list = wallet->ListCoins(*m_locked_chain);\n     }\n     BOOST_CHECK_EQUAL(list.size(), 1U);\n     BOOST_CHECK_EQUAL(boost::get<CKeyID>(list.begin()->first).ToString(), coinbaseAddress);\n@@ -349,7 +358,7 @@ BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n     {\n         LOCK2(cs_main, wallet->cs_wallet);\n         std::vector<COutput> available;\n-        wallet->AvailableCoins(available);\n+        wallet->AvailableCoins(*m_locked_chain, available);\n         BOOST_CHECK_EQUAL(available.size(), 2U);\n     }\n     for (const auto& group : list) {\n@@ -361,14 +370,14 @@ BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n     {\n         LOCK2(cs_main, wallet->cs_wallet);\n         std::vector<COutput> available;\n-        wallet->AvailableCoins(available);\n+        wallet->AvailableCoins(*m_locked_chain, available);\n         BOOST_CHECK_EQUAL(available.size(), 0U);\n     }\n     // Confirm ListCoins still returns same result as before, despite coins\n     // being locked.\n     {\n         LOCK2(cs_main, wallet->cs_wallet);\n-        list = wallet->ListCoins();\n+        list = wallet->ListCoins(*m_locked_chain);\n     }\n     BOOST_CHECK_EQUAL(list.size(), 1U);\n     BOOST_CHECK_EQUAL(boost::get<CKeyID>(list.begin()->first).ToString(), coinbaseAddress);\n@@ -377,7 +386,8 @@ BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n \n BOOST_FIXTURE_TEST_CASE(wallet_disableprivkeys, TestChain100Setup)\n {\n-    std::shared_ptr<CWallet> wallet = std::make_shared<CWallet>(\"dummy\", WalletDatabase::CreateDummy());\n+    auto chain = interfaces::MakeChain();\n+    std::shared_ptr<CWallet> wallet = std::make_shared<CWallet>(*chain, WalletLocation(), WalletDatabase::CreateDummy());\n     wallet->SetWalletFlag(WALLET_FLAG_DISABLE_PRIVATE_KEYS);\n     BOOST_CHECK(!wallet->TopUpKeyPool(1000));\n     CPubKey pubkey;"
      },
      {
        "sha": "8ea4c5c4957d1456ace2252780e756997ff49aeb",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 135,
        "deletions": 103,
        "changes": 238,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -11,6 +11,7 @@\n #include <consensus/consensus.h>\n #include <consensus/validation.h>\n #include <fs.h>\n+#include <interfaces/chain.h>\n #include <key.h>\n #include <key_io.h>\n #include <keystore.h>\n@@ -25,9 +26,8 @@\n #include <shutdown.h>\n #include <timedata.h>\n #include <txmempool.h>\n-#include <utilmoneystr.h>\n+#include <util/moneystr.h>\n #include <wallet/fees.h>\n-#include <wallet/walletutil.h>\n \n #include <algorithm>\n #include <assert.h>\n@@ -594,7 +594,7 @@ void CWallet::SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator> ran\n  * Outpoint is spent if any non-conflicted transaction\n  * spends it:\n  */\n-bool CWallet::IsSpent(const uint256& hash, unsigned int n) const\n+bool CWallet::IsSpent(interfaces::Chain::Lock& locked_chain, const uint256& hash, unsigned int n) const\n {\n     const COutPoint outpoint(hash, n);\n     std::pair<TxSpends::const_iterator, TxSpends::const_iterator> range;\n@@ -605,7 +605,7 @@ bool CWallet::IsSpent(const uint256& hash, unsigned int n) const\n         const uint256& wtxid = it->second;\n         std::map<uint256, CWalletTx>::const_iterator mit = mapWallet.find(wtxid);\n         if (mit != mapWallet.end()) {\n-            int depth = mit->second.GetDepthInMainChain();\n+            int depth = mit->second.GetDepthInMainChain(locked_chain);\n             if (depth > 0  || (depth == 0 && !mit->second.isAbandoned()))\n                 return true; // Spent\n         }\n@@ -1006,9 +1006,10 @@ bool CWallet::AddToWalletIfInvolvingMe(const CTransactionRef& ptx, const CBlockI\n \n bool CWallet::TransactionCanBeAbandoned(const uint256& hashTx) const\n {\n-    LOCK2(cs_main, cs_wallet);\n+    auto locked_chain = chain().lock();\n+    LOCK(cs_wallet);\n     const CWalletTx* wtx = GetWalletTx(hashTx);\n-    return wtx && !wtx->isAbandoned() && wtx->GetDepthInMainChain() == 0 && !wtx->InMempool();\n+    return wtx && !wtx->isAbandoned() && wtx->GetDepthInMainChain(*locked_chain) == 0 && !wtx->InMempool();\n }\n \n void CWallet::MarkInputsDirty(const CTransactionRef& tx)\n@@ -1021,9 +1022,10 @@ void CWallet::MarkInputsDirty(const CTransactionRef& tx)\n     }\n }\n \n-bool CWallet::AbandonTransaction(const uint256& hashTx)\n+bool CWallet::AbandonTransaction(interfaces::Chain::Lock& locked_chain, const uint256& hashTx)\n {\n-    LOCK2(cs_main, cs_wallet);\n+    auto locked_chain_recursive = chain().lock();  // Temporary. Removed in upcoming lock cleanup\n+    LOCK(cs_wallet);\n \n     WalletBatch batch(*database, \"r+\");\n \n@@ -1034,7 +1036,7 @@ bool CWallet::AbandonTransaction(const uint256& hashTx)\n     auto it = mapWallet.find(hashTx);\n     assert(it != mapWallet.end());\n     CWalletTx& origtx = it->second;\n-    if (origtx.GetDepthInMainChain() != 0 || origtx.InMempool()) {\n+    if (origtx.GetDepthInMainChain(locked_chain) != 0 || origtx.InMempool()) {\n         return false;\n     }\n \n@@ -1047,7 +1049,7 @@ bool CWallet::AbandonTransaction(const uint256& hashTx)\n         auto it = mapWallet.find(now);\n         assert(it != mapWallet.end());\n         CWalletTx& wtx = it->second;\n-        int currentconfirm = wtx.GetDepthInMainChain();\n+        int currentconfirm = wtx.GetDepthInMainChain(locked_chain);\n         // If the orig tx was not in block, none of its spends can be\n         assert(currentconfirm <= 0);\n         // if (currentconfirm < 0) {Tx and spends are already conflicted, no need to abandon}\n@@ -1078,7 +1080,8 @@ bool CWallet::AbandonTransaction(const uint256& hashTx)\n \n void CWallet::MarkConflicted(const uint256& hashBlock, const uint256& hashTx)\n {\n-    LOCK2(cs_main, cs_wallet);\n+    auto locked_chain = chain().lock();\n+    LOCK(cs_wallet);\n \n     int conflictconfirms = 0;\n     CBlockIndex* pindex = LookupBlockIndex(hashBlock);\n@@ -1107,7 +1110,7 @@ void CWallet::MarkConflicted(const uint256& hashBlock, const uint256& hashTx)\n         auto it = mapWallet.find(now);\n         assert(it != mapWallet.end());\n         CWalletTx& wtx = it->second;\n-        int currentconfirm = wtx.GetDepthInMainChain();\n+        int currentconfirm = wtx.GetDepthInMainChain(*locked_chain);\n         if (conflictconfirms < currentconfirm) {\n             // Block is 'more conflicted' than current confirm; update.\n             // Mark transaction as conflicted with this block.\n@@ -1141,7 +1144,8 @@ void CWallet::SyncTransaction(const CTransactionRef& ptx, const CBlockIndex *pin\n }\n \n void CWallet::TransactionAddedToMempool(const CTransactionRef& ptx) {\n-    LOCK2(cs_main, cs_wallet);\n+    auto locked_chain = chain().lock();\n+    LOCK(cs_wallet);\n     SyncTransaction(ptx);\n \n     auto it = mapWallet.find(ptx->GetHash());\n@@ -1159,7 +1163,8 @@ void CWallet::TransactionRemovedFromMempool(const CTransactionRef &ptx) {\n }\n \n void CWallet::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex *pindex, const std::vector<CTransactionRef>& vtxConflicted) {\n-    LOCK2(cs_main, cs_wallet);\n+    auto locked_chain = chain().lock();\n+    LOCK(cs_wallet);\n     // TODO: Temporarily ensure that mempool removals are notified before\n     // connected transactions.  This shouldn't matter, but the abandoned\n     // state of transactions in our wallet is currently cleared when we\n@@ -1181,7 +1186,8 @@ void CWallet::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const\n }\n \n void CWallet::BlockDisconnected(const std::shared_ptr<const CBlock>& pblock) {\n-    LOCK2(cs_main, cs_wallet);\n+    auto locked_chain = chain().lock();\n+    LOCK(cs_wallet);\n \n     for (const CTransactionRef& ptx : pblock->vtx) {\n         SyncTransaction(ptx);\n@@ -1200,7 +1206,7 @@ void CWallet::BlockUntilSyncedToCurrentChain() {\n         // We could also take cs_wallet here, and call m_last_block_processed\n         // protected by cs_wallet instead of cs_main, but as long as we need\n         // cs_main here anyway, it's easier to just call it cs_main-protected.\n-        LOCK(cs_main);\n+        auto locked_chain = chain().lock();\n         const CBlockIndex* initialChainTip = chainActive.Tip();\n \n         if (m_last_block_processed && m_last_block_processed->GetAncestor(initialChainTip->nHeight) == initialChainTip) {\n@@ -1261,6 +1267,11 @@ CAmount CWallet::GetCredit(const CTxOut& txout, const isminefilter& filter) cons\n }\n \n bool CWallet::IsChange(const CTxOut& txout) const\n+{\n+    return IsChange(txout.scriptPubKey);\n+}\n+\n+bool CWallet::IsChange(const CScript& script) const\n {\n     // TODO: fix handling of 'change' outputs. The assumption is that any\n     // payment to a script that is ours, but is not in the address book\n@@ -1269,10 +1280,10 @@ bool CWallet::IsChange(const CTxOut& txout) const\n     // a better way of identifying which outputs are 'the send' and which are\n     // 'the change' will need to be implemented (maybe extend CWalletTx to remember\n     // which output, if any, was change).\n-    if (::IsMine(*this, txout.scriptPubKey))\n+    if (::IsMine(*this, script))\n     {\n         CTxDestination address;\n-        if (!ExtractDestination(txout.scriptPubKey, address))\n+        if (!ExtractDestination(script, address))\n             return true;\n \n         LOCK(cs_wallet);\n@@ -1596,7 +1607,7 @@ int64_t CWallet::RescanFromTime(int64_t startTime, const WalletRescanReserver& r\n     // to be scanned.\n     CBlockIndex* startBlock = nullptr;\n     {\n-        LOCK(cs_main);\n+        auto locked_chain = chain().lock();\n         startBlock = chainActive.FindEarliestAtLeast(startTime - TIMESTAMP_WINDOW);\n         WalletLogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, startBlock ? chainActive.Height() - startBlock->nHeight + 1 : 0);\n     }\n@@ -1648,7 +1659,7 @@ CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, CBlock\n         double progress_begin;\n         double progress_end;\n         {\n-            LOCK(cs_main);\n+            auto locked_chain = chain().lock();\n             progress_begin = GuessVerificationProgress(chainParams.TxData(), pindex);\n             if (pindexStop == nullptr) {\n                 tip = chainActive.Tip();\n@@ -1670,7 +1681,8 @@ CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, CBlock\n \n             CBlock block;\n             if (ReadBlockFromDisk(block, pindex, Params().GetConsensus())) {\n-                LOCK2(cs_main, cs_wallet);\n+                auto locked_chain = chain().lock();\n+                LOCK(cs_wallet);\n                 if (pindex && !chainActive.Contains(pindex)) {\n                     // Abort scan if current block is no longer active, to prevent\n                     // marking transactions as coming from the wrong block.\n@@ -1687,7 +1699,7 @@ CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, CBlock\n                 break;\n             }\n             {\n-                LOCK(cs_main);\n+                auto locked_chain = chain().lock();\n                 pindex = chainActive.Next(pindex);\n                 progress_current = GuessVerificationProgress(chainParams.TxData(), pindex);\n                 if (pindexStop == nullptr && tip != chainActive.Tip()) {\n@@ -1712,7 +1724,8 @@ void CWallet::ReacceptWalletTransactions()\n     // If transactions aren't being broadcasted, don't let them into local mempool either\n     if (!fBroadcastTransactions)\n         return;\n-    LOCK2(cs_main, cs_wallet);\n+    auto locked_chain = chain().lock();\n+    LOCK(cs_wallet);\n     std::map<int64_t, CWalletTx*> mapSorted;\n \n     // Sort pending wallet transactions based on their initial wallet insertion order\n@@ -1722,7 +1735,7 @@ void CWallet::ReacceptWalletTransactions()\n         CWalletTx& wtx = item.second;\n         assert(wtx.GetHash() == wtxid);\n \n-        int nDepth = wtx.GetDepthInMainChain();\n+        int nDepth = wtx.GetDepthInMainChain(*locked_chain);\n \n         if (!wtx.IsCoinBase() && (nDepth == 0 && !wtx.isAbandoned())) {\n             mapSorted.insert(std::make_pair(wtx.nOrderPos, &wtx));\n@@ -1733,18 +1746,18 @@ void CWallet::ReacceptWalletTransactions()\n     for (const std::pair<const int64_t, CWalletTx*>& item : mapSorted) {\n         CWalletTx& wtx = *(item.second);\n         CValidationState state;\n-        wtx.AcceptToMemoryPool(maxTxFee, state);\n+        wtx.AcceptToMemoryPool(*locked_chain, maxTxFee, state);\n     }\n }\n \n-bool CWalletTx::RelayWalletTransaction(CConnman* connman)\n+bool CWalletTx::RelayWalletTransaction(interfaces::Chain::Lock& locked_chain, CConnman* connman)\n {\n     assert(pwallet->GetBroadcastTransactions());\n-    if (!IsCoinBase() && !isAbandoned() && GetDepthInMainChain() == 0)\n+    if (!IsCoinBase() && !isAbandoned() && GetDepthInMainChain(locked_chain) == 0)\n     {\n         CValidationState state;\n         /* GetDepthInMainChain already catches known conflicts. */\n-        if (InMempool() || AcceptToMemoryPool(maxTxFee, state)) {\n+        if (InMempool() || AcceptToMemoryPool(locked_chain, maxTxFee, state)) {\n             pwallet->WalletLogPrintf(\"Relaying wtx %s\\n\", GetHash().ToString());\n             if (connman) {\n                 CInv inv(MSG_TX, GetHash());\n@@ -1802,10 +1815,10 @@ CAmount CWalletTx::GetDebit(const isminefilter& filter) const\n     return debit;\n }\n \n-CAmount CWalletTx::GetCredit(const isminefilter& filter) const\n+CAmount CWalletTx::GetCredit(interfaces::Chain::Lock& locked_chain, const isminefilter& filter) const\n {\n     // Must wait until coinbase is safely deep enough in the chain before valuing it\n-    if (IsImmatureCoinBase())\n+    if (IsImmatureCoinBase(locked_chain))\n         return 0;\n \n     CAmount credit = 0;\n@@ -1835,9 +1848,9 @@ CAmount CWalletTx::GetCredit(const isminefilter& filter) const\n     return credit;\n }\n \n-CAmount CWalletTx::GetImmatureCredit(bool fUseCache) const\n+CAmount CWalletTx::GetImmatureCredit(interfaces::Chain::Lock& locked_chain, bool fUseCache) const\n {\n-    if (IsImmatureCoinBase() && IsInMainChain()) {\n+    if (IsImmatureCoinBase(locked_chain) && IsInMainChain(locked_chain)) {\n         if (fUseCache && fImmatureCreditCached)\n             return nImmatureCreditCached;\n         nImmatureCreditCached = pwallet->GetCredit(*tx, ISMINE_SPENDABLE);\n@@ -1848,13 +1861,13 @@ CAmount CWalletTx::GetImmatureCredit(bool fUseCache) const\n     return 0;\n }\n \n-CAmount CWalletTx::GetAvailableCredit(bool fUseCache, const isminefilter& filter) const\n+CAmount CWalletTx::GetAvailableCredit(interfaces::Chain::Lock& locked_chain, bool fUseCache, const isminefilter& filter) const\n {\n     if (pwallet == nullptr)\n         return 0;\n \n     // Must wait until coinbase is safely deep enough in the chain before valuing it\n-    if (IsImmatureCoinBase())\n+    if (IsImmatureCoinBase(locked_chain))\n         return 0;\n \n     CAmount* cache = nullptr;\n@@ -1876,7 +1889,7 @@ CAmount CWalletTx::GetAvailableCredit(bool fUseCache, const isminefilter& filter\n     uint256 hashTx = GetHash();\n     for (unsigned int i = 0; i < tx->vout.size(); i++)\n     {\n-        if (!pwallet->IsSpent(hashTx, i))\n+        if (!pwallet->IsSpent(locked_chain, hashTx, i))\n         {\n             const CTxOut &txout = tx->vout[i];\n             nCredit += pwallet->GetCredit(txout, filter);\n@@ -1893,9 +1906,9 @@ CAmount CWalletTx::GetAvailableCredit(bool fUseCache, const isminefilter& filter\n     return nCredit;\n }\n \n-CAmount CWalletTx::GetImmatureWatchOnlyCredit(const bool fUseCache) const\n+CAmount CWalletTx::GetImmatureWatchOnlyCredit(interfaces::Chain::Lock& locked_chain, const bool fUseCache) const\n {\n-    if (IsImmatureCoinBase() && IsInMainChain()) {\n+    if (IsImmatureCoinBase(locked_chain) && IsInMainChain(locked_chain)) {\n         if (fUseCache && fImmatureWatchCreditCached)\n             return nImmatureWatchCreditCached;\n         nImmatureWatchCreditCached = pwallet->GetCredit(*tx, ISMINE_WATCH_ONLY);\n@@ -1920,12 +1933,14 @@ bool CWalletTx::InMempool() const\n     return fInMempool;\n }\n \n-bool CWalletTx::IsTrusted() const\n+bool CWalletTx::IsTrusted(interfaces::Chain::Lock& locked_chain) const\n {\n+    LockAnnotation lock(::cs_main); // Temporary, for CheckFinalTx below. Removed in upcoming commit.\n+\n     // Quick answer in most cases\n     if (!CheckFinalTx(*tx))\n         return false;\n-    int nDepth = GetDepthInMainChain();\n+    int nDepth = GetDepthInMainChain(locked_chain);\n     if (nDepth >= 1)\n         return true;\n     if (nDepth < 0)\n@@ -1960,7 +1975,7 @@ bool CWalletTx::IsEquivalentTo(const CWalletTx& _tx) const\n         return CTransaction(tx1) == CTransaction(tx2);\n }\n \n-std::vector<uint256> CWallet::ResendWalletTransactionsBefore(int64_t nTime, CConnman* connman)\n+std::vector<uint256> CWallet::ResendWalletTransactionsBefore(interfaces::Chain::Lock& locked_chain, int64_t nTime, CConnman* connman)\n {\n     std::vector<uint256> result;\n \n@@ -1979,7 +1994,7 @@ std::vector<uint256> CWallet::ResendWalletTransactionsBefore(int64_t nTime, CCon\n     for (const std::pair<const unsigned int, CWalletTx*>& item : mapSorted)\n     {\n         CWalletTx& wtx = *item.second;\n-        if (wtx.RelayWalletTransaction(connman))\n+        if (wtx.RelayWalletTransaction(locked_chain, connman))\n             result.push_back(wtx.GetHash());\n     }\n     return result;\n@@ -2003,7 +2018,8 @@ void CWallet::ResendWalletTransactions(int64_t nBestBlockTime, CConnman* connman\n \n     // Rebroadcast unconfirmed txes older than 5 minutes before the last\n     // block was found:\n-    std::vector<uint256> relayed = ResendWalletTransactionsBefore(nBestBlockTime-5*60, connman);\n+    auto locked_chain = chain().assumeLocked();  // Temporary. Removed in upcoming lock cleanup\n+    std::vector<uint256> relayed = ResendWalletTransactionsBefore(*locked_chain, nBestBlockTime-5*60, connman);\n     if (!relayed.empty())\n         WalletLogPrintf(\"%s: rebroadcast %u unconfirmed transactions\\n\", __func__, relayed.size());\n }\n@@ -2023,12 +2039,13 @@ CAmount CWallet::GetBalance(const isminefilter& filter, const int min_depth) con\n {\n     CAmount nTotal = 0;\n     {\n-        LOCK2(cs_main, cs_wallet);\n+        auto locked_chain = chain().lock();\n+        LOCK(cs_wallet);\n         for (const auto& entry : mapWallet)\n         {\n             const CWalletTx* pcoin = &entry.second;\n-            if (pcoin->IsTrusted() && pcoin->GetDepthInMainChain() >= min_depth) {\n-                nTotal += pcoin->GetAvailableCredit(true, filter);\n+            if (pcoin->IsTrusted(*locked_chain) && pcoin->GetDepthInMainChain(*locked_chain) >= min_depth) {\n+                nTotal += pcoin->GetAvailableCredit(*locked_chain, true, filter);\n             }\n         }\n     }\n@@ -2040,12 +2057,13 @@ CAmount CWallet::GetUnconfirmedBalance() const\n {\n     CAmount nTotal = 0;\n     {\n-        LOCK2(cs_main, cs_wallet);\n+        auto locked_chain = chain().lock();\n+        LOCK(cs_wallet);\n         for (const auto& entry : mapWallet)\n         {\n             const CWalletTx* pcoin = &entry.second;\n-            if (!pcoin->IsTrusted() && pcoin->GetDepthInMainChain() == 0 && pcoin->InMempool())\n-                nTotal += pcoin->GetAvailableCredit();\n+            if (!pcoin->IsTrusted(*locked_chain) && pcoin->GetDepthInMainChain(*locked_chain) == 0 && pcoin->InMempool())\n+                nTotal += pcoin->GetAvailableCredit(*locked_chain);\n         }\n     }\n     return nTotal;\n@@ -2055,11 +2073,12 @@ CAmount CWallet::GetImmatureBalance() const\n {\n     CAmount nTotal = 0;\n     {\n-        LOCK2(cs_main, cs_wallet);\n+        auto locked_chain = chain().lock();\n+        LOCK(cs_wallet);\n         for (const auto& entry : mapWallet)\n         {\n             const CWalletTx* pcoin = &entry.second;\n-            nTotal += pcoin->GetImmatureCredit();\n+            nTotal += pcoin->GetImmatureCredit(*locked_chain);\n         }\n     }\n     return nTotal;\n@@ -2069,12 +2088,13 @@ CAmount CWallet::GetUnconfirmedWatchOnlyBalance() const\n {\n     CAmount nTotal = 0;\n     {\n-        LOCK2(cs_main, cs_wallet);\n+        auto locked_chain = chain().lock();\n+        LOCK(cs_wallet);\n         for (const auto& entry : mapWallet)\n         {\n             const CWalletTx* pcoin = &entry.second;\n-            if (!pcoin->IsTrusted() && pcoin->GetDepthInMainChain() == 0 && pcoin->InMempool())\n-                nTotal += pcoin->GetAvailableCredit(true, ISMINE_WATCH_ONLY);\n+            if (!pcoin->IsTrusted(*locked_chain) && pcoin->GetDepthInMainChain(*locked_chain) == 0 && pcoin->InMempool())\n+                nTotal += pcoin->GetAvailableCredit(*locked_chain, true, ISMINE_WATCH_ONLY);\n         }\n     }\n     return nTotal;\n@@ -2084,11 +2104,12 @@ CAmount CWallet::GetImmatureWatchOnlyBalance() const\n {\n     CAmount nTotal = 0;\n     {\n-        LOCK2(cs_main, cs_wallet);\n+        auto locked_chain = chain().lock();\n+        LOCK(cs_wallet);\n         for (const auto& entry : mapWallet)\n         {\n             const CWalletTx* pcoin = &entry.second;\n-            nTotal += pcoin->GetImmatureWatchOnlyCredit();\n+            nTotal += pcoin->GetImmatureWatchOnlyCredit(*locked_chain);\n         }\n     }\n     return nTotal;\n@@ -2102,13 +2123,15 @@ CAmount CWallet::GetImmatureWatchOnlyBalance() const\n // trusted.\n CAmount CWallet::GetLegacyBalance(const isminefilter& filter, int minDepth) const\n {\n-    LOCK2(cs_main, cs_wallet);\n+    LockAnnotation lock(::cs_main); // Temporary, for CheckFinalTx below. Removed in upcoming commit.\n+    auto locked_chain = chain().lock();\n+    LOCK(cs_wallet);\n \n     CAmount balance = 0;\n     for (const auto& entry : mapWallet) {\n         const CWalletTx& wtx = entry.second;\n-        const int depth = wtx.GetDepthInMainChain();\n-        if (depth < 0 || !CheckFinalTx(*wtx.tx) || wtx.IsImmatureCoinBase()) {\n+        const int depth = wtx.GetDepthInMainChain(*locked_chain);\n+        if (depth < 0 || !CheckFinalTx(*wtx.tx) || wtx.IsImmatureCoinBase(*locked_chain)) {\n             continue;\n         }\n \n@@ -2135,11 +2158,12 @@ CAmount CWallet::GetLegacyBalance(const isminefilter& filter, int minDepth) cons\n \n CAmount CWallet::GetAvailableBalance(const CCoinControl* coinControl) const\n {\n-    LOCK2(cs_main, cs_wallet);\n+    auto locked_chain = chain().lock();\n+    LOCK(cs_wallet);\n \n     CAmount balance = 0;\n     std::vector<COutput> vCoins;\n-    AvailableCoins(vCoins, true, coinControl);\n+    AvailableCoins(*locked_chain, vCoins, true, coinControl);\n     for (const COutput& out : vCoins) {\n         if (out.fSpendable) {\n             balance += out.tx->tx->vout[out.i].nValue;\n@@ -2148,7 +2172,7 @@ CAmount CWallet::GetAvailableBalance(const CCoinControl* coinControl) const\n     return balance;\n }\n \n-void CWallet::AvailableCoins(std::vector<COutput> &vCoins, bool fOnlySafe, const CCoinControl *coinControl, const CAmount &nMinimumAmount, const CAmount &nMaximumAmount, const CAmount &nMinimumSumAmount, const uint64_t nMaximumCount, const int nMinDepth, const int nMaxDepth) const\n+void CWallet::AvailableCoins(interfaces::Chain::Lock& locked_chain, std::vector<COutput> &vCoins, bool fOnlySafe, const CCoinControl *coinControl, const CAmount &nMinimumAmount, const CAmount &nMaximumAmount, const CAmount &nMinimumSumAmount, const uint64_t nMaximumCount, const int nMinDepth, const int nMaxDepth) const\n {\n     AssertLockHeld(cs_main);\n     AssertLockHeld(cs_wallet);\n@@ -2164,10 +2188,10 @@ void CWallet::AvailableCoins(std::vector<COutput> &vCoins, bool fOnlySafe, const\n         if (!CheckFinalTx(*pcoin->tx))\n             continue;\n \n-        if (pcoin->IsImmatureCoinBase())\n+        if (pcoin->IsImmatureCoinBase(locked_chain))\n             continue;\n \n-        int nDepth = pcoin->GetDepthInMainChain();\n+        int nDepth = pcoin->GetDepthInMainChain(locked_chain);\n         if (nDepth < 0)\n             continue;\n \n@@ -2176,7 +2200,7 @@ void CWallet::AvailableCoins(std::vector<COutput> &vCoins, bool fOnlySafe, const\n         if (nDepth == 0 && !pcoin->InMempool())\n             continue;\n \n-        bool safeTx = pcoin->IsTrusted();\n+        bool safeTx = pcoin->IsTrusted(locked_chain);\n \n         // We should not consider coins from transactions that are replacing\n         // other transactions.\n@@ -2226,7 +2250,7 @@ void CWallet::AvailableCoins(std::vector<COutput> &vCoins, bool fOnlySafe, const\n             if (IsLockedCoin(entry.first, i))\n                 continue;\n \n-            if (IsSpent(wtxid, i))\n+            if (IsSpent(locked_chain, wtxid, i))\n                 continue;\n \n             isminetype mine = IsMine(pcoin->tx->vout[i]);\n@@ -2257,15 +2281,15 @@ void CWallet::AvailableCoins(std::vector<COutput> &vCoins, bool fOnlySafe, const\n     }\n }\n \n-std::map<CTxDestination, std::vector<COutput>> CWallet::ListCoins() const\n+std::map<CTxDestination, std::vector<COutput>> CWallet::ListCoins(interfaces::Chain::Lock& locked_chain) const\n {\n     AssertLockHeld(cs_main);\n     AssertLockHeld(cs_wallet);\n \n     std::map<CTxDestination, std::vector<COutput>> result;\n     std::vector<COutput> availableCoins;\n \n-    AvailableCoins(availableCoins);\n+    AvailableCoins(locked_chain, availableCoins);\n \n     for (const COutput& coin : availableCoins) {\n         CTxDestination address;\n@@ -2280,7 +2304,7 @@ std::map<CTxDestination, std::vector<COutput>> CWallet::ListCoins() const\n     for (const COutPoint& output : lockedCoins) {\n         auto it = mapWallet.find(output.hash);\n         if (it != mapWallet.end()) {\n-            int depth = it->second.GetDepthInMainChain();\n+            int depth = it->second.GetDepthInMainChain(locked_chain);\n             if (depth >= 0 && output.n < it->second.tx->vout.size() &&\n                 IsMine(it->second.tx->vout[output.n]) == ISMINE_SPENDABLE) {\n                 CTxDestination address;\n@@ -2495,11 +2519,12 @@ bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nC\n \n     // Acquire the locks to prevent races to the new locked unspents between the\n     // CreateTransaction call and LockCoin calls (when lockUnspents is true).\n-    LOCK2(cs_main, cs_wallet);\n+    auto locked_chain = chain().lock();\n+    LOCK(cs_wallet);\n \n     CReserveKey reservekey(this);\n     CTransactionRef tx_new;\n-    if (!CreateTransaction(vecSend, tx_new, reservekey, nFeeRet, nChangePosInOut, strFailReason, coinControl, false)) {\n+    if (!CreateTransaction(*locked_chain, vecSend, tx_new, reservekey, nFeeRet, nChangePosInOut, strFailReason, coinControl, false)) {\n         return false;\n     }\n \n@@ -2558,7 +2583,7 @@ OutputType CWallet::TransactionChangeType(OutputType change_type, const std::vec\n     return m_default_address_type;\n }\n \n-bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CReserveKey& reservekey, CAmount& nFeeRet,\n+bool CWallet::CreateTransaction(interfaces::Chain::Lock& locked_chain, const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CReserveKey& reservekey, CAmount& nFeeRet,\n                          int& nChangePosInOut, std::string& strFailReason, const CCoinControl& coin_control, bool sign)\n {\n     CAmount nValue = 0;\n@@ -2620,10 +2645,11 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransac\n     int nBytes;\n     {\n         std::set<CInputCoin> setCoins;\n-        LOCK2(cs_main, cs_wallet);\n+        auto locked_chain = chain().lock();\n+        LOCK(cs_wallet);\n         {\n             std::vector<COutput> vAvailableCoins;\n-            AvailableCoins(vAvailableCoins, true, &coin_control);\n+            AvailableCoins(*locked_chain, vAvailableCoins, true, &coin_control);\n             CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n \n             // Create change script that will be used if we need change\n@@ -2958,7 +2984,8 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransac\n bool CWallet::CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::vector<std::pair<std::string, std::string>> orderForm, CReserveKey& reservekey, CConnman* connman, CValidationState& state)\n {\n     {\n-        LOCK2(cs_main, cs_wallet);\n+        auto locked_chain = chain().lock();\n+        LOCK(cs_wallet);\n \n         CWalletTx wtxNew(this, std::move(tx));\n         wtxNew.mapValue = std::move(mapValue);\n@@ -2991,11 +3018,11 @@ bool CWallet::CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::ve\n         if (fBroadcastTransactions)\n         {\n             // Broadcast\n-            if (!wtx.AcceptToMemoryPool(maxTxFee, state)) {\n+            if (!wtx.AcceptToMemoryPool(*locked_chain, maxTxFee, state)) {\n                 WalletLogPrintf(\"CommitTransaction(): Transaction cannot be broadcast immediately, %s\\n\", FormatStateMessage(state));\n                 // TODO: if we expect the failure to be long term or permanent, instead delete wtx from the wallet and return failure.\n             } else {\n-                wtx.RelayWalletTransaction(connman);\n+                wtx.RelayWalletTransaction(*locked_chain, connman);\n             }\n         }\n     }\n@@ -3004,7 +3031,8 @@ bool CWallet::CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::ve\n \n DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n {\n-    LOCK2(cs_main, cs_wallet);\n+    auto locked_chain = chain().lock();\n+    LOCK(cs_wallet);\n \n     fFirstRunRet = false;\n     DBErrors nLoadWalletRet = WalletBatch(*database,\"cr+\").LoadWallet(this);\n@@ -3388,7 +3416,7 @@ int64_t CWallet::GetOldestKeyPoolTime()\n     return oldestKey;\n }\n \n-std::map<CTxDestination, CAmount> CWallet::GetAddressBalances()\n+std::map<CTxDestination, CAmount> CWallet::GetAddressBalances(interfaces::Chain::Lock& locked_chain)\n {\n     std::map<CTxDestination, CAmount> balances;\n \n@@ -3398,13 +3426,13 @@ std::map<CTxDestination, CAmount> CWallet::GetAddressBalances()\n         {\n             const CWalletTx *pcoin = &walletEntry.second;\n \n-            if (!pcoin->IsTrusted())\n+            if (!pcoin->IsTrusted(locked_chain))\n                 continue;\n \n-            if (pcoin->IsImmatureCoinBase())\n+            if (pcoin->IsImmatureCoinBase(locked_chain))\n                 continue;\n \n-            int nDepth = pcoin->GetDepthInMainChain();\n+            int nDepth = pcoin->GetDepthInMainChain(locked_chain);\n             if (nDepth < (pcoin->IsFromMe(ISMINE_ALL) ? 0 : 1))\n                 continue;\n \n@@ -3416,7 +3444,7 @@ std::map<CTxDestination, CAmount> CWallet::GetAddressBalances()\n                 if(!ExtractDestination(pcoin->tx->vout[i].scriptPubKey, addr))\n                     continue;\n \n-                CAmount n = IsSpent(walletEntry.first, i) ? 0 : pcoin->tx->vout[i].nValue;\n+                CAmount n = IsSpent(locked_chain, walletEntry.first, i) ? 0 : pcoin->tx->vout[i].nValue;\n \n                 if (!balances.count(addr))\n                     balances[addr] = 0;\n@@ -3641,7 +3669,7 @@ void CWallet::ListLockedCoins(std::vector<COutPoint>& vOutpts) const\n \n /** @} */ // end of Actions\n \n-void CWallet::GetKeyBirthTimes(std::map<CTxDestination, int64_t> &mapKeyBirth) const {\n+void CWallet::GetKeyBirthTimes(interfaces::Chain::Lock& locked_chain, std::map<CTxDestination, int64_t> &mapKeyBirth) const {\n     AssertLockHeld(cs_wallet); // mapKeyMetadata\n     mapKeyBirth.clear();\n \n@@ -3821,7 +3849,7 @@ void CWallet::MarkPreSplitKeys()\n     }\n }\n \n-bool CWallet::Verify(std::string wallet_file, bool salvage_wallet, std::string& error_string, std::string& warning_string)\n+bool CWallet::Verify(interfaces::Chain& chain, const WalletLocation& location, bool salvage_wallet, std::string& error_string, std::string& warning_string)\n {\n     // Do some checking on wallet path. It should be either a:\n     //\n@@ -3830,23 +3858,23 @@ bool CWallet::Verify(std::string wallet_file, bool salvage_wallet, std::string&\n     // 3. Path to a symlink to a directory.\n     // 4. For backwards compatibility, the name of a data file in -walletdir.\n     LOCK(cs_wallets);\n-    fs::path wallet_path = fs::absolute(wallet_file, GetWalletDir());\n+    const fs::path& wallet_path = location.GetPath();\n     fs::file_type path_type = fs::symlink_status(wallet_path).type();\n     if (!(path_type == fs::file_not_found || path_type == fs::directory_file ||\n           (path_type == fs::symlink_file && fs::is_directory(wallet_path)) ||\n-          (path_type == fs::regular_file && fs::path(wallet_file).filename() == wallet_file))) {\n+          (path_type == fs::regular_file && fs::path(location.GetName()).filename() == location.GetName()))) {\n         error_string = strprintf(\n               \"Invalid -wallet path '%s'. -wallet path should point to a directory where wallet.dat and \"\n               \"database/log.?????????? files can be stored, a location where such a directory could be created, \"\n               \"or (for backwards compatibility) the name of an existing data file in -walletdir (%s)\",\n-              wallet_file, GetWalletDir());\n+              location.GetName(), GetWalletDir());\n         return false;\n     }\n \n     // Make sure that the wallet path doesn't clash with an existing wallet path\n     for (auto wallet : GetWallets()) {\n-        if (fs::absolute(wallet->GetName(), GetWalletDir()) == wallet_path) {\n-            error_string = strprintf(\"Error loading wallet %s. Duplicate -wallet filename specified.\", wallet_file);\n+        if (wallet->GetLocation().GetPath() == wallet_path) {\n+            error_string = strprintf(\"Error loading wallet %s. Duplicate -wallet filename specified.\", location.GetName());\n             return false;\n         }\n     }\n@@ -3856,13 +3884,13 @@ bool CWallet::Verify(std::string wallet_file, bool salvage_wallet, std::string&\n             return false;\n         }\n     } catch (const fs::filesystem_error& e) {\n-        error_string = strprintf(\"Error loading wallet %s. %s\", wallet_file, fsbridge::get_filesystem_error_message(e));\n+        error_string = strprintf(\"Error loading wallet %s. %s\", location.GetName(), fsbridge::get_filesystem_error_message(e));\n         return false;\n     }\n \n     if (salvage_wallet) {\n         // Recover readable keypairs:\n-        CWallet dummyWallet(\"dummy\", WalletDatabase::CreateDummy());\n+        CWallet dummyWallet(chain, WalletLocation(), WalletDatabase::CreateDummy());\n         std::string backup_filename;\n         if (!WalletBatch::Recover(wallet_path, (void *)&dummyWallet, WalletBatch::RecoverKeysOnlyFilter, backup_filename)) {\n             return false;\n@@ -3872,17 +3900,17 @@ bool CWallet::Verify(std::string wallet_file, bool salvage_wallet, std::string&\n     return WalletBatch::VerifyDatabaseFile(wallet_path, warning_string, error_string);\n }\n \n-std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(const std::string& name, const fs::path& path, uint64_t wallet_creation_flags)\n+std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain, const WalletLocation& location, uint64_t wallet_creation_flags)\n {\n-    const std::string& walletFile = name;\n+    const std::string& walletFile = location.GetName();\n \n     // needed to restore wallet transaction meta data after -zapwallettxes\n     std::vector<CWalletTx> vWtx;\n \n     if (gArgs.GetBoolArg(\"-zapwallettxes\", false)) {\n         uiInterface.InitMessage(_(\"Zapping all transactions from wallet...\"));\n \n-        std::unique_ptr<CWallet> tempWallet = MakeUnique<CWallet>(name, WalletDatabase::Create(path));\n+        std::unique_ptr<CWallet> tempWallet = MakeUnique<CWallet>(chain, location, WalletDatabase::Create(location.GetPath()));\n         DBErrors nZapWalletRet = tempWallet->ZapWalletTx(vWtx);\n         if (nZapWalletRet != DBErrors::LOAD_OK) {\n             InitError(strprintf(_(\"Error loading %s: Wallet corrupted\"), walletFile));\n@@ -3896,7 +3924,7 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(const std::string& name,\n     bool fFirstRun = true;\n     // TODO: Can't use std::make_shared because we need a custom deleter but\n     // should be possible to use std::allocate_shared.\n-    std::shared_ptr<CWallet> walletInstance(new CWallet(name, WalletDatabase::Create(path)), ReleaseWallet);\n+    std::shared_ptr<CWallet> walletInstance(new CWallet(chain, location, WalletDatabase::Create(location.GetPath())), ReleaseWallet);\n     DBErrors nLoadWalletRet = walletInstance->LoadWallet(fFirstRun);\n     if (nLoadWalletRet != DBErrors::LOAD_OK)\n     {\n@@ -4006,6 +4034,7 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(const std::string& name,\n             return nullptr;\n         }\n \n+        auto locked_chain = chain.assumeLocked();  // Temporary. Removed in upcoming lock cleanup\n         walletInstance->ChainStateFlushed(chainActive.GetLocator());\n     } else if (wallet_creation_flags & WALLET_FLAG_DISABLE_PRIVATE_KEYS) {\n         // Make it impossible to disable private keys after creation\n@@ -4093,7 +4122,9 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(const std::string& name,\n     // Try to top up keypool. No-op if the wallet is locked.\n     walletInstance->TopUpKeyPool();\n \n-    LOCK(cs_main);\n+    LockAnnotation lock(::cs_main); // Temporary, for FindForkInGlobalIndex below. Removed in upcoming commit.\n+    auto locked_chain = chain.lock();\n+    LOCK(walletInstance->cs_wallet);\n \n     CBlockIndex *pindexRescan = chainActive.Genesis();\n     if (!gArgs.GetBoolArg(\"-rescan\", false))\n@@ -4178,7 +4209,6 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(const std::string& name,\n     walletInstance->SetBroadcastTransactions(gArgs.GetBoolArg(\"-walletbroadcast\", DEFAULT_WALLETBROADCAST));\n \n     {\n-        LOCK(walletInstance->cs_wallet);\n         walletInstance->WalletLogPrintf(\"setKeyPool.size() = %u\\n\",      walletInstance->GetKeyPoolSize());\n         walletInstance->WalletLogPrintf(\"mapWallet.size() = %u\\n\",       walletInstance->mapWallet.size());\n         walletInstance->WalletLogPrintf(\"mapAddressBook.size() = %u\\n\",  walletInstance->mapAddressBook.size());\n@@ -4229,7 +4259,7 @@ void CMerkleTx::SetMerkleBranch(const CBlockIndex* pindex, int posInBlock)\n     nIndex = posInBlock;\n }\n \n-int CMerkleTx::GetDepthInMainChain() const\n+int CMerkleTx::GetDepthInMainChain(interfaces::Chain::Lock& locked_chain) const\n {\n     if (hashUnset())\n         return 0;\n@@ -4244,23 +4274,25 @@ int CMerkleTx::GetDepthInMainChain() const\n     return ((nIndex == -1) ? (-1) : 1) * (chainActive.Height() - pindex->nHeight + 1);\n }\n \n-int CMerkleTx::GetBlocksToMaturity() const\n+int CMerkleTx::GetBlocksToMaturity(interfaces::Chain::Lock& locked_chain) const\n {\n     if (!IsCoinBase())\n         return 0;\n-    int chain_depth = GetDepthInMainChain();\n+    int chain_depth = GetDepthInMainChain(locked_chain);\n     assert(chain_depth >= 0); // coinbase tx should not be conflicted\n     return std::max(0, (COINBASE_MATURITY+1) - chain_depth);\n }\n \n-bool CMerkleTx::IsImmatureCoinBase() const\n+bool CMerkleTx::IsImmatureCoinBase(interfaces::Chain::Lock& locked_chain) const\n {\n     // note GetBlocksToMaturity is 0 for non-coinbase tx\n-    return GetBlocksToMaturity() > 0;\n+    return GetBlocksToMaturity(locked_chain) > 0;\n }\n \n-bool CWalletTx::AcceptToMemoryPool(const CAmount& nAbsurdFee, CValidationState& state)\n+bool CWalletTx::AcceptToMemoryPool(interfaces::Chain::Lock& locked_chain, const CAmount& nAbsurdFee, CValidationState& state)\n {\n+    LockAnnotation lock(::cs_main); // Temporary, for AcceptToMemoryPool below. Removed in upcoming commit.\n+\n     // We must set fInMempool here - while it will be re-set to true by the\n     // entered-mempool callback, if we did not there would be a race where a\n     // user could call sendmoney in a loop and hit spurious out of funds errors"
      },
      {
        "sha": "f96798201f1fad775b34e4841a185608dd171ab6",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 91,
        "deletions": 55,
        "changes": 146,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -7,20 +7,21 @@\n #define BITCOIN_WALLET_WALLET_H\n \n #include <amount.h>\n+#include <interfaces/chain.h>\n #include <outputtype.h>\n #include <policy/feerate.h>\n #include <streams.h>\n #include <tinyformat.h>\n #include <ui_interface.h>\n-#include <utilstrencodings.h>\n+#include <util/strencodings.h>\n #include <validationinterface.h>\n #include <script/ismine.h>\n #include <script/sign.h>\n-#include <util.h>\n+#include <util/system.h>\n #include <wallet/crypter.h>\n #include <wallet/coinselection.h>\n #include <wallet/walletdb.h>\n-#include <wallet/rpcwallet.h>\n+#include <wallet/walletutil.h>\n \n #include <algorithm>\n #include <atomic>\n@@ -33,6 +34,26 @@\n #include <utility>\n #include <vector>\n \n+//! Responsible for reading and validating the -wallet arguments and verifying the wallet database.\n+//  This function will perform salvage on the wallet if requested, as long as only one wallet is\n+//  being loaded (WalletParameterInteraction forbids -salvagewallet, -zapwallettxes or -upgradewallet with multiwallet).\n+bool VerifyWallets(interfaces::Chain& chain, const std::vector<std::string>& wallet_files);\n+\n+//! Load wallet databases.\n+bool LoadWallets(interfaces::Chain& chain, const std::vector<std::string>& wallet_files);\n+\n+//! Complete startup of wallets.\n+void StartWallets(CScheduler& scheduler);\n+\n+//! Flush all wallets in preparation for shutdown.\n+void FlushWallets();\n+\n+//! Stop all wallets. Wallets will be flushed first.\n+void StopWallets();\n+\n+//! Close all wallets.\n+void UnloadWallets();\n+\n bool AddWallet(const std::shared_ptr<CWallet>& wallet);\n bool RemoveWallet(const std::shared_ptr<CWallet>& wallet);\n bool HasWallets();\n@@ -264,22 +285,22 @@ class CMerkleTx\n      *  0  : in memory pool, waiting to be included in a block\n      * >=1 : this many blocks deep in the main chain\n      */\n-    int GetDepthInMainChain() const EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-    bool IsInMainChain() const EXCLUSIVE_LOCKS_REQUIRED(cs_main) { return GetDepthInMainChain() > 0; }\n+    int GetDepthInMainChain(interfaces::Chain::Lock& locked_chain) const;\n+    bool IsInMainChain(interfaces::Chain::Lock& locked_chain) const { return GetDepthInMainChain(locked_chain) > 0; }\n \n     /**\n      * @return number of blocks to maturity for this transaction:\n      *  0 : is not a coinbase transaction, or is a mature coinbase transaction\n      * >0 : is a coinbase transaction which matures in this many blocks\n      */\n-    int GetBlocksToMaturity() const EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    int GetBlocksToMaturity(interfaces::Chain::Lock& locked_chain) const;\n     bool hashUnset() const { return (hashBlock.IsNull() || hashBlock == ABANDON_HASH); }\n     bool isAbandoned() const { return (hashBlock == ABANDON_HASH); }\n     void setAbandoned() { hashBlock = ABANDON_HASH; }\n \n     const uint256& GetHash() const { return tx->GetHash(); }\n     bool IsCoinBase() const { return tx->IsCoinBase(); }\n-    bool IsImmatureCoinBase() const EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool IsImmatureCoinBase(interfaces::Chain::Lock& locked_chain) const;\n };\n \n //Get the marginal bytes of spending the specified output\n@@ -458,10 +479,14 @@ class CWalletTx : public CMerkleTx\n \n     //! filter decides which addresses will count towards the debit\n     CAmount GetDebit(const isminefilter& filter) const;\n-    CAmount GetCredit(const isminefilter& filter) const EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-    CAmount GetImmatureCredit(bool fUseCache=true) const EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-    CAmount GetAvailableCredit(bool fUseCache=true, const isminefilter& filter=ISMINE_SPENDABLE) const EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-    CAmount GetImmatureWatchOnlyCredit(const bool fUseCache=true) const EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    CAmount GetCredit(interfaces::Chain::Lock& locked_chain, const isminefilter& filter) const;\n+    CAmount GetImmatureCredit(interfaces::Chain::Lock& locked_chain, bool fUseCache=true) const;\n+    // TODO: Remove \"NO_THREAD_SAFETY_ANALYSIS\" and replace it with the correct\n+    // annotation \"EXCLUSIVE_LOCKS_REQUIRED(cs_main, pwallet->cs_wallet)\". The\n+    // annotation \"NO_THREAD_SAFETY_ANALYSIS\" was temporarily added to avoid\n+    // having to resolve the issue of member access into incomplete type CWallet.\n+    CAmount GetAvailableCredit(interfaces::Chain::Lock& locked_chain, bool fUseCache=true, const isminefilter& filter=ISMINE_SPENDABLE) const NO_THREAD_SAFETY_ANALYSIS;\n+    CAmount GetImmatureWatchOnlyCredit(interfaces::Chain::Lock& locked_chain, const bool fUseCache=true) const;\n     CAmount GetChange() const;\n \n     // Get the marginal bytes if spending the specified output from this transaction\n@@ -482,17 +507,23 @@ class CWalletTx : public CMerkleTx\n     bool IsEquivalentTo(const CWalletTx& tx) const;\n \n     bool InMempool() const;\n-    bool IsTrusted() const EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool IsTrusted(interfaces::Chain::Lock& locked_chain) const;\n \n     int64_t GetTxTime() const;\n \n     // RelayWalletTransaction may only be called if fBroadcastTransactions!\n-    bool RelayWalletTransaction(CConnman* connman) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool RelayWalletTransaction(interfaces::Chain::Lock& locked_chain, CConnman* connman);\n \n     /** Pass this transaction to the mempool. Fails if absolute fee exceeds absurd fee. */\n-    bool AcceptToMemoryPool(const CAmount& nAbsurdFee, CValidationState& state) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-\n-    std::set<uint256> GetConflicts() const;\n+    bool AcceptToMemoryPool(interfaces::Chain::Lock& locked_chain, const CAmount& nAbsurdFee, CValidationState& state);\n+\n+    // TODO: Remove \"NO_THREAD_SAFETY_ANALYSIS\" and replace it with the correct\n+    // annotation \"EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\". The annotation\n+    // \"NO_THREAD_SAFETY_ANALYSIS\" was temporarily added to avoid having to\n+    // resolve the issue of member access into incomplete type CWallet. Note\n+    // that we still have the runtime check \"AssertLockHeld(pwallet->cs_wallet)\"\n+    // in place.\n+    std::set<uint256> GetConflicts() const NO_THREAD_SAFETY_ANALYSIS;\n };\n \n class COutput\n@@ -591,13 +622,13 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     std::mutex mutexScanning;\n     friend class WalletRescanReserver;\n \n-    WalletBatch *encrypted_batch = nullptr;\n+    WalletBatch *encrypted_batch GUARDED_BY(cs_wallet) = nullptr;\n \n     //! the current wallet version: clients below this version are not able to load the wallet\n     int nWalletVersion = FEATURE_BASE;\n \n     //! the maximum wallet format version: memory-only variable that specifies to what version this wallet may be upgraded\n-    int nWalletMaxVersion = FEATURE_BASE;\n+    int nWalletMaxVersion GUARDED_BY(cs_wallet) = FEATURE_BASE;\n \n     int64_t nNextResend = 0;\n     int64_t nLastResend = 0;\n@@ -609,9 +640,9 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n      * mutated transactions where the mutant gets mined).\n      */\n     typedef std::multimap<COutPoint, uint256> TxSpends;\n-    TxSpends mapTxSpends;\n-    void AddToSpends(const COutPoint& outpoint, const uint256& wtxid);\n-    void AddToSpends(const uint256& wtxid);\n+    TxSpends mapTxSpends GUARDED_BY(cs_wallet);\n+    void AddToSpends(const COutPoint& outpoint, const uint256& wtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    void AddToSpends(const uint256& wtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n     /**\n      * Add a transaction to the wallet, or update it.  pIndex and posInBlock should\n@@ -632,9 +663,9 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     void MarkConflicted(const uint256& hashBlock, const uint256& hashTx);\n \n     /* Mark a transaction's inputs dirty, thus forcing the outputs to be recomputed */\n-    void MarkInputsDirty(const CTransactionRef& tx);\n+    void MarkInputsDirty(const CTransactionRef& tx) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n-    void SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator>);\n+    void SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator>) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n     /* Used by TransactionAddedToMemorypool/BlockConnected/Disconnected/ScanForWalletTransactions.\n      * Should be called with pindexBlock and posInBlock if this is for a transaction that is included in a block. */\n@@ -647,13 +678,13 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     void DeriveNewChildKey(WalletBatch &batch, CKeyMetadata& metadata, CKey& secret, bool internal = false) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n     std::set<int64_t> setInternalKeyPool;\n-    std::set<int64_t> setExternalKeyPool;\n+    std::set<int64_t> setExternalKeyPool GUARDED_BY(cs_wallet);\n     std::set<int64_t> set_pre_split_keypool;\n-    int64_t m_max_keypool_index = 0;\n+    int64_t m_max_keypool_index GUARDED_BY(cs_wallet) = 0;\n     std::map<CKeyID, int64_t> m_pool_key_to_index;\n     std::atomic<uint64_t> m_wallet_flags{0};\n \n-    int64_t nTimeFirstKey = 0;\n+    int64_t nTimeFirstKey GUARDED_BY(cs_wallet) = 0;\n \n     /**\n      * Private version of AddWatchOnly method which does not accept a\n@@ -666,12 +697,11 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n      */\n     bool AddWatchOnly(const CScript& dest) override EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n-    /**\n-     * Wallet filename from wallet=<path> command line or config option.\n-     * Used in debug logs and to send RPCs to the right wallet instance when\n-     * more than one wallet is loaded.\n-     */\n-    std::string m_name;\n+    /** Interface for accessing chain state. */\n+    interfaces::Chain& m_chain;\n+\n+    /** Wallet location which includes wallet name (see WalletLocation). */\n+    WalletLocation m_location;\n \n     /** Internal database handle. */\n     std::unique_ptr<WalletDatabase> database;\n@@ -709,27 +739,29 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n      * if they are not ours\n      */\n     bool SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet,\n-                    const CCoinControl& coin_control, CoinSelectionParams& coin_selection_params, bool& bnb_used) const;\n+                    const CCoinControl& coin_control, CoinSelectionParams& coin_selection_params, bool& bnb_used) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+\n+    const WalletLocation& GetLocation() const { return m_location; }\n \n     /** Get a name for this wallet for logging/debugging purposes.\n      */\n-    const std::string& GetName() const { return m_name; }\n+    const std::string& GetName() const { return m_location.GetName(); }\n \n     void LoadKeyPool(int64_t nIndex, const CKeyPool &keypool) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    void MarkPreSplitKeys();\n+    void MarkPreSplitKeys() EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n     // Map from Key ID to key metadata.\n-    std::map<CKeyID, CKeyMetadata> mapKeyMetadata;\n+    std::map<CKeyID, CKeyMetadata> mapKeyMetadata GUARDED_BY(cs_wallet);\n \n     // Map from Script ID to key metadata (for watch-only keys).\n-    std::map<CScriptID, CKeyMetadata> m_script_metadata;\n+    std::map<CScriptID, CKeyMetadata> m_script_metadata GUARDED_BY(cs_wallet);\n \n     typedef std::map<unsigned int, CMasterKey> MasterKeyMap;\n     MasterKeyMap mapMasterKeys;\n     unsigned int nMasterKeyMaxID = 0;\n \n     /** Construct wallet with specified name and database implementation. */\n-    CWallet(std::string name, std::unique_ptr<WalletDatabase> database) : m_name(std::move(name)), database(std::move(database))\n+    CWallet(interfaces::Chain& chain, const WalletLocation& location, std::unique_ptr<WalletDatabase> database) : m_chain(chain), m_location(location), database(std::move(database))\n     {\n     }\n \n@@ -739,17 +771,20 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n         encrypted_batch = nullptr;\n     }\n \n-    std::map<uint256, CWalletTx> mapWallet;\n+    std::map<uint256, CWalletTx> mapWallet GUARDED_BY(cs_wallet);\n \n     typedef std::multimap<int64_t, CWalletTx*> TxItems;\n     TxItems wtxOrdered;\n \n-    int64_t nOrderPosNext = 0;\n+    int64_t nOrderPosNext GUARDED_BY(cs_wallet) = 0;\n     uint64_t nAccountingEntryNumber = 0;\n \n     std::map<CTxDestination, CAddressBookData> mapAddressBook;\n \n-    std::set<COutPoint> setLockedCoins;\n+    std::set<COutPoint> setLockedCoins GUARDED_BY(cs_wallet);\n+\n+    /** Interface for accessing chain state. */\n+    interfaces::Chain& chain() const { return m_chain; }\n \n     const CWalletTx* GetWalletTx(const uint256& hash) const;\n \n@@ -759,17 +794,17 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     /**\n      * populate vCoins with vector of available COutputs.\n      */\n-    void AvailableCoins(std::vector<COutput>& vCoins, bool fOnlySafe=true, const CCoinControl *coinControl = nullptr, const CAmount& nMinimumAmount = 1, const CAmount& nMaximumAmount = MAX_MONEY, const CAmount& nMinimumSumAmount = MAX_MONEY, const uint64_t nMaximumCount = 0, const int nMinDepth = 0, const int nMaxDepth = 9999999) const EXCLUSIVE_LOCKS_REQUIRED(cs_main, cs_wallet);\n+    void AvailableCoins(interfaces::Chain::Lock& locked_chain, std::vector<COutput>& vCoins, bool fOnlySafe=true, const CCoinControl *coinControl = nullptr, const CAmount& nMinimumAmount = 1, const CAmount& nMaximumAmount = MAX_MONEY, const CAmount& nMinimumSumAmount = MAX_MONEY, const uint64_t nMaximumCount = 0, const int nMinDepth = 0, const int nMaxDepth = 9999999) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n     /**\n      * Return list of available coins and locked coins grouped by non-change output address.\n      */\n-    std::map<CTxDestination, std::vector<COutput>> ListCoins() const EXCLUSIVE_LOCKS_REQUIRED(cs_main, cs_wallet);\n+    std::map<CTxDestination, std::vector<COutput>> ListCoins(interfaces::Chain::Lock& locked_chain) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n     /**\n      * Find non-change parent output.\n      */\n-    const CTxOut& FindNonChangeParentOutput(const CTransaction& tx, int output) const;\n+    const CTxOut& FindNonChangeParentOutput(const CTransaction& tx, int output) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n     /**\n      * Shuffle and select coins until nTargetValue is reached while avoiding\n@@ -780,7 +815,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     bool SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<OutputGroup> groups,\n         std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params, bool& bnb_used) const;\n \n-    bool IsSpent(const uint256& hash, unsigned int n) const EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool IsSpent(interfaces::Chain::Lock& locked_chain, const uint256& hash, unsigned int n) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     std::vector<OutputGroup> GroupOutputs(const std::vector<COutput>& outputs, bool single_coin) const;\n \n     bool IsLockedCoin(uint256 hash, unsigned int n) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n@@ -844,7 +879,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     bool ChangeWalletPassphrase(const SecureString& strOldWalletPassphrase, const SecureString& strNewWalletPassphrase);\n     bool EncryptWallet(const SecureString& strWalletPassphrase);\n \n-    void GetKeyBirthTimes(std::map<CTxDestination, int64_t> &mapKeyBirth) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    void GetKeyBirthTimes(interfaces::Chain::Lock& locked_chain, std::map<CTxDestination, int64_t> &mapKeyBirth) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     unsigned int ComputeTimeSmart(const CWalletTx& wtx) const;\n \n     /**\n@@ -856,7 +891,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n \n     void MarkDirty();\n     bool AddToWallet(const CWalletTx& wtxIn, bool fFlushOnClose=true);\n-    void LoadToWallet(const CWalletTx& wtxIn);\n+    void LoadToWallet(const CWalletTx& wtxIn) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     void TransactionAddedToMempool(const CTransactionRef& tx) override;\n     void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex *pindex, const std::vector<CTransactionRef>& vtxConflicted) override;\n     void BlockDisconnected(const std::shared_ptr<const CBlock>& pblock) override;\n@@ -866,7 +901,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     void ReacceptWalletTransactions();\n     void ResendWalletTransactions(int64_t nBestBlockTime, CConnman* connman) override EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     // ResendWalletTransactionsBefore may only be called if fBroadcastTransactions!\n-    std::vector<uint256> ResendWalletTransactionsBefore(int64_t nTime, CConnman* connman) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    std::vector<uint256> ResendWalletTransactionsBefore(interfaces::Chain::Lock& locked_chain, int64_t nTime, CConnman* connman);\n     CAmount GetBalance(const isminefilter& filter=ISMINE_SPENDABLE, const int min_depth=0) const;\n     CAmount GetUnconfirmedBalance() const;\n     CAmount GetImmatureBalance() const;\n@@ -889,7 +924,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n      * selected by SelectCoins(); Also create the change output, when needed\n      * @note passing nChangePosInOut as -1 will result in setting a random position\n      */\n-    bool CreateTransaction(const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CReserveKey& reservekey, CAmount& nFeeRet, int& nChangePosInOut,\n+    bool CreateTransaction(interfaces::Chain::Lock& locked_chain, const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CReserveKey& reservekey, CAmount& nFeeRet, int& nChangePosInOut,\n                            std::string& strFailReason, const CCoinControl& coin_control, bool sign = true);\n     bool CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::vector<std::pair<std::string, std::string>> orderForm, CReserveKey& reservekey, CConnman* connman, CValidationState& state);\n \n@@ -948,7 +983,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     const std::map<CKeyID, int64_t>& GetAllReserveKeys() const { return m_pool_key_to_index; }\n \n     std::set<std::set<CTxDestination>> GetAddressGroupings() EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    std::map<CTxDestination, CAmount> GetAddressBalances() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    std::map<CTxDestination, CAmount> GetAddressBalances(interfaces::Chain::Lock& locked_chain);\n \n     std::set<CTxDestination> GetLabelAddresses(const std::string& label) const;\n \n@@ -961,6 +996,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     isminetype IsMine(const CTxOut& txout) const;\n     CAmount GetCredit(const CTxOut& txout, const isminefilter& filter) const;\n     bool IsChange(const CTxOut& txout) const;\n+    bool IsChange(const CScript& script) const;\n     CAmount GetChange(const CTxOut& txout) const;\n     bool IsMine(const CTransaction& tx) const;\n     /** should probably be renamed to IsRelevantToMe */\n@@ -1000,7 +1036,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     int GetVersion() { LOCK(cs_wallet); return nWalletVersion; }\n \n     //! Get wallet transactions that conflict with given transaction (spend same outputs)\n-    std::set<uint256> GetConflicts(const uint256& txid) const;\n+    std::set<uint256> GetConflicts(const uint256& txid) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n     //! Check if a given transaction has any of its outputs spent by another transaction in the wallet\n     bool HasWalletSpend(const uint256& txid) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n@@ -1042,16 +1078,16 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     bool TransactionCanBeAbandoned(const uint256& hashTx) const;\n \n     /* Mark a transaction (and it in-wallet descendants) as abandoned so its inputs may be respent. */\n-    bool AbandonTransaction(const uint256& hashTx);\n+    bool AbandonTransaction(interfaces::Chain::Lock& locked_chain, const uint256& hashTx);\n \n     /** Mark a transaction as replaced by another transaction (e.g., BIP 125). */\n     bool MarkReplaced(const uint256& originalHash, const uint256& newHash);\n \n     //! Verify wallet naming and perform salvage on the wallet if required\n-    static bool Verify(std::string wallet_file, bool salvage_wallet, std::string& error_string, std::string& warning_string);\n+    static bool Verify(interfaces::Chain& chain, const WalletLocation& location, bool salvage_wallet, std::string& error_string, std::string& warning_string);\n \n     /* Initializes the wallet, returns a new CWallet instance or a null pointer in case of an error */\n-    static std::shared_ptr<CWallet> CreateWalletFromFile(const std::string& name, const fs::path& path, uint64_t wallet_creation_flags = 0);\n+    static std::shared_ptr<CWallet> CreateWalletFromFile(interfaces::Chain& chain, const WalletLocation& location, uint64_t wallet_creation_flags = 0);\n \n     /**\n      * Wallet post-init setup\n@@ -1198,6 +1234,6 @@ class WalletRescanReserver\n // Use DummySignatureCreator, which inserts 71 byte signatures everywhere.\n // NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n // be IsAllFromMe).\n-int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, bool use_max_sig = false);\n+int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, bool use_max_sig = false) EXCLUSIVE_LOCKS_REQUIRED(wallet->cs_wallet);\n int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, const std::vector<CTxOut>& txouts, bool use_max_sig = false);\n #endif // BITCOIN_WALLET_WALLET_H"
      },
      {
        "sha": "09a33f252c8d0feba0a4a31caa99bdf1c08b9da2",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -12,8 +12,8 @@\n #include <protocol.h>\n #include <serialize.h>\n #include <sync.h>\n-#include <util.h>\n-#include <utiltime.h>\n+#include <util/system.h>\n+#include <util/time.h>\n #include <wallet/wallet.h>\n \n #include <atomic>"
      },
      {
        "sha": "6db4c63acbe1d23bf91d29822903b1320a921ffb",
        "filename": "src/wallet/walletutil.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 4,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/walletutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/walletutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletutil.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -4,7 +4,7 @@\n \n #include <wallet/walletutil.h>\n \n-#include <util.h>\n+#include <util/system.h>\n \n fs::path GetWalletDir()\n {\n@@ -52,12 +52,17 @@ static bool IsBerkeleyBtree(const fs::path& path)\n std::vector<fs::path> ListWalletDir()\n {\n     const fs::path wallet_dir = GetWalletDir();\n+    const size_t offset = wallet_dir.string().size() + 1;\n     std::vector<fs::path> paths;\n \n-    for (auto it = fs::recursive_directory_iterator(wallet_dir); it != end(it); ++it) {\n+    for (auto it = fs::recursive_directory_iterator(wallet_dir); it != fs::recursive_directory_iterator(); ++it) {\n+        // Get wallet path relative to walletdir by removing walletdir from the wallet path.\n+        // This can be replaced by boost::filesystem::lexically_relative once boost is bumped to 1.60.\n+        const fs::path path = it->path().string().substr(offset);\n+\n         if (it->status().type() == fs::directory_file && IsBerkeleyBtree(it->path() / \"wallet.dat\")) {\n             // Found a directory which contains wallet.dat btree file, add it as a wallet.\n-            paths.emplace_back(fs::relative(it->path(), wallet_dir));\n+            paths.emplace_back(path);\n         } else if (it.level() == 0 && it->symlink_status().type() == fs::regular_file && IsBerkeleyBtree(it->path())) {\n             if (it->path().filename() == \"wallet.dat\") {\n                 // Found top-level wallet.dat btree file, add top level directory \"\"\n@@ -68,10 +73,21 @@ std::vector<fs::path> ListWalletDir()\n                 // software will never create these files but will allow them to be\n                 // opened in a shared database environment for backwards compatibility.\n                 // Add it to the list of available wallets.\n-                paths.emplace_back(fs::relative(it->path(), wallet_dir));\n+                paths.emplace_back(path);\n             }\n         }\n     }\n \n     return paths;\n }\n+\n+WalletLocation::WalletLocation(const std::string& name)\n+    : m_name(name)\n+    , m_path(fs::absolute(name, GetWalletDir()))\n+{\n+}\n+\n+bool WalletLocation::Exists() const\n+{\n+    return fs::symlink_status(m_path).type() != fs::file_not_found;\n+}"
      },
      {
        "sha": "ba2f9138419934d999b55b1bcf6357de5da12202",
        "filename": "src/wallet/walletutil.h",
        "status": "modified",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/walletutil.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/wallet/walletutil.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletutil.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -15,4 +15,24 @@ fs::path GetWalletDir();\n //! Get wallets in wallet directory.\n std::vector<fs::path> ListWalletDir();\n \n+//! The WalletLocation class provides wallet information.\n+class WalletLocation final\n+{\n+    std::string m_name;\n+    fs::path m_path;\n+\n+public:\n+    explicit WalletLocation() {}\n+    explicit WalletLocation(const std::string& name);\n+\n+    //! Get wallet name.\n+    const std::string& GetName() const { return m_name; }\n+\n+    //! Get wallet absolute path.\n+    const fs::path& GetPath() const { return m_path; }\n+\n+    //! Return whether the wallet exists.\n+    bool Exists() const;\n+};\n+\n #endif // BITCOIN_WALLET_WALLETUTIL_H"
      },
      {
        "sha": "22aca659903c0ded79f0e72ff59c60a39b463578",
        "filename": "src/walletinitinterface.h",
        "status": "modified",
        "additions": 3,
        "deletions": 14,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/walletinitinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/walletinitinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletinitinterface.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -9,6 +9,7 @@\n \n class CScheduler;\n class CRPCTable;\n+struct InitInterfaces;\n \n class WalletInitInterface {\n public:\n@@ -18,20 +19,8 @@ class WalletInitInterface {\n     virtual void AddWalletOptions() const = 0;\n     /** Check wallet parameter interaction */\n     virtual bool ParameterInteraction() const = 0;\n-    /** Register wallet RPC*/\n-    virtual void RegisterRPC(CRPCTable &) const = 0;\n-    /** Verify wallets */\n-    virtual bool Verify() const = 0;\n-    /** Open wallets*/\n-    virtual bool Open() const = 0;\n-    /** Start wallets*/\n-    virtual void Start(CScheduler& scheduler) const = 0;\n-    /** Flush Wallets*/\n-    virtual void Flush() const = 0;\n-    /** Stop Wallets*/\n-    virtual void Stop() const = 0;\n-    /** Close wallets */\n-    virtual void Close() const = 0;\n+    /** Add wallets that should be opened to list of init interfaces. */\n+    virtual void Construct(InitInterfaces& interfaces) const = 0;\n \n     virtual ~WalletInitInterface() {}\n };"
      },
      {
        "sha": "1c6ba13f60b3a28791e1eb10863c3f6c040efd01",
        "filename": "src/warnings.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/warnings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/warnings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/warnings.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -5,7 +5,7 @@\n \n #include <sync.h>\n #include <clientversion.h>\n-#include <util.h>\n+#include <util/system.h>\n #include <warnings.h>\n \n CCriticalSection cs_warnings;"
      },
      {
        "sha": "6a9661e3e812a36dc325e8893ebda1147e03db04",
        "filename": "src/zmq/zmqabstractnotifier.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/zmq/zmqabstractnotifier.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/zmq/zmqabstractnotifier.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqabstractnotifier.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -3,8 +3,9 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <zmq/zmqabstractnotifier.h>\n-#include <util.h>\n+#include <util/system.h>\n \n+const int CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM;\n \n CZMQAbstractNotifier::~CZMQAbstractNotifier()\n {"
      },
      {
        "sha": "887dde7b27124101a3360afe6e183a1a44dbfe65",
        "filename": "src/zmq/zmqabstractnotifier.h",
        "status": "modified",
        "additions": 10,
        "deletions": 1,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/zmq/zmqabstractnotifier.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/zmq/zmqabstractnotifier.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqabstractnotifier.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -15,7 +15,9 @@ typedef CZMQAbstractNotifier* (*CZMQNotifierFactory)();\n class CZMQAbstractNotifier\n {\n public:\n-    CZMQAbstractNotifier() : psocket(nullptr) { }\n+    static const int DEFAULT_ZMQ_SNDHWM {1000};\n+\n+    CZMQAbstractNotifier() : psocket(nullptr), outbound_message_high_water_mark(DEFAULT_ZMQ_SNDHWM) { }\n     virtual ~CZMQAbstractNotifier();\n \n     template <typename T>\n@@ -28,6 +30,12 @@ class CZMQAbstractNotifier\n     void SetType(const std::string &t) { type = t; }\n     std::string GetAddress() const { return address; }\n     void SetAddress(const std::string &a) { address = a; }\n+    int GetOutboundMessageHighWaterMark() const { return outbound_message_high_water_mark; }\n+    void SetOutboundMessageHighWaterMark(const int sndhwm) {\n+        if (sndhwm >= 0) {\n+            outbound_message_high_water_mark = sndhwm;\n+        }\n+    }\n \n     virtual bool Initialize(void *pcontext) = 0;\n     virtual void Shutdown() = 0;\n@@ -39,6 +47,7 @@ class CZMQAbstractNotifier\n     void *psocket;\n     std::string type;\n     std::string address;\n+    int outbound_message_high_water_mark; // aka SNDHWM\n };\n \n #endif // BITCOIN_ZMQ_ZMQABSTRACTNOTIFIER_H"
      },
      {
        "sha": "6826cf62d6f4724a4d308cf2dbe6770e1d6d17ac",
        "filename": "src/zmq/zmqnotificationinterface.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/zmq/zmqnotificationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/zmq/zmqnotificationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqnotificationinterface.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -8,7 +8,7 @@\n #include <version.h>\n #include <validation.h>\n #include <streams.h>\n-#include <util.h>\n+#include <util/system.h>\n \n void zmqError(const char *str)\n {\n@@ -59,6 +59,7 @@ CZMQNotificationInterface* CZMQNotificationInterface::Create()\n             CZMQAbstractNotifier *notifier = factory();\n             notifier->SetType(entry.first);\n             notifier->SetAddress(address);\n+            notifier->SetOutboundMessageHighWaterMark(static_cast<int>(gArgs.GetArg(arg + \"hwm\", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM)));\n             notifiers.push_back(notifier);\n         }\n     }\n@@ -102,11 +103,11 @@ bool CZMQNotificationInterface::Initialize()\n         CZMQAbstractNotifier *notifier = *i;\n         if (notifier->Initialize(pcontext))\n         {\n-            LogPrint(BCLog::ZMQ, \"  Notifier %s ready (address = %s)\\n\", notifier->GetType(), notifier->GetAddress());\n+            LogPrint(BCLog::ZMQ, \"zmq: Notifier %s ready (address = %s)\\n\", notifier->GetType(), notifier->GetAddress());\n         }\n         else\n         {\n-            LogPrint(BCLog::ZMQ, \"  Notifier %s failed (address = %s)\\n\", notifier->GetType(), notifier->GetAddress());\n+            LogPrint(BCLog::ZMQ, \"zmq: Notifier %s failed (address = %s)\\n\", notifier->GetType(), notifier->GetAddress());\n             break;\n         }\n     }\n@@ -128,7 +129,7 @@ void CZMQNotificationInterface::Shutdown()\n         for (std::list<CZMQAbstractNotifier*>::iterator i=notifiers.begin(); i!=notifiers.end(); ++i)\n         {\n             CZMQAbstractNotifier *notifier = *i;\n-            LogPrint(BCLog::ZMQ, \"   Shutdown notifier %s at %s\\n\", notifier->GetType(), notifier->GetAddress());\n+            LogPrint(BCLog::ZMQ, \"zmq: Shutdown notifier %s at %s\\n\", notifier->GetType(), notifier->GetAddress());\n             notifier->Shutdown();\n         }\n         zmq_ctx_term(pcontext);"
      },
      {
        "sha": "15d4ac1b89cc145ea4be25dc5901cd3a2db3e843",
        "filename": "src/zmq/zmqpublishnotifier.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 4,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/zmq/zmqpublishnotifier.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/zmq/zmqpublishnotifier.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqpublishnotifier.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -7,7 +7,7 @@\n #include <streams.h>\n #include <zmq/zmqpublishnotifier.h>\n #include <validation.h>\n-#include <util.h>\n+#include <util/system.h>\n #include <rpc/server.h>\n \n static std::multimap<std::string, CZMQAbstractPublishNotifier*> mapPublishNotifiers;\n@@ -76,8 +76,18 @@ bool CZMQAbstractPublishNotifier::Initialize(void *pcontext)\n             return false;\n         }\n \n-        int rc = zmq_bind(psocket, address.c_str());\n-        if (rc!=0)\n+        LogPrint(BCLog::ZMQ, \"zmq: Outbound message high water mark for %s at %s is %d\\n\", type, address, outbound_message_high_water_mark);\n+\n+        int rc = zmq_setsockopt(psocket, ZMQ_SNDHWM, &outbound_message_high_water_mark, sizeof(outbound_message_high_water_mark));\n+        if (rc != 0)\n+        {\n+            zmqError(\"Failed to set outbound message high water mark\");\n+            zmq_close(psocket);\n+            return false;\n+        }\n+\n+        rc = zmq_bind(psocket, address.c_str());\n+        if (rc != 0)\n         {\n             zmqError(\"Failed to bind address\");\n             zmq_close(psocket);\n@@ -120,7 +130,7 @@ void CZMQAbstractPublishNotifier::Shutdown()\n \n     if (count == 1)\n     {\n-        LogPrint(BCLog::ZMQ, \"Close socket at address %s\\n\", address);\n+        LogPrint(BCLog::ZMQ, \"zmq: Close socket at address %s\\n\", address);\n         int linger = 0;\n         zmq_setsockopt(psocket, ZMQ_LINGER, &linger, sizeof(linger));\n         zmq_close(psocket);"
      },
      {
        "sha": "278fdb94d2ccdc8babd6fe02e9fa1339b47024a9",
        "filename": "src/zmq/zmqpublishnotifier.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/zmq/zmqpublishnotifier.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/zmq/zmqpublishnotifier.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqpublishnotifier.h?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -12,7 +12,7 @@ class CBlockIndex;\n class CZMQAbstractPublishNotifier : public CZMQAbstractNotifier\n {\n private:\n-    uint32_t nSequence; //!< upcounting per message sequence number\n+    uint32_t nSequence {0U}; //!< upcounting per message sequence number\n \n public:\n "
      },
      {
        "sha": "66b491427d6bd6656d0d7f8cfd7079ebc1d1466e",
        "filename": "src/zmq/zmqrpc.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/zmq/zmqrpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/src/zmq/zmqrpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqrpc.cpp?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -5,6 +5,7 @@\n #include <zmq/zmqrpc.h>\n \n #include <rpc/server.h>\n+#include <rpc/util.h>\n #include <zmq/zmqabstractnotifier.h>\n #include <zmq/zmqnotificationinterface.h>\n \n@@ -22,7 +23,8 @@ UniValue getzmqnotifications(const JSONRPCRequest& request)\n             \"[\\n\"\n             \"  {                        (json object)\\n\"\n             \"    \\\"type\\\": \\\"pubhashtx\\\",   (string) Type of notification\\n\"\n-            \"    \\\"address\\\": \\\"...\\\"       (string) Address of the publisher\\n\"\n+            \"    \\\"address\\\": \\\"...\\\",      (string) Address of the publisher\\n\"\n+            \"    \\\"hwm\\\": n                 (numeric) Outbound message high water mark\\n\"\n             \"  },\\n\"\n             \"  ...\\n\"\n             \"]\\n\"\n@@ -38,6 +40,7 @@ UniValue getzmqnotifications(const JSONRPCRequest& request)\n             UniValue obj(UniValue::VOBJ);\n             obj.pushKV(\"type\", n->GetType());\n             obj.pushKV(\"address\", n->GetAddress());\n+            obj.pushKV(\"hwm\", n->GetOutboundMessageHighWaterMark());\n             result.push_back(obj);\n         }\n     }"
      },
      {
        "sha": "57f2608ee99f3c6c1ed030c5da260ca7c94dea8f",
        "filename": "test/functional/data/rpc_psbt.json",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/data/rpc_psbt.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/data/rpc_psbt.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/data/rpc_psbt.json?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -17,7 +17,8 @@\n         \"cHNidP8BAJoCAAAAAljoeiG1ba8MI76OcHBFbDNvfLqlyHV5JPVFiHuyq911AAAAAAD/////g40EJ9DsZQpoqka7CwmK6kQiwHGyyng1Kgd5WdB86h0BAAAAAP////8CcKrwCAAAAAAWABTYXCtx0AYLCcmIauuBXlCZHdoSTQDh9QUAAAAAFgAUAK6pouXw+HaliN9VRuh0LR2HAI8AAAAAAAEAuwIAAAABqtc5MQGL0l+ErkALaISL4J23BurCrBgpi6vucatlb4sAAAAASEcwRAIgWPb8fGoz4bMVSNSByCbAFb0wE1qtQs1neQ2rZtKtJDsCIEoc7SYExnNbY5PltBaR3XiwDwxZQvufdRhW+qk4FX26Af7///8CgPD6AgAAAAAXqRQPuUY0IWlrgsgzryQceMF9295JNIfQ8gonAQAAABepFCnKdPigj4GZlCgYXJe12FLkBj9hh2UAAAABB9oARzBEAiB0AYrUGACXuHMyPAAVcgs2hMyBI4kQSOfbzZtVrWecmQIgc9Npt0Dj61Pc76M4I8gHBRTKVafdlUTxV8FnkTJhEYwBSDBFAiEA9hA4swjcHahlo0hSdG8BV3KTQgjG0kRUOTzZm98iF3cCIAVuZ1pnWm0KArhbFOXikHTYolqbV2C+ooFvZhkQoAbqAUdSIQKVg785rgpgl0etGZrd1jT6YQhVnWxc05tMIYPxq5bgfyEC2rYf9JoU22p9ArDNH7t4/EsYMStbTlTa5Nui+/71NtdSrgABASAAwusLAAAAABepFLf1+vQOPUClpFmx2zU18rcvqSHohwEHIyIAIIwjUxc3Q7WV37Sge3K6jkLjeX2nTof+fZ10l+OyAokDAQjaBABHMEQCIGLrelVhB6fHP0WsSrWh3d9vcHX7EnWWmn84Pv/3hLyyAiAMBdu3Rw2/LwhVfdNWxzJcHtMJE+mWzThAlF2xIijaXwFHMEQCIGX0W6WZi1mif/4ae+0BavHx+Q1Us6qPdFCqX1aiUQO9AiB/ckcDrR7blmgLKEtW1P/LiPf7dZ6rvgiqMPKbhROD0gFHUiEDCJ3BDHrG21T5EymvYXMz2ziM6tDCMfcjN50bmQMLAtwhAjrdkE89bc9Z3bkGsN7iNSm3/7ntUOXoYVGSaGAiHw5zUq4AIQIDqaTDf1mW06ol26xrVwrwZQOUSSlCRgs1R1PtnuylhxDZDGpPAAAAgAAAAIAEAACAACICAn9jmXV9Lv9VoTatAsaEsYOLZVbl8bazQoKpS2tQBRCWENkMak8AAACAAAAAgAUAAIAA\",\n         \"cHNidP8BAHMCAAAAATAa6YblFqHsisW0vGVz0y+DtGXiOtdhZ9aLOOcwtNvbAAAAAAD/////AnR7AQAAAAAAF6kUA6oXrogrXQ1Usl1jEE5P/s57nqKHYEOZOwAAAAAXqRS5IbG6b3IuS/qDtlV6MTmYakLsg4cAAAAAAAEBHwDKmjsAAAAAFgAU0tlLZK4IWH7vyO6xh8YB6Tn5A3wCAwABAAAAAAEAFgAUYunpgv/zTdgjlhAxawkM0qO3R8sAAQAiACCHa62DLx0WgBXtQSMqnqZaGBXZ7xPA74dZ9ktbKyeKZQEBJVEhA7fOI6AcW0vwCmQlN836uzFbZoMyhnR471EwnSvVf4qHUa4A\",\n         \"cHNidP8BAHMCAAAAATAa6YblFqHsisW0vGVz0y+DtGXiOtdhZ9aLOOcwtNvbAAAAAAD/////AnR7AQAAAAAAF6kUA6oXrogrXQ1Usl1jEE5P/s57nqKHYEOZOwAAAAAXqRS5IbG6b3IuS/qDtlV6MTmYakLsg4cAAAAAAAEBHwDKmjsAAAAAFgAU0tlLZK4IWH7vyO6xh8YB6Tn5A3wAAgAAFgAUYunpgv/zTdgjlhAxawkM0qO3R8sAAQAiACCHa62DLx0WgBXtQSMqnqZaGBXZ7xPA74dZ9ktbKyeKZQEBJVEhA7fOI6AcW0vwCmQlN836uzFbZoMyhnR471EwnSvVf4qHUa4A\",\n-        \"cHNidP8BAHMCAAAAATAa6YblFqHsisW0vGVz0y+DtGXiOtdhZ9aLOOcwtNvbAAAAAAD/////AnR7AQAAAAAAF6kUA6oXrogrXQ1Usl1jEE5P/s57nqKHYEOZOwAAAAAXqRS5IbG6b3IuS/qDtlV6MTmYakLsg4cAAAAAAAEBHwDKmjsAAAAAFgAU0tlLZK4IWH7vyO6xh8YB6Tn5A3wAAQAWABRi6emC//NN2COWEDFrCQzSo7dHywABACIAIIdrrYMvHRaAFe1BIyqeploYFdnvE8Dvh1n2S1srJ4plIQEAJVEhA7fOI6AcW0vwCmQlN836uzFbZoMyhnR471EwnSvVf4qHUa4A\"\n+        \"cHNidP8BAHMCAAAAATAa6YblFqHsisW0vGVz0y+DtGXiOtdhZ9aLOOcwtNvbAAAAAAD/////AnR7AQAAAAAAF6kUA6oXrogrXQ1Usl1jEE5P/s57nqKHYEOZOwAAAAAXqRS5IbG6b3IuS/qDtlV6MTmYakLsg4cAAAAAAAEBHwDKmjsAAAAAFgAU0tlLZK4IWH7vyO6xh8YB6Tn5A3wAAQAWABRi6emC//NN2COWEDFrCQzSo7dHywABACIAIIdrrYMvHRaAFe1BIyqeploYFdnvE8Dvh1n2S1srJ4plIQEAJVEhA7fOI6AcW0vwCmQlN836uzFbZoMyhnR471EwnSvVf4qHUa4A\",\n+        \"cHNidP8BAHMCAAAAAbiWoY6pOQepFsEGhUPXaulX9rvye2NH+NrdlAHg+WgpAQAAAAD/////AkBLTAAAAAAAF6kUqWwXCcLM5BN2zoNqMNT5qMlIi7+HQEtMAAAAAAAXqRSVF/in2XNxAlN1OSxkyp0z+Wtg2YcAAAAAAAEBIBNssgAAAAAAF6kUamsvautR8hRlMRY6OKNTx03DK96HAQcXFgAUo8u1LWpHprjt/uENAwBpGZD0UH0BCGsCRzBEAiAONfH3DYiw67ZbylrsxCF/XXpVwyWBRgofyRbPslzvwgIgIKCsWw5sHSIPh1icNvcVLZLHWj6NA7Dk+4Os2pOnMbQBIQPGStfYHPtyhpV7zIWtn0Q4GXv5gK1zy/tnJ+cBXu4iiwABABYAFMwmJQEz+HDpBEEabxJ5PogPsqZRAAEAFgAUyCrGc3h3FYCmiIspbv2pSTKZ5jU\"\n     ],\n     \"valid\" : [\n         \"cHNidP8BAHUCAAAAASaBcTce3/KF6Tet7qSze3gADAVmy7OtZGQXE8pCFxv2AAAAAAD+////AtPf9QUAAAAAGXapFNDFmQPFusKGh2DpD9UhpGZap2UgiKwA4fUFAAAAABepFDVF5uM7gyxHBQ8k0+65PJwDlIvHh7MuEwAAAQD9pQEBAAAAAAECiaPHHqtNIOA3G7ukzGmPopXJRjr6Ljl/hTPMti+VZ+UBAAAAFxYAFL4Y0VKpsBIDna89p95PUzSe7LmF/////4b4qkOnHf8USIk6UwpyN+9rRgi7st0tAXHmOuxqSJC0AQAAABcWABT+Pp7xp0XpdNkCxDVZQ6vLNL1TU/////8CAMLrCwAAAAAZdqkUhc/xCX/Z4Ai7NK9wnGIZeziXikiIrHL++E4sAAAAF6kUM5cluiHv1irHU6m80GfWx6ajnQWHAkcwRAIgJxK+IuAnDzlPVoMR3HyppolwuAJf3TskAinwf4pfOiQCIAGLONfc0xTnNMkna9b7QPZzMlvEuqFEyADS8vAtsnZcASED0uFWdJQbrUqZY3LLh+GFbTZSYG2YVi/jnF6efkE/IQUCSDBFAiEA0SuFLYXc2WHS9fSrZgZU327tzHlMDDPOXMMJ/7X85Y0CIGczio4OFyXBl/saiK9Z9R5E5CVbIBZ8hoQDHAXR8lkqASECI7cr7vCWXRC+B3jv7NYfysb3mk6haTkzgHNEZPhPKrMAAAAAAAAA\","
      },
      {
        "sha": "be3544ee74cfc3f13dbdcfb6fa0ada3c5bb9dac2",
        "filename": "test/functional/example_test.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/example_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/example_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/example_test.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -164,13 +164,13 @@ def run_test(self):\n         self.tip = int(self.nodes[0].getbestblockhash(), 16)\n         self.block_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time'] + 1\n \n-        height = 1\n+        height = self.nodes[0].getblockcount()\n \n         for i in range(10):\n             # Use the mininode and blocktools functionality to manually build a block\n             # Calling the generate() rpc is easier, but this allows us to exactly\n             # control the blocks and transactions.\n-            block = create_block(self.tip, create_coinbase(height), self.block_time)\n+            block = create_block(self.tip, create_coinbase(height+1), self.block_time)\n             block.solve()\n             block_message = msg_block(block)\n             # Send message is used to send a P2P message to the node over our P2PInterface"
      },
      {
        "sha": "e386915ada016dcaacad39ab2b47119a813f0f79",
        "filename": "test/functional/feature_block.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/feature_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/feature_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_block.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -824,7 +824,7 @@ def run_test(self):\n         tx.vin.append(CTxIn(COutPoint(b64a.vtx[1].sha256, 0)))\n         b64a = self.update_block(\"64a\", [tx])\n         assert_equal(len(b64a.serialize()), MAX_BLOCK_BASE_SIZE + 8)\n-        self.sync_blocks([b64a], success=False, reject_reason='non-canonical ReadCompactSize():')\n+        self.sync_blocks([b64a], success=False, reject_reason='non-canonical ReadCompactSize()')\n \n         # bitcoind doesn't disconnect us for sending a bloated block, but if we subsequently\n         # resend the header message, it won't send us the getdata message again. Just"
      },
      {
        "sha": "302a5ec1cb14bda869031e0746b190c4714056b0",
        "filename": "test/functional/feature_cltv.py",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/feature_cltv.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/feature_cltv.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_cltv.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -25,7 +25,6 @@\n \n # Reject codes that we might receive in this test\n REJECT_INVALID = 16\n-REJECT_OBSOLETE = 17\n REJECT_NONSTANDARD = 64\n \n def cltv_invalidate(tx):"
      },
      {
        "sha": "88a9aadc7b7810e1567ed0f609ea78b94b4a7232",
        "filename": "test/functional/feature_config_args.py",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/feature_config_args.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/feature_config_args.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_config_args.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -29,6 +29,10 @@ def test_config_file_parser(self):\n             conf.write('nono\\n')\n         self.nodes[0].assert_start_raises_init_error(expected_msg='Error reading configuration file: parse error on line 1: nono, if you intended to specify a negated option, use nono=1 instead')\n \n+        with open(inc_conf_file_path, 'w', encoding='utf-8') as conf:\n+            conf.write('server=1\\nrpcuser=someuser\\nrpcpassword=some#pass')\n+        self.nodes[0].assert_start_raises_init_error(expected_msg='Error reading configuration file: parse error on line 3, using # in rpcpassword can be ambiguous and should be avoided')\n+\n         with open(inc_conf_file_path, 'w', encoding='utf-8') as conf:\n             conf.write('')  # clear\n "
      },
      {
        "sha": "70d67aa53aca45c7c7c55e42934217d7523d5f76",
        "filename": "test/functional/feature_dbcrash.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/feature_dbcrash.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/feature_dbcrash.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_dbcrash.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -69,6 +69,7 @@ def skip_test_if_missing_module(self):\n     def setup_network(self):\n         self.add_nodes(self.num_nodes, extra_args=self.extra_args)\n         self.start_nodes()\n+        self.import_deterministic_coinbase_privkeys()\n         # Leave them unconnected, we'll use submitblock directly in this test\n \n     def restart_node(self, node_index, expected_tip):"
      },
      {
        "sha": "9cbc1b39bd7c0bd6bc936aa99d6e802535dd8d52",
        "filename": "test/functional/feature_dersig.py",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/feature_dersig.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/feature_dersig.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_dersig.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -22,7 +22,6 @@\n \n # Reject codes that we might receive in this test\n REJECT_INVALID = 16\n-REJECT_OBSOLETE = 17\n REJECT_NONSTANDARD = 64\n \n # A canonical signature consists of:"
      },
      {
        "sha": "b68e46adbc75b01f2526ef4539ffbb8b7592b2e4",
        "filename": "test/functional/feature_fee_estimation.py",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/feature_fee_estimation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/feature_fee_estimation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_fee_estimation.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -144,6 +144,9 @@ def setup_network(self):\n         # (68k weight is room enough for 120 or so transactions)\n         # Node2 is a stingy miner, that\n         # produces too small blocks (room for only 55 or so transactions)\n+        self.start_nodes()\n+        self.import_deterministic_coinbase_privkeys()\n+        self.stop_nodes()\n \n     def transact_and_mine(self, numblocks, mining_node):\n         min_fee = Decimal(\"0.00001\")\n@@ -171,11 +174,6 @@ def transact_and_mine(self, numblocks, mining_node):\n                     newmem.append(utx)\n             self.memutxo = newmem\n \n-    def import_deterministic_coinbase_privkeys(self):\n-        self.start_nodes()\n-        super().import_deterministic_coinbase_privkeys()\n-        self.stop_nodes()\n-\n     def run_test(self):\n         self.log.info(\"This test is time consuming, please be patient\")\n         self.log.info(\"Splitting inputs so we can generate tx's\")"
      },
      {
        "sha": "eb76089d9c49d65754f4416f830bef5107af98ac",
        "filename": "test/functional/feature_nulldummy.py",
        "status": "modified",
        "additions": 7,
        "deletions": 9,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/feature_nulldummy.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/feature_nulldummy.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_nulldummy.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -12,15 +12,14 @@\n [Consensus] Check that the new NULLDUMMY rules are not enforced on the 431st block.\n [Policy/Consensus] Check that the new NULLDUMMY rules are enforced on the 432nd block.\n \"\"\"\n+import time\n \n from test_framework.blocktools import create_coinbase, create_block, create_transaction, add_witness_commitment\n from test_framework.messages import CTransaction\n from test_framework.script import CScript\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal, assert_raises_rpc_error, bytes_to_hex_str\n \n-import time\n-\n NULLDUMMY_ERROR = \"non-mandatory-script-verify-flag (Dummy CHECKMULTISIG argument must be zero) (code 64)\"\n \n def trueDummy(tx):\n@@ -42,22 +41,22 @@ def set_test_params(self):\n         self.setup_clean_chain = True\n         # This script tests NULLDUMMY activation, which is part of the 'segwit' deployment, so we go through\n         # normal segwit activation here (and don't use the default always-on behaviour).\n-        self.extra_args = [['-whitelist=127.0.0.1', '-vbparams=segwit:0:999999999999', '-addresstype=legacy', \"-deprecatedrpc=addwitnessaddress\"]]\n+        self.extra_args = [['-whitelist=127.0.0.1', '-vbparams=segwit:0:999999999999', '-addresstype=legacy']]\n \n     def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()\n \n     def run_test(self):\n         self.address = self.nodes[0].getnewaddress()\n         self.ms_address = self.nodes[0].addmultisigaddress(1, [self.address])['address']\n-        self.wit_address = self.nodes[0].addwitnessaddress(self.address)\n+        self.wit_address = self.nodes[0].getnewaddress(address_type='p2sh-segwit')\n         self.wit_ms_address = self.nodes[0].addmultisigaddress(1, [self.address], '', 'p2sh-segwit')['address']\n \n-        self.coinbase_blocks = self.nodes[0].generate(2) # Block 2\n+        self.coinbase_blocks = self.nodes[0].generate(2)  # Block 2\n         coinbase_txid = []\n         for i in self.coinbase_blocks:\n             coinbase_txid.append(self.nodes[0].getblock(i)['tx'][0])\n-        self.nodes[0].generate(427) # Block 429\n+        self.nodes[0].generate(427)  # Block 429\n         self.lastblockhash = self.nodes[0].getbestblockhash()\n         self.tip = int(\"0x\" + self.lastblockhash, 0)\n         self.lastblockheight = 429\n@@ -82,7 +81,7 @@ def run_test(self):\n \n         self.log.info(\"Test 4: Non-NULLDUMMY base multisig transaction is invalid after activation\")\n         test4tx = create_transaction(self.nodes[0], test2tx.hash, self.address, amount=46)\n-        test6txs=[CTransaction(test4tx)]\n+        test6txs = [CTransaction(test4tx)]\n         trueDummy(test4tx)\n         assert_raises_rpc_error(-26, NULLDUMMY_ERROR, self.nodes[0].sendrawtransaction, bytes_to_hex_str(test4tx.serialize_with_witness()), True)\n         self.block_submit(self.nodes[0], [test4tx])\n@@ -99,8 +98,7 @@ def run_test(self):\n             self.nodes[0].sendrawtransaction(bytes_to_hex_str(i.serialize_with_witness()), True)\n         self.block_submit(self.nodes[0], test6txs, True, True)\n \n-\n-    def block_submit(self, node, txs, witness = False, accept = False):\n+    def block_submit(self, node, txs, witness=False, accept=False):\n         block = create_block(self.tip, create_coinbase(self.lastblockheight + 1), self.lastblocktime + 1)\n         block.nVersion = 4\n         for tx in txs:"
      },
      {
        "sha": "c162f46d63703ef19f4f04b5a2565d95cb40444e",
        "filename": "test/functional/feature_pruning.py",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/feature_pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/feature_pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_pruning.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -63,6 +63,8 @@ def setup_network(self):\n     def setup_nodes(self):\n         self.add_nodes(self.num_nodes, self.extra_args)\n         self.start_nodes()\n+        for n in self.nodes:\n+            n.importprivkey(privkey=n.get_deterministic_priv_key().key, label='coinbase', rescan=False)\n \n     def create_big_chain(self):\n         # Start by creating some coinbases we can spend later\n@@ -247,7 +249,7 @@ def height(index):\n                 return index\n \n         def prune(index, expected_ret=None):\n-            ret = node.pruneblockchain(height(index))\n+            ret = node.pruneblockchain(height=height(index))\n             # Check the return value. When use_timestamp is True, just check\n             # that the return value is less than or equal to the expected\n             # value, because when more than one block is generated per second,"
      },
      {
        "sha": "7098a03f1ec0ea3a4c2935b26ccf0896342a6167",
        "filename": "test/functional/feature_segwit.py",
        "status": "modified",
        "additions": 50,
        "deletions": 100,
        "changes": 150,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/feature_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/feature_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_segwit.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -5,11 +5,10 @@\n \"\"\"Test the SegWit changeover logic.\"\"\"\n \n from decimal import Decimal\n+from io import BytesIO\n \n from test_framework.address import (\n     key_to_p2pkh,\n-    key_to_p2sh_p2wpkh,\n-    key_to_p2wpkh,\n     program_to_witness,\n     script_to_p2sh,\n     script_to_p2sh_p2wsh,\n@@ -21,8 +20,6 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal, assert_raises_rpc_error, bytes_to_hex_str, connect_nodes, hex_str_to_bytes, sync_blocks, try_rpc\n \n-from io import BytesIO\n-\n NODE_0 = 0\n NODE_2 = 2\n WIT_V0 = 0\n@@ -51,20 +48,17 @@ def set_test_params(self):\n                 \"-rpcserialversion=0\",\n                 \"-vbparams=segwit:0:999999999999\",\n                 \"-addresstype=legacy\",\n-                \"-deprecatedrpc=addwitnessaddress\",\n             ],\n             [\n                 \"-blockversion=4\",\n                 \"-rpcserialversion=1\",\n                 \"-vbparams=segwit:0:999999999999\",\n                 \"-addresstype=legacy\",\n-                \"-deprecatedrpc=addwitnessaddress\",\n             ],\n             [\n                 \"-blockversion=536870915\",\n                 \"-vbparams=segwit:0:999999999999\",\n                 \"-addresstype=legacy\",\n-                \"-deprecatedrpc=addwitnessaddress\",\n             ],\n         ]\n \n@@ -91,9 +85,8 @@ def skip_mine(self, node, txid, sign, redeem_script=\"\"):\n     def fail_accept(self, node, error_msg, txid, sign, redeem_script=\"\"):\n         assert_raises_rpc_error(-26, error_msg, send_to_witness, use_p2wsh=1, node=node, utxo=getutxo(txid), pubkey=self.pubkey[0], encode_p2sh=False, amount=Decimal(\"49.998\"), sign=sign, insert_redeem_script=redeem_script)\n \n-\n     def run_test(self):\n-        self.nodes[0].generate(161) #block 161\n+        self.nodes[0].generate(161)  # block 161\n \n         self.log.info(\"Verify sigops are counted in GBT with pre-BIP141 rules before the fork\")\n         txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n@@ -103,28 +96,24 @@ def run_test(self):\n         assert(tmpl['sigoplimit'] == 20000)\n         assert(tmpl['transactions'][0]['hash'] == txid)\n         assert(tmpl['transactions'][0]['sigops'] == 2)\n-        tmpl = self.nodes[0].getblocktemplate({'rules':['segwit']})\n+        tmpl = self.nodes[0].getblocktemplate({'rules': ['segwit']})\n         assert(tmpl['sizelimit'] == 1000000)\n         assert('weightlimit' not in tmpl)\n         assert(tmpl['sigoplimit'] == 20000)\n         assert(tmpl['transactions'][0]['hash'] == txid)\n         assert(tmpl['transactions'][0]['sigops'] == 2)\n-        self.nodes[0].generate(1) #block 162\n+        self.nodes[0].generate(1)  # block 162\n \n         balance_presetup = self.nodes[0].getbalance()\n         self.pubkey = []\n-        p2sh_ids = [] # p2sh_ids[NODE][VER] is an array of txids that spend to a witness version VER pkscript to an address for NODE embedded in p2sh\n-        wit_ids = [] # wit_ids[NODE][VER] is an array of txids that spend to a witness version VER pkscript to an address for NODE via bare witness\n+        p2sh_ids = []  # p2sh_ids[NODE][VER] is an array of txids that spend to a witness version VER pkscript to an address for NODE embedded in p2sh\n+        wit_ids = []  # wit_ids[NODE][VER] is an array of txids that spend to a witness version VER pkscript to an address for NODE via bare witness\n         for i in range(3):\n             newaddress = self.nodes[i].getnewaddress()\n             self.pubkey.append(self.nodes[i].getaddressinfo(newaddress)[\"pubkey\"])\n             multiscript = CScript([OP_1, hex_str_to_bytes(self.pubkey[-1]), OP_1, OP_CHECKMULTISIG])\n-            p2sh_addr = self.nodes[i].addwitnessaddress(newaddress)\n-            bip173_addr = self.nodes[i].addwitnessaddress(newaddress, False)\n             p2sh_ms_addr = self.nodes[i].addmultisigaddress(1, [self.pubkey[-1]], '', 'p2sh-segwit')['address']\n             bip173_ms_addr = self.nodes[i].addmultisigaddress(1, [self.pubkey[-1]], '', 'bech32')['address']\n-            assert_equal(p2sh_addr, key_to_p2sh_p2wpkh(self.pubkey[-1]))\n-            assert_equal(bip173_addr, key_to_p2wpkh(self.pubkey[-1]))\n             assert_equal(p2sh_ms_addr, script_to_p2sh_p2wsh(multiscript))\n             assert_equal(bip173_ms_addr, script_to_p2wsh(multiscript))\n             p2sh_ids.append([])\n@@ -139,32 +128,32 @@ def run_test(self):\n                     wit_ids[n][v].append(send_to_witness(v, self.nodes[0], find_spendable_utxo(self.nodes[0], 50), self.pubkey[n], False, Decimal(\"49.999\")))\n                     p2sh_ids[n][v].append(send_to_witness(v, self.nodes[0], find_spendable_utxo(self.nodes[0], 50), self.pubkey[n], True, Decimal(\"49.999\")))\n \n-        self.nodes[0].generate(1) #block 163\n+        self.nodes[0].generate(1)  # block 163\n         sync_blocks(self.nodes)\n \n         # Make sure all nodes recognize the transactions as theirs\n-        assert_equal(self.nodes[0].getbalance(), balance_presetup - 60*50 + 20*Decimal(\"49.999\") + 50)\n-        assert_equal(self.nodes[1].getbalance(), 20*Decimal(\"49.999\"))\n-        assert_equal(self.nodes[2].getbalance(), 20*Decimal(\"49.999\"))\n+        assert_equal(self.nodes[0].getbalance(), balance_presetup - 60 * 50 + 20 * Decimal(\"49.999\") + 50)\n+        assert_equal(self.nodes[1].getbalance(), 20 * Decimal(\"49.999\"))\n+        assert_equal(self.nodes[2].getbalance(), 20 * Decimal(\"49.999\"))\n \n-        self.nodes[0].generate(260) #block 423\n+        self.nodes[0].generate(260)  # block 423\n         sync_blocks(self.nodes)\n \n         self.log.info(\"Verify witness txs are skipped for mining before the fork\")\n-        self.skip_mine(self.nodes[2], wit_ids[NODE_2][WIT_V0][0], True) #block 424\n-        self.skip_mine(self.nodes[2], wit_ids[NODE_2][WIT_V1][0], True) #block 425\n-        self.skip_mine(self.nodes[2], p2sh_ids[NODE_2][WIT_V0][0], True) #block 426\n-        self.skip_mine(self.nodes[2], p2sh_ids[NODE_2][WIT_V1][0], True) #block 427\n+        self.skip_mine(self.nodes[2], wit_ids[NODE_2][WIT_V0][0], True)  # block 424\n+        self.skip_mine(self.nodes[2], wit_ids[NODE_2][WIT_V1][0], True)  # block 425\n+        self.skip_mine(self.nodes[2], p2sh_ids[NODE_2][WIT_V0][0], True)  # block 426\n+        self.skip_mine(self.nodes[2], p2sh_ids[NODE_2][WIT_V1][0], True)  # block 427\n \n         self.log.info(\"Verify unsigned p2sh witness txs without a redeem script are invalid\")\n         self.fail_accept(self.nodes[2], \"mandatory-script-verify-flag\", p2sh_ids[NODE_2][WIT_V0][1], False)\n         self.fail_accept(self.nodes[2], \"mandatory-script-verify-flag\", p2sh_ids[NODE_2][WIT_V1][1], False)\n \n-        self.nodes[2].generate(4) # blocks 428-431\n+        self.nodes[2].generate(4)  # blocks 428-431\n \n         self.log.info(\"Verify previous witness txs skipped for mining can now be mined\")\n         assert_equal(len(self.nodes[2].getrawmempool()), 4)\n-        block = self.nodes[2].generate(1) #block 432 (first block with new rules; 432 = 144 * 3)\n+        block = self.nodes[2].generate(1)  # block 432 (first block with new rules; 432 = 144 * 3)\n         sync_blocks(self.nodes)\n         assert_equal(len(self.nodes[2].getrawmempool()), 0)\n         segwit_tx_list = self.nodes[2].getblock(block[0])[\"tx\"]\n@@ -181,8 +170,8 @@ def run_test(self):\n         self.fail_accept(self.nodes[0], \"mandatory-script-verify-flag\", p2sh_ids[NODE_0][WIT_V1][0], False, witness_script(True, self.pubkey[0]))\n \n         self.log.info(\"Verify block and transaction serialization rpcs return differing serializations depending on rpc serialization flag\")\n-        assert(self.nodes[2].getblock(block[0], False) !=  self.nodes[0].getblock(block[0], False))\n-        assert(self.nodes[1].getblock(block[0], False) ==  self.nodes[2].getblock(block[0], False))\n+        assert(self.nodes[2].getblock(block[0], False) != self.nodes[0].getblock(block[0], False))\n+        assert(self.nodes[1].getblock(block[0], False) == self.nodes[2].getblock(block[0], False))\n         for i in range(len(segwit_tx_list)):\n             tx = FromHex(CTransaction(), self.nodes[2].gettransaction(segwit_tx_list[i])[\"hex\"])\n             assert(self.nodes[2].getrawtransaction(segwit_tx_list[i]) != self.nodes[0].getrawtransaction(segwit_tx_list[i]))\n@@ -198,21 +187,21 @@ def run_test(self):\n         self.fail_accept(self.nodes[2], 'non-mandatory-script-verify-flag (Witness program was passed an empty witness) (code 64)', p2sh_ids[NODE_2][WIT_V1][2], sign=False, redeem_script=witness_script(True, self.pubkey[2]))\n \n         self.log.info(\"Verify default node can now use witness txs\")\n-        self.success_mine(self.nodes[0], wit_ids[NODE_0][WIT_V0][0], True) #block 432\n-        self.success_mine(self.nodes[0], wit_ids[NODE_0][WIT_V1][0], True) #block 433\n-        self.success_mine(self.nodes[0], p2sh_ids[NODE_0][WIT_V0][0], True) #block 434\n-        self.success_mine(self.nodes[0], p2sh_ids[NODE_0][WIT_V1][0], True) #block 435\n+        self.success_mine(self.nodes[0], wit_ids[NODE_0][WIT_V0][0], True)  # block 432\n+        self.success_mine(self.nodes[0], wit_ids[NODE_0][WIT_V1][0], True)  # block 433\n+        self.success_mine(self.nodes[0], p2sh_ids[NODE_0][WIT_V0][0], True)  # block 434\n+        self.success_mine(self.nodes[0], p2sh_ids[NODE_0][WIT_V1][0], True)  # block 435\n \n         self.log.info(\"Verify sigops are counted in GBT with BIP141 rules after the fork\")\n         txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n-        tmpl = self.nodes[0].getblocktemplate({'rules':['segwit']})\n+        tmpl = self.nodes[0].getblocktemplate({'rules': ['segwit']})\n         assert(tmpl['sizelimit'] >= 3999577)  # actual maximum size is lower due to minimum mandatory non-witness data\n         assert(tmpl['weightlimit'] == 4000000)\n         assert(tmpl['sigoplimit'] == 80000)\n         assert(tmpl['transactions'][0]['txid'] == txid)\n         assert(tmpl['transactions'][0]['sigops'] == 8)\n \n-        self.nodes[0].generate(1) # Mine a block to clear the gbt cache\n+        self.nodes[0].generate(1)  # Mine a block to clear the gbt cache\n \n         self.log.info(\"Non-segwit miners are able to use GBT response after activation.\")\n         # Create a 3-tx chain: tx1 (non-segwit input, paying to a segwit output) ->\n@@ -222,7 +211,7 @@ def run_test(self):\n         txid1 = send_to_witness(1, self.nodes[0], find_spendable_utxo(self.nodes[0], 50), self.pubkey[0], False, Decimal(\"49.996\"))\n         hex_tx = self.nodes[0].gettransaction(txid)['hex']\n         tx = FromHex(CTransaction(), hex_tx)\n-        assert(tx.wit.is_null()) # This should not be a segwit input\n+        assert(tx.wit.is_null())  # This should not be a segwit input\n         assert(txid1 in self.nodes[0].getrawmempool())\n \n         # Now create tx2, which will spend from txid1.\n@@ -247,13 +236,13 @@ def run_test(self):\n         template = self.nodes[0].getblocktemplate()\n \n         # Check that tx1 is the only transaction of the 3 in the template.\n-        template_txids = [ t['txid'] for t in template['transactions'] ]\n+        template_txids = [t['txid'] for t in template['transactions']]\n         assert(txid2 not in template_txids and txid3 not in template_txids)\n         assert(txid1 in template_txids)\n \n         # Check that running with segwit support results in all 3 being included.\n         template = self.nodes[0].getblocktemplate({\"rules\": [\"segwit\"]})\n-        template_txids = [ t['txid'] for t in template['transactions'] ]\n+        template_txids = [t['txid'] for t in template['transactions']]\n         assert(txid1 in template_txids)\n         assert(txid2 in template_txids)\n         assert(txid3 in template_txids)\n@@ -264,26 +253,26 @@ def run_test(self):\n         # Mine a block to clear the gbt cache again.\n         self.nodes[0].generate(1)\n \n-        self.log.info(\"Verify behaviour of importaddress, addwitnessaddress and listunspent\")\n+        self.log.info(\"Verify behaviour of importaddress and listunspent\")\n \n         # Some public keys to be used later\n         pubkeys = [\n-            \"0363D44AABD0F1699138239DF2F042C3282C0671CC7A76826A55C8203D90E39242\", # cPiM8Ub4heR9NBYmgVzJQiUH1if44GSBGiqaeJySuL2BKxubvgwb\n-            \"02D3E626B3E616FC8662B489C123349FECBFC611E778E5BE739B257EAE4721E5BF\", # cPpAdHaD6VoYbW78kveN2bsvb45Q7G5PhaPApVUGwvF8VQ9brD97\n-            \"04A47F2CBCEFFA7B9BCDA184E7D5668D3DA6F9079AD41E422FA5FD7B2D458F2538A62F5BD8EC85C2477F39650BD391EA6250207065B2A81DA8B009FC891E898F0E\", # 91zqCU5B9sdWxzMt1ca3VzbtVm2YM6Hi5Rxn4UDtxEaN9C9nzXV\n-            \"02A47F2CBCEFFA7B9BCDA184E7D5668D3DA6F9079AD41E422FA5FD7B2D458F2538\", # cPQFjcVRpAUBG8BA9hzr2yEzHwKoMgLkJZBBtK9vJnvGJgMjzTbd\n-            \"036722F784214129FEB9E8129D626324F3F6716555B603FFE8300BBCB882151228\", # cQGtcm34xiLjB1v7bkRa4V3aAc9tS2UTuBZ1UnZGeSeNy627fN66\n-            \"0266A8396EE936BF6D99D17920DB21C6C7B1AB14C639D5CD72B300297E416FD2EC\", # cTW5mR5M45vHxXkeChZdtSPozrFwFgmEvTNnanCW6wrqwaCZ1X7K\n-            \"0450A38BD7F0AC212FEBA77354A9B036A32E0F7C81FC4E0C5ADCA7C549C4505D2522458C2D9AE3CEFD684E039194B72C8A10F9CB9D4764AB26FCC2718D421D3B84\", # 92h2XPssjBpsJN5CqSP7v9a7cf2kgDunBC6PDFwJHMACM1rrVBJ\n+            \"0363D44AABD0F1699138239DF2F042C3282C0671CC7A76826A55C8203D90E39242\",  # cPiM8Ub4heR9NBYmgVzJQiUH1if44GSBGiqaeJySuL2BKxubvgwb\n+            \"02D3E626B3E616FC8662B489C123349FECBFC611E778E5BE739B257EAE4721E5BF\",  # cPpAdHaD6VoYbW78kveN2bsvb45Q7G5PhaPApVUGwvF8VQ9brD97\n+            \"04A47F2CBCEFFA7B9BCDA184E7D5668D3DA6F9079AD41E422FA5FD7B2D458F2538A62F5BD8EC85C2477F39650BD391EA6250207065B2A81DA8B009FC891E898F0E\",  # 91zqCU5B9sdWxzMt1ca3VzbtVm2YM6Hi5Rxn4UDtxEaN9C9nzXV\n+            \"02A47F2CBCEFFA7B9BCDA184E7D5668D3DA6F9079AD41E422FA5FD7B2D458F2538\",  # cPQFjcVRpAUBG8BA9hzr2yEzHwKoMgLkJZBBtK9vJnvGJgMjzTbd\n+            \"036722F784214129FEB9E8129D626324F3F6716555B603FFE8300BBCB882151228\",  # cQGtcm34xiLjB1v7bkRa4V3aAc9tS2UTuBZ1UnZGeSeNy627fN66\n+            \"0266A8396EE936BF6D99D17920DB21C6C7B1AB14C639D5CD72B300297E416FD2EC\",  # cTW5mR5M45vHxXkeChZdtSPozrFwFgmEvTNnanCW6wrqwaCZ1X7K\n+            \"0450A38BD7F0AC212FEBA77354A9B036A32E0F7C81FC4E0C5ADCA7C549C4505D2522458C2D9AE3CEFD684E039194B72C8A10F9CB9D4764AB26FCC2718D421D3B84\",  # 92h2XPssjBpsJN5CqSP7v9a7cf2kgDunBC6PDFwJHMACM1rrVBJ\n         ]\n \n         # Import a compressed key and an uncompressed key, generate some multisig addresses\n         self.nodes[0].importprivkey(\"92e6XLo5jVAVwrQKPNTs93oQco8f8sDNBcpv73Dsrs397fQtFQn\")\n         uncompressed_spendable_address = [\"mvozP4UwyGD2mGZU4D2eMvMLPB9WkMmMQu\"]\n         self.nodes[0].importprivkey(\"cNC8eQ5dg3mFAVePDX4ddmPYpPbw41r9bm2jd1nLJT77e6RrzTRR\")\n         compressed_spendable_address = [\"mmWQubrDomqpgSYekvsU7HWEVjLFHAakLe\"]\n-        assert ((self.nodes[0].getaddressinfo(uncompressed_spendable_address[0])['iscompressed'] == False))\n-        assert ((self.nodes[0].getaddressinfo(compressed_spendable_address[0])['iscompressed'] == True))\n+        assert not self.nodes[0].getaddressinfo(uncompressed_spendable_address[0])['iscompressed']\n+        assert self.nodes[0].getaddressinfo(compressed_spendable_address[0])['iscompressed']\n \n         self.nodes[0].importpubkey(pubkeys[0])\n         compressed_solvable_address = [key_to_p2pkh(pubkeys[0])]\n@@ -305,7 +294,6 @@ def run_test(self):\n         uncompressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], uncompressed_solvable_address[0]])['address'])\n         compressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_solvable_address[0]])['address'])\n         compressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_solvable_address[0], compressed_solvable_address[1]])['address'])\n-        unknown_address = [\"mtKKyoHabkk6e4ppT7NaM7THqPUt7AzPrT\", \"2NDP3jLWAFT8NDAiUa9qiE6oBt2awmMq7Dx\"]\n \n         # Test multisig_without_privkey\n         # We have 2 public keys without private keys, use addmultisigaddress to add to wallet.\n@@ -386,17 +374,16 @@ def run_test(self):\n         op1 = CScript([OP_1])\n         op0 = CScript([OP_0])\n         # 2N7MGY19ti4KDMSzRfPAssP6Pxyuxoi6jLe is the P2SH(P2PKH) version of mjoE3sSrb8ByYEvgnC3Aox86u1CHnfJA4V\n-        unsolvable_address = [\"mjoE3sSrb8ByYEvgnC3Aox86u1CHnfJA4V\", \"2N7MGY19ti4KDMSzRfPAssP6Pxyuxoi6jLe\", script_to_p2sh(op1), script_to_p2sh(op0)]\n         unsolvable_address_key = hex_str_to_bytes(\"02341AEC7587A51CDE5279E0630A531AEA2615A9F80B17E8D9376327BAEAA59E3D\")\n         unsolvablep2pkh = CScript([OP_DUP, OP_HASH160, hash160(unsolvable_address_key), OP_EQUALVERIFY, OP_CHECKSIG])\n         unsolvablep2wshp2pkh = CScript([OP_0, sha256(unsolvablep2pkh)])\n         p2shop0 = CScript([OP_HASH160, hash160(op0), OP_EQUAL])\n         p2wshop1 = CScript([OP_0, sha256(op1)])\n         unsolvable_after_importaddress.append(unsolvablep2pkh)\n         unsolvable_after_importaddress.append(unsolvablep2wshp2pkh)\n-        unsolvable_after_importaddress.append(op1) # OP_1 will be imported as script\n+        unsolvable_after_importaddress.append(op1)  # OP_1 will be imported as script\n         unsolvable_after_importaddress.append(p2wshop1)\n-        unseen_anytime.append(op0) # OP_0 will be imported as P2SH address with no script provided\n+        unseen_anytime.append(op0)  # OP_0 will be imported as P2SH address with no script provided\n         unsolvable_after_importaddress.append(p2shop0)\n \n         spendable_txid = []\n@@ -432,27 +419,14 @@ def run_test(self):\n             # exceptions and continue.\n             try_rpc(-4, \"The wallet already contains the private key for this address or script\", self.nodes[0].importaddress, i, \"\", False, True)\n \n-        self.nodes[0].importaddress(script_to_p2sh(op0)) # import OP_0 as address only\n-        self.nodes[0].importaddress(multisig_without_privkey_address) # Test multisig_without_privkey\n+        self.nodes[0].importaddress(script_to_p2sh(op0))  # import OP_0 as address only\n+        self.nodes[0].importaddress(multisig_without_privkey_address)  # Test multisig_without_privkey\n \n         spendable_txid.append(self.mine_and_test_listunspent(spendable_anytime + spendable_after_importaddress, 2))\n         solvable_txid.append(self.mine_and_test_listunspent(solvable_anytime + solvable_after_importaddress, 1))\n         self.mine_and_test_listunspent(unsolvable_after_importaddress, 1)\n         self.mine_and_test_listunspent(unseen_anytime, 0)\n \n-        # addwitnessaddress should refuse to return a witness address if an uncompressed key is used\n-        # note that no witness address should be returned by unsolvable addresses\n-        for i in uncompressed_spendable_address + uncompressed_solvable_address + unknown_address + unsolvable_address:\n-            assert_raises_rpc_error(-4, \"Public key or redeemscript not known to wallet, or the key is uncompressed\", self.nodes[0].addwitnessaddress, i)\n-\n-        # addwitnessaddress should return a witness addresses even if keys are not in the wallet\n-        self.nodes[0].addwitnessaddress(multisig_without_privkey_address)\n-\n-        for i in compressed_spendable_address + compressed_solvable_address:\n-            witaddress = self.nodes[0].addwitnessaddress(i)\n-            # addwitnessaddress should return the same address if it is a known P2SH-witness address\n-            assert_equal(witaddress, self.nodes[0].addwitnessaddress(witaddress))\n-\n         spendable_txid.append(self.mine_and_test_listunspent(spendable_anytime + spendable_after_importaddress, 2))\n         solvable_txid.append(self.mine_and_test_listunspent(solvable_anytime + solvable_after_importaddress, 1))\n         self.mine_and_test_listunspent(unsolvable_after_importaddress, 1)\n@@ -470,8 +444,6 @@ def run_test(self):\n         self.nodes[0].importpubkey(pubkeys[6])\n         uncompressed_solvable_address = [key_to_p2pkh(pubkeys[6])]\n \n-        spendable_after_addwitnessaddress = []      # These outputs should be seen after importaddress\n-        solvable_after_addwitnessaddress=[]         # These outputs should be seen after importaddress but not spendable\n         unseen_anytime = []                         # These outputs should never be seen\n         solvable_anytime = []                       # These outputs should be solvable after importpubkey\n         unseen_anytime = []                         # These outputs should never be seen\n@@ -488,8 +460,6 @@ def run_test(self):\n             v = self.nodes[0].getaddressinfo(i)\n             if (v['isscript']):\n                 [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n-                # P2WSH and P2SH(P2WSH) multisig with compressed keys are spendable after addwitnessaddress\n-                spendable_after_addwitnessaddress.extend([p2wsh, p2sh_p2wsh])\n                 premature_witaddress.append(script_to_p2sh(p2wsh))\n             else:\n                 [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n@@ -510,9 +480,7 @@ def run_test(self):\n         for i in compressed_solvable_address:\n             v = self.nodes[0].getaddressinfo(i)\n             if (v['isscript']):\n-                # P2WSH multisig without private key are seen after addwitnessaddress\n                 [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n-                solvable_after_addwitnessaddress.extend([p2wsh, p2sh_p2wsh])\n                 premature_witaddress.append(script_to_p2sh(p2wsh))\n             else:\n                 [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n@@ -521,29 +489,11 @@ def run_test(self):\n \n         self.mine_and_test_listunspent(spendable_anytime, 2)\n         self.mine_and_test_listunspent(solvable_anytime, 1)\n-        self.mine_and_test_listunspent(spendable_after_addwitnessaddress + solvable_after_addwitnessaddress + unseen_anytime, 0)\n-\n-        # addwitnessaddress should refuse to return a witness address if an uncompressed key is used\n-        # note that a multisig address returned by addmultisigaddress is not solvable until it is added with importaddress\n-        # premature_witaddress are not accepted until the script is added with addwitnessaddress first\n-        for i in uncompressed_spendable_address + uncompressed_solvable_address + premature_witaddress:\n-            # This will raise an exception\n-            assert_raises_rpc_error(-4, \"Public key or redeemscript not known to wallet, or the key is uncompressed\", self.nodes[0].addwitnessaddress, i)\n-\n-        # after importaddress it should pass addwitnessaddress\n-        v = self.nodes[0].getaddressinfo(compressed_solvable_address[1])\n-        self.nodes[0].importaddress(v['hex'],\"\",False,True)\n-        for i in compressed_spendable_address + compressed_solvable_address + premature_witaddress:\n-            witaddress = self.nodes[0].addwitnessaddress(i)\n-            assert_equal(witaddress, self.nodes[0].addwitnessaddress(witaddress))\n-\n-        spendable_txid.append(self.mine_and_test_listunspent(spendable_after_addwitnessaddress + spendable_anytime, 2))\n-        solvable_txid.append(self.mine_and_test_listunspent(solvable_after_addwitnessaddress + solvable_anytime, 1))\n         self.mine_and_test_listunspent(unseen_anytime, 0)\n \n         # Check that createrawtransaction/decoderawtransaction with non-v0 Bech32 works\n-        v1_addr = program_to_witness(1, [3,5])\n-        v1_tx = self.nodes[0].createrawtransaction([getutxo(spendable_txid[0])],{v1_addr: 1})\n+        v1_addr = program_to_witness(1, [3, 5])\n+        v1_tx = self.nodes[0].createrawtransaction([getutxo(spendable_txid[0])], {v1_addr: 1})\n         v1_decoded = self.nodes[1].decoderawtransaction(v1_tx)\n         assert_equal(v1_decoded['vout'][0]['scriptPubKey']['addresses'][0], v1_addr)\n         assert_equal(v1_decoded['vout'][0]['scriptPubKey']['hex'], \"51020305\")\n@@ -586,7 +536,7 @@ def run_test(self):\n     def mine_and_test_listunspent(self, script_list, ismine):\n         utxo = find_spendable_utxo(self.nodes[0], 50)\n         tx = CTransaction()\n-        tx.vin.append(CTxIn(COutPoint(int('0x'+utxo['txid'],0), utxo['vout'])))\n+        tx.vin.append(CTxIn(COutPoint(int('0x' + utxo['txid'], 0), utxo['vout'])))\n         for i in script_list:\n             tx.vout.append(CTxOut(10000000, i))\n         tx.rehash()\n@@ -599,7 +549,7 @@ def mine_and_test_listunspent(self, script_list, ismine):\n         for i in self.nodes[0].listunspent():\n             if (i['txid'] == txid):\n                 watchcount += 1\n-                if (i['spendable'] == True):\n+                if i['spendable']:\n                     spendcount += 1\n         if (ismine == 2):\n             assert_equal(spendcount, len(script_list))\n@@ -610,14 +560,14 @@ def mine_and_test_listunspent(self, script_list, ismine):\n             assert_equal(watchcount, 0)\n         return txid\n \n-    def p2sh_address_to_script(self,v):\n+    def p2sh_address_to_script(self, v):\n         bare = CScript(hex_str_to_bytes(v['hex']))\n         p2sh = CScript(hex_str_to_bytes(v['scriptPubKey']))\n         p2wsh = CScript([OP_0, sha256(bare)])\n         p2sh_p2wsh = CScript([OP_HASH160, hash160(p2wsh), OP_EQUAL])\n         return([bare, p2sh, p2wsh, p2sh_p2wsh])\n \n-    def p2pkh_address_to_script(self,v):\n+    def p2pkh_address_to_script(self, v):\n         pubkey = hex_str_to_bytes(v['pubkey'])\n         p2wpkh = CScript([OP_0, hash160(pubkey)])\n         p2sh_p2wpkh = CScript([OP_HASH160, hash160(p2wpkh), OP_EQUAL])\n@@ -631,15 +581,15 @@ def p2pkh_address_to_script(self,v):\n         p2sh_p2wsh_p2pkh = CScript([OP_HASH160, hash160(p2wsh_p2pkh), OP_EQUAL])\n         return [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh]\n \n-    def create_and_mine_tx_from_txids(self, txids, success = True):\n+    def create_and_mine_tx_from_txids(self, txids, success=True):\n         tx = CTransaction()\n         for i in txids:\n             txtmp = CTransaction()\n             txraw = self.nodes[0].getrawtransaction(i)\n             f = BytesIO(hex_str_to_bytes(txraw))\n             txtmp.deserialize(f)\n             for j in range(len(txtmp.vout)):\n-                tx.vin.append(CTxIn(COutPoint(int('0x'+i,0), j)))\n+                tx.vin.append(CTxIn(COutPoint(int('0x' + i, 0), j)))\n         tx.vout.append(CTxOut(0, CScript()))\n         tx.rehash()\n         signresults = self.nodes[0].signrawtransactionwithwallet(bytes_to_hex_str(tx.serialize_without_witness()))['hex']"
      },
      {
        "sha": "94fea37090742d7ad24e6e7e42e4630cd96e67ee",
        "filename": "test/functional/interface_zmq.py",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/interface_zmq.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/interface_zmq.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_zmq.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -69,6 +69,7 @@ def setup_nodes(self):\n         ]\n         self.add_nodes(self.num_nodes, self.extra_args)\n         self.start_nodes()\n+        self.import_deterministic_coinbase_privkeys()\n \n     def run_test(self):\n         try:\n@@ -121,10 +122,10 @@ def _zmq_test(self):\n \n         self.log.info(\"Test the getzmqnotifications RPC\")\n         assert_equal(self.nodes[0].getzmqnotifications(), [\n-            {\"type\": \"pubhashblock\", \"address\": ADDRESS},\n-            {\"type\": \"pubhashtx\", \"address\": ADDRESS},\n-            {\"type\": \"pubrawblock\", \"address\": ADDRESS},\n-            {\"type\": \"pubrawtx\", \"address\": ADDRESS},\n+            {\"type\": \"pubhashblock\", \"address\": ADDRESS, \"hwm\": 1000},\n+            {\"type\": \"pubhashtx\", \"address\": ADDRESS, \"hwm\": 1000},\n+            {\"type\": \"pubrawblock\", \"address\": ADDRESS, \"hwm\": 1000},\n+            {\"type\": \"pubrawtx\", \"address\": ADDRESS, \"hwm\": 1000},\n         ])\n \n         assert_equal(self.nodes[1].getzmqnotifications(), [])"
      },
      {
        "sha": "845beb551efdde104618f99b376087597240ee18",
        "filename": "test/functional/mempool_resurrect.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/mempool_resurrect.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/mempool_resurrect.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_resurrect.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -47,12 +47,11 @@ def run_test(self):\n             tx = self.nodes[0].gettransaction(txid)\n             assert(tx[\"confirmations\"] > 0)\n \n-        # Use invalidateblock to re-org back; all transactions should\n-        # end up unconfirmed and back in the mempool\n+        # Use invalidateblock to re-org back\n         for node in self.nodes:\n             node.invalidateblock(blocks[0])\n \n-        # mempool should be empty, all txns confirmed\n+        # All txns should be back in mempool with 0 confirmations\n         assert_equal(set(self.nodes[0].getrawmempool()), set(spends1_id+spends2_id))\n         for txid in spends1_id+spends2_id:\n             tx = self.nodes[0].gettransaction(txid)"
      },
      {
        "sha": "9f01be064665daaaa6f03fdfacf56664286b06a1",
        "filename": "test/functional/mining_basic.py",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/mining_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/mining_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mining_basic.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -30,9 +30,10 @@\n def assert_template(node, block, expect, rehash=True):\n     if rehash:\n         block.hashMerkleRoot = block.calc_merkle_root()\n-    rsp = node.getblocktemplate({'data': b2x(block.serialize()), 'mode': 'proposal'})\n+    rsp = node.getblocktemplate(template_request={'data': b2x(block.serialize()), 'mode': 'proposal'})\n     assert_equal(rsp, expect)\n \n+\n class MiningTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 2"
      },
      {
        "sha": "f0dee59b5cc9798749451329c70ef54951894715",
        "filename": "test/functional/p2p_compactblocks.py",
        "status": "modified",
        "additions": 17,
        "deletions": 19,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/p2p_compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/p2p_compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_compactblocks.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -7,7 +7,6 @@\n Version 1 compact blocks are pre-segwit (txids)\n Version 2 compact blocks are post-segwit (wtxids)\n \"\"\"\n-\n from decimal import Decimal\n import random\n \n@@ -99,7 +98,7 @@ def set_test_params(self):\n         self.num_nodes = 2\n         # This test was written assuming SegWit is activated using BIP9 at height 432 (3x confirmation window).\n         # TODO: Rewrite this test to support SegWit being always active.\n-        self.extra_args = [[\"-vbparams=segwit:0:0\"], [\"-vbparams=segwit:0:999999999999\", \"-txindex\", \"-deprecatedrpc=addwitnessaddress\"]]\n+        self.extra_args = [[\"-vbparams=segwit:0:0\"], [\"-vbparams=segwit:0:999999999999\", \"-txindex\"]]\n         self.utxos = []\n \n     def skip_test_if_missing_module(self):\n@@ -189,7 +188,7 @@ def check_announcement_of_new_block(node, peer, predicate):\n \n         # Now try a SENDCMPCT message with too-high version\n         sendcmpct = msg_sendcmpct()\n-        sendcmpct.version = preferred_version+1\n+        sendcmpct.version = preferred_version + 1\n         sendcmpct.announce = True\n         test_node.send_and_ping(sendcmpct)\n         check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" not in p.last_message)\n@@ -220,7 +219,7 @@ def check_announcement_of_new_block(node, peer, predicate):\n         check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" in p.last_message)\n \n         # Try one more time, after sending a version-1, announce=false message.\n-        sendcmpct.version = preferred_version-1\n+        sendcmpct.version = preferred_version - 1\n         sendcmpct.announce = False\n         test_node.send_and_ping(sendcmpct)\n         check_announcement_of_new_block(node, test_node, lambda p: \"cmpctblock\" in p.last_message)\n@@ -234,7 +233,7 @@ def check_announcement_of_new_block(node, peer, predicate):\n         if old_node is not None:\n             # Verify that a peer using an older protocol version can receive\n             # announcements from this node.\n-            sendcmpct.version = preferred_version-1\n+            sendcmpct.version = preferred_version - 1\n             sendcmpct.announce = True\n             old_node.send_and_ping(sendcmpct)\n             # Header sync\n@@ -265,9 +264,9 @@ def test_compactblock_construction(self, node, test_node, version, use_witness_a\n         if use_witness_address:\n             # Want at least one segwit spend, so move all funds to\n             # a witness address.\n-            address = node.addwitnessaddress(address)\n+            address = node.getnewaddress(address_type='bech32')\n             value_to_send = node.getbalance()\n-            node.sendtoaddress(address, satoshi_round(value_to_send-Decimal(0.1)))\n+            node.sendtoaddress(address, satoshi_round(value_to_send - Decimal(0.1)))\n             node.generate(1)\n \n         segwit_tx_generated = False\n@@ -279,7 +278,7 @@ def test_compactblock_construction(self, node, test_node, version, use_witness_a\n                 segwit_tx_generated = True\n \n         if use_witness_address:\n-            assert(segwit_tx_generated) # check that our test is not broken\n+            assert segwit_tx_generated  # check that our test is not broken\n \n         # Wait until we've seen the block announcement for the resulting tip\n         tip = int(node.getbestblockhash(), 16)\n@@ -403,8 +402,7 @@ def test_compactblock_requests(self, node, test_node, version, segwit):\n             coinbase_hash = block.vtx[0].sha256\n             if version == 2:\n                 coinbase_hash = block.vtx[0].calc_sha256(True)\n-            comp_block.shortids = [\n-                    calculate_shortid(k0, k1, coinbase_hash) ]\n+            comp_block.shortids = [calculate_shortid(k0, k1, coinbase_hash)]\n             test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n             assert_equal(int(node.getbestblockhash(), 16), block.hashPrevBlock)\n             # Expect a getblocktxn message.\n@@ -443,7 +441,7 @@ def build_block_with_transactions(self, node, utxo, num_transactions):\n     # node needs, and that responding to them causes the block to be\n     # reconstructed.\n     def test_getblocktxn_requests(self, node, test_node, version):\n-        with_witness = (version==2)\n+        with_witness = (version == 2)\n \n         def test_getblocktxn_response(compact_block, peer, expected_result):\n             msg = msg_cmpctblock(compact_block.to_p2p())\n@@ -470,7 +468,7 @@ def test_tip_after_message(node, peer, msg, tip):\n \n         msg_bt = msg_blocktxn()\n         if with_witness:\n-            msg_bt = msg_witness_blocktxn() # serialize with witnesses\n+            msg_bt = msg_witness_blocktxn()  # serialize with witnesses\n         msg_bt.block_transactions = BlockTransactions(block.sha256, block.vtx[1:])\n         test_tip_after_message(node, test_node, msg_bt, block.sha256)\n \n@@ -560,7 +558,7 @@ def test_incorrect_blocktxn_response(self, node, test_node, version):\n         # verifying that the block isn't marked bad permanently. This is good\n         # enough for now.\n         msg = msg_blocktxn()\n-        if version==2:\n+        if version == 2:\n             msg = msg_witness_blocktxn()\n         msg.block_transactions = BlockTransactions(block.sha256, [block.vtx[5]] + block.vtx[7:])\n         test_node.send_and_ping(msg)\n@@ -571,11 +569,11 @@ def test_incorrect_blocktxn_response(self, node, test_node, version):\n         # We should receive a getdata request\n         wait_until(lambda: \"getdata\" in test_node.last_message, timeout=10, lock=mininode_lock)\n         assert_equal(len(test_node.last_message[\"getdata\"].inv), 1)\n-        assert(test_node.last_message[\"getdata\"].inv[0].type == 2 or test_node.last_message[\"getdata\"].inv[0].type == 2|MSG_WITNESS_FLAG)\n+        assert(test_node.last_message[\"getdata\"].inv[0].type == 2 or test_node.last_message[\"getdata\"].inv[0].type == 2 | MSG_WITNESS_FLAG)\n         assert_equal(test_node.last_message[\"getdata\"].inv[0].hash, block.sha256)\n \n         # Deliver the block\n-        if version==2:\n+        if version == 2:\n             test_node.send_and_ping(msg_witness_block(block))\n         else:\n             test_node.send_and_ping(msg_block(block))\n@@ -655,7 +653,7 @@ def test_compactblocks_not_at_tip(self, node, test_node):\n \n         # Generate an old compactblock, and verify that it's not accepted.\n         cur_height = node.getblockcount()\n-        hashPrevBlock = int(node.getblockhash(cur_height-5), 16)\n+        hashPrevBlock = int(node.getblockhash(cur_height - 5), 16)\n         block = self.build_block_on_tip(node)\n         block.hashPrevBlock = hashPrevBlock\n         block.solve()\n@@ -684,7 +682,7 @@ def test_compactblocks_not_at_tip(self, node, test_node):\n             assert \"blocktxn\" not in test_node.last_message\n \n     def activate_segwit(self, node):\n-        node.generate(144*3)\n+        node.generate(144 * 3)\n         assert_equal(get_bip9_status(node, \"segwit\")[\"status\"], 'active')\n \n     def test_end_to_end_block_relay(self, node, listeners):\n@@ -780,7 +778,7 @@ def announce_cmpct_block(node, peer):\n             delivery_peer.send_message(msg_tx(tx))\n         delivery_peer.sync_with_ping()\n \n-        cmpct_block.prefilled_txn[0].tx.wit.vtxinwit = [ CTxInWitness() ]\n+        cmpct_block.prefilled_txn[0].tx.wit.vtxinwit = [CTxInWitness()]\n         cmpct_block.prefilled_txn[0].tx.wit.vtxinwit[0].scriptWitness.stack = [ser_uint256(0)]\n \n         cmpct_block.use_witness = True\n@@ -886,7 +884,7 @@ def run_test(self):\n         self.log.info(\"Syncing nodes...\")\n         assert(self.nodes[0].getbestblockhash() != self.nodes[1].getbestblockhash())\n         while (self.nodes[0].getblockcount() > self.nodes[1].getblockcount()):\n-            block_hash = self.nodes[0].getblockhash(self.nodes[1].getblockcount()+1)\n+            block_hash = self.nodes[0].getblockhash(self.nodes[1].getblockcount() + 1)\n             self.nodes[1].submitblock(self.nodes[0].getblock(block_hash, False))\n         assert_equal(self.nodes[0].getbestblockhash(), self.nodes[1].getbestblockhash())\n "
      },
      {
        "sha": "1b11a2a2945d7da310d57aab9ea26da78bbcc399",
        "filename": "test/functional/p2p_disconnect_ban.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/p2p_disconnect_ban.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/p2p_disconnect_ban.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_disconnect_ban.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -22,7 +22,7 @@ def run_test(self):\n \n         self.log.info(\"setban: successfully ban single IP address\")\n         assert_equal(len(self.nodes[1].getpeerinfo()), 2)  # node1 should have 2 connections to node0 at this point\n-        self.nodes[1].setban(\"127.0.0.1\", \"add\")\n+        self.nodes[1].setban(subnet=\"127.0.0.1\", command=\"add\")\n         wait_until(lambda: len(self.nodes[1].getpeerinfo()) == 0, timeout=10)\n         assert_equal(len(self.nodes[1].getpeerinfo()), 0)  # all nodes must be disconnected at this point\n         assert_equal(len(self.nodes[1].listbanned()), 1)"
      },
      {
        "sha": "1e0b8765930672a2291ed2b33e231f19c21556d5",
        "filename": "test/functional/p2p_invalid_block.py",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/p2p_invalid_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/p2p_invalid_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_block.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -77,9 +77,9 @@ def run_test(self):\n         block2.vtx.append(tx2)\n         assert_equal(block2.hashMerkleRoot, block2.calc_merkle_root())\n         assert_equal(orig_hash, block2.rehash())\n-        assert(block2_orig.vtx != block2.vtx)\n+        assert block2_orig.vtx != block2.vtx\n \n-        node.p2p.send_blocks_and_test([block2], node, success=False, request_block=False, reject_reason='bad-txns-duplicate')\n+        node.p2p.send_blocks_and_test([block2], node, success=False, reject_reason='bad-txns-duplicate')\n \n         # Check transactions for duplicate inputs\n         self.log.info(\"Test duplicate input block.\")\n@@ -89,7 +89,7 @@ def run_test(self):\n         block2_orig.hashMerkleRoot = block2_orig.calc_merkle_root()\n         block2_orig.rehash()\n         block2_orig.solve()\n-        node.p2p.send_blocks_and_test([block2_orig], node, success=False, request_block=False, reject_reason='bad-txns-inputs-duplicate')\n+        node.p2p.send_blocks_and_test([block2_orig], node, success=False, reject_reason='bad-txns-inputs-duplicate')\n \n         self.log.info(\"Test very broken block.\")\n \n@@ -102,7 +102,8 @@ def run_test(self):\n         block3.rehash()\n         block3.solve()\n \n-        node.p2p.send_blocks_and_test([block3], node, success=False, request_block=False, reject_reason='bad-cb-amount')\n+        node.p2p.send_blocks_and_test([block3], node, success=False, reject_reason='bad-cb-amount')\n+\n \n if __name__ == '__main__':\n     InvalidBlockRequestTest().main()"
      },
      {
        "sha": "a2d40fab1a2ab51ef17dc29631b0293296ae4b81",
        "filename": "test/functional/p2p_invalid_messages.py",
        "status": "added",
        "additions": 175,
        "deletions": 0,
        "changes": 175,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/p2p_invalid_messages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/p2p_invalid_messages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_messages.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -0,0 +1,175 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2015-2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test node responses to invalid network messages.\"\"\"\n+import struct\n+\n+from test_framework import messages\n+from test_framework.mininode import P2PDataStore\n+from test_framework.test_framework import BitcoinTestFramework\n+\n+\n+class msg_unrecognized:\n+    \"\"\"Nonsensical message. Modeled after similar types in test_framework.messages.\"\"\"\n+\n+    command = b'badmsg'\n+\n+    def __init__(self, str_data):\n+        self.str_data = str_data.encode() if not isinstance(str_data, bytes) else str_data\n+\n+    def serialize(self):\n+        return messages.ser_string(self.str_data)\n+\n+    def __repr__(self):\n+        return \"{}(data={})\".format(self.command, self.str_data)\n+\n+\n+class msg_nametoolong(msg_unrecognized):\n+\n+    command = b'thisnameiswayyyyyyyyytoolong'\n+\n+\n+class InvalidMessagesTest(BitcoinTestFramework):\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+\n+    def run_test(self):\n+        \"\"\"\n+        0. Send a bunch of large (4MB) messages of an unrecognized type. Check to see\n+           that it isn't an effective DoS against the node.\n+\n+        1. Send an oversized (4MB+) message and check that we're disconnected.\n+\n+        2. Send a few messages with an incorrect data size in the header, ensure the\n+           messages are ignored.\n+\n+        3. Send an unrecognized message with a command name longer than 12 characters.\n+\n+        \"\"\"\n+        node = self.nodes[0]\n+        self.node = node\n+        node.add_p2p_connection(P2PDataStore())\n+        conn2 = node.add_p2p_connection(P2PDataStore())\n+\n+        msg_limit = 4 * 1000 * 1000  # 4MB, per MAX_PROTOCOL_MESSAGE_LENGTH\n+        valid_data_limit = msg_limit - 5  # Account for the 4-byte length prefix\n+\n+        #\n+        # 0.\n+        #\n+        # Send as large a message as is valid, ensure we aren't disconnected but\n+        # also can't exhaust resources.\n+        #\n+        msg_at_size = msg_unrecognized(\"b\" * valid_data_limit)\n+        assert len(msg_at_size.serialize()) == msg_limit\n+\n+        with node.assert_memory_usage_stable(perc_increase_allowed=0.03):\n+            self.log.info(\n+                \"Sending a bunch of large, junk messages to test \"\n+                \"memory exhaustion. May take a bit...\")\n+\n+            # Run a bunch of times to test for memory exhaustion.\n+            for _ in range(80):\n+                node.p2p.send_message(msg_at_size)\n+\n+            # Check that, even though the node is being hammered by nonsense from one\n+            # connection, it can still service other peers in a timely way.\n+            for _ in range(20):\n+                conn2.sync_with_ping(timeout=2)\n+\n+            # Peer 1, despite serving up a bunch of nonsense, should still be connected.\n+            self.log.info(\"Waiting for node to drop junk messages.\")\n+            node.p2p.sync_with_ping(timeout=30)\n+            assert node.p2p.is_connected\n+\n+        #\n+        # 1.\n+        #\n+        # Send an oversized message, ensure we're disconnected.\n+        #\n+        msg_over_size = msg_unrecognized(\"b\" * (valid_data_limit + 1))\n+        assert len(msg_over_size.serialize()) == (msg_limit + 1)\n+\n+        with node.assert_debug_log([\"Oversized message from peer=0, disconnecting\"]):\n+            # An unknown message type (or *any* message type) over\n+            # MAX_PROTOCOL_MESSAGE_LENGTH should result in a disconnect.\n+            node.p2p.send_message(msg_over_size)\n+            node.p2p.wait_for_disconnect(timeout=4)\n+\n+        node.disconnect_p2ps()\n+        conn = node.add_p2p_connection(P2PDataStore())\n+        conn.wait_for_verack()\n+\n+        #\n+        # 2.\n+        #\n+        # Send messages with an incorrect data size in the header.\n+        #\n+        actual_size = 100\n+        msg = msg_unrecognized(\"b\" * actual_size)\n+\n+        # TODO: handle larger-than cases. I haven't been able to pin down what behavior to expect.\n+        for wrong_size in (2, 77, 78, 79):\n+            self.log.info(\"Sending a message with incorrect size of {}\".format(wrong_size))\n+\n+            # Unmodified message should submit okay.\n+            node.p2p.send_and_ping(msg)\n+\n+            # A message lying about its data size results in a disconnect when the incorrect\n+            # data size is less than the actual size.\n+            #\n+            # TODO: why does behavior change at 78 bytes?\n+            #\n+            node.p2p.send_raw_message(self._tweak_msg_data_size(msg, wrong_size))\n+\n+            # For some reason unknown to me, we sometimes have to push additional data to the\n+            # peer in order for it to realize a disconnect.\n+            try:\n+                node.p2p.send_message(messages.msg_ping(nonce=123123))\n+            except IOError:\n+                pass\n+\n+            node.p2p.wait_for_disconnect(timeout=10)\n+            node.disconnect_p2ps()\n+            node.add_p2p_connection(P2PDataStore())\n+\n+        #\n+        # 3.\n+        #\n+        # Send a message with a too-long command name.\n+        #\n+        node.p2p.send_message(msg_nametoolong(\"foobar\"))\n+        node.p2p.wait_for_disconnect(timeout=4)\n+\n+        # Node is still up.\n+        conn = node.add_p2p_connection(P2PDataStore())\n+        conn.sync_with_ping()\n+\n+\n+    def _tweak_msg_data_size(self, message, wrong_size):\n+        \"\"\"\n+        Return a raw message based on another message but with an incorrect data size in\n+        the message header.\n+        \"\"\"\n+        raw_msg = self.node.p2p.build_message(message)\n+\n+        bad_size_bytes = struct.pack(\"<I\", wrong_size)\n+        num_header_bytes_before_size = 4 + 12\n+\n+        # Replace the correct data size in the message with an incorrect one.\n+        raw_msg_with_wrong_size = (\n+            raw_msg[:num_header_bytes_before_size] +\n+            bad_size_bytes +\n+            raw_msg[(num_header_bytes_before_size + len(bad_size_bytes)):]\n+        )\n+        assert len(raw_msg) == len(raw_msg_with_wrong_size)\n+\n+        return raw_msg_with_wrong_size\n+\n+\n+\n+if __name__ == '__main__':\n+    InvalidMessagesTest().main()"
      },
      {
        "sha": "dc4d475b2d894551615ab26144eb0afccaaf5775",
        "filename": "test/functional/p2p_leak_tx.py",
        "status": "added",
        "additions": 57,
        "deletions": 0,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/p2p_leak_tx.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/p2p_leak_tx.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_leak_tx.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -0,0 +1,57 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test that we don't leak txs to inbound peers that we haven't yet announced to\"\"\"\n+\n+from test_framework.messages import msg_getdata, CInv\n+from test_framework.mininode import P2PDataStore\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+)\n+\n+\n+class P2PNode(P2PDataStore):\n+    def on_inv(self, msg):\n+        pass\n+\n+\n+class P2PLeakTxTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        gen_node = self.nodes[0]  # The block and tx generating node\n+        gen_node.generate(1)\n+\n+        inbound_peer = self.nodes[0].add_p2p_connection(P2PNode())  # An \"attacking\" inbound peer\n+\n+        MAX_REPEATS = 100\n+        self.log.info(\"Running test up to {} times.\".format(MAX_REPEATS))\n+        for i in range(MAX_REPEATS):\n+            self.log.info('Run repeat {}'.format(i + 1))\n+            txid = gen_node.sendtoaddress(gen_node.getnewaddress(), 0.01)\n+\n+            want_tx = msg_getdata()\n+            want_tx.inv.append(CInv(t=1, h=int(txid, 16)))\n+            inbound_peer.last_message.pop('notfound', None)\n+            inbound_peer.send_message(want_tx)\n+            inbound_peer.sync_with_ping()\n+\n+            if inbound_peer.last_message.get('notfound'):\n+                self.log.debug('tx {} was not yet announced to us.'.format(txid))\n+                self.log.debug(\"node has responded with a notfound message. End test.\")\n+                assert_equal(inbound_peer.last_message['notfound'].vec[0].hash, int(txid, 16))\n+                inbound_peer.last_message.pop('notfound')\n+                break\n+            else:\n+                self.log.debug('tx {} was already announced to us. Try test again.'.format(txid))\n+                assert int(txid, 16) in [inv.hash for inv in inbound_peer.last_message['inv'].inv]\n+\n+\n+if __name__ == '__main__':\n+    P2PLeakTxTest().main()"
      },
      {
        "sha": "359880506ecd696c0d58b56dd58b40ef3999020b",
        "filename": "test/functional/p2p_node_network_limited.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/p2p_node_network_limited.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/p2p_node_network_limited.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_node_network_limited.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -43,8 +43,8 @@ def disconnect_all(self):\n         disconnect_nodes(self.nodes[1], 2)\n \n     def setup_network(self):\n-        super(NodeNetworkLimitedTest, self).setup_network()\n-        self.disconnect_all()\n+        self.add_nodes(self.num_nodes, self.extra_args)\n+        self.start_nodes()\n \n     def run_test(self):\n         node = self.nodes[0].add_p2p_connection(P2PIgnoreInv())"
      },
      {
        "sha": "31e60f1ceafc5d66ff94b9dd2adf4ce6d808618e",
        "filename": "test/functional/rpc_blockchain.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/rpc_blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/rpc_blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_blockchain.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -133,7 +133,7 @@ def _test_getchaintxstats(self):\n         assert_raises_rpc_error(-8, \"Block is not in main chain\", self.nodes[0].getchaintxstats, blockhash=blockhash)\n         self.nodes[0].reconsiderblock(blockhash)\n \n-        chaintxstats = self.nodes[0].getchaintxstats(1)\n+        chaintxstats = self.nodes[0].getchaintxstats(nblocks=1)\n         # 200 txs plus genesis tx\n         assert_equal(chaintxstats['txcount'], 201)\n         # tx rate should be 1 per 10 minutes, or 1/600\n@@ -211,7 +211,7 @@ def _test_getblockheader(self):\n \n         besthash = node.getbestblockhash()\n         secondbesthash = node.getblockhash(199)\n-        header = node.getblockheader(besthash)\n+        header = node.getblockheader(blockhash=besthash)\n \n         assert_equal(header['hash'], besthash)\n         assert_equal(header['height'], 200)\n@@ -287,7 +287,7 @@ def solve_and_send_block(prevhash, height, time):\n \n         def assert_waitforheight(height, timeout=2):\n             assert_equal(\n-                node.waitforblockheight(height, timeout)['height'],\n+                node.waitforblockheight(height=height, timeout=timeout)['height'],\n                 current_height)\n \n         assert_waitforheight(0)"
      },
      {
        "sha": "ca9e24367a324654fedcfb4c5d57fa129b1e543f",
        "filename": "test/functional/rpc_getblockstats.py",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/rpc_getblockstats.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/rpc_getblockstats.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_getblockstats.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -169,6 +169,8 @@ def run_test(self):\n         assert_raises_rpc_error(-8, 'Invalid selected statistic aaa%s' % inv_sel_stat,\n                                 self.nodes[0].getblockstats, hash_or_height=1, stats=['minfee' , 'aaa%s' % inv_sel_stat])\n \n+        assert_raises_rpc_error(-8, 'One or more of the selected stats requires -txindex enabled',\n+                                self.nodes[1].getblockstats, hash_or_height=1)\n         assert_raises_rpc_error(-8, 'One or more of the selected stats requires -txindex enabled',\n                                 self.nodes[1].getblockstats, hash_or_height=self.start_height + self.max_stat_pos)\n "
      },
      {
        "sha": "78d6e78aed21a6289a15a6bace6ec9a8f5d559b4",
        "filename": "test/functional/rpc_help.py",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/rpc_help.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/rpc_help.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_help.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -7,12 +7,18 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal, assert_raises_rpc_error\n \n+import os\n+\n \n class HelpRpcTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 1\n \n     def run_test(self):\n+        self.test_categories()\n+        self.dump_help()\n+\n+    def test_categories(self):\n         node = self.nodes[0]\n \n         # wrong argument count\n@@ -37,6 +43,15 @@ def run_test(self):\n \n         assert_equal(titles, components)\n \n+    def dump_help(self):\n+        dump_dir = os.path.join(self.options.tmpdir, 'rpc_help_dump')\n+        os.mkdir(dump_dir)\n+        calls = [line.split(' ', 1)[0] for line in self.nodes[0].help().splitlines() if line and not line.startswith('==')]\n+        for call in calls:\n+            with open(os.path.join(dump_dir, call), 'w', encoding='utf-8') as f:\n+                # Make sure the node can generate the help at runtime without crashing\n+                f.write(self.nodes[0].help(call))\n+\n \n if __name__ == '__main__':\n     HelpRpcTest().main()"
      },
      {
        "sha": "0affddcf05d373677fb91e07811c77b19e27d531",
        "filename": "test/functional/rpc_net.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/rpc_net.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/rpc_net.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_net.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -74,12 +74,12 @@ def _test_getnetworkinginfo(self):\n         assert_equal(self.nodes[0].getnetworkinfo()['networkactive'], True)\n         assert_equal(self.nodes[0].getnetworkinfo()['connections'], 2)\n \n-        self.nodes[0].setnetworkactive(False)\n+        self.nodes[0].setnetworkactive(state=False)\n         assert_equal(self.nodes[0].getnetworkinfo()['networkactive'], False)\n         # Wait a bit for all sockets to close\n         wait_until(lambda: self.nodes[0].getnetworkinfo()['connections'] == 0, timeout=3)\n \n-        self.nodes[0].setnetworkactive(True)\n+        self.nodes[0].setnetworkactive(state=True)\n         connect_nodes_bi(self.nodes, 0, 1)\n         assert_equal(self.nodes[0].getnetworkinfo()['networkactive'], True)\n         assert_equal(self.nodes[0].getnetworkinfo()['connections'], 2)\n@@ -88,7 +88,7 @@ def _test_getaddednodeinfo(self):\n         assert_equal(self.nodes[0].getaddednodeinfo(), [])\n         # add a node (node2) to node0\n         ip_port = \"127.0.0.1:{}\".format(p2p_port(2))\n-        self.nodes[0].addnode(ip_port, 'add')\n+        self.nodes[0].addnode(node=ip_port, command='add')\n         # check that the node has indeed been added\n         added_nodes = self.nodes[0].getaddednodeinfo(ip_port)\n         assert_equal(len(added_nodes), 1)"
      },
      {
        "sha": "04d9bb65a6def0a4ef56853e7a4c5fc40a4b4254",
        "filename": "test/functional/rpc_psbt.py",
        "status": "modified",
        "additions": 60,
        "deletions": 1,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/rpc_psbt.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/rpc_psbt.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_psbt.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -6,7 +6,7 @@\n \"\"\"\n \n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, assert_raises_rpc_error, find_output\n+from test_framework.util import assert_equal, assert_raises_rpc_error, find_output, disconnect_nodes, connect_nodes_bi, sync_blocks\n \n import json\n import os\n@@ -23,6 +23,45 @@ def set_test_params(self):\n     def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()\n \n+    def test_utxo_conversion(self):\n+        mining_node = self.nodes[2]\n+        offline_node = self.nodes[0]\n+        online_node = self.nodes[1]\n+\n+        # Disconnect offline node from others\n+        disconnect_nodes(offline_node, 1)\n+        disconnect_nodes(online_node, 0)\n+        disconnect_nodes(offline_node, 2)\n+        disconnect_nodes(mining_node, 0)\n+\n+        # Mine a transaction that credits the offline address\n+        offline_addr = offline_node.getnewaddress(address_type=\"p2sh-segwit\")\n+        online_addr = online_node.getnewaddress(address_type=\"p2sh-segwit\")\n+        online_node.importaddress(offline_addr, \"\", False)\n+        mining_node.sendtoaddress(address=offline_addr, amount=1.0)\n+        mining_node.generate(nblocks=1)\n+        sync_blocks([mining_node, online_node])\n+\n+        # Construct an unsigned PSBT on the online node (who doesn't know the output is Segwit, so will include a non-witness UTXO)\n+        utxos = online_node.listunspent(addresses=[offline_addr])\n+        raw = online_node.createrawtransaction([{\"txid\":utxos[0][\"txid\"], \"vout\":utxos[0][\"vout\"]}],[{online_addr:0.9999}])\n+        psbt = online_node.walletprocesspsbt(online_node.converttopsbt(raw))[\"psbt\"]\n+        assert(\"non_witness_utxo\" in mining_node.decodepsbt(psbt)[\"inputs\"][0])\n+\n+        # Have the offline node sign the PSBT (which will update the UTXO to segwit)\n+        signed_psbt = offline_node.walletprocesspsbt(psbt)[\"psbt\"]\n+        assert(\"witness_utxo\" in mining_node.decodepsbt(signed_psbt)[\"inputs\"][0])\n+\n+        # Make sure we can mine the resulting transaction\n+        txid = mining_node.sendrawtransaction(mining_node.finalizepsbt(signed_psbt)[\"hex\"])\n+        mining_node.generate(1)\n+        sync_blocks([mining_node, online_node])\n+        assert_equal(online_node.gettxout(txid,0)[\"confirmations\"], 1)\n+\n+        # Reconnect\n+        connect_nodes_bi(self.nodes, 0, 1)\n+        connect_nodes_bi(self.nodes, 0, 2)\n+\n     def run_test(self):\n         # Create and fund a raw tx for sending 10 BTC\n         psbtx1 = self.nodes[0].walletcreatefundedpsbt([], {self.nodes[2].getnewaddress():10})['psbt']\n@@ -107,6 +146,9 @@ def run_test(self):\n         # Make sure that a psbt with signatures cannot be converted\n         signedtx = self.nodes[0].signrawtransactionwithwallet(rawtx['hex'])\n         assert_raises_rpc_error(-22, \"TX decode failed\", self.nodes[0].converttopsbt, signedtx['hex'])\n+        assert_raises_rpc_error(-22, \"TX decode failed\", self.nodes[0].converttopsbt, signedtx['hex'], False)\n+        # Unless we allow it to convert and strip signatures\n+        self.nodes[0].converttopsbt(signedtx['hex'], True)\n \n         # Explicitly allow converting non-empty txs\n         new_psbt = self.nodes[0].converttopsbt(rawtx['hex'])\n@@ -168,6 +210,13 @@ def run_test(self):\n             assert tx_in[\"sequence\"] > MAX_BIP125_RBF_SEQUENCE\n         assert_equal(decoded_psbt[\"tx\"][\"locktime\"], 0)\n \n+        # Regression test for 14473 (mishandling of already-signed witness transaction):\n+        psbtx_info = self.nodes[0].walletcreatefundedpsbt([{\"txid\":unspent[\"txid\"], \"vout\":unspent[\"vout\"]}], [{self.nodes[2].getnewaddress():unspent[\"amount\"]+1}])\n+        complete_psbt = self.nodes[0].walletprocesspsbt(psbtx_info[\"psbt\"])\n+        double_processed_psbt = self.nodes[0].walletprocesspsbt(complete_psbt[\"psbt\"])\n+        assert_equal(complete_psbt, double_processed_psbt)\n+        # We don't care about the decode result, but decoding must succeed.\n+        self.nodes[0].decodepsbt(double_processed_psbt[\"psbt\"])\n \n         # BIP 174 Test Vectors\n \n@@ -224,6 +273,16 @@ def run_test(self):\n             extracted = self.nodes[2].finalizepsbt(extractor['extract'], True)['hex']\n             assert_equal(extracted, extractor['result'])\n \n+        # Unload extra wallets\n+        for i, signer in enumerate(signers):\n+            self.nodes[2].unloadwallet(\"wallet{}\".format(i))\n+\n+        self.test_utxo_conversion()\n+\n+        # Test that psbts with p2pkh outputs are created properly\n+        p2pkh = self.nodes[0].getnewaddress(address_type='legacy')\n+        psbt = self.nodes[1].walletcreatefundedpsbt([], [{p2pkh : 1}], 0, {\"includeWatching\" : True}, True)\n+        self.nodes[0].decodepsbt(psbt['psbt'])\n \n if __name__ == '__main__':\n     PSBTTest().main()"
      },
      {
        "sha": "81cce1167bae8832aa9bf06311b2d115b91022f3",
        "filename": "test/functional/test_framework/blocktools.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/test_framework/blocktools.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/test_framework/blocktools.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/blocktools.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -169,7 +169,7 @@ def get_legacy_sigopcount_tx(tx, accurate=True):\n     return count\n \n def witness_script(use_p2wsh, pubkey):\n-    \"\"\"Create a scriptPubKey for a pay-to-wtiness TxOut.\n+    \"\"\"Create a scriptPubKey for a pay-to-witness TxOut.\n \n     This is either a P2WPKH output for the given pubkey, or a P2WSH output of a\n     1-of-1 multisig for the given pubkey. Returns the hex encoding of the"
      },
      {
        "sha": "c72cb8835c15b0d69abb2dedd19d683f7a57bc2a",
        "filename": "test/functional/test_framework/messages.py",
        "status": "modified",
        "additions": 18,
        "deletions": 6,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/test_framework/messages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/test_framework/messages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/messages.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -35,7 +35,6 @@\n MY_SUBVERSION = b\"/python-mininode-tester:0.0.3/\"\n MY_RELAY = 1 # from version 70001 onwards, fRelay should be appended to version messages (BIP37)\n \n-MAX_INV_SZ = 50000\n MAX_LOCATOR_SZ = 101\n MAX_BLOCK_BASE_SIZE = 1000000\n \n@@ -58,9 +57,6 @@\n def sha256(s):\n     return hashlib.new('sha256', s).digest()\n \n-def ripemd160(s):\n-    return hashlib.new('ripemd160', s).digest()\n-\n def hash256(s):\n     return sha256(sha256(s))\n \n@@ -887,13 +883,12 @@ def __repr__(self):\n \n \n class CPartialMerkleTree:\n-    __slots__ = (\"fBad\", \"nTransactions\", \"vBits\", \"vHash\")\n+    __slots__ = (\"nTransactions\", \"vBits\", \"vHash\")\n \n     def __init__(self):\n         self.nTransactions = 0\n         self.vHash = []\n         self.vBits = []\n-        self.fBad = False\n \n     def deserialize(self, f):\n         self.nTransactions = struct.unpack(\"<i\", f.read(4))[0]\n@@ -1232,6 +1227,23 @@ def __repr__(self):\n         return \"msg_mempool()\"\n \n \n+class msg_notfound:\n+    __slots__ = (\"vec\", )\n+    command = b\"notfound\"\n+\n+    def __init__(self, vec=None):\n+        self.vec = vec or []\n+\n+    def deserialize(self, f):\n+        self.vec = deser_vector(f, CInv)\n+\n+    def serialize(self):\n+        return ser_vector(self.vec)\n+\n+    def __repr__(self):\n+        return \"msg_notfound(vec=%s)\" % (repr(self.vec))\n+\n+\n class msg_sendheaders:\n     __slots__ = ()\n     command = b\"sendheaders\""
      },
      {
        "sha": "388c123055587bd0cf070e2639de018923ab1d49",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 44,
        "deletions": 8,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -21,7 +21,38 @@\n import sys\n import threading\n \n-from test_framework.messages import CBlockHeader, MIN_VERSION_SUPPORTED, msg_addr, msg_block, MSG_BLOCK, msg_blocktxn, msg_cmpctblock, msg_feefilter, msg_getaddr, msg_getblocks, msg_getblocktxn, msg_getdata, msg_getheaders, msg_headers, msg_inv, msg_mempool, msg_ping, msg_pong, msg_reject, msg_sendcmpct, msg_sendheaders, msg_tx, MSG_TX, MSG_TYPE_MASK, msg_verack, msg_version, NODE_NETWORK, NODE_WITNESS, sha256\n+from test_framework.messages import (\n+    CBlockHeader,\n+    MIN_VERSION_SUPPORTED,\n+    msg_addr,\n+    msg_block,\n+    MSG_BLOCK,\n+    msg_blocktxn,\n+    msg_cmpctblock,\n+    msg_feefilter,\n+    msg_getaddr,\n+    msg_getblocks,\n+    msg_getblocktxn,\n+    msg_getdata,\n+    msg_getheaders,\n+    msg_headers,\n+    msg_inv,\n+    msg_mempool,\n+    msg_notfound,\n+    msg_ping,\n+    msg_pong,\n+    msg_reject,\n+    msg_sendcmpct,\n+    msg_sendheaders,\n+    msg_tx,\n+    MSG_TX,\n+    MSG_TYPE_MASK,\n+    msg_verack,\n+    msg_version,\n+    NODE_NETWORK,\n+    NODE_WITNESS,\n+    sha256,\n+)\n from test_framework.util import wait_until\n \n logger = logging.getLogger(\"TestFramework.mininode\")\n@@ -40,6 +71,7 @@\n     b\"headers\": msg_headers,\n     b\"inv\": msg_inv,\n     b\"mempool\": msg_mempool,\n+    b\"notfound\": msg_notfound,\n     b\"ping\": msg_ping,\n     b\"pong\": msg_pong,\n     b\"reject\": msg_reject,\n@@ -175,10 +207,13 @@ def send_message(self, message):\n \n         This method takes a P2P payload, builds the P2P header and adds\n         the message to the send buffer to be sent over the socket.\"\"\"\n+        tmsg = self.build_message(message)\n+        self._log_message(\"send\", message)\n+        return self.send_raw_message(tmsg)\n+\n+    def send_raw_message(self, raw_message_bytes):\n         if not self.is_connected:\n             raise IOError('Not connected')\n-        self._log_message(\"send\", message)\n-        tmsg = self._build_message(message)\n \n         def maybe_write():\n             if not self._transport:\n@@ -188,12 +223,12 @@ def maybe_write():\n             # Python 3.4 versions.\n             if hasattr(self._transport, 'is_closing') and self._transport.is_closing():\n                 return\n-            self._transport.write(tmsg)\n+            self._transport.write(raw_message_bytes)\n         NetworkThread.network_event_loop.call_soon_threadsafe(maybe_write)\n \n     # Class utility methods\n \n-    def _build_message(self, message):\n+    def build_message(self, message):\n         \"\"\"Build a serialized P2P message\"\"\"\n         command = message.command\n         data = message.serialize()\n@@ -295,6 +330,7 @@ def on_getdata(self, message): pass\n     def on_getheaders(self, message): pass\n     def on_headers(self, message): pass\n     def on_mempool(self, message): pass\n+    def on_notfound(self, message): pass\n     def on_pong(self, message): pass\n     def on_reject(self, message): pass\n     def on_sendcmpct(self, message): pass\n@@ -313,7 +349,7 @@ def on_ping(self, message):\n         self.send_message(msg_pong(message.nonce))\n \n     def on_verack(self, message):\n-        self.verack_received = True\n+        pass\n \n     def on_version(self, message):\n         assert message.nVersion >= MIN_VERSION_SUPPORTED, \"Version {} received. Test framework only supports versions greater than {}\".format(message.nVersion, MIN_VERSION_SUPPORTED)\n@@ -376,9 +412,9 @@ def wait_for_verack(self, timeout=60):\n \n     # Message sending helper functions\n \n-    def send_and_ping(self, message):\n+    def send_and_ping(self, message, timeout=60):\n         self.send_message(message)\n-        self.sync_with_ping()\n+        self.sync_with_ping(timeout=timeout)\n \n     # Sync up with the node\n     def sync_with_ping(self, timeout=60):"
      },
      {
        "sha": "a21c864e7538a5b36ca38c988f21356f021ee60a",
        "filename": "test/functional/test_framework/socks5.py",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/test_framework/socks5.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/test_framework/socks5.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/socks5.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -54,10 +54,9 @@ def __repr__(self):\n         return 'Socks5Command(%s,%s,%s,%s,%s,%s)' % (self.cmd, self.atyp, self.addr, self.port, self.username, self.password)\n \n class Socks5Connection():\n-    def __init__(self, serv, conn, peer):\n+    def __init__(self, serv, conn):\n         self.serv = serv\n         self.conn = conn\n-        self.peer = peer\n \n     def handle(self):\n         \"\"\"Handle socks5 request according to RFC192.\"\"\"\n@@ -137,9 +136,9 @@ def __init__(self, conf):\n \n     def run(self):\n         while self.running:\n-            (sockconn, peer) = self.s.accept()\n+            (sockconn, _) = self.s.accept()\n             if self.running:\n-                conn = Socks5Connection(self, sockconn, peer)\n+                conn = Socks5Connection(self, sockconn)\n                 thread = threading.Thread(None, conn.handle)\n                 thread.daemon = True\n                 thread.start()"
      },
      {
        "sha": "44fc185e6db1188449970f84e6cd1ace48d163c5",
        "filename": "test/functional/test_framework/test_framework.py",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/test_framework/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/test_framework/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_framework.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -168,7 +168,6 @@ def main(self):\n             self.skip_test_if_missing_module()\n             self.setup_chain()\n             self.setup_network()\n-            self.import_deterministic_coinbase_privkeys()\n             self.run_test()\n             success = TestStatus.PASSED\n         except JSONRPCException as e:\n@@ -261,19 +260,17 @@ def setup_nodes(self):\n             extra_args = self.extra_args\n         self.add_nodes(self.num_nodes, extra_args)\n         self.start_nodes()\n+        self.import_deterministic_coinbase_privkeys()\n \n     def import_deterministic_coinbase_privkeys(self):\n-        if self.setup_clean_chain:\n-            return\n-\n         for n in self.nodes:\n             try:\n                 n.getwalletinfo()\n             except JSONRPCException as e:\n                 assert str(e).startswith('Method not found')\n                 continue\n \n-            n.importprivkey(n.get_deterministic_priv_key().key)\n+            n.importprivkey(privkey=n.get_deterministic_priv_key().key, label='coinbase')\n \n     def run_test(self):\n         \"\"\"Tests must override this method to define test logic\"\"\""
      },
      {
        "sha": "9dcc0e6d0eacb29d298b17dbacf94b805fb79a21",
        "filename": "test/functional/test_framework/test_node.py",
        "status": "modified",
        "additions": 42,
        "deletions": 15,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/test_framework/test_node.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/test_framework/test_node.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_node.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -115,6 +115,25 @@ def get_deterministic_priv_key(self):\n         ]\n         return PRIV_KEYS[self.index]\n \n+    def get_mem_rss(self):\n+        \"\"\"Get the memory usage (RSS) per `ps`.\n+\n+        Returns None if `ps` is unavailable.\n+        \"\"\"\n+        assert self.running\n+\n+        try:\n+            return int(subprocess.check_output(\n+                [\"ps\", \"h\", \"-o\", \"rss\", \"{}\".format(self.process.pid)],\n+                stderr=subprocess.DEVNULL).split()[-1])\n+\n+        # Avoid failing on platforms where ps isn't installed.\n+        #\n+        # We could later use something like `psutils` to work across platforms.\n+        except (FileNotFoundError, subprocess.SubprocessError):\n+            self.log.exception(\"Unable to get memory usage\")\n+            return None\n+\n     def _node_msg(self, msg: str) -> str:\n         \"\"\"Return a modified msg that identifies this node by its index as a debugging aid.\"\"\"\n         return \"[node %d] %s\" % (self.index, msg)\n@@ -199,21 +218,6 @@ def wait_for_rpc_connection(self):\n \n     def generate(self, nblocks, maxtries=1000000):\n         self.log.debug(\"TestNode.generate() dispatches `generate` call to `generatetoaddress`\")\n-        # Try to import the node's deterministic private key. This is a no-op if the private key\n-        # has already been imported.\n-        try:\n-            self.rpc.importprivkey(privkey=self.get_deterministic_priv_key().key, label='coinbase', rescan=False)\n-        except JSONRPCException as e:\n-            # This may fail if:\n-            # - wallet is disabled ('Method not found')\n-            # - there are multiple wallets to import to ('Wallet file not specified')\n-            # - wallet is locked ('Error: Please enter the wallet passphrase with walletpassphrase first')\n-            # Just ignore those errors. We can make this tidier by importing the privkey during TestFramework.setup_nodes\n-            # TODO: tidy up deterministic privkey import.\n-            assert str(e).startswith('Method not found') or \\\n-                str(e).startswith('Wallet file not specified') or \\\n-                str(e).startswith('Error: Please enter the wallet passphrase with walletpassphrase first')\n-\n         return self.generatetoaddress(nblocks=nblocks, address=self.get_deterministic_priv_key().address, maxtries=maxtries)\n \n     def get_wallet_rpc(self, wallet_name):\n@@ -286,6 +290,29 @@ def assert_debug_log(self, expected_msgs):\n                 if re.search(re.escape(expected_msg), log, flags=re.MULTILINE) is None:\n                     self._raise_assertion_error('Expected message \"{}\" does not partially match log:\\n\\n{}\\n\\n'.format(expected_msg, print_log))\n \n+    @contextlib.contextmanager\n+    def assert_memory_usage_stable(self, perc_increase_allowed=0.03):\n+        \"\"\"Context manager that allows the user to assert that a node's memory usage (RSS)\n+        hasn't increased beyond some threshold percentage.\n+        \"\"\"\n+        before_memory_usage = self.get_mem_rss()\n+\n+        yield\n+\n+        after_memory_usage = self.get_mem_rss()\n+\n+        if not (before_memory_usage and after_memory_usage):\n+            self.log.warning(\"Unable to detect memory usage (RSS) - skipping memory check.\")\n+            return\n+\n+        perc_increase_memory_usage = (after_memory_usage / before_memory_usage) - 1\n+\n+        if perc_increase_memory_usage > perc_increase_allowed:\n+            self._raise_assertion_error(\n+                \"Memory usage increased over threshold of {:.3f}% from {} to {} ({:.3f}%)\".format(\n+                    perc_increase_allowed * 100, before_memory_usage, after_memory_usage,\n+                    perc_increase_memory_usage * 100))\n+\n     def assert_start_raises_init_error(self, extra_args=None, expected_msg=None, match=ErrorMatch.FULL_TEXT, *args, **kwargs):\n         \"\"\"Attempt to start the node and expect it to raise an error.\n "
      },
      {
        "sha": "5541b446901c7545cc28183cbc465e7cd2e32eee",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 40,
        "deletions": 25,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -68,9 +68,6 @@\n TEST_EXIT_PASSED = 0\n TEST_EXIT_SKIPPED = 77\n \n-# 20 minutes represented in seconds\n-TRAVIS_TIMEOUT_DURATION = 20 * 60\n-\n BASE_SCRIPTS = [\n     # Scripts that are run by the travis build process.\n     # Longest test should go first, to favor running tests in parallel\n@@ -139,6 +136,7 @@\n     'mining_prioritisetransaction.py',\n     'p2p_invalid_locator.py',\n     'p2p_invalid_block.py',\n+    'p2p_invalid_messages.py',\n     'p2p_invalid_tx.py',\n     'feature_assumevalid.py',\n     'example_test.py',\n@@ -152,10 +150,12 @@\n     'feature_versionbits_warning.py',\n     'rpc_preciousblock.py',\n     'wallet_importprunedfunds.py',\n+    'p2p_leak_tx.py',\n     'rpc_signmessage.py',\n     'feature_nulldummy.py',\n     'mempool_accept.py',\n     'wallet_import_rescan.py',\n+    'wallet_import_with_label.py',\n     'rpc_bind.py --ipv4',\n     'rpc_bind.py --ipv6',\n     'rpc_bind.py --nonloopback',\n@@ -213,15 +213,16 @@ def main():\n                                      epilog='''\n     Help text and arguments for individual test script:''',\n                                      formatter_class=argparse.RawTextHelpFormatter)\n-    parser.add_argument('--combinedlogslen', '-c', type=int, default=0, help='print a combined log (of length n lines) from all test nodes and test framework to the console on failure.')\n+    parser.add_argument('--combinedlogslen', '-c', type=int, default=0, metavar='n', help='On failure, print a log (of length n lines) to the console, combined from the test framework and all test nodes.')\n     parser.add_argument('--coverage', action='store_true', help='generate a basic coverage report for the RPC interface')\n+    parser.add_argument('--ci', action='store_true', help='Run checks and code that are usually only enabled in a continuous integration environment')\n     parser.add_argument('--exclude', '-x', help='specify a comma-separated-list of scripts to exclude.')\n     parser.add_argument('--extended', action='store_true', help='run the extended test suite in addition to the basic tests')\n     parser.add_argument('--force', '-f', action='store_true', help='run tests even on platforms where they are disabled by default (e.g. windows).')\n     parser.add_argument('--help', '-h', '-?', action='store_true', help='print help text and exit')\n     parser.add_argument('--jobs', '-j', type=int, default=4, help='how many test scripts to run in parallel. Default=4.')\n     parser.add_argument('--keepcache', '-k', action='store_true', help='the default behavior is to flush the cache directory on startup. --keepcache retains the cache from the previous testrun.')\n-    parser.add_argument('--quiet', '-q', action='store_true', help='only print results summary and failure logs')\n+    parser.add_argument('--quiet', '-q', action='store_true', help='only print dots, results summary and failure logs')\n     parser.add_argument('--tmpdirprefix', '-t', default=tempfile.gettempdir(), help=\"Root directory for datadirs\")\n     parser.add_argument('--failfast', action='store_true', help='stop execution after the first test failure')\n     args, unknown_args = parser.parse_known_args()\n@@ -305,25 +306,26 @@ def main():\n         subprocess.check_call([sys.executable, os.path.join(config[\"environment\"][\"SRCDIR\"], 'test', 'functional', test_list[0].split()[0]), '-h'])\n         sys.exit(0)\n \n-    check_script_list(config[\"environment\"][\"SRCDIR\"])\n+    check_script_list(src_dir=config[\"environment\"][\"SRCDIR\"], fail_on_warn=args.ci)\n     check_script_prefixes()\n \n     if not args.keepcache:\n         shutil.rmtree(\"%s/test/cache\" % config[\"environment\"][\"BUILDDIR\"], ignore_errors=True)\n \n     run_tests(\n-        test_list,\n-        config[\"environment\"][\"SRCDIR\"],\n-        config[\"environment\"][\"BUILDDIR\"],\n-        tmpdir,\n+        test_list=test_list,\n+        src_dir=config[\"environment\"][\"SRCDIR\"],\n+        build_dir=config[\"environment\"][\"BUILDDIR\"],\n+        tmpdir=tmpdir,\n         jobs=args.jobs,\n         enable_coverage=args.coverage,\n         args=passon_args,\n         combined_logs_len=args.combinedlogslen,\n         failfast=args.failfast,\n+        runs_ci=args.ci,\n     )\n \n-def run_tests(test_list, src_dir, build_dir, tmpdir, jobs=1, enable_coverage=False, args=None, combined_logs_len=0, failfast=False):\n+def run_tests(*, test_list, src_dir, build_dir, tmpdir, jobs=1, enable_coverage=False, args=None, combined_logs_len=0, failfast=False, runs_ci):\n     args = args or []\n \n     # Warn if bitcoind is already running (unix only)\n@@ -358,22 +360,29 @@ def run_tests(test_list, src_dir, build_dir, tmpdir, jobs=1, enable_coverage=Fal\n             raise\n \n     #Run Tests\n-    job_queue = TestHandler(jobs, tests_dir, tmpdir, test_list, flags)\n+    job_queue = TestHandler(\n+        num_tests_parallel=jobs,\n+        tests_dir=tests_dir,\n+        tmpdir=tmpdir,\n+        test_list=test_list,\n+        flags=flags,\n+        timeout_duration=40 * 60 if runs_ci else float('inf'),  # in seconds\n+    )\n     start_time = time.time()\n     test_results = []\n \n     max_len_name = len(max(test_list, key=len))\n-\n-    for _ in range(len(test_list)):\n+    test_count = len(test_list)\n+    for i in range(test_count):\n         test_result, testdir, stdout, stderr = job_queue.get_next()\n         test_results.append(test_result)\n-\n+        done_str = \"{}/{} - {}{}{}\".format(i + 1, test_count, BOLD[1], test_result.name, BOLD[0])\n         if test_result.status == \"Passed\":\n-            logging.debug(\"\\n%s%s%s passed, Duration: %s s\" % (BOLD[1], test_result.name, BOLD[0], test_result.time))\n+            logging.debug(\"%s passed, Duration: %s s\" % (done_str, test_result.time))\n         elif test_result.status == \"Skipped\":\n-            logging.debug(\"\\n%s%s%s skipped\" % (BOLD[1], test_result.name, BOLD[0]))\n+            logging.debug(\"%s skipped\" % (done_str))\n         else:\n-            print(\"\\n%s%s%s failed, Duration: %s s\\n\" % (BOLD[1], test_result.name, BOLD[0], test_result.time))\n+            print(\"%s failed, Duration: %s s\\n\" % (done_str, test_result.time))\n             print(BOLD[1] + 'stdout:\\n' + BOLD[0] + stdout + '\\n')\n             print(BOLD[1] + 'stderr:\\n' + BOLD[0] + stderr + '\\n')\n             if combined_logs_len and os.path.isdir(testdir):\n@@ -439,11 +448,12 @@ class TestHandler:\n     Trigger the test scripts passed in via the list.\n     \"\"\"\n \n-    def __init__(self, num_tests_parallel, tests_dir, tmpdir, test_list=None, flags=None):\n-        assert(num_tests_parallel >= 1)\n+    def __init__(self, *, num_tests_parallel, tests_dir, tmpdir, test_list, flags, timeout_duration):\n+        assert num_tests_parallel >= 1\n         self.num_jobs = num_tests_parallel\n         self.tests_dir = tests_dir\n         self.tmpdir = tmpdir\n+        self.timeout_duration = timeout_duration\n         self.test_list = test_list\n         self.flags = flags\n         self.num_running = 0\n@@ -472,12 +482,13 @@ def get_next(self):\n                               log_stderr))\n         if not self.jobs:\n             raise IndexError('pop from empty list')\n+        dot_count = 0\n         while True:\n             # Return first proc that finishes\n             time.sleep(.5)\n             for job in self.jobs:\n                 (name, start_time, proc, testdir, log_out, log_err) = job\n-                if os.getenv('TRAVIS') == 'true' and int(time.time() - start_time) > TRAVIS_TIMEOUT_DURATION:\n+                if int(time.time() - start_time) > self.timeout_duration:\n                     # In travis, timeout individual tests (to stop tests hanging and not providing useful output).\n                     proc.send_signal(signal.SIGINT)\n                 if proc.poll() is not None:\n@@ -492,9 +503,12 @@ def get_next(self):\n                         status = \"Failed\"\n                     self.num_running -= 1\n                     self.jobs.remove(job)\n-\n+                    clearline = '\\r' + (' ' * dot_count) + '\\r'\n+                    print(clearline, end='', flush=True)\n+                    dot_count = 0\n                     return TestResult(name, status, int(time.time() - start_time)), testdir, stdout, stderr\n             print('.', end='', flush=True)\n+            dot_count += 1\n \n     def kill_and_join(self):\n         \"\"\"Send SIGKILL to all jobs and block until all have ended.\"\"\"\n@@ -552,7 +566,7 @@ def check_script_prefixes():\n         raise AssertionError(\"Some tests are not following naming convention!\")\n \n \n-def check_script_list(src_dir):\n+def check_script_list(*, src_dir, fail_on_warn):\n     \"\"\"Check scripts directory.\n \n     Check that there are no scripts in the functional tests directory which are\n@@ -562,10 +576,11 @@ def check_script_list(src_dir):\n     missed_tests = list(python_files - set(map(lambda x: x.split()[0], ALL_SCRIPTS + NON_SCRIPTS)))\n     if len(missed_tests) != 0:\n         print(\"%sWARNING!%s The following scripts are not being run: %s. Check the test lists in test_runner.py.\" % (BOLD[1], BOLD[0], str(missed_tests)))\n-        if os.getenv('TRAVIS') == 'true':\n+        if fail_on_warn:\n             # On travis this warning is an error to prevent merging incomplete commits into master\n             sys.exit(1)\n \n+\n class RPCCoverage():\n     \"\"\"\n     Coverage reporting utilities for test_runner.\n@@ -621,7 +636,7 @@ def _get_uncovered_rpc_commands(self):\n         with open(coverage_ref_filename, 'r', encoding=\"utf8\") as coverage_ref_file:\n             all_cmds.update([line.strip() for line in coverage_ref_file.readlines()])\n \n-        for root, dirs, files in os.walk(self.dir):\n+        for root, _, files in os.walk(self.dir):\n             for filename in files:\n                 if filename.startswith(coverage_file_prefix):\n                     coverage_filenames.add(os.path.join(root, filename))"
      },
      {
        "sha": "c9b40905f05875345e40f977f8fa82a8a2356e07",
        "filename": "test/functional/wallet_basic.py",
        "status": "modified",
        "additions": 20,
        "deletions": 5,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/wallet_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/wallet_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_basic.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -28,10 +28,9 @@ def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()\n \n     def setup_network(self):\n-        self.add_nodes(4)\n-        self.start_node(0)\n-        self.start_node(1)\n-        self.start_node(2)\n+        self.setup_nodes()\n+        # Only need nodes 0-2 running at start of test\n+        self.stop_node(3)\n         connect_nodes_bi(self.nodes, 0, 1)\n         connect_nodes_bi(self.nodes, 1, 2)\n         connect_nodes_bi(self.nodes, 0, 2)\n@@ -480,14 +479,30 @@ def run_test(self):\n         # Verify nothing new in wallet\n         assert_equal(total_txs, len(self.nodes[0].listtransactions(\"*\", 99999)))\n \n-        # Test getaddressinfo. Note that these addresses are taken from disablewallet.py\n+        # Test getaddressinfo on external address. Note that these addresses are taken from disablewallet.py\n         assert_raises_rpc_error(-5, \"Invalid address\", self.nodes[0].getaddressinfo, \"3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy\")\n         address_info = self.nodes[0].getaddressinfo(\"mneYUmWYsuk7kySiURxCi3AGxrAqZxLgPZ\")\n         assert_equal(address_info['address'], \"mneYUmWYsuk7kySiURxCi3AGxrAqZxLgPZ\")\n         assert_equal(address_info[\"scriptPubKey\"], \"76a9144e3854046c7bd1594ac904e4793b6a45b36dea0988ac\")\n         assert not address_info[\"ismine\"]\n         assert not address_info[\"iswatchonly\"]\n         assert not address_info[\"isscript\"]\n+        assert not address_info[\"ischange\"]\n+\n+        # Test getaddressinfo 'ischange' field on change address.\n+        self.nodes[0].generate(1)\n+        destination = self.nodes[1].getnewaddress()\n+        txid = self.nodes[0].sendtoaddress(destination, 0.123)\n+        tx = self.nodes[0].decoderawtransaction(self.nodes[0].getrawtransaction(txid))\n+        output_addresses = [vout['scriptPubKey']['addresses'][0] for vout in tx[\"vout\"]]\n+        assert len(output_addresses) > 1\n+        for address in output_addresses:\n+            ischange = self.nodes[0].getaddressinfo(address)['ischange']\n+            assert_equal(ischange, address != destination)\n+            if ischange:\n+                change = address\n+        self.nodes[0].setlabel(change, 'foobar')\n+        assert_equal(self.nodes[0].getaddressinfo(change)['ischange'], False)\n \n if __name__ == '__main__':\n     WalletTest().main()"
      },
      {
        "sha": "7d3d9b61e2765a754aa734f9dc5fbbd50de5210d",
        "filename": "test/functional/wallet_bumpfee.py",
        "status": "modified",
        "additions": 7,
        "deletions": 12,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/wallet_bumpfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/wallet_bumpfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_bumpfee.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -13,26 +13,22 @@\n added in the future, they should try to follow the same convention and not\n make assumptions about execution order.\n \"\"\"\n-\n from decimal import Decimal\n+import io\n \n from test_framework.blocktools import add_witness_commitment, create_block, create_coinbase, send_to_witness\n from test_framework.messages import BIP125_SEQUENCE_NUMBER, CTransaction\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal, assert_greater_than, assert_raises_rpc_error, bytes_to_hex_str, connect_nodes_bi, hex_str_to_bytes, sync_mempools\n \n-import io\n-\n WALLET_PASSPHRASE = \"test\"\n WALLET_PASSPHRASE_TIMEOUT = 3600\n \n-\n class BumpFeeTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 2\n         self.setup_clean_chain = True\n         self.extra_args = [[\n-            \"-deprecatedrpc=addwitnessaddress\",\n             \"-walletrbf={}\".format(i),\n             \"-mintxfee=0.00002\",\n         ] for i in range(self.num_nodes)]\n@@ -107,8 +103,7 @@ def test_segwit_bumpfee_succeeds(rbf_node, dest_address):\n     # which spends it, and make sure bumpfee can be called on it.\n \n     segwit_in = next(u for u in rbf_node.listunspent() if u[\"amount\"] == Decimal(\"0.001\"))\n-    segwit_out = rbf_node.getaddressinfo(rbf_node.getnewaddress())\n-    rbf_node.addwitnessaddress(segwit_out[\"address\"])\n+    segwit_out = rbf_node.getaddressinfo(rbf_node.getnewaddress(address_type='p2sh-segwit'))\n     segwitid = send_to_witness(\n         use_p2wsh=False,\n         node=rbf_node,\n@@ -157,7 +152,7 @@ def test_notmine_bumpfee_fails(rbf_node, peer_node, dest_address):\n     signedtx = peer_node.signrawtransactionwithwallet(signedtx[\"hex\"])\n     rbfid = rbf_node.sendrawtransaction(signedtx[\"hex\"])\n     assert_raises_rpc_error(-4, \"Transaction contains inputs that don't belong to this wallet\",\n-                          rbf_node.bumpfee, rbfid)\n+                            rbf_node.bumpfee, rbfid)\n \n \n def test_bumpfee_with_descendant_fails(rbf_node, rbf_node_address, dest_address):\n@@ -187,11 +182,11 @@ def test_dust_to_fee(rbf_node, dest_address):\n     # (32-byte p2sh-pwpkh output size + 148 p2pkh spend estimate) * 10k(discard_rate) / 1000 = 1800\n     # P2SH outputs are slightly \"over-discarding\" due to the IsDust calculation assuming it will\n     # be spent as a P2PKH.\n-    bumped_tx = rbf_node.bumpfee(rbfid, {\"totalFee\": 50000-1800})\n+    bumped_tx = rbf_node.bumpfee(rbfid, {\"totalFee\": 50000 - 1800})\n     full_bumped_tx = rbf_node.getrawtransaction(bumped_tx[\"txid\"], 1)\n     assert_equal(bumped_tx[\"fee\"], Decimal(\"0.00050000\"))\n     assert_equal(len(fulltx[\"vout\"]), 2)\n-    assert_equal(len(full_bumped_tx[\"vout\"]), 1)  #change output is eliminated\n+    assert_equal(len(full_bumped_tx[\"vout\"]), 1)  # change output is eliminated\n \n \n def test_settxfee(rbf_node, dest_address):\n@@ -222,7 +217,7 @@ def test_rebumping_not_replaceable(rbf_node, dest_address):\n     rbfid = spend_one_input(rbf_node, dest_address)\n     bumped = rbf_node.bumpfee(rbfid, {\"totalFee\": 10000, \"replaceable\": False})\n     assert_raises_rpc_error(-4, \"Transaction is not BIP 125 replaceable\", rbf_node.bumpfee, bumped[\"txid\"],\n-                          {\"totalFee\": 20000})\n+                            {\"totalFee\": 20000})\n \n \n def test_unconfirmed_not_spendable(rbf_node, rbf_node_address):\n@@ -276,7 +271,7 @@ def test_locked_wallet_fails(rbf_node, dest_address):\n     rbfid = spend_one_input(rbf_node, dest_address)\n     rbf_node.walletlock()\n     assert_raises_rpc_error(-13, \"Please enter the wallet passphrase with walletpassphrase first.\",\n-                          rbf_node.bumpfee, rbfid)\n+                            rbf_node.bumpfee, rbfid)\n \n \n def spend_one_input(node, dest_address):"
      },
      {
        "sha": "20cb816ee81da1af934f5a19ec0e2ee27c25e434",
        "filename": "test/functional/wallet_dump.py",
        "status": "modified",
        "additions": 44,
        "deletions": 39,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/wallet_dump.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/wallet_dump.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_dump.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -3,7 +3,6 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the dumpwallet RPC.\"\"\"\n-\n import os\n \n from test_framework.test_framework import BitcoinTestFramework\n@@ -19,11 +18,12 @@ def read_dump(file_name, addrs, script_addrs, hd_master_addr_old):\n     Also check that the old hd_master is inactive\n     \"\"\"\n     with open(file_name, encoding='utf8') as inputfile:\n-        found_addr = 0\n+        found_legacy_addr = 0\n+        found_p2sh_segwit_addr = 0\n+        found_bech32_addr = 0\n         found_script_addr = 0\n         found_addr_chg = 0\n         found_addr_rsv = 0\n-        witness_addr_ret = None\n         hd_master_addr_ret = None\n         for line in inputfile:\n             # only read non comment lines\n@@ -60,14 +60,14 @@ def read_dump(file_name, addrs, script_addrs, hd_master_addr_old):\n                 # count key types\n                 for addrObj in addrs:\n                     if addrObj['address'] == addr.split(\",\")[0] and addrObj['hdkeypath'] == keypath and keytype == \"label=\":\n-                        # a labeled entry in the wallet should contain both a native address\n-                        # and the p2sh-p2wpkh address that was added at wallet setup\n-                        if len(addr.split(\",\")) == 2:\n-                            addr_list = addr.split(\",\")\n-                            # the entry should be of the first key in the wallet\n-                            assert_equal(addrs[0]['address'], addr_list[0])\n-                            witness_addr_ret = addr_list[1]\n-                        found_addr += 1\n+                        if addr.startswith('m') or addr.startswith('n'):\n+                            # P2PKH address\n+                            found_legacy_addr += 1\n+                        elif addr.startswith('2'):\n+                            # P2SH-segwit address\n+                            found_p2sh_segwit_addr += 1\n+                        elif addr.startswith('bcrt1'):\n+                            found_bech32_addr += 1\n                         break\n                     elif keytype == \"change=1\":\n                         found_addr_chg += 1\n@@ -82,13 +82,13 @@ def read_dump(file_name, addrs, script_addrs, hd_master_addr_old):\n                         found_script_addr += 1\n                         break\n \n-        return found_addr, found_script_addr, found_addr_chg, found_addr_rsv, hd_master_addr_ret, witness_addr_ret\n+        return found_legacy_addr, found_p2sh_segwit_addr, found_bech32_addr, found_script_addr, found_addr_chg, found_addr_rsv, hd_master_addr_ret\n \n \n class WalletDumpTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 1\n-        self.extra_args = [[\"-keypool=90\", \"-addresstype=legacy\", \"-deprecatedrpc=addwitnessaddress\"]]\n+        self.extra_args = [[\"-keypool=90\", \"-addresstype=legacy\"]]\n         self.rpc_timeout = 120\n \n     def skip_test_if_missing_module(self):\n@@ -102,49 +102,54 @@ def run_test(self):\n         wallet_unenc_dump = os.path.join(self.nodes[0].datadir, \"wallet.unencrypted.dump\")\n         wallet_enc_dump = os.path.join(self.nodes[0].datadir, \"wallet.encrypted.dump\")\n \n-        # generate 20 addresses to compare against the dump\n-        # but since we add a p2sh-p2wpkh address for the first pubkey in the\n-        # wallet, we will expect 21 addresses in the dump\n-        test_addr_count = 20\n+        # generate 30 addresses to compare against the dump\n+        # - 10 legacy P2PKH\n+        # - 10 P2SH-segwit\n+        # - 10 bech32\n+        test_addr_count = 10\n         addrs = []\n-        for i in range(0,test_addr_count):\n-            addr = self.nodes[0].getnewaddress()\n-            vaddr= self.nodes[0].getaddressinfo(addr) #required to get hd keypath\n-            addrs.append(vaddr)\n-        # Should be a no-op:\n-        self.nodes[0].keypoolrefill()\n+        for address_type in ['legacy', 'p2sh-segwit', 'bech32']:\n+            for i in range(0, test_addr_count):\n+                addr = self.nodes[0].getnewaddress(address_type=address_type)\n+                vaddr = self.nodes[0].getaddressinfo(addr)  # required to get hd keypath\n+                addrs.append(vaddr)\n \n-        # Test scripts dump by adding a P2SH witness and a 1-of-1 multisig address\n-        witness_addr = self.nodes[0].addwitnessaddress(addrs[0][\"address\"], True)\n+        # Test scripts dump by adding a 1-of-1 multisig address\n         multisig_addr = self.nodes[0].addmultisigaddress(1, [addrs[1][\"address\"]])[\"address\"]\n-        script_addrs = [witness_addr, multisig_addr]\n+\n+        # Refill the keypool. getnewaddress() refills the keypool *before* taking a key from\n+        # the keypool, so the final call to getnewaddress leaves the keypool with one key below\n+        # its capacity\n+        self.nodes[0].keypoolrefill()\n \n         # dump unencrypted wallet\n         result = self.nodes[0].dumpwallet(wallet_unenc_dump)\n         assert_equal(result['filename'], wallet_unenc_dump)\n \n-        found_addr, found_script_addr, found_addr_chg, found_addr_rsv, hd_master_addr_unenc, witness_addr_ret = \\\n-            read_dump(wallet_unenc_dump, addrs, script_addrs, None)\n-        assert_equal(found_addr, test_addr_count)  # all keys must be in the dump\n-        assert_equal(found_script_addr, 2)  # all scripts must be in the dump\n+        found_legacy_addr, found_p2sh_segwit_addr, found_bech32_addr, found_script_addr, found_addr_chg, found_addr_rsv, hd_master_addr_unenc = \\\n+            read_dump(wallet_unenc_dump, addrs, [multisig_addr], None)\n+        assert_equal(found_legacy_addr, test_addr_count)  # all keys must be in the dump\n+        assert_equal(found_p2sh_segwit_addr, test_addr_count)  # all keys must be in the dump\n+        assert_equal(found_bech32_addr, test_addr_count)  # all keys must be in the dump\n+        assert_equal(found_script_addr, 1)  # all scripts must be in the dump\n         assert_equal(found_addr_chg, 0)  # 0 blocks where mined\n         assert_equal(found_addr_rsv, 90 * 2)  # 90 keys plus 100% internal keys\n-        assert_equal(witness_addr_ret, witness_addr)  # p2sh-p2wsh address added to the first key\n \n-        #encrypt wallet, restart, unlock and dump\n+        # encrypt wallet, restart, unlock and dump\n         self.nodes[0].encryptwallet('test')\n         self.nodes[0].walletpassphrase('test', 10)\n         # Should be a no-op:\n         self.nodes[0].keypoolrefill()\n         self.nodes[0].dumpwallet(wallet_enc_dump)\n \n-        found_addr, found_script_addr, found_addr_chg, found_addr_rsv, _, witness_addr_ret = \\\n-            read_dump(wallet_enc_dump, addrs, script_addrs, hd_master_addr_unenc)\n-        assert_equal(found_addr, test_addr_count)\n-        assert_equal(found_script_addr, 2)\n+        found_legacy_addr, found_p2sh_segwit_addr, found_bech32_addr, found_script_addr, found_addr_chg, found_addr_rsv, _ = \\\n+            read_dump(wallet_enc_dump, addrs, [multisig_addr], hd_master_addr_unenc)\n+        assert_equal(found_legacy_addr, test_addr_count)  # all keys must be in the dump\n+        assert_equal(found_p2sh_segwit_addr, test_addr_count)  # all keys must be in the dump\n+        assert_equal(found_bech32_addr, test_addr_count)  # all keys must be in the dump\n+        assert_equal(found_script_addr, 1)\n         assert_equal(found_addr_chg, 90 * 2)  # old reserve keys are marked as change now\n         assert_equal(found_addr_rsv, 90 * 2)\n-        assert_equal(witness_addr_ret, witness_addr)\n \n         # Overwriting should fail\n         assert_raises_rpc_error(-8, \"already exists\", lambda: self.nodes[0].dumpwallet(wallet_enc_dump))\n@@ -155,13 +160,13 @@ def run_test(self):\n \n         # Make sure the address is not IsMine before import\n         result = self.nodes[0].getaddressinfo(multisig_addr)\n-        assert(result['ismine'] == False)\n+        assert not result['ismine']\n \n         self.nodes[0].importwallet(wallet_unenc_dump)\n \n         # Now check IsMine is true\n         result = self.nodes[0].getaddressinfo(multisig_addr)\n-        assert(result['ismine'] == True)\n+        assert result['ismine']\n \n if __name__ == '__main__':\n     WalletDumpTest().main()"
      },
      {
        "sha": "46462a16f371282a3fa1ae4346ebb243c7154563",
        "filename": "test/functional/wallet_import_rescan.py",
        "status": "modified",
        "additions": 22,
        "deletions": 9,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/wallet_import_rescan.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/wallet_import_rescan.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_import_rescan.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -46,11 +46,11 @@ def do_import(self, timestamp):\n \n         if self.call == Call.single:\n             if self.data == Data.address:\n-                response = self.try_rpc(self.node.importaddress, address=self.address[\"address\"], rescan=rescan)\n+                response = self.try_rpc(self.node.importaddress, address=self.address[\"address\"], label=self.label, rescan=rescan)\n             elif self.data == Data.pub:\n-                response = self.try_rpc(self.node.importpubkey, pubkey=self.address[\"pubkey\"], rescan=rescan)\n+                response = self.try_rpc(self.node.importpubkey, pubkey=self.address[\"pubkey\"], label=self.label, rescan=rescan)\n             elif self.data == Data.priv:\n-                response = self.try_rpc(self.node.importprivkey, privkey=self.key, rescan=rescan)\n+                response = self.try_rpc(self.node.importprivkey, privkey=self.key, label=self.label, rescan=rescan)\n             assert_equal(response, None)\n \n         elif self.call in (Call.multiaddress, Call.multiscript):\n@@ -61,18 +61,32 @@ def do_import(self, timestamp):\n                 \"timestamp\": timestamp + TIMESTAMP_WINDOW + (1 if self.rescan == Rescan.late_timestamp else 0),\n                 \"pubkeys\": [self.address[\"pubkey\"]] if self.data == Data.pub else [],\n                 \"keys\": [self.key] if self.data == Data.priv else [],\n+                \"label\": self.label,\n                 \"watchonly\": self.data != Data.priv\n             }], {\"rescan\": self.rescan in (Rescan.yes, Rescan.late_timestamp)})\n             assert_equal(response, [{\"success\": True}])\n \n     def check(self, txid=None, amount=None, confirmations=None):\n-        \"\"\"Verify that listreceivedbyaddress returns expected values.\"\"\"\n+        \"\"\"Verify that listtransactions/listreceivedbyaddress return expected values.\"\"\"\n+\n+        txs = self.node.listtransactions(label=self.label, count=10000, include_watchonly=True)\n+        assert_equal(len(txs), self.expected_txs)\n \n         addresses = self.node.listreceivedbyaddress(minconf=0, include_watchonly=True, address_filter=self.address['address'])\n         if self.expected_txs:\n             assert_equal(len(addresses[0][\"txids\"]), self.expected_txs)\n \n         if txid is not None:\n+            tx, = [tx for tx in txs if tx[\"txid\"] == txid]\n+            assert_equal(tx[\"label\"], self.label)\n+            assert_equal(tx[\"address\"], self.address[\"address\"])\n+            assert_equal(tx[\"amount\"], amount)\n+            assert_equal(tx[\"category\"], \"receive\")\n+            assert_equal(tx[\"label\"], self.label)\n+            assert_equal(tx[\"txid\"], txid)\n+            assert_equal(tx[\"confirmations\"], confirmations)\n+            assert_equal(\"trusted\" not in tx, True)\n+\n             address, = [ad for ad in addresses if txid in ad[\"txids\"]]\n             assert_equal(address[\"address\"], self.address[\"address\"])\n             assert_equal(address[\"amount\"], self.expected_balance)\n@@ -122,21 +136,20 @@ def setup_network(self):\n \n         # Import keys with pruning disabled\n         self.start_nodes(extra_args=[[]] * self.num_nodes)\n-        super().import_deterministic_coinbase_privkeys()\n+        for n in self.nodes:\n+            n.importprivkey(privkey=n.get_deterministic_priv_key().key, label='coinbase')\n         self.stop_nodes()\n \n         self.start_nodes()\n         for i in range(1, self.num_nodes):\n             connect_nodes(self.nodes[i], 0)\n \n-    def import_deterministic_coinbase_privkeys(self):\n-        pass\n-\n     def run_test(self):\n         # Create one transaction on node 0 with a unique amount for\n         # each possible type of wallet import RPC.\n         for i, variant in enumerate(IMPORT_VARIANTS):\n-            variant.address = self.nodes[1].getaddressinfo(self.nodes[1].getnewaddress())\n+            variant.label = \"label {} {}\".format(i, variant)\n+            variant.address = self.nodes[1].getaddressinfo(self.nodes[1].getnewaddress(variant.label))\n             variant.key = self.nodes[1].dumpprivkey(variant.address[\"address\"])\n             variant.initial_amount = 1 - (i + 1) / 64\n             variant.initial_txid = self.nodes[0].sendtoaddress(variant.address[\"address\"], variant.initial_amount)"
      },
      {
        "sha": "95acaa752e528e2bc7dcacab48d5e0b5d6cd8d83",
        "filename": "test/functional/wallet_import_with_label.py",
        "status": "added",
        "additions": 134,
        "deletions": 0,
        "changes": 134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/wallet_import_with_label.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/wallet_import_with_label.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_import_with_label.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -0,0 +1,134 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the behavior of RPC importprivkey on set and unset labels of\n+addresses.\n+\n+It tests different cases in which an address is imported with importaddress\n+with or without a label and then its private key is imported with importprivkey\n+with and without a label.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal\n+\n+\n+class ImportWithLabel(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.setup_clean_chain = True\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        \"\"\"Main test logic\"\"\"\n+\n+        self.log.info(\n+            \"Test importaddress with label and importprivkey without label.\"\n+        )\n+        self.log.info(\"Import a watch-only address with a label.\")\n+        address = self.nodes[0].getnewaddress()\n+        label = \"Test Label\"\n+        self.nodes[1].importaddress(address, label)\n+        address_assert = self.nodes[1].getaddressinfo(address)\n+\n+        assert_equal(address_assert[\"iswatchonly\"], True)\n+        assert_equal(address_assert[\"ismine\"], False)\n+        assert_equal(address_assert[\"label\"], label)\n+\n+        self.log.info(\n+            \"Import the watch-only address's private key without a \"\n+            \"label and the address should keep its label.\"\n+        )\n+        priv_key = self.nodes[0].dumpprivkey(address)\n+        self.nodes[1].importprivkey(priv_key)\n+\n+        assert_equal(label, self.nodes[1].getaddressinfo(address)[\"label\"])\n+\n+        self.log.info(\n+            \"Test importaddress without label and importprivkey with label.\"\n+        )\n+        self.log.info(\"Import a watch-only address without a label.\")\n+        address2 = self.nodes[0].getnewaddress()\n+        self.nodes[1].importaddress(address2)\n+        address_assert2 = self.nodes[1].getaddressinfo(address2)\n+\n+        assert_equal(address_assert2[\"iswatchonly\"], True)\n+        assert_equal(address_assert2[\"ismine\"], False)\n+        assert_equal(address_assert2[\"label\"], \"\")\n+\n+        self.log.info(\n+            \"Import the watch-only address's private key with a \"\n+            \"label and the address should have its label updated.\"\n+        )\n+        priv_key2 = self.nodes[0].dumpprivkey(address2)\n+        label2 = \"Test Label 2\"\n+        self.nodes[1].importprivkey(priv_key2, label2)\n+\n+        assert_equal(label2, self.nodes[1].getaddressinfo(address2)[\"label\"])\n+\n+        self.log.info(\"Test importaddress with label and importprivkey with label.\")\n+        self.log.info(\"Import a watch-only address with a label.\")\n+        address3 = self.nodes[0].getnewaddress()\n+        label3_addr = \"Test Label 3 for importaddress\"\n+        self.nodes[1].importaddress(address3, label3_addr)\n+        address_assert3 = self.nodes[1].getaddressinfo(address3)\n+\n+        assert_equal(address_assert3[\"iswatchonly\"], True)\n+        assert_equal(address_assert3[\"ismine\"], False)\n+        assert_equal(address_assert3[\"label\"], label3_addr)\n+\n+        self.log.info(\n+            \"Import the watch-only address's private key with a \"\n+            \"label and the address should have its label updated.\"\n+        )\n+        priv_key3 = self.nodes[0].dumpprivkey(address3)\n+        label3_priv = \"Test Label 3 for importprivkey\"\n+        self.nodes[1].importprivkey(priv_key3, label3_priv)\n+\n+        assert_equal(label3_priv, self.nodes[1].getaddressinfo(address3)[\"label\"])\n+\n+        self.log.info(\n+            \"Test importprivkey won't label new dests with the same \"\n+            \"label as others labeled dests for the same key.\"\n+        )\n+        self.log.info(\"Import a watch-only legacy address with a label.\")\n+        address4 = self.nodes[0].getnewaddress()\n+        label4_addr = \"Test Label 4 for importaddress\"\n+        self.nodes[1].importaddress(address4, label4_addr)\n+        address_assert4 = self.nodes[1].getaddressinfo(address4)\n+\n+        assert_equal(address_assert4[\"iswatchonly\"], True)\n+        assert_equal(address_assert4[\"ismine\"], False)\n+        assert_equal(address_assert4[\"label\"], label4_addr)\n+\n+        self.log.info(\"Asserts address has no embedded field with dests.\")\n+\n+        assert_equal(address_assert4.get(\"embedded\"), None)\n+\n+        self.log.info(\n+            \"Import the watch-only address's private key without a \"\n+            \"label and new destinations for the key should have an \"\n+            \"empty label while the 'old' destination should keep \"\n+            \"its label.\"\n+        )\n+        priv_key4 = self.nodes[0].dumpprivkey(address4)\n+        self.nodes[1].importprivkey(priv_key4)\n+        address_assert4 = self.nodes[1].getaddressinfo(address4)\n+\n+        assert address_assert4.get(\"embedded\")\n+\n+        bcaddress_assert = self.nodes[1].getaddressinfo(\n+            address_assert4[\"embedded\"][\"address\"]\n+        )\n+\n+        assert_equal(address_assert4[\"label\"], label4_addr)\n+        assert_equal(bcaddress_assert[\"label\"], \"\")\n+\n+        self.stop_nodes()\n+\n+\n+if __name__ == \"__main__\":\n+    ImportWithLabel().main()"
      },
      {
        "sha": "5c789b1c0300658c0a0c8b5b141a322b1cf7834d",
        "filename": "test/functional/wallet_importmulti.py",
        "status": "modified",
        "additions": 175,
        "deletions": 12,
        "changes": 187,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/wallet_importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c6e2d00d4efd7553dd82b0e7765a12477c8bff1/test/functional/wallet_importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importmulti.py?ref=7c6e2d00d4efd7553dd82b0e7765a12477c8bff1",
        "patch": "@@ -11,8 +11,14 @@\n     assert_greater_than,\n     assert_raises_rpc_error,\n     bytes_to_hex_str,\n+    hex_str_to_bytes\n )\n-\n+from test_framework.script import (\n+    CScript,\n+    OP_0,\n+    hash160\n+)\n+from test_framework.messages import sha256\n \n class ImportMultiTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -48,7 +54,7 @@ def run_test (self):\n \n         # RPC importmulti -----------------------------------------------\n \n-        # Bitcoin Address\n+        # Bitcoin Address (implicit non-internal)\n         self.log.info(\"Should import an address\")\n         address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n@@ -62,6 +68,7 @@ def run_test (self):\n         assert_equal(address_assert['iswatchonly'], True)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal(address_assert['timestamp'], timestamp)\n+        assert_equal(address_assert['ischange'], False)\n         watchonly_address = address['address']\n         watchonly_timestamp = timestamp\n \n@@ -89,6 +96,20 @@ def run_test (self):\n         assert_equal(address_assert['iswatchonly'], True)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal(address_assert['timestamp'], timestamp)\n+        assert_equal(address_assert['ischange'], True)\n+\n+        # ScriptPubKey + internal + label\n+        self.log.info(\"Should not allow a label to be specified when internal is true\")\n+        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": address['scriptPubKey'],\n+            \"timestamp\": \"now\",\n+            \"internal\": True,\n+            \"label\": \"Example label\"\n+        }])\n+        assert_equal(result[0]['success'], False)\n+        assert_equal(result[0]['error']['code'], -8)\n+        assert_equal(result[0]['error']['message'], 'Internal addresses should not have a label')\n \n         # Nonstandard scriptPubKey + !internal\n         self.log.info(\"Should not import a nonstandard scriptPubKey without internal flag\")\n@@ -107,15 +128,16 @@ def run_test (self):\n         assert_equal('timestamp' in address_assert, False)\n \n \n-        # Address + Public key + !Internal\n+        # Address + Public key + !Internal(explicit)\n         self.log.info(\"Should import an address with public key\")\n         address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n                 \"address\": address['address']\n             },\n             \"timestamp\": \"now\",\n-            \"pubkeys\": [ address['pubkey'] ]\n+            \"pubkeys\": [ address['pubkey'] ],\n+            \"internal\": False\n         }])\n         assert_equal(result[0]['success'], True)\n         address_assert = self.nodes[1].getaddressinfo(address['address'])\n@@ -133,7 +155,7 @@ def run_test (self):\n             \"pubkeys\": [ address['pubkey'] ],\n             \"internal\": True\n         }]\n-        result = self.nodes[1].importmulti(request)\n+        result = self.nodes[1].importmulti(requests=request)\n         assert_equal(result[0]['success'], True)\n         address_assert = self.nodes[1].getaddressinfo(address['address'])\n         assert_equal(address_assert['iswatchonly'], True)\n@@ -148,7 +170,7 @@ def run_test (self):\n             \"timestamp\": \"now\",\n             \"pubkeys\": [ address['pubkey'] ]\n         }]\n-        result = self.nodes[1].importmulti(request)\n+        result = self.nodes[1].importmulti(requests=request)\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -8)\n         assert_equal(result[0]['error']['message'], 'Internal must be set to true for nonstandard scriptPubKey imports.')\n@@ -198,7 +220,7 @@ def run_test (self):\n         }])\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -8)\n-        assert_equal(result[0]['error']['message'], 'Incompatibility found between watchonly and keys')\n+        assert_equal(result[0]['error']['message'], 'Watch-only addresses should not include private keys')\n         address_assert = self.nodes[1].getaddressinfo(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n@@ -339,7 +361,7 @@ def run_test (self):\n         }])\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -8)\n-        assert_equal(result[0]['error']['message'], 'Incompatibility found between watchonly and keys')\n+        assert_equal(result[0]['error']['message'], 'Watch-only addresses should not include private keys')\n \n \n         # Address + Public key + !Internal + Wrong pubkey\n@@ -355,7 +377,7 @@ def run_test (self):\n         }])\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -5)\n-        assert_equal(result[0]['error']['message'], 'Consistency check failed')\n+        assert_equal(result[0]['error']['message'], 'Key does not match address destination')\n         address_assert = self.nodes[1].getaddressinfo(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n@@ -375,7 +397,7 @@ def run_test (self):\n         result = self.nodes[1].importmulti(request)\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -5)\n-        assert_equal(result[0]['error']['message'], 'Consistency check failed')\n+        assert_equal(result[0]['error']['message'], 'Key does not match address destination')\n         address_assert = self.nodes[1].getaddressinfo(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n@@ -395,7 +417,7 @@ def run_test (self):\n         }])\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -5)\n-        assert_equal(result[0]['error']['message'], 'Consistency check failed')\n+        assert_equal(result[0]['error']['message'], 'Key does not match address destination')\n         address_assert = self.nodes[1].getaddressinfo(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n@@ -414,7 +436,7 @@ def run_test (self):\n         }])\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -5)\n-        assert_equal(result[0]['error']['message'], 'Consistency check failed')\n+        assert_equal(result[0]['error']['message'], 'Key does not match address destination')\n         address_assert = self.nodes[1].getaddressinfo(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n@@ -458,6 +480,147 @@ def run_test (self):\n                 \"timestamp\": \"\",\n             }])\n \n+        # Import P2WPKH address as watch only\n+        self.log.info(\"Should import a P2WPKH address as watch only\")\n+        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress(address_type=\"bech32\"))\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": address['address']\n+            },\n+            \"timestamp\": \"now\",\n+        }])\n+        assert_equal(result[0]['success'], True)\n+        address_assert = self.nodes[1].getaddressinfo(address['address'])\n+        assert_equal(address_assert['iswatchonly'], True)\n+        assert_equal(address_assert['solvable'], False)\n+\n+        # Import P2WPKH address with public key but no private key\n+        self.log.info(\"Should import a P2WPKH address and public key as solvable but not spendable\")\n+        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress(address_type=\"bech32\"))\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": address['address']\n+            },\n+            \"timestamp\": \"now\",\n+            \"pubkeys\": [ address['pubkey'] ]\n+        }])\n+        assert_equal(result[0]['success'], True)\n+        address_assert = self.nodes[1].getaddressinfo(address['address'])\n+        assert_equal(address_assert['ismine'], False)\n+        assert_equal(address_assert['solvable'], True)\n+\n+        # Import P2WPKH address with key and check it is spendable\n+        self.log.info(\"Should import a P2WPKH address with key\")\n+        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress(address_type=\"bech32\"))\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": address['address']\n+            },\n+            \"timestamp\": \"now\",\n+            \"keys\": [self.nodes[0].dumpprivkey(address['address'])]\n+        }])\n+        assert_equal(result[0]['success'], True)\n+        address_assert = self.nodes[1].getaddressinfo(address['address'])\n+        assert_equal(address_assert['iswatchonly'], False)\n+        assert_equal(address_assert['ismine'], True)\n+\n+        # P2WSH multisig address without scripts or keys\n+        sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        sig_address_2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        multi_sig_script = self.nodes[0].addmultisigaddress(2, [sig_address_1['pubkey'], sig_address_2['pubkey']], \"\", \"bech32\")\n+        self.log.info(\"Should import a p2wsh multisig as watch only without respective redeem script and private keys\")\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": multi_sig_script['address']\n+            },\n+            \"timestamp\": \"now\"\n+        }])\n+        assert_equal(result[0]['success'], True)\n+        address_assert = self.nodes[1].getaddressinfo(multi_sig_script['address'])\n+        assert_equal(address_assert['solvable'], False)\n+\n+        # Same P2WSH multisig address as above, but now with witnessscript + private keys\n+        self.log.info(\"Should import a p2wsh with respective redeem script and private keys\")\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": multi_sig_script['address']\n+            },\n+            \"timestamp\": \"now\",\n+            \"witnessscript\": multi_sig_script['redeemScript'],\n+            \"keys\": [ self.nodes[0].dumpprivkey(sig_address_1['address']), self.nodes[0].dumpprivkey(sig_address_2['address']) ]\n+        }])\n+        assert_equal(result[0]['success'], True)\n+        address_assert = self.nodes[1].getaddressinfo(multi_sig_script['address'])\n+        assert_equal(address_assert['solvable'], True)\n+        assert_equal(address_assert['ismine'], True)\n+        assert_equal(address_assert['sigsrequired'], 2)\n+\n+        # P2SH-P2WPKH address with no redeemscript or public or private key\n+        sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress(address_type=\"p2sh-segwit\"))\n+        pubkeyhash = hash160(hex_str_to_bytes(sig_address_1['pubkey']))\n+        pkscript = CScript([OP_0, pubkeyhash])\n+        self.log.info(\"Should import a p2sh-p2wpkh without redeem script or keys\")\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": sig_address_1['address']\n+            },\n+            \"timestamp\": \"now\"\n+        }])\n+        assert_equal(result[0]['success'], True)\n+        address_assert = self.nodes[1].getaddressinfo(sig_address_1['address'])\n+        assert_equal(address_assert['solvable'], False)\n+        assert_equal(address_assert['ismine'], False)\n+\n+        # P2SH-P2WPKH address + redeemscript + public key with no private key\n+        self.log.info(\"Should import a p2sh-p2wpkh with respective redeem script and pubkey as solvable\")\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": sig_address_1['address']\n+            },\n+            \"timestamp\": \"now\",\n+            \"redeemscript\": bytes_to_hex_str(pkscript),\n+            \"pubkeys\": [ sig_address_1['pubkey'] ]\n+        }])\n+        assert_equal(result[0]['success'], True)\n+        address_assert = self.nodes[1].getaddressinfo(sig_address_1['address'])\n+        assert_equal(address_assert['solvable'], True)\n+        assert_equal(address_assert['ismine'], False)\n+\n+        # P2SH-P2WPKH address + redeemscript + private key\n+        sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress(address_type=\"p2sh-segwit\"))\n+        pubkeyhash = hash160(hex_str_to_bytes(sig_address_1['pubkey']))\n+        pkscript = CScript([OP_0, pubkeyhash])\n+        self.log.info(\"Should import a p2sh-p2wpkh with respective redeem script and private keys\")\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": sig_address_1['address']\n+            },\n+            \"timestamp\": \"now\",\n+            \"redeemscript\": bytes_to_hex_str(pkscript),\n+            \"keys\": [ self.nodes[0].dumpprivkey(sig_address_1['address'])]\n+        }])\n+        assert_equal(result[0]['success'], True)\n+        address_assert = self.nodes[1].getaddressinfo(sig_address_1['address'])\n+        assert_equal(address_assert['solvable'], True)\n+        assert_equal(address_assert['ismine'], True)\n+\n+        # P2SH-P2WSH 1-of-1 multisig + redeemscript with no private key\n+        sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        multi_sig_script = self.nodes[0].addmultisigaddress(1, [sig_address_1['pubkey']], \"\", \"p2sh-segwit\")\n+        scripthash = sha256(hex_str_to_bytes(multi_sig_script['redeemScript']))\n+        redeem_script = CScript([OP_0, scripthash])\n+        self.log.info(\"Should import a p2sh-p2wsh with respective redeem script but no private key\")\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": multi_sig_script['address']\n+            },\n+            \"timestamp\": \"now\",\n+            \"redeemscript\": bytes_to_hex_str(redeem_script),\n+            \"witnessscript\": multi_sig_script['redeemScript']\n+        }])\n+        assert_equal(result[0]['success'], True)\n+        address_assert = self.nodes[1].getaddressinfo(multi_sig_script['address'])\n+        assert_equal(address_assert['solvable'], True)\n \n if __name__ == '__main__':\n     ImportMultiTest ().main ()"
      }
    ]
  }
]