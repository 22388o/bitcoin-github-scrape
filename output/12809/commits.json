[
  {
    "sha": "91c8756c6561e0a1bba64ad91cf4a4157d9a0749",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MWM4NzU2YzY1NjFlMGExYmJhNjRhZDkxY2Y0YTQxNTdkOWEwNzQ5",
    "commit": {
      "author": {
        "name": "murrayn",
        "email": "github@nesbitt.ca",
        "date": "2018-03-27T00:24:00Z"
      },
      "committer": {
        "name": "murrayn",
        "email": "github@nesbitt.ca",
        "date": "2018-03-28T04:30:53Z"
      },
      "message": "Formatting changes to --help code for increased readability.",
      "tree": {
        "sha": "53cc8e99d976494f68397ff17ba8d300afa71094",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/53cc8e99d976494f68397ff17ba8d300afa71094"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/91c8756c6561e0a1bba64ad91cf4a4157d9a0749",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/91c8756c6561e0a1bba64ad91cf4a4157d9a0749",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/91c8756c6561e0a1bba64ad91cf4a4157d9a0749",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/91c8756c6561e0a1bba64ad91cf4a4157d9a0749/comments",
    "author": {
      "login": "murrayn",
      "id": 5404807,
      "node_id": "MDQ6VXNlcjU0MDQ4MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5404807?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/murrayn",
      "html_url": "https://github.com/murrayn",
      "followers_url": "https://api.github.com/users/murrayn/followers",
      "following_url": "https://api.github.com/users/murrayn/following{/other_user}",
      "gists_url": "https://api.github.com/users/murrayn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/murrayn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/murrayn/subscriptions",
      "organizations_url": "https://api.github.com/users/murrayn/orgs",
      "repos_url": "https://api.github.com/users/murrayn/repos",
      "events_url": "https://api.github.com/users/murrayn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/murrayn/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "murrayn",
      "id": 5404807,
      "node_id": "MDQ6VXNlcjU0MDQ4MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5404807?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/murrayn",
      "html_url": "https://github.com/murrayn",
      "followers_url": "https://api.github.com/users/murrayn/followers",
      "following_url": "https://api.github.com/users/murrayn/following{/other_user}",
      "gists_url": "https://api.github.com/users/murrayn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/murrayn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/murrayn/subscriptions",
      "organizations_url": "https://api.github.com/users/murrayn/orgs",
      "repos_url": "https://api.github.com/users/murrayn/repos",
      "events_url": "https://api.github.com/users/murrayn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/murrayn/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7466a26cab5d66665991433947964a638f5b957e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7466a26cab5d66665991433947964a638f5b957e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7466a26cab5d66665991433947964a638f5b957e"
      }
    ],
    "stats": {
      "total": 608,
      "additions": 432,
      "deletions": 176
    },
    "files": [
      {
        "sha": "df3437a145fed6d962ca8712f8d0950afa3eb610",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 9,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/91c8756c6561e0a1bba64ad91cf4a4157d9a0749/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/91c8756c6561e0a1bba64ad91cf4a4157d9a0749/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=91c8756c6561e0a1bba64ad91cf4a4157d9a0749",
        "patch": "@@ -35,20 +35,39 @@ std::string HelpMessageCli()\n     std::string strUsage;\n     strUsage += HelpMessageGroup(_(\"Options:\"));\n     strUsage += HelpMessageOpt(\"-?\", _(\"This help message\"));\n-    strUsage += HelpMessageOpt(\"-conf=<file>\", strprintf(_(\"Specify configuration file. Relative paths will be prefixed by datadir location. (default: %s)\"), BITCOIN_CONF_FILENAME));\n+    strUsage += HelpMessageOpt(\"-conf=<file>\", strprintf(_(\n+        \"Specify configuration file. Relative paths will be prefixed by datadir location. (default: %s)\"),\n+            BITCOIN_CONF_FILENAME));\n     strUsage += HelpMessageOpt(\"-datadir=<dir>\", _(\"Specify data directory\"));\n-    strUsage += HelpMessageOpt(\"-getinfo\", _(\"Get general information from the remote server. Note that unlike server-side RPC calls, the results of -getinfo is the result of multiple non-atomic requests. Some entries in the result may represent results from different states (e.g. wallet balance may be as of a different block from the chain state reported)\"));\n+    strUsage += HelpMessageOpt(\"-getinfo\", _(\n+        \"Get general information from the remote server. Note that unlike server-side RPC calls, \"\n+        \"the results of -getinfo is the result of multiple non-atomic requests. Some entries in \"\n+        \"the result may represent results from different states (e.g. wallet balance may be as \"\n+        \"of a different block from the chain state reported)\"));\n     AppendParamsHelpMessages(strUsage);\n-    strUsage += HelpMessageOpt(\"-named\", strprintf(_(\"Pass named instead of positional arguments (default: %s)\"), DEFAULT_NAMED));\n-    strUsage += HelpMessageOpt(\"-rpcclienttimeout=<n>\", strprintf(_(\"Timeout in seconds during HTTP requests, or 0 for no timeout. (default: %d)\"), DEFAULT_HTTP_CLIENT_TIMEOUT));\n-    strUsage += HelpMessageOpt(\"-rpcconnect=<ip>\", strprintf(_(\"Send commands to node running on <ip> (default: %s)\"), DEFAULT_RPCCONNECT));\n+    strUsage += HelpMessageOpt(\"-named\", strprintf(_(\n+        \"Pass named instead of positional arguments (default: %s)\"), DEFAULT_NAMED));\n+    strUsage += HelpMessageOpt(\"-rpcclienttimeout=<n>\", strprintf(_(\n+        \"Timeout in seconds during HTTP requests, or 0 for no timeout. (default: %d)\"),\n+            DEFAULT_HTTP_CLIENT_TIMEOUT));\n+    strUsage += HelpMessageOpt(\"-rpcconnect=<ip>\", strprintf(_(\n+        \"Send commands to node running on <ip> (default: %s)\"), DEFAULT_RPCCONNECT));\n     strUsage += HelpMessageOpt(\"-rpcpassword=<pw>\", _(\"Password for JSON-RPC connections\"));\n-    strUsage += HelpMessageOpt(\"-rpcport=<port>\", strprintf(_(\"Connect to JSON-RPC on <port> (default: %u or testnet: %u)\"), defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort()));\n+    strUsage += HelpMessageOpt(\"-rpcport=<port>\", strprintf(_(\n+        \"Connect to JSON-RPC on <port> (default: %u or testnet: %u)\"), \n+            defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort()));\n     strUsage += HelpMessageOpt(\"-rpcuser=<user>\", _(\"Username for JSON-RPC connections\"));\n     strUsage += HelpMessageOpt(\"-rpcwait\", _(\"Wait for RPC server to start\"));\n-    strUsage += HelpMessageOpt(\"-rpcwallet=<walletname>\", _(\"Send RPC for non-default wallet on RPC server (needs to exactly match corresponding -wallet option passed to bitcoind)\"));\n-    strUsage += HelpMessageOpt(\"-stdin\", _(\"Read extra arguments from standard input, one per line until EOF/Ctrl-D (recommended for sensitive information such as passphrases).  When combined with -stdinrpcpass, the first line from standard input is used for the RPC password.\"));\n-    strUsage += HelpMessageOpt(\"-stdinrpcpass\", strprintf(_(\"Read RPC password from standard input as a single line.  When combined with -stdin, the first line from standard input is used for the RPC password.\")));\n+    strUsage += HelpMessageOpt(\"-rpcwallet=<walletname>\", _(\n+        \"Send RPC for non-default wallet on RPC server (needs to exactly match corresponding \"\n+        \"-wallet option passed to bitcoind)\"));\n+    strUsage += HelpMessageOpt(\"-stdin\", _(\n+        \"Read extra arguments from standard input, one per line until EOF/Ctrl-D (recommended \"\n+        \"for sensitive information such as passphrases).  When combined with -stdinrpcpass, \"\n+        \"the first line from standard input is used for the RPC password.\"));\n+    strUsage += HelpMessageOpt(\"-stdinrpcpass\", strprintf(_(\n+        \"Read RPC password from standard input as a single line.  When combined with -stdin, \"\n+        \"the first line from standard input is used for the RPC password.\")));\n \n     return strUsage;\n }"
      },
      {
        "sha": "361bca77067851dac28dc0e330e11394c966673b",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 5,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/91c8756c6561e0a1bba64ad91cf4a4157d9a0749/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/91c8756c6561e0a1bba64ad91cf4a4157d9a0749/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=91c8756c6561e0a1bba64ad91cf4a4157d9a0749",
        "patch": "@@ -79,16 +79,19 @@ static int AppInitRawTx(int argc, char* argv[])\n         strUsage += HelpMessageOpt(\"nversion=N\", _(\"Set TX version to N\"));\n         strUsage += HelpMessageOpt(\"outaddr=VALUE:ADDRESS\", _(\"Add address-based output to TX\"));\n         strUsage += HelpMessageOpt(\"outdata=[VALUE:]DATA\", _(\"Add data-based output to TX\"));\n-        strUsage += HelpMessageOpt(\"outmultisig=VALUE:REQUIRED:PUBKEYS:PUBKEY1:PUBKEY2:....[:FLAGS]\", _(\"Add Pay To n-of-m Multi-sig output to TX. n = REQUIRED, m = PUBKEYS\") + \". \" +\n+        strUsage += HelpMessageOpt(\"outmultisig=VALUE:REQUIRED:PUBKEYS:PUBKEY1:PUBKEY2:....[:FLAGS]\",\n+            _(\"Add Pay To n-of-m Multi-sig output to TX. n = REQUIRED, m = PUBKEYS\") + \". \" +\n             _(\"Optionally add the \\\"W\\\" flag to produce a pay-to-witness-script-hash output\") + \". \" +\n             _(\"Optionally add the \\\"S\\\" flag to wrap the output in a pay-to-script-hash.\"));\n-        strUsage += HelpMessageOpt(\"outpubkey=VALUE:PUBKEY[:FLAGS]\", _(\"Add pay-to-pubkey output to TX\") + \". \" +\n-            _(\"Optionally add the \\\"W\\\" flag to produce a pay-to-witness-pubkey-hash output\") + \". \" +\n-            _(\"Optionally add the \\\"S\\\" flag to wrap the output in a pay-to-script-hash.\"));\n+        strUsage += HelpMessageOpt(\"outpubkey=VALUE:PUBKEY[:FLAGS]\", _(\n+            \"Add pay-to-pubkey output to TX. Optionally add the \\\"W\\\" flag to produce a \"\n+            \"pay-to-witness-pubkey-hash output. Optionally add the \\\"S\\\" flag to wrap the \"\n+            \"output in a pay-to-script-hash.\"));\n         strUsage += HelpMessageOpt(\"outscript=VALUE:SCRIPT[:FLAGS]\", _(\"Add raw script output to TX\") + \". \" +\n             _(\"Optionally add the \\\"W\\\" flag to produce a pay-to-witness-script-hash output\") + \". \" +\n             _(\"Optionally add the \\\"S\\\" flag to wrap the output in a pay-to-script-hash.\"));\n-        strUsage += HelpMessageOpt(\"replaceable(=N)\", _(\"Set RBF opt-in sequence number for input N (if not provided, opt-in all available inputs)\"));\n+        strUsage += HelpMessageOpt(\"replaceable(=N)\", _(\n+            \"Set RBF opt-in sequence number for input N (if not provided, opt-in all available inputs)\"));\n         strUsage += HelpMessageOpt(\"sign=SIGHASH-FLAGS\", _(\"Add zero or more signatures to transaction\") + \". \" +\n             _(\"This command requires JSON registers:\") +\n             _(\"prevtxs=JSON object\") + \", \" +"
      },
      {
        "sha": "c523b32ba211cfb0e391fb937433666efccf3af3",
        "filename": "src/chainparamsbase.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/91c8756c6561e0a1bba64ad91cf4a4157d9a0749/src/chainparamsbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/91c8756c6561e0a1bba64ad91cf4a4157d9a0749/src/chainparamsbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsbase.cpp?ref=91c8756c6561e0a1bba64ad91cf4a4157d9a0749",
        "patch": "@@ -18,8 +18,9 @@ void AppendParamsHelpMessages(std::string& strUsage, bool debugHelp)\n {\n     strUsage += HelpMessageGroup(_(\"Chain selection options:\"));\n     if (debugHelp) {\n-        strUsage += HelpMessageOpt(\"-regtest\", \"Enter regression test mode, which uses a special chain in which blocks can be solved instantly. \"\n-                                   \"This is intended for regression testing tools and app development.\");\n+        strUsage += HelpMessageOpt(\"-regtest\",\n+            \"Enter regression test mode, which uses a special chain in which blocks can be solved \"\n+            \"instantly. This is intended for regression testing tools and app development.\");\n     }\n     strUsage += HelpMessageOpt(\"-testnet\", _(\"Use the test chain\"));\n }"
      },
      {
        "sha": "6dc88cf592913ba3ac277d412d56e429303460c9",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 312,
        "deletions": 124,
        "changes": 436,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/91c8756c6561e0a1bba64ad91cf4a4157d9a0749/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/91c8756c6561e0a1bba64ad91cf4a4157d9a0749/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=91c8756c6561e0a1bba64ad91cf4a4157d9a0749",
        "patch": "@@ -327,93 +327,187 @@ std::string HelpMessage(HelpMessageMode mode)\n     const bool showDebug = gArgs.GetBoolArg(\"-help-debug\", false);\n \n     // When adding new options to the categories, please keep and ensure alphabetical ordering.\n-    // Do not translate _(...) -help-debug options, Many technical terms, and only a very small audience, so is unnecessary stress to translators.\n+    // Do not translate _(...) -help-debug options, Many technical terms, and only a very small\n+    // audience, so is unnecessary stress to translators.\n     std::string strUsage = HelpMessageGroup(_(\"Options:\"));\n     strUsage += HelpMessageOpt(\"-?\", _(\"Print this help message and exit\"));\n     strUsage += HelpMessageOpt(\"-version\", _(\"Print version and exit\"));\n-    strUsage += HelpMessageOpt(\"-alertnotify=<cmd>\", _(\"Execute command when a relevant alert is received or we see a really long fork (%s in cmd is replaced by message)\"));\n-    strUsage +=HelpMessageOpt(\"-assumevalid=<hex>\", strprintf(_(\"If this block is in the chain assume that it and its ancestors are valid and potentially skip their script verification (0 to verify all, default: %s, testnet: %s)\"), defaultChainParams->GetConsensus().defaultAssumeValid.GetHex(), testnetChainParams->GetConsensus().defaultAssumeValid.GetHex()));\n-    strUsage += HelpMessageOpt(\"-blocknotify=<cmd>\", _(\"Execute command when the best block changes (%s in cmd is replaced by block hash)\"));\n-    strUsage += HelpMessageOpt(\"-blockreconstructionextratxn=<n>\", strprintf(_(\"Extra transactions to keep in memory for compact block reconstructions (default: %u)\"), DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN));\n+    strUsage += HelpMessageOpt(\"-alertnotify=<cmd>\", _(\n+        \"Execute command when a relevant alert is received or we see a really long fork \"\n+        \"(%s in cmd is replaced by message)\"));\n+    strUsage += HelpMessageOpt(\"-assumevalid=<hex>\", strprintf(_(\n+        \"If this block is in the chain assume that it and its ancestors are valid and \"\n+        \"potentially skip their script verification (0 to verify all, default: %s, testnet: %s)\"),\n+            defaultChainParams->GetConsensus().defaultAssumeValid.GetHex(),\n+            testnetChainParams->GetConsensus().defaultAssumeValid.GetHex()));\n+    strUsage += HelpMessageOpt(\"-blocknotify=<cmd>\", _(\n+        \"Execute command when the best block changes (%s in cmd is replaced by block hash)\"));\n+    strUsage += HelpMessageOpt(\"-blockreconstructionextratxn=<n>\", strprintf(_(\n+        \"Extra transactions to keep in memory for compact block reconstructions (default: %u)\"),\n+            DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN));\n     if (showDebug)\n-        strUsage += HelpMessageOpt(\"-blocksonly\", strprintf(_(\"Whether to operate in a blocks only mode (default: %u)\"), DEFAULT_BLOCKSONLY));\n-    strUsage += HelpMessageOpt(\"-conf=<file>\", strprintf(_(\"Specify configuration file. Relative paths will be prefixed by datadir location. (default: %s)\"), BITCOIN_CONF_FILENAME));\n+        strUsage += HelpMessageOpt(\"-blocksonly\", strprintf(_(\n+            \"Whether to operate in a blocks only mode (default: %u)\"), DEFAULT_BLOCKSONLY));\n+    strUsage += HelpMessageOpt(\"-conf=<file>\", strprintf(_(\n+        \"Specify configuration file. Relative paths will be prefixed by datadir location. \"\n+        \"(default: %s)\"), BITCOIN_CONF_FILENAME));\n     if (mode == HMM_BITCOIND)\n     {\n #if HAVE_DECL_DAEMON\n-        strUsage += HelpMessageOpt(\"-daemon\", _(\"Run in the background as a daemon and accept commands\"));\n+        strUsage += HelpMessageOpt(\"-daemon\", _(\n+            \"Run in the background as a daemon and accept commands\"));\n #endif\n     }\n     strUsage += HelpMessageOpt(\"-datadir=<dir>\", _(\"Specify data directory\"));\n     if (showDebug) {\n-        strUsage += HelpMessageOpt(\"-dbbatchsize\", strprintf(\"Maximum database write batch size in bytes (default: %u)\", nDefaultDbBatchSize));\n-    }\n-    strUsage += HelpMessageOpt(\"-dbcache=<n>\", strprintf(_(\"Set database cache size in megabytes (%d to %d, default: %d)\"), nMinDbCache, nMaxDbCache, nDefaultDbCache));\n-    strUsage += HelpMessageOpt(\"-debuglogfile=<file>\", strprintf(_(\"Specify location of debug log file. Relative paths will be prefixed by a net-specific datadir location. (default: %s)\"), DEFAULT_DEBUGLOGFILE));\n+        strUsage += HelpMessageOpt(\"-dbbatchsize\", strprintf(\n+            \"Maximum database write batch size in bytes (default: %u)\", nDefaultDbBatchSize));\n+    }\n+    strUsage += HelpMessageOpt(\"-dbcache=<n>\", strprintf(_(\n+        \"Set database cache size in megabytes (%d to %d, default: %d)\"),\n+            nMinDbCache, nMaxDbCache, nDefaultDbCache));\n+    strUsage += HelpMessageOpt(\"-debuglogfile=<file>\", strprintf(_(\n+        \"Specify location of debug log file. Relative paths will be prefixed by a \"\n+        \"net-specific datadir location. (default: %s)\"), DEFAULT_DEBUGLOGFILE));\n     if (showDebug)\n-        strUsage += HelpMessageOpt(\"-feefilter\", strprintf(\"Tell other nodes to filter invs to us by our mempool min fee (default: %u)\", DEFAULT_FEEFILTER));\n-    strUsage += HelpMessageOpt(\"-loadblock=<file>\", _(\"Imports blocks from external blk000??.dat file on startup\"));\n-    strUsage += HelpMessageOpt(\"-maxmempool=<n>\", strprintf(_(\"Keep the transaction memory pool below <n> megabytes (default: %u)\"), DEFAULT_MAX_MEMPOOL_SIZE));\n-    strUsage += HelpMessageOpt(\"-maxorphantx=<n>\", strprintf(_(\"Keep at most <n> unconnectable transactions in memory (default: %u)\"), DEFAULT_MAX_ORPHAN_TRANSACTIONS));\n-    strUsage += HelpMessageOpt(\"-mempoolexpiry=<n>\", strprintf(_(\"Do not keep transactions in the mempool longer than <n> hours (default: %u)\"), DEFAULT_MEMPOOL_EXPIRY));\n+        strUsage += HelpMessageOpt(\"-feefilter\", strprintf(\n+            \"Tell other nodes to filter invs to us by our mempool min fee (default: %u)\",\n+                DEFAULT_FEEFILTER));\n+    strUsage += HelpMessageOpt(\"-loadblock=<file>\", _(\n+        \"Imports blocks from external blk000??.dat file on startup\"));\n+    strUsage += HelpMessageOpt(\"-maxmempool=<n>\", strprintf(_(\n+        \"Keep the transaction memory pool below <n> megabytes (default: %u)\"),\n+            DEFAULT_MAX_MEMPOOL_SIZE));\n+    strUsage += HelpMessageOpt(\"-maxorphantx=<n>\", strprintf(_(\n+        \"Keep at most <n> unconnectable transactions in memory (default: %u)\"),\n+            DEFAULT_MAX_ORPHAN_TRANSACTIONS));\n+    strUsage += HelpMessageOpt(\"-mempoolexpiry=<n>\", strprintf(_(\n+        \"Do not keep transactions in the mempool longer than <n> hours (default: %u)\"),\n+            DEFAULT_MEMPOOL_EXPIRY));\n     if (showDebug) {\n-        strUsage += HelpMessageOpt(\"-minimumchainwork=<hex>\", strprintf(\"Minimum work assumed to exist on a valid chain in hex (default: %s, testnet: %s)\", defaultChainParams->GetConsensus().nMinimumChainWork.GetHex(), testnetChainParams->GetConsensus().nMinimumChainWork.GetHex()));\n-    }\n-    strUsage += HelpMessageOpt(\"-par=<n>\", strprintf(_(\"Set the number of script verification threads (%u to %d, 0 = auto, <0 = leave that many cores free, default: %d)\"),\n-        -GetNumCores(), MAX_SCRIPTCHECK_THREADS, DEFAULT_SCRIPTCHECK_THREADS));\n-    strUsage += HelpMessageOpt(\"-persistmempool\", strprintf(_(\"Whether to save the mempool on shutdown and load on restart (default: %u)\"), DEFAULT_PERSIST_MEMPOOL));\n+        strUsage += HelpMessageOpt(\"-minimumchainwork=<hex>\", strprintf(\n+            \"Minimum work assumed to exist on a valid chain in hex (default: %s, testnet: %s)\",\n+                defaultChainParams->GetConsensus().nMinimumChainWork.GetHex(),\n+                testnetChainParams->GetConsensus().nMinimumChainWork.GetHex()));\n+    }\n+    strUsage += HelpMessageOpt(\"-par=<n>\", strprintf(_(\n+        \"Set the number of script verification threads (%u to %d, 0 = auto, <0 = leave that \"\n+        \"many cores free, default: %d)\"),\n+            -GetNumCores(), MAX_SCRIPTCHECK_THREADS, DEFAULT_SCRIPTCHECK_THREADS));\n+    strUsage += HelpMessageOpt(\"-persistmempool\", strprintf(_(\n+        \"Whether to save the mempool on shutdown and load on restart (default: %u)\"),\n+            DEFAULT_PERSIST_MEMPOOL));\n #ifndef WIN32\n-    strUsage += HelpMessageOpt(\"-pid=<file>\", strprintf(_(\"Specify pid file. Relative paths will be prefixed by a net-specific datadir location. (default: %s)\"), BITCOIN_PID_FILENAME));\n+    strUsage += HelpMessageOpt(\"-pid=<file>\", strprintf(_(\n+        \"Specify pid file. Relative paths will be prefixed by a net-specific datadir location. \"\n+        \"(default: %s)\"), BITCOIN_PID_FILENAME));\n #endif\n-    strUsage += HelpMessageOpt(\"-prune=<n>\", strprintf(_(\"Reduce storage requirements by enabling pruning (deleting) of old blocks. This allows the pruneblockchain RPC to be called to delete specific blocks, and enables automatic pruning of old blocks if a target size in MiB is provided. This mode is incompatible with -txindex and -rescan. \"\n-            \"Warning: Reverting this setting requires re-downloading the entire blockchain. \"\n-            \"(default: 0 = disable pruning blocks, 1 = allow manual pruning via RPC, >%u = automatically prune block files to stay under the specified target size in MiB)\"), MIN_DISK_SPACE_FOR_BLOCK_FILES / 1024 / 1024));\n-    strUsage += HelpMessageOpt(\"-reindex\", _(\"Rebuild chain state and block index from the blk*.dat files on disk\"));\n-    strUsage += HelpMessageOpt(\"-reindex-chainstate\", _(\"Rebuild chain state from the currently indexed blocks\"));\n+    strUsage += HelpMessageOpt(\"-prune=<n>\", strprintf(_(\n+        \"Reduce storage requirements by enabling pruning (deleting) of old blocks. This allows \"\n+        \"the pruneblockchain RPC to be called to delete specific blocks, and enables automatic \"\n+        \"pruning of old blocks if a target size in MiB is provided. This mode is incompatible \"\n+        \"with -txindex and -rescan. Warning: Reverting this setting requires re-downloading the \"\n+        \"entire blockchain. (default: 0 = disable pruning blocks, 1 = allow manual pruning via \"\n+        \"RPC, >%u = automatically prune block files to stay under the specified target size in \"\n+        \"MiB)\"), MIN_DISK_SPACE_FOR_BLOCK_FILES / 1024 / 1024));\n+    strUsage += HelpMessageOpt(\"-reindex\", _(\n+        \"Rebuild chain state and block index from the blk*.dat files on disk\"));\n+    strUsage += HelpMessageOpt(\"-reindex-chainstate\", _(\n+        \"Rebuild chain state from the currently indexed blocks\"));\n #ifndef WIN32\n-    strUsage += HelpMessageOpt(\"-sysperms\", _(\"Create new files with system default permissions, instead of umask 077 (only effective with disabled wallet functionality)\"));\n+    strUsage += HelpMessageOpt(\"-sysperms\", _(\n+        \"Create new files with system default permissions, instead of umask 077 (only effective \"\n+        \"with disabled wallet functionality)\"));\n #endif\n-    strUsage += HelpMessageOpt(\"-txindex\", strprintf(_(\"Maintain a full transaction index, used by the getrawtransaction rpc call (default: %u)\"), DEFAULT_TXINDEX));\n+    strUsage += HelpMessageOpt(\"-txindex\", strprintf(_(\n+        \"Maintain a full transaction index, used by the getrawtransaction rpc call (default: %u)\"),\n+            DEFAULT_TXINDEX));\n \n     strUsage += HelpMessageGroup(_(\"Connection options:\"));\n-    strUsage += HelpMessageOpt(\"-addnode=<ip>\", _(\"Add a node to connect to and attempt to keep the connection open (see the `addnode` RPC command help for more info)\"));\n-    strUsage += HelpMessageOpt(\"-banscore=<n>\", strprintf(_(\"Threshold for disconnecting misbehaving peers (default: %u)\"), DEFAULT_BANSCORE_THRESHOLD));\n-    strUsage += HelpMessageOpt(\"-bantime=<n>\", strprintf(_(\"Number of seconds to keep misbehaving peers from reconnecting (default: %u)\"), DEFAULT_MISBEHAVING_BANTIME));\n-    strUsage += HelpMessageOpt(\"-bind=<addr>\", _(\"Bind to given address and always listen on it. Use [host]:port notation for IPv6\"));\n-    strUsage += HelpMessageOpt(\"-connect=<ip>\", _(\"Connect only to the specified node(s); -connect=0 disables automatic connections (the rules for this peer are the same as for -addnode)\"));\n-    strUsage += HelpMessageOpt(\"-discover\", _(\"Discover own IP addresses (default: 1 when listening and no -externalip or -proxy)\"));\n-    strUsage += HelpMessageOpt(\"-dns\", _(\"Allow DNS lookups for -addnode, -seednode and -connect\") + \" \" + strprintf(_(\"(default: %u)\"), DEFAULT_NAME_LOOKUP));\n-    strUsage += HelpMessageOpt(\"-dnsseed\", _(\"Query for peer addresses via DNS lookup, if low on addresses (default: 1 unless -connect used)\"));\n+    strUsage += HelpMessageOpt(\"-addnode=<ip>\", _(\n+        \"Add a node to connect to and attempt to keep the connection open (see the `addnode` RPC \"\n+        \"command help for more info)\"));\n+    strUsage += HelpMessageOpt(\"-banscore=<n>\", strprintf(_(\n+        \"Threshold for disconnecting misbehaving peers (default: %u)\"), DEFAULT_BANSCORE_THRESHOLD));\n+    strUsage += HelpMessageOpt(\"-bantime=<n>\", strprintf(_(\n+        \"Number of seconds to keep misbehaving peers from reconnecting (default: %u)\"),\n+            DEFAULT_MISBEHAVING_BANTIME));\n+    strUsage += HelpMessageOpt(\"-bind=<addr>\", _(\n+        \"Bind to given address and always listen on it. Use [host]:port notation for IPv6\"));\n+    strUsage += HelpMessageOpt(\"-connect=<ip>\", _(\n+        \"Connect only to the specified node(s); -connect=0 disables automatic connections (the \"\n+        \"rules for this peer are the same as for -addnode)\"));\n+    strUsage += HelpMessageOpt(\"-discover\", _(\n+        \"Discover own IP addresses (default: 1 when listening and no -externalip or -proxy)\"));\n+    strUsage += HelpMessageOpt(\"-dns\", _(\n+        \"Allow DNS lookups for -addnode, -seednode and -connect \") + \n+            strprintf(_(\"(default: %u)\"), DEFAULT_NAME_LOOKUP));\n+    strUsage += HelpMessageOpt(\"-dnsseed\", _(\n+        \"Query for peer addresses via DNS lookup, if low on addresses (default: 1 unless -connect used)\"));\n     strUsage += HelpMessageOpt(\"-externalip=<ip>\", _(\"Specify your own public address\"));\n-    strUsage += HelpMessageOpt(\"-forcednsseed\", strprintf(_(\"Always query for peer addresses via DNS lookup (default: %u)\"), DEFAULT_FORCEDNSSEED));\n-    strUsage += HelpMessageOpt(\"-listen\", _(\"Accept connections from outside (default: 1 if no -proxy or -connect)\"));\n-    strUsage += HelpMessageOpt(\"-listenonion\", strprintf(_(\"Automatically create Tor hidden service (default: %d)\"), DEFAULT_LISTEN_ONION));\n-    strUsage += HelpMessageOpt(\"-maxconnections=<n>\", strprintf(_(\"Maintain at most <n> connections to peers (default: %u)\"), DEFAULT_MAX_PEER_CONNECTIONS));\n-    strUsage += HelpMessageOpt(\"-maxreceivebuffer=<n>\", strprintf(_(\"Maximum per-connection receive buffer, <n>*1000 bytes (default: %u)\"), DEFAULT_MAXRECEIVEBUFFER));\n-    strUsage += HelpMessageOpt(\"-maxsendbuffer=<n>\", strprintf(_(\"Maximum per-connection send buffer, <n>*1000 bytes (default: %u)\"), DEFAULT_MAXSENDBUFFER));\n-    strUsage += HelpMessageOpt(\"-maxtimeadjustment\", strprintf(_(\"Maximum allowed median peer time offset adjustment. Local perspective of time may be influenced by peers forward or backward by this amount. (default: %u seconds)\"), DEFAULT_MAX_TIME_ADJUSTMENT));\n-    strUsage += HelpMessageOpt(\"-maxuploadtarget=<n>\", strprintf(_(\"Tries to keep outbound traffic under the given target (in MiB per 24h), 0 = no limit (default: %d)\"), DEFAULT_MAX_UPLOAD_TARGET));\n-    strUsage += HelpMessageOpt(\"-onion=<ip:port>\", strprintf(_(\"Use separate SOCKS5 proxy to reach peers via Tor hidden services (default: %s)\"), \"-proxy\"));\n-    strUsage += HelpMessageOpt(\"-onlynet=<net>\", _(\"Only connect to nodes in network <net> (ipv4, ipv6 or onion)\"));\n-    strUsage += HelpMessageOpt(\"-peerbloomfilters\", strprintf(_(\"Support filtering of blocks and transaction with bloom filters (default: %u)\"), DEFAULT_PEERBLOOMFILTERS));\n-    strUsage += HelpMessageOpt(\"-permitbaremultisig\", strprintf(_(\"Relay non-P2SH multisig (default: %u)\"), DEFAULT_PERMIT_BAREMULTISIG));\n-    strUsage += HelpMessageOpt(\"-port=<port>\", strprintf(_(\"Listen for connections on <port> (default: %u or testnet: %u)\"), defaultChainParams->GetDefaultPort(), testnetChainParams->GetDefaultPort()));\n+    strUsage += HelpMessageOpt(\"-forcednsseed\", strprintf(_(\n+        \"Always query for peer addresses via DNS lookup (default: %u)\"), DEFAULT_FORCEDNSSEED));\n+    strUsage += HelpMessageOpt(\"-listen\", _(\n+        \"Accept connections from outside (default: 1 if no -proxy or -connect)\"));\n+    strUsage += HelpMessageOpt(\"-listenonion\", strprintf(_(\n+        \"Automatically create Tor hidden service (default: %d)\"), DEFAULT_LISTEN_ONION));\n+    strUsage += HelpMessageOpt(\"-maxconnections=<n>\", strprintf(_(\n+        \"Maintain at most <n> connections to peers (default: %u)\"),\n+            DEFAULT_MAX_PEER_CONNECTIONS));\n+    strUsage += HelpMessageOpt(\"-maxreceivebuffer=<n>\", strprintf(_(\n+        \"Maximum per-connection receive buffer, <n>*1000 bytes (default: %u)\"),\n+            DEFAULT_MAXRECEIVEBUFFER));\n+    strUsage += HelpMessageOpt(\"-maxsendbuffer=<n>\", strprintf(_(\n+        \"Maximum per-connection send buffer, <n>*1000 bytes (default: %u)\"),\n+            DEFAULT_MAXSENDBUFFER));\n+    strUsage += HelpMessageOpt(\"-maxtimeadjustment\", strprintf(_(\n+        \"Maximum allowed median peer time offset adjustment. Local perspective of time may be \"\n+        \"influenced by peers forward or backward by this amount. (default: %u seconds)\"),\n+            DEFAULT_MAX_TIME_ADJUSTMENT));\n+    strUsage += HelpMessageOpt(\"-maxuploadtarget=<n>\", strprintf(_(\n+        \"Tries to keep outbound traffic under the given target (in MiB per 24h), \"\n+        \"0 = no limit (default: %d)\"), DEFAULT_MAX_UPLOAD_TARGET));\n+    strUsage += HelpMessageOpt(\"-onion=<ip:port>\", strprintf(_(\n+        \"Use separate SOCKS5 proxy to reach peers via Tor hidden services (default: %s)\"), \"-proxy\"));\n+    strUsage += HelpMessageOpt(\"-onlynet=<net>\", _(\n+        \"Only connect to nodes in network <net> (ipv4, ipv6 or onion)\"));\n+    strUsage += HelpMessageOpt(\"-peerbloomfilters\", strprintf(_(\n+        \"Support filtering of blocks and transaction with bloom filters (default: %u)\"),\n+            DEFAULT_PEERBLOOMFILTERS));\n+    strUsage += HelpMessageOpt(\"-permitbaremultisig\", strprintf(_(\n+        \"Relay non-P2SH multisig (default: %u)\"), DEFAULT_PERMIT_BAREMULTISIG));\n+    strUsage += HelpMessageOpt(\"-port=<port>\", strprintf(_(\n+        \"Listen for connections on <port> (default: %u or testnet: %u)\"),\n+            defaultChainParams->GetDefaultPort(), testnetChainParams->GetDefaultPort()));\n     strUsage += HelpMessageOpt(\"-proxy=<ip:port>\", _(\"Connect through SOCKS5 proxy\"));\n-    strUsage += HelpMessageOpt(\"-proxyrandomize\", strprintf(_(\"Randomize credentials for every proxy connection. This enables Tor stream isolation (default: %u)\"), DEFAULT_PROXYRANDOMIZE));\n-    strUsage += HelpMessageOpt(\"-seednode=<ip>\", _(\"Connect to a node to retrieve peer addresses, and disconnect\"));\n-    strUsage += HelpMessageOpt(\"-timeout=<n>\", strprintf(_(\"Specify connection timeout in milliseconds (minimum: 1, default: %d)\"), DEFAULT_CONNECT_TIMEOUT));\n-    strUsage += HelpMessageOpt(\"-torcontrol=<ip>:<port>\", strprintf(_(\"Tor control port to use if onion listening enabled (default: %s)\"), DEFAULT_TOR_CONTROL));\n-    strUsage += HelpMessageOpt(\"-torpassword=<pass>\", _(\"Tor control port password (default: empty)\"));\n+    strUsage += HelpMessageOpt(\"-proxyrandomize\", strprintf(_(\n+        \"Randomize credentials for every proxy connection. This enables Tor stream isolation \"\n+        \"(default: %u)\"), DEFAULT_PROXYRANDOMIZE));\n+    strUsage += HelpMessageOpt(\"-seednode=<ip>\", _(\n+        \"Connect to a node to retrieve peer addresses, and disconnect\"));\n+    strUsage += HelpMessageOpt(\"-timeout=<n>\", strprintf(_(\n+        \"Specify connection timeout in milliseconds (minimum: 1, default: %d)\"),\n+            DEFAULT_CONNECT_TIMEOUT));\n+    strUsage += HelpMessageOpt(\"-torcontrol=<ip>:<port>\", strprintf(_(\n+        \"Tor control port to use if onion listening enabled (default: %s)\"), DEFAULT_TOR_CONTROL));\n+    strUsage += HelpMessageOpt(\"-torpassword=<pass>\", _(\n+        \"Tor control port password (default: empty)\"));\n #ifdef USE_UPNP\n #if USE_UPNP\n-    strUsage += HelpMessageOpt(\"-upnp\", _(\"Use UPnP to map the listening port (default: 1 when listening and no -proxy)\"));\n+    strUsage += HelpMessageOpt(\"-upnp\", _(\n+        \"Use UPnP to map the listening port (default: 1 when listening and no -proxy)\"));\n #else\n-    strUsage += HelpMessageOpt(\"-upnp\", strprintf(_(\"Use UPnP to map the listening port (default: %u)\"), 0));\n+    strUsage += HelpMessageOpt(\"-upnp\", strprintf(_(\n+        \"Use UPnP to map the listening port (default: %u)\"), 0));\n #endif\n #endif\n-    strUsage += HelpMessageOpt(\"-whitebind=<addr>\", _(\"Bind to given address and whitelist peers connecting to it. Use [host]:port notation for IPv6\"));\n-    strUsage += HelpMessageOpt(\"-whitelist=<IP address or network>\", _(\"Whitelist peers connecting from the given IP address (e.g. 1.2.3.4) or CIDR notated network (e.g. 1.2.3.0/24). Can be specified multiple times.\") +\n-        \" \" + _(\"Whitelisted peers cannot be DoS banned and their transactions are always relayed, even if they are already in the mempool, useful e.g. for a gateway\"));\n+    strUsage += HelpMessageOpt(\"-whitebind=<addr>\", _(\n+        \"Bind to given address and whitelist peers connecting to it. Use [host]:port notation for IPv6\"));\n+    strUsage += HelpMessageOpt(\"-whitelist=<IP address or network>\", _(\n+        \"Whitelist peers connecting from the given IP address (e.g. 1.2.3.4) or CIDR notated \"\n+        \"network (e.g. 1.2.3.0/24). Can be specified multiple times. Whitelisted peers cannot be \"\n+        \"DoS banned and their transactions are always relayed, even if they are already in the \"\n+        \"mempool, useful e.g. for a gateway\"));\n \n #ifdef ENABLE_WALLET\n     strUsage += GetWalletHelpString(showDebug);\n@@ -430,89 +524,182 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageGroup(_(\"Debugging/Testing options:\"));\n     if (showDebug)\n     {\n-        strUsage += HelpMessageOpt(\"-checkblocks=<n>\", strprintf(_(\"How many blocks to check at startup (default: %u, 0 = all)\"), DEFAULT_CHECKBLOCKS));\n-        strUsage += HelpMessageOpt(\"-checklevel=<n>\", strprintf(_(\"How thorough the block verification of -checkblocks is (0-4, default: %u)\"), DEFAULT_CHECKLEVEL));\n-        strUsage += HelpMessageOpt(\"-checkblockindex\", strprintf(\"Do a full consistency check for mapBlockIndex, setBlockIndexCandidates, chainActive and mapBlocksUnlinked occasionally. Also sets -checkmempool (default: %u)\", defaultChainParams->DefaultConsistencyChecks()));\n-        strUsage += HelpMessageOpt(\"-checkmempool=<n>\", strprintf(\"Run checks every <n> transactions (default: %u)\", defaultChainParams->DefaultConsistencyChecks()));\n-        strUsage += HelpMessageOpt(\"-checkpoints\", strprintf(\"Disable expensive verification for known chain history (default: %u)\", DEFAULT_CHECKPOINTS_ENABLED));\n-        strUsage += HelpMessageOpt(\"-disablesafemode\", strprintf(\"Disable safemode, override a real safe mode event (default: %u)\", DEFAULT_DISABLE_SAFEMODE));\n-        strUsage += HelpMessageOpt(\"-deprecatedrpc=<method>\", \"Allows deprecated RPC method(s) to be used\");\n-        strUsage += HelpMessageOpt(\"-testsafemode\", strprintf(\"Force safe mode (default: %u)\", DEFAULT_TESTSAFEMODE));\n-        strUsage += HelpMessageOpt(\"-dropmessagestest=<n>\", \"Randomly drop 1 of every <n> network messages\");\n-        strUsage += HelpMessageOpt(\"-fuzzmessagestest=<n>\", \"Randomly fuzz 1 of every <n> network messages\");\n-        strUsage += HelpMessageOpt(\"-stopafterblockimport\", strprintf(\"Stop running after importing blocks from disk (default: %u)\", DEFAULT_STOPAFTERBLOCKIMPORT));\n-        strUsage += HelpMessageOpt(\"-stopatheight\", strprintf(\"Stop running after reaching the given height in the main chain (default: %u)\", DEFAULT_STOPATHEIGHT));\n-\n-        strUsage += HelpMessageOpt(\"-limitancestorcount=<n>\", strprintf(\"Do not accept transactions if number of in-mempool ancestors is <n> or more (default: %u)\", DEFAULT_ANCESTOR_LIMIT));\n-        strUsage += HelpMessageOpt(\"-limitancestorsize=<n>\", strprintf(\"Do not accept transactions whose size with all in-mempool ancestors exceeds <n> kilobytes (default: %u)\", DEFAULT_ANCESTOR_SIZE_LIMIT));\n-        strUsage += HelpMessageOpt(\"-limitdescendantcount=<n>\", strprintf(\"Do not accept transactions if any ancestor would have <n> or more in-mempool descendants (default: %u)\", DEFAULT_DESCENDANT_LIMIT));\n-        strUsage += HelpMessageOpt(\"-limitdescendantsize=<n>\", strprintf(\"Do not accept transactions if any ancestor would have more than <n> kilobytes of in-mempool descendants (default: %u).\", DEFAULT_DESCENDANT_SIZE_LIMIT));\n-        strUsage += HelpMessageOpt(\"-vbparams=deployment:start:end\", \"Use given start/end times for specified version bits deployment (regtest-only)\");\n+        strUsage += HelpMessageOpt(\"-checkblocks=<n>\", strprintf(_(\n+            \"How many blocks to check at startup (default: %u, 0 = all)\"), DEFAULT_CHECKBLOCKS));\n+        strUsage += HelpMessageOpt(\"-checklevel=<n>\", strprintf(_(\n+            \"How thorough the block verification of -checkblocks is (0-4, default: %u)\"),\n+                DEFAULT_CHECKLEVEL));\n+        strUsage += HelpMessageOpt(\"-checkblockindex\", strprintf(\n+            \"Do a full consistency check for mapBlockIndex, setBlockIndexCandidates, chainActive \"\n+            \"and mapBlocksUnlinked occasionally. Also sets -checkmempool (default: %u)\",\n+                defaultChainParams->DefaultConsistencyChecks()));\n+        strUsage += HelpMessageOpt(\"-checkmempool=<n>\", strprintf(\n+            \"Run checks every <n> transactions (default: %u)\",\n+                defaultChainParams->DefaultConsistencyChecks()));\n+        strUsage += HelpMessageOpt(\"-checkpoints\", strprintf(\n+            \"Disable expensive verification for known chain history (default: %u)\",\n+                DEFAULT_CHECKPOINTS_ENABLED));\n+        strUsage += HelpMessageOpt(\"-disablesafemode\", strprintf(\n+            \"Disable safemode, override a real safe mode event (default: %u)\",\n+                DEFAULT_DISABLE_SAFEMODE));\n+        strUsage += HelpMessageOpt(\"-deprecatedrpc=<method>\",\n+            \"Allows deprecated RPC method(s) to be used\");\n+        strUsage += HelpMessageOpt(\"-testsafemode\", strprintf(\n+            \"Force safe mode (default: %u)\", DEFAULT_TESTSAFEMODE));\n+        strUsage += HelpMessageOpt(\"-dropmessagestest=<n>\",\n+            \"Randomly drop 1 of every <n> network messages\");\n+        strUsage += HelpMessageOpt(\"-fuzzmessagestest=<n>\",\n+            \"Randomly fuzz 1 of every <n> network messages\");\n+        strUsage += HelpMessageOpt(\"-stopafterblockimport\",\n+            strprintf(\"Stop running after importing blocks from disk (default: %u)\",\n+                DEFAULT_STOPAFTERBLOCKIMPORT));\n+        strUsage += HelpMessageOpt(\"-stopatheight\", strprintf(\n+            \"Stop running after reaching the given height in the main chain (default: %u)\",\n+                DEFAULT_STOPATHEIGHT));\n+\n+        strUsage += HelpMessageOpt(\"-limitancestorcount=<n>\", strprintf(\n+            \"Do not accept transactions if number of in-mempool ancestors is <n> or more (default: %u)\",\n+                DEFAULT_ANCESTOR_LIMIT));\n+        strUsage += HelpMessageOpt(\"-limitancestorsize=<n>\", strprintf(\n+            \"Do not accept transactions whose size with all in-mempool ancestors exceeds <n> \"\n+            \"kilobytes (default: %u)\", DEFAULT_ANCESTOR_SIZE_LIMIT));\n+        strUsage += HelpMessageOpt(\"-limitdescendantcount=<n>\", strprintf(\n+            \"Do not accept transactions if any ancestor would have <n> or more in-mempool \"\n+            \"descendants (default: %u)\", DEFAULT_DESCENDANT_LIMIT));\n+        strUsage += HelpMessageOpt(\"-limitdescendantsize=<n>\", strprintf(\n+            \"Do not accept transactions if any ancestor would have more than <n> kilobytes of \"\n+            \"in-mempool descendants (default: %u).\", DEFAULT_DESCENDANT_SIZE_LIMIT));\n+        strUsage += HelpMessageOpt(\"-vbparams=deployment:start:end\",\n+            \"Use given start/end times for specified version bits deployment (regtest-only)\");\n         strUsage += HelpMessageOpt(\"-addrmantest\", \"Allows to test address relay on localhost\");\n     }\n-    strUsage += HelpMessageOpt(\"-debug=<category>\", strprintf(_(\"Output debugging information (default: %u, supplying <category> is optional)\"), 0) + \". \" +\n-        _(\"If <category> is not supplied or if <category> = 1, output all debugging information.\") + \" \" + _(\"<category> can be:\") + \" \" + ListLogCategories() + \".\");\n-    strUsage += HelpMessageOpt(\"-debugexclude=<category>\", strprintf(_(\"Exclude debugging information for a category. Can be used in conjunction with -debug=1 to output debug logs for all categories except one or more specified categories.\")));\n+    strUsage += HelpMessageOpt(\"-debug=<category>\", strprintf(_(\n+        \"Output debugging information (default: %u, supplying <category> is optional). \"), 0) +\n+        _(\"If <category> is not supplied or if <category> = 1, output all debugging information. \") +\n+        _(\"<category> can be: \") + ListLogCategories() + \".\");\n+    strUsage += HelpMessageOpt(\"-debugexclude=<category>\", strprintf(_(\n+        \"Exclude debugging information for a category. Can be used in conjunction with -debug=1 \"\n+        \"to output debug logs for all categories except one or more specified categories.\")));\n     strUsage += HelpMessageOpt(\"-help-debug\", _(\"Show all debugging options (usage: --help -help-debug)\"));\n-    strUsage += HelpMessageOpt(\"-logips\", strprintf(_(\"Include IP addresses in debug output (default: %u)\"), DEFAULT_LOGIPS));\n-    strUsage += HelpMessageOpt(\"-logtimestamps\", strprintf(_(\"Prepend debug output with timestamp (default: %u)\"), DEFAULT_LOGTIMESTAMPS));\n+    strUsage += HelpMessageOpt(\"-logips\", strprintf(_(\n+        \"Include IP addresses in debug output (default: %u)\"), DEFAULT_LOGIPS));\n+    strUsage += HelpMessageOpt(\"-logtimestamps\", strprintf(_(\n+        \"Prepend debug output with timestamp (default: %u)\"), DEFAULT_LOGTIMESTAMPS));\n     if (showDebug)\n     {\n-        strUsage += HelpMessageOpt(\"-logtimemicros\", strprintf(\"Add microsecond precision to debug timestamps (default: %u)\", DEFAULT_LOGTIMEMICROS));\n-        strUsage += HelpMessageOpt(\"-mocktime=<n>\", \"Replace actual time with <n> seconds since epoch (default: 0)\");\n-        strUsage += HelpMessageOpt(\"-maxsigcachesize=<n>\", strprintf(\"Limit sum of signature cache and script execution cache sizes to <n> MiB (default: %u)\", DEFAULT_MAX_SIG_CACHE_SIZE));\n-        strUsage += HelpMessageOpt(\"-maxtipage=<n>\", strprintf(\"Maximum tip age in seconds to consider node in initial block download (default: %u)\", DEFAULT_MAX_TIP_AGE));\n-    }\n-    strUsage += HelpMessageOpt(\"-maxtxfee=<amt>\", strprintf(_(\"Maximum total fees (in %s) to use in a single wallet transaction or raw transaction; setting this too low may abort large transactions (default: %s)\"),\n-        CURRENCY_UNIT, FormatMoney(DEFAULT_TRANSACTION_MAXFEE)));\n+        strUsage += HelpMessageOpt(\"-logtimemicros\", strprintf(\n+            \"Add microsecond precision to debug timestamps (default: %u)\", DEFAULT_LOGTIMEMICROS));\n+        strUsage += HelpMessageOpt(\"-mocktime=<n>\",\n+            \"Replace actual time with <n> seconds since epoch (default: 0)\");\n+        strUsage += HelpMessageOpt(\"-maxsigcachesize=<n>\", strprintf(\n+            \"Limit sum of signature cache and script execution cache sizes to <n> MiB (default: %u)\",\n+                DEFAULT_MAX_SIG_CACHE_SIZE));\n+        strUsage += HelpMessageOpt(\"-maxtipage=<n>\", strprintf(\n+            \"Maximum tip age in seconds to consider node in initial block download (default: %u)\",\n+                DEFAULT_MAX_TIP_AGE));\n+    }\n+    strUsage += HelpMessageOpt(\"-maxtxfee=<amt>\", strprintf(_(\n+        \"Maximum total fees (in %s) to use in a single wallet transaction or raw transaction; \"\n+        \"setting this too low may abort large transactions (default: %s)\"),\n+            CURRENCY_UNIT, FormatMoney(DEFAULT_TRANSACTION_MAXFEE)));\n     if (showDebug)\n     {\n-        strUsage += HelpMessageOpt(\"-printpriority\", strprintf(\"Log transaction fee per kB when mining blocks (default: %u)\", DEFAULT_PRINTPRIORITY));\n+        strUsage += HelpMessageOpt(\"-printpriority\", strprintf(\n+            \"Log transaction fee per kB when mining blocks (default: %u)\", DEFAULT_PRINTPRIORITY));\n     }\n-    strUsage += HelpMessageOpt(\"-printtoconsole\", _(\"Send trace/debug info to console instead of debug.log file\"));\n-    strUsage += HelpMessageOpt(\"-shrinkdebugfile\", _(\"Shrink debug.log file on client startup (default: 1 when no -debug)\"));\n+    strUsage += HelpMessageOpt(\"-printtoconsole\", _(\n+        \"Send trace/debug info to console instead of debug.log file\"));\n+    strUsage += HelpMessageOpt(\"-shrinkdebugfile\", _(\n+        \"Shrink debug.log file on client startup (default: 1 when no -debug)\"));\n     strUsage += HelpMessageOpt(\"-uacomment=<cmt>\", _(\"Append comment to the user agent string\"));\n \n     AppendParamsHelpMessages(strUsage, showDebug);\n \n     strUsage += HelpMessageGroup(_(\"Node relay options:\"));\n     if (showDebug) {\n-        strUsage += HelpMessageOpt(\"-acceptnonstdtxn\", strprintf(\"Relay and mine \\\"non-standard\\\" transactions (%sdefault: %u)\", \"testnet/regtest only; \", !testnetChainParams->RequireStandard()));\n-        strUsage += HelpMessageOpt(\"-incrementalrelayfee=<amt>\", strprintf(\"Fee rate (in %s/kB) used to define cost of relay, used for mempool limiting and BIP 125 replacement. (default: %s)\", CURRENCY_UNIT, FormatMoney(DEFAULT_INCREMENTAL_RELAY_FEE)));\n-        strUsage += HelpMessageOpt(\"-dustrelayfee=<amt>\", strprintf(\"Fee rate (in %s/kB) used to defined dust, the value of an output such that it will cost more than its value in fees at this fee rate to spend it. (default: %s)\", CURRENCY_UNIT, FormatMoney(DUST_RELAY_TX_FEE)));\n-    }\n-    strUsage += HelpMessageOpt(\"-bytespersigop\", strprintf(_(\"Equivalent bytes per sigop in transactions for relay and mining (default: %u)\"), DEFAULT_BYTES_PER_SIGOP));\n-    strUsage += HelpMessageOpt(\"-datacarrier\", strprintf(_(\"Relay and mine data carrier transactions (default: %u)\"), DEFAULT_ACCEPT_DATACARRIER));\n-    strUsage += HelpMessageOpt(\"-datacarriersize\", strprintf(_(\"Maximum size of data in data carrier transactions we relay and mine (default: %u)\"), MAX_OP_RETURN_RELAY));\n-    strUsage += HelpMessageOpt(\"-mempoolreplacement\", strprintf(_(\"Enable transaction replacement in the memory pool (default: %u)\"), DEFAULT_ENABLE_REPLACEMENT));\n-    strUsage += HelpMessageOpt(\"-minrelaytxfee=<amt>\", strprintf(_(\"Fees (in %s/kB) smaller than this are considered zero fee for relaying, mining and transaction creation (default: %s)\"),\n-        CURRENCY_UNIT, FormatMoney(DEFAULT_MIN_RELAY_TX_FEE)));\n-    strUsage += HelpMessageOpt(\"-whitelistforcerelay\", strprintf(_(\"Force relay of transactions from whitelisted peers even if they violate local relay policy (default: %d)\"), DEFAULT_WHITELISTFORCERELAY));\n-    strUsage += HelpMessageOpt(\"-whitelistrelay\", strprintf(_(\"Accept relayed transactions received from whitelisted peers even when not relaying transactions (default: %d)\"), DEFAULT_WHITELISTRELAY));\n+        strUsage += HelpMessageOpt(\"-acceptnonstdtxn\", strprintf(\n+            \"Relay and mine \\\"non-standard\\\" transactions (%sdefault: %u)\", \"testnet/regtest only; \",\n+                !testnetChainParams->RequireStandard()));\n+        strUsage += HelpMessageOpt(\"-incrementalrelayfee=<amt>\", strprintf(\n+            \"Fee rate (in %s/kB) used to define cost of relay, used for mempool limiting and BIP \"\n+            \"125 replacement. (default: %s)\",\n+                CURRENCY_UNIT, FormatMoney(DEFAULT_INCREMENTAL_RELAY_FEE)));\n+        strUsage += HelpMessageOpt(\"-dustrelayfee=<amt>\", strprintf(\n+            \"Fee rate (in %s/kB) used to defined dust, the value of an output such that it will \"\n+            \"cost more than its value in fees at this fee rate to spend it. (default: %s)\",\n+                CURRENCY_UNIT, FormatMoney(DUST_RELAY_TX_FEE)));\n+    }\n+    strUsage += HelpMessageOpt(\"-bytespersigop\", strprintf(_(\n+        \"Equivalent bytes per sigop in transactions for relay and mining (default: %u)\"),\n+            DEFAULT_BYTES_PER_SIGOP));\n+    strUsage += HelpMessageOpt(\"-datacarrier\", strprintf(_(\n+        \"Relay and mine data carrier transactions (default: %u)\"), DEFAULT_ACCEPT_DATACARRIER));\n+    strUsage += HelpMessageOpt(\"-datacarriersize\", strprintf(_(\n+        \"Maximum size of data in data carrier transactions we relay and mine (default: %u)\"),\n+            MAX_OP_RETURN_RELAY));\n+    strUsage += HelpMessageOpt(\"-mempoolreplacement\", strprintf(_(\n+        \"Enable transaction replacement in the memory pool (default: %u)\"), DEFAULT_ENABLE_REPLACEMENT));\n+    strUsage += HelpMessageOpt(\"-minrelaytxfee=<amt>\", strprintf(_(\n+        \"Fees (in %s/kB) smaller than this are considered zero fee for relaying, mining and \"\n+        \"transaction creation (default: %s)\"),\n+            CURRENCY_UNIT, FormatMoney(DEFAULT_MIN_RELAY_TX_FEE)));\n+    strUsage += HelpMessageOpt(\"-whitelistforcerelay\", strprintf(_(\n+        \"Force relay of transactions from whitelisted peers even if they violate local relay \"\n+        \"policy (default: %d)\"), DEFAULT_WHITELISTFORCERELAY));\n+    strUsage += HelpMessageOpt(\"-whitelistrelay\", strprintf(_(\n+        \"Accept relayed transactions received from whitelisted peers even when not relaying \"\n+        \"transactions (default: %d)\"), DEFAULT_WHITELISTRELAY));\n \n     strUsage += HelpMessageGroup(_(\"Block creation options:\"));\n     if (showDebug)\n-        strUsage += HelpMessageOpt(\"-blockmaxsize=<n>\", \"Set maximum BIP141 block weight to this * 4. Deprecated, use blockmaxweight\");\n-    strUsage += HelpMessageOpt(\"-blockmaxweight=<n>\", strprintf(_(\"Set maximum BIP141 block weight (default: %d)\"), DEFAULT_BLOCK_MAX_WEIGHT));\n-    strUsage += HelpMessageOpt(\"-blockmintxfee=<amt>\", strprintf(_(\"Set lowest fee rate (in %s/kB) for transactions to be included in block creation. (default: %s)\"), CURRENCY_UNIT, FormatMoney(DEFAULT_BLOCK_MIN_TX_FEE)));\n+        strUsage += HelpMessageOpt(\"-blockmaxsize=<n>\",\n+            \"Set maximum BIP141 block weight to this * 4. Deprecated, use blockmaxweight\");\n+    strUsage += HelpMessageOpt(\"-blockmaxweight=<n>\", strprintf(_(\n+        \"Set maximum BIP141 block weight (default: %d)\"), DEFAULT_BLOCK_MAX_WEIGHT));\n+    strUsage += HelpMessageOpt(\"-blockmintxfee=<amt>\", strprintf(_(\n+        \"Set lowest fee rate (in %s/kB) for transactions to be included in block creation. \"\n+        \"(default: %s)\"), CURRENCY_UNIT, FormatMoney(DEFAULT_BLOCK_MIN_TX_FEE)));\n     if (showDebug)\n         strUsage += HelpMessageOpt(\"-blockversion=<n>\", \"Override block version to test forking scenarios\");\n \n     strUsage += HelpMessageGroup(_(\"RPC server options:\"));\n-    strUsage += HelpMessageOpt(\"-rest\", strprintf(_(\"Accept public REST requests (default: %u)\"), DEFAULT_REST_ENABLE));\n-    strUsage += HelpMessageOpt(\"-rpcallowip=<ip>\", _(\"Allow JSON-RPC connections from specified source. Valid for <ip> are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24). This option can be specified multiple times\"));\n-    strUsage += HelpMessageOpt(\"-rpcauth=<userpw>\", _(\"Username and hashed password for JSON-RPC connections. The field <userpw> comes in the format: <USERNAME>:<SALT>$<HASH>. A canonical python script is included in share/rpcuser. The client then connects normally using the rpcuser=<USERNAME>/rpcpassword=<PASSWORD> pair of arguments. This option can be specified multiple times\"));\n-    strUsage += HelpMessageOpt(\"-rpcbind=<addr>[:port]\", _(\"Bind to given address to listen for JSON-RPC connections. This option is ignored unless -rpcallowip is also passed. Port is optional and overrides -rpcport. Use [host]:port notation for IPv6. This option can be specified multiple times (default: 127.0.0.1 and ::1 i.e., localhost, or if -rpcallowip has been specified, 0.0.0.0 and :: i.e., all addresses)\"));\n-    strUsage += HelpMessageOpt(\"-rpccookiefile=<loc>\", _(\"Location of the auth cookie. Relative paths will be prefixed by a net-specific datadir location. (default: data dir)\"));\n+    strUsage += HelpMessageOpt(\"-rest\", strprintf(_(\n+        \"Accept public REST requests (default: %u)\"), DEFAULT_REST_ENABLE));\n+    strUsage += HelpMessageOpt(\"-rpcallowip=<ip>\", _(\n+        \"Allow JSON-RPC connections from specified source. Valid for <ip> are a single IP \"\n+        \"(e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR \"\n+        \"(e.g. 1.2.3.4/24). This option can be specified multiple times\"));\n+    strUsage += HelpMessageOpt(\"-rpcauth=<userpw>\", _(\n+        \"Username and hashed password for JSON-RPC connections. The field <userpw> comes in the \"\n+        \"format: <USERNAME>:<SALT>$<HASH>. A canonical python script is included in share/rpcuser. \"\n+        \"The client then connects normally using the rpcuser=<USERNAME>/rpcpassword=<PASSWORD> \"\n+        \"pair of arguments. This option can be specified multiple times\"));\n+    strUsage += HelpMessageOpt(\"-rpcbind=<addr>[:port]\", _(\n+        \"Bind to given address to listen for JSON-RPC connections. This option is ignored unless \"\n+        \"-rpcallowip is also passed. Port is optional and overrides -rpcport. Use [host]:port \"\n+        \"notation for IPv6. This option can be specified multiple times (default: 127.0.0.1 and \"\n+        \"::1 i.e., localhost, or if -rpcallowip has been specified, 0.0.0.0 and :: i.e., all \"\n+        \"addresses)\"));\n+    strUsage += HelpMessageOpt(\"-rpccookiefile=<loc>\", _(\n+        \"Location of the auth cookie. Relative paths will be prefixed by a net-specific datadir \"\n+        \"location. (default: data dir)\"));\n     strUsage += HelpMessageOpt(\"-rpcpassword=<pw>\", _(\"Password for JSON-RPC connections\"));\n-    strUsage += HelpMessageOpt(\"-rpcport=<port>\", strprintf(_(\"Listen for JSON-RPC connections on <port> (default: %u or testnet: %u)\"), defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort()));\n-    strUsage += HelpMessageOpt(\"-rpcserialversion\", strprintf(_(\"Sets the serialization of raw transaction or block hex returned in non-verbose mode, non-segwit(0) or segwit(1) (default: %d)\"), DEFAULT_RPC_SERIALIZE_VERSION));\n+    strUsage += HelpMessageOpt(\"-rpcport=<port>\", strprintf(_(\n+        \"Listen for JSON-RPC connections on <port> (default: %u or testnet: %u)\"),\n+            defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort()));\n+    strUsage += HelpMessageOpt(\"-rpcserialversion\", strprintf(_(\n+        \"Sets the serialization of raw transaction or block hex returned in non-verbose mode, \"\n+        \"non-segwit(0) or segwit(1) (default: %d)\"), DEFAULT_RPC_SERIALIZE_VERSION));\n     if (showDebug)\n-        strUsage += HelpMessageOpt(\"-rpcservertimeout=<n>\", strprintf(\"Timeout during HTTP requests (default: %d)\", DEFAULT_HTTP_SERVER_TIMEOUT));\n-    strUsage += HelpMessageOpt(\"-rpcthreads=<n>\", strprintf(_(\"Set the number of threads to service RPC calls (default: %d)\"), DEFAULT_HTTP_THREADS));\n+        strUsage += HelpMessageOpt(\"-rpcservertimeout=<n>\", strprintf(\n+            \"Timeout during HTTP requests (default: %d)\", DEFAULT_HTTP_SERVER_TIMEOUT));\n+    strUsage += HelpMessageOpt(\"-rpcthreads=<n>\", strprintf(_(\n+        \"Set the number of threads to service RPC calls (default: %d)\"), DEFAULT_HTTP_THREADS));\n     strUsage += HelpMessageOpt(\"-rpcuser=<user>\", _(\"Username for JSON-RPC connections\"));\n     if (showDebug)\n-        strUsage += HelpMessageOpt(\"-rpcworkqueue=<n>\", strprintf(\"Set the depth of the work queue to service RPC calls (default: %d)\", DEFAULT_HTTP_WORKQUEUE));\n+        strUsage += HelpMessageOpt(\"-rpcworkqueue=<n>\", strprintf(\n+            \"Set the depth of the work queue to service RPC calls (default: %d)\",\n+                DEFAULT_HTTP_WORKQUEUE));\n     strUsage += HelpMessageOpt(\"-server\", _(\"Accept command line and JSON-RPC commands\"));\n \n     return strUsage;\n@@ -1235,11 +1422,12 @@ bool AppInitMain()\n \n     // Warn about relative -datadir path.\n     if (gArgs.IsArgSet(\"-datadir\") && !fs::path(gArgs.GetArg(\"-datadir\", \"\")).is_absolute()) {\n-        LogPrintf(\"Warning: relative datadir option '%s' specified, which will be interpreted relative to the \"\n-                  \"current working directory '%s'. This is fragile, because if bitcoin is started in the future \"\n-                  \"from a different location, it will be unable to locate the current data files. There could \"\n-                  \"also be data loss if bitcoin is started while in a temporary directory.\\n\",\n-            gArgs.GetArg(\"-datadir\", \"\"), fs::current_path().string());\n+        LogPrintf(\n+            \"Warning: relative datadir option '%s' specified, which will be interpreted relative to the \"\n+            \"current working directory '%s'. This is fragile, because if bitcoin is started in the future \"\n+            \"from a different location, it will be unable to locate the current data files. There could \"\n+            \"also be data loss if bitcoin is started while in a temporary directory.\\n\",\n+                gArgs.GetArg(\"-datadir\", \"\"), fs::current_path().string());\n     }\n \n     InitSignatureCache();"
      },
      {
        "sha": "a5d791a265b7aef8a4cb28f1c7c5887d56ad99f5",
        "filename": "src/qt/utilitydialog.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 7,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/91c8756c6561e0a1bba64ad91cf4a4157d9a0749/src/qt/utilitydialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/91c8756c6561e0a1bba64ad91cf4a4157d9a0749/src/qt/utilitydialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/utilitydialog.cpp?ref=91c8756c6561e0a1bba64ad91cf4a4157d9a0749",
        "patch": "@@ -81,16 +81,24 @@ HelpMessageDialog::HelpMessageDialog(QWidget *parent, bool about) :\n         const bool showDebug = gArgs.GetBoolArg(\"-help-debug\", false);\n         strUsage += HelpMessageGroup(tr(\"UI Options:\").toStdString());\n         if (showDebug) {\n-            strUsage += HelpMessageOpt(\"-allowselfsignedrootcertificates\", strprintf(\"Allow self signed root certificates (default: %u)\", DEFAULT_SELFSIGNED_ROOTCERTS));\n+            strUsage += HelpMessageOpt(\"-allowselfsignedrootcertificates\", strprintf(\n+                \"Allow self signed root certificates (default: %u)\", DEFAULT_SELFSIGNED_ROOTCERTS));\n         }\n-        strUsage += HelpMessageOpt(\"-choosedatadir\", strprintf(tr(\"Choose data directory on startup (default: %u)\").toStdString(), DEFAULT_CHOOSE_DATADIR));\n-        strUsage += HelpMessageOpt(\"-lang=<lang>\", tr(\"Set language, for example \\\"de_DE\\\" (default: system locale)\").toStdString());\n+        strUsage += HelpMessageOpt(\"-choosedatadir\", strprintf(tr(\n+            \"Choose data directory on startup (default: %u)\").toStdString(), DEFAULT_CHOOSE_DATADIR));\n+        strUsage += HelpMessageOpt(\"-lang=<lang>\", tr(\n+            \"Set language, for example \\\"de_DE\\\" (default: system locale)\").toStdString());\n         strUsage += HelpMessageOpt(\"-min\", tr(\"Start minimized\").toStdString());\n-        strUsage += HelpMessageOpt(\"-resetguisettings\", tr(\"Reset all settings changed in the GUI\").toStdString());\n-        strUsage += HelpMessageOpt(\"-rootcertificates=<file>\", tr(\"Set SSL root certificates for payment request (default: -system-)\").toStdString());\n-        strUsage += HelpMessageOpt(\"-splash\", strprintf(tr(\"Show splash screen on startup (default: %u)\").toStdString(), DEFAULT_SPLASHSCREEN));\n+        strUsage += HelpMessageOpt(\"-resetguisettings\", tr(\n+            \"Reset all settings changed in the GUI\").toStdString());\n+        strUsage += HelpMessageOpt(\"-rootcertificates=<file>\", tr(\n+            \"Set SSL root certificates for payment request (default: -system-)\").toStdString());\n+        strUsage += HelpMessageOpt(\"-splash\", strprintf(tr(\n+            \"Show splash screen on startup (default: %u)\").toStdString(), DEFAULT_SPLASHSCREEN));\n         if (showDebug) {\n-            strUsage += HelpMessageOpt(\"-uiplatform\", strprintf(\"Select platform to customize UI for (one of windows, macosx, other; default: %s)\", BitcoinGUI::DEFAULT_UIPLATFORM));\n+            strUsage += HelpMessageOpt(\"-uiplatform\", strprintf(\n+                \"Select platform to customize UI for (one of windows, macosx, other; default: %s)\",\n+                    BitcoinGUI::DEFAULT_UIPLATFORM));\n         }\n         QString coreOptions = QString::fromStdString(strUsage);\n         text = version + \"\\n\" + header + \"\\n\" + coreOptions;"
      },
      {
        "sha": "6acc6903d0e977dd1a3ecb9d4fdb4b2e03d983d1",
        "filename": "src/wallet/init.cpp",
        "status": "modified",
        "additions": 66,
        "deletions": 29,
        "changes": 95,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/91c8756c6561e0a1bba64ad91cf4a4157d9a0749/src/wallet/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/91c8756c6561e0a1bba64ad91cf4a4157d9a0749/src/wallet/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/init.cpp?ref=91c8756c6561e0a1bba64ad91cf4a4157d9a0749",
        "patch": "@@ -17,40 +17,77 @@\n std::string GetWalletHelpString(bool showDebug)\n {\n     std::string strUsage = HelpMessageGroup(_(\"Wallet options:\"));\n-    strUsage += HelpMessageOpt(\"-addresstype\", strprintf(\"What type of addresses to use (\\\"legacy\\\", \\\"p2sh-segwit\\\", or \\\"bech32\\\", default: \\\"%s\\\")\", FormatOutputType(DEFAULT_ADDRESS_TYPE)));\n-    strUsage += HelpMessageOpt(\"-changetype\", \"What type of change to use (\\\"legacy\\\", \\\"p2sh-segwit\\\", or \\\"bech32\\\"). Default is same as -addresstype, except when -addresstype=p2sh-segwit a native segwit output is used when sending to a native segwit address)\");\n-    strUsage += HelpMessageOpt(\"-disablewallet\", _(\"Do not load the wallet and disable wallet RPC calls\"));\n-    strUsage += HelpMessageOpt(\"-discardfee=<amt>\", strprintf(_(\"The fee rate (in %s/kB) that indicates your tolerance for discarding change by adding it to the fee (default: %s). \"\n-                                                                \"Note: An output is discarded if it is dust at this rate, but we will always discard up to the dust relay fee and a discard fee above that is limited by the fee estimate for the longest target\"),\n-                                                              CURRENCY_UNIT, FormatMoney(DEFAULT_DISCARD_FEE)));\n-    strUsage += HelpMessageOpt(\"-fallbackfee=<amt>\", strprintf(_(\"A fee rate (in %s/kB) that will be used when fee estimation has insufficient data (default: %s)\"),\n-                                                               CURRENCY_UNIT, FormatMoney(DEFAULT_FALLBACK_FEE)));\n-    strUsage += HelpMessageOpt(\"-keypool=<n>\", strprintf(_(\"Set key pool size to <n> (default: %u)\"), DEFAULT_KEYPOOL_SIZE));\n-    strUsage += HelpMessageOpt(\"-mintxfee=<amt>\", strprintf(_(\"Fees (in %s/kB) smaller than this are considered zero fee for transaction creation (default: %s)\"),\n-                                                            CURRENCY_UNIT, FormatMoney(DEFAULT_TRANSACTION_MINFEE)));\n-    strUsage += HelpMessageOpt(\"-paytxfee=<amt>\", strprintf(_(\"Fee (in %s/kB) to add to transactions you send (default: %s)\"),\n-                                                            CURRENCY_UNIT, FormatMoney(payTxFee.GetFeePerK())));\n-    strUsage += HelpMessageOpt(\"-rescan\", _(\"Rescan the block chain for missing wallet transactions on startup\"));\n-    strUsage += HelpMessageOpt(\"-salvagewallet\", _(\"Attempt to recover private keys from a corrupt wallet on startup\"));\n-    strUsage += HelpMessageOpt(\"-spendzeroconfchange\", strprintf(_(\"Spend unconfirmed change when sending transactions (default: %u)\"), DEFAULT_SPEND_ZEROCONF_CHANGE));\n-    strUsage += HelpMessageOpt(\"-txconfirmtarget=<n>\", strprintf(_(\"If paytxfee is not set, include enough fee so transactions begin confirmation on average within n blocks (default: %u)\"), DEFAULT_TX_CONFIRM_TARGET));\n-    strUsage += HelpMessageOpt(\"-upgradewallet\", _(\"Upgrade wallet to latest format on startup\"));\n-    strUsage += HelpMessageOpt(\"-wallet=<path>\", _(\"Specify wallet database path. Can be specified multiple times to load multiple wallets. Path is interpreted relative to <walletdir> if it is not absolute, and will be created if it does not exist (as a directory containing a wallet.dat file and log files). For backwards compatibility this will also accept names of existing data files in <walletdir>.)\"));\n-    strUsage += HelpMessageOpt(\"-walletbroadcast\", _(\"Make the wallet broadcast transactions\") + \" \" + strprintf(_(\"(default: %u)\"), DEFAULT_WALLETBROADCAST));\n-    strUsage += HelpMessageOpt(\"-walletdir=<dir>\", _(\"Specify directory to hold wallets (default: <datadir>/wallets if it exists, otherwise <datadir>)\"));\n-    strUsage += HelpMessageOpt(\"-walletnotify=<cmd>\", _(\"Execute command when a wallet transaction changes (%s in cmd is replaced by TxID)\"));\n-    strUsage += HelpMessageOpt(\"-walletrbf\", strprintf(_(\"Send transactions with full-RBF opt-in enabled (RPC only, default: %u)\"), DEFAULT_WALLET_RBF));\n-    strUsage += HelpMessageOpt(\"-zapwallettxes=<mode>\", _(\"Delete all wallet transactions and only recover those parts of the blockchain through -rescan on startup\") +\n-                               \" \" + _(\"(1 = keep tx meta data e.g. account owner and payment request information, 2 = drop tx meta data)\"));\n+    strUsage += HelpMessageOpt(\"-addresstype\", strprintf(\n+        \"What type of addresses to use (\\\"legacy\\\", \\\"p2sh-segwit\\\", or \\\"bech32\\\", default: \"\n+        \"\\\"%s\\\")\", FormatOutputType(DEFAULT_ADDRESS_TYPE)));\n+    strUsage += HelpMessageOpt(\"-changetype\",\n+        \"What type of change to use (\\\"legacy\\\", \\\"p2sh-segwit\\\", or \\\"bech32\\\"). Default is \"\n+        \"same as -addresstype, except when -addresstype=p2sh-segwit a native segwit output is \"\n+        \"used when sending to a native segwit address)\");\n+    strUsage += HelpMessageOpt(\"-disablewallet\", _(\n+        \"Do not load the wallet and disable wallet RPC calls\"));\n+    strUsage += HelpMessageOpt(\"-discardfee=<amt>\", strprintf(_(\n+        \"The fee rate (in %s/kB) that indicates your tolerance for discarding change by adding \"\n+        \"it to the fee (default: %s). Note: An output is discarded if it is dust at this rate, \"\n+        \"but we will always discard up to the dust relay fee and a discard fee above that is \"\n+        \"limited by the fee estimate for the longest target\"),\n+            CURRENCY_UNIT, FormatMoney(DEFAULT_DISCARD_FEE)));\n+    strUsage += HelpMessageOpt(\"-fallbackfee=<amt>\", strprintf(_(\n+        \"A fee rate (in %s/kB) that will be used when fee estimation has insufficient data \"\n+        \"(default: %s)\"), CURRENCY_UNIT, FormatMoney(DEFAULT_FALLBACK_FEE)));\n+    strUsage += HelpMessageOpt(\"-keypool=<n>\", strprintf(_(\n+        \"Set key pool size to <n> (default: %u)\"), DEFAULT_KEYPOOL_SIZE));\n+    strUsage += HelpMessageOpt(\"-mintxfee=<amt>\", strprintf(_(\n+        \"Fees (in %s/kB) smaller than this are considered zero fee for transaction creation \"\n+        \"(default: %s)\"), CURRENCY_UNIT, FormatMoney(DEFAULT_TRANSACTION_MINFEE)));\n+    strUsage += HelpMessageOpt(\"-paytxfee=<amt>\", strprintf(_(\n+        \"Fee (in %s/kB) to add to transactions you send (default: %s)\"),\n+            CURRENCY_UNIT, FormatMoney(payTxFee.GetFeePerK())));\n+    strUsage += HelpMessageOpt(\"-rescan\", _(\n+        \"Rescan the block chain for missing wallet transactions on startup\"));\n+    strUsage += HelpMessageOpt(\"-salvagewallet\", _(\n+        \"Attempt to recover private keys from a corrupt wallet on startup\"));\n+    strUsage += HelpMessageOpt(\"-spendzeroconfchange\", strprintf(_(\n+        \"Spend unconfirmed change when sending transactions (default: %u)\"),\n+            DEFAULT_SPEND_ZEROCONF_CHANGE));\n+    strUsage += HelpMessageOpt(\"-txconfirmtarget=<n>\", strprintf(_(\n+        \"If paytxfee is not set, include enough fee so transactions begin confirmation on \"\n+        \"average within n blocks (default: %u)\"), DEFAULT_TX_CONFIRM_TARGET));\n+    strUsage += HelpMessageOpt(\"-upgradewallet\", _(\n+        \"Upgrade wallet to latest format on startup\"));\n+    strUsage += HelpMessageOpt(\"-wallet=<path>\", _(\n+        \"Specify wallet database path. Can be specified multiple times to load multiple wallets. \"\n+        \"Path is interpreted relative to <walletdir> if it is not absolute, and will be created \"\n+        \"if it does not exist (as a directory containing a wallet.dat file and log files). For \"\n+        \"backwards compatibility this will also accept names of existing data files in <walletdir>.)\"));\n+    strUsage += HelpMessageOpt(\"-walletbroadcast\", _(\n+        \"Make the wallet broadcast transactions \") + strprintf(_(\"(default: %u)\"), DEFAULT_WALLETBROADCAST));\n+    strUsage += HelpMessageOpt(\"-walletdir=<dir>\", _(\n+        \"Specify directory to hold wallets (default: <datadir>/wallets if it exists, otherwise <datadir>)\"));\n+    strUsage += HelpMessageOpt(\"-walletnotify=<cmd>\", _(\n+        \"Execute command when a wallet transaction changes (%s in cmd is replaced by TxID)\"));\n+    strUsage += HelpMessageOpt(\"-walletrbf\", strprintf(_(\n+        \"Send transactions with full-RBF opt-in enabled (RPC only, default: %u)\"), DEFAULT_WALLET_RBF));\n+    strUsage += HelpMessageOpt(\"-zapwallettxes=<mode>\", _(\n+        \"Delete all wallet transactions and only recover those parts of the blockchain through \"\n+        \"-rescan on startup (1 = keep tx meta data e.g. account owner and payment request \"\n+        \"information, 2 = drop tx meta data)\"));\n \n     if (showDebug)\n     {\n         strUsage += HelpMessageGroup(_(\"Wallet debugging/testing options:\"));\n \n-        strUsage += HelpMessageOpt(\"-dblogsize=<n>\", strprintf(\"Flush wallet database activity from memory to disk log every <n> megabytes (default: %u)\", DEFAULT_WALLET_DBLOGSIZE));\n-        strUsage += HelpMessageOpt(\"-flushwallet\", strprintf(\"Run a thread to flush wallet periodically (default: %u)\", DEFAULT_FLUSHWALLET));\n-        strUsage += HelpMessageOpt(\"-privdb\", strprintf(\"Sets the DB_PRIVATE flag in the wallet db environment (default: %u)\", DEFAULT_WALLET_PRIVDB));\n-        strUsage += HelpMessageOpt(\"-walletrejectlongchains\", strprintf(_(\"Wallet will not create transactions that violate mempool chain limits (default: %u)\"), DEFAULT_WALLET_REJECT_LONG_CHAINS));\n+        strUsage += HelpMessageOpt(\"-dblogsize=<n>\", strprintf(\n+            \"Flush wallet database activity from memory to disk log every <n> megabytes \"\n+            \"(default: %u)\", DEFAULT_WALLET_DBLOGSIZE));\n+        strUsage += HelpMessageOpt(\"-flushwallet\", strprintf(\n+            \"Run a thread to flush wallet periodically (default: %u)\", DEFAULT_FLUSHWALLET));\n+        strUsage += HelpMessageOpt(\"-privdb\", strprintf(\n+            \"Sets the DB_PRIVATE flag in the wallet db environment (default: %u)\",\n+                DEFAULT_WALLET_PRIVDB));\n+        strUsage += HelpMessageOpt(\"-walletrejectlongchains\", strprintf(_(\n+            \"Wallet will not create transactions that violate mempool chain limits (default: %u)\"),\n+                DEFAULT_WALLET_REJECT_LONG_CHAINS));\n     }\n \n     return strUsage;"
      }
    ]
  },
  {
    "sha": "26e7f38260dc7150c0453fefa86712843d125e40",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNmU3ZjM4MjYwZGM3MTUwYzA0NTNmZWZhODY3MTI4NDNkMTI1ZTQw",
    "commit": {
      "author": {
        "name": "Murray Nesbitt",
        "email": "github@nesbitt.ca",
        "date": "2018-03-28T07:43:37Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2018-03-28T07:43:37Z"
      },
      "message": "Merge branch 'master' into help_formatting",
      "tree": {
        "sha": "3b16443696508d351cad47b969e01c3ed75074e3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3b16443696508d351cad47b969e01c3ed75074e3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/26e7f38260dc7150c0453fefa86712843d125e40",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJau0epCRBK7hj4Ov3rIwAAdHIIAHbwtJTnG/glEJb9ukcTDuwl\nB3+4wK09oh6mmfS8fo4VPt7N7j1QBoP47U+rg5usSAfdEEu+MiZKB+Jci51y+XEV\nPFcWwgAS8+6jl5BtDoycHFtfJI/Eh9+qLK3i/1FWDduC2OUV9PFBSbYuzds07XSu\nMRqEey49C5X+Rkcid5JSDUkB1hb9IekZnbRIQq7LfhCkzGX+wEBloDz0g44vGc90\nKvqdTCuqffYUhtID5bzLLBMrPYskQB/xMt3D8zIdVXv+yvqYnoD7itMmcdGFsy7J\np6DtHDw2U+kjRmaU0eq66+1V+rdDE7UFbV9Emz7TbjM1qaAvgK13xC1HQi2LFCs=\n=4Ody\n-----END PGP SIGNATURE-----\n",
        "payload": "tree 3b16443696508d351cad47b969e01c3ed75074e3\nparent 91c8756c6561e0a1bba64ad91cf4a4157d9a0749\nparent ac898b689c660df8a79cc64997dda66d36eb59dd\nauthor Murray Nesbitt <github@nesbitt.ca> 1522223017 -0700\ncommitter GitHub <noreply@github.com> 1522223017 -0700\n\nMerge branch 'master' into help_formatting"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/26e7f38260dc7150c0453fefa86712843d125e40",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/26e7f38260dc7150c0453fefa86712843d125e40",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/26e7f38260dc7150c0453fefa86712843d125e40/comments",
    "author": {
      "login": "murrayn",
      "id": 5404807,
      "node_id": "MDQ6VXNlcjU0MDQ4MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5404807?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/murrayn",
      "html_url": "https://github.com/murrayn",
      "followers_url": "https://api.github.com/users/murrayn/followers",
      "following_url": "https://api.github.com/users/murrayn/following{/other_user}",
      "gists_url": "https://api.github.com/users/murrayn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/murrayn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/murrayn/subscriptions",
      "organizations_url": "https://api.github.com/users/murrayn/orgs",
      "repos_url": "https://api.github.com/users/murrayn/repos",
      "events_url": "https://api.github.com/users/murrayn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/murrayn/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "91c8756c6561e0a1bba64ad91cf4a4157d9a0749",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/91c8756c6561e0a1bba64ad91cf4a4157d9a0749",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/91c8756c6561e0a1bba64ad91cf4a4157d9a0749"
      },
      {
        "sha": "ac898b689c660df8a79cc64997dda66d36eb59dd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ac898b689c660df8a79cc64997dda66d36eb59dd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ac898b689c660df8a79cc64997dda66d36eb59dd"
      }
    ],
    "stats": {
      "total": 1218,
      "additions": 732,
      "deletions": 486
    },
    "files": [
      {
        "sha": "f10ad8e877d4713cd51b267c94ef8d3143066c6f",
        "filename": "doc/developer-notes.md",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/doc/developer-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/doc/developer-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/developer-notes.md?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -39,6 +39,7 @@ code.\n   - `++i` is preferred over `i++`.\n   - `nullptr` is preferred over `NULL` or `(void*)0`.\n   - `static_assert` is preferred over `assert` where possible. Generally; compile-time checking is preferred over run-time checking.\n+  - `enum class` is preferred over `enum` where possible. Scoped enumerations avoid two potential pitfalls/problems with traditional C++ enumerations: implicit conversions to int, and name clashes due to enumerators being exported to the surrounding scope.\n \n Block style example:\n ```c++\n@@ -218,7 +219,7 @@ inconsistencies reported in the debug.log file.\n \n Re-architecting the core code so there are better-defined interfaces\n between the various components is a goal, with any necessary locking\n-done by the components (e.g. see the self-contained CKeyStore class\n+done by the components (e.g. see the self-contained CBasicKeyStore class\n and its cs_KeyStore lock for example).\n \n Threads"
      },
      {
        "sha": "740afd5137963ab734d1ab7bee25245687ddfe7d",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -109,6 +109,14 @@ Low-level RPC changes\n \n - The log timestamp format is now ISO 8601 (e.g. \"2018-02-28T12:34:56Z\").\n \n+Miner block size removed\n+------------------------\n+\n+The `-blockmaxsize` option for miners to limit their blocks' sizes was\n+deprecated in V0.15.1, and has now been removed. Miners should use the\n+`-blockmaxweight` option if they want to limit the weight of their blocks'\n+weights.\n+\n Credits\n =======\n "
      },
      {
        "sha": "705fa368a5072721f32a57d4aa3f21492bdc99dc",
        "filename": "src/bench/verify_script.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/bench/verify_script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/bench/verify_script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/verify_script.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -75,7 +75,7 @@ static void VerifyScriptBench(benchmark::State& state)\n     CMutableTransaction txSpend = BuildSpendingTransaction(scriptSig, txCredit);\n     CScriptWitness& witness = txSpend.vin[0].scriptWitness;\n     witness.stack.emplace_back();\n-    key.Sign(SignatureHash(witScriptPubkey, txSpend, 0, SIGHASH_ALL, txCredit.vout[0].nValue, SIGVERSION_WITNESS_V0), witness.stack.back(), 0);\n+    key.Sign(SignatureHash(witScriptPubkey, txSpend, 0, SIGHASH_ALL, txCredit.vout[0].nValue, SigVersion::WITNESS_V0), witness.stack.back(), 0);\n     witness.stack.back().push_back(static_cast<unsigned char>(SIGHASH_ALL));\n     witness.stack.push_back(ToByteVector(pubkey));\n "
      },
      {
        "sha": "db5e6106845bdc66da8fe43d3f3bd2dd6d4bd615",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -79,7 +79,7 @@ bool AppInit(int argc, char* argv[])\n             strUsage += \"\\n\" + _(\"Usage:\") + \"\\n\" +\n                   \"  bitcoind [options]                     \" + strprintf(_(\"Start %s Daemon\"), _(PACKAGE_NAME)) + \"\\n\";\n \n-            strUsage += \"\\n\" + HelpMessage(HMM_BITCOIND);\n+            strUsage += \"\\n\" + HelpMessage(HelpMessageMode::BITCOIND);\n         }\n \n         fprintf(stdout, \"%s\", strUsage.c_str());"
      },
      {
        "sha": "6067503b0b93c134d4459a92a31e4d318611cf60",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -135,6 +135,7 @@ class CMainParams : public CChainParams {\n         vSeeds.emplace_back(\"seed.bitcoinstats.com\"); // Christian Decker, supports x1 - xf\n         vSeeds.emplace_back(\"seed.bitcoin.jonasschnelli.ch\"); // Jonas Schnelli, only supports x1, x5, x9, and xd\n         vSeeds.emplace_back(\"seed.btc.petertodd.org\"); // Peter Todd, only supports x1, x5, x9, and xd\n+        vSeeds.emplace_back(\"seed.bitcoin.sprovoost.nl\"); // Sjors Provoost\n \n         base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,0);\n         base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,5);"
      },
      {
        "sha": "0a70619ba6a7e2f4b1565b9c76c5262f754b7a81",
        "filename": "src/httprpc.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/httprpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/httprpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httprpc.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -158,8 +158,9 @@ static bool HTTPReq_JSONRPC(HTTPRequest* req, const std::string &)\n     }\n \n     JSONRPCRequest jreq;\n+    jreq.peerAddr = req->GetPeer().ToString();\n     if (!RPCAuthorized(authHeader.second, jreq.authUser)) {\n-        LogPrintf(\"ThreadRPCServer incorrect password attempt from %s\\n\", req->GetPeer().ToString());\n+        LogPrintf(\"ThreadRPCServer incorrect password attempt from %s\\n\", jreq.peerAddr);\n \n         /* Deter brute-forcing\n            If this results in a DoS the user really\n@@ -252,6 +253,9 @@ void StopHTTPRPC()\n {\n     LogPrint(BCLog::RPC, \"Stopping HTTP RPC server\\n\");\n     UnregisterHTTPHandler(\"/\", true);\n+#ifdef ENABLE_WALLET\n+    UnregisterHTTPHandler(\"/wallet/\", false);\n+#endif\n     if (httpRPCTimerInterface) {\n         RPCUnsetTimerInterface(httpRPCTimerInterface.get());\n         httpRPCTimerInterface.reset();"
      },
      {
        "sha": "f40e1704a2694816cd26dff73ebb27cf09dd7f99",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 15,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -340,6 +340,8 @@ std::string HelpMessage(HelpMessageMode mode)\n         \"potentially skip their script verification (0 to verify all, default: %s, testnet: %s)\"),\n             defaultChainParams->GetConsensus().defaultAssumeValid.GetHex(),\n             testnetChainParams->GetConsensus().defaultAssumeValid.GetHex()));\n+    strUsage += HelpMessageOpt(\"-blocksdir=<dir>\", _(\n+        \"Specify blocks directory (default: <datadir>/blocks)\"));\n     strUsage += HelpMessageOpt(\"-blocknotify=<cmd>\", _(\n         \"Execute command when the best block changes (%s in cmd is replaced by block hash)\"));\n     strUsage += HelpMessageOpt(\"-blockreconstructionextratxn=<n>\", strprintf(_(\n@@ -351,7 +353,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-conf=<file>\", strprintf(_(\n         \"Specify configuration file. Relative paths will be prefixed by datadir location. \"\n         \"(default: %s)\"), BITCOIN_CONF_FILENAME));\n-    if (mode == HMM_BITCOIND)\n+    if (mode == HelpMessageMode::BITCOIND)\n     {\n #if HAVE_DECL_DAEMON\n         strUsage += HelpMessageOpt(\"-daemon\", _(\n@@ -651,9 +653,6 @@ std::string HelpMessage(HelpMessageMode mode)\n         \"transactions (default: %d)\"), DEFAULT_WHITELISTRELAY));\n \n     strUsage += HelpMessageGroup(_(\"Block creation options:\"));\n-    if (showDebug)\n-        strUsage += HelpMessageOpt(\"-blockmaxsize=<n>\",\n-            \"Set maximum BIP141 block weight to this * 4. Deprecated, use blockmaxweight\");\n     strUsage += HelpMessageOpt(\"-blockmaxweight=<n>\", strprintf(_(\n         \"Set maximum BIP141 block weight (default: %d)\"), DEFAULT_BLOCK_MAX_WEIGHT));\n     strUsage += HelpMessageOpt(\"-blockmintxfee=<amt>\", strprintf(_(\n@@ -783,7 +782,7 @@ void CleanupBlockRevFiles()\n     // Remove the rev files immediately and insert the blk file paths into an\n     // ordered map keyed by block file index.\n     LogPrintf(\"Removing unusable blk?????.dat and rev?????.dat files for -reindex with -prune\\n\");\n-    fs::path blocksdir = GetDataDir() / \"blocks\";\n+    fs::path blocksdir = GetBlocksDir();\n     for (fs::directory_iterator it(blocksdir); it != fs::directory_iterator(); it++) {\n         if (fs::is_regular_file(*it) &&\n             it->path().filename().string().length() == 12 &&\n@@ -985,15 +984,6 @@ void InitParameterInteraction()\n         if (gArgs.SoftSetBoolArg(\"-whitelistrelay\", true))\n             LogPrintf(\"%s: parameter interaction: -whitelistforcerelay=1 -> setting -whitelistrelay=1\\n\", __func__);\n     }\n-\n-    if (gArgs.IsArgSet(\"-blockmaxsize\")) {\n-        unsigned int max_size = gArgs.GetArg(\"-blockmaxsize\", 0);\n-        if (gArgs.SoftSetArg(\"blockmaxweight\", strprintf(\"%d\", max_size * WITNESS_SCALE_FACTOR))) {\n-            LogPrintf(\"%s: parameter interaction: -blockmaxsize=%d -> setting -blockmaxweight=%d (-blockmaxsize is deprecated!)\\n\", __func__, max_size, max_size * WITNESS_SCALE_FACTOR);\n-        } else {\n-            LogPrintf(\"%s: Ignoring blockmaxsize setting which is overridden by blockmaxweight\", __func__);\n-        }\n-    }\n }\n \n static std::string ResolveErrMsg(const char * const optname, const std::string& strBind)\n@@ -1095,6 +1085,10 @@ bool AppInitParameterInteraction()\n \n     // also see: InitParameterInteraction()\n \n+    if (!fs::is_directory(GetBlocksDir(false))) {\n+        return InitError(strprintf(_(\"Specified blocks directory \\\"%s\\\" does not exist.\\n\"), gArgs.GetArg(\"-blocksdir\", \"\").c_str()));\n+    }\n+\n     // if using block pruning, then disallow txindex\n     if (gArgs.GetArg(\"-prune\", 0)) {\n         if (gArgs.GetBoolArg(\"-txindex\", DEFAULT_TXINDEX))\n@@ -1821,7 +1815,7 @@ bool AppInitMain()\n \n     // ********************************************************* Step 10: import blocks\n \n-    if (!CheckDiskSpace())\n+    if (!CheckDiskSpace() && !CheckDiskSpace(0, true))\n         return false;\n \n     // Either install a handler to notify us when genesis activates, or set fHaveGenesis directly."
      },
      {
        "sha": "6f75a43e62d6d2f23e181dfffec2d97d900caeaf",
        "filename": "src/init.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/init.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/init.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.h?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -57,9 +57,9 @@ bool AppInitLockDataDirectory();\n bool AppInitMain();\n \n /** The help message mode determines what help message to show */\n-enum HelpMessageMode {\n-    HMM_BITCOIND,\n-    HMM_BITCOIN_QT\n+enum class HelpMessageMode {\n+    BITCOIND,\n+    BITCOIN_QT\n };\n \n /** Help for options shared between UI and daemon (for -help) */"
      },
      {
        "sha": "dfdfa5ea9f11ed27918fad13587f3bc2ebd14152",
        "filename": "src/keystore.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/keystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/keystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -7,10 +7,6 @@\n \n #include <util.h>\n \n-bool CKeyStore::AddKey(const CKey &key) {\n-    return AddKeyPubKey(key, key.GetPubKey());\n-}\n-\n void CBasicKeyStore::ImplicitlyLearnRelatedKeyScripts(const CPubKey& pubkey)\n {\n     AssertLockHeld(cs_KeyStore);"
      },
      {
        "sha": "fa912cb195106a3241006a52be5a5b15d1c30a86",
        "filename": "src/keystore.h",
        "status": "modified",
        "additions": 5,
        "deletions": 10,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/keystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/keystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.h?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -9,35 +9,27 @@\n #include <key.h>\n #include <pubkey.h>\n #include <script/script.h>\n+#include <script/sign.h>\n #include <script/standard.h>\n #include <sync.h>\n \n #include <boost/signals2/signal.hpp>\n \n /** A virtual base class for key stores */\n-class CKeyStore\n+class CKeyStore : public SigningProvider\n {\n-protected:\n-    mutable CCriticalSection cs_KeyStore;\n-\n public:\n-    virtual ~CKeyStore() {}\n-\n     //! Add a key to the store.\n     virtual bool AddKeyPubKey(const CKey &key, const CPubKey &pubkey) =0;\n-    virtual bool AddKey(const CKey &key);\n \n     //! Check whether a key corresponding to a given address is present in the store.\n     virtual bool HaveKey(const CKeyID &address) const =0;\n-    virtual bool GetKey(const CKeyID &address, CKey& keyOut) const =0;\n     virtual std::set<CKeyID> GetKeys() const =0;\n-    virtual bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const =0;\n \n     //! Support for BIP 0013 : see https://github.com/bitcoin/bips/blob/master/bip-0013.mediawiki\n     virtual bool AddCScript(const CScript& redeemScript) =0;\n     virtual bool HaveCScript(const CScriptID &hash) const =0;\n     virtual std::set<CScriptID> GetCScripts() const =0;\n-    virtual bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const =0;\n \n     //! Support for Watch-only addresses\n     virtual bool AddWatchOnly(const CScript &dest) =0;\n@@ -55,6 +47,8 @@ typedef std::set<CScript> WatchOnlySet;\n class CBasicKeyStore : public CKeyStore\n {\n protected:\n+    mutable CCriticalSection cs_KeyStore;\n+\n     KeyMap mapKeys;\n     WatchKeyMap mapWatchKeys;\n     ScriptMap mapScripts;\n@@ -64,6 +58,7 @@ class CBasicKeyStore : public CKeyStore\n \n public:\n     bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey) override;\n+    bool AddKey(const CKey &key) { return AddKeyPubKey(key, key.GetPubKey()); }\n     bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override;\n     bool HaveKey(const CKeyID &address) const override;\n     std::set<CKeyID> GetKeys() const override;"
      },
      {
        "sha": "0660df928c28b35bf78593cd5f6a467495e122ed",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -68,9 +68,7 @@ BlockAssembler::BlockAssembler(const CChainParams& params, const Options& option\n static BlockAssembler::Options DefaultOptions(const CChainParams& params)\n {\n     // Block resource limits\n-    // If neither -blockmaxsize or -blockmaxweight is given, limit to DEFAULT_BLOCK_MAX_*\n-    // If only one is given, only restrict the specified resource.\n-    // If both are given, restrict both.\n+    // If -blockmaxweight is not given, limit to DEFAULT_BLOCK_MAX_WEIGHT\n     BlockAssembler::Options options;\n     options.nBlockMaxWeight = gArgs.GetArg(\"-blockmaxweight\", DEFAULT_BLOCK_MAX_WEIGHT);\n     if (gArgs.IsArgSet(\"-blockmintxfee\")) {"
      },
      {
        "sha": "7f80fc92c2e22415088a1d06ea9279057c3bf19d",
        "filename": "src/policy/fees.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/policy/fees.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/policy/fees.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.h?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -68,7 +68,7 @@ class TxConfirmStats;\n \n /* Identifier for each of the 3 different TxConfirmStats which will track\n  * history over different time horizons. */\n-enum FeeEstimateHorizon {\n+enum class FeeEstimateHorizon {\n     SHORT_HALFLIFE = 0,\n     MED_HALFLIFE = 1,\n     LONG_HALFLIFE = 2"
      },
      {
        "sha": "c3f65fb2ab9c7f769e528c75a62106bfd4d3cce4",
        "filename": "src/policy/policy.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/policy/policy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/policy/policy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -179,7 +179,7 @@ bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n         {\n             std::vector<std::vector<unsigned char> > stack;\n             // convert the scriptSig into a stack, so we can inspect the redeemScript\n-            if (!EvalScript(stack, tx.vin[i].scriptSig, SCRIPT_VERIFY_NONE, BaseSignatureChecker(), SIGVERSION_BASE))\n+            if (!EvalScript(stack, tx.vin[i].scriptSig, SCRIPT_VERIFY_NONE, BaseSignatureChecker(), SigVersion::BASE))\n                 return false;\n             if (stack.empty())\n                 return false;\n@@ -215,7 +215,7 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n             // If the scriptPubKey is P2SH, we try to extract the redeemScript casually by converting the scriptSig\n             // into a stack. We do not check IsPushOnly nor compare the hash as these will be done later anyway.\n             // If the check fails at this stage, we know that this txid must be a bad one.\n-            if (!EvalScript(stack, tx.vin[i].scriptSig, SCRIPT_VERIFY_NONE, BaseSignatureChecker(), SIGVERSION_BASE))\n+            if (!EvalScript(stack, tx.vin[i].scriptSig, SCRIPT_VERIFY_NONE, BaseSignatureChecker(), SigVersion::BASE))\n                 return false;\n             if (stack.empty())\n                 return false;"
      },
      {
        "sha": "81b2a7fadc5a8ad944a8a9bdeb52dcd6119cefc0",
        "filename": "src/policy/rbf.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/policy/rbf.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/policy/rbf.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/rbf.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -22,13 +22,13 @@ RBFTransactionState IsRBFOptIn(const CTransaction &tx, CTxMemPool &pool)\n \n     // First check the transaction itself.\n     if (SignalsOptInRBF(tx)) {\n-        return RBF_TRANSACTIONSTATE_REPLACEABLE_BIP125;\n+        return RBFTransactionState::REPLACEABLE_BIP125;\n     }\n \n     // If this transaction is not in our mempool, then we can't be sure\n     // we will know about all its inputs.\n     if (!pool.exists(tx.GetHash())) {\n-        return RBF_TRANSACTIONSTATE_UNKNOWN;\n+        return RBFTransactionState::UNKNOWN;\n     }\n \n     // If all the inputs have nSequence >= maxint-1, it still might be\n@@ -40,8 +40,8 @@ RBFTransactionState IsRBFOptIn(const CTransaction &tx, CTxMemPool &pool)\n \n     for (CTxMemPool::txiter it : setAncestors) {\n         if (SignalsOptInRBF(it->GetTx())) {\n-            return RBF_TRANSACTIONSTATE_REPLACEABLE_BIP125;\n+            return RBFTransactionState::REPLACEABLE_BIP125;\n         }\n     }\n-    return RBF_TRANSACTIONSTATE_FINAL;\n+    return RBFTransactionState::FINAL;\n }"
      },
      {
        "sha": "b10532addf3ed2c0ac96d5c0f6b446bb3c29baaa",
        "filename": "src/policy/rbf.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/policy/rbf.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/policy/rbf.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/rbf.h?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -9,10 +9,10 @@\n \n static const uint32_t MAX_BIP125_RBF_SEQUENCE = 0xfffffffd;\n \n-enum RBFTransactionState {\n-    RBF_TRANSACTIONSTATE_UNKNOWN,\n-    RBF_TRANSACTIONSTATE_REPLACEABLE_BIP125,\n-    RBF_TRANSACTIONSTATE_FINAL\n+enum class RBFTransactionState {\n+    UNKNOWN,\n+    REPLACEABLE_BIP125,\n+    FINAL\n };\n \n // Check whether the sequence numbers on this transaction are signaling"
      },
      {
        "sha": "f1298df8ca4f22b4913d37a091d9768fcc369d9c",
        "filename": "src/qt/bitcoin.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 12,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -251,7 +251,7 @@ public Q_SLOTS:\n     QTimer *pollShutdownTimer;\n #ifdef ENABLE_WALLET\n     PaymentServer* paymentServer;\n-    WalletModel *walletModel;\n+    std::vector<WalletModel*> m_wallet_models;\n #endif\n     int returnValue;\n     const PlatformStyle *platformStyle;\n@@ -333,7 +333,7 @@ BitcoinApplication::BitcoinApplication(int &argc, char **argv):\n     pollShutdownTimer(0),\n #ifdef ENABLE_WALLET\n     paymentServer(0),\n-    walletModel(0),\n+    m_wallet_models(),\n #endif\n     returnValue(0)\n {\n@@ -451,8 +451,10 @@ void BitcoinApplication::requestShutdown()\n \n #ifdef ENABLE_WALLET\n     window->removeAllWallets();\n-    delete walletModel;\n-    walletModel = 0;\n+    for (WalletModel *walletModel : m_wallet_models) {\n+        delete walletModel;\n+    }\n+    m_wallet_models.clear();\n #endif\n     delete clientModel;\n     clientModel = 0;\n@@ -481,16 +483,20 @@ void BitcoinApplication::initializeResult(bool success)\n         window->setClientModel(clientModel);\n \n #ifdef ENABLE_WALLET\n-        // TODO: Expose secondary wallets\n-        if (!vpwallets.empty())\n-        {\n-            walletModel = new WalletModel(platformStyle, vpwallets[0], optionsModel);\n+        bool fFirstWallet = true;\n+        for (CWalletRef pwallet : vpwallets) {\n+            WalletModel * const walletModel = new WalletModel(platformStyle, pwallet, optionsModel);\n \n-            window->addWallet(BitcoinGUI::DEFAULT_WALLET, walletModel);\n-            window->setCurrentWallet(BitcoinGUI::DEFAULT_WALLET);\n+            window->addWallet(walletModel);\n+            if (fFirstWallet) {\n+                window->setCurrentWallet(walletModel->getWalletName());\n+                fFirstWallet = false;\n+            }\n \n             connect(walletModel, SIGNAL(coinsSent(CWallet*,SendCoinsRecipient,QByteArray)),\n                              paymentServer, SLOT(fetchPaymentACK(CWallet*,const SendCoinsRecipient&,QByteArray)));\n+\n+            m_wallet_models.push_back(walletModel);\n         }\n #endif\n \n@@ -617,7 +623,7 @@ int main(int argc, char *argv[])\n     if (!Intro::pickDataDirectory())\n         return EXIT_SUCCESS;\n \n-    /// 6. Determine availability of data directory and parse bitcoin.conf\n+    /// 6. Determine availability of data and blocks directory and parse bitcoin.conf\n     /// - Do not call GetDataDir(true) before this step finishes\n     if (!fs::is_directory(GetDataDir(false)))\n     {\n@@ -690,7 +696,7 @@ int main(int argc, char *argv[])\n     // Allow parameter interaction before we create the options model\n     app.parameterSetup();\n     // Load GUI settings from QSettings\n-    app.createOptionsModel(gArgs.IsArgSet(\"-resetguisettings\"));\n+    app.createOptionsModel(gArgs.GetBoolArg(\"-resetguisettings\", false));\n \n     // Subscribe to global signals from core\n     uiInterface.InitMessage.connect(InitMessage);"
      },
      {
        "sha": "e4207fce99b8fe0e13d535f24559a59ca52dd43b",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 49,
        "deletions": 13,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -21,6 +21,7 @@\n #ifdef ENABLE_WALLET\n #include <qt/walletframe.h>\n #include <qt/walletmodel.h>\n+#include <qt/walletview.h>\n #endif // ENABLE_WALLET\n \n #ifdef Q_OS_MAC\n@@ -36,6 +37,7 @@\n \n #include <QAction>\n #include <QApplication>\n+#include <QComboBox>\n #include <QDateTime>\n #include <QDesktopWidget>\n #include <QDragEnterEvent>\n@@ -70,10 +72,6 @@ const std::string BitcoinGUI::DEFAULT_UIPLATFORM =\n #endif\n         ;\n \n-/** Display name for default wallet name. Uses tilde to avoid name\n- * collisions in the future with additional wallets */\n-const QString BitcoinGUI::DEFAULT_WALLET = \"~Default\";\n-\n BitcoinGUI::BitcoinGUI(const PlatformStyle *_platformStyle, const NetworkStyle *networkStyle, QWidget *parent) :\n     QMainWindow(parent),\n     enableWallet(false),\n@@ -88,6 +86,7 @@ BitcoinGUI::BitcoinGUI(const PlatformStyle *_platformStyle, const NetworkStyle *\n     progressBar(0),\n     progressDialog(0),\n     appMenuBar(0),\n+    appToolBar(0),\n     overviewAction(0),\n     historyAction(0),\n     quitAction(0),\n@@ -455,6 +454,7 @@ void BitcoinGUI::createToolBars()\n     if(walletFrame)\n     {\n         QToolBar *toolbar = addToolBar(tr(\"Tabs toolbar\"));\n+        appToolBar = toolbar;\n         toolbar->setContextMenuPolicy(Qt::PreventContextMenu);\n         toolbar->setMovable(false);\n         toolbar->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);\n@@ -463,6 +463,15 @@ void BitcoinGUI::createToolBars()\n         toolbar->addAction(receiveCoinsAction);\n         toolbar->addAction(historyAction);\n         overviewAction->setChecked(true);\n+\n+#ifdef ENABLE_WALLET\n+        QWidget *spacer = new QWidget();\n+        spacer->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);\n+        toolbar->addWidget(spacer);\n+\n+        m_wallet_selector = new QComboBox();\n+        connect(m_wallet_selector, SIGNAL(currentIndexChanged(const QString&)), this, SLOT(setCurrentWallet(const QString&)));\n+#endif\n     }\n }\n \n@@ -529,12 +538,22 @@ void BitcoinGUI::setClientModel(ClientModel *_clientModel)\n }\n \n #ifdef ENABLE_WALLET\n-bool BitcoinGUI::addWallet(const QString& name, WalletModel *walletModel)\n+bool BitcoinGUI::addWallet(WalletModel *walletModel)\n {\n     if(!walletFrame)\n         return false;\n+    const QString name = walletModel->getWalletName();\n     setWalletActionsEnabled(true);\n-    return walletFrame->addWallet(name, walletModel);\n+    m_wallet_selector->addItem(name);\n+    if (m_wallet_selector->count() == 2) {\n+        m_wallet_selector_label = new QLabel();\n+        m_wallet_selector_label->setText(tr(\"Wallet:\") + \" \");\n+        m_wallet_selector_label->setBuddy(m_wallet_selector);\n+        appToolBar->addWidget(m_wallet_selector_label);\n+        appToolBar->addWidget(m_wallet_selector);\n+    }\n+    rpcConsole->addWallet(walletModel);\n+    return walletFrame->addWallet(walletModel);\n }\n \n bool BitcoinGUI::setCurrentWallet(const QString& name)\n@@ -780,25 +799,25 @@ void BitcoinGUI::setNumBlocks(int count, const QDateTime& blockDate, double nVer\n     // Acquire current block source\n     enum BlockSource blockSource = clientModel->getBlockSource();\n     switch (blockSource) {\n-        case BLOCK_SOURCE_NETWORK:\n+        case BlockSource::NETWORK:\n             if (header) {\n                 updateHeadersSyncProgressLabel();\n                 return;\n             }\n             progressBarLabel->setText(tr(\"Synchronizing with network...\"));\n             updateHeadersSyncProgressLabel();\n             break;\n-        case BLOCK_SOURCE_DISK:\n+        case BlockSource::DISK:\n             if (header) {\n                 progressBarLabel->setText(tr(\"Indexing blocks on disk...\"));\n             } else {\n                 progressBarLabel->setText(tr(\"Processing blocks on disk...\"));\n             }\n             break;\n-        case BLOCK_SOURCE_REINDEX:\n+        case BlockSource::REINDEX:\n             progressBarLabel->setText(tr(\"Reindexing blocks on disk...\"));\n             break;\n-        case BLOCK_SOURCE_NONE:\n+        case BlockSource::NONE:\n             if (header) {\n                 return;\n             }\n@@ -983,12 +1002,15 @@ void BitcoinGUI::showEvent(QShowEvent *event)\n }\n \n #ifdef ENABLE_WALLET\n-void BitcoinGUI::incomingTransaction(const QString& date, int unit, const CAmount& amount, const QString& type, const QString& address, const QString& label)\n+void BitcoinGUI::incomingTransaction(const QString& date, int unit, const CAmount& amount, const QString& type, const QString& address, const QString& label, const QString& walletName)\n {\n     // On new transaction, make an info balloon\n     QString msg = tr(\"Date: %1\\n\").arg(date) +\n-                  tr(\"Amount: %1\\n\").arg(BitcoinUnits::formatWithUnit(unit, amount, true)) +\n-                  tr(\"Type: %1\\n\").arg(type);\n+                  tr(\"Amount: %1\\n\").arg(BitcoinUnits::formatWithUnit(unit, amount, true));\n+    if (WalletModel::isMultiwallet() && !walletName.isEmpty()) {\n+        msg += tr(\"Wallet: %1\\n\").arg(walletName);\n+    }\n+    msg += tr(\"Type: %1\\n\").arg(type);\n     if (!label.isEmpty())\n         msg += tr(\"Label: %1\\n\").arg(label);\n     else if (!address.isEmpty())\n@@ -1079,6 +1101,20 @@ void BitcoinGUI::setEncryptionStatus(int status)\n         break;\n     }\n }\n+\n+void BitcoinGUI::updateWalletStatus()\n+{\n+    if (!walletFrame) {\n+        return;\n+    }\n+    WalletView * const walletView = walletFrame->currentWalletView();\n+    if (!walletView) {\n+        return;\n+    }\n+    WalletModel * const walletModel = walletView->getWalletModel();\n+    setEncryptionStatus(walletModel->getEncryptionStatus());\n+    setHDStatus(walletModel->hdEnabled());\n+}\n #endif // ENABLE_WALLET\n \n void BitcoinGUI::showNormalIfMinimized(bool fToggleHidden)"
      },
      {
        "sha": "b9e92f2d5bafbfeaf21e9c303de5347f3796005c",
        "filename": "src/qt/bitcoingui.h",
        "status": "modified",
        "additions": 14,
        "deletions": 4,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/bitcoingui.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/bitcoingui.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.h?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -33,6 +33,7 @@ class ModalOverlay;\n \n QT_BEGIN_NAMESPACE\n class QAction;\n+class QComboBox;\n class QProgressBar;\n class QProgressDialog;\n QT_END_NAMESPACE\n@@ -46,7 +47,6 @@ class BitcoinGUI : public QMainWindow\n     Q_OBJECT\n \n public:\n-    static const QString DEFAULT_WALLET;\n     static const std::string DEFAULT_UIPLATFORM;\n \n     explicit BitcoinGUI(const PlatformStyle *platformStyle, const NetworkStyle *networkStyle, QWidget *parent = 0);\n@@ -62,8 +62,7 @@ class BitcoinGUI : public QMainWindow\n         The wallet model represents a bitcoin wallet, and offers access to the list of transactions, address book and sending\n         functionality.\n     */\n-    bool addWallet(const QString& name, WalletModel *walletModel);\n-    bool setCurrentWallet(const QString& name);\n+    bool addWallet(WalletModel *walletModel);\n     void removeAllWallets();\n #endif // ENABLE_WALLET\n     bool enableWallet;\n@@ -90,6 +89,7 @@ class BitcoinGUI : public QMainWindow\n     QProgressDialog *progressDialog;\n \n     QMenuBar *appMenuBar;\n+    QToolBar *appToolBar;\n     QAction *overviewAction;\n     QAction *historyAction;\n     QAction *quitAction;\n@@ -112,6 +112,9 @@ class BitcoinGUI : public QMainWindow\n     QAction *openAction;\n     QAction *showHelpMessageAction;\n \n+    QLabel *m_wallet_selector_label;\n+    QComboBox *m_wallet_selector;\n+\n     QSystemTrayIcon *trayIcon;\n     QMenu *trayIconMenu;\n     Notificator *notificator;\n@@ -171,6 +174,12 @@ public Q_SLOTS:\n     void message(const QString &title, const QString &message, unsigned int style, bool *ret = nullptr);\n \n #ifdef ENABLE_WALLET\n+    bool setCurrentWallet(const QString& name);\n+    /** Set the UI status indicators based on the currently selected wallet.\n+    */\n+    void updateWalletStatus();\n+\n+private:\n     /** Set the encryption status as shown in the UI.\n        @param[in] status            current encryption status\n        @see WalletModel::EncryptionStatus\n@@ -183,10 +192,11 @@ public Q_SLOTS:\n      */\n     void setHDStatus(int hdEnabled);\n \n+public Q_SLOTS:\n     bool handlePaymentRequest(const SendCoinsRecipient& recipient);\n \n     /** Show incoming transaction notification for new transactions. */\n-    void incomingTransaction(const QString& date, int unit, const CAmount& amount, const QString& type, const QString& address, const QString& label);\n+    void incomingTransaction(const QString& date, int unit, const CAmount& amount, const QString& type, const QString& address, const QString& label, const QString& walletName);\n #endif // ENABLE_WALLET\n \n private Q_SLOTS:"
      },
      {
        "sha": "40661d9ec313f1b07c5e1761681281968c86fbcb",
        "filename": "src/qt/clientmodel.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/clientmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/clientmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -177,13 +177,13 @@ bool ClientModel::inInitialBlockDownload() const\n enum BlockSource ClientModel::getBlockSource() const\n {\n     if (fReindex)\n-        return BLOCK_SOURCE_REINDEX;\n+        return BlockSource::REINDEX;\n     else if (fImporting)\n-        return BLOCK_SOURCE_DISK;\n+        return BlockSource::DISK;\n     else if (getNumConnections() > 0)\n-        return BLOCK_SOURCE_NETWORK;\n+        return BlockSource::NETWORK;\n \n-    return BLOCK_SOURCE_NONE;\n+    return BlockSource::NONE;\n }\n \n void ClientModel::setNetworkActive(bool active)"
      },
      {
        "sha": "1118bc31b347d2b4f5ed89f754bfce26542424d3",
        "filename": "src/qt/clientmodel.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/clientmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/clientmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.h?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -20,11 +20,11 @@ QT_BEGIN_NAMESPACE\n class QTimer;\n QT_END_NAMESPACE\n \n-enum BlockSource {\n-    BLOCK_SOURCE_NONE,\n-    BLOCK_SOURCE_REINDEX,\n-    BLOCK_SOURCE_DISK,\n-    BLOCK_SOURCE_NETWORK\n+enum class BlockSource {\n+    NONE,\n+    REINDEX,\n+    DISK,\n+    NETWORK\n };\n \n enum NumConnections {"
      },
      {
        "sha": "695ed61228a4007283da4f7d3be95b21be0c02e0",
        "filename": "src/qt/forms/debugwindow.ui",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/forms/debugwindow.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/forms/debugwindow.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/debugwindow.ui?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -412,6 +412,22 @@\n          <property name=\"spacing\">\n           <number>4</number>\n          </property>\n+         <item>\n+          <widget class=\"QLabel\" name=\"WalletSelectorLabel\">\n+           <property name=\"text\">\n+            <string>Wallet: </string>\n+           </property>\n+          </widget>\n+         </item>\n+         <item>\n+          <widget class=\"QComboBox\" name=\"WalletSelector\">\n+           <item>\n+            <property name=\"text\">\n+             <string>(none)</string>\n+            </property>\n+           </item>\n+          </widget>\n+         </item>\n          <item>\n           <spacer name=\"horizontalSpacer\">\n            <property name=\"orientation\">"
      },
      {
        "sha": "7b653a99da49fe5681003b4a0a4cef365ca589a9",
        "filename": "src/qt/guiutil.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 9,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/guiutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/guiutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -137,15 +137,6 @@ void setupAddressWidget(QValidatedLineEdit *widget, QWidget *parent)\n     widget->setCheckValidator(new BitcoinAddressCheckValidator(parent));\n }\n \n-void setupAmountWidget(QLineEdit *widget, QWidget *parent)\n-{\n-    QDoubleValidator *amountValidator = new QDoubleValidator(parent);\n-    amountValidator->setDecimals(8);\n-    amountValidator->setBottom(0.0);\n-    widget->setValidator(amountValidator);\n-    widget->setAlignment(Qt::AlignRight|Qt::AlignVCenter);\n-}\n-\n bool parseBitcoinURI(const QUrl &uri, SendCoinsRecipient *out)\n {\n     // return if URI is not valid or is no bitcoin: URI"
      },
      {
        "sha": "bbbeaf2c43d184621cd0b7c059e88aeffe9bc13d",
        "filename": "src/qt/guiutil.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/guiutil.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/guiutil.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.h?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -40,9 +40,8 @@ namespace GUIUtil\n     // Return a monospace font\n     QFont fixedPitchFont();\n \n-    // Set up widgets for address and amounts\n+    // Set up widget for address\n     void setupAddressWidget(QValidatedLineEdit *widget, QWidget *parent);\n-    void setupAmountWidget(QLineEdit *widget, QWidget *parent);\n \n     // Parse \"bitcoin:\" URI into recipient object, return true on successful parsing\n     bool parseBitcoinURI(const QUrl &uri, SendCoinsRecipient *out);"
      },
      {
        "sha": "c8b6366db054aa190a220fcfead4d8ab1bfe6ef6",
        "filename": "src/qt/receivecoinsdialog.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/receivecoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/receivecoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/receivecoinsdialog.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -153,7 +153,7 @@ void ReceiveCoinsDialog::on_receiveButton_clicked()\n         ui->reqAmount->value(), ui->reqMessage->text());\n     ReceiveRequestDialog *dialog = new ReceiveRequestDialog(this);\n     dialog->setAttribute(Qt::WA_DeleteOnClose);\n-    dialog->setModel(model->getOptionsModel());\n+    dialog->setModel(model);\n     dialog->setInfo(info);\n     dialog->show();\n     clear();\n@@ -166,7 +166,7 @@ void ReceiveCoinsDialog::on_recentRequestsView_doubleClicked(const QModelIndex &\n {\n     const RecentRequestsTableModel *submodel = model->getRecentRequestsTableModel();\n     ReceiveRequestDialog *dialog = new ReceiveRequestDialog(this);\n-    dialog->setModel(model->getOptionsModel());\n+    dialog->setModel(model);\n     dialog->setInfo(submodel->entry(index.row()).recipient);\n     dialog->setAttribute(Qt::WA_DeleteOnClose);\n     dialog->show();"
      },
      {
        "sha": "75146e22141b911508cbdb46de19e826f5b484a7",
        "filename": "src/qt/receiverequestdialog.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/receiverequestdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/receiverequestdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/receiverequestdialog.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -108,12 +108,12 @@ ReceiveRequestDialog::~ReceiveRequestDialog()\n     delete ui;\n }\n \n-void ReceiveRequestDialog::setModel(OptionsModel *_model)\n+void ReceiveRequestDialog::setModel(WalletModel *_model)\n {\n     this->model = _model;\n \n     if (_model)\n-        connect(_model, SIGNAL(displayUnitChanged(int)), this, SLOT(update()));\n+        connect(_model->getOptionsModel(), SIGNAL(displayUnitChanged(int)), this, SLOT(update()));\n \n     // update the display unit if necessary\n     update();\n@@ -143,11 +143,14 @@ void ReceiveRequestDialog::update()\n     html += \"<a href=\\\"\"+uri+\"\\\">\" + GUIUtil::HtmlEscape(uri) + \"</a><br>\";\n     html += \"<b>\"+tr(\"Address\")+\"</b>: \" + GUIUtil::HtmlEscape(info.address) + \"<br>\";\n     if(info.amount)\n-        html += \"<b>\"+tr(\"Amount\")+\"</b>: \" + BitcoinUnits::formatHtmlWithUnit(model->getDisplayUnit(), info.amount) + \"<br>\";\n+        html += \"<b>\"+tr(\"Amount\")+\"</b>: \" + BitcoinUnits::formatHtmlWithUnit(model->getOptionsModel()->getDisplayUnit(), info.amount) + \"<br>\";\n     if(!info.label.isEmpty())\n         html += \"<b>\"+tr(\"Label\")+\"</b>: \" + GUIUtil::HtmlEscape(info.label) + \"<br>\";\n     if(!info.message.isEmpty())\n         html += \"<b>\"+tr(\"Message\")+\"</b>: \" + GUIUtil::HtmlEscape(info.message) + \"<br>\";\n+    if(model->isMultiwallet()) {\n+        html += \"<b>\"+tr(\"Wallet\")+\"</b>: \" + GUIUtil::HtmlEscape(model->getWalletName()) + \"<br>\";\n+    }\n     ui->outUri->setText(html);\n \n #ifdef USE_QRCODE"
      },
      {
        "sha": "23c5529535c1938bdc211530fb8127fceda08722",
        "filename": "src/qt/receiverequestdialog.h",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/receiverequestdialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/receiverequestdialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/receiverequestdialog.h?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -12,8 +12,6 @@\n #include <QLabel>\n #include <QPainter>\n \n-class OptionsModel;\n-\n namespace Ui {\n     class ReceiveRequestDialog;\n }\n@@ -53,7 +51,7 @@ class ReceiveRequestDialog : public QDialog\n     explicit ReceiveRequestDialog(QWidget *parent = 0);\n     ~ReceiveRequestDialog();\n \n-    void setModel(OptionsModel *model);\n+    void setModel(WalletModel *model);\n     void setInfo(const SendCoinsRecipient &info);\n \n private Q_SLOTS:\n@@ -64,7 +62,7 @@ private Q_SLOTS:\n \n private:\n     Ui::ReceiveRequestDialog *ui;\n-    OptionsModel *model;\n+    WalletModel *model;\n     SendCoinsRecipient info;\n };\n "
      },
      {
        "sha": "c41e19f6f5dd275b7cc7c6fb91ddaa6fee9d28c4",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 48,
        "deletions": 10,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -12,6 +12,7 @@\n #include <qt/bantablemodel.h>\n #include <qt/clientmodel.h>\n #include <qt/platformstyle.h>\n+#include <qt/walletmodel.h>\n #include <chainparams.h>\n #include <netbase.h>\n #include <rpc/server.h>\n@@ -84,7 +85,7 @@ class RPCExecutor : public QObject\n     Q_OBJECT\n \n public Q_SLOTS:\n-    void request(const QString &command);\n+    void request(const QString &command, const QString &walletID);\n \n Q_SIGNALS:\n     void reply(int category, const QString &command);\n@@ -145,7 +146,7 @@ class QtRPCTimerInterface: public RPCTimerInterface\n  * @param[out]   pstrFilteredOut  Command line, filtered to remove any sensitive data\n  */\n \n-bool RPCConsole::RPCParseCommandLine(std::string &strResult, const std::string &strCommand, const bool fExecute, std::string * const pstrFilteredOut)\n+bool RPCConsole::RPCParseCommandLine(std::string &strResult, const std::string &strCommand, const bool fExecute, std::string * const pstrFilteredOut, const std::string *walletID)\n {\n     std::vector< std::vector<std::string> > stack;\n     stack.push_back(std::vector<std::string>());\n@@ -303,10 +304,8 @@ bool RPCConsole::RPCParseCommandLine(std::string &strResult, const std::string &\n                             req.params = RPCConvertValues(stack.back()[0], std::vector<std::string>(stack.back().begin() + 1, stack.back().end()));\n                             req.strMethod = stack.back()[0];\n #ifdef ENABLE_WALLET\n-                            // TODO: Move this logic to WalletModel\n-                            if (!vpwallets.empty()) {\n-                                // in Qt, use always the wallet with index 0 when running with multiple wallets\n-                                QByteArray encodedName = QUrl::toPercentEncoding(QString::fromStdString(vpwallets[0]->GetName()));\n+                            if (walletID && !walletID->empty()) {\n+                                QByteArray encodedName = QUrl::toPercentEncoding(QString::fromStdString(*walletID));\n                                 req.URI = \"/wallet/\"+std::string(encodedName.constData(), encodedName.length());\n                             }\n #endif\n@@ -385,7 +384,7 @@ bool RPCConsole::RPCParseCommandLine(std::string &strResult, const std::string &\n     }\n }\n \n-void RPCExecutor::request(const QString &command)\n+void RPCExecutor::request(const QString &command, const QString &walletID)\n {\n     try\n     {\n@@ -416,7 +415,8 @@ void RPCExecutor::request(const QString &command)\n                 \"   example:    getblock(getblockhash(0),true)[tx][0]\\n\\n\")));\n             return;\n         }\n-        if(!RPCConsole::RPCExecuteCommandLine(result, executableCommand))\n+        std::string wallet_id = walletID.toStdString();\n+        if(!RPCConsole::RPCExecuteCommandLine(result, executableCommand, nullptr, &wallet_id))\n         {\n             Q_EMIT reply(RPCConsole::CMD_ERROR, QString(\"Parse error: unbalanced ' or \\\"\"));\n             return;\n@@ -478,6 +478,10 @@ RPCConsole::RPCConsole(const PlatformStyle *_platformStyle, QWidget *parent) :\n     connect(ui->fontSmallerButton, SIGNAL(clicked()), this, SLOT(fontSmaller()));\n     connect(ui->btnClearTrafficGraph, SIGNAL(clicked()), ui->trafficGraph, SLOT(clear()));\n \n+    // disable the wallet selector by default\n+    ui->WalletSelector->setVisible(false);\n+    ui->WalletSelectorLabel->setVisible(false);\n+\n     // set library version labels\n #ifdef ENABLE_WALLET\n     ui->berkeleyDBVersion->setText(DbEnv::version(0, 0, 0));\n@@ -687,6 +691,23 @@ void RPCConsole::setClientModel(ClientModel *model)\n     }\n }\n \n+#ifdef ENABLE_WALLET\n+void RPCConsole::addWallet(WalletModel * const walletModel)\n+{\n+    const QString name = walletModel->getWalletName();\n+    // use name for text and internal data object (to allow to move to a wallet id later)\n+    ui->WalletSelector->addItem(name, name);\n+    if (ui->WalletSelector->count() == 2 && !isVisible()) {\n+        // First wallet added, set to default so long as the window isn't presently visible (and potentially in use)\n+        ui->WalletSelector->setCurrentIndex(1);\n+    }\n+    if (ui->WalletSelector->count() > 2) {\n+        ui->WalletSelector->setVisible(true);\n+        ui->WalletSelectorLabel->setVisible(true);\n+    }\n+}\n+#endif\n+\n static QString categoryClass(int category)\n {\n     switch(category)\n@@ -874,8 +895,25 @@ void RPCConsole::on_lineEdit_returnPressed()\n \n         cmdBeforeBrowsing = QString();\n \n+        QString walletID;\n+#ifdef ENABLE_WALLET\n+        const int wallet_index = ui->WalletSelector->currentIndex();\n+        if (wallet_index > 0) {\n+            walletID = (QString)ui->WalletSelector->itemData(wallet_index).value<QString>();\n+        }\n+\n+        if (m_last_wallet_id != walletID) {\n+            if (walletID.isEmpty()) {\n+                message(CMD_REQUEST, tr(\"Executing command without any wallet\"));\n+            } else {\n+                message(CMD_REQUEST, tr(\"Executing command using \\\"%1\\\" wallet\").arg(walletID));\n+            }\n+            m_last_wallet_id = walletID;\n+        }\n+#endif\n+\n         message(CMD_REQUEST, QString::fromStdString(strFilteredCmd));\n-        Q_EMIT cmdRequest(cmd);\n+        Q_EMIT cmdRequest(cmd, walletID);\n \n         cmd = QString::fromStdString(strFilteredCmd);\n \n@@ -923,7 +961,7 @@ void RPCConsole::startExecutor()\n     // Replies from executor object must go to this object\n     connect(executor, SIGNAL(reply(int,QString)), this, SLOT(message(int,QString)));\n     // Requests from this object must go to executor\n-    connect(this, SIGNAL(cmdRequest(QString)), executor, SLOT(request(QString)));\n+    connect(this, SIGNAL(cmdRequest(QString, QString)), executor, SLOT(request(QString, QString)));\n \n     // On stopExecutor signal\n     // - quit the Qt event loop in the execution thread"
      },
      {
        "sha": "c97260b2c36f879cebf83c33ee66157e9f577107",
        "filename": "src/qt/rpcconsole.h",
        "status": "modified",
        "additions": 7,
        "deletions": 4,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/rpcconsole.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/rpcconsole.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.h?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -17,6 +17,7 @@\n class ClientModel;\n class PlatformStyle;\n class RPCTimerInterface;\n+class WalletModel;\n \n namespace Ui {\n     class RPCConsole;\n@@ -36,12 +37,13 @@ class RPCConsole: public QWidget\n     explicit RPCConsole(const PlatformStyle *platformStyle, QWidget *parent);\n     ~RPCConsole();\n \n-    static bool RPCParseCommandLine(std::string &strResult, const std::string &strCommand, bool fExecute, std::string * const pstrFilteredOut = nullptr);\n-    static bool RPCExecuteCommandLine(std::string &strResult, const std::string &strCommand, std::string * const pstrFilteredOut = nullptr) {\n-        return RPCParseCommandLine(strResult, strCommand, true, pstrFilteredOut);\n+    static bool RPCParseCommandLine(std::string &strResult, const std::string &strCommand, bool fExecute, std::string * const pstrFilteredOut = nullptr, const std::string *walletID = nullptr);\n+    static bool RPCExecuteCommandLine(std::string &strResult, const std::string &strCommand, std::string * const pstrFilteredOut = nullptr, const std::string *walletID = nullptr) {\n+        return RPCParseCommandLine(strResult, strCommand, true, pstrFilteredOut, walletID);\n     }\n \n     void setClientModel(ClientModel *model);\n+    void addWallet(WalletModel * const walletModel);\n \n     enum MessageClass {\n         MC_ERROR,\n@@ -120,7 +122,7 @@ public Q_SLOTS:\n Q_SIGNALS:\n     // For RPC command executor\n     void stopExecutor();\n-    void cmdRequest(const QString &command);\n+    void cmdRequest(const QString &command, const QString &walletID);\n \n private:\n     void startExecutor();\n@@ -151,6 +153,7 @@ public Q_SLOTS:\n     int consoleFontSize;\n     QCompleter *autoCompleter;\n     QThread thread;\n+    QString m_last_wallet_id;\n \n     /** Update UI with latest network info from model. */\n     void updateNetworkState();"
      },
      {
        "sha": "8a52aadbb0d99579304c91e8f8fed31139122510",
        "filename": "src/qt/sendcoinsdialog.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/sendcoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/sendcoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -277,8 +277,11 @@ void SendCoinsDialog::on_sendButton_clicked()\n     QStringList formatted;\n     for (const SendCoinsRecipient &rcp : currentTransaction.getRecipients())\n     {\n-        // generate bold amount string\n+        // generate bold amount string with wallet name in case of multiwallet\n         QString amount = \"<b>\" + BitcoinUnits::formatHtmlWithUnit(model->getOptionsModel()->getDisplayUnit(), rcp.amount);\n+        if (model->isMultiwallet()) {\n+            amount.append(\" <u>\"+tr(\"from wallet %1\").arg(GUIUtil::HtmlEscape(model->getWalletName()))+\"</u> \");\n+        }\n         amount.append(\"</b>\");\n         // generate monospace address string\n         QString address = \"<span style='font-family: monospace;'>\" + rcp.address;"
      },
      {
        "sha": "b4483f27d55cd64efca030c0cc7077ee4110215b",
        "filename": "src/qt/utilitydialog.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/utilitydialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/utilitydialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/utilitydialog.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -77,7 +77,7 @@ HelpMessageDialog::HelpMessageDialog(QWidget *parent, bool about) :\n         cursor.insertText(header);\n         cursor.insertBlock();\n \n-        std::string strUsage = HelpMessage(HMM_BITCOIN_QT);\n+        std::string strUsage = HelpMessage(HelpMessageMode::BITCOIN_QT);\n         const bool showDebug = gArgs.GetBoolArg(\"-help-debug\", false);\n         strUsage += HelpMessageGroup(tr(\"UI Options:\").toStdString());\n         if (showDebug) {"
      },
      {
        "sha": "5b13353d7bfc37cb654329381c8fe3332f40efab",
        "filename": "src/qt/walletframe.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 2,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/walletframe.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/walletframe.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletframe.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -3,6 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <qt/walletframe.h>\n+#include <qt/walletmodel.h>\n \n #include <qt/bitcoingui.h>\n #include <qt/walletview.h>\n@@ -39,10 +40,16 @@ void WalletFrame::setClientModel(ClientModel *_clientModel)\n     this->clientModel = _clientModel;\n }\n \n-bool WalletFrame::addWallet(const QString& name, WalletModel *walletModel)\n+bool WalletFrame::addWallet(WalletModel *walletModel)\n {\n-    if (!gui || !clientModel || !walletModel || mapWalletViews.count(name) > 0)\n+    if (!gui || !clientModel || !walletModel) {\n         return false;\n+    }\n+\n+    const QString name = walletModel->getWalletName();\n+    if (mapWalletViews.count(name) > 0) {\n+        return false;\n+    }\n \n     WalletView *walletView = new WalletView(platformStyle, this);\n     walletView->setBitcoinGUI(gui);"
      },
      {
        "sha": "6eedcf370c60c0a6046e5070a164367d471464ed",
        "filename": "src/qt/walletframe.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/walletframe.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/walletframe.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletframe.h?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -36,7 +36,7 @@ class WalletFrame : public QFrame\n \n     void setClientModel(ClientModel *clientModel);\n \n-    bool addWallet(const QString& name, WalletModel *walletModel);\n+    bool addWallet(WalletModel *walletModel);\n     bool setCurrentWallet(const QString& name);\n     bool removeWallet(const QString &name);\n     void removeAllWallets();\n@@ -59,6 +59,7 @@ class WalletFrame : public QFrame\n \n     const PlatformStyle *platformStyle;\n \n+public:\n     WalletView *currentWalletView();\n \n public Q_SLOTS:"
      },
      {
        "sha": "795302be587028ce3886fdaaaa2004caeea2bbdf",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 2,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -110,8 +110,9 @@ void WalletModel::updateStatus()\n {\n     EncryptionStatus newEncryptionStatus = getEncryptionStatus();\n \n-    if(cachedEncryptionStatus != newEncryptionStatus)\n-        Q_EMIT encryptionStatusChanged(newEncryptionStatus);\n+    if(cachedEncryptionStatus != newEncryptionStatus) {\n+        Q_EMIT encryptionStatusChanged();\n+    }\n }\n \n void WalletModel::pollBalanceChanged()\n@@ -743,3 +744,14 @@ int WalletModel::getDefaultConfirmTarget() const\n {\n     return nTxConfirmTarget;\n }\n+\n+QString WalletModel::getWalletName() const\n+{\n+    LOCK(wallet->cs_wallet);\n+    return QString::fromStdString(wallet->GetName());\n+}\n+\n+bool WalletModel::isMultiwallet()\n+{\n+    return gArgs.GetArgs(\"-wallet\").size() > 1;\n+}"
      },
      {
        "sha": "ff4b38a804a45b300f91346f7a284638ba126510",
        "filename": "src/qt/walletmodel.h",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/walletmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/walletmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.h?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -136,6 +136,8 @@ class WalletModel : public QObject\n     TransactionTableModel *getTransactionTableModel();\n     RecentRequestsTableModel *getRecentRequestsTableModel();\n \n+    CWallet *getWallet() const { return wallet; };\n+\n     CAmount getBalance(const CCoinControl *coinControl = nullptr) const;\n     CAmount getUnconfirmedBalance() const;\n     CAmount getImmatureBalance() const;\n@@ -225,6 +227,9 @@ class WalletModel : public QObject\n \n     int getDefaultConfirmTarget() const;\n \n+    QString getWalletName() const;\n+\n+    static bool isMultiwallet();\n private:\n     CWallet *wallet;\n     bool fHaveWatchOnly;\n@@ -260,7 +265,7 @@ class WalletModel : public QObject\n                         const CAmount& watchOnlyBalance, const CAmount& watchUnconfBalance, const CAmount& watchImmatureBalance);\n \n     // Encryption status of wallet changed\n-    void encryptionStatusChanged(int status);\n+    void encryptionStatusChanged();\n \n     // Signal emitted when wallet needs to be unlocked\n     // It is valid behaviour for listeners to keep the wallet locked after this signal;"
      },
      {
        "sha": "cc4300a7a1766447af1391ad9173280c63a4fadd",
        "filename": "src/qt/walletview.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/walletview.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/walletview.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletview.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -101,13 +101,13 @@ void WalletView::setBitcoinGUI(BitcoinGUI *gui)\n         connect(this, SIGNAL(message(QString,QString,unsigned int)), gui, SLOT(message(QString,QString,unsigned int)));\n \n         // Pass through encryption status changed signals\n-        connect(this, SIGNAL(encryptionStatusChanged(int)), gui, SLOT(setEncryptionStatus(int)));\n+        connect(this, SIGNAL(encryptionStatusChanged()), gui, SLOT(updateWalletStatus()));\n \n         // Pass through transaction notifications\n-        connect(this, SIGNAL(incomingTransaction(QString,int,CAmount,QString,QString,QString)), gui, SLOT(incomingTransaction(QString,int,CAmount,QString,QString,QString)));\n+        connect(this, SIGNAL(incomingTransaction(QString,int,CAmount,QString,QString,QString,QString)), gui, SLOT(incomingTransaction(QString,int,CAmount,QString,QString,QString,QString)));\n \n         // Connect HD enabled state signal \n-        connect(this, SIGNAL(hdEnabledStatusChanged(int)), gui, SLOT(setHDStatus(int)));\n+        connect(this, SIGNAL(hdEnabledStatusChanged()), gui, SLOT(updateWalletStatus()));\n     }\n }\n \n@@ -137,11 +137,11 @@ void WalletView::setWalletModel(WalletModel *_walletModel)\n         connect(_walletModel, SIGNAL(message(QString,QString,unsigned int)), this, SIGNAL(message(QString,QString,unsigned int)));\n \n         // Handle changes in encryption status\n-        connect(_walletModel, SIGNAL(encryptionStatusChanged(int)), this, SIGNAL(encryptionStatusChanged(int)));\n+        connect(_walletModel, SIGNAL(encryptionStatusChanged()), this, SIGNAL(encryptionStatusChanged()));\n         updateEncryptionStatus();\n \n         // update HD status\n-        Q_EMIT hdEnabledStatusChanged(_walletModel->hdEnabled());\n+        Q_EMIT hdEnabledStatusChanged();\n \n         // Balloon pop-up for new transaction\n         connect(_walletModel->getTransactionTableModel(), SIGNAL(rowsInserted(QModelIndex,int,int)),\n@@ -172,7 +172,7 @@ void WalletView::processNewTransaction(const QModelIndex& parent, int start, int\n     QString address = ttm->data(index, TransactionTableModel::AddressRole).toString();\n     QString label = ttm->data(index, TransactionTableModel::LabelRole).toString();\n \n-    Q_EMIT incomingTransaction(date, walletModel->getOptionsModel()->getDisplayUnit(), amount, type, address, label);\n+    Q_EMIT incomingTransaction(date, walletModel->getOptionsModel()->getDisplayUnit(), amount, type, address, label, walletModel->getWalletName());\n }\n \n void WalletView::gotoOverviewPage()\n@@ -234,7 +234,7 @@ void WalletView::showOutOfSyncWarning(bool fShow)\n \n void WalletView::updateEncryptionStatus()\n {\n-    Q_EMIT encryptionStatusChanged(walletModel->getEncryptionStatus());\n+    Q_EMIT encryptionStatusChanged();\n }\n \n void WalletView::encryptWallet(bool status)"
      },
      {
        "sha": "878a5966d607dde258f295b9527e0864d847a195",
        "filename": "src/qt/walletview.h",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/walletview.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/qt/walletview.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletview.h?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -44,6 +44,7 @@ class WalletView : public QStackedWidget\n         The client model represents the part of the core that communicates with the P2P network, and is wallet-agnostic.\n     */\n     void setClientModel(ClientModel *clientModel);\n+    WalletModel *getWalletModel() { return walletModel; }\n     /** Set the wallet model.\n         The wallet model represents a bitcoin wallet, and offers access to the list of transactions, address book and sending\n         functionality.\n@@ -119,11 +120,11 @@ public Q_SLOTS:\n     /**  Fired when a message should be reported to the user */\n     void message(const QString &title, const QString &message, unsigned int style);\n     /** Encryption status of wallet changed */\n-    void encryptionStatusChanged(int status);\n+    void encryptionStatusChanged();\n     /** HD-Enabled status of wallet changed (only possible during startup) */\n-    void hdEnabledStatusChanged(int hdEnabled);\n+    void hdEnabledStatusChanged();\n     /** Notify that a new transaction appeared */\n-    void incomingTransaction(const QString& date, int unit, const CAmount& amount, const QString& type, const QString& address, const QString& label);\n+    void incomingTransaction(const QString& date, int unit, const CAmount& amount, const QString& type, const QString& address, const QString& label, const QString& walletName);\n     /** Notify that the out of sync warning icon has been pressed */\n     void outOfSyncWarningClicked();\n };"
      },
      {
        "sha": "5871b554a6ae2c0bd8056a2480942b89ccd2a802",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 47,
        "deletions": 45,
        "changes": 92,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -24,21 +24,21 @@\n \n static const size_t MAX_GETUTXOS_OUTPOINTS = 15; //allow a max of 15 outpoints to be queried at once\n \n-enum RetFormat {\n-    RF_UNDEF,\n-    RF_BINARY,\n-    RF_HEX,\n-    RF_JSON,\n+enum class RetFormat {\n+    UNDEF,\n+    BINARY,\n+    HEX,\n+    JSON,\n };\n \n static const struct {\n     enum RetFormat rf;\n     const char* name;\n } rf_names[] = {\n-      {RF_UNDEF, \"\"},\n-      {RF_BINARY, \"bin\"},\n-      {RF_HEX, \"hex\"},\n-      {RF_JSON, \"json\"},\n+      {RetFormat::UNDEF, \"\"},\n+      {RetFormat::BINARY, \"bin\"},\n+      {RetFormat::HEX, \"hex\"},\n+      {RetFormat::JSON, \"json\"},\n };\n \n struct CCoin {\n@@ -162,20 +162,20 @@ static bool rest_headers(HTTPRequest* req,\n     }\n \n     switch (rf) {\n-    case RF_BINARY: {\n+    case RetFormat::BINARY: {\n         std::string binaryHeader = ssHeader.str();\n         req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n         req->WriteReply(HTTP_OK, binaryHeader);\n         return true;\n     }\n \n-    case RF_HEX: {\n+    case RetFormat::HEX: {\n         std::string strHex = HexStr(ssHeader.begin(), ssHeader.end()) + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"text/plain\");\n         req->WriteReply(HTTP_OK, strHex);\n         return true;\n     }\n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         UniValue jsonHeaders(UniValue::VARR);\n         {\n             LOCK(cs_main);\n@@ -227,21 +227,21 @@ static bool rest_block(HTTPRequest* req,\n     ssBlock << block;\n \n     switch (rf) {\n-    case RF_BINARY: {\n+    case RetFormat::BINARY: {\n         std::string binaryBlock = ssBlock.str();\n         req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n         req->WriteReply(HTTP_OK, binaryBlock);\n         return true;\n     }\n \n-    case RF_HEX: {\n+    case RetFormat::HEX: {\n         std::string strHex = HexStr(ssBlock.begin(), ssBlock.end()) + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"text/plain\");\n         req->WriteReply(HTTP_OK, strHex);\n         return true;\n     }\n \n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         UniValue objBlock;\n         {\n             LOCK(cs_main);\n@@ -280,7 +280,7 @@ static bool rest_chaininfo(HTTPRequest* req, const std::string& strURIPart)\n     const RetFormat rf = ParseDataFormat(param, strURIPart);\n \n     switch (rf) {\n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         JSONRPCRequest jsonRequest;\n         jsonRequest.params = UniValue(UniValue::VARR);\n         UniValue chainInfoObject = getblockchaininfo(jsonRequest);\n@@ -303,7 +303,7 @@ static bool rest_mempool_info(HTTPRequest* req, const std::string& strURIPart)\n     const RetFormat rf = ParseDataFormat(param, strURIPart);\n \n     switch (rf) {\n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         UniValue mempoolInfoObject = mempoolInfoToJSON();\n \n         std::string strJSON = mempoolInfoObject.write() + \"\\n\";\n@@ -325,7 +325,7 @@ static bool rest_mempool_contents(HTTPRequest* req, const std::string& strURIPar\n     const RetFormat rf = ParseDataFormat(param, strURIPart);\n \n     switch (rf) {\n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         UniValue mempoolObject = mempoolToJSON(true);\n \n         std::string strJSON = mempoolObject.write() + \"\\n\";\n@@ -359,21 +359,21 @@ static bool rest_tx(HTTPRequest* req, const std::string& strURIPart)\n     ssTx << tx;\n \n     switch (rf) {\n-    case RF_BINARY: {\n+    case RetFormat::BINARY: {\n         std::string binaryTx = ssTx.str();\n         req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n         req->WriteReply(HTTP_OK, binaryTx);\n         return true;\n     }\n \n-    case RF_HEX: {\n+    case RetFormat::HEX: {\n         std::string strHex = HexStr(ssTx.begin(), ssTx.end()) + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"text/plain\");\n         req->WriteReply(HTTP_OK, strHex);\n         return true;\n     }\n \n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         UniValue objTx(UniValue::VOBJ);\n         TxToUniv(*tx, hashBlock, objTx);\n         std::string strJSON = objTx.write() + \"\\n\";\n@@ -440,13 +440,13 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n     }\n \n     switch (rf) {\n-    case RF_HEX: {\n+    case RetFormat::HEX: {\n         // convert hex to bin, continue then with bin part\n         std::vector<unsigned char> strRequestV = ParseHex(strRequestMutable);\n         strRequestMutable.assign(strRequestV.begin(), strRequestV.end());\n     }\n \n-    case RF_BINARY: {\n+    case RetFormat::BINARY: {\n         try {\n             //deserialize only if user sent a request\n             if (strRequestMutable.size() > 0)\n@@ -466,7 +466,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n         break;\n     }\n \n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         if (!fInputParsed)\n             return RESTERR(req, HTTP_BAD_REQUEST, \"Error: empty request\");\n         break;\n@@ -487,33 +487,35 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n     std::vector<bool> hits;\n     bitmap.resize((vOutPoints.size() + 7) / 8);\n     {\n-        LOCK2(cs_main, mempool.cs);\n-\n-        CCoinsView viewDummy;\n-        CCoinsViewCache view(&viewDummy);\n-\n-        CCoinsViewCache& viewChain = *pcoinsTip;\n-        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n-\n-        if (fCheckMemPool)\n-            view.SetBackend(viewMempool); // switch cache backend to db+mempool in case user likes to query mempool\n-\n-        for (size_t i = 0; i < vOutPoints.size(); i++) {\n-            bool hit = false;\n-            Coin coin;\n-            if (view.GetCoin(vOutPoints[i], coin) && !mempool.isSpent(vOutPoints[i])) {\n-                hit = true;\n-                outs.emplace_back(std::move(coin));\n+        auto process_utxos = [&vOutPoints, &outs, &hits](const CCoinsView& view, const CTxMemPool& mempool) {\n+            for (const COutPoint& vOutPoint : vOutPoints) {\n+                Coin coin;\n+                bool hit = !mempool.isSpent(vOutPoint) && view.GetCoin(vOutPoint, coin);\n+                hits.push_back(hit);\n+                if (hit) outs.emplace_back(std::move(coin));\n             }\n+        };\n+\n+        if (fCheckMemPool) {\n+            // use db+mempool as cache backend in case user likes to query mempool\n+            LOCK2(cs_main, mempool.cs);\n+            CCoinsViewCache& viewChain = *pcoinsTip;\n+            CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+            process_utxos(viewMempool, mempool);\n+        } else {\n+            LOCK(cs_main);  // no need to lock mempool!\n+            process_utxos(*pcoinsTip, CTxMemPool());\n+        }\n \n-            hits.push_back(hit);\n+        for (size_t i = 0; i < hits.size(); ++i) {\n+            const bool hit = hits[i];\n             bitmapStringRepresentation.append(hit ? \"1\" : \"0\"); // form a binary string representation (human-readable for json output)\n             bitmap[i / 8] |= ((uint8_t)hit) << (i % 8);\n         }\n     }\n \n     switch (rf) {\n-    case RF_BINARY: {\n+    case RetFormat::BINARY: {\n         // serialize data\n         // use exact same output as mentioned in Bip64\n         CDataStream ssGetUTXOResponse(SER_NETWORK, PROTOCOL_VERSION);\n@@ -525,7 +527,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n         return true;\n     }\n \n-    case RF_HEX: {\n+    case RetFormat::HEX: {\n         CDataStream ssGetUTXOResponse(SER_NETWORK, PROTOCOL_VERSION);\n         ssGetUTXOResponse << chainActive.Height() << chainActive.Tip()->GetBlockHash() << bitmap << outs;\n         std::string strHex = HexStr(ssGetUTXOResponse.begin(), ssGetUTXOResponse.end()) + \"\\n\";\n@@ -535,7 +537,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n         return true;\n     }\n \n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         UniValue objGetUTXOResponse(UniValue::VOBJ);\n \n         // pack in some essentials"
      },
      {
        "sha": "e15dad2f0bf653f3f98217d6e60ca010496e437a",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -1120,20 +1120,20 @@ static UniValue BIP9SoftForkDesc(const Consensus::Params& consensusParams, Conse\n     UniValue rv(UniValue::VOBJ);\n     const ThresholdState thresholdState = VersionBitsTipState(consensusParams, id);\n     switch (thresholdState) {\n-    case THRESHOLD_DEFINED: rv.pushKV(\"status\", \"defined\"); break;\n-    case THRESHOLD_STARTED: rv.pushKV(\"status\", \"started\"); break;\n-    case THRESHOLD_LOCKED_IN: rv.pushKV(\"status\", \"locked_in\"); break;\n-    case THRESHOLD_ACTIVE: rv.pushKV(\"status\", \"active\"); break;\n-    case THRESHOLD_FAILED: rv.pushKV(\"status\", \"failed\"); break;\n+    case ThresholdState::DEFINED: rv.pushKV(\"status\", \"defined\"); break;\n+    case ThresholdState::STARTED: rv.pushKV(\"status\", \"started\"); break;\n+    case ThresholdState::LOCKED_IN: rv.pushKV(\"status\", \"locked_in\"); break;\n+    case ThresholdState::ACTIVE: rv.pushKV(\"status\", \"active\"); break;\n+    case ThresholdState::FAILED: rv.pushKV(\"status\", \"failed\"); break;\n     }\n-    if (THRESHOLD_STARTED == thresholdState)\n+    if (ThresholdState::STARTED == thresholdState)\n     {\n         rv.pushKV(\"bit\", consensusParams.vDeployments[id].bit);\n     }\n     rv.pushKV(\"startTime\", consensusParams.vDeployments[id].nStartTime);\n     rv.pushKV(\"timeout\", consensusParams.vDeployments[id].nTimeout);\n     rv.pushKV(\"since\", VersionBitsTipStateSinceHeight(consensusParams, id));\n-    if (THRESHOLD_STARTED == thresholdState)\n+    if (ThresholdState::STARTED == thresholdState)\n     {\n         UniValue statsUV(UniValue::VOBJ);\n         BIP9Stats statsStruct = VersionBitsTipStatistics(consensusParams, id);"
      },
      {
        "sha": "06882c0dfdd29347ccc2c459616b802f91609464",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -532,7 +532,7 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n     pblock->nNonce = 0;\n \n     // NOTE: If at some point we support pre-segwit miners post-segwit-activation, this needs to take segwit support into consideration\n-    const bool fPreSegWit = (THRESHOLD_ACTIVE != VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_SEGWIT, versionbitscache));\n+    const bool fPreSegWit = (ThresholdState::ACTIVE != VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_SEGWIT, versionbitscache));\n \n     UniValue aCaps(UniValue::VARR); aCaps.push_back(\"proposal\");\n \n@@ -593,15 +593,15 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n         Consensus::DeploymentPos pos = Consensus::DeploymentPos(j);\n         ThresholdState state = VersionBitsState(pindexPrev, consensusParams, pos, versionbitscache);\n         switch (state) {\n-            case THRESHOLD_DEFINED:\n-            case THRESHOLD_FAILED:\n+            case ThresholdState::DEFINED:\n+            case ThresholdState::FAILED:\n                 // Not exposed to GBT at all\n                 break;\n-            case THRESHOLD_LOCKED_IN:\n+            case ThresholdState::LOCKED_IN:\n                 // Ensure bit is set in block version\n                 pblock->nVersion |= VersionBitsMask(consensusParams, pos);\n                 // FALL THROUGH to get vbavailable set...\n-            case THRESHOLD_STARTED:\n+            case ThresholdState::STARTED:\n             {\n                 const struct VBDeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\n                 vbavailable.pushKV(gbt_vb_name(pos), consensusParams.vDeployments[pos].bit);\n@@ -613,7 +613,7 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n                 }\n                 break;\n             }\n-            case THRESHOLD_ACTIVE:\n+            case ThresholdState::ACTIVE:\n             {\n                 // Add to rules only\n                 const struct VBDeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];"
      },
      {
        "sha": "c7c3b1f0d372d97df0395047471c2bfc7b1c2de6",
        "filename": "src/rpc/server.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/rpc/server.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/rpc/server.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -367,7 +367,11 @@ void JSONRPCRequest::parse(const UniValue& valRequest)\n     if (!valMethod.isStr())\n         throw JSONRPCError(RPC_INVALID_REQUEST, \"Method must be a string\");\n     strMethod = valMethod.get_str();\n-    LogPrint(BCLog::RPC, \"ThreadRPCServer method=%s\\n\", SanitizeString(strMethod));\n+    if (fLogIPs)\n+        LogPrint(BCLog::RPC, \"ThreadRPCServer method=%s user=%s peeraddr=%s\\n\", SanitizeString(strMethod),\n+            this->authUser, this->peerAddr);\n+    else\n+        LogPrint(BCLog::RPC, \"ThreadRPCServer method=%s user=%s\\n\", SanitizeString(strMethod), this->authUser);\n \n     // Parse params\n     UniValue valParams = find_value(request, \"params\");"
      },
      {
        "sha": "7fc300f554cbaa3913f1ae7f818e1d4a77869de6",
        "filename": "src/rpc/server.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/rpc/server.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/rpc/server.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.h?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -45,6 +45,7 @@ class JSONRPCRequest\n     bool fHelp;\n     std::string URI;\n     std::string authUser;\n+    std::string peerAddr;\n \n     JSONRPCRequest() : id(NullUniValue), params(NullUniValue), fHelp(false) {}\n     void parse(const UniValue& valRequest);"
      },
      {
        "sha": "07b2292d461a462beab7fe866ea8733bfc48daf7",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -219,7 +219,7 @@ bool static CheckPubKeyEncoding(const valtype &vchPubKey, unsigned int flags, co\n         return set_error(serror, SCRIPT_ERR_PUBKEYTYPE);\n     }\n     // Only compressed keys are accepted in segwit\n-    if ((flags & SCRIPT_VERIFY_WITNESS_PUBKEYTYPE) != 0 && sigversion == SIGVERSION_WITNESS_V0 && !IsCompressedPubKey(vchPubKey)) {\n+    if ((flags & SCRIPT_VERIFY_WITNESS_PUBKEYTYPE) != 0 && sigversion == SigVersion::WITNESS_V0 && !IsCompressedPubKey(vchPubKey)) {\n         return set_error(serror, SCRIPT_ERR_WITNESS_PUBKEYTYPE);\n     }\n     return true;\n@@ -443,7 +443,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                         if (stack.size() < 1)\n                             return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);\n                         valtype& vch = stacktop(-1);\n-                        if (sigversion == SIGVERSION_WITNESS_V0 && (flags & SCRIPT_VERIFY_MINIMALIF)) {\n+                        if (sigversion == SigVersion::WITNESS_V0 && (flags & SCRIPT_VERIFY_MINIMALIF)) {\n                             if (vch.size() > 1)\n                                 return set_error(serror, SCRIPT_ERR_MINIMALIF);\n                             if (vch.size() == 1 && vch[0] != 1)\n@@ -890,7 +890,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                     CScript scriptCode(pbegincodehash, pend);\n \n                     // Drop the signature in pre-segwit scripts but not segwit scripts\n-                    if (sigversion == SIGVERSION_BASE) {\n+                    if (sigversion == SigVersion::BASE) {\n                         scriptCode.FindAndDelete(CScript(vchSig));\n                     }\n \n@@ -954,7 +954,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                     for (int k = 0; k < nSigsCount; k++)\n                     {\n                         valtype& vchSig = stacktop(-isig-k);\n-                        if (sigversion == SIGVERSION_BASE) {\n+                        if (sigversion == SigVersion::BASE) {\n                             scriptCode.FindAndDelete(CScript(vchSig));\n                         }\n                     }\n@@ -1182,7 +1182,7 @@ uint256 SignatureHash(const CScript& scriptCode, const CTransaction& txTo, unsig\n {\n     assert(nIn < txTo.vin.size());\n \n-    if (sigversion == SIGVERSION_WITNESS_V0) {\n+    if (sigversion == SigVersion::WITNESS_V0) {\n         uint256 hashPrevouts;\n         uint256 hashSequence;\n         uint256 hashOutputs;\n@@ -1396,7 +1396,7 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n             return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n     }\n \n-    if (!EvalScript(stack, scriptPubKey, flags, checker, SIGVERSION_WITNESS_V0, serror)) {\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, SigVersion::WITNESS_V0, serror)) {\n         return false;\n     }\n \n@@ -1423,12 +1423,12 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n     }\n \n     std::vector<std::vector<unsigned char> > stack, stackCopy;\n-    if (!EvalScript(stack, scriptSig, flags, checker, SIGVERSION_BASE, serror))\n+    if (!EvalScript(stack, scriptSig, flags, checker, SigVersion::BASE, serror))\n         // serror is set\n         return false;\n     if (flags & SCRIPT_VERIFY_P2SH)\n         stackCopy = stack;\n-    if (!EvalScript(stack, scriptPubKey, flags, checker, SIGVERSION_BASE, serror))\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, SigVersion::BASE, serror))\n         // serror is set\n         return false;\n     if (stack.empty())\n@@ -1474,7 +1474,7 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n         CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end());\n         popstack(stack);\n \n-        if (!EvalScript(stack, pubKey2, flags, checker, SIGVERSION_BASE, serror))\n+        if (!EvalScript(stack, pubKey2, flags, checker, SigVersion::BASE, serror))\n             // serror is set\n             return false;\n         if (stack.empty())"
      },
      {
        "sha": "bb7750d78346d1ae354333997c740ed45e6409be",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -123,10 +123,10 @@ struct PrecomputedTransactionData\n     explicit PrecomputedTransactionData(const CTransaction& tx);\n };\n \n-enum SigVersion\n+enum class SigVersion\n {\n-    SIGVERSION_BASE = 0,\n-    SIGVERSION_WITNESS_V0 = 1,\n+    BASE = 0,\n+    WITNESS_V0 = 1,\n };\n \n uint256 SignatureHash(const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion, const PrecomputedTransactionData* cache = nullptr);"
      },
      {
        "sha": "05bc5e9bd692852bd2798c7400794934ee5142e6",
        "filename": "src/script/ismine.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/script/ismine.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/script/ismine.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/ismine.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -61,7 +61,7 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey, bool&\n         break;\n     case TX_PUBKEY:\n         keyID = CPubKey(vSolutions[0]).GetID();\n-        if (sigversion != SIGVERSION_BASE && vSolutions[0].size() != 33) {\n+        if (sigversion != SigVersion::BASE && vSolutions[0].size() != 33) {\n             isInvalid = true;\n             return ISMINE_NO;\n         }\n@@ -76,14 +76,14 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey, bool&\n             // This also applies to the P2WSH case.\n             break;\n         }\n-        isminetype ret = ::IsMine(keystore, GetScriptForDestination(CKeyID(uint160(vSolutions[0]))), isInvalid, SIGVERSION_WITNESS_V0);\n+        isminetype ret = ::IsMine(keystore, GetScriptForDestination(CKeyID(uint160(vSolutions[0]))), isInvalid, SigVersion::WITNESS_V0);\n         if (ret == ISMINE_SPENDABLE || ret == ISMINE_WATCH_SOLVABLE || (ret == ISMINE_NO && isInvalid))\n             return ret;\n         break;\n     }\n     case TX_PUBKEYHASH:\n         keyID = CKeyID(uint160(vSolutions[0]));\n-        if (sigversion != SIGVERSION_BASE) {\n+        if (sigversion != SigVersion::BASE) {\n             CPubKey pubkey;\n             if (keystore.GetPubKey(keyID, pubkey) && !pubkey.IsCompressed()) {\n                 isInvalid = true;\n@@ -114,7 +114,7 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey, bool&\n         CScriptID scriptID = CScriptID(hash);\n         CScript subscript;\n         if (keystore.GetCScript(scriptID, subscript)) {\n-            isminetype ret = IsMine(keystore, subscript, isInvalid, SIGVERSION_WITNESS_V0);\n+            isminetype ret = IsMine(keystore, subscript, isInvalid, SigVersion::WITNESS_V0);\n             if (ret == ISMINE_SPENDABLE || ret == ISMINE_WATCH_SOLVABLE || (ret == ISMINE_NO && isInvalid))\n                 return ret;\n         }\n@@ -129,7 +129,7 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey, bool&\n         // them) enable spend-out-from-under-you attacks, especially\n         // in shared-wallet situations.\n         std::vector<valtype> keys(vSolutions.begin()+1, vSolutions.begin()+vSolutions.size()-1);\n-        if (sigversion != SIGVERSION_BASE) {\n+        if (sigversion != SigVersion::BASE) {\n             for (size_t i = 0; i < keys.size(); i++) {\n                 if (keys[i].size() != 33) {\n                     isInvalid = true;"
      },
      {
        "sha": "f93a66e35aa8fd3a8210a9fe3fcf79721697bf3c",
        "filename": "src/script/ismine.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/script/ismine.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/script/ismine.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/ismine.h?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -31,11 +31,11 @@ typedef uint8_t isminefilter;\n /* isInvalid becomes true when the script is found invalid by consensus or policy. This will terminate the recursion\n  * and return ISMINE_NO immediately, as an invalid script should never be considered as \"mine\". This is needed as\n  * different SIGVERSION may have different network rules. Currently the only use of isInvalid is indicate uncompressed\n- * keys in SIGVERSION_WITNESS_V0 script, but could also be used in similar cases in the future\n+ * keys in SigVersion::WITNESS_V0 script, but could also be used in similar cases in the future\n  */\n-isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey, bool& isInvalid, SigVersion = SIGVERSION_BASE);\n-isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey, SigVersion = SIGVERSION_BASE);\n-isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest, bool& isInvalid, SigVersion = SIGVERSION_BASE);\n-isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest, SigVersion = SIGVERSION_BASE);\n+isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey, bool& isInvalid, SigVersion = SigVersion::BASE);\n+isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey, SigVersion = SigVersion::BASE);\n+isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest, bool& isInvalid, SigVersion = SigVersion::BASE);\n+isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest, SigVersion = SigVersion::BASE);\n \n #endif // BITCOIN_SCRIPT_ISMINE_H"
      },
      {
        "sha": "910bb39ce6aa08e0a5e0e4e961547916248af3be",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 20,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -6,7 +6,6 @@\n #include <script/sign.h>\n \n #include <key.h>\n-#include <keystore.h>\n #include <policy/policy.h>\n #include <primitives/transaction.h>\n #include <script/standard.h>\n@@ -15,16 +14,16 @@\n \n typedef std::vector<unsigned char> valtype;\n \n-TransactionSignatureCreator::TransactionSignatureCreator(const CKeyStore* keystoreIn, const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn) : BaseSignatureCreator(keystoreIn), txTo(txToIn), nIn(nInIn), nHashType(nHashTypeIn), amount(amountIn), checker(txTo, nIn, amountIn) {}\n+TransactionSignatureCreator::TransactionSignatureCreator(const SigningProvider* provider, const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn) : BaseSignatureCreator(provider), txTo(txToIn), nIn(nInIn), nHashType(nHashTypeIn), amount(amountIn), checker(txTo, nIn, amountIn) {}\n \n bool TransactionSignatureCreator::CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& address, const CScript& scriptCode, SigVersion sigversion) const\n {\n     CKey key;\n-    if (!keystore->GetKey(address, key))\n+    if (!m_provider->GetKey(address, key))\n         return false;\n \n     // Signing with uncompressed keys is disabled in witness scripts\n-    if (sigversion == SIGVERSION_WITNESS_V0 && !key.IsCompressed())\n+    if (sigversion == SigVersion::WITNESS_V0 && !key.IsCompressed())\n         return false;\n \n     uint256 hash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion);\n@@ -91,12 +90,12 @@ static bool SignStep(const BaseSignatureCreator& creator, const CScript& scriptP\n         else\n         {\n             CPubKey vch;\n-            creator.KeyStore().GetPubKey(keyID, vch);\n+            creator.Provider().GetPubKey(keyID, vch);\n             ret.push_back(ToByteVector(vch));\n         }\n         return true;\n     case TX_SCRIPTHASH:\n-        if (creator.KeyStore().GetCScript(uint160(vSolutions[0]), scriptRet)) {\n+        if (creator.Provider().GetCScript(uint160(vSolutions[0]), scriptRet)) {\n             ret.push_back(std::vector<unsigned char>(scriptRet.begin(), scriptRet.end()));\n             return true;\n         }\n@@ -112,7 +111,7 @@ static bool SignStep(const BaseSignatureCreator& creator, const CScript& scriptP\n \n     case TX_WITNESS_V0_SCRIPTHASH:\n         CRIPEMD160().Write(&vSolutions[0][0], vSolutions[0].size()).Finalize(h160.begin());\n-        if (creator.KeyStore().GetCScript(h160, scriptRet)) {\n+        if (creator.Provider().GetCScript(h160, scriptRet)) {\n             ret.push_back(std::vector<unsigned char>(scriptRet.begin(), scriptRet.end()));\n             return true;\n         }\n@@ -142,7 +141,7 @@ bool ProduceSignature(const BaseSignatureCreator& creator, const CScript& fromPu\n {\n     std::vector<valtype> result;\n     txnouttype whichType;\n-    bool solved = SignStep(creator, fromPubKey, result, whichType, SIGVERSION_BASE);\n+    bool solved = SignStep(creator, fromPubKey, result, whichType, SigVersion::BASE);\n     bool P2SH = false;\n     CScript subscript;\n     sigdata.scriptWitness.stack.clear();\n@@ -153,7 +152,7 @@ bool ProduceSignature(const BaseSignatureCreator& creator, const CScript& fromPu\n         // the final scriptSig is the signatures from that\n         // and then the serialized subscript:\n         subscript = CScript(result[0].begin(), result[0].end());\n-        solved = solved && SignStep(creator, subscript, result, whichType, SIGVERSION_BASE) && whichType != TX_SCRIPTHASH;\n+        solved = solved && SignStep(creator, subscript, result, whichType, SigVersion::BASE) && whichType != TX_SCRIPTHASH;\n         P2SH = true;\n     }\n \n@@ -162,15 +161,15 @@ bool ProduceSignature(const BaseSignatureCreator& creator, const CScript& fromPu\n         CScript witnessscript;\n         witnessscript << OP_DUP << OP_HASH160 << ToByteVector(result[0]) << OP_EQUALVERIFY << OP_CHECKSIG;\n         txnouttype subType;\n-        solved = solved && SignStep(creator, witnessscript, result, subType, SIGVERSION_WITNESS_V0);\n+        solved = solved && SignStep(creator, witnessscript, result, subType, SigVersion::WITNESS_V0);\n         sigdata.scriptWitness.stack = result;\n         result.clear();\n     }\n     else if (solved && whichType == TX_WITNESS_V0_SCRIPTHASH)\n     {\n         CScript witnessscript(result[0].begin(), result[0].end());\n         txnouttype subType;\n-        solved = solved && SignStep(creator, witnessscript, result, subType, SIGVERSION_WITNESS_V0) && subType != TX_SCRIPTHASH && subType != TX_WITNESS_V0_SCRIPTHASH && subType != TX_WITNESS_V0_KEYHASH;\n+        solved = solved && SignStep(creator, witnessscript, result, subType, SigVersion::WITNESS_V0) && subType != TX_SCRIPTHASH && subType != TX_WITNESS_V0_SCRIPTHASH && subType != TX_WITNESS_V0_KEYHASH;\n         result.push_back(std::vector<unsigned char>(witnessscript.begin(), witnessscript.end()));\n         sigdata.scriptWitness.stack = result;\n         result.clear();\n@@ -206,27 +205,27 @@ void UpdateTransaction(CMutableTransaction& tx, unsigned int nIn, const Signatur\n     UpdateInput(tx.vin[nIn], data);\n }\n \n-bool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, const CAmount& amount, int nHashType)\n+bool SignSignature(const SigningProvider &provider, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, const CAmount& amount, int nHashType)\n {\n     assert(nIn < txTo.vin.size());\n \n     CTransaction txToConst(txTo);\n-    TransactionSignatureCreator creator(&keystore, &txToConst, nIn, amount, nHashType);\n+    TransactionSignatureCreator creator(&provider, &txToConst, nIn, amount, nHashType);\n \n     SignatureData sigdata;\n     bool ret = ProduceSignature(creator, fromPubKey, sigdata);\n     UpdateTransaction(txTo, nIn, sigdata);\n     return ret;\n }\n \n-bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType)\n+bool SignSignature(const SigningProvider &provider, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType)\n {\n     assert(nIn < txTo.vin.size());\n     CTxIn& txin = txTo.vin[nIn];\n     assert(txin.prevout.n < txFrom.vout.size());\n     const CTxOut& txout = txFrom.vout[txin.prevout.n];\n \n-    return SignSignature(keystore, txout.scriptPubKey, txTo, nIn, txout.nValue, nHashType);\n+    return SignSignature(provider, txout.scriptPubKey, txTo, nIn, txout.nValue, nHashType);\n }\n \n static std::vector<valtype> CombineMultisig(const CScript& scriptPubKey, const BaseSignatureChecker& checker,\n@@ -294,7 +293,7 @@ struct Stacks\n     Stacks() {}\n     explicit Stacks(const std::vector<valtype>& scriptSigStack_) : script(scriptSigStack_), witness() {}\n     explicit Stacks(const SignatureData& data) : witness(data.scriptWitness.stack) {\n-        EvalScript(script, data.scriptSig, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SIGVERSION_BASE);\n+        EvalScript(script, data.scriptSig, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SigVersion::BASE);\n     }\n \n     SignatureData Output() const {\n@@ -370,7 +369,7 @@ static Stacks CombineSignatures(const CScript& scriptPubKey, const BaseSignature\n             sigs2.witness.pop_back();\n             sigs2.script = sigs2.witness;\n             sigs2.witness.clear();\n-            Stacks result = CombineSignatures(pubKey2, checker, txType2, vSolutions2, sigs1, sigs2, SIGVERSION_WITNESS_V0);\n+            Stacks result = CombineSignatures(pubKey2, checker, txType2, vSolutions2, sigs1, sigs2, SigVersion::WITNESS_V0);\n             result.witness = result.script;\n             result.script.clear();\n             result.witness.push_back(valtype(pubKey2.begin(), pubKey2.end()));\n@@ -388,7 +387,7 @@ SignatureData CombineSignatures(const CScript& scriptPubKey, const BaseSignature\n     std::vector<std::vector<unsigned char> > vSolutions;\n     Solver(scriptPubKey, txType, vSolutions);\n \n-    return CombineSignatures(scriptPubKey, checker, txType, vSolutions, Stacks(scriptSig1), Stacks(scriptSig2), SIGVERSION_BASE).Output();\n+    return CombineSignatures(scriptPubKey, checker, txType, vSolutions, Stacks(scriptSig1), Stacks(scriptSig2), SigVersion::BASE).Output();\n }\n \n namespace {\n@@ -427,13 +426,13 @@ bool DummySignatureCreator::CreateSig(std::vector<unsigned char>& vchSig, const\n     return true;\n }\n \n-bool IsSolvable(const CKeyStore& store, const CScript& script)\n+bool IsSolvable(const SigningProvider& provider, const CScript& script)\n {\n     // This check is to make sure that the script we created can actually be solved for and signed by us\n     // if we were to have the private keys. This is just to make sure that the script is valid and that,\n     // if found in a transaction, we would still accept and relay that transaction. In particular,\n     // it will reject witness outputs that require signing with an uncompressed public key.\n-    DummySignatureCreator creator(&store);\n+    DummySignatureCreator creator(&provider);\n     SignatureData sigs;\n     // Make sure that STANDARD_SCRIPT_VERIFY_FLAGS includes SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, the most\n     // important property this function is designed to test for."
      },
      {
        "sha": "c301f0544f7b4ad0c22ba8ad8ebc12a082639b09",
        "filename": "src/script/sign.h",
        "status": "modified",
        "additions": 22,
        "deletions": 11,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -8,21 +8,32 @@\n \n #include <script/interpreter.h>\n \n+class CKey;\n class CKeyID;\n-class CKeyStore;\n class CScript;\n+class CScriptID;\n class CTransaction;\n \n struct CMutableTransaction;\n \n+/** An interface to be implemented by keystores that support signing. */\n+class SigningProvider\n+{\n+public:\n+    virtual ~SigningProvider() {}\n+    virtual bool GetCScript(const CScriptID &scriptid, CScript& script) const =0;\n+    virtual bool GetPubKey(const CKeyID &address, CPubKey& pubkey) const =0;\n+    virtual bool GetKey(const CKeyID &address, CKey& key) const =0;\n+};\n+\n /** Virtual base class for signature creators. */\n class BaseSignatureCreator {\n protected:\n-    const CKeyStore* keystore;\n+    const SigningProvider* m_provider;\n \n public:\n-    explicit BaseSignatureCreator(const CKeyStore* keystoreIn) : keystore(keystoreIn) {}\n-    const CKeyStore& KeyStore() const { return *keystore; };\n+    explicit BaseSignatureCreator(const SigningProvider* provider) : m_provider(provider) {}\n+    const SigningProvider& Provider() const { return *m_provider; }\n     virtual ~BaseSignatureCreator() {}\n     virtual const BaseSignatureChecker& Checker() const =0;\n \n@@ -39,7 +50,7 @@ class TransactionSignatureCreator : public BaseSignatureCreator {\n     const TransactionSignatureChecker checker;\n \n public:\n-    TransactionSignatureCreator(const CKeyStore* keystoreIn, const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn=SIGHASH_ALL);\n+    TransactionSignatureCreator(const SigningProvider* provider, const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn=SIGHASH_ALL);\n     const BaseSignatureChecker& Checker() const override { return checker; }\n     bool CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode, SigVersion sigversion) const override;\n };\n@@ -48,13 +59,13 @@ class MutableTransactionSignatureCreator : public TransactionSignatureCreator {\n     CTransaction tx;\n \n public:\n-    MutableTransactionSignatureCreator(const CKeyStore* keystoreIn, const CMutableTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn) : TransactionSignatureCreator(keystoreIn, &tx, nInIn, amountIn, nHashTypeIn), tx(*txToIn) {}\n+    MutableTransactionSignatureCreator(const SigningProvider* provider, const CMutableTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn) : TransactionSignatureCreator(provider, &tx, nInIn, amountIn, nHashTypeIn), tx(*txToIn) {}\n };\n \n /** A signature creator that just produces 72-byte empty signatures. */\n class DummySignatureCreator : public BaseSignatureCreator {\n public:\n-    explicit DummySignatureCreator(const CKeyStore* keystoreIn) : BaseSignatureCreator(keystoreIn) {}\n+    explicit DummySignatureCreator(const SigningProvider* provider) : BaseSignatureCreator(provider) {}\n     const BaseSignatureChecker& Checker() const override;\n     bool CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode, SigVersion sigversion) const override;\n };\n@@ -71,8 +82,8 @@ struct SignatureData {\n bool ProduceSignature(const BaseSignatureCreator& creator, const CScript& scriptPubKey, SignatureData& sigdata);\n \n /** Produce a script signature for a transaction. */\n-bool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, const CAmount& amount, int nHashType);\n-bool SignSignature(const CKeyStore& keystore, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType);\n+bool SignSignature(const SigningProvider &provider, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, const CAmount& amount, int nHashType);\n+bool SignSignature(const SigningProvider &provider, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType);\n \n /** Combine two script signatures using a generic signature checker, intelligently, possibly with OP_0 placeholders. */\n SignatureData CombineSignatures(const CScript& scriptPubKey, const BaseSignatureChecker& checker, const SignatureData& scriptSig1, const SignatureData& scriptSig2);\n@@ -84,8 +95,8 @@ void UpdateInput(CTxIn& input, const SignatureData& data);\n \n /* Check whether we know how to sign for an output like this, assuming we\n  * have all private keys. While this function does not need private keys, the passed\n- * keystore is used to look up public keys and redeemscripts by hash.\n+ * provider is used to look up public keys and redeemscripts by hash.\n  * Solvability is unrelated to whether we consider this output to be ours. */\n-bool IsSolvable(const CKeyStore& store, const CScript& script);\n+bool IsSolvable(const SigningProvider& provider, const CScript& script);\n \n #endif // BITCOIN_SCRIPT_SIGN_H"
      },
      {
        "sha": "abb46fe533b776ce61232cd040f2d87a370810b9",
        "filename": "src/test/data/tx_invalid.json",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/test/data/tx_invalid.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/test/data/tx_invalid.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/tx_invalid.json?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -321,7 +321,7 @@\n [\"where the pubkey is obtained through key recovery with sig and the wrong sighash.\"],\n [\"This is to show that FindAndDelete is applied only to non-segwit scripts\"],\n [\"To show that the tests are 'correctly wrong', they should pass by modifying OP_CHECKSIG under interpreter.cpp\"],\n-[\"by replacing (sigversion == SIGVERSION_BASE) with (sigversion != SIGVERSION_BASE)\"],\n+[\"by replacing (sigversion == SigVersion::BASE) with (sigversion != SigVersion::BASE)\"],\n [\"Non-segwit: wrong sighash (without FindAndDelete) = 1ba1fe3bc90c5d1265460e684ce6774e324f0fabdf67619eda729e64e8b6bc08\"],\n [[[\"f18783ace138abac5d3a7a5cf08e88fe6912f267ef936452e0c27d090621c169\", 7000, \"HASH160 0x14 0x0c746489e2d83cdbb5b90b432773342ba809c134 EQUAL\", 200000]],\n \"010000000169c12106097dc2e0526493ef67f21269fe888ef05c7a3a5dacab38e1ac8387f1581b0000b64830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e012103b12a1ec8428fc74166926318c15e17408fea82dbb157575e16a8c365f546248f4aad4830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e01ffffffff0101000000000000000000000000\", \"P2SH,WITNESS\"],\n@@ -332,7 +332,7 @@\n [\"Script is 2 CHECKMULTISIGVERIFY <sig1> <sig2> DROP\"],\n [\"52af4830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e0148304502205286f726690b2e9b0207f0345711e63fa7012045b9eb0f19c2458ce1db90cf43022100e89f17f86abc5b149eba4115d4f128bcf45d77fb3ecdd34f594091340c0395960175\"],\n [\"Signature is 0 <sig1> <sig2> 2 <key1> <key2>\"],\n-[\"Should pass by replacing (sigversion == SIGVERSION_BASE) with (sigversion != SIGVERSION_BASE) under OP_CHECKMULTISIG\"],\n+[\"Should pass by replacing (sigversion == SigVersion::BASE) with (sigversion != SigVersion::BASE) under OP_CHECKMULTISIG\"],\n [\"Non-segwit: wrong sighash (without FindAndDelete) = 4bc6a53e8e16ef508c19e38bba08831daba85228b0211f323d4cb0999cf2a5e8\"],\n [[[\"9628667ad48219a169b41b020800162287d2c0f713c04157e95c484a8dcb7592\", 7000, \"HASH160 0x14 0x5748407f5ca5cdca53ba30b79040260770c9ee1b EQUAL\", 200000]],\n \"01000000019275cb8d4a485ce95741c013f7c0d28722160008021bb469a11982d47a662896581b0000fd6f01004830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e0148304502205286f726690b2e9b0207f0345711e63fa7012045b9eb0f19c2458ce1db90cf43022100e89f17f86abc5b149eba4115d4f128bcf45d77fb3ecdd34f594091340c039596015221023fd5dd42b44769c5653cbc5947ff30ab8871f240ad0c0e7432aefe84b5b4ff3421039d52178dbde360b83f19cf348deb04fa8360e1bf5634577be8e50fafc2b0e4ef4c9552af4830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e0148304502205286f726690b2e9b0207f0345711e63fa7012045b9eb0f19c2458ce1db90cf43022100e89f17f86abc5b149eba4115d4f128bcf45d77fb3ecdd34f594091340c0395960175ffffffff0101000000000000000000000000\", \"P2SH,WITNESS\"],"
      },
      {
        "sha": "b593f9633ce945cac1087265fc98384010405fd8",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -21,7 +21,7 @@ BOOST_FIXTURE_TEST_SUITE(multisig_tests, BasicTestingSetup)\n CScript\n sign_multisig(CScript scriptPubKey, std::vector<CKey> keys, CTransaction transaction, int whichIn)\n {\n-    uint256 hash = SignatureHash(scriptPubKey, transaction, whichIn, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+    uint256 hash = SignatureHash(scriptPubKey, transaction, whichIn, SIGHASH_ALL, 0, SigVersion::BASE);\n \n     CScript result;\n     result << OP_0; // CHECKMULTISIG bug workaround"
      },
      {
        "sha": "46a2d13745019556e48e6d7729aec4f4730c4979",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 67,
        "deletions": 67,
        "changes": 134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -267,10 +267,10 @@ struct KeyData\n     }\n };\n \n-enum WitnessMode {\n-    WITNESS_NONE,\n-    WITNESS_PKH,\n-    WITNESS_SH\n+enum class WitnessMode {\n+    NONE,\n+    PKH,\n+    SH\n };\n \n class TestBuilder\n@@ -308,15 +308,15 @@ class TestBuilder\n     }\n \n public:\n-    TestBuilder(const CScript& script_, const std::string& comment_, int flags_, bool P2SH = false, WitnessMode wm = WITNESS_NONE, int witnessversion = 0, CAmount nValue_ = 0) : script(script_), havePush(false), comment(comment_), flags(flags_), scriptError(SCRIPT_ERR_OK), nValue(nValue_)\n+    TestBuilder(const CScript& script_, const std::string& comment_, int flags_, bool P2SH = false, WitnessMode wm = WitnessMode::NONE, int witnessversion = 0, CAmount nValue_ = 0) : script(script_), havePush(false), comment(comment_), flags(flags_), scriptError(SCRIPT_ERR_OK), nValue(nValue_)\n     {\n         CScript scriptPubKey = script;\n-        if (wm == WITNESS_PKH) {\n+        if (wm == WitnessMode::PKH) {\n             uint160 hash;\n             CHash160().Write(&script[1], script.size() - 1).Finalize(hash.begin());\n             script = CScript() << OP_DUP << OP_HASH160 << ToByteVector(hash) << OP_EQUALVERIFY << OP_CHECKSIG;\n             scriptPubKey = CScript() << witnessversion << ToByteVector(hash);\n-        } else if (wm == WITNESS_SH) {\n+        } else if (wm == WitnessMode::SH) {\n             witscript = scriptPubKey;\n             uint256 hash;\n             CSHA256().Write(&witscript[0], witscript.size()).Finalize(hash.begin());\n@@ -361,7 +361,7 @@ class TestBuilder\n         return *this;\n     }\n \n-    TestBuilder& PushSig(const CKey& key, int nHashType = SIGHASH_ALL, unsigned int lenR = 32, unsigned int lenS = 32, SigVersion sigversion = SIGVERSION_BASE, CAmount amount = 0)\n+    TestBuilder& PushSig(const CKey& key, int nHashType = SIGHASH_ALL, unsigned int lenR = 32, unsigned int lenS = 32, SigVersion sigversion = SigVersion::BASE, CAmount amount = 0)\n     {\n         uint256 hash = SignatureHash(script, spendTx, 0, nHashType, amount, sigversion);\n         std::vector<unsigned char> vchSig, r, s;\n@@ -379,7 +379,7 @@ class TestBuilder\n         return *this;\n     }\n \n-    TestBuilder& PushWitSig(const CKey& key, CAmount amount = -1, int nHashType = SIGHASH_ALL, unsigned int lenR = 32, unsigned int lenS = 32, SigVersion sigversion = SIGVERSION_WITNESS_V0)\n+    TestBuilder& PushWitSig(const CKey& key, CAmount amount = -1, int nHashType = SIGHASH_ALL, unsigned int lenR = 32, unsigned int lenS = 32, SigVersion sigversion = SigVersion::WITNESS_V0)\n     {\n         if (amount == -1)\n             amount = nValue;\n@@ -747,57 +747,57 @@ BOOST_AUTO_TEST_CASE(script_build)\n                                ).PushSig(keys.key0).PushRedeem());\n \n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"Basic P2WSH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                \"Basic P2WSH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH,\n                                 0, 1).PushWitSig(keys.key0).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"Basic P2WPKH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_PKH,\n+                                \"Basic P2WPKH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::PKH,\n                                 0, 1).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"Basic P2SH(P2WSH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                \"Basic P2SH(P2WSH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::SH,\n                                 0, 1).PushWitSig(keys.key0).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"Basic P2SH(P2WPKH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_PKH,\n+                                \"Basic P2SH(P2WPKH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::PKH,\n                                 0, 1).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n-                                \"Basic P2WSH with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH\n+                                \"Basic P2WSH with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH\n                                ).PushWitSig(keys.key0).PushWitRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1),\n-                                \"Basic P2WPKH with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_PKH\n+                                \"Basic P2WPKH with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey1).AsWit().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n-                                \"Basic P2SH(P2WSH) with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH\n+                                \"Basic P2SH(P2WSH) with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::SH\n                                ).PushWitSig(keys.key0).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1),\n-                                \"Basic P2SH(P2WPKH) with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_PKH\n+                                \"Basic P2SH(P2WPKH) with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey1).AsWit().PushRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n-                                \"Basic P2WSH with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, false, WITNESS_SH\n+                                \"Basic P2WSH with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, false, WitnessMode::SH\n                                ).PushWitSig(keys.key0).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1),\n-                                \"Basic P2WPKH with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, false, WITNESS_PKH\n+                                \"Basic P2WPKH with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, false, WitnessMode::PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey1).AsWit());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n-                                \"Basic P2SH(P2WSH) with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, true, WITNESS_SH\n+                                \"Basic P2SH(P2WSH) with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, true, WitnessMode::SH\n                                ).PushWitSig(keys.key0).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1),\n-                                \"Basic P2SH(P2WPKH) with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, true, WITNESS_PKH\n+                                \"Basic P2SH(P2WPKH) with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, true, WitnessMode::PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey1).AsWit().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"Basic P2WSH with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                \"Basic P2WSH with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH,\n                                 0, 0).PushWitSig(keys.key0, 1).PushWitRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"Basic P2WPKH with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_PKH,\n+                                \"Basic P2WPKH with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::PKH,\n                                 0, 0).PushWitSig(keys.key0, 1).Push(keys.pubkey0).AsWit().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"Basic P2SH(P2WSH) with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                \"Basic P2SH(P2WSH) with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::SH,\n                                 0, 0).PushWitSig(keys.key0, 1).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"Basic P2SH(P2WPKH) with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_PKH,\n+                                \"Basic P2SH(P2WPKH) with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::PKH,\n                                 0, 0).PushWitSig(keys.key0, 1).Push(keys.pubkey0).AsWit().PushRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n \n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n                                 \"P2WPKH with future witness version\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH |\n-                                SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM, false, WITNESS_PKH, 1\n+                                SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM, false, WitnessMode::PKH, 1\n                                ).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().ScriptError(SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM));\n     {\n         CScript witscript = CScript() << ToByteVector(keys.pubkey0);\n@@ -810,118 +810,118 @@ BOOST_AUTO_TEST_CASE(script_build)\n                                    ).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().ScriptError(SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH));\n     }\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"P2WSH with empty witness\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH\n+                                \"P2WSH with empty witness\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH\n                                ).ScriptError(SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY));\n     {\n         CScript witscript = CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG;\n         tests.push_back(TestBuilder(witscript,\n-                                    \"P2WSH with witness program mismatch\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH\n+                                    \"P2WSH with witness program mismatch\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH\n                                    ).PushWitSig(keys.key0).Push(witscript).DamagePush(0).AsWit().ScriptError(SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH));\n     }\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"P2WPKH with witness program mismatch\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_PKH\n+                                \"P2WPKH with witness program mismatch\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().Push(\"0\").AsWit().ScriptError(SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"P2WPKH with non-empty scriptSig\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_PKH\n+                                \"P2WPKH with non-empty scriptSig\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().Num(11).ScriptError(SCRIPT_ERR_WITNESS_MALLEATED));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1),\n-                                \"P2SH(P2WPKH) with superfluous push in scriptSig\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_PKH\n+                                \"P2SH(P2WPKH) with superfluous push in scriptSig\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey1).AsWit().Num(11).PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_MALLEATED_P2SH));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n                                 \"P2PK with witness\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH\n                                ).PushSig(keys.key0).Push(\"0\").AsWit().ScriptError(SCRIPT_ERR_WITNESS_UNEXPECTED));\n \n     // Compressed keys should pass SCRIPT_VERIFY_WITNESS_PUBKEYTYPE\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C) << OP_CHECKSIG,\n-                                \"Basic P2WSH with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"Basic P2WSH with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).PushWitSig(keys.key0C).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C),\n-                                \"Basic P2WPKH with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_PKH,\n+                                \"Basic P2WPKH with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::PKH,\n                                 0, 1).PushWitSig(keys.key0C).Push(keys.pubkey0C).AsWit());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C) << OP_CHECKSIG,\n-                                \"Basic P2SH(P2WSH) with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"Basic P2SH(P2WSH) with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).PushWitSig(keys.key0C).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C),\n-                                \"Basic P2SH(P2WPKH) with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_PKH,\n+                                \"Basic P2SH(P2WPKH) with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::PKH,\n                                 0, 1).PushWitSig(keys.key0C).Push(keys.pubkey0C).AsWit().PushRedeem());\n \n     // Testing uncompressed key in witness with SCRIPT_VERIFY_WITNESS_PUBKEYTYPE\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"Basic P2WSH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"Basic P2WSH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).PushWitSig(keys.key0).PushWitRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"Basic P2WPKH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_PKH,\n+                                \"Basic P2WPKH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::PKH,\n                                 0, 1).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"Basic P2SH(P2WSH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"Basic P2SH(P2WSH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).PushWitSig(keys.key0).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"Basic P2SH(P2WPKH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_PKH,\n+                                \"Basic P2SH(P2WPKH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::PKH,\n                                 0, 1).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n \n     // P2WSH 1-of-2 multisig with compressed keys\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem().PushRedeem());\n \n     // P2WSH 1-of-2 multisig with first key uncompressed\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0).PushWitRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     // P2WSH 1-of-2 multisig with second key uncompressed\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG second key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG second key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the first key should pass as the uncompressed key is not used\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the first key should pass as the uncompressed key is not used\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the first key should pass as the uncompressed key is not used\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the first key should pass as the uncompressed key is not used\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1).PushWitRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n \n     std::set<std::string> tests_set;\n@@ -1009,29 +1009,29 @@ BOOST_AUTO_TEST_CASE(script_PushData)\n \n     ScriptError err;\n     std::vector<std::vector<unsigned char> > directStack;\n-    BOOST_CHECK(EvalScript(directStack, CScript(&direct[0], &direct[sizeof(direct)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n+    BOOST_CHECK(EvalScript(directStack, CScript(&direct[0], &direct[sizeof(direct)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     std::vector<std::vector<unsigned char> > pushdata1Stack;\n-    BOOST_CHECK(EvalScript(pushdata1Stack, CScript(&pushdata1[0], &pushdata1[sizeof(pushdata1)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n+    BOOST_CHECK(EvalScript(pushdata1Stack, CScript(&pushdata1[0], &pushdata1[sizeof(pushdata1)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n     BOOST_CHECK(pushdata1Stack == directStack);\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     std::vector<std::vector<unsigned char> > pushdata2Stack;\n-    BOOST_CHECK(EvalScript(pushdata2Stack, CScript(&pushdata2[0], &pushdata2[sizeof(pushdata2)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n+    BOOST_CHECK(EvalScript(pushdata2Stack, CScript(&pushdata2[0], &pushdata2[sizeof(pushdata2)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n     BOOST_CHECK(pushdata2Stack == directStack);\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     std::vector<std::vector<unsigned char> > pushdata4Stack;\n-    BOOST_CHECK(EvalScript(pushdata4Stack, CScript(&pushdata4[0], &pushdata4[sizeof(pushdata4)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n+    BOOST_CHECK(EvalScript(pushdata4Stack, CScript(&pushdata4[0], &pushdata4[sizeof(pushdata4)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n     BOOST_CHECK(pushdata4Stack == directStack);\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n }\n \n CScript\n sign_multisig(CScript scriptPubKey, std::vector<CKey> keys, CTransaction transaction)\n {\n-    uint256 hash = SignatureHash(scriptPubKey, transaction, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+    uint256 hash = SignatureHash(scriptPubKey, transaction, 0, SIGHASH_ALL, 0, SigVersion::BASE);\n \n     CScript result;\n     //\n@@ -1227,15 +1227,15 @@ BOOST_AUTO_TEST_CASE(script_combineSigs)\n \n     // A couple of partially-signed versions:\n     std::vector<unsigned char> sig1;\n-    uint256 hash1 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+    uint256 hash1 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_ALL, 0, SigVersion::BASE);\n     BOOST_CHECK(keys[0].Sign(hash1, sig1));\n     sig1.push_back(SIGHASH_ALL);\n     std::vector<unsigned char> sig2;\n-    uint256 hash2 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_NONE, 0, SIGVERSION_BASE);\n+    uint256 hash2 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_NONE, 0, SigVersion::BASE);\n     BOOST_CHECK(keys[1].Sign(hash2, sig2));\n     sig2.push_back(SIGHASH_NONE);\n     std::vector<unsigned char> sig3;\n-    uint256 hash3 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_SINGLE, 0, SIGVERSION_BASE);\n+    uint256 hash3 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_SINGLE, 0, SigVersion::BASE);\n     BOOST_CHECK(keys[2].Sign(hash3, sig3));\n     sig3.push_back(SIGHASH_SINGLE);\n "
      },
      {
        "sha": "a2bd8998b1a192051b19db7b5abfc05dacf31590",
        "filename": "src/test/sighash_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/test/sighash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/test/sighash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sighash_tests.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -138,7 +138,7 @@ BOOST_AUTO_TEST_CASE(sighash_test)\n \n         uint256 sh, sho;\n         sho = SignatureHashOld(scriptCode, txTo, nIn, nHashType);\n-        sh = SignatureHash(scriptCode, txTo, nIn, nHashType, 0, SIGVERSION_BASE);\n+        sh = SignatureHash(scriptCode, txTo, nIn, nHashType, 0, SigVersion::BASE);\n         #if defined(PRINT_SIGHASH_JSON)\n         CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n         ss << txTo;\n@@ -204,7 +204,7 @@ BOOST_AUTO_TEST_CASE(sighash_from_data)\n           continue;\n         }\n \n-        sh = SignatureHash(scriptCode, *tx, nIn, nHashType, 0, SIGVERSION_BASE);\n+        sh = SignatureHash(scriptCode, *tx, nIn, nHashType, 0, SigVersion::BASE);\n         BOOST_CHECK_MESSAGE(sh.GetHex() == sigHashHex, strTest);\n     }\n }"
      },
      {
        "sha": "b222392ee5176557f2302d2d252cc3b49dde77ea",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -407,7 +407,7 @@ static CScript PushAll(const std::vector<valtype>& values)\n void ReplaceRedeemScript(CScript& script, const CScript& redeemScript)\n {\n     std::vector<valtype> stack;\n-    EvalScript(stack, script, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SIGVERSION_BASE);\n+    EvalScript(stack, script, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SigVersion::BASE);\n     assert(stack.size() > 0);\n     stack.back() = std::vector<unsigned char>(redeemScript.begin(), redeemScript.end());\n     script = PushAll(stack);"
      },
      {
        "sha": "7087c267747cc1d529635f4c33fe47efedb6a429",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -56,7 +56,7 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\n \n         // Sign:\n         std::vector<unsigned char> vchSig;\n-        uint256 hash = SignatureHash(scriptPubKey, spends[i], 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+        uint256 hash = SignatureHash(scriptPubKey, spends[i], 0, SIGHASH_ALL, 0, SigVersion::BASE);\n         BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n         vchSig.push_back((unsigned char)SIGHASH_ALL);\n         spends[i].vin[0].scriptSig << vchSig;\n@@ -182,7 +182,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n     // Sign, with a non-DER signature\n     {\n         std::vector<unsigned char> vchSig;\n-        uint256 hash = SignatureHash(p2pk_scriptPubKey, spend_tx, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+        uint256 hash = SignatureHash(p2pk_scriptPubKey, spend_tx, 0, SIGHASH_ALL, 0, SigVersion::BASE);\n         BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n         vchSig.push_back((unsigned char) 0); // padding byte makes this non-DER\n         vchSig.push_back((unsigned char)SIGHASH_ALL);\n@@ -256,7 +256,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n \n         // Sign\n         std::vector<unsigned char> vchSig;\n-        uint256 hash = SignatureHash(spend_tx.vout[2].scriptPubKey, invalid_with_cltv_tx, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+        uint256 hash = SignatureHash(spend_tx.vout[2].scriptPubKey, invalid_with_cltv_tx, 0, SIGHASH_ALL, 0, SigVersion::BASE);\n         BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n         vchSig.push_back((unsigned char)SIGHASH_ALL);\n         invalid_with_cltv_tx.vin[0].scriptSig = CScript() << vchSig << 101;\n@@ -284,7 +284,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n \n         // Sign\n         std::vector<unsigned char> vchSig;\n-        uint256 hash = SignatureHash(spend_tx.vout[3].scriptPubKey, invalid_with_csv_tx, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+        uint256 hash = SignatureHash(spend_tx.vout[3].scriptPubKey, invalid_with_csv_tx, 0, SIGHASH_ALL, 0, SigVersion::BASE);\n         BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n         vchSig.push_back((unsigned char)SIGHASH_ALL);\n         invalid_with_csv_tx.vin[0].scriptSig = CScript() << vchSig << 101;"
      },
      {
        "sha": "92ef58e517ded6090474524fa649d048ace5b2ea",
        "filename": "src/test/versionbits_tests.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/test/versionbits_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/test/versionbits_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/versionbits_tests.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -101,8 +101,8 @@ class VersionBitsTester\n     VersionBitsTester& TestDefined() {\n         for (int i = 0; i < CHECKERS; i++) {\n             if (InsecureRandBits(i) == 0) {\n-                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_DEFINED, strprintf(\"Test %i for DEFINED\", num));\n-                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n+                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::DEFINED, strprintf(\"Test %i for DEFINED\", num));\n+                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n             }\n         }\n         num++;\n@@ -112,8 +112,8 @@ class VersionBitsTester\n     VersionBitsTester& TestStarted() {\n         for (int i = 0; i < CHECKERS; i++) {\n             if (InsecureRandBits(i) == 0) {\n-                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_STARTED, strprintf(\"Test %i for STARTED\", num));\n-                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n+                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::STARTED, strprintf(\"Test %i for STARTED\", num));\n+                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n             }\n         }\n         num++;\n@@ -123,8 +123,8 @@ class VersionBitsTester\n     VersionBitsTester& TestLockedIn() {\n         for (int i = 0; i < CHECKERS; i++) {\n             if (InsecureRandBits(i) == 0) {\n-                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_LOCKED_IN, strprintf(\"Test %i for LOCKED_IN\", num));\n-                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n+                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::LOCKED_IN, strprintf(\"Test %i for LOCKED_IN\", num));\n+                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n             }\n         }\n         num++;\n@@ -134,8 +134,8 @@ class VersionBitsTester\n     VersionBitsTester& TestActive() {\n         for (int i = 0; i < CHECKERS; i++) {\n             if (InsecureRandBits(i) == 0) {\n-                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_ACTIVE, strprintf(\"Test %i for ACTIVE\", num));\n-                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n+                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::ACTIVE, strprintf(\"Test %i for ACTIVE\", num));\n+                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n             }\n         }\n         num++;\n@@ -145,8 +145,8 @@ class VersionBitsTester\n     VersionBitsTester& TestFailed() {\n         for (int i = 0; i < CHECKERS; i++) {\n             if (InsecureRandBits(i) == 0) {\n-                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_FAILED, strprintf(\"Test %i for FAILED\", num));\n-                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n+                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::FAILED, strprintf(\"Test %i for FAILED\", num));\n+                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n             }\n         }\n         num++;"
      },
      {
        "sha": "8550a7e8893e313c534bc730cb6f1a320036fde2",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -147,7 +147,7 @@ size_t CCoinsViewDB::EstimateSize() const\n     return db.EstimateSize(DB_COIN, (char)(DB_COIN+1));\n }\n \n-CBlockTreeDB::CBlockTreeDB(size_t nCacheSize, bool fMemory, bool fWipe) : CDBWrapper(GetDataDir() / \"blocks\" / \"index\", nCacheSize, fMemory, fWipe) {\n+CBlockTreeDB::CBlockTreeDB(size_t nCacheSize, bool fMemory, bool fWipe) : CDBWrapper(gArgs.IsArgSet(\"-blocksdir\") ? GetDataDir() / \"blocks\" / \"index\" : GetBlocksDir() / \"index\", nCacheSize, fMemory, fWipe) {\n }\n \n bool CBlockTreeDB::ReadBlockFileInfo(int nFile, CBlockFileInfo &info) {"
      },
      {
        "sha": "cc639288d37e5d1a082199cf85eb6c1e78ae96df",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -339,7 +339,7 @@ CTxMemPool::CTxMemPool(CBlockPolicyEstimator* estimator) :\n     nCheckFrequency = 0;\n }\n \n-bool CTxMemPool::isSpent(const COutPoint& outpoint)\n+bool CTxMemPool::isSpent(const COutPoint& outpoint) const\n {\n     LOCK(cs);\n     return mapNextTx.count(outpoint);"
      },
      {
        "sha": "699f6b554bd9344f7f1df32e7ba853d3bdbadc59",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -550,7 +550,7 @@ class CTxMemPool\n     void _clear(); //lock free\n     bool CompareDepthAndScore(const uint256& hasha, const uint256& hashb);\n     void queryHashes(std::vector<uint256>& vtxid);\n-    bool isSpent(const COutPoint& outpoint);\n+    bool isSpent(const COutPoint& outpoint) const;\n     unsigned int GetTransactionsUpdated() const;\n     void AddTransactionsUpdated(unsigned int n);\n     /**"
      },
      {
        "sha": "dbf90651132bbe345652772abe1b0c5dc5a9f577",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 0,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -613,10 +613,41 @@ fs::path GetDefaultDataDir()\n #endif\n }\n \n+static fs::path g_blocks_path_cached;\n+static fs::path g_blocks_path_cache_net_specific;\n static fs::path pathCached;\n static fs::path pathCachedNetSpecific;\n static CCriticalSection csPathCached;\n \n+const fs::path &GetBlocksDir(bool fNetSpecific)\n+{\n+\n+    LOCK(csPathCached);\n+\n+    fs::path &path = fNetSpecific ? g_blocks_path_cache_net_specific : g_blocks_path_cached;\n+\n+    // This can be called during exceptions by LogPrintf(), so we cache the\n+    // value so we don't have to do memory allocations after that.\n+    if (!path.empty())\n+        return path;\n+\n+    if (gArgs.IsArgSet(\"-blocksdir\")) {\n+        path = fs::system_complete(gArgs.GetArg(\"-blocksdir\", \"\"));\n+        if (!fs::is_directory(path)) {\n+            path = \"\";\n+            return path;\n+        }\n+    } else {\n+        path = GetDataDir(false);\n+    }\n+    if (fNetSpecific)\n+        path /= BaseParams().DataDir();\n+\n+    path /= \"blocks\";\n+    fs::create_directories(path);\n+    return path;\n+}\n+\n const fs::path &GetDataDir(bool fNetSpecific)\n {\n \n@@ -655,6 +686,8 @@ void ClearDatadirCache()\n \n     pathCached = fs::path();\n     pathCachedNetSpecific = fs::path();\n+    g_blocks_path_cached = fs::path();\n+    g_blocks_path_cache_net_specific = fs::path();\n }\n \n fs::path GetConfigFile(const std::string& confPath)"
      },
      {
        "sha": "592041c0cfaab0a2c62e947603ae059b2c540e99",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -183,6 +183,7 @@ void ReleaseDirectoryLocks();\n \n bool TryCreateDirectories(const fs::path& p);\n fs::path GetDefaultDataDir();\n+const fs::path &GetBlocksDir(bool fNetSpecific = true);\n const fs::path &GetDataDir(bool fNetSpecific = true);\n void ClearDatadirCache();\n fs::path GetConfigFile(const std::string& confPath);"
      },
      {
        "sha": "d107fec70c34c614f997d770fb8c48316aa47230",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 35,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -280,11 +280,11 @@ std::unique_ptr<CCoinsViewDB> pcoinsdbview;\n std::unique_ptr<CCoinsViewCache> pcoinsTip;\n std::unique_ptr<CBlockTreeDB> pblocktree;\n \n-enum FlushStateMode {\n-    FLUSH_STATE_NONE,\n-    FLUSH_STATE_IF_NEEDED,\n-    FLUSH_STATE_PERIODIC,\n-    FLUSH_STATE_ALWAYS\n+enum class FlushStateMode {\n+    NONE,\n+    IF_NEEDED,\n+    PERIODIC,\n+    ALWAYS\n };\n \n // See definition for documentation\n@@ -983,7 +983,7 @@ static bool AcceptToMemoryPoolWithTime(const CChainParams& chainparams, CTxMemPo\n     }\n     // After we've (potentially) uncached entries, ensure our coins cache is still within its size limits\n     CValidationState stateDummy;\n-    FlushStateToDisk(chainparams, stateDummy, FLUSH_STATE_PERIODIC);\n+    FlushStateToDisk(chainparams, stateDummy, FlushStateMode::PERIODIC);\n     return res;\n }\n \n@@ -1684,7 +1684,7 @@ int32_t ComputeBlockVersion(const CBlockIndex* pindexPrev, const Consensus::Para\n \n     for (int i = 0; i < (int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; i++) {\n         ThresholdState state = VersionBitsState(pindexPrev, params, static_cast<Consensus::DeploymentPos>(i), versionbitscache);\n-        if (state == THRESHOLD_LOCKED_IN || state == THRESHOLD_STARTED) {\n+        if (state == ThresholdState::LOCKED_IN || state == ThresholdState::STARTED) {\n             nVersion |= VersionBitsMask(params, static_cast<Consensus::DeploymentPos>(i));\n         }\n     }\n@@ -1740,7 +1740,7 @@ static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consens\n     }\n \n     // Start enforcing BIP68 (sequence locks) and BIP112 (CHECKSEQUENCEVERIFY) using versionbits logic.\n-    if (VersionBitsState(pindex->pprev, consensusparams, Consensus::DEPLOYMENT_CSV, versionbitscache) == THRESHOLD_ACTIVE) {\n+    if (VersionBitsState(pindex->pprev, consensusparams, Consensus::DEPLOYMENT_CSV, versionbitscache) == ThresholdState::ACTIVE) {\n         flags |= SCRIPT_VERIFY_CHECKSEQUENCEVERIFY;\n     }\n \n@@ -1926,7 +1926,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n \n     // Start enforcing BIP68 (sequence locks) and BIP112 (CHECKSEQUENCEVERIFY) using versionbits logic.\n     int nLockTimeFlags = 0;\n-    if (VersionBitsState(pindex->pprev, chainparams.GetConsensus(), Consensus::DEPLOYMENT_CSV, versionbitscache) == THRESHOLD_ACTIVE) {\n+    if (VersionBitsState(pindex->pprev, chainparams.GetConsensus(), Consensus::DEPLOYMENT_CSV, versionbitscache) == ThresholdState::ACTIVE) {\n         nLockTimeFlags |= LOCKTIME_VERIFY_SEQUENCE;\n     }\n \n@@ -2096,19 +2096,19 @@ bool static FlushStateToDisk(const CChainParams& chainparams, CValidationState &\n         int64_t cacheSize = pcoinsTip->DynamicMemoryUsage();\n         int64_t nTotalSpace = nCoinCacheUsage + std::max<int64_t>(nMempoolSizeMax - nMempoolUsage, 0);\n         // The cache is large and we're within 10% and 10 MiB of the limit, but we have time now (not in the middle of a block processing).\n-        bool fCacheLarge = mode == FLUSH_STATE_PERIODIC && cacheSize > std::max((9 * nTotalSpace) / 10, nTotalSpace - MAX_BLOCK_COINSDB_USAGE * 1024 * 1024);\n+        bool fCacheLarge = mode == FlushStateMode::PERIODIC && cacheSize > std::max((9 * nTotalSpace) / 10, nTotalSpace - MAX_BLOCK_COINSDB_USAGE * 1024 * 1024);\n         // The cache is over the limit, we have to write now.\n-        bool fCacheCritical = mode == FLUSH_STATE_IF_NEEDED && cacheSize > nTotalSpace;\n+        bool fCacheCritical = mode == FlushStateMode::IF_NEEDED && cacheSize > nTotalSpace;\n         // It's been a while since we wrote the block index to disk. Do this frequently, so we don't need to redownload after a crash.\n-        bool fPeriodicWrite = mode == FLUSH_STATE_PERIODIC && nNow > nLastWrite + (int64_t)DATABASE_WRITE_INTERVAL * 1000000;\n+        bool fPeriodicWrite = mode == FlushStateMode::PERIODIC && nNow > nLastWrite + (int64_t)DATABASE_WRITE_INTERVAL * 1000000;\n         // It's been very long since we flushed the cache. Do this infrequently, to optimize cache usage.\n-        bool fPeriodicFlush = mode == FLUSH_STATE_PERIODIC && nNow > nLastFlush + (int64_t)DATABASE_FLUSH_INTERVAL * 1000000;\n+        bool fPeriodicFlush = mode == FlushStateMode::PERIODIC && nNow > nLastFlush + (int64_t)DATABASE_FLUSH_INTERVAL * 1000000;\n         // Combine all conditions that result in a full cache flush.\n-        fDoFullFlush = (mode == FLUSH_STATE_ALWAYS) || fCacheLarge || fCacheCritical || fPeriodicFlush || fFlushForPrune;\n+        fDoFullFlush = (mode == FlushStateMode::ALWAYS) || fCacheLarge || fCacheCritical || fPeriodicFlush || fFlushForPrune;\n         // Write blocks and block index to disk.\n         if (fDoFullFlush || fPeriodicWrite) {\n             // Depend on nMinDiskSpace to ensure we can write block index\n-            if (!CheckDiskSpace(0))\n+            if (!CheckDiskSpace(0, true))\n                 return state.Error(\"out of disk space\");\n             // First make sure all block and undo data is flushed to disk.\n             FlushBlockFile();\n@@ -2150,7 +2150,7 @@ bool static FlushStateToDisk(const CChainParams& chainparams, CValidationState &\n             nLastFlush = nNow;\n         }\n     }\n-    if (fDoFullFlush || ((mode == FLUSH_STATE_ALWAYS || mode == FLUSH_STATE_PERIODIC) && nNow > nLastSetChain + (int64_t)DATABASE_WRITE_INTERVAL * 1000000)) {\n+    if (fDoFullFlush || ((mode == FlushStateMode::ALWAYS || mode == FlushStateMode::PERIODIC) && nNow > nLastSetChain + (int64_t)DATABASE_WRITE_INTERVAL * 1000000)) {\n         // Update best block in wallet (so we can detect restored wallets).\n         GetMainSignals().SetBestChain(chainActive.GetLocator());\n         nLastSetChain = nNow;\n@@ -2164,14 +2164,14 @@ bool static FlushStateToDisk(const CChainParams& chainparams, CValidationState &\n void FlushStateToDisk() {\n     CValidationState state;\n     const CChainParams& chainparams = Params();\n-    FlushStateToDisk(chainparams, state, FLUSH_STATE_ALWAYS);\n+    FlushStateToDisk(chainparams, state, FlushStateMode::ALWAYS);\n }\n \n void PruneAndFlush() {\n     CValidationState state;\n     fCheckForPruning = true;\n     const CChainParams& chainparams = Params();\n-    FlushStateToDisk(chainparams, state, FLUSH_STATE_NONE);\n+    FlushStateToDisk(chainparams, state, FlushStateMode::NONE);\n }\n \n static void DoWarning(const std::string& strWarning)\n@@ -2199,9 +2199,9 @@ void static UpdateTip(const CBlockIndex *pindexNew, const CChainParams& chainPar\n         for (int bit = 0; bit < VERSIONBITS_NUM_BITS; bit++) {\n             WarningBitsConditionChecker checker(bit);\n             ThresholdState state = checker.GetStateFor(pindex, chainParams.GetConsensus(), warningcache[bit]);\n-            if (state == THRESHOLD_ACTIVE || state == THRESHOLD_LOCKED_IN) {\n+            if (state == ThresholdState::ACTIVE || state == ThresholdState::LOCKED_IN) {\n                 const std::string strWarning = strprintf(_(\"Warning: unknown new rules activated (versionbit %i)\"), bit);\n-                if (state == THRESHOLD_ACTIVE) {\n+                if (state == ThresholdState::ACTIVE) {\n                     DoWarning(strWarning);\n                 } else {\n                     warningMessages.push_back(strWarning);\n@@ -2267,7 +2267,7 @@ bool CChainState::DisconnectTip(CValidationState& state, const CChainParams& cha\n     }\n     LogPrint(BCLog::BENCH, \"- Disconnect block: %.2fms\\n\", (GetTimeMicros() - nStart) * MILLI);\n     // Write the chain state to disk, if necessary.\n-    if (!FlushStateToDisk(chainparams, state, FLUSH_STATE_IF_NEEDED))\n+    if (!FlushStateToDisk(chainparams, state, FlushStateMode::IF_NEEDED))\n         return false;\n \n     if (disconnectpool) {\n@@ -2405,7 +2405,7 @@ bool CChainState::ConnectTip(CValidationState& state, const CChainParams& chainp\n     int64_t nTime4 = GetTimeMicros(); nTimeFlush += nTime4 - nTime3;\n     LogPrint(BCLog::BENCH, \"  - Flush: %.2fms [%.2fs (%.2fms/blk)]\\n\", (nTime4 - nTime3) * MILLI, nTimeFlush * MICRO, nTimeFlush * MILLI / nBlocksTotal);\n     // Write the chain state to disk, if necessary.\n-    if (!FlushStateToDisk(chainparams, state, FLUSH_STATE_IF_NEEDED))\n+    if (!FlushStateToDisk(chainparams, state, FlushStateMode::IF_NEEDED))\n         return false;\n     int64_t nTime5 = GetTimeMicros(); nTimeChainState += nTime5 - nTime4;\n     LogPrint(BCLog::BENCH, \"  - Writing chainstate: %.2fms [%.2fs (%.2fms/blk)]\\n\", (nTime5 - nTime4) * MILLI, nTimeChainState * MICRO, nTimeChainState * MILLI / nBlocksTotal);\n@@ -2682,7 +2682,7 @@ bool CChainState::ActivateBestChain(CValidationState &state, const CChainParams&\n     CheckBlockIndex(chainparams.GetConsensus());\n \n     // Write changes periodically to disk, after relay.\n-    if (!FlushStateToDisk(chainparams, state, FLUSH_STATE_PERIODIC)) {\n+    if (!FlushStateToDisk(chainparams, state, FlushStateMode::PERIODIC)) {\n         return false;\n     }\n \n@@ -2953,7 +2953,7 @@ static bool FindBlockPos(CDiskBlockPos &pos, unsigned int nAddSize, unsigned int\n         if (nNewChunks > nOldChunks) {\n             if (fPruneMode)\n                 fCheckForPruning = true;\n-            if (CheckDiskSpace(nNewChunks * BLOCKFILE_CHUNK_SIZE - pos.nPos)) {\n+            if (CheckDiskSpace(nNewChunks * BLOCKFILE_CHUNK_SIZE - pos.nPos, true)) {\n                 FILE *file = OpenBlockFile(pos);\n                 if (file) {\n                     LogPrintf(\"Pre-allocating up to position 0x%x in blk%05u.dat\\n\", nNewChunks * BLOCKFILE_CHUNK_SIZE, pos.nFile);\n@@ -2986,7 +2986,7 @@ static bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos,\n     if (nNewChunks > nOldChunks) {\n         if (fPruneMode)\n             fCheckForPruning = true;\n-        if (CheckDiskSpace(nNewChunks * UNDOFILE_CHUNK_SIZE - pos.nPos)) {\n+        if (CheckDiskSpace(nNewChunks * UNDOFILE_CHUNK_SIZE - pos.nPos, true)) {\n             FILE *file = OpenUndoFile(pos);\n             if (file) {\n                 LogPrintf(\"Pre-allocating up to position 0x%x in rev%05u.dat\\n\", nNewChunks * UNDOFILE_CHUNK_SIZE, pos.nFile);\n@@ -3076,7 +3076,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n bool IsWitnessEnabled(const CBlockIndex* pindexPrev, const Consensus::Params& params)\n {\n     LOCK(cs_main);\n-    return (VersionBitsState(pindexPrev, params, Consensus::DEPLOYMENT_SEGWIT, versionbitscache) == THRESHOLD_ACTIVE);\n+    return (VersionBitsState(pindexPrev, params, Consensus::DEPLOYMENT_SEGWIT, versionbitscache) == ThresholdState::ACTIVE);\n }\n \n // Compute at which vout of the block's coinbase transaction the witness\n@@ -3195,7 +3195,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n \n     // Start enforcing BIP113 (Median Time Past) using versionbits logic.\n     int nLockTimeFlags = 0;\n-    if (VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_CSV, versionbitscache) == THRESHOLD_ACTIVE) {\n+    if (VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_CSV, versionbitscache) == ThresholdState::ACTIVE) {\n         nLockTimeFlags |= LOCKTIME_MEDIAN_TIME_PAST;\n     }\n \n@@ -3229,7 +3229,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     //   {0xaa, 0x21, 0xa9, 0xed}, and the following 32 bytes are SHA256^2(witness root, witness nonce). In case there are\n     //   multiple, the last one is used.\n     bool fHaveWitness = false;\n-    if (VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_SEGWIT, versionbitscache) == THRESHOLD_ACTIVE) {\n+    if (VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_SEGWIT, versionbitscache) == ThresholdState::ACTIVE) {\n         int commitpos = GetWitnessCommitmentIndex(block);\n         if (commitpos != -1) {\n             bool malleated = false;\n@@ -3443,7 +3443,7 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CVali\n     }\n \n     if (fCheckForPruning)\n-        FlushStateToDisk(chainparams, state, FLUSH_STATE_NONE); // we just allocated more disk space for block files\n+        FlushStateToDisk(chainparams, state, FlushStateMode::NONE); // we just allocated more disk space for block files\n \n     CheckBlockIndex(chainparams.GetConsensus());\n \n@@ -3596,7 +3596,7 @@ void PruneBlockFilesManual(int nManualPruneHeight)\n {\n     CValidationState state;\n     const CChainParams& chainparams = Params();\n-    FlushStateToDisk(chainparams, state, FLUSH_STATE_NONE, nManualPruneHeight);\n+    FlushStateToDisk(chainparams, state, FlushStateMode::NONE, nManualPruneHeight);\n }\n \n /**\n@@ -3661,9 +3661,9 @@ static void FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfte\n            nLastBlockWeCanPrune, count);\n }\n \n-bool CheckDiskSpace(uint64_t nAdditionalBytes)\n+bool CheckDiskSpace(uint64_t nAdditionalBytes, bool blocks_dir)\n {\n-    uint64_t nFreeBytesAvailable = fs::space(GetDataDir()).available;\n+    uint64_t nFreeBytesAvailable = fs::space(blocks_dir ? GetBlocksDir() : GetDataDir()).available;\n \n     // Check for nMinDiskSpace bytes (currently 50MB)\n     if (nFreeBytesAvailable < nMinDiskSpace + nAdditionalBytes)\n@@ -3706,7 +3706,7 @@ static FILE* OpenUndoFile(const CDiskBlockPos &pos, bool fReadOnly) {\n \n fs::path GetBlockPosFilename(const CDiskBlockPos &pos, const char *prefix)\n {\n-    return GetDataDir() / \"blocks\" / strprintf(\"%s%05u.dat\", prefix, pos.nFile);\n+    return GetBlocksDir() / strprintf(\"%s%05u.dat\", prefix, pos.nFile);\n }\n \n CBlockIndex * CChainState::InsertBlockIndex(const uint256& hash)\n@@ -4094,7 +4094,7 @@ bool CChainState::RewindBlockIndex(const CChainParams& params)\n             return error(\"RewindBlockIndex: unable to disconnect block at height %i\", pindex->nHeight);\n         }\n         // Occasionally flush state to disk.\n-        if (!FlushStateToDisk(params, state, FLUSH_STATE_PERIODIC))\n+        if (!FlushStateToDisk(params, state, FlushStateMode::PERIODIC))\n             return false;\n     }\n \n@@ -4160,7 +4160,7 @@ bool RewindBlockIndex(const CChainParams& params) {\n         // and skip it here, we're about to -reindex-chainstate anyway, so\n         // it'll get called a bunch real soon.\n         CValidationState state;\n-        if (!FlushStateToDisk(params, state, FLUSH_STATE_ALWAYS)) {\n+        if (!FlushStateToDisk(params, state, FlushStateMode::ALWAYS)) {\n             return false;\n         }\n     }"
      },
      {
        "sha": "45968797710c64e78a763c8b0f93dd95dfc17d42",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -254,7 +254,7 @@ bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<cons\n bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& block, CValidationState& state, const CChainParams& chainparams, const CBlockIndex** ppindex=nullptr, CBlockHeader *first_invalid=nullptr);\n \n /** Check whether enough disk space is available for an incoming block */\n-bool CheckDiskSpace(uint64_t nAdditionalBytes = 0);\n+bool CheckDiskSpace(uint64_t nAdditionalBytes = 0, bool blocks_dir = false);\n /** Open a block file (blk?????.dat) */\n FILE* OpenBlockFile(const CDiskBlockPos &pos, bool fReadOnly = false);\n /** Translation to a filesystem path */"
      },
      {
        "sha": "e3ec078173408b1e835fc605a00126606f78d6d0",
        "filename": "src/versionbits.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/versionbits.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/versionbits.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/versionbits.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -29,7 +29,7 @@ ThresholdState AbstractThresholdConditionChecker::GetStateFor(const CBlockIndex*\n \n     // Check if this deployment is always active.\n     if (nTimeStart == Consensus::BIP9Deployment::ALWAYS_ACTIVE) {\n-        return THRESHOLD_ACTIVE;\n+        return ThresholdState::ACTIVE;\n     }\n \n     // A block's state is always the same as that of the first of its period, so it is computed based on a pindexPrev whose height equals a multiple of nPeriod - 1.\n@@ -42,12 +42,12 @@ ThresholdState AbstractThresholdConditionChecker::GetStateFor(const CBlockIndex*\n     while (cache.count(pindexPrev) == 0) {\n         if (pindexPrev == nullptr) {\n             // The genesis block is by definition defined.\n-            cache[pindexPrev] = THRESHOLD_DEFINED;\n+            cache[pindexPrev] = ThresholdState::DEFINED;\n             break;\n         }\n         if (pindexPrev->GetMedianTimePast() < nTimeStart) {\n             // Optimization: don't recompute down further, as we know every earlier block will be before the start time\n-            cache[pindexPrev] = THRESHOLD_DEFINED;\n+            cache[pindexPrev] = ThresholdState::DEFINED;\n             break;\n         }\n         vToCompute.push_back(pindexPrev);\n@@ -65,17 +65,17 @@ ThresholdState AbstractThresholdConditionChecker::GetStateFor(const CBlockIndex*\n         vToCompute.pop_back();\n \n         switch (state) {\n-            case THRESHOLD_DEFINED: {\n+            case ThresholdState::DEFINED: {\n                 if (pindexPrev->GetMedianTimePast() >= nTimeTimeout) {\n-                    stateNext = THRESHOLD_FAILED;\n+                    stateNext = ThresholdState::FAILED;\n                 } else if (pindexPrev->GetMedianTimePast() >= nTimeStart) {\n-                    stateNext = THRESHOLD_STARTED;\n+                    stateNext = ThresholdState::STARTED;\n                 }\n                 break;\n             }\n-            case THRESHOLD_STARTED: {\n+            case ThresholdState::STARTED: {\n                 if (pindexPrev->GetMedianTimePast() >= nTimeTimeout) {\n-                    stateNext = THRESHOLD_FAILED;\n+                    stateNext = ThresholdState::FAILED;\n                     break;\n                 }\n                 // We need to count\n@@ -88,17 +88,17 @@ ThresholdState AbstractThresholdConditionChecker::GetStateFor(const CBlockIndex*\n                     pindexCount = pindexCount->pprev;\n                 }\n                 if (count >= nThreshold) {\n-                    stateNext = THRESHOLD_LOCKED_IN;\n+                    stateNext = ThresholdState::LOCKED_IN;\n                 }\n                 break;\n             }\n-            case THRESHOLD_LOCKED_IN: {\n+            case ThresholdState::LOCKED_IN: {\n                 // Always progresses into ACTIVE.\n-                stateNext = THRESHOLD_ACTIVE;\n+                stateNext = ThresholdState::ACTIVE;\n                 break;\n             }\n-            case THRESHOLD_FAILED:\n-            case THRESHOLD_ACTIVE: {\n+            case ThresholdState::FAILED:\n+            case ThresholdState::ACTIVE: {\n                 // Nothing happens, these are terminal states.\n                 break;\n             }\n@@ -149,7 +149,7 @@ int AbstractThresholdConditionChecker::GetStateSinceHeightFor(const CBlockIndex*\n     const ThresholdState initialState = GetStateFor(pindexPrev, params, cache);\n \n     // BIP 9 about state DEFINED: \"The genesis block is by definition in this state for each deployment.\"\n-    if (initialState == THRESHOLD_DEFINED) {\n+    if (initialState == ThresholdState::DEFINED) {\n         return 0;\n     }\n "
      },
      {
        "sha": "65cf308c7942edab01583e66e8e24929a7346911",
        "filename": "src/versionbits.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/versionbits.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/versionbits.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/versionbits.h?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -17,12 +17,12 @@ static const int32_t VERSIONBITS_TOP_MASK = 0xE0000000UL;\n /** Total bits available for versionbits */\n static const int32_t VERSIONBITS_NUM_BITS = 29;\n \n-enum ThresholdState {\n-    THRESHOLD_DEFINED,\n-    THRESHOLD_STARTED,\n-    THRESHOLD_LOCKED_IN,\n-    THRESHOLD_ACTIVE,\n-    THRESHOLD_FAILED,\n+enum class ThresholdState {\n+    DEFINED,\n+    STARTED,\n+    LOCKED_IN,\n+    ACTIVE,\n+    FAILED,\n };\n \n // A map that gives the state for blocks whose height is a multiple of Period()."
      },
      {
        "sha": "553cae4d026cf32bb5f48a92b74d78b3dc2eb6a7",
        "filename": "src/wallet/db.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/wallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/wallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -235,13 +235,13 @@ CDBEnv::VerifyResult CDBEnv::Verify(const std::string& strFile, recoverFunc_type\n     Db db(dbenv.get(), 0);\n     int result = db.verify(strFile.c_str(), nullptr, nullptr, 0);\n     if (result == 0)\n-        return VERIFY_OK;\n+        return VerifyResult::VERIFY_OK;\n     else if (recoverFunc == nullptr)\n-        return RECOVER_FAIL;\n+        return VerifyResult::RECOVER_FAIL;\n \n     // Try to recover:\n     bool fRecovered = (*recoverFunc)(fs::path(strPath) / strFile, out_backup_filename);\n-    return (fRecovered ? RECOVER_OK : RECOVER_FAIL);\n+    return (fRecovered ? VerifyResult::RECOVER_OK : VerifyResult::RECOVER_FAIL);\n }\n \n bool CDB::Recover(const fs::path& file_path, void *callbackDataIn, bool (*recoverKVcallback)(void* callbackData, CDataStream ssKey, CDataStream ssValue), std::string& newFilename)\n@@ -347,15 +347,15 @@ bool CDB::VerifyDatabaseFile(const fs::path& file_path, std::string& warningStr,\n     {\n         std::string backup_filename;\n         CDBEnv::VerifyResult r = env->Verify(walletFile, recoverFunc, backup_filename);\n-        if (r == CDBEnv::RECOVER_OK)\n+        if (r == CDBEnv::VerifyResult::RECOVER_OK)\n         {\n             warningStr = strprintf(_(\"Warning: Wallet file corrupt, data salvaged!\"\n                                      \" Original %s saved as %s in %s; if\"\n                                      \" your balance or transactions are incorrect you should\"\n                                      \" restore from a backup.\"),\n                                    walletFile, backup_filename, walletDir);\n         }\n-        if (r == CDBEnv::RECOVER_FAIL)\n+        if (r == CDBEnv::VerifyResult::RECOVER_FAIL)\n         {\n             errorStr = strprintf(_(\"%s corrupt, salvage failed\"), walletFile);\n             return false;"
      },
      {
        "sha": "65bb8cc2532f65186c1d9efbda58c7d389552eb4",
        "filename": "src/wallet/db.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/wallet/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/wallet/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.h?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -53,7 +53,7 @@ class CDBEnv\n      * This must be called BEFORE strFile is opened.\n      * Returns true if strFile is OK.\n      */\n-    enum VerifyResult { VERIFY_OK,\n+    enum class VerifyResult { VERIFY_OK,\n                         RECOVER_OK,\n                         RECOVER_FAIL };\n     typedef bool (*recoverFunc_type)(const fs::path& file_path, std::string& out_backup_filename);"
      },
      {
        "sha": "28b6153ce14b6e950bff1605eee4b63a035ff136",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -406,7 +406,7 @@ UniValue removeprunedfunds(const JSONRPCRequest& request)\n     vHash.push_back(hash);\n     std::vector<uint256> vHashOut;\n \n-    if (pwallet->ZapSelectTx(vHash, vHashOut) != DB_LOAD_OK) {\n+    if (pwallet->ZapSelectTx(vHash, vHashOut) != DBErrors::LOAD_OK) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Could not properly delete the transaction.\");\n     }\n "
      },
      {
        "sha": "c34b166a41c31c3a175c0d51cc004882dd96f24a",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -113,9 +113,9 @@ void WalletTxToJSON(const CWalletTx& wtx, UniValue& entry)\n     if (confirms <= 0) {\n         LOCK(mempool.cs);\n         RBFTransactionState rbfState = IsRBFOptIn(*wtx.tx, mempool);\n-        if (rbfState == RBF_TRANSACTIONSTATE_UNKNOWN)\n+        if (rbfState == RBFTransactionState::UNKNOWN)\n             rbfStatus = \"unknown\";\n-        else if (rbfState == RBF_TRANSACTIONSTATE_REPLACEABLE_BIP125)\n+        else if (rbfState == RBFTransactionState::REPLACEABLE_BIP125)\n             rbfStatus = \"yes\";\n     }\n     entry.pushKV(\"bip125-replaceable\", rbfStatus);"
      },
      {
        "sha": "cc6e491f5308944b8e221f5b2182b7d38a936aec",
        "filename": "src/wallet/test/accounting_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/wallet/test/accounting_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/wallet/test/accounting_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/accounting_tests.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -18,7 +18,7 @@ GetResults(CWallet& wallet, std::map<CAmount, CAccountingEntry>& results)\n     std::list<CAccountingEntry> aes;\n \n     results.clear();\n-    BOOST_CHECK(wallet.ReorderTransactions() == DB_LOAD_OK);\n+    BOOST_CHECK(wallet.ReorderTransactions() == DBErrors::LOAD_OK);\n     wallet.ListAccountCreditDebit(\"\", aes);\n     for (CAccountingEntry& ae : aes)\n     {"
      },
      {
        "sha": "c9843599d6d9b7653ebb9b7dd352d5ae77089a60",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 43,
        "deletions": 34,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -727,11 +727,11 @@ DBErrors CWallet::ReorderTransactions()\n             if (pwtx)\n             {\n                 if (!walletdb.WriteTx(*pwtx))\n-                    return DB_LOAD_FAIL;\n+                    return DBErrors::LOAD_FAIL;\n             }\n             else\n                 if (!walletdb.WriteAccountingEntry(pacentry->nEntryNo, *pacentry))\n-                    return DB_LOAD_FAIL;\n+                    return DBErrors::LOAD_FAIL;\n         }\n         else\n         {\n@@ -751,16 +751,16 @@ DBErrors CWallet::ReorderTransactions()\n             if (pwtx)\n             {\n                 if (!walletdb.WriteTx(*pwtx))\n-                    return DB_LOAD_FAIL;\n+                    return DBErrors::LOAD_FAIL;\n             }\n             else\n                 if (!walletdb.WriteAccountingEntry(pacentry->nEntryNo, *pacentry))\n-                    return DB_LOAD_FAIL;\n+                    return DBErrors::LOAD_FAIL;\n         }\n     }\n     walletdb.WriteOrderPosNext(nOrderPosNext);\n \n-    return DB_LOAD_OK;\n+    return DBErrors::LOAD_OK;\n }\n \n int64_t CWallet::IncOrderPosNext(CWalletDB *pwalletdb)\n@@ -2890,20 +2890,11 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransac\n                     nChangePosInOut = -1;\n                 }\n \n-                // Fill vin\n+                // Dummy fill vin for maximum size estimation\n                 //\n-                // Note how the sequence number is set to non-maxint so that\n-                // the nLockTime set above actually works.\n-                //\n-                // BIP125 defines opt-in RBF as any nSequence < maxint-1, so\n-                // we use the highest possible value in that range (maxint-2)\n-                // to avoid conflicting with other possible uses of nSequence,\n-                // and in the spirit of \"smallest possible change from prior\n-                // behavior.\"\n-                const uint32_t nSequence = coin_control.signalRbf ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n-                for (const auto& coin : setCoins)\n-                    txNew.vin.push_back(CTxIn(coin.outpoint,CScript(),\n-                                              nSequence));\n+                for (const auto& coin : setCoins) {\n+                    txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));\n+                }\n \n                 nBytes = CalculateMaximumSignedTxSize(txNew, this);\n                 if (nBytes < 0) {\n@@ -2993,11 +2984,29 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransac\n \n         if (nChangePosInOut == -1) reservekey.ReturnKey(); // Return any reserved key if we don't have change\n \n+        // Shuffle selected coins and fill in final vin\n+        txNew.vin.clear();\n+        std::vector<CInputCoin> selected_coins(setCoins.begin(), setCoins.end());\n+        std::shuffle(selected_coins.begin(), selected_coins.end(), FastRandomContext());\n+\n+        // Note how the sequence number is set to non-maxint so that\n+        // the nLockTime set above actually works.\n+        //\n+        // BIP125 defines opt-in RBF as any nSequence < maxint-1, so\n+        // we use the highest possible value in that range (maxint-2)\n+        // to avoid conflicting with other possible uses of nSequence,\n+        // and in the spirit of \"smallest possible change from prior\n+        // behavior.\"\n+        const uint32_t nSequence = coin_control.signalRbf ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n+        for (const auto& coin : selected_coins) {\n+            txNew.vin.push_back(CTxIn(coin.outpoint, CScript(), nSequence));\n+        }\n+\n         if (sign)\n         {\n             CTransaction txNewConst(txNew);\n             int nIn = 0;\n-            for (const auto& coin : setCoins)\n+            for (const auto& coin : selected_coins)\n             {\n                 const CScript& scriptPubKey = coin.txout.scriptPubKey;\n                 SignatureData sigdata;\n@@ -3137,7 +3146,7 @@ DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n \n     fFirstRunRet = false;\n     DBErrors nLoadWalletRet = CWalletDB(*dbw,\"cr+\").LoadWallet(this);\n-    if (nLoadWalletRet == DB_NEED_REWRITE)\n+    if (nLoadWalletRet == DBErrors::NEED_REWRITE)\n     {\n         if (dbw->Rewrite(\"\\x04pool\"))\n         {\n@@ -3153,12 +3162,12 @@ DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n     // This wallet is in its first run if all of these are empty\n     fFirstRunRet = mapKeys.empty() && mapCryptedKeys.empty() && mapWatchKeys.empty() && setWatchOnly.empty() && mapScripts.empty();\n \n-    if (nLoadWalletRet != DB_LOAD_OK)\n+    if (nLoadWalletRet != DBErrors::LOAD_OK)\n         return nLoadWalletRet;\n \n     uiInterface.LoadWallet(this);\n \n-    return DB_LOAD_OK;\n+    return DBErrors::LOAD_OK;\n }\n \n DBErrors CWallet::ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256>& vHashOut)\n@@ -3168,7 +3177,7 @@ DBErrors CWallet::ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256\n     for (uint256 hash : vHashOut)\n         mapWallet.erase(hash);\n \n-    if (nZapSelectTxRet == DB_NEED_REWRITE)\n+    if (nZapSelectTxRet == DBErrors::NEED_REWRITE)\n     {\n         if (dbw->Rewrite(\"\\x04pool\"))\n         {\n@@ -3181,19 +3190,19 @@ DBErrors CWallet::ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256\n         }\n     }\n \n-    if (nZapSelectTxRet != DB_LOAD_OK)\n+    if (nZapSelectTxRet != DBErrors::LOAD_OK)\n         return nZapSelectTxRet;\n \n     MarkDirty();\n \n-    return DB_LOAD_OK;\n+    return DBErrors::LOAD_OK;\n \n }\n \n DBErrors CWallet::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n {\n     DBErrors nZapWalletTxRet = CWalletDB(*dbw,\"cr+\").ZapWalletTx(vWtx);\n-    if (nZapWalletTxRet == DB_NEED_REWRITE)\n+    if (nZapWalletTxRet == DBErrors::NEED_REWRITE)\n     {\n         if (dbw->Rewrite(\"\\x04pool\"))\n         {\n@@ -3207,10 +3216,10 @@ DBErrors CWallet::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n         }\n     }\n \n-    if (nZapWalletTxRet != DB_LOAD_OK)\n+    if (nZapWalletTxRet != DBErrors::LOAD_OK)\n         return nZapWalletTxRet;\n \n-    return DB_LOAD_OK;\n+    return DBErrors::LOAD_OK;\n }\n \n \n@@ -3922,7 +3931,7 @@ CWallet* CWallet::CreateWalletFromFile(const std::string& name, const fs::path&\n \n         std::unique_ptr<CWallet> tempWallet = MakeUnique<CWallet>(name, CWalletDBWrapper::Create(path));\n         DBErrors nZapWalletRet = tempWallet->ZapWalletTx(vWtx);\n-        if (nZapWalletRet != DB_LOAD_OK) {\n+        if (nZapWalletRet != DBErrors::LOAD_OK) {\n             InitError(strprintf(_(\"Error loading %s: Wallet corrupted\"), walletFile));\n             return nullptr;\n         }\n@@ -3934,23 +3943,23 @@ CWallet* CWallet::CreateWalletFromFile(const std::string& name, const fs::path&\n     bool fFirstRun = true;\n     CWallet *walletInstance = new CWallet(name, CWalletDBWrapper::Create(path));\n     DBErrors nLoadWalletRet = walletInstance->LoadWallet(fFirstRun);\n-    if (nLoadWalletRet != DB_LOAD_OK)\n+    if (nLoadWalletRet != DBErrors::LOAD_OK)\n     {\n-        if (nLoadWalletRet == DB_CORRUPT) {\n+        if (nLoadWalletRet == DBErrors::CORRUPT) {\n             InitError(strprintf(_(\"Error loading %s: Wallet corrupted\"), walletFile));\n             return nullptr;\n         }\n-        else if (nLoadWalletRet == DB_NONCRITICAL_ERROR)\n+        else if (nLoadWalletRet == DBErrors::NONCRITICAL_ERROR)\n         {\n             InitWarning(strprintf(_(\"Error reading %s! All keys read correctly, but transaction data\"\n                                          \" or address book entries might be missing or incorrect.\"),\n                 walletFile));\n         }\n-        else if (nLoadWalletRet == DB_TOO_NEW) {\n+        else if (nLoadWalletRet == DBErrors::TOO_NEW) {\n             InitError(strprintf(_(\"Error loading %s: Wallet requires newer version of %s\"), walletFile, _(PACKAGE_NAME)));\n             return nullptr;\n         }\n-        else if (nLoadWalletRet == DB_NEED_REWRITE)\n+        else if (nLoadWalletRet == DBErrors::NEED_REWRITE)\n         {\n             InitError(strprintf(_(\"Wallet needed to be rewritten: restart %s to complete\"), _(PACKAGE_NAME)));\n             return nullptr;"
      },
      {
        "sha": "77cdfe7dd0f051f6216504e99c2cab06fdd28255",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 21,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -522,15 +522,15 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n {\n     CWalletScanState wss;\n     bool fNoncriticalErrors = false;\n-    DBErrors result = DB_LOAD_OK;\n+    DBErrors result = DBErrors::LOAD_OK;\n \n     LOCK(pwallet->cs_wallet);\n     try {\n         int nMinVersion = 0;\n         if (batch.Read((std::string)\"minversion\", nMinVersion))\n         {\n             if (nMinVersion > CLIENT_VERSION)\n-                return DB_TOO_NEW;\n+                return DBErrors::TOO_NEW;\n             pwallet->LoadMinVersion(nMinVersion);\n         }\n \n@@ -539,7 +539,7 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n         if (!pcursor)\n         {\n             LogPrintf(\"Error getting wallet database cursor\\n\");\n-            return DB_CORRUPT;\n+            return DBErrors::CORRUPT;\n         }\n \n         while (true)\n@@ -553,7 +553,7 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n             else if (ret != 0)\n             {\n                 LogPrintf(\"Error reading next record from wallet database\\n\");\n-                return DB_CORRUPT;\n+                return DBErrors::CORRUPT;\n             }\n \n             // Try to be tolerant of single corrupt records:\n@@ -563,7 +563,7 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n                 // losing keys is considered a catastrophic error, anything else\n                 // we assume the user can live with:\n                 if (IsKeyType(strType) || strType == \"defaultkey\")\n-                    result = DB_CORRUPT;\n+                    result = DBErrors::CORRUPT;\n                 else\n                 {\n                     // Leave other errors alone, if we try to fix them we might make things worse.\n@@ -582,15 +582,15 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n         throw;\n     }\n     catch (...) {\n-        result = DB_CORRUPT;\n+        result = DBErrors::CORRUPT;\n     }\n \n-    if (fNoncriticalErrors && result == DB_LOAD_OK)\n-        result = DB_NONCRITICAL_ERROR;\n+    if (fNoncriticalErrors && result == DBErrors::LOAD_OK)\n+        result = DBErrors::NONCRITICAL_ERROR;\n \n     // Any wallet corruption at all: skip any rewriting or\n     // upgrading, we don't want to make it worse.\n-    if (result != DB_LOAD_OK)\n+    if (result != DBErrors::LOAD_OK)\n         return result;\n \n     LogPrintf(\"nFileVersion = %d\\n\", wss.nFileVersion);\n@@ -607,7 +607,7 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n \n     // Rewrite encrypted wallets of versions 0.4.0 and 0.5.0rc:\n     if (wss.fIsEncrypted && (wss.nFileVersion == 40000 || wss.nFileVersion == 50000))\n-        return DB_NEED_REWRITE;\n+        return DBErrors::NEED_REWRITE;\n \n     if (wss.nFileVersion < CLIENT_VERSION) // Update\n         WriteVersion(CLIENT_VERSION);\n@@ -626,22 +626,22 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n \n DBErrors CWalletDB::FindWalletTx(std::vector<uint256>& vTxHash, std::vector<CWalletTx>& vWtx)\n {\n-    DBErrors result = DB_LOAD_OK;\n+    DBErrors result = DBErrors::LOAD_OK;\n \n     try {\n         int nMinVersion = 0;\n         if (batch.Read((std::string)\"minversion\", nMinVersion))\n         {\n             if (nMinVersion > CLIENT_VERSION)\n-                return DB_TOO_NEW;\n+                return DBErrors::TOO_NEW;\n         }\n \n         // Get cursor\n         Dbc* pcursor = batch.GetCursor();\n         if (!pcursor)\n         {\n             LogPrintf(\"Error getting wallet database cursor\\n\");\n-            return DB_CORRUPT;\n+            return DBErrors::CORRUPT;\n         }\n \n         while (true)\n@@ -655,7 +655,7 @@ DBErrors CWalletDB::FindWalletTx(std::vector<uint256>& vTxHash, std::vector<CWal\n             else if (ret != 0)\n             {\n                 LogPrintf(\"Error reading next record from wallet database\\n\");\n-                return DB_CORRUPT;\n+                return DBErrors::CORRUPT;\n             }\n \n             std::string strType;\n@@ -677,7 +677,7 @@ DBErrors CWalletDB::FindWalletTx(std::vector<uint256>& vTxHash, std::vector<CWal\n         throw;\n     }\n     catch (...) {\n-        result = DB_CORRUPT;\n+        result = DBErrors::CORRUPT;\n     }\n \n     return result;\n@@ -689,7 +689,7 @@ DBErrors CWalletDB::ZapSelectTx(std::vector<uint256>& vTxHashIn, std::vector<uin\n     std::vector<uint256> vTxHash;\n     std::vector<CWalletTx> vWtx;\n     DBErrors err = FindWalletTx(vTxHash, vWtx);\n-    if (err != DB_LOAD_OK) {\n+    if (err != DBErrors::LOAD_OK) {\n         return err;\n     }\n \n@@ -716,26 +716,26 @@ DBErrors CWalletDB::ZapSelectTx(std::vector<uint256>& vTxHashIn, std::vector<uin\n     }\n \n     if (delerror) {\n-        return DB_CORRUPT;\n+        return DBErrors::CORRUPT;\n     }\n-    return DB_LOAD_OK;\n+    return DBErrors::LOAD_OK;\n }\n \n DBErrors CWalletDB::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n {\n     // build list of wallet TXs\n     std::vector<uint256> vTxHash;\n     DBErrors err = FindWalletTx(vTxHash, vWtx);\n-    if (err != DB_LOAD_OK)\n+    if (err != DBErrors::LOAD_OK)\n         return err;\n \n     // erase each wallet TX\n     for (uint256& hash : vTxHash) {\n         if (!EraseTx(hash))\n-            return DB_CORRUPT;\n+            return DBErrors::CORRUPT;\n     }\n \n-    return DB_LOAD_OK;\n+    return DBErrors::LOAD_OK;\n }\n \n void MaybeCompactWalletDB()"
      },
      {
        "sha": "606b7dace721ead8015ba7671d5373a0ac0df78a",
        "filename": "src/wallet/walletdb.h",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/src/wallet/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/src/wallet/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.h?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -46,14 +46,14 @@ class uint160;\n class uint256;\n \n /** Error statuses for the wallet database */\n-enum DBErrors\n+enum class DBErrors\n {\n-    DB_LOAD_OK,\n-    DB_CORRUPT,\n-    DB_NONCRITICAL_ERROR,\n-    DB_TOO_NEW,\n-    DB_LOAD_FAIL,\n-    DB_NEED_REWRITE\n+    LOAD_OK,\n+    CORRUPT,\n+    NONCRITICAL_ERROR,\n+    TOO_NEW,\n+    LOAD_FAIL,\n+    NEED_REWRITE\n };\n \n /* simple HD chain data model */"
      },
      {
        "sha": "6ee6cb9a3e6977576780898f5561430a855d1f12",
        "filename": "test/functional/feature_blocksdir.py",
        "status": "added",
        "additions": 34,
        "deletions": 0,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/test/functional/feature_blocksdir.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/test/functional/feature_blocksdir.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_blocksdir.py?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -0,0 +1,34 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the blocksdir option.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework, initialize_datadir\n+\n+import shutil\n+import os\n+\n+class BlocksdirTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+\n+    def run_test(self):\n+        self.stop_node(0)\n+        node0path = os.path.join(self.options.tmpdir, \"node0\")\n+        shutil.rmtree(node0path)\n+        initialize_datadir(self.options.tmpdir, 0)\n+        self.log.info(\"Starting with non exiting blocksdir ...\")\n+        self.assert_start_raises_init_error(0, [\"-blocksdir=\"+self.options.tmpdir+ \"/blocksdir\"], \"Specified blocks director\")\n+        os.mkdir(self.options.tmpdir+ \"/blocksdir\")\n+        self.log.info(\"Starting with exiting blocksdir ...\")\n+        self.start_node(0, [\"-blocksdir=\"+self.options.tmpdir+ \"/blocksdir\"])\n+        self.log.info(\"mining blocks..\")\n+        self.nodes[0].generate(10)\n+        assert(os.path.isfile(os.path.join(self.options.tmpdir, \"blocksdir\", \"regtest\", \"blocks\", \"blk00000.dat\")))\n+        assert(os.path.isdir(os.path.join(self.options.tmpdir, \"node0\", \"regtest\", \"blocks\", \"index\")))\n+\n+if __name__ == '__main__':\n+    BlocksdirTest().main()"
      },
      {
        "sha": "8e97df23618e2b3cfc3ea5d5e40a29f5e8872a3f",
        "filename": "test/functional/feature_fee_estimation.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/test/functional/feature_fee_estimation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/test/functional/feature_fee_estimation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_fee_estimation.py?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -133,8 +133,8 @@ def setup_network(self):\n         which we will use to generate our transactions.\n         \"\"\"\n         self.add_nodes(3, extra_args=[[\"-maxorphantx=1000\", \"-whitelist=127.0.0.1\"],\n-                                      [\"-blockmaxsize=17000\", \"-maxorphantx=1000\"],\n-                                      [\"-blockmaxsize=8000\", \"-maxorphantx=1000\"]])\n+                                      [\"-maxorphantx=1000\"],\n+                                      [\"-maxorphantx=1000\"]])\n         # Use node0 to mine blocks for input splitting\n         # Node1 mines small blocks but that are bigger than the expected transaction rate.\n         # NOTE: the CreateNewBlock code starts counting block size at 1,000 bytes,"
      },
      {
        "sha": "ce6ec76c613ec05b458aa025c160d1e6761e65a8",
        "filename": "test/functional/feature_maxuploadtarget.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/test/functional/feature_maxuploadtarget.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/test/functional/feature_maxuploadtarget.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_maxuploadtarget.py?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -34,7 +34,7 @@ class MaxUploadTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.setup_clean_chain = True\n         self.num_nodes = 1\n-        self.extra_args = [[\"-maxuploadtarget=800\", \"-blockmaxsize=999000\"]]\n+        self.extra_args = [[\"-maxuploadtarget=800\"]]\n \n         # Cache for utxos, as the listunspent may take a long time later in the test\n         self.utxo_cache = []\n@@ -144,7 +144,7 @@ def run_test(self):\n         #stop and start node 0 with 1MB maxuploadtarget, whitelist 127.0.0.1\n         self.log.info(\"Restarting nodes with -whitelist=127.0.0.1\")\n         self.stop_node(0)\n-        self.start_node(0, [\"-whitelist=127.0.0.1\", \"-maxuploadtarget=1\", \"-blockmaxsize=999000\"])\n+        self.start_node(0, [\"-whitelist=127.0.0.1\", \"-maxuploadtarget=1\"])\n \n         # Reconnect to self.nodes[0]\n         self.nodes[0].add_p2p_connection(TestP2PConn())"
      },
      {
        "sha": "227ae6cb366ce260393aad86b90431c5738922de",
        "filename": "test/functional/feature_pruning.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/test/functional/feature_pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/test/functional/feature_pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_pruning.py?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -31,14 +31,14 @@ def set_test_params(self):\n \n         # Create nodes 0 and 1 to mine.\n         # Create node 2 to test pruning.\n-        self.full_node_default_args = [\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\", \"-checkblocks=5\", \"-limitdescendantcount=100\", \"-limitdescendantsize=5000\", \"-limitancestorcount=100\", \"-limitancestorsize=5000\" ]\n+        self.full_node_default_args = [\"-maxreceivebuffer=20000\", \"-checkblocks=5\", \"-limitdescendantcount=100\", \"-limitdescendantsize=5000\", \"-limitancestorcount=100\", \"-limitancestorsize=5000\" ]\n         # Create nodes 3 and 4 to test manual pruning (they will be re-started with manual pruning later)\n         # Create nodes 5 to test wallet in prune mode, but do not connect\n         self.extra_args = [self.full_node_default_args,\n                            self.full_node_default_args,\n                            [\"-maxreceivebuffer=20000\", \"-prune=550\"],\n-                           [\"-maxreceivebuffer=20000\", \"-blockmaxsize=999000\"],\n-                           [\"-maxreceivebuffer=20000\", \"-blockmaxsize=999000\"],\n+                           [\"-maxreceivebuffer=20000\"],\n+                           [\"-maxreceivebuffer=20000\"],\n                            [\"-prune=550\"]]\n \n     def setup_network(self):\n@@ -124,7 +124,7 @@ def reorg_test(self):\n         # Reboot node 1 to clear its mempool (hopefully make the invalidate faster)\n         # Lower the block max size so we don't keep mining all our big mempool transactions (from disconnected blocks)\n         self.stop_node(1)\n-        self.start_node(1, extra_args=[\"-maxreceivebuffer=20000\",\"-blockmaxsize=5000\", \"-checkblocks=5\", \"-disablesafemode\"])\n+        self.start_node(1, extra_args=[\"-maxreceivebuffer=20000\",\"-checkblocks=5\", \"-disablesafemode\"])\n \n         height = self.nodes[1].getblockcount()\n         self.log.info(\"Current block height: %d\" % height)\n@@ -147,7 +147,7 @@ def reorg_test(self):\n \n         # Reboot node1 to clear those giant tx's from mempool\n         self.stop_node(1)\n-        self.start_node(1, extra_args=[\"-maxreceivebuffer=20000\",\"-blockmaxsize=5000\", \"-checkblocks=5\", \"-disablesafemode\"])\n+        self.start_node(1, extra_args=[\"-maxreceivebuffer=20000\",\"-checkblocks=5\", \"-disablesafemode\"])\n \n         self.log.info(\"Generating new longer chain of 300 more blocks\")\n         self.nodes[1].generate(300)"
      },
      {
        "sha": "6f585f6825a8342cfc85a5d32bc182dc22dc2dce",
        "filename": "test/functional/interface_rest.py",
        "status": "modified",
        "additions": 32,
        "deletions": 7,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/test/functional/interface_rest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/test/functional/interface_rest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_rest.py?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -85,7 +85,7 @@ def run_test(self):\n         #######################################\n         # GETUTXOS: query an unspent outpoint #\n         #######################################\n-        json_request = '/checkmempool/'+txid+'-'+str(n)\n+        json_request = '/'+txid+'-'+str(n)\n         json_string = http_get_call(url.hostname, url.port, '/rest/getutxos'+json_request+self.FORMAT_SEPARATOR+'json')\n         json_obj = json.loads(json_string)\n \n@@ -100,7 +100,7 @@ def run_test(self):\n         #################################################\n         # GETUTXOS: now query an already spent outpoint #\n         #################################################\n-        json_request = '/checkmempool/'+vintx+'-0'\n+        json_request = '/'+vintx+'-0'\n         json_string = http_get_call(url.hostname, url.port, '/rest/getutxos'+json_request+self.FORMAT_SEPARATOR+'json')\n         json_obj = json.loads(json_string)\n \n@@ -117,7 +117,7 @@ def run_test(self):\n         ##################################################\n         # GETUTXOS: now check both with the same request #\n         ##################################################\n-        json_request = '/checkmempool/'+txid+'-'+str(n)+'/'+vintx+'-0'\n+        json_request = '/'+txid+'-'+str(n)+'/'+vintx+'-0'\n         json_string = http_get_call(url.hostname, url.port, '/rest/getutxos'+json_request+self.FORMAT_SEPARATOR+'json')\n         json_obj = json.loads(json_string)\n         assert_equal(len(json_obj['utxos']), 1)\n@@ -151,23 +151,48 @@ def run_test(self):\n         txid = self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 0.1)\n         json_string = http_get_call(url.hostname, url.port, '/rest/tx/'+txid+self.FORMAT_SEPARATOR+\"json\")\n         json_obj = json.loads(json_string)\n-        vintx = json_obj['vin'][0]['txid'] # get the vin to later check for utxo (should be spent by then)\n+        # get the spent output to later check for utxo (should be spent by then)\n+        spent = '{}-{}'.format(json_obj['vin'][0]['txid'], json_obj['vin'][0]['vout'])\n         # get n of 0.1 outpoint\n         n = 0\n         for vout in json_obj['vout']:\n             if vout['value'] == 0.1:\n                 n = vout['n']\n+        spending = '{}-{}'.format(txid, n)\n \n-        json_request = '/'+txid+'-'+str(n)\n+        json_request = '/'+spending\n         json_string = http_get_call(url.hostname, url.port, '/rest/getutxos'+json_request+self.FORMAT_SEPARATOR+'json')\n         json_obj = json.loads(json_string)\n-        assert_equal(len(json_obj['utxos']), 0) #there should be an outpoint because it has just added to the mempool\n+        assert_equal(len(json_obj['utxos']), 0) #there should be no outpoint because it has just added to the mempool\n \n-        json_request = '/checkmempool/'+txid+'-'+str(n)\n+        json_request = '/checkmempool/'+spending\n         json_string = http_get_call(url.hostname, url.port, '/rest/getutxos'+json_request+self.FORMAT_SEPARATOR+'json')\n         json_obj = json.loads(json_string)\n         assert_equal(len(json_obj['utxos']), 1) #there should be an outpoint because it has just added to the mempool\n \n+        json_request = '/'+spent\n+        json_string = http_get_call(url.hostname, url.port, '/rest/getutxos'+json_request+self.FORMAT_SEPARATOR+'json')\n+        json_obj = json.loads(json_string)\n+        assert_equal(len(json_obj['utxos']), 1) #there should be an outpoint because its spending tx is not confirmed\n+\n+        json_request = '/checkmempool/'+spent\n+        json_string = http_get_call(url.hostname, url.port, '/rest/getutxos'+json_request+self.FORMAT_SEPARATOR+'json')\n+        json_obj = json.loads(json_string)\n+        assert_equal(len(json_obj['utxos']), 0) #there should be no outpoint because it has just spent (by mempool tx)\n+\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        json_request = '/'+spending\n+        json_string = http_get_call(url.hostname, url.port, '/rest/getutxos'+json_request+self.FORMAT_SEPARATOR+'json')\n+        json_obj = json.loads(json_string)\n+        assert_equal(len(json_obj['utxos']), 1) #there should be an outpoint because it was mined\n+\n+        json_request = '/checkmempool/'+spending\n+        json_string = http_get_call(url.hostname, url.port, '/rest/getutxos'+json_request+self.FORMAT_SEPARATOR+'json')\n+        json_obj = json.loads(json_string)\n+        assert_equal(len(json_obj['utxos']), 1) #there should be an outpoint because it was mined\n+\n         #do some invalid requests\n         json_request = '{\"checkmempool'\n         response = http_post_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'json', json_request, True)"
      },
      {
        "sha": "29ec535ca8e4c7c4c8db7c078b0e7a692dfef113",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26e7f38260dc7150c0453fefa86712843d125e40/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26e7f38260dc7150c0453fefa86712843d125e40/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=26e7f38260dc7150c0453fefa86712843d125e40",
        "patch": "@@ -136,6 +136,7 @@\n     'p2p_unrequested_blocks.py',\n     'feature_logging.py',\n     'p2p_node_network_limited.py',\n+    'feature_blocksdir.py',\n     'feature_config_args.py',\n     # Don't append tests at the end to avoid merge conflicts\n     # Put them in a random line within the section that fits their approximate run-time"
      }
    ]
  },
  {
    "sha": "e133491e622961af01ac73af64b403e481d34a12",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMTMzNDkxZTYyMjk2MWFmMDFhYzczYWY2NGI0MDNlNDgxZDM0YTEy",
    "commit": {
      "author": {
        "name": "murrayn",
        "email": "github@nesbitt.ca",
        "date": "2018-03-28T07:46:48Z"
      },
      "committer": {
        "name": "murrayn",
        "email": "github@nesbitt.ca",
        "date": "2018-03-28T07:46:48Z"
      },
      "message": "Maintain alphabetical order of options in --help output.",
      "tree": {
        "sha": "3085178ac2a0b2c9b276e6dafbd589dd52b54e57",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3085178ac2a0b2c9b276e6dafbd589dd52b54e57"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e133491e622961af01ac73af64b403e481d34a12",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e133491e622961af01ac73af64b403e481d34a12",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e133491e622961af01ac73af64b403e481d34a12",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e133491e622961af01ac73af64b403e481d34a12/comments",
    "author": {
      "login": "murrayn",
      "id": 5404807,
      "node_id": "MDQ6VXNlcjU0MDQ4MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5404807?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/murrayn",
      "html_url": "https://github.com/murrayn",
      "followers_url": "https://api.github.com/users/murrayn/followers",
      "following_url": "https://api.github.com/users/murrayn/following{/other_user}",
      "gists_url": "https://api.github.com/users/murrayn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/murrayn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/murrayn/subscriptions",
      "organizations_url": "https://api.github.com/users/murrayn/orgs",
      "repos_url": "https://api.github.com/users/murrayn/repos",
      "events_url": "https://api.github.com/users/murrayn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/murrayn/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "murrayn",
      "id": 5404807,
      "node_id": "MDQ6VXNlcjU0MDQ4MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5404807?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/murrayn",
      "html_url": "https://github.com/murrayn",
      "followers_url": "https://api.github.com/users/murrayn/followers",
      "following_url": "https://api.github.com/users/murrayn/following{/other_user}",
      "gists_url": "https://api.github.com/users/murrayn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/murrayn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/murrayn/subscriptions",
      "organizations_url": "https://api.github.com/users/murrayn/orgs",
      "repos_url": "https://api.github.com/users/murrayn/repos",
      "events_url": "https://api.github.com/users/murrayn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/murrayn/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "26e7f38260dc7150c0453fefa86712843d125e40",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/26e7f38260dc7150c0453fefa86712843d125e40",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/26e7f38260dc7150c0453fefa86712843d125e40"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 2,
      "deletions": 2
    },
    "files": [
      {
        "sha": "feaa0fc9f2f57307c9ab9ecd7c611e978dd68898",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e133491e622961af01ac73af64b403e481d34a12/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e133491e622961af01ac73af64b403e481d34a12/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=e133491e622961af01ac73af64b403e481d34a12",
        "patch": "@@ -340,13 +340,13 @@ std::string HelpMessage(HelpMessageMode mode)\n         \"potentially skip their script verification (0 to verify all, default: %s, testnet: %s)\"),\n             defaultChainParams->GetConsensus().defaultAssumeValid.GetHex(),\n             testnetChainParams->GetConsensus().defaultAssumeValid.GetHex()));\n-    strUsage += HelpMessageOpt(\"-blocksdir=<dir>\", _(\n-        \"Specify blocks directory (default: <datadir>/blocks)\"));\n     strUsage += HelpMessageOpt(\"-blocknotify=<cmd>\", _(\n         \"Execute command when the best block changes (%s in cmd is replaced by block hash)\"));\n     strUsage += HelpMessageOpt(\"-blockreconstructionextratxn=<n>\", strprintf(_(\n         \"Extra transactions to keep in memory for compact block reconstructions (default: %u)\"),\n             DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN));\n+    strUsage += HelpMessageOpt(\"-blocksdir=<dir>\", _(\n+        \"Specify blocks directory (default: <datadir>/blocks)\"));\n     if (showDebug)\n         strUsage += HelpMessageOpt(\"-blocksonly\", strprintf(_(\n             \"Whether to operate in a blocks only mode (default: %u)\"), DEFAULT_BLOCKSONLY));"
      }
    ]
  }
]