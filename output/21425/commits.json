[
  {
    "sha": "fa2a80bf12d87c1d8a1a98b2faa8eea6731aac0e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTJhODBiZjEyZDg3YzFkOGExYTk4YjJmYWE4ZWVhNjczMWFhYzBl",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-03-12T11:57:43Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-03-17T09:35:30Z"
      },
      "message": "refactor: Pass PeerManagerImpl members only once\n\nCan be reviewed with\n\n--word-diff-regex=. --ignore-all-space",
      "tree": {
        "sha": "063914bf778495595269ad912da460910ed1815c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/063914bf778495595269ad912da460910ed1815c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa2a80bf12d87c1d8a1a98b2faa8eea6731aac0e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUjDGQv6Avu60sSpgtxwLp4j2UxLWGXy5uSmr5Ob+Ee9T/Tm+u88jgfrkLjUI7f3\nVIPw4vcn3lvKm3/44vmIh44PJr/9JO2ePF7dC1bIohqWRHNeu1xX5V4izrZpId+1\nVSWqByTUssS6jIRZ3A4QnCfc8GQc5sbitXyqOmSwvnkO2k1iHdngHKoCx92Fz7G1\n49JPy3xDu6jHxOxJi6Odnsz0ERlBDorZ291NRhK6ZBvhadsR90bDuABxcK9xFPy+\nHXPr7B3p//2nZA3TurX/1aUSgxRU+KxKXkaamgu9qHvXgcNYiUblpZmhH+DcI5sU\nsi6I1dfornuHbwhxeJpoWzMTB4WJBOKGzoItXXbYAz46f++N42pqN+0mNY8nYvH4\n5X2+2RfZoku7A0/867JNtk4DLgvr3wQzcrN6B8pGtdiZEppibn5UhrZi6XnsDrgK\nbiwdRKnZdf03mniuRBuF1SQEInPyOjckWtbjyizFxQMhwzRvw78lW7Rn6Cg8+OXy\nowiwz6UT\n=tLmH\n-----END PGP SIGNATURE-----",
        "payload": "tree 063914bf778495595269ad912da460910ed1815c\nparent 5ef16038a1a8adc25438d77f60d83b2c01738fcf\nauthor MarcoFalke <falke.marco@gmail.com> 1615550263 +0100\ncommitter MarcoFalke <falke.marco@gmail.com> 1615973730 +0100\n\nrefactor: Pass PeerManagerImpl members only once\n\nCan be reviewed with\n\n--word-diff-regex=. --ignore-all-space\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa2a80bf12d87c1d8a1a98b2faa8eea6731aac0e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa2a80bf12d87c1d8a1a98b2faa8eea6731aac0e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa2a80bf12d87c1d8a1a98b2faa8eea6731aac0e/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5ef16038a1a8adc25438d77f60d83b2c01738fcf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5ef16038a1a8adc25438d77f60d83b2c01738fcf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5ef16038a1a8adc25438d77f60d83b2c01738fcf"
      }
    ],
    "stats": {
      "total": 121,
      "additions": 54,
      "deletions": 67
    },
    "files": [
      {
        "sha": "d2d605efe3f08967709649526f289e8d5e5fa3f2",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 54,
        "deletions": 67,
        "changes": 121,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa2a80bf12d87c1d8a1a98b2faa8eea6731aac0e/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa2a80bf12d87c1d8a1a98b2faa8eea6731aac0e/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=fa2a80bf12d87c1d8a1a98b2faa8eea6731aac0e",
        "patch": "@@ -474,22 +474,19 @@ class PeerManagerImpl final : public PeerManager\n     size_t vExtraTxnForCompactIt GUARDED_BY(g_cs_orphans) = 0;\n \n     void ProcessBlockAvailability(NodeId nodeid) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-    void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-    bool CanDirectFetch(const Consensus::Params &consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-    bool BlockRequestAllowed(const CBlockIndex* pindex, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    void UpdateBlockAvailability(NodeId nodeid, const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool CanDirectFetch() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool BlockRequestAllowed(const CBlockIndex* pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     bool AlreadyHaveBlock(const uint256& block_hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-    void ProcessGetBlockData(CNode& pfrom, Peer& peer, const CChainParams& chainparams, const CInv& inv, CConnman& connman);\n-    bool PrepareBlockFilterRequest(CNode& peer, const CChainParams& chain_params,\n+    void ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv& inv);\n+    bool PrepareBlockFilterRequest(CNode& peer,\n                                    BlockFilterType filter_type, uint32_t start_height,\n                                    const uint256& stop_hash, uint32_t max_height_diff,\n                                    const CBlockIndex*& stop_index,\n                                    BlockFilterIndex*& filter_index);\n-    void ProcessGetCFilters(CNode& peer, CDataStream& vRecv, const CChainParams& chain_params,\n-                                   CConnman& connman);\n-    void ProcessGetCFHeaders(CNode& peer, CDataStream& vRecv, const CChainParams& chain_params,\n-                                    CConnman& connman);\n-    void ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv, const CChainParams& chain_params,\n-                                    CConnman& connman);\n+    void ProcessGetCFilters(CNode& peer, CDataStream& vRecv);\n+    void ProcessGetCFHeaders(CNode& peer, CDataStream& vRecv);\n+    void ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv);\n };\n } // namespace\n \n@@ -728,9 +725,9 @@ bool PeerManagerImpl::TipMayBeStale()\n     return m_last_tip_update < GetTime() - consensusParams.nPowTargetSpacing * 3 && mapBlocksInFlight.empty();\n }\n \n-bool PeerManagerImpl::CanDirectFetch(const Consensus::Params &consensusParams)\n+bool PeerManagerImpl::CanDirectFetch()\n {\n-    return m_chainman.ActiveChain().Tip()->GetBlockTime() > GetAdjustedTime() - consensusParams.nPowTargetSpacing * 20;\n+    return m_chainman.ActiveChain().Tip()->GetBlockTime() > GetAdjustedTime() - m_chainparams.GetConsensus().nPowTargetSpacing * 20;\n }\n \n static bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n@@ -1193,13 +1190,13 @@ bool PeerManagerImpl::MaybePunishNodeForTx(NodeId nodeid, const TxValidationStat\n // active chain if they are no more than a month older (both in time, and in\n // best equivalent proof of work) than the best header chain we know about and\n // we fully-validated them at some point.\n-bool PeerManagerImpl::BlockRequestAllowed(const CBlockIndex* pindex, const Consensus::Params& consensusParams)\n+bool PeerManagerImpl::BlockRequestAllowed(const CBlockIndex* pindex)\n {\n     AssertLockHeld(cs_main);\n     if (m_chainman.ActiveChain().Contains(pindex)) return true;\n     return pindex->IsValid(BLOCK_VALID_SCRIPTS) && (pindexBestHeader != nullptr) &&\n-        (pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() < STALE_RELAY_AGE_LIMIT) &&\n-        (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, consensusParams) < STALE_RELAY_AGE_LIMIT);\n+           (pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() < STALE_RELAY_AGE_LIMIT) &&\n+           (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, m_chainparams.GetConsensus()) < STALE_RELAY_AGE_LIMIT);\n }\n \n std::unique_ptr<PeerManager> PeerManager::make(const CChainParams& chainparams, CConnman& connman, BanMan* banman,\n@@ -1529,13 +1526,12 @@ static void RelayAddress(const CNode& originator,\n     connman.ForEachNodeThen(std::move(sortfunc), std::move(pushfunc));\n }\n \n-void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CChainParams& chainparams, const CInv& inv, CConnman& connman)\n+void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv& inv)\n {\n     bool send = false;\n     std::shared_ptr<const CBlock> a_recent_block;\n     std::shared_ptr<const CBlockHeaderAndShortTxIDs> a_recent_compact_block;\n     bool fWitnessesPresentInARecentCompactBlock;\n-    const Consensus::Params& consensusParams = chainparams.GetConsensus();\n     {\n         LOCK(cs_most_recent_block);\n         a_recent_block = most_recent_block;\n@@ -1561,23 +1557,23 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CChain\n     } // release cs_main before calling ActivateBestChain\n     if (need_activate_chain) {\n         BlockValidationState state;\n-        if (!m_chainman.ActiveChainstate().ActivateBestChain(state, chainparams, a_recent_block)) {\n+        if (!m_chainman.ActiveChainstate().ActivateBestChain(state, m_chainparams, a_recent_block)) {\n             LogPrint(BCLog::NET, \"failed to activate chain (%s)\\n\", state.ToString());\n         }\n     }\n \n     LOCK(cs_main);\n     const CBlockIndex* pindex = m_chainman.m_blockman.LookupBlockIndex(inv.hash);\n     if (pindex) {\n-        send = BlockRequestAllowed(pindex, consensusParams);\n+        send = BlockRequestAllowed(pindex);\n         if (!send) {\n             LogPrint(BCLog::NET, \"%s: ignoring request from peer=%i for old block that isn't in the main chain\\n\", __func__, pfrom.GetId());\n         }\n     }\n     const CNetMsgMaker msgMaker(pfrom.GetCommonVersion());\n     // disconnect node in case we have reached the outbound limit for serving historical blocks\n     if (send &&\n-        connman.OutboundTargetReached(true) &&\n+        m_connman.OutboundTargetReached(true) &&\n         (((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() > HISTORICAL_BLOCK_AGE)) || inv.IsMsgFilteredBlk()) &&\n         !pfrom.HasPermission(PF_DOWNLOAD) // nodes with the download permission may exceed target\n     ) {\n@@ -1608,23 +1604,24 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CChain\n             // Fast-path: in this case it is possible to serve the block directly from disk,\n             // as the network format matches the format on disk\n             std::vector<uint8_t> block_data;\n-            if (!ReadRawBlockFromDisk(block_data, pindex, chainparams.MessageStart())) {\n+            if (!ReadRawBlockFromDisk(block_data, pindex, m_chainparams.MessageStart())) {\n                 assert(!\"cannot load block from disk\");\n             }\n-            connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::BLOCK, MakeSpan(block_data)));\n+            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::BLOCK, MakeSpan(block_data)));\n             // Don't set pblock as we've sent the block\n         } else {\n             // Send block from disk\n             std::shared_ptr<CBlock> pblockRead = std::make_shared<CBlock>();\n-            if (!ReadBlockFromDisk(*pblockRead, pindex, consensusParams))\n+            if (!ReadBlockFromDisk(*pblockRead, pindex, m_chainparams.GetConsensus())) {\n                 assert(!\"cannot load block from disk\");\n+            }\n             pblock = pblockRead;\n         }\n         if (pblock) {\n             if (inv.IsMsgBlk()) {\n-                connman.PushMessage(&pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, *pblock));\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, *pblock));\n             } else if (inv.IsMsgWitnessBlk()) {\n-                connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::BLOCK, *pblock));\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::BLOCK, *pblock));\n             } else if (inv.IsMsgFilteredBlk()) {\n                 bool sendMerkleBlock = false;\n                 CMerkleBlock merkleBlock;\n@@ -1636,7 +1633,7 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CChain\n                     }\n                 }\n                 if (sendMerkleBlock) {\n-                    connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::MERKLEBLOCK, merkleBlock));\n+                    m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::MERKLEBLOCK, merkleBlock));\n                     // CMerkleBlock just contains hashes, so also push any transactions in the block the client did not see\n                     // This avoids hurting performance by pointlessly requiring a round-trip\n                     // Note that there is currently no way for a node to request any single transactions we didn't send here -\n@@ -1645,7 +1642,7 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CChain\n                     // however we MUST always provide at least what the remote peer needs\n                     typedef std::pair<unsigned int, uint256> PairType;\n                     for (PairType& pair : merkleBlock.vMatchedTxn)\n-                        connman.PushMessage(&pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *pblock->vtx[pair.first]));\n+                        m_connman.PushMessage(&pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *pblock->vtx[pair.first]));\n                 }\n                 // else\n                     // no response\n@@ -1656,15 +1653,15 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CChain\n                 // instead we respond with the full, non-compact block.\n                 bool fPeerWantsWitness = State(pfrom.GetId())->fWantsCmpctWitness;\n                 int nSendFlags = fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n-                if (CanDirectFetch(consensusParams) && pindex->nHeight >= m_chainman.ActiveChain().Height() - MAX_CMPCTBLOCK_DEPTH) {\n+                if (CanDirectFetch() && pindex->nHeight >= m_chainman.ActiveChain().Height() - MAX_CMPCTBLOCK_DEPTH) {\n                     if ((fPeerWantsWitness || !fWitnessesPresentInARecentCompactBlock) && a_recent_compact_block && a_recent_compact_block->header.GetHash() == pindex->GetBlockHash()) {\n-                        connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block));\n+                        m_connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block));\n                     } else {\n                         CBlockHeaderAndShortTxIDs cmpctblock(*pblock, fPeerWantsWitness);\n-                        connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n+                        m_connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n                     }\n                 } else {\n-                    connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCK, *pblock));\n+                    m_connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCK, *pblock));\n                 }\n             }\n         }\n@@ -1678,7 +1675,7 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CChain\n                 // wait for other stuff first.\n                 std::vector<CInv> vInv;\n                 vInv.push_back(CInv(MSG_BLOCK, m_chainman.ActiveChain().Tip()->GetBlockHash()));\n-                connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::INV, vInv));\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::INV, vInv));\n                 peer.m_continuation_block.SetNull();\n             }\n         }\n@@ -1779,7 +1776,7 @@ void PeerManagerImpl::ProcessGetData(CNode& pfrom, Peer& peer, const std::atomic\n     if (it != peer.m_getdata_requests.end() && !pfrom.fPauseSend) {\n         const CInv &inv = *it++;\n         if (inv.IsGenBlkMsg()) {\n-            ProcessGetBlockData(pfrom, peer, m_chainparams, inv, m_connman);\n+            ProcessGetBlockData(pfrom, peer, inv);\n         }\n         // else: If the first item on the queue is an unknown type, we erase it\n         // and continue processing the queue on the next call.\n@@ -1927,10 +1924,9 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n             m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, m_chainman.ActiveChain().GetLocator(pindexLast), uint256()));\n         }\n \n-        bool fCanDirectFetch = CanDirectFetch(m_chainparams.GetConsensus());\n         // If this set of headers is valid and ends in a block with at least as\n         // much work as our tip, download as much as possible.\n-        if (fCanDirectFetch && pindexLast->IsValid(BLOCK_VALID_TREE) && m_chainman.ActiveChain().Tip()->nChainWork <= pindexLast->nChainWork) {\n+        if (CanDirectFetch() && pindexLast->IsValid(BLOCK_VALID_TREE) && m_chainman.ActiveChain().Tip()->nChainWork <= pindexLast->nChainWork) {\n             std::vector<const CBlockIndex*> vToFetch;\n             const CBlockIndex *pindexWalk = pindexLast;\n             // Calculate all the blocks we'd need to switch to pindexLast, up to a limit.\n@@ -2103,7 +2099,6 @@ void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n  * May disconnect from the peer in the case of a bad request.\n  *\n  * @param[in]   peer            The peer that we received the request from\n- * @param[in]   chain_params    Chain parameters\n  * @param[in]   filter_type     The filter type the request is for. Must be basic filters.\n  * @param[in]   start_height    The start height for the request\n  * @param[in]   stop_hash       The stop_hash for the request\n@@ -2112,11 +2107,11 @@ void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n  * @param[out]  filter_index    The filter index, if the request can be serviced.\n  * @return                      True if the request can be serviced.\n  */\n-bool PeerManagerImpl::PrepareBlockFilterRequest(CNode& peer, const CChainParams& chain_params,\n-                                      BlockFilterType filter_type, uint32_t start_height,\n-                                      const uint256& stop_hash, uint32_t max_height_diff,\n-                                      const CBlockIndex*& stop_index,\n-                                      BlockFilterIndex*& filter_index)\n+bool PeerManagerImpl::PrepareBlockFilterRequest(CNode& peer,\n+                                                BlockFilterType filter_type, uint32_t start_height,\n+                                                const uint256& stop_hash, uint32_t max_height_diff,\n+                                                const CBlockIndex*& stop_index,\n+                                                BlockFilterIndex*& filter_index)\n {\n     const bool supported_filter_type =\n         (filter_type == BlockFilterType::BASIC &&\n@@ -2133,7 +2128,7 @@ bool PeerManagerImpl::PrepareBlockFilterRequest(CNode& peer, const CChainParams&\n         stop_index = m_chainman.m_blockman.LookupBlockIndex(stop_hash);\n \n         // Check that the stop block exists and the peer would be allowed to fetch it.\n-        if (!stop_index || !BlockRequestAllowed(stop_index, chain_params.GetConsensus())) {\n+        if (!stop_index || !BlockRequestAllowed(stop_index)) {\n             LogPrint(BCLog::NET, \"peer %d requested invalid block hash: %s\\n\",\n                      peer.GetId(), stop_hash.ToString());\n             peer.fDisconnect = true;\n@@ -2172,11 +2167,8 @@ bool PeerManagerImpl::PrepareBlockFilterRequest(CNode& peer, const CChainParams&\n  *\n  * @param[in]   peer            The peer that we received the request from\n  * @param[in]   vRecv           The raw message received\n- * @param[in]   chain_params    Chain parameters\n- * @param[in]   connman         Pointer to the connection manager\n  */\n-void PeerManagerImpl::ProcessGetCFilters(CNode& peer, CDataStream& vRecv, const CChainParams& chain_params,\n-                               CConnman& connman)\n+void PeerManagerImpl::ProcessGetCFilters(CNode& peer, CDataStream& vRecv)\n {\n     uint8_t filter_type_ser;\n     uint32_t start_height;\n@@ -2188,7 +2180,7 @@ void PeerManagerImpl::ProcessGetCFilters(CNode& peer, CDataStream& vRecv, const\n \n     const CBlockIndex* stop_index;\n     BlockFilterIndex* filter_index;\n-    if (!PrepareBlockFilterRequest(peer, chain_params, filter_type, start_height, stop_hash,\n+    if (!PrepareBlockFilterRequest(peer, filter_type, start_height, stop_hash,\n                                    MAX_GETCFILTERS_SIZE, stop_index, filter_index)) {\n         return;\n     }\n@@ -2203,7 +2195,7 @@ void PeerManagerImpl::ProcessGetCFilters(CNode& peer, CDataStream& vRecv, const\n     for (const auto& filter : filters) {\n         CSerializedNetMsg msg = CNetMsgMaker(peer.GetCommonVersion())\n             .Make(NetMsgType::CFILTER, filter);\n-        connman.PushMessage(&peer, std::move(msg));\n+        m_connman.PushMessage(&peer, std::move(msg));\n     }\n }\n \n@@ -2214,11 +2206,8 @@ void PeerManagerImpl::ProcessGetCFilters(CNode& peer, CDataStream& vRecv, const\n  *\n  * @param[in]   peer            The peer that we received the request from\n  * @param[in]   vRecv           The raw message received\n- * @param[in]   chain_params    Chain parameters\n- * @param[in]   connman         Pointer to the connection manager\n  */\n-void PeerManagerImpl::ProcessGetCFHeaders(CNode& peer, CDataStream& vRecv, const CChainParams& chain_params,\n-                                CConnman& connman)\n+void PeerManagerImpl::ProcessGetCFHeaders(CNode& peer, CDataStream& vRecv)\n {\n     uint8_t filter_type_ser;\n     uint32_t start_height;\n@@ -2230,7 +2219,7 @@ void PeerManagerImpl::ProcessGetCFHeaders(CNode& peer, CDataStream& vRecv, const\n \n     const CBlockIndex* stop_index;\n     BlockFilterIndex* filter_index;\n-    if (!PrepareBlockFilterRequest(peer, chain_params, filter_type, start_height, stop_hash,\n+    if (!PrepareBlockFilterRequest(peer, filter_type, start_height, stop_hash,\n                                    MAX_GETCFHEADERS_SIZE, stop_index, filter_index)) {\n         return;\n     }\n@@ -2259,7 +2248,7 @@ void PeerManagerImpl::ProcessGetCFHeaders(CNode& peer, CDataStream& vRecv, const\n               stop_index->GetBlockHash(),\n               prev_header,\n               filter_hashes);\n-    connman.PushMessage(&peer, std::move(msg));\n+    m_connman.PushMessage(&peer, std::move(msg));\n }\n \n /**\n@@ -2269,11 +2258,8 @@ void PeerManagerImpl::ProcessGetCFHeaders(CNode& peer, CDataStream& vRecv, const\n  *\n  * @param[in]   peer            The peer that we received the request from\n  * @param[in]   vRecv           The raw message received\n- * @param[in]   chain_params    Chain parameters\n- * @param[in]   connman         Pointer to the connection manager\n  */\n-void PeerManagerImpl::ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv, const CChainParams& chain_params,\n-                                CConnman& connman)\n+void PeerManagerImpl::ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv)\n {\n     uint8_t filter_type_ser;\n     uint256 stop_hash;\n@@ -2284,7 +2270,7 @@ void PeerManagerImpl::ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv, const\n \n     const CBlockIndex* stop_index;\n     BlockFilterIndex* filter_index;\n-    if (!PrepareBlockFilterRequest(peer, chain_params, filter_type, /*start_height=*/0, stop_hash,\n+    if (!PrepareBlockFilterRequest(peer, filter_type, /*start_height=*/0, stop_hash,\n                                    /*max_height_diff=*/std::numeric_limits<uint32_t>::max(),\n                                    stop_index, filter_index)) {\n         return;\n@@ -2310,7 +2296,7 @@ void PeerManagerImpl::ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv, const\n               filter_type_ser,\n               stop_index->GetBlockHash(),\n               headers);\n-    connman.PushMessage(&peer, std::move(msg));\n+    m_connman.PushMessage(&peer, std::move(msg));\n }\n \n void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRecv,\n@@ -2948,7 +2934,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 return;\n             }\n \n-            if (!BlockRequestAllowed(pindex, m_chainparams.GetConsensus())) {\n+            if (!BlockRequestAllowed(pindex)) {\n                 LogPrint(BCLog::NET, \"%s: ignoring request from peer=%i for old block header that isn't in the main chain\\n\", __func__, pfrom.GetId());\n                 return;\n             }\n@@ -3286,8 +3272,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         }\n \n         // If we're not close to tip yet, give up and let parallel block fetch work its magic\n-        if (!fAlreadyInFlight && !CanDirectFetch(m_chainparams.GetConsensus()))\n+        if (!fAlreadyInFlight && !CanDirectFetch()) {\n             return;\n+        }\n \n         if (IsWitnessEnabled(pindex->pprev, m_chainparams.GetConsensus()) && !nodestate->fSupportsDesiredCmpctVersion) {\n             // Don't bother trying to process compact blocks from v1 peers\n@@ -3780,17 +3767,17 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n     }\n \n     if (msg_type == NetMsgType::GETCFILTERS) {\n-        ProcessGetCFilters(pfrom, vRecv, m_chainparams, m_connman);\n+        ProcessGetCFilters(pfrom, vRecv);\n         return;\n     }\n \n     if (msg_type == NetMsgType::GETCFHEADERS) {\n-        ProcessGetCFHeaders(pfrom, vRecv, m_chainparams, m_connman);\n+        ProcessGetCFHeaders(pfrom, vRecv);\n         return;\n     }\n \n     if (msg_type == NetMsgType::GETCFCHECKPT) {\n-        ProcessGetCFCheckPt(pfrom, vRecv, m_chainparams, m_connman);\n+        ProcessGetCFCheckPt(pfrom, vRecv);\n         return;\n     }\n \n@@ -4105,7 +4092,7 @@ void PeerManagerImpl::CheckForStaleTipAndEvictPeers()\n         m_stale_tip_check_time = time_in_seconds + STALE_CHECK_INTERVAL;\n     }\n \n-    if (!m_initial_sync_finished && CanDirectFetch(m_chainparams.GetConsensus())) {\n+    if (!m_initial_sync_finished && CanDirectFetch()) {\n         m_connman.StartExtraBlockRelayPeers();\n         m_initial_sync_finished = true;\n     }"
      }
    ]
  }
]