[
  {
    "sha": "102a33a0405e4236fee1def3a847892cab605bdf",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMDJhMzNhMDQwNWU0MjM2ZmVlMWRlZjNhODQ3ODkyY2FiNjA1YmRm",
    "commit": {
      "author": {
        "name": "Luke Dashjr",
        "email": "luke-jr+git@utopios.org",
        "date": "2012-08-01T22:36:01Z"
      },
      "committer": {
        "name": "Luke Dashjr",
        "email": "luke-jr+git@utopios.org",
        "date": "2015-04-06T22:47:19Z"
      },
      "message": "CreateNewBlock: Consider parent transactions in the \"cost\" of child transactions until confirmed, and confirm them together",
      "tree": {
        "sha": "9339aa91b68927c2f3b5d2f1e2352da1fb4459e7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9339aa91b68927c2f3b5d2f1e2352da1fb4459e7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/102a33a0405e4236fee1def3a847892cab605bdf",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/102a33a0405e4236fee1def3a847892cab605bdf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/102a33a0405e4236fee1def3a847892cab605bdf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/102a33a0405e4236fee1def3a847892cab605bdf/comments",
    "author": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1b178a7f966cd3649b7f0a52ffc4b8ef4c227900",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1b178a7f966cd3649b7f0a52ffc4b8ef4c227900",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1b178a7f966cd3649b7f0a52ffc4b8ef4c227900"
      }
    ],
    "stats": {
      "total": 326,
      "additions": 229,
      "deletions": 97
    },
    "files": [
      {
        "sha": "c419535db0a183f9cf282b2c26dacdfb7ec1542b",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 229,
        "deletions": 97,
        "changes": 326,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/102a33a0405e4236fee1def3a847892cab605bdf/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/102a33a0405e4236fee1def3a847892cab605bdf/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=102a33a0405e4236fee1def3a847892cab605bdf",
        "patch": "@@ -34,27 +34,165 @@ using namespace std;\n // transactions in the memory pool. When we select transactions from the\n // pool, we select by highest priority or fee rate, so we might consider\n // transactions that depend on transactions that aren't yet in the block.\n-// The COrphan class keeps track of these 'temporary orphans' while\n-// CreateBlock is figuring out which transactions to include.\n+// CTxInfo represents a logical transaction to potentially be included in blocks\n+// It stores extra metadata such as the subjective priority of a transaction at\n+// the time of building the block. When there are unconfirmed transactions that\n+// depend on other unconfirmed transactions, these \"child\" transactions' CTxInfo\n+// object factors in its \"parents\" to its priority and effective size; this way,\n+// the \"child\" can cover the \"cost\" of its \"parents\", and the \"parents\" are\n+// included into the block as part of the \"child\".\n //\n-class COrphan\n+class CTxInfo;\n+typedef std::map<uint256, CTxInfo> mapInfo_t;\n+\n+class CTxInfo\n {\n public:\n+    mapInfo_t *pmapInfoById;\n     const CTransaction* ptx;\n+    uint256 hash;\n+private:\n     set<uint256> setDependsOn;\n-    CFeeRate feeRate;\n+public:\n+    set<uint256> setDependents;\n     double dPriority;\n+    CAmount nTxFee;\n+    int nTxSigOpsP2SHOnly;\n+    bool fInvalid;\n+    unsigned int nSize;\n+    unsigned int nEffectiveSizeCached;\n+\n+    CTxInfo() : pmapInfoById(NULL), ptx(NULL), hash(0), dPriority(0), nTxFee(0), fInvalid(false), nSize(0), nEffectiveSizeCached(0)\n+    {\n+    }\n+\n+    void addDependsOn(const uint256& hashPrev)\n+    {\n+        setDependsOn.insert(hashPrev);\n+        nEffectiveSizeCached = 0;\n+    }\n+\n+    void rmDependsOn(const uint256& hashPrev)\n+    {\n+        setDependsOn.erase(hashPrev);\n+        nEffectiveSizeCached = 0;\n+    }\n+\n+    // effectiveSize handles inheriting the fInvalid flag as a side effect\n+    unsigned int effectiveSize()\n+    {\n+        if (fInvalid)\n+            return -1;\n+\n+        if (nEffectiveSizeCached)\n+            return nEffectiveSizeCached;\n+\n+        assert(pmapInfoById);\n+\n+        if (!nSize)\n+            nSize = ::GetSerializeSize(*ptx, SER_NETWORK, PROTOCOL_VERSION);\n+        unsigned int nEffectiveSize = nSize;\n+        BOOST_FOREACH(const uint256& dephash, setDependsOn)\n+        {\n+            CTxInfo& depinfo = (*pmapInfoById)[dephash];\n+            nEffectiveSize += depinfo.effectiveSize();\n+\n+            if (depinfo.fInvalid)\n+            {\n+                fInvalid = true;\n+                return -1;\n+            }\n+        }\n+        nEffectiveSizeCached = nEffectiveSize;\n+        return nEffectiveSize;\n+    }\n \n-    COrphan(const CTransaction* ptxIn) : ptx(ptxIn), feeRate(0), dPriority(0)\n+    unsigned int effectiveSizeMod()\n     {\n+        unsigned int nTxSizeMod = effectiveSize();\n+        const CTransaction &tx = *ptx;\n+        // In order to avoid disincentivizing cleaning up the UTXO set we don't count\n+        // the constant overhead for each txin and up to 110 bytes of scriptSig (which\n+        // is enough to cover a compressed pubkey p2sh redemption) for priority.\n+        // Providing any more cleanup incentive than making additional inputs free would\n+        // risk encouraging people to create junk outputs to redeem later.\n+        BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+        {\n+            unsigned int offset = 41U + min(110U, (unsigned int)txin.scriptSig.size());\n+            if (nTxSizeMod > offset)\n+                nTxSizeMod -= offset;\n+        }\n+        return nTxSizeMod;\n+    }\n+\n+    double getPriority()\n+    {\n+        // Priority is sum(valuein * age) / modified_txsize\n+        return dPriority / effectiveSizeMod();\n+    }\n+\n+    CFeeRate getFeeRate()\n+    {\n+        return CFeeRate(nTxFee, effectiveSize());\n+    }\n+\n+    unsigned int GetLegacySigOpCount()\n+    {\n+        assert(pmapInfoById);\n+\n+        unsigned int n = ::GetLegacySigOpCount(*ptx);\n+        BOOST_FOREACH(const uint256& dephash, setDependsOn)\n+        {\n+            CTxInfo& depinfo = (*pmapInfoById)[dephash];\n+            n += depinfo.GetLegacySigOpCount();\n+        }\n+        return n;\n+    }\n+\n+    bool DoInputs(CCoinsViewCache& view, const int nHeight, std::vector<CTxInfo*>& vAdded, unsigned int& nSigOpCounter)\n+    {\n+        const CTransaction& tx = *ptx;\n+\n+        if (view.HaveCoins(hash))\n+            // Already included in block template\n+            return true;\n+\n+        assert(pmapInfoById);\n+\n+        BOOST_FOREACH(const uint256& dephash, setDependsOn)\n+        {\n+            CTxInfo& depinfo = (*pmapInfoById)[dephash];\n+            if (!depinfo.DoInputs(view, nHeight, vAdded, nSigOpCounter))\n+                return false;\n+        }\n+\n+        if (!view.HaveInputs(tx))\n+            return false;\n+\n+        nTxSigOpsP2SHOnly = GetP2SHSigOpCount(tx, view);\n+        nSigOpCounter += nTxSigOpsP2SHOnly;\n+\n+        // Note that flags: we don't want to set mempool/IsStandard()\n+        // policy here, but we still have to ensure that the block we\n+        // create only contains transactions that are valid in new blocks.\n+        CValidationState state;\n+        if (!CheckInputs(tx, state, view, true, MANDATORY_SCRIPT_VERIFY_FLAGS, true))\n+            return false;\n+\n+        CTxUndo txundo;\n+        UpdateCoins(tx, state, view, txundo, nHeight);\n+\n+        vAdded.push_back(this);\n+\n+        return true;\n     }\n };\n \n uint64_t nLastBlockTx = 0;\n uint64_t nLastBlockSize = 0;\n \n-// We want to sort transactions by priority and fee rate, so:\n-typedef boost::tuple<double, CFeeRate, const CTransaction*> TxPriority;\n+// We want to sort transactions by priority and fee, so:\n+typedef CTxInfo* TxPriority;\n class TxPriorityCompare\n {\n     bool byFee;\n@@ -66,15 +204,15 @@ class TxPriorityCompare\n     {\n         if (byFee)\n         {\n-            if (a.get<1>() == b.get<1>())\n-                return a.get<0>() < b.get<0>();\n-            return a.get<1>() < b.get<1>();\n+            if (a->getFeeRate() == b->getFeeRate())\n+                return a->getPriority() < b->getPriority();\n+            return a->getFeeRate() < b->getFeeRate();\n         }\n         else\n         {\n-            if (a.get<0>() == b.get<0>())\n-                return a.get<1>() < b.get<1>();\n-            return a.get<0>() < b.get<0>();\n+            if (a->getPriority() == b->getPriority())\n+                return a->getFeeRate() < b->getFeeRate();\n+            return a->getPriority() < b->getPriority();\n         }\n     }\n };\n@@ -138,82 +276,76 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n         CCoinsViewCache view(pcoinsTip);\n \n         // Priority order to process transactions\n-        list<COrphan> vOrphan; // list memory doesn't move\n-        map<uint256, vector<COrphan*> > mapDependers;\n+        mapInfo_t mapInfoById;\n         bool fPrintPriority = GetBoolArg(\"-printpriority\", false);\n \n         // This vector will be sorted into a priority queue:\n         vector<TxPriority> vecPriority;\n         vecPriority.reserve(mempool.mapTx.size());\n+\n         for (map<uint256, CTxMemPoolEntry>::iterator mi = mempool.mapTx.begin();\n              mi != mempool.mapTx.end(); ++mi)\n         {\n             const CTransaction& tx = mi->second.GetTx();\n+\n+            const uint256& hash = tx.GetHash();\n+            CTxInfo& txinfo = mapInfoById[hash];\n+            txinfo.hash = hash;\n+            txinfo.pmapInfoById = &mapInfoById;\n+            txinfo.ptx = &tx;\n+\n             if (tx.IsCoinBase() || !IsFinalTx(tx, nHeight))\n+            {\n+                txinfo.fInvalid = true;\n                 continue;\n+            }\n \n-            COrphan* porphan = NULL;\n-            double dPriority = 0;\n+            double& dPriority = txinfo.dPriority;\n+            CAmount& nTxFee = txinfo.nTxFee;\n             CAmount nTotalIn = 0;\n-            bool fMissingInputs = false;\n             BOOST_FOREACH(const CTxIn& txin, tx.vin)\n             {\n                 // Read prev transaction\n-                if (!view.HaveCoins(txin.prevout.hash))\n+                CAmount nValueIn;\n+                int nConf;\n+                if (view.HaveCoins(txin.prevout.hash))\n                 {\n-                    // This should never happen; all transactions in the memory\n-                    // pool should connect to either transactions in the chain\n-                    // or other transactions in the memory pool.\n-                    if (!mempool.mapTx.count(txin.prevout.hash))\n-                    {\n-                        LogPrintf(\"ERROR: mempool transaction missing input\\n\");\n-                        if (fDebug) assert(\"mempool transaction missing input\" == 0);\n-                        fMissingInputs = true;\n-                        if (porphan)\n-                            vOrphan.pop_back();\n-                        break;\n-                    }\n-\n-                    // Has to wait for dependencies\n-                    if (!porphan)\n-                    {\n-                        // Use list for automatic deletion\n-                        vOrphan.push_back(COrphan(&tx));\n-                        porphan = &vOrphan.back();\n-                    }\n-                    mapDependers[txin.prevout.hash].push_back(porphan);\n-                    porphan->setDependsOn.insert(txin.prevout.hash);\n-                    nTotalIn += mempool.mapTx[txin.prevout.hash].GetTx().vout[txin.prevout.n].nValue;\n-                    continue;\n+                    const CCoins* coins = view.AccessCoins(txin.prevout.hash);\n+                    assert(coins);\n+                    // Input is confirmed\n+                    nConf = nHeight - coins->nHeight;\n+                    nValueIn = coins->vout[txin.prevout.n].nValue;\n+                    dPriority += (double)nValueIn * nConf;\n+                }\n+                else\n+                if (mempool.mapTx.count(txin.prevout.hash))\n+                {\n+                    // Input is still unconfirmed\n+                    const uint256& hashPrev = txin.prevout.hash;\n+                    nValueIn = mempool.mapTx[hashPrev].GetTx().vout[txin.prevout.n].nValue;\n+                    txinfo.addDependsOn(hashPrev);\n+                    mapInfoById[hashPrev].setDependents.insert(hash);\n+                    nConf = 0;\n+                }\n+                else\n+                {\n+                    // We don't know where the input is\n+                    // In this case, it's impossible to include this transaction in a block, so mark it invalid and move on\n+                    txinfo.fInvalid = true;\n+                    LogPrintf(\"priority %s invalid input %s\\n\", txinfo.hash.ToString().substr(0,10).c_str(), txin.prevout.hash.ToString().substr(0,10).c_str());\n+                    goto nexttxn;\n                 }\n-                const CCoins* coins = view.AccessCoins(txin.prevout.hash);\n-                assert(coins);\n \n-                CAmount nValueIn = coins->vout[txin.prevout.n].nValue;\n                 nTotalIn += nValueIn;\n-\n-                int nConf = nHeight - coins->nHeight;\n-\n-                dPriority += (double)nValueIn * nConf;\n             }\n-            if (fMissingInputs) continue;\n \n-            // Priority is sum(valuein * age) / modified_txsize\n-            unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n-            dPriority = tx.ComputePriority(dPriority, nTxSize);\n+            nTxFee = nTotalIn - tx.GetValueOut();\n \n-            uint256 hash = tx.GetHash();\n             mempool.ApplyDeltas(hash, dPriority, nTotalIn);\n \n-            CFeeRate feeRate(nTotalIn-tx.GetValueOut(), nTxSize);\n+            vecPriority.push_back(&txinfo);\n \n-            if (porphan)\n-            {\n-                porphan->dPriority = dPriority;\n-                porphan->feeRate = feeRate;\n-            }\n-            else\n-                vecPriority.push_back(TxPriority(dPriority, feeRate, &mi->second.GetTx()));\n+nexttxn:    (void)1;\n         }\n \n         // Collect transactions into block\n@@ -228,20 +360,24 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n         while (!vecPriority.empty())\n         {\n             // Take highest priority transaction off the priority queue:\n-            double dPriority = vecPriority.front().get<0>();\n-            CFeeRate feeRate = vecPriority.front().get<1>();\n-            const CTransaction& tx = *(vecPriority.front().get<2>());\n-\n+            CTxInfo& txinfo = *(vecPriority.front());\n             std::pop_heap(vecPriority.begin(), vecPriority.end(), comparer);\n             vecPriority.pop_back();\n \n+            if (txinfo.fInvalid)\n+                continue;\n+\n+            const CTransaction& tx = *txinfo.ptx;\n+            double dPriority = txinfo.getPriority();\n+            CFeeRate feeRate = txinfo.getFeeRate();\n+\n             // Size limits\n-            unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n+            unsigned int nTxSize = txinfo.effectiveSize();\n             if (nBlockSize + nTxSize >= nBlockMaxSize)\n                 continue;\n \n             // Legacy limits on sigOps:\n-            unsigned int nTxSigOps = GetLegacySigOpCount(tx);\n+            unsigned int nTxSigOps = txinfo.GetLegacySigOpCount();\n             if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n                 continue;\n \n@@ -263,56 +399,52 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n                 std::make_heap(vecPriority.begin(), vecPriority.end(), comparer);\n             }\n \n-            if (!view.HaveInputs(tx))\n-                continue;\n-\n-            CAmount nTxFees = view.GetValueIn(tx)-tx.GetValueOut();\n+            // second layer cached modifications just for this transaction\n+            CCoinsViewCache viewTemp(&view);\n \n-            nTxSigOps += GetP2SHSigOpCount(tx, view);\n-            if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n+            std::vector<CTxInfo*> vAdded;\n+            if (!txinfo.DoInputs(viewTemp, nHeight, vAdded, nTxSigOps))\n                 continue;\n \n-            // Note that flags: we don't want to set mempool/IsStandard()\n-            // policy here, but we still have to ensure that the block we\n-            // create only contains transactions that are valid in new blocks.\n-            CValidationState state;\n-            if (!CheckInputs(tx, state, view, true, MANDATORY_SCRIPT_VERIFY_FLAGS, true))\n+            if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n                 continue;\n \n-            CTxUndo txundo;\n-            UpdateCoins(tx, state, view, txundo, nHeight);\n+            // push changes from the second layer cache to the first one\n+            viewTemp.Flush();\n \n             // Added\n-            pblock->vtx.push_back(tx);\n-            pblocktemplate->vTxFees.push_back(nTxFees);\n-            pblocktemplate->vTxSigOps.push_back(nTxSigOps);\n             nBlockSize += nTxSize;\n-            ++nBlockTx;\n+            nBlockTx += vAdded.size();\n             nBlockSigOps += nTxSigOps;\n-            nFees += nTxFees;\n \n             if (fPrintPriority)\n             {\n                 LogPrintf(\"priority %.1f fee %s txid %s\\n\",\n                     dPriority, feeRate.ToString(), tx.GetHash().ToString());\n             }\n \n-            // Add transactions that depend on this one to the priority queue\n-            if (mapDependers.count(hash))\n+            bool fResort = false;\n+            BOOST_FOREACH(CTxInfo* ptxinfo, vAdded)\n             {\n-                BOOST_FOREACH(COrphan* porphan, mapDependers[hash])\n+                pblock->vtx.push_back(*ptxinfo->ptx);\n+                pblocktemplate->vTxFees.push_back(ptxinfo->nTxFee);\n+                pblocktemplate->vTxSigOps.push_back(GetLegacySigOpCount(*ptxinfo->ptx) + ptxinfo->nTxSigOpsP2SHOnly);\n+                nFees += ptxinfo->nTxFee;\n+\n+                ptxinfo->fInvalid = true;\n+                if (!ptxinfo->setDependents.empty())\n                 {\n-                    if (!porphan->setDependsOn.empty())\n+                    fResort = true;\n+                    BOOST_FOREACH(const uint256& dhash, ptxinfo->setDependents)\n                     {\n-                        porphan->setDependsOn.erase(hash);\n-                        if (porphan->setDependsOn.empty())\n-                        {\n-                            vecPriority.push_back(TxPriority(porphan->dPriority, porphan->feeRate, porphan->ptx));\n-                            std::push_heap(vecPriority.begin(), vecPriority.end(), comparer);\n-                        }\n+                        CTxInfo& dtxinfo = mapInfoById[dhash];\n+                        dtxinfo.rmDependsOn(ptxinfo->hash);\n                     }\n                 }\n             }\n+            if (fResort)\n+                // Re-sort the priority queue to pick up on improved standing\n+                std::make_heap(vecPriority.begin(), vecPriority.end(), comparer);\n         }\n \n         nLastBlockTx = nBlockTx;"
      }
    ]
  },
  {
    "sha": "b7d980681d8d5368f82a5c5a9938d954590a58af",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiN2Q5ODA2ODFkOGQ1MzY4ZjgyYTVjNWE5OTM4ZDk1NDU5MGE1OGFm",
    "commit": {
      "author": {
        "name": "Luke Dashjr",
        "email": "luke-jr+git@utopios.org",
        "date": "2015-06-24T07:18:42Z"
      },
      "committer": {
        "name": "Luke Dashjr",
        "email": "luke-jr+git@utopios.org",
        "date": "2015-06-24T07:18:42Z"
      },
      "message": "Merge branch 'minedeps-0.10.x' into minedeps",
      "tree": {
        "sha": "73328427b91da36fdd481ba77c07d55d0b0f14c3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/73328427b91da36fdd481ba77c07d55d0b0f14c3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b7d980681d8d5368f82a5c5a9938d954590a58af",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b7d980681d8d5368f82a5c5a9938d954590a58af",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b7d980681d8d5368f82a5c5a9938d954590a58af",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b7d980681d8d5368f82a5c5a9938d954590a58af/comments",
    "author": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e9d0d252fc57119766f5d7b58715451dd42b1ce6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e9d0d252fc57119766f5d7b58715451dd42b1ce6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e9d0d252fc57119766f5d7b58715451dd42b1ce6"
      },
      {
        "sha": "102a33a0405e4236fee1def3a847892cab605bdf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/102a33a0405e4236fee1def3a847892cab605bdf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/102a33a0405e4236fee1def3a847892cab605bdf"
      }
    ],
    "stats": {
      "total": 324,
      "additions": 228,
      "deletions": 96
    },
    "files": [
      {
        "sha": "c55db339ffbd90ce5a9875b5c8302c7705e91dd1",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 228,
        "deletions": 96,
        "changes": 324,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7d980681d8d5368f82a5c5a9938d954590a58af/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7d980681d8d5368f82a5c5a9938d954590a58af/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=b7d980681d8d5368f82a5c5a9938d954590a58af",
        "patch": "@@ -36,27 +36,164 @@ using namespace std;\n // transactions in the memory pool. When we select transactions from the\n // pool, we select by highest priority or fee rate, so we might consider\n // transactions that depend on transactions that aren't yet in the block.\n-// The COrphan class keeps track of these 'temporary orphans' while\n-// CreateBlock is figuring out which transactions to include.\n+// CTxInfo represents a logical transaction to potentially be included in blocks\n+// It stores extra metadata such as the subjective priority of a transaction at\n+// the time of building the block. When there are unconfirmed transactions that\n+// depend on other unconfirmed transactions, these \"child\" transactions' CTxInfo\n+// object factors in its \"parents\" to its priority and effective size; this way,\n+// the \"child\" can cover the \"cost\" of its \"parents\", and the \"parents\" are\n+// included into the block as part of the \"child\".\n //\n-class COrphan\n+class CTxInfo;\n+typedef std::map<uint256, CTxInfo> mapInfo_t;\n+\n+class CTxInfo\n {\n public:\n+    mapInfo_t *pmapInfoById;\n     const CTransaction* ptx;\n+    uint256 hash;\n+private:\n     set<uint256> setDependsOn;\n-    CFeeRate feeRate;\n+public:\n+    set<uint256> setDependents;\n     double dPriority;\n+    CAmount nTxFee;\n+    int nTxSigOpsP2SHOnly;\n+    bool fInvalid;\n+    unsigned int nSize;\n+    unsigned int nEffectiveSizeCached;\n+\n+    CTxInfo() : pmapInfoById(NULL), ptx(NULL), hash(), dPriority(0), nTxFee(0), fInvalid(false), nSize(0), nEffectiveSizeCached(0)\n+    {\n+    }\n+\n+    void addDependsOn(const uint256& hashPrev)\n+    {\n+        setDependsOn.insert(hashPrev);\n+        nEffectiveSizeCached = 0;\n+    }\n+\n+    void rmDependsOn(const uint256& hashPrev)\n+    {\n+        setDependsOn.erase(hashPrev);\n+        nEffectiveSizeCached = 0;\n+    }\n+\n+    // effectiveSize handles inheriting the fInvalid flag as a side effect\n+    unsigned int effectiveSize()\n+    {\n+        if (fInvalid)\n+            return -1;\n+\n+        if (nEffectiveSizeCached)\n+            return nEffectiveSizeCached;\n+\n+        assert(pmapInfoById);\n+\n+        if (!nSize)\n+            nSize = ::GetSerializeSize(*ptx, SER_NETWORK, PROTOCOL_VERSION);\n+        unsigned int nEffectiveSize = nSize;\n+        BOOST_FOREACH(const uint256& dephash, setDependsOn)\n+        {\n+            CTxInfo& depinfo = (*pmapInfoById)[dephash];\n+            nEffectiveSize += depinfo.effectiveSize();\n+\n+            if (depinfo.fInvalid)\n+            {\n+                fInvalid = true;\n+                return -1;\n+            }\n+        }\n+        nEffectiveSizeCached = nEffectiveSize;\n+        return nEffectiveSize;\n+    }\n+\n+    unsigned int effectiveSizeMod()\n+    {\n+        unsigned int nTxSizeMod = effectiveSize();\n+        const CTransaction &tx = *ptx;\n+        // In order to avoid disincentivizing cleaning up the UTXO set we don't count\n+        // the constant overhead for each txin and up to 110 bytes of scriptSig (which\n+        // is enough to cover a compressed pubkey p2sh redemption) for priority.\n+        // Providing any more cleanup incentive than making additional inputs free would\n+        // risk encouraging people to create junk outputs to redeem later.\n+        BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+        {\n+            unsigned int offset = 41U + min(110U, (unsigned int)txin.scriptSig.size());\n+            if (nTxSizeMod > offset)\n+                nTxSizeMod -= offset;\n+        }\n+        return nTxSizeMod;\n+    }\n \n-    COrphan(const CTransaction* ptxIn) : ptx(ptxIn), feeRate(0), dPriority(0)\n+    double getPriority()\n     {\n+        // Priority is sum(valuein * age) / modified_txsize\n+        return dPriority / effectiveSizeMod();\n+    }\n+\n+    CFeeRate getFeeRate()\n+    {\n+        return CFeeRate(nTxFee, effectiveSize());\n+    }\n+\n+    unsigned int GetLegacySigOpCount()\n+    {\n+        assert(pmapInfoById);\n+\n+        unsigned int n = ::GetLegacySigOpCount(*ptx);\n+        BOOST_FOREACH(const uint256& dephash, setDependsOn)\n+        {\n+            CTxInfo& depinfo = (*pmapInfoById)[dephash];\n+            n += depinfo.GetLegacySigOpCount();\n+        }\n+        return n;\n+    }\n+\n+    bool DoInputs(CCoinsViewCache& view, const int nHeight, std::vector<CTxInfo*>& vAdded, unsigned int& nSigOpCounter)\n+    {\n+        const CTransaction& tx = *ptx;\n+\n+        if (view.HaveCoins(hash))\n+            // Already included in block template\n+            return true;\n+\n+        assert(pmapInfoById);\n+\n+        BOOST_FOREACH(const uint256& dephash, setDependsOn)\n+        {\n+            CTxInfo& depinfo = (*pmapInfoById)[dephash];\n+            if (!depinfo.DoInputs(view, nHeight, vAdded, nSigOpCounter))\n+                return false;\n+        }\n+\n+        if (!view.HaveInputs(tx))\n+            return false;\n+\n+        nTxSigOpsP2SHOnly = GetP2SHSigOpCount(tx, view);\n+        nSigOpCounter += nTxSigOpsP2SHOnly;\n+\n+        // Note that flags: we don't want to set mempool/IsStandard()\n+        // policy here, but we still have to ensure that the block we\n+        // create only contains transactions that are valid in new blocks.\n+        CValidationState state;\n+        if (!CheckInputs(tx, state, view, true, MANDATORY_SCRIPT_VERIFY_FLAGS, true))\n+            return false;\n+\n+        UpdateCoins(tx, state, view, nHeight);\n+\n+        vAdded.push_back(this);\n+\n+        return true;\n     }\n };\n \n uint64_t nLastBlockTx = 0;\n uint64_t nLastBlockSize = 0;\n \n-// We want to sort transactions by priority and fee rate, so:\n-typedef boost::tuple<double, CFeeRate, const CTransaction*> TxPriority;\n+// We want to sort transactions by priority and fee, so:\n+typedef CTxInfo* TxPriority;\n class TxPriorityCompare\n {\n     bool byFee;\n@@ -68,15 +205,15 @@ class TxPriorityCompare\n     {\n         if (byFee)\n         {\n-            if (a.get<1>() == b.get<1>())\n-                return a.get<0>() < b.get<0>();\n-            return a.get<1>() < b.get<1>();\n+            if (a->getFeeRate() == b->getFeeRate())\n+                return a->getPriority() < b->getPriority();\n+            return a->getFeeRate() < b->getFeeRate();\n         }\n         else\n         {\n-            if (a.get<0>() == b.get<0>())\n-                return a.get<1>() < b.get<1>();\n-            return a.get<0>() < b.get<0>();\n+            if (a->getPriority() == b->getPriority())\n+                return a->getFeeRate() < b->getFeeRate();\n+            return a->getPriority() < b->getPriority();\n         }\n     }\n };\n@@ -141,82 +278,76 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n         CCoinsViewCache view(pcoinsTip);\n \n         // Priority order to process transactions\n-        list<COrphan> vOrphan; // list memory doesn't move\n-        map<uint256, vector<COrphan*> > mapDependers;\n+        mapInfo_t mapInfoById;\n         bool fPrintPriority = GetBoolArg(\"-printpriority\", false);\n \n         // This vector will be sorted into a priority queue:\n         vector<TxPriority> vecPriority;\n         vecPriority.reserve(mempool.mapTx.size());\n+\n         for (map<uint256, CTxMemPoolEntry>::iterator mi = mempool.mapTx.begin();\n              mi != mempool.mapTx.end(); ++mi)\n         {\n             const CTransaction& tx = mi->second.GetTx();\n+\n+            const uint256& hash = tx.GetHash();\n+            CTxInfo& txinfo = mapInfoById[hash];\n+            txinfo.hash = hash;\n+            txinfo.pmapInfoById = &mapInfoById;\n+            txinfo.ptx = &tx;\n+\n             if (tx.IsCoinBase() || !IsFinalTx(tx, nHeight))\n+            {\n+                txinfo.fInvalid = true;\n                 continue;\n+            }\n \n-            COrphan* porphan = NULL;\n-            double dPriority = 0;\n+            double& dPriority = txinfo.dPriority;\n+            CAmount& nTxFee = txinfo.nTxFee;\n             CAmount nTotalIn = 0;\n-            bool fMissingInputs = false;\n             BOOST_FOREACH(const CTxIn& txin, tx.vin)\n             {\n                 // Read prev transaction\n-                if (!view.HaveCoins(txin.prevout.hash))\n+                CAmount nValueIn;\n+                int nConf;\n+                if (view.HaveCoins(txin.prevout.hash))\n                 {\n-                    // This should never happen; all transactions in the memory\n-                    // pool should connect to either transactions in the chain\n-                    // or other transactions in the memory pool.\n-                    if (!mempool.mapTx.count(txin.prevout.hash))\n-                    {\n-                        LogPrintf(\"ERROR: mempool transaction missing input\\n\");\n-                        if (fDebug) assert(\"mempool transaction missing input\" == 0);\n-                        fMissingInputs = true;\n-                        if (porphan)\n-                            vOrphan.pop_back();\n-                        break;\n-                    }\n-\n-                    // Has to wait for dependencies\n-                    if (!porphan)\n-                    {\n-                        // Use list for automatic deletion\n-                        vOrphan.push_back(COrphan(&tx));\n-                        porphan = &vOrphan.back();\n-                    }\n-                    mapDependers[txin.prevout.hash].push_back(porphan);\n-                    porphan->setDependsOn.insert(txin.prevout.hash);\n-                    nTotalIn += mempool.mapTx[txin.prevout.hash].GetTx().vout[txin.prevout.n].nValue;\n-                    continue;\n+                    const CCoins* coins = view.AccessCoins(txin.prevout.hash);\n+                    assert(coins);\n+                    // Input is confirmed\n+                    nConf = nHeight - coins->nHeight;\n+                    nValueIn = coins->vout[txin.prevout.n].nValue;\n+                    dPriority += (double)nValueIn * nConf;\n+                }\n+                else\n+                if (mempool.mapTx.count(txin.prevout.hash))\n+                {\n+                    // Input is still unconfirmed\n+                    const uint256& hashPrev = txin.prevout.hash;\n+                    nValueIn = mempool.mapTx[hashPrev].GetTx().vout[txin.prevout.n].nValue;\n+                    txinfo.addDependsOn(hashPrev);\n+                    mapInfoById[hashPrev].setDependents.insert(hash);\n+                    nConf = 0;\n+                }\n+                else\n+                {\n+                    // We don't know where the input is\n+                    // In this case, it's impossible to include this transaction in a block, so mark it invalid and move on\n+                    txinfo.fInvalid = true;\n+                    LogPrintf(\"priority %s invalid input %s\\n\", txinfo.hash.ToString().substr(0,10).c_str(), txin.prevout.hash.ToString().substr(0,10).c_str());\n+                    goto nexttxn;\n                 }\n-                const CCoins* coins = view.AccessCoins(txin.prevout.hash);\n-                assert(coins);\n \n-                CAmount nValueIn = coins->vout[txin.prevout.n].nValue;\n                 nTotalIn += nValueIn;\n-\n-                int nConf = nHeight - coins->nHeight;\n-\n-                dPriority += (double)nValueIn * nConf;\n             }\n-            if (fMissingInputs) continue;\n \n-            // Priority is sum(valuein * age) / modified_txsize\n-            unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n-            dPriority = tx.ComputePriority(dPriority, nTxSize);\n+            nTxFee = nTotalIn - tx.GetValueOut();\n \n-            uint256 hash = tx.GetHash();\n             mempool.ApplyDeltas(hash, dPriority, nTotalIn);\n \n-            CFeeRate feeRate(nTotalIn-tx.GetValueOut(), nTxSize);\n+            vecPriority.push_back(&txinfo);\n \n-            if (porphan)\n-            {\n-                porphan->dPriority = dPriority;\n-                porphan->feeRate = feeRate;\n-            }\n-            else\n-                vecPriority.push_back(TxPriority(dPriority, feeRate, &mi->second.GetTx()));\n+nexttxn:    (void)1;\n         }\n \n         // Collect transactions into block\n@@ -231,20 +362,24 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n         while (!vecPriority.empty())\n         {\n             // Take highest priority transaction off the priority queue:\n-            double dPriority = vecPriority.front().get<0>();\n-            CFeeRate feeRate = vecPriority.front().get<1>();\n-            const CTransaction& tx = *(vecPriority.front().get<2>());\n-\n+            CTxInfo& txinfo = *(vecPriority.front());\n             std::pop_heap(vecPriority.begin(), vecPriority.end(), comparer);\n             vecPriority.pop_back();\n \n+            if (txinfo.fInvalid)\n+                continue;\n+\n+            const CTransaction& tx = *txinfo.ptx;\n+            double dPriority = txinfo.getPriority();\n+            CFeeRate feeRate = txinfo.getFeeRate();\n+\n             // Size limits\n-            unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n+            unsigned int nTxSize = txinfo.effectiveSize();\n             if (nBlockSize + nTxSize >= nBlockMaxSize)\n                 continue;\n \n             // Legacy limits on sigOps:\n-            unsigned int nTxSigOps = GetLegacySigOpCount(tx);\n+            unsigned int nTxSigOps = txinfo.GetLegacySigOpCount();\n             if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n                 continue;\n \n@@ -266,55 +401,52 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n                 std::make_heap(vecPriority.begin(), vecPriority.end(), comparer);\n             }\n \n-            if (!view.HaveInputs(tx))\n-                continue;\n-\n-            CAmount nTxFees = view.GetValueIn(tx)-tx.GetValueOut();\n+            // second layer cached modifications just for this transaction\n+            CCoinsViewCache viewTemp(&view);\n \n-            nTxSigOps += GetP2SHSigOpCount(tx, view);\n-            if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n+            std::vector<CTxInfo*> vAdded;\n+            if (!txinfo.DoInputs(viewTemp, nHeight, vAdded, nTxSigOps))\n                 continue;\n \n-            // Note that flags: we don't want to set mempool/IsStandard()\n-            // policy here, but we still have to ensure that the block we\n-            // create only contains transactions that are valid in new blocks.\n-            CValidationState state;\n-            if (!CheckInputs(tx, state, view, true, MANDATORY_SCRIPT_VERIFY_FLAGS, true))\n+            if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n                 continue;\n \n-            UpdateCoins(tx, state, view, nHeight);\n+            // push changes from the second layer cache to the first one\n+            viewTemp.Flush();\n \n             // Added\n-            pblock->vtx.push_back(tx);\n-            pblocktemplate->vTxFees.push_back(nTxFees);\n-            pblocktemplate->vTxSigOps.push_back(nTxSigOps);\n             nBlockSize += nTxSize;\n-            ++nBlockTx;\n+            nBlockTx += vAdded.size();\n             nBlockSigOps += nTxSigOps;\n-            nFees += nTxFees;\n \n             if (fPrintPriority)\n             {\n                 LogPrintf(\"priority %.1f fee %s txid %s\\n\",\n                     dPriority, feeRate.ToString(), tx.GetHash().ToString());\n             }\n \n-            // Add transactions that depend on this one to the priority queue\n-            if (mapDependers.count(hash))\n+            bool fResort = false;\n+            BOOST_FOREACH(CTxInfo* ptxinfo, vAdded)\n             {\n-                BOOST_FOREACH(COrphan* porphan, mapDependers[hash])\n+                pblock->vtx.push_back(*ptxinfo->ptx);\n+                pblocktemplate->vTxFees.push_back(ptxinfo->nTxFee);\n+                pblocktemplate->vTxSigOps.push_back(GetLegacySigOpCount(*ptxinfo->ptx) + ptxinfo->nTxSigOpsP2SHOnly);\n+                nFees += ptxinfo->nTxFee;\n+\n+                ptxinfo->fInvalid = true;\n+                if (!ptxinfo->setDependents.empty())\n                 {\n-                    if (!porphan->setDependsOn.empty())\n+                    fResort = true;\n+                    BOOST_FOREACH(const uint256& dhash, ptxinfo->setDependents)\n                     {\n-                        porphan->setDependsOn.erase(hash);\n-                        if (porphan->setDependsOn.empty())\n-                        {\n-                            vecPriority.push_back(TxPriority(porphan->dPriority, porphan->feeRate, porphan->ptx));\n-                            std::push_heap(vecPriority.begin(), vecPriority.end(), comparer);\n-                        }\n+                        CTxInfo& dtxinfo = mapInfoById[dhash];\n+                        dtxinfo.rmDependsOn(ptxinfo->hash);\n                     }\n                 }\n             }\n+            if (fResort)\n+                // Re-sort the priority queue to pick up on improved standing\n+                std::make_heap(vecPriority.begin(), vecPriority.end(), comparer);\n         }\n \n         nLastBlockTx = nBlockTx;"
      }
    ]
  }
]