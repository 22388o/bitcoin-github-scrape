[
  {
    "sha": "5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1YzhmZjBkNDQ4ZmZkYzYzNDBiMTk1ZGRmYTIxMjhkNWYyMWE4Mzli",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-08-23T01:02:33Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-09-06T20:07:45Z"
      },
      "message": "Introduce wrappers around CBitcoinAddress\n\nThis patch removes the need for the intermediary Base58 type\nCBitcoinAddress, by providing {Encode,Decode,IsValid}Destination\nfunction that directly operate on the conversion between strings\nand CTxDestination.",
      "tree": {
        "sha": "63a83a0708303a8d8382739c283bb41e07bdc5fe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/63a83a0708303a8d8382739c283bb41e07bdc5fe"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6866b4912b8013ed748d12250209f7079a3c92e6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6866b4912b8013ed748d12250209f7079a3c92e6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6866b4912b8013ed748d12250209f7079a3c92e6"
      }
    ],
    "stats": {
      "total": 576,
      "additions": 299,
      "deletions": 277
    },
    "files": [
      {
        "sha": "69692c95ebe865c2ee7214c2254e8971d78d1f9e",
        "filename": "src/base58.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/base58.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/base58.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.cpp?ref=5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
        "patch": "@@ -318,3 +318,25 @@ bool CBitcoinSecret::SetString(const std::string& strSecret)\n {\n     return SetString(strSecret.c_str());\n }\n+\n+std::string EncodeDestination(const CTxDestination& dest)\n+{\n+    CBitcoinAddress addr(dest);\n+    if (!addr.IsValid()) return \"\";\n+    return addr.ToString();\n+}\n+\n+CTxDestination DecodeDestination(const std::string& str)\n+{\n+    return CBitcoinAddress(str).Get();\n+}\n+\n+bool IsValidDestinationString(const std::string& str, const CChainParams& params)\n+{\n+    return CBitcoinAddress(str).IsValid(params);\n+}\n+\n+bool IsValidDestinationString(const std::string& str)\n+{\n+    return CBitcoinAddress(str).IsValid();\n+}"
      },
      {
        "sha": "0a0ae6ae299d5df5d45d3c13c9a284b740b90d8c",
        "filename": "src/base58.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/base58.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/base58.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.h?ref=5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
        "patch": "@@ -167,4 +167,9 @@ template<typename K, int Size, CChainParams::Base58Type Type> class CBitcoinExtK\n typedef CBitcoinExtKeyBase<CExtKey, BIP32_EXTKEY_SIZE, CChainParams::EXT_SECRET_KEY> CBitcoinExtKey;\n typedef CBitcoinExtKeyBase<CExtPubKey, BIP32_EXTKEY_SIZE, CChainParams::EXT_PUBLIC_KEY> CBitcoinExtPubKey;\n \n+std::string EncodeDestination(const CTxDestination& dest);\n+CTxDestination DecodeDestination(const std::string& str);\n+bool IsValidDestinationString(const std::string& str);\n+bool IsValidDestinationString(const std::string& str, const CChainParams& params);\n+\n #endif // BITCOIN_BASE58_H"
      },
      {
        "sha": "d8d7934bf649a17b774d8c7279991d70ca505c39",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 15,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
        "patch": "@@ -271,11 +271,11 @@ static void MutateTxAddOutAddr(CMutableTransaction& tx, const std::string& strIn\n \n     // extract and validate ADDRESS\n     std::string strAddr = vStrInputParts[1];\n-    CBitcoinAddress addr(strAddr);\n-    if (!addr.IsValid())\n+    CTxDestination destination = DecodeDestination(strAddr);\n+    if (!IsValidDestination(destination)) {\n         throw std::runtime_error(\"invalid TX output address\");\n-    // build standard output script via GetScriptForDestination()\n-    CScript scriptPubKey = GetScriptForDestination(addr.Get());\n+    }\n+    CScript scriptPubKey = GetScriptForDestination(destination);\n \n     // construct TxOut, append to transaction output list\n     CTxOut txout(value, scriptPubKey);\n@@ -314,10 +314,8 @@ static void MutateTxAddOutPubKey(CMutableTransaction& tx, const std::string& str\n         scriptPubKey = GetScriptForWitness(scriptPubKey);\n     }\n     if (bScriptHash) {\n-        // Get the address for the redeem script, then call\n-        // GetScriptForDestination() to construct a P2SH scriptPubKey.\n-        CBitcoinAddress redeemScriptAddr(scriptPubKey);\n-        scriptPubKey = GetScriptForDestination(redeemScriptAddr.Get());\n+        // Get the ID for the script, and then construct a P2SH destination for it.\n+        scriptPubKey = GetScriptForDestination(CScriptID(scriptPubKey));\n     }\n \n     // construct TxOut, append to transaction output list\n@@ -381,10 +379,8 @@ static void MutateTxAddOutMultiSig(CMutableTransaction& tx, const std::string& s\n         scriptPubKey = GetScriptForWitness(scriptPubKey);\n     }\n     if (bScriptHash) {\n-        // Get the address for the redeem script, then call\n-        // GetScriptForDestination() to construct a P2SH scriptPubKey.\n-        CBitcoinAddress addr(scriptPubKey);\n-        scriptPubKey = GetScriptForDestination(addr.Get());\n+        // Get the ID for the script, and then construct a P2SH destination for it.\n+        scriptPubKey = GetScriptForDestination(CScriptID(scriptPubKey));\n     }\n \n     // construct TxOut, append to transaction output list\n@@ -444,11 +440,10 @@ static void MutateTxAddOutScript(CMutableTransaction& tx, const std::string& str\n     }\n \n     if (bSegWit) {\n-      scriptPubKey = GetScriptForWitness(scriptPubKey);\n+        scriptPubKey = GetScriptForWitness(scriptPubKey);\n     }\n     if (bScriptHash) {\n-      CBitcoinAddress addr(scriptPubKey);\n-      scriptPubKey = GetScriptForDestination(addr.Get());\n+        scriptPubKey = GetScriptForDestination(CScriptID(scriptPubKey));\n     }\n \n     // construct TxOut, append to transaction output list"
      },
      {
        "sha": "e16db1365047b539db03ab6f8bb7a092a0201880",
        "filename": "src/core_write.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/core_write.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/core_write.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_write.cpp?ref=5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
        "patch": "@@ -148,8 +148,9 @@ void ScriptPubKeyToUniv(const CScript& scriptPubKey,\n     out.pushKV(\"type\", GetTxnOutputType(type));\n \n     UniValue a(UniValue::VARR);\n-    for (const CTxDestination& addr : addresses)\n-        a.push_back(CBitcoinAddress(addr).ToString());\n+    for (const CTxDestination& addr : addresses) {\n+        a.push_back(EncodeDestination(addr));\n+    }\n     out.pushKV(\"addresses\", a);\n }\n "
      },
      {
        "sha": "0eb7ec4306ba8346c24dec7b8f81f3b6c06bad32",
        "filename": "src/qt/addresstablemodel.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/qt/addresstablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/qt/addresstablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addresstablemodel.cpp?ref=5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
        "patch": "@@ -82,14 +82,14 @@ class AddressTablePriv\n             LOCK(wallet->cs_wallet);\n             for (const std::pair<CTxDestination, CAddressBookData>& item : wallet->mapAddressBook)\n             {\n-                const CBitcoinAddress& address = item.first;\n-                bool fMine = IsMine(*wallet, address.Get());\n+                const CTxDestination& address = item.first;\n+                bool fMine = IsMine(*wallet, address);\n                 AddressTableEntry::Type addressType = translateTransactionType(\n                         QString::fromStdString(item.second.purpose), fMine);\n                 const std::string& strName = item.second.name;\n                 cachedAddressTable.append(AddressTableEntry(addressType,\n                                   QString::fromStdString(strName),\n-                                  QString::fromStdString(address.ToString())));\n+                                  QString::fromStdString(EncodeDestination(address))));\n             }\n         }\n         // qLowerBound() and qUpperBound() require our cachedAddressTable list to be sorted in asc order\n@@ -246,7 +246,7 @@ bool AddressTableModel::setData(const QModelIndex &index, const QVariant &value,\n     if(role == Qt::EditRole)\n     {\n         LOCK(wallet->cs_wallet); /* For SetAddressBook / DelAddressBook */\n-        CTxDestination curAddress = CBitcoinAddress(rec->address.toStdString()).Get();\n+        CTxDestination curAddress = DecodeDestination(rec->address.toStdString());\n         if(index.column() == Label)\n         {\n             // Do nothing, if old label == new label\n@@ -257,7 +257,7 @@ bool AddressTableModel::setData(const QModelIndex &index, const QVariant &value,\n             }\n             wallet->SetAddressBook(curAddress, value.toString().toStdString(), strPurpose);\n         } else if(index.column() == Address) {\n-            CTxDestination newAddress = CBitcoinAddress(value.toString().toStdString()).Get();\n+            CTxDestination newAddress = DecodeDestination(value.toString().toStdString());\n             // Refuse to set invalid address, set error status and return false\n             if(boost::get<CNoDestination>(&newAddress))\n             {\n@@ -358,7 +358,7 @@ QString AddressTableModel::addRow(const QString &type, const QString &label, con\n         // Check for duplicate addresses\n         {\n             LOCK(wallet->cs_wallet);\n-            if(wallet->mapAddressBook.count(CBitcoinAddress(strAddress).Get()))\n+            if(wallet->mapAddressBook.count(DecodeDestination(strAddress)))\n             {\n                 editStatus = DUPLICATE_ADDRESS;\n                 return QString();\n@@ -384,7 +384,7 @@ QString AddressTableModel::addRow(const QString &type, const QString &label, con\n                 return QString();\n             }\n         }\n-        strAddress = CBitcoinAddress(newKey.GetID()).ToString();\n+        strAddress = EncodeDestination(newKey.GetID());\n     }\n     else\n     {\n@@ -394,7 +394,7 @@ QString AddressTableModel::addRow(const QString &type, const QString &label, con\n     // Add entry\n     {\n         LOCK(wallet->cs_wallet);\n-        wallet->SetAddressBook(CBitcoinAddress(strAddress).Get(), strLabel,\n+        wallet->SetAddressBook(DecodeDestination(strAddress), strLabel,\n                                (type == Send ? \"send\" : \"receive\"));\n     }\n     return QString::fromStdString(strAddress);\n@@ -412,7 +412,7 @@ bool AddressTableModel::removeRows(int row, int count, const QModelIndex &parent\n     }\n     {\n         LOCK(wallet->cs_wallet);\n-        wallet->DelAddressBook(CBitcoinAddress(rec->address.toStdString()).Get());\n+        wallet->DelAddressBook(DecodeDestination(rec->address.toStdString()));\n     }\n     return true;\n }\n@@ -423,8 +423,8 @@ QString AddressTableModel::labelForAddress(const QString &address) const\n {\n     {\n         LOCK(wallet->cs_wallet);\n-        CBitcoinAddress address_parsed(address.toStdString());\n-        std::map<CTxDestination, CAddressBookData>::iterator mi = wallet->mapAddressBook.find(address_parsed.Get());\n+        CTxDestination destination = DecodeDestination(address.toStdString());\n+        std::map<CTxDestination, CAddressBookData>::iterator mi = wallet->mapAddressBook.find(destination);\n         if (mi != wallet->mapAddressBook.end())\n         {\n             return QString::fromStdString(mi->second.name);"
      },
      {
        "sha": "4dd10928064386206eda6f494c8ba2e969b46e2c",
        "filename": "src/qt/bitcoinaddressvalidator.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/qt/bitcoinaddressvalidator.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/qt/bitcoinaddressvalidator.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoinaddressvalidator.cpp?ref=5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
        "patch": "@@ -89,9 +89,9 @@ QValidator::State BitcoinAddressCheckValidator::validate(QString &input, int &po\n {\n     Q_UNUSED(pos);\n     // Validate the passed Bitcoin address\n-    CBitcoinAddress addr(input.toStdString());\n-    if (addr.IsValid())\n+    if (IsValidDestinationString(input.toStdString())) {\n         return QValidator::Acceptable;\n+    }\n \n     return QValidator::Invalid;\n }"
      },
      {
        "sha": "3ca43eae229fc1b5739d6bf87ff75a945bc70bad",
        "filename": "src/qt/coincontroldialog.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/qt/coincontroldialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/qt/coincontroldialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroldialog.cpp?ref=5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
        "patch": "@@ -660,7 +660,7 @@ void CoinControlDialog::updateView()\n             QString sAddress = \"\";\n             if(ExtractDestination(out.tx->tx->vout[out.i].scriptPubKey, outputAddress))\n             {\n-                sAddress = QString::fromStdString(CBitcoinAddress(outputAddress).ToString());\n+                sAddress = QString::fromStdString(EncodeDestination(outputAddress));\n \n                 // if listMode or change => show bitcoin address. In tree mode, address is not shown again for direct wallet address outputs\n                 if (!treeMode || (!(sAddress == sWalletAddress)))"
      },
      {
        "sha": "ea5343c19ddd51ffdec5b31dbdb0ef4dd69f0f54",
        "filename": "src/qt/guiutil.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/qt/guiutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/qt/guiutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.cpp?ref=5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
        "patch": "@@ -112,8 +112,9 @@ static std::string DummyAddress(const CChainParams &params)\n     sourcedata.insert(sourcedata.end(), dummydata, dummydata + sizeof(dummydata));\n     for(int i=0; i<256; ++i) { // Try every trailing byte\n         std::string s = EncodeBase58(sourcedata.data(), sourcedata.data() + sourcedata.size());\n-        if (!CBitcoinAddress(s).IsValid())\n+        if (!IsValidDestinationString(s)) {\n             return s;\n+        }\n         sourcedata[sourcedata.size()-1] += 1;\n     }\n     return \"\";\n@@ -248,7 +249,7 @@ QString formatBitcoinURI(const SendCoinsRecipient &info)\n \n bool isDust(const QString& address, const CAmount& amount)\n {\n-    CTxDestination dest = CBitcoinAddress(address.toStdString()).Get();\n+    CTxDestination dest = DecodeDestination(address.toStdString());\n     CScript script = GetScriptForDestination(dest);\n     CTxOut txOut(amount, script);\n     return IsDust(txOut, ::dustRelayFee);"
      },
      {
        "sha": "169684cf6d84acd27f4bbd469b043c3f006f3e7a",
        "filename": "src/qt/paymentserver.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 9,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/qt/paymentserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/qt/paymentserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentserver.cpp?ref=5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
        "patch": "@@ -218,17 +218,15 @@ void PaymentServer::ipcParseCommandLine(int argc, char* argv[])\n             SendCoinsRecipient r;\n             if (GUIUtil::parseBitcoinURI(arg, &r) && !r.address.isEmpty())\n             {\n-                CBitcoinAddress address(r.address.toStdString());\n                 auto tempChainParams = CreateChainParams(CBaseChainParams::MAIN);\n \n-                if (address.IsValid(*tempChainParams))\n-                {\n+                if (IsValidDestinationString(r.address.toStdString(), *tempChainParams)) {\n                     SelectParams(CBaseChainParams::MAIN);\n-                }\n-                else {\n+                } else {\n                     tempChainParams = CreateChainParams(CBaseChainParams::TESTNET);\n-                    if (address.IsValid(*tempChainParams))\n+                    if (IsValidDestinationString(r.address.toStdString(), *tempChainParams)) {\n                         SelectParams(CBaseChainParams::TESTNET);\n+                    }\n                 }\n             }\n         }\n@@ -441,8 +439,7 @@ void PaymentServer::handleURIOrFile(const QString& s)\n             SendCoinsRecipient recipient;\n             if (GUIUtil::parseBitcoinURI(s, &recipient))\n             {\n-                CBitcoinAddress address(recipient.address.toStdString());\n-                if (!address.IsValid()) {\n+                if (!IsValidDestinationString(recipient.address.toStdString())) {\n                     Q_EMIT message(tr(\"URI handling\"), tr(\"Invalid payment address %1\").arg(recipient.address),\n                         CClientUIInterface::MSG_ERROR);\n                 }\n@@ -560,7 +557,7 @@ bool PaymentServer::processPaymentRequest(const PaymentRequestPlus& request, Sen\n         CTxDestination dest;\n         if (ExtractDestination(sendingTo.first, dest)) {\n             // Append destination address\n-            addresses.append(QString::fromStdString(CBitcoinAddress(dest).ToString()));\n+            addresses.append(QString::fromStdString(EncodeDestination(dest)));\n         }\n         else if (!recipient.authenticatedMerchant.isEmpty()) {\n             // Unauthenticated payment requests to custom bitcoin addresses are not supported"
      },
      {
        "sha": "05c5ccbfe26a33a60578e03de506251649961b4a",
        "filename": "src/qt/sendcoinsdialog.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/qt/sendcoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/qt/sendcoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.cpp?ref=5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
        "patch": "@@ -777,19 +777,18 @@ void SendCoinsDialog::coinControlChangeEdited(const QString& text)\n         CoinControlDialog::coinControl->destChange = CNoDestination();\n         ui->labelCoinControlChangeLabel->setStyleSheet(\"QLabel{color:red;}\");\n \n-        CBitcoinAddress addr = CBitcoinAddress(text.toStdString());\n+        const CTxDestination dest = DecodeDestination(text.toStdString());\n \n         if (text.isEmpty()) // Nothing entered\n         {\n             ui->labelCoinControlChangeLabel->setText(\"\");\n         }\n-        else if (!addr.IsValid()) // Invalid address\n+        else if (!IsValidDestination(dest)) // Invalid address\n         {\n             ui->labelCoinControlChangeLabel->setText(tr(\"Warning: Invalid Bitcoin address\"));\n         }\n         else // Valid address\n         {\n-            const CTxDestination dest = addr.Get();\n             if (!model->IsSpendable(dest)) {\n                 ui->labelCoinControlChangeLabel->setText(tr(\"Warning: Unknown change address\"));\n "
      },
      {
        "sha": "4e37b816545ea9f2b89f1deaa18f5c18c8554329",
        "filename": "src/qt/signverifymessagedialog.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 15,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/qt/signverifymessagedialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/qt/signverifymessagedialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/signverifymessagedialog.cpp?ref=5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
        "patch": "@@ -117,16 +117,14 @@ void SignVerifyMessageDialog::on_signMessageButton_SM_clicked()\n     /* Clear old signature to ensure users don't get confused on error with an old signature displayed */\n     ui->signatureOut_SM->clear();\n \n-    CBitcoinAddress addr(ui->addressIn_SM->text().toStdString());\n-    if (!addr.IsValid())\n-    {\n+    CTxDestination destination = DecodeDestination(ui->addressIn_SM->text().toStdString());\n+    if (!IsValidDestination(destination)) {\n         ui->statusLabel_SM->setStyleSheet(\"QLabel { color: red; }\");\n         ui->statusLabel_SM->setText(tr(\"The entered address is invalid.\") + QString(\" \") + tr(\"Please check the address and try again.\"));\n         return;\n     }\n-    CKeyID keyID;\n-    if (!addr.GetKeyID(keyID))\n-    {\n+    const CKeyID* keyID = boost::get<CKeyID>(&destination);\n+    if (!keyID) {\n         ui->addressIn_SM->setValid(false);\n         ui->statusLabel_SM->setStyleSheet(\"QLabel { color: red; }\");\n         ui->statusLabel_SM->setText(tr(\"The entered address does not refer to a key.\") + QString(\" \") + tr(\"Please check the address and try again.\"));\n@@ -142,7 +140,7 @@ void SignVerifyMessageDialog::on_signMessageButton_SM_clicked()\n     }\n \n     CKey key;\n-    if (!model->getPrivKey(keyID, key))\n+    if (!model->getPrivKey(*keyID, key))\n     {\n         ui->statusLabel_SM->setStyleSheet(\"QLabel { color: red; }\");\n         ui->statusLabel_SM->setText(tr(\"Private key for the entered address is not available.\"));\n@@ -197,16 +195,13 @@ void SignVerifyMessageDialog::on_addressBookButton_VM_clicked()\n \n void SignVerifyMessageDialog::on_verifyMessageButton_VM_clicked()\n {\n-    CBitcoinAddress addr(ui->addressIn_VM->text().toStdString());\n-    if (!addr.IsValid())\n-    {\n+    CTxDestination destination = DecodeDestination(ui->addressIn_VM->text().toStdString());\n+    if (!IsValidDestination(destination)) {\n         ui->statusLabel_VM->setStyleSheet(\"QLabel { color: red; }\");\n         ui->statusLabel_VM->setText(tr(\"The entered address is invalid.\") + QString(\" \") + tr(\"Please check the address and try again.\"));\n         return;\n     }\n-    CKeyID keyID;\n-    if (!addr.GetKeyID(keyID))\n-    {\n+    if (!boost::get<CKeyID>(&destination)) {\n         ui->addressIn_VM->setValid(false);\n         ui->statusLabel_VM->setStyleSheet(\"QLabel { color: red; }\");\n         ui->statusLabel_VM->setText(tr(\"The entered address does not refer to a key.\") + QString(\" \") + tr(\"Please check the address and try again.\"));\n@@ -237,8 +232,7 @@ void SignVerifyMessageDialog::on_verifyMessageButton_VM_clicked()\n         return;\n     }\n \n-    if (!(CBitcoinAddress(pubkey.GetID()) == addr))\n-    {\n+    if (!(CTxDestination(pubkey.GetID()) == destination)) {\n         ui->statusLabel_VM->setStyleSheet(\"QLabel { color: red; }\");\n         ui->statusLabel_VM->setText(QString(\"<nobr>\") + tr(\"Message verification failed.\") + QString(\"</nobr>\"));\n         return;"
      },
      {
        "sha": "5031d7651d8afa8eb53b767d5b8e144c0096f56e",
        "filename": "src/qt/test/wallettests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/qt/test/wallettests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/qt/test/wallettests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/wallettests.cpp?ref=5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
        "patch": "@@ -57,11 +57,11 @@ void ConfirmSend(QString* text = nullptr, bool cancel = false)\n }\n \n //! Send coins to address and return txid.\n-uint256 SendCoins(CWallet& wallet, SendCoinsDialog& sendCoinsDialog, const CBitcoinAddress& address, CAmount amount, bool rbf)\n+uint256 SendCoins(CWallet& wallet, SendCoinsDialog& sendCoinsDialog, const CTxDestination& address, CAmount amount, bool rbf)\n {\n     QVBoxLayout* entries = sendCoinsDialog.findChild<QVBoxLayout*>(\"entries\");\n     SendCoinsEntry* entry = qobject_cast<SendCoinsEntry*>(entries->itemAt(0)->widget());\n-    entry->findChild<QValidatedLineEdit*>(\"payTo\")->setText(QString::fromStdString(address.ToString()));\n+    entry->findChild<QValidatedLineEdit*>(\"payTo\")->setText(QString::fromStdString(EncodeDestination(address)));\n     entry->findChild<BitcoinAmountField*>(\"payAmount\")->setValue(amount);\n     sendCoinsDialog.findChild<QFrame*>(\"frameFee\")\n         ->findChild<QFrame*>(\"frameFeeSelection\")\n@@ -172,8 +172,8 @@ void TestSendCoins()\n     // Send two transactions, and verify they are added to transaction list.\n     TransactionTableModel* transactionTableModel = walletModel.getTransactionTableModel();\n     QCOMPARE(transactionTableModel->rowCount({}), 105);\n-    uint256 txid1 = SendCoins(wallet, sendCoinsDialog, CBitcoinAddress(CKeyID()), 5 * COIN, false /* rbf */);\n-    uint256 txid2 = SendCoins(wallet, sendCoinsDialog, CBitcoinAddress(CKeyID()), 10 * COIN, true /* rbf */);\n+    uint256 txid1 = SendCoins(wallet, sendCoinsDialog, CKeyID(), 5 * COIN, false /* rbf */);\n+    uint256 txid2 = SendCoins(wallet, sendCoinsDialog, CKeyID(), 10 * COIN, true /* rbf */);\n     QCOMPARE(transactionTableModel->rowCount({}), 107);\n     QVERIFY(FindTx(*transactionTableModel, txid1).isValid());\n     QVERIFY(FindTx(*transactionTableModel, txid2).isValid());"
      },
      {
        "sha": "f3fe4096a22a80b5681ef93313f4717bb833a260",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
        "patch": "@@ -91,9 +91,8 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n         if (nNet > 0)\n         {\n             // Credit\n-            if (CBitcoinAddress(rec->address).IsValid())\n-            {\n-                CTxDestination address = CBitcoinAddress(rec->address).Get();\n+            if (IsValidDestinationString(rec->address)) {\n+                CTxDestination address = DecodeDestination(rec->address);\n                 if (wallet->mapAddressBook.count(address))\n                 {\n                     strHTML += \"<b>\" + tr(\"From\") + \":</b> \" + tr(\"unknown\") + \"<br>\";\n@@ -118,7 +117,7 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n         // Online transaction\n         std::string strAddress = wtx.mapValue[\"to\"];\n         strHTML += \"<b>\" + tr(\"To\") + \":</b> \";\n-        CTxDestination dest = CBitcoinAddress(strAddress).Get();\n+        CTxDestination dest = DecodeDestination(strAddress);\n         if (wallet->mapAddressBook.count(dest) && !wallet->mapAddressBook[dest].name.empty())\n             strHTML += GUIUtil::HtmlEscape(wallet->mapAddressBook[dest].name) + \" \";\n         strHTML += GUIUtil::HtmlEscape(strAddress) + \"<br>\";\n@@ -189,7 +188,7 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n                         strHTML += \"<b>\" + tr(\"To\") + \":</b> \";\n                         if (wallet->mapAddressBook.count(address) && !wallet->mapAddressBook[address].name.empty())\n                             strHTML += GUIUtil::HtmlEscape(wallet->mapAddressBook[address].name) + \" \";\n-                        strHTML += GUIUtil::HtmlEscape(CBitcoinAddress(address).ToString());\n+                        strHTML += GUIUtil::HtmlEscape(EncodeDestination(address));\n                         if(toSelf == ISMINE_SPENDABLE)\n                             strHTML += \" (own address)\";\n                         else if(toSelf & ISMINE_WATCH_ONLY)\n@@ -304,7 +303,7 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n                     {\n                         if (wallet->mapAddressBook.count(address) && !wallet->mapAddressBook[address].name.empty())\n                             strHTML += GUIUtil::HtmlEscape(wallet->mapAddressBook[address].name) + \" \";\n-                        strHTML += QString::fromStdString(CBitcoinAddress(address).ToString());\n+                        strHTML += QString::fromStdString(EncodeDestination(address));\n                     }\n                     strHTML = strHTML + \" \" + tr(\"Amount\") + \"=\" + BitcoinUnits::formatHtmlWithUnit(unit, vout.nValue);\n                     strHTML = strHTML + \" IsMine=\" + (wallet->IsMine(vout) & ISMINE_SPENDABLE ? tr(\"true\") : tr(\"false\")) + \"</li>\";"
      },
      {
        "sha": "d40ffd22cd10e4fdf70ff377e6a352a0b30dc6e2",
        "filename": "src/qt/transactionrecord.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/qt/transactionrecord.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/qt/transactionrecord.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.cpp?ref=5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
        "patch": "@@ -55,7 +55,7 @@ QList<TransactionRecord> TransactionRecord::decomposeTransaction(const CWallet *\n                 {\n                     // Received by Bitcoin Address\n                     sub.type = TransactionRecord::RecvWithAddress;\n-                    sub.address = CBitcoinAddress(address).ToString();\n+                    sub.address = EncodeDestination(address);\n                 }\n                 else\n                 {\n@@ -127,7 +127,7 @@ QList<TransactionRecord> TransactionRecord::decomposeTransaction(const CWallet *\n                 {\n                     // Sent to Bitcoin Address\n                     sub.type = TransactionRecord::SendToAddress;\n-                    sub.address = CBitcoinAddress(address).ToString();\n+                    sub.address = EncodeDestination(address);\n                 }\n                 else\n                 {"
      },
      {
        "sha": "53b1c2967cd5287ce7682a8abcddbbc8142f5fd6",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
        "patch": "@@ -188,8 +188,7 @@ void WalletModel::updateWatchOnlyFlag(bool fHaveWatchonly)\n \n bool WalletModel::validateAddress(const QString &address)\n {\n-    CBitcoinAddress addressParsed(address.toStdString());\n-    return addressParsed.IsValid();\n+    return IsValidDestinationString(address.toStdString());\n }\n \n WalletModel::SendCoinsReturn WalletModel::prepareTransaction(WalletModelTransaction &transaction, const CCoinControl& coinControl)\n@@ -247,7 +246,7 @@ WalletModel::SendCoinsReturn WalletModel::prepareTransaction(WalletModelTransact\n             setAddress.insert(rcp.address);\n             ++nAddresses;\n \n-            CScript scriptPubKey = GetScriptForDestination(CBitcoinAddress(rcp.address.toStdString()).Get());\n+            CScript scriptPubKey = GetScriptForDestination(DecodeDestination(rcp.address.toStdString()));\n             CRecipient recipient = {scriptPubKey, rcp.amount, rcp.fSubtractFeeFromAmount};\n             vecSend.push_back(recipient);\n \n@@ -348,7 +347,7 @@ WalletModel::SendCoinsReturn WalletModel::sendCoins(WalletModelTransaction &tran\n         if (!rcp.paymentRequest.IsInitialized())\n         {\n             std::string strAddress = rcp.address.toStdString();\n-            CTxDestination dest = CBitcoinAddress(strAddress).Get();\n+            CTxDestination dest = DecodeDestination(strAddress);\n             std::string strLabel = rcp.label.toStdString();\n             {\n                 LOCK(wallet->cs_wallet);\n@@ -464,7 +463,7 @@ static void NotifyAddressBookChanged(WalletModel *walletmodel, CWallet *wallet,\n         const CTxDestination &address, const std::string &label, bool isMine,\n         const std::string &purpose, ChangeType status)\n {\n-    QString strAddress = QString::fromStdString(CBitcoinAddress(address).ToString());\n+    QString strAddress = QString::fromStdString(EncodeDestination(address));\n     QString strLabel = QString::fromStdString(label);\n     QString strPurpose = QString::fromStdString(purpose);\n \n@@ -596,7 +595,7 @@ bool WalletModel::isSpent(const COutPoint& outpoint) const\n void WalletModel::listCoins(std::map<QString, std::vector<COutput> >& mapCoins) const\n {\n     for (auto& group : wallet->ListCoins()) {\n-        auto& resultGroup = mapCoins[QString::fromStdString(CBitcoinAddress(group.first).ToString())];\n+        auto& resultGroup = mapCoins[QString::fromStdString(EncodeDestination(group.first))];\n         for (auto& coin : group.second) {\n             resultGroup.emplace_back(std::move(coin));\n         }\n@@ -634,7 +633,7 @@ void WalletModel::loadReceiveRequests(std::vector<std::string>& vReceiveRequests\n \n bool WalletModel::saveReceiveRequest(const std::string &sAddress, const int64_t nId, const std::string &sRequest)\n {\n-    CTxDestination dest = CBitcoinAddress(sAddress).Get();\n+    CTxDestination dest = DecodeDestination(sAddress);\n \n     std::stringstream ss;\n     ss << nId;"
      },
      {
        "sha": "9809883700ffad3c297ac72e42b7b26e70af7ffe",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
        "patch": "@@ -176,12 +176,13 @@ UniValue generatetoaddress(const JSONRPCRequest& request)\n         nMaxTries = request.params[2].get_int();\n     }\n \n-    CBitcoinAddress address(request.params[1].get_str());\n-    if (!address.IsValid())\n+    CTxDestination destination = DecodeDestination(request.params[1].get_str());\n+    if (!IsValidDestination(destination)) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Error: Invalid address\");\n+    }\n \n     std::shared_ptr<CReserveScript> coinbaseScript = std::make_shared<CReserveScript>();\n-    coinbaseScript->reserveScript = GetScriptForDestination(address.Get());\n+    coinbaseScript->reserveScript = GetScriptForDestination(destination);\n \n     return generateBlocks(coinbaseScript, nGenerate, nMaxTries, false);\n }"
      },
      {
        "sha": "91e3b05be324b21b2645677de9e8edf88ea56408",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 24,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
        "patch": "@@ -152,8 +152,9 @@ class DescribeAddressVisitor : public boost::static_visitor<UniValue>\n             obj.push_back(Pair(\"script\", GetTxnOutputType(whichType)));\n             obj.push_back(Pair(\"hex\", HexStr(subscript.begin(), subscript.end())));\n             UniValue a(UniValue::VARR);\n-            for (const CTxDestination& addr : addresses)\n-                a.push_back(CBitcoinAddress(addr).ToString());\n+            for (const CTxDestination& addr : addresses) {\n+                a.push_back(EncodeDestination(addr));\n+            }\n             obj.push_back(Pair(\"addresses\", a));\n             if (whichType == TX_MULTISIG)\n                 obj.push_back(Pair(\"sigsrequired\", nRequired));\n@@ -207,15 +208,14 @@ UniValue validateaddress(const JSONRPCRequest& request)\n     LOCK(cs_main);\n #endif\n \n-    CBitcoinAddress address(request.params[0].get_str());\n-    bool isValid = address.IsValid();\n+    CTxDestination dest = DecodeDestination(request.params[0].get_str());\n+    bool isValid = IsValidDestination(dest);\n \n     UniValue ret(UniValue::VOBJ);\n     ret.push_back(Pair(\"isvalid\", isValid));\n     if (isValid)\n     {\n-        CTxDestination dest = address.Get();\n-        std::string currentAddress = address.ToString();\n+        std::string currentAddress = EncodeDestination(dest);\n         ret.push_back(Pair(\"address\", currentAddress));\n \n         CScript scriptPubKey = GetScriptForDestination(dest);\n@@ -230,10 +230,10 @@ UniValue validateaddress(const JSONRPCRequest& request)\n         if (pwallet && pwallet->mapAddressBook.count(dest)) {\n             ret.push_back(Pair(\"account\", pwallet->mapAddressBook[dest].name));\n         }\n-        CKeyID keyID;\n         if (pwallet) {\n             const auto& meta = pwallet->mapKeyMetadata;\n-            auto it = address.GetKeyID(keyID) ? meta.find(keyID) : meta.end();\n+            const CKeyID *keyID = boost::get<CKeyID>(&dest);\n+            auto it = keyID ? meta.find(*keyID) : meta.end();\n             if (it == meta.end()) {\n                 it = meta.find(CScriptID(scriptPubKey));\n             }\n@@ -277,16 +277,15 @@ CScript _createmultisig_redeemScript(CWallet * const pwallet, const UniValue& pa\n         const std::string& ks = keys[i].get_str();\n #ifdef ENABLE_WALLET\n         // Case 1: Bitcoin address and we have full public key:\n-        CBitcoinAddress address(ks);\n-        if (pwallet && address.IsValid()) {\n-            CKeyID keyID;\n-            if (!address.GetKeyID(keyID))\n-                throw std::runtime_error(\n-                    strprintf(\"%s does not refer to a key\",ks));\n+        CTxDestination dest = DecodeDestination(ks);\n+        if (pwallet && IsValidDestination(dest)) {\n+            const CKeyID *keyID = boost::get<CKeyID>(&dest);\n+            if (!keyID) {\n+                throw std::runtime_error(strprintf(\"%s does not refer to a key\", ks));\n+            }\n             CPubKey vchPubKey;\n-            if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n-                throw std::runtime_error(\n-                    strprintf(\"no full public key for address %s\",ks));\n+            if (!pwallet->GetPubKey(*keyID, vchPubKey)) {\n+                throw std::runtime_error(strprintf(\"no full public key for address %s\", ks));\n             }\n             if (!vchPubKey.IsFullyValid())\n                 throw std::runtime_error(\" Invalid public key: \"+ks);\n@@ -357,10 +356,9 @@ UniValue createmultisig(const JSONRPCRequest& request)\n     // Construct using pay-to-script-hash:\n     CScript inner = _createmultisig_redeemScript(pwallet, request.params);\n     CScriptID innerID(inner);\n-    CBitcoinAddress address(innerID);\n \n     UniValue result(UniValue::VOBJ);\n-    result.push_back(Pair(\"address\", address.ToString()));\n+    result.push_back(Pair(\"address\", EncodeDestination(innerID)));\n     result.push_back(Pair(\"redeemScript\", HexStr(inner.begin(), inner.end())));\n \n     return result;\n@@ -395,13 +393,15 @@ UniValue verifymessage(const JSONRPCRequest& request)\n     std::string strSign     = request.params[1].get_str();\n     std::string strMessage  = request.params[2].get_str();\n \n-    CBitcoinAddress addr(strAddress);\n-    if (!addr.IsValid())\n+    CTxDestination destination = DecodeDestination(strAddress);\n+    if (!IsValidDestination(destination)) {\n         throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid address\");\n+    }\n \n-    CKeyID keyID;\n-    if (!addr.GetKeyID(keyID))\n+    const CKeyID *keyID = boost::get<CKeyID>(&destination);\n+    if (!keyID) {\n         throw JSONRPCError(RPC_TYPE_ERROR, \"Address does not refer to key\");\n+    }\n \n     bool fInvalid = false;\n     std::vector<unsigned char> vchSig = DecodeBase64(strSign.c_str(), &fInvalid);\n@@ -417,7 +417,7 @@ UniValue verifymessage(const JSONRPCRequest& request)\n     if (!pubkey.RecoverCompact(ss.GetHash(), vchSig))\n         return false;\n \n-    return (pubkey.GetID() == keyID);\n+    return (pubkey.GetID() == *keyID);\n }\n \n UniValue signmessagewithprivkey(const JSONRPCRequest& request)"
      },
      {
        "sha": "a0322f67b407e16b2e3ea24c6acc17cf106ddd66",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 9,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
        "patch": "@@ -384,7 +384,7 @@ UniValue createrawtransaction(const JSONRPCRequest& request)\n         rawTx.vin.push_back(in);\n     }\n \n-    std::set<CBitcoinAddress> setAddress;\n+    std::set<CTxDestination> destinations;\n     std::vector<std::string> addrList = sendTo.getKeys();\n     for (const std::string& name_ : addrList) {\n \n@@ -394,15 +394,16 @@ UniValue createrawtransaction(const JSONRPCRequest& request)\n             CTxOut out(0, CScript() << OP_RETURN << data);\n             rawTx.vout.push_back(out);\n         } else {\n-            CBitcoinAddress address(name_);\n-            if (!address.IsValid())\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(\"Invalid Bitcoin address: \")+name_);\n+            CTxDestination destination = DecodeDestination(name_);\n+            if (!IsValidDestination(destination)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(\"Invalid Bitcoin address: \") + name_);\n+            }\n \n-            if (setAddress.count(address))\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, std::string(\"Invalid parameter, duplicated address: \")+name_);\n-            setAddress.insert(address);\n+            if (!destinations.insert(destination).second) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, std::string(\"Invalid parameter, duplicated address: \") + name_);\n+            }\n \n-            CScript scriptPubKey = GetScriptForDestination(address.Get());\n+            CScript scriptPubKey = GetScriptForDestination(destination);\n             CAmount nAmount = AmountFromValue(sendTo[name_]);\n \n             CTxOut out(nAmount, scriptPubKey);\n@@ -529,7 +530,7 @@ UniValue decodescript(const JSONRPCRequest& request)\n     if (type.isStr() && type.get_str() != \"scripthash\") {\n         // P2SH cannot be wrapped in a P2SH. If this script is already a P2SH,\n         // don't return the address for a P2SH of the P2SH.\n-        r.push_back(Pair(\"p2sh\", CBitcoinAddress(CScriptID(script)).ToString()));\n+        r.push_back(Pair(\"p2sh\", EncodeDestination(CScriptID(script))));\n     }\n \n     return r;"
      },
      {
        "sha": "b6e2232ab4420eef4349b99ba73f0c46ded2ab9b",
        "filename": "src/script/standard.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/script/standard.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/script/standard.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.cpp?ref=5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
        "patch": "@@ -317,3 +317,7 @@ CScript GetScriptForWitness(const CScript& redeemscript)\n     ret << OP_0 << ToByteVector(hash);\n     return ret;\n }\n+\n+bool IsValidDestination(const CTxDestination& dest) {\n+    return dest.which() != 0;\n+}"
      },
      {
        "sha": "8df143a3a3caad78cc0ec0161dc7e27d6c44e0d0",
        "filename": "src/script/standard.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/script/standard.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/script/standard.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.h?ref=5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
        "patch": "@@ -77,10 +77,13 @@ class CNoDestination {\n  *  * CNoDestination: no destination set\n  *  * CKeyID: TX_PUBKEYHASH destination\n  *  * CScriptID: TX_SCRIPTHASH destination\n- *  A CTxDestination is the internal data type encoded in a CBitcoinAddress\n+ *  A CTxDestination is the internal data type encoded in a bitcoin address\n  */\n typedef boost::variant<CNoDestination, CKeyID, CScriptID> CTxDestination;\n \n+/** Check whether a CTxDestination is a CNoDestination. */\n+bool IsValidDestination(const CTxDestination& dest);\n+\n /** Get the name of a txnouttype as a C string, or nullptr if unknown. */\n const char* GetTxnOutputType(txnouttype t);\n "
      },
      {
        "sha": "4829590c54be74970dbc50cf04d70c783632b252",
        "filename": "src/test/base58_tests.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 20,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/test/base58_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/test/base58_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/base58_tests.cpp?ref=5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
        "patch": "@@ -121,7 +121,7 @@ BOOST_AUTO_TEST_CASE(base58_keys_valid_parse)\n {\n     UniValue tests = read_json(std::string(json_tests::base58_keys_valid, json_tests::base58_keys_valid + sizeof(json_tests::base58_keys_valid)));\n     CBitcoinSecret secret;\n-    CBitcoinAddress addr;\n+    CTxDestination destination;\n     SelectParams(CBaseChainParams::MAIN);\n \n     for (unsigned int idx = 0; idx < tests.size(); idx++) {\n@@ -145,26 +145,24 @@ BOOST_AUTO_TEST_CASE(base58_keys_valid_parse)\n         {\n             bool isCompressed = find_value(metadata, \"isCompressed\").get_bool();\n             // Must be valid private key\n-            // Note: CBitcoinSecret::SetString tests isValid, whereas CBitcoinAddress does not!\n             BOOST_CHECK_MESSAGE(secret.SetString(exp_base58string), \"!SetString:\"+ strTest);\n             BOOST_CHECK_MESSAGE(secret.IsValid(), \"!IsValid:\" + strTest);\n             CKey privkey = secret.GetKey();\n             BOOST_CHECK_MESSAGE(privkey.IsCompressed() == isCompressed, \"compressed mismatch:\" + strTest);\n             BOOST_CHECK_MESSAGE(privkey.size() == exp_payload.size() && std::equal(privkey.begin(), privkey.end(), exp_payload.begin()), \"key mismatch:\" + strTest);\n \n             // Private key must be invalid public key\n-            addr.SetString(exp_base58string);\n-            BOOST_CHECK_MESSAGE(!addr.IsValid(), \"IsValid privkey as pubkey:\" + strTest);\n+            destination = DecodeDestination(exp_base58string);\n+            BOOST_CHECK_MESSAGE(!IsValidDestination(destination), \"IsValid privkey as pubkey:\" + strTest);\n         }\n         else\n         {\n             std::string exp_addrType = find_value(metadata, \"addrType\").get_str(); // \"script\" or \"pubkey\"\n             // Must be valid public key\n-            BOOST_CHECK_MESSAGE(addr.SetString(exp_base58string), \"SetString:\" + strTest);\n-            BOOST_CHECK_MESSAGE(addr.IsValid(), \"!IsValid:\" + strTest);\n-            BOOST_CHECK_MESSAGE(addr.IsScript() == (exp_addrType == \"script\"), \"isScript mismatch\" + strTest);\n-            CTxDestination dest = addr.Get();\n-            BOOST_CHECK_MESSAGE(boost::apply_visitor(TestAddrTypeVisitor(exp_addrType), dest), \"addrType mismatch\" + strTest);\n+            destination = DecodeDestination(exp_base58string);\n+            BOOST_CHECK_MESSAGE(IsValidDestination(destination), \"!IsValid:\" + strTest);\n+            BOOST_CHECK_MESSAGE((boost::get<CScriptID>(&destination) != nullptr) == (exp_addrType == \"script\"), \"isScript mismatch\" + strTest);\n+            BOOST_CHECK_MESSAGE(boost::apply_visitor(TestAddrTypeVisitor(exp_addrType), destination), \"addrType mismatch\" + strTest);\n \n             // Public key must be invalid private key\n             secret.SetString(exp_base58string);\n@@ -226,17 +224,11 @@ BOOST_AUTO_TEST_CASE(base58_keys_valid_gen)\n                 BOOST_ERROR(\"Bad addrtype: \" << strTest);\n                 continue;\n             }\n-            CBitcoinAddress addrOut;\n-            BOOST_CHECK_MESSAGE(addrOut.Set(dest), \"encode dest: \" + strTest);\n-            BOOST_CHECK_MESSAGE(addrOut.ToString() == exp_base58string, \"mismatch: \" + strTest);\n+            std::string address = EncodeDestination(dest);\n+            BOOST_CHECK_MESSAGE(address == exp_base58string, \"mismatch: \" + strTest);\n         }\n     }\n \n-    // Visiting a CNoDestination must fail\n-    CBitcoinAddress dummyAddr;\n-    CTxDestination nodest = CNoDestination();\n-    BOOST_CHECK(!dummyAddr.Set(nodest));\n-\n     SelectParams(CBaseChainParams::MAIN);\n }\n \n@@ -245,7 +237,7 @@ BOOST_AUTO_TEST_CASE(base58_keys_invalid)\n {\n     UniValue tests = read_json(std::string(json_tests::base58_keys_invalid, json_tests::base58_keys_invalid + sizeof(json_tests::base58_keys_invalid))); // Negative testcases\n     CBitcoinSecret secret;\n-    CBitcoinAddress addr;\n+    CTxDestination destination;\n \n     for (unsigned int idx = 0; idx < tests.size(); idx++) {\n         UniValue test = tests[idx];\n@@ -258,8 +250,8 @@ BOOST_AUTO_TEST_CASE(base58_keys_invalid)\n         std::string exp_base58string = test[0].get_str();\n \n         // must be invalid as public and as private key\n-        addr.SetString(exp_base58string);\n-        BOOST_CHECK_MESSAGE(!addr.IsValid(), \"IsValid pubkey:\" + strTest);\n+        destination = DecodeDestination(exp_base58string);\n+        BOOST_CHECK_MESSAGE(!IsValidDestination(destination), \"IsValid pubkey:\" + strTest);\n         secret.SetString(exp_base58string);\n         BOOST_CHECK_MESSAGE(!secret.IsValid(), \"IsValid privkey:\" + strTest);\n     }"
      },
      {
        "sha": "91c0175412d61d4e59fba0880590f5b36552b857",
        "filename": "src/test/key_tests.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 14,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/test/key_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/test/key_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/key_tests.cpp?ref=5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
        "patch": "@@ -16,17 +16,16 @@\n \n #include <boost/test/unit_test.hpp>\n \n-static const std::string strSecret1     (\"5HxWvvfubhXpYYpS3tJkw6fq9jE9j18THftkZjHHfmFiWtmAbrj\");\n-static const std::string strSecret2     (\"5KC4ejrDjv152FGwP386VD1i2NYc5KkfSMyv1nGy1VGDxGHqVY3\");\n-static const std::string strSecret1C    (\"Kwr371tjA9u2rFSMZjTNun2PXXP3WPZu2afRHTcta6KxEUdm1vEw\");\n-static const std::string strSecret2C    (\"L3Hq7a8FEQwJkW1M2GNKDW28546Vp5miewcCzSqUD9kCAXrJdS3g\");\n-static const CBitcoinAddress addr1 (\"1QFqqMUD55ZV3PJEJZtaKCsQmjLT6JkjvJ\");\n-static const CBitcoinAddress addr2 (\"1F5y5E5FMc5YzdJtB9hLaUe43GDxEKXENJ\");\n-static const CBitcoinAddress addr1C(\"1NoJrossxPBKfCHuJXT4HadJrXRE9Fxiqs\");\n-static const CBitcoinAddress addr2C(\"1CRj2HyM1CXWzHAXLQtiGLyggNT9WQqsDs\");\n+static const std::string strSecret1 = \"5HxWvvfubhXpYYpS3tJkw6fq9jE9j18THftkZjHHfmFiWtmAbrj\";\n+static const std::string strSecret2 = \"5KC4ejrDjv152FGwP386VD1i2NYc5KkfSMyv1nGy1VGDxGHqVY3\";\n+static const std::string strSecret1C = \"Kwr371tjA9u2rFSMZjTNun2PXXP3WPZu2afRHTcta6KxEUdm1vEw\";\n+static const std::string strSecret2C = \"L3Hq7a8FEQwJkW1M2GNKDW28546Vp5miewcCzSqUD9kCAXrJdS3g\";\n+static const std::string addr1 = \"1QFqqMUD55ZV3PJEJZtaKCsQmjLT6JkjvJ\";\n+static const std::string addr2 = \"1F5y5E5FMc5YzdJtB9hLaUe43GDxEKXENJ\";\n+static const std::string addr1C = \"1NoJrossxPBKfCHuJXT4HadJrXRE9Fxiqs\";\n+static const std::string addr2C = \"1CRj2HyM1CXWzHAXLQtiGLyggNT9WQqsDs\";\n \n-\n-static const std::string strAddressBad(\"1HV9Lc3sNHZxwj4Zk6fB38tEmBryq2cBiF\");\n+static const std::string strAddressBad = \"1HV9Lc3sNHZxwj4Zk6fB38tEmBryq2cBiF\";\n \n \n BOOST_FIXTURE_TEST_SUITE(key_tests, BasicTestingSetup)\n@@ -74,10 +73,10 @@ BOOST_AUTO_TEST_CASE(key_test1)\n     BOOST_CHECK(!key2C.VerifyPubKey(pubkey2));\n     BOOST_CHECK(key2C.VerifyPubKey(pubkey2C));\n \n-    BOOST_CHECK(addr1.Get()  == CTxDestination(pubkey1.GetID()));\n-    BOOST_CHECK(addr2.Get()  == CTxDestination(pubkey2.GetID()));\n-    BOOST_CHECK(addr1C.Get() == CTxDestination(pubkey1C.GetID()));\n-    BOOST_CHECK(addr2C.Get() == CTxDestination(pubkey2C.GetID()));\n+    BOOST_CHECK(DecodeDestination(addr1)  == CTxDestination(pubkey1.GetID()));\n+    BOOST_CHECK(DecodeDestination(addr2)  == CTxDestination(pubkey2.GetID()));\n+    BOOST_CHECK(DecodeDestination(addr1C) == CTxDestination(pubkey1C.GetID()));\n+    BOOST_CHECK(DecodeDestination(addr2C) == CTxDestination(pubkey2C.GetID()));\n \n     for (int n=0; n<16; n++)\n     {"
      },
      {
        "sha": "9539cc9f429f291fb45c701033900ef2ffb2318c",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 42,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
        "patch": "@@ -181,7 +181,7 @@ UniValue abortrescan(const JSONRPCRequest& request)\n     return true;\n }\n \n-void ImportAddress(CWallet*, const CBitcoinAddress& address, const std::string& strLabel);\n+void ImportAddress(CWallet*, const CTxDestination& dest, const std::string& strLabel);\n void ImportScript(CWallet* const pwallet, const CScript& script, const std::string& strLabel, bool isRedeemScript)\n {\n     if (!isRedeemScript && ::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n@@ -198,7 +198,7 @@ void ImportScript(CWallet* const pwallet, const CScript& script, const std::stri\n         if (!pwallet->HaveCScript(script) && !pwallet->AddCScript(script)) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n         }\n-        ImportAddress(pwallet, CBitcoinAddress(CScriptID(script)), strLabel);\n+        ImportAddress(pwallet, CScriptID(script), strLabel);\n     } else {\n         CTxDestination destination;\n         if (ExtractDestination(script, destination)) {\n@@ -207,13 +207,13 @@ void ImportScript(CWallet* const pwallet, const CScript& script, const std::stri\n     }\n }\n \n-void ImportAddress(CWallet* const pwallet, const CBitcoinAddress& address, const std::string& strLabel)\n+void ImportAddress(CWallet* const pwallet, const CTxDestination& dest, const std::string& strLabel)\n {\n-    CScript script = GetScriptForDestination(address.Get());\n+    CScript script = GetScriptForDestination(dest);\n     ImportScript(pwallet, script, strLabel, false);\n     // add to address book or update label\n-    if (address.IsValid())\n-        pwallet->SetAddressBook(address.Get(), strLabel, \"receive\");\n+    if (IsValidDestination(dest))\n+        pwallet->SetAddressBook(dest, strLabel, \"receive\");\n }\n \n UniValue importaddress(const JSONRPCRequest& request)\n@@ -265,11 +265,12 @@ UniValue importaddress(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    CBitcoinAddress address(request.params[0].get_str());\n-    if (address.IsValid()) {\n-        if (fP2SH)\n+    CTxDestination dest = DecodeDestination(request.params[0].get_str());\n+    if (IsValidDestination(dest)) {\n+        if (fP2SH) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Cannot use the p2sh flag with an address - use a script instead\");\n-        ImportAddress(pwallet, address, strLabel);\n+        }\n+        ImportAddress(pwallet, dest, strLabel);\n     } else if (IsHex(request.params[0].get_str())) {\n         std::vector<unsigned char> data(ParseHex(request.params[0].get_str()));\n         ImportScript(pwallet, CScript(data.begin(), data.end()), strLabel, fP2SH);\n@@ -432,7 +433,7 @@ UniValue importpubkey(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    ImportAddress(pwallet, CBitcoinAddress(pubKey.GetID()), strLabel);\n+    ImportAddress(pwallet, pubKey.GetID(), strLabel);\n     ImportScript(pwallet, GetScriptForRawPubKey(pubKey), strLabel, false);\n \n     if (fRescan)\n@@ -506,7 +507,7 @@ UniValue importwallet(const JSONRPCRequest& request)\n         assert(key.VerifyPubKey(pubkey));\n         CKeyID keyid = pubkey.GetID();\n         if (pwallet->HaveKey(keyid)) {\n-            LogPrintf(\"Skipping import of %s (key already present)\\n\", CBitcoinAddress(keyid).ToString());\n+            LogPrintf(\"Skipping import of %s (key already present)\\n\", EncodeDestination(keyid));\n             continue;\n         }\n         int64_t nTime = DecodeDumpTime(vstr[1]);\n@@ -524,7 +525,7 @@ UniValue importwallet(const JSONRPCRequest& request)\n                 fLabel = true;\n             }\n         }\n-        LogPrintf(\"Importing %s...\\n\", CBitcoinAddress(keyid).ToString());\n+        LogPrintf(\"Importing %s...\\n\", EncodeDestination(keyid));\n         if (!pwallet->AddKeyPubKey(key, pubkey)) {\n             fGood = false;\n             continue;\n@@ -573,14 +574,16 @@ UniValue dumpprivkey(const JSONRPCRequest& request)\n     EnsureWalletIsUnlocked(pwallet);\n \n     std::string strAddress = request.params[0].get_str();\n-    CBitcoinAddress address;\n-    if (!address.SetString(strAddress))\n+    CTxDestination dest = DecodeDestination(strAddress);\n+    if (!IsValidDestination(dest)) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n-    CKeyID keyID;\n-    if (!address.GetKeyID(keyID))\n+    }\n+    const CKeyID *keyID = boost::get<CKeyID>(&dest);\n+    if (!keyID) {\n         throw JSONRPCError(RPC_TYPE_ERROR, \"Address does not refer to a key\");\n+    }\n     CKey vchSecret;\n-    if (!pwallet->GetKey(keyID, vchSecret)) {\n+    if (!pwallet->GetKey(*keyID, vchSecret)) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Private key for address \" + strAddress + \" is not known\");\n     }\n     return CBitcoinSecret(vchSecret).ToString();\n@@ -659,7 +662,7 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     for (std::vector<std::pair<int64_t, CKeyID> >::const_iterator it = vKeyBirth.begin(); it != vKeyBirth.end(); it++) {\n         const CKeyID &keyid = it->second;\n         std::string strTime = EncodeDumpTime(it->first);\n-        std::string strAddr = CBitcoinAddress(keyid).ToString();\n+        std::string strAddr = EncodeDestination(keyid);\n         CKey key;\n         if (pwallet->GetKey(keyid, key)) {\n             file << strprintf(\"%s %s \", CBitcoinSecret(key).ToString(), strTime);\n@@ -715,14 +718,14 @@ UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int6\n \n         // Parse the output.\n         CScript script;\n-        CBitcoinAddress address;\n+        CTxDestination dest;\n \n         if (!isScript) {\n-            address = CBitcoinAddress(output);\n-            if (!address.IsValid()) {\n+            dest = DecodeDestination(output);\n+            if (!IsValidDestination(dest)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n             }\n-            script = GetScriptForDestination(address.Get());\n+            script = GetScriptForDestination(dest);\n         } else {\n             if (!IsHex(output)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n@@ -780,8 +783,8 @@ UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int6\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n             }\n \n-            CBitcoinAddress redeemAddress = CBitcoinAddress(CScriptID(redeemScript));\n-            CScript redeemDestination = GetScriptForDestination(redeemAddress.Get());\n+            CTxDestination redeem_dest = CScriptID(redeemScript);\n+            CScript redeemDestination = GetScriptForDestination(redeem_dest);\n \n             if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n@@ -794,8 +797,8 @@ UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int6\n             }\n \n             // add to address book or update label\n-            if (address.IsValid()) {\n-                pwallet->SetAddressBook(address.Get(), label, \"receive\");\n+            if (IsValidDestination(dest)) {\n+                pwallet->SetAddressBook(dest, label, \"receive\");\n             }\n \n             // Import private keys.\n@@ -854,27 +857,25 @@ UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int6\n                     throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n                 }\n \n-                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+                CTxDestination pubkey_dest = pubKey.GetID();\n \n                 // Consistency check.\n-                if (!isScript && !(pubKeyAddress.Get() == address.Get())) {\n+                if (!isScript && !(pubkey_dest == dest)) {\n                     throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n                 }\n \n                 // Consistency check.\n                 if (isScript) {\n-                    CBitcoinAddress scriptAddress;\n                     CTxDestination destination;\n \n                     if (ExtractDestination(script, destination)) {\n-                        scriptAddress = CBitcoinAddress(destination);\n-                        if (!(scriptAddress.Get() == pubKeyAddress.Get())) {\n+                        if (!(destination == pubkey_dest)) {\n                             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n                         }\n                     }\n                 }\n \n-                CScript pubKeyScript = GetScriptForDestination(pubKeyAddress.Get());\n+                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n \n                 if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n                     throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n@@ -887,8 +888,8 @@ UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int6\n                 }\n \n                 // add to address book or update label\n-                if (pubKeyAddress.IsValid()) {\n-                    pwallet->SetAddressBook(pubKeyAddress.Get(), label, \"receive\");\n+                if (IsValidDestination(pubkey_dest)) {\n+                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n                 }\n \n                 // TODO Is this necessary?\n@@ -927,21 +928,19 @@ UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int6\n                 CPubKey pubKey = key.GetPubKey();\n                 assert(key.VerifyPubKey(pubKey));\n \n-                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+                CTxDestination pubkey_dest = pubKey.GetID();\n \n                 // Consistency check.\n-                if (!isScript && !(pubKeyAddress.Get() == address.Get())) {\n+                if (!isScript && !(pubkey_dest == dest)) {\n                     throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n                 }\n \n                 // Consistency check.\n                 if (isScript) {\n-                    CBitcoinAddress scriptAddress;\n                     CTxDestination destination;\n \n                     if (ExtractDestination(script, destination)) {\n-                        scriptAddress = CBitcoinAddress(destination);\n-                        if (!(scriptAddress.Get() == pubKeyAddress.Get())) {\n+                        if (!(destination == pubkey_dest)) {\n                             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n                         }\n                     }\n@@ -980,8 +979,8 @@ UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int6\n \n                 if (scriptPubKey.getType() == UniValue::VOBJ) {\n                     // add to address book or update label\n-                    if (address.IsValid()) {\n-                        pwallet->SetAddressBook(address.Get(), label, \"receive\");\n+                    if (IsValidDestination(dest)) {\n+                        pwallet->SetAddressBook(dest, label, \"receive\");\n                     }\n                 }\n "
      },
      {
        "sha": "637ca04e82e3e5aa5d1e1fec18d1113e8113cbc0",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 85,
        "deletions": 74,
        "changes": 159,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
        "patch": "@@ -170,18 +170,18 @@ UniValue getnewaddress(const JSONRPCRequest& request)\n \n     pwallet->SetAddressBook(keyID, strAccount, \"receive\");\n \n-    return CBitcoinAddress(keyID).ToString();\n+    return EncodeDestination(keyID);\n }\n \n \n-CBitcoinAddress GetAccountAddress(CWallet* const pwallet, std::string strAccount, bool bForceNew=false)\n+CTxDestination GetAccountAddress(CWallet* const pwallet, std::string strAccount, bool bForceNew=false)\n {\n     CPubKey pubKey;\n     if (!pwallet->GetAccountPubkey(pubKey, strAccount, bForceNew)) {\n         throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, \"Error: Keypool ran out, please call keypoolrefill first\");\n     }\n \n-    return CBitcoinAddress(pubKey.GetID());\n+    return pubKey.GetID();\n }\n \n UniValue getaccountaddress(const JSONRPCRequest& request)\n@@ -213,7 +213,7 @@ UniValue getaccountaddress(const JSONRPCRequest& request)\n \n     UniValue ret(UniValue::VSTR);\n \n-    ret = GetAccountAddress(pwallet, strAccount).ToString();\n+    ret = EncodeDestination(GetAccountAddress(pwallet, strAccount));\n     return ret;\n }\n \n@@ -252,7 +252,7 @@ UniValue getrawchangeaddress(const JSONRPCRequest& request)\n \n     CKeyID keyID = vchPubKey.GetID();\n \n-    return CBitcoinAddress(keyID).ToString();\n+    return EncodeDestination(keyID);\n }\n \n \n@@ -277,24 +277,25 @@ UniValue setaccount(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    CBitcoinAddress address(request.params[0].get_str());\n-    if (!address.IsValid())\n+    CTxDestination dest = DecodeDestination(request.params[0].get_str());\n+    if (!IsValidDestination(dest)) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n+    }\n \n     std::string strAccount;\n     if (!request.params[1].isNull())\n         strAccount = AccountFromValue(request.params[1]);\n \n     // Only add the account if the address is yours.\n-    if (IsMine(*pwallet, address.Get())) {\n+    if (IsMine(*pwallet, dest)) {\n         // Detect when changing the account of an address that is the 'unused current key' of another account:\n-        if (pwallet->mapAddressBook.count(address.Get())) {\n-            std::string strOldAccount = pwallet->mapAddressBook[address.Get()].name;\n-            if (address == GetAccountAddress(pwallet, strOldAccount)) {\n+        if (pwallet->mapAddressBook.count(dest)) {\n+            std::string strOldAccount = pwallet->mapAddressBook[dest].name;\n+            if (dest == GetAccountAddress(pwallet, strOldAccount)) {\n                 GetAccountAddress(pwallet, strOldAccount, true);\n             }\n         }\n-        pwallet->SetAddressBook(address.Get(), strAccount, \"receive\");\n+        pwallet->SetAddressBook(dest, strAccount, \"receive\");\n     }\n     else\n         throw JSONRPCError(RPC_MISC_ERROR, \"setaccount can only be used with own address\");\n@@ -325,12 +326,13 @@ UniValue getaccount(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    CBitcoinAddress address(request.params[0].get_str());\n-    if (!address.IsValid())\n+    CTxDestination dest = DecodeDestination(request.params[0].get_str());\n+    if (!IsValidDestination(dest)) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n+    }\n \n     std::string strAccount;\n-    std::map<CTxDestination, CAddressBookData>::iterator mi = pwallet->mapAddressBook.find(address.Get());\n+    std::map<CTxDestination, CAddressBookData>::iterator mi = pwallet->mapAddressBook.find(dest);\n     if (mi != pwallet->mapAddressBook.end() && !(*mi).second.name.empty()) {\n         strAccount = (*mi).second.name;\n     }\n@@ -367,11 +369,12 @@ UniValue getaddressesbyaccount(const JSONRPCRequest& request)\n \n     // Find all addresses that have the given account\n     UniValue ret(UniValue::VARR);\n-    for (const std::pair<CBitcoinAddress, CAddressBookData>& item : pwallet->mapAddressBook) {\n-        const CBitcoinAddress& address = item.first;\n+    for (const std::pair<CTxDestination, CAddressBookData>& item : pwallet->mapAddressBook) {\n+        const CTxDestination& dest = item.first;\n         const std::string& strName = item.second.name;\n-        if (strName == strAccount)\n-            ret.push_back(address.ToString());\n+        if (strName == strAccount) {\n+            ret.push_back(EncodeDestination(dest));\n+        }\n     }\n     return ret;\n }\n@@ -454,9 +457,10 @@ UniValue sendtoaddress(const JSONRPCRequest& request)\n     ObserveSafeMode();\n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    CBitcoinAddress address(request.params[0].get_str());\n-    if (!address.IsValid())\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n+    CTxDestination dest = DecodeDestination(request.params[0].get_str());\n+    if (!IsValidDestination(dest)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n \n     // Amount\n     CAmount nAmount = AmountFromValue(request.params[1]);\n@@ -493,7 +497,7 @@ UniValue sendtoaddress(const JSONRPCRequest& request)\n \n     EnsureWalletIsUnlocked(pwallet);\n \n-    SendMoney(pwallet, address.Get(), nAmount, fSubtractFeeFromAmount, wtx, coin_control);\n+    SendMoney(pwallet, dest, nAmount, fSubtractFeeFromAmount, wtx, coin_control);\n \n     return wtx.GetHash().GetHex();\n }\n@@ -533,16 +537,16 @@ UniValue listaddressgroupings(const JSONRPCRequest& request)\n \n     UniValue jsonGroupings(UniValue::VARR);\n     std::map<CTxDestination, CAmount> balances = pwallet->GetAddressBalances();\n-    for (std::set<CTxDestination> grouping : pwallet->GetAddressGroupings()) {\n+    for (const std::set<CTxDestination>& grouping : pwallet->GetAddressGroupings()) {\n         UniValue jsonGrouping(UniValue::VARR);\n-        for (CTxDestination address : grouping)\n+        for (const CTxDestination& address : grouping)\n         {\n             UniValue addressInfo(UniValue::VARR);\n-            addressInfo.push_back(CBitcoinAddress(address).ToString());\n+            addressInfo.push_back(EncodeDestination(address));\n             addressInfo.push_back(ValueFromAmount(balances[address]));\n             {\n-                if (pwallet->mapAddressBook.find(CBitcoinAddress(address).Get()) != pwallet->mapAddressBook.end()) {\n-                    addressInfo.push_back(pwallet->mapAddressBook.find(CBitcoinAddress(address).Get())->second.name);\n+                if (pwallet->mapAddressBook.find(address) != pwallet->mapAddressBook.end()) {\n+                    addressInfo.push_back(pwallet->mapAddressBook.find(address)->second.name);\n                 }\n             }\n             jsonGrouping.push_back(addressInfo);\n@@ -587,16 +591,18 @@ UniValue signmessage(const JSONRPCRequest& request)\n     std::string strAddress = request.params[0].get_str();\n     std::string strMessage = request.params[1].get_str();\n \n-    CBitcoinAddress addr(strAddress);\n-    if (!addr.IsValid())\n+    CTxDestination dest = DecodeDestination(strAddress);\n+    if (!IsValidDestination(dest)) {\n         throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid address\");\n+    }\n \n-    CKeyID keyID;\n-    if (!addr.GetKeyID(keyID))\n+    const CKeyID *keyID = boost::get<CKeyID>(&dest);\n+    if (!keyID) {\n         throw JSONRPCError(RPC_TYPE_ERROR, \"Address does not refer to key\");\n+    }\n \n     CKey key;\n-    if (!pwallet->GetKey(keyID, key)) {\n+    if (!pwallet->GetKey(*keyID, key)) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Private key not available\");\n     }\n \n@@ -642,10 +648,11 @@ UniValue getreceivedbyaddress(const JSONRPCRequest& request)\n     LOCK2(cs_main, pwallet->cs_wallet);\n \n     // Bitcoin address\n-    CBitcoinAddress address = CBitcoinAddress(request.params[0].get_str());\n-    if (!address.IsValid())\n+    CTxDestination dest = DecodeDestination(request.params[0].get_str());\n+    if (!IsValidDestination(dest)) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n-    CScript scriptPubKey = GetScriptForDestination(address.Get());\n+    }\n+    CScript scriptPubKey = GetScriptForDestination(dest);\n     if (!IsMine(*pwallet, scriptPubKey)) {\n         return ValueFromAmount(0);\n     }\n@@ -915,9 +922,10 @@ UniValue sendfrom(const JSONRPCRequest& request)\n     LOCK2(cs_main, pwallet->cs_wallet);\n \n     std::string strAccount = AccountFromValue(request.params[0]);\n-    CBitcoinAddress address(request.params[1].get_str());\n-    if (!address.IsValid())\n+    CTxDestination dest = DecodeDestination(request.params[1].get_str());\n+    if (!IsValidDestination(dest)) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n+    }\n     CAmount nAmount = AmountFromValue(request.params[2]);\n     if (nAmount <= 0)\n         throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid amount for send\");\n@@ -940,7 +948,7 @@ UniValue sendfrom(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Account has insufficient funds\");\n \n     CCoinControl no_coin_control; // This is a deprecated API\n-    SendMoney(pwallet, address.Get(), nAmount, false, wtx, no_coin_control);\n+    SendMoney(pwallet, dest, nAmount, false, wtx, no_coin_control);\n \n     return wtx.GetHash().GetHex();\n }\n@@ -1032,22 +1040,23 @@ UniValue sendmany(const JSONRPCRequest& request)\n         }\n     }\n \n-    std::set<CBitcoinAddress> setAddress;\n+    std::set<CTxDestination> destinations;\n     std::vector<CRecipient> vecSend;\n \n     CAmount totalAmount = 0;\n     std::vector<std::string> keys = sendTo.getKeys();\n-    for (const std::string& name_ : keys)\n-    {\n-        CBitcoinAddress address(name_);\n-        if (!address.IsValid())\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(\"Invalid Bitcoin address: \")+name_);\n+    for (const std::string& name_ : keys) {\n+        CTxDestination dest = DecodeDestination(name_);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(\"Invalid Bitcoin address: \") + name_);\n+        }\n \n-        if (setAddress.count(address))\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, std::string(\"Invalid parameter, duplicated address: \")+name_);\n-        setAddress.insert(address);\n+        if (destinations.count(dest)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, std::string(\"Invalid parameter, duplicated address: \") + name_);\n+        }\n+        destinations.insert(dest);\n \n-        CScript scriptPubKey = GetScriptForDestination(address.Get());\n+        CScript scriptPubKey = GetScriptForDestination(dest);\n         CAmount nAmount = AmountFromValue(sendTo[name_]);\n         if (nAmount <= 0)\n             throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid amount for send\");\n@@ -1138,7 +1147,7 @@ UniValue addmultisigaddress(const JSONRPCRequest& request)\n     pwallet->AddCScript(inner);\n \n     pwallet->SetAddressBook(innerID, strAccount, \"send\");\n-    return CBitcoinAddress(innerID).ToString();\n+    return EncodeDestination(innerID);\n }\n \n class Witnessifier : public boost::static_visitor<bool>\n@@ -1226,20 +1235,20 @@ UniValue addwitnessaddress(const JSONRPCRequest& request)\n         }\n     }\n \n-    CBitcoinAddress address(request.params[0].get_str());\n-    if (!address.IsValid())\n+    CTxDestination dest = DecodeDestination(request.params[0].get_str());\n+    if (!IsValidDestination(dest)) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n+    }\n \n     Witnessifier w(pwallet);\n-    CTxDestination dest = address.Get();\n     bool ret = boost::apply_visitor(w, dest);\n     if (!ret) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Public key or redeemscript not known to wallet, or the key is uncompressed\");\n     }\n \n     pwallet->SetAddressBook(w.result, \"\", \"receive\");\n \n-    return CBitcoinAddress(w.result).ToString();\n+    return EncodeDestination(w.result);\n }\n \n struct tallyitem\n@@ -1274,7 +1283,7 @@ UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool fByA\n             filter = filter | ISMINE_WATCH_ONLY;\n \n     // Tally\n-    std::map<CBitcoinAddress, tallyitem> mapTally;\n+    std::map<CTxDestination, tallyitem> mapTally;\n     for (const std::pair<uint256, CWalletTx>& pairWtx : pwallet->mapWallet) {\n         const CWalletTx& wtx = pairWtx.second;\n \n@@ -1307,10 +1316,10 @@ UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool fByA\n     // Reply\n     UniValue ret(UniValue::VARR);\n     std::map<std::string, tallyitem> mapAccountTally;\n-    for (const std::pair<CBitcoinAddress, CAddressBookData>& item : pwallet->mapAddressBook) {\n-        const CBitcoinAddress& address = item.first;\n+    for (const std::pair<CTxDestination, CAddressBookData>& item : pwallet->mapAddressBook) {\n+        const CTxDestination& dest = item.first;\n         const std::string& strAccount = item.second.name;\n-        std::map<CBitcoinAddress, tallyitem>::iterator it = mapTally.find(address);\n+        std::map<CTxDestination, tallyitem>::iterator it = mapTally.find(dest);\n         if (it == mapTally.end() && !fIncludeEmpty)\n             continue;\n \n@@ -1336,7 +1345,7 @@ UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool fByA\n             UniValue obj(UniValue::VOBJ);\n             if(fIsWatchonly)\n                 obj.push_back(Pair(\"involvesWatchonly\", true));\n-            obj.push_back(Pair(\"address\",       address.ToString()));\n+            obj.push_back(Pair(\"address\",       EncodeDestination(dest)));\n             obj.push_back(Pair(\"account\",       strAccount));\n             obj.push_back(Pair(\"amount\",        ValueFromAmount(nAmount)));\n             obj.push_back(Pair(\"confirmations\", (nConf == std::numeric_limits<int>::max() ? 0 : nConf)));\n@@ -1461,9 +1470,9 @@ UniValue listreceivedbyaccount(const JSONRPCRequest& request)\n \n static void MaybePushAddress(UniValue & entry, const CTxDestination &dest)\n {\n-    CBitcoinAddress addr;\n-    if (addr.Set(dest))\n-        entry.push_back(Pair(\"address\", addr.ToString()));\n+    if (IsValidDestination(dest)) {\n+        entry.push_back(Pair(\"address\", EncodeDestination(dest)));\n+    }\n }\n \n /**\n@@ -2717,18 +2726,19 @@ UniValue listunspent(const JSONRPCRequest& request)\n         nMaxDepth = request.params[1].get_int();\n     }\n \n-    std::set<CBitcoinAddress> setAddress;\n+    std::set<CTxDestination> destinations;\n     if (!request.params[2].isNull()) {\n         RPCTypeCheckArgument(request.params[2], UniValue::VARR);\n         UniValue inputs = request.params[2].get_array();\n         for (unsigned int idx = 0; idx < inputs.size(); idx++) {\n             const UniValue& input = inputs[idx];\n-            CBitcoinAddress address(input.get_str());\n-            if (!address.IsValid())\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(\"Invalid Bitcoin address: \")+input.get_str());\n-            if (setAddress.count(address))\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, std::string(\"Invalid parameter, duplicated address: \")+input.get_str());\n-           setAddress.insert(address);\n+            CTxDestination dest = DecodeDestination(input.get_str());\n+            if (!IsValidDestination(dest)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(\"Invalid Bitcoin address: \") + input.get_str());\n+            }\n+            if (!destinations.insert(dest).second) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, std::string(\"Invalid parameter, duplicated address: \") + input.get_str());\n+            }\n         }\n     }\n \n@@ -2770,15 +2780,15 @@ UniValue listunspent(const JSONRPCRequest& request)\n         const CScript& scriptPubKey = out.tx->tx->vout[out.i].scriptPubKey;\n         bool fValidAddress = ExtractDestination(scriptPubKey, address);\n \n-        if (setAddress.size() && (!fValidAddress || !setAddress.count(address)))\n+        if (destinations.size() && (!fValidAddress || !destinations.count(address)))\n             continue;\n \n         UniValue entry(UniValue::VOBJ);\n         entry.push_back(Pair(\"txid\", out.tx->GetHash().GetHex()));\n         entry.push_back(Pair(\"vout\", out.i));\n \n         if (fValidAddress) {\n-            entry.push_back(Pair(\"address\", CBitcoinAddress(address).ToString()));\n+            entry.push_back(Pair(\"address\", EncodeDestination(address)));\n \n             if (pwallet->mapAddressBook.count(address)) {\n                 entry.push_back(Pair(\"account\", pwallet->mapAddressBook[address].name));\n@@ -2901,12 +2911,13 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n             true, true);\n \n         if (options.exists(\"changeAddress\")) {\n-            CBitcoinAddress address(options[\"changeAddress\"].get_str());\n+            CTxDestination dest = DecodeDestination(options[\"changeAddress\"].get_str());\n \n-            if (!address.IsValid())\n+            if (!IsValidDestination(dest)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"changeAddress must be a valid bitcoin address\");\n+            }\n \n-            coinControl.destChange = address.Get();\n+            coinControl.destChange = dest;\n         }\n \n         if (options.exists(\"changePosition\"))"
      },
      {
        "sha": "584324feb5890425458972f3a6be17702e22ffdc",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
        "patch": "@@ -307,7 +307,7 @@ bool CWallet::LoadCScript(const CScript& redeemScript)\n      * these. Do not add them to the wallet and warn. */\n     if (redeemScript.size() > MAX_SCRIPT_ELEMENT_SIZE)\n     {\n-        std::string strAddr = CBitcoinAddress(CScriptID(redeemScript)).ToString();\n+        std::string strAddr = EncodeDestination(CScriptID(redeemScript));\n         LogPrintf(\"%s: Warning: This wallet contains a redeemScript of size %i which exceeds maximum size %i thus can never be redeemed. Do not use address %s.\\n\",\n             __func__, redeemScript.size(), MAX_SCRIPT_ELEMENT_SIZE, strAddr);\n         return true;\n@@ -3072,9 +3072,9 @@ bool CWallet::SetAddressBook(const CTxDestination& address, const std::string& s\n     }\n     NotifyAddressBookChanged(this, address, strName, ::IsMine(*this, address) != ISMINE_NO,\n                              strPurpose, (fUpdated ? CT_UPDATED : CT_NEW) );\n-    if (!strPurpose.empty() && !CWalletDB(*dbw).WritePurpose(CBitcoinAddress(address).ToString(), strPurpose))\n+    if (!strPurpose.empty() && !CWalletDB(*dbw).WritePurpose(EncodeDestination(address), strPurpose))\n         return false;\n-    return CWalletDB(*dbw).WriteName(CBitcoinAddress(address).ToString(), strName);\n+    return CWalletDB(*dbw).WriteName(EncodeDestination(address), strName);\n }\n \n bool CWallet::DelAddressBook(const CTxDestination& address)\n@@ -3083,7 +3083,7 @@ bool CWallet::DelAddressBook(const CTxDestination& address)\n         LOCK(cs_wallet); // mapAddressBook\n \n         // Delete destdata tuples associated with address\n-        std::string strAddress = CBitcoinAddress(address).ToString();\n+        std::string strAddress = EncodeDestination(address);\n         for (const std::pair<std::string, std::string> &item : mapAddressBook[address].destdata)\n         {\n             CWalletDB(*dbw).EraseDestData(strAddress, item.first);\n@@ -3093,8 +3093,8 @@ bool CWallet::DelAddressBook(const CTxDestination& address)\n \n     NotifyAddressBookChanged(this, address, \"\", ::IsMine(*this, address) != ISMINE_NO, \"\", CT_DELETED);\n \n-    CWalletDB(*dbw).ErasePurpose(CBitcoinAddress(address).ToString());\n-    return CWalletDB(*dbw).EraseName(CBitcoinAddress(address).ToString());\n+    CWalletDB(*dbw).ErasePurpose(EncodeDestination(address));\n+    return CWalletDB(*dbw).EraseName(EncodeDestination(address));\n }\n \n const std::string& CWallet::GetAccountName(const CScript& scriptPubKey) const\n@@ -3711,14 +3711,14 @@ bool CWallet::AddDestData(const CTxDestination &dest, const std::string &key, co\n         return false;\n \n     mapAddressBook[dest].destdata.insert(std::make_pair(key, value));\n-    return CWalletDB(*dbw).WriteDestData(CBitcoinAddress(dest).ToString(), key, value);\n+    return CWalletDB(*dbw).WriteDestData(EncodeDestination(dest), key, value);\n }\n \n bool CWallet::EraseDestData(const CTxDestination &dest, const std::string &key)\n {\n     if (!mapAddressBook[dest].destdata.erase(key))\n         return false;\n-    return CWalletDB(*dbw).EraseDestData(CBitcoinAddress(dest).ToString(), key);\n+    return CWalletDB(*dbw).EraseDestData(EncodeDestination(dest), key);\n }\n \n bool CWallet::LoadDestData(const CTxDestination &dest, const std::string &key, const std::string &value)"
      },
      {
        "sha": "52370a8eb5676ea429bb6d816aa912c8b8e55e62",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
        "patch": "@@ -253,13 +253,13 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n         {\n             std::string strAddress;\n             ssKey >> strAddress;\n-            ssValue >> pwallet->mapAddressBook[CBitcoinAddress(strAddress).Get()].name;\n+            ssValue >> pwallet->mapAddressBook[DecodeDestination(strAddress)].name;\n         }\n         else if (strType == \"purpose\")\n         {\n             std::string strAddress;\n             ssKey >> strAddress;\n-            ssValue >> pwallet->mapAddressBook[CBitcoinAddress(strAddress).Get()].purpose;\n+            ssValue >> pwallet->mapAddressBook[DecodeDestination(strAddress)].purpose;\n         }\n         else if (strType == \"tx\")\n         {\n@@ -493,7 +493,7 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n             ssKey >> strAddress;\n             ssKey >> strKey;\n             ssValue >> strValue;\n-            if (!pwallet->LoadDestData(CBitcoinAddress(strAddress).Get(), strKey, strValue))\n+            if (!pwallet->LoadDestData(DecodeDestination(strAddress), strKey, strValue))\n             {\n                 strErr = \"Error reading wallet database: LoadDestData failed\";\n                 return false;"
      }
    ]
  },
  {
    "sha": "864cd278741ab0e17e7d93eedee39417d4797b37",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4NjRjZDI3ODc0MWFiMGUxN2U3ZDkzZWVkZWUzOTQxN2Q0Nzk3YjM3",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-08-23T06:46:51Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-09-06T20:07:45Z"
      },
      "message": "Move CBitcoinAddress to base58.cpp",
      "tree": {
        "sha": "83c407bda9f0cf0437a4c46a7d35c37f732f9a05",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/83c407bda9f0cf0437a4c46a7d35c37f732f9a05"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/864cd278741ab0e17e7d93eedee39417d4797b37",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/864cd278741ab0e17e7d93eedee39417d4797b37",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/864cd278741ab0e17e7d93eedee39417d4797b37",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/864cd278741ab0e17e7d93eedee39417d4797b37/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5c8ff0d448ffdc6340b195ddfa2128d5f21a839b"
      }
    ],
    "stats": {
      "total": 48,
      "additions": 24,
      "deletions": 24
    },
    "files": [
      {
        "sha": "e093608aa3f758aefabaed506d69b921d737405d",
        "filename": "src/base58.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/864cd278741ab0e17e7d93eedee39417d4797b37/src/base58.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/864cd278741ab0e17e7d93eedee39417d4797b37/src/base58.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.cpp?ref=864cd278741ab0e17e7d93eedee39417d4797b37",
        "patch": "@@ -212,6 +212,30 @@ int CBase58Data::CompareTo(const CBase58Data& b58) const\n \n namespace\n {\n+/** base58-encoded Bitcoin addresses.\n+ * Public-key-hash-addresses have version 0 (or 111 testnet).\n+ * The data vector contains RIPEMD160(SHA256(pubkey)), where pubkey is the serialized public key.\n+ * Script-hash-addresses have version 5 (or 196 testnet).\n+ * The data vector contains RIPEMD160(SHA256(cscript)), where cscript is the serialized redemption script.\n+ */\n+class CBitcoinAddress : public CBase58Data {\n+public:\n+    bool Set(const CKeyID &id);\n+    bool Set(const CScriptID &id);\n+    bool Set(const CTxDestination &dest);\n+    bool IsValid() const;\n+    bool IsValid(const CChainParams &params) const;\n+\n+    CBitcoinAddress() {}\n+    CBitcoinAddress(const CTxDestination &dest) { Set(dest); }\n+    CBitcoinAddress(const std::string& strAddress) { SetString(strAddress); }\n+    CBitcoinAddress(const char* pszAddress) { SetString(pszAddress); }\n+\n+    CTxDestination Get() const;\n+    bool GetKeyID(CKeyID &keyID) const;\n+    bool IsScript() const;\n+};\n+\n class CBitcoinAddressVisitor : public boost::static_visitor<bool>\n {\n private:"
      },
      {
        "sha": "4b895ca02228b6933d879cf11180951e00554c67",
        "filename": "src/base58.h",
        "status": "modified",
        "additions": 0,
        "deletions": 24,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/864cd278741ab0e17e7d93eedee39417d4797b37/src/base58.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/864cd278741ab0e17e7d93eedee39417d4797b37/src/base58.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.h?ref=864cd278741ab0e17e7d93eedee39417d4797b37",
        "patch": "@@ -95,30 +95,6 @@ class CBase58Data\n     bool operator> (const CBase58Data& b58) const { return CompareTo(b58) >  0; }\n };\n \n-/** base58-encoded Bitcoin addresses.\n- * Public-key-hash-addresses have version 0 (or 111 testnet).\n- * The data vector contains RIPEMD160(SHA256(pubkey)), where pubkey is the serialized public key.\n- * Script-hash-addresses have version 5 (or 196 testnet).\n- * The data vector contains RIPEMD160(SHA256(cscript)), where cscript is the serialized redemption script.\n- */\n-class CBitcoinAddress : public CBase58Data {\n-public:\n-    bool Set(const CKeyID &id);\n-    bool Set(const CScriptID &id);\n-    bool Set(const CTxDestination &dest);\n-    bool IsValid() const;\n-    bool IsValid(const CChainParams &params) const;\n-\n-    CBitcoinAddress() {}\n-    CBitcoinAddress(const CTxDestination &dest) { Set(dest); }\n-    CBitcoinAddress(const std::string& strAddress) { SetString(strAddress); }\n-    CBitcoinAddress(const char* pszAddress) { SetString(pszAddress); }\n-\n-    CTxDestination Get() const;\n-    bool GetKeyID(CKeyID &keyID) const;\n-    bool IsScript() const;\n-};\n-\n /**\n  * A base58-encoded secret key\n  */"
      }
    ]
  }
]