promag,2020-03-06 15:00:54,I think this is the wrong approach.,https://github.com/bitcoin/bitcoin/pull/18279#issuecomment-595806717,595806717,
bvbfan,2020-03-06 15:16:54,"> I think this is the wrong approach.\n\nThat's at least ensure sync between wallet and chain tips otherwise all calls to `BlockUntilSyncedToCurrentChain` are just pointless, they don't do what is supposed to do. Your patch looks fine but not what we want when calls a function like `BlockUntilSyncedToCurrentChain`",https://github.com/bitcoin/bitcoin/pull/18279#issuecomment-595813866,595813866,
DrahtBot,2020-03-07 02:45:29,"<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #18338 (wip: Fix wallet unload race condition by promag)\n\nIf you consider this pull request important, please also help ",https://github.com/bitcoin/bitcoin/pull/18279#issuecomment-596037468,596037468,
bvbfan,2020-03-07 09:22:50,"@promag the problem is not the queued connection / disconnection, actually \n```\nvoid UnregisterValidationInterface(CValidationInterface* pwalletIn) {\n    if (g_signals.m_internals) {\n        g_signals.m_internals->m_connMainSignals.erase(pwalletIn);\n    }\n}\n```\nsignal is received before disconnect is called by erasing the caller.\n\nFix unit test and rebase.",https://github.com/bitcoin/bitcoin/pull/18279#issuecomment-596066452,596066452,
bvbfan,2020-03-07 10:47:18,"Let's clarify a bit more.\n```\nvoid disconnect() override\n{\n    if (m_notifications) {\n        m_notifications = nullptr; // <---------------- it makes no sense to be before unregister\n        UnregisterValidationInterface(this);\n    }\n}\n```\nSince `ValidationInterfaceConnections` calls destructors in reverse order, for a bad luck `UpdatedBlockTip` is disconnected last which is n",https://github.com/bitcoin/bitcoin/pull/18279#issuecomment-596074276,596074276,
bvbfan,2020-03-10 13:06:08,"> while holding wallet lock and then test handler still exists in BlockConnected/BlockDisconnected\n\ni don't think that's right approach to me.",https://github.com/bitcoin/bitcoin/pull/18279#issuecomment-597074855,597074855,
bvbfan,2020-03-11 13:21:53,"@promag, @ryanofsky i have another, looking better to me, solution ensuring there is no background tasks, but i've not push since it's not well tested\n```\ndiff --git a/src/scheduler.cpp b/src/scheduler.cpp\nindex 7cb7754fd..17c26be74 100644\n--- a/src/scheduler.cpp\n+++ b/src/scheduler.cpp\n@@ -199,12 +199,16 @@ void SingleThreadedSchedulerClient::AddToProcessQueue(std::function<void ()> f",https://github.com/bitcoin/bitcoin/pull/18279#issuecomment-597629954,597629954,
ryanofsky,2020-03-11 14:10:15,"re: https://github.com/bitcoin/bitcoin/pull/18279#issuecomment-597629954\n\n> @promag, @ryanofsky i have another, looking better to me, solution ensuring there is no background tasks, but i've not push since it's not well tested\n\nThis fix is very similar to c3722190bc4f0efb76008dff16c6721ef0248856 from #18280, and probably we should review and merge #18280 when it's ready and close this PR.",https://github.com/bitcoin/bitcoin/pull/18279#issuecomment-597656698,597656698,
bvbfan,2020-03-11 14:22:57,"> This fix is very similar to c372219 from #18280, and probably we should review and merge #18280 when it's ready and close this PR.\n\nStill no to me, changes in BlockUntilSyncedToCurrentChain are significant to me.",https://github.com/bitcoin/bitcoin/pull/18279#issuecomment-597663477,597663477,
bvbfan,2020-03-11 14:25:29,Also sync should be in `UnregisterValidationInterface` to be applied in all cases.,https://github.com/bitcoin/bitcoin/pull/18279#issuecomment-597664982,597664982,
ryanofsky,2020-03-11 15:02:55,"> Still no to me, changes in BlockUntilSyncedToCurrentChain are significant to me.\n\nOf course no need to close this PR if you want to make other improvements, but I hope you can review #18280 when it's ready as a fix for the original issue. Also would encourage closing this PR and opening a new one if the new version will differ substantially, so the review comment history will be intelligible",https://github.com/bitcoin/bitcoin/pull/18279#issuecomment-597686042,597686042,
bvbfan,2020-03-11 15:31:44,"> This is only true when unregistering wallets, as far as I know. Not things like indexes.\n\nNo, that's not correct to me,\n\n> Maybe m_notifications should be an atomic pointer too since m_notifications is get and set from different threads, though probably the synchronization done by boost signals & the scheduler prevents bugs from it not being atomic\n\ndoing in `UnregisterValidationInte",https://github.com/bitcoin/bitcoin/pull/18279#issuecomment-597701856,597701856,
promag,2020-03-11 16:01:41,"> No reason conceptually wallets should have to wait for events they don't care about just to fix a pointer lifetime issue\n\nAgree with this.\n\nFrom #18280:\n\n> From boost signal documentation at https://www.boost.org/doc/libs/1_72_0/doc/html/signals2/thread-safety.html:\n> \n> > When a signal is invoked by calling signal::operator(), the invocation first acquires a lock on the signal's",https://github.com/bitcoin/bitcoin/pull/18279#issuecomment-597719211,597719211,
MarcoFalke,2020-03-06 14:58:58,"Shouldn't this whole scope happen under the cs_wallet lock?\n\nAlso, shouldn't `m_chain_notifications_handler.reset()` happen inside here under the wallet lock?\n\nOtherwise a new block could come in and put new notifications in the handler while we reset it.",https://github.com/bitcoin/bitcoin/pull/18279#discussion_r388951184,388951184,src/wallet/wallet.cpp
bvbfan,2020-03-06 15:10:19,"> Shouldn't this whole scope happen under the cs_wallet lock?\n\nNo, we leave mutex for process thread to finish.\n> Also, shouldn't m_chain_notifications_handler.reset() happen inside here under the wallet lock?\n\nNo.\n> Otherwise a new block could come in and put new notifications in the handler while we reset it.\n\nI'm aware of that, we can have a function that takes a mutex and reset",https://github.com/bitcoin/bitcoin/pull/18279#discussion_r388957652,388957652,src/wallet/wallet.cpp
ryanofsky,2020-03-10 16:35:46,"This change seems clearly correct. Good catch! Maybe `m_notifications` should be an atomic pointer too since `m_notifications` is get and set from different threads, though probably the synchronization done by boost signals & the scheduler prevents bugs from it not being atomic",https://github.com/bitcoin/bitcoin/pull/18279#discussion_r390450804,390450804,src/interfaces/chain.cpp
ryanofsky,2020-03-10 16:39:54,"I like the name change, and I can see how the having the bool return value should make races and the deadlock reported https://github.com/bitcoin/bitcoin/issues/16307#issuecomment-595786198 less likely, though I suspect there is also probably a more direct and reliable fix we can find",https://github.com/bitcoin/bitcoin/pull/18279#discussion_r390453622,390453622,src/interfaces/chain.cpp
ryanofsky,2020-03-10 16:46:06,"Acquiring the cs_wallet lock here is unexpected. If this is really neccessary, I think the lock should be acquired closer to where it's used inside the Flush implementation, probably with a comment if the purpose of the lock isn't more obvious there",https://github.com/bitcoin/bitcoin/pull/18279#discussion_r390457946,390457946,src/wallet/wallet.cpp
bvbfan,2020-03-11 08:15:24,"> I think there is a misunderstanding here (maybe my own), but my understanding is that the point of BlockUntilSyncedToCurrentChain is just to ensure that if you make two RPC calls in a row the second RPC call is always aware of the result of first call. Ensuring that notification in the queue from the time of the call are processed is sufficient to do this, without trying to guarantee that the wa",https://github.com/bitcoin/bitcoin/pull/18279#discussion_r390802687,390802687,src/wallet/wallet.cpp
bvbfan,2020-03-11 08:17:07,"Here after BlockUntilSyncedToCurrentChain is ensuring it's on current tip, the lock tries to guarantee that notification thread is finished before we flush and release memory.",https://github.com/bitcoin/bitcoin/pull/18279#discussion_r390803411,390803411,src/wallet/wallet.cpp
bvbfan,2020-03-11 08:30:07,"> Maybe m_notifications should be an atomic pointer too since m_notifications is get and set from different threads, though probably the synchronization done by boost signals & the scheduler prevents bugs from it not being atomic\n\nYou're right",https://github.com/bitcoin/bitcoin/pull/18279#discussion_r390809490,390809490,src/interfaces/chain.cpp
