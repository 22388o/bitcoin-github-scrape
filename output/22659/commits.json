[
  {
    "sha": "002c960fe4980d51716dcad4a57e264599ca9138",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMDJjOTYwZmU0OTgwZDUxNzE2ZGNhZDRhNTdlMjY0NTk5Y2E5MTM4",
    "commit": {
      "author": {
        "name": "S3RK",
        "email": "1466284+S3RK@users.noreply.github.com",
        "date": "2021-08-04T08:02:09Z"
      },
      "committer": {
        "name": "S3RK",
        "email": "1466284+S3RK@users.noreply.github.com",
        "date": "2021-08-07T12:12:35Z"
      },
      "message": "WIP",
      "tree": {
        "sha": "67bc2410d93031c047d26ca44766fe67bca4a31a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/67bc2410d93031c047d26ca44766fe67bca4a31a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/002c960fe4980d51716dcad4a57e264599ca9138",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/002c960fe4980d51716dcad4a57e264599ca9138",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/002c960fe4980d51716dcad4a57e264599ca9138",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/002c960fe4980d51716dcad4a57e264599ca9138/comments",
    "author": {
      "login": "S3RK",
      "id": 1466284,
      "node_id": "MDQ6VXNlcjE0NjYyODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/S3RK",
      "html_url": "https://github.com/S3RK",
      "followers_url": "https://api.github.com/users/S3RK/followers",
      "following_url": "https://api.github.com/users/S3RK/following{/other_user}",
      "gists_url": "https://api.github.com/users/S3RK/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/S3RK/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
      "organizations_url": "https://api.github.com/users/S3RK/orgs",
      "repos_url": "https://api.github.com/users/S3RK/repos",
      "events_url": "https://api.github.com/users/S3RK/events{/privacy}",
      "received_events_url": "https://api.github.com/users/S3RK/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "S3RK",
      "id": 1466284,
      "node_id": "MDQ6VXNlcjE0NjYyODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/S3RK",
      "html_url": "https://github.com/S3RK",
      "followers_url": "https://api.github.com/users/S3RK/followers",
      "following_url": "https://api.github.com/users/S3RK/following{/other_user}",
      "gists_url": "https://api.github.com/users/S3RK/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/S3RK/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
      "organizations_url": "https://api.github.com/users/S3RK/orgs",
      "repos_url": "https://api.github.com/users/S3RK/repos",
      "events_url": "https://api.github.com/users/S3RK/events{/privacy}",
      "received_events_url": "https://api.github.com/users/S3RK/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1488f55fa57a1400a57be837b574183f019c7855",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1488f55fa57a1400a57be837b574183f019c7855",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1488f55fa57a1400a57be837b574183f019c7855"
      }
    ],
    "stats": {
      "total": 143,
      "additions": 131,
      "deletions": 12
    },
    "files": [
      {
        "sha": "1a1f0d2c6ec2fa358e6de1f6ec73cdd1716c0e1e",
        "filename": "src/wallet/scriptpubkeyman.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 4,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/002c960fe4980d51716dcad4a57e264599ca9138/src/wallet/scriptpubkeyman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/002c960fe4980d51716dcad4a57e264599ca9138/src/wallet/scriptpubkeyman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/scriptpubkeyman.cpp?ref=002c960fe4980d51716dcad4a57e264599ca9138",
        "patch": "@@ -354,15 +354,22 @@ bool LegacyScriptPubKeyMan::TopUpInactiveHDChain(const CKeyID seed_id, int64_t i\n     return true;\n }\n \n-void LegacyScriptPubKeyMan::MarkUnusedAddresses(const CScript& script)\n+used_destinations LegacyScriptPubKeyMan::MarkUnusedAddresses(const CScript& script)\n {\n     LOCK(cs_KeyStore);\n+    used_destinations result;\n     // extract addresses and check if they match with an unused keypool key\n     for (const auto& keyid : GetAffectedKeys(script, *this)) {\n         std::map<CKeyID, int64_t>::const_iterator mi = m_pool_key_to_index.find(keyid);\n         if (mi != m_pool_key_to_index.end()) {\n             WalletLogPrintf(\"%s: Detected a used keypool key, mark all keypool keys up to this key as used\\n\", __func__);\n-            MarkReserveKeysAsUsed(mi->second);\n+            const auto& keypools = MarkReserveKeysAsUsed(mi->second);\n+            for (const auto& keypool : keypools) {\n+                for (const auto &type: LEGACY_OUTPUT_TYPES) {\n+                    const auto &dest = GetDestinationForKey(keypool.vchPubKey, type);\n+                    result.push_back(std::make_pair(dest, keypool.fInternal));\n+                }\n+            }\n \n             if (!TopUp()) {\n                 WalletLogPrintf(\"%s: Topping up keypool failed (locked wallet)\\n\", __func__);\n@@ -384,6 +391,8 @@ void LegacyScriptPubKeyMan::MarkUnusedAddresses(const CScript& script)\n             }\n         }\n     }\n+\n+    return result;\n }\n \n void LegacyScriptPubKeyMan::UpgradeKeyMetadata()\n@@ -1427,14 +1436,15 @@ void LegacyScriptPubKeyMan::LearnAllRelatedScripts(const CPubKey& key)\n     LearnRelatedScripts(key, OutputType::P2SH_SEGWIT);\n }\n \n-void LegacyScriptPubKeyMan::MarkReserveKeysAsUsed(int64_t keypool_id)\n+std::vector<CKeyPool> LegacyScriptPubKeyMan::MarkReserveKeysAsUsed(int64_t keypool_id)\n {\n     AssertLockHeld(cs_KeyStore);\n     bool internal = setInternalKeyPool.count(keypool_id);\n     if (!internal) assert(setExternalKeyPool.count(keypool_id) || set_pre_split_keypool.count(keypool_id));\n     std::set<int64_t> *setKeyPool = internal ? &setInternalKeyPool : (set_pre_split_keypool.empty() ? &setExternalKeyPool : &set_pre_split_keypool);\n     auto it = setKeyPool->begin();\n \n+    std::vector<CKeyPool> result;\n     WalletBatch batch(m_storage.GetDatabase());\n     while (it != std::end(*setKeyPool)) {\n         const int64_t& index = *(it);\n@@ -1448,7 +1458,10 @@ void LegacyScriptPubKeyMan::MarkReserveKeysAsUsed(int64_t keypool_id)\n         batch.ErasePool(index);\n         WalletLogPrintf(\"keypool index %d removed\\n\", index);\n         it = setKeyPool->erase(it);\n+        result.push_back(keypool);\n     }\n+\n+    return result;\n }\n \n std::vector<CKeyID> GetAffectedKeys(const CScript& spk, const SigningProvider& provider)\n@@ -1820,11 +1833,23 @@ bool DescriptorScriptPubKeyMan::TopUp(unsigned int size)\n     return true;\n }\n \n-void DescriptorScriptPubKeyMan::MarkUnusedAddresses(const CScript& script)\n+used_destinations DescriptorScriptPubKeyMan::MarkUnusedAddresses(const CScript& script)\n {\n     LOCK(cs_desc_man);\n+    used_destinations result;\n     if (IsMine(script)) {\n         int32_t index = m_map_script_pub_keys[script];\n+        for (int i = m_wallet_descriptor.next_index; i <= index; i++) {\n+            std::unique_ptr<FlatSigningProvider> out_keys = std::make_unique<FlatSigningProvider>();\n+            std::vector<CScript> scripts_temp;\n+            if (!m_wallet_descriptor.descriptor->ExpandFromCache(i, m_wallet_descriptor.cache, scripts_temp, *out_keys)) {\n+                throw std::runtime_error(std::string(__func__) + \": something wrong happened\");\n+            }\n+            CTxDestination dest;\n+            ExtractDestination(scripts_temp[0], dest);\n+            result.push_back({dest, std::nullopt});\n+        }\n+\n         if (index >= m_wallet_descriptor.next_index) {\n             WalletLogPrintf(\"%s: Detected a used keypool item at index %d, mark all keypool items up to this item as used\\n\", __func__, index);\n             m_wallet_descriptor.next_index = index + 1;\n@@ -1833,6 +1858,8 @@ void DescriptorScriptPubKeyMan::MarkUnusedAddresses(const CScript& script)\n             WalletLogPrintf(\"%s: Topping up keypool failed (locked wallet)\\n\", __func__);\n         }\n     }\n+\n+    return result;\n }\n \n void DescriptorScriptPubKeyMan::AddDescriptorKey(const CKey& key, const CPubKey &pubkey)"
      },
      {
        "sha": "9f13a9729c0c05dcfdee6fa348b04198d9882719",
        "filename": "src/wallet/scriptpubkeyman.h",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/002c960fe4980d51716dcad4a57e264599ca9138/src/wallet/scriptpubkeyman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/002c960fe4980d51716dcad4a57e264599ca9138/src/wallet/scriptpubkeyman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/scriptpubkeyman.h?ref=002c960fe4980d51716dcad4a57e264599ca9138",
        "patch": "@@ -159,6 +159,8 @@ class KeyIDHasher\n     }\n };\n \n+using used_destinations = std::vector<std::pair<CTxDestination, std::optional<bool>>>;\n+\n /*\n  * A class implementing ScriptPubKeyMan manages some (or all) scriptPubKeys used in a wallet.\n  * It contains the scripts and keys related to the scriptPubKeys it manages.\n@@ -192,7 +194,7 @@ class ScriptPubKeyMan\n     virtual bool TopUp(unsigned int size = 0) { return false; }\n \n     //! Mark unused addresses as being used\n-    virtual void MarkUnusedAddresses(const CScript& script) {}\n+    virtual used_destinations MarkUnusedAddresses(const CScript& script) { return {}; }\n \n     /** Sets up the key generation stuff, i.e. generates new HD seeds and sets them as active.\n       * Returns false if already setup or setup fails, true if setup is successful\n@@ -367,7 +369,7 @@ class LegacyScriptPubKeyMan : public ScriptPubKeyMan, public FillableSigningProv\n \n     bool TopUp(unsigned int size = 0) override;\n \n-    void MarkUnusedAddresses(const CScript& script) override;\n+    used_destinations MarkUnusedAddresses(const CScript& script) override;\n \n     //! Upgrade stored CKeyMetadata objects to store key origin info as KeyOriginInfo\n     void UpgradeKeyMetadata();\n@@ -494,7 +496,7 @@ class LegacyScriptPubKeyMan : public ScriptPubKeyMan, public FillableSigningProv\n     /**\n      * Marks all keys in the keypool up to and including reserve_key as used.\n      */\n-    void MarkReserveKeysAsUsed(int64_t keypool_id) EXCLUSIVE_LOCKS_REQUIRED(cs_KeyStore);\n+    std::vector<CKeyPool> MarkReserveKeysAsUsed(int64_t keypool_id) EXCLUSIVE_LOCKS_REQUIRED(cs_KeyStore);\n     const std::map<CKeyID, int64_t>& GetAllReserveKeys() const { return m_pool_key_to_index; }\n \n     std::set<CKeyID> GetKeys() const override;\n@@ -574,7 +576,7 @@ class DescriptorScriptPubKeyMan : public ScriptPubKeyMan\n     // (with or without private keys), the \"keypool\" is a single xpub.\n     bool TopUp(unsigned int size = 0) override;\n \n-    void MarkUnusedAddresses(const CScript& script) override;\n+    used_destinations MarkUnusedAddresses(const CScript& script) override;\n \n     bool IsHDEnabled() const override;\n "
      },
      {
        "sha": "aa7a7c2b154db8548de8ddf75a33804a13266fb6",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 2,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/002c960fe4980d51716dcad4a57e264599ca9138/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/002c960fe4980d51716dcad4a57e264599ca9138/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=002c960fe4980d51716dcad4a57e264599ca9138",
        "patch": "@@ -906,7 +906,9 @@ CWalletTx* CWallet::AddToWallet(CTransactionRef tx, const CWalletTx::Confirmatio\n         wtx.nOrderPos = IncOrderPosNext(&batch);\n         wtx.m_it_wtxOrdered = wtxOrdered.insert(std::make_pair(wtx.nOrderPos, &wtx));\n         wtx.nTimeSmart = ComputeTimeSmart(wtx);\n-        AddToSpends(hash);\n+        if (IsFromMe(*tx.get())) {\n+            AddToSpends(hash);\n+        }\n     }\n \n     if (!fInsertedNew)\n@@ -1053,8 +1055,26 @@ bool CWallet::AddToWalletIfInvolvingMe(const CTransactionRef& ptx, CWalletTx::Co\n \n             // loop though all outputs\n             for (const CTxOut& txout: tx.vout) {\n+                // TODO: use GetScriptPubKeyMan(CScript)\n                 for (const auto& spk_man_pair : m_spk_managers) {\n-                    spk_man_pair.second->MarkUnusedAddresses(txout.scriptPubKey);\n+                    const auto& destinations = spk_man_pair.second->MarkUnusedAddresses(txout.scriptPubKey);\n+                    for (const auto& dest : destinations) {\n+                        auto internal = dest.second;\n+                        auto desc_spk_man = dynamic_cast<DescriptorScriptPubKeyMan*>(spk_man_pair.second.get());\n+                        if (desc_spk_man) {\n+                            LOCK(desc_spk_man->cs_desc_man);\n+                            const auto& type = desc_spk_man->GetWalletDescriptor().descriptor->GetOutputType();\n+                            // e.g. combo descriptors don't have output type and are never active\n+                            if (type.has_value()) {\n+                                const auto &active_internal = GetScriptPubKeyMan(type.value(), /* internal= */true);\n+                                internal = desc_spk_man == active_internal;\n+                            }\n+                        }\n+\n+                        if (internal.has_value() && !internal.value() && !FindAddressBookEntry(dest.first, /* allow_change= */ false)) {\n+                            SetAddressBook(dest.first, \"\", \"receive\");\n+                        }\n+                    }\n                 }\n             }\n "
      },
      {
        "sha": "ecddbe9f82dfa3c552b56e0cdc5f27f7bbbcd13a",
        "filename": "test/functional/wallet_listtransactions.py",
        "status": "modified",
        "additions": 72,
        "deletions": 2,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/002c960fe4980d51716dcad4a57e264599ca9138/test/functional/wallet_listtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/002c960fe4980d51716dcad4a57e264599ca9138/test/functional/wallet_listtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_listtransactions.py?ref=002c960fe4980d51716dcad4a57e264599ca9138",
        "patch": "@@ -3,6 +3,10 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the listtransactions API.\"\"\"\n+\n+import shutil\n+import os\n+\n from decimal import Decimal\n \n from test_framework.messages import (\n@@ -17,14 +21,80 @@\n \n class ListTransactionsTest(BitcoinTestFramework):\n     def set_test_params(self):\n-        self.num_nodes = 2\n+        self.num_nodes = 3\n+\n+        self.extra_args = [[\"-whitelist=noban@127.0.0.1\"]] * self.num_nodes\n \n     def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()\n \n     def run_test(self):\n-        self.nodes[0].generate(1)  # Get out of IBD\n+        # self.nodes[0].generate(1)  # Get out of IBD\n+        # self.sync_all()\n+\n+        self.nodes[0].keypoolrefill(1000)\n+        # print(self.nodes[0].getwalletinfo())\n+        self.stop_nodes()\n+        wallet0 = os.path.join(self.nodes[0].datadir, self.chain, self.default_wallet_name, \"wallet.dat\")\n+        wallet2 = os.path.join(self.nodes[2].datadir, self.chain, self.default_wallet_name, \"wallet.dat\")\n+        shutil.copyfile(wallet0, wallet2)\n+        self.start_nodes()\n+        self.connect_nodes(0, 1)\n+        self.connect_nodes(0, 2)\n+        self.connect_nodes(1, 2)\n+\n+        addr1 = self.nodes[0].getnewaddress(\"pizza1\", 'legacy')\n+        addr2 = self.nodes[0].getnewaddress(\"pizza2\", 'p2sh-segwit')\n+        addr3 = self.nodes[0].getnewaddress(\"pizza3\", 'bech32')\n+\n+        self.log.info(\"Send to externally generated address\")\n+        txid = self.nodes[1].sendtoaddress(addr3, \"0.001\")\n+        self.nodes[1].generate(1)\n         self.sync_all()\n+\n+        self.log.info(\"the tx in question from node0\")\n+        for tx in self.nodes[0].listtransactions():\n+            if tx['address'] == addr3:\n+                print(tx)\n+\n+        self.log.info(\"the tx in question from node2\")\n+        for tx in self.nodes[2].listtransactions():\n+            if tx['address'] == addr3:\n+                print(tx)\n+\n+        # self.log.info(\"nodes[2].gettransaction(txid)\")\n+        # tx = self.nodes[2].gettransaction(txid)\n+        # print(tx)\n+\n+        self.log.info(\"Send to p2sh-segwit\")\n+        self.nodes[1].sendtoaddress(addr2, \"0.001\")\n+        self.nodes[1].generate(1)\n+        self.sync_all()\n+\n+        self.log.info(\"Send to self\")\n+        self.nodes[0].sendtoaddress(addr1, \"0.001\")\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        self.log.info(\"Compare listtransactions is the same on node0 and node2 (except labels)\")\n+        def getTxId(e):\n+            return e['txid']\n+\n+        transactions0 = self.nodes[0].listtransactions()\n+        [x.pop('label', None) for x in transactions0]\n+        transactions0.sort(key=getTxId)\n+        transactions2 = self.nodes[2].listtransactions()\n+        [x.pop('label', None) for x in transactions2]\n+        transactions2.sort(key=getTxId)\n+        assert_equal(transactions0, transactions2)\n+\n+        self.log.info(\"verify labels: \")\n+        assert_equal(['pizza1'], self.nodes[0].getaddressinfo(addr1)['labels'])\n+        assert_equal(['pizza2'], self.nodes[0].getaddressinfo(addr2)['labels'])\n+        assert_equal(['pizza3'], self.nodes[0].getaddressinfo(addr3)['labels'])\n+\n+        return\n+\n         # Simple send, 0 to 1:\n         txid = self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 0.1)\n         self.sync_all()"
      }
    ]
  }
]