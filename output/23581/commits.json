[
  {
    "sha": "fa6a0f9a7c00015e70c9805faf45685ac300f61e",
    "node_id": "C_kwDOABII59oAKGZhNmEwZjlhN2MwMDAxNWU3MGM5ODA1ZmFmNDU2ODVhYzMwMGY2MWU",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-11-23T17:01:51Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-11-25T11:30:07Z"
      },
      "message": "Remove GetSpendHeight\n\nIt is unclear what the goal of the helper is, as the caller already\nknows the spend height before calling the helper.\n\nAlso, in case the coins view is corrupted, LookupBlockIndex will return\nnullptr. Dereferencing a nullptr is UB.\n\nFix both issues by removing it. Also, add a sanity check, which aborts\nif the coins view is corrupted.",
      "tree": {
        "sha": "50d45a2b2e9def40490f9444ea5b600d17fcb15e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/50d45a2b2e9def40490f9444ea5b600d17fcb15e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa6a0f9a7c00015e70c9805faf45685ac300f61e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUj0aAwAs7LVXMR5vHYXM1VaqxpyVkFSCRGfeQ1MvaiS2l8D9ZYkr84v3h0zUUD3\nDy4n/GpIVpYQPT7BDZ72uP8LcUyYLHtBiCcH5thapZ0GeizdnBpBuISyegqNP7Lq\njBbYf3kYeLuczFcCluFi0rNjrWMpKNFKdxtMLVZtJSnp74g1UkpGly6F2snGAULw\nQvQtpLZMkHicXGppxwqq7M4+IJ4j7pFM6yruYhzSvpISkJlshOOZow2o3SfnkI/q\nYoCutYTXytQ4jlI5b8wJKTeiWcJmJktaewfaAGiHNCtN21xWE8/cvXrM8Bgwrgny\nNVN7dfdgd4LZSZakzWh/gv7BOE+qfeBeG6hxUyJ3w0KU+VrfoDS5poGgVL/9++VL\nd1JCwnto178PMCzmRI5C1hpkzG88WZ4rxZCRqWjWmxEnfTvTjJJD/pHB3xHFhOxm\nXo8OUQVytwYtpboyVS83aU0xuesN0BqFtA4IpD8HJ/mD21qxSs+MzsxRTg/JDrqq\n3swIC7F+\n=PvyV\n-----END PGP SIGNATURE-----",
        "payload": "tree 50d45a2b2e9def40490f9444ea5b600d17fcb15e\nparent 76392b042e98fcdb3b7ce3c2023003910326d14e\nauthor MarcoFalke <falke.marco@gmail.com> 1637686911 +0100\ncommitter MarcoFalke <falke.marco@gmail.com> 1637839807 +0100\n\nRemove GetSpendHeight\n\nIt is unclear what the goal of the helper is, as the caller already\nknows the spend height before calling the helper.\n\nAlso, in case the coins view is corrupted, LookupBlockIndex will return\nnullptr. Dereferencing a nullptr is UB.\n\nFix both issues by removing it. Also, add a sanity check, which aborts\nif the coins view is corrupted.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa6a0f9a7c00015e70c9805faf45685ac300f61e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa6a0f9a7c00015e70c9805faf45685ac300f61e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa6a0f9a7c00015e70c9805faf45685ac300f61e/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "76392b042e98fcdb3b7ce3c2023003910326d14e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/76392b042e98fcdb3b7ce3c2023003910326d14e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/76392b042e98fcdb3b7ce3c2023003910326d14e"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 3,
      "deletions": 16
    },
    "files": [
      {
        "sha": "895d97cf1561c6b5a0b56428dce3cad288defe34",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 9,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa6a0f9a7c00015e70c9805faf45685ac300f61e/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa6a0f9a7c00015e70c9805faf45685ac300f61e/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=fa6a0f9a7c00015e70c9805faf45685ac300f61e",
        "patch": "@@ -710,6 +710,8 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     // to coins_to_uncache)\n     m_view.SetBackend(m_dummy);\n \n+    assert(m_active_chainstate.m_blockman.LookupBlockIndex(m_view.GetBestBlock()) == m_active_chainstate.m_chain.Tip());\n+\n     // Only accept BIP68 sequence locked transactions that can be mined in the next\n     // block; we don't want our mempool filled up with transactions that can't\n     // be mined yet.\n@@ -718,7 +720,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     if (!CheckSequenceLocks(m_active_chainstate.m_chain.Tip(), m_view, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n         return state.Invalid(TxValidationResult::TX_PREMATURE_SPEND, \"non-BIP68-final\");\n \n-    if (!Consensus::CheckTxInputs(tx, state, m_view, m_active_chainstate.m_blockman.GetSpendHeight(m_view), ws.m_base_fees)) {\n+    if (!Consensus::CheckTxInputs(tx, state, m_view, m_active_chainstate.m_chain.Height() + 1, ws.m_base_fees)) {\n         return false; // state filled in by CheckTxInputs\n     }\n \n@@ -1306,14 +1308,6 @@ bool CScriptCheck::operator()() {\n     return VerifyScript(scriptSig, m_tx_out.scriptPubKey, witness, nFlags, CachingTransactionSignatureChecker(ptxTo, nIn, m_tx_out.nValue, cacheStore, *txdata), &error);\n }\n \n-int BlockManager::GetSpendHeight(const CCoinsViewCache& inputs)\n-{\n-    AssertLockHeld(cs_main);\n-    CBlockIndex* pindexPrev = LookupBlockIndex(inputs.GetBestBlock());\n-    return pindexPrev->nHeight + 1;\n-}\n-\n-\n static CuckooCache::cache<uint256, SignatureCacheHasher> g_scriptExecutionCache;\n static CSHA256 g_scriptExecutionCacheHasher;\n "
      },
      {
        "sha": "af84092b57d6fd66b06481a30d35888d43035d66",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 0,
        "deletions": 7,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa6a0f9a7c00015e70c9805faf45685ac300f61e/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa6a0f9a7c00015e70c9805faf45685ac300f61e/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=fa6a0f9a7c00015e70c9805faf45685ac300f61e",
        "patch": "@@ -479,13 +479,6 @@ class BlockManager\n     //! Returns last CBlockIndex* that is a checkpoint\n     CBlockIndex* GetLastCheckpoint(const CCheckpointData& data) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n-    /**\n-     * Return the spend height, which is one more than the inputs.GetBestBlock().\n-     * While checking, GetBestBlock() refers to the parent block. (protected by cs_main)\n-     * This is also true for mempool checks.\n-     */\n-    int GetSpendHeight(const CCoinsViewCache& inputs) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-\n     ~BlockManager() {\n         Unload();\n     }"
      }
    ]
  },
  {
    "sha": "fa28ba090d25ec421cf60b088124568fe7e90950",
    "node_id": "C_kwDOABII59oAKGZhMjhiYTA5MGQyNWVjNDIxY2Y2MGIwODgxMjQ1NjhmZTdlOTA5NTA",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-11-23T16:42:36Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-11-25T11:31:56Z"
      },
      "message": "Move FindForkInGlobalIndex from BlockManager to CChainState\n\nThe helper was moved in commit b026e318c39f59a06e29f1b25c7f577e01b25ccb,\nwhich also mentioned that it could be moved to CChainState. So do that,\nas the functionality is not block-storage related.\n\nThis also allows to drop one function argument.",
      "tree": {
        "sha": "b45f263e08f2db54a15f50225aba75b5b42ccb4d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b45f263e08f2db54a15f50225aba75b5b42ccb4d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa28ba090d25ec421cf60b088124568fe7e90950",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUh6dQv/YNeo6Avb/lVy9RrWGkdQjIXFi1EmBBO+iZW5QVS7ARBxNmjSNwHSxP2g\n6UBTq4+PfPVfs/1ygXhUSofMhqRQr4SiUyYYLXSj1yAfpVtvapHjem79VfS+Rj8S\nmVVpLvSpWB2NSRq+XIpkJkJdj3dubop3dugT0W4Js1fUWBcOvg3DVcJRfX0w86lG\nicMTKH1RKaR1jSIqouoJBiX4AQGNzmKrvQ9XrDZV5I9PYMXeb5nnlBaK+bzQ0xY2\nzPSKHAq9Uapt5xTA/gFrbD8OFjzwiDtl7mxVwZGf874v2UqRInr8NSG49TM5+/MI\nYtHkM3ryQnEL+dD5rC1eBo68L6SVNN6Zk0kmC9mBPJQtOKdXmNH5oLo0dNy4wizn\n3nViN1SKA77LvAhQw2vmQWyrsIz2UGGuoFLeTxFf1hjBAs16TgKncAMvW+Sb6q8v\nLMIsXD9f2nvP8k5sXS1zVTcMwQ0vtuYm68ibNFWnGrEcQwbkbmqVvz6lVAC4ac40\nwngzIzWY\n=/FsT\n-----END PGP SIGNATURE-----",
        "payload": "tree b45f263e08f2db54a15f50225aba75b5b42ccb4d\nparent fa6a0f9a7c00015e70c9805faf45685ac300f61e\nauthor MarcoFalke <falke.marco@gmail.com> 1637685756 +0100\ncommitter MarcoFalke <falke.marco@gmail.com> 1637839916 +0100\n\nMove FindForkInGlobalIndex from BlockManager to CChainState\n\nThe helper was moved in commit b026e318c39f59a06e29f1b25c7f577e01b25ccb,\nwhich also mentioned that it could be moved to CChainState. So do that,\nas the functionality is not block-storage related.\n\nThis also allows to drop one function argument.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa28ba090d25ec421cf60b088124568fe7e90950",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa28ba090d25ec421cf60b088124568fe7e90950",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa28ba090d25ec421cf60b088124568fe7e90950/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fa6a0f9a7c00015e70c9805faf45685ac300f61e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa6a0f9a7c00015e70c9805faf45685ac300f61e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fa6a0f9a7c00015e70c9805faf45685ac300f61e"
      }
    ],
    "stats": {
      "total": 29,
      "additions": 15,
      "deletions": 14
    },
    "files": [
      {
        "sha": "a6ebd53596d871d6ed74d176e4e0c61260da39be",
        "filename": "src/index/base.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa28ba090d25ec421cf60b088124568fe7e90950/src/index/base.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa28ba090d25ec421cf60b088124568fe7e90950/src/index/base.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/base.cpp?ref=fa28ba090d25ec421cf60b088124568fe7e90950",
        "patch": "@@ -65,7 +65,7 @@ bool BaseIndex::Init()\n     if (locator.IsNull()) {\n         m_best_block_index = nullptr;\n     } else {\n-        m_best_block_index = m_chainstate->m_blockman.FindForkInGlobalIndex(active_chain, locator);\n+        m_best_block_index = m_chainstate->FindForkInGlobalIndex(locator);\n     }\n     m_synced = m_best_block_index.load() == active_chain.Tip();\n     if (!m_synced) {"
      },
      {
        "sha": "03c183939afff39d002c91efcf11d67200605c82",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa28ba090d25ec421cf60b088124568fe7e90950/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa28ba090d25ec421cf60b088124568fe7e90950/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=fa28ba090d25ec421cf60b088124568fe7e90950",
        "patch": "@@ -3043,7 +3043,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         LOCK(cs_main);\n \n         // Find the last block the caller has in the main chain\n-        const CBlockIndex* pindex = m_chainman.m_blockman.FindForkInGlobalIndex(m_chainman.ActiveChain(), locator);\n+        const CBlockIndex* pindex = m_chainman.ActiveChainstate().FindForkInGlobalIndex(locator);\n \n         // Send the rest of the chain\n         if (pindex)\n@@ -3163,7 +3163,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         else\n         {\n             // Find the last block the caller has in the main chain\n-            pindex = m_chainman.m_blockman.FindForkInGlobalIndex(m_chainman.ActiveChain(), locator);\n+            pindex = m_chainman.ActiveChainstate().FindForkInGlobalIndex(locator);\n             if (pindex)\n                 pindex = m_chainman.ActiveChain().Next(pindex);\n         }"
      },
      {
        "sha": "1e5001810a33874e33db7bb1f62467d0c517158a",
        "filename": "src/node/interfaces.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa28ba090d25ec421cf60b088124568fe7e90950/src/node/interfaces.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa28ba090d25ec421cf60b088124568fe7e90950/src/node/interfaces.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/interfaces.cpp?ref=fa28ba090d25ec421cf60b088124568fe7e90950",
        "patch": "@@ -494,8 +494,8 @@ class ChainImpl : public Chain\n     std::optional<int> findLocatorFork(const CBlockLocator& locator) override\n     {\n         LOCK(cs_main);\n-        const CChain& active = Assert(m_node.chainman)->ActiveChain();\n-        if (CBlockIndex* fork = m_node.chainman->m_blockman.FindForkInGlobalIndex(active, locator)) {\n+        const CChainState& active = Assert(m_node.chainman)->ActiveChainstate();\n+        if (CBlockIndex* fork = active.FindForkInGlobalIndex(locator)) {\n             return fork->nHeight;\n         }\n         return std::nullopt;"
      },
      {
        "sha": "227333010f6336d5446d718fbaedd3f2810a8245",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 6,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa28ba090d25ec421cf60b088124568fe7e90950/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa28ba090d25ec421cf60b088124568fe7e90950/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=fa28ba090d25ec421cf60b088124568fe7e90950",
        "patch": "@@ -154,23 +154,24 @@ CBlockIndex* BlockManager::LookupBlockIndex(const uint256& hash) const\n     return it == m_block_index.end() ? nullptr : it->second;\n }\n \n-CBlockIndex* BlockManager::FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator)\n+CBlockIndex* CChainState::FindForkInGlobalIndex(const CBlockLocator& locator) const\n {\n     AssertLockHeld(cs_main);\n \n     // Find the latest block common to locator and chain - we expect that\n     // locator.vHave is sorted descending by height.\n     for (const uint256& hash : locator.vHave) {\n-        CBlockIndex* pindex = LookupBlockIndex(hash);\n+        CBlockIndex* pindex{m_blockman.LookupBlockIndex(hash)};\n         if (pindex) {\n-            if (chain.Contains(pindex))\n+            if (m_chain.Contains(pindex)) {\n                 return pindex;\n-            if (pindex->GetAncestor(chain.Height()) == chain.Tip()) {\n-                return chain.Tip();\n+            }\n+            if (pindex->GetAncestor(m_chain.Height()) == m_chain.Tip()) {\n+                return m_chain.Tip();\n             }\n         }\n     }\n-    return chain.Genesis();\n+    return m_chain.Genesis();\n }\n \n bool CheckInputScripts(const CTransaction& tx, TxValidationState& state,"
      },
      {
        "sha": "a99b0fb4850d090a5ecae272856430f63d9323d2",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa28ba090d25ec421cf60b088124568fe7e90950/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa28ba090d25ec421cf60b088124568fe7e90950/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=fa28ba090d25ec421cf60b088124568fe7e90950",
        "patch": "@@ -473,9 +473,6 @@ class BlockManager\n \n     CBlockIndex* LookupBlockIndex(const uint256& hash) const EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n-    /** Find the last common block between the parameter chain and a locator. */\n-    CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-\n     //! Returns last CBlockIndex* that is a checkpoint\n     CBlockIndex* GetLastCheckpoint(const CCheckpointData& data) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n@@ -751,6 +748,9 @@ class CChainState\n     /** Check whether we are doing an initial block download (synchronizing from disk or network) */\n     bool IsInitialBlockDownload() const;\n \n+    /** Find the last common block of this chain and a locator. */\n+    CBlockIndex* FindForkInGlobalIndex(const CBlockLocator& locator) const EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n     /**\n      * Make various assertions about the state of the block index.\n      *"
      }
    ]
  },
  {
    "sha": "66662a0ad4c1ad3323ac869f6959e4d246add7bb",
    "node_id": "C_kwDOABII59oAKDY2NjYyYTBhZDRjMWFkMzMyM2FjODY5ZjY5NTllNGQyNDZhZGQ3YmI",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-11-23T18:34:51Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-11-25T11:32:02Z"
      },
      "message": "Move AcceptBlockHeader to ChainstateManager\n\nThis is needed for the next commit.",
      "tree": {
        "sha": "a94ee37ba6fac0f7e2778e54738bff1ff2051071",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a94ee37ba6fac0f7e2778e54738bff1ff2051071"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/66662a0ad4c1ad3323ac869f6959e4d246add7bb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUjTQwwAgISwL2icrYtrH4VymmzMKXTVhx0+pR4XPocXesKSXEqm04WHbBulftxX\nyBdWvEIfcKJOP8+pJQaiG7dMxnGh18sXOjbGjH9ZgM7eulErIuaJM6wKwsJn16uH\nSgSuAnstbR7uW8quukeNWCVE/HKQPGpQP8Vn+mA7duseEnQov9LRIDj6YYSTfahy\nCVSsRhI2KPy86P3kSchghndh/PfSxsrUGNNbozEphS1tubt8J8s2POCBJbWzVCsO\nnTLCGOfd7QvH4xmc0rvc/LuPGlSnjwxb3Z3WePIrH9rAq9JlWlfZs6LLdYKnWRo/\nOTZDtqLvXJ+/0i8NRPiqJlihuyOcCTWOYvqY2ESGCZN4sTUPrrZCQhqfrLmQmwKk\nEh6vVyLevv1B94+FAddwZbGEMPh0iJp5PUD91TYp9p43ee4RLphdO/SoQ8XpLUtc\n/x0ejpgfrZFY0uQisshEfTkZCAZf6OGTPn+oWvMB/qKezJiCGE0XXzsFZFB/9tsg\nEn9glaOC\n=ouqh\n-----END PGP SIGNATURE-----",
        "payload": "tree a94ee37ba6fac0f7e2778e54738bff1ff2051071\nparent fa28ba090d25ec421cf60b088124568fe7e90950\nauthor MarcoFalke <falke.marco@gmail.com> 1637692491 +0100\ncommitter MarcoFalke <falke.marco@gmail.com> 1637839922 +0100\n\nMove AcceptBlockHeader to ChainstateManager\n\nThis is needed for the next commit.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/66662a0ad4c1ad3323ac869f6959e4d246add7bb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/66662a0ad4c1ad3323ac869f6959e4d246add7bb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/66662a0ad4c1ad3323ac869f6959e4d246add7bb/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fa28ba090d25ec421cf60b088124568fe7e90950",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa28ba090d25ec421cf60b088124568fe7e90950",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fa28ba090d25ec421cf60b088124568fe7e90950"
      }
    ],
    "stats": {
      "total": 42,
      "additions": 21,
      "deletions": 21
    },
    "files": [
      {
        "sha": "275ba70401e0d939735a0bbcad776afe3e7e3f31",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 11,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/66662a0ad4c1ad3323ac869f6959e4d246add7bb/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/66662a0ad4c1ad3323ac869f6959e4d246add7bb/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=66662a0ad4c1ad3323ac869f6959e4d246add7bb",
        "patch": "@@ -3242,14 +3242,14 @@ static bool ContextualCheckBlock(const CBlock& block, BlockValidationState& stat\n     return true;\n }\n \n-bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, BlockValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex)\n+bool ChainstateManager::AcceptBlockHeader(const CBlockHeader& block, BlockValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex)\n {\n     AssertLockHeld(cs_main);\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n-    BlockMap::iterator miSelf = m_block_index.find(hash);\n+    BlockMap::iterator miSelf{m_blockman.m_block_index.find(hash)};\n     if (hash != chainparams.GetConsensus().hashGenesisBlock) {\n-        if (miSelf != m_block_index.end()) {\n+        if (miSelf != m_blockman.m_block_index.end()) {\n             // Block header is already known.\n             CBlockIndex* pindex = miSelf->second;\n             if (ppindex)\n@@ -3268,8 +3268,8 @@ bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, BlockValidationS\n \n         // Get prev block index\n         CBlockIndex* pindexPrev = nullptr;\n-        BlockMap::iterator mi = m_block_index.find(block.hashPrevBlock);\n-        if (mi == m_block_index.end()) {\n+        BlockMap::iterator mi{m_blockman.m_block_index.find(block.hashPrevBlock)};\n+        if (mi == m_blockman.m_block_index.end()) {\n             LogPrint(BCLog::VALIDATION, \"%s: %s prev block not found\\n\", __func__, hash.ToString());\n             return state.Invalid(BlockValidationResult::BLOCK_MISSING_PREV, \"prev-blk-not-found\");\n         }\n@@ -3278,7 +3278,7 @@ bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, BlockValidationS\n             LogPrint(BCLog::VALIDATION, \"%s: %s prev block invalid\\n\", __func__, hash.ToString());\n             return state.Invalid(BlockValidationResult::BLOCK_INVALID_PREV, \"bad-prevblk\");\n         }\n-        if (!ContextualCheckBlockHeader(block, state, *this, chainparams, pindexPrev, GetAdjustedTime())) {\n+        if (!ContextualCheckBlockHeader(block, state, m_blockman, chainparams, pindexPrev, GetAdjustedTime())) {\n             LogPrint(BCLog::VALIDATION, \"%s: Consensus::ContextualCheckBlockHeader: %s, %s\\n\", __func__, hash.ToString(), state.ToString());\n             return false;\n         }\n@@ -3307,7 +3307,7 @@ bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, BlockValidationS\n             // hasn't been validated up to BLOCK_VALID_SCRIPTS. This is a performance\n             // optimization, in the common case of adding a new block to the tip,\n             // we don't need to iterate over the failed blocks list.\n-            for (const CBlockIndex* failedit : m_failed_blocks) {\n+            for (const CBlockIndex* failedit : m_blockman.m_failed_blocks) {\n                 if (pindexPrev->GetAncestor(failedit->nHeight) == failedit) {\n                     assert(failedit->nStatus & BLOCK_FAILED_VALID);\n                     CBlockIndex* invalid_walk = pindexPrev;\n@@ -3322,7 +3322,7 @@ bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, BlockValidationS\n             }\n         }\n     }\n-    CBlockIndex* pindex = AddToBlockIndex(block);\n+    CBlockIndex* pindex{m_blockman.AddToBlockIndex(block)};\n \n     if (ppindex)\n         *ppindex = pindex;\n@@ -3338,8 +3338,7 @@ bool ChainstateManager::ProcessNewBlockHeaders(const std::vector<CBlockHeader>&\n         LOCK(cs_main);\n         for (const CBlockHeader& header : headers) {\n             CBlockIndex *pindex = nullptr; // Use a temp pindex instead of ppindex to avoid a const_cast\n-            bool accepted = m_blockman.AcceptBlockHeader(\n-                header, state, chainparams, &pindex);\n+            bool accepted{AcceptBlockHeader(header, state, chainparams, &pindex)};\n             ActiveChainstate().CheckBlockIndex();\n \n             if (!accepted) {\n@@ -3369,7 +3368,7 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, Block\n     CBlockIndex *pindexDummy = nullptr;\n     CBlockIndex *&pindex = ppindex ? *ppindex : pindexDummy;\n \n-    bool accepted_header = m_blockman.AcceptBlockHeader(block, state, m_params, &pindex);\n+    bool accepted_header{m_chainman.AcceptBlockHeader(block, state, m_params, &pindex)};\n     CheckBlockIndex();\n \n     if (!accepted_header)"
      },
      {
        "sha": "fd60ff7e7f26a9584ec34983885d553d0e22ece8",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 11,
        "deletions": 10,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/66662a0ad4c1ad3323ac869f6959e4d246add7bb/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/66662a0ad4c1ad3323ac869f6959e4d246add7bb/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=66662a0ad4c1ad3323ac869f6959e4d246add7bb",
        "patch": "@@ -461,16 +461,6 @@ class BlockManager\n     //! Mark one block file as pruned (modify associated database entries)\n     void PruneOneBlockFile(const int fileNumber) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n-    /**\n-     * If a block header hasn't already been seen, call CheckBlockHeader on it, ensure\n-     * that it doesn't descend from an invalid block, and then add it to m_block_index.\n-     */\n-    bool AcceptBlockHeader(\n-        const CBlockHeader& block,\n-        BlockValidationState& state,\n-        const CChainParams& chainparams,\n-        CBlockIndex** ppindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-\n     CBlockIndex* LookupBlockIndex(const uint256& hash) const EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     //! Returns last CBlockIndex* that is a checkpoint\n@@ -897,6 +887,17 @@ class ChainstateManager\n         CAutoFile& coins_file,\n         const SnapshotMetadata& metadata);\n \n+    /**\n+     * If a block header hasn't already been seen, call CheckBlockHeader on it, ensure\n+     * that it doesn't descend from an invalid block, and then add it to m_block_index.\n+     */\n+    bool AcceptBlockHeader(\n+        const CBlockHeader& block,\n+        BlockValidationState& state,\n+        const CChainParams& chainparams,\n+        CBlockIndex** ppindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    friend CChainState;\n+\n public:\n     std::thread m_load_block;\n     //! A single BlockManager instance is shared across each constructed"
      }
    ]
  },
  {
    "sha": "7777930a19ae424315a60b1df601409a63ecff25",
    "node_id": "C_kwDOABII59oAKDc3Nzc5MzBhMTlhZTQyNDMxNWE2MGIxZGY2MDE0MDlhNjNlY2ZmMjU",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-11-23T18:37:08Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-11-25T11:32:50Z"
      },
      "message": "Move m_failed_blocks to ChainstateManager\n\nThe member is unrelated to block storage (BlockManager). It is related\nto validation.\n\nFix the confusion by moving it.\n\nCan be reviewed with\n--color-moved=dimmed-zebra --color-moved-ws=ignore-all-space",
      "tree": {
        "sha": "cd301d80da0ec530f055fdf1952c20865c961b24",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cd301d80da0ec530f055fdf1952c20865c961b24"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7777930a19ae424315a60b1df601409a63ecff25",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUgp6Av+JmD8yGkVVSmRTqlPGE4rsdSyqIKkfvbQwJCS5il8Movc3zYoBn15tkWf\nTPTCAqFDTrYRAA/tzlVK7uILtJ+ITI4bh/LuhCnlorEDhpj+u2zHTkcxsC+Bw1F8\n0VbfmXfJbWdqwbSGZiy8YOUQ7xUeUD3hyVMNJmNQ0BmN6j1iYW/9agryRXTBFcJ2\n6o3ZFewgTMztQFXo4mFztkUxnzXTeYHACW7nYOmOp2nZ2M5BfyAvZiHMElRkMCPV\noHbxBFwqVe2ieC3WKC3KbxilJGMU0b8E5JUEf7jySS2Pcfipt/N5IQ8xntwk+ZQ4\nxxznspq+ug9LM8UE51ExDqY9VE5pKAP7db/l0swgBdQGBCKwEePnYTB2ug34W6sW\nu9N+n6B63X4gZrXc9Rr8u56IvsV0z/OivswmUguRrYHTC1UuPps9Bvn6O8oVWElR\njtx9hZ4PfD42Z4aPLp+vfGkQssOZtLHI+BlN7Bn+MWJUWobUsJ+d9scwlCme9Wey\n8rLY0LRa\n=uzWm\n-----END PGP SIGNATURE-----",
        "payload": "tree cd301d80da0ec530f055fdf1952c20865c961b24\nparent 66662a0ad4c1ad3323ac869f6959e4d246add7bb\nauthor MarcoFalke <falke.marco@gmail.com> 1637692628 +0100\ncommitter MarcoFalke <falke.marco@gmail.com> 1637839970 +0100\n\nMove m_failed_blocks to ChainstateManager\n\nThe member is unrelated to block storage (BlockManager). It is related\nto validation.\n\nFix the confusion by moving it.\n\nCan be reviewed with\n--color-moved=dimmed-zebra --color-moved-ws=ignore-all-space\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7777930a19ae424315a60b1df601409a63ecff25",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7777930a19ae424315a60b1df601409a63ecff25",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7777930a19ae424315a60b1df601409a63ecff25/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "66662a0ad4c1ad3323ac869f6959e4d246add7bb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/66662a0ad4c1ad3323ac869f6959e4d246add7bb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/66662a0ad4c1ad3323ac869f6959e4d246add7bb"
      }
    ],
    "stats": {
      "total": 53,
      "additions": 27,
      "deletions": 26
    },
    "files": [
      {
        "sha": "2b5886da9bcb3981cded86563a6848bf46fc0a37",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7777930a19ae424315a60b1df601409a63ecff25/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7777930a19ae424315a60b1df601409a63ecff25/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=7777930a19ae424315a60b1df601409a63ecff25",
        "patch": "@@ -1281,7 +1281,7 @@ void CChainState::InvalidBlockFound(CBlockIndex* pindex, const BlockValidationSt\n {\n     if (state.GetResult() != BlockValidationResult::BLOCK_MUTATED) {\n         pindex->nStatus |= BLOCK_FAILED_VALID;\n-        m_blockman.m_failed_blocks.insert(pindex);\n+        m_chainman.m_failed_blocks.insert(pindex);\n         setDirtyBlockIndex.insert(pindex);\n         setBlockIndexCandidates.erase(pindex);\n         InvalidChainFound(pindex);\n@@ -2826,7 +2826,7 @@ bool CChainState::InvalidateBlock(BlockValidationState& state, CBlockIndex* pind\n         to_mark_failed->nStatus |= BLOCK_FAILED_VALID;\n         setDirtyBlockIndex.insert(to_mark_failed);\n         setBlockIndexCandidates.erase(to_mark_failed);\n-        m_blockman.m_failed_blocks.insert(to_mark_failed);\n+        m_chainman.m_failed_blocks.insert(to_mark_failed);\n \n         // If any new blocks somehow arrived while we were disconnecting\n         // (above), then the pre-calculation of what should go into\n@@ -2871,7 +2871,7 @@ void CChainState::ResetBlockFailureFlags(CBlockIndex *pindex) {\n                 // Reset invalid block marker if it was pointing to one of those.\n                 pindexBestInvalid = nullptr;\n             }\n-            m_blockman.m_failed_blocks.erase(it->second);\n+            m_chainman.m_failed_blocks.erase(it->second);\n         }\n         it++;\n     }\n@@ -2881,7 +2881,7 @@ void CChainState::ResetBlockFailureFlags(CBlockIndex *pindex) {\n         if (pindex->nStatus & BLOCK_FAILED_MASK) {\n             pindex->nStatus &= ~BLOCK_FAILED_MASK;\n             setDirtyBlockIndex.insert(pindex);\n-            m_blockman.m_failed_blocks.erase(pindex);\n+            m_chainman.m_failed_blocks.erase(pindex);\n         }\n         pindex = pindex->pprev;\n     }\n@@ -3307,7 +3307,7 @@ bool ChainstateManager::AcceptBlockHeader(const CBlockHeader& block, BlockValida\n             // hasn't been validated up to BLOCK_VALID_SCRIPTS. This is a performance\n             // optimization, in the common case of adding a new block to the tip,\n             // we don't need to iterate over the failed blocks list.\n-            for (const CBlockIndex* failedit : m_blockman.m_failed_blocks) {\n+            for (const CBlockIndex* failedit : m_failed_blocks) {\n                 if (pindexPrev->GetAncestor(failedit->nHeight) == failedit) {\n                     assert(failedit->nStatus & BLOCK_FAILED_VALID);\n                     CBlockIndex* invalid_walk = pindexPrev;\n@@ -3732,7 +3732,6 @@ bool BlockManager::LoadBlockIndex(\n }\n \n void BlockManager::Unload() {\n-    m_failed_blocks.clear();\n     m_blocks_unlinked.clear();\n \n     for (const BlockMap::value_type& entry : m_block_index) {\n@@ -5039,6 +5038,7 @@ void ChainstateManager::Unload()\n         chainstate->UnloadBlockIndex();\n     }\n \n+    m_failed_blocks.clear();\n     m_blockman.Unload();\n }\n "
      },
      {
        "sha": "8768e07294a144ba16a60de532c94d4520d49697",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 21,
        "deletions": 20,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7777930a19ae424315a60b1df601409a63ecff25/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7777930a19ae424315a60b1df601409a63ecff25/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=7777930a19ae424315a60b1df601409a63ecff25",
        "patch": "@@ -408,26 +408,6 @@ class BlockManager\n public:\n     BlockMap m_block_index GUARDED_BY(cs_main);\n \n-    /** In order to efficiently track invalidity of headers, we keep the set of\n-      * blocks which we tried to connect and found to be invalid here (ie which\n-      * were set to BLOCK_FAILED_VALID since the last restart). We can then\n-      * walk this set and check if a new header is a descendant of something in\n-      * this set, preventing us from having to walk m_block_index when we try\n-      * to connect a bad block and fail.\n-      *\n-      * While this is more complicated than marking everything which descends\n-      * from an invalid block as invalid at the time we discover it to be\n-      * invalid, doing so would require walking all of m_block_index to find all\n-      * descendants. Since this case should be very rare, keeping track of all\n-      * BLOCK_FAILED_VALID blocks in a set should be just fine and work just as\n-      * well.\n-      *\n-      * Because we already walk m_block_index in height-order at startup, we go\n-      * ahead and mark descendants of invalid blocks as FAILED_CHILD at that time,\n-      * instead of putting things in this set.\n-      */\n-    std::set<CBlockIndex*> m_failed_blocks;\n-\n     /**\n      * All pairs A->B, where A (or one of its ancestors) misses transactions, but B has transactions.\n      * Pruned nodes may have entries where B is missing data.\n@@ -904,6 +884,27 @@ class ChainstateManager\n     //! chainstate to avoid duplicating block metadata.\n     BlockManager m_blockman GUARDED_BY(::cs_main);\n \n+    /**\n+     * In order to efficiently track invalidity of headers, we keep the set of\n+     * blocks which we tried to connect and found to be invalid here (ie which\n+     * were set to BLOCK_FAILED_VALID since the last restart). We can then\n+     * walk this set and check if a new header is a descendant of something in\n+     * this set, preventing us from having to walk m_block_index when we try\n+     * to connect a bad block and fail.\n+     *\n+     * While this is more complicated than marking everything which descends\n+     * from an invalid block as invalid at the time we discover it to be\n+     * invalid, doing so would require walking all of m_block_index to find all\n+     * descendants. Since this case should be very rare, keeping track of all\n+     * BLOCK_FAILED_VALID blocks in a set should be just fine and work just as\n+     * well.\n+     *\n+     * Because we already walk m_block_index in height-order at startup, we go\n+     * ahead and mark descendants of invalid blocks as FAILED_CHILD at that time,\n+     * instead of putting things in this set.\n+     */\n+    std::set<CBlockIndex*> m_failed_blocks;\n+\n     //! The total number of bytes available for us to use across all in-memory\n     //! coins caches. This will be split somehow across chainstates.\n     int64_t m_total_coinstip_cache{0};"
      }
    ]
  },
  {
    "sha": "fa0fd6cd3db43f8f76569f9cd608c35920ea2cf9",
    "node_id": "C_kwDOABII59oAKGZhMGZkNmNkM2RiNDNmOGY3NjU2OWY5Y2Q2MDhjMzU5MjBlYTJjZjk",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-11-23T19:47:43Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-11-25T11:33:09Z"
      },
      "message": "Pass best_invalid to LoadBlockIndex\n\nThis is needed for a later commit.",
      "tree": {
        "sha": "db2713342b22fd283fb66431d1954378b9bb0d5c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/db2713342b22fd283fb66431d1954378b9bb0d5c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa0fd6cd3db43f8f76569f9cd608c35920ea2cf9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUhbfwv6As0zH4yBs6RQ5Ln+SFLAwLwv+d+9szUS9WAi2wT2AU1rpfFNzcpEfHww\nPTDmsvsOred+BiJP+Jqeq8nfJED/dlSZnOQ0tfMRmzgmvqw17K0pmBfITFV4pZj7\nNvZpB6pYKY3RfD+JmMx3Iji9d8zCsldUS6XAADzEWSybOgROvxUXvAeXXFjVpMdM\nVzuAIQ18JqMCLxMw1hNRpQXLikSYu0A91wzSvxOdA4eNx+tX/oMp0AQSEUwORvG7\n83EBG0U/jccF1TuSkDgFVUi+GVIFZk8lDIoUvj4fWGGj4giosrmOuWMwLeFF4u8n\nwprXp1aan+WxanjxkPagXMrt7FHPf2lxz87zQEfUDoP6zHE0wFdj+8elUQrGtUQZ\n/yahDBJTYYMwVjNpuPxch08NUyWxujL3tub8QAZqHlTXV+RQ6yXMqzsjDNozSCfP\noGew3WQWXjF40g93laCC4nrUYR5I4sBDsnWQ1XtD63/KHNoiABIFSYPu7eUY6LLG\nw0Z4bWSi\n=mnBJ\n-----END PGP SIGNATURE-----",
        "payload": "tree db2713342b22fd283fb66431d1954378b9bb0d5c\nparent 7777930a19ae424315a60b1df601409a63ecff25\nauthor MarcoFalke <falke.marco@gmail.com> 1637696863 +0100\ncommitter MarcoFalke <falke.marco@gmail.com> 1637839989 +0100\n\nPass best_invalid to LoadBlockIndex\n\nThis is needed for a later commit.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa0fd6cd3db43f8f76569f9cd608c35920ea2cf9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa0fd6cd3db43f8f76569f9cd608c35920ea2cf9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa0fd6cd3db43f8f76569f9cd608c35920ea2cf9/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7777930a19ae424315a60b1df601409a63ecff25",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7777930a19ae424315a60b1df601409a63ecff25",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7777930a19ae424315a60b1df601409a63ecff25"
      }
    ],
    "stats": {
      "total": 17,
      "additions": 12,
      "deletions": 5
    },
    "files": [
      {
        "sha": "db523e362a50cf178af24ca00ae3ab26e00b22ee",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 4,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0fd6cd3db43f8f76569f9cd608c35920ea2cf9/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0fd6cd3db43f8f76569f9cd608c35920ea2cf9/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=fa0fd6cd3db43f8f76569f9cd608c35920ea2cf9",
        "patch": "@@ -3676,6 +3676,7 @@ CBlockIndex * BlockManager::InsertBlockIndex(const uint256& hash)\n \n bool BlockManager::LoadBlockIndex(\n     const Consensus::Params& consensus_params,\n+    CBlockIndex*& best_invalid,\n     std::set<CBlockIndex*, CBlockIndexWorkComparator>& block_index_candidates)\n {\n     if (!m_block_tree_db->LoadBlockIndexGuts(consensus_params, [this](const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main) { return this->InsertBlockIndex(hash); })) {\n@@ -3720,8 +3721,9 @@ bool BlockManager::LoadBlockIndex(\n                  (pindex->HaveTxsDownloaded() || pindex->pprev == nullptr))) {\n             block_index_candidates.insert(pindex);\n         }\n-        if (pindex->nStatus & BLOCK_FAILED_MASK && (!pindexBestInvalid || pindex->nChainWork > pindexBestInvalid->nChainWork))\n-            pindexBestInvalid = pindex;\n+        if (pindex->nStatus & BLOCK_FAILED_MASK && (!best_invalid || pindex->nChainWork > best_invalid->nChainWork)) {\n+            best_invalid = pindex;\n+        }\n         if (pindex->pprev)\n             pindex->BuildSkip();\n         if (pindex->IsValid(BLOCK_VALID_TREE) && (pindexBestHeader == nullptr || CBlockIndexWorkComparator()(pindexBestHeader, pindex)))\n@@ -3741,10 +3743,11 @@ void BlockManager::Unload() {\n     m_block_index.clear();\n }\n \n-bool BlockManager::LoadBlockIndexDB(std::set<CBlockIndex*, CBlockIndexWorkComparator>& setBlockIndexCandidates)\n+bool BlockManager::LoadBlockIndexDB(CBlockIndex*& best_invalid, std::set<CBlockIndex*, CBlockIndexWorkComparator>& setBlockIndexCandidates)\n {\n     if (!LoadBlockIndex(\n             ::Params().GetConsensus(),\n+            best_invalid,\n             setBlockIndexCandidates)) {\n         return false;\n     }\n@@ -4091,7 +4094,7 @@ bool ChainstateManager::LoadBlockIndex()\n     // Load block index from databases\n     bool needs_init = fReindex;\n     if (!fReindex) {\n-        bool ret = m_blockman.LoadBlockIndexDB(ActiveChainstate().setBlockIndexCandidates);\n+        bool ret = m_blockman.LoadBlockIndexDB(::pindexBestInvalid, ActiveChainstate().setBlockIndexCandidates);\n         if (!ret) return false;\n         needs_init = m_blockman.m_block_index.empty();\n     }"
      },
      {
        "sha": "5509e08d9f4e2d8fd90e116d7dce3f7e5e6a3320",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0fd6cd3db43f8f76569f9cd608c35920ea2cf9/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0fd6cd3db43f8f76569f9cd608c35920ea2cf9/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=fa0fd6cd3db43f8f76569f9cd608c35920ea2cf9",
        "patch": "@@ -416,18 +416,22 @@ class BlockManager\n \n     std::unique_ptr<CBlockTreeDB> m_block_tree_db GUARDED_BY(::cs_main);\n \n-    bool LoadBlockIndexDB(std::set<CBlockIndex*, CBlockIndexWorkComparator>& setBlockIndexCandidates) EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n+    bool LoadBlockIndexDB(CBlockIndex*& best_invalid, std::set<CBlockIndex*, CBlockIndexWorkComparator>& setBlockIndexCandidates)\n+        EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n \n     /**\n      * Load the blocktree off disk and into memory. Populate certain metadata\n      * per index entry (nStatus, nChainWork, nTimeMax, etc.) as well as peripheral\n      * collections like setDirtyBlockIndex.\n      *\n+     * @param[out] best_invalid            Set to the invalid block with the\n+     *                                     most proof of work, if any.\n      * @param[out] block_index_candidates  Fill this set with any valid blocks for\n      *                                     which we've downloaded all transactions.\n      */\n     bool LoadBlockIndex(\n         const Consensus::Params& consensus_params,\n+        CBlockIndex*& best_invalid,\n         std::set<CBlockIndex*, CBlockIndexWorkComparator>& block_index_candidates)\n         EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n "
      }
    ]
  },
  {
    "sha": "faca15d27a194c3e9e5f52ddf35fd6baddb403b8",
    "node_id": "C_kwDOABII59oAKGZhY2ExNWQyN2ExOTRjM2U5ZTVmNTJkZGYzNWZkNmJhZGRiNDAzYjg",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-11-23T14:19:38Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-11-25T11:33:22Z"
      },
      "message": "Move BlockManager to node/blockstorage\n\nCan be reviewed with --color-moved=dimmed-zebra",
      "tree": {
        "sha": "a2c869a81cd6443b9929f7c715e2b4a8d0e0d78e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a2c869a81cd6443b9929f7c715e2b4a8d0e0d78e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/faca15d27a194c3e9e5f52ddf35fd6baddb403b8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUjvPgwAxD7Xr1Vvmdtrp2iMz7f2HVuvW8CstgGXRYHO1rSs4jiBXpOwTr3xPr0r\n6UypX/e1kOxDF40HvmUC4fSbm+4wQ841TpE97GowCFoDsED9puknX0vmewwZPrqm\nr1TdYevgxwqyiu22J26fJHXNUZ47A+2bRGjv/PuHpFfrEQXwoVvL6fTFoLcHbKkO\n058LgJ/7rMThAdUmB4XYCwovC/pMUcx2Y6keHTyUeAZPD5+zsK8Z3fKYMdR34jHj\nEynoHbljKvm5b5QB1sn0DUFshz6kDm7CZQShnY6dfuFZ2pPgdp8D8uprC9S0ToCk\n7i7w9qLf1HvbwfRPQwPZ+++zCpeDAHjFxnzcTI+ttXiIB/wIplTiUTzITDmjJ53F\nH75G8gtr3hRCxhVpgs3Vb049znGqDa8w/q4axQUkvC3Vy4XeKWBLEhLVmxnRGhW3\nfLo98PERWdc7GU7i0WmP5sx+rcFR0ragExQFGeMb1SizePgYSx+fYfo/cvldG80Y\nzOKtIJ8X\n=/XWv\n-----END PGP SIGNATURE-----",
        "payload": "tree a2c869a81cd6443b9929f7c715e2b4a8d0e0d78e\nparent fa0fd6cd3db43f8f76569f9cd608c35920ea2cf9\nauthor MarcoFalke <falke.marco@gmail.com> 1637677178 +0100\ncommitter MarcoFalke <falke.marco@gmail.com> 1637840002 +0100\n\nMove BlockManager to node/blockstorage\n\nCan be reviewed with --color-moved=dimmed-zebra\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/faca15d27a194c3e9e5f52ddf35fd6baddb403b8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/faca15d27a194c3e9e5f52ddf35fd6baddb403b8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/faca15d27a194c3e9e5f52ddf35fd6baddb403b8/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fa0fd6cd3db43f8f76569f9cd608c35920ea2cf9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa0fd6cd3db43f8f76569f9cd608c35920ea2cf9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fa0fd6cd3db43f8f76569f9cd608c35920ea2cf9"
      }
    ],
    "stats": {
      "total": 826,
      "additions": 414,
      "deletions": 412
    },
    "files": [
      {
        "sha": "1aa2aea649e771a25773f8ed0b32b9db6a6845f1",
        "filename": "src/node/blockstorage.cpp",
        "status": "modified",
        "additions": 320,
        "deletions": 0,
        "changes": 320,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/faca15d27a194c3e9e5f52ddf35fd6baddb403b8/src/node/blockstorage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/faca15d27a194c3e9e5f52ddf35fd6baddb403b8/src/node/blockstorage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/blockstorage.cpp?ref=faca15d27a194c3e9e5f52ddf35fd6baddb403b8",
        "patch": "@@ -12,6 +12,7 @@\n #include <fs.h>\n #include <hash.h>\n #include <pow.h>\n+#include <reverse_iterator.h>\n #include <shutdown.h>\n #include <signet.h>\n #include <streams.h>\n@@ -47,6 +48,325 @@ static FILE* OpenUndoFile(const FlatFilePos& pos, bool fReadOnly = false);\n static FlatFileSeq BlockFileSeq();\n static FlatFileSeq UndoFileSeq();\n \n+CBlockIndex* BlockManager::LookupBlockIndex(const uint256& hash) const\n+{\n+    AssertLockHeld(cs_main);\n+    BlockMap::const_iterator it = m_block_index.find(hash);\n+    return it == m_block_index.end() ? nullptr : it->second;\n+}\n+\n+CBlockIndex* BlockManager::AddToBlockIndex(const CBlockHeader& block)\n+{\n+    AssertLockHeld(cs_main);\n+\n+    // Check for duplicate\n+    uint256 hash = block.GetHash();\n+    BlockMap::iterator it = m_block_index.find(hash);\n+    if (it != m_block_index.end())\n+        return it->second;\n+\n+    // Construct new block index object\n+    CBlockIndex* pindexNew = new CBlockIndex(block);\n+    // We assign the sequence id to blocks only when the full data is available,\n+    // to avoid miners withholding blocks but broadcasting headers, to get a\n+    // competitive advantage.\n+    pindexNew->nSequenceId = 0;\n+    BlockMap::iterator mi = m_block_index.insert(std::make_pair(hash, pindexNew)).first;\n+    pindexNew->phashBlock = &((*mi).first);\n+    BlockMap::iterator miPrev = m_block_index.find(block.hashPrevBlock);\n+    if (miPrev != m_block_index.end())\n+    {\n+        pindexNew->pprev = (*miPrev).second;\n+        pindexNew->nHeight = pindexNew->pprev->nHeight + 1;\n+        pindexNew->BuildSkip();\n+    }\n+    pindexNew->nTimeMax = (pindexNew->pprev ? std::max(pindexNew->pprev->nTimeMax, pindexNew->nTime) : pindexNew->nTime);\n+    pindexNew->nChainWork = (pindexNew->pprev ? pindexNew->pprev->nChainWork : 0) + GetBlockProof(*pindexNew);\n+    pindexNew->RaiseValidity(BLOCK_VALID_TREE);\n+    if (pindexBestHeader == nullptr || pindexBestHeader->nChainWork < pindexNew->nChainWork)\n+        pindexBestHeader = pindexNew;\n+\n+    setDirtyBlockIndex.insert(pindexNew);\n+\n+    return pindexNew;\n+}\n+\n+CBlockIndex* BlockManager::GetLastCheckpoint(const CCheckpointData& data)\n+{\n+    const MapCheckpoints& checkpoints = data.mapCheckpoints;\n+\n+    for (const MapCheckpoints::value_type& i : reverse_iterate(checkpoints))\n+    {\n+        const uint256& hash = i.second;\n+        CBlockIndex* pindex = LookupBlockIndex(hash);\n+        if (pindex) {\n+            return pindex;\n+        }\n+    }\n+    return nullptr;\n+}\n+\n+void BlockManager::PruneOneBlockFile(const int fileNumber)\n+{\n+    AssertLockHeld(cs_main);\n+    LOCK(cs_LastBlockFile);\n+\n+    for (const auto& entry : m_block_index) {\n+        CBlockIndex* pindex = entry.second;\n+        if (pindex->nFile == fileNumber) {\n+            pindex->nStatus &= ~BLOCK_HAVE_DATA;\n+            pindex->nStatus &= ~BLOCK_HAVE_UNDO;\n+            pindex->nFile = 0;\n+            pindex->nDataPos = 0;\n+            pindex->nUndoPos = 0;\n+            setDirtyBlockIndex.insert(pindex);\n+\n+            // Prune from m_blocks_unlinked -- any block we prune would have\n+            // to be downloaded again in order to consider its chain, at which\n+            // point it would be considered as a candidate for\n+            // m_blocks_unlinked or setBlockIndexCandidates.\n+            auto range = m_blocks_unlinked.equal_range(pindex->pprev);\n+            while (range.first != range.second) {\n+                std::multimap<CBlockIndex *, CBlockIndex *>::iterator _it = range.first;\n+                range.first++;\n+                if (_it->second == pindex) {\n+                    m_blocks_unlinked.erase(_it);\n+                }\n+            }\n+        }\n+    }\n+\n+    vinfoBlockFile[fileNumber].SetNull();\n+    setDirtyFileInfo.insert(fileNumber);\n+}\n+\n+void BlockManager::FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPruneHeight, int chain_tip_height)\n+{\n+    assert(fPruneMode && nManualPruneHeight > 0);\n+\n+    LOCK2(cs_main, cs_LastBlockFile);\n+    if (chain_tip_height < 0) {\n+        return;\n+    }\n+\n+    // last block to prune is the lesser of (user-specified height, MIN_BLOCKS_TO_KEEP from the tip)\n+    unsigned int nLastBlockWeCanPrune = std::min((unsigned)nManualPruneHeight, chain_tip_height - MIN_BLOCKS_TO_KEEP);\n+    int count = 0;\n+    for (int fileNumber = 0; fileNumber < nLastBlockFile; fileNumber++) {\n+        if (vinfoBlockFile[fileNumber].nSize == 0 || vinfoBlockFile[fileNumber].nHeightLast > nLastBlockWeCanPrune) {\n+            continue;\n+        }\n+        PruneOneBlockFile(fileNumber);\n+        setFilesToPrune.insert(fileNumber);\n+        count++;\n+    }\n+    LogPrintf(\"Prune (Manual): prune_height=%d removed %d blk/rev pairs\\n\", nLastBlockWeCanPrune, count);\n+}\n+\n+void BlockManager::FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfterHeight, int chain_tip_height, int prune_height, bool is_ibd)\n+{\n+    LOCK2(cs_main, cs_LastBlockFile);\n+    if (chain_tip_height < 0 || nPruneTarget == 0) {\n+        return;\n+    }\n+    if ((uint64_t)chain_tip_height <= nPruneAfterHeight) {\n+        return;\n+    }\n+\n+    unsigned int nLastBlockWeCanPrune = std::min(prune_height, chain_tip_height - static_cast<int>(MIN_BLOCKS_TO_KEEP));\n+    uint64_t nCurrentUsage = CalculateCurrentUsage();\n+    // We don't check to prune until after we've allocated new space for files\n+    // So we should leave a buffer under our target to account for another allocation\n+    // before the next pruning.\n+    uint64_t nBuffer = BLOCKFILE_CHUNK_SIZE + UNDOFILE_CHUNK_SIZE;\n+    uint64_t nBytesToPrune;\n+    int count = 0;\n+\n+    if (nCurrentUsage + nBuffer >= nPruneTarget) {\n+        // On a prune event, the chainstate DB is flushed.\n+        // To avoid excessive prune events negating the benefit of high dbcache\n+        // values, we should not prune too rapidly.\n+        // So when pruning in IBD, increase the buffer a bit to avoid a re-prune too soon.\n+        if (is_ibd) {\n+            // Since this is only relevant during IBD, we use a fixed 10%\n+            nBuffer += nPruneTarget / 10;\n+        }\n+\n+        for (int fileNumber = 0; fileNumber < nLastBlockFile; fileNumber++) {\n+            nBytesToPrune = vinfoBlockFile[fileNumber].nSize + vinfoBlockFile[fileNumber].nUndoSize;\n+\n+            if (vinfoBlockFile[fileNumber].nSize == 0) {\n+                continue;\n+            }\n+\n+            if (nCurrentUsage + nBuffer < nPruneTarget) { // are we below our target?\n+                break;\n+            }\n+\n+            // don't prune files that could have a block within MIN_BLOCKS_TO_KEEP of the main chain's tip but keep scanning\n+            if (vinfoBlockFile[fileNumber].nHeightLast > nLastBlockWeCanPrune) {\n+                continue;\n+            }\n+\n+            PruneOneBlockFile(fileNumber);\n+            // Queue up the files for removal\n+            setFilesToPrune.insert(fileNumber);\n+            nCurrentUsage -= nBytesToPrune;\n+            count++;\n+        }\n+    }\n+\n+    LogPrint(BCLog::PRUNE, \"Prune: target=%dMiB actual=%dMiB diff=%dMiB max_prune_height=%d removed %d blk/rev pairs\\n\",\n+           nPruneTarget/1024/1024, nCurrentUsage/1024/1024,\n+           ((int64_t)nPruneTarget - (int64_t)nCurrentUsage)/1024/1024,\n+           nLastBlockWeCanPrune, count);\n+}\n+\n+CBlockIndex * BlockManager::InsertBlockIndex(const uint256& hash)\n+{\n+    AssertLockHeld(cs_main);\n+\n+    if (hash.IsNull())\n+        return nullptr;\n+\n+    // Return existing\n+    BlockMap::iterator mi = m_block_index.find(hash);\n+    if (mi != m_block_index.end())\n+        return (*mi).second;\n+\n+    // Create new\n+    CBlockIndex* pindexNew = new CBlockIndex();\n+    mi = m_block_index.insert(std::make_pair(hash, pindexNew)).first;\n+    pindexNew->phashBlock = &((*mi).first);\n+\n+    return pindexNew;\n+}\n+\n+bool BlockManager::LoadBlockIndex(\n+    const Consensus::Params& consensus_params,\n+    CBlockIndex*& best_invalid,\n+    std::set<CBlockIndex*, CBlockIndexWorkComparator>& block_index_candidates)\n+{\n+    if (!m_block_tree_db->LoadBlockIndexGuts(consensus_params, [this](const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main) { return this->InsertBlockIndex(hash); })) {\n+        return false;\n+    }\n+\n+    // Calculate nChainWork\n+    std::vector<std::pair<int, CBlockIndex*> > vSortedByHeight;\n+    vSortedByHeight.reserve(m_block_index.size());\n+    for (const std::pair<const uint256, CBlockIndex*>& item : m_block_index)\n+    {\n+        CBlockIndex* pindex = item.second;\n+        vSortedByHeight.push_back(std::make_pair(pindex->nHeight, pindex));\n+    }\n+    sort(vSortedByHeight.begin(), vSortedByHeight.end());\n+    for (const std::pair<int, CBlockIndex*>& item : vSortedByHeight)\n+    {\n+        if (ShutdownRequested()) return false;\n+        CBlockIndex* pindex = item.second;\n+        pindex->nChainWork = (pindex->pprev ? pindex->pprev->nChainWork : 0) + GetBlockProof(*pindex);\n+        pindex->nTimeMax = (pindex->pprev ? std::max(pindex->pprev->nTimeMax, pindex->nTime) : pindex->nTime);\n+        // We can link the chain of blocks for which we've received transactions at some point.\n+        // Pruned nodes may have deleted the block.\n+        if (pindex->nTx > 0) {\n+            if (pindex->pprev) {\n+                if (pindex->pprev->HaveTxsDownloaded()) {\n+                    pindex->nChainTx = pindex->pprev->nChainTx + pindex->nTx;\n+                } else {\n+                    pindex->nChainTx = 0;\n+                    m_blocks_unlinked.insert(std::make_pair(pindex->pprev, pindex));\n+                }\n+            } else {\n+                pindex->nChainTx = pindex->nTx;\n+            }\n+        }\n+        if (!(pindex->nStatus & BLOCK_FAILED_MASK) && pindex->pprev && (pindex->pprev->nStatus & BLOCK_FAILED_MASK)) {\n+            pindex->nStatus |= BLOCK_FAILED_CHILD;\n+            setDirtyBlockIndex.insert(pindex);\n+        }\n+        if (pindex->IsAssumedValid() ||\n+                (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) &&\n+                 (pindex->HaveTxsDownloaded() || pindex->pprev == nullptr))) {\n+            block_index_candidates.insert(pindex);\n+        }\n+        if (pindex->nStatus & BLOCK_FAILED_MASK && (!best_invalid || pindex->nChainWork > best_invalid->nChainWork)) {\n+            best_invalid = pindex;\n+        }\n+        if (pindex->pprev)\n+            pindex->BuildSkip();\n+        if (pindex->IsValid(BLOCK_VALID_TREE) && (pindexBestHeader == nullptr || CBlockIndexWorkComparator()(pindexBestHeader, pindex)))\n+            pindexBestHeader = pindex;\n+    }\n+\n+    return true;\n+}\n+\n+void BlockManager::Unload() {\n+    m_blocks_unlinked.clear();\n+\n+    for (const BlockMap::value_type& entry : m_block_index) {\n+        delete entry.second;\n+    }\n+\n+    m_block_index.clear();\n+}\n+\n+bool BlockManager::LoadBlockIndexDB(CBlockIndex*& best_invalid, std::set<CBlockIndex*, CBlockIndexWorkComparator>& setBlockIndexCandidates)\n+{\n+    if (!LoadBlockIndex(\n+            ::Params().GetConsensus(),\n+            best_invalid,\n+            setBlockIndexCandidates)) {\n+        return false;\n+    }\n+\n+    // Load block file info\n+    m_block_tree_db->ReadLastBlockFile(nLastBlockFile);\n+    vinfoBlockFile.resize(nLastBlockFile + 1);\n+    LogPrintf(\"%s: last block file = %i\\n\", __func__, nLastBlockFile);\n+    for (int nFile = 0; nFile <= nLastBlockFile; nFile++) {\n+        m_block_tree_db->ReadBlockFileInfo(nFile, vinfoBlockFile[nFile]);\n+    }\n+    LogPrintf(\"%s: last block file info: %s\\n\", __func__, vinfoBlockFile[nLastBlockFile].ToString());\n+    for (int nFile = nLastBlockFile + 1; true; nFile++) {\n+        CBlockFileInfo info;\n+        if (m_block_tree_db->ReadBlockFileInfo(nFile, info)) {\n+            vinfoBlockFile.push_back(info);\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    // Check presence of blk files\n+    LogPrintf(\"Checking all blk files are present...\\n\");\n+    std::set<int> setBlkDataFiles;\n+    for (const std::pair<const uint256, CBlockIndex*>& item : m_block_index) {\n+        CBlockIndex* pindex = item.second;\n+        if (pindex->nStatus & BLOCK_HAVE_DATA) {\n+            setBlkDataFiles.insert(pindex->nFile);\n+        }\n+    }\n+    for (std::set<int>::iterator it = setBlkDataFiles.begin(); it != setBlkDataFiles.end(); it++)\n+    {\n+        FlatFilePos pos(*it, 0);\n+        if (CAutoFile(OpenBlockFile(pos, true), SER_DISK, CLIENT_VERSION).IsNull()) {\n+            return false;\n+        }\n+    }\n+\n+    // Check whether we have ever pruned block & undo files\n+    m_block_tree_db->ReadFlag(\"prunedblockfiles\", fHavePruned);\n+    if (fHavePruned)\n+        LogPrintf(\"LoadBlockIndexDB(): Block files have previously been pruned\\n\");\n+\n+    // Check whether we need to continue reindexing\n+    bool fReindexing = false;\n+    m_block_tree_db->ReadReindexing(fReindexing);\n+    if(fReindexing) fReindex = true;\n+\n+    return true;\n+}\n+\n bool IsBlockPruned(const CBlockIndex* pblockindex)\n {\n     return (fHavePruned && !(pblockindex->nStatus & BLOCK_HAVE_DATA) && pblockindex->nTx > 0);"
      },
      {
        "sha": "cc8c023a5a78fffc6eae3d49676d68698f604844",
        "filename": "src/node/blockstorage.h",
        "status": "modified",
        "additions": 92,
        "deletions": 0,
        "changes": 92,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/faca15d27a194c3e9e5f52ddf35fd6baddb403b8/src/node/blockstorage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/faca15d27a194c3e9e5f52ddf35fd6baddb403b8/src/node/blockstorage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/blockstorage.h?ref=faca15d27a194c3e9e5f52ddf35fd6baddb403b8",
        "patch": "@@ -7,6 +7,7 @@\n \n #include <fs.h>\n #include <protocol.h> // For CMessageHeader::MessageStartChars\n+#include <txdb.h>\n \n #include <atomic>\n #include <cstdint>\n@@ -19,8 +20,10 @@ class CBlockFileInfo;\n class CBlockIndex;\n class CBlockUndo;\n class CChain;\n+class CChainState;\n class CChainParams;\n class ChainstateManager;\n+struct CCheckpointData;\n struct FlatFilePos;\n namespace Consensus {\n struct Params;\n@@ -45,6 +48,95 @@ extern bool fPruneMode;\n /** Number of MiB of block files that we're trying to stay below. */\n extern uint64_t nPruneTarget;\n \n+typedef std::unordered_map<uint256, CBlockIndex*, BlockHasher> BlockMap;\n+\n+struct CBlockIndexWorkComparator\n+{\n+    bool operator()(const CBlockIndex *pa, const CBlockIndex *pb) const;\n+};\n+\n+/**\n+ * Maintains a tree of blocks (stored in `m_block_index`) which is consulted\n+ * to determine where the most-work tip is.\n+ *\n+ * This data is used mostly in `CChainState` - information about, e.g.,\n+ * candidate tips is not maintained here.\n+ */\n+class BlockManager\n+{\n+    friend CChainState;\n+\n+private:\n+    /* Calculate the block/rev files to delete based on height specified by user with RPC command pruneblockchain */\n+    void FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPruneHeight, int chain_tip_height);\n+\n+    /**\n+     * Prune block and undo files (blk???.dat and undo???.dat) so that the disk space used is less than a user-defined target.\n+     * The user sets the target (in MB) on the command line or in config file.  This will be run on startup and whenever new\n+     * space is allocated in a block or undo file, staying below the target. Changing back to unpruned requires a reindex\n+     * (which in this case means the blockchain must be re-downloaded.)\n+     *\n+     * Pruning functions are called from FlushStateToDisk when the global fCheckForPruning flag has been set.\n+     * Block and undo files are deleted in lock-step (when blk00003.dat is deleted, so is rev00003.dat.)\n+     * Pruning cannot take place until the longest chain is at least a certain length (100000 on mainnet, 1000 on testnet, 1000 on regtest).\n+     * Pruning will never delete a block within a defined distance (currently 288) from the active chain's tip.\n+     * The block index is updated by unsetting HAVE_DATA and HAVE_UNDO for any blocks that were stored in the deleted files.\n+     * A db flag records the fact that at least some block files have been pruned.\n+     *\n+     * @param[out]   setFilesToPrune   The set of file indices that can be unlinked will be returned\n+     */\n+    void FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfterHeight, int chain_tip_height, int prune_height, bool is_ibd);\n+\n+public:\n+    BlockMap m_block_index GUARDED_BY(cs_main);\n+\n+    /**\n+     * All pairs A->B, where A (or one of its ancestors) misses transactions, but B has transactions.\n+     * Pruned nodes may have entries where B is missing data.\n+     */\n+    std::multimap<CBlockIndex*, CBlockIndex*> m_blocks_unlinked;\n+\n+    std::unique_ptr<CBlockTreeDB> m_block_tree_db GUARDED_BY(::cs_main);\n+\n+    bool LoadBlockIndexDB(CBlockIndex*& best_invalid, std::set<CBlockIndex*, CBlockIndexWorkComparator>& setBlockIndexCandidates)\n+        EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n+\n+    /**\n+     * Load the blocktree off disk and into memory. Populate certain metadata\n+     * per index entry (nStatus, nChainWork, nTimeMax, etc.) as well as peripheral\n+     * collections like setDirtyBlockIndex.\n+     *\n+     * @param[out] best_invalid            Set to the invalid block with the\n+     *                                     most proof of work, if any.\n+     * @param[out] block_index_candidates  Fill this set with any valid blocks for\n+     *                                     which we've downloaded all transactions.\n+     */\n+    bool LoadBlockIndex(\n+        const Consensus::Params& consensus_params,\n+        CBlockIndex*& best_invalid,\n+        std::set<CBlockIndex*, CBlockIndexWorkComparator>& block_index_candidates)\n+        EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    /** Clear all data members. */\n+    void Unload() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    CBlockIndex* AddToBlockIndex(const CBlockHeader& block) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    /** Create a new block index entry for a given block hash */\n+    CBlockIndex* InsertBlockIndex(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    //! Mark one block file as pruned (modify associated database entries)\n+    void PruneOneBlockFile(const int fileNumber) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    CBlockIndex* LookupBlockIndex(const uint256& hash) const EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    //! Returns last CBlockIndex* that is a checkpoint\n+    CBlockIndex* GetLastCheckpoint(const CCheckpointData& data) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    ~BlockManager() {\n+        Unload();\n+    }\n+};\n+\n //! Check whether the block associated with this index entry is pruned or not.\n bool IsBlockPruned(const CBlockIndex* pblockindex);\n "
      },
      {
        "sha": "4761ab0cbae8e32ec98d3a494a276cc8ff1ab71c",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 323,
        "changes": 323,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/faca15d27a194c3e9e5f52ddf35fd6baddb403b8/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/faca15d27a194c3e9e5f52ddf35fd6baddb403b8/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=faca15d27a194c3e9e5f52ddf35fd6baddb403b8",
        "patch": "@@ -147,13 +147,6 @@ extern std::set<int> setDirtyFileInfo;\n void FlushBlockFile(bool fFinalize = false, bool finalize_undo = false);\n // ... TODO move fully to blockstorage\n \n-CBlockIndex* BlockManager::LookupBlockIndex(const uint256& hash) const\n-{\n-    AssertLockHeld(cs_main);\n-    BlockMap::const_iterator it = m_block_index.find(hash);\n-    return it == m_block_index.end() ? nullptr : it->second;\n-}\n-\n CBlockIndex* CChainState::FindForkInGlobalIndex(const CBlockLocator& locator) const\n {\n     AssertLockHeld(cs_main);\n@@ -2887,42 +2880,6 @@ void CChainState::ResetBlockFailureFlags(CBlockIndex *pindex) {\n     }\n }\n \n-CBlockIndex* BlockManager::AddToBlockIndex(const CBlockHeader& block)\n-{\n-    AssertLockHeld(cs_main);\n-\n-    // Check for duplicate\n-    uint256 hash = block.GetHash();\n-    BlockMap::iterator it = m_block_index.find(hash);\n-    if (it != m_block_index.end())\n-        return it->second;\n-\n-    // Construct new block index object\n-    CBlockIndex* pindexNew = new CBlockIndex(block);\n-    // We assign the sequence id to blocks only when the full data is available,\n-    // to avoid miners withholding blocks but broadcasting headers, to get a\n-    // competitive advantage.\n-    pindexNew->nSequenceId = 0;\n-    BlockMap::iterator mi = m_block_index.insert(std::make_pair(hash, pindexNew)).first;\n-    pindexNew->phashBlock = &((*mi).first);\n-    BlockMap::iterator miPrev = m_block_index.find(block.hashPrevBlock);\n-    if (miPrev != m_block_index.end())\n-    {\n-        pindexNew->pprev = (*miPrev).second;\n-        pindexNew->nHeight = pindexNew->pprev->nHeight + 1;\n-        pindexNew->BuildSkip();\n-    }\n-    pindexNew->nTimeMax = (pindexNew->pprev ? std::max(pindexNew->pprev->nTimeMax, pindexNew->nTime) : pindexNew->nTime);\n-    pindexNew->nChainWork = (pindexNew->pprev ? pindexNew->pprev->nChainWork : 0) + GetBlockProof(*pindexNew);\n-    pindexNew->RaiseValidity(BLOCK_VALID_TREE);\n-    if (pindexBestHeader == nullptr || pindexBestHeader->nChainWork < pindexNew->nChainWork)\n-        pindexBestHeader = pindexNew;\n-\n-    setDirtyBlockIndex.insert(pindexNew);\n-\n-    return pindexNew;\n-}\n-\n /** Mark a block as having its data received and checked (up to BLOCK_VALID_TRANSACTIONS). */\n void CChainState::ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pindexNew, const FlatFilePos& pos)\n {\n@@ -3089,21 +3046,6 @@ std::vector<unsigned char> GenerateCoinbaseCommitment(CBlock& block, const CBloc\n     return commitment;\n }\n \n-CBlockIndex* BlockManager::GetLastCheckpoint(const CCheckpointData& data)\n-{\n-    const MapCheckpoints& checkpoints = data.mapCheckpoints;\n-\n-    for (const MapCheckpoints::value_type& i : reverse_iterate(checkpoints))\n-    {\n-        const uint256& hash = i.second;\n-        CBlockIndex* pindex = LookupBlockIndex(hash);\n-        if (pindex) {\n-            return pindex;\n-        }\n-    }\n-    return nullptr;\n-}\n-\n /** Context-dependent validity checks.\n  *  By \"context\", we mean only the previous block headers, but not the UTXO\n  *  set; UTXO-related validity checks are done in ConnectBlock().\n@@ -3524,67 +3466,6 @@ bool TestBlockValidity(BlockValidationState& state,\n     return true;\n }\n \n-/**\n- * BLOCK PRUNING CODE\n- */\n-\n-void BlockManager::PruneOneBlockFile(const int fileNumber)\n-{\n-    AssertLockHeld(cs_main);\n-    LOCK(cs_LastBlockFile);\n-\n-    for (const auto& entry : m_block_index) {\n-        CBlockIndex* pindex = entry.second;\n-        if (pindex->nFile == fileNumber) {\n-            pindex->nStatus &= ~BLOCK_HAVE_DATA;\n-            pindex->nStatus &= ~BLOCK_HAVE_UNDO;\n-            pindex->nFile = 0;\n-            pindex->nDataPos = 0;\n-            pindex->nUndoPos = 0;\n-            setDirtyBlockIndex.insert(pindex);\n-\n-            // Prune from m_blocks_unlinked -- any block we prune would have\n-            // to be downloaded again in order to consider its chain, at which\n-            // point it would be considered as a candidate for\n-            // m_blocks_unlinked or setBlockIndexCandidates.\n-            auto range = m_blocks_unlinked.equal_range(pindex->pprev);\n-            while (range.first != range.second) {\n-                std::multimap<CBlockIndex *, CBlockIndex *>::iterator _it = range.first;\n-                range.first++;\n-                if (_it->second == pindex) {\n-                    m_blocks_unlinked.erase(_it);\n-                }\n-            }\n-        }\n-    }\n-\n-    vinfoBlockFile[fileNumber].SetNull();\n-    setDirtyFileInfo.insert(fileNumber);\n-}\n-\n-void BlockManager::FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPruneHeight, int chain_tip_height)\n-{\n-    assert(fPruneMode && nManualPruneHeight > 0);\n-\n-    LOCK2(cs_main, cs_LastBlockFile);\n-    if (chain_tip_height < 0) {\n-        return;\n-    }\n-\n-    // last block to prune is the lesser of (user-specified height, MIN_BLOCKS_TO_KEEP from the tip)\n-    unsigned int nLastBlockWeCanPrune = std::min((unsigned)nManualPruneHeight, chain_tip_height - MIN_BLOCKS_TO_KEEP);\n-    int count = 0;\n-    for (int fileNumber = 0; fileNumber < nLastBlockFile; fileNumber++) {\n-        if (vinfoBlockFile[fileNumber].nSize == 0 || vinfoBlockFile[fileNumber].nHeightLast > nLastBlockWeCanPrune) {\n-            continue;\n-        }\n-        PruneOneBlockFile(fileNumber);\n-        setFilesToPrune.insert(fileNumber);\n-        count++;\n-    }\n-    LogPrintf(\"Prune (Manual): prune_height=%d removed %d blk/rev pairs\\n\", nLastBlockWeCanPrune, count);\n-}\n-\n /* This function is called from the RPC code for pruneblockchain */\n void PruneBlockFilesManual(CChainState& active_chainstate, int nManualPruneHeight)\n {\n@@ -3595,210 +3476,6 @@ void PruneBlockFilesManual(CChainState& active_chainstate, int nManualPruneHeigh\n     }\n }\n \n-void BlockManager::FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfterHeight, int chain_tip_height, int prune_height, bool is_ibd)\n-{\n-    LOCK2(cs_main, cs_LastBlockFile);\n-    if (chain_tip_height < 0 || nPruneTarget == 0) {\n-        return;\n-    }\n-    if ((uint64_t)chain_tip_height <= nPruneAfterHeight) {\n-        return;\n-    }\n-\n-    unsigned int nLastBlockWeCanPrune = std::min(prune_height, chain_tip_height - static_cast<int>(MIN_BLOCKS_TO_KEEP));\n-    uint64_t nCurrentUsage = CalculateCurrentUsage();\n-    // We don't check to prune until after we've allocated new space for files\n-    // So we should leave a buffer under our target to account for another allocation\n-    // before the next pruning.\n-    uint64_t nBuffer = BLOCKFILE_CHUNK_SIZE + UNDOFILE_CHUNK_SIZE;\n-    uint64_t nBytesToPrune;\n-    int count = 0;\n-\n-    if (nCurrentUsage + nBuffer >= nPruneTarget) {\n-        // On a prune event, the chainstate DB is flushed.\n-        // To avoid excessive prune events negating the benefit of high dbcache\n-        // values, we should not prune too rapidly.\n-        // So when pruning in IBD, increase the buffer a bit to avoid a re-prune too soon.\n-        if (is_ibd) {\n-            // Since this is only relevant during IBD, we use a fixed 10%\n-            nBuffer += nPruneTarget / 10;\n-        }\n-\n-        for (int fileNumber = 0; fileNumber < nLastBlockFile; fileNumber++) {\n-            nBytesToPrune = vinfoBlockFile[fileNumber].nSize + vinfoBlockFile[fileNumber].nUndoSize;\n-\n-            if (vinfoBlockFile[fileNumber].nSize == 0) {\n-                continue;\n-            }\n-\n-            if (nCurrentUsage + nBuffer < nPruneTarget) { // are we below our target?\n-                break;\n-            }\n-\n-            // don't prune files that could have a block within MIN_BLOCKS_TO_KEEP of the main chain's tip but keep scanning\n-            if (vinfoBlockFile[fileNumber].nHeightLast > nLastBlockWeCanPrune) {\n-                continue;\n-            }\n-\n-            PruneOneBlockFile(fileNumber);\n-            // Queue up the files for removal\n-            setFilesToPrune.insert(fileNumber);\n-            nCurrentUsage -= nBytesToPrune;\n-            count++;\n-        }\n-    }\n-\n-    LogPrint(BCLog::PRUNE, \"Prune: target=%dMiB actual=%dMiB diff=%dMiB max_prune_height=%d removed %d blk/rev pairs\\n\",\n-           nPruneTarget/1024/1024, nCurrentUsage/1024/1024,\n-           ((int64_t)nPruneTarget - (int64_t)nCurrentUsage)/1024/1024,\n-           nLastBlockWeCanPrune, count);\n-}\n-\n-CBlockIndex * BlockManager::InsertBlockIndex(const uint256& hash)\n-{\n-    AssertLockHeld(cs_main);\n-\n-    if (hash.IsNull())\n-        return nullptr;\n-\n-    // Return existing\n-    BlockMap::iterator mi = m_block_index.find(hash);\n-    if (mi != m_block_index.end())\n-        return (*mi).second;\n-\n-    // Create new\n-    CBlockIndex* pindexNew = new CBlockIndex();\n-    mi = m_block_index.insert(std::make_pair(hash, pindexNew)).first;\n-    pindexNew->phashBlock = &((*mi).first);\n-\n-    return pindexNew;\n-}\n-\n-bool BlockManager::LoadBlockIndex(\n-    const Consensus::Params& consensus_params,\n-    CBlockIndex*& best_invalid,\n-    std::set<CBlockIndex*, CBlockIndexWorkComparator>& block_index_candidates)\n-{\n-    if (!m_block_tree_db->LoadBlockIndexGuts(consensus_params, [this](const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main) { return this->InsertBlockIndex(hash); })) {\n-        return false;\n-    }\n-\n-    // Calculate nChainWork\n-    std::vector<std::pair<int, CBlockIndex*> > vSortedByHeight;\n-    vSortedByHeight.reserve(m_block_index.size());\n-    for (const std::pair<const uint256, CBlockIndex*>& item : m_block_index)\n-    {\n-        CBlockIndex* pindex = item.second;\n-        vSortedByHeight.push_back(std::make_pair(pindex->nHeight, pindex));\n-    }\n-    sort(vSortedByHeight.begin(), vSortedByHeight.end());\n-    for (const std::pair<int, CBlockIndex*>& item : vSortedByHeight)\n-    {\n-        if (ShutdownRequested()) return false;\n-        CBlockIndex* pindex = item.second;\n-        pindex->nChainWork = (pindex->pprev ? pindex->pprev->nChainWork : 0) + GetBlockProof(*pindex);\n-        pindex->nTimeMax = (pindex->pprev ? std::max(pindex->pprev->nTimeMax, pindex->nTime) : pindex->nTime);\n-        // We can link the chain of blocks for which we've received transactions at some point.\n-        // Pruned nodes may have deleted the block.\n-        if (pindex->nTx > 0) {\n-            if (pindex->pprev) {\n-                if (pindex->pprev->HaveTxsDownloaded()) {\n-                    pindex->nChainTx = pindex->pprev->nChainTx + pindex->nTx;\n-                } else {\n-                    pindex->nChainTx = 0;\n-                    m_blocks_unlinked.insert(std::make_pair(pindex->pprev, pindex));\n-                }\n-            } else {\n-                pindex->nChainTx = pindex->nTx;\n-            }\n-        }\n-        if (!(pindex->nStatus & BLOCK_FAILED_MASK) && pindex->pprev && (pindex->pprev->nStatus & BLOCK_FAILED_MASK)) {\n-            pindex->nStatus |= BLOCK_FAILED_CHILD;\n-            setDirtyBlockIndex.insert(pindex);\n-        }\n-        if (pindex->IsAssumedValid() ||\n-                (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) &&\n-                 (pindex->HaveTxsDownloaded() || pindex->pprev == nullptr))) {\n-            block_index_candidates.insert(pindex);\n-        }\n-        if (pindex->nStatus & BLOCK_FAILED_MASK && (!best_invalid || pindex->nChainWork > best_invalid->nChainWork)) {\n-            best_invalid = pindex;\n-        }\n-        if (pindex->pprev)\n-            pindex->BuildSkip();\n-        if (pindex->IsValid(BLOCK_VALID_TREE) && (pindexBestHeader == nullptr || CBlockIndexWorkComparator()(pindexBestHeader, pindex)))\n-            pindexBestHeader = pindex;\n-    }\n-\n-    return true;\n-}\n-\n-void BlockManager::Unload() {\n-    m_blocks_unlinked.clear();\n-\n-    for (const BlockMap::value_type& entry : m_block_index) {\n-        delete entry.second;\n-    }\n-\n-    m_block_index.clear();\n-}\n-\n-bool BlockManager::LoadBlockIndexDB(CBlockIndex*& best_invalid, std::set<CBlockIndex*, CBlockIndexWorkComparator>& setBlockIndexCandidates)\n-{\n-    if (!LoadBlockIndex(\n-            ::Params().GetConsensus(),\n-            best_invalid,\n-            setBlockIndexCandidates)) {\n-        return false;\n-    }\n-\n-    // Load block file info\n-    m_block_tree_db->ReadLastBlockFile(nLastBlockFile);\n-    vinfoBlockFile.resize(nLastBlockFile + 1);\n-    LogPrintf(\"%s: last block file = %i\\n\", __func__, nLastBlockFile);\n-    for (int nFile = 0; nFile <= nLastBlockFile; nFile++) {\n-        m_block_tree_db->ReadBlockFileInfo(nFile, vinfoBlockFile[nFile]);\n-    }\n-    LogPrintf(\"%s: last block file info: %s\\n\", __func__, vinfoBlockFile[nLastBlockFile].ToString());\n-    for (int nFile = nLastBlockFile + 1; true; nFile++) {\n-        CBlockFileInfo info;\n-        if (m_block_tree_db->ReadBlockFileInfo(nFile, info)) {\n-            vinfoBlockFile.push_back(info);\n-        } else {\n-            break;\n-        }\n-    }\n-\n-    // Check presence of blk files\n-    LogPrintf(\"Checking all blk files are present...\\n\");\n-    std::set<int> setBlkDataFiles;\n-    for (const std::pair<const uint256, CBlockIndex*>& item : m_block_index) {\n-        CBlockIndex* pindex = item.second;\n-        if (pindex->nStatus & BLOCK_HAVE_DATA) {\n-            setBlkDataFiles.insert(pindex->nFile);\n-        }\n-    }\n-    for (std::set<int>::iterator it = setBlkDataFiles.begin(); it != setBlkDataFiles.end(); it++)\n-    {\n-        FlatFilePos pos(*it, 0);\n-        if (CAutoFile(OpenBlockFile(pos, true), SER_DISK, CLIENT_VERSION).IsNull()) {\n-            return false;\n-        }\n-    }\n-\n-    // Check whether we have ever pruned block & undo files\n-    m_block_tree_db->ReadFlag(\"prunedblockfiles\", fHavePruned);\n-    if (fHavePruned)\n-        LogPrintf(\"LoadBlockIndexDB(): Block files have previously been pruned\\n\");\n-\n-    // Check whether we need to continue reindexing\n-    bool fReindexing = false;\n-    m_block_tree_db->ReadReindexing(fReindexing);\n-    if(fReindexing) fReindex = true;\n-\n-    return true;\n-}\n-\n void CChainState::LoadMempool(const ArgsManager& args)\n {\n     if (!m_mempool) return;"
      },
      {
        "sha": "bb7ac4e2b838f2005fecab94df2315c133f74614",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 89,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/faca15d27a194c3e9e5f52ddf35fd6baddb403b8/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/faca15d27a194c3e9e5f52ddf35fd6baddb403b8/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=faca15d27a194c3e9e5f52ddf35fd6baddb403b8",
        "patch": "@@ -15,6 +15,7 @@\n #include <chain.h>\n #include <consensus/amount.h>\n #include <fs.h>\n+#include <node/blockstorage.h>\n #include <policy/feerate.h>\n #include <policy/packages.h>\n #include <script/script_error.h>\n@@ -40,7 +41,6 @@\n class CChainState;\n class CBlockTreeDB;\n class CChainParams;\n-struct CCheckpointData;\n class CTxMemPool;\n class ChainstateManager;\n class SnapshotMetadata;\n@@ -97,7 +97,6 @@ enum class SynchronizationState {\n };\n \n extern RecursiveMutex cs_main;\n-typedef std::unordered_map<uint256, CBlockIndex*, BlockHasher> BlockMap;\n extern Mutex g_best_block_mutex;\n extern std::condition_variable g_best_block_cv;\n /** Used to notify getblocktemplate RPC of new tips. */\n@@ -368,93 +367,6 @@ enum class FlushStateMode {\n     ALWAYS\n };\n \n-struct CBlockIndexWorkComparator\n-{\n-    bool operator()(const CBlockIndex *pa, const CBlockIndex *pb) const;\n-};\n-\n-/**\n- * Maintains a tree of blocks (stored in `m_block_index`) which is consulted\n- * to determine where the most-work tip is.\n- *\n- * This data is used mostly in `CChainState` - information about, e.g.,\n- * candidate tips is not maintained here.\n- */\n-class BlockManager\n-{\n-    friend CChainState;\n-\n-private:\n-    /* Calculate the block/rev files to delete based on height specified by user with RPC command pruneblockchain */\n-    void FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPruneHeight, int chain_tip_height);\n-\n-    /**\n-     * Prune block and undo files (blk???.dat and undo???.dat) so that the disk space used is less than a user-defined target.\n-     * The user sets the target (in MB) on the command line or in config file.  This will be run on startup and whenever new\n-     * space is allocated in a block or undo file, staying below the target. Changing back to unpruned requires a reindex\n-     * (which in this case means the blockchain must be re-downloaded.)\n-     *\n-     * Pruning functions are called from FlushStateToDisk when the global fCheckForPruning flag has been set.\n-     * Block and undo files are deleted in lock-step (when blk00003.dat is deleted, so is rev00003.dat.)\n-     * Pruning cannot take place until the longest chain is at least a certain length (100000 on mainnet, 1000 on testnet, 1000 on regtest).\n-     * Pruning will never delete a block within a defined distance (currently 288) from the active chain's tip.\n-     * The block index is updated by unsetting HAVE_DATA and HAVE_UNDO for any blocks that were stored in the deleted files.\n-     * A db flag records the fact that at least some block files have been pruned.\n-     *\n-     * @param[out]   setFilesToPrune   The set of file indices that can be unlinked will be returned\n-     */\n-    void FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfterHeight, int chain_tip_height, int prune_height, bool is_ibd);\n-\n-public:\n-    BlockMap m_block_index GUARDED_BY(cs_main);\n-\n-    /**\n-     * All pairs A->B, where A (or one of its ancestors) misses transactions, but B has transactions.\n-     * Pruned nodes may have entries where B is missing data.\n-     */\n-    std::multimap<CBlockIndex*, CBlockIndex*> m_blocks_unlinked;\n-\n-    std::unique_ptr<CBlockTreeDB> m_block_tree_db GUARDED_BY(::cs_main);\n-\n-    bool LoadBlockIndexDB(CBlockIndex*& best_invalid, std::set<CBlockIndex*, CBlockIndexWorkComparator>& setBlockIndexCandidates)\n-        EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n-\n-    /**\n-     * Load the blocktree off disk and into memory. Populate certain metadata\n-     * per index entry (nStatus, nChainWork, nTimeMax, etc.) as well as peripheral\n-     * collections like setDirtyBlockIndex.\n-     *\n-     * @param[out] best_invalid            Set to the invalid block with the\n-     *                                     most proof of work, if any.\n-     * @param[out] block_index_candidates  Fill this set with any valid blocks for\n-     *                                     which we've downloaded all transactions.\n-     */\n-    bool LoadBlockIndex(\n-        const Consensus::Params& consensus_params,\n-        CBlockIndex*& best_invalid,\n-        std::set<CBlockIndex*, CBlockIndexWorkComparator>& block_index_candidates)\n-        EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-\n-    /** Clear all data members. */\n-    void Unload() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-\n-    CBlockIndex* AddToBlockIndex(const CBlockHeader& block) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-    /** Create a new block index entry for a given block hash */\n-    CBlockIndex* InsertBlockIndex(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-\n-    //! Mark one block file as pruned (modify associated database entries)\n-    void PruneOneBlockFile(const int fileNumber) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-\n-    CBlockIndex* LookupBlockIndex(const uint256& hash) const EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-\n-    //! Returns last CBlockIndex* that is a checkpoint\n-    CBlockIndex* GetLastCheckpoint(const CCheckpointData& data) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-\n-    ~BlockManager() {\n-        Unload();\n-    }\n-};\n-\n /**\n  * A convenience class for constructing the CCoinsView* hierarchy used\n  * to facilitate access to the UTXO set."
      },
      {
        "sha": "6db73252d744a7f5322919a21616829c4f6c917e",
        "filename": "test/sanitizer_suppressions/ubsan",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/faca15d27a194c3e9e5f52ddf35fd6baddb403b8/test/sanitizer_suppressions/ubsan",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/faca15d27a194c3e9e5f52ddf35fd6baddb403b8/test/sanitizer_suppressions/ubsan",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/sanitizer_suppressions/ubsan?ref=faca15d27a194c3e9e5f52ddf35fd6baddb403b8",
        "patch": "@@ -61,6 +61,7 @@ implicit-integer-sign-change:crypto/\n implicit-integer-sign-change:FuzzedDataProvider.h\n implicit-integer-sign-change:key.cpp\n implicit-integer-sign-change:minisketch/\n+implicit-integer-sign-change:node/blockstorage.cpp\n implicit-integer-sign-change:noui.cpp\n implicit-integer-sign-change:policy/fees.cpp\n implicit-integer-sign-change:prevector.h"
      }
    ]
  },
  {
    "sha": "fa898c657880b313028256b45baf3ad6422b18fa",
    "node_id": "C_kwDOABII59oAKGZhODk4YzY1Nzg4MGIzMTMwMjgyNTZiNDViYWYzYWQ2NDIyYjE4ZmE",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-11-23T14:07:01Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-11-25T11:33:25Z"
      },
      "message": "Fixup style of moved code\n\nCan be reviewed with --word-diff-regex=. -U0 --ignore-all-space",
      "tree": {
        "sha": "25a34061df776e0321ea28fc0d0536710e75584a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/25a34061df776e0321ea28fc0d0536710e75584a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa898c657880b313028256b45baf3ad6422b18fa",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUgiAgv/f5rDQa8G0/LMOCnyj5dhNzi1Z1bRS6XXFPgRYKabFqS43fA45vh9dqdO\ndlOvYpbp74hhFxJN7deVC0bimMxoS1N58NB8dkNHpxEAUoDLtjjcFF95c6QsXwbT\nmnwnnEntz0cLrWwNmY4vJvdPEPZ721MjVXQxL9LsEb2qZ4JTfkro1tXo45HOa45W\n38GU3KOQBxnYWVRjbBwoMo7PYU0zGtAPUDWpsGpGce5MCRY8aZQ19KlLqp08Xa+E\nNLwec6fw697BoYSDLN5tL2l4J2iqW8ROUKsf+VC2pkFPxIXg2/UMvaq7ej010hGM\nE21r89gakN5/ZhRBOmyXYgC2MpfiRutLzxJ94WVywPPVAvcQ4yRSFiNsJl0a57i7\nIZCo943qP6osa3JfgRbuywkyiFrOvF82JguQxWr+dJvsZ6pkVX2vimFg+IcFDmsL\nXpKbz2DhkV0jEpbECEXHxVK8hr5QUbyIKHpwjVwPGogT/I2g4GQem6of7eKEMJeQ\nqbUGAz5+\n=9FRg\n-----END PGP SIGNATURE-----",
        "payload": "tree 25a34061df776e0321ea28fc0d0536710e75584a\nparent faca15d27a194c3e9e5f52ddf35fd6baddb403b8\nauthor MarcoFalke <falke.marco@gmail.com> 1637676421 +0100\ncommitter MarcoFalke <falke.marco@gmail.com> 1637840005 +0100\n\nFixup style of moved code\n\nCan be reviewed with --word-diff-regex=. -U0 --ignore-all-space\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa898c657880b313028256b45baf3ad6422b18fa",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa898c657880b313028256b45baf3ad6422b18fa",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa898c657880b313028256b45baf3ad6422b18fa/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "faca15d27a194c3e9e5f52ddf35fd6baddb403b8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/faca15d27a194c3e9e5f52ddf35fd6baddb403b8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/faca15d27a194c3e9e5f52ddf35fd6baddb403b8"
      }
    ],
    "stats": {
      "total": 52,
      "additions": 27,
      "deletions": 25
    },
    "files": [
      {
        "sha": "eccac879309e2865ba0dda1bdc42ae993ac679b0",
        "filename": "src/node/blockstorage.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 21,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa898c657880b313028256b45baf3ad6422b18fa/src/node/blockstorage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa898c657880b313028256b45baf3ad6422b18fa/src/node/blockstorage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/blockstorage.cpp?ref=fa898c657880b313028256b45baf3ad6422b18fa",
        "patch": "@@ -62,8 +62,9 @@ CBlockIndex* BlockManager::AddToBlockIndex(const CBlockHeader& block)\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n     BlockMap::iterator it = m_block_index.find(hash);\n-    if (it != m_block_index.end())\n+    if (it != m_block_index.end()) {\n         return it->second;\n+    }\n \n     // Construct new block index object\n     CBlockIndex* pindexNew = new CBlockIndex(block);\n@@ -74,17 +75,17 @@ CBlockIndex* BlockManager::AddToBlockIndex(const CBlockHeader& block)\n     BlockMap::iterator mi = m_block_index.insert(std::make_pair(hash, pindexNew)).first;\n     pindexNew->phashBlock = &((*mi).first);\n     BlockMap::iterator miPrev = m_block_index.find(block.hashPrevBlock);\n-    if (miPrev != m_block_index.end())\n-    {\n+    if (miPrev != m_block_index.end()) {\n         pindexNew->pprev = (*miPrev).second;\n         pindexNew->nHeight = pindexNew->pprev->nHeight + 1;\n         pindexNew->BuildSkip();\n     }\n     pindexNew->nTimeMax = (pindexNew->pprev ? std::max(pindexNew->pprev->nTimeMax, pindexNew->nTime) : pindexNew->nTime);\n     pindexNew->nChainWork = (pindexNew->pprev ? pindexNew->pprev->nChainWork : 0) + GetBlockProof(*pindexNew);\n     pindexNew->RaiseValidity(BLOCK_VALID_TREE);\n-    if (pindexBestHeader == nullptr || pindexBestHeader->nChainWork < pindexNew->nChainWork)\n+    if (pindexBestHeader == nullptr || pindexBestHeader->nChainWork < pindexNew->nChainWork) {\n         pindexBestHeader = pindexNew;\n+    }\n \n     setDirtyBlockIndex.insert(pindexNew);\n \n@@ -95,8 +96,7 @@ CBlockIndex* BlockManager::GetLastCheckpoint(const CCheckpointData& data)\n {\n     const MapCheckpoints& checkpoints = data.mapCheckpoints;\n \n-    for (const MapCheckpoints::value_type& i : reverse_iterate(checkpoints))\n-    {\n+    for (const MapCheckpoints::value_type& i : reverse_iterate(checkpoints)) {\n         const uint256& hash = i.second;\n         CBlockIndex* pindex = LookupBlockIndex(hash);\n         if (pindex) {\n@@ -127,7 +127,7 @@ void BlockManager::PruneOneBlockFile(const int fileNumber)\n             // m_blocks_unlinked or setBlockIndexCandidates.\n             auto range = m_blocks_unlinked.equal_range(pindex->pprev);\n             while (range.first != range.second) {\n-                std::multimap<CBlockIndex *, CBlockIndex *>::iterator _it = range.first;\n+                std::multimap<CBlockIndex*, CBlockIndex*>::iterator _it = range.first;\n                 range.first++;\n                 if (_it->second == pindex) {\n                     m_blocks_unlinked.erase(_it);\n@@ -222,17 +222,19 @@ void BlockManager::FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPr\n            nLastBlockWeCanPrune, count);\n }\n \n-CBlockIndex * BlockManager::InsertBlockIndex(const uint256& hash)\n+CBlockIndex* BlockManager::InsertBlockIndex(const uint256& hash)\n {\n     AssertLockHeld(cs_main);\n \n-    if (hash.IsNull())\n+    if (hash.IsNull()) {\n         return nullptr;\n+    }\n \n     // Return existing\n     BlockMap::iterator mi = m_block_index.find(hash);\n-    if (mi != m_block_index.end())\n+    if (mi != m_block_index.end()) {\n         return (*mi).second;\n+    }\n \n     // Create new\n     CBlockIndex* pindexNew = new CBlockIndex();\n@@ -252,16 +254,14 @@ bool BlockManager::LoadBlockIndex(\n     }\n \n     // Calculate nChainWork\n-    std::vector<std::pair<int, CBlockIndex*> > vSortedByHeight;\n+    std::vector<std::pair<int, CBlockIndex*>> vSortedByHeight;\n     vSortedByHeight.reserve(m_block_index.size());\n-    for (const std::pair<const uint256, CBlockIndex*>& item : m_block_index)\n-    {\n+    for (const std::pair<const uint256, CBlockIndex*>& item : m_block_index) {\n         CBlockIndex* pindex = item.second;\n         vSortedByHeight.push_back(std::make_pair(pindex->nHeight, pindex));\n     }\n     sort(vSortedByHeight.begin(), vSortedByHeight.end());\n-    for (const std::pair<int, CBlockIndex*>& item : vSortedByHeight)\n-    {\n+    for (const std::pair<int, CBlockIndex*>& item : vSortedByHeight) {\n         if (ShutdownRequested()) return false;\n         CBlockIndex* pindex = item.second;\n         pindex->nChainWork = (pindex->pprev ? pindex->pprev->nChainWork : 0) + GetBlockProof(*pindex);\n@@ -292,16 +292,18 @@ bool BlockManager::LoadBlockIndex(\n         if (pindex->nStatus & BLOCK_FAILED_MASK && (!best_invalid || pindex->nChainWork > best_invalid->nChainWork)) {\n             best_invalid = pindex;\n         }\n-        if (pindex->pprev)\n+        if (pindex->pprev) {\n             pindex->BuildSkip();\n+        }\n         if (pindex->IsValid(BLOCK_VALID_TREE) && (pindexBestHeader == nullptr || CBlockIndexWorkComparator()(pindexBestHeader, pindex)))\n             pindexBestHeader = pindex;\n     }\n \n     return true;\n }\n \n-void BlockManager::Unload() {\n+void BlockManager::Unload()\n+{\n     m_blocks_unlinked.clear();\n \n     for (const BlockMap::value_type& entry : m_block_index) {\n@@ -346,8 +348,7 @@ bool BlockManager::LoadBlockIndexDB(CBlockIndex*& best_invalid, std::set<CBlockI\n             setBlkDataFiles.insert(pindex->nFile);\n         }\n     }\n-    for (std::set<int>::iterator it = setBlkDataFiles.begin(); it != setBlkDataFiles.end(); it++)\n-    {\n+    for (std::set<int>::iterator it = setBlkDataFiles.begin(); it != setBlkDataFiles.end(); it++) {\n         FlatFilePos pos(*it, 0);\n         if (CAutoFile(OpenBlockFile(pos, true), SER_DISK, CLIENT_VERSION).IsNull()) {\n             return false;\n@@ -356,13 +357,14 @@ bool BlockManager::LoadBlockIndexDB(CBlockIndex*& best_invalid, std::set<CBlockI\n \n     // Check whether we have ever pruned block & undo files\n     m_block_tree_db->ReadFlag(\"prunedblockfiles\", fHavePruned);\n-    if (fHavePruned)\n+    if (fHavePruned) {\n         LogPrintf(\"LoadBlockIndexDB(): Block files have previously been pruned\\n\");\n+    }\n \n     // Check whether we need to continue reindexing\n     bool fReindexing = false;\n     m_block_tree_db->ReadReindexing(fReindexing);\n-    if(fReindexing) fReindex = true;\n+    if (fReindexing) fReindex = true;\n \n     return true;\n }"
      },
      {
        "sha": "089870558b73b914f724df282441ec2dba97e7a6",
        "filename": "src/node/blockstorage.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa898c657880b313028256b45baf3ad6422b18fa/src/node/blockstorage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa898c657880b313028256b45baf3ad6422b18fa/src/node/blockstorage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/blockstorage.h?ref=fa898c657880b313028256b45baf3ad6422b18fa",
        "patch": "@@ -50,9 +50,8 @@ extern uint64_t nPruneTarget;\n \n typedef std::unordered_map<uint256, CBlockIndex*, BlockHasher> BlockMap;\n \n-struct CBlockIndexWorkComparator\n-{\n-    bool operator()(const CBlockIndex *pa, const CBlockIndex *pb) const;\n+struct CBlockIndexWorkComparator {\n+    bool operator()(const CBlockIndex* pa, const CBlockIndex* pb) const;\n };\n \n /**\n@@ -132,7 +131,8 @@ class BlockManager\n     //! Returns last CBlockIndex* that is a checkpoint\n     CBlockIndex* GetLastCheckpoint(const CCheckpointData& data) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n-    ~BlockManager() {\n+    ~BlockManager()\n+    {\n         Unload();\n     }\n };"
      }
    ]
  },
  {
    "sha": "fa0ecc1bb2e57d6e11cf81074d2fd988f6e9d291",
    "node_id": "C_kwDOABII59oAKGZhMGVjYzFiYjJlNTdkNmUxMWNmODEwNzRkMmZkOTg4ZjZlOWQyOTE",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-11-24T10:56:29Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-11-25T11:34:01Z"
      },
      "message": "test: Replace int sign change suppression with cast\n\nCurrenlty the whole file is suppressed, which might fail to prevent new\nissues from being introduced. Fix that by removing the file-wide\nsuppression and replacing it with a cast in the exact place where\nneeded.",
      "tree": {
        "sha": "604974a6b04cc36dabc83fc1914620f1ad3f54b6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/604974a6b04cc36dabc83fc1914620f1ad3f54b6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa0ecc1bb2e57d6e11cf81074d2fd988f6e9d291",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUiIlwv+Nz9EOjDr9PVepimlzNT5ikgWXNhiVRNPumncI/lK31mmobeybRJSjcUs\nSCGozehMS6lozMhzozIuvTPnNBNXJp0Iwj2JINg9O9/tb68xF6YK32cfWjr5tg0x\nlbSi5P4yv40mCmikmVMFITpY7+17Fg0hRM0niIjP0Pdz65X710Ghrj2upDOrMynN\nJYqlpKU+rg6oWdMAhvRsAj+Zgcr7FvZdJwbn3BMwzblM0lOAJNN1loqPefUQfky/\nSAqmuOgUaCI6ugnuU3+ku67rkU8zNJLhkl6h1crgitcYkZk7Bs9JI57dfF7VECFz\nkZ8llyzD+xDS0PUP2L8GJ+2yX0/9UdWI2l7ZJ+jHvDtowkCAuY4bL0lbrgvKBBWg\na770oQM51FUb3pgfsAYuNy6bJxFhols7fzQSGpLgMlYMutUhsHA+nk8XYuZdgDXV\n4v1p+w7dEHwxL6lg9xTgenTRkjzTNRQgjNx21T1r5DdQUAU/JiiwaTnalHaYhLSx\nv+i+rqO7\n=z+1M\n-----END PGP SIGNATURE-----",
        "payload": "tree 604974a6b04cc36dabc83fc1914620f1ad3f54b6\nparent fa898c657880b313028256b45baf3ad6422b18fa\nauthor MarcoFalke <falke.marco@gmail.com> 1637751389 +0100\ncommitter MarcoFalke <falke.marco@gmail.com> 1637840041 +0100\n\ntest: Replace int sign change suppression with cast\n\nCurrenlty the whole file is suppressed, which might fail to prevent new\nissues from being introduced. Fix that by removing the file-wide\nsuppression and replacing it with a cast in the exact place where\nneeded.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa0ecc1bb2e57d6e11cf81074d2fd988f6e9d291",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa0ecc1bb2e57d6e11cf81074d2fd988f6e9d291",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa0ecc1bb2e57d6e11cf81074d2fd988f6e9d291/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fa898c657880b313028256b45baf3ad6422b18fa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa898c657880b313028256b45baf3ad6422b18fa",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fa898c657880b313028256b45baf3ad6422b18fa"
      }
    ],
    "stats": {
      "total": 3,
      "additions": 1,
      "deletions": 2
    },
    "files": [
      {
        "sha": "52751db59e58317a0bb467904c144790c4ef4c72",
        "filename": "src/node/blockstorage.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0ecc1bb2e57d6e11cf81074d2fd988f6e9d291/src/node/blockstorage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0ecc1bb2e57d6e11cf81074d2fd988f6e9d291/src/node/blockstorage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/blockstorage.cpp?ref=fa0ecc1bb2e57d6e11cf81074d2fd988f6e9d291",
        "patch": "@@ -173,7 +173,7 @@ void BlockManager::FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPr\n         return;\n     }\n \n-    unsigned int nLastBlockWeCanPrune = std::min(prune_height, chain_tip_height - static_cast<int>(MIN_BLOCKS_TO_KEEP));\n+    unsigned int nLastBlockWeCanPrune{(unsigned)std::min(prune_height, chain_tip_height - static_cast<int>(MIN_BLOCKS_TO_KEEP))};\n     uint64_t nCurrentUsage = CalculateCurrentUsage();\n     // We don't check to prune until after we've allocated new space for files\n     // So we should leave a buffer under our target to account for another allocation"
      },
      {
        "sha": "79a4eba1fc502ea7324a525f81d056b505e0c4cd",
        "filename": "test/sanitizer_suppressions/ubsan",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0ecc1bb2e57d6e11cf81074d2fd988f6e9d291/test/sanitizer_suppressions/ubsan",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0ecc1bb2e57d6e11cf81074d2fd988f6e9d291/test/sanitizer_suppressions/ubsan",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/sanitizer_suppressions/ubsan?ref=fa0ecc1bb2e57d6e11cf81074d2fd988f6e9d291",
        "patch": "@@ -61,7 +61,6 @@ implicit-integer-sign-change:crypto/\n implicit-integer-sign-change:FuzzedDataProvider.h\n implicit-integer-sign-change:key.cpp\n implicit-integer-sign-change:minisketch/\n-implicit-integer-sign-change:node/blockstorage.cpp\n implicit-integer-sign-change:noui.cpp\n implicit-integer-sign-change:policy/fees.cpp\n implicit-integer-sign-change:prevector.h"
      }
    ]
  }
]