[
  {
    "sha": "75e8bf55f5a014faada7712a9640dc35e8c86f15",
    "node_id": "C_kwDOABII59oAKDc1ZThiZjU1ZjVhMDE0ZmFhZGE3NzEyYTk2NDBkYzM1ZThjODZmMTU",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2021-04-26T14:22:07Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2021-11-18T12:29:23Z"
      },
      "message": "net: dedup and RAII-fy the creation of a copy of CConnman::vNodes\n\nThe following pattern was duplicated in CConnman:\n\n```cpp\nlock\ncreate a copy of vNodes, add a reference to each one\nunlock\n... use the copy ...\nlock\nrelease each node from the copy\nunlock\n```\n\nPut that code in a RAII helper that reduces it to:\n\n```cpp\ncreate snapshot \"snap\"\n... use the copy ...\n// release happens when \"snap\" goes out of scope\n```",
      "tree": {
        "sha": "e008c898e12afe42bf673a15a48de49028c0803d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e008c898e12afe42bf673a15a48de49028c0803d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/75e8bf55f5a014faada7712a9640dc35e8c86f15",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAmGWRyUACgkQVN8G9ktV\ny78KlCAAmWhmPFmVqmMsdcECSjKx0WcIrZa/+kSu5El9YxOmWD5sUBl+FQCrpfSM\nX/mufOehYFQFUcB/nUPSgaLFaFlnz8toX0EDTuiKq/IOnr4jCrTPKgqukQj+gfQg\nS2cvrTTwDokLWEQY83BBIubbcO7OVmySE4VjLIGG67euVsOvgewG+x4235+et10y\nf6oIqMLxUAuIX105P0Vuru1PaLOK41lyJ/h9i8mwNwsSW5lVNuEwWUVkwoA2sDW4\noUkxVNkd6p3t0YMo4XcieGeU6LPid/ZgVfmxp/77w3AOVBD4HPNKMGQEMghfBIeF\nHohmQtBki1bUJVHr9Sg1Ops9HM/4RtPEChkwR+R4Z1wp62nJr1wjGq73cWmlUYjv\nOvMHiJZuK4ma5IxbIYgkFUgPO2KHXn5j1P2vwByKsFC6s8hTzJwUY1soFkh7WHoF\noYeK1HM45XWth3vePCkaZ5sIyDOX8iBWYGtbqCJO1vH+rEKL0Dg16paL91u13hcJ\nOQnBdcoyuHrimuiMET1G1B38TCVbehE8ClQITzYaWe2L1xs20mh/t41e1VzqzjX3\nYDLwu4G9aflnVgM5angtPydNC3wqSsyuNyXW7utONTkT+tAEwnQAVOI81mRUrCzQ\n8aSwj4/u7cwi60LTe48OC9rjCHJs4HGbumEKCGKrwz2rqN5/sXa7o3nATSA3/EEN\n6XNnclvISQ+/E1mPUrOc1Vg22N/OD6a72CC6CQjm9tadKFbHmbzzrI1krhb6B92M\nnOSeh41ABidcPqB8EyvrsjQyVKUmxn0LQ2fcPqVxLWjXnaDvrcjd//qSDpE9G0h8\nVILP8o17ldvxCvjY3l7H6FANoga8kzzvjO1tFze7GGn3vI43eBP983VzYSrcotEA\n+7Sv8bB5H1UcfEqZ1TsmpaOq69+R+jeIzU5fkClvHKMQ/8lawZ5vS05obMLGjtZf\nNDq2FWX72qHYyGixkk7E8p8XNEOHrySqGjlgEBEu0cIQGV0Z3bctsRaJjv1GNMmZ\nSH6At0RS8tlstB3VvXwPoe4VsRIIXCg30rkldYL6QywM6rO0g07Al7E4oMtEuRf6\nzXaf662ovq+GjTx9dQJDAqdtVRBCJCp21B1ILfROK4PZKsUTxbEignDDK0G93Gkz\nPZH3JBQAnR95TPP0KfQNfWWM+O3/MsIwfVoJNkxH7r3uqu8RmQsSKGld5+b0hKEQ\nI6hxWV/UP8xPS8SHnwOvJU4+P2+jl7VlWaTBAhpNt0CrYD7emjXisYu0IytKf8Hv\nLmy2QbX+HhLcwoi2QcASZheJa4yzHY2E+tlEH+6hwjR4Zn3WpXuF4iVtDPkVCTlc\ndRyVEl+Rhe8MLCRL8j7sK2jgm4L6vQ==\n=GKjT\n-----END PGP SIGNATURE-----",
        "payload": "tree e008c898e12afe42bf673a15a48de49028c0803d\nparent b9cf505bdfade074f3d2b0473d56d2cbc2711cb3\nauthor Vasil Dimov <vd@FreeBSD.org> 1619446927 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1637238563 +0100\n\nnet: dedup and RAII-fy the creation of a copy of CConnman::vNodes\n\nThe following pattern was duplicated in CConnman:\n\n```cpp\nlock\ncreate a copy of vNodes, add a reference to each one\nunlock\n... use the copy ...\nlock\nrelease each node from the copy\nunlock\n```\n\nPut that code in a RAII helper that reduces it to:\n\n```cpp\ncreate snapshot \"snap\"\n... use the copy ...\n// release happens when \"snap\" goes out of scope\n```\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/75e8bf55f5a014faada7712a9640dc35e8c86f15",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/75e8bf55f5a014faada7712a9640dc35e8c86f15",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/75e8bf55f5a014faada7712a9640dc35e8c86f15/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b9cf505bdfade074f3d2b0473d56d2cbc2711cb3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b9cf505bdfade074f3d2b0473d56d2cbc2711cb3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b9cf505bdfade074f3d2b0473d56d2cbc2711cb3"
      }
    ],
    "stats": {
      "total": 109,
      "additions": 60,
      "deletions": 49
    },
    "files": [
      {
        "sha": "165a28c04e224b599603fc1fddfeeddb3d3b46f6",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 49,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/75e8bf55f5a014faada7712a9640dc35e8c86f15/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/75e8bf55f5a014faada7712a9640dc35e8c86f15/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=75e8bf55f5a014faada7712a9640dc35e8c86f15",
        "patch": "@@ -1513,18 +1513,12 @@ void CConnman::SocketHandler()\n         }\n     }\n \n+    const NodesSnapshot snap{*this, /*shuffle=*/false};\n+\n     //\n     // Service each socket\n     //\n-    std::vector<CNode*> vNodesCopy;\n-    {\n-        LOCK(cs_vNodes);\n-        vNodesCopy = vNodes;\n-        for (CNode* pnode : vNodesCopy)\n-            pnode->AddRef();\n-    }\n-    for (CNode* pnode : vNodesCopy)\n-    {\n+    for (CNode* pnode : snap.Nodes()) {\n         if (interruptNet)\n             return;\n \n@@ -1606,11 +1600,6 @@ void CConnman::SocketHandler()\n \n         if (InactivityCheck(*pnode)) pnode->fDisconnect = true;\n     }\n-    {\n-        LOCK(cs_vNodes);\n-        for (CNode* pnode : vNodesCopy)\n-            pnode->Release();\n-    }\n }\n \n void CConnman::ThreadSocketHandler()\n@@ -2224,49 +2213,34 @@ void CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFai\n void CConnman::ThreadMessageHandler()\n {\n     SetSyscallSandboxPolicy(SyscallSandboxPolicy::MESSAGE_HANDLER);\n-    FastRandomContext rng;\n     while (!flagInterruptMsgProc)\n     {\n-        std::vector<CNode*> vNodesCopy;\n-        {\n-            LOCK(cs_vNodes);\n-            vNodesCopy = vNodes;\n-            for (CNode* pnode : vNodesCopy) {\n-                pnode->AddRef();\n-            }\n-        }\n-\n         bool fMoreWork = false;\n \n-        // Randomize the order in which we process messages from/to our peers.\n-        // This prevents attacks in which an attacker exploits having multiple\n-        // consecutive connections in the vNodes list.\n-        Shuffle(vNodesCopy.begin(), vNodesCopy.end(), rng);\n-\n-        for (CNode* pnode : vNodesCopy)\n         {\n-            if (pnode->fDisconnect)\n-                continue;\n+            // Randomize the order in which we process messages from/to our peers.\n+            // This prevents attacks in which an attacker exploits having multiple\n+            // consecutive connections in the vNodes list.\n+            const NodesSnapshot snap{*this, /*shuffle=*/true};\n \n-            // Receive messages\n-            bool fMoreNodeWork = m_msgproc->ProcessMessages(pnode, flagInterruptMsgProc);\n-            fMoreWork |= (fMoreNodeWork && !pnode->fPauseSend);\n-            if (flagInterruptMsgProc)\n-                return;\n-            // Send messages\n-            {\n-                LOCK(pnode->cs_sendProcessing);\n-                m_msgproc->SendMessages(pnode);\n-            }\n+            for (CNode* pnode : snap.Nodes()) {\n+                if (pnode->fDisconnect)\n+                    continue;\n \n-            if (flagInterruptMsgProc)\n-                return;\n-        }\n+                // Receive messages\n+                bool fMoreNodeWork = m_msgproc->ProcessMessages(pnode, flagInterruptMsgProc);\n+                fMoreWork |= (fMoreNodeWork && !pnode->fPauseSend);\n+                if (flagInterruptMsgProc)\n+                    return;\n+                // Send messages\n+                {\n+                    LOCK(pnode->cs_sendProcessing);\n+                    m_msgproc->SendMessages(pnode);\n+                }\n \n-        {\n-            LOCK(cs_vNodes);\n-            for (CNode* pnode : vNodesCopy)\n-                pnode->Release();\n+                if (flagInterruptMsgProc)\n+                    return;\n+            }\n         }\n \n         WAIT_LOCK(mutexMsgProc, lock);"
      },
      {
        "sha": "7b97b98ae519e642e579dab3e5f5fa6f42f5fa52",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 37,
        "deletions": 0,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/75e8bf55f5a014faada7712a9640dc35e8c86f15/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/75e8bf55f5a014faada7712a9640dc35e8c86f15/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=75e8bf55f5a014faada7712a9640dc35e8c86f15",
        "patch": "@@ -1177,6 +1177,43 @@ class CConnman\n      */\n     std::vector<CService> m_onion_binds;\n \n+    /**\n+     * RAII helper to atomically create a copy of `vNodes` and add a reference\n+     * to each of the nodes. The nodes are released when this object is destroyed.\n+     */\n+    class NodesSnapshot\n+    {\n+    public:\n+        explicit NodesSnapshot(const CConnman& connman, bool shuffle)\n+        {\n+            {\n+                LOCK(connman.cs_vNodes);\n+                m_nodes_copy = connman.vNodes;\n+                for (auto& node : m_nodes_copy) {\n+                    node->AddRef();\n+                }\n+            }\n+            if (shuffle) {\n+                Shuffle(m_nodes_copy.begin(), m_nodes_copy.end(), FastRandomContext{});\n+            }\n+        }\n+\n+        ~NodesSnapshot()\n+        {\n+            for (auto& node : m_nodes_copy) {\n+                node->Release();\n+            }\n+        }\n+\n+        const std::vector<CNode*>& Nodes() const\n+        {\n+            return m_nodes_copy;\n+        }\n+\n+    private:\n+        std::vector<CNode*> m_nodes_copy;\n+    };\n+\n     friend struct CConnmanTest;\n     friend struct ConnmanTestMsg;\n };"
      }
    ]
  },
  {
    "sha": "664ac22c5379db65757fc3aab91fff8765683e7f",
    "node_id": "C_kwDOABII59oAKDY2NGFjMjJjNTM3OWRiNjU3NTdmYzNhYWI5MWZmZjg3NjU2ODNlN2Y",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2021-04-28T16:29:32Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2021-11-18T12:38:42Z"
      },
      "message": "net: keep reference to each node during socket wait\n\nCreate the snapshot of `CConnman::vNodes` to operate on earlier in\n`CConnman::SocketHandler()`, before calling `CConnman::SocketEvents()`\nand pass the `vNodes` copy from the snapshot to `SocketEvents()`.\n\nThis will keep the refcount of each node incremented during\n`SocketEvents()` so that the `CNode` object is not destroyed before\n`SocketEvents()` has finished.\n\nCurrently in `SocketEvents()` we only remember file descriptor numbers\n(when not holding `CConnman::cs_vNodes`) which is safe, but we will\nchange this to remember pointers to `CNode::m_sock`.",
      "tree": {
        "sha": "3198887177c5920ef47f4d9c3d1effc00af6da31",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3198887177c5920ef47f4d9c3d1effc00af6da31"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/664ac22c5379db65757fc3aab91fff8765683e7f",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAmGWSVQACgkQVN8G9ktV\ny7+wWB/8CH7DtaS669Mm4QKqKCYkakmVpo0tRzF9Tt0IG4xksLNPcI8LZNJ++Zlk\njklOpGP9JoaDm07KXqyxDZs84yda8Ra/RBXZ7k88z2pjfoDNZOirIH3xzuyFtxVC\n/adW7Gqt76wcIAjTkqHoUcuuRocH+zrPo9A0OuHYCwzoUHLDlXCV5w1njGJQ0gPp\n81vGO51iWQQdQT+IkQ22/1HJ5Q6WSvzaXtz9wa70Lv4Dhj9sHW5B5luSLFeKZpIE\nAMZiXBNUCCUH6t1XWbRFs3iYLh0lvF02oRVKFbSPMqMYTTAeH4MZ/DLS6VJkcmQP\n7T5uzuPnY7u2g+NqEndKmc0HFWyKM5adhy9gWdRZN+xi3GcFnVKtlUEOgK85Wkfn\n0LiMGlSOJ8B2SLgXlvsVbm6/+Rwn1u8VaJOMBOFulh2+8LdDCww6aFQV16HX4FgG\nZWhlODzqClWFWH0fdhByldYUW//aJeEydgfbi/s7mBNQ8tQKJrbC0NmVEzzQD/UF\nARZgqKj3TkkIGb+uxiE7z0XT5hcs50vK44N2XRjh0cDgW0FC7BGAMsUKJ34cfqoB\nPsF/roHAziB9fU1K6ck3SuCVYo4moz2cUYrWttJP6b/v/GjtV7gAaxhUBX16m64E\nyTEHS7UCFag5GbSC5DfZkrLDrs1pMHjUrH70Fv9rSivv7TEzqItkJO/cY8HsbAY2\nzCZ/TPQoyZd/xPo6t8gZIJ26r4Z+TVOdzuGBbsh7BStswEBrnDLMXYkP2ziJ0alH\n2mC2YWPb6Q2fdvh4kzbdxsZc24m//ZY0TPyviOX+kpHQgkRKmalD5WgCY6MP0fAU\nTPD1DOIIK1hJxGLGga4R705Nwv7k/4ilI3HVtTnHdPpbvOfpKM6CGnRRNyLI56X0\nuh5d1xGkqefJE0wJ56OYZAz8mhrvN+/dgJZhtjjj5UUT+4Sm4ta/dNbxvlW+lhyx\nozpPGvh7FBgXA6y5gsFl+/LQrczwUtXeln9O5BonIfMg+QyXouNl8EnEHvtnfIUU\n/Q4qkGmXWr5ipkVOraewZRD9fXOAGWd2JcScNp57Z/npfl07HdF9VqhL8SQFNCQ0\nMKP1z//OKgd5Jp4/WEo9F7A/CkKRzdSVzf7pWkTmZLZMEYJ+M5Z/+zq4huDCbnTB\nOdqJVL0uHQsyoKfLqTVLJ8mLs5yY0BQHdKcoQ2vGAr0JEnhcU+7jnBoiOJddngsw\niNf8Yj3XW1nxKUtedzIUjjO4lEin/Deqe+QRrYvZ91ntJccT2UU0mJUakYedzZq9\nM9SfO6P7fKFvEkLM2LWUE4ZdhTGW5VV2XTNnZzIFkix4ZqPgktPTtt2HZ72ajI3S\nvTzqvfDeCqFAEcxV8Ezl8T18AFFUDg==\n=wcki\n-----END PGP SIGNATURE-----",
        "payload": "tree 3198887177c5920ef47f4d9c3d1effc00af6da31\nparent 75e8bf55f5a014faada7712a9640dc35e8c86f15\nauthor Vasil Dimov <vd@FreeBSD.org> 1619627372 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1637239122 +0100\n\nnet: keep reference to each node during socket wait\n\nCreate the snapshot of `CConnman::vNodes` to operate on earlier in\n`CConnman::SocketHandler()`, before calling `CConnman::SocketEvents()`\nand pass the `vNodes` copy from the snapshot to `SocketEvents()`.\n\nThis will keep the refcount of each node incremented during\n`SocketEvents()` so that the `CNode` object is not destroyed before\n`SocketEvents()` has finished.\n\nCurrently in `SocketEvents()` we only remember file descriptor numbers\n(when not holding `CConnman::cs_vNodes`) which is safe, but we will\nchange this to remember pointers to `CNode::m_sock`.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/664ac22c5379db65757fc3aab91fff8765683e7f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/664ac22c5379db65757fc3aab91fff8765683e7f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/664ac22c5379db65757fc3aab91fff8765683e7f/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "75e8bf55f5a014faada7712a9640dc35e8c86f15",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/75e8bf55f5a014faada7712a9640dc35e8c86f15",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/75e8bf55f5a014faada7712a9640dc35e8c86f15"
      }
    ],
    "stats": {
      "total": 58,
      "additions": 45,
      "deletions": 13
    },
    "files": [
      {
        "sha": "6fab80f97662fbbf64965072fe96c88d0d9c0d13",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 11,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/664ac22c5379db65757fc3aab91fff8765683e7f/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/664ac22c5379db65757fc3aab91fff8765683e7f/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=664ac22c5379db65757fc3aab91fff8765683e7f",
        "patch": "@@ -1331,16 +1331,17 @@ bool CConnman::InactivityCheck(const CNode& node) const\n     return false;\n }\n \n-bool CConnman::GenerateSelectSet(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+bool CConnman::GenerateSelectSet(const std::vector<CNode*>& nodes,\n+                                 std::set<SOCKET>& recv_set,\n+                                 std::set<SOCKET>& send_set,\n+                                 std::set<SOCKET>& error_set)\n {\n     for (const ListenSocket& hListenSocket : vhListenSocket) {\n         recv_set.insert(hListenSocket.socket);\n     }\n \n     {\n-        LOCK(cs_vNodes);\n-        for (CNode* pnode : vNodes)\n-        {\n+        for (CNode* pnode : nodes) {\n             // Implement the following logic:\n             // * If there is data to send, select() for sending data. As this only\n             //   happens when optimistic write failed, we choose to first drain the\n@@ -1378,10 +1379,13 @@ bool CConnman::GenerateSelectSet(std::set<SOCKET> &recv_set, std::set<SOCKET> &s\n }\n \n #ifdef USE_POLL\n-void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+void CConnman::SocketEvents(const std::vector<CNode*>& nodes,\n+                            std::set<SOCKET>& recv_set,\n+                            std::set<SOCKET>& send_set,\n+                            std::set<SOCKET>& error_set)\n {\n     std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n-    if (!GenerateSelectSet(recv_select_set, send_select_set, error_select_set)) {\n+    if (!GenerateSelectSet(nodes, recv_select_set, send_select_set, error_select_set)) {\n         interruptNet.sleep_for(std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS));\n         return;\n     }\n@@ -1420,10 +1424,13 @@ void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_s\n     }\n }\n #else\n-void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+void CConnman::SocketEvents(const std::vector<CNode*>& nodes,\n+                            std::set<SOCKET>& recv_set,\n+                            std::set<SOCKET>& send_set,\n+                            std::set<SOCKET>& error_set)\n {\n     std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n-    if (!GenerateSelectSet(recv_select_set, send_select_set, error_select_set)) {\n+    if (!GenerateSelectSet(nodes, recv_select_set, send_select_set, error_select_set)) {\n         interruptNet.sleep_for(std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS));\n         return;\n     }\n@@ -1497,8 +1504,10 @@ void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_s\n \n void CConnman::SocketHandler()\n {\n+    const NodesSnapshot snap{*this, /*shuffle=*/false};\n+\n     std::set<SOCKET> recv_set, send_set, error_set;\n-    SocketEvents(recv_set, send_set, error_set);\n+    SocketEvents(snap.Nodes(), recv_set, send_set, error_set);\n \n     if (interruptNet) return;\n \n@@ -1513,8 +1522,6 @@ void CConnman::SocketHandler()\n         }\n     }\n \n-    const NodesSnapshot snap{*this, /*shuffle=*/false};\n-\n     //\n     // Service each socket\n     //"
      },
      {
        "sha": "f03883ca54424d69c9751ea84934e558fca82d42",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 27,
        "deletions": 2,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/664ac22c5379db65757fc3aab91fff8765683e7f/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/664ac22c5379db65757fc3aab91fff8765683e7f/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=664ac22c5379db65757fc3aab91fff8765683e7f",
        "patch": "@@ -983,8 +983,33 @@ class CConnman\n     void NotifyNumConnectionsChanged();\n     /** Return true if the peer is inactive and should be disconnected. */\n     bool InactivityCheck(const CNode& node) const;\n-    bool GenerateSelectSet(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set);\n-    void SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set);\n+\n+    /**\n+     * Generate a collection of sockets to check for IO readiness.\n+     * @param[in] nodes Select from these nodes' sockets.\n+     * @param[out] recv_set Sockets to check for read readiness.\n+     * @param[out] send_set Sockets to check for write readiness.\n+     * @param[out] error_set Sockets to check for errors.\n+     * @return true if at least one socket is to be checked (the returned set is not empty)\n+     */\n+    bool GenerateSelectSet(const std::vector<CNode*>& nodes,\n+                           std::set<SOCKET>& recv_set,\n+                           std::set<SOCKET>& send_set,\n+                           std::set<SOCKET>& error_set);\n+\n+    /**\n+     * Check which sockets are ready for IO.\n+     * @param[in] nodes Select from these nodes' sockets.\n+     * @param[out] recv_set Sockets which are ready for read.\n+     * @param[out] send_set Sockets which are ready for write.\n+     * @param[out] error_set Sockets which have errors.\n+     * This calls `GenerateSelectSet()` to gather a list of sockets to check.\n+     */\n+    void SocketEvents(const std::vector<CNode*>& nodes,\n+                      std::set<SOCKET>& recv_set,\n+                      std::set<SOCKET>& send_set,\n+                      std::set<SOCKET>& error_set);\n+\n     void SocketHandler();\n     void ThreadSocketHandler();\n     void ThreadDNSAddressSeed();"
      }
    ]
  },
  {
    "sha": "c7eb19ec8302e6a5abd89c0566540c2c862e9121",
    "node_id": "C_kwDOABII59oAKGM3ZWIxOWVjODMwMmU2YTVhYmQ4OWMwNTY2NTQwYzJjODYyZTkxMjE",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2021-10-25T11:49:33Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2021-11-18T12:39:09Z"
      },
      "message": "style: remove unnecessary braces\n\nThey were needed to define the scope of `LOCK(cs_vNodes)` which was\nremoved in the previous commit. Re-indent in a separate commit to ease\nreview (use `--ignore-space-change`).",
      "tree": {
        "sha": "de33d628e8a36e11ef302e2fc71a9bd9963167a4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/de33d628e8a36e11ef302e2fc71a9bd9963167a4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c7eb19ec8302e6a5abd89c0566540c2c862e9121",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAmGWSW0ACgkQVN8G9ktV\ny7+V4R/+Mf0Tfp2oKfE7u9J11hBMTiCwjNXwn7KqbBNXEIrOhlw6BRyKINESgge9\nLXQ/oHKK3w3CujJESlhKGroOQldsmY/emImuuLC5nfW+D66jvc20two8jS7tR8Sk\nZeSLaCvm4tKWVstRoG5y8+iSmllCRYzpH0kZXgnJ+qaYxEtmDMt1QD6B11ppse5I\nw96mfjHeRAAgvLT3VcKuIO1UhaufZzmT3jzpMeglX9XfK2aDElygdoGSUVWOKshY\ncTSLrPzBx2q/vGNSBRm+bjf2dS83WEXoq+yTrWE/+t6xWOzxWQ/KjOUjUV5Qb9CG\nbvu3hRn/P1HHmiEvxyU/Lk5lN2lPEDF62YgxNLp52zqt1q65yKTH7I5w/1bHAEEn\n4kY0L1/wr435ZHYfSDL2Qr3QWsQWWyve388prhm/Pl8IXM5Pmc3O4aCHp1DhywV7\nkp2dFGUJsNzQ4b+Cy9ctH51gfpOE5VuRz1RMuRWnMSYsxQJ9uTt8PQLonTgM3Tnn\ntnNc96xGAiafEUhSUCk5YMkfCCQWeomNuu8WX6kdoqjDMHtwdAkqklOdtikeBO/K\ngITorXmSYxnnS3Qn+VJSx31p6nWS2zvZ5VG5I3yXlTFwfkxwEqtedD0+h5OoZ/WJ\naB/bS+OkYJpAjVWY0eZFEuMt9WLyrKcyFq7h6uGLjNxSAdVMWFqjnLvmIjkDcnGL\nMUX4AZ8mnwGRHLNHkx3ixsQq+OpThNwK1NXyAwuvTh5PAqNpf1ZUTMCdh5V8GZGA\n0jKMrtuIJMk1vyBtJmJT6tInsPz+JnMMue7lbxf1+fOV28dSRdBa7sWvl5LXRy/y\no4U6yvfd7ZNXy7/fFi1birGN+/alnyL4M/o/q5tW9Q1O+EM1EtrUQZt2NFWd/KM8\nY0ArWrg1T9ryv6kgIYB7rIcJcdu7VBb1562e7DERO488Sxm1b185JwcL1mnRTVaK\nYbkGZ5RPXa9pd7JfmPIyAYbm+sC4UuzA5pwbr+yq1EZvQN3HsS9u1lUW5ElTb9X6\n/4bzOPsYmQ/o7LUdmIeAoDPmY5t7E5nm7dO4HSLeZ/kQFVdRKvnm6++K4OYHvbpS\n2yBC7kP0ysleib2/X1VINbTbLrnT8O1yrjTaQb3yU+VvQCo0In6mIxKgIbg6hch3\nm5GMAYbAFxE2Z3LPF7fFlhmBAWrZ2z0uKDF29l900bjowl2xXaiyVYlEu3a9QMj9\nkdcw1GWpYSx0OrMU8mF3b2MyiQCytxDqwvg0USgrYnU9yYFWUTWzEIY0hUSp7QqM\nCmsITvXHC+VlAkI7VPVVHjgJsMP/UMfv20fWOYHUMbjjAE3jxLKypNaL4uAEAXIq\nuLMZgFHxYICkPasU4W3MzcsDFV1O8Q==\n=nPBo\n-----END PGP SIGNATURE-----",
        "payload": "tree de33d628e8a36e11ef302e2fc71a9bd9963167a4\nparent 664ac22c5379db65757fc3aab91fff8765683e7f\nauthor Vasil Dimov <vd@FreeBSD.org> 1635162573 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1637239149 +0100\n\nstyle: remove unnecessary braces\n\nThey were needed to define the scope of `LOCK(cs_vNodes)` which was\nremoved in the previous commit. Re-indent in a separate commit to ease\nreview (use `--ignore-space-change`).\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c7eb19ec8302e6a5abd89c0566540c2c862e9121",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c7eb19ec8302e6a5abd89c0566540c2c862e9121",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c7eb19ec8302e6a5abd89c0566540c2c862e9121/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "664ac22c5379db65757fc3aab91fff8765683e7f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/664ac22c5379db65757fc3aab91fff8765683e7f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/664ac22c5379db65757fc3aab91fff8765683e7f"
      }
    ],
    "stats": {
      "total": 58,
      "additions": 28,
      "deletions": 30
    },
    "files": [
      {
        "sha": "610a795c64a995ed37c5927fbdb92561a5df1d44",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 30,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c7eb19ec8302e6a5abd89c0566540c2c862e9121/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c7eb19ec8302e6a5abd89c0566540c2c862e9121/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=c7eb19ec8302e6a5abd89c0566540c2c862e9121",
        "patch": "@@ -1340,38 +1340,36 @@ bool CConnman::GenerateSelectSet(const std::vector<CNode*>& nodes,\n         recv_set.insert(hListenSocket.socket);\n     }\n \n-    {\n-        for (CNode* pnode : nodes) {\n-            // Implement the following logic:\n-            // * If there is data to send, select() for sending data. As this only\n-            //   happens when optimistic write failed, we choose to first drain the\n-            //   write buffer in this case before receiving more. This avoids\n-            //   needlessly queueing received data, if the remote peer is not themselves\n-            //   receiving data. This means properly utilizing TCP flow control signalling.\n-            // * Otherwise, if there is space left in the receive buffer, select() for\n-            //   receiving data.\n-            // * Hand off all complete messages to the processor, to be handled without\n-            //   blocking here.\n-\n-            bool select_recv = !pnode->fPauseRecv;\n-            bool select_send;\n-            {\n-                LOCK(pnode->cs_vSend);\n-                select_send = !pnode->vSendMsg.empty();\n-            }\n+    for (CNode* pnode : nodes) {\n+        // Implement the following logic:\n+        // * If there is data to send, select() for sending data. As this only\n+        //   happens when optimistic write failed, we choose to first drain the\n+        //   write buffer in this case before receiving more. This avoids\n+        //   needlessly queueing received data, if the remote peer is not themselves\n+        //   receiving data. This means properly utilizing TCP flow control signalling.\n+        // * Otherwise, if there is space left in the receive buffer, select() for\n+        //   receiving data.\n+        // * Hand off all complete messages to the processor, to be handled without\n+        //   blocking here.\n+\n+        bool select_recv = !pnode->fPauseRecv;\n+        bool select_send;\n+        {\n+            LOCK(pnode->cs_vSend);\n+            select_send = !pnode->vSendMsg.empty();\n+        }\n \n-            LOCK(pnode->cs_hSocket);\n-            if (pnode->hSocket == INVALID_SOCKET)\n-                continue;\n+        LOCK(pnode->cs_hSocket);\n+        if (pnode->hSocket == INVALID_SOCKET)\n+            continue;\n \n-            error_set.insert(pnode->hSocket);\n-            if (select_send) {\n-                send_set.insert(pnode->hSocket);\n-                continue;\n-            }\n-            if (select_recv) {\n-                recv_set.insert(pnode->hSocket);\n-            }\n+        error_set.insert(pnode->hSocket);\n+        if (select_send) {\n+            send_set.insert(pnode->hSocket);\n+            continue;\n+        }\n+        if (select_recv) {\n+            recv_set.insert(pnode->hSocket);\n         }\n     }\n "
      }
    ]
  },
  {
    "sha": "f52b6b2d9f482353821da0ef4c485c402a396c8d",
    "node_id": "C_kwDOABII59oAKGY1MmI2YjJkOWY0ODIzNTM4MjFkYTBlZjRjNDg1YzQwMmEzOTZjOGQ",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2021-10-25T09:03:58Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2021-11-18T12:39:10Z"
      },
      "message": "net: split CConnman::SocketHandler()\n\n`CConnman::SocketHandler()` does 3 things:\n1. Check sockets for readiness\n2. Process ready listening sockets\n3. Process ready connected sockets\n\nSplit the processing (2. and 3.) into separate methods to make the code\neasier to grasp.\n\nAlso, move the processing of listening sockets after the processing of\nconnected sockets to make it obvious that there is no dependency and\nalso explicitly release the snapshot before dealing with listening\nsockets - it is only necessary for the connected sockets part.",
      "tree": {
        "sha": "71100049a61ca06f6eebb7570d2ef765ac1f4f01",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/71100049a61ca06f6eebb7570d2ef765ac1f4f01"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f52b6b2d9f482353821da0ef4c485c402a396c8d",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAmGWSW4ACgkQVN8G9ktV\ny79FUR/+Mmaz1txYV5wgGc+BiuIYyLQoLpk52rkduCjGYoAZW2LLXssYKZV+LPrI\nawmCIJmPCQCc1NWKL1MS/B89RO1VkeXt+Cg0zMM+f2jHpCBYfUIyDV2Of84WbN9T\n57BffayIABsq9p1JqI2QKP4L9v/ftZHxVcwFsUrWJlt2npNgD/ik0sleV+9Y5dBj\ndOgywZnVQJNnPwdNNowGCXXE2rsHc/dlUeAT/U8OCCx9i9HORxMgL9eV7jqHxyZs\npvRqUz3dgTUr1F0ROMOi8tw1rcyWbkbNb/yFsLiAmDQ8rGw4zDH9X1GIa5Xlm1Ox\nHfoiS12jK0oSPCsZIHiVIUUCelQ4No8gsw/FPAaL4bQBmHvYKOfx3dxZ63CJqnoE\nN3t1rXpCV/PxMZF2crrxTgDChJX6zUsDKjg9Qdw+HEob3RpwOTM58ShxwLfHn31T\nvWa+BVsE68UvGrOVB+Sh3eeYb663gudsydTgE17wokdmdJxymDsVuestrDGbLMSM\nAZKPh+B3CkpBtEleH8+fSqCx1D3xBTEyFOEiOtl0a/NBQ77gvUHcOr7SpIUQLGap\nXy7kw1hHFo2xqRLWIbCD1QbBq57uIDDv1tqjuM5/7zxfgNWZzuRwenNDJthLduTU\nlc5V2MWzxm6SZ09IBZ5l96nPQqpLIuAAGC8EAf5xY86zpAlSYODHaXyuKljVvY+q\nNa88o2TyocsEXn9Q9rKocjTitJnEwlO5OY+qFJVY/7OnzYSjG2K9154LWcUY9oMf\naVI4gPAPCShSOx6VjrLAv3to4/5JAzhBTKvW2cyJV6m0ejBa2J10rt8wHJT4uh2K\nvBys4ZlQGf75L8AakYmOgTGFBIUanTg0/vYsjkQ2dfIjJdeDrU6r+4cYnEaqziM9\nFImidpx6WI/yGvvhHPSLxLmNLJroOH7qfHdOo+YfAj8CawmEf2QZ1LYRFk54bBEm\nozgAYb551xnsF5INEiZtwVVR6e3HcgN7Mu5NO9mWUxAQPdKd70A7ZbnP7yr71/zZ\nZsfH9HCuCAkVa41hOCcxqVg9O/w4r4TTluth1TK5WQGNH2cOblZ3e7PU+oAH1RTx\nqu+mhfPt3ZtqwUqAPUdX4Ba6cZ6+g+mJ6UkJ7FQwn7XY7hiIMZslkhxOvxk+hle4\nKPyxuj74EbnghFO1Y4mh6CZs8JC+UPUe150TevYVTlbazzCE9Ul6QC6YHstwcEgM\n0khyC4pna2gc3oYO7Pis2Ma+maX+RHFnMSjC//Boyx9SbMtPHADfPMQSMLw4ztr6\nFQR2xU91joiS1MGWA06N1nD1b+xHUcalZKdIR8c4ZabH++UrD5A3Pttqd9WAHThb\n5h9YvM4uqehvi1pAX8SQgzv4xnQ/nw==\n=HOOy\n-----END PGP SIGNATURE-----",
        "payload": "tree 71100049a61ca06f6eebb7570d2ef765ac1f4f01\nparent c7eb19ec8302e6a5abd89c0566540c2c862e9121\nauthor Vasil Dimov <vd@FreeBSD.org> 1635152638 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1637239150 +0100\n\nnet: split CConnman::SocketHandler()\n\n`CConnman::SocketHandler()` does 3 things:\n1. Check sockets for readiness\n2. Process ready listening sockets\n3. Process ready connected sockets\n\nSplit the processing (2. and 3.) into separate methods to make the code\neasier to grasp.\n\nAlso, move the processing of listening sockets after the processing of\nconnected sockets to make it obvious that there is no dependency and\nalso explicitly release the snapshot before dealing with listening\nsockets - it is only necessary for the connected sockets part.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f52b6b2d9f482353821da0ef4c485c402a396c8d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f52b6b2d9f482353821da0ef4c485c402a396c8d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f52b6b2d9f482353821da0ef4c485c402a396c8d/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c7eb19ec8302e6a5abd89c0566540c2c862e9121",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c7eb19ec8302e6a5abd89c0566540c2c862e9121",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c7eb19ec8302e6a5abd89c0566540c2c862e9121"
      }
    ],
    "stats": {
      "total": 74,
      "additions": 57,
      "deletions": 17
    },
    "files": [
      {
        "sha": "652bdb36b644d240699676c9d2c58abdf6ec4e94",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 34,
        "deletions": 17,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f52b6b2d9f482353821da0ef4c485c402a396c8d/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f52b6b2d9f482353821da0ef4c485c402a396c8d/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=f52b6b2d9f482353821da0ef4c485c402a396c8d",
        "patch": "@@ -1502,28 +1502,33 @@ void CConnman::SocketEvents(const std::vector<CNode*>& nodes,\n \n void CConnman::SocketHandler()\n {\n-    const NodesSnapshot snap{*this, /*shuffle=*/false};\n+    std::set<SOCKET> recv_set;\n+    std::set<SOCKET> send_set;\n+    std::set<SOCKET> error_set;\n \n-    std::set<SOCKET> recv_set, send_set, error_set;\n-    SocketEvents(snap.Nodes(), recv_set, send_set, error_set);\n+    {\n+        const NodesSnapshot snap{*this, /*shuffle=*/false};\n \n-    if (interruptNet) return;\n+        // Check for the readiness of the already connected sockets and the\n+        // listening sockets in one call (\"readiness\" as in poll(2) or\n+        // select(2)). If none are ready, wait for a short while and return\n+        // empty sets.\n+        SocketEvents(snap.Nodes(), recv_set, send_set, error_set);\n \n-    //\n-    // Accept new connections\n-    //\n-    for (const ListenSocket& hListenSocket : vhListenSocket)\n-    {\n-        if (hListenSocket.socket != INVALID_SOCKET && recv_set.count(hListenSocket.socket) > 0)\n-        {\n-            AcceptConnection(hListenSocket);\n-        }\n+        // Service (send/receive) each of the already connected nodes.\n+        SocketHandlerConnected(snap.Nodes(), recv_set, send_set, error_set);\n     }\n \n-    //\n-    // Service each socket\n-    //\n-    for (CNode* pnode : snap.Nodes()) {\n+    // Accept new connections from listening sockets.\n+    SocketHandlerListening(recv_set);\n+}\n+\n+void CConnman::SocketHandlerConnected(const std::vector<CNode*>& nodes,\n+                                      const std::set<SOCKET>& recv_set,\n+                                      const std::set<SOCKET>& send_set,\n+                                      const std::set<SOCKET>& error_set)\n+{\n+    for (CNode* pnode : nodes) {\n         if (interruptNet)\n             return;\n \n@@ -1607,6 +1612,18 @@ void CConnman::SocketHandler()\n     }\n }\n \n+void CConnman::SocketHandlerListening(const std::set<SOCKET>& recv_set)\n+{\n+    for (const ListenSocket& listen_socket : vhListenSocket) {\n+        if (interruptNet) {\n+            return;\n+        }\n+        if (listen_socket.socket != INVALID_SOCKET && recv_set.count(listen_socket.socket) > 0) {\n+            AcceptConnection(listen_socket);\n+        }\n+    }\n+}\n+\n void CConnman::ThreadSocketHandler()\n {\n     SetSyscallSandboxPolicy(SyscallSandboxPolicy::NET);"
      },
      {
        "sha": "e8de0265730c53c5871e11948296a341f7201845",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f52b6b2d9f482353821da0ef4c485c402a396c8d/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f52b6b2d9f482353821da0ef4c485c402a396c8d/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=f52b6b2d9f482353821da0ef4c485c402a396c8d",
        "patch": "@@ -1010,7 +1010,30 @@ class CConnman\n                       std::set<SOCKET>& send_set,\n                       std::set<SOCKET>& error_set);\n \n+    /**\n+     * Check connected and listening sockets for IO readiness and process them accordingly.\n+     */\n     void SocketHandler();\n+\n+    /**\n+     * Do the read/write for connected sockets that are ready for IO.\n+     * @param[in] nodes Nodes to process. The socket of each node is checked against\n+     * `recv_set`, `send_set` and `error_set`.\n+     * @param[in] recv_set Sockets that are ready for read.\n+     * @param[in] send_set Sockets that are ready for send.\n+     * @param[in] error_set Sockets that have an exceptional condition (error).\n+     */\n+    void SocketHandlerConnected(const std::vector<CNode*>& nodes,\n+                                const std::set<SOCKET>& recv_set,\n+                                const std::set<SOCKET>& send_set,\n+                                const std::set<SOCKET>& error_set);\n+\n+    /**\n+     * Accept incoming connections, one from each read-ready listening socket.\n+     * @param[in] recv_set Sockets that are ready for read.\n+     */\n+    void SocketHandlerListening(const std::set<SOCKET>& recv_set);\n+\n     void ThreadSocketHandler();\n     void ThreadDNSAddressSeed();\n "
      }
    ]
  }
]