[
  {
    "sha": "c8abbc9d1fd8f77b5dcf31cf7a6dd6aac5d1c75c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjOGFiYmM5ZDFmZDhmNzdiNWRjZjMxY2Y3YTZkZDZhYWM1ZDFjNzVj",
    "commit": {
      "author": {
        "name": "Jon Atack",
        "email": "jon@atack.com",
        "date": "2020-10-15T22:18:44Z"
      },
      "committer": {
        "name": "Jon Atack",
        "email": "jon@atack.com",
        "date": "2020-10-16T21:33:44Z"
      },
      "message": "p2p: declare Announcement::m_state as uint8_t, add getter/setter\n\nto silence these Travis CI GCC compiler warnings:\n\ntxrequest.cpp:73:21: warning: \u2018{anonymous}::Announcement::m_state\u2019 is\ntoo small to hold all values of \u2018enum class {anonymous}::State\u2019\n     State m_state : 3;\n                     ^\nThe warnings are based on the maximum value held by the underlying uint8_t\nenumerator type, though the intention of the bitfield declaration is the\nmaximum declared enumerator value.\n\nThe warning been silenced in GCC 8.4+ and 9.3+ according to\nhttps://gcc.gnu.org/bugzilla/show_bug.cgi?id=61414",
      "tree": {
        "sha": "d5c43cceb08852dfd47b17b7a74ec7c47dc00b8a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d5c43cceb08852dfd47b17b7a74ec7c47dc00b8a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c8abbc9d1fd8f77b5dcf31cf7a6dd6aac5d1c75c",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEd6u7+MhX7zEv6RP5T1chs9Djkh0FAl+KEgwACgkQT1chs9Dj\nkh2chQ/+PkIXGTvcirfrcHpe4Zi/yJ/4P9E7RHlAQo0ko/jFbmVVswBBSbsA3BVJ\nxXnaPhkE2GyPepl+14iWw/S3DEFUpk+gJCRZqMqx6Qdloh6dI5BatqOd+TGHjCOS\npvbXAdr+mmUEePy0sFCqY8xtX+bUijM0mejolOSrOROLZZZ9ivGalew5yY6JrurJ\ndw69pDV124OKsjoGFEfo5395T2ie2b5+uUzHO2sBfInVbjX0wKVPYhfWX4hdLWSz\n1J5emIKlbI0b5EbWpaElXxxUnavap7f1pJF7LIE7HQ14MdeGCzOK8gpsvT8wBm7z\nrl6GjV6efcFqy1+jEmx5Ss4T0DD1yZ1BpC8SexaZT3e4b2E7uE3F09dyq2LygXyW\nw/MLxKw5/R3MVNu7jnmrG0LuIxH9Uz32PQ6DbaKxnEncbTTKSg6VqNFS15dD4MBF\nOXQMPoZs74LfA17mY2e5ssQqCvmruSvHvTLOXTEtamJ5KodzqrsiZSAoN1H7QhR6\niBCyZ8GpAzLx9TJziaS6zRjQNqsvD7oxyYnkVjfrMavHZd8daSmZFm0eKSWp4SXm\nG+9jW4pFJMmhXylxKAoj+/etZkw4MD3J5XlQgt+d+8J2pUjF9apP3sVT5SN7sQcg\nbF8uOBUzOqF1z7CNdG43rF8Sm7YdTeoZiKGBX5YiQ8xJtO+GTl8=\n=W7an\n-----END PGP SIGNATURE-----\n-----BEGIN OPENTIMESTAMPS GIT TIMESTAMP-----\n\nAQHwIIZGMbs212gmwwRobbfVplyE26u6XzzmPp2bV1E1GZIkCP/wEA1QLPhMtP13\nk0nx4lrZVEkI8QRfihIO8Ahw8xv/+pwuJACD3+MNLvkMjiMiaHR0cHM6Ly9idGMu\nY2FsZW5kYXIuY2F0YWxsYXh5LmNvbf/wEBI6hiIlZVC/ktWm80MosAAI8QRfihIO\n8AhBnnjuZOFWSgCD3+MNLvkMjiwraHR0cHM6Ly9ib2IuYnRjLmNhbGVuZGFyLm9w\nZW50aW1lc3RhbXBzLm9yZ//wEGPWUmOp1T+shtK5gA/IJ98I8QRfihIP8AiTR745\nSOkArwCD3+MNLvkMjikoaHR0cHM6Ly9maW5uZXkuY2FsZW5kYXIuZXRlcm5pdHl3\nYWxsLmNvbfAQbsoHzqBdjjAbofIC6Fxw+wjxBF+KEg7wCOoWpf60Ee8WAIPf4w0u\n+QyOLi1odHRwczovL2FsaWNlLmJ0Yy5jYWxlbmRhci5vcGVudGltZXN0YW1wcy5v\ncmc=\n-----END OPENTIMESTAMPS GIT TIMESTAMP-----",
        "payload": "tree d5c43cceb08852dfd47b17b7a74ec7c47dc00b8a\nparent 0d22482353752ebfb11aa29f4b26113b817a448a\nauthor Jon Atack <jon@atack.com> 1602800324 +0200\ncommitter Jon Atack <jon@atack.com> 1602884024 +0200\n\np2p: declare Announcement::m_state as uint8_t, add getter/setter\n\nto silence these Travis CI GCC compiler warnings:\n\ntxrequest.cpp:73:21: warning: \u2018{anonymous}::Announcement::m_state\u2019 is\ntoo small to hold all values of \u2018enum class {anonymous}::State\u2019\n     State m_state : 3;\n                     ^\nThe warnings are based on the maximum value held by the underlying uint8_t\nenumerator type, though the intention of the bitfield declaration is the\nmaximum declared enumerator value.\n\nThe warning been silenced in GCC 8.4+ and 9.3+ according to\nhttps://gcc.gnu.org/bugzilla/show_bug.cgi?id=61414\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c8abbc9d1fd8f77b5dcf31cf7a6dd6aac5d1c75c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c8abbc9d1fd8f77b5dcf31cf7a6dd6aac5d1c75c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c8abbc9d1fd8f77b5dcf31cf7a6dd6aac5d1c75c/comments",
    "author": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0d22482353752ebfb11aa29f4b26113b817a448a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0d22482353752ebfb11aa29f4b26113b817a448a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0d22482353752ebfb11aa29f4b26113b817a448a"
      }
    ],
    "stats": {
      "total": 100,
      "additions": 54,
      "deletions": 46
    },
    "files": [
      {
        "sha": "09eb78e927331822c16d6afbbec1a20fec4506cd",
        "filename": "src/txrequest.cpp",
        "status": "modified",
        "additions": 54,
        "deletions": 46,
        "changes": 100,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c8abbc9d1fd8f77b5dcf31cf7a6dd6aac5d1c75c/src/txrequest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c8abbc9d1fd8f77b5dcf31cf7a6dd6aac5d1c75c/src/txrequest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txrequest.cpp?ref=c8abbc9d1fd8f77b5dcf31cf7a6dd6aac5d1c75c",
        "patch": "@@ -69,32 +69,40 @@ struct Announcement {\n     /** Whether this is a wtxid request. */\n     const bool m_is_wtxid : 1;\n \n-    /** What state this announcement is in. */\n-    State m_state : 3;\n+    /** What state this announcement is in.\n+     *  This is a uint8_t instead of a State to silence a GCC warning in versions prior to 8.4 and 9.3.\n+     *  See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61414 */\n+    uint8_t m_state : 3;\n+\n+    /** Convert m_state to a State enum. */\n+    State GetState() const { return static_cast<State>(m_state); }\n+\n+    /** Convert a State enum to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = static_cast<uint8_t>(state); }\n \n     /** Whether this announcement is selected. There can be at most 1 selected peer per txhash. */\n     bool IsSelected() const\n     {\n-        return m_state == State::CANDIDATE_BEST || m_state == State::REQUESTED;\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n     }\n \n     /** Whether this announcement is waiting for a certain time to pass. */\n     bool IsWaiting() const\n     {\n-        return m_state == State::REQUESTED || m_state == State::CANDIDATE_DELAYED;\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n     }\n \n     /** Whether this announcement can feasibly be selected if the current IsSelected() one disappears. */\n     bool IsSelectable() const\n     {\n-        return m_state == State::CANDIDATE_READY || m_state == State::CANDIDATE_BEST;\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n     }\n \n     /** Construct a new announcement from scratch, initially in CANDIDATE_DELAYED state. */\n     Announcement(const GenTxid& gtxid, NodeId peer, bool preferred, std::chrono::microseconds reqtime,\n         SequenceNumber sequence) :\n         m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n-        m_is_wtxid(gtxid.IsWtxid()), m_state(State::CANDIDATE_DELAYED) {}\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(static_cast<uint8_t>(State::CANDIDATE_DELAYED)) {}\n };\n \n //! Type alias for priorities.\n@@ -143,7 +151,7 @@ struct ByPeerViewExtractor\n     using result_type = ByPeerView;\n     result_type operator()(const Announcement& ann) const\n     {\n-        return ByPeerView{ann.m_peer, ann.m_state == State::CANDIDATE_BEST, ann.m_txhash};\n+        return ByPeerView{ann.m_peer, ann.GetState() == State::CANDIDATE_BEST, ann.m_txhash};\n     }\n };\n \n@@ -166,8 +174,8 @@ class ByTxHashViewExtractor {\n     using result_type = ByTxHashView;\n     result_type operator()(const Announcement& ann) const\n     {\n-        const Priority prio = (ann.m_state == State::CANDIDATE_READY) ? m_computer(ann) : 0;\n-        return ByTxHashView{ann.m_txhash, ann.m_state, prio};\n+        const Priority prio = (ann.GetState() == State::CANDIDATE_READY) ? m_computer(ann) : 0;\n+        return ByTxHashView{ann.m_txhash, ann.GetState(), prio};\n     }\n };\n \n@@ -261,8 +269,8 @@ std::unordered_map<NodeId, PeerInfo> RecomputePeerInfo(const Index& index)\n     for (const Announcement& ann : index) {\n         PeerInfo& info = ret[ann.m_peer];\n         ++info.m_total;\n-        info.m_requested += (ann.m_state == State::REQUESTED);\n-        info.m_completed += (ann.m_state == State::COMPLETED);\n+        info.m_requested += (ann.GetState() == State::REQUESTED);\n+        info.m_completed += (ann.GetState() == State::COMPLETED);\n     }\n     return ret;\n }\n@@ -274,15 +282,15 @@ std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const Priori\n     for (const Announcement& ann : index) {\n         TxHashInfo& info = ret[ann.m_txhash];\n         // Classify how many announcements of each state we have for this txhash.\n-        info.m_candidate_delayed += (ann.m_state == State::CANDIDATE_DELAYED);\n-        info.m_candidate_ready += (ann.m_state == State::CANDIDATE_READY);\n-        info.m_candidate_best += (ann.m_state == State::CANDIDATE_BEST);\n-        info.m_requested += (ann.m_state == State::REQUESTED);\n+        info.m_candidate_delayed += (ann.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (ann.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (ann.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (ann.GetState() == State::REQUESTED);\n         // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST announcements.\n-        if (ann.m_state == State::CANDIDATE_BEST) {\n+        if (ann.GetState() == State::CANDIDATE_BEST) {\n             info.m_priority_candidate_best = computer(ann);\n         }\n-        if (ann.m_state == State::CANDIDATE_READY) {\n+        if (ann.GetState() == State::CANDIDATE_READY) {\n             info.m_priority_best_candidate_ready = std::max(info.m_priority_best_candidate_ready, computer(ann));\n         }\n         // Also keep track of which peers this txhash has an announcement for (so we can detect duplicates).\n@@ -369,8 +377,8 @@ class TxRequestTracker::Impl {\n     Iter<Tag> Erase(Iter<Tag> it)\n     {\n         auto peerit = m_peerinfo.find(it->m_peer);\n-        peerit->second.m_completed -= it->m_state == State::COMPLETED;\n-        peerit->second.m_requested -= it->m_state == State::REQUESTED;\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n         if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n         return m_index.get<Tag>().erase(it);\n     }\n@@ -380,11 +388,11 @@ class TxRequestTracker::Impl {\n     void Modify(Iter<Tag> it, Modifier modifier)\n     {\n         auto peerit = m_peerinfo.find(it->m_peer);\n-        peerit->second.m_completed -= it->m_state == State::COMPLETED;\n-        peerit->second.m_requested -= it->m_state == State::REQUESTED;\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n         m_index.get<Tag>().modify(it, std::move(modifier));\n-        peerit->second.m_completed += it->m_state == State::COMPLETED;\n-        peerit->second.m_requested += it->m_state == State::REQUESTED;\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n     }\n \n     //! Convert a CANDIDATE_DELAYED announcement into a CANDIDATE_READY. If this makes it the new best\n@@ -393,26 +401,26 @@ class TxRequestTracker::Impl {\n     void PromoteCandidateReady(Iter<ByTxHash> it)\n     {\n         assert(it != m_index.get<ByTxHash>().end());\n-        assert(it->m_state == State::CANDIDATE_DELAYED);\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n         // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n-        Modify<ByTxHash>(it, [](Announcement& ann){ ann.m_state = State::CANDIDATE_READY; });\n+        Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n         // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n         // _DELAYED, then _READY, then _BEST/REQUESTED). Within the _READY announcements, the best one (highest\n         // priority) comes last. Thus, if an existing _BEST exists for the same txhash that this announcement may\n         // be preferred over, it must immediately follow the newly created _READY.\n         auto it_next = std::next(it);\n         if (it_next == m_index.get<ByTxHash>().end() || it_next->m_txhash != it->m_txhash ||\n-            it_next->m_state == State::COMPLETED) {\n+            it_next->GetState() == State::COMPLETED) {\n             // This is the new best CANDIDATE_READY, and there is no IsSelected() announcement for this txhash\n             // already.\n-            Modify<ByTxHash>(it, [](Announcement& ann){ ann.m_state = State::CANDIDATE_BEST; });\n-        } else if (it_next->m_state == State::CANDIDATE_BEST) {\n+            Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+        } else if (it_next->GetState() == State::CANDIDATE_BEST) {\n             Priority priority_old = m_computer(*it_next);\n             Priority priority_new = m_computer(*it);\n             if (priority_new > priority_old) {\n                 // There is a CANDIDATE_BEST announcement already, but this one is better.\n-                Modify<ByTxHash>(it_next, [](Announcement& ann){ ann.m_state = State::CANDIDATE_READY; });\n-                Modify<ByTxHash>(it, [](Announcement& ann){ ann.m_state = State::CANDIDATE_BEST; });\n+                Modify<ByTxHash>(it_next, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n             }\n         }\n     }\n@@ -427,27 +435,27 @@ class TxRequestTracker::Impl {\n             auto it_prev = std::prev(it);\n             // The next best CANDIDATE_READY, if any, immediately precedes the REQUESTED or CANDIDATE_BEST\n             // announcement in the ByTxHash index.\n-            if (it_prev->m_txhash == it->m_txhash && it_prev->m_state == State::CANDIDATE_READY) {\n+            if (it_prev->m_txhash == it->m_txhash && it_prev->GetState() == State::CANDIDATE_READY) {\n                 // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n-                Modify<ByTxHash>(it_prev, [](Announcement& ann){ ann.m_state = State::CANDIDATE_BEST; });\n+                Modify<ByTxHash>(it_prev, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n             }\n         }\n-        Modify<ByTxHash>(it, [new_state](Announcement& ann){ ann.m_state = new_state; });\n+        Modify<ByTxHash>(it, [new_state](Announcement& ann){ ann.SetState(new_state); });\n     }\n \n     //! Check if 'it' is the only announcement for a given txhash that isn't COMPLETED.\n     bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n     {\n         assert(it != m_index.get<ByTxHash>().end());\n-        assert(it->m_state != State::COMPLETED); // Not allowed to call this on COMPLETED announcements.\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED announcements.\n \n         // This announcement has a predecessor that belongs to the same txhash. Due to ordering, and the\n         // fact that 'it' is not COMPLETED, its predecessor cannot be COMPLETED here.\n         if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n \n         // This announcement has a successor that belongs to the same txhash, and is not COMPLETED.\n         if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n-            std::next(it)->m_state != State::COMPLETED) return false;\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n \n         return true;\n     }\n@@ -460,7 +468,7 @@ class TxRequestTracker::Impl {\n         assert(it != m_index.get<ByTxHash>().end());\n \n         // Nothing to be done if it's already COMPLETED.\n-        if (it->m_state == State::COMPLETED) return true;\n+        if (it->GetState() == State::COMPLETED) return true;\n \n         if (IsOnlyNonCompleted(it)) {\n             // This is the last non-COMPLETED announcement for this txhash. Delete all.\n@@ -490,9 +498,9 @@ class TxRequestTracker::Impl {\n         // and convert them to CANDIDATE_READY and COMPLETED respectively.\n         while (!m_index.empty()) {\n             auto it = m_index.get<ByTime>().begin();\n-            if (it->m_state == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n                 PromoteCandidateReady(m_index.project<ByTxHash>(it));\n-            } else if (it->m_state == State::REQUESTED && it->m_time <= now) {\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n                 if (expired) expired->emplace_back(it->m_peer, ToGenTxid(*it));\n                 MakeCompleted(m_index.project<ByTxHash>(it));\n             } else {\n@@ -596,7 +604,7 @@ class TxRequestTracker::Impl {\n         std::vector<const Announcement*> selected;\n         auto it_peer = m_index.get<ByPeer>().lower_bound(ByPeerView{peer, true, uint256::ZERO});\n         while (it_peer != m_index.get<ByPeer>().end() && it_peer->m_peer == peer &&\n-            it_peer->m_state == State::CANDIDATE_BEST) {\n+            it_peer->GetState() == State::CANDIDATE_BEST) {\n             selected.emplace_back(&*it_peer);\n             ++it_peer;\n         }\n@@ -625,8 +633,8 @@ class TxRequestTracker::Impl {\n             // returned by GetRequestable always correspond to CANDIDATE_BEST announcements).\n \n             it = m_index.get<ByPeer>().find(ByPeerView{peer, false, txhash});\n-            if (it == m_index.get<ByPeer>().end() || (it->m_state != State::CANDIDATE_DELAYED &&\n-                it->m_state != State::CANDIDATE_READY)) {\n+            if (it == m_index.get<ByPeer>().end() || (it->GetState() != State::CANDIDATE_DELAYED &&\n+                                                      it->GetState() != State::CANDIDATE_READY)) {\n                 // There is no CANDIDATE announcement tracked for this peer, so we have nothing to do. Either this\n                 // txhash wasn't tracked at all (and the caller should have called ReceivedInv), or it was already\n                 // requested and/or completed for other reasons and this is just a superfluous RequestedTx call.\n@@ -638,24 +646,24 @@ class TxRequestTracker::Impl {\n             // other CANDIDATE_BEST or REQUESTED can exist.\n             auto it_old = m_index.get<ByTxHash>().lower_bound(ByTxHashView{txhash, State::CANDIDATE_BEST, 0});\n             if (it_old != m_index.get<ByTxHash>().end() && it_old->m_txhash == txhash) {\n-                if (it_old->m_state == State::CANDIDATE_BEST) {\n+                if (it_old->GetState() == State::CANDIDATE_BEST) {\n                     // The data structure's invariants require that there can be at most one CANDIDATE_BEST or one\n                     // REQUESTED announcement per txhash (but not both simultaneously), so we have to convert any\n                     // existing CANDIDATE_BEST to another CANDIDATE_* when constructing another REQUESTED.\n                     // It doesn't matter whether we pick CANDIDATE_READY or _DELAYED here, as SetTimePoint()\n                     // will correct it at GetRequestable() time. If time only goes forward, it will always be\n                     // _READY, so pick that to avoid extra work in SetTimePoint().\n-                    Modify<ByTxHash>(it_old, [](Announcement& ann) { ann.m_state = State::CANDIDATE_READY; });\n-                } else if (it_old->m_state == State::REQUESTED) {\n+                    Modify<ByTxHash>(it_old, [](Announcement& ann) { ann.SetState(State::CANDIDATE_READY); });\n+                } else if (it_old->GetState() == State::REQUESTED) {\n                     // As we're no longer waiting for a response to the previous REQUESTED announcement, convert it\n                     // to COMPLETED. This also helps guaranteeing progress.\n-                    Modify<ByTxHash>(it_old, [](Announcement& ann) { ann.m_state = State::COMPLETED; });\n+                    Modify<ByTxHash>(it_old, [](Announcement& ann) { ann.SetState(State::COMPLETED); });\n                 }\n             }\n         }\n \n         Modify<ByPeer>(it, [expiry](Announcement& ann) {\n-            ann.m_state = State::REQUESTED;\n+            ann.SetState(State::REQUESTED);\n             ann.m_time = expiry;\n         });\n     }"
      }
    ]
  }
]