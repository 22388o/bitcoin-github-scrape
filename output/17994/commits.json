[
  {
    "sha": "ac94141af0c16161afa68de1c3720f254ae4e12c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphYzk0MTQxYWYwYzE2MTYxYWZhNjhkZTFjMzcyMGYyNTRhZTRlMTJj",
    "commit": {
      "author": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2020-01-24T04:02:13Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2020-03-24T02:57:19Z"
      },
      "message": "validation: delay flushing undo files in syncing node case\n\nData files are pre-allocated, and upon flush/finalization, they are trimmed down to their resulting size.\nBlock (blk) files are written to disk as blocks come in, which is often out of order, whereas undo (rev) files are written sequentially, as each block is added to the top of the chain.\nWhen a block file hits the size limit, the system flushes and trims the file down to its final size, and moves on to the next block file.\n\nCase 1: blocks are added to the chain as they come in (synced up node case) -- in this case, we will flush and finalize the undo file together with the block file.\n\nCase 2: blocks are added to the chain after they have been downloaded (syncing node case) -- in this case, we postpone finalizing the undo file until we know the undo data for the last block in the file has been written to disk.",
      "tree": {
        "sha": "d88333902e14e5f574b1fe146529b1da02e1d33c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d88333902e14e5f574b1fe146529b1da02e1d33c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ac94141af0c16161afa68de1c3720f254ae4e12c",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEExCr/fGGz5EoUVM01V692LbM1MyIFAl55dx8ACgkQV692LbM1\nMyIr7Q/7B691mcthw6AqfKYMgO9vcwFf8/q/Y0peXgrxuXi35g3Z78oqWDiCvGtv\n5bcZ5LjE1A0Be1Z3xh/uzMoyngzHLKa/GPWtOVizEs9eQ4u/5GfSpeybqM6RlYcX\nLrp+9hDqwj1A6wXuGB2gIXb7/HaJfWrBi32ARsZtpDiW3RdzaG+FbWJZCJUvQ3Y+\nafK543GtiiUwxV7/NDU4/tBWRG0ensBr+DDllLRPXC/KBiqzEzQOUveMDV6HD0+J\nUC9F0sHGoG3HS3dpj36XReR2o2T2HH/xAsKfiaktiNHqCJ5K85nFujA2cyvZQEhQ\nf31+nLyioA3mHeGx2Pq4lpiozuu+7u855OiQMExcjAIGe6/k4TbTeWpqIoNITxLS\nn+4xY5fpAIiKmL5X2iNX7K0csISnC8p03cx2Hf+7v7IlLGF82trxDVv35DeXPDrq\nYod/VJe20oPgYYuLTdLRcB/O8B73p5kShfmRFZk8uwcuYgBb9jrG4+9Qf4WlBkCb\n9+veaiDmRwnmRkfZI5H5w3z4p7+dV+XtFiAcl5MFXXKYuxM2FnJLXgs/gr4gVGKV\nr6QtFFo+W1tQ+yowUzlfQiOZgG2d/EFmAraSbaEIOlMuwKF/XLRwnk+fdijh2be5\n/J8dtJztY6zDH1Sa4fW2UblXa9m5R+2SWFC82GsgZ2bNoBB5boM=\n=ihx/\n-----END PGP SIGNATURE-----",
        "payload": "tree d88333902e14e5f574b1fe146529b1da02e1d33c\nparent 04f78b818f02279d32c3ad3a1140e9410bfb26bf\nauthor Karl-Johan Alm <karljohan-alm@garage.co.jp> 1579838533 +0900\ncommitter Karl-Johan Alm <karljohan-alm@garage.co.jp> 1585018639 +0900\n\nvalidation: delay flushing undo files in syncing node case\n\nData files are pre-allocated, and upon flush/finalization, they are trimmed down to their resulting size.\nBlock (blk) files are written to disk as blocks come in, which is often out of order, whereas undo (rev) files are written sequentially, as each block is added to the top of the chain.\nWhen a block file hits the size limit, the system flushes and trims the file down to its final size, and moves on to the next block file.\n\nCase 1: blocks are added to the chain as they come in (synced up node case) -- in this case, we will flush and finalize the undo file together with the block file.\n\nCase 2: blocks are added to the chain after they have been downloaded (syncing node case) -- in this case, we postpone finalizing the undo file until we know the undo data for the last block in the file has been written to disk.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ac94141af0c16161afa68de1c3720f254ae4e12c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ac94141af0c16161afa68de1c3720f254ae4e12c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ac94141af0c16161afa68de1c3720f254ae4e12c/comments",
    "author": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "04f78b818f02279d32c3ad3a1140e9410bfb26bf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/04f78b818f02279d32c3ad3a1140e9410bfb26bf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/04f78b818f02279d32c3ad3a1140e9410bfb26bf"
      }
    ],
    "stats": {
      "total": 36,
      "additions": 27,
      "deletions": 9
    },
    "files": [
      {
        "sha": "faf92b3b07dd7d22aaad0c97d4b513ca03ebe768",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 9,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac94141af0c16161afa68de1c3720f254ae4e12c/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac94141af0c16161afa68de1c3720f254ae4e12c/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=ac94141af0c16161afa68de1c3720f254ae4e12c",
        "patch": "@@ -1731,19 +1731,24 @@ DisconnectResult CChainState::DisconnectBlock(const CBlock& block, const CBlockI\n     return fClean ? DISCONNECT_OK : DISCONNECT_UNCLEAN;\n }\n \n-void static FlushBlockFile(bool fFinalize = false)\n+static void FlushUndoFile(int block_file, bool finalize = false)\n {\n-    LOCK(cs_LastBlockFile);\n+    FlatFilePos undo_pos_old(block_file, vinfoBlockFile[block_file].nUndoSize);\n+    if (!UndoFileSeq().Flush(undo_pos_old, finalize)) {\n+        AbortNode(\"Flushing undo file to disk failed. This is likely the result of an I/O error.\");\n+    }\n+}\n \n+static void FlushBlockFile(bool fFinalize = false, bool finalize_undo = false)\n+{\n+    LOCK(cs_LastBlockFile);\n     FlatFilePos block_pos_old(nLastBlockFile, vinfoBlockFile[nLastBlockFile].nSize);\n-    FlatFilePos undo_pos_old(nLastBlockFile, vinfoBlockFile[nLastBlockFile].nUndoSize);\n-\n-    bool status = true;\n-    status &= BlockFileSeq().Flush(block_pos_old, fFinalize);\n-    status &= UndoFileSeq().Flush(undo_pos_old, fFinalize);\n-    if (!status) {\n+    if (!BlockFileSeq().Flush(block_pos_old, fFinalize)) {\n         AbortNode(\"Flushing block file to disk failed. This is likely the result of an I/O error.\");\n     }\n+    // we do not always flush the undo file, as the chain tip may be lagging behind the incoming blocks,\n+    // e.g. during IBD or a sync after a node going offline\n+    if (!fFinalize || finalize_undo) FlushUndoFile(nLastBlockFile, finalize_undo);\n }\n \n static bool FindUndoPos(BlockValidationState &state, int nFile, FlatFilePos &pos, unsigned int nAddSize);\n@@ -1757,6 +1762,14 @@ static bool WriteUndoDataForBlock(const CBlockUndo& blockundo, BlockValidationSt\n             return error(\"ConnectBlock(): FindUndoPos failed\");\n         if (!UndoWriteToDisk(blockundo, _pos, pindex->pprev->GetBlockHash(), chainparams.MessageStart()))\n             return AbortNode(state, \"Failed to write undo data\");\n+        // rev files are written in block height order, whereas blk files are written as blocks come in (often out of order)\n+        // we want to flush the rev (undo) file once we've written the last block, which is indicated by the last height\n+        // in the block file info as below; note that this does not catch the case where the undo writes are keeping up\n+        // with the block writes (usually when a synced up node is getting newly mined blocks) -- this case is caught in\n+        // the FindBlockPos function\n+        if (_pos.nFile < nLastBlockFile && static_cast<uint32_t>(pindex->nHeight) == vinfoBlockFile[_pos.nFile].nHeightLast) {\n+            FlushUndoFile(_pos.nFile, true);\n+        }\n \n         // update nUndoPos in block index\n         pindex->nUndoPos = _pos.nPos;\n@@ -3220,8 +3233,13 @@ static bool FindBlockPos(FlatFilePos &pos, unsigned int nAddSize, unsigned int n\n         vinfoBlockFile.resize(nFile + 1);\n     }\n \n+    bool finalize_undo = false;\n     if (!fKnown) {\n         while (vinfoBlockFile[nFile].nSize + nAddSize >= MAX_BLOCKFILE_SIZE) {\n+            // when the undo file is keeping up with the block file, we want to flush it explicitly\n+            // when it is lagging behind (more blocks arrive than are being connected), we let the\n+            // undo block write case handle it\n+            finalize_undo = (vinfoBlockFile[nFile].nHeightLast == (unsigned int)ChainActive().Tip()->nHeight);\n             nFile++;\n             if (vinfoBlockFile.size() <= nFile) {\n                 vinfoBlockFile.resize(nFile + 1);\n@@ -3235,7 +3253,7 @@ static bool FindBlockPos(FlatFilePos &pos, unsigned int nAddSize, unsigned int n\n         if (!fKnown) {\n             LogPrintf(\"Leaving block file %i: %s\\n\", nLastBlockFile, vinfoBlockFile[nLastBlockFile].ToString());\n         }\n-        FlushBlockFile(!fKnown);\n+        FlushBlockFile(!fKnown, finalize_undo);\n         nLastBlockFile = nFile;\n     }\n "
      }
    ]
  }
]