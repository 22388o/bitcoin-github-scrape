[
  {
    "sha": "057c8b4ce84c81e008d53b90ecddfa6d4f58cd9a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNTdjOGI0Y2U4NGM4MWUwMDhkNTNiOTBlY2RkZmE2ZDRmNThjZDlh",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "j@rubin.io",
        "date": "2020-01-21T20:44:01Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "j@rubin.io",
        "date": "2020-02-11T01:20:51Z"
      },
      "message": "Change UpdateForDescendants to use Epochs",
      "tree": {
        "sha": "457c4b0ef0912c9e0ba3eff1c8d90f0a1cb627ab",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/457c4b0ef0912c9e0ba3eff1c8d90f0a1cb627ab"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/057c8b4ce84c81e008d53b90ecddfa6d4f58cd9a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/057c8b4ce84c81e008d53b90ecddfa6d4f58cd9a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/057c8b4ce84c81e008d53b90ecddfa6d4f58cd9a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/057c8b4ce84c81e008d53b90ecddfa6d4f58cd9a/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bd5a02692853f7240a4fdc593d7d0123d7916e45",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bd5a02692853f7240a4fdc593d7d0123d7916e45",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bd5a02692853f7240a4fdc593d7d0123d7916e45"
      }
    ],
    "stats": {
      "total": 93,
      "additions": 58,
      "deletions": 35
    },
    "files": [
      {
        "sha": "6b16c4cf18e140cd83e4cc06d11d223eaebdcf02",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 56,
        "deletions": 34,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/057c8b4ce84c81e008d53b90ecddfa6d4f58cd9a/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/057c8b4ce84c81e008d53b90ecddfa6d4f58cd9a/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=057c8b4ce84c81e008d53b90ecddfa6d4f58cd9a",
        "patch": "@@ -57,48 +57,70 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache, const std::set<uint256>& exclude)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    const CTxMemPool::setEntries& direct_children = GetMemPoolChildren(update_it);\n+    // set up the update_cache to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction)\n+    vecEntries update_cache;\n+    update_cache.reserve(direct_children.size());\n+    // mark every direct_child as visited so that we don't accidentally re-add them\n+    // to the cache in the grandchild is child case\n+    for (const txiter direct_child : direct_children) {\n+        update_cache.emplace_back(direct_child);\n+        visited(direct_child);\n+    }\n+    // already_traversed index keeps track of the elements that we've\n+    // already expanded. If index is < already_traversed, we've walked it.\n+    // If index is >= already_traversed, we need to walk it.\n+    // If already_traversed >= update_cache.size(), we're finished.\n+    for (size_t already_traversed = 0; already_traversed < update_cache.size(); /* modified in loop body */) {\n+        // rotate the back() to behind already_traversed\n+        const txiter child_it = update_cache.back();\n+        std::swap(update_cache[already_traversed++], update_cache.back());\n+\n+        // N.B. grand_children may also be children\n+        const CTxMemPool::setEntries& grand_children = GetMemPoolChildren(child_it);\n+        for (const txiter grand_child_it : grand_children) {\n+            if (visited(grand_child_it)) continue;\n+            // Schedule for later processing\n+            update_cache.emplace_back(grand_child_it);\n+            // if it exists in the cache, unschedule and use cached descendants\n+            cacheMap::iterator cached_great_grand_children = cache.find(grand_child_it);\n+            if (cached_great_grand_children != cache.end()) {\n+                std::swap(update_cache[already_traversed++], update_cache.back());\n+                for (const txiter great_grand_child : cached_great_grand_children->second) {\n+                    if (visited(great_grand_child)) continue;\n+                    update_cache.emplace_back(great_grand_child);\n+                    // place on the back and then swap into the already_traversed index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this)\n+                    std::swap(update_cache[already_traversed++], update_cache.back());\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n-                // Schedule for later processing\n-                stageEntries.insert(childEntry);\n             }\n         }\n     }\n-    // setAllDescendants now contains all in-mempool descendants of updateIt.\n-    // Update and add to cached descendant map\n-    int64_t modifySize = 0;\n-    CAmount modifyFee = 0;\n-    int64_t modifyCount = 0;\n-    for (txiter cit : setAllDescendants) {\n-        if (!setExclude.count(cit->GetTx().GetHash())) {\n-            modifySize += cit->GetTxSize();\n-            modifyFee += cit->GetModifiedFee();\n-            modifyCount++;\n-            cachedDescendants[updateIt].insert(cit);\n-            // Update ancestor state for each descendant\n-            mapTx.modify(cit, update_ancestor_state(updateIt->GetTxSize(), updateIt->GetModifiedFee(), 1, updateIt->GetSigOpCost()));\n+\n+    // update_cache now contains all in-mempool descendants of update_it,\n+    // compute updates now.\n+    int64_t modify_size = 0;\n+    CAmount modify_fee = 0;\n+    int64_t modify_count = 0;\n+    for (txiter child_it : update_cache) {\n+        const CTxMemPoolEntry& child = *child_it;\n+        if (!exclude.count(child.GetTx().GetHash())) {\n+            modify_size += child.GetTxSize();\n+            modify_fee += child.GetModifiedFee();\n+            modify_count++;\n+            mapTx.modify(child_it, update_ancestor_state(update_it->GetTxSize(), update_it->GetModifiedFee(), 1, update_it->GetSigOpCost()));\n         }\n     }\n-    mapTx.modify(updateIt, update_descendant_state(modifySize, modifyFee, modifyCount));\n+    mapTx.modify(update_it, update_descendant_state(modify_size, modify_fee, modify_count));\n+    // share the cache (if there is one)\n+    if (!update_cache.empty()) cache.emplace(update_it, std::move(update_cache));\n }\n-\n // vHashesToUpdate is the set of transaction hashes from a disconnected block\n // which has been re-added to the mempool.\n // for each entry, look for descendants that are outside vHashesToUpdate, and"
      },
      {
        "sha": "c2890cbe0ba72491c6fde37ddab1b159abff1f58",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/057c8b4ce84c81e008d53b90ecddfa6d4f58cd9a/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/057c8b4ce84c81e008d53b90ecddfa6d4f58cd9a/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=057c8b4ce84c81e008d53b90ecddfa6d4f58cd9a",
        "patch": "@@ -530,12 +530,13 @@ class CTxMemPool\n         }\n     };\n     typedef std::set<txiter, CompareIteratorByHash> setEntries;\n+    typedef std::vector<txiter> vecEntries;\n \n     const setEntries & GetMemPoolParents(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n     const setEntries & GetMemPoolChildren(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n     uint64_t CalculateDescendantMaximum(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n private:\n-    typedef std::map<txiter, setEntries, CompareIteratorByHash> cacheMap;\n+    typedef std::map<txiter, vecEntries, CompareIteratorByHash> cacheMap;\n \n     struct TxLinks {\n         setEntries parents;"
      }
    ]
  }
]