[
  {
    "sha": "0c74716c50384677724247e05e6592f845fc8635",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowYzc0NzE2YzUwMzg0Njc3NzI0MjQ3ZTA1ZTY1OTJmODQ1ZmM4NjM1",
    "commit": {
      "author": {
        "name": "glozow",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-04-20T17:44:11Z"
      },
      "committer": {
        "name": "glozow",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-04-22T20:32:24Z"
      },
      "message": "[docs] format existing comments as doxygen\n\nCo-authored-by: Xekyo <murch@murch.one>",
      "tree": {
        "sha": "c4a6761f86f0a089b926ff0c77ce18fa51b39a53",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c4a6761f86f0a089b926ff0c77ce18fa51b39a53"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0c74716c50384677724247e05e6592f845fc8635",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0c74716c50384677724247e05e6592f845fc8635",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0c74716c50384677724247e05e6592f845fc8635",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0c74716c50384677724247e05e6592f845fc8635/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4b5659c6b115315c9fd2902b4edd4b960a5e066e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4b5659c6b115315c9fd2902b4edd4b960a5e066e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4b5659c6b115315c9fd2902b4edd4b960a5e066e"
      }
    ],
    "stats": {
      "total": 32,
      "additions": 16,
      "deletions": 16
    },
    "files": [
      {
        "sha": "cc197d329c8901cbf66cf681adb13021ad131d05",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0c74716c50384677724247e05e6592f845fc8635/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0c74716c50384677724247e05e6592f845fc8635/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=0c74716c50384677724247e05e6592f845fc8635",
        "patch": "@@ -368,7 +368,7 @@ class CWalletTx\n \n     CTransactionRef tx;\n \n-    /* New transactions start as UNCONFIRMED. At BlockConnected,\n+    /** New transactions start as UNCONFIRMED. At BlockConnected,\n      * they will transition to CONFIRMED. In case of reorg, at BlockDisconnected,\n      * they roll back to UNCONFIRMED. If we detect a conflicting transaction at\n      * block connection, we update conflicted tx and its dependencies as CONFLICTED.\n@@ -383,7 +383,7 @@ class CWalletTx\n         ABANDONED\n     };\n \n-    /* Confirmation includes tx status and a triplet of {block height/block hash/tx index in block}\n+    /** Confirmation includes tx status and a triplet of {block height/block hash/tx index in block}\n      * at which tx has been confirmed. All three are set to 0 if tx is unconfirmed or abandoned.\n      * Meaning of these fields changes with CONFLICTED state where they instead point to block hash\n      * and block height of the deepest conflicting tx.\n@@ -481,7 +481,7 @@ class CWalletTx\n     CAmount GetImmatureWatchOnlyCredit(const bool fUseCache = true) const;\n     CAmount GetChange() const;\n \n-    // Get the marginal bytes if spending the specified output from this transaction\n+    /** Get the marginal bytes if spending the specified output from this transaction */\n     int GetSpendSize(unsigned int out, bool use_max_sig = false) const\n     {\n         return CalculateMaximumSignedInputSize(tx->vout[out], pwallet, use_max_sig);\n@@ -495,15 +495,15 @@ class CWalletTx\n         return (GetDebit(filter) > 0);\n     }\n \n-    // True if only scriptSigs are different\n+    /** True if only scriptSigs are different */\n     bool IsEquivalentTo(const CWalletTx& tx) const;\n \n     bool InMempool() const;\n     bool IsTrusted() const;\n \n     int64_t GetTxTime() const;\n \n-    // Pass this transaction to node for mempool insertion and relay to peers if flag set to true\n+    /** Pass this transaction to node for mempool insertion and relay to peers if flag set to true */\n     bool SubmitMemoryPoolAndRelay(std::string& err_string, bool relay);\n \n     // TODO: Remove \"NO_THREAD_SAFETY_ANALYSIS\" and replace it with the correct\n@@ -613,7 +613,7 @@ struct CoinSelectionParams\n     CFeeRate m_long_term_feerate;\n     CFeeRate m_discard_feerate;\n     size_t tx_noinputs_size = 0;\n-    //! Indicate that we are subtracting the fee from outputs\n+    /** Indicate that we are subtracting the fee from outputs */\n     bool m_subtract_fee_outputs = false;\n     bool m_avoid_partial_spends = false;\n \n@@ -682,10 +682,10 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n      */\n     bool AddToWalletIfInvolvingMe(const CTransactionRef& tx, CWalletTx::Confirmation confirm, bool fUpdate) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n-    /* Mark a transaction (and its in-wallet descendants) as conflicting with a particular block. */\n+    /** Mark a transaction (and its in-wallet descendants) as conflicting with a particular block. */\n     void MarkConflicted(const uint256& hashBlock, int conflicting_height, const uint256& hashTx);\n \n-    /* Mark a transaction's inputs dirty, thus forcing the outputs to be recomputed */\n+    /** Mark a transaction's inputs dirty, thus forcing the outputs to be recomputed */\n     void MarkInputsDirty(const CTransactionRef& tx) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n     void SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator>) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n@@ -722,7 +722,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n      */\n     uint256 m_last_block_processed GUARDED_BY(cs_wallet);\n \n-    /* Height of last block processed is used by wallet to know depth of transactions\n+    /** Height of last block processed is used by wallet to know depth of transactions\n      * without relying on Chain interface beyond asynchronous updates. For safety, we\n      * initialize it to -1. Height is a pointer on node's tip and doesn't imply\n      * that the wallet has scanned sequentially all blocks up to this one.\n@@ -739,7 +739,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     bool CreateTransactionInternal(const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CAmount& nFeeRet, int& nChangePosInOut, bilingual_str& error, const CCoinControl& coin_control, FeeCalculation& fee_calc_out, bool sign);\n \n public:\n-    /*\n+    /**\n      * Main wallet lock.\n      * This lock protects all the fields added by CWallet.\n      */\n@@ -956,9 +956,9 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n      * calling CreateTransaction();\n      */\n     bool FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nChangePosInOut, bilingual_str& error, bool lockUnspents, const std::set<int>& setSubtractFeeFromOutputs, CCoinControl);\n-    // Fetch the inputs and sign with SIGHASH_ALL.\n+    /** Fetch the inputs and sign with SIGHASH_ALL. */\n     bool SignTransaction(CMutableTransaction& tx) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    // Sign the tx given the input coins and sighash.\n+    /** Sign the tx given the input coins and sighash. */\n     bool SignTransaction(CMutableTransaction& tx, const std::map<COutPoint, Coin>& coins, int sighash, std::map<int, std::string>& input_errors) const;\n     SigningResult SignMessage(const std::string& message, const PKHash& pkhash, std::string& str_sig) const;\n \n@@ -1333,10 +1333,10 @@ class WalletRescanReserver\n     }\n };\n \n-// Calculate the size of the transaction assuming all signatures are max size\n-// Use DummySignatureCreator, which inserts 71 byte signatures everywhere.\n-// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n-// be IsAllFromMe).\n+/** Calculate the size of the transaction assuming all signatures are max size\n+* Use DummySignatureCreator, which inserts 71 byte signatures everywhere.\n+* NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+* be IsAllFromMe). */\n std::pair<int64_t, int64_t> CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, bool use_max_sig = false) EXCLUSIVE_LOCKS_REQUIRED(wallet->cs_wallet);\n std::pair<int64_t, int64_t> CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, const std::vector<CTxOut>& txouts, bool use_max_sig = false);\n "
      }
    ]
  },
  {
    "sha": "58ea324fdd906204bb77ea4be1c01a3ab56cf86f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1OGVhMzI0ZmRkOTA2MjA0YmI3N2VhNGJlMWMwMWEzYWI1NmNmODZm",
    "commit": {
      "author": {
        "name": "glozow",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-04-21T22:52:29Z"
      },
      "committer": {
        "name": "glozow",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-04-26T18:00:18Z"
      },
      "message": "[docs] add doxygen comments to wallet code\n\nCo-authored-by: Xekyo <murch@murch.one>",
      "tree": {
        "sha": "b9c377d224d07a1aa2e291a9fe6167eef4c1105b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b9c377d224d07a1aa2e291a9fe6167eef4c1105b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/58ea324fdd906204bb77ea4be1c01a3ab56cf86f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/58ea324fdd906204bb77ea4be1c01a3ab56cf86f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/58ea324fdd906204bb77ea4be1c01a3ab56cf86f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/58ea324fdd906204bb77ea4be1c01a3ab56cf86f/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0c74716c50384677724247e05e6592f845fc8635",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0c74716c50384677724247e05e6592f845fc8635",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0c74716c50384677724247e05e6592f845fc8635"
      }
    ],
    "stats": {
      "total": 80,
      "additions": 77,
      "deletions": 3
    },
    "files": [
      {
        "sha": "5c1b36be6e32e649289dd046b7735bb2eeca997b",
        "filename": "src/wallet/coinselection.h",
        "status": "modified",
        "additions": 29,
        "deletions": 1,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58ea324fdd906204bb77ea4be1c01a3ab56cf86f/src/wallet/coinselection.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58ea324fdd906204bb77ea4be1c01a3ab56cf86f/src/wallet/coinselection.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.h?ref=58ea324fdd906204bb77ea4be1c01a3ab56cf86f",
        "patch": "@@ -15,6 +15,7 @@ static constexpr CAmount MIN_CHANGE{COIN / 100};\n //! final minimum change amount after paying for fees\n static const CAmount MIN_FINAL_CHANGE = MIN_CHANGE/2;\n \n+/** A UTXO under consideration for use in funding a new transaction. */\n class CInputCoin {\n public:\n     CInputCoin(const CTransactionRef& tx, unsigned int i)\n@@ -56,31 +57,58 @@ class CInputCoin {\n     }\n };\n \n+/** Parameters for filtering which OutputGroups we may use in coin selection.\n+ * We start by being very selective and requiring multiple confirmations and\n+ * then get more permissive if we cannot fund the transaction. */\n struct CoinEligibilityFilter\n {\n+    /** Minimum number of confirmations for outputs that we sent to ourselves.\n+     * We may use unconfirmed UTXOs sent from ourselves, e.g. change outputs. */\n     const int conf_mine;\n+    /** Minimum number of confirmations for outputs received from a different\n+     * wallet. We never spend unconfirmed foreign outputs as we cannot rely on these funds yet. */\n     const int conf_theirs;\n+    /** Maximum number of unconfirmed ancestors aggregated across all UTXOs in an OutputGroup. */\n     const uint64_t max_ancestors;\n+    /** Maximum number of descendants that a single UTXO in the OutputGroup may have. */\n     const uint64_t max_descendants;\n-    const bool m_include_partial_groups{false}; //! Include partial destination groups when avoid_reuse and there are full groups\n+    /** When avoid_reuse=true and there are full groups (OUTPUT_GROUP_MAX_ENTRIES), whether or not to use any partial groups.*/\n+    const bool m_include_partial_groups{false};\n \n     CoinEligibilityFilter(int conf_mine, int conf_theirs, uint64_t max_ancestors) : conf_mine(conf_mine), conf_theirs(conf_theirs), max_ancestors(max_ancestors), max_descendants(max_ancestors) {}\n     CoinEligibilityFilter(int conf_mine, int conf_theirs, uint64_t max_ancestors, uint64_t max_descendants) : conf_mine(conf_mine), conf_theirs(conf_theirs), max_ancestors(max_ancestors), max_descendants(max_descendants) {}\n     CoinEligibilityFilter(int conf_mine, int conf_theirs, uint64_t max_ancestors, uint64_t max_descendants, bool include_partial) : conf_mine(conf_mine), conf_theirs(conf_theirs), max_ancestors(max_ancestors), max_descendants(max_descendants), m_include_partial_groups(include_partial) {}\n };\n \n+/** A group of UTXOs paid to the same output script. */\n struct OutputGroup\n {\n+    /** The list of UTXOs contained in this output group. */\n     std::vector<CInputCoin> m_outputs;\n+    /** Whether the UTXOs were sent by the wallet to itself. This is relevant because we may want at\n+     * least a certain number of confirmations on UTXOs received from outside wallets while trusting\n+     * our own UTXOs more. */\n     bool m_from_me{true};\n+    /** The total value of the UTXOs in sum. */\n     CAmount m_value{0};\n+    /** The minimum number of confirmations the UTXOs in the group have. Unconfirmed is 0. */\n     int m_depth{999};\n+    /** The aggregated count of unconfirmed ancestors of all UTXOs in this\n+     * group. Not deduplicated and may overestimate when ancestors are shared. */\n     size_t m_ancestors{0};\n+    /** The maximum count of descendants of a single UTXO in this output group. */\n     size_t m_descendants{0};\n+    /** The value of the UTXOs after deducting the cost of spending them at the effective feerate. */\n     CAmount effective_value{0};\n+    /** The fee to spend these UTXOs at the effective feerate. */\n     CAmount fee{0};\n+    /** The target feerate of the transaction we're trying to build. */\n     CFeeRate m_effective_feerate{0};\n+    /** The fee to spend these UTXOs at the long term feerate. */\n     CAmount long_term_fee{0};\n+    /** The feerate for spending a created change output eventually (i.e. not urgently, and thus at\n+     * a lower feerate). Calculated using long term fee estimate. This is used to decide whether\n+     * it could be economical to create a change output. */\n     CFeeRate m_long_term_feerate{0};\n \n     OutputGroup() {}"
      },
      {
        "sha": "03adca7a896bd62c9273602ce5e3d783fcc4e937",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 48,
        "deletions": 2,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58ea324fdd906204bb77ea4be1c01a3ab56cf86f/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58ea324fdd906204bb77ea4be1c01a3ab56cf86f/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=58ea324fdd906204bb77ea4be1c01a3ab56cf86f",
        "patch": "@@ -564,7 +564,15 @@ class COutput\n {\n public:\n     const CWalletTx *tx;\n+\n+    /** Index in tx->vout. */\n     int i;\n+\n+    /**\n+     * Depth in block chain.\n+     * If > 0: the tx is on chain and has this many confirmations.\n+     * If = 0: the tx is waiting confirmation.\n+     * If < 0: a conflicting tx is on chain and has this many confirmations. */\n     int nDepth;\n \n     /** Pre-computed estimated size of this output as a fully-signed input in a transaction. Can be -1 if it could not be calculated */\n@@ -604,17 +612,30 @@ class COutput\n     }\n };\n \n+/** Parameters for one iteration of Coin Selection. */\n struct CoinSelectionParams\n {\n+    /** Toggles use of Branch and Bound instead of Knapsack solver. */\n     bool use_bnb = true;\n+    /** Size of a change output in bytes, determined by the output type. */\n     size_t change_output_size = 0;\n+    /** Size of the input to spend a change output in virtual bytes. */\n     size_t change_spend_size = 0;\n+    /** The targeted feerate of the transaction being built. */\n     CFeeRate m_effective_feerate;\n+    /** The feerate estimate used to estimate an upper bound on what should be sufficient to spend\n+     * the change output sometime in the future. */\n     CFeeRate m_long_term_feerate;\n+    /** If the cost to spend a change output at the discard feerate exceeds its value, drop it to fees. */\n     CFeeRate m_discard_feerate;\n+    /** Size of the transaction before coin selection, consisting of the header and recipient\n+     * output(s), excluding the inputs and change output(s). */\n     size_t tx_noinputs_size = 0;\n     /** Indicate that we are subtracting the fee from outputs */\n     bool m_subtract_fee_outputs = false;\n+    /** When true, always spend all (up to OUTPUT_GROUP_MAX_ENTRIES) or none of the outputs\n+     * associated with the same address. This helps reduce privacy leaks resulting from address\n+     * reuse. Dust outputs are not eligible to be added to output groups and thus not considered. */\n     bool m_avoid_partial_spends = false;\n \n     CoinSelectionParams(bool use_bnb, size_t change_output_size, size_t change_spend_size, CFeeRate effective_feerate,\n@@ -652,7 +673,10 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     //! the current wallet version: clients below this version are not able to load the wallet\n     int nWalletVersion GUARDED_BY(cs_wallet){FEATURE_BASE};\n \n+    /** The next scheduled rebroadcast of wallet transactions. */\n     int64_t nNextResend = 0;\n+    /** Whether this wallet will submit newly created transactions to the node's mempool and\n+     * prompt rebroadcasts (see ResendWalletTransactions()). */\n     bool fBroadcastTransactions = false;\n     // Local time that the tip block was received. Used to schedule wallet rebroadcasts.\n     std::atomic<int64_t> m_best_block_time {0};\n@@ -694,6 +718,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n      * Should be called with non-zero block_hash and posInBlock if this is for a transaction that is included in a block. */\n     void SyncTransaction(const CTransactionRef& tx, CWalletTx::Confirmation confirm, bool update_tx = true) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n+    /** WalletFlags set on this wallet. */\n     std::atomic<uint64_t> m_wallet_flags{0};\n \n     bool SetAddressBookWithDB(WalletBatch& batch, const CTxDestination& address, const std::string& strName, const std::string& strPurpose);\n@@ -753,8 +778,11 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n \n     /**\n      * Select a set of coins such that nValueRet >= nTargetValue and at least\n-     * all coins from coinControl are selected; Never select unconfirmed coins\n-     * if they are not ours\n+     * all coins from coin_control are selected; never select unconfirmed coins if they are not ours\n+     * param@[out]  setCoinsRet         Populated with inputs including pre-selected inputs from\n+     *                                  coin_control and Coin Selection if successful.\n+     * param@[out]  nValueRet           Total value of selected coins including pre-selected ones\n+     *                                  from coin_control and Coin Selection if successful.\n      */\n     bool SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet,\n                     const CCoinControl& coin_control, CoinSelectionParams& coin_selection_params, bool& bnb_used) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n@@ -788,6 +816,8 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     /** Interface to assert chain access */\n     bool HaveChain() const { return m_chain ? true : false; }\n \n+    /** Map from txid to CWalletTx for all transactions this wallet is\n+     * interested in, including received and sent transactions. */\n     std::map<uint256, CWalletTx> mapWallet GUARDED_BY(cs_wallet);\n \n     typedef std::multimap<int64_t, CWalletTx*> TxItems;\n@@ -799,6 +829,10 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     std::map<CTxDestination, CAddressBookData> m_address_book GUARDED_BY(cs_wallet);\n     const CAddressBookData* FindAddressBookEntry(const CTxDestination&, bool allow_change = false) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n+    /** Set of Coins owned by this wallet that we won't try to spend from. A\n+     * Coin may be locked if it has already been used to fund a transaction\n+     * that hasn't confirmed yet. We wouldn't consider the Coin spent already,\n+     * but also shouldn't try to use it again. */\n     std::set<COutPoint> setLockedCoins GUARDED_BY(cs_wallet);\n \n     /** Registered interfaces::Chain::Notifications handler. */\n@@ -833,6 +867,11 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n      * small change; This method is stochastic for some inputs and upon\n      * completion the coin set and corresponding actual target value is\n      * assembled\n+     * param@[in]   coins           Set of UTXOs to consider. These will be categorized into\n+     *                              OutputGroups and filtered using eligibility_filter before\n+     *                              selecting coins.\n+     * param@[out]  setCoinsRet     Populated with the coins selected if successful.\n+     * param@[out]  nValueRet       Used to return the total value of selected coins.\n      */\n     bool SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<COutput> coins,\n         std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params, bool& bnb_used) const;\n@@ -1015,6 +1054,8 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n \n     CFeeRate m_pay_tx_fee{DEFAULT_PAY_TX_FEE};\n     unsigned int m_confirm_target{DEFAULT_TX_CONFIRM_TARGET};\n+    /** Allow Coin Selection to pick unconfirmed UTXOs that were sent from our own wallet if it\n+     * cannot fund the transaction otherwise. */\n     bool m_spend_zero_conf_change{DEFAULT_SPEND_ZEROCONF_CHANGE};\n     bool m_signal_rbf{DEFAULT_WALLET_RBF};\n     bool m_allow_fallback_fee{true}; //!< will be false if -fallbackfee=0\n@@ -1025,7 +1066,12 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n      * Override with -fallbackfee\n      */\n     CFeeRate m_fallback_fee{DEFAULT_FALLBACK_FEE};\n+\n+     /** If the cost to spend a change output at this feerate is greater than the value of the\n+      * output itself, just drop it to fees. */\n     CFeeRate m_discard_rate{DEFAULT_DISCARD_FEE};\n+\n+    /** The maximum fee amount we're willing to pay to prioritize partial spend avoidance. */\n     CAmount m_max_aps_fee{DEFAULT_MAX_AVOIDPARTIALSPEND_FEE}; //!< note: this is absolute fee, not fee rate\n     OutputType m_default_address_type{DEFAULT_ADDRESS_TYPE};\n     /**"
      }
    ]
  },
  {
    "sha": "6ba892126d354219b146f0c7f35d472f9c14bdac",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2YmE4OTIxMjZkMzU0MjE5YjE0NmYwYzdmMzVkNDcyZjljMTRiZGFj",
    "commit": {
      "author": {
        "name": "glozow",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-04-22T13:17:21Z"
      },
      "committer": {
        "name": "glozow",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-04-26T18:00:18Z"
      },
      "message": "refactor + document coin selection strategy\n\nCo-authored-by: Xekyo <murch@murch.one>",
      "tree": {
        "sha": "0f595b5cabc44762c1f74d3dbf473f0ebf520a75",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0f595b5cabc44762c1f74d3dbf473f0ebf520a75"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6ba892126d354219b146f0c7f35d472f9c14bdac",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6ba892126d354219b146f0c7f35d472f9c14bdac",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6ba892126d354219b146f0c7f35d472f9c14bdac",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6ba892126d354219b146f0c7f35d472f9c14bdac/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "58ea324fdd906204bb77ea4be1c01a3ab56cf86f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/58ea324fdd906204bb77ea4be1c01a3ab56cf86f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/58ea324fdd906204bb77ea4be1c01a3ab56cf86f"
      }
    ],
    "stats": {
      "total": 63,
      "additions": 50,
      "deletions": 13
    },
    "files": [
      {
        "sha": "f0aaee7e4ea37e8a1d546fd5a3cf04ab3b7554c3",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 50,
        "deletions": 13,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6ba892126d354219b146f0c7f35d472f9c14bdac/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6ba892126d354219b146f0c7f35d472f9c14bdac/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=6ba892126d354219b146f0c7f35d472f9c14bdac",
        "patch": "@@ -2478,7 +2478,7 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n         }\n     }\n \n-    // remove preset inputs from vCoins\n+    // remove preset inputs from vCoins so that Coin Selection doesn't pick them.\n     for (std::vector<COutput>::iterator it = vCoins.begin(); it != vCoins.end() && coin_control.HasSelected();)\n     {\n         if (setPresetCoins.count(it->GetInputCoin()))\n@@ -2490,9 +2490,9 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n     unsigned int limit_ancestor_count = 0;\n     unsigned int limit_descendant_count = 0;\n     chain().getPackageLimits(limit_ancestor_count, limit_descendant_count);\n-    size_t max_ancestors = (size_t)std::max<int64_t>(1, limit_ancestor_count);\n-    size_t max_descendants = (size_t)std::max<int64_t>(1, limit_descendant_count);\n-    bool fRejectLongChains = gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS);\n+    const size_t max_ancestors = (size_t)std::max<int64_t>(1, limit_ancestor_count);\n+    const size_t max_descendants = (size_t)std::max<int64_t>(1, limit_descendant_count);\n+    const bool fRejectLongChains = gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS);\n \n     // form groups from remaining coins; note that preset coins will not\n     // automatically have their associated (same address) coins included\n@@ -2502,16 +2502,53 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n         // explicitly shuffling the outputs before processing\n         Shuffle(vCoins.begin(), vCoins.end(), FastRandomContext());\n     }\n-    bool res = value_to_select <= 0 ||\n-        SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(1, 6, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used) ||\n-        SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(1, 1, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, 2), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n-        (m_spend_zero_conf_change && SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1, true /* include_partial_groups */), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n-        (m_spend_zero_conf_change && !fRejectLongChains && SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max(), std::numeric_limits<uint64_t>::max(), true /* include_partial_groups */), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n \n-    // because SelectCoinsMinConf clears the setCoinsRet, we now add the possible inputs to the coinset\n+    // Coin Selection attempts to select inputs from a pool of eligible UTXOs to fund the\n+    // transaction at a target feerate. If an attempt fails, more attempts may be made using a more\n+    // permissive CoinEligibilityFilter.\n+    const bool res = [&] {\n+        // Pre-selected inputs already cover the target amount.\n+        if (value_to_select <= 0) return true;\n+\n+        // If possible, fund the transaction with confirmed UTXOs only. Prefer at least six\n+        // confirmations on outputs received from other wallets and only spend confirmed change.\n+        if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(1, 6, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) return true;\n+        if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(1, 1, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) return true;\n+\n+        // Fall back to using zero confirmation change (but with as few ancestors in the mempool as\n+        // possible) if we cannot fund the transaction otherwise. We never spend unconfirmed\n+        // outputs received from other wallets.\n+        if (m_spend_zero_conf_change) {\n+            if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, 2), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) return true;\n+            if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)),\n+                                   vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) {\n+                return true;\n+            }\n+            if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2),\n+                                   vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) {\n+                return true;\n+            }\n+            // If partial groups are allowed, relax the requirement of spending OutputGroups (groups\n+            // of UTXOs sent to the same address, which are obviously controlled by a single wallet)\n+            // in their entirety.\n+            if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1, true /* include_partial_groups */),\n+                                   vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) {\n+                return true;\n+            }\n+            // Try with unlimited ancestors/descendants. The transaction will still need to meet\n+            // mempool ancestor/descendant policy to be accepted to mempool and broadcasted, but\n+            // OutputGroups use heuristics that may overestimate ancestor/descendant counts.\n+            if (!fRejectLongChains && SelectCoinsMinConf(value_to_select,\n+                                      CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max(), std::numeric_limits<uint64_t>::max(), true /* include_partial_groups */),\n+                                      vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) {\n+                return true;\n+            }\n+        }\n+        // Coin Selection failed.\n+        return false;\n+    }();\n+\n+    // SelectCoinsMinConf clears setCoinsRet, so add the preset inputs from coin_control to the coinset\n     util::insert(setCoinsRet, setPresetCoins);\n \n     // add preset inputs to the total value selected"
      }
    ]
  }
]