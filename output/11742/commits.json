[
  {
    "sha": "b55555da3e25a47f1e7fced7f09d4f0bf8198624",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNTU1NTVkYTNlMjVhNDdmMWU3ZmNlZDdmMDlkNGYwYmY4MTk4NjI0",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-17T17:54:39Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-03-24T15:17:08Z"
      },
      "message": "rpc: Add testmempoolaccept",
      "tree": {
        "sha": "551e618067f55d5de6d4b05623202020ce1f626b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/551e618067f55d5de6d4b05623202020ce1f626b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b55555da3e25a47f1e7fced7f09d4f0bf8198624",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGcBAABCgAGBQJatmv0AAoJEM4rdWl+aaVIgSkMAJJBxvm6EUKVOFDsLWDoAPGo\nuuq4BqDrX0w/tCq+Y9SZ5k5+wi5rrmCFTQuQGAmSDExxxv8EOspirkZynHYs2J3y\nzi31TeH9JOq0yQfEyC2HUCr4a8ZWUpopl293xibMwVm4eIV5HW6zpCtJO4ggk71s\nJGKSS8ljT2ApG4gz12r1yg+jpo0VXMD1gftZ4Lko97YBOVjd8QfW+RNxPFRtkQgi\nSVkpWctD4EsoGw9OkZTpIpOFy4f42pZvwzFP9jnoE/ohtP1onoF/fVJn5jLYO7oK\nOIBZqHsuK6AGyr8DWrkCLh7SD/PjkcNXhUafZpjDRhxJd3cAV7ft9sd8QgHU/bUY\nnUmTKa4S31VyX4n5vo0RoTmKLDkRUTKkcDAEgrl0Va4adsMWNmGOlpzFL4l4GPBE\nXAGlDyLDDlwuGTayxPYOq/7FLL0vV2EKI+AlCc/YOXPQhfay6nvE2nmqNnFkeP6y\nSo05QdpwLPe/XIvcb2CL/Bpb4PWIMybd9z0arXxIHA==\n=EWpQ\n-----END PGP SIGNATURE-----",
        "payload": "tree 551e618067f55d5de6d4b05623202020ce1f626b\nparent b43aba89e356ff95b706e80d4802f60fc46a569a\nauthor MarcoFalke <falke.marco@gmail.com> 1510941279 -0500\ncommitter MarcoFalke <falke.marco@gmail.com> 1521904628 -0400\n\nrpc: Add testmempoolaccept\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b55555da3e25a47f1e7fced7f09d4f0bf8198624",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b55555da3e25a47f1e7fced7f09d4f0bf8198624",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b55555da3e25a47f1e7fced7f09d4f0bf8198624/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b43aba89e356ff95b706e80d4802f60fc46a569a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b43aba89e356ff95b706e80d4802f60fc46a569a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b43aba89e356ff95b706e80d4802f60fc46a569a"
      }
    ],
    "stats": {
      "total": 413,
      "additions": 399,
      "deletions": 14
    },
    "files": [
      {
        "sha": "01f932dbb4bb2a136ce75248a2ec8101d726a1ed",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b55555da3e25a47f1e7fced7f09d4f0bf8198624/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b55555da3e25a47f1e7fced7f09d4f0bf8198624/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=b55555da3e25a47f1e7fced7f09d4f0bf8198624",
        "patch": "@@ -103,6 +103,8 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"signrawtransactionwithkey\", 2, \"prevtxs\" },\n     { \"signrawtransactionwithwallet\", 1, \"prevtxs\" },\n     { \"sendrawtransaction\", 1, \"allowhighfees\" },\n+    { \"testmempoolaccept\", 0, \"rawtxs\" },\n+    { \"testmempoolaccept\", 1, \"allowhighfees\" },\n     { \"combinerawtransaction\", 0, \"txs\" },\n     { \"fundrawtransaction\", 1, \"options\" },\n     { \"fundrawtransaction\", 2, \"iswitness\" },"
      },
      {
        "sha": "3247c61242826ef3201a0d2887719ab9526f666c",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 82,
        "deletions": 0,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b55555da3e25a47f1e7fced7f09d4f0bf8198624/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b55555da3e25a47f1e7fced7f09d4f0bf8198624/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=b55555da3e25a47f1e7fced7f09d4f0bf8198624",
        "patch": "@@ -1134,6 +1134,87 @@ UniValue sendrawtransaction(const JSONRPCRequest& request)\n     return hashTx.GetHex();\n }\n \n+UniValue testmempoolaccept(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2) {\n+        throw std::runtime_error(\n+            // clang-format off\n+            \"testmempoolaccept [\\\"rawtxs\\\"] ( allowhighfees )\\n\"\n+            \"\\nReturns if raw transaction (serialized, hex-encoded) would be accepted by mempool.\\n\"\n+            \"\\nThis checks if the transaction violates the consensus or policy rules.\\n\"\n+            \"\\nSee sendrawtransaction call.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. [\\\"rawtxs\\\"]       (array, required) An array of hex strings of raw transactions.\\n\"\n+            \"                                        Length must be one for now.\\n\"\n+            \"2. allowhighfees    (boolean, optional, default=false) Allow high fees\\n\"\n+            \"\\nResult:\\n\"\n+            \"[                   (array) The result of the mempool acceptance test for each raw transaction in the input array.\\n\"\n+            \"                            Length is exactly one for now.\\n\"\n+            \" {\\n\"\n+            \"  \\\"txid\\\"           (string) The transaction hash in hex\\n\"\n+            \"  \\\"allowed\\\"        (boolean) If the mempool allows this tx to be inserted\\n\"\n+            \"  \\\"reject-reason\\\"  (string) Rejection string (only present when 'allowed' is false)\\n\"\n+            \" }\\n\"\n+            \"]\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nCreate a transaction\\n\"\n+            + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\" : \\\\\\\"mytxid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"{\\\\\\\"myaddress\\\\\\\":0.01}\\\"\") +\n+            \"Sign the transaction, and get back the hex\\n\"\n+            + HelpExampleCli(\"signrawtransaction\", \"\\\"myhex\\\"\") +\n+            \"\\nTest acceptance of the transaction (signed hex)\\n\"\n+            + HelpExampleCli(\"testmempoolaccept\", \"\\\"signedhex\\\"\") +\n+            \"\\nAs a json rpc call\\n\"\n+            + HelpExampleRpc(\"testmempoolaccept\", \"[\\\"signedhex\\\"]\")\n+            // clang-format on\n+            );\n+    }\n+\n+    ObserveSafeMode();\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL});\n+    if (request.params[0].get_array().size() != 1) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Array must contain exactly one raw transaction for now\");\n+    }\n+\n+    CMutableTransaction mtx;\n+    if (!DecodeHexTx(mtx, request.params[0].get_array()[0].get_str())) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n+    }\n+    CTransactionRef tx(MakeTransactionRef(std::move(mtx)));\n+    const uint256& tx_hash = tx->GetHash();\n+\n+    CAmount max_raw_tx_fee = ::maxTxFee;\n+    if (!request.params[1].isNull() && request.params[1].get_bool()) {\n+        max_raw_tx_fee = 0;\n+    }\n+\n+    UniValue result(UniValue::VARR);\n+    UniValue result_0(UniValue::VOBJ);\n+    result_0.pushKV(\"txid\", tx_hash.GetHex());\n+\n+    CValidationState state;\n+    bool missing_inputs;\n+    bool test_accept_res;\n+    {\n+        LOCK(cs_main);\n+        test_accept_res = AcceptToMemoryPool(mempool, state, std::move(tx), &missing_inputs,\n+            nullptr /* plTxnReplaced */, false /* bypass_limits */, max_raw_tx_fee, /* test_accpet */ true);\n+    }\n+    result_0.pushKV(\"allowed\", test_accept_res);\n+    if (!test_accept_res) {\n+        if (state.IsInvalid()) {\n+            result_0.pushKV(\"reject-reason\", strprintf(\"%i: %s\", state.GetRejectCode(), state.GetRejectReason()));\n+        } else if (missing_inputs) {\n+            result_0.pushKV(\"reject-reason\", \"missing-inputs\");\n+        } else {\n+            result_0.pushKV(\"reject-reason\", state.GetRejectReason());\n+        }\n+    }\n+\n+    result.push_back(std::move(result_0));\n+    return result;\n+}\n+\n static const CRPCCommand commands[] =\n { //  category              name                            actor (function)            argNames\n   //  --------------------- ------------------------        -----------------------     ----------\n@@ -1145,6 +1226,7 @@ static const CRPCCommand commands[] =\n     { \"rawtransactions\",    \"combinerawtransaction\",        &combinerawtransaction,     {\"txs\"} },\n     { \"rawtransactions\",    \"signrawtransaction\",           &signrawtransaction,        {\"hexstring\",\"prevtxs\",\"privkeys\",\"sighashtype\"} }, /* uses wallet if enabled */\n     { \"rawtransactions\",    \"signrawtransactionwithkey\",    &signrawtransactionwithkey, {\"hexstring\",\"privkeys\",\"prevtxs\",\"sighashtype\"} },\n+    { \"rawtransactions\",    \"testmempoolaccept\",            &testmempoolaccept,         {\"rawtxs\",\"allowhighfees\"} },\n \n     { \"blockchain\",         \"gettxoutproof\",                &gettxoutproof,             {\"txids\", \"blockhash\"} },\n     { \"blockchain\",         \"verifytxoutproof\",             &verifytxoutproof,          {\"proof\"} },"
      },
      {
        "sha": "462c165cc4b4ef2ab9bd2c7c31cb89f58cfea1ed",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b55555da3e25a47f1e7fced7f09d4f0bf8198624/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b55555da3e25a47f1e7fced7f09d4f0bf8198624/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=b55555da3e25a47f1e7fced7f09d4f0bf8198624",
        "patch": "@@ -447,7 +447,7 @@ void CTxMemPool::removeUnchecked(txiter it, MemPoolRemovalReason reason)\n // Also assumes that if an entry is in setDescendants already, then all\n // in-mempool descendants of it are already in setDescendants as well, so that we\n // can save time by not iterating over those entries.\n-void CTxMemPool::CalculateDescendants(txiter entryit, setEntries &setDescendants)\n+void CTxMemPool::CalculateDescendants(txiter entryit, setEntries& setDescendants) const\n {\n     setEntries stage;\n     if (setDescendants.count(entryit) == 0) {"
      },
      {
        "sha": "ff792cbdf06a80df98887c5e1426b1bea4ea6c9b",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b55555da3e25a47f1e7fced7f09d4f0bf8198624/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b55555da3e25a47f1e7fced7f09d4f0bf8198624/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=b55555da3e25a47f1e7fced7f09d4f0bf8198624",
        "patch": "@@ -600,7 +600,7 @@ class CTxMemPool\n     /** Populate setDescendants with all in-mempool descendants of hash.\n      *  Assumes that setDescendants includes all in-mempool descendants of anything\n      *  already in it.  */\n-    void CalculateDescendants(txiter it, setEntries &setDescendants);\n+    void CalculateDescendants(txiter it, setEntries& setDescendants) const;\n \n     /** The minimum fee to get into the mempool, which may itself not be enough\n       *  for larger-sized transactions."
      },
      {
        "sha": "084dd1f121b8f5262c67d9c1b2091a49938fe5dd",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 6,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b55555da3e25a47f1e7fced7f09d4f0bf8198624/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b55555da3e25a47f1e7fced7f09d4f0bf8198624/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=b55555da3e25a47f1e7fced7f09d4f0bf8198624",
        "patch": "@@ -542,7 +542,7 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n \n static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n                               bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache)\n+                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept)\n {\n     const CTransaction& tx = *ptx;\n     const uint256 hash = tx.GetHash();\n@@ -934,6 +934,11 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             }\n         }\n \n+        if (test_accept) {\n+            // Tx was accepted, but not added\n+            return true;\n+        }\n+\n         // Remove conflicting transactions from the mempool\n         for (const CTxMemPool::txiter it : allConflicting)\n         {\n@@ -973,10 +978,10 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n /** (try to) add transaction to memory pool with a specified acceptance time **/\n static bool AcceptToMemoryPoolWithTime(const CChainParams& chainparams, CTxMemPool& pool, CValidationState &state, const CTransactionRef &tx,\n                         bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                        bool bypass_limits, const CAmount nAbsurdFee)\n+                        bool bypass_limits, const CAmount nAbsurdFee, bool test_accept)\n {\n     std::vector<COutPoint> coins_to_uncache;\n-    bool res = AcceptToMemoryPoolWorker(chainparams, pool, state, tx, pfMissingInputs, nAcceptTime, plTxnReplaced, bypass_limits, nAbsurdFee, coins_to_uncache);\n+    bool res = AcceptToMemoryPoolWorker(chainparams, pool, state, tx, pfMissingInputs, nAcceptTime, plTxnReplaced, bypass_limits, nAbsurdFee, coins_to_uncache, test_accept);\n     if (!res) {\n         for (const COutPoint& hashTx : coins_to_uncache)\n             pcoinsTip->Uncache(hashTx);\n@@ -989,10 +994,10 @@ static bool AcceptToMemoryPoolWithTime(const CChainParams& chainparams, CTxMemPo\n \n bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransactionRef &tx,\n                         bool* pfMissingInputs, std::list<CTransactionRef>* plTxnReplaced,\n-                        bool bypass_limits, const CAmount nAbsurdFee)\n+                        bool bypass_limits, const CAmount nAbsurdFee, bool test_accept)\n {\n     const CChainParams& chainparams = Params();\n-    return AcceptToMemoryPoolWithTime(chainparams, pool, state, tx, pfMissingInputs, GetTime(), plTxnReplaced, bypass_limits, nAbsurdFee);\n+    return AcceptToMemoryPoolWithTime(chainparams, pool, state, tx, pfMissingInputs, GetTime(), plTxnReplaced, bypass_limits, nAbsurdFee, test_accept);\n }\n \n /**\n@@ -4639,7 +4644,8 @@ bool LoadMempool(void)\n             if (nTime + nExpiryTimeout > nNow) {\n                 LOCK(cs_main);\n                 AcceptToMemoryPoolWithTime(chainparams, mempool, state, tx, nullptr /* pfMissingInputs */, nTime,\n-                                           nullptr /* plTxnReplaced */, false /* bypass_limits */, 0 /* nAbsurdFee */);\n+                                           nullptr /* plTxnReplaced */, false /* bypass_limits */, 0 /* nAbsurdFee */,\n+                                           false /* test_accept */);\n                 if (state.IsValid()) {\n                     ++count;\n                 } else {"
      },
      {
        "sha": "a658d8c5d31e72cd12f259c246b883f6673f92a8",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b55555da3e25a47f1e7fced7f09d4f0bf8198624/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b55555da3e25a47f1e7fced7f09d4f0bf8198624/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=b55555da3e25a47f1e7fced7f09d4f0bf8198624",
        "patch": "@@ -307,7 +307,7 @@ void PruneBlockFilesManual(int nManualPruneHeight);\n  * plTxnReplaced will be appended to with all transactions replaced from mempool **/\n bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransactionRef &tx,\n                         bool* pfMissingInputs, std::list<CTransactionRef>* plTxnReplaced,\n-                        bool bypass_limits, const CAmount nAbsurdFee);\n+                        bool bypass_limits, const CAmount nAbsurdFee, bool test_accept=false);\n \n /** Convert CValidationState to a human-readable message for logging */\n std::string FormatStateMessage(const CValidationState &state);"
      },
      {
        "sha": "7cdb24c6a5c44d9e6a550dd62cd792e8d752f4c9",
        "filename": "test/functional/mempool_accept.py",
        "status": "added",
        "additions": 293,
        "deletions": 0,
        "changes": 293,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b55555da3e25a47f1e7fced7f09d4f0bf8198624/test/functional/mempool_accept.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b55555da3e25a47f1e7fced7f09d4f0bf8198624/test/functional/mempool_accept.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_accept.py?ref=b55555da3e25a47f1e7fced7f09d4f0bf8198624",
        "patch": "@@ -0,0 +1,293 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test mempool acceptance of raw transactions.\"\"\"\n+\n+from io import BytesIO\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.messages import (\n+    BIP125_SEQUENCE_NUMBER,\n+    COIN,\n+    COutPoint,\n+    CTransaction,\n+    CTxOut,\n+    MAX_BLOCK_BASE_SIZE,\n+)\n+from test_framework.script import (\n+    hash160,\n+    CScript,\n+    OP_0,\n+    OP_EQUAL,\n+    OP_HASH160,\n+    OP_RETURN,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_rpc_error,\n+    bytes_to_hex_str,\n+    hex_str_to_bytes,\n+    wait_until,\n+)\n+\n+\n+class MempoolAcceptanceTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            '-checkmempool',\n+            '-txindex',\n+            '-reindex',  # Need reindex for txindex\n+            '-acceptnonstdtxn=0',  # Try to mimic main-net\n+        ]] * self.num_nodes\n+\n+    def check_mempool_result(self, result_expected, *args, **kwargs):\n+        \"\"\"Wrapper to check result of testmempoolaccept on node_0's mempool\"\"\"\n+        result_test = self.nodes[0].testmempoolaccept(*args, **kwargs)\n+        assert_equal(result_expected, result_test)\n+        assert_equal(self.nodes[0].getmempoolinfo()['size'], self.mempool_size)  # Must not change mempool state\n+\n+    def run_test(self):\n+        node = self.nodes[0]\n+\n+        self.log.info('Start with empty mempool, and 200 blocks')\n+        self.mempool_size = 0\n+        wait_until(lambda: node.getblockcount() == 200)\n+        assert_equal(node.getmempoolinfo()['size'], self.mempool_size)\n+\n+        self.log.info('Should not accept garbage to testmempoolaccept')\n+        assert_raises_rpc_error(-3, 'Expected type array, got string', lambda: node.testmempoolaccept(rawtxs='ff00baar'))\n+        assert_raises_rpc_error(-8, 'Array must contain exactly one raw transaction for now', lambda: node.testmempoolaccept(rawtxs=['ff00baar', 'ff22']))\n+        assert_raises_rpc_error(-22, 'TX decode failed', lambda: node.testmempoolaccept(rawtxs=['ff00baar']))\n+\n+        self.log.info('A transaction already in the blockchain')\n+        coin = node.listunspent()[0]  # Pick a random coin(base) to spend\n+        raw_tx_in_block = node.signrawtransactionwithwallet(node.createrawtransaction(\n+            inputs=[{'txid': coin['txid'], 'vout': coin['vout']}],\n+            outputs=[{node.getnewaddress(): 0.3}, {node.getnewaddress(): 49}],\n+        ))['hex']\n+        txid_in_block = node.sendrawtransaction(hexstring=raw_tx_in_block, allowhighfees=True)\n+        node.generate(1)\n+        self.check_mempool_result(\n+            result_expected=[{'txid': txid_in_block, 'allowed': False, 'reject-reason': '18: txn-already-known'}],\n+            rawtxs=[raw_tx_in_block],\n+        )\n+\n+        self.log.info('A transaction not in the mempool')\n+        fee = 0.00000700\n+        raw_tx_0 = node.signrawtransactionwithwallet(node.createrawtransaction(\n+            inputs=[{\"txid\": txid_in_block, \"vout\": 0, \"sequence\": BIP125_SEQUENCE_NUMBER}],  # RBF is used later\n+            outputs=[{node.getnewaddress(): 0.3 - fee}],\n+        ))['hex']\n+        tx = CTransaction()\n+        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_0)))\n+        txid_0 = tx.rehash()\n+        self.check_mempool_result(\n+            result_expected=[{'txid': txid_0, 'allowed': True}],\n+            rawtxs=[raw_tx_0],\n+        )\n+\n+        self.log.info('A transaction in the mempool')\n+        node.sendrawtransaction(hexstring=raw_tx_0)\n+        self.mempool_size = 1\n+        self.check_mempool_result(\n+            result_expected=[{'txid': txid_0, 'allowed': False, 'reject-reason': '18: txn-already-in-mempool'}],\n+            rawtxs=[raw_tx_0],\n+        )\n+\n+        self.log.info('A transaction that replaces a mempool transaction')\n+        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_0)))\n+        tx.vout[0].nValue -= int(fee * COIN)  # Double the fee\n+        tx.vin[0].nSequence = BIP125_SEQUENCE_NUMBER + 1  # Now, opt out of RBF\n+        raw_tx_0 = node.signrawtransactionwithwallet(bytes_to_hex_str(tx.serialize()))['hex']\n+        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_0)))\n+        txid_0 = tx.rehash()\n+        self.check_mempool_result(\n+            result_expected=[{'txid': txid_0, 'allowed': True}],\n+            rawtxs=[raw_tx_0],\n+        )\n+\n+        self.log.info('A transaction that conflicts with an unconfirmed tx')\n+        # Send the transaction that replaces the mempool transaction and opts out of replaceability\n+        node.sendrawtransaction(hexstring=bytes_to_hex_str(tx.serialize()), allowhighfees=True)\n+        # take original raw_tx_0\n+        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_0)))\n+        tx.vout[0].nValue -= int(4 * fee * COIN)  # Set more fee\n+        # skip re-signing the tx\n+        self.check_mempool_result(\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '18: txn-mempool-conflict'}],\n+            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+            allowhighfees=True,\n+        )\n+\n+        self.log.info('A transaction with missing inputs, that never existed')\n+        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_0)))\n+        tx.vin[0].prevout = COutPoint(hash=int('ff' * 32, 16), n=14)\n+        # skip re-signing the tx\n+        self.check_mempool_result(\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'missing-inputs'}],\n+            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+        )\n+\n+        self.log.info('A transaction with missing inputs, that existed once in the past')\n+        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_0)))\n+        tx.vin[0].prevout.n = 1  # Set vout to 1, to spend the other outpoint (49 coins) of the in-chain-tx we want to double spend\n+        raw_tx_1 = node.signrawtransactionwithwallet(bytes_to_hex_str(tx.serialize()))['hex']\n+        txid_1 = node.sendrawtransaction(hexstring=raw_tx_1, allowhighfees=True)\n+        # Now spend both to \"clearly hide\" the outputs, ie. remove the coins from the utxo set by spending them\n+        raw_tx_spend_both = node.signrawtransactionwithwallet(node.createrawtransaction(\n+            inputs=[\n+                {'txid': txid_0, 'vout': 0},\n+                {'txid': txid_1, 'vout': 0},\n+            ],\n+            outputs=[{node.getnewaddress(): 0.1}]\n+        ))['hex']\n+        txid_spend_both = node.sendrawtransaction(hexstring=raw_tx_spend_both, allowhighfees=True)\n+        node.generate(1)\n+        self.mempool_size = 0\n+        # Now see if we can add the coins back to the utxo set by sending the exact txs again\n+        self.check_mempool_result(\n+            result_expected=[{'txid': txid_0, 'allowed': False, 'reject-reason': 'missing-inputs'}],\n+            rawtxs=[raw_tx_0],\n+        )\n+        self.check_mempool_result(\n+            result_expected=[{'txid': txid_1, 'allowed': False, 'reject-reason': 'missing-inputs'}],\n+            rawtxs=[raw_tx_1],\n+        )\n+\n+        self.log.info('Create a signed \"reference\" tx for later use')\n+        raw_tx_reference = node.signrawtransactionwithwallet(node.createrawtransaction(\n+            inputs=[{'txid': txid_spend_both, 'vout': 0}],\n+            outputs=[{node.getnewaddress(): 0.05}],\n+        ))['hex']\n+        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        # Reference tx should be valid on itself\n+        self.check_mempool_result(\n+            result_expected=[{'txid': tx.rehash(), 'allowed': True}],\n+            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+        )\n+\n+        self.log.info('A transaction with no outputs')\n+        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx.vout = []\n+        # Skip re-signing the transaction for context independent checks from now on\n+        # tx.deserialize(BytesIO(hex_str_to_bytes(node.signrawtransactionwithwallet(bytes_to_hex_str(tx.serialize()))['hex'])))\n+        self.check_mempool_result(\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '16: bad-txns-vout-empty'}],\n+            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+        )\n+\n+        self.log.info('A really large transaction')\n+        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx.vin = [tx.vin[0]] * (MAX_BLOCK_BASE_SIZE // len(tx.vin[0].serialize()))\n+        self.check_mempool_result(\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '16: bad-txns-oversize'}],\n+            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+        )\n+\n+        self.log.info('A transaction with negative output value')\n+        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx.vout[0].nValue *= -1\n+        self.check_mempool_result(\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '16: bad-txns-vout-negative'}],\n+            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+        )\n+\n+        self.log.info('A transaction with too large output value')\n+        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx.vout[0].nValue = 21000000 * COIN + 1\n+        self.check_mempool_result(\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '16: bad-txns-vout-toolarge'}],\n+            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+        )\n+\n+        self.log.info('A transaction with too large sum of output values')\n+        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx.vout = [tx.vout[0]] * 2\n+        tx.vout[0].nValue = 21000000 * COIN\n+        self.check_mempool_result(\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '16: bad-txns-txouttotal-toolarge'}],\n+            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+        )\n+\n+        self.log.info('A transaction with duplicate inputs')\n+        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx.vin = [tx.vin[0]] * 2\n+        self.check_mempool_result(\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '16: bad-txns-inputs-duplicate'}],\n+            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+        )\n+\n+        self.log.info('A coinbase transaction')\n+        # Pick the input of the first tx we signed, so it has to be a coinbase tx\n+        raw_tx_coinbase_spent = node.getrawtransaction(txid=node.decoderawtransaction(hexstring=raw_tx_in_block)['vin'][0]['txid'])\n+        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_coinbase_spent)))\n+        self.check_mempool_result(\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '16: coinbase'}],\n+            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+        )\n+\n+        self.log.info('Some nonstandard transactions')\n+        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx.nVersion = 3  # A version currently non-standard\n+        self.check_mempool_result(\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '64: version'}],\n+            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+        )\n+        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx.vout[0].scriptPubKey = CScript([OP_0])  # Some non-standard script\n+        self.check_mempool_result(\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '64: scriptpubkey'}],\n+            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+        )\n+        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx.vin[0].scriptSig = CScript([OP_HASH160])  # Some not-pushonly scriptSig\n+        self.check_mempool_result(\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '64: scriptsig-not-pushonly'}],\n+            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+        )\n+        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        output_p2sh_burn = CTxOut(nValue=540, scriptPubKey=CScript([OP_HASH160, hash160(b'burn'), OP_EQUAL]))\n+        num_scripts = 100000 // len(output_p2sh_burn.serialize())  # Use enough outputs to make the tx too large for our policy\n+        tx.vout = [output_p2sh_burn] * num_scripts\n+        self.check_mempool_result(\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '64: tx-size'}],\n+            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+        )\n+        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx.vout[0] = output_p2sh_burn\n+        tx.vout[0].nValue -= 1  # Make output smaller, such that it is dust for our policy\n+        self.check_mempool_result(\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '64: dust'}],\n+            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+        )\n+        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx.vout[0].scriptPubKey = CScript([OP_RETURN, b'\\xff'])\n+        tx.vout = [tx.vout[0]] * 2\n+        self.check_mempool_result(\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '64: multi-op-return'}],\n+            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+        )\n+\n+        self.log.info('A timelocked transaction')\n+        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx.vin[0].nSequence -= 1  # Should be non-max, so locktime is not ignored\n+        tx.nLockTime = node.getblockcount() + 1\n+        self.check_mempool_result(\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '64: non-final'}],\n+            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+        )\n+\n+        self.log.info('A transaction that is locked by BIP68 sequence logic')\n+        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx.vin[0].nSequence = 2  # We could include it in the second block mined from now, but not the very next one\n+        # Can skip re-signing the tx because of early rejection\n+        self.check_mempool_result(\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '64: non-BIP68-final'}],\n+            rawtxs=[bytes_to_hex_str(tx.serialize())],\n+            allowhighfees=True,\n+        )\n+\n+\n+if __name__ == '__main__':\n+    MempoolAcceptanceTest().main()"
      },
      {
        "sha": "ca2e425bd658710af8b110ef7e0b0439dec40c34",
        "filename": "test/functional/test_framework/messages.py",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b55555da3e25a47f1e7fced7f09d4f0bf8198624/test/functional/test_framework/messages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b55555da3e25a47f1e7fced7f09d4f0bf8198624/test/functional/test_framework/messages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/messages.py?ref=b55555da3e25a47f1e7fced7f09d4f0bf8198624",
        "patch": "@@ -34,7 +34,9 @@\n MAX_INV_SZ = 50000\n MAX_BLOCK_BASE_SIZE = 1000000\n \n-COIN = 100000000 # 1 btc in satoshis\n+COIN = 100000000  # 1 btc in satoshis\n+\n+BIP125_SEQUENCE_NUMBER = 0xfffffffd  # Sequence number that is BIP 125 opt-in and BIP 68-opt-out\n \n NODE_NETWORK = (1 << 0)\n # NODE_GETUTXO = (1 << 1)\n@@ -470,6 +472,7 @@ def serialize(self):\n     def rehash(self):\n         self.sha256 = None\n         self.calc_sha256()\n+        return self.hash\n \n     # We will only cache the serialization without witness in\n     # self.sha256 and self.hash -- those are expected to be the txid."
      },
      {
        "sha": "d0b8bb44167fd619fcdc2bf55082232c219e2ed2",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b55555da3e25a47f1e7fced7f09d4f0bf8198624/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b55555da3e25a47f1e7fced7f09d4f0bf8198624/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=b55555da3e25a47f1e7fced7f09d4f0bf8198624",
        "patch": "@@ -55,7 +55,7 @@\n # 20 minutes represented in seconds\n TRAVIS_TIMEOUT_DURATION = 20 * 60\n \n-BASE_SCRIPTS= [\n+BASE_SCRIPTS = [\n     # Scripts that are run by the travis build process.\n     # Longest test should go first, to favor running tests in parallel\n     'wallet_hd.py',\n@@ -118,6 +118,7 @@\n     'wallet_importprunedfunds.py',\n     'rpc_signmessage.py',\n     'feature_nulldummy.py',\n+    'mempool_accept.py',\n     'wallet_import_rescan.py',\n     'mining_basic.py',\n     'wallet_bumpfee.py',"
      },
      {
        "sha": "5efc846b6e64023990f0d63281582bc1f0a8c0b9",
        "filename": "test/functional/wallet_bumpfee.py",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b55555da3e25a47f1e7fced7f09d4f0bf8198624/test/functional/wallet_bumpfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b55555da3e25a47f1e7fced7f09d4f0bf8198624/test/functional/wallet_bumpfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_bumpfee.py?ref=b55555da3e25a47f1e7fced7f09d4f0bf8198624",
        "patch": "@@ -17,14 +17,12 @@\n from test_framework.blocktools import send_to_witness\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework import blocktools\n+from test_framework.messages import BIP125_SEQUENCE_NUMBER\n from test_framework.mininode import CTransaction\n from test_framework.util import *\n \n import io\n \n-# Sequence number that is BIP 125 opt-in and BIP 68-compliant\n-BIP125_SEQUENCE_NUMBER = 0xfffffffd\n-\n WALLET_PASSPHRASE = \"test\"\n WALLET_PASSPHRASE_TIMEOUT = 3600\n "
      }
    ]
  }
]