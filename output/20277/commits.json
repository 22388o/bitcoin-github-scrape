[
  {
    "sha": "5b2ab873f7c793ea8ce871260b35f7d50b0ee680",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1YjJhYjg3M2Y3Yzc5M2VhOGNlODcxMjYwYjM1ZjdkNTBiMGVlNjgw",
    "commit": {
      "author": {
        "name": "Antoine Riard",
        "email": "antoine.riard@gmail.com",
        "date": "2020-10-27T14:19:39Z"
      },
      "committer": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2021-02-08T15:37:50Z"
      },
      "message": "test: Make getdata accounting a generic P2PInterface option\n\nWe also move some constants from net_processing in p2p.py",
      "tree": {
        "sha": "ebf18a8d8572c839b8eab769f6909ba483f65365",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ebf18a8d8572c839b8eab769f6909ba483f65365"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5b2ab873f7c793ea8ce871260b35f7d50b0ee680",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5b2ab873f7c793ea8ce871260b35f7d50b0ee680",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5b2ab873f7c793ea8ce871260b35f7d50b0ee680",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5b2ab873f7c793ea8ce871260b35f7d50b0ee680/comments",
    "author": {
      "login": "ariard",
      "id": 23310655,
      "node_id": "MDQ6VXNlcjIzMzEwNjU1",
      "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ariard",
      "html_url": "https://github.com/ariard",
      "followers_url": "https://api.github.com/users/ariard/followers",
      "following_url": "https://api.github.com/users/ariard/following{/other_user}",
      "gists_url": "https://api.github.com/users/ariard/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ariard/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
      "organizations_url": "https://api.github.com/users/ariard/orgs",
      "repos_url": "https://api.github.com/users/ariard/repos",
      "events_url": "https://api.github.com/users/ariard/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ariard/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": null,
    "parents": [
      {
        "sha": "b401b093556f53023d1615f7cff3eb84807c6e8b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b401b093556f53023d1615f7cff3eb84807c6e8b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b401b093556f53023d1615f7cff3eb84807c6e8b"
      }
    ],
    "stats": {
      "total": 68,
      "additions": 32,
      "deletions": 36
    },
    "files": [
      {
        "sha": "378c9f4a4c97f81faa9af1ad9301af4f35c94c2b",
        "filename": "test/functional/p2p_tx_download.py",
        "status": "modified",
        "additions": 21,
        "deletions": 35,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5b2ab873f7c793ea8ce871260b35f7d50b0ee680/test/functional/p2p_tx_download.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5b2ab873f7c793ea8ce871260b35f7d50b0ee680/test/functional/p2p_tx_download.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_tx_download.py?ref=5b2ab873f7c793ea8ce871260b35f7d50b0ee680",
        "patch": "@@ -11,14 +11,15 @@\n     CTransaction,\n     FromHex,\n     MSG_TX,\n-    MSG_TYPE_MASK,\n     MSG_WTX,\n     msg_inv,\n     msg_notfound,\n )\n from test_framework.p2p import (\n     P2PInterface,\n     p2p_lock,\n+    NONPREF_PEER_TX_DELAY,\n+    TXID_RELAY_DELAY,\n )\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n@@ -28,30 +29,15 @@\n \n import time\n \n-\n-class TestP2PConn(P2PInterface):\n-    def __init__(self, wtxidrelay=True):\n-        super().__init__(wtxidrelay=wtxidrelay)\n-        self.tx_getdata_count = 0\n-\n-    def on_getdata(self, message):\n-        for i in message.inv:\n-            if i.type & MSG_TYPE_MASK == MSG_TX or i.type & MSG_TYPE_MASK == MSG_WTX:\n-                self.tx_getdata_count += 1\n-\n-\n # Constants from net_processing\n GETDATA_TX_INTERVAL = 60  # seconds\n-INBOUND_PEER_TX_DELAY = 2  # seconds\n-TXID_RELAY_DELAY = 2 # seconds\n OVERLOADED_PEER_DELAY = 2 # seconds\n MAX_GETDATA_IN_FLIGHT = 100\n MAX_PEER_TX_ANNOUNCEMENTS = 5000\n-NONPREF_PEER_TX_DELAY = 2\n \n # Python test constants\n NUM_INBOUND = 10\n-MAX_GETDATA_INBOUND_WAIT = GETDATA_TX_INTERVAL + INBOUND_PEER_TX_DELAY + TXID_RELAY_DELAY\n+MAX_GETDATA_INBOUND_WAIT = GETDATA_TX_INTERVAL + NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY\n \n \n class TxDownloadTest(BitcoinTestFramework):\n@@ -121,7 +107,7 @@ def test_inv_block(self):\n         # * the first time it is re-requested from the outbound peer, plus\n         # * 2 seconds to avoid races\n         assert self.nodes[1].getpeerinfo()[0]['inbound'] == False\n-        timeout = 2 + INBOUND_PEER_TX_DELAY + GETDATA_TX_INTERVAL\n+        timeout = 2 + NONPREF_PEER_TX_DELAY + GETDATA_TX_INTERVAL\n         self.log.info(\"Tx should be received at node 1 after {} seconds\".format(timeout))\n         self.sync_mempools(timeout=timeout)\n \n@@ -139,26 +125,26 @@ def test_in_flight_max(self):\n         for i in range(MAX_GETDATA_IN_FLIGHT):\n             p.send_message(msg_inv([CInv(t=MSG_WTX, h=txids[i])]))\n         p.sync_with_ping()\n-        mock_time += INBOUND_PEER_TX_DELAY\n+        mock_time += NONPREF_PEER_TX_DELAY\n         self.nodes[0].setmocktime(mock_time)\n         p.wait_until(lambda: p.tx_getdata_count >= MAX_GETDATA_IN_FLIGHT)\n         for i in range(MAX_GETDATA_IN_FLIGHT, len(txids)):\n             p.send_message(msg_inv([CInv(t=MSG_WTX, h=txids[i])]))\n         p.sync_with_ping()\n-        self.log.info(\"No more than {} requests should be seen within {} seconds after announcement\".format(MAX_GETDATA_IN_FLIGHT, INBOUND_PEER_TX_DELAY + OVERLOADED_PEER_DELAY - 1))\n-        self.nodes[0].setmocktime(mock_time + INBOUND_PEER_TX_DELAY + OVERLOADED_PEER_DELAY - 1)\n+        self.log.info(\"No more than {} requests should be seen within {} seconds after announcement\".format(MAX_GETDATA_IN_FLIGHT, NONPREF_PEER_TX_DELAY + OVERLOADED_PEER_DELAY - 1))\n+        self.nodes[0].setmocktime(mock_time + NONPREF_PEER_TX_DELAY + OVERLOADED_PEER_DELAY - 1)\n         p.sync_with_ping()\n         with p2p_lock:\n             assert_equal(p.tx_getdata_count, MAX_GETDATA_IN_FLIGHT)\n-        self.log.info(\"If we wait {} seconds after announcement, we should eventually get more requests\".format(INBOUND_PEER_TX_DELAY + OVERLOADED_PEER_DELAY))\n-        self.nodes[0].setmocktime(mock_time + INBOUND_PEER_TX_DELAY + OVERLOADED_PEER_DELAY)\n+        self.log.info(\"If we wait {} seconds after announcement, we should eventually get more requests\".format(NONPREF_PEER_TX_DELAY + OVERLOADED_PEER_DELAY))\n+        self.nodes[0].setmocktime(mock_time + NONPREF_PEER_TX_DELAY + OVERLOADED_PEER_DELAY)\n         p.wait_until(lambda: p.tx_getdata_count == len(txids))\n \n     def test_expiry_fallback(self):\n         self.log.info('Check that expiry will select another peer for download')\n         WTXID = 0xffaa\n-        peer1 = self.nodes[0].add_p2p_connection(TestP2PConn())\n-        peer2 = self.nodes[0].add_p2p_connection(TestP2PConn())\n+        peer1 = self.nodes[0].add_p2p_connection(P2PInterface())\n+        peer2 = self.nodes[0].add_p2p_connection(P2PInterface())\n         for p in [peer1, peer2]:\n             p.send_message(msg_inv([CInv(t=MSG_WTX, h=WTXID)]))\n         # One of the peers is asked for the tx\n@@ -173,8 +159,8 @@ def test_expiry_fallback(self):\n     def test_disconnect_fallback(self):\n         self.log.info('Check that disconnect will select another peer for download')\n         WTXID = 0xffbb\n-        peer1 = self.nodes[0].add_p2p_connection(TestP2PConn())\n-        peer2 = self.nodes[0].add_p2p_connection(TestP2PConn())\n+        peer1 = self.nodes[0].add_p2p_connection(P2PInterface())\n+        peer2 = self.nodes[0].add_p2p_connection(P2PInterface())\n         for p in [peer1, peer2]:\n             p.send_message(msg_inv([CInv(t=MSG_WTX, h=WTXID)]))\n         # One of the peers is asked for the tx\n@@ -189,8 +175,8 @@ def test_disconnect_fallback(self):\n     def test_notfound_fallback(self):\n         self.log.info('Check that notfounds will select another peer for download immediately')\n         WTXID = 0xffdd\n-        peer1 = self.nodes[0].add_p2p_connection(TestP2PConn())\n-        peer2 = self.nodes[0].add_p2p_connection(TestP2PConn())\n+        peer1 = self.nodes[0].add_p2p_connection(P2PInterface())\n+        peer2 = self.nodes[0].add_p2p_connection(P2PInterface())\n         for p in [peer1, peer2]:\n             p.send_message(msg_inv([CInv(t=MSG_WTX, h=WTXID)]))\n         # One of the peers is asked for the tx\n@@ -209,7 +195,7 @@ def test_preferred_inv(self, preferred=False):\n             self.log.info('Check invs from non-preferred peers are downloaded after {} s'.format(NONPREF_PEER_TX_DELAY))\n         mock_time = int(time.time() + 1)\n         self.nodes[0].setmocktime(mock_time)\n-        peer = self.nodes[0].add_p2p_connection(TestP2PConn())\n+        peer = self.nodes[0].add_p2p_connection(P2PInterface())\n         peer.send_message(msg_inv([CInv(t=MSG_WTX, h=0xff00ff00)]))\n         peer.sync_with_ping()\n         if preferred:\n@@ -225,11 +211,11 @@ def test_txid_inv_delay(self, glob_wtxid=False):\n         self.restart_node(0, extra_args=['-whitelist=noban@127.0.0.1'])\n         mock_time = int(time.time() + 1)\n         self.nodes[0].setmocktime(mock_time)\n-        peer = self.nodes[0].add_p2p_connection(TestP2PConn(wtxidrelay=False))\n+        peer = self.nodes[0].add_p2p_connection(P2PInterface(wtxidrelay=False))\n         if glob_wtxid:\n             # Add a second wtxid-relay connection otherwise TXID_RELAY_DELAY is waived in\n             # lack of wtxid-relay peers\n-            self.nodes[0].add_p2p_connection(TestP2PConn(wtxidrelay=True))\n+            self.nodes[0].add_p2p_connection(P2PInterface(wtxidrelay=True))\n         peer.send_message(msg_inv([CInv(t=MSG_TX, h=0xff11ff11)]))\n         peer.sync_with_ping()\n         with p2p_lock:\n@@ -240,13 +226,13 @@ def test_txid_inv_delay(self, glob_wtxid=False):\n     def test_large_inv_batch(self):\n         self.log.info('Test how large inv batches are handled with relay permission')\n         self.restart_node(0, extra_args=['-whitelist=relay@127.0.0.1'])\n-        peer = self.nodes[0].add_p2p_connection(TestP2PConn())\n+        peer = self.nodes[0].add_p2p_connection(P2PInterface())\n         peer.send_message(msg_inv([CInv(t=MSG_WTX, h=wtxid) for wtxid in range(MAX_PEER_TX_ANNOUNCEMENTS + 1)]))\n         peer.wait_until(lambda: peer.tx_getdata_count == MAX_PEER_TX_ANNOUNCEMENTS + 1)\n \n         self.log.info('Test how large inv batches are handled without relay permission')\n         self.restart_node(0)\n-        peer = self.nodes[0].add_p2p_connection(TestP2PConn())\n+        peer = self.nodes[0].add_p2p_connection(P2PInterface())\n         peer.send_message(msg_inv([CInv(t=MSG_WTX, h=wtxid) for wtxid in range(MAX_PEER_TX_ANNOUNCEMENTS + 1)]))\n         peer.wait_until(lambda: peer.tx_getdata_count == MAX_PEER_TX_ANNOUNCEMENTS)\n         peer.sync_with_ping()\n@@ -277,7 +263,7 @@ def run_test(self):\n             self.peers = []\n             for node in self.nodes:\n                 for _ in range(NUM_INBOUND):\n-                    self.peers.append(node.add_p2p_connection(TestP2PConn()))\n+                    self.peers.append(node.add_p2p_connection(P2PInterface()))\n             self.log.info(\"Nodes are setup with {} incoming connections each\".format(NUM_INBOUND))\n             test()\n "
      },
      {
        "sha": "4dc8e589f23bc8c87728ce7a7ce8c8ebe69d9b5f",
        "filename": "test/functional/test_framework/p2p.py",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5b2ab873f7c793ea8ce871260b35f7d50b0ee680/test/functional/test_framework/p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5b2ab873f7c793ea8ce871260b35f7d50b0ee680/test/functional/test_framework/p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/p2p.py?ref=5b2ab873f7c793ea8ce871260b35f7d50b0ee680",
        "patch": "@@ -120,6 +120,9 @@\n     \"signet\": b\"\\x0a\\x03\\xcf\\x40\",    # signet\n }\n \n+# Constants from net_processing\n+NONPREF_PEER_TX_DELAY = 2  # seconds\n+TXID_RELAY_DELAY = 2 # seconds\n \n class P2PConnection(asyncio.Protocol):\n     \"\"\"A low-level connection object to a node's P2P interface.\n@@ -324,6 +327,9 @@ def __init__(self, support_addrv2=False, wtxidrelay=True):\n         # If the peer supports wtxid-relay\n         self.wtxidrelay = wtxidrelay\n \n+        # Getdata counter for tx-relay related tests\n+        self.tx_getdata_count = 0\n+\n     def peer_connect_send_version(self, services):\n         # Send a version msg\n         vt = msg_version()\n@@ -389,7 +395,6 @@ def on_filterload(self, message): pass\n     def on_getaddr(self, message): pass\n     def on_getblocks(self, message): pass\n     def on_getblocktxn(self, message): pass\n-    def on_getdata(self, message): pass\n     def on_getheaders(self, message): pass\n     def on_headers(self, message): pass\n     def on_mempool(self, message): pass\n@@ -425,6 +430,11 @@ def on_version(self, message):\n         self.send_message(msg_verack())\n         self.nServices = message.nServices\n \n+    def on_getdata(self, message):\n+        for i in message.inv:\n+            if (i.type & MSG_TYPE_MASK) in {MSG_TX, MSG_WTX}:\n+                self.tx_getdata_count += 1\n+\n     # Connection helper methods\n \n     def wait_until(self, test_function_in, *, timeout=60, check_connected=True):"
      }
    ]
  },
  {
    "sha": "ec04fa50c703e726f2315195892d22c4486bf31a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplYzA0ZmE1MGM3MDNlNzI2ZjIzMTUxOTU4OTJkMjJjNDQ4NmJmMzFh",
    "commit": {
      "author": {
        "name": "Antoine Riard",
        "email": "antoine.riard@gmail.com",
        "date": "2020-10-27T15:02:53Z"
      },
      "committer": {
        "name": "Antoine Riard",
        "email": "antoine.riard@gmail.com",
        "date": "2021-02-23T15:15:30Z"
      },
      "message": "test: add coverage for no tx-request during ibd",
      "tree": {
        "sha": "02297abc158a8388e7c39d121da2dba289ddef7c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/02297abc158a8388e7c39d121da2dba289ddef7c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ec04fa50c703e726f2315195892d22c4486bf31a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ec04fa50c703e726f2315195892d22c4486bf31a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ec04fa50c703e726f2315195892d22c4486bf31a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ec04fa50c703e726f2315195892d22c4486bf31a/comments",
    "author": {
      "login": "ariard",
      "id": 23310655,
      "node_id": "MDQ6VXNlcjIzMzEwNjU1",
      "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ariard",
      "html_url": "https://github.com/ariard",
      "followers_url": "https://api.github.com/users/ariard/followers",
      "following_url": "https://api.github.com/users/ariard/following{/other_user}",
      "gists_url": "https://api.github.com/users/ariard/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ariard/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
      "organizations_url": "https://api.github.com/users/ariard/orgs",
      "repos_url": "https://api.github.com/users/ariard/repos",
      "events_url": "https://api.github.com/users/ariard/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ariard/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ariard",
      "id": 23310655,
      "node_id": "MDQ6VXNlcjIzMzEwNjU1",
      "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ariard",
      "html_url": "https://github.com/ariard",
      "followers_url": "https://api.github.com/users/ariard/followers",
      "following_url": "https://api.github.com/users/ariard/following{/other_user}",
      "gists_url": "https://api.github.com/users/ariard/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ariard/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
      "organizations_url": "https://api.github.com/users/ariard/orgs",
      "repos_url": "https://api.github.com/users/ariard/repos",
      "events_url": "https://api.github.com/users/ariard/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ariard/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5b2ab873f7c793ea8ce871260b35f7d50b0ee680",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5b2ab873f7c793ea8ce871260b35f7d50b0ee680",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5b2ab873f7c793ea8ce871260b35f7d50b0ee680"
      }
    ],
    "stats": {
      "total": 41,
      "additions": 38,
      "deletions": 3
    },
    "files": [
      {
        "sha": "11217c1f9ab66a774b04257641f7240f622ed48a",
        "filename": "test/functional/p2p_ibd_txrelay.py",
        "status": "modified",
        "additions": 38,
        "deletions": 3,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ec04fa50c703e726f2315195892d22c4486bf31a/test/functional/p2p_ibd_txrelay.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ec04fa50c703e726f2315195892d22c4486bf31a/test/functional/p2p_ibd_txrelay.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_ibd_txrelay.py?ref=ec04fa50c703e726f2315195892d22c4486bf31a",
        "patch": "@@ -2,12 +2,30 @@\n # Copyright (c) 2020 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Test fee filters during and after IBD.\"\"\"\n+\"\"\"This test covers tx-relay behaviors which are function of IBD\n+    * switching fee filter setting during and after IBD\n+    * stop tx-requesting during IBD\n+\"\"\"\n \n from decimal import Decimal\n \n-from test_framework.messages import COIN\n+from test_framework.messages import (\n+    COIN,\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+    p2p_lock,\n+    NONPREF_PEER_TX_DELAY,\n+)\n from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+)\n+\n+import time\n \n MAX_FEE_FILTER = Decimal(9170997) / COIN\n NORMAL_FEE_FILTER = Decimal(100) / COIN\n@@ -22,7 +40,21 @@ def set_test_params(self):\n             [\"-minrelaytxfee={}\".format(NORMAL_FEE_FILTER)],\n         ]\n \n-    def run_test(self):\n+    def test_inv_ibd(self):\n+        self.log.info(\"Check that nodes don't request txn while still in IBD\")\n+        peer = self.nodes[0].add_p2p_connection(P2PInterface())\n+        peer.send_message(msg_inv([CInv(t=MSG_WTX, h=0xffaa)]))\n+        # As tx-announcing connection is inbound, wait for the inbound delay applied by requester.\n+\n+        mock_time = int(time.time() + NONPREF_PEER_TX_DELAY)\n+        self.nodes[0].setmocktime(mock_time)\n+        peer.sync_with_ping()\n+        with p2p_lock:\n+            assert_equal(peer.tx_getdata_count, 0)\n+        peer.peer_disconnect()\n+        peer.wait_for_disconnect()\n+\n+    def test_feefilter_ibd(self):\n         self.log.info(\"Check that nodes set minfilter to MAX_MONEY while still in IBD\")\n         for node in self.nodes:\n             assert node.getblockchaininfo()['initialblockdownload']\n@@ -37,6 +69,9 @@ def run_test(self):\n             assert not node.getblockchaininfo()['initialblockdownload']\n             self.wait_until(lambda: all(peer['minfeefilter'] == NORMAL_FEE_FILTER for peer in node.getpeerinfo()))\n \n+    def run_test(self):\n+        self.test_inv_ibd()\n+        self.test_feefilter_ibd()\n \n if __name__ == '__main__':\n     P2PIBDTxRelayTest().main()"
      }
    ]
  }
]