[
  {
    "sha": "6be0fb4b3f865e80e0465c2266b0560bd6bbb406",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2YmUwZmI0YjNmODY1ZTgwZTA0NjVjMjI2NmIwNTYwYmQ2YmJiNDA2",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2018-11-03T01:00:35Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2018-11-28T23:16:17Z"
      },
      "message": "[refactor] Add a base DescriptorImpl with most common logic",
      "tree": {
        "sha": "7ca0ca903e762665355c6a90b240db6cc866efb3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7ca0ca903e762665355c6a90b240db6cc866efb3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6be0fb4b3f865e80e0465c2266b0560bd6bbb406",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6be0fb4b3f865e80e0465c2266b0560bd6bbb406",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6be0fb4b3f865e80e0465c2266b0560bd6bbb406",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6be0fb4b3f865e80e0465c2266b0560bd6bbb406/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "60b20c869f8df9a81b5080ebcbe8c9cf4e6b9d77",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/60b20c869f8df9a81b5080ebcbe8c9cf4e6b9d77",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/60b20c869f8df9a81b5080ebcbe8c9cf4e6b9d77"
      }
    ],
    "stats": {
      "total": 367,
      "additions": 195,
      "deletions": 172
    },
    "files": [
      {
        "sha": "0f895566193783b22bd0b2dfbe4257f848381fa3",
        "filename": "src/script/descriptor.cpp",
        "status": "modified",
        "additions": 193,
        "deletions": 172,
        "changes": 365,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6be0fb4b3f865e80e0465c2266b0560bd6bbb406/src/script/descriptor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6be0fb4b3f865e80e0465c2266b0560bd6bbb406/src/script/descriptor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.cpp?ref=6be0fb4b3f865e80e0465c2266b0560bd6bbb406",
        "patch": "@@ -202,219 +202,240 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n-{\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    bool IsSolvable() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n-\n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CScript m_script;\n+    //! Public key arguments for this descriptor (size 1 for PK, PKH, WPKH; any size of Multisig).\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkey_args;\n+    //! The sub-descriptor argument (nullptr for everything but SH and WSH).\n+    const std::unique_ptr<Descriptor> m_script_arg;\n+    //! The string name of the descriptor function.\n+    const std::string m_name;\n+\n+protected:\n+    //! Return a serialization of anything except pubkey and script arguments, to be prepended to those.\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+\n+    /** A helper function to construct the scripts for this descriptor.\n+     *\n+     *  This function is invoked once for every CScript produced by evaluating\n+     *  m_script_arg, or just once in case m_script_arg is nullptr.\n+\n+     *  @param pubkeys The evaluations of the m_pubkey_args field.\n+     *  @param script The evaluation of m_script_arg (or nullptr when m_script_arg is nullptr).\n+     *  @param out A FlatSigningProvider to put scripts or public keys in that are necessary to the solver.\n+     *             The script and pubkeys argument to this function are automatically added.\n+     *  @return A vector with scriptPubKeys for this descriptor.\n+     */\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, const CScript* script, FlatSigningProvider& out) const = 0;\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<Descriptor> script, const std::string& name) : m_pubkey_args(std::move(pubkeys)), m_script_arg(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    bool IsSolvable() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsSolvable() const override\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    bool IsSolvable() const override { return true; }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n+        if (m_script_arg) {\n+            if (!m_script_arg->IsSolvable()) return false;\n+        }\n         return true;\n     }\n-};\n \n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n+    bool IsRange() const final\n     {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkey_args) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script_arg) {\n+            if (m_script_arg->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    bool IsSolvable() const override { return true; }\n-\n-    std::string ToString() const override\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const final\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0 ? 1 : 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkey_args) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!pubkey->ToPrivateString(arg, tmp)) return false;\n+            ret += std::move(tmp);\n         }\n-        return std::move(ret) + \")\";\n+        if (m_script_arg) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_script_arg->ToPrivateString(arg, tmp)) return false;\n+            ret += std::move(tmp);\n+        }\n+        out = std::move(ret) + \")\";\n+        return true;\n     }\n \n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    std::string ToString() const final\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0 ? 1 : 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkey_args) {\n+            if (pos++) ret += \",\";\n+            ret += pubkey->ToString();\n         }\n-        out = std::move(ret) + \")\";\n-        return true;\n+        if (m_script_arg) {\n+            if (pos++) ret += \",\";\n+            ret += m_script_arg->ToString();\n+        }\n+        return std::move(ret) + \")\";\n     }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const final\n     {\n         std::vector<std::pair<CPubKey, KeyOriginInfo>> entries;\n-        entries.reserve(m_providers.size());\n-        // Construct temporary data in `entries`, to avoid producing output in case of failure.\n-        for (const auto& p : m_providers) {\n+        entries.reserve(m_pubkey_args.size());\n+\n+        // Construct temporary data in `entries` and `subscripts`, to avoid producing output in case of failure.\n+        for (const auto& p : m_pubkey_args) {\n             entries.emplace_back();\n             if (!p->GetPubKey(pos, arg, entries.back().first, entries.back().second)) return false;\n         }\n+        std::vector<CScript> subscripts;\n+        if (m_script_arg) {\n+            FlatSigningProvider subprovider;\n+            if (!m_script_arg->Expand(pos, arg, subscripts, subprovider)) return false;\n+            out = Merge(out, subprovider);\n+        }\n+\n         std::vector<CPubKey> pubkeys;\n         pubkeys.reserve(entries.size());\n         for (auto& entry : entries) {\n             pubkeys.push_back(entry.first);\n             out.origins.emplace(entry.first.GetID(), std::move(entry.second));\n             out.pubkeys.emplace(entry.first.GetID(), entry.first);\n         }\n-        output_scripts = std::vector<CScript>{GetScriptForMultisig(m_threshold, pubkeys)};\n+        if (m_script_arg) {\n+            for (const auto& subscript : subscripts) {\n+                out.scripts.emplace(CScriptID(subscript), subscript);\n+                std::vector<CScript> addscripts = MakeScripts(pubkeys, &subscript, out);\n+                for (auto& addscript : addscripts) {\n+                    output_scripts.push_back(std::move(addscript));\n+                }\n+            }\n+        } else {\n+            output_scripts = MakeScripts(pubkeys, nullptr, out);\n+        }\n         return true;\n     }\n };\n \n-/** A parsed sh(S) or wsh(S) descriptor. */\n-class ConvertorDescriptor : public Descriptor\n+/** Construct a vector with one element, which is moved into it. */\n+template<typename T>\n+std::vector<T> Singleton(T elem)\n {\n-    const std::function<CScript(const CScript&)> m_convert_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<Descriptor> m_descriptor;\n+    std::vector<T> ret;\n+    ret.emplace_back(std::move(elem));\n+    return ret;\n+}\n \n+/** A parsed addr(A) descriptor. */\n+class AddressDescriptor final : public DescriptorImpl\n+{\n+    const CTxDestination m_destination;\n+protected:\n+    std::string ToStringExtra() const override { return EncodeDestination(m_destination); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, const CScript*, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(m_destination)); }\n public:\n-    ConvertorDescriptor(std::unique_ptr<Descriptor> descriptor, const std::function<CScript(const CScript&)>& fn, const std::string& name) : m_convert_fn(fn), m_fn_name(name), m_descriptor(std::move(descriptor)) {}\n+    AddressDescriptor(CTxDestination destination) : DescriptorImpl({}, {}, \"addr\"), m_destination(std::move(destination)) {}\n+    bool IsSolvable() const final { return false; }\n+};\n \n-    bool IsRange() const override { return m_descriptor->IsRange(); }\n-    bool IsSolvable() const override { return m_descriptor->IsSolvable(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_descriptor->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_descriptor->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        std::vector<CScript> sub;\n-        if (!m_descriptor->Expand(pos, arg, sub, out)) return false;\n-        output_scripts.clear();\n-        for (const auto& script : sub) {\n-            CScriptID id(script);\n-            out.scripts.emplace(CScriptID(script), script);\n-            output_scripts.push_back(m_convert_fn(script));\n-        }\n-        return true;\n-    }\n+/** A parsed raw(H) descriptor. */\n+class RawDescriptor final : public DescriptorImpl\n+{\n+    const CScript m_script;\n+protected:\n+    std::string ToStringExtra() const override { return HexStr(m_script.begin(), m_script.end()); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, const CScript*, FlatSigningProvider&) const override { return Singleton(m_script); }\n+public:\n+    RawDescriptor(CScript script) : DescriptorImpl({}, {}, \"raw\"), m_script(std::move(script)) {}\n+    bool IsSolvable() const final { return false; }\n };\n \n-CScript ConvertP2SH(const CScript& script) { return GetScriptForDestination(CScriptID(script)); }\n-CScript ConvertP2WSH(const CScript& script) { return GetScriptForDestination(WitnessV0ScriptHash(script)); }\n+/** A parsed pk(P) descriptor. */\n+class PKDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, const CScript*, FlatSigningProvider&) const override { return Singleton(GetScriptForRawPubKey(keys[0])); }\n+public:\n+    PKDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"pk\") {}\n+};\n \n-/** A parsed combo(P) descriptor. */\n-class ComboDescriptor final : public Descriptor\n+/** A parsed pkh(P) descriptor. */\n+class PKHDescriptor final : public DescriptorImpl\n {\n-    std::unique_ptr<PubkeyProvider> m_provider;\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, const CScript*, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(keys[0].GetID())); }\n+public:\n+    PKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"pkh\") {}\n+};\n \n+/** A parsed wpkh(P) descriptor. */\n+class WPKHDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, const CScript*, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(WitnessV0KeyHash(keys[0].GetID()))); }\n public:\n-    ComboDescriptor(std::unique_ptr<PubkeyProvider> provider) : m_provider(std::move(provider)) {}\n+    WPKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"wpkh\") {}\n+};\n \n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    bool IsSolvable() const override { return true; }\n-    std::string ToString() const override { return \"combo(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = \"combo(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+/** A parsed combo(P) descriptor. */\n+class ComboDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, const CScript*, FlatSigningProvider& out) const override\n     {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        CKeyID keyid = key.GetID();\n-        {\n-            CScript p2pk = GetScriptForRawPubKey(key);\n-            CScript p2pkh = GetScriptForDestination(keyid);\n-            output_scripts = std::vector<CScript>{std::move(p2pk), std::move(p2pkh)};\n-            out.pubkeys.emplace(keyid, key);\n-            out.origins.emplace(keyid, std::move(info));\n-        }\n-        if (key.IsCompressed()) {\n-            CScript p2wpkh = GetScriptForDestination(WitnessV0KeyHash(keyid));\n-            CScriptID p2wpkh_id(p2wpkh);\n-            CScript p2sh_p2wpkh = GetScriptForDestination(p2wpkh_id);\n-            out.scripts.emplace(p2wpkh_id, p2wpkh);\n-            output_scripts.push_back(std::move(p2wpkh));\n-            output_scripts.push_back(std::move(p2sh_p2wpkh));\n+        std::vector<CScript> ret;\n+        CKeyID id = keys[0].GetID();\n+        ret.emplace_back(GetScriptForRawPubKey(keys[0])); // P2PK\n+        ret.emplace_back(GetScriptForDestination(id)); // P2PKH\n+        if (keys[0].IsCompressed()) {\n+            CScript p2wpkh = GetScriptForDestination(WitnessV0KeyHash(id));\n+            out.scripts.emplace(CScriptID(p2wpkh), p2wpkh);\n+            ret.emplace_back(p2wpkh);\n+            ret.emplace_back(GetScriptForDestination(CScriptID(p2wpkh))); // P2SH-P2WPKH\n         }\n-        return true;\n+        return ret;\n     }\n+public:\n+    ComboDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"combo\") {}\n+};\n+\n+/** A parsed multi(...) descriptor. */\n+class MultisigDescriptor final : public DescriptorImpl\n+{\n+    const int m_threshold;\n+protected:\n+    std::string ToStringExtra() const override { return strprintf(\"%i\", m_threshold); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, const CScript*, FlatSigningProvider&) const override { return Singleton(GetScriptForMultisig(m_threshold, keys)); }\n+public:\n+    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : DescriptorImpl(std::move(providers), {}, \"multi\"), m_threshold(threshold) {}\n+};\n+\n+/** A parsed sh(...) descriptor. */\n+class SHDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, const CScript* script, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(CScriptID(*script))); }\n+public:\n+    SHDescriptor(std::unique_ptr<Descriptor> desc) : DescriptorImpl({}, std::move(desc), \"sh\") {}\n+};\n+\n+/** A parsed wsh(...) descriptor. */\n+class WSHDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, const CScript* script, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(WitnessV0ScriptHash(*script))); }\n+public:\n+    WSHDescriptor(std::unique_ptr<Descriptor> desc) : DescriptorImpl({}, std::move(desc), \"wsh\") {}\n };\n \n ////////////////////////////////////////////////////////////////////////////\n@@ -568,12 +589,12 @@ std::unique_ptr<Descriptor> ParseScript(Span<const char>& sp, ParseScriptContext\n     if (Func(\"pk\", expr)) {\n         auto pubkey = ParsePubkey(expr, ctx != ParseScriptContext::P2WSH, out);\n         if (!pubkey) return nullptr;\n-        return MakeUnique<SingleKeyDescriptor>(std::move(pubkey), P2PKGetScript, \"pk\");\n+        return MakeUnique<PKDescriptor>(std::move(pubkey));\n     }\n     if (Func(\"pkh\", expr)) {\n         auto pubkey = ParsePubkey(expr, ctx != ParseScriptContext::P2WSH, out);\n         if (!pubkey) return nullptr;\n-        return MakeUnique<SingleKeyDescriptor>(std::move(pubkey), P2PKHGetScript, \"pkh\");\n+        return MakeUnique<PKHDescriptor>(std::move(pubkey));\n     }\n     if (ctx == ParseScriptContext::TOP && Func(\"combo\", expr)) {\n         auto pubkey = ParsePubkey(expr, true, out);\n@@ -606,17 +627,17 @@ std::unique_ptr<Descriptor> ParseScript(Span<const char>& sp, ParseScriptContext\n     if (ctx != ParseScriptContext::P2WSH && Func(\"wpkh\", expr)) {\n         auto pubkey = ParsePubkey(expr, false, out);\n         if (!pubkey) return nullptr;\n-        return MakeUnique<SingleKeyDescriptor>(std::move(pubkey), P2WPKHGetScript, \"wpkh\");\n+        return MakeUnique<WPKHDescriptor>(std::move(pubkey));\n     }\n     if (ctx == ParseScriptContext::TOP && Func(\"sh\", expr)) {\n         auto desc = ParseScript(expr, ParseScriptContext::P2SH, out);\n         if (!desc || expr.size()) return nullptr;\n-        return MakeUnique<ConvertorDescriptor>(std::move(desc), ConvertP2SH, \"sh\");\n+        return MakeUnique<SHDescriptor>(std::move(desc));\n     }\n     if (ctx != ParseScriptContext::P2WSH && Func(\"wsh\", expr)) {\n         auto desc = ParseScript(expr, ParseScriptContext::P2WSH, out);\n         if (!desc || expr.size()) return nullptr;\n-        return MakeUnique<ConvertorDescriptor>(std::move(desc), ConvertP2WSH, \"wsh\");\n+        return MakeUnique<WSHDescriptor>(std::move(desc));\n     }\n     if (ctx == ParseScriptContext::TOP && Func(\"addr\", expr)) {\n         CTxDestination dest = DecodeDestination(std::string(expr.begin(), expr.end()));\n@@ -650,23 +671,23 @@ std::unique_ptr<Descriptor> InferScript(const CScript& script, ParseScriptContex\n     if (txntype == TX_PUBKEY) {\n         CPubKey pubkey(data[0].begin(), data[0].end());\n         if (pubkey.IsValid()) {\n-            return MakeUnique<SingleKeyDescriptor>(InferPubkey(pubkey, ctx, provider), P2PKGetScript, \"pk\");\n+            return MakeUnique<PKDescriptor>(InferPubkey(pubkey, ctx, provider));\n         }\n     }\n     if (txntype == TX_PUBKEYHASH) {\n         uint160 hash(data[0]);\n         CKeyID keyid(hash);\n         CPubKey pubkey;\n         if (provider.GetPubKey(keyid, pubkey)) {\n-            return MakeUnique<SingleKeyDescriptor>(InferPubkey(pubkey, ctx, provider), P2PKHGetScript, \"pkh\");\n+            return MakeUnique<PKHDescriptor>(InferPubkey(pubkey, ctx, provider));\n         }\n     }\n     if (txntype == TX_WITNESS_V0_KEYHASH && ctx != ParseScriptContext::P2WSH) {\n         uint160 hash(data[0]);\n         CKeyID keyid(hash);\n         CPubKey pubkey;\n         if (provider.GetPubKey(keyid, pubkey)) {\n-            return MakeUnique<SingleKeyDescriptor>(InferPubkey(pubkey, ctx, provider), P2WPKHGetScript, \"wpkh\");\n+            return MakeUnique<WPKHDescriptor>(InferPubkey(pubkey, ctx, provider));\n         }\n     }\n     if (txntype == TX_MULTISIG) {\n@@ -683,7 +704,7 @@ std::unique_ptr<Descriptor> InferScript(const CScript& script, ParseScriptContex\n         CScript subscript;\n         if (provider.GetCScript(scriptid, subscript)) {\n             auto sub = InferScript(subscript, ParseScriptContext::P2SH, provider);\n-            if (sub) return MakeUnique<ConvertorDescriptor>(std::move(sub), ConvertP2SH, \"sh\");\n+            if (sub) return MakeUnique<SHDescriptor>(std::move(sub));\n         }\n     }\n     if (txntype == TX_WITNESS_V0_SCRIPTHASH && ctx != ParseScriptContext::P2WSH) {\n@@ -692,7 +713,7 @@ std::unique_ptr<Descriptor> InferScript(const CScript& script, ParseScriptContex\n         CScript subscript;\n         if (provider.GetCScript(scriptid, subscript)) {\n             auto sub = InferScript(subscript, ParseScriptContext::P2WSH, provider);\n-            if (sub) return MakeUnique<ConvertorDescriptor>(std::move(sub), ConvertP2WSH, \"wsh\");\n+            if (sub) return MakeUnique<WSHDescriptor>(std::move(sub));\n         }\n     }\n "
      },
      {
        "sha": "635e4fa3d27df0fe476a1eff0b6fedbfadb67a19",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6be0fb4b3f865e80e0465c2266b0560bd6bbb406/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6be0fb4b3f865e80e0465c2266b0560bd6bbb406/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=6be0fb4b3f865e80e0465c2266b0560bd6bbb406",
        "patch": "@@ -705,5 +705,7 @@ FlatSigningProvider Merge(const FlatSigningProvider& a, const FlatSigningProvide\n     ret.pubkeys.insert(b.pubkeys.begin(), b.pubkeys.end());\n     ret.keys = a.keys;\n     ret.keys.insert(b.keys.begin(), b.keys.end());\n+    ret.origins = a.origins;\n+    ret.origins.insert(b.origins.begin(), b.origins.end());\n     return ret;\n }"
      }
    ]
  },
  {
    "sha": "24d3a7b3a9e81c04505d130eb7e41885eda9d35f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNGQzYTdiM2E5ZTgxYzA0NTA1ZDEzMGViN2U0MTg4NWVkYTlkMzVm",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2018-11-03T03:30:42Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2018-11-28T23:24:49Z"
      },
      "message": "[refactor] Use DescriptorImpl internally, permitting access to new methods",
      "tree": {
        "sha": "2f95fabbd7560225da4fd9748ce73846e47b3fe1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2f95fabbd7560225da4fd9748ce73846e47b3fe1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/24d3a7b3a9e81c04505d130eb7e41885eda9d35f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/24d3a7b3a9e81c04505d130eb7e41885eda9d35f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/24d3a7b3a9e81c04505d130eb7e41885eda9d35f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/24d3a7b3a9e81c04505d130eb7e41885eda9d35f/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6be0fb4b3f865e80e0465c2266b0560bd6bbb406",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6be0fb4b3f865e80e0465c2266b0560bd6bbb406",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6be0fb4b3f865e80e0465c2266b0560bd6bbb406"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 7,
      "deletions": 7
    },
    "files": [
      {
        "sha": "44e6112f2dcf06e9413307f9273d8e1682a6da62",
        "filename": "src/script/descriptor.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/24d3a7b3a9e81c04505d130eb7e41885eda9d35f/src/script/descriptor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/24d3a7b3a9e81c04505d130eb7e41885eda9d35f/src/script/descriptor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.cpp?ref=24d3a7b3a9e81c04505d130eb7e41885eda9d35f",
        "patch": "@@ -208,7 +208,7 @@ class DescriptorImpl : public Descriptor\n     //! Public key arguments for this descriptor (size 1 for PK, PKH, WPKH; any size of Multisig).\n     const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkey_args;\n     //! The sub-descriptor argument (nullptr for everything but SH and WSH).\n-    const std::unique_ptr<Descriptor> m_script_arg;\n+    const std::unique_ptr<DescriptorImpl> m_script_arg;\n     //! The string name of the descriptor function.\n     const std::string m_name;\n \n@@ -230,7 +230,7 @@ class DescriptorImpl : public Descriptor\n     virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, const CScript* script, FlatSigningProvider& out) const = 0;\n \n public:\n-    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<Descriptor> script, const std::string& name) : m_pubkey_args(std::move(pubkeys)), m_script_arg(std::move(script)), m_name(name) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkey_args(std::move(pubkeys)), m_script_arg(std::move(script)), m_name(name) {}\n \n     bool IsSolvable() const override\n     {\n@@ -426,7 +426,7 @@ class SHDescriptor final : public DescriptorImpl\n protected:\n     std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, const CScript* script, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(CScriptID(*script))); }\n public:\n-    SHDescriptor(std::unique_ptr<Descriptor> desc) : DescriptorImpl({}, std::move(desc), \"sh\") {}\n+    SHDescriptor(std::unique_ptr<DescriptorImpl> desc) : DescriptorImpl({}, std::move(desc), \"sh\") {}\n };\n \n /** A parsed wsh(...) descriptor. */\n@@ -435,7 +435,7 @@ class WSHDescriptor final : public DescriptorImpl\n protected:\n     std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, const CScript* script, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(WitnessV0ScriptHash(*script))); }\n public:\n-    WSHDescriptor(std::unique_ptr<Descriptor> desc) : DescriptorImpl({}, std::move(desc), \"wsh\") {}\n+    WSHDescriptor(std::unique_ptr<DescriptorImpl> desc) : DescriptorImpl({}, std::move(desc), \"wsh\") {}\n };\n \n ////////////////////////////////////////////////////////////////////////////\n@@ -583,7 +583,7 @@ std::unique_ptr<PubkeyProvider> ParsePubkey(const Span<const char>& sp, bool per\n }\n \n /** Parse a script in a particular context. */\n-std::unique_ptr<Descriptor> ParseScript(Span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out)\n+std::unique_ptr<DescriptorImpl> ParseScript(Span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out)\n {\n     auto expr = Expr(sp);\n     if (Func(\"pk\", expr)) {\n@@ -663,7 +663,7 @@ std::unique_ptr<PubkeyProvider> InferPubkey(const CPubKey& pubkey, ParseScriptCo\n     return key_provider;\n }\n \n-std::unique_ptr<Descriptor> InferScript(const CScript& script, ParseScriptContext ctx, const SigningProvider& provider)\n+std::unique_ptr<DescriptorImpl> InferScript(const CScript& script, ParseScriptContext ctx, const SigningProvider& provider)\n {\n     std::vector<std::vector<unsigned char>> data;\n     txnouttype txntype = Solver(script, data);\n@@ -733,7 +733,7 @@ std::unique_ptr<Descriptor> Parse(const std::string& descriptor, FlatSigningProv\n {\n     Span<const char> sp(descriptor.data(), descriptor.size());\n     auto ret = ParseScript(sp, ParseScriptContext::TOP, out);\n-    if (sp.size() == 0 && ret) return ret;\n+    if (sp.size() == 0 && ret) return std::unique_ptr<Descriptor>(std::move(ret));\n     return nullptr;\n }\n "
      }
    ]
  },
  {
    "sha": "1eda33aabc15b905a1e23ffab648ecf2a8f5322b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxZWRhMzNhYWJjMTViOTA1YTFlMjNmZmFiNjQ4ZWNmMmE4ZjUzMjJi",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2018-11-03T03:47:50Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2018-11-28T23:24:49Z"
      },
      "message": "[refactor] Combine the ToString and ToPrivateString implementations",
      "tree": {
        "sha": "091db0b0802e88505eb71a80d1f54314b030bab2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/091db0b0802e88505eb71a80d1f54314b030bab2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1eda33aabc15b905a1e23ffab648ecf2a8f5322b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1eda33aabc15b905a1e23ffab648ecf2a8f5322b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1eda33aabc15b905a1e23ffab648ecf2a8f5322b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1eda33aabc15b905a1e23ffab648ecf2a8f5322b/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "24d3a7b3a9e81c04505d130eb7e41885eda9d35f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/24d3a7b3a9e81c04505d130eb7e41885eda9d35f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/24d3a7b3a9e81c04505d130eb7e41885eda9d35f"
      }
    ],
    "stats": {
      "total": 27,
      "additions": 12,
      "deletions": 15
    },
    "files": [
      {
        "sha": "adb5d20edbdb8fb809de66535b00825ab1120e23",
        "filename": "src/script/descriptor.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 15,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1eda33aabc15b905a1e23ffab648ecf2a8f5322b/src/script/descriptor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1eda33aabc15b905a1e23ffab648ecf2a8f5322b/src/script/descriptor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.cpp?ref=1eda33aabc15b905a1e23ffab648ecf2a8f5322b",
        "patch": "@@ -251,21 +251,25 @@ class DescriptorImpl : public Descriptor\n         return false;\n     }\n \n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const final\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n         std::string extra = ToStringExtra();\n         size_t pos = extra.size() > 0 ? 1 : 0;\n         std::string ret = m_name + \"(\" + extra;\n         for (const auto& pubkey : m_pubkey_args) {\n             if (pos++) ret += \",\";\n             std::string tmp;\n-            if (!pubkey->ToPrivateString(arg, tmp)) return false;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n             ret += std::move(tmp);\n         }\n         if (m_script_arg) {\n             if (pos++) ret += \",\";\n             std::string tmp;\n-            if (!m_script_arg->ToPrivateString(arg, tmp)) return false;\n+            if (!m_script_arg->ToStringHelper(arg, tmp, priv)) return false;\n             ret += std::move(tmp);\n         }\n         out = std::move(ret) + \")\";\n@@ -274,20 +278,13 @@ class DescriptorImpl : public Descriptor\n \n     std::string ToString() const final\n     {\n-        std::string extra = ToStringExtra();\n-        size_t pos = extra.size() > 0 ? 1 : 0;\n-        std::string ret = m_name + \"(\" + extra;\n-        for (const auto& pubkey : m_pubkey_args) {\n-            if (pos++) ret += \",\";\n-            ret += pubkey->ToString();\n-        }\n-        if (m_script_arg) {\n-            if (pos++) ret += \",\";\n-            ret += m_script_arg->ToString();\n-        }\n-        return std::move(ret) + \")\";\n+        std::string ret;\n+        ToStringHelper(nullptr, ret, false);\n+        return ret;\n     }\n \n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final { return ToStringHelper(&arg, out, true); }\n+\n     bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const final\n     {\n         std::vector<std::pair<CPubKey, KeyOriginInfo>> entries;"
      }
    ]
  },
  {
    "sha": "82df4c64ffa2f0dd45e7ae694903615358f121a6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4MmRmNGM2NGZmYTJmMGRkNDVlN2FlNjk0OTAzNjE1MzU4ZjEyMWE2",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2018-11-03T02:19:39Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2018-11-28T23:24:49Z"
      },
      "message": "Add descriptor expansion cache",
      "tree": {
        "sha": "942cc9dcb23e0004660d129358fd8afed6ba2467",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/942cc9dcb23e0004660d129358fd8afed6ba2467"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/82df4c64ffa2f0dd45e7ae694903615358f121a6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/82df4c64ffa2f0dd45e7ae694903615358f121a6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/82df4c64ffa2f0dd45e7ae694903615358f121a6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/82df4c64ffa2f0dd45e7ae694903615358f121a6/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1eda33aabc15b905a1e23ffab648ecf2a8f5322b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1eda33aabc15b905a1e23ffab648ecf2a8f5322b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1eda33aabc15b905a1e23ffab648ecf2a8f5322b"
      }
    ],
    "stats": {
      "total": 105,
      "additions": 75,
      "deletions": 30
    },
    "files": [
      {
        "sha": "a702be5b780e69e82701197963f4e3f6fff0a7aa",
        "filename": "src/script/descriptor.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 26,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/82df4c64ffa2f0dd45e7ae694903615358f121a6/src/script/descriptor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/82df4c64ffa2f0dd45e7ae694903615358f121a6/src/script/descriptor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.cpp?ref=82df4c64ffa2f0dd45e7ae694903615358f121a6",
        "patch": "@@ -40,8 +40,8 @@ struct PubkeyProvider\n {\n     virtual ~PubkeyProvider() = default;\n \n-    /** Derive a public key. */\n-    virtual bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& key, KeyOriginInfo& info) const = 0;\n+    /** Derive a public key. If key==nullptr, only info is desired. */\n+    virtual bool GetPubKey(int pos, const SigningProvider& arg, CPubKey* key, KeyOriginInfo& info) const = 0;\n \n     /** Whether this represent multiple public keys at different positions. */\n     virtual bool IsRange() const = 0;\n@@ -68,7 +68,7 @@ class OriginPubkeyProvider final : public PubkeyProvider\n \n public:\n     OriginPubkeyProvider(KeyOriginInfo info, std::unique_ptr<PubkeyProvider> provider) : m_origin(std::move(info)), m_provider(std::move(provider)) {}\n-    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& key, KeyOriginInfo& info) const override\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey* key, KeyOriginInfo& info) const override\n     {\n         if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n         std::copy(std::begin(m_origin.fingerprint), std::end(m_origin.fingerprint), info.fingerprint);\n@@ -94,9 +94,9 @@ class ConstPubkeyProvider final : public PubkeyProvider\n \n public:\n     ConstPubkeyProvider(const CPubKey& pubkey) : m_pubkey(pubkey) {}\n-    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& key, KeyOriginInfo& info) const override\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey* key, KeyOriginInfo& info) const override\n     {\n-        key = m_pubkey;\n+        if (key) *key = m_pubkey;\n         info.path.clear();\n         CKeyID keyid = m_pubkey.GetID();\n         std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n@@ -152,26 +152,28 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     BIP32PubkeyProvider(const CExtPubKey& extkey, KeyPath path, DeriveType derive) : m_extkey(extkey), m_path(std::move(path)), m_derive(derive) {}\n     bool IsRange() const override { return m_derive != DeriveType::NO; }\n     size_t GetSize() const override { return 33; }\n-    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& key, KeyOriginInfo& info) const override\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey* key, KeyOriginInfo& info) const override\n     {\n-        if (IsHardened()) {\n-            CExtKey extkey;\n-            if (!GetExtKey(arg, extkey)) return false;\n-            for (auto entry : m_path) {\n-                extkey.Derive(extkey, entry);\n-            }\n-            if (m_derive == DeriveType::UNHARDENED) extkey.Derive(extkey, pos);\n-            if (m_derive == DeriveType::HARDENED) extkey.Derive(extkey, pos | 0x80000000UL);\n-            key = extkey.Neuter().pubkey;\n-        } else {\n-            // TODO: optimize by caching\n-            CExtPubKey extkey = m_extkey;\n-            for (auto entry : m_path) {\n-                extkey.Derive(extkey, entry);\n+        if (key) {\n+            if (IsHardened()) {\n+                CExtKey extkey;\n+                if (!GetExtKey(arg, extkey)) return false;\n+                for (auto entry : m_path) {\n+                    extkey.Derive(extkey, entry);\n+                }\n+                if (m_derive == DeriveType::UNHARDENED) extkey.Derive(extkey, pos);\n+                if (m_derive == DeriveType::HARDENED) extkey.Derive(extkey, pos | 0x80000000UL);\n+                *key = extkey.Neuter().pubkey;\n+            } else {\n+                // TODO: optimize by caching\n+                CExtPubKey extkey = m_extkey;\n+                for (auto entry : m_path) {\n+                    extkey.Derive(extkey, entry);\n+                }\n+                if (m_derive == DeriveType::UNHARDENED) extkey.Derive(extkey, pos);\n+                assert(m_derive != DeriveType::HARDENED);\n+                *key = extkey.pubkey;\n             }\n-            if (m_derive == DeriveType::UNHARDENED) extkey.Derive(extkey, pos);\n-            assert(m_derive != DeriveType::HARDENED);\n-            key = extkey.pubkey;\n         }\n         CKeyID keyid = m_extkey.pubkey.GetID();\n         std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n@@ -285,20 +287,33 @@ class DescriptorImpl : public Descriptor\n \n     bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final { return ToStringHelper(&arg, out, true); }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const final\n+    bool ExpandHelper(int pos, const SigningProvider& arg, Span<const unsigned char>* cache_read, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache_write) const\n     {\n         std::vector<std::pair<CPubKey, KeyOriginInfo>> entries;\n         entries.reserve(m_pubkey_args.size());\n \n         // Construct temporary data in `entries` and `subscripts`, to avoid producing output in case of failure.\n         for (const auto& p : m_pubkey_args) {\n             entries.emplace_back();\n-            if (!p->GetPubKey(pos, arg, entries.back().first, entries.back().second)) return false;\n+            if (!p->GetPubKey(pos, arg, cache_read ? nullptr : &entries.back().first, entries.back().second)) return false;\n+            if (cache_read) {\n+                // Cached expanded public key exists, use it.\n+                if (cache_read->size() == 0) return false;\n+                bool compressed = ((*cache_read)[0] == 0x02 || (*cache_read)[0] == 0x03) && cache_read->size() >= 33;\n+                bool uncompressed = ((*cache_read)[0] == 0x04) && cache_read->size() >= 65;\n+                if (!(compressed || uncompressed)) return false;\n+                CPubKey pubkey(cache_read->begin(), cache_read->begin() + (compressed ? 33 : 65));\n+                entries.back().first = pubkey;\n+                *cache_read = cache_read->subspan(compressed ? 33 : 65);\n+            }\n+            if (cache_write) {\n+                cache_write->insert(cache_write->end(), entries.back().first.begin(), entries.back().first.end());\n+            }\n         }\n         std::vector<CScript> subscripts;\n         if (m_script_arg) {\n             FlatSigningProvider subprovider;\n-            if (!m_script_arg->Expand(pos, arg, subscripts, subprovider)) return false;\n+            if (!m_script_arg->ExpandHelper(pos, arg, cache_read, subscripts, subprovider, cache_write)) return false;\n             out = Merge(out, subprovider);\n         }\n \n@@ -322,6 +337,17 @@ class DescriptorImpl : public Descriptor\n         }\n         return true;\n     }\n+\n+    bool Expand(int pos, const SigningProvider& provider, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache = nullptr) const final\n+    {\n+        return ExpandHelper(pos, provider, nullptr, output_scripts, out, cache);\n+    }\n+\n+    bool ExpandFromCache(int pos, const std::vector<unsigned char>& cache, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const final\n+    {\n+        Span<const unsigned char> span = MakeSpan(cache);\n+        return ExpandHelper(pos, DUMMY_SIGNING_PROVIDER, &span, output_scripts, out, nullptr) && span.size() == 0;\n+    }\n };\n \n /** Construct a vector with one element, which is moved into it. */"
      },
      {
        "sha": "44f0efca03e9091b8a5ec1046901a90633977ee2",
        "filename": "src/script/descriptor.h",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/82df4c64ffa2f0dd45e7ae694903615358f121a6/src/script/descriptor.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/82df4c64ffa2f0dd45e7ae694903615358f121a6/src/script/descriptor.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.h?ref=82df4c64ffa2f0dd45e7ae694903615358f121a6",
        "patch": "@@ -48,8 +48,18 @@ struct Descriptor {\n      * provider: the provider to query for private keys in case of hardened derivation.\n      * output_script: the expanded scriptPubKeys will be put here.\n      * out: scripts and public keys necessary for solving the expanded scriptPubKeys will be put here (may be equal to provider).\n+     * cache: vector which will be overwritten with cache data necessary to-evaluate the descriptor at this point without access to private keys.\n      */\n-    virtual bool Expand(int pos, const SigningProvider& provider, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const = 0;\n+    virtual bool Expand(int pos, const SigningProvider& provider, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache = nullptr) const = 0;\n+\n+    /** Expand a descriptor at a specified position using cached expansion data.\n+     *\n+     * pos: the position at which to expand the descriptor. If IsRange() is false, this is ignored.\n+     * cache: vector from which cached expansion data will be read.\n+     * output_script: the expanded scriptPubKeys will be put here.\n+     * out: scripts and public keys necessary for solving the expanded scriptPubKeys will be put here (may be equal to provider).\n+     */\n+    virtual bool ExpandFromCache(int pos, const std::vector<unsigned char>& cache, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const = 0;\n };\n \n /** Parse a descriptor string. Included private keys are put in out. Returns nullptr if parsing fails. */"
      },
      {
        "sha": "1a35b5ea71f455477756feed7acb46e703e0a77d",
        "filename": "src/test/descriptor_tests.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 3,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/82df4c64ffa2f0dd45e7ae694903615358f121a6/src/test/descriptor_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/82df4c64ffa2f0dd45e7ae694903615358f121a6/src/test/descriptor_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/descriptor_tests.cpp?ref=82df4c64ffa2f0dd45e7ae694903615358f121a6",
        "patch": "@@ -88,9 +88,18 @@ void Check(const std::string& prv, const std::string& pub, int flags, const std:\n         const auto& ref = scripts[(flags & RANGE) ? i : 0];\n         for (int t = 0; t < 2; ++t) {\n             const FlatSigningProvider& key_provider = (flags & HARDENED) ? keys_priv : keys_pub;\n-            FlatSigningProvider script_provider;\n-            std::vector<CScript> spks;\n-            BOOST_CHECK((t ? parse_priv : parse_pub)->Expand(i, key_provider, spks, script_provider));\n+            FlatSigningProvider script_provider, script_provider_cached;\n+            std::vector<CScript> spks, spks_cached;\n+            std::vector<unsigned char> cache;\n+            BOOST_CHECK((t ? parse_priv : parse_pub)->Expand(i, key_provider, spks, script_provider, &cache));\n+\n+            // Try to expand again using cached data, and compare.\n+            BOOST_CHECK(parse_pub->ExpandFromCache(i, cache, spks_cached, script_provider_cached));\n+            BOOST_CHECK(spks == spks_cached);\n+            BOOST_CHECK(script_provider.pubkeys == script_provider_cached.pubkeys);\n+            BOOST_CHECK(script_provider.scripts == script_provider_cached.scripts);\n+            BOOST_CHECK(script_provider.origins == script_provider_cached.origins);\n+\n             BOOST_CHECK_EQUAL(spks.size(), ref.size());\n             for (size_t n = 0; n < spks.size(); ++n) {\n                 BOOST_CHECK_EQUAL(ref[n], HexStr(spks[n].begin(), spks[n].end()));"
      }
    ]
  },
  {
    "sha": "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNjg3OTUwOWYxYTNiOWZjMGZhNjE2MTY0ZTVhODhmZGIzNDRhYzRk",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2018-11-07T18:54:56Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2018-11-28T23:24:49Z"
      },
      "message": "Add comments to descriptor tests",
      "tree": {
        "sha": "d163f42580b6c00d8a9a19b4e943957e5bacec6e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d163f42580b6c00d8a9a19b4e943957e5bacec6e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/26879509f1a3b9fc0fa616164e5a88fdb344ac4d/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "82df4c64ffa2f0dd45e7ae694903615358f121a6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/82df4c64ffa2f0dd45e7ae694903615358f121a6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/82df4c64ffa2f0dd45e7ae694903615358f121a6"
      }
    ],
    "stats": {
      "total": 23,
      "additions": 19,
      "deletions": 4
    },
    "files": [
      {
        "sha": "8da8cfc00c4f22dcdd69aeee4fa1816143dcaf56",
        "filename": "src/test/descriptor_tests.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 4,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26879509f1a3b9fc0fa616164e5a88fdb344ac4d/src/test/descriptor_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26879509f1a3b9fc0fa616164e5a88fdb344ac4d/src/test/descriptor_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/descriptor_tests.cpp?ref=26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
        "patch": "@@ -79,28 +79,42 @@ void Check(const std::string& prv, const std::string& pub, int flags, const std:\n     BOOST_CHECK_EQUAL(parse_pub->IsRange(), (flags & RANGE) != 0);\n     BOOST_CHECK_EQUAL(parse_priv->IsRange(), (flags & RANGE) != 0);\n \n-\n-    // Is not ranged descriptor, only a single result is expected.\n+    // * For ranged descriptors,  the `scripts` parameter is a list of expected result outputs, for subsequent\n+    //   positions to evaluate the descriptors on (so the first element of `scripts` is for evaluating the\n+    //   descriptor at 0; the second at 1; and so on). To verify this, we evaluate the descriptors once for\n+    //   each element in `scripts`.\n+    // * For non-ranged descriptors, we evaluate the descriptors at positions 0, 1, and 2, but expect the\n+    //   same result in each case, namely the first element of `scripts`. Because of that, the size of\n+    //   `scripts` must be one in that case.\n     if (!(flags & RANGE)) assert(scripts.size() == 1);\n-\n     size_t max = (flags & RANGE) ? scripts.size() : 3;\n+\n+    // Iterate over the position we'll evaluate the descriptors in.\n     for (size_t i = 0; i < max; ++i) {\n+        // Call the expected result scripts `ref`.\n         const auto& ref = scripts[(flags & RANGE) ? i : 0];\n+        // When t=0, evaluate the `prv` descriptor; when t=1, evaluate the `pub` descriptor.\n         for (int t = 0; t < 2; ++t) {\n+            // When the descriptor is hardened, evaluate with access to the private keys inside.\n             const FlatSigningProvider& key_provider = (flags & HARDENED) ? keys_priv : keys_pub;\n+\n+            // Evaluate the descriptor selected by `t` in poisition `i`.\n             FlatSigningProvider script_provider, script_provider_cached;\n             std::vector<CScript> spks, spks_cached;\n             std::vector<unsigned char> cache;\n             BOOST_CHECK((t ? parse_priv : parse_pub)->Expand(i, key_provider, spks, script_provider, &cache));\n \n+            // Compare the output with the expected result.\n+            BOOST_CHECK_EQUAL(spks.size(), ref.size());\n+\n             // Try to expand again using cached data, and compare.\n             BOOST_CHECK(parse_pub->ExpandFromCache(i, cache, spks_cached, script_provider_cached));\n             BOOST_CHECK(spks == spks_cached);\n             BOOST_CHECK(script_provider.pubkeys == script_provider_cached.pubkeys);\n             BOOST_CHECK(script_provider.scripts == script_provider_cached.scripts);\n             BOOST_CHECK(script_provider.origins == script_provider_cached.origins);\n \n-            BOOST_CHECK_EQUAL(spks.size(), ref.size());\n+            // For each of the produced scripts, verify solvability, and when possible, try to sign a transaction spending it.\n             for (size_t n = 0; n < spks.size(); ++n) {\n                 BOOST_CHECK_EQUAL(ref[n], HexStr(spks[n].begin(), spks[n].end()));\n                 BOOST_CHECK_EQUAL(IsSolvable(Merge(key_provider, script_provider), spks[n]), (flags & UNSOLVABLE) == 0);\n@@ -132,6 +146,7 @@ void Check(const std::string& prv, const std::string& pub, int flags, const std:\n             }\n         }\n     }\n+\n     // Verify no expected paths remain that were not observed.\n     BOOST_CHECK_MESSAGE(left_paths.empty(), \"Not all expected key paths found: \" + prv);\n }"
      }
    ]
  }
]