[
  {
    "sha": "18946846d5c321d2afc11445580874c9a8bb0733",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxODk0Njg0NmQ1YzMyMWQyYWZjMTE0NDU1ODA4NzRjOWE4YmIwNzMz",
    "commit": {
      "author": {
        "name": "Jeff Garzik",
        "email": "jgarzik@bitpay.com",
        "date": "2013-07-31T12:45:49Z"
      },
      "committer": {
        "name": "Jeff Garzik",
        "email": "jgarzik@bitpay.com",
        "date": "2013-07-31T12:45:49Z"
      },
      "message": "Minor miner fixes (hey hey it's fun to say)\n\n* Fix UpdateCoins() definition in main.h\n* Remove pwalletMain reference from BitcoinMiner(), as it is passed\n  a wallet argument.",
      "tree": {
        "sha": "f7f74b189fa9d1f17279160fb18d3d81655ff811",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f7f74b189fa9d1f17279160fb18d3d81655ff811"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/18946846d5c321d2afc11445580874c9a8bb0733",
      "comment_count": 1,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/18946846d5c321d2afc11445580874c9a8bb0733",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/18946846d5c321d2afc11445580874c9a8bb0733",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/18946846d5c321d2afc11445580874c9a8bb0733/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "8351d55cd3955c95c5e3fe065a456db08cc8a559",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8351d55cd3955c95c5e3fe065a456db08cc8a559",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8351d55cd3955c95c5e3fe065a456db08cc8a559"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 2,
      "deletions": 2
    },
    "files": [
      {
        "sha": "1d72ef16e961aa05d0378b02bec334238b44afe7",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/18946846d5c321d2afc11445580874c9a8bb0733/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/18946846d5c321d2afc11445580874c9a8bb0733/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=18946846d5c321d2afc11445580874c9a8bb0733",
        "patch": "@@ -4681,7 +4681,7 @@ void static BitcoinMiner(CWallet *pwallet)\n                     assert(hash == pblock->GetHash());\n \n                     SetThreadPriority(THREAD_PRIORITY_NORMAL);\n-                    CheckWork(pblock, *pwalletMain, reservekey);\n+                    CheckWork(pblock, *pwallet, reservekey);\n                     SetThreadPriority(THREAD_PRIORITY_LOWEST);\n \n                     // In regression test mode, stop mining after a block is found. This"
      },
      {
        "sha": "a42f7968fdf62bf0345f4cd3edce7399d099a990",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/18946846d5c321d2afc11445580874c9a8bb0733/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/18946846d5c321d2afc11445580874c9a8bb0733/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=18946846d5c321d2afc11445580874c9a8bb0733",
        "patch": "@@ -318,7 +318,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, CCoinsViewCach\n                  std::vector<CScriptCheck> *pvChecks = NULL);\n \n // Apply the effects of this transaction on the UTXO set represented by view\n-bool UpdateCoins(const CTransaction& tx, CCoinsViewCache &view, CTxUndo &txundo, int nHeight, const uint256 &txhash);\n+void UpdateCoins(const CTransaction& tx, CValidationState &state, CCoinsViewCache &inputs, CTxUndo &txundo, int nHeight, const uint256 &txhash);\n \n // Context-independent validity checks\n bool CheckTransaction(const CTransaction& tx, CValidationState& state);"
      }
    ]
  },
  {
    "sha": "d247a5d130544622519ad84dc8a1e50336397c51",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMjQ3YTVkMTMwNTQ0NjIyNTE5YWQ4NGRjOGExZTUwMzM2Mzk3YzUx",
    "commit": {
      "author": {
        "name": "Jeff Garzik",
        "email": "jgarzik@bitpay.com",
        "date": "2013-07-31T13:43:35Z"
      },
      "committer": {
        "name": "Jeff Garzik",
        "email": "jgarzik@bitpay.com",
        "date": "2013-07-31T13:43:35Z"
      },
      "message": "Move internal miner/block creation to separate miner.cpp module.\n\nPublic functions referenced elsewhere are added to miner.h.",
      "tree": {
        "sha": "81064dc545e650cd3c50866c50d9440e57e2b907",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/81064dc545e650cd3c50866c50d9440e57e2b907"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d247a5d130544622519ad84dc8a1e50336397c51",
      "comment_count": 1,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d247a5d130544622519ad84dc8a1e50336397c51",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d247a5d130544622519ad84dc8a1e50336397c51",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d247a5d130544622519ad84dc8a1e50336397c51/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "18946846d5c321d2afc11445580874c9a8bb0733",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/18946846d5c321d2afc11445580874c9a8bb0733",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/18946846d5c321d2afc11445580874c9a8bb0733"
      }
    ],
    "stats": {
      "total": 1368,
      "additions": 700,
      "deletions": 668
    },
    "files": [
      {
        "sha": "13c9d4cf2410dbf99efb6034d1f2d76cdca42708",
        "filename": "bitcoin-qt.pro",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d247a5d130544622519ad84dc8a1e50336397c51/bitcoin-qt.pro",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d247a5d130544622519ad84dc8a1e50336397c51/bitcoin-qt.pro",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/bitcoin-qt.pro?ref=d247a5d130544622519ad84dc8a1e50336397c51",
        "patch": "@@ -157,6 +157,7 @@ HEADERS += src/qt/bitcoingui.h \\\n     src/serialize.h \\\n     src/core.h \\\n     src/main.h \\\n+    src/miner.h \\\n     src/net.h \\\n     src/key.h \\\n     src/db.h \\\n@@ -240,6 +241,7 @@ SOURCES += src/qt/bitcoin.cpp \\\n     src/core.cpp \\\n     src/main.cpp \\\n     src/init.cpp \\\n+    src/miner.cpp \\\n     src/net.cpp \\\n     src/bloom.cpp \\\n     src/checkpoints.cpp \\"
      },
      {
        "sha": "49d6e1fde4c99e6257f2691a4460be3ef1458d8a",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d247a5d130544622519ad84dc8a1e50336397c51/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d247a5d130544622519ad84dc8a1e50336397c51/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=d247a5d130544622519ad84dc8a1e50336397c51",
        "patch": "@@ -12,6 +12,7 @@\n #include \"bitcoinrpc.h\"\n #include \"net.h\"\n #include \"util.h\"\n+#include \"miner.h\"\n #include \"ui_interface.h\"\n #include \"checkpoints.h\"\n "
      },
      {
        "sha": "ac3ee06f6f558027265dac42fb7cf14fc3040d8b",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 658,
        "changes": 660,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d247a5d130544622519ad84dc8a1e50336397c51/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d247a5d130544622519ad84dc8a1e50336397c51/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=d247a5d130544622519ad84dc8a1e50336397c51",
        "patch": "@@ -1244,7 +1244,7 @@ uint256 static GetOrphanRoot(const CBlockHeader* pblock)\n     return pblock->GetHash();\n }\n \n-int64 static GetBlockValue(int nHeight, int64 nFees)\n+int64 GetBlockValue(int nHeight, int64 nFees)\n {\n     int64 nSubsidy = 50 * COIN;\n \n@@ -1284,7 +1284,7 @@ unsigned int ComputeMinWork(unsigned int nBase, int64 nTime)\n     return bnResult.GetCompact();\n }\n \n-unsigned int static GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHeader *pblock)\n+unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHeader *pblock)\n {\n     unsigned int nProofOfWorkLimit = Params().ProofOfWorkLimit().GetCompact();\n \n@@ -4124,662 +4124,6 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n \n \n \n-\n-\n-\n-\n-\n-\n-\n-\n-//////////////////////////////////////////////////////////////////////////////\n-//\n-// BitcoinMiner\n-//\n-\n-int static FormatHashBlocks(void* pbuffer, unsigned int len)\n-{\n-    unsigned char* pdata = (unsigned char*)pbuffer;\n-    unsigned int blocks = 1 + ((len + 8) / 64);\n-    unsigned char* pend = pdata + 64 * blocks;\n-    memset(pdata + len, 0, 64 * blocks - len);\n-    pdata[len] = 0x80;\n-    unsigned int bits = len * 8;\n-    pend[-1] = (bits >> 0) & 0xff;\n-    pend[-2] = (bits >> 8) & 0xff;\n-    pend[-3] = (bits >> 16) & 0xff;\n-    pend[-4] = (bits >> 24) & 0xff;\n-    return blocks;\n-}\n-\n-static const unsigned int pSHA256InitState[8] =\n-{0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19};\n-\n-void SHA256Transform(void* pstate, void* pinput, const void* pinit)\n-{\n-    SHA256_CTX ctx;\n-    unsigned char data[64];\n-\n-    SHA256_Init(&ctx);\n-\n-    for (int i = 0; i < 16; i++)\n-        ((uint32_t*)data)[i] = ByteReverse(((uint32_t*)pinput)[i]);\n-\n-    for (int i = 0; i < 8; i++)\n-        ctx.h[i] = ((uint32_t*)pinit)[i];\n-\n-    SHA256_Update(&ctx, data, sizeof(data));\n-    for (int i = 0; i < 8; i++)\n-        ((uint32_t*)pstate)[i] = ctx.h[i];\n-}\n-\n-//\n-// ScanHash scans nonces looking for a hash with at least some zero bits.\n-// It operates on big endian data.  Caller does the byte reversing.\n-// All input buffers are 16-byte aligned.  nNonce is usually preserved\n-// between calls, but periodically or if nNonce is 0xffff0000 or above,\n-// the block is rebuilt and nNonce starts over at zero.\n-//\n-unsigned int static ScanHash_CryptoPP(char* pmidstate, char* pdata, char* phash1, char* phash, unsigned int& nHashesDone)\n-{\n-    unsigned int& nNonce = *(unsigned int*)(pdata + 12);\n-    for (;;)\n-    {\n-        // Crypto++ SHA256\n-        // Hash pdata using pmidstate as the starting state into\n-        // pre-formatted buffer phash1, then hash phash1 into phash\n-        nNonce++;\n-        SHA256Transform(phash1, pdata, pmidstate);\n-        SHA256Transform(phash, phash1, pSHA256InitState);\n-\n-        // Return the nonce if the hash has at least some zero bits,\n-        // caller will check if it has enough to reach the target\n-        if (((unsigned short*)phash)[14] == 0)\n-            return nNonce;\n-\n-        // If nothing found after trying for a while, return -1\n-        if ((nNonce & 0xffff) == 0)\n-        {\n-            nHashesDone = 0xffff+1;\n-            return (unsigned int) -1;\n-        }\n-        if ((nNonce & 0xfff) == 0)\n-            boost::this_thread::interruption_point();\n-    }\n-}\n-\n-// Some explaining would be appreciated\n-class COrphan\n-{\n-public:\n-    CTransaction* ptx;\n-    set<uint256> setDependsOn;\n-    double dPriority;\n-    double dFeePerKb;\n-\n-    COrphan(CTransaction* ptxIn)\n-    {\n-        ptx = ptxIn;\n-        dPriority = dFeePerKb = 0;\n-    }\n-\n-    void print() const\n-    {\n-        printf(\"COrphan(hash=%s, dPriority=%.1f, dFeePerKb=%.1f)\\n\",\n-               ptx->GetHash().ToString().c_str(), dPriority, dFeePerKb);\n-        BOOST_FOREACH(uint256 hash, setDependsOn)\n-            printf(\"   setDependsOn %s\\n\", hash.ToString().c_str());\n-    }\n-};\n-\n-\n-uint64 nLastBlockTx = 0;\n-uint64 nLastBlockSize = 0;\n-\n-// We want to sort transactions by priority and fee, so:\n-typedef boost::tuple<double, double, CTransaction*> TxPriority;\n-class TxPriorityCompare\n-{\n-    bool byFee;\n-public:\n-    TxPriorityCompare(bool _byFee) : byFee(_byFee) { }\n-    bool operator()(const TxPriority& a, const TxPriority& b)\n-    {\n-        if (byFee)\n-        {\n-            if (a.get<1>() == b.get<1>())\n-                return a.get<0>() < b.get<0>();\n-            return a.get<1>() < b.get<1>();\n-        }\n-        else\n-        {\n-            if (a.get<0>() == b.get<0>())\n-                return a.get<1>() < b.get<1>();\n-            return a.get<0>() < b.get<0>();\n-        }\n-    }\n-};\n-\n-CBlockTemplate* CreateNewBlock(CReserveKey& reservekey)\n-{\n-    // Create new block\n-    auto_ptr<CBlockTemplate> pblocktemplate(new CBlockTemplate());\n-    if(!pblocktemplate.get())\n-        return NULL;\n-    CBlock *pblock = &pblocktemplate->block; // pointer for convenience\n-\n-    // Create coinbase tx\n-    CTransaction txNew;\n-    txNew.vin.resize(1);\n-    txNew.vin[0].prevout.SetNull();\n-    txNew.vout.resize(1);\n-    CPubKey pubkey;\n-    if (!reservekey.GetReservedKey(pubkey))\n-        return NULL;\n-    txNew.vout[0].scriptPubKey << pubkey << OP_CHECKSIG;\n-\n-    // Add our coinbase tx as first transaction\n-    pblock->vtx.push_back(txNew);\n-    pblocktemplate->vTxFees.push_back(-1); // updated at end\n-    pblocktemplate->vTxSigOps.push_back(-1); // updated at end\n-\n-    // Largest block you're willing to create:\n-    unsigned int nBlockMaxSize = GetArg(\"-blockmaxsize\", MAX_BLOCK_SIZE_GEN/2);\n-    // Limit to betweeen 1K and MAX_BLOCK_SIZE-1K for sanity:\n-    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));\n-\n-    // How much of the block should be dedicated to high-priority transactions,\n-    // included regardless of the fees they pay\n-    unsigned int nBlockPrioritySize = GetArg(\"-blockprioritysize\", DEFAULT_BLOCK_PRIORITY_SIZE);\n-    nBlockPrioritySize = std::min(nBlockMaxSize, nBlockPrioritySize);\n-\n-    // Minimum block size you want to create; block will be filled with free transactions\n-    // until there are no more or the block reaches this size:\n-    unsigned int nBlockMinSize = GetArg(\"-blockminsize\", 0);\n-    nBlockMinSize = std::min(nBlockMaxSize, nBlockMinSize);\n-\n-    // Collect memory pool transactions into the block\n-    int64 nFees = 0;\n-    {\n-        LOCK2(cs_main, mempool.cs);\n-        CBlockIndex* pindexPrev = pindexBest;\n-        CCoinsViewCache view(*pcoinsTip, true);\n-\n-        // Priority order to process transactions\n-        list<COrphan> vOrphan; // list memory doesn't move\n-        map<uint256, vector<COrphan*> > mapDependers;\n-        bool fPrintPriority = GetBoolArg(\"-printpriority\", false);\n-\n-        // This vector will be sorted into a priority queue:\n-        vector<TxPriority> vecPriority;\n-        vecPriority.reserve(mempool.mapTx.size());\n-        for (map<uint256, CTransaction>::iterator mi = mempool.mapTx.begin(); mi != mempool.mapTx.end(); ++mi)\n-        {\n-            CTransaction& tx = (*mi).second;\n-            if (tx.IsCoinBase() || !IsFinalTx(tx))\n-                continue;\n-\n-            COrphan* porphan = NULL;\n-            double dPriority = 0;\n-            int64 nTotalIn = 0;\n-            bool fMissingInputs = false;\n-            BOOST_FOREACH(const CTxIn& txin, tx.vin)\n-            {\n-                // Read prev transaction\n-                if (!view.HaveCoins(txin.prevout.hash))\n-                {\n-                    // This should never happen; all transactions in the memory\n-                    // pool should connect to either transactions in the chain\n-                    // or other transactions in the memory pool.\n-                    if (!mempool.mapTx.count(txin.prevout.hash))\n-                    {\n-                        printf(\"ERROR: mempool transaction missing input\\n\");\n-                        if (fDebug) assert(\"mempool transaction missing input\" == 0);\n-                        fMissingInputs = true;\n-                        if (porphan)\n-                            vOrphan.pop_back();\n-                        break;\n-                    }\n-\n-                    // Has to wait for dependencies\n-                    if (!porphan)\n-                    {\n-                        // Use list for automatic deletion\n-                        vOrphan.push_back(COrphan(&tx));\n-                        porphan = &vOrphan.back();\n-                    }\n-                    mapDependers[txin.prevout.hash].push_back(porphan);\n-                    porphan->setDependsOn.insert(txin.prevout.hash);\n-                    nTotalIn += mempool.mapTx[txin.prevout.hash].vout[txin.prevout.n].nValue;\n-                    continue;\n-                }\n-                const CCoins &coins = view.GetCoins(txin.prevout.hash);\n-\n-                int64 nValueIn = coins.vout[txin.prevout.n].nValue;\n-                nTotalIn += nValueIn;\n-\n-                int nConf = pindexPrev->nHeight - coins.nHeight + 1;\n-\n-                dPriority += (double)nValueIn * nConf;\n-            }\n-            if (fMissingInputs) continue;\n-\n-            // Priority is sum(valuein * age) / txsize\n-            unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n-            dPriority /= nTxSize;\n-\n-            // This is a more accurate fee-per-kilobyte than is used by the client code, because the\n-            // client code rounds up the size to the nearest 1K. That's good, because it gives an\n-            // incentive to create smaller transactions.\n-            double dFeePerKb =  double(nTotalIn-GetValueOut(tx)) / (double(nTxSize)/1000.0);\n-\n-            if (porphan)\n-            {\n-                porphan->dPriority = dPriority;\n-                porphan->dFeePerKb = dFeePerKb;\n-            }\n-            else\n-                vecPriority.push_back(TxPriority(dPriority, dFeePerKb, &(*mi).second));\n-        }\n-\n-        // Collect transactions into block\n-        uint64 nBlockSize = 1000;\n-        uint64 nBlockTx = 0;\n-        int nBlockSigOps = 100;\n-        bool fSortedByFee = (nBlockPrioritySize <= 0);\n-\n-        TxPriorityCompare comparer(fSortedByFee);\n-        std::make_heap(vecPriority.begin(), vecPriority.end(), comparer);\n-\n-        while (!vecPriority.empty())\n-        {\n-            // Take highest priority transaction off the priority queue:\n-            double dPriority = vecPriority.front().get<0>();\n-            double dFeePerKb = vecPriority.front().get<1>();\n-            CTransaction& tx = *(vecPriority.front().get<2>());\n-\n-            std::pop_heap(vecPriority.begin(), vecPriority.end(), comparer);\n-            vecPriority.pop_back();\n-\n-            // Size limits\n-            unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n-            if (nBlockSize + nTxSize >= nBlockMaxSize)\n-                continue;\n-\n-            // Legacy limits on sigOps:\n-            unsigned int nTxSigOps = GetLegacySigOpCount(tx);\n-            if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n-                continue;\n-\n-            // Skip free transactions if we're past the minimum block size:\n-            if (fSortedByFee && (dFeePerKb < CTransaction::nMinTxFee) && (nBlockSize + nTxSize >= nBlockMinSize))\n-                continue;\n-\n-            // Prioritize by fee once past the priority size or we run out of high-priority\n-            // transactions:\n-            if (!fSortedByFee &&\n-                ((nBlockSize + nTxSize >= nBlockPrioritySize) || !AllowFree(dPriority)))\n-            {\n-                fSortedByFee = true;\n-                comparer = TxPriorityCompare(fSortedByFee);\n-                std::make_heap(vecPriority.begin(), vecPriority.end(), comparer);\n-            }\n-\n-            if (!view.HaveInputs(tx))\n-                continue;\n-\n-            int64 nTxFees = view.GetValueIn(tx)-GetValueOut(tx);\n-\n-            nTxSigOps += GetP2SHSigOpCount(tx, view);\n-            if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n-                continue;\n-\n-            CValidationState state;\n-            if (!CheckInputs(tx, state, view, true, SCRIPT_VERIFY_P2SH))\n-                continue;\n-\n-            CTxUndo txundo;\n-            uint256 hash = tx.GetHash();\n-            UpdateCoins(tx, state, view, txundo, pindexPrev->nHeight+1, hash);\n-\n-            // Added\n-            pblock->vtx.push_back(tx);\n-            pblocktemplate->vTxFees.push_back(nTxFees);\n-            pblocktemplate->vTxSigOps.push_back(nTxSigOps);\n-            nBlockSize += nTxSize;\n-            ++nBlockTx;\n-            nBlockSigOps += nTxSigOps;\n-            nFees += nTxFees;\n-\n-            if (fPrintPriority)\n-            {\n-                printf(\"priority %.1f feeperkb %.1f txid %s\\n\",\n-                       dPriority, dFeePerKb, tx.GetHash().ToString().c_str());\n-            }\n-\n-            // Add transactions that depend on this one to the priority queue\n-            if (mapDependers.count(hash))\n-            {\n-                BOOST_FOREACH(COrphan* porphan, mapDependers[hash])\n-                {\n-                    if (!porphan->setDependsOn.empty())\n-                    {\n-                        porphan->setDependsOn.erase(hash);\n-                        if (porphan->setDependsOn.empty())\n-                        {\n-                            vecPriority.push_back(TxPriority(porphan->dPriority, porphan->dFeePerKb, porphan->ptx));\n-                            std::push_heap(vecPriority.begin(), vecPriority.end(), comparer);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        nLastBlockTx = nBlockTx;\n-        nLastBlockSize = nBlockSize;\n-        printf(\"CreateNewBlock(): total size %\"PRI64u\"\\n\", nBlockSize);\n-\n-        pblock->vtx[0].vout[0].nValue = GetBlockValue(pindexPrev->nHeight+1, nFees);\n-        pblocktemplate->vTxFees[0] = -nFees;\n-\n-        // Fill in header\n-        pblock->hashPrevBlock  = pindexPrev->GetBlockHash();\n-        UpdateTime(*pblock, pindexPrev);\n-        pblock->nBits          = GetNextWorkRequired(pindexPrev, pblock);\n-        pblock->nNonce         = 0;\n-        pblock->vtx[0].vin[0].scriptSig = CScript() << OP_0 << OP_0;\n-        pblocktemplate->vTxSigOps[0] = GetLegacySigOpCount(pblock->vtx[0]);\n-\n-        CBlockIndex indexDummy(*pblock);\n-        indexDummy.pprev = pindexPrev;\n-        indexDummy.nHeight = pindexPrev->nHeight + 1;\n-        CCoinsViewCache viewNew(*pcoinsTip, true);\n-        CValidationState state;\n-        if (!ConnectBlock(*pblock, state, &indexDummy, viewNew, true))\n-            throw std::runtime_error(\"CreateNewBlock() : ConnectBlock failed\");\n-    }\n-\n-    return pblocktemplate.release();\n-}\n-\n-\n-void IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int& nExtraNonce)\n-{\n-    // Update nExtraNonce\n-    static uint256 hashPrevBlock;\n-    if (hashPrevBlock != pblock->hashPrevBlock)\n-    {\n-        nExtraNonce = 0;\n-        hashPrevBlock = pblock->hashPrevBlock;\n-    }\n-    ++nExtraNonce;\n-    unsigned int nHeight = pindexPrev->nHeight+1; // Height first in coinbase required for block.version=2\n-    pblock->vtx[0].vin[0].scriptSig = (CScript() << nHeight << CBigNum(nExtraNonce)) + COINBASE_FLAGS;\n-    assert(pblock->vtx[0].vin[0].scriptSig.size() <= 100);\n-\n-    pblock->hashMerkleRoot = pblock->BuildMerkleTree();\n-}\n-\n-\n-void FormatHashBuffers(CBlock* pblock, char* pmidstate, char* pdata, char* phash1)\n-{\n-    //\n-    // Pre-build hash buffers\n-    //\n-    struct\n-    {\n-        struct unnamed2\n-        {\n-            int nVersion;\n-            uint256 hashPrevBlock;\n-            uint256 hashMerkleRoot;\n-            unsigned int nTime;\n-            unsigned int nBits;\n-            unsigned int nNonce;\n-        }\n-        block;\n-        unsigned char pchPadding0[64];\n-        uint256 hash1;\n-        unsigned char pchPadding1[64];\n-    }\n-    tmp;\n-    memset(&tmp, 0, sizeof(tmp));\n-\n-    tmp.block.nVersion       = pblock->nVersion;\n-    tmp.block.hashPrevBlock  = pblock->hashPrevBlock;\n-    tmp.block.hashMerkleRoot = pblock->hashMerkleRoot;\n-    tmp.block.nTime          = pblock->nTime;\n-    tmp.block.nBits          = pblock->nBits;\n-    tmp.block.nNonce         = pblock->nNonce;\n-\n-    FormatHashBlocks(&tmp.block, sizeof(tmp.block));\n-    FormatHashBlocks(&tmp.hash1, sizeof(tmp.hash1));\n-\n-    // Byte swap all the input buffer\n-    for (unsigned int i = 0; i < sizeof(tmp)/4; i++)\n-        ((unsigned int*)&tmp)[i] = ByteReverse(((unsigned int*)&tmp)[i]);\n-\n-    // Precalc the first half of the first hash, which stays constant\n-    SHA256Transform(pmidstate, &tmp.block, pSHA256InitState);\n-\n-    memcpy(pdata, &tmp.block, 128);\n-    memcpy(phash1, &tmp.hash1, 64);\n-}\n-\n-\n-bool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey)\n-{\n-    uint256 hash = pblock->GetHash();\n-    uint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n-\n-    if (hash > hashTarget)\n-        return false;\n-\n-    //// debug print\n-    printf(\"BitcoinMiner:\\n\");\n-    printf(\"proof-of-work found  \\n  hash: %s  \\ntarget: %s\\n\", hash.GetHex().c_str(), hashTarget.GetHex().c_str());\n-    pblock->print();\n-    printf(\"generated %s\\n\", FormatMoney(pblock->vtx[0].vout[0].nValue).c_str());\n-\n-    // Found a solution\n-    {\n-        LOCK(cs_main);\n-        if (pblock->hashPrevBlock != hashBestChain)\n-            return error(\"BitcoinMiner : generated block is stale\");\n-\n-        // Remove key from key pool\n-        reservekey.KeepKey();\n-\n-        // Track how many getdata requests this block gets\n-        {\n-            LOCK(wallet.cs_wallet);\n-            wallet.mapRequestCount[pblock->GetHash()] = 0;\n-        }\n-\n-        // Process this block the same as if we had received it from another node\n-        CValidationState state;\n-        if (!ProcessBlock(state, NULL, pblock))\n-            return error(\"BitcoinMiner : ProcessBlock, block not accepted\");\n-    }\n-\n-    return true;\n-}\n-\n-void static BitcoinMiner(CWallet *pwallet)\n-{\n-    printf(\"BitcoinMiner started\\n\");\n-    SetThreadPriority(THREAD_PRIORITY_LOWEST);\n-    RenameThread(\"bitcoin-miner\");\n-\n-    // Each thread has its own key and counter\n-    CReserveKey reservekey(pwallet);\n-    unsigned int nExtraNonce = 0;\n-\n-    try { while (true) {\n-        if (Params().NetworkID() != CChainParams::REGTEST) {\n-            // Busy-wait for the network to come online so we don't waste time mining\n-            // on an obsolete chain. In regtest mode we expect to fly solo.\n-            while (vNodes.empty())\n-                MilliSleep(1000);\n-        }\n-\n-        //\n-        // Create new block\n-        //\n-        unsigned int nTransactionsUpdatedLast = nTransactionsUpdated;\n-        CBlockIndex* pindexPrev = pindexBest;\n-\n-        auto_ptr<CBlockTemplate> pblocktemplate(CreateNewBlock(reservekey));\n-        if (!pblocktemplate.get())\n-            return;\n-        CBlock *pblock = &pblocktemplate->block;\n-        IncrementExtraNonce(pblock, pindexPrev, nExtraNonce);\n-\n-        printf(\"Running BitcoinMiner with %\"PRIszu\" transactions in block (%u bytes)\\n\", pblock->vtx.size(),\n-               ::GetSerializeSize(*pblock, SER_NETWORK, PROTOCOL_VERSION));\n-\n-        //\n-        // Pre-build hash buffers\n-        //\n-        char pmidstatebuf[32+16]; char* pmidstate = alignup<16>(pmidstatebuf);\n-        char pdatabuf[128+16];    char* pdata     = alignup<16>(pdatabuf);\n-        char phash1buf[64+16];    char* phash1    = alignup<16>(phash1buf);\n-\n-        FormatHashBuffers(pblock, pmidstate, pdata, phash1);\n-\n-        unsigned int& nBlockTime = *(unsigned int*)(pdata + 64 + 4);\n-        unsigned int& nBlockBits = *(unsigned int*)(pdata + 64 + 8);\n-        unsigned int& nBlockNonce = *(unsigned int*)(pdata + 64 + 12);\n-\n-\n-        //\n-        // Search\n-        //\n-        int64 nStart = GetTime();\n-        uint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n-        uint256 hashbuf[2];\n-        uint256& hash = *alignup<16>(hashbuf);\n-        while (true)\n-        {\n-            unsigned int nHashesDone = 0;\n-            unsigned int nNonceFound;\n-\n-            // Crypto++ SHA256\n-            nNonceFound = ScanHash_CryptoPP(pmidstate, pdata + 64, phash1,\n-                                            (char*)&hash, nHashesDone);\n-\n-            // Check if something found\n-            if (nNonceFound != (unsigned int) -1)\n-            {\n-                for (unsigned int i = 0; i < sizeof(hash)/4; i++)\n-                    ((unsigned int*)&hash)[i] = ByteReverse(((unsigned int*)&hash)[i]);\n-\n-                if (hash <= hashTarget)\n-                {\n-                    // Found a solution\n-                    pblock->nNonce = ByteReverse(nNonceFound);\n-                    assert(hash == pblock->GetHash());\n-\n-                    SetThreadPriority(THREAD_PRIORITY_NORMAL);\n-                    CheckWork(pblock, *pwallet, reservekey);\n-                    SetThreadPriority(THREAD_PRIORITY_LOWEST);\n-\n-                    // In regression test mode, stop mining after a block is found. This\n-                    // allows developers to controllably generate a block on demand.\n-                    if (Params().NetworkID() == CChainParams::REGTEST)\n-                        throw boost::thread_interrupted();\n-\n-                    break;\n-                }\n-            }\n-\n-            // Meter hashes/sec\n-            static int64 nHashCounter;\n-            if (nHPSTimerStart == 0)\n-            {\n-                nHPSTimerStart = GetTimeMillis();\n-                nHashCounter = 0;\n-            }\n-            else\n-                nHashCounter += nHashesDone;\n-            if (GetTimeMillis() - nHPSTimerStart > 4000)\n-            {\n-                static CCriticalSection cs;\n-                {\n-                    LOCK(cs);\n-                    if (GetTimeMillis() - nHPSTimerStart > 4000)\n-                    {\n-                        dHashesPerSec = 1000.0 * nHashCounter / (GetTimeMillis() - nHPSTimerStart);\n-                        nHPSTimerStart = GetTimeMillis();\n-                        nHashCounter = 0;\n-                        static int64 nLogTime;\n-                        if (GetTime() - nLogTime > 30 * 60)\n-                        {\n-                            nLogTime = GetTime();\n-                            printf(\"hashmeter %6.0f khash/s\\n\", dHashesPerSec/1000.0);\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // Check for stop or if block needs to be rebuilt\n-            boost::this_thread::interruption_point();\n-            if (vNodes.empty() && Params().NetworkID() != CChainParams::REGTEST)\n-                break;\n-            if (nBlockNonce >= 0xffff0000)\n-                break;\n-            if (nTransactionsUpdated != nTransactionsUpdatedLast && GetTime() - nStart > 60)\n-                break;\n-            if (pindexPrev != pindexBest)\n-                break;\n-\n-            // Update nTime every few seconds\n-            UpdateTime(*pblock, pindexPrev);\n-            nBlockTime = ByteReverse(pblock->nTime);\n-            if (TestNet())\n-            {\n-                // Changing pblock->nTime can change work required on testnet:\n-                nBlockBits = ByteReverse(pblock->nBits);\n-                hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n-            }\n-        }\n-    } }\n-    catch (boost::thread_interrupted)\n-    {\n-        printf(\"BitcoinMiner terminated\\n\");\n-        throw;\n-    }\n-}\n-\n-void GenerateBitcoins(bool fGenerate, CWallet* pwallet)\n-{\n-    static boost::thread_group* minerThreads = NULL;\n-\n-    int nThreads = GetArg(\"-genproclimit\", -1);\n-    if (nThreads < 0) {\n-        if (Params().NetworkID() == CChainParams::REGTEST)\n-            nThreads = 1;\n-        else\n-            nThreads = boost::thread::hardware_concurrency();\n-    }\n-\n-    if (minerThreads != NULL)\n-    {\n-        minerThreads->interrupt_all();\n-        delete minerThreads;\n-        minerThreads = NULL;\n-    }\n-\n-    if (nThreads == 0 || !fGenerate)\n-        return;\n-\n-    minerThreads = new boost::thread_group();\n-    for (int i = 0; i < nThreads; i++)\n-        minerThreads->create_thread(boost::bind(&BitcoinMiner, pwallet));\n-}\n-\n-\n-\n class CMainCleanup\n {\n public:"
      },
      {
        "sha": "cb0ee1aaa85ede7b5107d0f3f4c960dc13a07bba",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 2,
        "deletions": 10,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d247a5d130544622519ad84dc8a1e50336397c51/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d247a5d130544622519ad84dc8a1e50336397c51/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=d247a5d130544622519ad84dc8a1e50336397c51",
        "patch": "@@ -159,16 +159,6 @@ bool ProcessMessages(CNode* pfrom);\n bool SendMessages(CNode* pto, bool fSendTrickle);\n /** Run an instance of the script checking thread */\n void ThreadScriptCheck();\n-/** Run the miner threads */\n-void GenerateBitcoins(bool fGenerate, CWallet* pwallet);\n-/** Generate a new block, without valid proof-of-work */\n-CBlockTemplate* CreateNewBlock(CReserveKey& reservekey);\n-/** Modify the extranonce in a block */\n-void IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int& nExtraNonce);\n-/** Do mining precalculation */\n-void FormatHashBuffers(CBlock* pblock, char* pmidstate, char* pdata, char* phash1);\n-/** Check mined block */\n-bool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey);\n /** Check whether a block hash satisfies the proof-of-work requirement specified by nBits */\n bool CheckProofOfWork(uint256 hash, unsigned int nBits);\n /** Calculate the minimum amount of work a received block needs, without knowing its direct parent */\n@@ -185,6 +175,8 @@ bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock, b\n bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew);\n /** Find the best known block, and make it the tip of the block chain */\n bool ConnectBestBlock(CValidationState &state);\n+int64 GetBlockValue(int nHeight, int64 nFees);\n+unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHeader *pblock);\n \n void UpdateTime(CBlockHeader& block, const CBlockIndex* pindexPrev);\n "
      },
      {
        "sha": "51830f2342c26880f5118bee8cf46bb6614a974a",
        "filename": "src/makefile.linux-mingw",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d247a5d130544622519ad84dc8a1e50336397c51/src/makefile.linux-mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d247a5d130544622519ad84dc8a1e50336397c51/src/makefile.linux-mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.linux-mingw?ref=d247a5d130544622519ad84dc8a1e50336397c51",
        "patch": "@@ -75,6 +75,7 @@ OBJS= \\\n     obj/keystore.o \\\n     obj/core.o \\\n     obj/main.o \\\n+    obj/miner.o \\\n     obj/net.o \\\n     obj/protocol.o \\\n     obj/bitcoinrpc.o \\"
      },
      {
        "sha": "464f69b1c9e654036791b1e0b769a2173a5db008",
        "filename": "src/makefile.mingw",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d247a5d130544622519ad84dc8a1e50336397c51/src/makefile.mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d247a5d130544622519ad84dc8a1e50336397c51/src/makefile.mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.mingw?ref=d247a5d130544622519ad84dc8a1e50336397c51",
        "patch": "@@ -83,6 +83,7 @@ OBJS= \\\n     obj/keystore.o \\\n     obj/core.o \\\n     obj/main.o \\\n+    obj/miner.o \\\n     obj/net.o \\\n     obj/protocol.o \\\n     obj/bitcoinrpc.o \\"
      },
      {
        "sha": "ee364f5c4a1d6697a0ec8290218301c9a090d064",
        "filename": "src/makefile.osx",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d247a5d130544622519ad84dc8a1e50336397c51/src/makefile.osx",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d247a5d130544622519ad84dc8a1e50336397c51/src/makefile.osx",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.osx?ref=d247a5d130544622519ad84dc8a1e50336397c51",
        "patch": "@@ -86,6 +86,7 @@ OBJS= \\\n     obj/keystore.o \\\n     obj/core.o \\\n     obj/main.o \\\n+    obj/miner.o \\\n     obj/net.o \\\n     obj/protocol.o \\\n     obj/bitcoinrpc.o \\"
      },
      {
        "sha": "e00db09a33b2b25019ad0695f0b8dc1a68b36d49",
        "filename": "src/makefile.unix",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d247a5d130544622519ad84dc8a1e50336397c51/src/makefile.unix",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d247a5d130544622519ad84dc8a1e50336397c51/src/makefile.unix",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.unix?ref=d247a5d130544622519ad84dc8a1e50336397c51",
        "patch": "@@ -125,6 +125,7 @@ OBJS= \\\n     obj/keystore.o \\\n     obj/core.o \\\n     obj/main.o \\\n+    obj/miner.o \\\n     obj/net.o \\\n     obj/protocol.o \\\n     obj/bitcoinrpc.o \\"
      },
      {
        "sha": "e50c0b576df0d62f56828680d7975f1a0cbb62c4",
        "filename": "src/miner.cpp",
        "status": "added",
        "additions": 663,
        "deletions": 0,
        "changes": 663,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d247a5d130544622519ad84dc8a1e50336397c51/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d247a5d130544622519ad84dc8a1e50336397c51/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=d247a5d130544622519ad84dc8a1e50336397c51",
        "patch": "@@ -0,0 +1,663 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2012 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"core.h\"\n+#include \"wallet.h\"\n+#include \"miner.h\"\n+#include \"main.h\"\n+\n+\n+\n+\n+\n+\n+//////////////////////////////////////////////////////////////////////////////\n+//\n+// BitcoinMiner\n+//\n+\n+int static FormatHashBlocks(void* pbuffer, unsigned int len)\n+{\n+    unsigned char* pdata = (unsigned char*)pbuffer;\n+    unsigned int blocks = 1 + ((len + 8) / 64);\n+    unsigned char* pend = pdata + 64 * blocks;\n+    memset(pdata + len, 0, 64 * blocks - len);\n+    pdata[len] = 0x80;\n+    unsigned int bits = len * 8;\n+    pend[-1] = (bits >> 0) & 0xff;\n+    pend[-2] = (bits >> 8) & 0xff;\n+    pend[-3] = (bits >> 16) & 0xff;\n+    pend[-4] = (bits >> 24) & 0xff;\n+    return blocks;\n+}\n+\n+static const unsigned int pSHA256InitState[8] =\n+{0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19};\n+\n+void SHA256Transform(void* pstate, void* pinput, const void* pinit)\n+{\n+    SHA256_CTX ctx;\n+    unsigned char data[64];\n+\n+    SHA256_Init(&ctx);\n+\n+    for (int i = 0; i < 16; i++)\n+        ((uint32_t*)data)[i] = ByteReverse(((uint32_t*)pinput)[i]);\n+\n+    for (int i = 0; i < 8; i++)\n+        ctx.h[i] = ((uint32_t*)pinit)[i];\n+\n+    SHA256_Update(&ctx, data, sizeof(data));\n+    for (int i = 0; i < 8; i++)\n+        ((uint32_t*)pstate)[i] = ctx.h[i];\n+}\n+\n+//\n+// ScanHash scans nonces looking for a hash with at least some zero bits.\n+// It operates on big endian data.  Caller does the byte reversing.\n+// All input buffers are 16-byte aligned.  nNonce is usually preserved\n+// between calls, but periodically or if nNonce is 0xffff0000 or above,\n+// the block is rebuilt and nNonce starts over at zero.\n+//\n+unsigned int static ScanHash_CryptoPP(char* pmidstate, char* pdata, char* phash1, char* phash, unsigned int& nHashesDone)\n+{\n+    unsigned int& nNonce = *(unsigned int*)(pdata + 12);\n+    for (;;)\n+    {\n+        // Crypto++ SHA256\n+        // Hash pdata using pmidstate as the starting state into\n+        // pre-formatted buffer phash1, then hash phash1 into phash\n+        nNonce++;\n+        SHA256Transform(phash1, pdata, pmidstate);\n+        SHA256Transform(phash, phash1, pSHA256InitState);\n+\n+        // Return the nonce if the hash has at least some zero bits,\n+        // caller will check if it has enough to reach the target\n+        if (((unsigned short*)phash)[14] == 0)\n+            return nNonce;\n+\n+        // If nothing found after trying for a while, return -1\n+        if ((nNonce & 0xffff) == 0)\n+        {\n+            nHashesDone = 0xffff+1;\n+            return (unsigned int) -1;\n+        }\n+        if ((nNonce & 0xfff) == 0)\n+            boost::this_thread::interruption_point();\n+    }\n+}\n+\n+// Some explaining would be appreciated\n+class COrphan\n+{\n+public:\n+    CTransaction* ptx;\n+    set<uint256> setDependsOn;\n+    double dPriority;\n+    double dFeePerKb;\n+\n+    COrphan(CTransaction* ptxIn)\n+    {\n+        ptx = ptxIn;\n+        dPriority = dFeePerKb = 0;\n+    }\n+\n+    void print() const\n+    {\n+        printf(\"COrphan(hash=%s, dPriority=%.1f, dFeePerKb=%.1f)\\n\",\n+               ptx->GetHash().ToString().c_str(), dPriority, dFeePerKb);\n+        BOOST_FOREACH(uint256 hash, setDependsOn)\n+            printf(\"   setDependsOn %s\\n\", hash.ToString().c_str());\n+    }\n+};\n+\n+\n+uint64 nLastBlockTx = 0;\n+uint64 nLastBlockSize = 0;\n+\n+// We want to sort transactions by priority and fee, so:\n+typedef boost::tuple<double, double, CTransaction*> TxPriority;\n+class TxPriorityCompare\n+{\n+    bool byFee;\n+public:\n+    TxPriorityCompare(bool _byFee) : byFee(_byFee) { }\n+    bool operator()(const TxPriority& a, const TxPriority& b)\n+    {\n+        if (byFee)\n+        {\n+            if (a.get<1>() == b.get<1>())\n+                return a.get<0>() < b.get<0>();\n+            return a.get<1>() < b.get<1>();\n+        }\n+        else\n+        {\n+            if (a.get<0>() == b.get<0>())\n+                return a.get<1>() < b.get<1>();\n+            return a.get<0>() < b.get<0>();\n+        }\n+    }\n+};\n+\n+CBlockTemplate* CreateNewBlock(CReserveKey& reservekey)\n+{\n+    // Create new block\n+    auto_ptr<CBlockTemplate> pblocktemplate(new CBlockTemplate());\n+    if(!pblocktemplate.get())\n+        return NULL;\n+    CBlock *pblock = &pblocktemplate->block; // pointer for convenience\n+\n+    // Create coinbase tx\n+    CTransaction txNew;\n+    txNew.vin.resize(1);\n+    txNew.vin[0].prevout.SetNull();\n+    txNew.vout.resize(1);\n+    CPubKey pubkey;\n+    if (!reservekey.GetReservedKey(pubkey))\n+        return NULL;\n+    txNew.vout[0].scriptPubKey << pubkey << OP_CHECKSIG;\n+\n+    // Add our coinbase tx as first transaction\n+    pblock->vtx.push_back(txNew);\n+    pblocktemplate->vTxFees.push_back(-1); // updated at end\n+    pblocktemplate->vTxSigOps.push_back(-1); // updated at end\n+\n+    // Largest block you're willing to create:\n+    unsigned int nBlockMaxSize = GetArg(\"-blockmaxsize\", MAX_BLOCK_SIZE_GEN/2);\n+    // Limit to betweeen 1K and MAX_BLOCK_SIZE-1K for sanity:\n+    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));\n+\n+    // How much of the block should be dedicated to high-priority transactions,\n+    // included regardless of the fees they pay\n+    unsigned int nBlockPrioritySize = GetArg(\"-blockprioritysize\", DEFAULT_BLOCK_PRIORITY_SIZE);\n+    nBlockPrioritySize = std::min(nBlockMaxSize, nBlockPrioritySize);\n+\n+    // Minimum block size you want to create; block will be filled with free transactions\n+    // until there are no more or the block reaches this size:\n+    unsigned int nBlockMinSize = GetArg(\"-blockminsize\", 0);\n+    nBlockMinSize = std::min(nBlockMaxSize, nBlockMinSize);\n+\n+    // Collect memory pool transactions into the block\n+    int64 nFees = 0;\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CBlockIndex* pindexPrev = pindexBest;\n+        CCoinsViewCache view(*pcoinsTip, true);\n+\n+        // Priority order to process transactions\n+        list<COrphan> vOrphan; // list memory doesn't move\n+        map<uint256, vector<COrphan*> > mapDependers;\n+        bool fPrintPriority = GetBoolArg(\"-printpriority\", false);\n+\n+        // This vector will be sorted into a priority queue:\n+        vector<TxPriority> vecPriority;\n+        vecPriority.reserve(mempool.mapTx.size());\n+        for (map<uint256, CTransaction>::iterator mi = mempool.mapTx.begin(); mi != mempool.mapTx.end(); ++mi)\n+        {\n+            CTransaction& tx = (*mi).second;\n+            if (tx.IsCoinBase() || !IsFinalTx(tx))\n+                continue;\n+\n+            COrphan* porphan = NULL;\n+            double dPriority = 0;\n+            int64 nTotalIn = 0;\n+            bool fMissingInputs = false;\n+            BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+            {\n+                // Read prev transaction\n+                if (!view.HaveCoins(txin.prevout.hash))\n+                {\n+                    // This should never happen; all transactions in the memory\n+                    // pool should connect to either transactions in the chain\n+                    // or other transactions in the memory pool.\n+                    if (!mempool.mapTx.count(txin.prevout.hash))\n+                    {\n+                        printf(\"ERROR: mempool transaction missing input\\n\");\n+                        if (fDebug) assert(\"mempool transaction missing input\" == 0);\n+                        fMissingInputs = true;\n+                        if (porphan)\n+                            vOrphan.pop_back();\n+                        break;\n+                    }\n+\n+                    // Has to wait for dependencies\n+                    if (!porphan)\n+                    {\n+                        // Use list for automatic deletion\n+                        vOrphan.push_back(COrphan(&tx));\n+                        porphan = &vOrphan.back();\n+                    }\n+                    mapDependers[txin.prevout.hash].push_back(porphan);\n+                    porphan->setDependsOn.insert(txin.prevout.hash);\n+                    nTotalIn += mempool.mapTx[txin.prevout.hash].vout[txin.prevout.n].nValue;\n+                    continue;\n+                }\n+                const CCoins &coins = view.GetCoins(txin.prevout.hash);\n+\n+                int64 nValueIn = coins.vout[txin.prevout.n].nValue;\n+                nTotalIn += nValueIn;\n+\n+                int nConf = pindexPrev->nHeight - coins.nHeight + 1;\n+\n+                dPriority += (double)nValueIn * nConf;\n+            }\n+            if (fMissingInputs) continue;\n+\n+            // Priority is sum(valuein * age) / txsize\n+            unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n+            dPriority /= nTxSize;\n+\n+            // This is a more accurate fee-per-kilobyte than is used by the client code, because the\n+            // client code rounds up the size to the nearest 1K. That's good, because it gives an\n+            // incentive to create smaller transactions.\n+            double dFeePerKb =  double(nTotalIn-GetValueOut(tx)) / (double(nTxSize)/1000.0);\n+\n+            if (porphan)\n+            {\n+                porphan->dPriority = dPriority;\n+                porphan->dFeePerKb = dFeePerKb;\n+            }\n+            else\n+                vecPriority.push_back(TxPriority(dPriority, dFeePerKb, &(*mi).second));\n+        }\n+\n+        // Collect transactions into block\n+        uint64 nBlockSize = 1000;\n+        uint64 nBlockTx = 0;\n+        int nBlockSigOps = 100;\n+        bool fSortedByFee = (nBlockPrioritySize <= 0);\n+\n+        TxPriorityCompare comparer(fSortedByFee);\n+        std::make_heap(vecPriority.begin(), vecPriority.end(), comparer);\n+\n+        while (!vecPriority.empty())\n+        {\n+            // Take highest priority transaction off the priority queue:\n+            double dPriority = vecPriority.front().get<0>();\n+            double dFeePerKb = vecPriority.front().get<1>();\n+            CTransaction& tx = *(vecPriority.front().get<2>());\n+\n+            std::pop_heap(vecPriority.begin(), vecPriority.end(), comparer);\n+            vecPriority.pop_back();\n+\n+            // Size limits\n+            unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n+            if (nBlockSize + nTxSize >= nBlockMaxSize)\n+                continue;\n+\n+            // Legacy limits on sigOps:\n+            unsigned int nTxSigOps = GetLegacySigOpCount(tx);\n+            if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n+                continue;\n+\n+            // Skip free transactions if we're past the minimum block size:\n+            if (fSortedByFee && (dFeePerKb < CTransaction::nMinTxFee) && (nBlockSize + nTxSize >= nBlockMinSize))\n+                continue;\n+\n+            // Prioritize by fee once past the priority size or we run out of high-priority\n+            // transactions:\n+            if (!fSortedByFee &&\n+                ((nBlockSize + nTxSize >= nBlockPrioritySize) || !AllowFree(dPriority)))\n+            {\n+                fSortedByFee = true;\n+                comparer = TxPriorityCompare(fSortedByFee);\n+                std::make_heap(vecPriority.begin(), vecPriority.end(), comparer);\n+            }\n+\n+            if (!view.HaveInputs(tx))\n+                continue;\n+\n+            int64 nTxFees = view.GetValueIn(tx)-GetValueOut(tx);\n+\n+            nTxSigOps += GetP2SHSigOpCount(tx, view);\n+            if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n+                continue;\n+\n+            CValidationState state;\n+            if (!CheckInputs(tx, state, view, true, SCRIPT_VERIFY_P2SH))\n+                continue;\n+\n+            CTxUndo txundo;\n+            uint256 hash = tx.GetHash();\n+            UpdateCoins(tx, state, view, txundo, pindexPrev->nHeight+1, hash);\n+\n+            // Added\n+            pblock->vtx.push_back(tx);\n+            pblocktemplate->vTxFees.push_back(nTxFees);\n+            pblocktemplate->vTxSigOps.push_back(nTxSigOps);\n+            nBlockSize += nTxSize;\n+            ++nBlockTx;\n+            nBlockSigOps += nTxSigOps;\n+            nFees += nTxFees;\n+\n+            if (fPrintPriority)\n+            {\n+                printf(\"priority %.1f feeperkb %.1f txid %s\\n\",\n+                       dPriority, dFeePerKb, tx.GetHash().ToString().c_str());\n+            }\n+\n+            // Add transactions that depend on this one to the priority queue\n+            if (mapDependers.count(hash))\n+            {\n+                BOOST_FOREACH(COrphan* porphan, mapDependers[hash])\n+                {\n+                    if (!porphan->setDependsOn.empty())\n+                    {\n+                        porphan->setDependsOn.erase(hash);\n+                        if (porphan->setDependsOn.empty())\n+                        {\n+                            vecPriority.push_back(TxPriority(porphan->dPriority, porphan->dFeePerKb, porphan->ptx));\n+                            std::push_heap(vecPriority.begin(), vecPriority.end(), comparer);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        nLastBlockTx = nBlockTx;\n+        nLastBlockSize = nBlockSize;\n+        printf(\"CreateNewBlock(): total size %\"PRI64u\"\\n\", nBlockSize);\n+\n+        pblock->vtx[0].vout[0].nValue = GetBlockValue(pindexPrev->nHeight+1, nFees);\n+        pblocktemplate->vTxFees[0] = -nFees;\n+\n+        // Fill in header\n+        pblock->hashPrevBlock  = pindexPrev->GetBlockHash();\n+        UpdateTime(*pblock, pindexPrev);\n+        pblock->nBits          = GetNextWorkRequired(pindexPrev, pblock);\n+        pblock->nNonce         = 0;\n+        pblock->vtx[0].vin[0].scriptSig = CScript() << OP_0 << OP_0;\n+        pblocktemplate->vTxSigOps[0] = GetLegacySigOpCount(pblock->vtx[0]);\n+\n+        CBlockIndex indexDummy(*pblock);\n+        indexDummy.pprev = pindexPrev;\n+        indexDummy.nHeight = pindexPrev->nHeight + 1;\n+        CCoinsViewCache viewNew(*pcoinsTip, true);\n+        CValidationState state;\n+        if (!ConnectBlock(*pblock, state, &indexDummy, viewNew, true))\n+            throw std::runtime_error(\"CreateNewBlock() : ConnectBlock failed\");\n+    }\n+\n+    return pblocktemplate.release();\n+}\n+\n+\n+void IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int& nExtraNonce)\n+{\n+    // Update nExtraNonce\n+    static uint256 hashPrevBlock;\n+    if (hashPrevBlock != pblock->hashPrevBlock)\n+    {\n+        nExtraNonce = 0;\n+        hashPrevBlock = pblock->hashPrevBlock;\n+    }\n+    ++nExtraNonce;\n+    unsigned int nHeight = pindexPrev->nHeight+1; // Height first in coinbase required for block.version=2\n+    pblock->vtx[0].vin[0].scriptSig = (CScript() << nHeight << CBigNum(nExtraNonce)) + COINBASE_FLAGS;\n+    assert(pblock->vtx[0].vin[0].scriptSig.size() <= 100);\n+\n+    pblock->hashMerkleRoot = pblock->BuildMerkleTree();\n+}\n+\n+\n+void FormatHashBuffers(CBlock* pblock, char* pmidstate, char* pdata, char* phash1)\n+{\n+    //\n+    // Pre-build hash buffers\n+    //\n+    struct\n+    {\n+        struct unnamed2\n+        {\n+            int nVersion;\n+            uint256 hashPrevBlock;\n+            uint256 hashMerkleRoot;\n+            unsigned int nTime;\n+            unsigned int nBits;\n+            unsigned int nNonce;\n+        }\n+        block;\n+        unsigned char pchPadding0[64];\n+        uint256 hash1;\n+        unsigned char pchPadding1[64];\n+    }\n+    tmp;\n+    memset(&tmp, 0, sizeof(tmp));\n+\n+    tmp.block.nVersion       = pblock->nVersion;\n+    tmp.block.hashPrevBlock  = pblock->hashPrevBlock;\n+    tmp.block.hashMerkleRoot = pblock->hashMerkleRoot;\n+    tmp.block.nTime          = pblock->nTime;\n+    tmp.block.nBits          = pblock->nBits;\n+    tmp.block.nNonce         = pblock->nNonce;\n+\n+    FormatHashBlocks(&tmp.block, sizeof(tmp.block));\n+    FormatHashBlocks(&tmp.hash1, sizeof(tmp.hash1));\n+\n+    // Byte swap all the input buffer\n+    for (unsigned int i = 0; i < sizeof(tmp)/4; i++)\n+        ((unsigned int*)&tmp)[i] = ByteReverse(((unsigned int*)&tmp)[i]);\n+\n+    // Precalc the first half of the first hash, which stays constant\n+    SHA256Transform(pmidstate, &tmp.block, pSHA256InitState);\n+\n+    memcpy(pdata, &tmp.block, 128);\n+    memcpy(phash1, &tmp.hash1, 64);\n+}\n+\n+\n+bool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey)\n+{\n+    uint256 hash = pblock->GetHash();\n+    uint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n+\n+    if (hash > hashTarget)\n+        return false;\n+\n+    //// debug print\n+    printf(\"BitcoinMiner:\\n\");\n+    printf(\"proof-of-work found  \\n  hash: %s  \\ntarget: %s\\n\", hash.GetHex().c_str(), hashTarget.GetHex().c_str());\n+    pblock->print();\n+    printf(\"generated %s\\n\", FormatMoney(pblock->vtx[0].vout[0].nValue).c_str());\n+\n+    // Found a solution\n+    {\n+        LOCK(cs_main);\n+        if (pblock->hashPrevBlock != hashBestChain)\n+            return error(\"BitcoinMiner : generated block is stale\");\n+\n+        // Remove key from key pool\n+        reservekey.KeepKey();\n+\n+        // Track how many getdata requests this block gets\n+        {\n+            LOCK(wallet.cs_wallet);\n+            wallet.mapRequestCount[pblock->GetHash()] = 0;\n+        }\n+\n+        // Process this block the same as if we had received it from another node\n+        CValidationState state;\n+        if (!ProcessBlock(state, NULL, pblock))\n+            return error(\"BitcoinMiner : ProcessBlock, block not accepted\");\n+    }\n+\n+    return true;\n+}\n+\n+void static BitcoinMiner(CWallet *pwallet)\n+{\n+    printf(\"BitcoinMiner started\\n\");\n+    SetThreadPriority(THREAD_PRIORITY_LOWEST);\n+    RenameThread(\"bitcoin-miner\");\n+\n+    // Each thread has its own key and counter\n+    CReserveKey reservekey(pwallet);\n+    unsigned int nExtraNonce = 0;\n+\n+    try { while (true) {\n+        if (Params().NetworkID() != CChainParams::REGTEST) {\n+            // Busy-wait for the network to come online so we don't waste time mining\n+            // on an obsolete chain. In regtest mode we expect to fly solo.\n+            while (vNodes.empty())\n+                MilliSleep(1000);\n+        }\n+\n+        //\n+        // Create new block\n+        //\n+        unsigned int nTransactionsUpdatedLast = nTransactionsUpdated;\n+        CBlockIndex* pindexPrev = pindexBest;\n+\n+        auto_ptr<CBlockTemplate> pblocktemplate(CreateNewBlock(reservekey));\n+        if (!pblocktemplate.get())\n+            return;\n+        CBlock *pblock = &pblocktemplate->block;\n+        IncrementExtraNonce(pblock, pindexPrev, nExtraNonce);\n+\n+        printf(\"Running BitcoinMiner with %\"PRIszu\" transactions in block (%u bytes)\\n\", pblock->vtx.size(),\n+               ::GetSerializeSize(*pblock, SER_NETWORK, PROTOCOL_VERSION));\n+\n+        //\n+        // Pre-build hash buffers\n+        //\n+        char pmidstatebuf[32+16]; char* pmidstate = alignup<16>(pmidstatebuf);\n+        char pdatabuf[128+16];    char* pdata     = alignup<16>(pdatabuf);\n+        char phash1buf[64+16];    char* phash1    = alignup<16>(phash1buf);\n+\n+        FormatHashBuffers(pblock, pmidstate, pdata, phash1);\n+\n+        unsigned int& nBlockTime = *(unsigned int*)(pdata + 64 + 4);\n+        unsigned int& nBlockBits = *(unsigned int*)(pdata + 64 + 8);\n+        unsigned int& nBlockNonce = *(unsigned int*)(pdata + 64 + 12);\n+\n+\n+        //\n+        // Search\n+        //\n+        int64 nStart = GetTime();\n+        uint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n+        uint256 hashbuf[2];\n+        uint256& hash = *alignup<16>(hashbuf);\n+        while (true)\n+        {\n+            unsigned int nHashesDone = 0;\n+            unsigned int nNonceFound;\n+\n+            // Crypto++ SHA256\n+            nNonceFound = ScanHash_CryptoPP(pmidstate, pdata + 64, phash1,\n+                                            (char*)&hash, nHashesDone);\n+\n+            // Check if something found\n+            if (nNonceFound != (unsigned int) -1)\n+            {\n+                for (unsigned int i = 0; i < sizeof(hash)/4; i++)\n+                    ((unsigned int*)&hash)[i] = ByteReverse(((unsigned int*)&hash)[i]);\n+\n+                if (hash <= hashTarget)\n+                {\n+                    // Found a solution\n+                    pblock->nNonce = ByteReverse(nNonceFound);\n+                    assert(hash == pblock->GetHash());\n+\n+                    SetThreadPriority(THREAD_PRIORITY_NORMAL);\n+                    CheckWork(pblock, *pwallet, reservekey);\n+                    SetThreadPriority(THREAD_PRIORITY_LOWEST);\n+\n+                    // In regression test mode, stop mining after a block is found. This\n+                    // allows developers to controllably generate a block on demand.\n+                    if (Params().NetworkID() == CChainParams::REGTEST)\n+                        throw boost::thread_interrupted();\n+\n+                    break;\n+                }\n+            }\n+\n+            // Meter hashes/sec\n+            static int64 nHashCounter;\n+            if (nHPSTimerStart == 0)\n+            {\n+                nHPSTimerStart = GetTimeMillis();\n+                nHashCounter = 0;\n+            }\n+            else\n+                nHashCounter += nHashesDone;\n+            if (GetTimeMillis() - nHPSTimerStart > 4000)\n+            {\n+                static CCriticalSection cs;\n+                {\n+                    LOCK(cs);\n+                    if (GetTimeMillis() - nHPSTimerStart > 4000)\n+                    {\n+                        dHashesPerSec = 1000.0 * nHashCounter / (GetTimeMillis() - nHPSTimerStart);\n+                        nHPSTimerStart = GetTimeMillis();\n+                        nHashCounter = 0;\n+                        static int64 nLogTime;\n+                        if (GetTime() - nLogTime > 30 * 60)\n+                        {\n+                            nLogTime = GetTime();\n+                            printf(\"hashmeter %6.0f khash/s\\n\", dHashesPerSec/1000.0);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Check for stop or if block needs to be rebuilt\n+            boost::this_thread::interruption_point();\n+            if (vNodes.empty() && Params().NetworkID() != CChainParams::REGTEST)\n+                break;\n+            if (nBlockNonce >= 0xffff0000)\n+                break;\n+            if (nTransactionsUpdated != nTransactionsUpdatedLast && GetTime() - nStart > 60)\n+                break;\n+            if (pindexPrev != pindexBest)\n+                break;\n+\n+            // Update nTime every few seconds\n+            UpdateTime(*pblock, pindexPrev);\n+            nBlockTime = ByteReverse(pblock->nTime);\n+            if (TestNet())\n+            {\n+                // Changing pblock->nTime can change work required on testnet:\n+                nBlockBits = ByteReverse(pblock->nBits);\n+                hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n+            }\n+        }\n+    } }\n+    catch (boost::thread_interrupted)\n+    {\n+        printf(\"BitcoinMiner terminated\\n\");\n+        throw;\n+    }\n+}\n+\n+void GenerateBitcoins(bool fGenerate, CWallet* pwallet)\n+{\n+    static boost::thread_group* minerThreads = NULL;\n+\n+    int nThreads = GetArg(\"-genproclimit\", -1);\n+    if (nThreads < 0) {\n+        if (Params().NetworkID() == CChainParams::REGTEST)\n+            nThreads = 1;\n+        else\n+            nThreads = boost::thread::hardware_concurrency();\n+    }\n+\n+    if (minerThreads != NULL)\n+    {\n+        minerThreads->interrupt_all();\n+        delete minerThreads;\n+        minerThreads = NULL;\n+    }\n+\n+    if (nThreads == 0 || !fGenerate)\n+        return;\n+\n+    minerThreads = new boost::thread_group();\n+    for (int i = 0; i < nThreads; i++)\n+        minerThreads->create_thread(boost::bind(&BitcoinMiner, pwallet));\n+}\n+\n+\n+"
      },
      {
        "sha": "51d6a2e3eaded4b07cde6587b68cb49c512475d8",
        "filename": "src/miner.h",
        "status": "added",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d247a5d130544622519ad84dc8a1e50336397c51/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d247a5d130544622519ad84dc8a1e50336397c51/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=d247a5d130544622519ad84dc8a1e50336397c51",
        "patch": "@@ -0,0 +1,24 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2012 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef BITCOIN_MINER_H\n+#define BITCOIN_MINER_H\n+\n+#include \"core.h\"\n+#include \"wallet.h\"\n+\n+/** Run the miner threads */\n+void GenerateBitcoins(bool fGenerate, CWallet* pwallet);\n+/** Generate a new block, without valid proof-of-work */\n+CBlockTemplate* CreateNewBlock(CReserveKey& reservekey);\n+/** Modify the extranonce in a block */\n+void IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int& nExtraNonce);\n+/** Do mining precalculation */\n+void FormatHashBuffers(CBlock* pblock, char* pmidstate, char* pdata, char* phash1);\n+/** Check mined block */\n+bool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey);\n+/** Base sha256 mining transform */\n+void SHA256Transform(void* pstate, void* pinput, const void* pinit);\n+\n+#endif // BITCOIN_MINER_H"
      },
      {
        "sha": "25111d3787239682b2b5fa179e8e0f688805ef72",
        "filename": "src/rpcmining.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d247a5d130544622519ad84dc8a1e50336397c51/src/rpcmining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d247a5d130544622519ad84dc8a1e50336397c51/src/rpcmining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcmining.cpp?ref=d247a5d130544622519ad84dc8a1e50336397c51",
        "patch": "@@ -6,6 +6,7 @@\n #include \"chainparams.h\"\n #include \"db.h\"\n #include \"init.h\"\n+#include \"miner.h\"\n #include \"bitcoinrpc.h\"\n \n using namespace json_spirit;"
      },
      {
        "sha": "bd1d998c4f2db2ff22dd409660a5645c0c8b9a1e",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d247a5d130544622519ad84dc8a1e50336397c51/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d247a5d130544622519ad84dc8a1e50336397c51/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=d247a5d130544622519ad84dc8a1e50336397c51",
        "patch": "@@ -4,6 +4,7 @@\n #include \"main.h\"\n #include \"uint256.h\"\n #include \"util.h\"\n+#include \"miner.h\"\n #include \"wallet.h\"\n \n extern void SHA256Transform(void* pstate, void* pinput, const void* pinit);"
      }
    ]
  },
  {
    "sha": "2febacc277911d7f51a465e5bacb7f29482539a1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyZmViYWNjMjc3OTExZDdmNTFhNDY1ZTViYWNiN2YyOTQ4MjUzOWEx",
    "commit": {
      "author": {
        "name": "Jeff Garzik",
        "email": "jgarzik@bitpay.com",
        "date": "2013-07-31T14:46:58Z"
      },
      "committer": {
        "name": "Jeff Garzik",
        "email": "jgarzik@bitpay.com",
        "date": "2013-07-31T14:46:58Z"
      },
      "message": "Move wallet/dispatch functions from main.cpp to wallet.cpp.\n\nAll wallet-related implementation code is now gone from main.cpp.\nA few calls to wallet dispatch functions remain in main.cpp.\n\nAll mentions of wallet are gone from main.h.",
      "tree": {
        "sha": "215d0acc4a57588521852a4178d27d531aa7027b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/215d0acc4a57588521852a4178d27d531aa7027b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2febacc277911d7f51a465e5bacb7f29482539a1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2febacc277911d7f51a465e5bacb7f29482539a1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2febacc277911d7f51a465e5bacb7f29482539a1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2febacc277911d7f51a465e5bacb7f29482539a1/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "d247a5d130544622519ad84dc8a1e50336397c51",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d247a5d130544622519ad84dc8a1e50336397c51",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d247a5d130544622519ad84dc8a1e50336397c51"
      }
    ],
    "stats": {
      "total": 230,
      "additions": 114,
      "deletions": 116
    },
    "files": [
      {
        "sha": "9404ed8aed2ae380812448a3b46fc3d375b527c8",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 100,
        "changes": 100,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2febacc277911d7f51a465e5bacb7f29482539a1/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2febacc277911d7f51a465e5bacb7f29482539a1/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=2febacc277911d7f51a465e5bacb7f29482539a1",
        "patch": "@@ -23,9 +23,6 @@ using namespace boost;\n // Global state\n //\n \n-CCriticalSection cs_setpwalletRegistered;\n-set<CWallet*> setpwalletRegistered;\n-\n CCriticalSection cs_main;\n \n CTxMemPool mempool;\n@@ -74,103 +71,6 @@ int64 nHPSTimerStart = 0;\n int64 nTransactionFee = 0;\n \n \n-\n-//////////////////////////////////////////////////////////////////////////////\n-//\n-// dispatching functions\n-//\n-\n-// These functions dispatch to one or all registered wallets\n-\n-\n-void RegisterWallet(CWallet* pwalletIn)\n-{\n-    {\n-        LOCK(cs_setpwalletRegistered);\n-        setpwalletRegistered.insert(pwalletIn);\n-    }\n-}\n-\n-void UnregisterWallet(CWallet* pwalletIn)\n-{\n-    {\n-        LOCK(cs_setpwalletRegistered);\n-        setpwalletRegistered.erase(pwalletIn);\n-    }\n-}\n-\n-void UnregisterAllWallets()\n-{\n-    LOCK(cs_setpwalletRegistered);\n-    setpwalletRegistered.clear();\n-}\n-\n-// get the wallet transaction with the given hash (if it exists)\n-bool static GetTransaction(const uint256& hashTx, CWalletTx& wtx)\n-{\n-    LOCK(cs_setpwalletRegistered);\n-    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n-        if (pwallet->GetTransaction(hashTx,wtx))\n-            return true;\n-    return false;\n-}\n-\n-// erases transaction with the given hash from all wallets\n-void static EraseFromWallets(uint256 hash)\n-{\n-    LOCK(cs_setpwalletRegistered);\n-    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n-        pwallet->EraseFromWallet(hash);\n-}\n-\n-// make sure all wallets know about the given transaction, in the given block\n-void SyncWithWallets(const uint256 &hash, const CTransaction& tx, const CBlock* pblock, bool fUpdate)\n-{\n-    LOCK(cs_setpwalletRegistered);\n-    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n-        pwallet->AddToWalletIfInvolvingMe(hash, tx, pblock, fUpdate);\n-}\n-\n-// notify wallets about a new best chain\n-void static SetBestChain(const CBlockLocator& loc)\n-{\n-    LOCK(cs_setpwalletRegistered);\n-    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n-        pwallet->SetBestChain(loc);\n-}\n-\n-// notify wallets about an updated transaction\n-void static UpdatedTransaction(const uint256& hashTx)\n-{\n-    LOCK(cs_setpwalletRegistered);\n-    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n-        pwallet->UpdatedTransaction(hashTx);\n-}\n-\n-// dump all wallets\n-void static PrintWallets(const CBlock& block)\n-{\n-    LOCK(cs_setpwalletRegistered);\n-    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n-        pwallet->PrintWallet(block);\n-}\n-\n-// notify wallets about an incoming inventory (for request counts)\n-void static Inventory(const uint256& hash)\n-{\n-    LOCK(cs_setpwalletRegistered);\n-    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n-        pwallet->Inventory(hash);\n-}\n-\n-// ask wallets to resend their transactions\n-void static ResendWalletTransactions()\n-{\n-    LOCK(cs_setpwalletRegistered);\n-    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n-        pwallet->ResendWalletTransactions();\n-}\n-\n //////////////////////////////////////////////////////////////////////////////\n //\n // Registration of network node signals."
      },
      {
        "sha": "8292aa54bb472ffb553b8ae4e8d84c08dc39bcfb",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 0,
        "deletions": 16,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2febacc277911d7f51a465e5bacb7f29482539a1/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2febacc277911d7f51a465e5bacb7f29482539a1/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=2febacc277911d7f51a465e5bacb7f29482539a1",
        "patch": "@@ -13,11 +13,9 @@\n \n #include <list>\n \n-class CWallet;\n class CBlock;\n class CBlockIndex;\n class CKeyItem;\n-class CReserveKey;\n \n class CAddress;\n class CInv;\n@@ -85,8 +83,6 @@ extern const std::string strMessageMagic;\n extern double dHashesPerSec;\n extern int64 nHPSTimerStart;\n extern int64 nTimeBestReceived;\n-extern CCriticalSection cs_setpwalletRegistered;\n-extern std::set<CWallet*> setpwalletRegistered;\n extern bool fImporting;\n extern bool fReindex;\n extern bool fBenchmark;\n@@ -102,7 +98,6 @@ extern int64 nTransactionFee;\n static const uint64 nMinDiskSpace = 52428800;\n \n \n-class CReserveKey;\n class CCoinsDB;\n class CBlockTreeDB;\n struct CDiskBlockPos;\n@@ -115,15 +110,6 @@ class CValidationState;\n \n struct CBlockTemplate;\n \n-/** Register a wallet to receive updates from core */\n-void RegisterWallet(CWallet* pwalletIn);\n-/** Unregister a wallet from core */\n-void UnregisterWallet(CWallet* pwalletIn);\n-/** Unregister all wallets from core */\n-void UnregisterAllWallets();\n-/** Push an updated transaction to all registered wallets */\n-void SyncWithWallets(const uint256 &hash, const CTransaction& tx, const CBlock* pblock = NULL, bool fUpdate = false);\n-\n /** Register with a network node to receive its signals */\n void RegisterNodeSignals(CNodeSignals& nodeSignals);\n /** Unregister a network node */\n@@ -197,8 +183,6 @@ bool AbortNode(const std::string &msg);\n \n \n \n-bool GetWalletFile(CWallet* pwallet, std::string &strWalletFileOut);\n-\n struct CDiskBlockPos\n {\n     int nFile;"
      },
      {
        "sha": "897e2de7838a3459b074176618cd4264c86157c8",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 102,
        "deletions": 0,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2febacc277911d7f51a465e5bacb7f29482539a1/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2febacc277911d7f51a465e5bacb7f29482539a1/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=2febacc277911d7f51a465e5bacb7f29482539a1",
        "patch": "@@ -12,6 +12,9 @@\n \n using namespace std;\n \n+static CCriticalSection cs_setpwalletRegistered;\n+static set<CWallet*> setpwalletRegistered;\n+\n \n //////////////////////////////////////////////////////////////////////////////\n //\n@@ -1956,3 +1959,102 @@ void CWallet::GetKeyBirthTimes(std::map<CKeyID, int64> &mapKeyBirth) const {\n     for (std::map<CKeyID, CBlockIndex*>::const_iterator it = mapKeyFirstBlock.begin(); it != mapKeyFirstBlock.end(); it++)\n         mapKeyBirth[it->first] = it->second->nTime - 7200; // block times can be 2h off\n }\n+\n+\n+\n+//////////////////////////////////////////////////////////////////////////////\n+//\n+// dispatching functions\n+//\n+\n+// These functions dispatch to one or all registered wallets\n+\n+\n+void RegisterWallet(CWallet* pwalletIn)\n+{\n+    {\n+        LOCK(cs_setpwalletRegistered);\n+        setpwalletRegistered.insert(pwalletIn);\n+    }\n+}\n+\n+void UnregisterWallet(CWallet* pwalletIn)\n+{\n+    {\n+        LOCK(cs_setpwalletRegistered);\n+        setpwalletRegistered.erase(pwalletIn);\n+    }\n+}\n+\n+void UnregisterAllWallets()\n+{\n+    LOCK(cs_setpwalletRegistered);\n+    setpwalletRegistered.clear();\n+}\n+\n+// get the wallet transaction with the given hash (if it exists)\n+bool GetTransaction(const uint256& hashTx, CWalletTx& wtx)\n+{\n+    LOCK(cs_setpwalletRegistered);\n+    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n+        if (pwallet->GetTransaction(hashTx,wtx))\n+            return true;\n+    return false;\n+}\n+\n+// erases transaction with the given hash from all wallets\n+void EraseFromWallets(uint256 hash)\n+{\n+    LOCK(cs_setpwalletRegistered);\n+    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n+        pwallet->EraseFromWallet(hash);\n+}\n+\n+// make sure all wallets know about the given transaction, in the given block\n+void SyncWithWallets(const uint256 &hash, const CTransaction& tx, const CBlock* pblock, bool fUpdate)\n+{\n+    LOCK(cs_setpwalletRegistered);\n+    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n+        pwallet->AddToWalletIfInvolvingMe(hash, tx, pblock, fUpdate);\n+}\n+\n+// notify wallets about a new best chain\n+void SetBestChain(const CBlockLocator& loc)\n+{\n+    LOCK(cs_setpwalletRegistered);\n+    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n+        pwallet->SetBestChain(loc);\n+}\n+\n+// notify wallets about an updated transaction\n+void UpdatedTransaction(const uint256& hashTx)\n+{\n+    LOCK(cs_setpwalletRegistered);\n+    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n+        pwallet->UpdatedTransaction(hashTx);\n+}\n+\n+// dump all wallets\n+void PrintWallets(const CBlock& block)\n+{\n+    LOCK(cs_setpwalletRegistered);\n+    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n+        pwallet->PrintWallet(block);\n+}\n+\n+// notify wallets about an incoming inventory (for request counts)\n+void Inventory(const uint256& hash)\n+{\n+    LOCK(cs_setpwalletRegistered);\n+    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n+        pwallet->Inventory(hash);\n+}\n+\n+// ask wallets to resend their transactions\n+void ResendWalletTransactions()\n+{\n+    LOCK(cs_setpwalletRegistered);\n+    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n+        pwallet->ResendWalletTransactions();\n+}\n+"
      },
      {
        "sha": "e89af2b051dd94ecc4771e205822b3bd2ad9ec1b",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2febacc277911d7f51a465e5bacb7f29482539a1/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2febacc277911d7f51a465e5bacb7f29482539a1/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=2febacc277911d7f51a465e5bacb7f29482539a1",
        "patch": "@@ -874,4 +874,16 @@ class CAccountingEntry\n \n bool GetWalletFile(CWallet* pwallet, std::string &strWalletFileOut);\n \n+void RegisterWallet(CWallet* pwalletIn);\n+void UnregisterWallet(CWallet* pwalletIn);\n+void UnregisterAllWallets();\n+bool GetTransaction(const uint256& hashTx, CWalletTx& wtx);\n+void EraseFromWallets(uint256 hash);\n+void SyncWithWallets(const uint256 &hash, const CTransaction& tx, const CBlock* pblock, bool fUpdate);\n+void SetBestChain(const CBlockLocator& loc);\n+void UpdatedTransaction(const uint256& hashTx);\n+void PrintWallets(const CBlock& block);\n+void Inventory(const uint256& hash);\n+void ResendWalletTransactions();\n+\n #endif"
      }
    ]
  },
  {
    "sha": "4eba75671cb952646b70320bdf8db7f468826e21",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ZWJhNzU2NzFjYjk1MjY0NmI3MDMyMGJkZjhkYjdmNDY4ODI2ZTIx",
    "commit": {
      "author": {
        "name": "Jeff Garzik",
        "email": "jgarzik@bitpay.com",
        "date": "2013-07-31T14:52:19Z"
      },
      "committer": {
        "name": "Jeff Garzik",
        "email": "jgarzik@bitpay.com",
        "date": "2013-07-31T14:52:19Z"
      },
      "message": "Remove dead code function GetWalletFile()",
      "tree": {
        "sha": "44bb26a8436d14d1e077cb6641cc508e54905be6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/44bb26a8436d14d1e077cb6641cc508e54905be6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4eba75671cb952646b70320bdf8db7f468826e21",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4eba75671cb952646b70320bdf8db7f468826e21",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4eba75671cb952646b70320bdf8db7f468826e21",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4eba75671cb952646b70320bdf8db7f468826e21/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "2febacc277911d7f51a465e5bacb7f29482539a1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2febacc277911d7f51a465e5bacb7f29482539a1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2febacc277911d7f51a465e5bacb7f29482539a1"
      }
    ],
    "stats": {
      "total": 10,
      "additions": 0,
      "deletions": 10
    },
    "files": [
      {
        "sha": "014fe4e54c262c6f75bf203173b924bd5b1667fd",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 8,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4eba75671cb952646b70320bdf8db7f468826e21/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4eba75671cb952646b70320bdf8db7f468826e21/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=4eba75671cb952646b70320bdf8db7f468826e21",
        "patch": "@@ -1518,14 +1518,6 @@ bool CWallet::SetDefaultKey(const CPubKey &vchPubKey)\n     return true;\n }\n \n-bool GetWalletFile(CWallet* pwallet, string &strWalletFileOut)\n-{\n-    if (!pwallet->fFileBacked)\n-        return false;\n-    strWalletFileOut = pwallet->strWalletFile;\n-    return true;\n-}\n-\n //\n // Mark old keypool keys as used,\n // and generate all new keys"
      },
      {
        "sha": "30259d51901060bee4a078168681114fc89cc270",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4eba75671cb952646b70320bdf8db7f468826e21/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4eba75671cb952646b70320bdf8db7f468826e21/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=4eba75671cb952646b70320bdf8db7f468826e21",
        "patch": "@@ -872,8 +872,6 @@ class CAccountingEntry\n     std::vector<char> _ssExtra;\n };\n \n-bool GetWalletFile(CWallet* pwallet, std::string &strWalletFileOut);\n-\n void RegisterWallet(CWallet* pwalletIn);\n void UnregisterWallet(CWallet* pwalletIn);\n void UnregisterAllWallets();"
      }
    ]
  }
]