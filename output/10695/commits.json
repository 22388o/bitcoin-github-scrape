[
  {
    "sha": "d4f0d87b6fe800b6500dc5baff2e8db33e151da5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNGYwZDg3YjZmZTgwMGI2NTAwZGM1YmFmZjJlOGRiMzNlMTUxZGE1",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-06-28T18:52:24Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-06-30T13:04:36Z"
      },
      "message": "[qa] Rewrite BIP65 functional tests\n\nAfter 122786d0e0170c73536360b705af711e1338adbf, BIP65 activates at\na particular height (without regard to version numbers of blocks\nbelow that height).  Rewrite the BIP65 functional tests to take\nthis into account, and add a test case that exercises\nOP_CHECKLOCKTIMEVERIFY in a block where the soft-fork is active.\n\nAlso moves the bip65 functional test out of the extended test suite.",
      "tree": {
        "sha": "fd07108816d4823e36b0c909b824be70eec664ca",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fd07108816d4823e36b0c909b824be70eec664ca"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d4f0d87b6fe800b6500dc5baff2e8db33e151da5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d4f0d87b6fe800b6500dc5baff2e8db33e151da5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d4f0d87b6fe800b6500dc5baff2e8db33e151da5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d4f0d87b6fe800b6500dc5baff2e8db33e151da5/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d4e551adfec298d12f2147467227f07e3a94b872",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d4e551adfec298d12f2147467227f07e3a94b872",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d4e551adfec298d12f2147467227f07e3a94b872"
      }
    ],
    "stats": {
      "total": 326,
      "additions": 116,
      "deletions": 210
    },
    "files": [
      {
        "sha": "7e5e4cf6820b4da034a3f1523287f08e3b14d863",
        "filename": "test/functional/bip65-cltv-p2p.py",
        "status": "modified",
        "additions": 115,
        "deletions": 126,
        "changes": 241,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d4f0d87b6fe800b6500dc5baff2e8db33e151da5/test/functional/bip65-cltv-p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d4f0d87b6fe800b6500dc5baff2e8db33e151da5/test/functional/bip65-cltv-p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bip65-cltv-p2p.py?ref=d4f0d87b6fe800b6500dc5baff2e8db33e151da5",
        "patch": "@@ -4,173 +4,162 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test BIP65 (CHECKLOCKTIMEVERIFY).\n \n-Connect to a single node.\n-Mine 2 (version 3) blocks (save the coinbases for later).\n-Generate 98 more version 3 blocks, verify the node accepts.\n-Mine 749 version 4 blocks, verify the node accepts.\n-Check that the new CLTV rules are not enforced on the 750th version 4 block.\n-Check that the new CLTV rules are enforced on the 751st version 4 block.\n-Mine 199 new version blocks.\n-Mine 1 old-version block.\n-Mine 1 new version block.\n-Mine 1 old version block, see that the node rejects.\n+Test that the CHECKLOCKTIMEVERIFY soft-fork activates at (regtest) block height\n+1351.\n \"\"\"\n \n-from test_framework.test_framework import ComparisonTestFramework\n+from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n-from test_framework.mininode import CTransaction, NetworkThread\n+from test_framework.mininode import *\n from test_framework.blocktools import create_coinbase, create_block\n-from test_framework.comptool import TestInstance, TestManager\n-from test_framework.script import CScript, OP_1NEGATE, OP_CHECKLOCKTIMEVERIFY, OP_DROP\n+from test_framework.script import CScript, OP_1NEGATE, OP_CHECKLOCKTIMEVERIFY, OP_DROP, CScriptNum\n from io import BytesIO\n-import time\n+\n+CLTV_HEIGHT = 1351\n+\n+# Reject codes that we might receive in this test\n+REJECT_INVALID = 16\n+REJECT_OBSOLETE = 17\n+REJECT_NONSTANDARD = 64\n \n def cltv_invalidate(tx):\n     '''Modify the signature in vin 0 of the tx to fail CLTV\n \n     Prepends -1 CLTV DROP in the scriptSig itself.\n+\n+    TODO: test more ways that transactions using CLTV could be invalid (eg\n+    locktime requirements fail, sequence time requirements fail, etc).\n     '''\n     tx.vin[0].scriptSig = CScript([OP_1NEGATE, OP_CHECKLOCKTIMEVERIFY, OP_DROP] +\n                                   list(CScript(tx.vin[0].scriptSig)))\n \n-\n-class BIP65Test(ComparisonTestFramework):\n+def cltv_validate(node, tx, height):\n+    '''Modify the signature in vin 0 of the tx to pass CLTV\n+    Prepends <height> CLTV DROP in the scriptSig, and sets\n+    the locktime to height'''\n+    tx.vin[0].nSequence = 0\n+    tx.nLockTime = height\n+\n+    # Need to re-sign, since nSequence and nLockTime changed\n+    signed_result = node.signrawtransaction(ToHex(tx))\n+    new_tx = CTransaction()\n+    new_tx.deserialize(BytesIO(hex_str_to_bytes(signed_result['hex'])))\n+\n+    new_tx.vin[0].scriptSig = CScript([CScriptNum(height), OP_CHECKLOCKTIMEVERIFY, OP_DROP] +\n+                                  list(CScript(new_tx.vin[0].scriptSig)))\n+    return new_tx\n+\n+def create_transaction(node, coinbase, to_address, amount):\n+    from_txid = node.getblock(coinbase)['tx'][0]\n+    inputs = [{ \"txid\" : from_txid, \"vout\" : 0}]\n+    outputs = { to_address : amount }\n+    rawtx = node.createrawtransaction(inputs, outputs)\n+    signresult = node.signrawtransaction(rawtx)\n+    tx = CTransaction()\n+    tx.deserialize(BytesIO(hex_str_to_bytes(signresult['hex'])))\n+    return tx\n+\n+class BIP65Test(BitcoinTestFramework):\n \n     def __init__(self):\n         super().__init__()\n         self.num_nodes = 1\n-        self.extra_args = [['-whitelist=127.0.0.1', '-blockversion=3']]\n+        self.extra_args = [['-promiscuousmempoolflags=1', '-whitelist=127.0.0.1']]\n+        self.setup_clean_chain = True\n \n     def run_test(self):\n-        test = TestManager(self, self.options.tmpdir)\n-        test.add_all_connections(self.nodes)\n+        node0 = NodeConnCB()\n+        connections = []\n+        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], node0))\n+        node0.add_connection(connections[0])\n+\n         NetworkThread().start() # Start up network handling in another thread\n-        test.run()\n-\n-    def create_transaction(self, node, coinbase, to_address, amount):\n-        from_txid = node.getblock(coinbase)['tx'][0]\n-        inputs = [{ \"txid\" : from_txid, \"vout\" : 0}]\n-        outputs = { to_address : amount }\n-        rawtx = node.createrawtransaction(inputs, outputs)\n-        signresult = node.signrawtransaction(rawtx)\n-        tx = CTransaction()\n-        f = BytesIO(hex_str_to_bytes(signresult['hex']))\n-        tx.deserialize(f)\n-        return tx\n-\n-    def get_tests(self):\n-\n-        self.coinbase_blocks = self.nodes[0].generate(2)\n-        height = 3  # height of the next block to build\n-        self.tip = int(\"0x\" + self.nodes[0].getbestblockhash(), 0)\n+\n+        # wait_for_verack ensures that the P2P connection is fully up.\n+        node0.wait_for_verack()\n+\n+        self.log.info(\"Mining %d blocks\", CLTV_HEIGHT - 2)\n+        self.coinbase_blocks = self.nodes[0].generate(CLTV_HEIGHT - 2)\n         self.nodeaddress = self.nodes[0].getnewaddress()\n-        self.last_block_time = int(time.time())\n-\n-        ''' 398 more version 3 blocks '''\n-        test_blocks = []\n-        for i in range(398):\n-            block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n-            block.nVersion = 3\n-            block.rehash()\n-            block.solve()\n-            test_blocks.append([block, True])\n-            self.last_block_time += 1\n-            self.tip = block.sha256\n-            height += 1\n-        yield TestInstance(test_blocks, sync_every_block=False)\n-\n-        ''' Mine 749 version 4 blocks '''\n-        test_blocks = []\n-        for i in range(749):\n-            block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n-            block.nVersion = 4\n-            block.rehash()\n-            block.solve()\n-            test_blocks.append([block, True])\n-            self.last_block_time += 1\n-            self.tip = block.sha256\n-            height += 1\n-        yield TestInstance(test_blocks, sync_every_block=False)\n-\n-        '''\n-        Check that the new CLTV rules are not enforced in the 750th\n-        version 3 block.\n-        '''\n-        spendtx = self.create_transaction(self.nodes[0],\n-                self.coinbase_blocks[0], self.nodeaddress, 1.0)\n+\n+        self.log.info(\"Test that an invalid-according-to-CLTV transaction can still appear in a block\")\n+\n+        spendtx = create_transaction(self.nodes[0], self.coinbase_blocks[0],\n+                self.nodeaddress, 1.0)\n         cltv_invalidate(spendtx)\n         spendtx.rehash()\n \n-        block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n-        block.nVersion = 4\n+        tip = self.nodes[0].getbestblockhash()\n+        block_time = self.nodes[0].getblockheader(tip)['mediantime'] + 1\n+        block = create_block(int(tip, 16), create_coinbase(CLTV_HEIGHT - 1), block_time)\n+        block.nVersion = 3\n         block.vtx.append(spendtx)\n         block.hashMerkleRoot = block.calc_merkle_root()\n-        block.rehash()\n         block.solve()\n \n-        self.last_block_time += 1\n-        self.tip = block.sha256\n-        height += 1\n-        yield TestInstance([[block, True]])\n-\n-        ''' Mine 199 new version blocks on last valid tip '''\n-        test_blocks = []\n-        for i in range(199):\n-            block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n-            block.nVersion = 4\n-            block.rehash()\n-            block.solve()\n-            test_blocks.append([block, True])\n-            self.last_block_time += 1\n-            self.tip = block.sha256\n-            height += 1\n-        yield TestInstance(test_blocks, sync_every_block=False)\n-\n-        ''' Mine 1 old version block '''\n-        block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n+        node0.send_and_ping(msg_block(block))\n+        assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n+\n+        self.log.info(\"Test that blocks must now be at least version 4\")\n+        tip = block.sha256\n+        block_time += 1\n+        block = create_block(tip, create_coinbase(CLTV_HEIGHT), block_time)\n         block.nVersion = 3\n-        block.rehash()\n         block.solve()\n-        self.last_block_time += 1\n-        self.tip = block.sha256\n-        height += 1\n-        yield TestInstance([[block, True]])\n+        node0.send_and_ping(msg_block(block))\n+        assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n \n-        ''' Mine 1 new version block '''\n-        block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n+        assert wait_until(lambda: \"reject\" in node0.last_message.keys())\n+        with mininode_lock:\n+            assert_equal(node0.last_message[\"reject\"].code, REJECT_OBSOLETE)\n+            assert_equal(node0.last_message[\"reject\"].reason, b'bad-version(0x00000003)')\n+            assert_equal(node0.last_message[\"reject\"].data, block.sha256)\n+            del node0.last_message[\"reject\"]\n+\n+        self.log.info(\"Test that invalid-according-to-cltv transactions cannot appear in a block\")\n         block.nVersion = 4\n-        block.rehash()\n-        block.solve()\n-        self.last_block_time += 1\n-        self.tip = block.sha256\n-        height += 1\n-        yield TestInstance([[block, True]])\n-\n-        '''\n-        Check that the new CLTV rules are enforced in the 951st version 4\n-        block.\n-        '''\n-        spendtx = self.create_transaction(self.nodes[0],\n-                self.coinbase_blocks[1], self.nodeaddress, 1.0)\n+\n+        spendtx = create_transaction(self.nodes[0], self.coinbase_blocks[1],\n+                self.nodeaddress, 1.0)\n         cltv_invalidate(spendtx)\n         spendtx.rehash()\n \n-        block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n-        block.nVersion = 4\n+        # First we show that this tx is valid except for CLTV by getting it\n+        # accepted to the mempool (which we can achieve with\n+        # -promiscuousmempoolflags).\n+        node0.send_and_ping(msg_tx(spendtx))\n+        assert spendtx.hash in self.nodes[0].getrawmempool()\n+\n+        # Now we verify that a block with this transaction is invalid.\n         block.vtx.append(spendtx)\n         block.hashMerkleRoot = block.calc_merkle_root()\n-        block.rehash()\n         block.solve()\n-        self.last_block_time += 1\n-        yield TestInstance([[block, False]])\n \n-        ''' Mine 1 old version block, should be invalid '''\n-        block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n-        block.nVersion = 3\n-        block.rehash()\n+        node0.send_and_ping(msg_block(block))\n+        assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n+\n+        assert wait_until (lambda: \"reject\" in node0.last_message.keys())\n+        with mininode_lock:\n+            assert node0.last_message[\"reject\"].code in [REJECT_INVALID, REJECT_NONSTANDARD]\n+            assert_equal(node0.last_message[\"reject\"].data, block.sha256)\n+            if node0.last_message[\"reject\"].code == REJECT_INVALID:\n+                # Generic rejection when a block is invalid\n+                assert_equal(node0.last_message[\"reject\"].reason, b'block-validation-failed')\n+            else:\n+                assert b'Negative locktime' in node0.last_message[\"reject\"].reason\n+\n+        self.log.info(\"Test that a version 4 block with a valid-according-to-CLTV transaction is accepted\")\n+        spendtx = cltv_validate(self.nodes[0], spendtx, CLTV_HEIGHT - 1)\n+        spendtx.rehash()\n+\n+        block.vtx.pop(1)\n+        block.vtx.append(spendtx)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n         block.solve()\n-        self.last_block_time += 1\n-        yield TestInstance([[block, False]])\n+\n+        node0.send_and_ping(msg_block(block))\n+        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+\n \n if __name__ == '__main__':\n     BIP65Test().main()"
      },
      {
        "sha": "ddf932c74606b4cb1c1f2942d1b41863cd416b58",
        "filename": "test/functional/bip65-cltv.py",
        "status": "removed",
        "additions": 0,
        "deletions": 82,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d4e551adfec298d12f2147467227f07e3a94b872/test/functional/bip65-cltv.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d4e551adfec298d12f2147467227f07e3a94b872/test/functional/bip65-cltv.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bip65-cltv.py?ref=d4e551adfec298d12f2147467227f07e3a94b872",
        "patch": "@@ -1,82 +0,0 @@\n-#!/usr/bin/env python3\n-# Copyright (c) 2015-2016 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Test the CHECKLOCKTIMEVERIFY (BIP65) soft-fork logic.\"\"\"\n-\n-from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import *\n-\n-class BIP65Test(BitcoinTestFramework):\n-    def __init__(self):\n-        super().__init__()\n-        self.num_nodes = 3\n-        self.setup_clean_chain = False\n-        self.extra_args = [[], [\"-blockversion=3\"], [\"-blockversion=4\"]]\n-\n-    def setup_network(self):\n-        self.setup_nodes()\n-        connect_nodes(self.nodes[1], 0)\n-        connect_nodes(self.nodes[2], 0)\n-        self.sync_all()\n-\n-    def run_test(self):\n-        cnt = self.nodes[0].getblockcount()\n-\n-        # Mine some old-version blocks\n-        self.nodes[1].generate(200)\n-        cnt += 100\n-        self.sync_all()\n-        if (self.nodes[0].getblockcount() != cnt + 100):\n-            raise AssertionError(\"Failed to mine 100 version=3 blocks\")\n-\n-        # Mine 750 new-version blocks\n-        for i in range(15):\n-            self.nodes[2].generate(50)\n-        self.sync_all()\n-        if (self.nodes[0].getblockcount() != cnt + 850):\n-            raise AssertionError(\"Failed to mine 750 version=4 blocks\")\n-\n-        # TODO: check that new CHECKLOCKTIMEVERIFY rules are not enforced\n-\n-        # Mine 1 new-version block\n-        self.nodes[2].generate(1)\n-        self.sync_all()\n-        if (self.nodes[0].getblockcount() != cnt + 851):\n-            raise AssertionError(\"Failed to mine a version=4 blocks\")\n-\n-        # TODO: check that new CHECKLOCKTIMEVERIFY rules are enforced\n-\n-        # Mine 198 new-version blocks\n-        for i in range(2):\n-            self.nodes[2].generate(99)\n-        self.sync_all()\n-        if (self.nodes[0].getblockcount() != cnt + 1049):\n-            raise AssertionError(\"Failed to mine 198 version=4 blocks\")\n-\n-        # Mine 1 old-version block\n-        self.nodes[1].generate(1)\n-        self.sync_all()\n-        if (self.nodes[0].getblockcount() != cnt + 1050):\n-            raise AssertionError(\"Failed to mine a version=3 block after 949 version=4 blocks\")\n-\n-        # Mine 1 new-version blocks\n-        self.nodes[2].generate(1)\n-        self.sync_all()\n-        if (self.nodes[0].getblockcount() != cnt + 1051):\n-            raise AssertionError(\"Failed to mine a version=4 block\")\n-\n-        # Mine 1 old-version blocks. This should fail\n-        assert_raises_jsonrpc(-1,\"CreateNewBlock: TestBlockValidity failed: bad-version(0x00000003)\", self.nodes[1].generate, 1)\n-        self.sync_all()\n-        if (self.nodes[0].getblockcount() != cnt + 1051):\n-            raise AssertionError(\"Accepted a version=3 block after 950 version=4 blocks\")\n-\n-        # Mine 1 new-version blocks\n-        self.nodes[2].generate(1)\n-        self.sync_all()\n-        if (self.nodes[0].getblockcount() != cnt + 1052):\n-            raise AssertionError(\"Failed to mine a version=4 block\")\n-\n-if __name__ == '__main__':\n-    BIP65Test().main()"
      },
      {
        "sha": "c8c794c77220cdc7668855c99c1330334cfdc80b",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d4f0d87b6fe800b6500dc5baff2e8db33e151da5/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d4f0d87b6fe800b6500dc5baff2e8db33e151da5/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=d4f0d87b6fe800b6500dc5baff2e8db33e151da5",
        "patch": "@@ -113,6 +113,7 @@\n     'listsinceblock.py',\n     'p2p-leaktests.py',\n     'wallet-encryption.py',\n+    'bip65-cltv-p2p.py',\n     'uptime.py',\n ]\n \n@@ -136,8 +137,6 @@\n     'rpcbind_test.py',\n     # vv Tests less than 30s vv\n     'assumevalid.py',\n-    'bip65-cltv.py',\n-    'bip65-cltv-p2p.py',\n     'bipdersig-p2p.py',\n     'bipdersig.py',\n     'example_test.py',"
      }
    ]
  },
  {
    "sha": "4ccc12a54a217892bd4ccfd94c46052a11cdb3fb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0Y2NjMTJhNTRhMjE3ODkyYmQ0Y2NmZDk0YzQ2MDUyYTExY2RiM2Zi",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-06-28T20:56:37Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-07-06T14:09:54Z"
      },
      "message": "[qa] Rewrite BIP66 functional tests\n\nRewrite the BIP66 functional tests to reflect height-based activation,\nand move it out of the extended test suite.\n\nRemove the unnecessary bipdersig.py test",
      "tree": {
        "sha": "129b24a25fa82ff33a5903f5a8f6c41783da7a11",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/129b24a25fa82ff33a5903f5a8f6c41783da7a11"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4ccc12a54a217892bd4ccfd94c46052a11cdb3fb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ccc12a54a217892bd4ccfd94c46052a11cdb3fb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4ccc12a54a217892bd4ccfd94c46052a11cdb3fb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ccc12a54a217892bd4ccfd94c46052a11cdb3fb/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d4f0d87b6fe800b6500dc5baff2e8db33e151da5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d4f0d87b6fe800b6500dc5baff2e8db33e151da5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d4f0d87b6fe800b6500dc5baff2e8db33e151da5"
      }
    ],
    "stats": {
      "total": 301,
      "additions": 97,
      "deletions": 204
    },
    "files": [
      {
        "sha": "38a90095441c5ae12a4b92aabee2297d9449073a",
        "filename": "test/functional/bipdersig-p2p.py",
        "status": "modified",
        "additions": 96,
        "deletions": 121,
        "changes": 217,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4ccc12a54a217892bd4ccfd94c46052a11cdb3fb/test/functional/bipdersig-p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4ccc12a54a217892bd4ccfd94c46052a11cdb3fb/test/functional/bipdersig-p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bipdersig-p2p.py?ref=4ccc12a54a217892bd4ccfd94c46052a11cdb3fb",
        "patch": "@@ -4,28 +4,24 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test BIP66 (DER SIG).\n \n-Connect to a single node.\n-Mine 2 (version 2) blocks (save the coinbases for later).\n-Generate 98 more version 2 blocks, verify the node accepts.\n-Mine 749 version 3 blocks, verify the node accepts.\n-Check that the new DERSIG rules are not enforced on the 750th version 3 block.\n-Check that the new DERSIG rules are enforced on the 751st version 3 block.\n-Mine 199 new version blocks.\n-Mine 1 old-version block.\n-Mine 1 new version block.\n-Mine 1 old version block, see that the node rejects.\n+Test that the DERSIG soft-fork activates at (regtest) height 1251.\n \"\"\"\n \n-from test_framework.test_framework import ComparisonTestFramework\n+from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n-from test_framework.mininode import CTransaction, NetworkThread\n+from test_framework.mininode import *\n from test_framework.blocktools import create_coinbase, create_block\n-from test_framework.comptool import TestInstance, TestManager\n from test_framework.script import CScript\n from io import BytesIO\n-import time\n \n-# A canonical signature consists of: \n+DERSIG_HEIGHT = 1251\n+\n+# Reject codes that we might receive in this test\n+REJECT_INVALID = 16\n+REJECT_OBSOLETE = 17\n+REJECT_NONSTANDARD = 64\n+\n+# A canonical signature consists of:\n # <30> <total len> <02> <len R> <R> <02> <len S> <S> <hashtype>\n def unDERify(tx):\n     \"\"\"\n@@ -40,143 +36,122 @@ def unDERify(tx):\n         else:\n             newscript.append(i)\n     tx.vin[0].scriptSig = CScript(newscript)\n-            \n-class BIP66Test(ComparisonTestFramework):\n+\n+def create_transaction(node, coinbase, to_address, amount):\n+    from_txid = node.getblock(coinbase)['tx'][0]\n+    inputs = [{ \"txid\" : from_txid, \"vout\" : 0}]\n+    outputs = { to_address : amount }\n+    rawtx = node.createrawtransaction(inputs, outputs)\n+    signresult = node.signrawtransaction(rawtx)\n+    tx = CTransaction()\n+    tx.deserialize(BytesIO(hex_str_to_bytes(signresult['hex'])))\n+    return tx\n+\n+class BIP66Test(BitcoinTestFramework):\n \n     def __init__(self):\n         super().__init__()\n         self.num_nodes = 1\n+        self.extra_args = [['-promiscuousmempoolflags=1', '-whitelist=127.0.0.1']]\n+        self.setup_clean_chain = True\n \n     def run_test(self):\n-        test = TestManager(self, self.options.tmpdir)\n-        test.add_all_connections(self.nodes)\n+        node0 = NodeConnCB()\n+        connections = []\n+        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], node0))\n+        node0.add_connection(connections[0])\n         NetworkThread().start() # Start up network handling in another thread\n-        test.run()\n-\n-    def create_transaction(self, node, coinbase, to_address, amount):\n-        from_txid = node.getblock(coinbase)['tx'][0]\n-        inputs = [{ \"txid\" : from_txid, \"vout\" : 0}]\n-        outputs = { to_address : amount }\n-        rawtx = node.createrawtransaction(inputs, outputs)\n-        signresult = node.signrawtransaction(rawtx)\n-        tx = CTransaction()\n-        f = BytesIO(hex_str_to_bytes(signresult['hex']))\n-        tx.deserialize(f)\n-        return tx\n-\n-    def get_tests(self):\n-\n-        self.coinbase_blocks = self.nodes[0].generate(2)\n-        height = 3  # height of the next block to build\n-        self.tip = int(\"0x\" + self.nodes[0].getbestblockhash(), 0)\n+\n+        # wait_for_verack ensures that the P2P connection is fully up.\n+        node0.wait_for_verack()\n+\n+        self.log.info(\"Mining %d blocks\", DERSIG_HEIGHT - 2)\n+        self.coinbase_blocks = self.nodes[0].generate(DERSIG_HEIGHT - 2)\n         self.nodeaddress = self.nodes[0].getnewaddress()\n-        self.last_block_time = int(time.time())\n-\n-        ''' 298 more version 2 blocks '''\n-        test_blocks = []\n-        for i in range(298):\n-            block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n-            block.nVersion = 2\n-            block.rehash()\n-            block.solve()\n-            test_blocks.append([block, True])\n-            self.last_block_time += 1\n-            self.tip = block.sha256\n-            height += 1\n-        yield TestInstance(test_blocks, sync_every_block=False)\n-\n-        ''' Mine 749 version 3 blocks '''\n-        test_blocks = []\n-        for i in range(749):\n-            block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n-            block.nVersion = 3\n-            block.rehash()\n-            block.solve()\n-            test_blocks.append([block, True])\n-            self.last_block_time += 1\n-            self.tip = block.sha256\n-            height += 1\n-        yield TestInstance(test_blocks, sync_every_block=False)\n-\n-        ''' \n-        Check that the new DERSIG rules are not enforced in the 750th\n-        version 3 block.\n-        '''\n-        spendtx = self.create_transaction(self.nodes[0],\n-                self.coinbase_blocks[0], self.nodeaddress, 1.0)\n+\n+        self.log.info(\"Test that a transaction with non-DER signature can still appear in a block\")\n+\n+        spendtx = create_transaction(self.nodes[0], self.coinbase_blocks[0],\n+                self.nodeaddress, 1.0)\n         unDERify(spendtx)\n         spendtx.rehash()\n \n-        block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n-        block.nVersion = 3\n+        tip = self.nodes[0].getbestblockhash()\n+        block_time = self.nodes[0].getblockheader(tip)['mediantime'] + 1\n+        block = create_block(int(tip, 16), create_coinbase(DERSIG_HEIGHT - 1), block_time)\n+        block.nVersion = 2\n         block.vtx.append(spendtx)\n         block.hashMerkleRoot = block.calc_merkle_root()\n         block.rehash()\n         block.solve()\n \n-        self.last_block_time += 1\n-        self.tip = block.sha256\n-        height += 1\n-        yield TestInstance([[block, True]])       \n-\n-        ''' Mine 199 new version blocks on last valid tip '''\n-        test_blocks = []\n-        for i in range(199):\n-            block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n-            block.nVersion = 3\n-            block.rehash()\n-            block.solve()\n-            test_blocks.append([block, True])\n-            self.last_block_time += 1\n-            self.tip = block.sha256\n-            height += 1\n-        yield TestInstance(test_blocks, sync_every_block=False)\n-\n-        ''' Mine 1 old version block '''\n-        block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n+        node0.send_and_ping(msg_block(block))\n+        assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n+\n+        self.log.info(\"Test that blocks must now be at least version 3\")\n+        tip = block.sha256\n+        block_time += 1\n+        block = create_block(tip, create_coinbase(DERSIG_HEIGHT), block_time)\n         block.nVersion = 2\n         block.rehash()\n         block.solve()\n-        self.last_block_time += 1\n-        self.tip = block.sha256\n-        height += 1\n-        yield TestInstance([[block, True]])\n+        node0.send_and_ping(msg_block(block))\n+        assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n \n-        ''' Mine 1 new version block '''\n-        block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n+        assert wait_until(lambda: \"reject\" in node0.last_message.keys())\n+        with mininode_lock:\n+            assert_equal(node0.last_message[\"reject\"].code, REJECT_OBSOLETE)\n+            assert_equal(node0.last_message[\"reject\"].reason, b'bad-version(0x00000002)')\n+            assert_equal(node0.last_message[\"reject\"].data, block.sha256)\n+            del node0.last_message[\"reject\"]\n+\n+        self.log.info(\"Test that transactions with non-DER signatures cannot appear in a block\")\n         block.nVersion = 3\n-        block.rehash()\n-        block.solve()\n-        self.last_block_time += 1\n-        self.tip = block.sha256\n-        height += 1\n-        yield TestInstance([[block, True]])\n-\n-        ''' \n-        Check that the new DERSIG rules are enforced in the 951st version 3\n-        block.\n-        '''\n-        spendtx = self.create_transaction(self.nodes[0],\n-                self.coinbase_blocks[1], self.nodeaddress, 1.0)\n+\n+        spendtx = create_transaction(self.nodes[0], self.coinbase_blocks[1],\n+                self.nodeaddress, 1.0)\n         unDERify(spendtx)\n         spendtx.rehash()\n \n-        block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n-        block.nVersion = 3\n+        # First we show that this tx is valid except for DERSIG by getting it\n+        # accepted to the mempool (which we can achieve with\n+        # -promiscuousmempoolflags).\n+        node0.send_and_ping(msg_tx(spendtx))\n+        assert spendtx.hash in self.nodes[0].getrawmempool()\n+\n+        # Now we verify that a block with this transaction is invalid.\n         block.vtx.append(spendtx)\n         block.hashMerkleRoot = block.calc_merkle_root()\n         block.rehash()\n         block.solve()\n-        self.last_block_time += 1\n-        yield TestInstance([[block, False]])\n \n-        ''' Mine 1 old version block, should be invalid '''\n-        block = create_block(self.tip, create_coinbase(height), self.last_block_time + 1)\n-        block.nVersion = 2\n+        node0.send_and_ping(msg_block(block))\n+        assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n+\n+        assert wait_until (lambda: \"reject\" in node0.last_message.keys())\n+        with mininode_lock:\n+            # We can receive different reject messages depending on whether\n+            # bitcoind is running with multiple script check threads. If script\n+            # check threads are not in use, then transaction script validation\n+            # happens sequentially, and bitcoind produces more specific reject\n+            # reasons.\n+            assert node0.last_message[\"reject\"].code in [REJECT_INVALID, REJECT_NONSTANDARD]\n+            assert_equal(node0.last_message[\"reject\"].data, block.sha256)\n+            if node0.last_message[\"reject\"].code == REJECT_INVALID:\n+                # Generic rejection when a block is invalid\n+                assert_equal(node0.last_message[\"reject\"].reason, b'block-validation-failed')\n+            else:\n+                assert b'Non-canonical DER signature' in node0.last_message[\"reject\"].reason\n+\n+        self.log.info(\"Test that a version 3 block with a DERSIG-compliant transaction is accepted\")\n+        block.vtx[1] = create_transaction(self.nodes[0],\n+                self.coinbase_blocks[1], self.nodeaddress, 1.0)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n         block.rehash()\n         block.solve()\n-        self.last_block_time += 1\n-        yield TestInstance([[block, False]])\n+\n+        node0.send_and_ping(msg_block(block))\n+        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n \n if __name__ == '__main__':\n     BIP66Test().main()"
      },
      {
        "sha": "41f88fb664b2318f447be09c4063a7e694f8c6a5",
        "filename": "test/functional/bipdersig.py",
        "status": "removed",
        "additions": 0,
        "deletions": 81,
        "changes": 81,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d4f0d87b6fe800b6500dc5baff2e8db33e151da5/test/functional/bipdersig.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d4f0d87b6fe800b6500dc5baff2e8db33e151da5/test/functional/bipdersig.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bipdersig.py?ref=d4f0d87b6fe800b6500dc5baff2e8db33e151da5",
        "patch": "@@ -1,81 +0,0 @@\n-#!/usr/bin/env python3\n-# Copyright (c) 2014-2016 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Test the BIP66 changeover logic.\"\"\"\n-\n-from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import *\n-\n-class BIP66Test(BitcoinTestFramework):\n-    def __init__(self):\n-        super().__init__()\n-        self.num_nodes = 3\n-        self.setup_clean_chain = False\n-        self.extra_args = [[], [\"-blockversion=2\"], [\"-blockversion=3\"]]\n-\n-    def setup_network(self):\n-        self.setup_nodes()\n-        connect_nodes(self.nodes[1], 0)\n-        connect_nodes(self.nodes[2], 0)\n-        self.sync_all()\n-\n-    def run_test(self):\n-        cnt = self.nodes[0].getblockcount()\n-\n-        # Mine some old-version blocks\n-        self.nodes[1].generate(100)\n-        self.sync_all()\n-        if (self.nodes[0].getblockcount() != cnt + 100):\n-            raise AssertionError(\"Failed to mine 100 version=2 blocks\")\n-\n-        # Mine 750 new-version blocks\n-        for i in range(15):\n-            self.nodes[2].generate(50)\n-        self.sync_all()\n-        if (self.nodes[0].getblockcount() != cnt + 850):\n-            raise AssertionError(\"Failed to mine 750 version=3 blocks\")\n-\n-        # TODO: check that new DERSIG rules are not enforced\n-\n-        # Mine 1 new-version block\n-        self.nodes[2].generate(1)\n-        self.sync_all()\n-        if (self.nodes[0].getblockcount() != cnt + 851):\n-            raise AssertionError(\"Failed to mine a version=3 blocks\")\n-\n-        # TODO: check that new DERSIG rules are enforced\n-\n-        # Mine 198 new-version blocks\n-        for i in range(2):\n-            self.nodes[2].generate(99)\n-        self.sync_all()\n-        if (self.nodes[0].getblockcount() != cnt + 1049):\n-            raise AssertionError(\"Failed to mine 198 version=3 blocks\")\n-\n-        # Mine 1 old-version block\n-        self.nodes[1].generate(1)\n-        self.sync_all()\n-        if (self.nodes[0].getblockcount() != cnt + 1050):\n-            raise AssertionError(\"Failed to mine a version=2 block after 949 version=3 blocks\")\n-\n-        # Mine 1 new-version blocks\n-        self.nodes[2].generate(1)\n-        self.sync_all()\n-        if (self.nodes[0].getblockcount() != cnt + 1051):\n-            raise AssertionError(\"Failed to mine a version=3 block\")\n-\n-        # Mine 1 old-version blocks. This should fail\n-        assert_raises_jsonrpc(-1, \"CreateNewBlock: TestBlockValidity failed: bad-version(0x00000002)\", self.nodes[1].generate, 1)\n-        self.sync_all()\n-        if (self.nodes[0].getblockcount() != cnt + 1051):\n-            raise AssertionError(\"Accepted a version=2 block after 950 version=3 blocks\")\n-\n-        # Mine 1 new-version blocks\n-        self.nodes[2].generate(1)\n-        self.sync_all()\n-        if (self.nodes[0].getblockcount() != cnt + 1052):\n-            raise AssertionError(\"Failed to mine a version=3 block\")\n-\n-if __name__ == '__main__':\n-    BIP66Test().main()"
      },
      {
        "sha": "31a01dee9128e89e6494dd95104abada9fb709e4",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4ccc12a54a217892bd4ccfd94c46052a11cdb3fb/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4ccc12a54a217892bd4ccfd94c46052a11cdb3fb/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=4ccc12a54a217892bd4ccfd94c46052a11cdb3fb",
        "patch": "@@ -113,6 +113,7 @@\n     'listsinceblock.py',\n     'p2p-leaktests.py',\n     'wallet-encryption.py',\n+    'bipdersig-p2p.py',\n     'bip65-cltv-p2p.py',\n     'uptime.py',\n ]\n@@ -137,8 +138,6 @@\n     'rpcbind_test.py',\n     # vv Tests less than 30s vv\n     'assumevalid.py',\n-    'bipdersig-p2p.py',\n-    'bipdersig.py',\n     'example_test.py',\n     'getblocktemplate_proposals.py',\n     'txn_doublespend.py',"
      }
    ]
  }
]