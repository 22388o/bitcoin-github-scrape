[
  {
    "sha": "facc352648e4fe1ed9b406400b6e4a9d51f30349",
    "node_id": "C_kwDOABII59oAKGZhY2MzNTI2NDhlNGZlMWVkOWI0MDY0MDBiNmU0YTlkNTFmMzAzNDk",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2020-11-10T17:02:31Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-10-29T11:34:52Z"
      },
      "message": "test: Implicitly sync after generate*, unless opted out",
      "tree": {
        "sha": "7bba05900db761f91c0b416985a3a774984bfd49",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7bba05900db761f91c0b416985a3a774984bfd49"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/facc352648e4fe1ed9b406400b6e4a9d51f30349",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUjylQwApcFXQGVhB2s13rd9x33aZB+IScXdCQLSmnig4RxwNFqGVrkeCDY8RWbo\nKL1BBTTMFDAA3WaPAebBni7utDWB/Z6lx/NXgEqeRcbLwhnMw8SUjTmhtnfO/GhR\n+JU+KxxdOFvni5oR84jkkgRTiFQ6txE5eM4S/CidsjorgoNhbDRh+YQje2FvKeCO\nqs/r5VbGVZ3HbXyA/mqgDog1zOcMGEbiq7/t5ca9mIkm4rVYaKVRXCE+CuTYdbtt\n4nVwDE2sBeYI6z/ZbLCESX6HEqt1vaTngY0/mY43OGVYico3a4EuzDDOE5Mrtem3\ndB7AJgYBG8meRcMhR25O9F638plvV8tegoCdSmdxRqb1hoWFchwZp6xElxN0Q9U+\nVVnY9Zo/y/C1CGD8GPkoMWPYS/nS81D07zdsbE5Y44u41pO7XqWceIWXfLOPLXmu\nPmwREPBN50gMJ+qWwKWcgmqDua4rtr3nronDqRaF3puVxUUBPjnvOWllANJwHG7u\ncPh76vrB\n=KJQR\n-----END PGP SIGNATURE-----",
        "payload": "tree 7bba05900db761f91c0b416985a3a774984bfd49\nparent 5574881ce329f91cc5bbc2b9585860a45fde7c3c\nauthor MarcoFalke <falke.marco@gmail.com> 1605027751 +0100\ncommitter MarcoFalke <falke.marco@gmail.com> 1635507292 +0200\n\ntest: Implicitly sync after generate*, unless opted out\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/facc352648e4fe1ed9b406400b6e4a9d51f30349",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/facc352648e4fe1ed9b406400b6e4a9d51f30349",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/facc352648e4fe1ed9b406400b6e4a9d51f30349/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5574881ce329f91cc5bbc2b9585860a45fde7c3c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5574881ce329f91cc5bbc2b9585860a45fde7c3c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5574881ce329f91cc5bbc2b9585860a45fde7c3c"
      }
    ],
    "stats": {
      "total": 319,
      "additions": 144,
      "deletions": 175
    },
    "files": [
      {
        "sha": "2473edcfe9eddc64fdafeb87db8fc8ac88f3acbd",
        "filename": "test/functional/example_test.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/example_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/example_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/example_test.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -141,8 +141,7 @@ def run_test(self):\n         peer_messaging = self.nodes[0].add_p2p_connection(BaseNode())\n \n         # Generating a block on one of the nodes will get us out of IBD\n-        blocks = [int(self.generate(self.nodes[0], nblocks=1)[0], 16)]\n-        self.sync_all(self.nodes[0:2])\n+        blocks = [int(self.generate(self.nodes[0], sync_fun=lambda: self.sync_all(self.nodes[0:2]), nblocks=1)[0], 16)]\n \n         # Notice above how we called an RPC by calling a method with the same\n         # name on the node object. Notice also how we used a keyword argument"
      },
      {
        "sha": "bb67dc88a674be58e41401101a409f40896083de",
        "filename": "test/functional/feature_abortnode.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/feature_abortnode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/feature_abortnode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_abortnode.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -26,18 +26,18 @@ def setup_network(self):\n         # We'll connect the nodes later\n \n     def run_test(self):\n-        self.generate(self.nodes[0], 3)\n+        self.generate(self.nodes[0], 3, sync_fun=self.no_op)\n         datadir = get_datadir_path(self.options.tmpdir, 0)\n \n         # Deleting the undo file will result in reorg failure\n         os.unlink(os.path.join(datadir, self.chain, 'blocks', 'rev00000.dat'))\n \n         # Connecting to a node with a more work chain will trigger a reorg\n         # attempt.\n-        self.generate(self.nodes[1], 3)\n+        self.generate(self.nodes[1], 3, sync_fun=self.no_op)\n         with self.nodes[0].assert_debug_log([\"Failed to disconnect block\"]):\n             self.connect_nodes(0, 1)\n-            self.generate(self.nodes[1], 1)\n+            self.generate(self.nodes[1], 1, sync_fun=self.no_op)\n \n             # Check that node0 aborted\n             self.log.info(\"Waiting for crash\")"
      },
      {
        "sha": "d962b622feef3e299ed0ab3221e7870aaa08edbf",
        "filename": "test/functional/feature_bip68_sequence.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/feature_bip68_sequence.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/feature_bip68_sequence.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_bip68_sequence.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -275,7 +275,7 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n         cur_time = int(time.time())\n         for _ in range(10):\n             self.nodes[0].setmocktime(cur_time + 600)\n-            self.generate(self.nodes[0], 1)\n+            self.generate(self.nodes[0], 1, sync_fun=self.no_op)\n             cur_time += 600\n \n         assert tx2.hash in self.nodes[0].getrawmempool()\n@@ -351,7 +351,7 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n         # Reset the chain and get rid of the mocktimed-blocks\n         self.nodes[0].setmocktime(0)\n         self.nodes[0].invalidateblock(self.nodes[0].getblockhash(cur_height+1))\n-        self.generate(self.nodes[0], 10)\n+        self.generate(self.nodes[0], 10, sync_fun=self.no_op)\n \n     # Make sure that BIP68 isn't being used to validate blocks prior to\n     # activation height.  If more blocks are mined prior to this test\n@@ -405,9 +405,9 @@ def activateCSV(self):\n         min_activation_height = 432\n         height = self.nodes[0].getblockcount()\n         assert_greater_than(min_activation_height - height, 2)\n-        self.generate(self.nodes[0], min_activation_height - height - 2)\n+        self.generate(self.nodes[0], min_activation_height - height - 2, sync_fun=self.no_op)\n         assert not softfork_active(self.nodes[0], 'csv')\n-        self.generate(self.nodes[0], 1)\n+        self.generate(self.nodes[0], 1, sync_fun=self.no_op)\n         assert softfork_active(self.nodes[0], 'csv')\n         self.sync_blocks()\n "
      },
      {
        "sha": "b996b16b9cb67f1221974e3f876c0413fc47f901",
        "filename": "test/functional/feature_coinstatsindex.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/feature_coinstatsindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/feature_coinstatsindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_coinstatsindex.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -228,7 +228,7 @@ def _test_coin_stats_index(self):\n         res9 = index_node.gettxoutsetinfo('muhash')\n         assert_equal(res8, res9)\n \n-        self.generate(index_node, 1)\n+        self.generate(index_node, 1, sync_fun=self.no_op)\n         res10 = index_node.gettxoutsetinfo('muhash')\n         assert(res8['txouts'] < res10['txouts'])\n \n@@ -254,7 +254,7 @@ def _test_reorg_index(self):\n         assert_equal(index_node.gettxoutsetinfo('muhash')['height'], 110)\n \n         # Add two new blocks\n-        block = self.generate(index_node, 2)[1]\n+        block = self.generate(index_node, 2, sync_fun=self.no_op)[1]\n         res = index_node.gettxoutsetinfo(hash_type='muhash', hash_or_height=None, use_index=False)\n \n         # Test that the result of the reorged block is not returned for its old block height"
      },
      {
        "sha": "1bda4a29b5ae8f26291ae7eacf5f8dfe08efbc5d",
        "filename": "test/functional/feature_dbcrash.py",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/feature_dbcrash.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/feature_dbcrash.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_dbcrash.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -217,7 +217,7 @@ def run_test(self):\n \n         # Start by creating a lot of utxos on node3\n         initial_height = self.nodes[3].getblockcount()\n-        utxo_list = create_confirmed_utxos(self, self.nodes[3].getnetworkinfo()['relayfee'], self.nodes[3], 5000)\n+        utxo_list = create_confirmed_utxos(self, self.nodes[3].getnetworkinfo()['relayfee'], self.nodes[3], 5000, sync_fun=self.no_op)\n         self.log.info(f\"Prepped {len(utxo_list)} utxo entries\")\n \n         # Sync these blocks with the other nodes\n@@ -258,6 +258,7 @@ def run_test(self):\n                     nblocks=min(10, current_height + 1 - self.nodes[3].getblockcount()),\n                     # new address to avoid mining a block that has just been invalidated\n                     address=self.nodes[3].getnewaddress(),\n+                    sync_fun=self.no_op,\n                 ))\n             self.log.debug(f\"Syncing {len(block_hashes)} new blocks...\")\n             self.sync_node3blocks(block_hashes)"
      },
      {
        "sha": "2a8dd1fb7baafcec74fb1d9c89ba5e804d1dcf80",
        "filename": "test/functional/feature_fee_estimation.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/feature_fee_estimation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/feature_fee_estimation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_fee_estimation.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -237,7 +237,7 @@ def initial_split(self, node):\n \n         # Mine\n         while len(node.getrawmempool()) > 0:\n-            self.generate(node, 1)\n+            self.generate(node, 1, sync_fun=self.no_op)\n \n         # Repeatedly split those 2 outputs, doubling twice for each rep\n         # Use txouts to monitor the available utxo, since these won't be tracked in wallet\n@@ -247,12 +247,12 @@ def initial_split(self, node):\n             while len(self.txouts) > 0:\n                 split_inputs(node, self.txouts, self.txouts2)\n             while len(node.getrawmempool()) > 0:\n-                self.generate(node, 1)\n+                self.generate(node, 1, sync_fun=self.no_op)\n             # Double txouts2 to txouts\n             while len(self.txouts2) > 0:\n                 split_inputs(node, self.txouts2, self.txouts)\n             while len(node.getrawmempool()) > 0:\n-                self.generate(node, 1)\n+                self.generate(node, 1, sync_fun=self.no_op)\n             reps += 1\n \n     def sanity_check_estimates_range(self):"
      },
      {
        "sha": "079630546ef9e68fc4dbf77ba74c4bf08f8778f9",
        "filename": "test/functional/feature_loadblock.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/feature_loadblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/feature_loadblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_loadblock.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -29,7 +29,7 @@ def set_test_params(self):\n \n     def run_test(self):\n         self.nodes[1].setnetworkactive(state=False)\n-        self.generate(self.nodes[0], COINBASE_MATURITY)\n+        self.generate(self.nodes[0], COINBASE_MATURITY, sync_fun=self.no_op)\n \n         # Parsing the url of our node to get settings for config file\n         data_dir = self.nodes[0].datadir"
      },
      {
        "sha": "a77f022ddd4fc3392dbc056f6f126c0f817c451d",
        "filename": "test/functional/feature_minchainwork.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/feature_minchainwork.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/feature_minchainwork.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_minchainwork.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -51,8 +51,7 @@ def run_test(self):\n \n         num_blocks_to_generate = int((self.node_min_work[1] - starting_chain_work) / REGTEST_WORK_PER_BLOCK)\n         self.log.info(f\"Generating {num_blocks_to_generate} blocks on node0\")\n-        hashes = self.generatetoaddress(self.nodes[0], num_blocks_to_generate,\n-                                                 self.nodes[0].get_deterministic_priv_key().address)\n+        hashes = self.generate(self.nodes[0], num_blocks_to_generate, sync_fun=self.no_op)\n \n         self.log.info(f\"Node0 current chain work: {self.nodes[0].getblockheader(hashes[-1])['chainwork']}\")\n \n@@ -73,7 +72,7 @@ def run_test(self):\n         assert_equal(self.nodes[2].getblockcount(), starting_blockcount)\n \n         self.log.info(\"Generating one more block\")\n-        self.generatetoaddress(self.nodes[0], 1, self.nodes[0].get_deterministic_priv_key().address)\n+        self.generate(self.nodes[0], 1)\n \n         self.log.info(\"Verifying nodes are all synced\")\n "
      },
      {
        "sha": "612b724fa5c738bce6b6d1021cfb4673b85177cb",
        "filename": "test/functional/feature_notifications.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/feature_notifications.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/feature_notifications.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_notifications.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -149,7 +149,7 @@ def run_test(self):\n             # about newly confirmed bump2 and newly conflicted tx2.\n             self.disconnect_nodes(0, 1)\n             bump2 = self.nodes[0].bumpfee(tx2)[\"txid\"]\n-            blockhash2 = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+            blockhash2 = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE, sync_fun=self.no_op)[0]\n             blockheight2 = self.nodes[0].getblockcount()\n             assert_equal(self.nodes[0].gettransaction(bump2)[\"confirmations\"], 1)\n             assert_equal(tx2 in self.nodes[1].getrawmempool(), True)"
      },
      {
        "sha": "125b219bd4f03635610a2c5c50c2726fd6a55e75",
        "filename": "test/functional/feature_pruning.py",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/feature_pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/feature_pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_pruning.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -118,9 +118,8 @@ def setup_nodes(self):\n \n     def create_big_chain(self):\n         # Start by creating some coinbases we can spend later\n-        self.generate(self.nodes[1], 200)\n-        self.sync_blocks(self.nodes[0:2])\n-        self.generate(self.nodes[0], 150)\n+        self.generate(self.nodes[1], 200, sync_fun=lambda: self.sync_blocks(self.nodes[0:2]))\n+        self.generate(self.nodes[0], 150, sync_fun=self.no_op)\n \n         # Then mine enough full blocks to create more than 550MiB of data\n         mine_large_blocks(self.nodes[0], 645)\n@@ -211,7 +210,7 @@ def reorg_test(self):\n         self.disconnect_nodes(1, 2)\n \n         self.log.info(\"Generating new longer chain of 300 more blocks\")\n-        self.generate(self.nodes[1], 300)\n+        self.generate(self.nodes[1], 300, sync_fun=self.no_op)\n \n         self.log.info(\"Reconnect nodes\")\n         self.connect_nodes(0, 1)\n@@ -263,7 +262,7 @@ def reorg_back(self):\n             self.nodes[0].invalidateblock(curchainhash)\n             assert_equal(self.nodes[0].getblockcount(), self.mainchainheight)\n             assert_equal(self.nodes[0].getbestblockhash(), self.mainchainhash2)\n-            goalbesthash = self.generate(self.nodes[0], blocks_to_mine)[-1]\n+            goalbesthash = self.generate(self.nodes[0], blocks_to_mine, sync_fun=self.no_op)[-1]\n             goalbestheight = first_reorg_height + 1\n \n         self.log.info(\"Verify node 2 reorged back to the main chain, some blocks of which it had to redownload\")\n@@ -306,7 +305,7 @@ def has_block(index):\n         assert_equal(block1_details[\"nTx\"], len(block1_details[\"tx\"]))\n \n         # mine 6 blocks so we are at height 1001 (i.e., above PruneAfterHeight)\n-        self.generate(node, 6)\n+        self.generate(node, 6, sync_fun=self.no_op)\n         assert_equal(node.getblockchaininfo()[\"blocks\"], 1001)\n \n         # Pruned block should still know the number of transactions\n@@ -337,7 +336,7 @@ def has_block(index):\n         assert has_block(2), \"blk00002.dat is still there, should be pruned by now\"\n \n         # advance the tip so blk00002.dat and blk00003.dat can be pruned (the last 288 blocks should now be in blk00004.dat)\n-        self.generate(node, 288)\n+        self.generate(node, 288, sync_fun=self.no_op)\n         prune(1000)\n         assert not has_block(2), \"blk00002.dat is still there, should be pruned by now\"\n         assert not has_block(3), \"blk00003.dat is still there, should be pruned by now\""
      },
      {
        "sha": "268da62fafd32562e00bf0b08075a5768d69316b",
        "filename": "test/functional/feature_signet.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/feature_signet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/feature_signet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_signet.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -51,7 +51,7 @@ def run_test(self):\n         assert_equal(mining_info['networkhashps'], Decimal('0'))\n         assert_equal(mining_info['pooledtx'], 0)\n \n-        self.generate(self.nodes[0], 1)\n+        self.generate(self.nodes[0], 1, sync_fun=self.no_op)\n \n         self.log.info(\"pregenerated signet blocks check\")\n "
      },
      {
        "sha": "5bf75e2064daceddac0f33901f1cf3f720da4773",
        "filename": "test/functional/interface_zmq.py",
        "status": "modified",
        "additions": 7,
        "deletions": 8,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/interface_zmq.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/interface_zmq.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_zmq.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -82,9 +82,8 @@ class ZMQTestSetupBlock:\n     the generated block's hash, it's (coinbase) transaction id, the raw block or\n     raw transaction data.\n     \"\"\"\n-\n     def __init__(self, test_framework, node):\n-        self.block_hash = test_framework.generate(node, 1)[0]\n+        self.block_hash = test_framework.generate(node, 1, sync_fun=test_framework.no_op)[0]\n         coinbase = node.getblock(self.block_hash, 2)['tx'][0]\n         self.tx_hash = coinbase['txid']\n         self.raw_tx = coinbase['hex']\n@@ -261,14 +260,14 @@ def test_reorg(self):\n \n         # Generate 1 block in nodes[0] with 1 mempool tx and receive all notifications\n         payment_txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n-        disconnect_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        disconnect_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE, sync_fun=self.no_op)[0]\n         disconnect_cb = self.nodes[0].getblock(disconnect_block)[\"tx\"][0]\n         assert_equal(self.nodes[0].getbestblockhash(), hashblock.receive().hex())\n         assert_equal(hashtx.receive().hex(), payment_txid)\n         assert_equal(hashtx.receive().hex(), disconnect_cb)\n \n         # Generate 2 blocks in nodes[1] to a different address to ensure split\n-        connect_blocks = self.generatetoaddress(self.nodes[1], 2, ADDRESS_BCRT1_P2WSH_OP_TRUE)\n+        connect_blocks = self.generatetoaddress(self.nodes[1], 2, ADDRESS_BCRT1_P2WSH_OP_TRUE, sync_fun=self.no_op)\n \n         # nodes[0] will reorg chain after connecting back nodes[1]\n         self.connect_nodes(0, 1)\n@@ -312,13 +311,13 @@ def test_sequence(self):\n         seq_num = 1\n \n         # Generate 1 block in nodes[0] and receive all notifications\n-        dc_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        dc_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE, sync_fun=self.no_op)[0]\n \n         # Note: We are not notified of any block transactions, coinbase or mined\n         assert_equal((self.nodes[0].getbestblockhash(), \"C\", None), seq.receive_sequence())\n \n         # Generate 2 blocks in nodes[1] to a different address to ensure a chain split\n-        self.generatetoaddress(self.nodes[1], 2, ADDRESS_BCRT1_P2WSH_OP_TRUE)\n+        self.generatetoaddress(self.nodes[1], 2, ADDRESS_BCRT1_P2WSH_OP_TRUE, sync_fun=self.no_op)\n \n         # nodes[0] will reorg chain after connecting back nodes[1]\n         self.connect_nodes(0, 1)\n@@ -474,7 +473,7 @@ def test_mempool_sync(self):\n         # 1) Consume backlog until we get a mempool sequence number\n         (hash_str, label, zmq_mem_seq) = seq.receive_sequence()\n         while zmq_mem_seq is None:\n-                (hash_str, label, zmq_mem_seq) = seq.receive_sequence()\n+            (hash_str, label, zmq_mem_seq) = seq.receive_sequence()\n \n         assert label == \"A\" or label == \"R\"\n         assert hash_str is not None\n@@ -566,7 +565,7 @@ def test_multiple_interfaces(self):\n         ], sync_blocks=False)\n \n         # Generate 1 block in nodes[0] and receive all notifications\n-        self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)\n+        self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE, sync_fun=self.no_op)\n \n         # Should receive the same block hash on both subscribers\n         assert_equal(self.nodes[0].getbestblockhash(), subscribers[0].receive().hex())"
      },
      {
        "sha": "5263920dae7d2aadd934e1f365d89b35cf2b4b2b",
        "filename": "test/functional/mempool_compatibility.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/mempool_compatibility.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/mempool_compatibility.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_compatibility.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -38,8 +38,8 @@ def run_test(self):\n \n         old_node, new_node = self.nodes\n         new_wallet = MiniWallet(new_node)\n-        self.generate(new_wallet, 1)\n-        self.generate(new_node, COINBASE_MATURITY)\n+        self.generate(new_wallet, 1, sync_fun=self.no_op)\n+        self.generate(new_node, COINBASE_MATURITY, sync_fun=self.no_op)\n         # Sync the nodes to ensure old_node has the block that contains the coinbase that new_wallet will spend.\n         # Otherwise, because coinbases are only valid in a block and not as loose txns, if the nodes aren't synced\n         # unbroadcasted_tx won't pass old_node's `MemPoolAccept::PreChecks`."
      },
      {
        "sha": "a91fcbd6c7da5d45fc914319ea4ec95f1327255e",
        "filename": "test/functional/mempool_persist.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/mempool_persist.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/mempool_persist.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_persist.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -174,7 +174,7 @@ def test_persist_unbroadcast(self):\n         self.start_node(0)\n \n         # clear out mempool\n-        self.generate(node0, 1)\n+        self.generate(node0, 1, sync_fun=self.no_op)\n \n         # ensure node0 doesn't have any connections\n         # make a transaction that will remain in the unbroadcast set"
      },
      {
        "sha": "509a003746b8b339ab10c9de0d0866898fa3f543",
        "filename": "test/functional/mempool_reorg.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/mempool_reorg.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/mempool_reorg.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_reorg.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -79,9 +79,8 @@ def run_test(self):\n         spend_3_1_id = self.nodes[0].sendrawtransaction(spend_3_1['hex'])\n         self.log.info(\"Generate a block\")\n         last_block = self.generate(self.nodes[0], 1)\n-        # Sync blocks, so that peer 1 gets the block before timelock_tx\n+        # generate() implicitly syncs blocks, so that peer 1 gets the block before timelock_tx\n         # Otherwise, peer 1 would put the timelock_tx in m_recent_rejects\n-        self.sync_all()\n \n         self.log.info(\"The time-locked transaction can now be spent\")\n         timelock_tx_id = self.nodes[0].sendrawtransaction(timelock_tx)"
      },
      {
        "sha": "88194a09b4690ef61dd8c5215ca55503e673c570",
        "filename": "test/functional/mempool_unbroadcast.py",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/mempool_unbroadcast.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/mempool_unbroadcast.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_unbroadcast.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -109,7 +109,8 @@ def test_txn_removal(self):\n         # a block\n         removal_reason = \"Removed {} from set of unbroadcast txns before confirmation that txn was sent out\".format(txhsh)\n         with node.assert_debug_log([removal_reason]):\n-            self.generate(node, 1)\n+            self.generate(node, 1, sync_fun=self.no_op)\n+\n \n if __name__ == \"__main__\":\n     MempoolUnbroadcastTest().main()"
      },
      {
        "sha": "3d1f804ddca835cea9acf9dccce9d5bf9c9fd32c",
        "filename": "test/functional/mining_basic.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/mining_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/mining_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mining_basic.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -58,7 +58,7 @@ def mine_chain(self):\n         self.log.info('Create some old blocks')\n         for t in range(TIME_GENESIS_BLOCK, TIME_GENESIS_BLOCK + 200 * 600, 600):\n             self.nodes[0].setmocktime(t)\n-            self.generate(self.nodes[0], 1)\n+            self.generate(self.nodes[0], 1, sync_fun=self.no_op)\n         mining_info = self.nodes[0].getmininginfo()\n         assert_equal(mining_info['blocks'], 200)\n         assert_equal(mining_info['currentblocktx'], 0)"
      },
      {
        "sha": "01d8501b6be618cbcc29548392605bb8da278e82",
        "filename": "test/functional/mining_prioritisetransaction.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/mining_prioritisetransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/mining_prioritisetransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mining_prioritisetransaction.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -105,7 +105,7 @@ def run_test(self):\n         # the other high fee transactions. Keep mining until our mempool has\n         # decreased by all the high fee size that we calculated above.\n         while (self.nodes[0].getmempoolinfo()['bytes'] > sizes[0] + sizes[1]):\n-            self.generate(self.nodes[0], 1)\n+            self.generate(self.nodes[0], 1, sync_fun=self.no_op)\n \n         # High fee transaction should not have been mined, but other high fee rate\n         # transactions should have been."
      },
      {
        "sha": "b67a0b3f7e7457febd83af57f9fb25294420dda2",
        "filename": "test/functional/p2p_blockfilters.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/p2p_blockfilters.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/p2p_blockfilters.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_blockfilters.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -62,11 +62,11 @@ def run_test(self):\n         # Stale blocks by disconnecting nodes 0 & 1, mining, then reconnecting\n         self.disconnect_nodes(0, 1)\n \n-        stale_block_hash = self.generate(self.nodes[0], 1)[0]\n+        stale_block_hash = self.generate(self.nodes[0], 1, sync_fun=self.no_op)[0]\n         self.nodes[0].syncwithvalidationinterfacequeue()\n         assert_equal(self.nodes[0].getblockcount(), 1000)\n \n-        self.generate(self.nodes[1], 1001)\n+        self.generate(self.nodes[1], 1001, sync_fun=self.no_op)\n         assert_equal(self.nodes[1].getblockcount(), 2000)\n \n         # Check that nodes have signalled NODE_COMPACT_FILTERS correctly."
      },
      {
        "sha": "6367eb26a368b020cb7396639794d3193e0c3119",
        "filename": "test/functional/p2p_compactblocks_blocksonly.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/p2p_compactblocks_blocksonly.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/p2p_compactblocks_blocksonly.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_compactblocks_blocksonly.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -33,7 +33,7 @@ def setup_network(self):\n         self.sync_all()\n \n     def build_block_on_tip(self):\n-        blockhash = self.generate(self.nodes[2], 1)[0]\n+        blockhash = self.generate(self.nodes[2], 1, sync_fun=self.no_op)[0]\n         block_hex = self.nodes[2].getblock(blockhash=blockhash, verbosity=0)\n         block = from_hex(CBlock(), block_hex)\n         block.rehash()"
      },
      {
        "sha": "d70870fa56d1b14ebf25ca8cce4355d1fc0faecd",
        "filename": "test/functional/p2p_node_network_limited.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/p2p_node_network_limited.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/p2p_node_network_limited.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_node_network_limited.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -59,7 +59,7 @@ def run_test(self):\n \n         self.log.info(\"Mine enough blocks to reach the NODE_NETWORK_LIMITED range.\")\n         self.connect_nodes(0, 1)\n-        blocks = self.generatetoaddress(self.nodes[1], 292, self.nodes[1].get_deterministic_priv_key().address)\n+        blocks = self.generate(self.nodes[1], 292, sync_fun=self.no_op)\n         self.sync_blocks([self.nodes[0], self.nodes[1]])\n \n         self.log.info(\"Make sure we can max retrieve block at tip-288.\")\n@@ -101,7 +101,7 @@ def run_test(self):\n         self.disconnect_all()\n \n         # mine 10 blocks on node 0 (pruned node)\n-        self.generatetoaddress(self.nodes[0], 10, self.nodes[0].get_deterministic_priv_key().address)\n+        self.generate(self.nodes[0], 10, sync_fun=self.no_op)\n \n         # connect node1 (non pruned) with node0 (pruned) and check if the can sync\n         self.connect_nodes(0, 1)"
      },
      {
        "sha": "e03719857391e19f666f4fb294780700df32e5aa",
        "filename": "test/functional/p2p_unrequested_blocks.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/p2p_unrequested_blocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/p2p_unrequested_blocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_unrequested_blocks.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -77,7 +77,7 @@ def run_test(self):\n         min_work_node = self.nodes[1].add_p2p_connection(P2PInterface())\n \n         # 1. Have nodes mine a block (leave IBD)\n-        [self.generatetoaddress(n, 1, n.get_deterministic_priv_key().address) for n in self.nodes]\n+        [self.generate(n, 1, sync_fun=self.no_op) for n in self.nodes]\n         tips = [int(\"0x\" + n.getbestblockhash(), 0) for n in self.nodes]\n \n         # 2. Send one block that builds on each tip."
      },
      {
        "sha": "6cebfdc51f128d9a3765981dbaaeba0922d478b8",
        "filename": "test/functional/rpc_blockchain.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/rpc_blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/rpc_blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_blockchain.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -376,7 +376,7 @@ def _test_stopatheight(self):\n         self.log.debug('Node should not stop at this height')\n         assert_raises(subprocess.TimeoutExpired, lambda: self.nodes[0].process.wait(timeout=3))\n         try:\n-            self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_P2WSH_OP_TRUE)\n+            self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_P2WSH_OP_TRUE, sync_fun=self.no_op)\n         except (ConnectionError, http.client.BadStatusLine):\n             pass  # The node already shut down before response\n         self.log.debug('Node should stop at this height...')"
      },
      {
        "sha": "017541db90012d6eaf0cfc2d8d9492b84b59174d",
        "filename": "test/functional/rpc_fundrawtransaction.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/rpc_fundrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/rpc_fundrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_fundrawtransaction.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -1096,7 +1096,7 @@ def test_22670(self):\n         # than any single input available, and require more than 1 input. So we make 3 outputs\n         for i in range(0, 3):\n             funds.sendtoaddress(tester.getnewaddress(address_type=\"bech32\"), 1)\n-        self.generate(self.nodes[0], 1)\n+        self.generate(self.nodes[0], 1, sync_fun=self.no_op)\n \n         # Create transactions in order to calculate fees for the target bounds that can trigger this bug\n         change_tx = tester.fundrawtransaction(tester.createrawtransaction([], [{funds.getnewaddress(): 1.5}]))"
      },
      {
        "sha": "1c456a5b82ba05659c5a11cb9ea95320d3f81903",
        "filename": "test/functional/rpc_getblockfilter.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/rpc_getblockfilter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/rpc_getblockfilter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_getblockfilter.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -21,8 +21,8 @@ def run_test(self):\n         # Create two chains by disconnecting nodes 0 & 1, mining, then reconnecting\n         self.disconnect_nodes(0, 1)\n \n-        self.generate(self.nodes[0], 3)\n-        self.generate(self.nodes[1], 4)\n+        self.generate(self.nodes[0], 3, sync_fun=self.no_op)\n+        self.generate(self.nodes[1], 4, sync_fun=self.no_op)\n \n         assert_equal(self.nodes[0].getblockcount(), 3)\n         chain0_hashes = [self.nodes[0].getblockhash(block_height) for block_height in range(4)]"
      },
      {
        "sha": "fb09c81cbd4083bd87f8f1dd05e576236bc81187",
        "filename": "test/functional/rpc_getchaintips.py",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/rpc_getchaintips.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/rpc_getchaintips.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_getchaintips.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -26,10 +26,8 @@ def run_test(self):\n \n         # Split the network and build two chains of different lengths.\n         self.split_network()\n-        self.generatetoaddress(self.nodes[0], 10, self.nodes[0].get_deterministic_priv_key().address)\n-        self.generatetoaddress(self.nodes[2], 20, self.nodes[2].get_deterministic_priv_key().address)\n-        self.sync_all(self.nodes[:2])\n-        self.sync_all(self.nodes[2:])\n+        self.generate(self.nodes[0], 10, sync_fun=lambda: self.sync_all(self.nodes[:2]))\n+        self.generate(self.nodes[2], 20, sync_fun=lambda: self.sync_all(self.nodes[2:]))\n \n         tips = self.nodes[1].getchaintips ()\n         assert_equal (len (tips), 1)"
      },
      {
        "sha": "9bc02d153e421fe3c0478a84f8cf600c6c6654de",
        "filename": "test/functional/rpc_invalidateblock.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/rpc_invalidateblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/rpc_invalidateblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_invalidateblock.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -22,12 +22,12 @@ def setup_network(self):\n     def run_test(self):\n         self.log.info(\"Make sure we repopulate setBlockIndexCandidates after InvalidateBlock:\")\n         self.log.info(\"Mine 4 blocks on Node 0\")\n-        self.generatetoaddress(self.nodes[0], 4, self.nodes[0].get_deterministic_priv_key().address)\n+        self.generate(self.nodes[0], 4, sync_fun=self.no_op)\n         assert_equal(self.nodes[0].getblockcount(), 4)\n         besthash_n0 = self.nodes[0].getbestblockhash()\n \n         self.log.info(\"Mine competing 6 blocks on Node 1\")\n-        self.generatetoaddress(self.nodes[1], 6, self.nodes[1].get_deterministic_priv_key().address)\n+        self.generate(self.nodes[1], 6, sync_fun=self.no_op)\n         assert_equal(self.nodes[1].getblockcount(), 6)\n \n         self.log.info(\"Connect nodes to force a reorg\")\n@@ -53,14 +53,14 @@ def run_test(self):\n         self.nodes[2].invalidateblock(self.nodes[2].getblockhash(3))\n         assert_equal(self.nodes[2].getblockcount(), 2)\n         self.log.info(\"..and then mine a block\")\n-        self.generatetoaddress(self.nodes[2], 1, self.nodes[2].get_deterministic_priv_key().address)\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n         self.log.info(\"Verify all nodes are at the right height\")\n         self.wait_until(lambda: self.nodes[2].getblockcount() == 3, timeout=5)\n         self.wait_until(lambda: self.nodes[0].getblockcount() == 4, timeout=5)\n         self.wait_until(lambda: self.nodes[1].getblockcount() == 4, timeout=5)\n \n         self.log.info(\"Verify that we reconsider all ancestors as well\")\n-        blocks = self.generatetodescriptor(self.nodes[1], 10, ADDRESS_BCRT1_UNSPENDABLE_DESCRIPTOR)\n+        blocks = self.generatetodescriptor(self.nodes[1], 10, ADDRESS_BCRT1_UNSPENDABLE_DESCRIPTOR, sync_fun=self.no_op)\n         assert_equal(self.nodes[1].getbestblockhash(), blocks[-1])\n         # Invalidate the two blocks at the tip\n         self.nodes[1].invalidateblock(blocks[-1])\n@@ -72,7 +72,7 @@ def run_test(self):\n         assert_equal(self.nodes[1].getbestblockhash(), blocks[-1])\n \n         self.log.info(\"Verify that we reconsider all descendants\")\n-        blocks = self.generatetodescriptor(self.nodes[1], 10, ADDRESS_BCRT1_UNSPENDABLE_DESCRIPTOR)\n+        blocks = self.generatetodescriptor(self.nodes[1], 10, ADDRESS_BCRT1_UNSPENDABLE_DESCRIPTOR, sync_fun=self.no_op)\n         assert_equal(self.nodes[1].getbestblockhash(), blocks[-1])\n         # Invalidate the two blocks at the tip\n         self.nodes[1].invalidateblock(blocks[-2])"
      },
      {
        "sha": "2e526efd9abd5fddd20f0bb62825b76c8bc143c5",
        "filename": "test/functional/rpc_preciousblock.py",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/rpc_preciousblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/rpc_preciousblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_preciousblock.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -42,19 +42,18 @@ def setup_network(self):\n \n     def run_test(self):\n         self.log.info(\"Ensure submitblock can in principle reorg to a competing chain\")\n-        gen_address = lambda i: self.nodes[i].get_deterministic_priv_key().address  # A non-wallet address to mine to\n-        self.generatetoaddress(self.nodes[0], 1, gen_address(0))\n+        self.generate(self.nodes[0], 1, sync_fun=self.no_op)\n         assert_equal(self.nodes[0].getblockcount(), 1)\n-        hashZ = self.generatetoaddress(self.nodes[1], 2, gen_address(1))[-1]\n+        hashZ = self.generate(self.nodes[1], 2, sync_fun=self.no_op)[-1]\n         assert_equal(self.nodes[1].getblockcount(), 2)\n         node_sync_via_rpc(self.nodes[0:3])\n         assert_equal(self.nodes[0].getbestblockhash(), hashZ)\n \n         self.log.info(\"Mine blocks A-B-C on Node 0\")\n-        hashC = self.generatetoaddress(self.nodes[0], 3, gen_address(0))[-1]\n+        hashC = self.generate(self.nodes[0], 3, sync_fun=self.no_op)[-1]\n         assert_equal(self.nodes[0].getblockcount(), 5)\n         self.log.info(\"Mine competing blocks E-F-G on Node 1\")\n-        hashG = self.generatetoaddress(self.nodes[1], 3, gen_address(1))[-1]\n+        hashG = self.generate(self.nodes[1], 3, sync_fun=self.no_op)[-1]\n         assert_equal(self.nodes[1].getblockcount(), 5)\n         assert hashC != hashG\n         self.log.info(\"Connect nodes and check no reorg occurs\")\n@@ -83,7 +82,7 @@ def run_test(self):\n         self.nodes[1].preciousblock(hashC)\n         assert_equal(self.nodes[1].getbestblockhash(), hashC)\n         self.log.info(\"Mine another block (E-F-G-)H on Node 0 and reorg Node 1\")\n-        self.generatetoaddress(self.nodes[0], 1, gen_address(0))\n+        self.generate(self.nodes[0], 1, sync_fun=self.no_op)\n         assert_equal(self.nodes[0].getblockcount(), 6)\n         self.sync_blocks(self.nodes[0:2])\n         hashH = self.nodes[0].getbestblockhash()\n@@ -92,7 +91,7 @@ def run_test(self):\n         self.nodes[1].preciousblock(hashC)\n         assert_equal(self.nodes[1].getbestblockhash(), hashH)\n         self.log.info(\"Mine competing blocks I-J-K-L on Node 2\")\n-        self.generatetoaddress(self.nodes[2], 4, gen_address(2))\n+        self.generate(self.nodes[2], 4, sync_fun=self.no_op)\n         assert_equal(self.nodes[2].getblockcount(), 6)\n         hashL = self.nodes[2].getbestblockhash()\n         self.log.info(\"Connect nodes and check no reorg occurs\")"
      },
      {
        "sha": "3cb11b4c18351fefa587edfece21f37542fd35fe",
        "filename": "test/functional/rpc_txoutproof.py",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/rpc_txoutproof.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/rpc_txoutproof.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_txoutproof.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -43,7 +43,6 @@ def run_test(self):\n \n         self.generate(self.nodes[0], 1)\n         blockhash = self.nodes[0].getblockhash(chain_height + 1)\n-        self.sync_all()\n \n         txlist = []\n         blocktxn = self.nodes[0].getblock(blockhash, True)[\"tx\"]"
      },
      {
        "sha": "84d94b34f7e812af7e85a160893054f34373d567",
        "filename": "test/functional/test_framework/test_framework.py",
        "status": "modified",
        "additions": 12,
        "deletions": 5,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/test_framework/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/test_framework/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_framework.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -413,7 +413,7 @@ def setup_nodes(self):\n             # To ensure that all nodes are out of IBD, the most recent block\n             # must have a timestamp not too old (see IsInitialBlockDownload()).\n             self.log.debug('Generate a block with current time')\n-            block_hash = self.generate(self.nodes[0], 1)[0]\n+            block_hash = self.generate(self.nodes[0], 1, sync_fun=self.no_op)[0]\n             block = self.nodes[0].getblock(blockhash=block_hash, verbosity=0)\n             for n in self.nodes:\n                 n.submitblock(block)\n@@ -627,20 +627,27 @@ def join_network(self):\n         self.connect_nodes(1, 2)\n         self.sync_all()\n \n-    def generate(self, generator, *args, **kwargs):\n+    def no_op(self):\n+        pass\n+\n+    def generate(self, generator, *args, sync_fun=None, **kwargs):\n         blocks = generator.generate(*args, invalid_call=False, **kwargs)\n+        sync_fun() if sync_fun else self.sync_all()\n         return blocks\n \n-    def generateblock(self, generator, *args, **kwargs):\n+    def generateblock(self, generator, *args, sync_fun=None, **kwargs):\n         blocks = generator.generateblock(*args, invalid_call=False, **kwargs)\n+        sync_fun() if sync_fun else self.sync_all()\n         return blocks\n \n-    def generatetoaddress(self, generator, *args, **kwargs):\n+    def generatetoaddress(self, generator, *args, sync_fun=None, **kwargs):\n         blocks = generator.generatetoaddress(*args, invalid_call=False, **kwargs)\n+        sync_fun() if sync_fun else self.sync_all()\n         return blocks\n \n-    def generatetodescriptor(self, generator, *args, **kwargs):\n+    def generatetodescriptor(self, generator, *args, sync_fun=None, **kwargs):\n         blocks = generator.generatetodescriptor(*args, invalid_call=False, **kwargs)\n+        sync_fun() if sync_fun else self.sync_all()\n         return blocks\n \n     def sync_blocks(self, nodes=None, wait=1, timeout=60):"
      },
      {
        "sha": "792886544e3fedb3f3bccae53bb4a096dfa0dd15",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -451,10 +451,10 @@ def find_output(node, txid, amount, *, blockhash=None):\n \n # Helper to create at least \"count\" utxos\n # Pass in a fee that is sufficient for relay and mining new transactions.\n-def create_confirmed_utxos(test_framework, fee, node, count):\n+def create_confirmed_utxos(test_framework, fee, node, count, **kwargs):\n     to_generate = int(0.5 * count) + 101\n     while to_generate > 0:\n-        test_framework.generate(node, min(25, to_generate))\n+        test_framework.generate(node, min(25, to_generate), **kwargs)\n         to_generate -= 25\n     utxos = node.listunspent()\n     iterations = count - len(utxos)\n@@ -475,7 +475,7 @@ def create_confirmed_utxos(test_framework, fee, node, count):\n         node.sendrawtransaction(signed_tx)\n \n     while (node.getmempoolinfo()['size'] > 0):\n-        test_framework.generate(node, 1)\n+        test_framework.generate(node, 1, **kwargs)\n \n     utxos = node.listunspent()\n     assert len(utxos) >= count"
      },
      {
        "sha": "edb3779f8228573996c819dc1f17c9d776ef0046",
        "filename": "test/functional/wallet_abandonconflict.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_abandonconflict.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_abandonconflict.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_abandonconflict.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -43,7 +43,6 @@ def run_test(self):\n         # Can not abandon confirmed transaction\n         assert_raises_rpc_error(-5, 'Transaction not eligible for abandonment', lambda: self.nodes[0].abandontransaction(txid=txA))\n \n-        self.sync_blocks()\n         newbalance = self.nodes[0].getbalance()\n         assert balance - newbalance < Decimal(\"0.001\")  #no more than fees lost\n         balance = newbalance\n@@ -167,7 +166,7 @@ def run_test(self):\n         tx = self.nodes[0].createrawtransaction(inputs, outputs)\n         signed = self.nodes[0].signrawtransactionwithwallet(tx)\n         self.nodes[1].sendrawtransaction(signed[\"hex\"])\n-        self.generate(self.nodes[1], 1)\n+        self.generate(self.nodes[1], 1, sync_fun=self.no_op)\n \n         self.connect_nodes(0, 1)\n         self.sync_blocks()"
      },
      {
        "sha": "470cd9f34ccc62effa6d8f580a9f8f0aff653f33",
        "filename": "test/functional/wallet_balance.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_balance.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_balance.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_balance.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -265,7 +265,7 @@ def test_balances(*, fee_node_1=0):\n         self.nodes[0].invalidateblock(block_reorg)\n         self.nodes[1].invalidateblock(block_reorg)\n         assert_equal(self.nodes[0].getbalance(minconf=0), 0)  # wallet txs not in the mempool are untrusted\n-        self.generatetoaddress(self.nodes[0], 1, ADDRESS_WATCHONLY)\n+        self.generatetoaddress(self.nodes[0], 1, ADDRESS_WATCHONLY, sync_fun=self.no_op)\n         assert_equal(self.nodes[0].getbalance(minconf=0), 0)  # wallet txs not in the mempool are untrusted\n \n         # Now confirm tx_orig"
      },
      {
        "sha": "3839360eda66b0c482f99485d4cd6bd861738c5b",
        "filename": "test/functional/wallet_basic.py",
        "status": "modified",
        "additions": 22,
        "deletions": 40,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_basic.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -60,15 +60,14 @@ def run_test(self):\n \n         self.log.info(\"Mining blocks...\")\n \n-        self.generate(self.nodes[0], 1)\n+        self.generate(self.nodes[0], 1, sync_fun=self.no_op)\n \n         walletinfo = self.nodes[0].getwalletinfo()\n         assert_equal(walletinfo['immature_balance'], 50)\n         assert_equal(walletinfo['balance'], 0)\n \n         self.sync_all(self.nodes[0:3])\n-        self.generate(self.nodes[1], COINBASE_MATURITY + 1)\n-        self.sync_all(self.nodes[0:3])\n+        self.generate(self.nodes[1], COINBASE_MATURITY + 1, sync_fun=lambda: self.sync_all(self.nodes[0:3]))\n \n         assert_equal(self.nodes[0].getbalance(), 50)\n         assert_equal(self.nodes[1].getbalance(), 50)\n@@ -116,8 +115,7 @@ def run_test(self):\n         assert_equal(walletinfo['immature_balance'], 0)\n \n         # Have node0 mine a block, thus it will collect its own fee.\n-        self.generate(self.nodes[0], 1)\n-        self.sync_all(self.nodes[0:3])\n+        self.generate(self.nodes[0], 1, sync_fun=lambda: self.sync_all(self.nodes[0:3]))\n \n         # Exercise locking of unspent outputs\n         unspent_0 = self.nodes[2].listunspent()[0]\n@@ -196,8 +194,7 @@ def run_test(self):\n         assert_equal(len(self.nodes[1].listlockunspent()), 0)\n \n         # Have node1 generate 100 blocks (so node0 can recover the fee)\n-        self.generate(self.nodes[1], COINBASE_MATURITY)\n-        self.sync_all(self.nodes[0:3])\n+        self.generate(self.nodes[1], COINBASE_MATURITY, sync_fun=lambda: self.sync_all(self.nodes[0:3]))\n \n         # node0 should end up with 100 btc in block rewards plus fees, but\n         # minus the 21 plus fees sent to node2\n@@ -225,8 +222,7 @@ def run_test(self):\n         self.nodes[1].sendrawtransaction(hexstring=txns_to_send[1][\"hex\"], maxfeerate=0)\n \n         # Have node1 mine a block to confirm transactions:\n-        self.generate(self.nodes[1], 1)\n-        self.sync_all(self.nodes[0:3])\n+        self.generate(self.nodes[1], 1, sync_fun=lambda: self.sync_all(self.nodes[0:3]))\n \n         assert_equal(self.nodes[0].getbalance(), 0)\n         assert_equal(self.nodes[2].getbalance(), 94)\n@@ -240,15 +236,13 @@ def run_test(self):\n         fee_per_byte = Decimal('0.001') / 1000\n         self.nodes[2].settxfee(fee_per_byte * 1000)\n         txid = self.nodes[2].sendtoaddress(address, 10, \"\", \"\", False)\n-        self.generate(self.nodes[2], 1)\n-        self.sync_all(self.nodes[0:3])\n+        self.generate(self.nodes[2], 1, sync_fun=lambda: self.sync_all(self.nodes[0:3]))\n         node_2_bal = self.check_fee_amount(self.nodes[2].getbalance(), Decimal('84'), fee_per_byte, self.get_vsize(self.nodes[2].gettransaction(txid)['hex']))\n         assert_equal(self.nodes[0].getbalance(), Decimal('10'))\n \n         # Send 10 BTC with subtract fee from amount\n         txid = self.nodes[2].sendtoaddress(address, 10, \"\", \"\", True)\n-        self.generate(self.nodes[2], 1)\n-        self.sync_all(self.nodes[0:3])\n+        self.generate(self.nodes[2], 1, sync_fun=lambda: self.sync_all(self.nodes[0:3]))\n         node_2_bal -= Decimal('10')\n         assert_equal(self.nodes[2].getbalance(), node_2_bal)\n         node_0_bal = self.check_fee_amount(self.nodes[0].getbalance(), Decimal('20'), fee_per_byte, self.get_vsize(self.nodes[2].gettransaction(txid)['hex']))\n@@ -257,16 +251,14 @@ def run_test(self):\n \n         # Sendmany 10 BTC\n         txid = self.nodes[2].sendmany('', {address: 10}, 0, \"\", [])\n-        self.generate(self.nodes[2], 1)\n-        self.sync_all(self.nodes[0:3])\n+        self.generate(self.nodes[2], 1, sync_fun=lambda: self.sync_all(self.nodes[0:3]))\n         node_0_bal += Decimal('10')\n         node_2_bal = self.check_fee_amount(self.nodes[2].getbalance(), node_2_bal - Decimal('10'), fee_per_byte, self.get_vsize(self.nodes[2].gettransaction(txid)['hex']))\n         assert_equal(self.nodes[0].getbalance(), node_0_bal)\n \n         # Sendmany 10 BTC with subtract fee from amount\n         txid = self.nodes[2].sendmany('', {address: 10}, 0, \"\", [address])\n-        self.generate(self.nodes[2], 1)\n-        self.sync_all(self.nodes[0:3])\n+        self.generate(self.nodes[2], 1, sync_fun=lambda: self.sync_all(self.nodes[0:3]))\n         node_2_bal -= Decimal('10')\n         assert_equal(self.nodes[2].getbalance(), node_2_bal)\n         node_0_bal = self.check_fee_amount(self.nodes[0].getbalance(), node_0_bal + Decimal('10'), fee_per_byte, self.get_vsize(self.nodes[2].gettransaction(txid)['hex']))\n@@ -278,8 +270,7 @@ def run_test(self):\n \n         # Test passing fee_rate as a string\n         txid = self.nodes[2].sendmany(amounts={address: 10}, fee_rate=str(fee_rate_sat_vb))\n-        self.generate(self.nodes[2], 1)\n-        self.sync_all(self.nodes[0:3])\n+        self.generate(self.nodes[2], 1, sync_fun=lambda: self.sync_all(self.nodes[0:3]))\n         balance = self.nodes[2].getbalance()\n         node_2_bal = self.check_fee_amount(balance, node_2_bal - Decimal('10'), explicit_fee_rate_btc_kvb, self.get_vsize(self.nodes[2].gettransaction(txid)['hex']))\n         assert_equal(balance, node_2_bal)\n@@ -289,8 +280,7 @@ def run_test(self):\n         # Test passing fee_rate as an integer\n         amount = Decimal(\"0.0001\")\n         txid = self.nodes[2].sendmany(amounts={address: amount}, fee_rate=fee_rate_sat_vb)\n-        self.generate(self.nodes[2], 1)\n-        self.sync_all(self.nodes[0:3])\n+        self.generate(self.nodes[2], 1, sync_fun=lambda: self.sync_all(self.nodes[0:3]))\n         balance = self.nodes[2].getbalance()\n         node_2_bal = self.check_fee_amount(balance, node_2_bal - amount, explicit_fee_rate_btc_kvb, self.get_vsize(self.nodes[2].gettransaction(txid)['hex']))\n         assert_equal(balance, node_2_bal)\n@@ -374,14 +364,12 @@ def run_test(self):\n \n         txid_not_broadcast = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 2)\n         tx_obj_not_broadcast = self.nodes[0].gettransaction(txid_not_broadcast)\n-        self.generate(self.nodes[1], 1)  # mine a block, tx should not be in there\n-        self.sync_all(self.nodes[0:3])\n+        self.generate(self.nodes[1], 1, sync_fun=lambda: self.sync_all(self.nodes[0:3]))  # mine a block, tx should not be in there\n         assert_equal(self.nodes[2].getbalance(), node_2_bal)  # should not be changed because tx was not broadcasted\n \n         # now broadcast from another node, mine a block, sync, and check the balance\n         self.nodes[1].sendrawtransaction(tx_obj_not_broadcast['hex'])\n-        self.generate(self.nodes[1], 1)\n-        self.sync_all(self.nodes[0:3])\n+        self.generate(self.nodes[1], 1, sync_fun=lambda: self.sync_all(self.nodes[0:3]))\n         node_2_bal += 2\n         tx_obj_not_broadcast = self.nodes[0].gettransaction(txid_not_broadcast)\n         assert_equal(self.nodes[2].getbalance(), node_2_bal)\n@@ -399,8 +387,7 @@ def run_test(self):\n         self.connect_nodes(0, 2)\n         self.sync_blocks(self.nodes[0:3])\n \n-        self.generate(self.nodes[0], 1)\n-        self.sync_blocks(self.nodes[0:3])\n+        self.generate(self.nodes[0], 1, sync_fun=lambda: self.sync_blocks(self.nodes[0:3]))\n         node_2_bal += 2\n \n         # tx should be added to balance because after restarting the nodes tx should be broadcast\n@@ -467,8 +454,7 @@ def run_test(self):\n             self.sync_mempools(self.nodes[0:3])\n             vout = find_vout_for_address(self.nodes[2], txid, address_to_import)\n             self.nodes[2].lockunspent(False, [{\"txid\": txid, \"vout\": vout}])\n-            self.generate(self.nodes[0], 1)\n-            self.sync_all(self.nodes[0:3])\n+            self.generate(self.nodes[0], 1, sync_fun=lambda: self.sync_all(self.nodes[0:3]))\n \n             self.log.info(\"Test sendtoaddress with fee_rate param (explicit fee rate in sat/vB)\")\n             prebalance = self.nodes[2].getbalance()\n@@ -480,8 +466,7 @@ def run_test(self):\n             # Test passing fee_rate as an integer\n             txid = self.nodes[2].sendtoaddress(address=address, amount=amount, fee_rate=fee_rate_sat_vb)\n             tx_size = self.get_vsize(self.nodes[2].gettransaction(txid)['hex'])\n-            self.generate(self.nodes[0], 1)\n-            self.sync_all(self.nodes[0:3])\n+            self.generate(self.nodes[0], 1, sync_fun=lambda: self.sync_all(self.nodes[0:3]))\n             postbalance = self.nodes[2].getbalance()\n             fee = prebalance - postbalance - Decimal(amount)\n             assert_fee_amount(fee, tx_size, Decimal(fee_rate_btc_kvb))\n@@ -493,8 +478,7 @@ def run_test(self):\n             # Test passing fee_rate as a string\n             txid = self.nodes[2].sendtoaddress(address=address, amount=amount, fee_rate=str(fee_rate_sat_vb))\n             tx_size = self.get_vsize(self.nodes[2].gettransaction(txid)['hex'])\n-            self.generate(self.nodes[0], 1)\n-            self.sync_all(self.nodes[0:3])\n+            self.generate(self.nodes[0], 1, sync_fun=lambda: self.sync_all(self.nodes[0:3]))\n             postbalance = self.nodes[2].getbalance()\n             fee = prebalance - postbalance - amount\n             assert_fee_amount(fee, tx_size, Decimal(fee_rate_btc_kvb))\n@@ -555,17 +539,15 @@ def run_test(self):\n \n         # Mine a block from node0 to an address from node1\n         coinbase_addr = self.nodes[1].getnewaddress()\n-        block_hash = self.generatetoaddress(self.nodes[0], 1, coinbase_addr)[0]\n+        block_hash = self.generatetoaddress(self.nodes[0], 1, coinbase_addr, sync_fun=lambda: self.sync_all(self.nodes[0:3]))[0]\n         coinbase_txid = self.nodes[0].getblock(block_hash)['tx'][0]\n-        self.sync_all(self.nodes[0:3])\n \n         # Check that the txid and balance is found by node1\n         self.nodes[1].gettransaction(coinbase_txid)\n \n         # check if wallet or blockchain maintenance changes the balance\n         self.sync_all(self.nodes[0:3])\n-        blocks = self.generate(self.nodes[0], 2)\n-        self.sync_all(self.nodes[0:3])\n+        blocks = self.generate(self.nodes[0], 2, sync_fun=lambda: self.sync_all(self.nodes[0:3]))\n         balance_nodes = [self.nodes[i].getbalance() for i in range(3)]\n         block_count = self.nodes[0].getblockcount()\n \n@@ -606,13 +588,13 @@ def run_test(self):\n         # Get all non-zero utxos together\n         chain_addrs = [self.nodes[0].getnewaddress(), self.nodes[0].getnewaddress()]\n         singletxid = self.nodes[0].sendtoaddress(chain_addrs[0], self.nodes[0].getbalance(), \"\", \"\", True)\n-        self.generate(self.nodes[0], 1)\n+        self.generate(self.nodes[0], 1, sync_fun=self.no_op)\n         node0_balance = self.nodes[0].getbalance()\n         # Split into two chains\n         rawtx = self.nodes[0].createrawtransaction([{\"txid\": singletxid, \"vout\": 0}], {chain_addrs[0]: node0_balance / 2 - Decimal('0.01'), chain_addrs[1]: node0_balance / 2 - Decimal('0.01')})\n         signedtx = self.nodes[0].signrawtransactionwithwallet(rawtx)\n         singletxid = self.nodes[0].sendrawtransaction(hexstring=signedtx[\"hex\"], maxfeerate=0)\n-        self.generate(self.nodes[0], 1)\n+        self.generate(self.nodes[0], 1, sync_fun=self.no_op)\n \n         # Make a long chain of unconfirmed payments without hitting mempool limit\n         # Each tx we make leaves only one output of change on a chain 1 longer\n@@ -663,7 +645,7 @@ def run_test(self):\n         assert not address_info[\"ischange\"]\n \n         # Test getaddressinfo 'ischange' field on change address.\n-        self.generate(self.nodes[0], 1)\n+        self.generate(self.nodes[0], 1, sync_fun=self.no_op)\n         destination = self.nodes[1].getnewaddress()\n         txid = self.nodes[0].sendtoaddress(destination, 0.123)\n         tx = self.nodes[0].gettransaction(txid=txid, verbose=True)['decoded']"
      },
      {
        "sha": "34ee06b2fe460062d7686c244bfd524410526045",
        "filename": "test/functional/wallet_bumpfee.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_bumpfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_bumpfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_bumpfee.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -529,7 +529,7 @@ def test_unconfirmed_not_spendable(self, rbf_node, rbf_node_address):\n     assert_equal([t for t in rbf_node.listunspent(minconf=0, include_unsafe=False) if t[\"txid\"] == rbfid], [])\n \n     # check that the main output from the rbf tx is spendable after confirmed\n-    self.generate(rbf_node, 1)\n+    self.generate(rbf_node, 1, sync_fun=self.no_op)\n     assert_equal(\n         sum(1 for t in rbf_node.listunspent(minconf=0, include_unsafe=False)\n             if t[\"txid\"] == rbfid and t[\"address\"] == rbf_node_address and t[\"spendable\"]), 1)"
      },
      {
        "sha": "6f9cd2e80ff5e70cbfac6c30f83cf5d08f3e702a",
        "filename": "test/functional/wallet_import_rescan.py",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_import_rescan.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_import_rescan.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_import_rescan.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -181,7 +181,6 @@ def run_test(self):\n             self.generate(self.nodes[0], 1)  # Generate one block for each send\n             variant.confirmation_height = self.nodes[0].getblockcount()\n             variant.timestamp = self.nodes[0].getblockheader(self.nodes[0].getbestblockhash())[\"time\"]\n-        self.sync_all() # Conclude sync before calling setmocktime to avoid timeouts\n \n         # Generate a block further in the future (past the rescan window).\n         assert_equal(self.nodes[0].getrawmempool(), [])"
      },
      {
        "sha": "8289c6b8ce4b11c3d86f6254dc68bd1ea9b882c1",
        "filename": "test/functional/wallet_importmulti.py",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importmulti.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -62,8 +62,8 @@ def test_importmulti(self, req, success, error_code=None, error_message=None, wa\n \n     def run_test(self):\n         self.log.info(\"Mining blocks...\")\n-        self.generate(self.nodes[0], 1)\n-        self.generate(self.nodes[1], 1)\n+        self.generate(self.nodes[0], 1, sync_fun=self.no_op)\n+        self.generate(self.nodes[1], 1, sync_fun=self.no_op)\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n         self.nodes[1].syncwithvalidationinterfacequeue()  # Sync the timestamp to the wallet, so that importmulti works\n \n@@ -256,9 +256,9 @@ def run_test(self):\n \n         # P2SH address\n         multisig = get_multisig(self.nodes[0])\n-        self.generate(self.nodes[1], COINBASE_MATURITY)\n+        self.generate(self.nodes[1], COINBASE_MATURITY, sync_fun=self.no_op)\n         self.nodes[1].sendtoaddress(multisig.p2sh_addr, 10.00)\n-        self.generate(self.nodes[1], 1)\n+        self.generate(self.nodes[1], 1, sync_fun=self.no_op)\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n         self.nodes[1].syncwithvalidationinterfacequeue()\n \n@@ -277,9 +277,9 @@ def run_test(self):\n \n         # P2SH + Redeem script\n         multisig = get_multisig(self.nodes[0])\n-        self.generate(self.nodes[1], COINBASE_MATURITY)\n+        self.generate(self.nodes[1], COINBASE_MATURITY, sync_fun=self.no_op)\n         self.nodes[1].sendtoaddress(multisig.p2sh_addr, 10.00)\n-        self.generate(self.nodes[1], 1)\n+        self.generate(self.nodes[1], 1, sync_fun=self.no_op)\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n         self.nodes[1].syncwithvalidationinterfacequeue()\n \n@@ -298,9 +298,9 @@ def run_test(self):\n \n         # P2SH + Redeem script + Private Keys + !Watchonly\n         multisig = get_multisig(self.nodes[0])\n-        self.generate(self.nodes[1], COINBASE_MATURITY)\n+        self.generate(self.nodes[1], COINBASE_MATURITY, sync_fun=self.no_op)\n         self.nodes[1].sendtoaddress(multisig.p2sh_addr, 10.00)\n-        self.generate(self.nodes[1], 1)\n+        self.generate(self.nodes[1], 1, sync_fun=self.no_op)\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n         self.nodes[1].syncwithvalidationinterfacequeue()\n \n@@ -324,9 +324,9 @@ def run_test(self):\n \n         # P2SH + Redeem script + Private Keys + Watchonly\n         multisig = get_multisig(self.nodes[0])\n-        self.generate(self.nodes[1], COINBASE_MATURITY)\n+        self.generate(self.nodes[1], COINBASE_MATURITY, sync_fun=self.no_op)\n         self.nodes[1].sendtoaddress(multisig.p2sh_addr, 10.00)\n-        self.generate(self.nodes[1], 1)\n+        self.generate(self.nodes[1], 1, sync_fun=self.no_op)\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n         self.nodes[1].syncwithvalidationinterfacequeue()\n "
      },
      {
        "sha": "815e3e6298d1a49fb3a0f4b76f7a9acdb4a28d0d",
        "filename": "test/functional/wallet_listsinceblock.py",
        "status": "modified",
        "additions": 7,
        "deletions": 12,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_listsinceblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_listsinceblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_listsinceblock.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -54,7 +54,6 @@ def test_no_blockhash(self):\n \n         blockhash, = self.generate(self.nodes[2], 1)\n         blockheight = self.nodes[2].getblockheader(blockhash)['height']\n-        self.sync_all()\n \n         txs = self.nodes[0].listtransactions()\n         assert_array_result(txs, {\"txid\": txid}, {\n@@ -99,7 +98,6 @@ def test_targetconfirmations(self):\n         self.log.info(\"Test target_confirmations\")\n         blockhash, = self.generate(self.nodes[2], 1)\n         blockheight = self.nodes[2].getblockheader(blockhash)['height']\n-        self.sync_all()\n \n         assert_equal(\n             self.nodes[0].getblockhash(0),\n@@ -147,14 +145,11 @@ def test_reorg(self):\n         senttx = self.nodes[2].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n \n         # generate on both sides\n-        nodes1_last_blockhash = self.generate(self.nodes[1], 6)[-1]\n-        nodes2_first_blockhash = self.generate(self.nodes[2], 7)[0]\n+        nodes1_last_blockhash = self.generate(self.nodes[1], 6, sync_fun=lambda: self.sync_all(self.nodes[:2]))[-1]\n+        nodes2_first_blockhash = self.generate(self.nodes[2], 7, sync_fun=lambda: self.sync_all(self.nodes[2:]))[0]\n         self.log.debug(\"nodes[1] last blockhash = {}\".format(nodes1_last_blockhash))\n         self.log.debug(\"nodes[2] first blockhash = {}\".format(nodes2_first_blockhash))\n \n-        self.sync_all(self.nodes[:2])\n-        self.sync_all(self.nodes[2:])\n-\n         self.join_network()\n \n         # listsinceblock(nodes1_last_blockhash) should now include tx as seen from nodes[0]\n@@ -236,8 +231,8 @@ def test_double_spend(self):\n                 self.nodes[2].createrawtransaction(utxo_dicts, recipient_dict2))['hex'])\n \n         # generate on both sides\n-        lastblockhash = self.generate(self.nodes[1], 3)[2]\n-        self.generate(self.nodes[2], 4)\n+        lastblockhash = self.generate(self.nodes[1], 3, sync_fun=self.no_op)[2]\n+        self.generate(self.nodes[2], 4, sync_fun=self.no_op)\n \n         self.join_network()\n \n@@ -308,16 +303,16 @@ def test_double_send(self):\n         txid1 = self.nodes[1].sendrawtransaction(signedtx)\n \n         # generate bb1-bb2 on right side\n-        self.generate(self.nodes[2], 2)\n+        self.generate(self.nodes[2], 2, sync_fun=self.no_op)\n \n         # send from nodes[2]; this will end up in bb3\n         txid2 = self.nodes[2].sendrawtransaction(signedtx)\n \n         assert_equal(txid1, txid2)\n \n         # generate on both sides\n-        lastblockhash = self.generate(self.nodes[1], 3)[2]\n-        self.generate(self.nodes[2], 2)\n+        lastblockhash = self.generate(self.nodes[1], 3, sync_fun=self.no_op)[2]\n+        self.generate(self.nodes[2], 2, sync_fun=self.no_op)\n \n         self.join_network()\n "
      },
      {
        "sha": "269ce6925db7bfad02525ba05224985bc5c5d8d7",
        "filename": "test/functional/wallet_listtransactions.py",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_listtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_listtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_listtransactions.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -38,7 +38,6 @@ def run_test(self):\n         self.log.info(\"Test confirmations change after mining a block\")\n         blockhash = self.generate(self.nodes[0], 1)[0]\n         blockheight = self.nodes[0].getblockheader(blockhash)['height']\n-        self.sync_all()\n         assert_array_result(self.nodes[0].listtransactions(),\n                             {\"txid\": txid},\n                             {\"category\": \"send\", \"amount\": Decimal(\"-0.1\"), \"confirmations\": 1, \"blockhash\": blockhash, \"blockheight\": blockheight})"
      },
      {
        "sha": "1ed887191bba8952e5be8128ea5f4e1bf9d52188",
        "filename": "test/functional/wallet_multiwallet.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_multiwallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_multiwallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_multiwallet.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -185,7 +185,7 @@ def wallet_file(name):\n         self.nodes[0].createwallet(\"w5\")\n         assert_equal(set(node.listwallets()), {\"w4\", \"w5\"})\n         w5 = wallet(\"w5\")\n-        self.generatetoaddress(node, nblocks=1, address=w5.getnewaddress())\n+        self.generatetoaddress(node, nblocks=1, address=w5.getnewaddress(), sync_fun=self.no_op)\n \n         # now if wallets/ exists again, but the rootdir is specified as the walletdir, w4 and w5 should still be loaded\n         os.rename(wallet_dir2, wallet_dir())\n@@ -217,7 +217,7 @@ def wallet_file(name):\n         wallet_bad = wallet(\"bad\")\n \n         # check wallet names and balances\n-        self.generatetoaddress(node, nblocks=1, address=wallets[0].getnewaddress())\n+        self.generatetoaddress(node, nblocks=1, address=wallets[0].getnewaddress(), sync_fun=self.no_op)\n         for wallet_name, wallet in zip(wallet_names, wallets):\n             info = wallet.getwalletinfo()\n             assert_equal(info['immature_balance'], 50 if wallet is wallets[0] else 0)\n@@ -230,7 +230,7 @@ def wallet_file(name):\n         assert_raises_rpc_error(-19, \"Wallet file not specified\", node.getwalletinfo)\n \n         w1, w2, w3, w4, *_ = wallets\n-        self.generatetoaddress(node, nblocks=COINBASE_MATURITY + 1, address=w1.getnewaddress())\n+        self.generatetoaddress(node, nblocks=COINBASE_MATURITY + 1, address=w1.getnewaddress(), sync_fun=self.no_op)\n         assert_equal(w1.getbalance(), 100)\n         assert_equal(w2.getbalance(), 0)\n         assert_equal(w3.getbalance(), 0)\n@@ -239,7 +239,7 @@ def wallet_file(name):\n         w1.sendtoaddress(w2.getnewaddress(), 1)\n         w1.sendtoaddress(w3.getnewaddress(), 2)\n         w1.sendtoaddress(w4.getnewaddress(), 3)\n-        self.generatetoaddress(node, nblocks=1, address=w1.getnewaddress())\n+        self.generatetoaddress(node, nblocks=1, address=w1.getnewaddress(), sync_fun=self.no_op)\n         assert_equal(w2.getbalance(), 1)\n         assert_equal(w3.getbalance(), 2)\n         assert_equal(w4.getbalance(), 3)"
      },
      {
        "sha": "9a86ede5f94f29e3ddf56d7befd81dab997ece66",
        "filename": "test/functional/wallet_reorgsrestore.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_reorgsrestore.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_reorgsrestore.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_reorgsrestore.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -43,7 +43,7 @@ def run_test(self):\n         # Send a tx to be unconfirmed later\n         txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), Decimal(\"10\"))\n         tx = self.nodes[0].gettransaction(txid)\n-        self.generate(self.nodes[0], 4)\n+        self.generate(self.nodes[0], 4, sync_fun=self.no_op)\n         tx_before_reorg = self.nodes[0].gettransaction(txid)\n         assert_equal(tx_before_reorg[\"confirmations\"], 4)\n \n@@ -62,9 +62,9 @@ def run_test(self):\n         conflicting = self.nodes[0].signrawtransactionwithwallet(self.nodes[0].createrawtransaction(inputs, outputs_2))\n \n         conflicted_txid = self.nodes[0].sendrawtransaction(conflicted[\"hex\"])\n-        self.generate(self.nodes[0], 1)\n+        self.generate(self.nodes[0], 1, sync_fun=self.no_op)\n         conflicting_txid = self.nodes[2].sendrawtransaction(conflicting[\"hex\"])\n-        self.generate(self.nodes[2], 9)\n+        self.generate(self.nodes[2], 9, sync_fun=self.no_op)\n \n         # Reconnect node0 and node2 and check that conflicted_txid is effectively conflicted\n         self.connect_nodes(0, 2)\n@@ -78,11 +78,11 @@ def run_test(self):\n         self.restart_node(0)\n \n         # The block chain re-orgs and the tx is included in a different block\n-        self.generate(self.nodes[1], 9)\n+        self.generate(self.nodes[1], 9, sync_fun=self.no_op)\n         self.nodes[1].sendrawtransaction(tx[\"hex\"])\n-        self.generate(self.nodes[1], 1)\n+        self.generate(self.nodes[1], 1, sync_fun=self.no_op)\n         self.nodes[1].sendrawtransaction(conflicted[\"hex\"])\n-        self.generate(self.nodes[1], 1)\n+        self.generate(self.nodes[1], 1, sync_fun=self.no_op)\n \n         # Node0 wallet file is loaded on longest sync'ed node1\n         self.stop_node(1)"
      },
      {
        "sha": "ec8a4d33a38b2d26b139d4befa05f36ac0657144",
        "filename": "test/functional/wallet_send.py",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_send.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_send.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_send.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -448,7 +448,6 @@ def run_test(self):\n         res = self.nodes[0].sendrawtransaction(hex)\n         self.generate(self.nodes[0], 1)\n         assert_equal(self.nodes[0].gettransaction(txid)[\"confirmations\"], 1)\n-        self.sync_all()\n \n         self.log.info(\"Lock unspents...\")\n         utxo1 = w0.listunspent()[0]"
      },
      {
        "sha": "b22c17137453469f9f92306837c83763d7ab57e8",
        "filename": "test/functional/wallet_taproot.py",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_taproot.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_taproot.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_taproot.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -272,11 +272,11 @@ def do_test_sendtoaddress(self, comment, pattern, privmap, treefn, keys_pay, key\n             boring_balance = int(self.boring.getbalance() * 100000000)\n             to_amnt = random.randrange(1000000, boring_balance)\n             self.boring.sendtoaddress(address=addr_g, amount=Decimal(to_amnt) / 100000000, subtractfeefromamount=True)\n-            self.generatetoaddress(self.nodes[0], 1, self.boring.getnewaddress())\n+            self.generatetoaddress(self.nodes[0], 1, self.boring.getnewaddress(), sync_fun=self.no_op)\n             test_balance = int(self.rpc_online.getbalance() * 100000000)\n             ret_amnt = random.randrange(100000, test_balance)\n             res = self.rpc_online.sendtoaddress(address=self.boring.getnewaddress(), amount=Decimal(ret_amnt) / 100000000, subtractfeefromamount=True)\n-            self.generatetoaddress(self.nodes[0], 1, self.boring.getnewaddress())\n+            self.generatetoaddress(self.nodes[0], 1, self.boring.getnewaddress(), sync_fun=self.no_op)\n             assert(self.rpc_online.gettransaction(res)[\"confirmations\"] > 0)\n \n     def do_test_psbt(self, comment, pattern, privmap, treefn, keys_pay, keys_change):\n@@ -303,15 +303,15 @@ def do_test_psbt(self, comment, pattern, privmap, treefn, keys_pay, keys_change)\n             boring_balance = int(self.boring.getbalance() * 100000000)\n             to_amnt = random.randrange(1000000, boring_balance)\n             self.boring.sendtoaddress(address=addr_g, amount=Decimal(to_amnt) / 100000000, subtractfeefromamount=True)\n-            self.generatetoaddress(self.nodes[0], 1, self.boring.getnewaddress())\n+            self.generatetoaddress(self.nodes[0], 1, self.boring.getnewaddress(), sync_fun=self.no_op)\n             test_balance = int(self.psbt_online.getbalance() * 100000000)\n             ret_amnt = random.randrange(100000, test_balance)\n             psbt = self.psbt_online.walletcreatefundedpsbt([], [{self.boring.getnewaddress(): Decimal(ret_amnt) / 100000000}], None, {\"subtractFeeFromOutputs\":[0]})['psbt']\n             res = self.psbt_offline.walletprocesspsbt(psbt)\n             assert(res['complete'])\n             rawtx = self.nodes[0].finalizepsbt(res['psbt'])['hex']\n             txid = self.nodes[0].sendrawtransaction(rawtx)\n-            self.generatetoaddress(self.nodes[0], 1, self.boring.getnewaddress())\n+            self.generatetoaddress(self.nodes[0], 1, self.boring.getnewaddress(), sync_fun=self.no_op)\n             assert(self.psbt_online.gettransaction(txid)['confirmations'] > 0)\n \n     def do_test(self, comment, pattern, privmap, treefn, nkeys):\n@@ -343,7 +343,7 @@ def run_test(self):\n \n         self.log.info(\"Mining blocks...\")\n         gen_addr = self.boring.getnewaddress()\n-        self.generatetoaddress(self.nodes[0], 101, gen_addr)\n+        self.generatetoaddress(self.nodes[0], 101, gen_addr, sync_fun=self.no_op)\n \n         self.do_test(\n             \"tr(XPRV)\",\n@@ -412,15 +412,15 @@ def run_test(self):\n         self.log.info(\"Sending everything back...\")\n \n         txid = self.rpc_online.sendtoaddress(address=self.boring.getnewaddress(), amount=self.rpc_online.getbalance(), subtractfeefromamount=True)\n-        self.generatetoaddress(self.nodes[0], 1, self.boring.getnewaddress())\n+        self.generatetoaddress(self.nodes[0], 1, self.boring.getnewaddress(), sync_fun=self.no_op)\n         assert(self.rpc_online.gettransaction(txid)[\"confirmations\"] > 0)\n \n         psbt = self.psbt_online.walletcreatefundedpsbt([], [{self.boring.getnewaddress(): self.psbt_online.getbalance()}], None, {\"subtractFeeFromOutputs\": [0]})['psbt']\n         res = self.psbt_offline.walletprocesspsbt(psbt)\n         assert(res['complete'])\n         rawtx = self.nodes[0].finalizepsbt(res['psbt'])['hex']\n         txid = self.nodes[0].sendrawtransaction(rawtx)\n-        self.generatetoaddress(self.nodes[0], 1, self.boring.getnewaddress())\n+        self.generatetoaddress(self.nodes[0], 1, self.boring.getnewaddress(), sync_fun=self.no_op)\n         assert(self.psbt_online.gettransaction(txid)['confirmations'] > 0)\n \n if __name__ == '__main__':"
      },
      {
        "sha": "5ca231cb769cabc7b71ab2ad60f0a1094d0d33fd",
        "filename": "test/functional/wallet_txn_clone.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_txn_clone.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_txn_clone.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_txn_clone.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -93,8 +93,7 @@ def run_test(self):\n \n         # Have node0 mine a block, if requested:\n         if (self.options.mine_block):\n-            self.generate(self.nodes[0], 1)\n-            self.sync_blocks(self.nodes[0:2])\n+            self.generate(self.nodes[0], 1, sync_fun=lambda: self.sync_blocks(self.nodes[0:2]))\n \n         tx1 = self.nodes[0].gettransaction(txid1)\n         tx2 = self.nodes[0].gettransaction(txid2)\n@@ -123,7 +122,7 @@ def run_test(self):\n             return\n \n         # ... mine a block...\n-        self.generate(self.nodes[2], 1)\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n \n         # Reconnect the split network, and sync chain:\n         self.connect_nodes(1, 2)"
      },
      {
        "sha": "526e5cdd94367651bb39a08f416933976ae9d18d",
        "filename": "test/functional/wallet_txn_doublespend.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_txn_doublespend.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_txn_doublespend.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_txn_doublespend.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -91,8 +91,7 @@ def run_test(self):\n \n         # Have node0 mine a block:\n         if (self.options.mine_block):\n-            self.generate(self.nodes[0], 1)\n-            self.sync_blocks(self.nodes[0:2])\n+            self.generate(self.nodes[0], 1, sync_fun=lambda: self.sync_blocks(self.nodes[0:2]))\n \n         tx1 = self.nodes[0].gettransaction(txid1)\n         tx2 = self.nodes[0].gettransaction(txid2)\n@@ -120,7 +119,7 @@ def run_test(self):\n         self.nodes[2].sendrawtransaction(fund_bar_tx[\"hex\"])\n         doublespend_txid = self.nodes[2].sendrawtransaction(doublespend[\"hex\"])\n         # ... mine a block...\n-        self.generate(self.nodes[2], 1)\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n \n         # Reconnect the split network, and sync chain:\n         self.connect_nodes(1, 2)"
      },
      {
        "sha": "db03796df6fed44374da556cc3c7011a89098906",
        "filename": "test/functional/wallet_upgradewallet.py",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_upgradewallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facc352648e4fe1ed9b406400b6e4a9d51f30349/test/functional/wallet_upgradewallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_upgradewallet.py?ref=facc352648e4fe1ed9b406400b6e4a9d51f30349",
        "patch": "@@ -119,8 +119,7 @@ def test_upgradewallet_error(self, wallet, previous_version, requested_version,\n         assert_equal(wallet.getwalletinfo()[\"walletversion\"], previous_version)\n \n     def run_test(self):\n-        self.generatetoaddress(self.nodes[0], COINBASE_MATURITY + 1, self.nodes[0].getnewaddress())\n-        self.dumb_sync_blocks()\n+        self.generatetoaddress(self.nodes[0], COINBASE_MATURITY + 1, self.nodes[0].getnewaddress(), sync_fun=lambda: self.dumb_sync_blocks())\n         # # Sanity check the test framework:\n         res = self.nodes[0].getblockchaininfo()\n         assert_equal(res['blocks'], COINBASE_MATURITY + 1)\n@@ -131,8 +130,7 @@ def run_test(self):\n         # Send coins to old wallets for later conversion checks.\n         v16_3_wallet  = v16_3_node.get_wallet_rpc('wallet.dat')\n         v16_3_address = v16_3_wallet.getnewaddress()\n-        self.generatetoaddress(node_master, COINBASE_MATURITY + 1, v16_3_address)\n-        self.dumb_sync_blocks()\n+        self.generatetoaddress(node_master, COINBASE_MATURITY + 1, v16_3_address, sync_fun=lambda: self.dumb_sync_blocks())\n         v16_3_balance = v16_3_wallet.getbalance()\n \n         self.log.info(\"Test upgradewallet RPC...\")"
      }
    ]
  }
]