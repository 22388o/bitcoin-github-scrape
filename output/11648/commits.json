[
  {
    "sha": "f9cd9b1bfaf65b4e24c1eb9ca8268513e78cc458",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmOWNkOWIxYmZhZjY1YjRlMjRjMWViOWNhODI2ODUxM2U3OGNjNDU4",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-17T02:25:15Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-10T16:56:45Z"
      },
      "message": "[tests] Move test_framework Bitcoin primitives into separate module\n\nmininode.py wildcard imports all names from primitives.py. This is\nto avoid having to change all test scripts that import from mininode.py.",
      "tree": {
        "sha": "d4f37ab8dbf724abc0fe78445dcb25261c4fdb13",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d4f37ab8dbf724abc0fe78445dcb25261c4fdb13"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f9cd9b1bfaf65b4e24c1eb9ca8268513e78cc458",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f9cd9b1bfaf65b4e24c1eb9ca8268513e78cc458",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f9cd9b1bfaf65b4e24c1eb9ca8268513e78cc458",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f9cd9b1bfaf65b4e24c1eb9ca8268513e78cc458/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1f4375f8e75f95522ad763d06da047b1b3893530",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1f4375f8e75f95522ad763d06da047b1b3893530",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1f4375f8e75f95522ad763d06da047b1b3893530"
      }
    ],
    "stats": {
      "total": 2625,
      "additions": 1320,
      "deletions": 1305
    },
    "files": [
      {
        "sha": "40d02f3ee0a63953dd7836816d257197d177a4ed",
        "filename": "test/functional/test_framework/messages.py",
        "status": "added",
        "additions": 1319,
        "deletions": 0,
        "changes": 1319,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f9cd9b1bfaf65b4e24c1eb9ca8268513e78cc458/test/functional/test_framework/messages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f9cd9b1bfaf65b4e24c1eb9ca8268513e78cc458/test/functional/test_framework/messages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/messages.py?ref=f9cd9b1bfaf65b4e24c1eb9ca8268513e78cc458",
        "patch": "@@ -0,0 +1,1319 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2010 ArtForz -- public domain half-a-node\n+# Copyright (c) 2012 Jeff Garzik\n+# Copyright (c) 2010-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Bitcoin test framework primitive and message strcutures\n+\n+CBlock, CTransaction, CBlockHeader, CTxIn, CTxOut, etc....:\n+    data structures that should map to corresponding structures in\n+    bitcoin/primitives\n+\n+msg_block, msg_tx, msg_headers, etc.:\n+    data structures that represent network messages\n+\n+ser_*, deser_*: functions that handle serialization/deserialization.\"\"\"\n+from codecs import encode\n+import copy\n+import hashlib\n+from io import BytesIO\n+import random\n+import socket\n+import struct\n+import time\n+\n+from test_framework.siphash import siphash256\n+from test_framework.util import hex_str_to_bytes, bytes_to_hex_str, wait_until\n+\n+MIN_VERSION_SUPPORTED = 60001\n+MY_VERSION = 70014  # past bip-31 for ping/pong\n+MY_SUBVERSION = b\"/python-mininode-tester:0.0.3/\"\n+MY_RELAY = 1 # from version 70001 onwards, fRelay should be appended to version messages (BIP37)\n+\n+MAX_INV_SZ = 50000\n+MAX_BLOCK_BASE_SIZE = 1000000\n+\n+COIN = 100000000 # 1 btc in satoshis\n+\n+NODE_NETWORK = (1 << 0)\n+# NODE_GETUTXO = (1 << 1)\n+# NODE_BLOOM = (1 << 2)\n+NODE_WITNESS = (1 << 3)\n+NODE_UNSUPPORTED_SERVICE_BIT_5 = (1 << 5)\n+NODE_UNSUPPORTED_SERVICE_BIT_7 = (1 << 7)\n+\n+# Serialization/deserialization tools\n+def sha256(s):\n+    return hashlib.new('sha256', s).digest()\n+\n+def ripemd160(s):\n+    return hashlib.new('ripemd160', s).digest()\n+\n+def hash256(s):\n+    return sha256(sha256(s))\n+\n+def ser_compact_size(l):\n+    r = b\"\"\n+    if l < 253:\n+        r = struct.pack(\"B\", l)\n+    elif l < 0x10000:\n+        r = struct.pack(\"<BH\", 253, l)\n+    elif l < 0x100000000:\n+        r = struct.pack(\"<BI\", 254, l)\n+    else:\n+        r = struct.pack(\"<BQ\", 255, l)\n+    return r\n+\n+def deser_compact_size(f):\n+    nit = struct.unpack(\"<B\", f.read(1))[0]\n+    if nit == 253:\n+        nit = struct.unpack(\"<H\", f.read(2))[0]\n+    elif nit == 254:\n+        nit = struct.unpack(\"<I\", f.read(4))[0]\n+    elif nit == 255:\n+        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    return nit\n+\n+def deser_string(f):\n+    nit = deser_compact_size(f)\n+    return f.read(nit)\n+\n+def ser_string(s):\n+    return ser_compact_size(len(s)) + s\n+\n+def deser_uint256(f):\n+    r = 0\n+    for i in range(8):\n+        t = struct.unpack(\"<I\", f.read(4))[0]\n+        r += t << (i * 32)\n+    return r\n+\n+\n+def ser_uint256(u):\n+    rs = b\"\"\n+    for i in range(8):\n+        rs += struct.pack(\"<I\", u & 0xFFFFFFFF)\n+        u >>= 32\n+    return rs\n+\n+\n+def uint256_from_str(s):\n+    r = 0\n+    t = struct.unpack(\"<IIIIIIII\", s[:32])\n+    for i in range(8):\n+        r += t[i] << (i * 32)\n+    return r\n+\n+\n+def uint256_from_compact(c):\n+    nbytes = (c >> 24) & 0xFF\n+    v = (c & 0xFFFFFF) << (8 * (nbytes - 3))\n+    return v\n+\n+\n+def deser_vector(f, c):\n+    nit = deser_compact_size(f)\n+    r = []\n+    for i in range(nit):\n+        t = c()\n+        t.deserialize(f)\n+        r.append(t)\n+    return r\n+\n+\n+# ser_function_name: Allow for an alternate serialization function on the\n+# entries in the vector (we use this for serializing the vector of transactions\n+# for a witness block).\n+def ser_vector(l, ser_function_name=None):\n+    r = ser_compact_size(len(l))\n+    for i in l:\n+        if ser_function_name:\n+            r += getattr(i, ser_function_name)()\n+        else:\n+            r += i.serialize()\n+    return r\n+\n+\n+def deser_uint256_vector(f):\n+    nit = deser_compact_size(f)\n+    r = []\n+    for i in range(nit):\n+        t = deser_uint256(f)\n+        r.append(t)\n+    return r\n+\n+\n+def ser_uint256_vector(l):\n+    r = ser_compact_size(len(l))\n+    for i in l:\n+        r += ser_uint256(i)\n+    return r\n+\n+\n+def deser_string_vector(f):\n+    nit = deser_compact_size(f)\n+    r = []\n+    for i in range(nit):\n+        t = deser_string(f)\n+        r.append(t)\n+    return r\n+\n+\n+def ser_string_vector(l):\n+    r = ser_compact_size(len(l))\n+    for sv in l:\n+        r += ser_string(sv)\n+    return r\n+\n+\n+def deser_int_vector(f):\n+    nit = deser_compact_size(f)\n+    r = []\n+    for i in range(nit):\n+        t = struct.unpack(\"<i\", f.read(4))[0]\n+        r.append(t)\n+    return r\n+\n+\n+def ser_int_vector(l):\n+    r = ser_compact_size(len(l))\n+    for i in l:\n+        r += struct.pack(\"<i\", i)\n+    return r\n+\n+# Deserialize from a hex string representation (eg from RPC)\n+def FromHex(obj, hex_string):\n+    obj.deserialize(BytesIO(hex_str_to_bytes(hex_string)))\n+    return obj\n+\n+# Convert a binary-serializable object to hex (eg for submission via RPC)\n+def ToHex(obj):\n+    return bytes_to_hex_str(obj.serialize())\n+\n+# Objects that map to bitcoind objects, which can be serialized/deserialized\n+\n+class CAddress():\n+    def __init__(self):\n+        self.nServices = 1\n+        self.pchReserved = b\"\\x00\" * 10 + b\"\\xff\" * 2\n+        self.ip = \"0.0.0.0\"\n+        self.port = 0\n+\n+    def deserialize(self, f):\n+        self.nServices = struct.unpack(\"<Q\", f.read(8))[0]\n+        self.pchReserved = f.read(12)\n+        self.ip = socket.inet_ntoa(f.read(4))\n+        self.port = struct.unpack(\">H\", f.read(2))[0]\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<Q\", self.nServices)\n+        r += self.pchReserved\n+        r += socket.inet_aton(self.ip)\n+        r += struct.pack(\">H\", self.port)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CAddress(nServices=%i ip=%s port=%i)\" % (self.nServices,\n+                                                         self.ip, self.port)\n+\n+MSG_WITNESS_FLAG = 1<<30\n+\n+class CInv():\n+    typemap = {\n+        0: \"Error\",\n+        1: \"TX\",\n+        2: \"Block\",\n+        1|MSG_WITNESS_FLAG: \"WitnessTx\",\n+        2|MSG_WITNESS_FLAG : \"WitnessBlock\",\n+        4: \"CompactBlock\"\n+    }\n+\n+    def __init__(self, t=0, h=0):\n+        self.type = t\n+        self.hash = h\n+\n+    def deserialize(self, f):\n+        self.type = struct.unpack(\"<i\", f.read(4))[0]\n+        self.hash = deser_uint256(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<i\", self.type)\n+        r += ser_uint256(self.hash)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CInv(type=%s hash=%064x)\" \\\n+            % (self.typemap[self.type], self.hash)\n+\n+\n+class CBlockLocator():\n+    def __init__(self):\n+        self.nVersion = MY_VERSION\n+        self.vHave = []\n+\n+    def deserialize(self, f):\n+        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n+        self.vHave = deser_uint256_vector(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<i\", self.nVersion)\n+        r += ser_uint256_vector(self.vHave)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CBlockLocator(nVersion=%i vHave=%s)\" \\\n+            % (self.nVersion, repr(self.vHave))\n+\n+\n+class COutPoint():\n+    def __init__(self, hash=0, n=0):\n+        self.hash = hash\n+        self.n = n\n+\n+    def deserialize(self, f):\n+        self.hash = deser_uint256(f)\n+        self.n = struct.unpack(\"<I\", f.read(4))[0]\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += ser_uint256(self.hash)\n+        r += struct.pack(\"<I\", self.n)\n+        return r\n+\n+    def __repr__(self):\n+        return \"COutPoint(hash=%064x n=%i)\" % (self.hash, self.n)\n+\n+\n+class CTxIn():\n+    def __init__(self, outpoint=None, scriptSig=b\"\", nSequence=0):\n+        if outpoint is None:\n+            self.prevout = COutPoint()\n+        else:\n+            self.prevout = outpoint\n+        self.scriptSig = scriptSig\n+        self.nSequence = nSequence\n+\n+    def deserialize(self, f):\n+        self.prevout = COutPoint()\n+        self.prevout.deserialize(f)\n+        self.scriptSig = deser_string(f)\n+        self.nSequence = struct.unpack(\"<I\", f.read(4))[0]\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += self.prevout.serialize()\n+        r += ser_string(self.scriptSig)\n+        r += struct.pack(\"<I\", self.nSequence)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CTxIn(prevout=%s scriptSig=%s nSequence=%i)\" \\\n+            % (repr(self.prevout), bytes_to_hex_str(self.scriptSig),\n+               self.nSequence)\n+\n+\n+class CTxOut():\n+    def __init__(self, nValue=0, scriptPubKey=b\"\"):\n+        self.nValue = nValue\n+        self.scriptPubKey = scriptPubKey\n+\n+    def deserialize(self, f):\n+        self.nValue = struct.unpack(\"<q\", f.read(8))[0]\n+        self.scriptPubKey = deser_string(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<q\", self.nValue)\n+        r += ser_string(self.scriptPubKey)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CTxOut(nValue=%i.%08i scriptPubKey=%s)\" \\\n+            % (self.nValue // COIN, self.nValue % COIN,\n+               bytes_to_hex_str(self.scriptPubKey))\n+\n+\n+class CScriptWitness():\n+    def __init__(self):\n+        # stack is a vector of strings\n+        self.stack = []\n+\n+    def __repr__(self):\n+        return \"CScriptWitness(%s)\" % \\\n+               (\",\".join([bytes_to_hex_str(x) for x in self.stack]))\n+\n+    def is_null(self):\n+        if self.stack:\n+            return False\n+        return True\n+\n+\n+class CTxInWitness():\n+    def __init__(self):\n+        self.scriptWitness = CScriptWitness()\n+\n+    def deserialize(self, f):\n+        self.scriptWitness.stack = deser_string_vector(f)\n+\n+    def serialize(self):\n+        return ser_string_vector(self.scriptWitness.stack)\n+\n+    def __repr__(self):\n+        return repr(self.scriptWitness)\n+\n+    def is_null(self):\n+        return self.scriptWitness.is_null()\n+\n+\n+class CTxWitness():\n+    def __init__(self):\n+        self.vtxinwit = []\n+\n+    def deserialize(self, f):\n+        for i in range(len(self.vtxinwit)):\n+            self.vtxinwit[i].deserialize(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        # This is different than the usual vector serialization --\n+        # we omit the length of the vector, which is required to be\n+        # the same length as the transaction's vin vector.\n+        for x in self.vtxinwit:\n+            r += x.serialize()\n+        return r\n+\n+    def __repr__(self):\n+        return \"CTxWitness(%s)\" % \\\n+               (';'.join([repr(x) for x in self.vtxinwit]))\n+\n+    def is_null(self):\n+        for x in self.vtxinwit:\n+            if not x.is_null():\n+                return False\n+        return True\n+\n+\n+class CTransaction():\n+    def __init__(self, tx=None):\n+        if tx is None:\n+            self.nVersion = 1\n+            self.vin = []\n+            self.vout = []\n+            self.wit = CTxWitness()\n+            self.nLockTime = 0\n+            self.sha256 = None\n+            self.hash = None\n+        else:\n+            self.nVersion = tx.nVersion\n+            self.vin = copy.deepcopy(tx.vin)\n+            self.vout = copy.deepcopy(tx.vout)\n+            self.nLockTime = tx.nLockTime\n+            self.sha256 = tx.sha256\n+            self.hash = tx.hash\n+            self.wit = copy.deepcopy(tx.wit)\n+\n+    def deserialize(self, f):\n+        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n+        self.vin = deser_vector(f, CTxIn)\n+        flags = 0\n+        if len(self.vin) == 0:\n+            flags = struct.unpack(\"<B\", f.read(1))[0]\n+            # Not sure why flags can't be zero, but this\n+            # matches the implementation in bitcoind\n+            if (flags != 0):\n+                self.vin = deser_vector(f, CTxIn)\n+                self.vout = deser_vector(f, CTxOut)\n+        else:\n+            self.vout = deser_vector(f, CTxOut)\n+        if flags != 0:\n+            self.wit.vtxinwit = [CTxInWitness() for i in range(len(self.vin))]\n+            self.wit.deserialize(f)\n+        self.nLockTime = struct.unpack(\"<I\", f.read(4))[0]\n+        self.sha256 = None\n+        self.hash = None\n+\n+    def serialize_without_witness(self):\n+        r = b\"\"\n+        r += struct.pack(\"<i\", self.nVersion)\n+        r += ser_vector(self.vin)\n+        r += ser_vector(self.vout)\n+        r += struct.pack(\"<I\", self.nLockTime)\n+        return r\n+\n+    # Only serialize with witness when explicitly called for\n+    def serialize_with_witness(self):\n+        flags = 0\n+        if not self.wit.is_null():\n+            flags |= 1\n+        r = b\"\"\n+        r += struct.pack(\"<i\", self.nVersion)\n+        if flags:\n+            dummy = []\n+            r += ser_vector(dummy)\n+            r += struct.pack(\"<B\", flags)\n+        r += ser_vector(self.vin)\n+        r += ser_vector(self.vout)\n+        if flags & 1:\n+            if (len(self.wit.vtxinwit) != len(self.vin)):\n+                # vtxinwit must have the same length as vin\n+                self.wit.vtxinwit = self.wit.vtxinwit[:len(self.vin)]\n+                for i in range(len(self.wit.vtxinwit), len(self.vin)):\n+                    self.wit.vtxinwit.append(CTxInWitness())\n+            r += self.wit.serialize()\n+        r += struct.pack(\"<I\", self.nLockTime)\n+        return r\n+\n+    # Regular serialization is without witness -- must explicitly\n+    # call serialize_with_witness to include witness data.\n+    def serialize(self):\n+        return self.serialize_without_witness()\n+\n+    # Recalculate the txid (transaction hash without witness)\n+    def rehash(self):\n+        self.sha256 = None\n+        self.calc_sha256()\n+\n+    # We will only cache the serialization without witness in\n+    # self.sha256 and self.hash -- those are expected to be the txid.\n+    def calc_sha256(self, with_witness=False):\n+        if with_witness:\n+            # Don't cache the result, just return it\n+            return uint256_from_str(hash256(self.serialize_with_witness()))\n+\n+        if self.sha256 is None:\n+            self.sha256 = uint256_from_str(hash256(self.serialize_without_witness()))\n+        self.hash = encode(hash256(self.serialize())[::-1], 'hex_codec').decode('ascii')\n+\n+    def is_valid(self):\n+        self.calc_sha256()\n+        for tout in self.vout:\n+            if tout.nValue < 0 or tout.nValue > 21000000 * COIN:\n+                return False\n+        return True\n+\n+    def __repr__(self):\n+        return \"CTransaction(nVersion=%i vin=%s vout=%s wit=%s nLockTime=%i)\" \\\n+            % (self.nVersion, repr(self.vin), repr(self.vout), repr(self.wit), self.nLockTime)\n+\n+\n+class CBlockHeader():\n+    def __init__(self, header=None):\n+        if header is None:\n+            self.set_null()\n+        else:\n+            self.nVersion = header.nVersion\n+            self.hashPrevBlock = header.hashPrevBlock\n+            self.hashMerkleRoot = header.hashMerkleRoot\n+            self.nTime = header.nTime\n+            self.nBits = header.nBits\n+            self.nNonce = header.nNonce\n+            self.sha256 = header.sha256\n+            self.hash = header.hash\n+            self.calc_sha256()\n+\n+    def set_null(self):\n+        self.nVersion = 1\n+        self.hashPrevBlock = 0\n+        self.hashMerkleRoot = 0\n+        self.nTime = 0\n+        self.nBits = 0\n+        self.nNonce = 0\n+        self.sha256 = None\n+        self.hash = None\n+\n+    def deserialize(self, f):\n+        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n+        self.hashPrevBlock = deser_uint256(f)\n+        self.hashMerkleRoot = deser_uint256(f)\n+        self.nTime = struct.unpack(\"<I\", f.read(4))[0]\n+        self.nBits = struct.unpack(\"<I\", f.read(4))[0]\n+        self.nNonce = struct.unpack(\"<I\", f.read(4))[0]\n+        self.sha256 = None\n+        self.hash = None\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<i\", self.nVersion)\n+        r += ser_uint256(self.hashPrevBlock)\n+        r += ser_uint256(self.hashMerkleRoot)\n+        r += struct.pack(\"<I\", self.nTime)\n+        r += struct.pack(\"<I\", self.nBits)\n+        r += struct.pack(\"<I\", self.nNonce)\n+        return r\n+\n+    def calc_sha256(self):\n+        if self.sha256 is None:\n+            r = b\"\"\n+            r += struct.pack(\"<i\", self.nVersion)\n+            r += ser_uint256(self.hashPrevBlock)\n+            r += ser_uint256(self.hashMerkleRoot)\n+            r += struct.pack(\"<I\", self.nTime)\n+            r += struct.pack(\"<I\", self.nBits)\n+            r += struct.pack(\"<I\", self.nNonce)\n+            self.sha256 = uint256_from_str(hash256(r))\n+            self.hash = encode(hash256(r)[::-1], 'hex_codec').decode('ascii')\n+\n+    def rehash(self):\n+        self.sha256 = None\n+        self.calc_sha256()\n+        return self.sha256\n+\n+    def __repr__(self):\n+        return \"CBlockHeader(nVersion=%i hashPrevBlock=%064x hashMerkleRoot=%064x nTime=%s nBits=%08x nNonce=%08x)\" \\\n+            % (self.nVersion, self.hashPrevBlock, self.hashMerkleRoot,\n+               time.ctime(self.nTime), self.nBits, self.nNonce)\n+\n+\n+class CBlock(CBlockHeader):\n+    def __init__(self, header=None):\n+        super(CBlock, self).__init__(header)\n+        self.vtx = []\n+\n+    def deserialize(self, f):\n+        super(CBlock, self).deserialize(f)\n+        self.vtx = deser_vector(f, CTransaction)\n+\n+    def serialize(self, with_witness=False):\n+        r = b\"\"\n+        r += super(CBlock, self).serialize()\n+        if with_witness:\n+            r += ser_vector(self.vtx, \"serialize_with_witness\")\n+        else:\n+            r += ser_vector(self.vtx)\n+        return r\n+\n+    # Calculate the merkle root given a vector of transaction hashes\n+    @classmethod\n+    def get_merkle_root(cls, hashes):\n+        while len(hashes) > 1:\n+            newhashes = []\n+            for i in range(0, len(hashes), 2):\n+                i2 = min(i+1, len(hashes)-1)\n+                newhashes.append(hash256(hashes[i] + hashes[i2]))\n+            hashes = newhashes\n+        return uint256_from_str(hashes[0])\n+\n+    def calc_merkle_root(self):\n+        hashes = []\n+        for tx in self.vtx:\n+            tx.calc_sha256()\n+            hashes.append(ser_uint256(tx.sha256))\n+        return self.get_merkle_root(hashes)\n+\n+    def calc_witness_merkle_root(self):\n+        # For witness root purposes, the hash of the\n+        # coinbase, with witness, is defined to be 0...0\n+        hashes = [ser_uint256(0)]\n+\n+        for tx in self.vtx[1:]:\n+            # Calculate the hashes with witness data\n+            hashes.append(ser_uint256(tx.calc_sha256(True)))\n+\n+        return self.get_merkle_root(hashes)\n+\n+    def is_valid(self):\n+        self.calc_sha256()\n+        target = uint256_from_compact(self.nBits)\n+        if self.sha256 > target:\n+            return False\n+        for tx in self.vtx:\n+            if not tx.is_valid():\n+                return False\n+        if self.calc_merkle_root() != self.hashMerkleRoot:\n+            return False\n+        return True\n+\n+    def solve(self):\n+        self.rehash()\n+        target = uint256_from_compact(self.nBits)\n+        while self.sha256 > target:\n+            self.nNonce += 1\n+            self.rehash()\n+\n+    def __repr__(self):\n+        return \"CBlock(nVersion=%i hashPrevBlock=%064x hashMerkleRoot=%064x nTime=%s nBits=%08x nNonce=%08x vtx=%s)\" \\\n+            % (self.nVersion, self.hashPrevBlock, self.hashMerkleRoot,\n+               time.ctime(self.nTime), self.nBits, self.nNonce, repr(self.vtx))\n+\n+\n+class PrefilledTransaction():\n+    def __init__(self, index=0, tx = None):\n+        self.index = index\n+        self.tx = tx\n+\n+    def deserialize(self, f):\n+        self.index = deser_compact_size(f)\n+        self.tx = CTransaction()\n+        self.tx.deserialize(f)\n+\n+    def serialize(self, with_witness=False):\n+        r = b\"\"\n+        r += ser_compact_size(self.index)\n+        if with_witness:\n+            r += self.tx.serialize_with_witness()\n+        else:\n+            r += self.tx.serialize_without_witness()\n+        return r\n+\n+    def serialize_with_witness(self):\n+        return self.serialize(with_witness=True)\n+\n+    def __repr__(self):\n+        return \"PrefilledTransaction(index=%d, tx=%s)\" % (self.index, repr(self.tx))\n+\n+# This is what we send on the wire, in a cmpctblock message.\n+class P2PHeaderAndShortIDs():\n+    def __init__(self):\n+        self.header = CBlockHeader()\n+        self.nonce = 0\n+        self.shortids_length = 0\n+        self.shortids = []\n+        self.prefilled_txn_length = 0\n+        self.prefilled_txn = []\n+\n+    def deserialize(self, f):\n+        self.header.deserialize(f)\n+        self.nonce = struct.unpack(\"<Q\", f.read(8))[0]\n+        self.shortids_length = deser_compact_size(f)\n+        for i in range(self.shortids_length):\n+            # shortids are defined to be 6 bytes in the spec, so append\n+            # two zero bytes and read it in as an 8-byte number\n+            self.shortids.append(struct.unpack(\"<Q\", f.read(6) + b'\\x00\\x00')[0])\n+        self.prefilled_txn = deser_vector(f, PrefilledTransaction)\n+        self.prefilled_txn_length = len(self.prefilled_txn)\n+\n+    # When using version 2 compact blocks, we must serialize with_witness.\n+    def serialize(self, with_witness=False):\n+        r = b\"\"\n+        r += self.header.serialize()\n+        r += struct.pack(\"<Q\", self.nonce)\n+        r += ser_compact_size(self.shortids_length)\n+        for x in self.shortids:\n+            # We only want the first 6 bytes\n+            r += struct.pack(\"<Q\", x)[0:6]\n+        if with_witness:\n+            r += ser_vector(self.prefilled_txn, \"serialize_with_witness\")\n+        else:\n+            r += ser_vector(self.prefilled_txn)\n+        return r\n+\n+    def __repr__(self):\n+        return \"P2PHeaderAndShortIDs(header=%s, nonce=%d, shortids_length=%d, shortids=%s, prefilled_txn_length=%d, prefilledtxn=%s\" % (repr(self.header), self.nonce, self.shortids_length, repr(self.shortids), self.prefilled_txn_length, repr(self.prefilled_txn))\n+\n+# P2P version of the above that will use witness serialization (for compact\n+# block version 2)\n+class P2PHeaderAndShortWitnessIDs(P2PHeaderAndShortIDs):\n+    def serialize(self):\n+        return super(P2PHeaderAndShortWitnessIDs, self).serialize(with_witness=True)\n+\n+# Calculate the BIP 152-compact blocks shortid for a given transaction hash\n+def calculate_shortid(k0, k1, tx_hash):\n+    expected_shortid = siphash256(k0, k1, tx_hash)\n+    expected_shortid &= 0x0000ffffffffffff\n+    return expected_shortid\n+\n+# This version gets rid of the array lengths, and reinterprets the differential\n+# encoding into indices that can be used for lookup.\n+class HeaderAndShortIDs():\n+    def __init__(self, p2pheaders_and_shortids = None):\n+        self.header = CBlockHeader()\n+        self.nonce = 0\n+        self.shortids = []\n+        self.prefilled_txn = []\n+        self.use_witness = False\n+\n+        if p2pheaders_and_shortids != None:\n+            self.header = p2pheaders_and_shortids.header\n+            self.nonce = p2pheaders_and_shortids.nonce\n+            self.shortids = p2pheaders_and_shortids.shortids\n+            last_index = -1\n+            for x in p2pheaders_and_shortids.prefilled_txn:\n+                self.prefilled_txn.append(PrefilledTransaction(x.index + last_index + 1, x.tx))\n+                last_index = self.prefilled_txn[-1].index\n+\n+    def to_p2p(self):\n+        if self.use_witness:\n+            ret = P2PHeaderAndShortWitnessIDs()\n+        else:\n+            ret = P2PHeaderAndShortIDs()\n+        ret.header = self.header\n+        ret.nonce = self.nonce\n+        ret.shortids_length = len(self.shortids)\n+        ret.shortids = self.shortids\n+        ret.prefilled_txn_length = len(self.prefilled_txn)\n+        ret.prefilled_txn = []\n+        last_index = -1\n+        for x in self.prefilled_txn:\n+            ret.prefilled_txn.append(PrefilledTransaction(x.index - last_index - 1, x.tx))\n+            last_index = x.index\n+        return ret\n+\n+    def get_siphash_keys(self):\n+        header_nonce = self.header.serialize()\n+        header_nonce += struct.pack(\"<Q\", self.nonce)\n+        hash_header_nonce_as_str = sha256(header_nonce)\n+        key0 = struct.unpack(\"<Q\", hash_header_nonce_as_str[0:8])[0]\n+        key1 = struct.unpack(\"<Q\", hash_header_nonce_as_str[8:16])[0]\n+        return [ key0, key1 ]\n+\n+    # Version 2 compact blocks use wtxid in shortids (rather than txid)\n+    def initialize_from_block(self, block, nonce=0, prefill_list = [0], use_witness = False):\n+        self.header = CBlockHeader(block)\n+        self.nonce = nonce\n+        self.prefilled_txn = [ PrefilledTransaction(i, block.vtx[i]) for i in prefill_list ]\n+        self.shortids = []\n+        self.use_witness = use_witness\n+        [k0, k1] = self.get_siphash_keys()\n+        for i in range(len(block.vtx)):\n+            if i not in prefill_list:\n+                tx_hash = block.vtx[i].sha256\n+                if use_witness:\n+                    tx_hash = block.vtx[i].calc_sha256(with_witness=True)\n+                self.shortids.append(calculate_shortid(k0, k1, tx_hash))\n+\n+    def __repr__(self):\n+        return \"HeaderAndShortIDs(header=%s, nonce=%d, shortids=%s, prefilledtxn=%s\" % (repr(self.header), self.nonce, repr(self.shortids), repr(self.prefilled_txn))\n+\n+\n+class BlockTransactionsRequest():\n+\n+    def __init__(self, blockhash=0, indexes = None):\n+        self.blockhash = blockhash\n+        self.indexes = indexes if indexes != None else []\n+\n+    def deserialize(self, f):\n+        self.blockhash = deser_uint256(f)\n+        indexes_length = deser_compact_size(f)\n+        for i in range(indexes_length):\n+            self.indexes.append(deser_compact_size(f))\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += ser_uint256(self.blockhash)\n+        r += ser_compact_size(len(self.indexes))\n+        for x in self.indexes:\n+            r += ser_compact_size(x)\n+        return r\n+\n+    # helper to set the differentially encoded indexes from absolute ones\n+    def from_absolute(self, absolute_indexes):\n+        self.indexes = []\n+        last_index = -1\n+        for x in absolute_indexes:\n+            self.indexes.append(x-last_index-1)\n+            last_index = x\n+\n+    def to_absolute(self):\n+        absolute_indexes = []\n+        last_index = -1\n+        for x in self.indexes:\n+            absolute_indexes.append(x+last_index+1)\n+            last_index = absolute_indexes[-1]\n+        return absolute_indexes\n+\n+    def __repr__(self):\n+        return \"BlockTransactionsRequest(hash=%064x indexes=%s)\" % (self.blockhash, repr(self.indexes))\n+\n+\n+class BlockTransactions():\n+\n+    def __init__(self, blockhash=0, transactions = None):\n+        self.blockhash = blockhash\n+        self.transactions = transactions if transactions != None else []\n+\n+    def deserialize(self, f):\n+        self.blockhash = deser_uint256(f)\n+        self.transactions = deser_vector(f, CTransaction)\n+\n+    def serialize(self, with_witness=False):\n+        r = b\"\"\n+        r += ser_uint256(self.blockhash)\n+        if with_witness:\n+            r += ser_vector(self.transactions, \"serialize_with_witness\")\n+        else:\n+            r += ser_vector(self.transactions)\n+        return r\n+\n+    def __repr__(self):\n+        return \"BlockTransactions(hash=%064x transactions=%s)\" % (self.blockhash, repr(self.transactions))\n+\n+\n+# Objects that correspond to messages on the wire\n+class msg_version():\n+    command = b\"version\"\n+\n+    def __init__(self):\n+        self.nVersion = MY_VERSION\n+        self.nServices = NODE_NETWORK | NODE_WITNESS\n+        self.nTime = int(time.time())\n+        self.addrTo = CAddress()\n+        self.addrFrom = CAddress()\n+        self.nNonce = random.getrandbits(64)\n+        self.strSubVer = MY_SUBVERSION\n+        self.nStartingHeight = -1\n+        self.nRelay = MY_RELAY\n+\n+    def deserialize(self, f):\n+        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n+        if self.nVersion == 10300:\n+            self.nVersion = 300\n+        self.nServices = struct.unpack(\"<Q\", f.read(8))[0]\n+        self.nTime = struct.unpack(\"<q\", f.read(8))[0]\n+        self.addrTo = CAddress()\n+        self.addrTo.deserialize(f)\n+\n+        if self.nVersion >= 106:\n+            self.addrFrom = CAddress()\n+            self.addrFrom.deserialize(f)\n+            self.nNonce = struct.unpack(\"<Q\", f.read(8))[0]\n+            self.strSubVer = deser_string(f)\n+        else:\n+            self.addrFrom = None\n+            self.nNonce = None\n+            self.strSubVer = None\n+            self.nStartingHeight = None\n+\n+        if self.nVersion >= 209:\n+            self.nStartingHeight = struct.unpack(\"<i\", f.read(4))[0]\n+        else:\n+            self.nStartingHeight = None\n+\n+        if self.nVersion >= 70001:\n+            # Relay field is optional for version 70001 onwards\n+            try:\n+                self.nRelay = struct.unpack(\"<b\", f.read(1))[0]\n+            except:\n+                self.nRelay = 0\n+        else:\n+            self.nRelay = 0\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<i\", self.nVersion)\n+        r += struct.pack(\"<Q\", self.nServices)\n+        r += struct.pack(\"<q\", self.nTime)\n+        r += self.addrTo.serialize()\n+        r += self.addrFrom.serialize()\n+        r += struct.pack(\"<Q\", self.nNonce)\n+        r += ser_string(self.strSubVer)\n+        r += struct.pack(\"<i\", self.nStartingHeight)\n+        r += struct.pack(\"<b\", self.nRelay)\n+        return r\n+\n+    def __repr__(self):\n+        return 'msg_version(nVersion=%i nServices=%i nTime=%s addrTo=%s addrFrom=%s nNonce=0x%016X strSubVer=%s nStartingHeight=%i nRelay=%i)' \\\n+            % (self.nVersion, self.nServices, time.ctime(self.nTime),\n+               repr(self.addrTo), repr(self.addrFrom), self.nNonce,\n+               self.strSubVer, self.nStartingHeight, self.nRelay)\n+\n+\n+class msg_verack():\n+    command = b\"verack\"\n+\n+    def __init__(self):\n+        pass\n+\n+    def deserialize(self, f):\n+        pass\n+\n+    def serialize(self):\n+        return b\"\"\n+\n+    def __repr__(self):\n+        return \"msg_verack()\"\n+\n+\n+class msg_addr():\n+    command = b\"addr\"\n+\n+    def __init__(self):\n+        self.addrs = []\n+\n+    def deserialize(self, f):\n+        self.addrs = deser_vector(f, CAddress)\n+\n+    def serialize(self):\n+        return ser_vector(self.addrs)\n+\n+    def __repr__(self):\n+        return \"msg_addr(addrs=%s)\" % (repr(self.addrs))\n+\n+\n+class msg_inv():\n+    command = b\"inv\"\n+\n+    def __init__(self, inv=None):\n+        if inv is None:\n+            self.inv = []\n+        else:\n+            self.inv = inv\n+\n+    def deserialize(self, f):\n+        self.inv = deser_vector(f, CInv)\n+\n+    def serialize(self):\n+        return ser_vector(self.inv)\n+\n+    def __repr__(self):\n+        return \"msg_inv(inv=%s)\" % (repr(self.inv))\n+\n+\n+class msg_getdata():\n+    command = b\"getdata\"\n+\n+    def __init__(self, inv=None):\n+        self.inv = inv if inv != None else []\n+\n+    def deserialize(self, f):\n+        self.inv = deser_vector(f, CInv)\n+\n+    def serialize(self):\n+        return ser_vector(self.inv)\n+\n+    def __repr__(self):\n+        return \"msg_getdata(inv=%s)\" % (repr(self.inv))\n+\n+\n+class msg_getblocks():\n+    command = b\"getblocks\"\n+\n+    def __init__(self):\n+        self.locator = CBlockLocator()\n+        self.hashstop = 0\n+\n+    def deserialize(self, f):\n+        self.locator = CBlockLocator()\n+        self.locator.deserialize(f)\n+        self.hashstop = deser_uint256(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += self.locator.serialize()\n+        r += ser_uint256(self.hashstop)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_getblocks(locator=%s hashstop=%064x)\" \\\n+            % (repr(self.locator), self.hashstop)\n+\n+\n+class msg_tx():\n+    command = b\"tx\"\n+\n+    def __init__(self, tx=CTransaction()):\n+        self.tx = tx\n+\n+    def deserialize(self, f):\n+        self.tx.deserialize(f)\n+\n+    def serialize(self):\n+        return self.tx.serialize_without_witness()\n+\n+    def __repr__(self):\n+        return \"msg_tx(tx=%s)\" % (repr(self.tx))\n+\n+class msg_witness_tx(msg_tx):\n+\n+    def serialize(self):\n+        return self.tx.serialize_with_witness()\n+\n+\n+class msg_block():\n+    command = b\"block\"\n+\n+    def __init__(self, block=None):\n+        if block is None:\n+            self.block = CBlock()\n+        else:\n+            self.block = block\n+\n+    def deserialize(self, f):\n+        self.block.deserialize(f)\n+\n+    def serialize(self):\n+        return self.block.serialize()\n+\n+    def __repr__(self):\n+        return \"msg_block(block=%s)\" % (repr(self.block))\n+\n+# for cases where a user needs tighter control over what is sent over the wire\n+# note that the user must supply the name of the command, and the data\n+class msg_generic():\n+    def __init__(self, command, data=None):\n+        self.command = command\n+        self.data = data\n+\n+    def serialize(self):\n+        return self.data\n+\n+    def __repr__(self):\n+        return \"msg_generic()\"\n+\n+class msg_witness_block(msg_block):\n+\n+    def serialize(self):\n+        r = self.block.serialize(with_witness=True)\n+        return r\n+\n+class msg_getaddr():\n+    command = b\"getaddr\"\n+\n+    def __init__(self):\n+        pass\n+\n+    def deserialize(self, f):\n+        pass\n+\n+    def serialize(self):\n+        return b\"\"\n+\n+    def __repr__(self):\n+        return \"msg_getaddr()\"\n+\n+\n+class msg_ping():\n+    command = b\"ping\"\n+\n+    def __init__(self, nonce=0):\n+        self.nonce = nonce\n+\n+    def deserialize(self, f):\n+        self.nonce = struct.unpack(\"<Q\", f.read(8))[0]\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<Q\", self.nonce)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_ping(nonce=%08x)\" % self.nonce\n+\n+\n+class msg_pong():\n+    command = b\"pong\"\n+\n+    def __init__(self, nonce=0):\n+        self.nonce = nonce\n+\n+    def deserialize(self, f):\n+        self.nonce = struct.unpack(\"<Q\", f.read(8))[0]\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<Q\", self.nonce)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_pong(nonce=%08x)\" % self.nonce\n+\n+\n+class msg_mempool():\n+    command = b\"mempool\"\n+\n+    def __init__(self):\n+        pass\n+\n+    def deserialize(self, f):\n+        pass\n+\n+    def serialize(self):\n+        return b\"\"\n+\n+    def __repr__(self):\n+        return \"msg_mempool()\"\n+\n+class msg_sendheaders():\n+    command = b\"sendheaders\"\n+\n+    def __init__(self):\n+        pass\n+\n+    def deserialize(self, f):\n+        pass\n+\n+    def serialize(self):\n+        return b\"\"\n+\n+    def __repr__(self):\n+        return \"msg_sendheaders()\"\n+\n+\n+# getheaders message has\n+# number of entries\n+# vector of hashes\n+# hash_stop (hash of last desired block header, 0 to get as many as possible)\n+class msg_getheaders():\n+    command = b\"getheaders\"\n+\n+    def __init__(self):\n+        self.locator = CBlockLocator()\n+        self.hashstop = 0\n+\n+    def deserialize(self, f):\n+        self.locator = CBlockLocator()\n+        self.locator.deserialize(f)\n+        self.hashstop = deser_uint256(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += self.locator.serialize()\n+        r += ser_uint256(self.hashstop)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_getheaders(locator=%s, stop=%064x)\" \\\n+            % (repr(self.locator), self.hashstop)\n+\n+\n+# headers message has\n+# <count> <vector of block headers>\n+class msg_headers():\n+    command = b\"headers\"\n+\n+    def __init__(self, headers=None):\n+        self.headers = headers if headers is not None else []\n+\n+    def deserialize(self, f):\n+        # comment in bitcoind indicates these should be deserialized as blocks\n+        blocks = deser_vector(f, CBlock)\n+        for x in blocks:\n+            self.headers.append(CBlockHeader(x))\n+\n+    def serialize(self):\n+        blocks = [CBlock(x) for x in self.headers]\n+        return ser_vector(blocks)\n+\n+    def __repr__(self):\n+        return \"msg_headers(headers=%s)\" % repr(self.headers)\n+\n+\n+class msg_reject():\n+    command = b\"reject\"\n+    REJECT_MALFORMED = 1\n+\n+    def __init__(self):\n+        self.message = b\"\"\n+        self.code = 0\n+        self.reason = b\"\"\n+        self.data = 0\n+\n+    def deserialize(self, f):\n+        self.message = deser_string(f)\n+        self.code = struct.unpack(\"<B\", f.read(1))[0]\n+        self.reason = deser_string(f)\n+        if (self.code != self.REJECT_MALFORMED and\n+                (self.message == b\"block\" or self.message == b\"tx\")):\n+            self.data = deser_uint256(f)\n+\n+    def serialize(self):\n+        r = ser_string(self.message)\n+        r += struct.pack(\"<B\", self.code)\n+        r += ser_string(self.reason)\n+        if (self.code != self.REJECT_MALFORMED and\n+                (self.message == b\"block\" or self.message == b\"tx\")):\n+            r += ser_uint256(self.data)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_reject: %s %d %s [%064x]\" \\\n+            % (self.message, self.code, self.reason, self.data)\n+\n+class msg_feefilter():\n+    command = b\"feefilter\"\n+\n+    def __init__(self, feerate=0):\n+        self.feerate = feerate\n+\n+    def deserialize(self, f):\n+        self.feerate = struct.unpack(\"<Q\", f.read(8))[0]\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<Q\", self.feerate)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_feefilter(feerate=%08x)\" % self.feerate\n+\n+class msg_sendcmpct():\n+    command = b\"sendcmpct\"\n+\n+    def __init__(self):\n+        self.announce = False\n+        self.version = 1\n+\n+    def deserialize(self, f):\n+        self.announce = struct.unpack(\"<?\", f.read(1))[0]\n+        self.version = struct.unpack(\"<Q\", f.read(8))[0]\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<?\", self.announce)\n+        r += struct.pack(\"<Q\", self.version)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_sendcmpct(announce=%s, version=%lu)\" % (self.announce, self.version)\n+\n+class msg_cmpctblock():\n+    command = b\"cmpctblock\"\n+\n+    def __init__(self, header_and_shortids = None):\n+        self.header_and_shortids = header_and_shortids\n+\n+    def deserialize(self, f):\n+        self.header_and_shortids = P2PHeaderAndShortIDs()\n+        self.header_and_shortids.deserialize(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += self.header_and_shortids.serialize()\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_cmpctblock(HeaderAndShortIDs=%s)\" % repr(self.header_and_shortids)\n+\n+class msg_getblocktxn():\n+    command = b\"getblocktxn\"\n+\n+    def __init__(self):\n+        self.block_txn_request = None\n+\n+    def deserialize(self, f):\n+        self.block_txn_request = BlockTransactionsRequest()\n+        self.block_txn_request.deserialize(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += self.block_txn_request.serialize()\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_getblocktxn(block_txn_request=%s)\" % (repr(self.block_txn_request))\n+\n+class msg_blocktxn():\n+    command = b\"blocktxn\"\n+\n+    def __init__(self):\n+        self.block_transactions = BlockTransactions()\n+\n+    def deserialize(self, f):\n+        self.block_transactions.deserialize(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += self.block_transactions.serialize()\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_blocktxn(block_transactions=%s)\" % (repr(self.block_transactions))\n+\n+class msg_witness_blocktxn(msg_blocktxn):\n+    def serialize(self):\n+        r = b\"\"\n+        r += self.block_transactions.serialize(with_witness=True)\n+        return r"
      },
      {
        "sha": "2a1ac2d7055d967ae5e1399e40faecfdb5b0e6cc",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1305,
        "changes": 1306,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f9cd9b1bfaf65b4e24c1eb9ca8268513e78cc458/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f9cd9b1bfaf65b4e24c1eb9ca8268513e78cc458/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=f9cd9b1bfaf65b4e24c1eb9ca8268513e78cc458",
        "patch": "@@ -12,47 +12,18 @@\n NodeConn: an object which manages p2p connectivity to a bitcoin node\n NodeConnCB: a base class that describes the interface for receiving\n             callbacks with network messages from a NodeConn\n-CBlock, CTransaction, CBlockHeader, CTxIn, CTxOut, etc....:\n-    data structures that should map to corresponding structures in\n-    bitcoin/primitives\n-msg_block, msg_tx, msg_headers, etc.:\n-    data structures that represent network messages\n-ser_*, deser_*: functions that handle serialization/deserialization\n \"\"\"\n-\n import asyncore\n-from codecs import encode\n from collections import defaultdict\n-import copy\n-import hashlib\n from io import BytesIO\n import logging\n-import random\n import socket\n import struct\n import sys\n import time\n from threading import RLock, Thread\n \n-from test_framework.siphash import siphash256\n-from test_framework.util import hex_str_to_bytes, bytes_to_hex_str, wait_until\n-\n-MIN_VERSION_SUPPORTED = 60001\n-MY_VERSION = 70014  # past bip-31 for ping/pong\n-MY_SUBVERSION = b\"/python-mininode-tester:0.0.3/\"\n-MY_RELAY = 1 # from version 70001 onwards, fRelay should be appended to version messages (BIP37)\n-\n-MAX_INV_SZ = 50000\n-MAX_BLOCK_BASE_SIZE = 1000000\n-\n-COIN = 100000000 # 1 btc in satoshis\n-\n-NODE_NETWORK = (1 << 0)\n-# NODE_GETUTXO = (1 << 1)\n-# NODE_BLOOM = (1 << 2)\n-NODE_WITNESS = (1 << 3)\n-NODE_UNSUPPORTED_SERVICE_BIT_5 = (1 << 5)\n-NODE_UNSUPPORTED_SERVICE_BIT_7 = (1 << 7)\n+from test_framework.messages import *\n \n logger = logging.getLogger(\"TestFramework.mininode\")\n \n@@ -69,1281 +40,6 @@\n # access to any data shared with the NodeConnCB or NodeConn.\n mininode_lock = RLock()\n \n-# Serialization/deserialization tools\n-def sha256(s):\n-    return hashlib.new('sha256', s).digest()\n-\n-def ripemd160(s):\n-    return hashlib.new('ripemd160', s).digest()\n-\n-def hash256(s):\n-    return sha256(sha256(s))\n-\n-def ser_compact_size(l):\n-    r = b\"\"\n-    if l < 253:\n-        r = struct.pack(\"B\", l)\n-    elif l < 0x10000:\n-        r = struct.pack(\"<BH\", 253, l)\n-    elif l < 0x100000000:\n-        r = struct.pack(\"<BI\", 254, l)\n-    else:\n-        r = struct.pack(\"<BQ\", 255, l)\n-    return r\n-\n-def deser_compact_size(f):\n-    nit = struct.unpack(\"<B\", f.read(1))[0]\n-    if nit == 253:\n-        nit = struct.unpack(\"<H\", f.read(2))[0]\n-    elif nit == 254:\n-        nit = struct.unpack(\"<I\", f.read(4))[0]\n-    elif nit == 255:\n-        nit = struct.unpack(\"<Q\", f.read(8))[0]\n-    return nit\n-\n-def deser_string(f):\n-    nit = deser_compact_size(f)\n-    return f.read(nit)\n-\n-def ser_string(s):\n-    return ser_compact_size(len(s)) + s\n-\n-def deser_uint256(f):\n-    r = 0\n-    for i in range(8):\n-        t = struct.unpack(\"<I\", f.read(4))[0]\n-        r += t << (i * 32)\n-    return r\n-\n-\n-def ser_uint256(u):\n-    rs = b\"\"\n-    for i in range(8):\n-        rs += struct.pack(\"<I\", u & 0xFFFFFFFF)\n-        u >>= 32\n-    return rs\n-\n-\n-def uint256_from_str(s):\n-    r = 0\n-    t = struct.unpack(\"<IIIIIIII\", s[:32])\n-    for i in range(8):\n-        r += t[i] << (i * 32)\n-    return r\n-\n-\n-def uint256_from_compact(c):\n-    nbytes = (c >> 24) & 0xFF\n-    v = (c & 0xFFFFFF) << (8 * (nbytes - 3))\n-    return v\n-\n-\n-def deser_vector(f, c):\n-    nit = deser_compact_size(f)\n-    r = []\n-    for i in range(nit):\n-        t = c()\n-        t.deserialize(f)\n-        r.append(t)\n-    return r\n-\n-\n-# ser_function_name: Allow for an alternate serialization function on the\n-# entries in the vector (we use this for serializing the vector of transactions\n-# for a witness block).\n-def ser_vector(l, ser_function_name=None):\n-    r = ser_compact_size(len(l))\n-    for i in l:\n-        if ser_function_name:\n-            r += getattr(i, ser_function_name)()\n-        else:\n-            r += i.serialize()\n-    return r\n-\n-\n-def deser_uint256_vector(f):\n-    nit = deser_compact_size(f)\n-    r = []\n-    for i in range(nit):\n-        t = deser_uint256(f)\n-        r.append(t)\n-    return r\n-\n-\n-def ser_uint256_vector(l):\n-    r = ser_compact_size(len(l))\n-    for i in l:\n-        r += ser_uint256(i)\n-    return r\n-\n-\n-def deser_string_vector(f):\n-    nit = deser_compact_size(f)\n-    r = []\n-    for i in range(nit):\n-        t = deser_string(f)\n-        r.append(t)\n-    return r\n-\n-\n-def ser_string_vector(l):\n-    r = ser_compact_size(len(l))\n-    for sv in l:\n-        r += ser_string(sv)\n-    return r\n-\n-\n-def deser_int_vector(f):\n-    nit = deser_compact_size(f)\n-    r = []\n-    for i in range(nit):\n-        t = struct.unpack(\"<i\", f.read(4))[0]\n-        r.append(t)\n-    return r\n-\n-\n-def ser_int_vector(l):\n-    r = ser_compact_size(len(l))\n-    for i in l:\n-        r += struct.pack(\"<i\", i)\n-    return r\n-\n-# Deserialize from a hex string representation (eg from RPC)\n-def FromHex(obj, hex_string):\n-    obj.deserialize(BytesIO(hex_str_to_bytes(hex_string)))\n-    return obj\n-\n-# Convert a binary-serializable object to hex (eg for submission via RPC)\n-def ToHex(obj):\n-    return bytes_to_hex_str(obj.serialize())\n-\n-# Objects that map to bitcoind objects, which can be serialized/deserialized\n-\n-class CAddress():\n-    def __init__(self):\n-        self.nServices = 1\n-        self.pchReserved = b\"\\x00\" * 10 + b\"\\xff\" * 2\n-        self.ip = \"0.0.0.0\"\n-        self.port = 0\n-\n-    def deserialize(self, f):\n-        self.nServices = struct.unpack(\"<Q\", f.read(8))[0]\n-        self.pchReserved = f.read(12)\n-        self.ip = socket.inet_ntoa(f.read(4))\n-        self.port = struct.unpack(\">H\", f.read(2))[0]\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += struct.pack(\"<Q\", self.nServices)\n-        r += self.pchReserved\n-        r += socket.inet_aton(self.ip)\n-        r += struct.pack(\">H\", self.port)\n-        return r\n-\n-    def __repr__(self):\n-        return \"CAddress(nServices=%i ip=%s port=%i)\" % (self.nServices,\n-                                                         self.ip, self.port)\n-\n-MSG_WITNESS_FLAG = 1<<30\n-\n-class CInv():\n-    typemap = {\n-        0: \"Error\",\n-        1: \"TX\",\n-        2: \"Block\",\n-        1|MSG_WITNESS_FLAG: \"WitnessTx\",\n-        2|MSG_WITNESS_FLAG : \"WitnessBlock\",\n-        4: \"CompactBlock\"\n-    }\n-\n-    def __init__(self, t=0, h=0):\n-        self.type = t\n-        self.hash = h\n-\n-    def deserialize(self, f):\n-        self.type = struct.unpack(\"<i\", f.read(4))[0]\n-        self.hash = deser_uint256(f)\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += struct.pack(\"<i\", self.type)\n-        r += ser_uint256(self.hash)\n-        return r\n-\n-    def __repr__(self):\n-        return \"CInv(type=%s hash=%064x)\" \\\n-            % (self.typemap[self.type], self.hash)\n-\n-\n-class CBlockLocator():\n-    def __init__(self):\n-        self.nVersion = MY_VERSION\n-        self.vHave = []\n-\n-    def deserialize(self, f):\n-        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n-        self.vHave = deser_uint256_vector(f)\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += struct.pack(\"<i\", self.nVersion)\n-        r += ser_uint256_vector(self.vHave)\n-        return r\n-\n-    def __repr__(self):\n-        return \"CBlockLocator(nVersion=%i vHave=%s)\" \\\n-            % (self.nVersion, repr(self.vHave))\n-\n-\n-class COutPoint():\n-    def __init__(self, hash=0, n=0):\n-        self.hash = hash\n-        self.n = n\n-\n-    def deserialize(self, f):\n-        self.hash = deser_uint256(f)\n-        self.n = struct.unpack(\"<I\", f.read(4))[0]\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += ser_uint256(self.hash)\n-        r += struct.pack(\"<I\", self.n)\n-        return r\n-\n-    def __repr__(self):\n-        return \"COutPoint(hash=%064x n=%i)\" % (self.hash, self.n)\n-\n-\n-class CTxIn():\n-    def __init__(self, outpoint=None, scriptSig=b\"\", nSequence=0):\n-        if outpoint is None:\n-            self.prevout = COutPoint()\n-        else:\n-            self.prevout = outpoint\n-        self.scriptSig = scriptSig\n-        self.nSequence = nSequence\n-\n-    def deserialize(self, f):\n-        self.prevout = COutPoint()\n-        self.prevout.deserialize(f)\n-        self.scriptSig = deser_string(f)\n-        self.nSequence = struct.unpack(\"<I\", f.read(4))[0]\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += self.prevout.serialize()\n-        r += ser_string(self.scriptSig)\n-        r += struct.pack(\"<I\", self.nSequence)\n-        return r\n-\n-    def __repr__(self):\n-        return \"CTxIn(prevout=%s scriptSig=%s nSequence=%i)\" \\\n-            % (repr(self.prevout), bytes_to_hex_str(self.scriptSig),\n-               self.nSequence)\n-\n-\n-class CTxOut():\n-    def __init__(self, nValue=0, scriptPubKey=b\"\"):\n-        self.nValue = nValue\n-        self.scriptPubKey = scriptPubKey\n-\n-    def deserialize(self, f):\n-        self.nValue = struct.unpack(\"<q\", f.read(8))[0]\n-        self.scriptPubKey = deser_string(f)\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += struct.pack(\"<q\", self.nValue)\n-        r += ser_string(self.scriptPubKey)\n-        return r\n-\n-    def __repr__(self):\n-        return \"CTxOut(nValue=%i.%08i scriptPubKey=%s)\" \\\n-            % (self.nValue // COIN, self.nValue % COIN,\n-               bytes_to_hex_str(self.scriptPubKey))\n-\n-\n-class CScriptWitness():\n-    def __init__(self):\n-        # stack is a vector of strings\n-        self.stack = []\n-\n-    def __repr__(self):\n-        return \"CScriptWitness(%s)\" % \\\n-               (\",\".join([bytes_to_hex_str(x) for x in self.stack]))\n-\n-    def is_null(self):\n-        if self.stack:\n-            return False\n-        return True\n-\n-\n-class CTxInWitness():\n-    def __init__(self):\n-        self.scriptWitness = CScriptWitness()\n-\n-    def deserialize(self, f):\n-        self.scriptWitness.stack = deser_string_vector(f)\n-\n-    def serialize(self):\n-        return ser_string_vector(self.scriptWitness.stack)\n-\n-    def __repr__(self):\n-        return repr(self.scriptWitness)\n-\n-    def is_null(self):\n-        return self.scriptWitness.is_null()\n-\n-\n-class CTxWitness():\n-    def __init__(self):\n-        self.vtxinwit = []\n-\n-    def deserialize(self, f):\n-        for i in range(len(self.vtxinwit)):\n-            self.vtxinwit[i].deserialize(f)\n-\n-    def serialize(self):\n-        r = b\"\"\n-        # This is different than the usual vector serialization --\n-        # we omit the length of the vector, which is required to be\n-        # the same length as the transaction's vin vector.\n-        for x in self.vtxinwit:\n-            r += x.serialize()\n-        return r\n-\n-    def __repr__(self):\n-        return \"CTxWitness(%s)\" % \\\n-               (';'.join([repr(x) for x in self.vtxinwit]))\n-\n-    def is_null(self):\n-        for x in self.vtxinwit:\n-            if not x.is_null():\n-                return False\n-        return True\n-\n-\n-class CTransaction():\n-    def __init__(self, tx=None):\n-        if tx is None:\n-            self.nVersion = 1\n-            self.vin = []\n-            self.vout = []\n-            self.wit = CTxWitness()\n-            self.nLockTime = 0\n-            self.sha256 = None\n-            self.hash = None\n-        else:\n-            self.nVersion = tx.nVersion\n-            self.vin = copy.deepcopy(tx.vin)\n-            self.vout = copy.deepcopy(tx.vout)\n-            self.nLockTime = tx.nLockTime\n-            self.sha256 = tx.sha256\n-            self.hash = tx.hash\n-            self.wit = copy.deepcopy(tx.wit)\n-\n-    def deserialize(self, f):\n-        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n-        self.vin = deser_vector(f, CTxIn)\n-        flags = 0\n-        if len(self.vin) == 0:\n-            flags = struct.unpack(\"<B\", f.read(1))[0]\n-            # Not sure why flags can't be zero, but this\n-            # matches the implementation in bitcoind\n-            if (flags != 0):\n-                self.vin = deser_vector(f, CTxIn)\n-                self.vout = deser_vector(f, CTxOut)\n-        else:\n-            self.vout = deser_vector(f, CTxOut)\n-        if flags != 0:\n-            self.wit.vtxinwit = [CTxInWitness() for i in range(len(self.vin))]\n-            self.wit.deserialize(f)\n-        self.nLockTime = struct.unpack(\"<I\", f.read(4))[0]\n-        self.sha256 = None\n-        self.hash = None\n-\n-    def serialize_without_witness(self):\n-        r = b\"\"\n-        r += struct.pack(\"<i\", self.nVersion)\n-        r += ser_vector(self.vin)\n-        r += ser_vector(self.vout)\n-        r += struct.pack(\"<I\", self.nLockTime)\n-        return r\n-\n-    # Only serialize with witness when explicitly called for\n-    def serialize_with_witness(self):\n-        flags = 0\n-        if not self.wit.is_null():\n-            flags |= 1\n-        r = b\"\"\n-        r += struct.pack(\"<i\", self.nVersion)\n-        if flags:\n-            dummy = []\n-            r += ser_vector(dummy)\n-            r += struct.pack(\"<B\", flags)\n-        r += ser_vector(self.vin)\n-        r += ser_vector(self.vout)\n-        if flags & 1:\n-            if (len(self.wit.vtxinwit) != len(self.vin)):\n-                # vtxinwit must have the same length as vin\n-                self.wit.vtxinwit = self.wit.vtxinwit[:len(self.vin)]\n-                for i in range(len(self.wit.vtxinwit), len(self.vin)):\n-                    self.wit.vtxinwit.append(CTxInWitness())\n-            r += self.wit.serialize()\n-        r += struct.pack(\"<I\", self.nLockTime)\n-        return r\n-\n-    # Regular serialization is without witness -- must explicitly\n-    # call serialize_with_witness to include witness data.\n-    def serialize(self):\n-        return self.serialize_without_witness()\n-\n-    # Recalculate the txid (transaction hash without witness)\n-    def rehash(self):\n-        self.sha256 = None\n-        self.calc_sha256()\n-\n-    # We will only cache the serialization without witness in\n-    # self.sha256 and self.hash -- those are expected to be the txid.\n-    def calc_sha256(self, with_witness=False):\n-        if with_witness:\n-            # Don't cache the result, just return it\n-            return uint256_from_str(hash256(self.serialize_with_witness()))\n-\n-        if self.sha256 is None:\n-            self.sha256 = uint256_from_str(hash256(self.serialize_without_witness()))\n-        self.hash = encode(hash256(self.serialize())[::-1], 'hex_codec').decode('ascii')\n-\n-    def is_valid(self):\n-        self.calc_sha256()\n-        for tout in self.vout:\n-            if tout.nValue < 0 or tout.nValue > 21000000 * COIN:\n-                return False\n-        return True\n-\n-    def __repr__(self):\n-        return \"CTransaction(nVersion=%i vin=%s vout=%s wit=%s nLockTime=%i)\" \\\n-            % (self.nVersion, repr(self.vin), repr(self.vout), repr(self.wit), self.nLockTime)\n-\n-\n-class CBlockHeader():\n-    def __init__(self, header=None):\n-        if header is None:\n-            self.set_null()\n-        else:\n-            self.nVersion = header.nVersion\n-            self.hashPrevBlock = header.hashPrevBlock\n-            self.hashMerkleRoot = header.hashMerkleRoot\n-            self.nTime = header.nTime\n-            self.nBits = header.nBits\n-            self.nNonce = header.nNonce\n-            self.sha256 = header.sha256\n-            self.hash = header.hash\n-            self.calc_sha256()\n-\n-    def set_null(self):\n-        self.nVersion = 1\n-        self.hashPrevBlock = 0\n-        self.hashMerkleRoot = 0\n-        self.nTime = 0\n-        self.nBits = 0\n-        self.nNonce = 0\n-        self.sha256 = None\n-        self.hash = None\n-\n-    def deserialize(self, f):\n-        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n-        self.hashPrevBlock = deser_uint256(f)\n-        self.hashMerkleRoot = deser_uint256(f)\n-        self.nTime = struct.unpack(\"<I\", f.read(4))[0]\n-        self.nBits = struct.unpack(\"<I\", f.read(4))[0]\n-        self.nNonce = struct.unpack(\"<I\", f.read(4))[0]\n-        self.sha256 = None\n-        self.hash = None\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += struct.pack(\"<i\", self.nVersion)\n-        r += ser_uint256(self.hashPrevBlock)\n-        r += ser_uint256(self.hashMerkleRoot)\n-        r += struct.pack(\"<I\", self.nTime)\n-        r += struct.pack(\"<I\", self.nBits)\n-        r += struct.pack(\"<I\", self.nNonce)\n-        return r\n-\n-    def calc_sha256(self):\n-        if self.sha256 is None:\n-            r = b\"\"\n-            r += struct.pack(\"<i\", self.nVersion)\n-            r += ser_uint256(self.hashPrevBlock)\n-            r += ser_uint256(self.hashMerkleRoot)\n-            r += struct.pack(\"<I\", self.nTime)\n-            r += struct.pack(\"<I\", self.nBits)\n-            r += struct.pack(\"<I\", self.nNonce)\n-            self.sha256 = uint256_from_str(hash256(r))\n-            self.hash = encode(hash256(r)[::-1], 'hex_codec').decode('ascii')\n-\n-    def rehash(self):\n-        self.sha256 = None\n-        self.calc_sha256()\n-        return self.sha256\n-\n-    def __repr__(self):\n-        return \"CBlockHeader(nVersion=%i hashPrevBlock=%064x hashMerkleRoot=%064x nTime=%s nBits=%08x nNonce=%08x)\" \\\n-            % (self.nVersion, self.hashPrevBlock, self.hashMerkleRoot,\n-               time.ctime(self.nTime), self.nBits, self.nNonce)\n-\n-\n-class CBlock(CBlockHeader):\n-    def __init__(self, header=None):\n-        super(CBlock, self).__init__(header)\n-        self.vtx = []\n-\n-    def deserialize(self, f):\n-        super(CBlock, self).deserialize(f)\n-        self.vtx = deser_vector(f, CTransaction)\n-\n-    def serialize(self, with_witness=False):\n-        r = b\"\"\n-        r += super(CBlock, self).serialize()\n-        if with_witness:\n-            r += ser_vector(self.vtx, \"serialize_with_witness\")\n-        else:\n-            r += ser_vector(self.vtx)\n-        return r\n-\n-    # Calculate the merkle root given a vector of transaction hashes\n-    @classmethod\n-    def get_merkle_root(cls, hashes):\n-        while len(hashes) > 1:\n-            newhashes = []\n-            for i in range(0, len(hashes), 2):\n-                i2 = min(i+1, len(hashes)-1)\n-                newhashes.append(hash256(hashes[i] + hashes[i2]))\n-            hashes = newhashes\n-        return uint256_from_str(hashes[0])\n-\n-    def calc_merkle_root(self):\n-        hashes = []\n-        for tx in self.vtx:\n-            tx.calc_sha256()\n-            hashes.append(ser_uint256(tx.sha256))\n-        return self.get_merkle_root(hashes)\n-\n-    def calc_witness_merkle_root(self):\n-        # For witness root purposes, the hash of the\n-        # coinbase, with witness, is defined to be 0...0\n-        hashes = [ser_uint256(0)]\n-\n-        for tx in self.vtx[1:]:\n-            # Calculate the hashes with witness data\n-            hashes.append(ser_uint256(tx.calc_sha256(True)))\n-\n-        return self.get_merkle_root(hashes)\n-\n-    def is_valid(self):\n-        self.calc_sha256()\n-        target = uint256_from_compact(self.nBits)\n-        if self.sha256 > target:\n-            return False\n-        for tx in self.vtx:\n-            if not tx.is_valid():\n-                return False\n-        if self.calc_merkle_root() != self.hashMerkleRoot:\n-            return False\n-        return True\n-\n-    def solve(self):\n-        self.rehash()\n-        target = uint256_from_compact(self.nBits)\n-        while self.sha256 > target:\n-            self.nNonce += 1\n-            self.rehash()\n-\n-    def __repr__(self):\n-        return \"CBlock(nVersion=%i hashPrevBlock=%064x hashMerkleRoot=%064x nTime=%s nBits=%08x nNonce=%08x vtx=%s)\" \\\n-            % (self.nVersion, self.hashPrevBlock, self.hashMerkleRoot,\n-               time.ctime(self.nTime), self.nBits, self.nNonce, repr(self.vtx))\n-\n-\n-class PrefilledTransaction():\n-    def __init__(self, index=0, tx = None):\n-        self.index = index\n-        self.tx = tx\n-\n-    def deserialize(self, f):\n-        self.index = deser_compact_size(f)\n-        self.tx = CTransaction()\n-        self.tx.deserialize(f)\n-\n-    def serialize(self, with_witness=False):\n-        r = b\"\"\n-        r += ser_compact_size(self.index)\n-        if with_witness:\n-            r += self.tx.serialize_with_witness()\n-        else:\n-            r += self.tx.serialize_without_witness()\n-        return r\n-\n-    def serialize_with_witness(self):\n-        return self.serialize(with_witness=True)\n-\n-    def __repr__(self):\n-        return \"PrefilledTransaction(index=%d, tx=%s)\" % (self.index, repr(self.tx))\n-\n-# This is what we send on the wire, in a cmpctblock message.\n-class P2PHeaderAndShortIDs():\n-    def __init__(self):\n-        self.header = CBlockHeader()\n-        self.nonce = 0\n-        self.shortids_length = 0\n-        self.shortids = []\n-        self.prefilled_txn_length = 0\n-        self.prefilled_txn = []\n-\n-    def deserialize(self, f):\n-        self.header.deserialize(f)\n-        self.nonce = struct.unpack(\"<Q\", f.read(8))[0]\n-        self.shortids_length = deser_compact_size(f)\n-        for i in range(self.shortids_length):\n-            # shortids are defined to be 6 bytes in the spec, so append\n-            # two zero bytes and read it in as an 8-byte number\n-            self.shortids.append(struct.unpack(\"<Q\", f.read(6) + b'\\x00\\x00')[0])\n-        self.prefilled_txn = deser_vector(f, PrefilledTransaction)\n-        self.prefilled_txn_length = len(self.prefilled_txn)\n-\n-    # When using version 2 compact blocks, we must serialize with_witness.\n-    def serialize(self, with_witness=False):\n-        r = b\"\"\n-        r += self.header.serialize()\n-        r += struct.pack(\"<Q\", self.nonce)\n-        r += ser_compact_size(self.shortids_length)\n-        for x in self.shortids:\n-            # We only want the first 6 bytes\n-            r += struct.pack(\"<Q\", x)[0:6]\n-        if with_witness:\n-            r += ser_vector(self.prefilled_txn, \"serialize_with_witness\")\n-        else:\n-            r += ser_vector(self.prefilled_txn)\n-        return r\n-\n-    def __repr__(self):\n-        return \"P2PHeaderAndShortIDs(header=%s, nonce=%d, shortids_length=%d, shortids=%s, prefilled_txn_length=%d, prefilledtxn=%s\" % (repr(self.header), self.nonce, self.shortids_length, repr(self.shortids), self.prefilled_txn_length, repr(self.prefilled_txn))\n-\n-# P2P version of the above that will use witness serialization (for compact\n-# block version 2)\n-class P2PHeaderAndShortWitnessIDs(P2PHeaderAndShortIDs):\n-    def serialize(self):\n-        return super(P2PHeaderAndShortWitnessIDs, self).serialize(with_witness=True)\n-\n-# Calculate the BIP 152-compact blocks shortid for a given transaction hash\n-def calculate_shortid(k0, k1, tx_hash):\n-    expected_shortid = siphash256(k0, k1, tx_hash)\n-    expected_shortid &= 0x0000ffffffffffff\n-    return expected_shortid\n-\n-# This version gets rid of the array lengths, and reinterprets the differential\n-# encoding into indices that can be used for lookup.\n-class HeaderAndShortIDs():\n-    def __init__(self, p2pheaders_and_shortids = None):\n-        self.header = CBlockHeader()\n-        self.nonce = 0\n-        self.shortids = []\n-        self.prefilled_txn = []\n-        self.use_witness = False\n-\n-        if p2pheaders_and_shortids != None:\n-            self.header = p2pheaders_and_shortids.header\n-            self.nonce = p2pheaders_and_shortids.nonce\n-            self.shortids = p2pheaders_and_shortids.shortids\n-            last_index = -1\n-            for x in p2pheaders_and_shortids.prefilled_txn:\n-                self.prefilled_txn.append(PrefilledTransaction(x.index + last_index + 1, x.tx))\n-                last_index = self.prefilled_txn[-1].index\n-\n-    def to_p2p(self):\n-        if self.use_witness:\n-            ret = P2PHeaderAndShortWitnessIDs()\n-        else:\n-            ret = P2PHeaderAndShortIDs()\n-        ret.header = self.header\n-        ret.nonce = self.nonce\n-        ret.shortids_length = len(self.shortids)\n-        ret.shortids = self.shortids\n-        ret.prefilled_txn_length = len(self.prefilled_txn)\n-        ret.prefilled_txn = []\n-        last_index = -1\n-        for x in self.prefilled_txn:\n-            ret.prefilled_txn.append(PrefilledTransaction(x.index - last_index - 1, x.tx))\n-            last_index = x.index\n-        return ret\n-\n-    def get_siphash_keys(self):\n-        header_nonce = self.header.serialize()\n-        header_nonce += struct.pack(\"<Q\", self.nonce)\n-        hash_header_nonce_as_str = sha256(header_nonce)\n-        key0 = struct.unpack(\"<Q\", hash_header_nonce_as_str[0:8])[0]\n-        key1 = struct.unpack(\"<Q\", hash_header_nonce_as_str[8:16])[0]\n-        return [ key0, key1 ]\n-\n-    # Version 2 compact blocks use wtxid in shortids (rather than txid)\n-    def initialize_from_block(self, block, nonce=0, prefill_list = [0], use_witness = False):\n-        self.header = CBlockHeader(block)\n-        self.nonce = nonce\n-        self.prefilled_txn = [ PrefilledTransaction(i, block.vtx[i]) for i in prefill_list ]\n-        self.shortids = []\n-        self.use_witness = use_witness\n-        [k0, k1] = self.get_siphash_keys()\n-        for i in range(len(block.vtx)):\n-            if i not in prefill_list:\n-                tx_hash = block.vtx[i].sha256\n-                if use_witness:\n-                    tx_hash = block.vtx[i].calc_sha256(with_witness=True)\n-                self.shortids.append(calculate_shortid(k0, k1, tx_hash))\n-\n-    def __repr__(self):\n-        return \"HeaderAndShortIDs(header=%s, nonce=%d, shortids=%s, prefilledtxn=%s\" % (repr(self.header), self.nonce, repr(self.shortids), repr(self.prefilled_txn))\n-\n-\n-class BlockTransactionsRequest():\n-\n-    def __init__(self, blockhash=0, indexes = None):\n-        self.blockhash = blockhash\n-        self.indexes = indexes if indexes != None else []\n-\n-    def deserialize(self, f):\n-        self.blockhash = deser_uint256(f)\n-        indexes_length = deser_compact_size(f)\n-        for i in range(indexes_length):\n-            self.indexes.append(deser_compact_size(f))\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += ser_uint256(self.blockhash)\n-        r += ser_compact_size(len(self.indexes))\n-        for x in self.indexes:\n-            r += ser_compact_size(x)\n-        return r\n-\n-    # helper to set the differentially encoded indexes from absolute ones\n-    def from_absolute(self, absolute_indexes):\n-        self.indexes = []\n-        last_index = -1\n-        for x in absolute_indexes:\n-            self.indexes.append(x-last_index-1)\n-            last_index = x\n-\n-    def to_absolute(self):\n-        absolute_indexes = []\n-        last_index = -1\n-        for x in self.indexes:\n-            absolute_indexes.append(x+last_index+1)\n-            last_index = absolute_indexes[-1]\n-        return absolute_indexes\n-\n-    def __repr__(self):\n-        return \"BlockTransactionsRequest(hash=%064x indexes=%s)\" % (self.blockhash, repr(self.indexes))\n-\n-\n-class BlockTransactions():\n-\n-    def __init__(self, blockhash=0, transactions = None):\n-        self.blockhash = blockhash\n-        self.transactions = transactions if transactions != None else []\n-\n-    def deserialize(self, f):\n-        self.blockhash = deser_uint256(f)\n-        self.transactions = deser_vector(f, CTransaction)\n-\n-    def serialize(self, with_witness=False):\n-        r = b\"\"\n-        r += ser_uint256(self.blockhash)\n-        if with_witness:\n-            r += ser_vector(self.transactions, \"serialize_with_witness\")\n-        else:\n-            r += ser_vector(self.transactions)\n-        return r\n-\n-    def __repr__(self):\n-        return \"BlockTransactions(hash=%064x transactions=%s)\" % (self.blockhash, repr(self.transactions))\n-\n-\n-# Objects that correspond to messages on the wire\n-class msg_version():\n-    command = b\"version\"\n-\n-    def __init__(self):\n-        self.nVersion = MY_VERSION\n-        self.nServices = NODE_NETWORK | NODE_WITNESS\n-        self.nTime = int(time.time())\n-        self.addrTo = CAddress()\n-        self.addrFrom = CAddress()\n-        self.nNonce = random.getrandbits(64)\n-        self.strSubVer = MY_SUBVERSION\n-        self.nStartingHeight = -1\n-        self.nRelay = MY_RELAY\n-\n-    def deserialize(self, f):\n-        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n-        if self.nVersion == 10300:\n-            self.nVersion = 300\n-        self.nServices = struct.unpack(\"<Q\", f.read(8))[0]\n-        self.nTime = struct.unpack(\"<q\", f.read(8))[0]\n-        self.addrTo = CAddress()\n-        self.addrTo.deserialize(f)\n-\n-        if self.nVersion >= 106:\n-            self.addrFrom = CAddress()\n-            self.addrFrom.deserialize(f)\n-            self.nNonce = struct.unpack(\"<Q\", f.read(8))[0]\n-            self.strSubVer = deser_string(f)\n-        else:\n-            self.addrFrom = None\n-            self.nNonce = None\n-            self.strSubVer = None\n-            self.nStartingHeight = None\n-\n-        if self.nVersion >= 209:\n-            self.nStartingHeight = struct.unpack(\"<i\", f.read(4))[0]\n-        else:\n-            self.nStartingHeight = None\n-\n-        if self.nVersion >= 70001:\n-            # Relay field is optional for version 70001 onwards\n-            try:\n-                self.nRelay = struct.unpack(\"<b\", f.read(1))[0]\n-            except:\n-                self.nRelay = 0\n-        else:\n-            self.nRelay = 0\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += struct.pack(\"<i\", self.nVersion)\n-        r += struct.pack(\"<Q\", self.nServices)\n-        r += struct.pack(\"<q\", self.nTime)\n-        r += self.addrTo.serialize()\n-        r += self.addrFrom.serialize()\n-        r += struct.pack(\"<Q\", self.nNonce)\n-        r += ser_string(self.strSubVer)\n-        r += struct.pack(\"<i\", self.nStartingHeight)\n-        r += struct.pack(\"<b\", self.nRelay)\n-        return r\n-\n-    def __repr__(self):\n-        return 'msg_version(nVersion=%i nServices=%i nTime=%s addrTo=%s addrFrom=%s nNonce=0x%016X strSubVer=%s nStartingHeight=%i nRelay=%i)' \\\n-            % (self.nVersion, self.nServices, time.ctime(self.nTime),\n-               repr(self.addrTo), repr(self.addrFrom), self.nNonce,\n-               self.strSubVer, self.nStartingHeight, self.nRelay)\n-\n-\n-class msg_verack():\n-    command = b\"verack\"\n-\n-    def __init__(self):\n-        pass\n-\n-    def deserialize(self, f):\n-        pass\n-\n-    def serialize(self):\n-        return b\"\"\n-\n-    def __repr__(self):\n-        return \"msg_verack()\"\n-\n-\n-class msg_addr():\n-    command = b\"addr\"\n-\n-    def __init__(self):\n-        self.addrs = []\n-\n-    def deserialize(self, f):\n-        self.addrs = deser_vector(f, CAddress)\n-\n-    def serialize(self):\n-        return ser_vector(self.addrs)\n-\n-    def __repr__(self):\n-        return \"msg_addr(addrs=%s)\" % (repr(self.addrs))\n-\n-\n-class msg_inv():\n-    command = b\"inv\"\n-\n-    def __init__(self, inv=None):\n-        if inv is None:\n-            self.inv = []\n-        else:\n-            self.inv = inv\n-\n-    def deserialize(self, f):\n-        self.inv = deser_vector(f, CInv)\n-\n-    def serialize(self):\n-        return ser_vector(self.inv)\n-\n-    def __repr__(self):\n-        return \"msg_inv(inv=%s)\" % (repr(self.inv))\n-\n-\n-class msg_getdata():\n-    command = b\"getdata\"\n-\n-    def __init__(self, inv=None):\n-        self.inv = inv if inv != None else []\n-\n-    def deserialize(self, f):\n-        self.inv = deser_vector(f, CInv)\n-\n-    def serialize(self):\n-        return ser_vector(self.inv)\n-\n-    def __repr__(self):\n-        return \"msg_getdata(inv=%s)\" % (repr(self.inv))\n-\n-\n-class msg_getblocks():\n-    command = b\"getblocks\"\n-\n-    def __init__(self):\n-        self.locator = CBlockLocator()\n-        self.hashstop = 0\n-\n-    def deserialize(self, f):\n-        self.locator = CBlockLocator()\n-        self.locator.deserialize(f)\n-        self.hashstop = deser_uint256(f)\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += self.locator.serialize()\n-        r += ser_uint256(self.hashstop)\n-        return r\n-\n-    def __repr__(self):\n-        return \"msg_getblocks(locator=%s hashstop=%064x)\" \\\n-            % (repr(self.locator), self.hashstop)\n-\n-\n-class msg_tx():\n-    command = b\"tx\"\n-\n-    def __init__(self, tx=CTransaction()):\n-        self.tx = tx\n-\n-    def deserialize(self, f):\n-        self.tx.deserialize(f)\n-\n-    def serialize(self):\n-        return self.tx.serialize_without_witness()\n-\n-    def __repr__(self):\n-        return \"msg_tx(tx=%s)\" % (repr(self.tx))\n-\n-class msg_witness_tx(msg_tx):\n-\n-    def serialize(self):\n-        return self.tx.serialize_with_witness()\n-\n-\n-class msg_block():\n-    command = b\"block\"\n-\n-    def __init__(self, block=None):\n-        if block is None:\n-            self.block = CBlock()\n-        else:\n-            self.block = block\n-\n-    def deserialize(self, f):\n-        self.block.deserialize(f)\n-\n-    def serialize(self):\n-        return self.block.serialize()\n-\n-    def __repr__(self):\n-        return \"msg_block(block=%s)\" % (repr(self.block))\n-\n-# for cases where a user needs tighter control over what is sent over the wire\n-# note that the user must supply the name of the command, and the data\n-class msg_generic():\n-    def __init__(self, command, data=None):\n-        self.command = command\n-        self.data = data\n-\n-    def serialize(self):\n-        return self.data\n-\n-    def __repr__(self):\n-        return \"msg_generic()\"\n-\n-class msg_witness_block(msg_block):\n-\n-    def serialize(self):\n-        r = self.block.serialize(with_witness=True)\n-        return r\n-\n-class msg_getaddr():\n-    command = b\"getaddr\"\n-\n-    def __init__(self):\n-        pass\n-\n-    def deserialize(self, f):\n-        pass\n-\n-    def serialize(self):\n-        return b\"\"\n-\n-    def __repr__(self):\n-        return \"msg_getaddr()\"\n-\n-\n-class msg_ping():\n-    command = b\"ping\"\n-\n-    def __init__(self, nonce=0):\n-        self.nonce = nonce\n-\n-    def deserialize(self, f):\n-        self.nonce = struct.unpack(\"<Q\", f.read(8))[0]\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += struct.pack(\"<Q\", self.nonce)\n-        return r\n-\n-    def __repr__(self):\n-        return \"msg_ping(nonce=%08x)\" % self.nonce\n-\n-\n-class msg_pong():\n-    command = b\"pong\"\n-\n-    def __init__(self, nonce=0):\n-        self.nonce = nonce\n-\n-    def deserialize(self, f):\n-        self.nonce = struct.unpack(\"<Q\", f.read(8))[0]\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += struct.pack(\"<Q\", self.nonce)\n-        return r\n-\n-    def __repr__(self):\n-        return \"msg_pong(nonce=%08x)\" % self.nonce\n-\n-\n-class msg_mempool():\n-    command = b\"mempool\"\n-\n-    def __init__(self):\n-        pass\n-\n-    def deserialize(self, f):\n-        pass\n-\n-    def serialize(self):\n-        return b\"\"\n-\n-    def __repr__(self):\n-        return \"msg_mempool()\"\n-\n-class msg_sendheaders():\n-    command = b\"sendheaders\"\n-\n-    def __init__(self):\n-        pass\n-\n-    def deserialize(self, f):\n-        pass\n-\n-    def serialize(self):\n-        return b\"\"\n-\n-    def __repr__(self):\n-        return \"msg_sendheaders()\"\n-\n-\n-# getheaders message has\n-# number of entries\n-# vector of hashes\n-# hash_stop (hash of last desired block header, 0 to get as many as possible)\n-class msg_getheaders():\n-    command = b\"getheaders\"\n-\n-    def __init__(self):\n-        self.locator = CBlockLocator()\n-        self.hashstop = 0\n-\n-    def deserialize(self, f):\n-        self.locator = CBlockLocator()\n-        self.locator.deserialize(f)\n-        self.hashstop = deser_uint256(f)\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += self.locator.serialize()\n-        r += ser_uint256(self.hashstop)\n-        return r\n-\n-    def __repr__(self):\n-        return \"msg_getheaders(locator=%s, stop=%064x)\" \\\n-            % (repr(self.locator), self.hashstop)\n-\n-\n-# headers message has\n-# <count> <vector of block headers>\n-class msg_headers():\n-    command = b\"headers\"\n-\n-    def __init__(self, headers=None):\n-        self.headers = headers if headers is not None else []\n-\n-    def deserialize(self, f):\n-        # comment in bitcoind indicates these should be deserialized as blocks\n-        blocks = deser_vector(f, CBlock)\n-        for x in blocks:\n-            self.headers.append(CBlockHeader(x))\n-\n-    def serialize(self):\n-        blocks = [CBlock(x) for x in self.headers]\n-        return ser_vector(blocks)\n-\n-    def __repr__(self):\n-        return \"msg_headers(headers=%s)\" % repr(self.headers)\n-\n-\n-class msg_reject():\n-    command = b\"reject\"\n-    REJECT_MALFORMED = 1\n-\n-    def __init__(self):\n-        self.message = b\"\"\n-        self.code = 0\n-        self.reason = b\"\"\n-        self.data = 0\n-\n-    def deserialize(self, f):\n-        self.message = deser_string(f)\n-        self.code = struct.unpack(\"<B\", f.read(1))[0]\n-        self.reason = deser_string(f)\n-        if (self.code != self.REJECT_MALFORMED and\n-                (self.message == b\"block\" or self.message == b\"tx\")):\n-            self.data = deser_uint256(f)\n-\n-    def serialize(self):\n-        r = ser_string(self.message)\n-        r += struct.pack(\"<B\", self.code)\n-        r += ser_string(self.reason)\n-        if (self.code != self.REJECT_MALFORMED and\n-                (self.message == b\"block\" or self.message == b\"tx\")):\n-            r += ser_uint256(self.data)\n-        return r\n-\n-    def __repr__(self):\n-        return \"msg_reject: %s %d %s [%064x]\" \\\n-            % (self.message, self.code, self.reason, self.data)\n-\n-class msg_feefilter():\n-    command = b\"feefilter\"\n-\n-    def __init__(self, feerate=0):\n-        self.feerate = feerate\n-\n-    def deserialize(self, f):\n-        self.feerate = struct.unpack(\"<Q\", f.read(8))[0]\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += struct.pack(\"<Q\", self.feerate)\n-        return r\n-\n-    def __repr__(self):\n-        return \"msg_feefilter(feerate=%08x)\" % self.feerate\n-\n-class msg_sendcmpct():\n-    command = b\"sendcmpct\"\n-\n-    def __init__(self):\n-        self.announce = False\n-        self.version = 1\n-\n-    def deserialize(self, f):\n-        self.announce = struct.unpack(\"<?\", f.read(1))[0]\n-        self.version = struct.unpack(\"<Q\", f.read(8))[0]\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += struct.pack(\"<?\", self.announce)\n-        r += struct.pack(\"<Q\", self.version)\n-        return r\n-\n-    def __repr__(self):\n-        return \"msg_sendcmpct(announce=%s, version=%lu)\" % (self.announce, self.version)\n-\n-class msg_cmpctblock():\n-    command = b\"cmpctblock\"\n-\n-    def __init__(self, header_and_shortids = None):\n-        self.header_and_shortids = header_and_shortids\n-\n-    def deserialize(self, f):\n-        self.header_and_shortids = P2PHeaderAndShortIDs()\n-        self.header_and_shortids.deserialize(f)\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += self.header_and_shortids.serialize()\n-        return r\n-\n-    def __repr__(self):\n-        return \"msg_cmpctblock(HeaderAndShortIDs=%s)\" % repr(self.header_and_shortids)\n-\n-class msg_getblocktxn():\n-    command = b\"getblocktxn\"\n-\n-    def __init__(self):\n-        self.block_txn_request = None\n-\n-    def deserialize(self, f):\n-        self.block_txn_request = BlockTransactionsRequest()\n-        self.block_txn_request.deserialize(f)\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += self.block_txn_request.serialize()\n-        return r\n-\n-    def __repr__(self):\n-        return \"msg_getblocktxn(block_txn_request=%s)\" % (repr(self.block_txn_request))\n-\n-class msg_blocktxn():\n-    command = b\"blocktxn\"\n-\n-    def __init__(self):\n-        self.block_transactions = BlockTransactions()\n-\n-    def deserialize(self, f):\n-        self.block_transactions.deserialize(f)\n-\n-    def serialize(self):\n-        r = b\"\"\n-        r += self.block_transactions.serialize()\n-        return r\n-\n-    def __repr__(self):\n-        return \"msg_blocktxn(block_transactions=%s)\" % (repr(self.block_transactions))\n-\n-class msg_witness_blocktxn(msg_blocktxn):\n-    def serialize(self):\n-        r = b\"\"\n-        r += self.block_transactions.serialize(with_witness=True)\n-        return r\n-\n class NodeConnCB():\n     \"\"\"Callback and helper functions for P2P connection to a bitcoind node.\n "
      }
    ]
  },
  {
    "sha": "1135c796a0e1151b03933f2cd36ce95a8e136b7a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMTM1Yzc5NmEwZTExNTFiMDM5MzNmMmNkMzZjZTk1YThlMTM2Yjdh",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-17T11:51:50Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-10T16:56:59Z"
      },
      "message": "[tests] Tidy up mininode.py module\n\nMostly move only. Adds a few extra comments.",
      "tree": {
        "sha": "8322a5157f92f7ca281d469a5253766e42380146",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8322a5157f92f7ca281d469a5253766e42380146"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1135c796a0e1151b03933f2cd36ce95a8e136b7a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1135c796a0e1151b03933f2cd36ce95a8e136b7a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1135c796a0e1151b03933f2cd36ce95a8e136b7a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1135c796a0e1151b03933f2cd36ce95a8e136b7a/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f9cd9b1bfaf65b4e24c1eb9ca8268513e78cc458",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f9cd9b1bfaf65b4e24c1eb9ca8268513e78cc458",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f9cd9b1bfaf65b4e24c1eb9ca8268513e78cc458"
      }
    ],
    "stats": {
      "total": 170,
      "additions": 92,
      "deletions": 78
    },
    "files": [
      {
        "sha": "91badc72ce79c4c071e205ef26396643a37cd7b8",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 92,
        "deletions": 78,
        "changes": 170,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1135c796a0e1151b03933f2cd36ce95a8e136b7a/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1135c796a0e1151b03933f2cd36ce95a8e136b7a/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=1135c796a0e1151b03933f2cd36ce95a8e136b7a",
        "patch": "@@ -27,18 +27,35 @@\n \n logger = logging.getLogger(\"TestFramework.mininode\")\n \n-# Keep our own socket map for asyncore, so that we can track disconnects\n-# ourselves (to workaround an issue with closing an asyncore socket when\n-# using select)\n-mininode_socket_map = dict()\n-\n-# One lock for synchronizing all data access between the networking thread (see\n-# NetworkThread below) and the thread running the test logic.  For simplicity,\n-# NodeConn acquires this lock whenever delivering a message to a NodeConnCB,\n-# and whenever adding anything to the send buffer (in send_message()).  This\n-# lock should be acquired in the thread running the test logic to synchronize\n-# access to any data shared with the NodeConnCB or NodeConn.\n-mininode_lock = RLock()\n+MESSAGEMAP = {\n+    b\"addr\": msg_addr,\n+    b\"block\": msg_block,\n+    b\"blocktxn\": msg_blocktxn,\n+    b\"cmpctblock\": msg_cmpctblock,\n+    b\"feefilter\": msg_feefilter,\n+    b\"getaddr\": msg_getaddr,\n+    b\"getblocks\": msg_getblocks,\n+    b\"getblocktxn\": msg_getblocktxn,\n+    b\"getdata\": msg_getdata,\n+    b\"getheaders\": msg_getheaders,\n+    b\"headers\": msg_headers,\n+    b\"inv\": msg_inv,\n+    b\"mempool\": msg_mempool,\n+    b\"ping\": msg_ping,\n+    b\"pong\": msg_pong,\n+    b\"reject\": msg_reject,\n+    b\"sendcmpct\": msg_sendcmpct,\n+    b\"sendheaders\": msg_sendheaders,\n+    b\"tx\": msg_tx,\n+    b\"verack\": msg_verack,\n+    b\"version\": msg_version,\n+}\n+\n+MAGIC_BYTES = {\n+    \"mainnet\": b\"\\xf9\\xbe\\xb4\\xd9\",   # mainnet\n+    \"testnet3\": b\"\\x0b\\x11\\x09\\x07\",  # testnet3\n+    \"regtest\": b\"\\xfa\\xbf\\xb5\\xda\",   # regtest\n+}\n \n class NodeConnCB():\n     \"\"\"Callback and helper functions for P2P connection to a bitcoind node.\n@@ -183,34 +200,6 @@ class NodeConn(asyncore.dispatcher):\n     \"\"\"The actual NodeConn class\n \n     This class provides an interface for a p2p connection to a specified node.\"\"\"\n-    messagemap = {\n-        b\"version\": msg_version,\n-        b\"verack\": msg_verack,\n-        b\"addr\": msg_addr,\n-        b\"inv\": msg_inv,\n-        b\"getdata\": msg_getdata,\n-        b\"getblocks\": msg_getblocks,\n-        b\"tx\": msg_tx,\n-        b\"block\": msg_block,\n-        b\"getaddr\": msg_getaddr,\n-        b\"ping\": msg_ping,\n-        b\"pong\": msg_pong,\n-        b\"headers\": msg_headers,\n-        b\"getheaders\": msg_getheaders,\n-        b\"reject\": msg_reject,\n-        b\"mempool\": msg_mempool,\n-        b\"feefilter\": msg_feefilter,\n-        b\"sendheaders\": msg_sendheaders,\n-        b\"sendcmpct\": msg_sendcmpct,\n-        b\"cmpctblock\": msg_cmpctblock,\n-        b\"getblocktxn\": msg_getblocktxn,\n-        b\"blocktxn\": msg_blocktxn\n-    }\n-    MAGIC_BYTES = {\n-        \"mainnet\": b\"\\xf9\\xbe\\xb4\\xd9\",   # mainnet\n-        \"testnet3\": b\"\\x0b\\x11\\x09\\x07\",  # testnet3\n-        \"regtest\": b\"\\xfa\\xbf\\xb5\\xda\",   # regtest\n-    }\n \n     def __init__(self, dstaddr, dstport, rpc, callback, net=\"regtest\", services=NODE_NETWORK|NODE_WITNESS, send_version=True):\n         asyncore.dispatcher.__init__(self, map=mininode_socket_map)\n@@ -247,6 +236,8 @@ def __init__(self, dstaddr, dstport, rpc, callback, net=\"regtest\", services=NODE\n             self.handle_close()\n         self.rpc = rpc\n \n+    # Connection and disconnection methods\n+\n     def handle_connect(self):\n         if self.state != \"connected\":\n             logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n@@ -264,44 +255,30 @@ def handle_close(self):\n             pass\n         self.cb.on_close(self)\n \n+    def disconnect_node(self):\n+        \"\"\" Disconnect the p2p connection.\n+\n+        Called by the test logic thread. Causes the p2p connection\n+        to be disconnected on the next iteration of the asyncore loop.\"\"\"\n+        self.disconnect = True\n+\n+    # Socket read methods\n+\n+    def readable(self):\n+        return True\n+\n     def handle_read(self):\n         t = self.recv(8192)\n         if len(t) > 0:\n             self.recvbuf += t\n             self.got_data()\n \n-    def readable(self):\n-        return True\n-\n-    def writable(self):\n-        with mininode_lock:\n-            pre_connection = self.state == \"connecting\"\n-            length = len(self.sendbuf)\n-        return (length > 0 or pre_connection)\n-\n-    def handle_write(self):\n-        with mininode_lock:\n-            # asyncore does not expose socket connection, only the first read/write\n-            # event, thus we must check connection manually here to know when we\n-            # actually connect\n-            if self.state == \"connecting\":\n-                self.handle_connect()\n-            if not self.writable():\n-                return\n-\n-            try:\n-                sent = self.send(self.sendbuf)\n-            except:\n-                self.handle_close()\n-                return\n-            self.sendbuf = self.sendbuf[sent:]\n-\n     def got_data(self):\n         try:\n             while True:\n                 if len(self.recvbuf) < 4:\n                     return\n-                if self.recvbuf[:4] != self.MAGIC_BYTES[self.network]:\n+                if self.recvbuf[:4] != MAGIC_BYTES[self.network]:\n                     raise ValueError(\"got garbage %s\" % repr(self.recvbuf))\n                 if len(self.recvbuf) < 4 + 12 + 4 + 4:\n                     return\n@@ -316,23 +293,54 @@ def got_data(self):\n                 if checksum != h[:4]:\n                     raise ValueError(\"got bad checksum \" + repr(self.recvbuf))\n                 self.recvbuf = self.recvbuf[4+12+4+4+msglen:]\n-                if command not in self.messagemap:\n+                if command not in MESSAGEMAP:\n                     raise ValueError(\"Received unknown command from %s:%d: '%s' %s\" % (self.dstaddr, self.dstport, command, repr(msg)))\n                 f = BytesIO(msg)\n-                t = self.messagemap[command]()\n+                t = MESSAGEMAP[command]()\n                 t.deserialize(f)\n                 self.got_message(t)\n         except Exception as e:\n             logger.exception('Error reading message:', repr(e))\n             raise\n \n+    def got_message(self, message):\n+        if self.last_sent + 30 * 60 < time.time():\n+            self.send_message(MESSAGEMAP[b'ping']())\n+        self._log_message(\"receive\", message)\n+        self.cb.deliver(self, message)\n+\n+    # Socket write methods\n+\n+    def writable(self):\n+        with mininode_lock:\n+            pre_connection = self.state == \"connecting\"\n+            length = len(self.sendbuf)\n+        return (length > 0 or pre_connection)\n+\n+    def handle_write(self):\n+        with mininode_lock:\n+            # asyncore does not expose socket connection, only the first read/write\n+            # event, thus we must check connection manually here to know when we\n+            # actually connect\n+            if self.state == \"connecting\":\n+                self.handle_connect()\n+            if not self.writable():\n+                return\n+\n+            try:\n+                sent = self.send(self.sendbuf)\n+            except:\n+                self.handle_close()\n+                return\n+            self.sendbuf = self.sendbuf[sent:]\n+\n     def send_message(self, message, pushbuf=False):\n         if self.state != \"connected\" and not pushbuf:\n             raise IOError('Not connected, no pushbuf')\n         self._log_message(\"send\", message)\n         command = message.command\n         data = message.serialize()\n-        tmsg = self.MAGIC_BYTES[self.network]\n+        tmsg = MAGIC_BYTES[self.network]\n         tmsg += command\n         tmsg += b\"\\x00\" * (12 - len(command))\n         tmsg += struct.pack(\"<I\", len(data))\n@@ -351,11 +359,7 @@ def send_message(self, message, pushbuf=False):\n                 self.sendbuf += tmsg\n             self.last_sent = time.time()\n \n-    def got_message(self, message):\n-        if self.last_sent + 30 * 60 < time.time():\n-            self.send_message(self.messagemap[b'ping']())\n-        self._log_message(\"receive\", message)\n-        self.cb.deliver(self, message)\n+    # Class utility methods\n \n     def _log_message(self, direction, msg):\n         if direction == \"send\":\n@@ -367,9 +371,19 @@ def _log_message(self, direction, msg):\n             log_message += \"... (msg truncated)\"\n         logger.debug(log_message)\n \n-    def disconnect_node(self):\n-        self.disconnect = True\n \n+# Keep our own socket map for asyncore, so that we can track disconnects\n+# ourselves (to workaround an issue with closing an asyncore socket when\n+# using select)\n+mininode_socket_map = dict()\n+\n+# One lock for synchronizing all data access between the networking thread (see\n+# NetworkThread below) and the thread running the test logic.  For simplicity,\n+# NodeConn acquires this lock whenever delivering a message to a NodeConnCB,\n+# and whenever adding anything to the send buffer (in send_message()).  This\n+# lock should be acquired in the thread running the test logic to synchronize\n+# access to any data shared with the NodeConnCB or NodeConn.\n+mininode_lock = RLock()\n \n class NetworkThread(Thread):\n     def run(self):\n@@ -381,6 +395,6 @@ def run(self):\n             for fd, obj in mininode_socket_map.items():\n                 if obj.disconnect:\n                     disconnected.append(obj)\n-            [ obj.handle_close() for obj in disconnected ]\n+            [obj.handle_close() for obj in disconnected]\n             asyncore.loop(0.1, use_poll=True, map=mininode_socket_map, count=1)\n         logger.debug(\"Network thread closing\")"
      }
    ]
  }
]