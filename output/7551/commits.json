[
  {
    "sha": "cb08fdbf78685b55029768524ca867772711c32b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjYjA4ZmRiZjc4Njg1YjU1MDI5NzY4NTI0Y2E4Njc3NzI3MTFjMzJi",
    "commit": {
      "author": {
        "name": "Pedro Branco",
        "email": "branco@uphold.com",
        "date": "2016-06-16T14:57:48Z"
      },
      "committer": {
        "name": "Pedro Branco",
        "email": "branco@uphold.com",
        "date": "2016-10-19T14:17:13Z"
      },
      "message": "Add importmulti rpc call",
      "tree": {
        "sha": "c41c0169a7a428f93527eb715ec2ae9de2df7e70",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c41c0169a7a428f93527eb715ec2ae9de2df7e70"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cb08fdbf78685b55029768524ca867772711c32b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cb08fdbf78685b55029768524ca867772711c32b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cb08fdbf78685b55029768524ca867772711c32b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cb08fdbf78685b55029768524ca867772711c32b/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "97c7f7362f9b59247753d6e8fa8022a6205f9c09",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/97c7f7362f9b59247753d6e8fa8022a6205f9c09",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/97c7f7362f9b59247753d6e8fa8022a6205f9c09"
      }
    ],
    "stats": {
      "total": 698,
      "additions": 698,
      "deletions": 0
    },
    "files": [
      {
        "sha": "778f8d8a77818e9a60cc2df8026458861d16359d",
        "filename": "qa/pull-tester/rpc-tests.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cb08fdbf78685b55029768524ca867772711c32b/qa/pull-tester/rpc-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cb08fdbf78685b55029768524ca867772711c32b/qa/pull-tester/rpc-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.py?ref=cb08fdbf78685b55029768524ca867772711c32b",
        "patch": "@@ -145,6 +145,7 @@\n     'signmessages.py',\n     'p2p-compactblocks.py',\n     'nulldummy.py',\n+    'importmulti.py',\n ]\n if ENABLE_ZMQ:\n     testScripts.append('zmq_test.py')"
      },
      {
        "sha": "960cb63d768c5a8a8b1c2c87c4f0c0069610247c",
        "filename": "qa/rpc-tests/importmulti.py",
        "status": "added",
        "additions": 293,
        "deletions": 0,
        "changes": 293,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cb08fdbf78685b55029768524ca867772711c32b/qa/rpc-tests/importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cb08fdbf78685b55029768524ca867772711c32b/qa/rpc-tests/importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/importmulti.py?ref=cb08fdbf78685b55029768524ca867772711c32b",
        "patch": "@@ -0,0 +1,293 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+class ImportMultiTest (BitcoinTestFramework):\n+    def __init__(self):\n+        super().__init__()\n+        self.num_nodes = 2\n+        self.setup_clean_chain = True\n+\n+    def setup_network(self, split=False):\n+        self.nodes = start_nodes(2, self.options.tmpdir)\n+        self.is_network_split=False\n+\n+    def run_test (self):\n+        print (\"Mining blocks...\")\n+        self.nodes[0].generate(1)\n+        self.nodes[1].generate(1)\n+\n+        # keyword definition\n+        PRIV_KEY = 'privkey'\n+        PUB_KEY = 'pubkey'\n+        ADDRESS_KEY = 'address'\n+        SCRIPT_KEY = 'script'\n+\n+\n+        node0_address1 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        node0_address2 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        node0_address3 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+\n+        #Check only one address\n+        assert_equal(node0_address1['ismine'], True)\n+\n+        #Node 1 sync test\n+        assert_equal(self.nodes[1].getblockcount(),1)\n+\n+        #Address Test - before import\n+        address_info = self.nodes[1].validateaddress(node0_address1['address'])\n+        assert_equal(address_info['iswatchonly'], False)\n+        assert_equal(address_info['ismine'], False)\n+\n+\n+        # RPC importmulti -----------------------------------------------\n+\n+        # Bitcoin Address\n+        print(\"Should import an address\")\n+        address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": address['address']\n+            }\n+        }])\n+        assert_equal(result[0]['success'], True)\n+        address_assert = self.nodes[1].validateaddress(address['address'])\n+        assert_equal(address_assert['iswatchonly'], True)\n+        assert_equal(address_assert['ismine'], False)\n+\n+\n+        # ScriptPubKey + internal\n+        print(\"Should import a scriptPubKey with internal flag\")\n+        address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": address['scriptPubKey'],\n+            \"internal\": True\n+        }])\n+        assert_equal(result[0]['success'], True)\n+        address_assert = self.nodes[1].validateaddress(address['address'])\n+        assert_equal(address_assert['iswatchonly'], True)\n+        assert_equal(address_assert['ismine'], False)\n+\n+        # ScriptPubKey + !internal\n+        print(\"Should not import a scriptPubKey without internal flag\")\n+        address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": address['scriptPubKey']\n+        }])\n+        assert_equal(result[0]['success'], False)\n+        assert_equal(result[0]['error']['code'], -8)\n+        assert_equal(result[0]['error']['message'], 'Internal must be set for hex scriptPubKey')\n+        address_assert = self.nodes[1].validateaddress(address['address'])\n+        assert_equal(address_assert['iswatchonly'], False)\n+        assert_equal(address_assert['ismine'], False)\n+\n+\n+        # Address + Public key + !Internal\n+        print(\"Should import an address with public key\")\n+        address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": address['address']\n+            },\n+            \"pubkeys\": [ address['pubkey'] ]\n+        }])\n+        assert_equal(result[0]['success'], True)\n+        address_assert = self.nodes[1].validateaddress(address['address'])\n+        assert_equal(address_assert['iswatchonly'], True)\n+        assert_equal(address_assert['ismine'], False)\n+\n+\n+        # ScriptPubKey + Public key + internal\n+        print(\"Should import a scriptPubKey with internal and with public key\")\n+        address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        request = [{\n+            \"scriptPubKey\": address['scriptPubKey'],\n+            \"pubkeys\": [ address['pubkey'] ],\n+            \"internal\": True\n+        }];\n+        result = self.nodes[1].importmulti(request)\n+        assert_equal(result[0]['success'], True)\n+        address_assert = self.nodes[1].validateaddress(address['address'])\n+        assert_equal(address_assert['iswatchonly'], True)\n+        assert_equal(address_assert['ismine'], False)\n+\n+        # ScriptPubKey + Public key + !internal\n+        print(\"Should not import a scriptPubKey without internal and with public key\")\n+        address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        request = [{\n+            \"scriptPubKey\": address['scriptPubKey'],\n+            \"pubkeys\": [ address['pubkey'] ]\n+        }];\n+        result = self.nodes[1].importmulti(request)\n+        assert_equal(result[0]['success'], False)\n+        assert_equal(result[0]['error']['code'], -8)\n+        assert_equal(result[0]['error']['message'], 'Internal must be set for hex scriptPubKey')\n+        address_assert = self.nodes[1].validateaddress(address['address'])\n+        assert_equal(address_assert['iswatchonly'], False)\n+        assert_equal(address_assert['ismine'], False)\n+\n+        # Address + Private key + !watchonly\n+        print(\"Should import an address with private key\")\n+        address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": address['address']\n+            },\n+            \"keys\": [ self.nodes[0].dumpprivkey(address['address']) ]\n+        }])\n+        assert_equal(result[0]['success'], True)\n+        address_assert = self.nodes[1].validateaddress(address['address'])\n+        assert_equal(address_assert['iswatchonly'], False)\n+        assert_equal(address_assert['ismine'], True)\n+\n+        # Address + Private key + watchonly\n+        print(\"Should not import an address with private key and with watchonly\")\n+        address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": address['address']\n+            },\n+            \"keys\": [ self.nodes[0].dumpprivkey(address['address']) ],\n+            \"watchonly\": True\n+        }])\n+        assert_equal(result[0]['success'], False)\n+        assert_equal(result[0]['error']['code'], -8)\n+        assert_equal(result[0]['error']['message'], 'Incompatibility found between watchonly and keys')\n+        address_assert = self.nodes[1].validateaddress(address['address'])\n+        assert_equal(address_assert['iswatchonly'], False)\n+        assert_equal(address_assert['ismine'], False)\n+\n+        # ScriptPubKey + Private key + internal\n+        print(\"Should import a scriptPubKey with internal and with private key\")\n+        address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": address['scriptPubKey'],\n+            \"keys\": [ self.nodes[0].dumpprivkey(address['address']) ],\n+            \"internal\": True\n+        }])\n+        assert_equal(result[0]['success'], True)\n+        address_assert = self.nodes[1].validateaddress(address['address'])\n+        assert_equal(address_assert['iswatchonly'], False)\n+        assert_equal(address_assert['ismine'], True)\n+\n+        # ScriptPubKey + Private key + !internal\n+        print(\"Should not import a scriptPubKey without internal and with private key\")\n+        address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": address['scriptPubKey'],\n+            \"keys\": [ self.nodes[0].dumpprivkey(address['address']) ]\n+        }])\n+        assert_equal(result[0]['success'], False)\n+        assert_equal(result[0]['error']['code'], -8)\n+        assert_equal(result[0]['error']['message'], 'Internal must be set for hex scriptPubKey')\n+        address_assert = self.nodes[1].validateaddress(address['address'])\n+        assert_equal(address_assert['iswatchonly'], False)\n+        assert_equal(address_assert['ismine'], False)\n+\n+\n+        # P2SH address\n+        sig_address_1 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        sig_address_2 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        sig_address_3 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        multi_sig_script = self.nodes[0].createmultisig(2, [sig_address_1['address'], sig_address_2['address'], sig_address_3['pubkey']])\n+        self.nodes[1].generate(100)\n+        transactionid = self.nodes[1].sendtoaddress(multi_sig_script['address'], 10.00)\n+        self.nodes[1].generate(1)\n+        transaction = self.nodes[1].gettransaction(transactionid);\n+\n+        print(\"Should import a p2sh\")\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": multi_sig_script['address']\n+            }\n+        }])\n+        assert_equal(result[0]['success'], True)\n+        address_assert = self.nodes[1].validateaddress(multi_sig_script['address'])\n+        assert_equal(address_assert['isscript'], True)\n+        assert_equal(address_assert['iswatchonly'], True)\n+        p2shunspent = self.nodes[1].listunspent(0,999999, [multi_sig_script['address']])[0]\n+        assert_equal(p2shunspent['spendable'], False)\n+        assert_equal(p2shunspent['solvable'], False)\n+\n+\n+        # P2SH + Redeem script\n+        sig_address_1 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        sig_address_2 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        sig_address_3 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        multi_sig_script = self.nodes[0].createmultisig(2, [sig_address_1['address'], sig_address_2['address'], sig_address_3['pubkey']])\n+        self.nodes[1].generate(100)\n+        transactionid = self.nodes[1].sendtoaddress(multi_sig_script['address'], 10.00)\n+        self.nodes[1].generate(1)\n+        transaction = self.nodes[1].gettransaction(transactionid);\n+\n+        print(\"Should import a p2sh with respective redeem script\")\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": multi_sig_script['address']\n+            },\n+            \"redeemscript\": multi_sig_script['redeemScript']\n+        }])\n+        assert_equal(result[0]['success'], True)\n+\n+        p2shunspent = self.nodes[1].listunspent(0,999999, [multi_sig_script['address']])[0]\n+        assert_equal(p2shunspent['spendable'], False)\n+        assert_equal(p2shunspent['solvable'], True)\n+\n+\n+        # P2SH + Redeem script + Private Keys + !Watchonly\n+        sig_address_1 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        sig_address_2 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        sig_address_3 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        multi_sig_script = self.nodes[0].createmultisig(2, [sig_address_1['address'], sig_address_2['address'], sig_address_3['pubkey']])\n+        self.nodes[1].generate(100)\n+        transactionid = self.nodes[1].sendtoaddress(multi_sig_script['address'], 10.00)\n+        self.nodes[1].generate(1)\n+        transaction = self.nodes[1].gettransaction(transactionid);\n+\n+        print(\"Should import a p2sh with respective redeem script and private keys\")\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": multi_sig_script['address']\n+            },\n+            \"redeemscript\": multi_sig_script['redeemScript'],\n+            \"keys\": [ self.nodes[0].dumpprivkey(sig_address_1['address']), self.nodes[0].dumpprivkey(sig_address_2['address'])]\n+        }])\n+        assert_equal(result[0]['success'], True)\n+\n+        p2shunspent = self.nodes[1].listunspent(0,999999, [multi_sig_script['address']])[0]\n+        assert_equal(p2shunspent['spendable'], False)\n+        assert_equal(p2shunspent['solvable'], True)\n+\n+        # P2SH + Redeem script + Private Keys + Watchonly\n+        sig_address_1 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        sig_address_2 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        sig_address_3 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        multi_sig_script = self.nodes[0].createmultisig(2, [sig_address_1['address'], sig_address_2['address'], sig_address_3['pubkey']])\n+        self.nodes[1].generate(100)\n+        transactionid = self.nodes[1].sendtoaddress(multi_sig_script['address'], 10.00)\n+        self.nodes[1].generate(1)\n+        transaction = self.nodes[1].gettransaction(transactionid);\n+\n+        print(\"Should import a p2sh with respective redeem script and private keys\")\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": multi_sig_script['address']\n+            },\n+            \"redeemscript\": multi_sig_script['redeemScript'],\n+            \"keys\": [ self.nodes[0].dumpprivkey(sig_address_1['address']), self.nodes[0].dumpprivkey(sig_address_2['address'])],\n+            \"watchonly\": True\n+        }])\n+        assert_equal(result[0]['success'], False)\n+        assert_equal(result[0]['error']['code'], -8)\n+        assert_equal(result[0]['error']['message'], 'Incompatibility found between watchonly and keys')\n+\n+        # TODO Consistency tests?\n+\n+\n+\n+if __name__ == '__main__':\n+    ImportMultiTest ().main ()"
      },
      {
        "sha": "1e611906d146fb4fdb375275996d442bdac07c0b",
        "filename": "src/chain.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cb08fdbf78685b55029768524ca867772711c32b/src/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cb08fdbf78685b55029768524ca867772711c32b/src/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.cpp?ref=cb08fdbf78685b55029768524ca867772711c32b",
        "patch": "@@ -61,6 +61,13 @@ const CBlockIndex *CChain::FindFork(const CBlockIndex *pindex) const {\n     return pindex;\n }\n \n+CBlockIndex* CChain::FindLatestBefore(int64_t nTime) const\n+{\n+    std::vector<CBlockIndex*>::const_iterator lower = std::lower_bound(vChain.begin(), vChain.end(), nTime,\n+        [](CBlockIndex* pBlock, const int64_t& time) -> bool { return pBlock->GetBlockTime() < time; });\n+    return (lower == vChain.end() ? NULL : *lower);\n+}\n+\n /** Turn the lowest '1' bit in the binary representation of a number into a '0'. */\n int static inline InvertLowestOne(int n) { return n & (n - 1); }\n "
      },
      {
        "sha": "46a16a30617f411eb70e9c1cd707ba5ee116feec",
        "filename": "src/chain.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cb08fdbf78685b55029768524ca867772711c32b/src/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cb08fdbf78685b55029768524ca867772711c32b/src/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.h?ref=cb08fdbf78685b55029768524ca867772711c32b",
        "patch": "@@ -459,6 +459,9 @@ class CChain {\n \n     /** Find the last common block between this chain and a block index entry. */\n     const CBlockIndex *FindFork(const CBlockIndex *pindex) const;\n+\n+    /** Find the most recent block with timestamp lower than the given. */\n+    CBlockIndex* FindLatestBefore(int64_t nTime) const;\n };\n \n #endif // BITCOIN_CHAIN_H"
      },
      {
        "sha": "8370a0f43effbc37763c5593a3f2d52fde6933e6",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cb08fdbf78685b55029768524ca867772711c32b/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cb08fdbf78685b55029768524ca867772711c32b/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=cb08fdbf78685b55029768524ca867772711c32b",
        "patch": "@@ -95,6 +95,8 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"importaddress\", 2 },\n     { \"importaddress\", 3 },\n     { \"importpubkey\", 2 },\n+    { \"importmulti\", 0 },\n+    { \"importmulti\", 1 },\n     { \"verifychain\", 0 },\n     { \"verifychain\", 1 },\n     { \"keypoolrefill\", 0 },"
      },
      {
        "sha": "0297337c2a3997e96b598025ddf5654b6b9f03a6",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 390,
        "deletions": 0,
        "changes": 390,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cb08fdbf78685b55029768524ca867772711c32b/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cb08fdbf78685b55029768524ca867772711c32b/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=cb08fdbf78685b55029768524ca867772711c32b",
        "patch": "@@ -24,6 +24,7 @@\n \n #include <univalue.h>\n \n+#include <boost/assign/list_of.hpp>\n #include <boost/foreach.hpp>\n \n using namespace std;\n@@ -637,3 +638,392 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     file.close();\n     return NullUniValue;\n }\n+\n+\n+UniValue processImport(const UniValue& data) {\n+    // TODO List:\n+    // - Check consistency between pubkeys/privkeys and scriptPubKey/redeemScript.\n+\n+    try {\n+        bool success = false;\n+\n+        // Required fields.\n+        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+\n+        // Should have script or JSON with \"address\".\n+        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+        }\n+\n+        // Optional fields.\n+        const string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+        const bool& internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        const bool& watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n+        const int64_t& timestamp = data.exists(\"timestamp\") && data[\"timestamp\"].get_int64() > 1 ? data[\"timestamp\"].get_int64() : 1;\n+\n+        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+        bool isP2SH = strRedeemScript.length() > 0;\n+        const string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+        // Parse the output.\n+        CScript script;\n+        CBitcoinAddress address;\n+\n+        if (!isScript) {\n+            address = CBitcoinAddress(output);\n+            script = GetScriptForDestination(address.Get());\n+        } else {\n+            if (!IsHex(output)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n+            }\n+\n+            std::vector<unsigned char> vData(ParseHex(output));\n+            script = CScript(vData.begin(), vData.end());\n+        }\n+\n+        // Watchonly and private keys\n+        if (watchOnly && keys.size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n+\n+        // Internal + Label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+\n+        // Not having Internal + Script\n+        if (!internal && isScript) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set for hex scriptPubKey\");\n+        }\n+\n+        // Keys / PubKeys size check.\n+        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n+        }\n+\n+        // Invalid P2SH redeemScript\n+        if (isP2SH && !IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n+        }\n+\n+        // Process. //\n+\n+        // P2SH\n+        if (isP2SH) {\n+            // TODO: check consistency between private keys and p2sh redeemscript + p2sh address\n+\n+            // Import redeem script.\n+            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+            CScript redeemScript = CScript(vData.begin(), vData.end());\n+\n+            // Invalid P2SH address\n+            if (!script.IsPayToScriptHash()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemScript) && !pwalletMain->AddWatchOnly(redeemScript)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+\n+            if (!pwalletMain->HaveCScript(redeemScript) && !pwalletMain->AddCScript(redeemScript)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+            }\n+\n+            CBitcoinAddress redeemAddress = CBitcoinAddress(CScriptID(redeemScript));\n+            CScript redeemDestination = GetScriptForDestination(redeemAddress.Get());\n+\n+            if (::IsMine(*pwalletMain, redeemDestination) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n+\n+            pwalletMain->MarkDirty();\n+\n+            if (!pwalletMain->HaveWatchOnly(redeemDestination) && !pwalletMain->AddWatchOnly(redeemDestination)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            }\n+\n+            // add to address book or update label\n+            if (address.IsValid()) {\n+                pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+            }\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                for (size_t i = 0; i < keys.size(); i++) {\n+                    const string& privkey = keys[i].get_str();\n+\n+                    CBitcoinSecret vchSecret;\n+                    bool fGood = vchSecret.SetString(privkey);\n+\n+                    if (!fGood) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+                    }\n+\n+                    CKey key = vchSecret.GetKey();\n+\n+                    if (!key.IsValid()) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+                    }\n+\n+                    CPubKey pubkey = key.GetPubKey();\n+                    assert(key.VerifyPubKey(pubkey));\n+\n+                    CKeyID vchAddress = pubkey.GetID();\n+                    pwalletMain->MarkDirty();\n+                    pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                    if (pwalletMain->HaveKey(vchAddress)) {\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+                    }\n+\n+                    pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                    if (!pwalletMain->AddKeyPubKey(key, pubkey)) {\n+                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+                    }\n+\n+                    if (timestamp < pwalletMain->nTimeFirstKey) {\n+                        pwalletMain->nTimeFirstKey = timestamp;\n+                    }\n+                }\n+            }\n+\n+            success = true;\n+        } else {\n+            // TODO: check consistency between private/public keys and scriptPubKey / address\n+\n+            // Import public keys.\n+            if (pubKeys.size() && keys.size() == 0) {\n+                const string& strPubKey = pubKeys[0].get_str();\n+\n+                if (!IsHex(strPubKey)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+                }\n+\n+                std::vector<unsigned char> data(ParseHex(strPubKey));\n+                CPubKey pubKey(data.begin(), data.end());\n+\n+                if (!pubKey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n+                }\n+\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+                CScript pubKeyScript = GetScriptForDestination(pubKeyAddress.Get());\n+\n+                if (::IsMine(*pwalletMain, pubKeyScript) == ISMINE_SPENDABLE) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+                }\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(pubKeyScript) && !pwalletMain->AddWatchOnly(pubKeyScript)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                }\n+\n+                // add to address book or update label\n+                if (pubKeyAddress.IsValid()) {\n+                    pwalletMain->SetAddressBook(pubKeyAddress.Get(), label, \"receive\");\n+                }\n+\n+                // TODO Is this necessary?\n+                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+\n+                if (::IsMine(*pwalletMain, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+                }\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(scriptRawPubKey) && !pwalletMain->AddWatchOnly(scriptRawPubKey)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                }\n+\n+                success = true;\n+            }\n+\n+            // Import private keys.\n+            if (keys.size()) {\n+                const string& strPrivkey = keys[0].get_str();\n+\n+                // Checks.\n+                CBitcoinSecret vchSecret;\n+                bool fGood = vchSecret.SetString(strPrivkey);\n+\n+                if (!fGood) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+                }\n+\n+                CKey key = vchSecret.GetKey();\n+                if (!key.IsValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+                }\n+\n+                CPubKey pubKey = key.GetPubKey();\n+                assert(key.VerifyPubKey(pubKey));\n+\n+                CKeyID vchAddress = pubkey.GetID();\n+                pwalletMain->MarkDirty();\n+                pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+\n+                if (pwalletMain->HaveKey(vchAddress)) {\n+                    return false;\n+                }\n+\n+                pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+\n+                if (!pwalletMain->AddKeyPubKey(key, pubKey)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+                }\n+\n+                if (timestamp < pwalletMain->nTimeFirstKey) {\n+                    pwalletMain->nTimeFirstKey = timestamp;\n+                }\n+\n+                success = true;\n+            }\n+\n+            // Import scriptPubKey only.\n+            if (pubKeys.size() == 0 && keys.size() == 0) {\n+                if (::IsMine(*pwalletMain, script) == ISMINE_SPENDABLE) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+                }\n+\n+                pwalletMain->MarkDirty();\n+\n+                if (!pwalletMain->HaveWatchOnly(script) && !pwalletMain->AddWatchOnly(script)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                }\n+\n+                if (scriptPubKey.getType() == UniValue::VOBJ) {\n+                    // add to address book or update label\n+                    if (address.IsValid()) {\n+                        pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+                    }\n+                }\n+\n+                success = true;\n+            }\n+        }\n+\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(success));\n+        return result;\n+    } catch (const UniValue& e) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", e);\n+        return result;\n+    } catch (...) {\n+        UniValue result = UniValue(UniValue::VOBJ);\n+        result.pushKV(\"success\", UniValue(false));\n+        result.pushKV(\"error\", JSONRPCError(RPC_MISC_ERROR, \"Missing required fields\"));\n+        return result;\n+    }\n+}\n+\n+UniValue importmulti(const JSONRPCRequest& mainRequest)\n+{\n+    // clang-format off\n+    if (mainRequest.fHelp || mainRequest.params.size() < 1 || mainRequest.params.size() > 2)\n+        throw runtime_error(\n+            \"importmulti '[<json import requests>]' '<json options>' \\n\\n\"\n+            \"Import addresses/scripts (with private or public keys, redeem script (P2SH)), rescanning all addresses in one-shot-only (rescan can be disabled via options).\\n\\n\"\n+            \"Arguments:\\n\"\n+            \"1. request array     (array, required) Data to be imported\\n\"\n+            \"  [     (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"scriptPubKey\\\": \\\"<script>\\\" | { \\\"address\\\":\\\"<address>\\\" }, (string / json, required) Type of scriptPubKey (string for script, json for address)\\n\"\n+            \"      \\\"redeemscript\\\": \\\"<script>\\\"                            , (string, optional) Allowed only if the scriptPubKey is a P2SH address or a P2SH scriptPubKey\\n\"\n+            \"      \\\"pubkeys\\\": [\\\"<pubKey>\\\", ... ]                         , (array, optional) Array of strings giving pubkeys that must occur in the output or redeemscript\\n\"\n+            \"      \\\"keys\\\": [\\\"<key>\\\", ... ]                               , (array, optional) Array of strings giving private keys whose corresponding public keys must occur in the output or redeemscript\\n\"\n+            \"      \\\"internal\\\": <true>                                    , (boolean, optional, default: false) Stating whether matching outputs should be be treated as not incoming payments\\n\"\n+            \"      \\\"watchonly\\\": <true>                                   , (boolean, optional, default: false) Stating whether matching outputs should be considered watched even when they're not spendable, only allowed if keys are empty\\n\"\n+            \"      \\\"label\\\": <label>                                      , (string, optional, default: '') Label to assign to the address (aka account name, for now), only allowed with internal=false\\n\"\n+            \"      \\\"timestamp\\\": 1454686740,                                (integer, optional, default now) Timestamp\\n\"\n+            \"    }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"2. json options                 (json, optional)\\n\"\n+            \"  {\\n\"\n+            \"     \\\"rescan\\\": <false>,         (boolean, optional, default: true) Stating if should rescan the blockchain after all imports\\n\"\n+            \"  }\\n\"\n+            \"\\nExamples:\\n\" +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }, \"\n+                                          \"{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my 2nd address>\\\" }, \\\"label\\\": \\\"example 2\\\", \\\"timestamp\\\": 1455191480 }]'\") +\n+            HelpExampleCli(\"importmulti\", \"'[{ \\\"scriptPubKey\\\": { \\\"address\\\": \\\"<my address>\\\" }, \\\"timestamp\\\":1455191478 }]' '{ \\\"rescan\\\": false}'\") +\n+\n+            \"\\nResponse is an array with the same size as the input that has the execution result :\\n\"\n+            \"  [{ \\\"success\\\": true } , { \\\"success\\\": false, \\\"error\\\": { \\\"code\\\": -1, \\\"message\\\": \\\"Internal Server Error\\\"} }, ... ]\\n\");\n+\n+    // clang-format on\n+    if (!EnsureWalletIsAvailable(mainRequest.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    RPCTypeCheck(mainRequest.params, boost::assign::list_of(UniValue::VARR)(UniValue::VOBJ));\n+\n+    const UniValue& requests = mainRequest.params[0];\n+\n+    //Default options\n+    bool fRescan = true;\n+\n+    if (mainRequest.params.size() > 1) {\n+        const UniValue& options = mainRequest.params[1];\n+\n+        if (options.exists(\"rescan\")) {\n+            fRescan = options[\"rescan\"].get_bool();\n+        }\n+    }\n+\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+\n+    bool fRunScan = false;\n+    const int64_t minimumTimestamp = 1;\n+    int64_t nLowestTimestamp;\n+\n+    if (fRescan && chainActive.Tip()) {\n+        nLowestTimestamp = chainActive.Tip()->GetBlockTime();\n+    } else {\n+        fRescan = false;\n+    }\n+\n+    UniValue response(UniValue::VARR);\n+\n+    BOOST_FOREACH (const UniValue& data, requests.getValues()) {\n+        const UniValue result = processImport(data);\n+        response.push_back(result);\n+\n+        if (!fRescan) {\n+            continue;\n+        }\n+\n+        // If at least one request was successful then allow rescan.\n+        if (result[\"success\"].get_bool()) {\n+            fRunScan = true;\n+        }\n+\n+        // Get the lowest timestamp.\n+        const int64_t& timestamp = data.exists(\"timestamp\") && data[\"timestamp\"].get_int64() > minimumTimestamp ? data[\"timestamp\"].get_int64() : minimumTimestamp;\n+\n+        if (timestamp < nLowestTimestamp) {\n+            nLowestTimestamp = timestamp;\n+        }\n+    }\n+\n+    if (fRescan && fRunScan && requests.size() && nLowestTimestamp <= chainActive.Tip()->GetBlockTime()) {\n+        CBlockIndex* pindex = nLowestTimestamp > minimumTimestamp ? chainActive.FindLatestBefore(nLowestTimestamp) : chainActive.Genesis();\n+\n+        if (pindex) {\n+            pwalletMain->ScanForWalletTransactions(pindex, true);\n+            pwalletMain->ReacceptWalletTransactions();\n+        }\n+    }\n+\n+    return response;\n+}"
      },
      {
        "sha": "ab7e74988a00fd1b0fb36c2e3ec4dc065f27261a",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cb08fdbf78685b55029768524ca867772711c32b/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cb08fdbf78685b55029768524ca867772711c32b/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=cb08fdbf78685b55029768524ca867772711c32b",
        "patch": "@@ -2583,6 +2583,7 @@ extern UniValue dumpwallet(const JSONRPCRequest& request);\n extern UniValue importwallet(const JSONRPCRequest& request);\n extern UniValue importprunedfunds(const JSONRPCRequest& request);\n extern UniValue removeprunedfunds(const JSONRPCRequest& request);\n+extern UniValue importmulti(const JSONRPCRequest& request);\n \n static const CRPCCommand commands[] =\n { //  category              name                        actor (function)           okSafeMode\n@@ -2607,6 +2608,7 @@ static const CRPCCommand commands[] =\n     { \"wallet\",             \"gettransaction\",           &gettransaction,           false },\n     { \"wallet\",             \"getunconfirmedbalance\",    &getunconfirmedbalance,    false },\n     { \"wallet\",             \"getwalletinfo\",            &getwalletinfo,            false },\n+    { \"wallet\",             \"importmulti\",              &importmulti,              true  },\n     { \"wallet\",             \"importprivkey\",            &importprivkey,            true  },\n     { \"wallet\",             \"importwallet\",             &importwallet,             true  },\n     { \"wallet\",             \"importaddress\",            &importaddress,            true  },"
      }
    ]
  },
  {
    "sha": "215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMTVjYWJhNGVkNDU0N2Q2ZjJhMDk1NGZhOWZlMWFlNzhmNGE3YzQw",
    "commit": {
      "author": {
        "name": "Pedro Branco",
        "email": "branco@uphold.com",
        "date": "2016-10-19T14:17:42Z"
      },
      "committer": {
        "name": "Pedro Branco",
        "email": "branco@uphold.com",
        "date": "2016-10-19T14:17:42Z"
      },
      "message": "Add consistency check to RPC call importmulti",
      "tree": {
        "sha": "da88271ec1e64d3307c04522c87632791f14a5fb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/da88271ec1e64d3307c04522c87632791f14a5fb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "cb08fdbf78685b55029768524ca867772711c32b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cb08fdbf78685b55029768524ca867772711c32b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cb08fdbf78685b55029768524ca867772711c32b"
      }
    ],
    "stats": {
      "total": 117,
      "additions": 108,
      "deletions": 9
    },
    "files": [
      {
        "sha": "5c536f2f4952860259ea72642dd6a3870ad32eb4",
        "filename": "qa/rpc-tests/importmulti.py",
        "status": "modified",
        "additions": 68,
        "deletions": 1,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40/qa/rpc-tests/importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40/qa/rpc-tests/importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/importmulti.py?ref=215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
        "patch": "@@ -285,9 +285,76 @@ def run_test (self):\n         assert_equal(result[0]['error']['code'], -8)\n         assert_equal(result[0]['error']['message'], 'Incompatibility found between watchonly and keys')\n \n-        # TODO Consistency tests?\n \n+        # Address + Public key + !Internal + Wrong pubkey\n+        print(\"Should not import an address with a wrong public key\")\n+        address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        address2 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": address['address']\n+            },\n+            \"pubkeys\": [ address2['pubkey'] ]\n+        }])\n+        assert_equal(result[0]['success'], False)\n+        assert_equal(result[0]['error']['code'], -5)\n+        assert_equal(result[0]['error']['message'], 'Consistency check failed')\n+        address_assert = self.nodes[1].validateaddress(address['address'])\n+        assert_equal(address_assert['iswatchonly'], False)\n+        assert_equal(address_assert['ismine'], False)\n+\n+\n+        # ScriptPubKey + Public key + internal + Wrong pubkey\n+        print(\"Should not import a scriptPubKey with internal and with a wrong public key\")\n+        address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        address2 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        request = [{\n+            \"scriptPubKey\": address['scriptPubKey'],\n+            \"pubkeys\": [ address2['pubkey'] ],\n+            \"internal\": True\n+        }];\n+        result = self.nodes[1].importmulti(request)\n+        assert_equal(result[0]['success'], False)\n+        assert_equal(result[0]['error']['code'], -5)\n+        assert_equal(result[0]['error']['message'], 'Consistency check failed')\n+        address_assert = self.nodes[1].validateaddress(address['address'])\n+        assert_equal(address_assert['iswatchonly'], False)\n+        assert_equal(address_assert['ismine'], False)\n \n \n+        # Address + Private key + !watchonly + Wrong private key\n+        print(\"Should not import an address with a wrong private key\")\n+        address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        address2 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": address['address']\n+            },\n+            \"keys\": [ self.nodes[0].dumpprivkey(address2['address']) ]\n+        }])\n+        assert_equal(result[0]['success'], False)\n+        assert_equal(result[0]['error']['code'], -5)\n+        assert_equal(result[0]['error']['message'], 'Consistency check failed')\n+        address_assert = self.nodes[1].validateaddress(address['address'])\n+        assert_equal(address_assert['iswatchonly'], False)\n+        assert_equal(address_assert['ismine'], False)\n+\n+\n+        # ScriptPubKey + Private key + internal + Wrong private key\n+        print(\"Should not import a scriptPubKey with internal and with a wrong private key\")\n+        address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        address2 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": address['scriptPubKey'],\n+            \"keys\": [ self.nodes[0].dumpprivkey(address2['address']) ],\n+            \"internal\": True\n+        }])\n+        assert_equal(result[0]['success'], False)\n+        assert_equal(result[0]['error']['code'], -5)\n+        assert_equal(result[0]['error']['message'], 'Consistency check failed')\n+        address_assert = self.nodes[1].validateaddress(address['address'])\n+        assert_equal(address_assert['iswatchonly'], False)\n+        assert_equal(address_assert['ismine'], False)\n+\n if __name__ == '__main__':\n     ImportMultiTest ().main ()"
      },
      {
        "sha": "7b16b4adfb32481d438757acf870b27cd9ec3cfa",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 40,
        "deletions": 8,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=215caba4ed4547d6f2a0954fa9fe1ae78f4a7c40",
        "patch": "@@ -641,9 +641,6 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n \n \n UniValue processImport(const UniValue& data) {\n-    // TODO List:\n-    // - Check consistency between pubkeys/privkeys and scriptPubKey/redeemScript.\n-\n     try {\n         bool success = false;\n \n@@ -713,8 +710,6 @@ UniValue processImport(const UniValue& data) {\n \n         // P2SH\n         if (isP2SH) {\n-            // TODO: check consistency between private keys and p2sh redeemscript + p2sh address\n-\n             // Import redeem script.\n             std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n             CScript redeemScript = CScript(vData.begin(), vData.end());\n@@ -795,8 +790,6 @@ UniValue processImport(const UniValue& data) {\n \n             success = true;\n         } else {\n-            // TODO: check consistency between private/public keys and scriptPubKey / address\n-\n             // Import public keys.\n             if (pubKeys.size() && keys.size() == 0) {\n                 const string& strPubKey = pubKeys[0].get_str();\n@@ -813,6 +806,25 @@ UniValue processImport(const UniValue& data) {\n                 }\n \n                 CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n                 CScript pubKeyScript = GetScriptForDestination(pubKeyAddress.Get());\n \n                 if (::IsMine(*pwalletMain, pubKeyScript) == ISMINE_SPENDABLE) {\n@@ -866,7 +878,27 @@ UniValue processImport(const UniValue& data) {\n                 CPubKey pubKey = key.GetPubKey();\n                 assert(key.VerifyPubKey(pubKey));\n \n-                CKeyID vchAddress = pubkey.GetID();\n+                CBitcoinAddress pubKeyAddress = CBitcoinAddress(pubKey.GetID());\n+\n+                // Consistency check.\n+                if (!isScript && pubKeyAddress.Get() != address.Get()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                }\n+\n+                // Consistency check.\n+                if (isScript) {\n+                    CBitcoinAddress scriptAddress;\n+                    CTxDestination destination;\n+\n+                    if (ExtractDestination(script, destination)) {\n+                        scriptAddress = CBitcoinAddress(destination);\n+                        if (scriptAddress.Get() != pubKeyAddress.Get()) {\n+                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n+                        }\n+                    }\n+                }\n+\n+                CKeyID vchAddress = pubKey.GetID();\n                 pwalletMain->MarkDirty();\n                 pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n "
      }
    ]
  }
]