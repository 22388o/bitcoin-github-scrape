[
  {
    "sha": "e025121c1ca4b86296c6b36386786522bd79a6e1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMDI1MTIxYzFjYTRiODYyOTZjNmIzNjM4Njc4NjUyMmJkNzlhNmUx",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-05-19T15:39:05Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-09-29T08:30:32Z"
      },
      "message": "net: CAddress & CAddrMan: (un)serialize as ADDRv2\n\nChange the serialization of `CAddrMan` to serialize its addresses\nin ADDRv2/BIP155 format by default. Introduce a new `CAddrMan` format\nversion (3).\n\nAdd support for ADDRv2 format in `CAddress` (un)serialization.\n\nCo-authored-by: Carl Dong <contact@carldong.me>",
      "tree": {
        "sha": "fb5439ad08a93cc2056f8f1ce38511156f2c03ef",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fb5439ad08a93cc2056f8f1ce38511156f2c03ef"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e025121c1ca4b86296c6b36386786522bd79a6e1",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAl9y8KkACgkQVN8G9ktV\ny78wQx//XRniFwTpSdTvpbef+CtLer8yK6eWuAqwfKcEYPUmut8nc53LEp6dwyOH\njTr6kwzV1k6wwAI/IDISbMBZYbUGPeQLQw+uRubcanUsQL047K3DcVIdqjMWGe2z\nbe5lqqEXVaGV4ucg7+9YqrPWoAaX0PqZp7LljrYYDy/sN8VA3p3Y0pD96zT/QRWm\nxzz5qIXu/wfF/jTv19J50Wk3+cC6cWgolpWyb5gLVlNDcsz/UETAYrXUriMlzjFx\n8OGvv50vP0uqG4WIh/5nVlgqB7WMtTkU9EeM6OdP5nCQYumP7qz9er1ZWDmriksd\n5yWLOfb73thKAKzp2qQ1iRKO2GiDgz55mAccqXzUQwnvhvGLk/WC4vSPrJoCPjUZ\n3+N/hiAVM4PdBWA9YGOIahrAkZnOWg8yMEgqugXjuVe69SdywYq14tQBtV+7I0mA\nFcvjSFr5EPt9dIpDihcbjAihoblSDBwbExSp6jzp+1tMQ/M3dqzKaaBqXDrwCZ66\nUk1RmQNSjnfoc6zPIejBgNZ0RaLQVy0ArnT9jXIqlBH32EW1PwZCuevDEr1KM4/t\nRHF0KdHTHPTnWXduTFPGVeX/nh44nOru/9lSb9HEaWs4WS1Jp+WUjn9xELBvJZ3M\n36yASD+ruwzGS83Q4wk2kyXcQMMF2osVFlKhFyqxo7DloEsLeXaGkERyOE108F+x\n7+zuozd4pTBgX1WHZjXcb8p0UYB/6LzwjHd75/l+cxQ0v5G9xwl4UTc3EZ4Tb824\n/YPcw0Pp65AHfG9ls6qe2KQVDLvFDaqBX6keQsI07QU0wIv7xOLQa05ojU3B/ycM\nEhVR1cpQaYZN1RNX44K+l8PiHicJ4TvazBSFaL/i+hgkwMinnKU94VvBg50IGYMj\nFh/8KzPpRFlIxH3jPqoATi09wGqxD6/1opt+9/qXXF+dNjvU6rPL6IlA+aQ8tD7N\nqL3mzOwX7WtOQfRcyxpMRo81XqSOq+EsAeB79giHlW/02k+HebEYsUAVRZvgOQRA\n0nBFEvHJnjFl2Tdk3Fc8zGyzZKH+MYShaQFX/TUqCscv/nece5v1oaiLH1uR1BmC\n/lEZrtTl8AMkfeqzZoqRWcAmG5YyrhkRmW/OSV2iSgJowU3P60hZbXlk/IJfqGOT\nmXNqjnr0r2SIb7sKZVX5e4/pOH61+7qXeFMYgRg6OI8mrKdkU9CmFDFIfhSUqm9s\nZuxi2qY/p1x8CrCWlPGq8D5PIYxvC249/K+mrtVTRiaO+3i1iANTJxWHqpsg5IM1\nmBglMAnT0uQZNXHT8YScLd9auF96w2vSoTafACIweIboaIeaBLxHC9NjMX7993k6\noQx9jd1O3P2/9oiGLgHy6EK3rWa9Iw==\n=gP/0\n-----END PGP SIGNATURE-----",
        "payload": "tree fb5439ad08a93cc2056f8f1ce38511156f2c03ef\nparent 6af9b31bfc6dd6086d245c00eb7cff762fc34a1e\nauthor Vasil Dimov <vd@FreeBSD.org> 1589902745 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1601368232 +0200\n\nnet: CAddress & CAddrMan: (un)serialize as ADDRv2\n\nChange the serialization of `CAddrMan` to serialize its addresses\nin ADDRv2/BIP155 format by default. Introduce a new `CAddrMan` format\nversion (3).\n\nAdd support for ADDRv2 format in `CAddress` (un)serialization.\n\nCo-authored-by: Carl Dong <contact@carldong.me>\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e025121c1ca4b86296c6b36386786522bd79a6e1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e025121c1ca4b86296c6b36386786522bd79a6e1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e025121c1ca4b86296c6b36386786522bd79a6e1/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6af9b31bfc6dd6086d245c00eb7cff762fc34a1e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6af9b31bfc6dd6086d245c00eb7cff762fc34a1e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6af9b31bfc6dd6086d245c00eb7cff762fc34a1e"
      }
    ],
    "stats": {
      "total": 208,
      "additions": 193,
      "deletions": 15
    },
    "files": [
      {
        "sha": "accb8e52de28911f3e329d06161724e99e6f1cc9",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 43,
        "deletions": 10,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e025121c1ca4b86296c6b36386786522bd79a6e1/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e025121c1ca4b86296c6b36386786522bd79a6e1/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=e025121c1ca4b86296c6b36386786522bd79a6e1",
        "patch": "@@ -264,6 +264,17 @@ friend class CAddrManTest;\n     void SetServices_(const CService &addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n public:\n+    //! Serialization versions.\n+    enum class Format : uint8_t {\n+        V0 = 0, //!< historic format, before commit e6b343d88\n+        V1 = 1, //!< for pre-asmap files\n+        V2 = 2, //!< for files including asmap version\n+        V3 = 3, //!< same as V2 plus addresses are in BIP155 format\n+    };\n+\n+    //! Serialization / unserialization format.\n+    Format m_format = Format::V3;\n+\n     // Compressed IP->ASN mapping, loaded from a file when a node starts.\n     // Should be always empty if no file was provided.\n     // This mapping is then used for bucketing nodes in Addrman.\n@@ -285,8 +296,8 @@ friend class CAddrManTest;\n \n \n     /**\n-     * serialized format:\n-     * * version byte (1 for pre-asmap files, 2 for files including asmap version)\n+     * Serialized format.\n+     * * version byte (@see `Format`)\n      * * 0x20 + nKey (serialized as if it were a vector, for backward compatibility)\n      * * nNew\n      * * nTried\n@@ -318,8 +329,15 @@ friend class CAddrManTest;\n     {\n         LOCK(cs);\n \n-        unsigned char nVersion = 2;\n-        s << nVersion;\n+        const auto stream_version_orig = s.GetVersion();\n+\n+        if (m_format >= Format::V3) {\n+            // Add ADDRV2_FORMAT to the version so that the CNetAddr and CAddress\n+            // serialize methods produce an address in v2 format.\n+            s.SetVersion(stream_version_orig | ADDRV2_FORMAT);\n+        }\n+\n+        s << (uint8_t)m_format;\n         s << ((unsigned char)32);\n         s << nKey;\n         s << nNew;\n@@ -368,6 +386,8 @@ friend class CAddrManTest;\n             asmap_version = SerializeHash(m_asmap);\n         }\n         s << asmap_version;\n+\n+        s.SetVersion(stream_version_orig);\n     }\n \n     template<typename Stream>\n@@ -376,8 +396,17 @@ friend class CAddrManTest;\n         LOCK(cs);\n \n         Clear();\n-        unsigned char nVersion;\n-        s >> nVersion;\n+\n+        const auto stream_version_orig = s.GetVersion();\n+\n+        uint8_t format_tmp;\n+        s >> format_tmp;\n+        m_format = (Format)format_tmp;\n+        if (m_format >= Format::V3) {\n+            // Add ADDRV2_FORMAT to the version so that the CNetAddr and CAddress\n+            // unserialize methods know that an address in v2 format is coming.\n+            s.SetVersion(stream_version_orig | ADDRV2_FORMAT);\n+        }\n         unsigned char nKeySize;\n         s >> nKeySize;\n         if (nKeySize != 32) throw std::ios_base::failure(\"Incorrect keysize in addrman deserialization\");\n@@ -386,15 +415,17 @@ friend class CAddrManTest;\n         s >> nTried;\n         int nUBuckets = 0;\n         s >> nUBuckets;\n-        if (nVersion != 0) {\n+        if (m_format > Format::V0) {\n             nUBuckets ^= (1 << 30);\n         }\n \n         if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE) {\n+            s.SetVersion(stream_version_orig);\n             throw std::ios_base::failure(\"Corrupt CAddrMan serialization, nNew exceeds limit.\");\n         }\n \n         if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE) {\n+            s.SetVersion(stream_version_orig);\n             throw std::ios_base::failure(\"Corrupt CAddrMan serialization, nTried exceeds limit.\");\n         }\n \n@@ -449,21 +480,21 @@ friend class CAddrManTest;\n             supplied_asmap_version = SerializeHash(m_asmap);\n         }\n         uint256 serialized_asmap_version;\n-        if (nVersion > 1) {\n+        if (m_format > Format::V1) {\n             s >> serialized_asmap_version;\n         }\n \n         for (int n = 0; n < nNew; n++) {\n             CAddrInfo &info = mapInfo[n];\n             int bucket = entryToBucket[n];\n             int nUBucketPos = info.GetBucketPosition(nKey, true, bucket);\n-            if (nVersion == 2 && nUBuckets == ADDRMAN_NEW_BUCKET_COUNT && vvNew[bucket][nUBucketPos] == -1 &&\n+            if (m_format >= Format::V2 && nUBuckets == ADDRMAN_NEW_BUCKET_COUNT && vvNew[bucket][nUBucketPos] == -1 &&\n                 info.nRefCount < ADDRMAN_NEW_BUCKETS_PER_ADDRESS && serialized_asmap_version == supplied_asmap_version) {\n                 // Bucketing has not changed, using existing bucket positions for the new table\n                 vvNew[bucket][nUBucketPos] = n;\n                 info.nRefCount++;\n             } else {\n-                // In case the new table data cannot be used (nVersion unknown, bucket count wrong or new asmap),\n+                // In case the new table data cannot be used (m_format unknown, bucket count wrong or new asmap),\n                 // try to give them a reference based on their primary source address.\n                 LogPrint(BCLog::ADDRMAN, \"Bucketing method was updated, re-bucketing addrman entries from disk\\n\");\n                 bucket = info.GetNewBucket(nKey, m_asmap);\n@@ -491,6 +522,8 @@ friend class CAddrManTest;\n         }\n \n         Check();\n+\n+        s.SetVersion(stream_version_orig);\n     }\n \n     void Clear()"
      },
      {
        "sha": "535c9d8087d496e896455d1ea8aee153f70196f1",
        "filename": "src/hash.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e025121c1ca4b86296c6b36386786522bd79a6e1/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e025121c1ca4b86296c6b36386786522bd79a6e1/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.h?ref=e025121c1ca4b86296c6b36386786522bd79a6e1",
        "patch": "@@ -102,13 +102,14 @@ class CHashWriter\n     CSHA256 ctx;\n \n     const int nType;\n-    const int nVersion;\n+    int nVersion;\n public:\n \n     CHashWriter(int nTypeIn, int nVersionIn) : nType(nTypeIn), nVersion(nVersionIn) {}\n \n     int GetType() const { return nType; }\n     int GetVersion() const { return nVersion; }\n+    void SetVersion(int n) { nVersion = n; }\n \n     void write(const char *pch, size_t size) {\n         ctx.Write((const unsigned char*)pch, size);"
      },
      {
        "sha": "50d2bfb440653263a480bc4f5a77309e2f59aecb",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 10,
        "deletions": 2,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e025121c1ca4b86296c6b36386786522bd79a6e1/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e025121c1ca4b86296c6b36386786522bd79a6e1/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=e025121c1ca4b86296c6b36386786522bd79a6e1",
        "patch": "@@ -351,7 +351,8 @@ class CAddress : public CService\n \n public:\n     CAddress() : CService{} {};\n-    explicit CAddress(CService ipIn, ServiceFlags nServicesIn) : CService{ipIn}, nServices{nServicesIn} {};\n+    CAddress(CService ipIn, ServiceFlags nServicesIn) : CService{ipIn}, nServices{nServicesIn} {};\n+    CAddress(CService ipIn, ServiceFlags nServicesIn, uint32_t nTimeIn) : CService{ipIn}, nTime{nTimeIn}, nServices{nServicesIn} {};\n \n     SERIALIZE_METHODS(CAddress, obj)\n     {\n@@ -370,7 +371,14 @@ class CAddress : public CService\n             // nTime.\n             READWRITE(obj.nTime);\n         }\n-        READWRITE(Using<CustomUintFormatter<8>>(obj.nServices));\n+        if (nVersion & ADDRV2_FORMAT) {\n+            uint64_t services_tmp;\n+            SER_WRITE(obj, services_tmp = obj.nServices);\n+            READWRITE(COMPACTSIZE(services_tmp));\n+            SER_READ(obj, obj.nServices = static_cast<ServiceFlags>(services_tmp));\n+        } else {\n+            READWRITE(Using<CustomUintFormatter<8>>(obj.nServices));\n+        }\n         READWRITEAS(CService, obj);\n     }\n "
      },
      {
        "sha": "668ea5deb286f8896281836389474d540eebe4be",
        "filename": "src/streams.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e025121c1ca4b86296c6b36386786522bd79a6e1/src/streams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e025121c1ca4b86296c6b36386786522bd79a6e1/src/streams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/streams.h?ref=e025121c1ca4b86296c6b36386786522bd79a6e1",
        "patch": "@@ -602,7 +602,7 @@ class CAutoFile\n {\n private:\n     const int nType;\n-    const int nVersion;\n+    int nVersion;\n \n     FILE* file;\n \n@@ -650,6 +650,7 @@ class CAutoFile\n     //\n     int GetType() const          { return nType; }\n     int GetVersion() const       { return nVersion; }\n+    void SetVersion(int n)       { nVersion = n; }\n \n     void read(char* pch, size_t nSize)\n     {"
      },
      {
        "sha": "987ef1efdbf5c8ad40651390e25901bea2821ee6",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 1,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e025121c1ca4b86296c6b36386786522bd79a6e1/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e025121c1ca4b86296c6b36386786522bd79a6e1/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=e025121c1ca4b86296c6b36386786522bd79a6e1",
        "patch": "@@ -80,7 +80,7 @@ static CDataStream AddrmanToStream(CAddrManSerializationMock& _addrman)\n     ssPeersIn << _addrman;\n     std::string str = ssPeersIn.str();\n     std::vector<unsigned char> vchData(str.begin(), str.end());\n-    return CDataStream(vchData, SER_DISK, CLIENT_VERSION);\n+    return CDataStream(vchData, ssPeersIn.GetType(), ssPeersIn.GetVersion());\n }\n \n BOOST_FIXTURE_TEST_SUITE(net_tests, BasicTestingSetup)\n@@ -142,6 +142,36 @@ BOOST_AUTO_TEST_CASE(caddrdb_read)\n     BOOST_CHECK(addrman2.size() == 3);\n }\n \n+BOOST_AUTO_TEST_CASE(caddrdb_read_v1_ser)\n+{\n+    // Construct an AddrMan that serializes addresses in pre-BIP155 format.\n+    CAddrManUncorrupted addrmanUncorrupted;\n+    addrmanUncorrupted.m_format = CAddrMan::Format::V2;\n+    addrmanUncorrupted.MakeDeterministic();\n+\n+    CService addr1, addr2, addr3;\n+    BOOST_CHECK(Lookup(\"250.7.1.1\", addr1, 8333, false));\n+    BOOST_CHECK(Lookup(\"250.7.2.2\", addr2, 9999, false));\n+    BOOST_CHECK(Lookup(\"250.7.3.3\", addr3, 9999, false));\n+\n+    // Add three addresses to new table.\n+    CService source;\n+    BOOST_CHECK(Lookup(\"252.5.1.1\", source, 8333, false));\n+    BOOST_CHECK(addrmanUncorrupted.Add(CAddress(addr1, NODE_NONE), source));\n+    BOOST_CHECK(addrmanUncorrupted.Add(CAddress(addr2, NODE_NONE), source));\n+    BOOST_CHECK(addrmanUncorrupted.Add(CAddress(addr3, NODE_NONE), source));\n+\n+    // Test that the de-serialization does not throw an exception.\n+    CDataStream ssPeers1 = AddrmanToStream(addrmanUncorrupted);\n+    CAddrMan addrman1;\n+\n+    BOOST_CHECK(addrman1.size() == 0);\n+    unsigned char message_start[4];\n+    ssPeers1 >> message_start;\n+    ssPeers1 >> addrman1;\n+    BOOST_CHECK_EQUAL(addrman1.m_format, CAddrMan::Format::V2);\n+    BOOST_CHECK_EQUAL(addrman1.size(), 3U);\n+}\n \n BOOST_AUTO_TEST_CASE(caddrdb_read_corrupted)\n {"
      },
      {
        "sha": "eb0d95a373d4344d602941c24cd60db78807b64c",
        "filename": "src/test/netbase_tests.cpp",
        "status": "modified",
        "additions": 105,
        "deletions": 0,
        "changes": 105,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e025121c1ca4b86296c6b36386786522bd79a6e1/src/test/netbase_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e025121c1ca4b86296c6b36386786522bd79a6e1/src/test/netbase_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/netbase_tests.cpp?ref=e025121c1ca4b86296c6b36386786522bd79a6e1",
        "patch": "@@ -4,9 +4,13 @@\n \n #include <net_permissions.h>\n #include <netbase.h>\n+#include <protocol.h>\n+#include <serialize.h>\n+#include <streams.h>\n #include <test/util/setup_common.h>\n #include <util/strencodings.h>\n #include <util/translation.h>\n+#include <version.h>\n \n #include <string>\n \n@@ -443,4 +447,105 @@ BOOST_AUTO_TEST_CASE(netbase_dont_resolve_strings_with_embedded_nul_characters)\n     BOOST_CHECK(!LookupSubNet(std::string(\"5wyqrzbvrdsumnok.onion\\0example.com\\0\", 35), ret));\n }\n \n+// Since CNetAddr (un)ser is tested separately in net_tests.cpp here we only\n+// try a few edge cases for port, service flags and time.\n+\n+static const std::vector<CAddress> fixture_addresses({\n+    CAddress(\n+        CService(CNetAddr(in6addr_loopback), 0 /* port */),\n+        NODE_NONE,\n+        0x4966bc61U /* Fri Jan  9 02:54:25 UTC 2009 */\n+    ),\n+    CAddress(\n+        CService(CNetAddr(in6addr_loopback), 0x00f1 /* port */),\n+        NODE_NETWORK,\n+        0x83766279U /* Tue Nov 22 11:22:33 UTC 2039 */\n+    ),\n+    CAddress(\n+        CService(CNetAddr(in6addr_loopback), 0xf1f2 /* port */),\n+        static_cast<ServiceFlags>(NODE_WITNESS | NODE_COMPACT_FILTERS | NODE_NETWORK_LIMITED),\n+        0xffffffffU /* Sun Feb  7 06:28:15 UTC 2106 */\n+    )\n+});\n+\n+// fixture_addresses should equal to this when serialized in V1 format.\n+// When this is unserialized from V1 format it should equal to fixture_addresses.\n+static constexpr const char* stream_addrv1_hex =\n+    \"03\" // number of entries\n+\n+    \"61bc6649\"                         // time, Fri Jan  9 02:54:25 UTC 2009\n+    \"0000000000000000\"                 // service flags, NODE_NONE\n+    \"00000000000000000000000000000001\" // address, fixed 16 bytes (IPv4 embedded in IPv6)\n+    \"0000\"                             // port\n+\n+    \"79627683\"                         // time, Tue Nov 22 11:22:33 UTC 2039\n+    \"0100000000000000\"                 // service flags, NODE_NETWORK\n+    \"00000000000000000000000000000001\" // address, fixed 16 bytes (IPv6)\n+    \"00f1\"                             // port\n+\n+    \"ffffffff\"                         // time, Sun Feb  7 06:28:15 UTC 2106\n+    \"4804000000000000\"                 // service flags, NODE_WITNESS | NODE_COMPACT_FILTERS | NODE_NETWORK_LIMITED\n+    \"00000000000000000000000000000001\" // address, fixed 16 bytes (IPv6)\n+    \"f1f2\";                            // port\n+\n+// fixture_addresses should equal to this when serialized in V2 format.\n+// When this is unserialized from V2 format it should equal to fixture_addresses.\n+static constexpr const char* stream_addrv2_hex =\n+    \"03\" // number of entries\n+\n+    \"61bc6649\"                         // time, Fri Jan  9 02:54:25 UTC 2009\n+    \"00\"                               // service flags, COMPACTSIZE(NODE_NONE)\n+    \"02\"                               // network id, IPv6\n+    \"10\"                               // address length, COMPACTSIZE(16)\n+    \"00000000000000000000000000000001\" // address\n+    \"0000\"                             // port\n+\n+    \"79627683\"                         // time, Tue Nov 22 11:22:33 UTC 2039\n+    \"01\"                               // service flags, COMPACTSIZE(NODE_NETWORK)\n+    \"02\"                               // network id, IPv6\n+    \"10\"                               // address length, COMPACTSIZE(16)\n+    \"00000000000000000000000000000001\" // address\n+    \"00f1\"                             // port\n+\n+    \"ffffffff\"                         // time, Sun Feb  7 06:28:15 UTC 2106\n+    \"fd4804\"                           // service flags, COMPACTSIZE(NODE_WITNESS | NODE_COMPACT_FILTERS | NODE_NETWORK_LIMITED)\n+    \"02\"                               // network id, IPv6\n+    \"10\"                               // address length, COMPACTSIZE(16)\n+    \"00000000000000000000000000000001\" // address\n+    \"f1f2\";                            // port\n+\n+BOOST_AUTO_TEST_CASE(caddress_serialize_v1)\n+{\n+    CDataStream s(SER_NETWORK, PROTOCOL_VERSION);\n+\n+    s << fixture_addresses;\n+    BOOST_CHECK_EQUAL(HexStr(s), stream_addrv1_hex);\n+}\n+\n+BOOST_AUTO_TEST_CASE(caddress_unserialize_v1)\n+{\n+    CDataStream s(ParseHex(stream_addrv1_hex), SER_NETWORK, PROTOCOL_VERSION);\n+    std::vector<CAddress> addresses_unserialized;\n+\n+    s >> addresses_unserialized;\n+    BOOST_CHECK(fixture_addresses == addresses_unserialized);\n+}\n+\n+BOOST_AUTO_TEST_CASE(caddress_serialize_v2)\n+{\n+    CDataStream s(SER_NETWORK, PROTOCOL_VERSION | ADDRV2_FORMAT);\n+\n+    s << fixture_addresses;\n+    BOOST_CHECK_EQUAL(HexStr(s), stream_addrv2_hex);\n+}\n+\n+BOOST_AUTO_TEST_CASE(caddress_unserialize_v2)\n+{\n+    CDataStream s(ParseHex(stream_addrv2_hex), SER_NETWORK, PROTOCOL_VERSION | ADDRV2_FORMAT);\n+    std::vector<CAddress> addresses_unserialized;\n+\n+    s >> addresses_unserialized;\n+    BOOST_CHECK(fixture_addresses == addresses_unserialized);\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYjkwZDI3NGUzNGI4Zjk4MTRlZmU3YzM1YTVlOGU2NDdlZTFhYjRi",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-05-20T10:05:18Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-09-29T08:31:32Z"
      },
      "message": "net: advertise support for ADDRv2 via new message\n\nIntroduce a new message `sendaddrv2` to signal support for ADDRv2.\nSend the new message immediately after sending the `VERACK` message.\n\nAdd support for receiving and parsing ADDRv2 messages.\n\nSend ADDRv2 messages (instead of ADDR) to a peer if he has\nadvertised support for it.\n\nCo-authored-by: Carl Dong <contact@carldong.me>",
      "tree": {
        "sha": "062031b39269ba720ddb35855047d1a7c8481b1c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/062031b39269ba720ddb35855047d1a7c8481b1c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAl9y8OYACgkQVN8G9ktV\ny7+zzx//agAEvTTac0VP7shznUVDiJ0r8025wTgTngpKz+uoGZTeMg6g1se05Wxe\nBLQvDC46sNEWtzcAPn58wtAdWtEXVeaL3Q7osI+G+8lnCX20opLfMAvDIzVt4LVL\nFS5r3DWRQ03Y0juklpHp7Ax2J85rm5hZgvg2kpBTdIfAsezMqtely3sm+WPhk2zE\nce6Z5pTjD0fm1/TEk7Gy5WGA+SRzof1L2dO/fNfEInhawQ/sjEv+oReDEzZewCto\ncndMk1e6E3QFTF0vAIck4uwpbBPlQmnEhnqvJIKs0clQUmHsIloqNP14uwxwVFvR\nfpDu1n4eCdrzagWKDQirhu2WcUCWNcBuPSDdLglY75kA7s8ZoRrRrcCbr+igTKdI\nV/OH4fRWB/hxj4YIBwOVJd2zvUzOsHKaHeseevwaaWQV/hb0ABnDCTI3hqh1/d2t\ns7pGR/xHdMJjH19wxEI3XSHmTxM0mo/ly7OmMo4jQYoYaIN6MfbeVQ8z6kC5A/m2\nIm3cFvrNS5WoG6V8M1FZV+BfOWBKzukcfHVaF1J1/ZzqobD0axRW7bWsMTW3oyuW\nbtFT6mAJDzKfIseMM6+G49vr62OheW4+y6/Z/Rb36GD4bAkkoIK1zkkT/dHYyVni\n8XG78Yf2n5pESv193MxFYVgzUaVQKPrZvwjOwC9NMC+VZi+bj96+A/ZMKVrL8zCo\naxonbEemsJkmBUK4AM1ZpXmt27Ai2UiGy8jaPvQxMJSQB2hT+llimeseB5vkCZ/U\nny7bEtoo6FGRmKr4hbA9gB+d8Ixep8rrVQ1JK4hHHwuPH2LJE3FDszvz6ZfJdjfu\nJRZ4ujWitkkFYhKU+l0uREiqVynq9oS+GYBfeeM+4pu7fBDuzQx/8xpt05XjlybT\nvdpwjwdIjLivNO4xxezrar3XQIfvQTw7poP66cN19uZfVwNDZANX/2Aijlj97daD\na7aukLcL9F0IlRWdi162V6e7K9ZYzatpkn0clQdwbYPlC+1xZGsDqUee9Z8BIe7k\nlYvS4YVJ/CiwsK49T1pRJwUCuxqZ+7KVlrvWjVvkmfRPNctx3WQpIARM1rlVh0vo\nSLLeFGmltny6Sl+o3xoX6yTXukzRghVgaRfWuZ8aMhjE9NEFfypH/v/F2j4WFXnR\nOayEwqZAcxnSlf/GFmZuxQ4/45a35dANROfgXlh4TOppSDiALJD8brKhXJGmBg94\nkbyOuB/FM1BfO2KTKmXotKU96RzWo3c1vsLItLeHQ4O8wpVOeqKpdsHqsr903rz2\n0t5R8WLywitKUddIg7G5G0seednwTT1QFUAvjadgb4WMfijr3Z2+hlghqPywD2Ew\n89rLusnSisa1aTT6G5N7bWMevbt8bw==\n=5Ndl\n-----END PGP SIGNATURE-----",
        "payload": "tree 062031b39269ba720ddb35855047d1a7c8481b1c\nparent e025121c1ca4b86296c6b36386786522bd79a6e1\nauthor Vasil Dimov <vd@FreeBSD.org> 1589969118 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1601368292 +0200\n\nnet: advertise support for ADDRv2 via new message\n\nIntroduce a new message `sendaddrv2` to signal support for ADDRv2.\nSend the new message immediately after sending the `VERACK` message.\n\nAdd support for receiving and parsing ADDRv2 messages.\n\nSend ADDRv2 messages (instead of ADDR) to a peer if he has\nadvertised support for it.\n\nCo-authored-by: Carl Dong <contact@carldong.me>\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e025121c1ca4b86296c6b36386786522bd79a6e1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e025121c1ca4b86296c6b36386786522bd79a6e1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e025121c1ca4b86296c6b36386786522bd79a6e1"
      }
    ],
    "stats": {
      "total": 349,
      "additions": 323,
      "deletions": 26
    },
    "files": [
      {
        "sha": "def30b47781225b8311e1a62146a75513116765e",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b",
        "patch": "@@ -868,6 +868,11 @@ class CNode\n     bool m_legacyWhitelisted{false};\n     bool fClient{false}; // set by version message\n     bool m_limited_node{false}; //after BIP159, set by version message\n+    /**\n+     * Whether the peer has signaled support for receiving ADDRv2 (BIP155)\n+     * messages, implying a preference to receive ADDRv2 instead of ADDR ones.\n+     */\n+    std::atomic_bool m_wants_addrv2{false};\n     std::atomic_bool fSuccessfullyConnected{false};\n     // Setting fDisconnect to true will cause the node to be disconnected the\n     // next time DisconnectNodes() runs\n@@ -1115,11 +1120,16 @@ class CNode\n \n     void PushAddress(const CAddress& _addr, FastRandomContext &insecure_rand)\n     {\n+        // Whether the peer supports the address in `_addr`. For example,\n+        // nodes that do not implement BIP155 cannot receive Tor v3 addresses\n+        // because they require ADDRv2 (BIP155) encoding.\n+        const bool addr_format_supported = m_wants_addrv2 || _addr.IsAddrV1Compatible();\n+\n         // Known checking here is only to save space from duplicates.\n         // SendMessages will filter it again for knowns that were added\n         // after addresses were pushed.\n         assert(m_addr_known);\n-        if (_addr.IsValid() && !m_addr_known->contains(_addr.GetKey())) {\n+        if (_addr.IsValid() && !m_addr_known->contains(_addr.GetKey()) && addr_format_supported) {\n             if (vAddrToSend.size() >= MAX_ADDR_TO_SEND) {\n                 vAddrToSend[insecure_rand.randrange(vAddrToSend.size())] = _addr;\n             } else {"
      },
      {
        "sha": "be3e7886e68f0f627e0560db2fc2c1afb4328713",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 38,
        "deletions": 4,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b",
        "patch": "@@ -2414,6 +2414,9 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n \n         m_connman.PushMessage(&pfrom, CNetMsgMaker(greatest_common_version).Make(NetMsgType::VERACK));\n \n+        // Signal ADDRv2 support (BIP155).\n+        m_connman.PushMessage(&pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::SENDADDRv2));\n+\n         pfrom.nServices = nServices;\n         pfrom.SetAddrLocal(addrMe);\n         {\n@@ -2582,9 +2585,29 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n         return;\n     }\n \n-    if (msg_type == NetMsgType::ADDR) {\n+    if (msg_type == NetMsgType::ADDR || msg_type == NetMsgType::ADDRv2) {\n+        const auto version_orig = vRecv.GetVersion();\n+        if (msg_type == NetMsgType::ADDRv2) {\n+            // Add ADDRV2_FORMAT to the version so that the CNetAddr and CAddress\n+            // unserialize methods know that an address in v2 format is coming.\n+            vRecv.SetVersion(version_orig | ADDRV2_FORMAT);\n+        }\n         std::vector<CAddress> vAddr;\n-        vRecv >> vAddr;\n+\n+        try {\n+            vRecv >> vAddr;\n+        } catch (const std::exception& e) {\n+            vRecv.SetVersion(version_orig);\n+\n+            LOCK(cs_main);\n+            Misbehaving(pfrom.GetId(), 20,\n+                strprintf(\n+                    \"Supplied us with a message that contains an unparsable address: %s\",\n+                    e.what()));\n+            return;\n+        }\n+\n+        vRecv.SetVersion(version_orig);\n \n         if (!pfrom.RelayAddrsWithConn()) {\n             return;\n@@ -2610,6 +2633,11 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n             if (!MayHaveUsefulAddressDB(addr.nServices) && !HasAllDesirableServiceFlags(addr.nServices))\n                 continue;\n \n+            // Skip invalid addresses, maybe a new BIP155 network id from the future.\n+            if (!addr.IsValid()) {\n+                continue;\n+            }\n+\n             if (addr.nTime <= 100000000 || addr.nTime > nNow + 10 * 60)\n                 addr.nTime = nNow - 5 * 24 * 60 * 60;\n             pfrom.AddAddressKnown(addr);\n@@ -2635,6 +2663,11 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n         return;\n     }\n \n+    if (msg_type == NetMsgType::SENDADDRv2) {\n+        pfrom.m_wants_addrv2 = true;\n+        return;\n+    }\n+\n     if (msg_type == NetMsgType::SENDHEADERS) {\n         LOCK(cs_main);\n         State(pfrom.GetId())->fPreferHeaders = true;\n@@ -4095,6 +4128,7 @@ bool PeerManager::SendMessages(CNode* pto)\n             std::vector<CAddress> vAddr;\n             vAddr.reserve(pto->vAddrToSend.size());\n             assert(pto->m_addr_known);\n+            const auto& msg_type = pto->m_wants_addrv2 ? NetMsgType::ADDRv2 : NetMsgType::ADDR;\n             for (const CAddress& addr : pto->vAddrToSend)\n             {\n                 if (!pto->m_addr_known->contains(addr.GetKey()))\n@@ -4104,14 +4138,14 @@ bool PeerManager::SendMessages(CNode* pto)\n                     // receiver rejects addr messages larger than MAX_ADDR_TO_SEND\n                     if (vAddr.size() >= MAX_ADDR_TO_SEND)\n                     {\n-                        m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::ADDR, vAddr));\n+                        m_connman.PushMessage(pto, msgMaker.Make(msg_type, vAddr));\n                         vAddr.clear();\n                     }\n                 }\n             }\n             pto->vAddrToSend.clear();\n             if (!vAddr.empty())\n-                m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::ADDR, vAddr));\n+                m_connman.PushMessage(pto, msgMaker.Make(msg_type, vAddr));\n             // we only send the big addr message once\n             if (pto->vAddrToSend.capacity() > 40)\n                 pto->vAddrToSend.shrink_to_fit();"
      },
      {
        "sha": "91350d3d44daf232f2a0599ffbd924cca90c5996",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 3,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b",
        "patch": "@@ -474,6 +474,25 @@ bool CNetAddr::IsInternal() const\n    return m_net == NET_INTERNAL;\n }\n \n+bool CNetAddr::IsAddrV1Compatible() const\n+{\n+    switch (m_net) {\n+    case NET_IPV4:\n+    case NET_IPV6:\n+    case NET_INTERNAL:\n+        return true;\n+    case NET_ONION:\n+        return m_addr.size() == ADDR_TORV2_SIZE;\n+    case NET_I2P:\n+    case NET_CJDNS:\n+    case NET_UNROUTABLE:\n+    case NET_MAX:\n+        return false;\n+    }\n+\n+    return false;\n+}\n+\n enum Network CNetAddr::GetNetwork() const\n {\n     if (IsInternal())\n@@ -744,9 +763,12 @@ std::vector<unsigned char> CNetAddr::GetGroup(const std::vector<bool> &asmap) co\n \n std::vector<unsigned char> CNetAddr::GetAddrBytes() const\n {\n-    uint8_t serialized[V1_SERIALIZATION_SIZE];\n-    SerializeV1Array(serialized);\n-    return {std::begin(serialized), std::end(serialized)};\n+    if (IsAddrV1Compatible()) {\n+        uint8_t serialized[V1_SERIALIZATION_SIZE];\n+        SerializeV1Array(serialized);\n+        return {std::begin(serialized), std::end(serialized)};\n+    }\n+    return std::vector<unsigned char>(m_addr.begin(), m_addr.end());\n }\n \n uint64_t CNetAddr::GetHash() const"
      },
      {
        "sha": "a0992e70c406ebc3e9b0ccd020b2f312d5feff76",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b",
        "patch": "@@ -173,6 +173,12 @@ class CNetAddr\n         bool IsRoutable() const;\n         bool IsInternal() const;\n         bool IsValid() const;\n+\n+        /**\n+         * Check if the current object can be serialized in pre-ADDRv2/BIP155 format.\n+         */\n+        bool IsAddrV1Compatible() const;\n+\n         enum Network GetNetwork() const;\n         std::string ToString() const;\n         std::string ToStringIP() const;"
      },
      {
        "sha": "0b1d224b9fa401c4183932c64069602f99ae0e1a",
        "filename": "src/netmessagemaker.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b/src/netmessagemaker.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b/src/netmessagemaker.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netmessagemaker.h?ref=fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b",
        "patch": "@@ -18,6 +18,11 @@ class CNetMsgMaker\n     CSerializedNetMsg Make(int nFlags, std::string msg_type, Args&&... args) const\n     {\n         CSerializedNetMsg msg;\n+        if (msg_type == NetMsgType::ADDRv2) {\n+            // Add ADDRV2_FORMAT to the version so that the CNetAddr and CAddress\n+            // serialize methods produce an address in v2 format.\n+            nFlags |= ADDRV2_FORMAT;\n+        }\n         msg.m_type = std::move(msg_type);\n         CVectorWriter{ SER_NETWORK, nFlags | nVersion, msg.data, 0, std::forward<Args>(args)... };\n         return msg;"
      },
      {
        "sha": "30002f8ecdbac30dc5f031cff4ba08eba9cf5996",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b",
        "patch": "@@ -14,6 +14,8 @@ namespace NetMsgType {\n const char *VERSION=\"version\";\n const char *VERACK=\"verack\";\n const char *ADDR=\"addr\";\n+const char *ADDRv2=\"addrv2\";\n+const char *SENDADDRv2=\"sendaddrv2\";\n const char *INV=\"inv\";\n const char *GETDATA=\"getdata\";\n const char *MERKLEBLOCK=\"merkleblock\";\n@@ -52,6 +54,8 @@ const static std::string allNetMessageTypes[] = {\n     NetMsgType::VERSION,\n     NetMsgType::VERACK,\n     NetMsgType::ADDR,\n+    NetMsgType::ADDRv2,\n+    NetMsgType::SENDADDRv2,\n     NetMsgType::INV,\n     NetMsgType::GETDATA,\n     NetMsgType::MERKLEBLOCK,"
      },
      {
        "sha": "81dbcb384fe5efefdc14c7b5486f760e26744200",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b",
        "patch": "@@ -76,6 +76,18 @@ extern const char* VERACK;\n  * network.\n  */\n extern const char* ADDR;\n+/**\n+ * The addrv2 message relays connection information for peers on the network just\n+ * like the addr message, but is extended to allow gossiping of longer node\n+ * addresses (see BIP155).\n+ */\n+extern const char *ADDRv2;\n+/**\n+ * The sendaddrv2 message signals support for receiving ADDRv2 messages (BIP155).\n+ * It also implies that its sender can encode as ADDRv2 and would send ADDRv2\n+ * instead of ADDR to a peer that has signaled ADDRv2 support by sending SENDADDRv2.\n+ */\n+extern const char *SENDADDRv2;\n /**\n  * The inv message (inventory message) transmits one or more inventories of\n  * objects known to the transmitting peer."
      },
      {
        "sha": "a28dfcd7c7b7ddc749774bada5b4c459c66db36d",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b",
        "patch": "@@ -242,6 +242,7 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\n     BOOST_REQUIRE(addr.IsIPv4());\n \n     BOOST_CHECK(addr.IsBindAny());\n+    BOOST_CHECK(addr.IsAddrV1Compatible());\n     BOOST_CHECK_EQUAL(addr.ToString(), \"0.0.0.0\");\n \n     // IPv4, INADDR_NONE\n@@ -250,6 +251,7 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\n     BOOST_REQUIRE(addr.IsIPv4());\n \n     BOOST_CHECK(!addr.IsBindAny());\n+    BOOST_CHECK(addr.IsAddrV1Compatible());\n     BOOST_CHECK_EQUAL(addr.ToString(), \"255.255.255.255\");\n \n     // IPv4, casual\n@@ -258,6 +260,7 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\n     BOOST_REQUIRE(addr.IsIPv4());\n \n     BOOST_CHECK(!addr.IsBindAny());\n+    BOOST_CHECK(addr.IsAddrV1Compatible());\n     BOOST_CHECK_EQUAL(addr.ToString(), \"12.34.56.78\");\n \n     // IPv6, in6addr_any\n@@ -266,6 +269,7 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\n     BOOST_REQUIRE(addr.IsIPv6());\n \n     BOOST_CHECK(addr.IsBindAny());\n+    BOOST_CHECK(addr.IsAddrV1Compatible());\n     BOOST_CHECK_EQUAL(addr.ToString(), \"::\");\n \n     // IPv6, casual\n@@ -274,6 +278,7 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\n     BOOST_REQUIRE(addr.IsIPv6());\n \n     BOOST_CHECK(!addr.IsBindAny());\n+    BOOST_CHECK(addr.IsAddrV1Compatible());\n     BOOST_CHECK_EQUAL(addr.ToString(), \"1122:3344:5566:7788:9900:aabb:ccdd:eeff\");\n \n     // TORv2\n@@ -282,6 +287,7 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\n     BOOST_REQUIRE(addr.IsTor());\n \n     BOOST_CHECK(!addr.IsBindAny());\n+    BOOST_CHECK(addr.IsAddrV1Compatible());\n     BOOST_CHECK_EQUAL(addr.ToString(), \"6hzph5hv6337r6p2.onion\");\n \n     // TORv3\n@@ -291,6 +297,7 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\n     BOOST_REQUIRE(addr.IsTor());\n \n     BOOST_CHECK(!addr.IsBindAny());\n+    BOOST_CHECK(!addr.IsAddrV1Compatible());\n     BOOST_CHECK_EQUAL(addr.ToString(), torv3_addr);\n \n     // TORv3, broken, with wrong checksum\n@@ -315,6 +322,7 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\n     BOOST_REQUIRE(addr.IsInternal());\n \n     BOOST_CHECK(!addr.IsBindAny());\n+    BOOST_CHECK(addr.IsAddrV1Compatible());\n     BOOST_CHECK_EQUAL(addr.ToString(), \"esffpvrt3wpeaygy.internal\");\n \n     // Totally bogus"
      },
      {
        "sha": "c06e6798a341043642d7be1d0fec24a400ca1070",
        "filename": "test/functional/p2p_addr_relay.py",
        "status": "modified",
        "additions": 17,
        "deletions": 6,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b/test/functional/p2p_addr_relay.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b/test/functional/p2p_addr_relay.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_addr_relay.py?ref=fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b",
        "patch": "@@ -10,7 +10,7 @@\n     CAddress,\n     NODE_NETWORK,\n     NODE_WITNESS,\n-    msg_addr,\n+    msg_addrv2,\n )\n from test_framework.p2p import P2PInterface\n from test_framework.test_framework import BitcoinTestFramework\n@@ -30,11 +30,20 @@\n \n \n class AddrReceiver(P2PInterface):\n-    def on_addr(self, message):\n+    addrv2_received_and_checked = False\n+\n+    def __init__(self):\n+        super().__init__(support_addrv2 = True)\n+\n+    def on_addrv2(self, message):\n         for addr in message.addrs:\n             assert_equal(addr.nServices, 9)\n             assert addr.ip.startswith('123.123.123.')\n             assert (8333 <= addr.port < 8343)\n+        self.addrv2_received_and_checked = True\n+\n+    def wait_for_addrv2(self):\n+        self.wait_until(lambda: \"addrv2\" in self.last_message)\n \n \n class AddrTest(BitcoinTestFramework):\n@@ -45,7 +54,7 @@ def set_test_params(self):\n     def run_test(self):\n         self.log.info('Create connection that sends addr messages')\n         addr_source = self.nodes[0].add_p2p_connection(P2PInterface())\n-        msg = msg_addr()\n+        msg = msg_addrv2()\n \n         self.log.info('Send too-large addr message')\n         msg.addrs = ADDRS * 101\n@@ -57,12 +66,14 @@ def run_test(self):\n         msg.addrs = ADDRS\n         with self.nodes[0].assert_debug_log([\n                 'Added 10 addresses from 127.0.0.1: 0 tried',\n-                'received: addr (301 bytes) peer=0',\n-                'sending addr (301 bytes) peer=1',\n+                'received: addrv2 (131 bytes) peer=0',\n+                'sending addrv2 (131 bytes) peer=1',\n         ]):\n             addr_source.send_and_ping(msg)\n             self.nodes[0].setmocktime(int(time.time()) + 30 * 60)\n-            addr_receiver.sync_with_ping()\n+            addr_receiver.wait_for_addrv2()\n+\n+        assert addr_receiver.addrv2_received_and_checked\n \n \n if __name__ == '__main__':"
      },
      {
        "sha": "e2570c57c63a8ddacf127b84d5d5e1435695e0ed",
        "filename": "test/functional/p2p_invalid_messages.py",
        "status": "modified",
        "additions": 93,
        "deletions": 1,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b/test/functional/p2p_invalid_messages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b/test/functional/p2p_invalid_messages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_messages.py?ref=fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b",
        "patch": "@@ -22,7 +22,12 @@\n     P2PInterface,\n )\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal\n+from test_framework.util import (\n+    assert_equal,\n+    hex_str_to_bytes,\n+)\n+import struct\n+import time\n \n VALID_DATA_LIMIT = MAX_PROTOCOL_MESSAGE_LENGTH - 5  # Account for the 5-byte length prefix\n \n@@ -42,6 +47,11 @@ def __repr__(self):\n         return \"{}(data={})\".format(self.msgtype, self.str_data)\n \n \n+class SenderOfAddrV2(P2PInterface):\n+    def wait_for_sendaddrv2(self):\n+        self.wait_until(lambda: 'sendaddrv2' in self.last_message)\n+\n+\n class InvalidMessagesTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 1\n@@ -53,6 +63,10 @@ def run_test(self):\n         self.test_checksum()\n         self.test_size()\n         self.test_msgtype()\n+        self.test_addrv2_empty()\n+        self.test_addrv2_no_addresses()\n+        self.test_addrv2_too_long_address()\n+        self.test_addrv2_unrecognized_network()\n         self.test_oversized_inv_msg()\n         self.test_oversized_getdata_msg()\n         self.test_oversized_headers_msg()\n@@ -127,6 +141,84 @@ def test_msgtype(self):\n         assert_equal(self.nodes[0].getpeerinfo()[0]['bytesrecv_per_msg']['*other*'], 26)\n         self.nodes[0].disconnect_p2ps()\n \n+    def test_addrv2(self, label, required_log_messages, raw_addrv2):\n+        node = self.nodes[0]\n+        conn = node.add_p2p_connection(SenderOfAddrV2())\n+\n+        # Make sure bitcoind signals support for ADDRv2, otherwise this test\n+        # will bombard an old node with messages it does not recognize which\n+        # will produce unexpected results.\n+        conn.wait_for_sendaddrv2()\n+\n+        self.log.info('Test addrv2: ' + label)\n+\n+        msg = msg_unrecognized(str_data=b'')\n+        msg.msgtype = b'addrv2'\n+        with node.assert_debug_log(required_log_messages):\n+            # override serialize() which would include the length of the data\n+            msg.serialize = lambda: raw_addrv2\n+            conn.send_raw_message(conn.build_message(msg))\n+            conn.sync_with_ping()\n+\n+        node.disconnect_p2ps()\n+\n+    def test_addrv2_empty(self):\n+        self.test_addrv2('empty',\n+            [\n+                'received: addrv2 (0 bytes)',\n+                'unparsable address',\n+                'end of data',\n+            ],\n+            b'')\n+\n+    def test_addrv2_no_addresses(self):\n+        self.test_addrv2('no addresses',\n+            [\n+                'received: addrv2 (1 bytes)',\n+            ],\n+            hex_str_to_bytes('00'))\n+\n+    def test_addrv2_too_long_address(self):\n+        self.test_addrv2('too long address',\n+            [\n+                'received: addrv2 (525 bytes)',\n+                'unparsable address',\n+                'Address too long: 513 > 512',\n+            ],\n+            hex_str_to_bytes(\n+                '01' +       # number of entries\n+                '61bc6649' + # time, Fri Jan  9 02:54:25 UTC 2009\n+                '00' +       # service flags, COMPACTSIZE(NODE_NONE)\n+                '01' +       # network type (IPv4)\n+                'fd0102' +   # address length (COMPACTSIZE(513))\n+                'ab' * 513 + # address\n+                '208d'))     # port\n+\n+    def test_addrv2_unrecognized_network(self):\n+        now_hex = struct.pack('<I', int(time.time())).hex()\n+        self.test_addrv2('unrecognized network',\n+            [\n+                'received: addrv2 (25 bytes)',\n+                'IP 9.9.9.9 mapped',\n+                'Added 1 addresses',\n+            ],\n+            hex_str_to_bytes(\n+                '02' +     # number of entries\n+                # this should be ignored without impeding acceptance of subsequent ones\n+                now_hex +  # time\n+                '01' +     # service flags, COMPACTSIZE(NODE_NETWORK)\n+                '99' +     # network type (unrecognized)\n+                '02' +     # address length (COMPACTSIZE(2))\n+                'ab' * 2 + # address\n+                '208d' +   # port\n+                # this should be added:\n+                now_hex +  # time\n+                '01' +     # service flags, COMPACTSIZE(NODE_NETWORK)\n+                '01' +     # network type (IPv4)\n+                '04' +     # address length (COMPACTSIZE(4))\n+                '09' * 4 + # address\n+                '208d'))   # port\n+\n     def test_oversized_msg(self, msg, size):\n         msg_type = msg.msgtype.decode('ascii')\n         self.log.info(\"Test {} message of size {} is logged as misbehaving\".format(msg_type, size))"
      },
      {
        "sha": "ff7f73bdf4c6ee11bb3d8b7e77feafbf80d4b532",
        "filename": "test/functional/test_framework/messages.py",
        "status": "modified",
        "additions": 93,
        "deletions": 10,
        "changes": 103,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b/test/functional/test_framework/messages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b/test/functional/test_framework/messages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/messages.py?ref=fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b",
        "patch": "@@ -136,12 +136,17 @@ def uint256_from_compact(c):\n     return v\n \n \n-def deser_vector(f, c):\n+# deser_function_name: Allow for an alternate deserialization function on the\n+# entries in the vector.\n+def deser_vector(f, c, deser_function_name=None):\n     nit = deser_compact_size(f)\n     r = []\n     for _ in range(nit):\n         t = c()\n-        t.deserialize(f)\n+        if deser_function_name:\n+            getattr(t, deser_function_name)(f)\n+        else:\n+            t.deserialize(f)\n         r.append(t)\n     return r\n \n@@ -204,38 +209,82 @@ def ToHex(obj):\n \n \n class CAddress:\n-    __slots__ = (\"ip\", \"nServices\", \"pchReserved\", \"port\", \"time\")\n+    __slots__ = (\"net\", \"ip\", \"nServices\", \"port\", \"time\")\n+\n+    # see https://github.com/bitcoin/bips/blob/master/bip-0155.mediawiki\n+    NET_IPV4 = 1\n+\n+    ADDRV2_NET_NAME = {\n+        NET_IPV4: \"IPv4\"\n+    }\n+\n+    ADDRV2_ADDRESS_LENGTH = {\n+        NET_IPV4: 4\n+    }\n \n     def __init__(self):\n         self.time = 0\n         self.nServices = 1\n-        self.pchReserved = b\"\\x00\" * 10 + b\"\\xff\" * 2\n+        self.net = self.NET_IPV4\n         self.ip = \"0.0.0.0\"\n         self.port = 0\n \n     def deserialize(self, f, *, with_time=True):\n+        \"\"\"Deserialize from addrv1 format (pre-BIP155)\"\"\"\n         if with_time:\n             # VERSION messages serialize CAddress objects without time\n-            self.time = struct.unpack(\"<i\", f.read(4))[0]\n+            self.time = struct.unpack(\"<I\", f.read(4))[0]\n         self.nServices = struct.unpack(\"<Q\", f.read(8))[0]\n-        self.pchReserved = f.read(12)\n+        # We only support IPv4 which means skip 12 bytes and read the next 4 as IPv4 address.\n+        f.read(12)\n+        self.net = self.NET_IPV4\n         self.ip = socket.inet_ntoa(f.read(4))\n         self.port = struct.unpack(\">H\", f.read(2))[0]\n \n     def serialize(self, *, with_time=True):\n+        \"\"\"Serialize in addrv1 format (pre-BIP155)\"\"\"\n+        assert self.net == self.NET_IPV4\n         r = b\"\"\n         if with_time:\n             # VERSION messages serialize CAddress objects without time\n-            r += struct.pack(\"<i\", self.time)\n+            r += struct.pack(\"<I\", self.time)\n         r += struct.pack(\"<Q\", self.nServices)\n-        r += self.pchReserved\n+        r += b\"\\x00\" * 10 + b\"\\xff\" * 2\n+        r += socket.inet_aton(self.ip)\n+        r += struct.pack(\">H\", self.port)\n+        return r\n+\n+    def deserialize_v2(self, f):\n+        \"\"\"Deserialize from addrv2 format (BIP155)\"\"\"\n+        self.time = struct.unpack(\"<I\", f.read(4))[0]\n+\n+        self.nServices = deser_compact_size(f)\n+\n+        self.net = struct.unpack(\"B\", f.read(1))[0]\n+        assert self.net == self.NET_IPV4\n+\n+        address_length = deser_compact_size(f)\n+        assert address_length == self.ADDRV2_ADDRESS_LENGTH[self.net]\n+\n+        self.ip = socket.inet_ntoa(f.read(4))\n+\n+        self.port = struct.unpack(\">H\", f.read(2))[0]\n+\n+    def serialize_v2(self):\n+        \"\"\"Serialize in addrv2 format (BIP155)\"\"\"\n+        assert self.net == self.NET_IPV4\n+        r = b\"\"\n+        r += struct.pack(\"<I\", self.time)\n+        r += ser_compact_size(self.nServices)\n+        r += struct.pack(\"B\", self.net)\n+        r += ser_compact_size(self.ADDRV2_ADDRESS_LENGTH[self.net])\n         r += socket.inet_aton(self.ip)\n         r += struct.pack(\">H\", self.port)\n         return r\n \n     def __repr__(self):\n-        return \"CAddress(nServices=%i ip=%s port=%i)\" % (self.nServices,\n-                                                         self.ip, self.port)\n+        return (\"CAddress(nServices=%i net=%s addr=%s port=%i)\"\n+                % (self.nServices, self.ADDRV2_NET_NAME[self.net], self.ip, self.port))\n \n \n class CInv:\n@@ -1064,6 +1113,40 @@ def __repr__(self):\n         return \"msg_addr(addrs=%s)\" % (repr(self.addrs))\n \n \n+class msg_addrv2:\n+    __slots__ = (\"addrs\",)\n+    msgtype = b\"addrv2\"\n+\n+    def __init__(self):\n+        self.addrs = []\n+\n+    def deserialize(self, f):\n+        self.addrs = deser_vector(f, CAddress, \"deserialize_v2\")\n+\n+    def serialize(self):\n+        return ser_vector(self.addrs, \"serialize_v2\")\n+\n+    def __repr__(self):\n+        return \"msg_addrv2(addrs=%s)\" % (repr(self.addrs))\n+\n+\n+class msg_sendaddrv2:\n+    __slots__ = ()\n+    msgtype = b\"sendaddrv2\"\n+\n+    def __init__(self):\n+        pass\n+\n+    def deserialize(self, f):\n+        pass\n+\n+    def serialize(self):\n+        return b\"\"\n+\n+    def __repr__(self):\n+        return \"msg_sendaddrv2()\"\n+\n+\n class msg_inv:\n     __slots__ = (\"inv\",)\n     msgtype = b\"inv\""
      },
      {
        "sha": "6846d31221b39f34234a4d1bedac93cac6c020de",
        "filename": "test/functional/test_framework/p2p.py",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b/test/functional/test_framework/p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b/test/functional/test_framework/p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/p2p.py?ref=fb90d274e34b8f9814efe7c35a5e8e647ee1ab4b",
        "patch": "@@ -33,6 +33,7 @@\n     MAX_HEADERS_RESULTS,\n     MIN_VERSION_SUPPORTED,\n     msg_addr,\n+    msg_addrv2,\n     msg_block,\n     MSG_BLOCK,\n     msg_blocktxn,\n@@ -56,6 +57,7 @@\n     msg_notfound,\n     msg_ping,\n     msg_pong,\n+    msg_sendaddrv2,\n     msg_sendcmpct,\n     msg_sendheaders,\n     msg_tx,\n@@ -75,6 +77,7 @@\n \n MESSAGEMAP = {\n     b\"addr\": msg_addr,\n+    b\"addrv2\": msg_addrv2,\n     b\"block\": msg_block,\n     b\"blocktxn\": msg_blocktxn,\n     b\"cfcheckpt\": msg_cfcheckpt,\n@@ -97,6 +100,7 @@\n     b\"notfound\": msg_notfound,\n     b\"ping\": msg_ping,\n     b\"pong\": msg_pong,\n+    b\"sendaddrv2\": msg_sendaddrv2,\n     b\"sendcmpct\": msg_sendcmpct,\n     b\"sendheaders\": msg_sendheaders,\n     b\"tx\": msg_tx,\n@@ -285,7 +289,7 @@ class P2PInterface(P2PConnection):\n \n     Individual testcases should subclass this and override the on_* methods\n     if they want to alter message handling behaviour.\"\"\"\n-    def __init__(self):\n+    def __init__(self, support_addrv2=False):\n         super().__init__()\n \n         # Track number of messages of each type received.\n@@ -303,6 +307,8 @@ def __init__(self):\n         # The network services received from the peer\n         self.nServices = 0\n \n+        self.support_addrv2 = support_addrv2\n+\n     def peer_connect(self, *args, services=NODE_NETWORK|NODE_WITNESS, send_version=True, **kwargs):\n         create_conn = super().peer_connect(*args, **kwargs)\n \n@@ -345,6 +351,7 @@ def on_close(self):\n         pass\n \n     def on_addr(self, message): pass\n+    def on_addrv2(self, message): pass\n     def on_block(self, message): pass\n     def on_blocktxn(self, message): pass\n     def on_cfcheckpt(self, message): pass\n@@ -365,6 +372,7 @@ def on_mempool(self, message): pass\n     def on_merkleblock(self, message): pass\n     def on_notfound(self, message): pass\n     def on_pong(self, message): pass\n+    def on_sendaddrv2(self, message): pass\n     def on_sendcmpct(self, message): pass\n     def on_sendheaders(self, message): pass\n     def on_tx(self, message): pass\n@@ -389,6 +397,8 @@ def on_version(self, message):\n         if message.nVersion >= 70016:\n             self.send_message(msg_wtxidrelay())\n         self.send_message(msg_verack())\n+        if self.support_addrv2:\n+            self.send_message(msg_sendaddrv2())\n         self.nServices = message.nServices\n \n     # Connection helper methods"
      }
    ]
  }
]