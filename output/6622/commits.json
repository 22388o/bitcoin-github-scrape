[
  {
    "sha": "872fee3fccc8b33b9af0a401b5f85ac5504b57eb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4NzJmZWUzZmNjYzhiMzNiOWFmMGE0MDFiNWY4NWFjNTUwNGI1N2Vi",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-09-02T15:03:27Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2015-10-26T14:37:30Z"
      },
      "message": "Introduce -maxuploadtarget\n\n* -maxuploadtarget can be set in MiB\n* if <limit> - ( time-left-in-24h-cycle / 600 * MAX_BLOCK_SIZE ) has reach, stop serve blocks older than one week and filtered blocks\n* no action if limit has reached, no guarantee that the target will not be  surpassed\n* add outbound limit informations to rpc getnettotals",
      "tree": {
        "sha": "d868b4a0a6b9f9b55882c324afb362d5a1914e20",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d868b4a0a6b9f9b55882c324afb362d5a1914e20"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/872fee3fccc8b33b9af0a401b5f85ac5504b57eb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "expired_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJWLjqqAAoJECnUvLZBb1PsZWwQAJZQ+5tcBcUYVeO6VlI1sOP0\nnGjew7tzZMtJKJ/6EQeRt861TS8uFdgq2r7ijx+6dzlKe9A/p7QVq1Z/3XksddDO\n5c2nlKLyZtPoBsqQDPLxYLhT0ZRiGwkcx6FRkHwdpT2DLrsOky+eQ0y3tHbZzhYu\nNDPDxAFezYhRlRordlNS0rMFTwyqF1/YxVsUuSjVc8ItMPZskhW/ORV5T8i4Rpej\n0gTthidwd/E2ajbCDMu5HUrlE0g7lWURSbhnzMKU+uAgfwcrvLvV6iqU0nt4MfjC\nPsT7vX3+Ei3teHPrMlgKxTDFeleS7OfaVYgv3ZhY016o8LyQyl0FSrc5G+nMkqLs\nsoviyB7w9QydYqvBzvcqtNcp0o3ALJhyGy5myH4+ZS1IXEjXGsSQoYYdAKJsM7+i\nCV7VWz1jYuZN4Q+sjHAj5qMcObItSUa24K/qy0QycUS3q74JjSBfvQRu7XWdmips\nC44lPIE7LAUx+Fb84wZ1I7k9eJC3jqLr6SgNuuI3xx6YWT0PLvTsRhoDG1OWPQy5\nna185ik7Dlwv2QOAcWsmGEiCu8K/JtoOIb7iZ9Tm+KpiGVg2lS20C2sEG6W/XZ8M\nsvC+Iow7NSi0l4McioofxYVlnYg4hMiuPP21YwqZWT+N1HoskbVdyNS6yvcnJ+vq\n/v2D6s8exGlh8HA1zKlo\n=thWL\n-----END PGP SIGNATURE-----",
        "payload": "tree d868b4a0a6b9f9b55882c324afb362d5a1914e20\nparent 867d6c90b85070644c3458e3e7ed168765523361\nauthor Jonas Schnelli <jonas.schnelli@include7.ch> 1441206207 +0200\ncommitter Jonas Schnelli <dev@jonasschnelli.ch> 1445870250 +0100\n\nIntroduce -maxuploadtarget\n\n* -maxuploadtarget can be set in MiB\n* if <limit> - ( time-left-in-24h-cycle / 600 * MAX_BLOCK_SIZE ) has reach, stop serve blocks older than one week and filtered blocks\n* no action if limit has reached, no guarantee that the target will not be  surpassed\n* add outbound limit informations to rpc getnettotals\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/872fee3fccc8b33b9af0a401b5f85ac5504b57eb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/872fee3fccc8b33b9af0a401b5f85ac5504b57eb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/872fee3fccc8b33b9af0a401b5f85ac5504b57eb/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "867d6c90b85070644c3458e3e7ed168765523361",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/867d6c90b85070644c3458e3e7ed168765523361",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/867d6c90b85070644c3458e3e7ed168765523361"
      }
    ],
    "stats": {
      "total": 144,
      "additions": 144,
      "deletions": 0
    },
    "files": [
      {
        "sha": "0210ac1135d53d36e2aabc0ce79656f941bc0e14",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/872fee3fccc8b33b9af0a401b5f85ac5504b57eb/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/872fee3fccc8b33b9af0a401b5f85ac5504b57eb/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=872fee3fccc8b33b9af0a401b5f85ac5504b57eb",
        "patch": "@@ -369,6 +369,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-whitebind=<addr>\", _(\"Bind to given address and whitelist peers connecting to it. Use [host]:port notation for IPv6\"));\n     strUsage += HelpMessageOpt(\"-whitelist=<netmask>\", _(\"Whitelist peers connecting from the given netmask or IP address. Can be specified multiple times.\") +\n         \" \" + _(\"Whitelisted peers cannot be DoS banned and their transactions are always relayed, even if they are already in the mempool, useful e.g. for a gateway\"));\n+    strUsage += HelpMessageOpt(\"-maxuploadtarget=<n>\", strprintf(_(\"Tries to keep outbound traffic under the given target (in MiB per 24h), 0 = no limit (default: %d)\"), 0));\n \n #ifdef ENABLE_WALLET\n     strUsage += HelpMessageGroup(_(\"Wallet options:\"));\n@@ -1174,6 +1175,9 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n         RegisterValidationInterface(pzmqNotificationInterface);\n     }\n #endif\n+    if (mapArgs.count(\"-maxuploadtarget\")) {\n+        CNode::SetMaxOutboundTarget(GetArg(\"-maxuploadtarget\", 0)*1024*1024);\n+    }\n \n     // ********************************************************* Step 7: load block chain\n "
      },
      {
        "sha": "26a22ae6fd7cfd7d618410c6a03a6022b22d01ee",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/872fee3fccc8b33b9af0a401b5f85ac5504b57eb/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/872fee3fccc8b33b9af0a401b5f85ac5504b57eb/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=872fee3fccc8b33b9af0a401b5f85ac5504b57eb",
        "patch": "@@ -3805,6 +3805,16 @@ void static ProcessGetData(CNode* pfrom)\n                         }\n                     }\n                 }\n+                // disconnect node in case we have reached the outbound limit for serving historical blocks\n+                static const int nOneWeek = 7 * 24 * 60 * 60; // assume > 1 week = historical\n+                if (send && CNode::OutboundTargetReached(true) && ( ((pindexBestHeader != NULL) && (pindexBestHeader->GetBlockTime() - mi->second->GetBlockTime() > nOneWeek)) || inv.type == MSG_FILTERED_BLOCK) )\n+                {\n+                    LogPrint(\"net\", \"historical block serving limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n+\n+                    //disconnect node\n+                    pfrom->fDisconnect = true;\n+                    send = false;\n+                }\n                 // Pruned nodes may have deleted the block, so check whether\n                 // it's available before trying to send.\n                 if (send && (mi->second->nStatus & BLOCK_HAVE_DATA))"
      },
      {
        "sha": "e18e8d0e29aa30a46b931b223137b5b1ab57465d",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 94,
        "deletions": 0,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/872fee3fccc8b33b9af0a401b5f85ac5504b57eb/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/872fee3fccc8b33b9af0a401b5f85ac5504b57eb/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=872fee3fccc8b33b9af0a401b5f85ac5504b57eb",
        "patch": "@@ -12,6 +12,7 @@\n #include \"addrman.h\"\n #include \"chainparams.h\"\n #include \"clientversion.h\"\n+#include \"consensus/consensus.h\"\n #include \"crypto/common.h\"\n #include \"hash.h\"\n #include \"primitives/transaction.h\"\n@@ -326,6 +327,11 @@ uint64_t CNode::nTotalBytesSent = 0;\n CCriticalSection CNode::cs_totalBytesRecv;\n CCriticalSection CNode::cs_totalBytesSent;\n \n+uint64_t CNode::nMaxOutboundLimit = 0;\n+uint64_t CNode::nMaxOutboundTotalBytesSentInCycle = 0;\n+uint64_t CNode::nMaxOutboundTimeframe = 60*60*24; //1 day\n+uint64_t CNode::nMaxOutboundCycleStartTime = 0;\n+\n CNode* FindNode(const CNetAddr& ip)\n {\n     LOCK(cs_vNodes);\n@@ -2083,6 +2089,94 @@ void CNode::RecordBytesSent(uint64_t bytes)\n {\n     LOCK(cs_totalBytesSent);\n     nTotalBytesSent += bytes;\n+\n+    uint64_t now = GetTime();\n+    if (nMaxOutboundCycleStartTime + nMaxOutboundTimeframe < now)\n+    {\n+        // timeframe expired, reset cycle\n+        nMaxOutboundCycleStartTime = now;\n+        nMaxOutboundTotalBytesSentInCycle = 0;\n+    }\n+\n+    // TODO, exclude whitebind peers\n+    nMaxOutboundTotalBytesSentInCycle += bytes;\n+}\n+\n+void CNode::SetMaxOutboundTarget(uint64_t limit)\n+{\n+    LOCK(cs_totalBytesSent);\n+    uint64_t recommendedMinimum = (nMaxOutboundTimeframe / 600) * MAX_BLOCK_SIZE;\n+    nMaxOutboundLimit = limit;\n+\n+    if (limit < recommendedMinimum)\n+        LogPrintf(\"Max outbound target is very small (%s) and will be overshot. Recommended minimum is %s\\n.\", nMaxOutboundLimit, recommendedMinimum);\n+}\n+\n+uint64_t CNode::GetMaxOutboundTarget()\n+{\n+    LOCK(cs_totalBytesSent);\n+    return nMaxOutboundLimit;\n+}\n+\n+uint64_t CNode::GetMaxOutboundTimeframe()\n+{\n+    LOCK(cs_totalBytesSent);\n+    return nMaxOutboundTimeframe;\n+}\n+\n+uint64_t CNode::GetMaxOutboundTimeLeftInCycle()\n+{\n+    LOCK(cs_totalBytesSent);\n+    if (nMaxOutboundLimit == 0)\n+        return 0;\n+\n+    if (nMaxOutboundCycleStartTime == 0)\n+        return nMaxOutboundTimeframe;\n+\n+    uint64_t cycleEndTime = nMaxOutboundCycleStartTime + nMaxOutboundTimeframe;\n+    uint64_t now = GetTime();\n+    return (cycleEndTime < now) ? 0 : cycleEndTime - GetTime();\n+}\n+\n+void CNode::SetMaxOutboundTimeframe(uint64_t timeframe)\n+{\n+    LOCK(cs_totalBytesSent);\n+    if (nMaxOutboundTimeframe != timeframe)\n+    {\n+        // reset measure-cycle in case of changing\n+        // the timeframe\n+        nMaxOutboundCycleStartTime = GetTime();\n+    }\n+    nMaxOutboundTimeframe = timeframe;\n+}\n+\n+bool CNode::OutboundTargetReached(bool historicalBlockServingLimit)\n+{\n+    LOCK(cs_totalBytesSent);\n+    if (nMaxOutboundLimit == 0)\n+        return false;\n+\n+    if (historicalBlockServingLimit)\n+    {\n+        // keep a large enought buffer to at least relay each block once\n+        uint64_t timeLeftInCycle = GetMaxOutboundTimeLeftInCycle();\n+        uint64_t buffer = timeLeftInCycle / 600 * MAX_BLOCK_SIZE;\n+        if (buffer >= nMaxOutboundLimit || nMaxOutboundTotalBytesSentInCycle >= nMaxOutboundLimit - buffer)\n+            return true;\n+    }\n+    else if (nMaxOutboundTotalBytesSentInCycle >= nMaxOutboundLimit)\n+        return true;\n+\n+    return false;\n+}\n+\n+uint64_t CNode::GetOutboundTargetBytesLeft()\n+{\n+    LOCK(cs_totalBytesSent);\n+    if (nMaxOutboundLimit == 0)\n+        return 0;\n+\n+    return (nMaxOutboundTotalBytesSentInCycle >= nMaxOutboundLimit) ? 0 : nMaxOutboundLimit - nMaxOutboundTotalBytesSentInCycle;\n }\n \n uint64_t CNode::GetTotalBytesRecv()"
      },
      {
        "sha": "f90b3385afea1f1358d161cd8623c52f938992e0",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/872fee3fccc8b33b9af0a401b5f85ac5504b57eb/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/872fee3fccc8b33b9af0a401b5f85ac5504b57eb/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=872fee3fccc8b33b9af0a401b5f85ac5504b57eb",
        "patch": "@@ -400,6 +400,12 @@ class CNode\n     static uint64_t nTotalBytesRecv;\n     static uint64_t nTotalBytesSent;\n \n+    // outbound limit & stats\n+    static uint64_t nMaxOutboundTotalBytesSentInCycle;\n+    static uint64_t nMaxOutboundCycleStartTime;\n+    static uint64_t nMaxOutboundLimit;\n+    static uint64_t nMaxOutboundTimeframe;\n+\n     CNode(const CNode&);\n     void operator=(const CNode&);\n \n@@ -701,6 +707,27 @@ class CNode\n \n     static uint64_t GetTotalBytesRecv();\n     static uint64_t GetTotalBytesSent();\n+\n+    //!set the max outbound target in bytes\n+    static void SetMaxOutboundTarget(uint64_t limit);\n+    static uint64_t GetMaxOutboundTarget();\n+\n+    //!set the timeframe for the max outbound target\n+    static void SetMaxOutboundTimeframe(uint64_t timeframe);\n+    static uint64_t GetMaxOutboundTimeframe();\n+\n+    //!check if the outbound target is reached\n+    // if param historicalBlockServingLimit is set true, the function will\n+    // response true if the limit for serving historical blocks has been reached\n+    static bool OutboundTargetReached(bool historicalBlockServingLimit);\n+\n+    //!response the bytes left in the current max outbound cycle\n+    // in case of no limit, it will always response 0\n+    static uint64_t GetOutboundTargetBytesLeft();\n+\n+    //!response the time in second left in the current max outbound cycle\n+    // in case of no limit, it will always response 0\n+    static uint64_t GetMaxOutboundTimeLeftInCycle();\n };\n \n "
      },
      {
        "sha": "6b4815ebd8fa763a5b4b435c840aa6c54abd6d77",
        "filename": "src/rpcnet.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/872fee3fccc8b33b9af0a401b5f85ac5504b57eb/src/rpcnet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/872fee3fccc8b33b9af0a401b5f85ac5504b57eb/src/rpcnet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcnet.cpp?ref=872fee3fccc8b33b9af0a401b5f85ac5504b57eb",
        "patch": "@@ -379,6 +379,15 @@ UniValue getnettotals(const UniValue& params, bool fHelp)\n     obj.push_back(Pair(\"totalbytesrecv\", CNode::GetTotalBytesRecv()));\n     obj.push_back(Pair(\"totalbytessent\", CNode::GetTotalBytesSent()));\n     obj.push_back(Pair(\"timemillis\", GetTimeMillis()));\n+\n+    UniValue outboundLimit(UniValue::VOBJ);\n+    outboundLimit.push_back(Pair(\"timeframe\", CNode::GetMaxOutboundTimeframe()));\n+    outboundLimit.push_back(Pair(\"target\", CNode::GetMaxOutboundTarget()));\n+    outboundLimit.push_back(Pair(\"target_reached\", CNode::OutboundTargetReached(false)));\n+    outboundLimit.push_back(Pair(\"serve_historical_blocks\", !CNode::OutboundTargetReached(true)));\n+    outboundLimit.push_back(Pair(\"bytes_left_in_cycle\", CNode::GetOutboundTargetBytesLeft()));\n+    outboundLimit.push_back(Pair(\"time_left_in_cycle\", CNode::GetMaxOutboundTimeLeftInCycle()));\n+    obj.push_back(Pair(\"uploadtarget\", outboundLimit));\n     return obj;\n }\n "
      }
    ]
  },
  {
    "sha": "17a073ae0692fe378827e3c4dae01294509e19e9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxN2EwNzNhZTA2OTJmZTM3ODgyN2UzYzRkYWUwMTI5NDUwOWUxOWU5",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2015-09-18T19:59:55Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2015-10-26T14:40:38Z"
      },
      "message": "Add RPC test for -maxuploadtarget",
      "tree": {
        "sha": "4560ef6836a8e1556ec4e65aedf573af4e7f3f79",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4560ef6836a8e1556ec4e65aedf573af4e7f3f79"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/17a073ae0692fe378827e3c4dae01294509e19e9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "expired_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJWLjtmAAoJECnUvLZBb1Ps7i8P/1b2BxoAYvAFo3OkjCohF5Qn\nmZUlrbBuimVrFx9vlu7i1/rMH/nwjjkxAugxn5ZG3b4io4/SnCZHyP8uXbsMyM/B\n7km1hDmB6gw4iPSwtbdya2s1ouIc4b7gbw5Dfga2hqX3FUcnHWAf0bVSOa6zs8Bf\nimNtqVodG8MeU1SBa/r04q2fBUP8xMIqraxqURhgXgwowr6iLUHZ3DzXKSI6fB1T\nzegvx43U3mpUzmSRJhq7K/77k82CevATlpKmXjc4mRdg4ijuJCxWmzH4Lgkmtazm\n44wHc5LrDS8uOzEO3tzt0BF5gRar475UFIuSgCkZ83U2nV7zD11tfL+lekXR8EID\na6515mvsA6b+kLqQb2poaEyuNC1UT/kDUxTwNmKfbAiH2Jjhe0krYQyGPIeyLB3p\nnxvbN2x1eLOBYlxYWkbCguIxRe3lGBQYElHowODJwHKrAF7lHL3z7nnRC6ZAQzwZ\n816ynCCAdRSnyLoj0b0gynxcGsmphCQh9QhLaQ+3ZDdunWYoq8h7hXPLB1meUWwB\nstBAsJfO7myaHEZiDskjVyOn+jBKZCfRrlamvQary8IR0mA+FEALDINlKlzfgMyk\nVwP2Rh9+ztsMdZtR/vN1ROx0l6pYulrjn0Wubg9ZMYjz4DsH+Xp8x/UgqB4Fiw85\n6+p4r1WqMCOdua48xL05\n=7HiY\n-----END PGP SIGNATURE-----",
        "payload": "tree 4560ef6836a8e1556ec4e65aedf573af4e7f3f79\nparent 872fee3fccc8b33b9af0a401b5f85ac5504b57eb\nauthor Suhas Daftuar <sdaftuar@chaincode.com> 1442606395 -0400\ncommitter Jonas Schnelli <dev@jonasschnelli.ch> 1445870438 +0100\n\nAdd RPC test for -maxuploadtarget\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/17a073ae0692fe378827e3c4dae01294509e19e9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/17a073ae0692fe378827e3c4dae01294509e19e9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/17a073ae0692fe378827e3c4dae01294509e19e9/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "872fee3fccc8b33b9af0a401b5f85ac5504b57eb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/872fee3fccc8b33b9af0a401b5f85ac5504b57eb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/872fee3fccc8b33b9af0a401b5f85ac5504b57eb"
      }
    ],
    "stats": {
      "total": 251,
      "additions": 250,
      "deletions": 1
    },
    "files": [
      {
        "sha": "3059fee42662e6010e9056ffcc2894afdaaab38e",
        "filename": "qa/pull-tester/rpc-tests.py",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/17a073ae0692fe378827e3c4dae01294509e19e9/qa/pull-tester/rpc-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/17a073ae0692fe378827e3c4dae01294509e19e9/qa/pull-tester/rpc-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.py?ref=17a073ae0692fe378827e3c4dae01294509e19e9",
        "patch": "@@ -84,12 +84,13 @@\n     'keypool.py',\n     'receivedby.py',\n #    'rpcbind_test.py', #temporary, bug in libevent, see #6655\n-#   'script_test.py', #used for manual comparison of 2 binaries\n+#    'script_test.py', #used for manual comparison of 2 binaries\n     'smartfees.py',\n     'maxblocksinflight.py',\n     'invalidblockrequest.py',\n     'p2p-acceptblock.py',\n     'mempool_packages.py',\n+    'maxuploadtarget.py',\n ]\n \n #Enable ZMQ tests"
      },
      {
        "sha": "67c4a509854c84c487761868c82c5ed5fac0c680",
        "filename": "qa/rpc-tests/maxuploadtarget.py",
        "status": "added",
        "additions": 248,
        "deletions": 0,
        "changes": 248,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/17a073ae0692fe378827e3c4dae01294509e19e9/qa/rpc-tests/maxuploadtarget.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/17a073ae0692fe378827e3c4dae01294509e19e9/qa/rpc-tests/maxuploadtarget.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/maxuploadtarget.py?ref=17a073ae0692fe378827e3c4dae01294509e19e9",
        "patch": "@@ -0,0 +1,248 @@\n+#!/usr/bin/env python2\n+#\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+from test_framework.mininode import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.comptool import wait_until\n+import time\n+\n+'''\n+Test behavior of -maxuploadtarget.\n+\n+* Verify that getdata requests for old blocks (>1week) are dropped\n+if uploadtarget has been reached.\n+* Verify that getdata requests for recent blocks are respecteved even\n+if uploadtarget has been reached.\n+* Verify that the upload counters are reset after 24 hours.\n+'''\n+\n+# TestNode: bare-bones \"peer\".  Used mostly as a conduit for a test to sending\n+# p2p messages to a node, generating the messages in the main testing logic.\n+class TestNode(NodeConnCB):\n+    def __init__(self):\n+        NodeConnCB.__init__(self)\n+        self.create_callback_map()\n+        self.connection = None\n+        self.ping_counter = 1\n+        self.last_pong = msg_pong()\n+        self.block_receive_map = {}\n+\n+    def add_connection(self, conn):\n+        self.connection = conn\n+        self.peer_disconnected = False\n+\n+    def on_inv(self, conn, message):\n+        pass\n+\n+    # Track the last getdata message we receive (used in the test)\n+    def on_getdata(self, conn, message):\n+        self.last_getdata = message\n+\n+    def on_block(self, conn, message):\n+        message.block.calc_sha256()\n+        try:\n+            self.block_receive_map[message.block.sha256] += 1\n+        except KeyError as e:\n+            self.block_receive_map[message.block.sha256] = 1\n+\n+    # Spin until verack message is received from the node.\n+    # We use this to signal that our test can begin. This\n+    # is called from the testing thread, so it needs to acquire\n+    # the global lock.\n+    def wait_for_verack(self):\n+        def veracked():\n+            return self.verack_received\n+        return wait_until(veracked, timeout=10)\n+\n+    def wait_for_disconnect(self):\n+        def disconnected():\n+            return self.peer_disconnected\n+        return wait_until(disconnected, timeout=10)\n+\n+    # Wrapper for the NodeConn's send_message function\n+    def send_message(self, message):\n+        self.connection.send_message(message)\n+\n+    def on_pong(self, conn, message):\n+        self.last_pong = message\n+\n+    def on_close(self, conn):\n+        self.peer_disconnected = True\n+\n+    # Sync up with the node after delivery of a block\n+    def sync_with_ping(self, timeout=30):\n+        def received_pong():\n+            return (self.last_pong.nonce == self.ping_counter)\n+        self.connection.send_message(msg_ping(nonce=self.ping_counter))\n+        success = wait_until(received_pong, timeout)\n+        self.ping_counter += 1\n+        return success\n+\n+class MaxUploadTest(BitcoinTestFramework):\n+    def __init__(self):\n+        self.utxo = []\n+\n+        # Some pre-processing to create a bunch of OP_RETURN txouts to insert into transactions we create\n+        # So we have big transactions and full blocks to fill up our block files\n+        # create one script_pubkey\n+        script_pubkey = \"6a4d0200\" #OP_RETURN OP_PUSH2 512 bytes\n+        for i in xrange (512):\n+            script_pubkey = script_pubkey + \"01\"\n+        # concatenate 128 txouts of above script_pubkey which we'll insert before the txout for change\n+        self.txouts = \"81\"\n+        for k in xrange(128):\n+            # add txout value\n+            self.txouts = self.txouts + \"0000000000000000\"\n+            # add length of script_pubkey\n+            self.txouts = self.txouts + \"fd0402\"\n+            # add script_pubkey\n+            self.txouts = self.txouts + script_pubkey\n+ \n+    def add_options(self, parser):\n+        parser.add_option(\"--testbinary\", dest=\"testbinary\",\n+                          default=os.getenv(\"BITCOIND\", \"bitcoind\"),\n+                          help=\"bitcoind binary to test\")\n+\n+    def setup_chain(self):\n+        initialize_chain_clean(self.options.tmpdir, 2)\n+\n+    def setup_network(self):\n+        # Start a node with maxuploadtarget of 200 MB (/24h)\n+        self.nodes = []\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-maxuploadtarget=200\", \"-blockmaxsize=999000\"]))\n+\n+    def mine_full_block(self, node, address):\n+        # Want to create a full block\n+        # We'll generate a 66k transaction below, and 14 of them is close to the 1MB block limit\n+        for j in xrange(14):\n+            if len(self.utxo) < 14:\n+                self.utxo = node.listunspent()\n+            inputs=[]\n+            outputs = {}\n+            t = self.utxo.pop()\n+            inputs.append({ \"txid\" : t[\"txid\"], \"vout\" : t[\"vout\"]})\n+            remchange = t[\"amount\"] - Decimal(\"0.001000\")\n+            outputs[address]=remchange\n+            # Create a basic transaction that will send change back to ourself after account for a fee\n+            # And then insert the 128 generated transaction outs in the middle rawtx[92] is where the #\n+            # of txouts is stored and is the only thing we overwrite from the original transaction\n+            rawtx = node.createrawtransaction(inputs, outputs)\n+            newtx = rawtx[0:92]\n+            newtx = newtx + self.txouts\n+            newtx = newtx + rawtx[94:]\n+            # Appears to be ever so slightly faster to sign with SIGHASH_NONE\n+            signresult = node.signrawtransaction(newtx,None,None,\"NONE\")\n+            txid = node.sendrawtransaction(signresult[\"hex\"], True)\n+        # Mine a full sized block which will be these transactions we just created\n+        node.generate(1)\n+\n+    def run_test(self):\n+        # Before we connect anything, we first set the time on the node\n+        # to be in the past, otherwise things break because the CNode\n+        # time counters can't be reset backward after initialization\n+        old_time = int(time.time() - 2*60*60*24*7)\n+        self.nodes[0].setmocktime(old_time)\n+\n+        # Generate some old blocks\n+        self.nodes[0].generate(130)\n+\n+        # test_nodes[0] will only request old blocks\n+        # test_nodes[1] will only request new blocks\n+        # test_nodes[2] will test resetting the counters\n+        test_nodes = []\n+        connections = []\n+\n+        for i in xrange(3):\n+            test_nodes.append(TestNode())\n+            connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_nodes[i]))\n+            test_nodes[i].add_connection(connections[i])\n+\n+        NetworkThread().start() # Start up network handling in another thread\n+        [x.wait_for_verack() for x in test_nodes]\n+\n+        # Test logic begins here\n+\n+        # Now mine a big block\n+        self.mine_full_block(self.nodes[0], self.nodes[0].getnewaddress())\n+\n+        # Store the hash; we'll request this later\n+        big_old_block = self.nodes[0].getbestblockhash()\n+        old_block_size = self.nodes[0].getblock(big_old_block, True)['size']\n+        big_old_block = int(big_old_block, 16)\n+\n+        # Advance to two days ago\n+        self.nodes[0].setmocktime(int(time.time()) - 2*60*60*24)\n+\n+        # Mine one more block, so that the prior block looks old\n+        self.mine_full_block(self.nodes[0], self.nodes[0].getnewaddress())\n+\n+        # We'll be requesting this new block too\n+        big_new_block = self.nodes[0].getbestblockhash()\n+        new_block_size = self.nodes[0].getblock(big_new_block)['size']\n+        big_new_block = int(big_new_block, 16)\n+\n+        # test_nodes[0] will test what happens if we just keep requesting the\n+        # the same big old block too many times (expect: disconnect)\n+\n+        getdata_request = msg_getdata()\n+        getdata_request.inv.append(CInv(2, big_old_block))\n+\n+        max_bytes_per_day = 200*1024*1024\n+        max_bytes_available = max_bytes_per_day - 144*1000000\n+        success_count = max_bytes_available / old_block_size\n+        \n+        # 144MB will be reserved for relaying new blocks, so expect this to\n+        # succeed for ~70 tries.\n+        for i in xrange(success_count):\n+            test_nodes[0].send_message(getdata_request)\n+            test_nodes[0].sync_with_ping()\n+            assert_equal(test_nodes[0].block_receive_map[big_old_block], i+1)\n+\n+        assert_equal(len(self.nodes[0].getpeerinfo()), 3)\n+        # At most a couple more tries should succeed (depending on how long \n+        # the test has been running so far).\n+        for i in xrange(3):\n+            test_nodes[0].send_message(getdata_request)\n+        test_nodes[0].wait_for_disconnect()\n+        assert_equal(len(self.nodes[0].getpeerinfo()), 2)\n+        print \"Peer 0 disconnected after downloading old block too many times\"\n+\n+        # Requesting the current block on test_nodes[1] should succeed indefinitely,\n+        # even when over the max upload target.\n+        # We'll try 200 times\n+        getdata_request.inv = [CInv(2, big_new_block)]\n+        for i in xrange(200):\n+            test_nodes[1].send_message(getdata_request)\n+            test_nodes[1].sync_with_ping()\n+            assert_equal(test_nodes[1].block_receive_map[big_new_block], i+1)\n+\n+        print \"Peer 1 able to repeatedly download new block\"\n+\n+        # But if test_nodes[1] tries for an old block, it gets disconnected too.\n+        getdata_request.inv = [CInv(2, big_old_block)]\n+        test_nodes[1].send_message(getdata_request)\n+        test_nodes[1].wait_for_disconnect()\n+        assert_equal(len(self.nodes[0].getpeerinfo()), 1)\n+        \n+        print \"Peer 1 disconnected after trying to download old block\"\n+\n+        print \"Advancing system time on node to clear counters...\"\n+\n+        # If we advance the time by 24 hours, then the counters should reset,\n+        # and test_nodes[2] should be able to retrieve the old block.\n+        self.nodes[0].setmocktime(int(time.time()))\n+        test_nodes[2].sync_with_ping()\n+        test_nodes[2].send_message(getdata_request)\n+        test_nodes[2].sync_with_ping()\n+        assert_equal(test_nodes[2].block_receive_map[big_old_block], 1)\n+\n+        print \"Peer 2 able to download old block\"\n+\n+        [c.disconnect_node() for c in connections]\n+\n+if __name__ == '__main__':\n+    MaxUploadTest().main()"
      }
    ]
  }
]