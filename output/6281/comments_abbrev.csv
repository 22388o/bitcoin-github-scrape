sipa,2015-06-14T13:11:35Z,"Iterating though the entire mempool whenever the limit size is exceeded seems inefficient, especially with larger mempools. I would either keep an index ordered by priority/whatever, or use random deletes instead.\n\nAlso, needs a hook for the wallet to mark its own transactions as ""precious"", or the conflict detection mechanism will break.\n",https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-111825309,111825309,
sipa,2015-06-14T13:13:55Z,"Also, priority seems to be the wrong metric, as most of the mempool sorting is done by fee/byte rather than by priority.\n",https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-111825386,111825386,
ashleyholman,2015-06-14T14:06:06Z,"You should not remove any transactions that have dependencies before first removing their dependent transactions.\n\nAlso how about preserving nBlockPrioritySize worth of the highest priority transactions, and then pruning the rest based on fees.\n",https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-111828867,111828867,
ashleyholman,2015-06-14T14:27:14Z,"Actually, ignore what I said about dependents because I see that the remove() call will remove all of the dependent transactions, which seems like the right thing to do.\n",https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-111831328,111831328,
afk11,2015-06-14T18:45:12Z,"I was playing with recursively splitting utxos recently, and managed to fill my two testnet nodes mempools to 300mb (>110k tx's) over half an hour. One node was used for broadcasting, the other for informational purposes. Both gave similar results throughout, so I suspect many nodes accumulated the same. https://www.blocktrail.com/tBTC/address/mvoh3Jwirz6YLdSdpp1558uHWdJ9Qpijjg \n\nSince all of th",https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-111863662,111863662,
pstratem,2015-06-14T19:45:54Z,@sipa The entire priority calculation setup seems like it could use being cleaned up.\n\nIt would be a shame to write a bunch of complicated specific code here instead of figuring out someway to incorporate existing priority calculation code.\n,https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-111869955,111869955,
ashleyholman,2015-06-15T02:41:38Z,@pstratem I just had some further thoughts about this.. hope you don't mind my 2c\n\nIn general I think it would make sense to align the policy of choosing transactions to pack into a block (in CreateNewBlock) and the policy for mempool retention.  The only difference would be nBlockMaxSize vs nMaxMempoolSize.\n\nSo how about splitting out the transaction selection code from CreateNewBlock into a ,https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-111905384,111905384,
pstratem,2015-06-15T03:41:20Z,@ashleyholman I'm going to take a look at the various places that policy is applied and figure out how to work from there.\n\nSo far I see\n\nTransaction select for CreateNewblock\nRelay policy\n\nAm I missing anything?\n,https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-111911448,111911448,
ashleyholman,2015-06-15T05:31:18Z,"Sounds good!  Let me know if you want any assistance with writing code or testing, because I'm quite interested in this patch so am happy to get involved :)\n\nIf you're implementing this as a full sweep of the mempool (like the CreateNewBlock code does), maybe it should run less often than every time a tx comes in.  You could have two limits, 1 for the threshold (size at which to trigger the clea",https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-111929903,111929903,
morcos,2015-06-15T14:09:22Z,"@pstratem Thanks for getting started on this.  I'd been putting off working on it because it wasn't clear to me that there was agreement on how to boot things from the mempool.  In my mind though, you would keep all the transactions in a sorted list (or up to 3 lists, one by priority, one by fee, one for wallet transactions) and that same sorting would be used in 3 places.  For booting things at t",https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-112082440,112082440,
jonasschnelli,2015-06-15T14:21:37Z,Started working on a rebases version of #3753  https://github.com/jonasschnelli/bitcoin/commits/2015/06/mempool-janitor with focus on protecting wallet relevant transaction.\nRemoved the thread and try to check during `CTxMemPool::addUnchecked()` but only if a certain amount of time has passed (24h by default).\nWill focus now on a hierarchical check for wtx (don't remove wtx dependent tx).\n,https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-112087492,112087492,
pstratem,2015-06-15T19:34:58Z,@jonasschnelli It seems like it would be more efficient to simply add a whitelisting flag to CTxMemPoolEntry which is passed as part of addUnchecked\n,https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-112182405,112182405,
pstratem,2015-06-15T19:49:34Z,"@morcos Unfortunately that was the same conclusion that I came to.\n\nIf I can get everybody to agree on some algorithm for calculating a single priority number which takes into account dPriority, nFee, and IsMine/IsFromMe then the code here (and potentially in CreateNewBlock) becomes much simpler.\n",https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-112186793,112186793,
morcos,2015-06-15T19:56:03Z,"actually it's probably a lot easier to keep dPriority in its own queue, because that queue is a pain to maintain as all the transactions in it are updating their priority every block.\n\nalso having CPFP implemented will make this work a lot better if we can make it efficient\n",https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-112188766,112188766,
gavinandresen,2015-06-15T20:07:02Z,"When I've contemplated updating this code in the past I've thought that storing mempool entries using a Boost multi-index container (with indexes on fee-per-kb, priority, and time inserted) would be the right thing to do. See http://www.boost.org/doc/libs/1_58_0/libs/multi_index/doc/index.html\n\nThe goal would be to do all the sorting as transactions enter the mempool, so CreateNewBlock doesn't h",https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-112191902,112191902,
pstratem,2015-06-15T20:17:50Z,@gavinandresen The goal is simplicity...\n,https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-112196023,112196023,
sipa,2015-06-15T20:29:07Z,"I must agree actually that boost::multiindex is pretty elegant and efficient, for this purpose.\n",https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-112198793,112198793,
pstratem,2015-06-15T20:30:42Z,@jonasschnelli  @morcos \n\nOn further consideration... protecting wallet transactions from eviction is an information leak.\n,https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-112199200,112199200,
sipa,2015-06-15T20:33:28Z,"@pstratem That's indeed a consideration. The alternative is to do all tracking inside the wallet for conflicts, but that is less strong (it cannot detect conflicts that are caused by an indirect out-of-wallet dependency that conflicts). In the long term, I think there is no way around that though - the dependency of the wallet is ugly, inefficient, and incompatible with SPV (and my idea, IIRC...).",https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-112200214,112200214,
pstratem,2015-06-15T20:43:45Z,Then the question is whether memory pool acceptance should use the same transaction priority model as block creation.\n,https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-112205019,112205019,
morcos,2015-06-15T20:52:15Z,Ugh..  turns out I spoke too soon on the priority calculations.  `GetPriority` in txmempool.cpp is wrong after all.\n,https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-112207850,112207850,
jonasschnelli,2015-06-15T23:27:04Z,@pstratem: I'm not sure if adding whitelist flag to CTxMemPoolEntry is the right way. How would you then protect a 0-conf input (which has low priority for some reasons and therefore is marked for removal) used within a just created wtx (not part of the assumed pool sweep)? Or also the other way (wtx outpoint used in tx input and marked for deletion during poolsweep).\n\nBut the potential privacy ,https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-112236905,112236905,
sipa,2015-06-16T09:08:56Z,"The problem is that the wallet uses the mempool as a means for estimating\nwhether an unconfirmed transaction is expected to be confirmed.\n\nWith the memory-size-limited mempool, it pretty much loses that\nfunctionality, because when you set your limit lower than most mempools in\nthe network, or even lower than just a few miners, that does not decrease\nyour confirmation chances; only your abili",https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-112350758,112350758,
petertodd,2015-06-16T13:01:41Z,"re: 0-conf chains, this is a good argument to handle them w/ replace-by-fee, by rewriting the tx with more outputs rather than a long chain. Also, this results in lower overall tx fee costs.\n",https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-112419401,112419401,
pstratem,2015-06-16T23:08:57Z,@sipa ah so if a wallet transaction is evicted from the mempool the conflict tracking stuff will all break? that's nasty\n\nthe rabbit's hole of things to fix gets every deeper\n,https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-112599310,112599310,
dgenr8,2015-06-17T00:53:34Z,Wallet could add parents of a received wtx that are &lt; some-confirmation-level.  Conflict detection is important enough to justify this imho.  Next question is how long to keep the parents (esp. if wtx and possibly parents remain unconfirmed).\n,https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-112615569,112615569,
petertodd,2015-06-18T06:26:19Z,Have you considered just making the minimum relay/acceptance fee increase exponentially as the mempool size increases? e.g. just doubling the min-relay-fee for every additional x MB would be easy to implement.\n,https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-113050305,113050305,
lapp0,2015-06-18T09:43:29Z,"Does this open a new DoS vulnerability?\n\nIf you can fill transactions to the max mempool size of some peers, you can replace any dropped transaction with little additional fee. This set of transactions would propagate through any peers that have a mempool limit smaller than the set of transactions.\n\nPerhaps an index of outputs that have been redeemed by transactions dropped from the mempool ne",https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-113091854,113091854,
pstratem,2015-06-18T09:54:30Z,"@petertodd a hard upper bound is preferred for memory constrained systems, possibly such a scheme could be used in addition to the upper limit\n",https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-113096178,113096178,
pstratem,2015-06-18T10:08:47Z,@lapp0 an attacker directly connected to a peer can send the same low priority transaction to the peer continuously; this is however insignificant\n,https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-113098660,113098660,
lapp0,2015-06-18T10:23:06Z,"@pstratem And if a transaction is dropped from the mempool, an attacker can replace that transaction and have that replacement transaction propagate among all peers that have also dropped the transaction.\n\nThe resources used to broadcast X bytes of data to the set of nodes that the data can propagate to is the cost of uploading X bytes to my peer(s) that will propagate it.\n",https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-113100811,113100811,
pstratem,2015-06-18T10:35:48Z,@lapp0 the replacement wont pass AcceptToMemoryPool and will thus not be relayed\n,https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-113103025,113103025,
lapp0,2015-06-18T10:41:39Z,@pstratem why?\n,https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-113104313,113104313,
pstratem,2015-06-18T10:46:40Z,@lapp0 because that's what the code does?\n,https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-113104960,113104960,
lapp0,2015-06-18T10:51:32Z,"@pstratem I think you're missing the fact that the transaction it's ""replacing"" is dropped. If it's accepted into the mempool the first time it's not already there, it should also be accepted the 2nd time it's not in the mempool.\n",https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-113105616,113105616,
pstratem,2015-06-18T10:54:17Z,"@lapp0 a remote node cannot trigger a transaction to be dropped except by sending a new transaction with higher priority/fees, stop and reconsider how that effects what you're considering\n",https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-113106005,113106005,
pstratem,2015-06-18T11:01:29Z,"@lapp0 after consulting @sipa i think I understand what you're getting at, it's the same issue that the replace by fee patch has around enforcing a minimum delta in fees for replacement, is that right?\n",https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-113107453,113107453,
sipa,2015-06-18T11:03:36Z,"Good catch. I think indeed that if tx1 causes tx2 to be evicted, that\ntx1.fee - tx2.fee should account for the relay cost of tx1.\n",https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-113108022,113108022,
lapp0,2015-06-18T11:05:32Z,"@pstratem Yes, I considered the fact that you must have a higher fee in my first comment ""you can replace any dropped transaction with little additional fee.""\n\nIf you order by fees it is very cheap to outbid your own transactions and drop them.\n\nUpdate:\n\n> It's the same issue that the replace by fee patch has around enforcing a minimum delta in fees for replacement, is that right?\n\nYes, ho",https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-113108921,113108921,
pstratem,2015-06-18T11:25:23Z,@lapp0 sorry I misinterpreted your first comment\n,https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-113120098,113120098,
petertodd,2015-06-18T19:37:26Z,"@lapp0 Given we're discussing this on #bitcoin-dev right now, just wanted to say kudo's to your recognizing the RBF-like fee issue re: eviction. Nice catch!\n",https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-113267913,113267913,
pstratem,2015-06-26T07:57:20Z,Transactions that are old are now removed first.\n\nThe memory pool is then trimmed on a strict feerate basis.\n,https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-115566738,115566738,
lapp0,2015-06-26T08:50:40Z,Perhaps this should be integrated with #6331?\n,https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-115581735,115581735,
sipa,2015-07-09T18:42:09Z,See #6410 for accurate memory usage accounting.\n,https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-120101020,120101020,
ashleyholman,2015-07-11T10:19:52Z,@pstratem could you explain the rationale behind removeOldTransactions()?  It looks like you are calculating the expected number of seconds it would take the drain a full mempool with full blocks every 10 mins.  And then you are subtracting this amount of time from the current timestamp and pruning any transactions are older than that?  What is the logic behind that?\n,https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-120601828,120601828,
sipa,2015-07-11T10:43:27Z,"I'm working on another mempool limiting implementation, which uses\n@ashleyholman's index, and should deal correctly with the DoS issue\ndescribee above.\n",https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-120603369,120603369,
pstratem,2015-07-11T20:39:23Z,@ashleyholman The model used for evicting transactions from the mempool cannot perfectly model the policy of miners as a whole.  As such it's necessary for the age of a transaction to be part of the eviction criteria.\n,https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-120660451,120660451,
pstratem,2015-07-12T21:29:30Z,Closed in favor of #6421 \n,https://github.com/bitcoin/bitcoin/pull/6281#issuecomment-120763279,120763279,
