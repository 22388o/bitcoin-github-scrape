[
  {
    "sha": "a119cfa881d7c5fb30dfef22796fd13a7eee2a9f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphMTE5Y2ZhODgxZDdjNWZiMzBkZmVmMjI3OTZmZDEzYTdlZWUyYTlm",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-04-10T09:10:04Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-04-10T10:50:35Z"
      },
      "message": "Simplify mining code",
      "tree": {
        "sha": "f747c50efb8bb5ea06f1d77a559e58a196b9d467",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f747c50efb8bb5ea06f1d77a559e58a196b9d467"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a119cfa881d7c5fb30dfef22796fd13a7eee2a9f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a119cfa881d7c5fb30dfef22796fd13a7eee2a9f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a119cfa881d7c5fb30dfef22796fd13a7eee2a9f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a119cfa881d7c5fb30dfef22796fd13a7eee2a9f/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c8a13501196fc79a3f728683b74f9d586dda46c1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c8a13501196fc79a3f728683b74f9d586dda46c1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c8a13501196fc79a3f728683b74f9d586dda46c1"
      }
    ],
    "stats": {
      "total": 184,
      "additions": 83,
      "deletions": 101
    },
    "files": [
      {
        "sha": "2c7fffb21bfee4ba4764ae95f94ea6f34e04d33c",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 60,
        "deletions": 68,
        "changes": 128,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a119cfa881d7c5fb30dfef22796fd13a7eee2a9f/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a119cfa881d7c5fb30dfef22796fd13a7eee2a9f/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=a119cfa881d7c5fb30dfef22796fd13a7eee2a9f",
        "patch": "@@ -81,13 +81,10 @@ class TxPriorityCompare\n void UpdateTime(CBlockHeader* pblock, const CBlockIndex* pindexPrev)\n {\n     pblock->nTime = std::max(pindexPrev->GetMedianTimePast()+1, GetAdjustedTime());\n-\n-    // Updating time can change work required on testnet:\n-    if (Params().AllowMinDifficultyBlocks())\n-        pblock->nBits = GetNextWorkRequired(pindexPrev, pblock, Params().GetConsensus());\n+    pblock->nBits = GetNextWorkRequired(pindexPrev, pblock, Params().GetConsensus());\n }\n \n-CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n+CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn, CBlockIndex*& pindexPrev, const CChainParams& params)\n {\n     // Create new block\n     auto_ptr<CBlockTemplate> pblocktemplate(new CBlockTemplate());\n@@ -97,7 +94,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n \n     // -regtest only: allow overriding block.nVersion with\n     // -blockversion=N to test forking scenarios\n-    if (Params().MineBlocksOnDemand())\n+    if (params.MineBlocksOnDemand())\n         pblock->nVersion = GetArg(\"-blockversion\", pblock->nVersion);\n \n     // Create coinbase tx\n@@ -132,7 +129,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n \n     {\n         LOCK2(cs_main, mempool.cs);\n-        CBlockIndex* pindexPrev = chainActive.Tip();\n+        pindexPrev = chainActive.Tip();\n         const int nHeight = pindexPrev->nHeight + 1;\n         CCoinsViewCache view(pcoinsTip);\n \n@@ -326,7 +323,6 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n         // Fill in header\n         pblock->hashPrevBlock  = pindexPrev->GetBlockHash();\n         UpdateTime(pblock, pindexPrev);\n-        pblock->nBits          = GetNextWorkRequired(pindexPrev, pblock, Params().GetConsensus());\n         pblock->nNonce         = 0;\n         pblocktemplate->vTxSigOps[0] = GetLegacySigOpCount(pblock->vtx[0]);\n \n@@ -364,46 +360,36 @@ void IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int&\n //\n \n //\n-// ScanHash scans nonces looking for a hash with at least some zero bits.\n-// The nonce is usually preserved between calls, but periodically or if the\n-// nonce is 0xffff0000 or above, the block is rebuilt and nNonce starts over at\n-// zero.\n+// ScanHash iterates up to nMaxIter nonces in order to find a block with\n+// valid proof of work. It returns false after that.\n //\n-bool static ScanHash(const CBlockHeader *pblock, uint32_t& nNonce, uint256 *phash)\n+bool static ScanHash(CBlockHeader *pblock, CBlockIndex *pindexPrev, int64_t nMaxIter)\n {\n-    // Write the first 76 bytes of the block header to a double-SHA256 state.\n-    CHash256 hasher;\n-    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n-    ss << *pblock;\n-    assert(ss.size() == 80);\n-    hasher.Write((unsigned char*)&ss[0], 76);\n+    UpdateTime(pblock, pindexPrev);\n \n-    while (true) {\n-        nNonce++;\n+    uint256 hash;\n+    arith_uint256 hashTarget = arith_uint256().SetCompact(pblock->nBits);\n \n-        // Write the last 4 bytes of the block header (the nonce) to a copy of\n-        // the double-SHA256 state, and compute the result.\n-        CHash256(hasher).Write((unsigned char*)&nNonce, 4).Finalize((unsigned char*)phash);\n+    while (nMaxIter--) {\n+        pblock->nNonce++;\n+        hash = pblock->GetHash();\n \n-        // Return the nonce if the hash has at least some zero bits,\n-        // caller will check if it has enough to reach the target\n-        if (((uint16_t*)phash)[15] == 0)\n+        if (UintToArith256(hash) <= hashTarget)\n             return true;\n-\n-        // If nothing found after trying for a while, return -1\n-        if ((nNonce & 0xfff) == 0)\n-            return false;\n     }\n+\n+    // If nothing found after trying for a while, return false.\n+    return false;\n }\n \n-CBlockTemplate* CreateNewBlockWithKey(CReserveKey& reservekey)\n+CBlockTemplate* CreateNewBlockWithKey(CReserveKey& reservekey, CBlockIndex*& pindexPrev, const CChainParams& params)\n {\n     CPubKey pubkey;\n     if (!reservekey.GetReservedKey(pubkey))\n         return NULL;\n \n     CScript scriptPubKey = CScript() << ToByteVector(pubkey) << OP_CHECKSIG;\n-    return CreateNewBlock(scriptPubKey);\n+    return CreateNewBlock(scriptPubKey, pindexPrev, params);\n }\n \n static bool ProcessBlockFound(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey)\n@@ -435,6 +421,36 @@ static bool ProcessBlockFound(CBlock* pblock, CWallet& wallet, CReserveKey& rese\n     return true;\n }\n \n+bool MineBlock(CReserveKey& reservekey, uint256& hash)\n+{\n+    unsigned int nExtraNonce = 0;\n+\n+    while (true) {\n+        CBlockIndex *pindexPrev = NULL;\n+\n+        auto_ptr<CBlockTemplate> pblocktemplate(CreateNewBlockWithKey(reservekey, pindexPrev, Params()));\n+        if (!pblocktemplate.get()) {\n+            return false;\n+        }\n+\n+        CBlock *pblock = &pblocktemplate->block;\n+        IncrementExtraNonce(pblock, pindexPrev, nExtraNonce);\n+\n+        while (true) {\n+            if (ScanHash(pblock, pindexPrev, 0x1000)) {\n+                CValidationState state;\n+                if (ProcessNewBlock(state, NULL, pblock)) {\n+                    hash = pblock->GetHash();\n+                    return true;\n+                }\n+            }\n+            boost::this_thread::interruption_point();\n+            if (pblock->nNonce >= 0xffff0000)\n+                break;\n+        }\n+    }\n+}\n+\n void static BitcoinMiner(CWallet *pwallet)\n {\n     LogPrintf(\"BitcoinMiner started\\n\");\n@@ -458,9 +474,9 @@ void static BitcoinMiner(CWallet *pwallet)\n             // Create new block\n             //\n             unsigned int nTransactionsUpdatedLast = mempool.GetTransactionsUpdated();\n-            CBlockIndex* pindexPrev = chainActive.Tip();\n+            CBlockIndex* pindexPrev = NULL;\n \n-            auto_ptr<CBlockTemplate> pblocktemplate(CreateNewBlockWithKey(reservekey));\n+            auto_ptr<CBlockTemplate> pblocktemplate(CreateNewBlockWithKey(reservekey, pindexPrev, Params()));\n             if (!pblocktemplate.get())\n             {\n                 LogPrintf(\"Error in BitcoinMiner: Keypool ran out, please call keypoolrefill before restarting the mining thread\\n\");\n@@ -476,52 +492,28 @@ void static BitcoinMiner(CWallet *pwallet)\n             // Search\n             //\n             int64_t nStart = GetTime();\n-            arith_uint256 hashTarget = arith_uint256().SetCompact(pblock->nBits);\n-            uint256 hash;\n-            uint32_t nNonce = 0;\n             while (true) {\n                 // Check if something found\n-                if (ScanHash(pblock, nNonce, &hash))\n-                {\n-                    if (UintToArith256(hash) <= hashTarget)\n-                    {\n-                        // Found a solution\n-                        pblock->nNonce = nNonce;\n-                        assert(hash == pblock->GetHash());\n-\n-                        SetThreadPriority(THREAD_PRIORITY_NORMAL);\n-                        LogPrintf(\"BitcoinMiner:\\n\");\n-                        LogPrintf(\"proof-of-work found  \\n  hash: %s  \\ntarget: %s\\n\", hash.GetHex(), hashTarget.GetHex());\n-                        ProcessBlockFound(pblock, *pwallet, reservekey);\n-                        SetThreadPriority(THREAD_PRIORITY_LOWEST);\n-\n-                        // In regression test mode, stop mining after a block is found.\n-                        if (Params().MineBlocksOnDemand())\n-                            throw boost::thread_interrupted();\n+                if (ScanHash(pblock, pindexPrev, 0x1000)) {\n+                    SetThreadPriority(THREAD_PRIORITY_NORMAL);\n+                    LogPrintf(\"BitcoinMiner:\\n\");\n+                    LogPrintf(\"proof-of-work found  \\n\");\n+                    ProcessBlockFound(pblock, *pwallet, reservekey);\n+                    SetThreadPriority(THREAD_PRIORITY_LOWEST);\n \n-                        break;\n-                    }\n+                    break;\n                 }\n-\n-                // Check for stop or if block needs to be rebuilt\n                 boost::this_thread::interruption_point();\n+\n                 // Regtest mode doesn't require peers\n                 if (vNodes.empty() && Params().MiningRequiresPeers())\n                     break;\n-                if (nNonce >= 0xffff0000)\n+                if (pblock->nNonce >= 0xffff0000)\n                     break;\n                 if (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && GetTime() - nStart > 60)\n                     break;\n                 if (pindexPrev != chainActive.Tip())\n                     break;\n-\n-                // Update nTime every few seconds\n-                UpdateTime(pblock, pindexPrev);\n-                if (Params().AllowMinDifficultyBlocks())\n-                {\n-                    // Changing pblock->nTime can change work required on testnet:\n-                    hashTarget.SetCompact(pblock->nBits);\n-                }\n             }\n         }\n     }"
      },
      {
        "sha": "ed0d249a147bdd571430247eb215ddf370b83118",
        "filename": "src/miner.h",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a119cfa881d7c5fb30dfef22796fd13a7eee2a9f/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a119cfa881d7c5fb30dfef22796fd13a7eee2a9f/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=a119cfa881d7c5fb30dfef22796fd13a7eee2a9f",
        "patch": "@@ -7,6 +7,7 @@\n #define BITCOIN_MINER_H\n \n #include \"primitives/block.h\"\n+#include \"chainparams.h\"\n \n #include <stdint.h>\n \n@@ -25,8 +26,9 @@ struct CBlockTemplate\n /** Run the miner threads */\n void GenerateBitcoins(bool fGenerate, CWallet* pwallet, int nThreads);\n /** Generate a new block, without valid proof-of-work */\n-CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn);\n-CBlockTemplate* CreateNewBlockWithKey(CReserveKey& reservekey);\n+CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn, CBlockIndex*& pindexPrev, const CChainParams& params);\n+CBlockTemplate* CreateNewBlockWithKey(CReserveKey& reservekey, CBlockIndex*& pindexPrev, const CChainParams& params);\n+bool MineBlock(CReserveKey& key, uint256& hash);\n /** Modify the extranonce in a block */\n void IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int& nExtraNonce);\n void UpdateTime(CBlockHeader* block, const CBlockIndex* pindexPrev);"
      },
      {
        "sha": "544d6b02a194f4f03580570dfe5d4a19115537c0",
        "filename": "src/rpcmining.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 18,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a119cfa881d7c5fb30dfef22796fd13a7eee2a9f/src/rpcmining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a119cfa881d7c5fb30dfef22796fd13a7eee2a9f/src/rpcmining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcmining.cpp?ref=a119cfa881d7c5fb30dfef22796fd13a7eee2a9f",
        "patch": "@@ -145,28 +145,15 @@ Value generate(const Array& params, bool fHelp)\n         nHeight = nHeightStart;\n         nHeightEnd = nHeightStart+nGenerate;\n     }\n-    unsigned int nExtraNonce = 0;\n     Array blockHashes;\n     while (nHeight < nHeightEnd)\n     {\n-        auto_ptr<CBlockTemplate> pblocktemplate(CreateNewBlockWithKey(reservekey));\n-        if (!pblocktemplate.get())\n+        uint256 hash;\n+        if (!MineBlock(reservekey, hash)) {\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"Wallet keypool empty\");\n-        CBlock *pblock = &pblocktemplate->block;\n-        {\n-            LOCK(cs_main);\n-            IncrementExtraNonce(pblock, chainActive.Tip(), nExtraNonce);\n-        }\n-        while (!CheckProofOfWork(pblock->GetHash(), pblock->nBits, Params().GetConsensus())) {\n-            // Yes, there is a chance every nonce could fail to satisfy the -regtest\n-            // target -- 1 in 2^(2^32). That ain't gonna happen.\n-            ++pblock->nNonce;\n         }\n-        CValidationState state;\n-        if (!ProcessNewBlock(state, NULL, pblock))\n-            throw JSONRPCError(RPC_INTERNAL_ERROR, \"ProcessNewBlock, block not accepted\");\n         ++nHeight;\n-        blockHashes.push_back(pblock->GetHash().GetHex());\n+        blockHashes.push_back(hash.GetHex());\n     }\n     return blockHashes;\n }\n@@ -494,7 +481,7 @@ Value getblocktemplate(const Array& params, bool fHelp)\n \n         // Store the pindexBest used before CreateNewBlock, to avoid races\n         nTransactionsUpdatedLast = mempool.GetTransactionsUpdated();\n-        CBlockIndex* pindexPrevNew = chainActive.Tip();\n+        CBlockIndex* pindexPrevNew = NULL;\n         nStart = GetTime();\n \n         // Create new block\n@@ -504,7 +491,7 @@ Value getblocktemplate(const Array& params, bool fHelp)\n             pblocktemplate = NULL;\n         }\n         CScript scriptDummy = CScript() << OP_TRUE;\n-        pblocktemplate = CreateNewBlock(scriptDummy);\n+        pblocktemplate = CreateNewBlock(scriptDummy, pindexPrevNew, Params());\n         if (!pblocktemplate)\n             throw JSONRPCError(RPC_OUT_OF_MEMORY, \"Out of memory\");\n "
      },
      {
        "sha": "c9a6b76110fc16633fb9f96f56553e5e0a573003",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 13,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a119cfa881d7c5fb30dfef22796fd13a7eee2a9f/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a119cfa881d7c5fb30dfef22796fd13a7eee2a9f/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=a119cfa881d7c5fb30dfef22796fd13a7eee2a9f",
        "patch": "@@ -57,12 +57,13 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     CMutableTransaction tx,tx2;\n     CScript script;\n     uint256 hash;\n+    CBlockIndex *pindexPrev = NULL;\n \n     LOCK(cs_main);\n     Checkpoints::fEnabled = false;\n \n     // Simple block creation, nothing special yet:\n-    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey, pindexPrev, Params()));\n \n     // We can't make transactions until we have inputs\n     // Therefore, load 100 blocks :)\n@@ -90,7 +91,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     delete pblocktemplate;\n \n     // Just to make sure we can still make simple blocks\n-    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey, pindexPrev, Params()));\n     delete pblocktemplate;\n \n     // block sigops > limit: 1000 CHECKMULTISIG + 1\n@@ -108,7 +109,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n         tx.vin[0].prevout.hash = hash;\n     }\n-    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey, pindexPrev, Params()));\n     delete pblocktemplate;\n     mempool.clear();\n \n@@ -128,14 +129,14 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n         tx.vin[0].prevout.hash = hash;\n     }\n-    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey, pindexPrev, Params()));\n     delete pblocktemplate;\n     mempool.clear();\n \n     // orphan in mempool\n     hash = tx.GetHash();\n     mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n-    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey, pindexPrev, Params()));\n     delete pblocktemplate;\n     mempool.clear();\n \n@@ -153,7 +154,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vout[0].nValue = 5900000000LL;\n     hash = tx.GetHash();\n     mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n-    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey, pindexPrev, Params()));\n     delete pblocktemplate;\n     mempool.clear();\n \n@@ -164,7 +165,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vout[0].nValue = 0;\n     hash = tx.GetHash();\n     mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n-    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey, pindexPrev, Params()));\n     delete pblocktemplate;\n     mempool.clear();\n \n@@ -182,7 +183,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vout[0].nValue -= 1000000;\n     hash = tx.GetHash();\n     mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n-    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey, pindexPrev, Params()));\n     delete pblocktemplate;\n     mempool.clear();\n \n@@ -196,17 +197,17 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vout[0].scriptPubKey = CScript() << OP_2;\n     hash = tx.GetHash();\n     mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n-    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey, pindexPrev, Params()));\n     delete pblocktemplate;\n     mempool.clear();\n \n     // subsidy changing\n     int nHeight = chainActive.Height();\n     chainActive.Tip()->nHeight = 209999;\n-    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey, pindexPrev, Params()));\n     delete pblocktemplate;\n     chainActive.Tip()->nHeight = 210000;\n-    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey, pindexPrev, Params()));\n     delete pblocktemplate;\n     chainActive.Tip()->nHeight = nHeight;\n \n@@ -238,7 +239,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     mempool.addUnchecked(hash, CTxMemPoolEntry(tx2, 11, GetTime(), 111.0, 11));\n     BOOST_CHECK(!IsFinalTx(tx2));\n \n-    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey, pindexPrev, Params()));\n \n     // Neither tx should have make it into the template.\n     BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 1);\n@@ -251,7 +252,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     BOOST_CHECK(IsFinalTx(tx, chainActive.Tip()->nHeight + 1));\n     BOOST_CHECK(IsFinalTx(tx2));\n \n-    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey, pindexPrev, Params()));\n     BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 3);\n     delete pblocktemplate;\n "
      }
    ]
  }
]