[
  {
    "sha": "3d060feddf627ae204c619cc1104171be633de6e",
    "node_id": "C_kwDOABII59oAKDNkMDYwZmVkZGY2MjdhZTIwNGM2MTljYzExMDQxNzFiZTYzM2RlNmU",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "j@rubin.io",
        "date": "2021-10-19T18:58:17Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "j@rubin.io",
        "date": "2021-10-19T19:36:28Z"
      },
      "message": "Add a basic python REST API Server Wrapper",
      "tree": {
        "sha": "2aa641913a44ea95987439e024399ccebe8a4568",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2aa641913a44ea95987439e024399ccebe8a4568"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3d060feddf627ae204c619cc1104171be633de6e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3d060feddf627ae204c619cc1104171be633de6e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3d060feddf627ae204c619cc1104171be633de6e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3d060feddf627ae204c619cc1104171be633de6e/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "986003aff93c099c400c9285b4a2ed63f4b3f180",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/986003aff93c099c400c9285b4a2ed63f4b3f180",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/986003aff93c099c400c9285b4a2ed63f4b3f180"
      }
    ],
    "stats": {
      "total": 355,
      "additions": 355,
      "deletions": 0
    },
    "files": [
      {
        "sha": "5cd2c3b67c26537e2b0f46c71204c9bfe7077422",
        "filename": "contrib/rest/server.py",
        "status": "added",
        "additions": 355,
        "deletions": 0,
        "changes": 355,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3d060feddf627ae204c619cc1104171be633de6e/contrib/rest/server.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3d060feddf627ae204c619cc1104171be633de6e/contrib/rest/server.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/rest/server.py?ref=3d060feddf627ae204c619cc1104171be633de6e",
        "patch": "@@ -0,0 +1,355 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2021 Jeremy Rubin (added REST API)\n+#\n+# Copyright (c) 2011 Jeff Garzik\n+#\n+# Previous copyright, from python-jsonrpc/jsonrpc/proxy.py:\n+#\n+# Copyright (c) 2007 Jan-Klaas Kollhof\n+#\n+# This file is part of jsonrpc.\n+#\n+# jsonrpc is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU Lesser General Public License as published by\n+# the Free Software Foundation; either version 2.1 of the License, or\n+# (at your option) any later version.\n+#\n+# This software is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Lesser General Public License for more details.\n+#\n+# You should have received a copy of the GNU Lesser General Public License\n+# along with this software; if not, write to the Free Software\n+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n+\"\"\"HTTP proxy for opening RPC connection to bitcoind.\n+\n+AuthServiceProxy has the following improvements over python-jsonrpc's\n+ServiceProxy class:\n+\n+- HTTP connections persist for the life of the AuthServiceProxy object\n+  (if server supports HTTP/1.1)\n+- sends protocol 'version', per JSON-RPC 1.1\n+- sends proper, incrementing 'id'\n+- sends Basic HTTP authentication headers\n+- parses all JSON numbers that look like floats as Decimal\n+- uses standard Python json lib\n+\"\"\"\n+\n+import base64\n+import decimal\n+from http import HTTPStatus\n+import http.client\n+import json\n+import logging\n+import os\n+import socket\n+import sys\n+import time\n+import urllib.parse\n+import tornado.ioloop\n+import tornado.web\n+\n+HTTP_TIMEOUT = 30\n+USER_AGENT = \"AuthServiceProxy/0.1\"\n+\n+log = logging.getLogger(\"BitcoinRPC\")\n+\n+class JSONRPCException(Exception):\n+    def __init__(self, rpc_error, http_status=None):\n+        try:\n+            errmsg = '%(message)s (%(code)i)' % rpc_error\n+        except (KeyError, TypeError):\n+            errmsg = ''\n+        super().__init__(errmsg)\n+        self.error = rpc_error\n+        self.http_status = http_status\n+\n+\n+def EncodeDecimal(o):\n+    if isinstance(o, decimal.Decimal):\n+        return str(o)\n+    raise TypeError(repr(o) + \" is not JSON serializable\")\n+\n+class AuthServiceProxy():\n+    __id_count = 0\n+\n+    # ensure_ascii: escape unicode as \\uXXXX, passed to json.dumps\n+    def __init__(self, service_url, service_name=None, timeout=HTTP_TIMEOUT, connection=None, ensure_ascii=True):\n+        self.__service_url = service_url\n+        self._service_name = service_name\n+        self.ensure_ascii = ensure_ascii  # can be toggled on the fly by tests\n+        self.__url = urllib.parse.urlparse(service_url)\n+        user = None if self.__url.username is None else self.__url.username.encode('utf8')\n+        passwd = None if self.__url.password is None else self.__url.password.encode('utf8')\n+        authpair = user + b':' + passwd\n+        self.__auth_header = b'Basic ' + base64.b64encode(authpair)\n+        self.timeout = timeout\n+        self._set_conn(connection)\n+\n+    def __getattr__(self, name):\n+        if name.startswith('__') and name.endswith('__'):\n+            # Python internal stuff\n+            raise AttributeError\n+        if self._service_name is not None:\n+            name = \"%s.%s\" % (self._service_name, name)\n+        return AuthServiceProxy(self.__service_url, name, connection=self.__conn)\n+\n+    def _request(self, method, path, postdata):\n+        '''\n+        Do a HTTP request, with retry if we get disconnected (e.g. due to a timeout).\n+        This is a workaround for https://bugs.python.org/issue3566 which is fixed in Python 3.5.\n+        '''\n+        headers = {'Host': self.__url.hostname,\n+                   'User-Agent': USER_AGENT,\n+                   'Authorization': self.__auth_header,\n+                   'Content-type': 'application/json'}\n+        if os.name == 'nt':\n+            # Windows somehow does not like to re-use connections\n+            # TODO: Find out why the connection would disconnect occasionally and make it reusable on Windows\n+            # Avoid \"ConnectionAbortedError: [WinError 10053] An established connection was aborted by the software in your host machine\"\n+            self._set_conn()\n+        try:\n+            self.__conn.request(method, path, postdata, headers)\n+            return self._get_response()\n+        except (BrokenPipeError, ConnectionResetError):\n+            # Python 3.5+ raises BrokenPipeError when the connection was reset\n+            # ConnectionResetError happens on FreeBSD\n+            self.__conn.close()\n+            self.__conn.request(method, path, postdata, headers)\n+            return self._get_response()\n+        except OSError as e:\n+            retry = (\n+                '[WinError 10053] An established connection was aborted by the software in your host machine' in str(e))\n+            # Workaround for a bug on macOS. See https://bugs.python.org/issue33450\n+            retry = retry or ('[Errno 41] Protocol wrong type for socket' in str(e))\n+            if retry:\n+                self.__conn.close()\n+                self.__conn.request(method, path, postdata, headers)\n+                return self._get_response()\n+            else:\n+                raise\n+\n+    def get_request(self, *args, **argsn):\n+        AuthServiceProxy.__id_count += 1\n+\n+        log.debug(\"-{}-> {} {}\".format(\n+            AuthServiceProxy.__id_count,\n+            self._service_name,\n+            json.dumps(args or argsn, default=EncodeDecimal, ensure_ascii=self.ensure_ascii),\n+        ))\n+        if args and argsn:\n+            raise ValueError('Cannot handle both named and positional arguments')\n+        return {'version': '1.1',\n+                'method': self._service_name,\n+                'params': args or argsn,\n+                'id': AuthServiceProxy.__id_count}\n+\n+    def __call__(self, *args, **argsn):\n+        postdata = json.dumps(self.get_request(*args, **argsn), default=EncodeDecimal, ensure_ascii=self.ensure_ascii)\n+        response, status = self._request('POST', self.__url.path, postdata.encode('utf-8'))\n+        if response['error'] is not None:\n+            raise JSONRPCException(response['error'], status)\n+        elif 'result' not in response:\n+            raise JSONRPCException({\n+                'code': -343, 'message': 'missing JSON-RPC result'}, status)\n+        elif status != HTTPStatus.OK:\n+            raise JSONRPCException({\n+                'code': -342, 'message': 'non-200 HTTP status code but no JSON-RPC error'}, status)\n+        else:\n+            return response['result']\n+\n+    def batch(self, rpc_call_list):\n+        postdata = json.dumps(list(rpc_call_list), default=EncodeDecimal, ensure_ascii=self.ensure_ascii)\n+        log.debug(\"--> \" + postdata)\n+        response, status = self._request('POST', self.__url.path, postdata.encode('utf-8'))\n+        if status != HTTPStatus.OK:\n+            raise JSONRPCException({\n+                'code': -342, 'message': 'non-200 HTTP status code but no JSON-RPC error'}, status)\n+        return response\n+\n+    def _get_response(self):\n+        req_start_time = time.time()\n+        try:\n+            http_response = self.__conn.getresponse()\n+        except socket.timeout:\n+            raise JSONRPCException({\n+                'code': -344,\n+                'message': '%r RPC took longer than %f seconds. Consider '\n+                           'using larger timeout for calls that take '\n+                           'longer to return.' % (self._service_name,\n+                                                  self.__conn.timeout)})\n+        if http_response is None:\n+            raise JSONRPCException({\n+                'code': -342, 'message': 'missing HTTP response from server'})\n+\n+        content_type = http_response.getheader('Content-Type')\n+        if content_type != 'application/json':\n+            raise JSONRPCException(\n+                {'code': -342, 'message': 'non-JSON HTTP response with \\'%i %s\\' from server' % (http_response.status, http_response.reason)},\n+                http_response.status)\n+\n+        responsedata = http_response.read().decode('utf8')\n+        response = json.loads(responsedata, parse_float=decimal.Decimal)\n+        elapsed = time.time() - req_start_time\n+        if \"error\" in response and response[\"error\"] is None:\n+            log.debug(\"<-%s- [%.6f] %s\" % (response[\"id\"], elapsed, json.dumps(response[\"result\"], default=EncodeDecimal, ensure_ascii=self.ensure_ascii)))\n+        else:\n+            log.debug(\"<-- [%.6f] %s\" % (elapsed, responsedata))\n+        return response, http_response.status\n+\n+    def __truediv__(self, relative_uri):\n+        return AuthServiceProxy(\"{}/{}\".format(self.__service_url, relative_uri), self._service_name, connection=self.__conn)\n+\n+    def _set_conn(self, connection=None):\n+        port = 80 if self.__url.port is None else self.__url.port\n+        if connection:\n+            self.__conn = connection\n+            self.timeout = connection.timeout\n+        elif self.__url.scheme == 'https':\n+            self.__conn = http.client.HTTPSConnection(self.__url.hostname, port, timeout=self.timeout)\n+        else:\n+            self.__conn = http.client.HTTPConnection(self.__url.hostname, port, timeout=self.timeout)\n+\n+app_log = logging.getLogger('tornado.application')\n+\n+\n+class rest_tx(tornado.web.RequestHandler):\n+    def get(self, txhash, encoding):\n+        node = AuthServiceProxy(sys.argv[1])\n+        try:\n+            result = node.getrawtransaction(txhash, 1 if encoding == \".json\" else 0)\n+        except JSONRPCException as e:\n+            msg = f\"Transaction Not Found: {e}\"\n+            raise tornado.web.HTTPError(status_code=404, log_message=msg, reason=msg)\n+        if encoding == \".json\":\n+            self.set_header(\"Content-Type\", 'application/json')\n+            self.write(json.dumps(result, default=EncodeDecimal))\n+        if encoding == \".bin\":\n+            self.set_header(\"Content-Type\", 'application/octet-stream')\n+            self.write(bytes.fromhex(result))\n+        if encoding == \".hex\":\n+            self.set_header(\"Content-Type\", 'application/plain')\n+            self.write(result)\n+\n+def rest_block(details):\n+    class inner(tornado.web.RequestHandler):\n+        def get(self, blockhash, encoding):\n+            node = AuthServiceProxy(sys.argv[1])\n+            try:\n+                result = node.getblock(blockhash, 0 if encoding in [\".hex\", \".bin\"] else (2 if details else 1))\n+            except JSONRPCException as e:\n+                msg = f\"Block Not Found: {e}\"\n+                raise tornado.web.HTTPError(status_code=404, log_message=msg, reason=msg)\n+            if encoding == \".json\":\n+                self.set_header(\"Content-Type\", 'application/json')\n+                self.write(json.dumps(result, default=EncodeDecimal))\n+            if encoding == \".bin\":\n+                self.set_header(\"Content-Type\", 'application/octet-stream')\n+                self.write(bytes.fromhex(result))\n+            if encoding == \".hex\":\n+                self.set_header(\"Content-Type\", 'application/plain')\n+                self.write(result)\n+    return inner\n+\n+class rest_chaininfo(tornado.web.RequestHandler):\n+    def get(self):\n+        node = AuthServiceProxy(sys.argv[1])\n+        try:\n+            result = node.getblockchaininfo()\n+        except JSONRPCException as e:\n+            msg = f\"{e}\"\n+            raise tornado.web.HTTPError(status_code=404, log_message=msg, reason=msg)\n+        self.set_header(\"Content-Type\", 'application/json')\n+        self.write(json.dumps(result, default=EncodeDecimal))\n+class rest_mempool_info(tornado.web.RequestHandler):\n+    def get(self):\n+        node = AuthServiceProxy(sys.argv[1])\n+        try:\n+            result = node.getmempoolinfo()\n+        except JSONRPCException as e:\n+            msg = f\"{e}\"\n+            raise tornado.web.HTTPError(status_code=404, log_message=msg, reason=msg)\n+        self.set_header(\"Content-Type\", 'application/json')\n+        self.write(json.dumps(result, default=EncodeDecimal))\n+class rest_mempool_contents(tornado.web.RequestHandler):\n+    def get(self):\n+        node = AuthServiceProxy(sys.argv[1])\n+        try:\n+            result = node.getrawmempool(1)\n+        except JSONRPCException as e:\n+            msg = f\"Mempool Error: {e}\"\n+            raise tornado.web.HTTPError(status_code=404, log_message=msg, reason=msg)\n+        self.set_header(\"Content-Type\", 'application/json')\n+        self.write(json.dumps(result, default=EncodeDecimal))\n+\n+class rest_headers(tornado.web.RequestHandler):\n+    def get(self, strcount, starthash, encoding):\n+        node = AuthServiceProxy(sys.argv[1])\n+        count = int(strcount)\n+        if count > 2000 or count < 1:\n+            msg = \"Header Count out of range (\"+strcount+\")\"\n+            raise tornado.web.HTTPError(status_code=400, reason=msg, log_message=msg)\n+        result = []\n+        h = starthash\n+        for _ in range(count):\n+            try:\n+                res = node.getblockheader(h, 1 if encoding == \".json\" else 0)\n+            except JSONRPCException as e:\n+                msg = f\"Header {h} Not Found: {e}\"\n+                raise tornado.web.HTTPError(status_code=404, log_message=msg, reason=msg)\n+            result.append(res)\n+            h = result[-1][\"previousblockhash\"] if encoding == \".json\" else result[-1][4:4+32]\n+            if all(ch == '0' for ch in h):\n+                # Is Genesis Block\n+                break\n+\n+        if encoding == \".bin\":\n+            r = b\"\".join(map(bytes.fromhex, result))\n+            self.set_header(\"Content-Type\", 'application/octet-stream')\n+            self.write(r)\n+        if encoding == \".hex\":\n+            self.set_header(\"Content-Type\", 'application/plain')\n+            self.write(\"\".join(result))\n+        if encoding == \".json\":\n+            self.set_header(\"Content-Type\", 'application/json')\n+            self.write(json.dumps(result, default=EncodeDecimal))\n+\n+class rest_blockhash_by_height():\n+    def get(self, str_height, encoding):\n+        node = AuthServiceProxy(sys.argv[1])\n+        height = int(str_height)\n+        try:\n+            result = node.getblockhash(height)\n+        except JSONRPCException as e:\n+            msg = f\"Block {str_height} Not Found: {e}\"\n+            raise tornado.web.HTTPError(status_code=404, log_message=msg, reason=msg)\n+        if encoding == \".json\":\n+            self.set_header(\"Content-Type\", 'application/json')\n+            self.write(json.dumps({\"blockhash\":result}, default=EncodeDecimal))\n+        if encoding == \".bin\":\n+            self.set_header(\"Content-Type\", 'application/octet-stream')\n+            self.write(bytes.fromhex(result))\n+        if encoding == \".hex\":\n+            self.set_header(\"Content-Type\", 'application/plain')\n+            self.write(result)\n+\n+def make_app():\n+    format_hash = \"([0-9a-fA-F]{64})(\\\\.json|\\\\.hex|\\\\.bin)\"\n+    return tornado.web.Application([\n+        (f\"/rest/tx/{format_hash}\", rest_tx),\n+        (f\"/rest/block/notxdetails/{format_hash}\", rest_block(False)),\n+        (f\"/rest/block/{format_hash}\", rest_block(True)),\n+        (f\"/rest/chaininfo.json\", rest_chaininfo),\n+        (f\"/rest/mempool/info.json\", rest_mempool_info),\n+        (f\"/rest/mempool/contents.json\", rest_mempool_contents),\n+        (f\"/rest/headers/([0-9])+/{format_hash}\", rest_headers),\n+        (f\"/rest/blockhashbyheight/([0-9]+)\", rest_blockhash_by_height),\n+        # (f\"/rest/getutxos\", rest_getutxos), # TODO: This API is not REST-y in the original\n+        ])\n+\n+port = int(sys.argv[2])\n+if __name__ == \"__main__\":\n+    app = make_app()\n+    app.listen(port)\n+    tornado.ioloop.IOLoop.current().start()"
      }
    ]
  }
]