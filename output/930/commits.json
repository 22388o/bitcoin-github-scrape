[
  {
    "sha": "d68dcf741e088d8d7033521aa1a1e5e87d9dd283",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNjhkY2Y3NDFlMDg4ZDhkNzAzMzUyMWFhMWExZTVlODdkOWRkMjgz",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-03-10T22:04:06Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-03-12T19:31:56Z"
      },
      "message": "Limit the impact of reorganisations on the database\n\nSometimes a new block arrives in a new chain that was already the\nbest valid one, but wasn't marked that way. This happens for example\nwhen network rules change to recover after a fork.\n\nIn this case, it is not necessary to do the entire reorganisation\ninside a single db commit. These can become huge, and exceed the\nobjects/lockers limits in bdb. This patch limits the blocks the\nactual reorganisation is applied to, and adds the next blocks\nafterwards in separate db transactions.",
      "tree": {
        "sha": "5b98bddc5cb9258e5afab24505ad3dba7238b31a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5b98bddc5cb9258e5afab24505ad3dba7238b31a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d68dcf741e088d8d7033521aa1a1e5e87d9dd283",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d68dcf741e088d8d7033521aa1a1e5e87d9dd283",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d68dcf741e088d8d7033521aa1a1e5e87d9dd283",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d68dcf741e088d8d7033521aa1a1e5e87d9dd283/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "336ba312a6ddc08f40ce456bfd09f0711bdc78dc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/336ba312a6ddc08f40ce456bfd09f0711bdc78dc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/336ba312a6ddc08f40ce456bfd09f0711bdc78dc"
      }
    ],
    "stats": {
      "total": 81,
      "additions": 64,
      "deletions": 17
    },
    "files": [
      {
        "sha": "1b56cead3c631f1cd6f657db5c5c1a2391976afc",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 61,
        "deletions": 17,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d68dcf741e088d8d7033521aa1a1e5e87d9dd283/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d68dcf741e088d8d7033521aa1a1e5e87d9dd283/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=d68dcf741e088d8d7033521aa1a1e5e87d9dd283",
        "patch": "@@ -1457,6 +1457,32 @@ runCommand(std::string strCommand)\n         printf(\"runCommand error: system(%s) returned %d\\n\", strCommand.c_str(), nErr);\n }\n \n+bool CBlock::SetBestChainInner(CTxDB& txdb, CBlockIndex *pindexNew)\n+{\n+    assert(pindexNew->pprev == pindexBest);\n+\n+    uint256 hash = GetHash();\n+\n+    // Adding to current best branch\n+    if (!ConnectBlock(txdb, pindexNew) || !txdb.WriteHashBestChain(hash))\n+    {\n+        txdb.TxnAbort();\n+        InvalidChainFound(pindexNew);\n+        return false;\n+    }\n+    if (!txdb.TxnCommit())\n+        return error(\"SetBestChain() : TxnCommit failed\");\n+\n+    // Add to current best branch\n+    pindexNew->pprev->pnext = pindexNew;\n+\n+    // Delete redundant memory transactions\n+    BOOST_FOREACH(CTransaction& tx, vtx)\n+        tx.RemoveFromMemoryPool();\n+\n+    return true;\n+}\n+\n bool CBlock::SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew)\n {\n     uint256 hash = GetHash();\n@@ -1471,32 +1497,50 @@ bool CBlock::SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew)\n     }\n     else if (hashPrevBlock == hashBestChain)\n     {\n-        // Adding to current best branch\n-        if (!ConnectBlock(txdb, pindexNew) || !txdb.WriteHashBestChain(hash))\n+        if (!SetBestChainInner(txdb, pindexNew))\n+            return error(\"SetBestChain() : SetBestChainInner failed\");\n+    }\n+    else\n+    {\n+        // the first block in the new chain that will cause it to become the new best chain\n+        CBlockIndex *pindexIntermediate = pindexNew;\n+\n+        // list of blocks that need to be connected afterwards\n+        std::vector<CBlockIndex*> vpindexSecondary;\n+\n+        // Reorganize is costly in terms of db load, as it works in a single db transaction.\n+        // Try to limit how much needs to be done inside\n+        while (pindexIntermediate->pprev && pindexIntermediate->pprev->bnChainWork > pindexBest->bnChainWork)\n         {\n-            txdb.TxnAbort();\n-            InvalidChainFound(pindexNew);\n-            return error(\"SetBestChain() : ConnectBlock failed\");\n+            vpindexSecondary.push_back(pindexIntermediate);\n+            pindexIntermediate = pindexIntermediate->pprev;\n         }\n-        if (!txdb.TxnCommit())\n-            return error(\"SetBestChain() : TxnCommit failed\");\n \n-        // Add to current best branch\n-        pindexNew->pprev->pnext = pindexNew;\n+        if (!vpindexSecondary.empty())\n+            printf(\"Postponing %i reconnects\\n\", vpindexSecondary.size());\n \n-        // Delete redundant memory transactions\n-        BOOST_FOREACH(CTransaction& tx, vtx)\n-            tx.RemoveFromMemoryPool();\n-    }\n-    else\n-    {\n-        // New best branch\n-        if (!Reorganize(txdb, pindexNew))\n+        // Switch to new best branch\n+        if (!Reorganize(txdb, pindexIntermediate))\n         {\n             txdb.TxnAbort();\n             InvalidChainFound(pindexNew);\n             return error(\"SetBestChain() : Reorganize failed\");\n         }\n+\n+        // Connect futher blocks\n+        BOOST_REVERSE_FOREACH(CBlockIndex *pindex, vpindexSecondary)\n+        {\n+            CBlock block;\n+            if (!block.ReadFromDisk(pindex))\n+            {\n+                printf(\"SetBestChain() : ReadFromDisk failed\\n\");\n+                break;\n+            }\n+            txdb.TxnBegin();\n+            // errors now are not fatal, we still did a reorganisation to a new chain in a valid way\n+            if (!block.SetBestChainInner(txdb, pindex))\n+                break;\n+        }\n     }\n \n     // Update best block in wallet (so we can detect restored wallets)"
      },
      {
        "sha": "b731d896e8ae568977619a4fc7fc570d9c70166e",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d68dcf741e088d8d7033521aa1a1e5e87d9dd283/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d68dcf741e088d8d7033521aa1a1e5e87d9dd283/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=d68dcf741e088d8d7033521aa1a1e5e87d9dd283",
        "patch": "@@ -1030,6 +1030,9 @@ class CBlock\n     bool AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos);\n     bool CheckBlock() const;\n     bool AcceptBlock();\n+\n+private:\n+    bool SetBestChainInner(CTxDB& txdb, CBlockIndex *pindexNew);\n };\n \n "
      }
    ]
  }
]