[
  {
    "sha": "c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNmNiMjFkMTdhYjgwOTdiNmE0MjVkMzdlNDhjOTU1ZmJiMGU5ZjBj",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2014-04-10T18:14:18Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2014-06-06T14:34:18Z"
      },
      "message": "Type-safe CFeeRate class\n\nUse CFeeRate instead of an int64_t for quantities that are\nfee-per-size.\n\nHelps prevent unit-conversion mismatches between the wallet,\nrelaying, and mining code.",
      "tree": {
        "sha": "297b740beca0274be8a85d8c355acecafecbbc3e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/297b740beca0274be8a85d8c355acecafecbbc3e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "345cb52e8ba878ca3e2590d5792b733ec11a1f0d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/345cb52e8ba878ca3e2590d5792b733ec11a1f0d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/345cb52e8ba878ca3e2590d5792b733ec11a1f0d"
      }
    ],
    "stats": {
      "total": 238,
      "additions": 123,
      "deletions": 115
    },
    "files": [
      {
        "sha": "6039986e6c64b42440fd79268955bd2381a73bba",
        "filename": "src/core.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/core.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/core.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core.cpp?ref=c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c",
        "patch": "@@ -72,6 +72,25 @@ void CTxOut::print() const\n     LogPrintf(\"%s\\n\", ToString());\n }\n \n+CFeeRate::CFeeRate(int64_t nFeePaid, size_t nSize)\n+{\n+    if (nSize > 0)\n+        nSatoshisPerK = nFeePaid*1000/nSize;\n+    else\n+        nSatoshisPerK = 0;\n+}\n+\n+int64_t CFeeRate::GetFee(size_t nSize)\n+{\n+    return nSatoshisPerK*nSize / 1000;\n+}\n+\n+std::string CFeeRate::ToString() const\n+{\n+    std::string result = FormatMoney(nSatoshisPerK) + \" BTC/kB\";\n+    return result;\n+}\n+\n uint256 CTransaction::GetHash() const\n {\n     return SerializeHash(*this);"
      },
      {
        "sha": "9fccffc4b29e8f231d9059751cd3d566a58b8185",
        "filename": "src/core.h",
        "status": "modified",
        "additions": 30,
        "deletions": 7,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/core.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/core.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core.h?ref=c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c",
        "patch": "@@ -112,6 +112,28 @@ class CTxIn\n \n \n \n+/** Type-safe wrapper class to for fee rates\n+ * (how much to pay based on transaction size)\n+ */\n+class CFeeRate\n+{\n+private:\n+    int64_t nSatoshisPerK; // unit is satoshis-per-1,000-bytes\n+public:\n+    explicit CFeeRate(int64_t _nSatoshisPerK): nSatoshisPerK(_nSatoshisPerK) { }\n+    CFeeRate(int64_t nFeePaid, size_t nSize);\n+    CFeeRate(const CFeeRate& other) { nSatoshisPerK = other.nSatoshisPerK; }\n+\n+    int64_t GetFee(size_t size); // unit returned is satoshis\n+    int64_t GetFeePerK() { return GetFee(1000); } // satoshis-per-1000-bytes\n+\n+    friend bool operator<(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK < b.nSatoshisPerK; }\n+    friend bool operator>(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK > b.nSatoshisPerK; }\n+    friend bool operator==(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK == b.nSatoshisPerK; }\n+\n+    std::string ToString() const;\n+};\n+\n \n /** An output of a transaction.  It contains the public key that the next input\n  * must be able to sign with to claim it.\n@@ -148,17 +170,18 @@ class CTxOut\n \n     uint256 GetHash() const;\n \n-    bool IsDust(int64_t nMinRelayTxFee) const\n+    bool IsDust(CFeeRate minRelayTxFee) const\n     {\n-        // \"Dust\" is defined in terms of CTransaction::nMinRelayTxFee,\n+        // \"Dust\" is defined in terms of CTransaction::minRelayTxFee,\n         // which has units satoshis-per-kilobyte.\n         // If you'd pay more than 1/3 in fees\n         // to spend something, then we consider it dust.\n         // A typical txout is 34 bytes big, and will\n-        // need a CTxIn of at least 148 bytes to spend,\n+        // need a CTxIn of at least 148 bytes to spend:\n         // so dust is a txout less than 546 satoshis \n-        // with default nMinRelayTxFee.\n-        return ((nValue*1000)/(3*((int)GetSerializeSize(SER_DISK,0)+148)) < nMinRelayTxFee);\n+        // with default minRelayTxFee.\n+        size_t nSize = GetSerializeSize(SER_DISK,0)+148u;\n+        return (nValue < 3*minRelayTxFee.GetFee(nSize));\n     }\n \n     friend bool operator==(const CTxOut& a, const CTxOut& b)\n@@ -183,8 +206,8 @@ class CTxOut\n class CTransaction\n {\n public:\n-    static int64_t nMinTxFee;\n-    static int64_t nMinRelayTxFee;\n+    static CFeeRate minTxFee;\n+    static CFeeRate minRelayTxFee;\n     static const int CURRENT_VERSION=1;\n     int nVersion;\n     std::vector<CTxIn> vin;"
      },
      {
        "sha": "1aad679b3b473976b84c7ef4ab9b2600033d3a3e",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 6,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c",
        "patch": "@@ -281,8 +281,8 @@ std::string HelpMessage(HelpMessageMode hmm)\n         strUsage += \"  -limitfreerelay=<n>    \" + _(\"Continuously rate-limit free transactions to <n>*1000 bytes per minute (default:15)\") + \"\\n\";\n         strUsage += \"  -maxsigcachesize=<n>   \" + _(\"Limit size of signature cache to <n> entries (default: 50000)\") + \"\\n\";\n     }\n-    strUsage += \"  -mintxfee=<amt>        \" + _(\"Fees smaller than this are considered zero fee (for transaction creation) (default:\") + \" \" + FormatMoney(CTransaction::nMinTxFee) + \")\" + \"\\n\";\n-    strUsage += \"  -minrelaytxfee=<amt>   \" + _(\"Fees smaller than this are considered zero fee (for relaying) (default:\") + \" \" + FormatMoney(CTransaction::nMinRelayTxFee) + \")\" + \"\\n\";\n+    strUsage += \"  -mintxfee=<amt>        \" + _(\"Fees smaller than this are considered zero fee (for transaction creation) (default:\") + \" \" + FormatMoney(CTransaction::minTxFee.GetFeePerK()) + \")\" + \"\\n\";\n+    strUsage += \"  -minrelaytxfee=<amt>   \" + _(\"Fees smaller than this are considered zero fee (for relaying) (default:\") + \" \" + FormatMoney(CTransaction::minRelayTxFee.GetFeePerK()) + \")\" + \"\\n\";\n     strUsage += \"  -printtoconsole        \" + _(\"Send trace/debug info to console instead of debug.log file\") + \"\\n\";\n     if (GetBoolArg(\"-help-debug\", false))\n     {\n@@ -560,26 +560,28 @@ bool AppInit2(boost::thread_group& threadGroup)\n     {\n         int64_t n = 0;\n         if (ParseMoney(mapArgs[\"-mintxfee\"], n) && n > 0)\n-            CTransaction::nMinTxFee = n;\n+            CTransaction::minTxFee = CFeeRate(n);\n         else\n             return InitError(strprintf(_(\"Invalid amount for -mintxfee=<amount>: '%s'\"), mapArgs[\"-mintxfee\"]));\n     }\n     if (mapArgs.count(\"-minrelaytxfee\"))\n     {\n         int64_t n = 0;\n         if (ParseMoney(mapArgs[\"-minrelaytxfee\"], n) && n > 0)\n-            CTransaction::nMinRelayTxFee = n;\n+            CTransaction::minRelayTxFee = CFeeRate(n);\n         else\n             return InitError(strprintf(_(\"Invalid amount for -minrelaytxfee=<amount>: '%s'\"), mapArgs[\"-minrelaytxfee\"]));\n     }\n \n #ifdef ENABLE_WALLET\n     if (mapArgs.count(\"-paytxfee\"))\n     {\n-        if (!ParseMoney(mapArgs[\"-paytxfee\"], nTransactionFee))\n+        int64_t nFeePerK = 0;\n+        if (!ParseMoney(mapArgs[\"-paytxfee\"], nFeePerK))\n             return InitError(strprintf(_(\"Invalid amount for -paytxfee=<amount>: '%s'\"), mapArgs[\"-paytxfee\"]));\n-        if (nTransactionFee > nHighTransactionFeeWarning)\n+        if (nFeePerK > nHighTransactionFeeWarning)\n             InitWarning(_(\"Warning: -paytxfee is set very high! This is the transaction fee you will pay if you send a transaction.\"));\n+        payTxFee = CFeeRate(nFeePerK, 1000);\n     }\n     bSpendZeroConfChange = GetArg(\"-spendzeroconfchange\", true);\n "
      },
      {
        "sha": "9d6c01d64e9978212c8eeae06e57f0ab6624b46f",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 20,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c",
        "patch": "@@ -50,9 +50,9 @@ bool fTxIndex = false;\n unsigned int nCoinCacheSize = 5000;\n \n /** Fees smaller than this (in satoshi) are considered zero fee (for transaction creation) */\n-int64_t CTransaction::nMinTxFee = 10000;  // Override with -mintxfee\n+CFeeRate CTransaction::minTxFee = CFeeRate(10000);  // Override with -mintxfee\n /** Fees smaller than this (in satoshi) are considered zero fee (for relaying and mining) */\n-int64_t CTransaction::nMinRelayTxFee = 1000;\n+CFeeRate CTransaction::minRelayTxFee = CFeeRate(1000);\n \n struct COrphanBlock {\n     uint256 hashBlock;\n@@ -543,7 +543,7 @@ bool IsStandardTx(const CTransaction& tx, string& reason)\n         }\n         if (whichType == TX_NULL_DATA)\n             nDataOut++;\n-        else if (txout.IsDust(CTransaction::nMinRelayTxFee)) {\n+        else if (txout.IsDust(CTransaction::minRelayTxFee)) {\n             reason = \"dust\";\n             return false;\n         }\n@@ -783,10 +783,10 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state)\n \n int64_t GetMinFee(const CTransaction& tx, unsigned int nBytes, bool fAllowFree, enum GetMinFee_mode mode)\n {\n-    // Base fee is either nMinTxFee or nMinRelayTxFee\n-    int64_t nBaseFee = (mode == GMF_RELAY) ? tx.nMinRelayTxFee : tx.nMinTxFee;\n+    // Base fee is either minTxFee or minRelayTxFee\n+    CFeeRate baseFeeRate = (mode == GMF_RELAY) ? tx.minRelayTxFee : tx.minTxFee;\n \n-    int64_t nMinFee = (1 + (int64_t)nBytes / 1000) * nBaseFee;\n+    int64_t nMinFee = baseFeeRate.GetFee(nBytes);\n \n     if (fAllowFree)\n     {\n@@ -800,16 +800,6 @@ int64_t GetMinFee(const CTransaction& tx, unsigned int nBytes, bool fAllowFree,\n             nMinFee = 0;\n     }\n \n-    // This code can be removed after enough miners have upgraded to version 0.9.\n-    // Until then, be safe when sending and require a fee if any output\n-    // is less than CENT:\n-    if (nMinFee < nBaseFee && mode == GMF_SEND)\n-    {\n-        BOOST_FOREACH(const CTxOut& txout, tx.vout)\n-            if (txout.nValue < CENT)\n-                nMinFee = nBaseFee;\n-    }\n-\n     if (!MoneyRange(nMinFee))\n         nMinFee = MAX_MONEY;\n     return nMinFee;\n@@ -916,10 +906,10 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n                                       hash.ToString(), nFees, txMinFee),\n                              REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n \n-        // Continuously rate-limit free transactions\n+        // Continuously rate-limit free (really, very-low-fee)transactions\n         // This mitigates 'penny-flooding' -- sending thousands of free transactions just to\n         // be annoying or make others' transactions take longer to confirm.\n-        if (fLimitFree && nFees < CTransaction::nMinRelayTxFee)\n+        if (fLimitFree && nFees < CTransaction::minRelayTxFee.GetFee(nSize))\n         {\n             static CCriticalSection csFreeLimiter;\n             static double dFreeCount;\n@@ -940,10 +930,10 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n             dFreeCount += nSize;\n         }\n \n-        if (fRejectInsaneFee && nFees > CTransaction::nMinRelayTxFee * 10000)\n+        if (fRejectInsaneFee && nFees > CTransaction::minRelayTxFee.GetFee(nSize) * 10000)\n             return error(\"AcceptToMemoryPool: : insane fees %s, %d > %d\",\n                          hash.ToString(),\n-                         nFees, CTransaction::nMinRelayTxFee * 10000);\n+                         nFees, CTransaction::minRelayTxFee.GetFee(nSize) * 10000);\n \n         // Check against previous transactions\n         // This is done last to help prevent CPU exhaustion denial-of-service attacks."
      },
      {
        "sha": "4e131c088b8bfa129b6c7f0abbf26921c5bd0e3d",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 20,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c",
        "patch": "@@ -52,25 +52,30 @@ void SHA256Transform(void* pstate, void* pinput, const void* pinit)\n         ((uint32_t*)pstate)[i] = ctx.h[i];\n }\n \n-// Some explaining would be appreciated\n+//\n+// Unconfirmed transactions in the memory pool often depend on other\n+// transactions in the memory pool. When we select transactions from the\n+// pool, we select by highest priority or fee rate, so we might consider\n+// transactions that depend on transactions that aren't yet in the block.\n+// The COrphan class keeps track of these 'temporary orphans' while\n+// CreateBlock is figuring out which transactions to include.\n+//\n class COrphan\n {\n public:\n     const CTransaction* ptx;\n     set<uint256> setDependsOn;\n     double dPriority;\n-    double dFeePerKb;\n+    CFeeRate feeRate;\n \n-    COrphan(const CTransaction* ptxIn)\n+    COrphan(const CTransaction* ptxIn) : ptx(ptxIn), feeRate(0), dPriority(0)\n     {\n-        ptx = ptxIn;\n-        dPriority = dFeePerKb = 0;\n     }\n \n     void print() const\n     {\n-        LogPrintf(\"COrphan(hash=%s, dPriority=%.1f, dFeePerKb=%.1f)\\n\",\n-               ptx->GetHash().ToString(), dPriority, dFeePerKb);\n+        LogPrintf(\"COrphan(hash=%s, dPriority=%.1f, fee=%s)\\n\",\n+                  ptx->GetHash().ToString(), dPriority, feeRate.ToString());\n         BOOST_FOREACH(uint256 hash, setDependsOn)\n             LogPrintf(\"   setDependsOn %s\\n\", hash.ToString());\n     }\n@@ -80,8 +85,8 @@ class COrphan\n uint64_t nLastBlockTx = 0;\n uint64_t nLastBlockSize = 0;\n \n-// We want to sort transactions by priority and fee, so:\n-typedef boost::tuple<double, double, const CTransaction*> TxPriority;\n+// We want to sort transactions by priority and fee rate, so:\n+typedef boost::tuple<double, CFeeRate, const CTransaction*> TxPriority;\n class TxPriorityCompare\n {\n     bool byFee;\n@@ -210,18 +215,15 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n             unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n             dPriority = tx.ComputePriority(dPriority, nTxSize);\n \n-            // This is a more accurate fee-per-kilobyte than is used by the client code, because the\n-            // client code rounds up the size to the nearest 1K. That's good, because it gives an\n-            // incentive to create smaller transactions.\n-            double dFeePerKb =  double(nTotalIn-tx.GetValueOut()) / (double(nTxSize)/1000.0);\n+            CFeeRate feeRate(nTotalIn-tx.GetValueOut(), nTxSize);\n \n             if (porphan)\n             {\n                 porphan->dPriority = dPriority;\n-                porphan->dFeePerKb = dFeePerKb;\n+                porphan->feeRate = feeRate;\n             }\n             else\n-                vecPriority.push_back(TxPriority(dPriority, dFeePerKb, &mi->second.GetTx()));\n+                vecPriority.push_back(TxPriority(dPriority, feeRate, &mi->second.GetTx()));\n         }\n \n         // Collect transactions into block\n@@ -237,7 +239,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n         {\n             // Take highest priority transaction off the priority queue:\n             double dPriority = vecPriority.front().get<0>();\n-            double dFeePerKb = vecPriority.front().get<1>();\n+            CFeeRate feeRate = vecPriority.front().get<1>();\n             const CTransaction& tx = *(vecPriority.front().get<2>());\n \n             std::pop_heap(vecPriority.begin(), vecPriority.end(), comparer);\n@@ -254,7 +256,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n                 continue;\n \n             // Skip free transactions if we're past the minimum block size:\n-            if (fSortedByFee && (dFeePerKb < CTransaction::nMinRelayTxFee) && (nBlockSize + nTxSize >= nBlockMinSize))\n+            if (fSortedByFee && (feeRate < CTransaction::minRelayTxFee) && (nBlockSize + nTxSize >= nBlockMinSize))\n                 continue;\n \n             // Prioritize by fee once past the priority size or we run out of high-priority\n@@ -298,8 +300,8 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n \n             if (fPrintPriority)\n             {\n-                LogPrintf(\"priority %.1f feeperkb %.1f txid %s\\n\",\n-                       dPriority, dFeePerKb, tx.GetHash().ToString());\n+                LogPrintf(\"priority %.1f fee %s txid %s\\n\",\n+                          dPriority, feeRate.ToString(), tx.GetHash().ToString());\n             }\n \n             // Add transactions that depend on this one to the priority queue\n@@ -312,7 +314,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n                         porphan->setDependsOn.erase(hash);\n                         if (porphan->setDependsOn.empty())\n                         {\n-                            vecPriority.push_back(TxPriority(porphan->dPriority, porphan->dFeePerKb, porphan->ptx));\n+                            vecPriority.push_back(TxPriority(porphan->dPriority, porphan->feeRate, porphan->ptx));\n                             std::push_heap(vecPriority.begin(), vecPriority.end(), comparer);\n                         }\n                     }"
      },
      {
        "sha": "e27f1bff97bc2fe59546db245dc6aa532ece3726",
        "filename": "src/qt/coincontroldialog.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 22,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/qt/coincontroldialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/qt/coincontroldialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroldialog.cpp?ref=c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c",
        "patch": "@@ -453,7 +453,7 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n \n             CTxOut txout(amount, (CScript)vector<unsigned char>(24, 0));\n             txDummy.vout.push_back(txout);\n-            if (txout.IsDust(CTransaction::nMinRelayTxFee))\n+            if (txout.IsDust(CTransaction::minRelayTxFee))\n                fDust = true;\n         }\n     }\n@@ -525,7 +525,7 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n         sPriorityLabel = CoinControlDialog::getPriorityLabel(dPriority);\n \n         // Fee\n-        int64_t nFee = nTransactionFee * (1 + (int64_t)nBytes / 1000);\n+        int64_t nFee = payTxFee.GetFee(nBytes);\n \n         // Min Fee\n         int64_t nMinFee = GetMinFee(txDummy, nBytes, AllowFree(dPriority), GMF_SEND);\n@@ -536,26 +536,11 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n         {\n             nChange = nAmount - nPayFee - nPayAmount;\n \n-            // if sub-cent change is required, the fee must be raised to at least CTransaction::nMinTxFee\n-            if (nPayFee < CTransaction::nMinTxFee && nChange > 0 && nChange < CENT)\n-            {\n-                if (nChange < CTransaction::nMinTxFee) // change < 0.0001 => simply move all change to fees\n-                {\n-                    nPayFee += nChange;\n-                    nChange = 0;\n-                }\n-                else\n-                {\n-                    nChange = nChange + nPayFee - CTransaction::nMinTxFee;\n-                    nPayFee = CTransaction::nMinTxFee;\n-                }\n-            }\n-\n             // Never create dust outputs; if we would, just add the dust to the fee.\n             if (nChange > 0 && nChange < CENT)\n             {\n                 CTxOut txout(nChange, (CScript)vector<unsigned char>(24, 0));\n-                if (txout.IsDust(CTransaction::nMinRelayTxFee))\n+                if (txout.IsDust(CTransaction::minRelayTxFee))\n                 {\n                     nPayFee += nChange;\n                     nChange = 0;\n@@ -610,19 +595,19 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n \n     // tool tips\n     QString toolTip1 = tr(\"This label turns red, if the transaction size is greater than 1000 bytes.\") + \"<br /><br />\";\n-    toolTip1 += tr(\"This means a fee of at least %1 per kB is required.\").arg(BitcoinUnits::formatWithUnit(nDisplayUnit, CTransaction::nMinTxFee)) + \"<br /><br />\";\n+    toolTip1 += tr(\"This means a fee of at least %1 per kB is required.\").arg(BitcoinUnits::formatWithUnit(nDisplayUnit, CTransaction::minTxFee.GetFeePerK())) + \"<br /><br />\";\n     toolTip1 += tr(\"Can vary +/- 1 byte per input.\");\n \n     QString toolTip2 = tr(\"Transactions with higher priority are more likely to get included into a block.\") + \"<br /><br />\";\n     toolTip2 += tr(\"This label turns red, if the priority is smaller than \\\"medium\\\".\") + \"<br /><br />\";\n-    toolTip2 += tr(\"This means a fee of at least %1 per kB is required.\").arg(BitcoinUnits::formatWithUnit(nDisplayUnit, CTransaction::nMinTxFee));\n+    toolTip2 += tr(\"This means a fee of at least %1 per kB is required.\").arg(BitcoinUnits::formatWithUnit(nDisplayUnit, CTransaction::minTxFee.GetFeePerK()));\n \n     QString toolTip3 = tr(\"This label turns red, if any recipient receives an amount smaller than %1.\").arg(BitcoinUnits::formatWithUnit(nDisplayUnit, CENT)) + \"<br /><br />\";\n-    toolTip3 += tr(\"This means a fee of at least %1 is required.\").arg(BitcoinUnits::formatWithUnit(nDisplayUnit, CTransaction::nMinTxFee)) + \"<br /><br />\";\n+    toolTip3 += tr(\"This means a fee of at least %1 is required.\").arg(BitcoinUnits::formatWithUnit(nDisplayUnit, CTransaction::minTxFee.GetFeePerK())) + \"<br /><br />\";\n     toolTip3 += tr(\"Amounts below 0.546 times the minimum relay fee are shown as dust.\");\n \n     QString toolTip4 = tr(\"This label turns red, if the change is smaller than %1.\").arg(BitcoinUnits::formatWithUnit(nDisplayUnit, CENT)) + \"<br /><br />\";\n-    toolTip4 += tr(\"This means a fee of at least %1 is required.\").arg(BitcoinUnits::formatWithUnit(nDisplayUnit, CTransaction::nMinTxFee));\n+    toolTip4 += tr(\"This means a fee of at least %1 is required.\").arg(BitcoinUnits::formatWithUnit(nDisplayUnit, CTransaction::minTxFee.GetFeePerK()));\n \n     l5->setToolTip(toolTip1);\n     l6->setToolTip(toolTip2);"
      },
      {
        "sha": "4fe98251d98ef448e0ac5a5e90b51acd64de7ff7",
        "filename": "src/qt/guiutil.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/qt/guiutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/qt/guiutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.cpp?ref=c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c",
        "patch": "@@ -210,7 +210,7 @@ bool isDust(const QString& address, qint64 amount)\n     CTxDestination dest = CBitcoinAddress(address.toStdString()).Get();\n     CScript script; script.SetDestination(dest);\n     CTxOut txOut(amount, script);\n-    return txOut.IsDust(CTransaction::nMinRelayTxFee);\n+    return txOut.IsDust(CTransaction::minRelayTxFee);\n }\n \n QString HtmlEscape(const QString& str, bool fMultiLine)"
      },
      {
        "sha": "1cbf5f88106dc2ad12869886698f17a263a999ff",
        "filename": "src/qt/optionsdialog.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/qt/optionsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/qt/optionsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsdialog.cpp?ref=c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c",
        "patch": "@@ -14,7 +14,7 @@\n #include \"monitoreddatamapper.h\"\n #include \"optionsmodel.h\"\n \n-#include \"main.h\" // for CTransaction::nMinTxFee and MAX_SCRIPTCHECK_THREADS\n+#include \"main.h\" // for CTransaction::minTxFee and MAX_SCRIPTCHECK_THREADS\n #include \"netbase.h\"\n #include \"txdb.h\" // for -dbcache defaults\n \n@@ -101,7 +101,7 @@ OptionsDialog::OptionsDialog(QWidget *parent) :\n #endif\n \n     ui->unit->setModel(new BitcoinUnits(this));\n-    ui->transactionFee->setSingleStep(CTransaction::nMinTxFee);\n+    ui->transactionFee->setSingleStep(CTransaction::minTxFee.GetFeePerK());\n \n     /* Widget-to-option mapper */\n     mapper = new MonitoredDataMapper(this);"
      },
      {
        "sha": "f3a5f37bb3897b1c7fc259f70ca5fa55be6f5be7",
        "filename": "src/qt/optionsmodel.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 9,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/qt/optionsmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/qt/optionsmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsmodel.cpp?ref=c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c",
        "patch": "@@ -94,7 +94,7 @@ void OptionsModel::Init()\n #ifdef ENABLE_WALLET\n     if (!settings.contains(\"nTransactionFee\"))\n         settings.setValue(\"nTransactionFee\", (qint64)DEFAULT_TRANSACTION_FEE);\n-    nTransactionFee = settings.value(\"nTransactionFee\").toLongLong(); // if -paytxfee is set, this will be overridden later in init.cpp\n+    payTxFee = CFeeRate(settings.value(\"nTransactionFee\").toLongLong()); // if -paytxfee is set, this will be overridden later in init.cpp\n     if (mapArgs.count(\"-paytxfee\"))\n         addOverriddenOption(\"-paytxfee\");\n \n@@ -187,15 +187,16 @@ QVariant OptionsModel::data(const QModelIndex & index, int role) const\n             return settings.value(\"nSocksVersion\", 5);\n \n #ifdef ENABLE_WALLET\n-        case Fee:\n-            // Attention: Init() is called before nTransactionFee is set in AppInit2()!\n+        case Fee: {\n+            // Attention: Init() is called before payTxFee is set in AppInit2()!\n             // To ensure we can change the fee on-the-fly update our QSetting when\n             // opening OptionsDialog, which queries Fee via the mapper.\n-            if (nTransactionFee != settings.value(\"nTransactionFee\").toLongLong())\n-                settings.setValue(\"nTransactionFee\", (qint64)nTransactionFee);\n-            // Todo: Consider to revert back to use just nTransactionFee here, if we don't want\n+            if (!(payTxFee == CFeeRate(settings.value(\"nTransactionFee\").toLongLong(), 1000)))\n+                settings.setValue(\"nTransactionFee\", (qint64)payTxFee.GetFeePerK());\n+            // Todo: Consider to revert back to use just payTxFee here, if we don't want\n             // -paytxfee to update our QSettings!\n             return settings.value(\"nTransactionFee\");\n+        }\n         case SpendZeroConfChange:\n             return settings.value(\"bSpendZeroConfChange\");\n #endif\n@@ -284,12 +285,14 @@ bool OptionsModel::setData(const QModelIndex & index, const QVariant & value, in\n         }\n         break;\n #ifdef ENABLE_WALLET\n-        case Fee: // core option - can be changed on-the-fly\n+        case Fee: { // core option - can be changed on-the-fly\n             // Todo: Add is valid check  and warn via message, if not\n-            nTransactionFee = value.toLongLong();\n-            settings.setValue(\"nTransactionFee\", (qint64)nTransactionFee);\n+            qint64 nTransactionFee = value.toLongLong();\n+            payTxFee = CFeeRate(nTransactionFee, 1000);\n+            settings.setValue(\"nTransactionFee\", nTransactionFee);\n             emit transactionFeeChanged(nTransactionFee);\n             break;\n+        }\n         case SpendZeroConfChange:\n             if (settings.value(\"bSpendZeroConfChange\") != value) {\n                 settings.setValue(\"bSpendZeroConfChange\", value);"
      },
      {
        "sha": "6165731d223ee703e2e76581819fa3fd7c57e18a",
        "filename": "src/qt/paymentserver.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/qt/paymentserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/qt/paymentserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentserver.cpp?ref=c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c",
        "patch": "@@ -551,7 +551,7 @@ bool PaymentServer::processPaymentRequest(PaymentRequestPlus& request, SendCoins\n \n         // Extract and check amounts\n         CTxOut txOut(sendingTo.second, sendingTo.first);\n-        if (txOut.IsDust(CTransaction::nMinRelayTxFee)) {\n+        if (txOut.IsDust(CTransaction::minRelayTxFee)) {\n             emit message(tr(\"Payment request error\"), tr(\"Requested payment amount of %1 is too small (considered dust).\")\n                 .arg(BitcoinUnits::formatWithUnit(optionsModel->getDisplayUnit(), sendingTo.second)),\n                 CClientUIInterface::MSG_ERROR);"
      },
      {
        "sha": "87ff3db5843792d5c6c9b78cdc140fab984030ec",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c",
        "patch": "@@ -231,12 +231,6 @@ WalletModel::SendCoinsReturn WalletModel::prepareTransaction(WalletModelTransact\n         return AmountExceedsBalance;\n     }\n \n-    if((total + nTransactionFee) > nBalance)\n-    {\n-        transaction.setTransactionFee(nTransactionFee);\n-        return SendCoinsReturn(AmountWithFeeExceedsBalance);\n-    }\n-\n     {\n         LOCK2(cs_main, wallet->cs_wallet);\n "
      },
      {
        "sha": "9802445fcb20d3bdcdaa2b60111512919d279be2",
        "filename": "src/rpcmisc.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/rpcmisc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/rpcmisc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcmisc.cpp?ref=c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c",
        "patch": "@@ -81,9 +81,9 @@ Value getinfo(const Array& params, bool fHelp)\n     }\n     if (pwalletMain && pwalletMain->IsCrypted())\n         obj.push_back(Pair(\"unlocked_until\", nWalletUnlockTime));\n-    obj.push_back(Pair(\"paytxfee\",      ValueFromAmount(nTransactionFee)));\n+    obj.push_back(Pair(\"paytxfee\",      ValueFromAmount(payTxFee.GetFeePerK())));\n #endif\n-    obj.push_back(Pair(\"relayfee\",      ValueFromAmount(CTransaction::nMinRelayTxFee)));\n+    obj.push_back(Pair(\"relayfee\",      ValueFromAmount(CTransaction::minRelayTxFee.GetFeePerK())));\n     obj.push_back(Pair(\"errors\",        GetWarnings(\"statusbar\")));\n     return obj;\n }"
      },
      {
        "sha": "0eca55a472ccc6b97cfc5096f9051429d72db810",
        "filename": "src/rpcnet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/rpcnet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/rpcnet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcnet.cpp?ref=c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c",
        "patch": "@@ -368,7 +368,7 @@ Value getnetworkinfo(const Array& params, bool fHelp)\n     obj.push_back(Pair(\"timeoffset\",    GetTimeOffset()));\n     obj.push_back(Pair(\"connections\",   (int)vNodes.size()));\n     obj.push_back(Pair(\"proxy\",         (proxy.first.IsValid() ? proxy.first.ToStringIPPort() : string())));\n-    obj.push_back(Pair(\"relayfee\",      ValueFromAmount(CTransaction::nMinRelayTxFee)));\n+    obj.push_back(Pair(\"relayfee\",      ValueFromAmount(CTransaction::minRelayTxFee.GetFeePerK())));\n     Array localAddresses;\n     {\n         LOCK(cs_mapLocalHost);"
      },
      {
        "sha": "f376ab6b636c7f980b9924a66bc4cbfd0bdffd90",
        "filename": "src/rpcwallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcwallet.cpp?ref=c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c",
        "patch": "@@ -1883,7 +1883,7 @@ Value settxfee(const Array& params, bool fHelp)\n     if (params[0].get_real() != 0.0)\n         nAmount = AmountFromValue(params[0]);        // rejects 0.0 amounts\n \n-    nTransactionFee = nAmount;\n+    payTxFee = CFeeRate(nAmount, 1000);\n     return true;\n }\n "
      },
      {
        "sha": "ef0b442e1a18b635180bd41340546a34c92dbae1",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 16,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c",
        "patch": "@@ -16,7 +16,7 @@\n using namespace std;\n \n // Settings\n-int64_t nTransactionFee = DEFAULT_TRANSACTION_FEE;\n+CFeeRate payTxFee(DEFAULT_TRANSACTION_FEE);\n bool bSpendZeroConfChange = true;\n \n //////////////////////////////////////////////////////////////////////////////\n@@ -1233,7 +1233,7 @@ bool CWallet::CreateTransaction(const vector<pair<CScript, int64_t> >& vecSend,\n     {\n         LOCK2(cs_main, cs_wallet);\n         {\n-            nFeeRet = nTransactionFee;\n+            nFeeRet = payTxFee.GetFeePerK();\n             while (true)\n             {\n                 wtxNew.vin.clear();\n@@ -1246,7 +1246,7 @@ bool CWallet::CreateTransaction(const vector<pair<CScript, int64_t> >& vecSend,\n                 BOOST_FOREACH (const PAIRTYPE(CScript, int64_t)& s, vecSend)\n                 {\n                     CTxOut txout(s.second, s.first);\n-                    if (txout.IsDust(CTransaction::nMinRelayTxFee))\n+                    if (txout.IsDust(CTransaction::minRelayTxFee))\n                     {\n                         strFailReason = _(\"Transaction amount too small\");\n                         return false;\n@@ -1272,16 +1272,6 @@ bool CWallet::CreateTransaction(const vector<pair<CScript, int64_t> >& vecSend,\n                 }\n \n                 int64_t nChange = nValueIn - nValue - nFeeRet;\n-                // The following if statement should be removed once enough miners\n-                // have upgraded to the 0.9 GetMinFee() rules. Until then, this avoids\n-                // creating free transactions that have change outputs less than\n-                // CENT bitcoins.\n-                if (nFeeRet < CTransaction::nMinTxFee && nChange > 0 && nChange < CENT)\n-                {\n-                    int64_t nMoveToFee = min(nChange, CTransaction::nMinTxFee - nFeeRet);\n-                    nChange -= nMoveToFee;\n-                    nFeeRet += nMoveToFee;\n-                }\n \n                 if (nChange > 0)\n                 {\n@@ -1317,7 +1307,7 @@ bool CWallet::CreateTransaction(const vector<pair<CScript, int64_t> >& vecSend,\n \n                     // Never create dust outputs; if we would, just\n                     // add the dust to the fee.\n-                    if (newTxOut.IsDust(CTransaction::nMinRelayTxFee))\n+                    if (newTxOut.IsDust(CTransaction::minRelayTxFee))\n                     {\n                         nFeeRet += nChange;\n                         reservekey.ReturnKey();\n@@ -1355,7 +1345,7 @@ bool CWallet::CreateTransaction(const vector<pair<CScript, int64_t> >& vecSend,\n                 dPriority = wtxNew.ComputePriority(dPriority, nBytes);\n \n                 // Check that enough fee is included\n-                int64_t nPayFee = nTransactionFee * (1 + (int64_t)nBytes / 1000);\n+                int64_t nPayFee = payTxFee.GetFee(nBytes);\n                 bool fAllowFree = AllowFree(dPriority);\n                 int64_t nMinFee = GetMinFee(wtxNew, nBytes, fAllowFree, GMF_SEND);\n                 if (nFeeRet < max(nPayFee, nMinFee))\n@@ -1464,7 +1454,7 @@ string CWallet::SendMoneyToDestination(const CTxDestination& address, int64_t nV\n     // Check amount\n     if (nValue <= 0)\n         return _(\"Invalid amount\");\n-    if (nValue + nTransactionFee > GetBalance())\n+    if (nValue > GetBalance())\n         return _(\"Insufficient funds\");\n \n     // Parse Bitcoin address"
      },
      {
        "sha": "274c31157c0a7891ea83ca4dd32b09e284ca8260",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c",
        "patch": "@@ -24,7 +24,7 @@\n #include <vector>\n \n // Settings\n-extern int64_t nTransactionFee;\n+extern CFeeRate payTxFee;\n extern bool bSpendZeroConfChange;\n \n // -paytxfee default"
      }
    ]
  },
  {
    "sha": "0193fb82a6fe443e5434f2c2af3b252409c19b25",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMTkzZmI4MmE2ZmU0NDNlNTQzNGYyYzJhZjNiMjUyNDA5YzE5YjI1",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2014-03-14T16:19:52Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2014-06-06T14:34:18Z"
      },
      "message": "Allow multiple regression tests to run at once\n\nChoose ports at startup based on PID, so multiple regression tests\ncan run on the same system at the same time.",
      "tree": {
        "sha": "64332beb4bc948b9dc4a021bd9358abebd7c9aba",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/64332beb4bc948b9dc4a021bd9358abebd7c9aba"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0193fb82a6fe443e5434f2c2af3b252409c19b25",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0193fb82a6fe443e5434f2c2af3b252409c19b25",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0193fb82a6fe443e5434f2c2af3b252409c19b25",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0193fb82a6fe443e5434f2c2af3b252409c19b25/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c6cb21d17ab8097b6a425d37e48c955fbb0e9f0c"
      }
    ],
    "stats": {
      "total": 37,
      "additions": 22,
      "deletions": 15
    },
    "files": [
      {
        "sha": "eab526daf3655b22ffff7b437afa61dc47f5336a",
        "filename": "qa/rpc-tests/util.py",
        "status": "modified",
        "additions": 22,
        "deletions": 15,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0193fb82a6fe443e5434f2c2af3b252409c19b25/qa/rpc-tests/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0193fb82a6fe443e5434f2c2af3b252409c19b25/qa/rpc-tests/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/util.py?ref=0193fb82a6fe443e5434f2c2af3b252409c19b25",
        "patch": "@@ -20,8 +20,10 @@\n from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException\n from util import *\n \n-START_P2P_PORT=11000\n-START_RPC_PORT=11100\n+def p2p_port(n):\n+    return 11000 + n + os.getpid()%999\n+def rpc_port(n):\n+    return 12000 + n + os.getpid()%999\n \n def check_json_precision():\n     \"\"\"Make sure json library being used does not lose precision converting BTC values\"\"\"\n@@ -58,6 +60,17 @@ def sync_mempools(rpc_connections):\n \n bitcoind_processes = []\n \n+def initialize_datadir(dir, n):\n+    datadir = os.path.join(dir, \"node\"+str(n))\n+    if not os.path.isdir(datadir):\n+        os.makedirs(datadir)\n+    with open(os.path.join(datadir, \"bitcoin.conf\"), 'w') as f:\n+        f.write(\"regtest=1\\n\");\n+        f.write(\"rpcuser=rt\\n\");\n+        f.write(\"rpcpassword=rt\\n\");\n+        f.write(\"port=\"+str(p2p_port(n))+\"\\n\");\n+        f.write(\"rpcport=\"+str(rpc_port(n))+\"\\n\");\n+\n def initialize_chain(test_dir):\n     \"\"\"\n     Create (or copy from cache) a 200-block-long chain and\n@@ -69,25 +82,18 @@ def initialize_chain(test_dir):\n         devnull = open(\"/dev/null\", \"w+\")\n         # Create cache directories, run bitcoinds:\n         for i in range(4):\n-            datadir = os.path.join(\"cache\", \"node\"+str(i))\n-            os.makedirs(datadir)\n-            with open(os.path.join(datadir, \"bitcoin.conf\"), 'w') as f:\n-                f.write(\"regtest=1\\n\");\n-                f.write(\"rpcuser=rt\\n\");\n-                f.write(\"rpcpassword=rt\\n\");\n-                f.write(\"port=\"+str(START_P2P_PORT+i)+\"\\n\");\n-                f.write(\"rpcport=\"+str(START_RPC_PORT+i)+\"\\n\");\n+            initialize_datadir(\"cache\", i)\n             args = [ \"bitcoind\", \"-keypool=1\", \"-datadir=\"+datadir ]\n             if i > 0:\n-                args.append(\"-connect=127.0.0.1:\"+str(START_P2P_PORT))\n+                args.append(\"-connect=127.0.0.1:\"+str(p2p_port(0)))\n             bitcoind_processes.append(subprocess.Popen(args))\n             subprocess.check_call([ \"bitcoin-cli\", \"-datadir=\"+datadir,\n                                     \"-rpcwait\", \"getblockcount\"], stdout=devnull)\n         devnull.close()\n         rpcs = []\n         for i in range(4):\n             try:\n-                url = \"http://rt:rt@127.0.0.1:%d\"%(START_RPC_PORT+i,)\n+                url = \"http://rt:rt@127.0.0.1:%d\"%(rpc_port(i),)\n                 rpcs.append(AuthServiceProxy(url))\n             except:\n                 sys.stderr.write(\"Error connecting to \"+url+\"\\n\")\n@@ -112,6 +118,7 @@ def initialize_chain(test_dir):\n         from_dir = os.path.join(\"cache\", \"node\"+str(i))\n         to_dir = os.path.join(test_dir,  \"node\"+str(i))\n         shutil.copytree(from_dir, to_dir)\n+        initialize_datadir(test_dir, i) # Overwrite port/rpcport in bitcoin.conf\n \n def _rpchost_to_args(rpchost):\n     '''Convert optional IP:port spec to rpcconnect/rpcport args'''\n@@ -138,7 +145,7 @@ def start_nodes(num_nodes, dir, extra_args=None, rpchost=None):\n     devnull = open(\"/dev/null\", \"w+\")\n     for i in range(num_nodes):\n         datadir = os.path.join(dir, \"node\"+str(i))\n-        args = [ \"bitcoind\", \"-datadir=\"+datadir ]\n+        args = [ \"bitcoind\", \"-datadir=\"+datadir, \"-keypool=1\" ]\n         if extra_args is not None:\n             args += extra_args[i]\n         bitcoind_processes.append(subprocess.Popen(args))\n@@ -149,7 +156,7 @@ def start_nodes(num_nodes, dir, extra_args=None, rpchost=None):\n     # Create&return JSON-RPC connections\n     rpc_connections = []\n     for i in range(num_nodes):\n-        url = \"http://rt:rt@%s:%d\" % (rpchost or '127.0.0.1', START_RPC_PORT+i,)\n+        url = \"http://rt:rt@%s:%d\" % (rpchost or '127.0.0.1', rpc_port(i))\n         rpc_connections.append(AuthServiceProxy(url))\n     return rpc_connections\n \n@@ -168,7 +175,7 @@ def wait_bitcoinds():\n     del bitcoind_processes[:]\n \n def connect_nodes(from_connection, node_num):\n-    ip_port = \"127.0.0.1:\"+str(START_P2P_PORT+node_num)\n+    ip_port = \"127.0.0.1:\"+str(p2p_port(node_num))\n     from_connection.addnode(ip_port, \"onetry\")\n \n def assert_equal(thing1, thing2):"
      }
    ]
  },
  {
    "sha": "171ca7745e77c9f78f26556457fe64e5b2004a75",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxNzFjYTc3NDVlNzdjOWY3OGYyNjU1NjQ1N2ZlNjRlNWIyMDA0YTc1",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2014-03-17T12:19:54Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2014-06-06T14:44:57Z"
      },
      "message": "estimatefee / estimatepriority RPC methods\n\nNew RPC methods: return an estimate of the fee (or priority) a\ntransaction needs to be likely to confirm in a given number of\nblocks.\n\nMike Hearn created the first version of this method for estimating fees.\nIt works as follows:\n\nFor transactions that took 1 to N (I picked N=25) blocks to confirm,\nkeep N buckets with at most 100 entries in each recording the\nfees-per-kilobyte paid by those transactions.\n\n(separate buckets are kept for transactions that confirmed because\nthey are high-priority)\n\nThe buckets are filled as blocks are found, and are saved/restored\nin a new fee_estiamtes.dat file in the data directory.\n\nA few variations on Mike's initial scheme:\n\nTo estimate the fee needed for a transaction to confirm in X buckets,\nall of the samples in all of the buckets are used and a median of\nall of the data is used to make the estimate. For example, imagine\n25 buckets each containing the full 100 entries. Those 2,500 samples\nare sorted, and the estimate of the fee needed to confirm in the very\nnext block is the 50'th-highest-fee-entry in that sorted list; the\nestimate of the fee needed to confirm in the next two blocks is the\n150'th-highest-fee-entry, etc.\n\nThat algorithm has the nice property that estimates of how much fee\nyou need to pay to get confirmed in block N will always be greater\nthan or equal to the estimate for block N+1. It would clearly be wrong\nto say \"pay 11 uBTC and you'll get confirmed in 3 blocks, but pay\n12 uBTC and it will take LONGER\".\n\nA single block will not contribute more than 10 entries to any one\nbucket, so a single miner and a large block cannot overwhelm\nthe estimates.",
      "tree": {
        "sha": "0a25f1f328ca66177c79afcf4422ea99d221f981",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0a25f1f328ca66177c79afcf4422ea99d221f981"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/171ca7745e77c9f78f26556457fe64e5b2004a75",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/171ca7745e77c9f78f26556457fe64e5b2004a75",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/171ca7745e77c9f78f26556457fe64e5b2004a75",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/171ca7745e77c9f78f26556457fe64e5b2004a75/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0193fb82a6fe443e5434f2c2af3b252409c19b25",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0193fb82a6fe443e5434f2c2af3b252409c19b25",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0193fb82a6fe443e5434f2c2af3b252409c19b25"
      }
    ],
    "stats": {
      "total": 798,
      "additions": 767,
      "deletions": 31
    },
    "files": [
      {
        "sha": "9272d427cdc95f8b254ec5bd4597a0702ec62de9",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/171ca7745e77c9f78f26556457fe64e5b2004a75/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/171ca7745e77c9f78f26556457fe64e5b2004a75/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=171ca7745e77c9f78f26556457fe64e5b2004a75",
        "patch": "@@ -1,2 +1,21 @@\n (note: this is a temporary file, to be added-to by anybody, and moved to\n release-notes at release time)\n+\n+New RPC methods\n+===============\n+\n+Fee/Priority estimation\n+-----------------------\n+\n+estimatefee nblocks : Returns approximate fee-per-1,000-bytes needed for\n+a transaction to be confirmed within nblocks. Returns -1 if not enough\n+transactions have been observed to compute a good estimate.\n+\n+estimatepriority nblocks : Returns approximate priority needed for\n+a zero-fee transaction to confirm within nblocks. Returns -1 if not\n+enough free transactions have been observed to compute a good\n+estimate.\n+\n+Statistics used to estimate fees and priorities are saved in the\n+data directory in the 'fee_estimates.dat' file just before\n+program shutdown, and are read in at startup."
      },
      {
        "sha": "e8abbfba194efa9313a2117af7a9522b56df7366",
        "filename": "qa/rpc-tests/smartfees.py",
        "status": "added",
        "additions": 142,
        "deletions": 0,
        "changes": 142,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/171ca7745e77c9f78f26556457fe64e5b2004a75/qa/rpc-tests/smartfees.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/171ca7745e77c9f78f26556457fe64e5b2004a75/qa/rpc-tests/smartfees.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/smartfees.py?ref=171ca7745e77c9f78f26556457fe64e5b2004a75",
        "patch": "@@ -0,0 +1,142 @@\n+#!/usr/bin/env python\n+\n+#\n+# Test fee estimation code\n+#\n+\n+# Add python-bitcoinrpc to module search path:\n+import os\n+import sys\n+sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), \"python-bitcoinrpc\"))\n+\n+import json\n+import random\n+import shutil\n+import subprocess\n+import tempfile\n+import traceback\n+\n+from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException\n+from util import *\n+\n+\n+def run_test(nodes, test_dir):\n+    nodes.append(start_node(0, test_dir,\n+                            [\"-debug=mempool\", \"-debug=estimatefee\"]))\n+    # Node1 mines small-but-not-tiny blocks, and allows free transactions.\n+    # NOTE: the CreateNewBlock code starts counting block size at 1,000 bytes,\n+    # so blockmaxsize of 2,000 is really just 1,000 bytes (room enough for\n+    # 6 or 7 transactions)\n+    nodes.append(start_node(1, test_dir,\n+                            [\"-blockprioritysize=1500\", \"-blockmaxsize=2000\",\n+                             \"-debug=mempool\", \"-debug=estimatefee\"]))\n+    connect_nodes(nodes[1], 0)\n+\n+    # Node2 is a stingy miner, that\n+    # produces very small blocks (room for only 3 or so transactions)\n+    node2args = [ \"-blockprioritysize=0\", \"-blockmaxsize=1500\",\n+                             \"-debug=mempool\", \"-debug=estimatefee\"]\n+    nodes.append(start_node(2, test_dir, node2args))\n+    connect_nodes(nodes[2], 0)\n+\n+    sync_blocks(nodes)\n+\n+    # Prime the memory pool with pairs of transactions\n+    # (high-priority, random fee and zero-priority, random fee)\n+    min_fee = Decimal(\"0.001\")\n+    fees_per_kb = [];\n+    for i in range(12):\n+        (txid, txhex, fee) = random_zeropri_transaction(nodes, Decimal(\"1.1\"),\n+                                                        min_fee, min_fee, 20)\n+        tx_kbytes = (len(txhex)/2)/1000.0\n+        fees_per_kb.append(float(fee)/tx_kbytes)\n+\n+    # Mine blocks with node2 until the memory pool clears:\n+    count_start = nodes[2].getblockcount()\n+    while len(nodes[2].getrawmempool()) > 0:\n+        nodes[2].setgenerate(True, 1)\n+        sync_blocks(nodes)\n+\n+    all_estimates = [ nodes[0].estimatefee(i) for i in range(1,20) ]\n+    print(\"Fee estimates, super-stingy miner: \"+str([str(e) for e in all_estimates]))\n+\n+    # Estimates should be within the bounds of what transactions fees actually were:\n+    delta = 1.0e-6 # account for rounding error\n+    for e in filter(lambda x: x >= 0, all_estimates):\n+        if float(e)+delta < min(fees_per_kb) or float(e)-delta > max(fees_per_kb):\n+            raise AssertionError(\"Estimated fee (%f) out of range (%f,%f)\"%(float(e), min_fee_kb, max_fee_kb))\n+\n+    # Generate transactions while mining 30 more blocks, this time with node1:\n+    for i in range(30):\n+        for j in range(random.randrange(6-4,6+4)):\n+            (txid, txhex, fee) = random_transaction(nodes, Decimal(\"1.1\"),\n+                                                    Decimal(\"0.0\"), min_fee, 20)\n+            tx_kbytes = (len(txhex)/2)/1000.0\n+            fees_per_kb.append(float(fee)/tx_kbytes)\n+        nodes[1].setgenerate(True, 1)\n+        sync_blocks(nodes)\n+\n+    all_estimates = [ nodes[0].estimatefee(i) for i in range(1,20) ]\n+    print(\"Fee estimates, more generous miner: \"+str([ str(e) for e in all_estimates]))\n+    for e in filter(lambda x: x >= 0, all_estimates):\n+        if float(e)+delta < min(fees_per_kb) or float(e)-delta > max(fees_per_kb):\n+            raise AssertionError(\"Estimated fee (%f) out of range (%f,%f)\"%(float(e), min_fee_kb, max_fee_kb))\n+\n+    # Finish by mining a normal-sized block:\n+    while len(nodes[0].getrawmempool()) > 0:\n+        nodes[0].setgenerate(True, 1)\n+        sync_blocks(nodes)\n+\n+    final_estimates = [ nodes[0].estimatefee(i) for i in range(1,20) ]\n+    print(\"Final fee estimates: \"+str([ str(e) for e in final_estimates]))\n+\n+def main():\n+    import optparse\n+\n+    parser = optparse.OptionParser(usage=\"%prog [options]\")\n+    parser.add_option(\"--nocleanup\", dest=\"nocleanup\", default=False, action=\"store_true\",\n+                      help=\"Leave bitcoinds and test.* datadir on exit or error\")\n+    parser.add_option(\"--srcdir\", dest=\"srcdir\", default=\"../../src\",\n+                      help=\"Source directory containing bitcoind/bitcoin-cli (default: %default%)\")\n+    parser.add_option(\"--tmpdir\", dest=\"tmpdir\", default=tempfile.mkdtemp(prefix=\"test\"),\n+                      help=\"Root directory for datadirs\")\n+    (options, args) = parser.parse_args()\n+\n+    os.environ['PATH'] = options.srcdir+\":\"+os.environ['PATH']\n+\n+    check_json_precision()\n+\n+    success = False\n+    nodes = []\n+    try:\n+        print(\"Initializing test directory \"+options.tmpdir)\n+        print(\"  node0 running at: 127.0.0.1:%d\"%(p2p_port(0)))\n+        if not os.path.isdir(options.tmpdir):\n+            os.makedirs(options.tmpdir)\n+        initialize_chain(options.tmpdir)\n+\n+        run_test(nodes, options.tmpdir)\n+\n+        success = True\n+\n+    except AssertionError as e:\n+        print(\"Assertion failed: \"+e.message)\n+    except Exception as e:\n+        print(\"Unexpected exception caught during testing: \"+str(e))\n+        traceback.print_tb(sys.exc_info()[2])\n+\n+    if not options.nocleanup:\n+        print(\"Cleaning up\")\n+        stop_nodes(nodes)\n+        wait_bitcoinds()\n+        shutil.rmtree(options.tmpdir)\n+\n+    if success:\n+        print(\"Tests successful\")\n+        sys.exit(0)\n+    else:\n+        print(\"Failed\")\n+        sys.exit(1)\n+\n+if __name__ == '__main__':\n+    main()"
      },
      {
        "sha": "eded098c7c95f973bf16da0b368648afe9d35dbd",
        "filename": "qa/rpc-tests/util.py",
        "status": "modified",
        "additions": 125,
        "deletions": 18,
        "changes": 143,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/171ca7745e77c9f78f26556457fe64e5b2004a75/qa/rpc-tests/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/171ca7745e77c9f78f26556457fe64e5b2004a75/qa/rpc-tests/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/util.py?ref=171ca7745e77c9f78f26556457fe64e5b2004a75",
        "patch": "@@ -12,6 +12,7 @@\n \n from decimal import Decimal\n import json\n+import random\n import shutil\n import subprocess\n import time\n@@ -70,6 +71,7 @@ def initialize_datadir(dir, n):\n         f.write(\"rpcpassword=rt\\n\");\n         f.write(\"port=\"+str(p2p_port(n))+\"\\n\");\n         f.write(\"rpcport=\"+str(rpc_port(n))+\"\\n\");\n+    return datadir\n \n def initialize_chain(test_dir):\n     \"\"\"\n@@ -82,7 +84,7 @@ def initialize_chain(test_dir):\n         devnull = open(\"/dev/null\", \"w+\")\n         # Create cache directories, run bitcoinds:\n         for i in range(4):\n-            initialize_datadir(\"cache\", i)\n+            datadir=initialize_datadir(\"cache\", i)\n             args = [ \"bitcoind\", \"-keypool=1\", \"-datadir=\"+datadir ]\n             if i > 0:\n                 args.append(\"-connect=127.0.0.1:\"+str(p2p_port(0)))\n@@ -140,25 +142,28 @@ def _rpchost_to_args(rpchost):\n         rv += ['-rpcport=' + rpcport]\n     return rv\n \n-def start_nodes(num_nodes, dir, extra_args=None, rpchost=None):\n-    # Start bitcoinds, and wait for RPC interface to be up and running:\n+def start_node(i, dir, extra_args=None, rpchost=None):\n+    \"\"\"\n+    Start a bitcoind and return RPC connection to it\n+    \"\"\"\n+    datadir = os.path.join(dir, \"node\"+str(i))\n+    args = [ \"bitcoind\", \"-datadir=\"+datadir, \"-keypool=1\" ]\n+    if extra_args is not None: args.extend(extra_args)\n+    bitcoind_processes.append(subprocess.Popen(args))\n     devnull = open(\"/dev/null\", \"w+\")\n-    for i in range(num_nodes):\n-        datadir = os.path.join(dir, \"node\"+str(i))\n-        args = [ \"bitcoind\", \"-datadir=\"+datadir, \"-keypool=1\" ]\n-        if extra_args is not None:\n-            args += extra_args[i]\n-        bitcoind_processes.append(subprocess.Popen(args))\n-        subprocess.check_call([ \"bitcoin-cli\", \"-datadir=\"+datadir] +\n-                                  _rpchost_to_args(rpchost)  +\n-                                  [\"-rpcwait\", \"getblockcount\"], stdout=devnull)\n+    subprocess.check_call([ \"bitcoin-cli\", \"-datadir=\"+datadir] +\n+                          _rpchost_to_args(rpchost)  +\n+                          [\"-rpcwait\", \"getblockcount\"], stdout=devnull)\n     devnull.close()\n-    # Create&return JSON-RPC connections\n-    rpc_connections = []\n-    for i in range(num_nodes):\n-        url = \"http://rt:rt@%s:%d\" % (rpchost or '127.0.0.1', rpc_port(i))\n-        rpc_connections.append(AuthServiceProxy(url))\n-    return rpc_connections\n+    url = \"http://rt:rt@%s:%d\" % (rpchost or '127.0.0.1', rpc_port(i))\n+    return AuthServiceProxy(url)\n+\n+def start_nodes(num_nodes, dir, extra_args=None, rpchost=None):\n+    \"\"\"\n+    Start multiple bitcoinds, return RPC connections to them\n+    \"\"\"\n+    if extra_args is None: extra_args = [ None for i in range(num_nodes) ]\n+    return [ start_node(i, dir, extra_args[i], rpchost) for i in range(num_nodes) ]\n \n def debug_log(dir, n_node):\n     return os.path.join(dir, \"node\"+str(n_node), \"regtest\", \"debug.log\")\n@@ -178,6 +183,108 @@ def connect_nodes(from_connection, node_num):\n     ip_port = \"127.0.0.1:\"+str(p2p_port(node_num))\n     from_connection.addnode(ip_port, \"onetry\")\n \n+def find_output(node, txid, amount):\n+    \"\"\"\n+    Return index to output of txid with value amount\n+    Raises exception if there is none.\n+    \"\"\"\n+    txdata = node.getrawtransaction(txid, 1)\n+    for i in range(len(txdata[\"vout\"])):\n+        if txdata[\"vout\"][i][\"value\"] == amount:\n+            return i\n+    raise RuntimeError(\"find_output txid %s : %s not found\"%(txid,str(amount)))\n+\n+def gather_inputs(from_node, amount_needed):\n+    \"\"\"\n+    Return a random set of unspent txouts that are enough to pay amount_needed\n+    \"\"\"\n+    utxo = from_node.listunspent(1)\n+    random.shuffle(utxo)\n+    inputs = []\n+    total_in = Decimal(\"0.00000000\")\n+    while total_in < amount_needed and len(utxo) > 0:\n+        t = utxo.pop()\n+        total_in += t[\"amount\"]\n+        inputs.append({ \"txid\" : t[\"txid\"], \"vout\" : t[\"vout\"], \"address\" : t[\"address\"] } )\n+    if total_in < amount_needed:\n+        raise RuntimeError(\"Insufficient funds: need %d, have %d\"%(amount+fee*2, total_in))\n+    return (total_in, inputs)\n+\n+def make_change(from_node, amount_in, amount_out, fee):\n+    \"\"\"\n+    Create change output(s), return them\n+    \"\"\"\n+    outputs = {}\n+    amount = amount_out+fee\n+    change = amount_in - amount\n+    if change > amount*2:\n+        # Create an extra change output to break up big inputs\n+        outputs[from_node.getnewaddress()] = float(change/2)\n+        change = change/2\n+    if change > 0:\n+        outputs[from_node.getnewaddress()] = float(change)\n+    return outputs\n+\n+def send_zeropri_transaction(from_node, to_node, amount, fee):\n+    \"\"\"\n+    Create&broadcast a zero-priority transaction.\n+    Returns (txid, hex-encoded-txdata)\n+    Ensures transaction is zero-priority by first creating a send-to-self,\n+    then using it's output\n+    \"\"\"\n+\n+    # Create a send-to-self with confirmed inputs:\n+    self_address = from_node.getnewaddress()\n+    (total_in, inputs) = gather_inputs(from_node, amount+fee*2)\n+    outputs = make_change(from_node, total_in, amount+fee, fee)\n+    outputs[self_address] = float(amount+fee)\n+\n+    self_rawtx = from_node.createrawtransaction(inputs, outputs)\n+    self_signresult = from_node.signrawtransaction(self_rawtx)\n+    self_txid = from_node.sendrawtransaction(self_signresult[\"hex\"], True)\n+\n+    vout = find_output(from_node, self_txid, amount+fee)\n+    # Now immediately spend the output to create a 1-input, 1-output\n+    # zero-priority transaction:\n+    inputs = [ { \"txid\" : self_txid, \"vout\" : vout } ]\n+    outputs = { to_node.getnewaddress() : float(amount) }\n+\n+    rawtx = from_node.createrawtransaction(inputs, outputs)\n+    signresult = from_node.signrawtransaction(rawtx)\n+    txid = from_node.sendrawtransaction(signresult[\"hex\"], True)\n+\n+    return (txid, signresult[\"hex\"])\n+\n+def random_zeropri_transaction(nodes, amount, min_fee, fee_increment, fee_variants):\n+    \"\"\"\n+    Create a random zero-priority transaction.\n+    Returns (txid, hex-encoded-transaction-data, fee)\n+    \"\"\"\n+    from_node = random.choice(nodes)\n+    to_node = random.choice(nodes)\n+    fee = min_fee + fee_increment*random.randint(0,fee_variants)\n+    (txid, txhex) = send_zeropri_transaction(from_node, to_node, amount, fee)\n+    return (txid, txhex, fee)\n+\n+def random_transaction(nodes, amount, min_fee, fee_increment, fee_variants):\n+    \"\"\"\n+    Create a random transaction.\n+    Returns (txid, hex-encoded-transaction-data, fee)\n+    \"\"\"\n+    from_node = random.choice(nodes)\n+    to_node = random.choice(nodes)\n+    fee = min_fee + fee_increment*random.randint(0,fee_variants)\n+\n+    (total_in, inputs) = gather_inputs(from_node, amount+fee)\n+    outputs = make_change(from_node, total_in, amount, fee)\n+    outputs[to_node.getnewaddress()] = float(amount)\n+\n+    rawtx = from_node.createrawtransaction(inputs, outputs)\n+    signresult = from_node.signrawtransaction(rawtx)\n+    txid = from_node.sendrawtransaction(signresult[\"hex\"], True)\n+\n+    return (txid, signresult[\"hex\"], fee)\n+\n def assert_equal(thing1, thing2):\n     if thing1 != thing2:\n         raise AssertionError(\"%s != %s\"%(str(thing1),str(thing2)))"
      },
      {
        "sha": "0e5912934962cab3cc5c4d8d4e9b6049b1271ec7",
        "filename": "src/core.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/171ca7745e77c9f78f26556457fe64e5b2004a75/src/core.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/171ca7745e77c9f78f26556457fe64e5b2004a75/src/core.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core.h?ref=171ca7745e77c9f78f26556457fe64e5b2004a75",
        "patch": "@@ -120,6 +120,7 @@ class CFeeRate\n private:\n     int64_t nSatoshisPerK; // unit is satoshis-per-1,000-bytes\n public:\n+    CFeeRate() : nSatoshisPerK(0) { }\n     explicit CFeeRate(int64_t _nSatoshisPerK): nSatoshisPerK(_nSatoshisPerK) { }\n     CFeeRate(int64_t nFeePaid, size_t nSize);\n     CFeeRate(const CFeeRate& other) { nSatoshisPerK = other.nSatoshisPerK; }\n@@ -132,6 +133,8 @@ class CFeeRate\n     friend bool operator==(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK == b.nSatoshisPerK; }\n \n     std::string ToString() const;\n+\n+    IMPLEMENT_SERIALIZE( READWRITE(nSatoshisPerK); )\n };\n \n "
      },
      {
        "sha": "aca5e0c9aa92a6b5f3715d313faa88bef574ac33",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/171ca7745e77c9f78f26556457fe64e5b2004a75/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/171ca7745e77c9f78f26556457fe64e5b2004a75/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=171ca7745e77c9f78f26556457fe64e5b2004a75",
        "patch": "@@ -59,6 +59,7 @@ enum BindFlags {\n     BF_REPORT_ERROR = (1U << 1)\n };\n \n+static const char* FEE_ESTIMATES_FILENAME=\"fee_estimates.dat\";\n \n //////////////////////////////////////////////////////////////////////////////\n //\n@@ -121,6 +122,14 @@ void Shutdown()\n #endif\n     StopNode();\n     UnregisterNodeSignals(GetNodeSignals());\n+\n+    boost::filesystem::path est_path = GetDataDir() / FEE_ESTIMATES_FILENAME;\n+    CAutoFile est_fileout = CAutoFile(fopen(est_path.string().c_str(), \"wb\"), SER_DISK, CLIENT_VERSION);\n+    if (est_fileout)\n+        mempool.WriteFeeEstimates(est_fileout);\n+    else\n+        LogPrintf(\"failed to write fee estimates\");\n+\n     {\n         LOCK(cs_main);\n #ifdef ENABLE_WALLET\n@@ -933,6 +942,11 @@ bool AppInit2(boost::thread_group& threadGroup)\n         return false;\n     }\n \n+    boost::filesystem::path est_path = GetDataDir() / FEE_ESTIMATES_FILENAME;\n+    CAutoFile est_filein = CAutoFile(fopen(est_path.string().c_str(), \"rb\"), SER_DISK, CLIENT_VERSION);\n+    if (est_filein)\n+        mempool.ReadFeeEstimates(est_filein);\n+\n     // ********************************************************* Step 8: load wallet\n #ifdef ENABLE_WALLET\n     if (fDisableWallet) {"
      },
      {
        "sha": "429473d8f8ac5ef44b97ccf5330846e0fdf4dd46",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 6,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/171ca7745e77c9f78f26556457fe64e5b2004a75/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/171ca7745e77c9f78f26556457fe64e5b2004a75/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=171ca7745e77c9f78f26556457fe64e5b2004a75",
        "patch": "@@ -851,6 +851,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         CCoinsView dummy;\n         CCoinsViewCache view(dummy);\n \n+        int64_t nValueIn = 0;\n         {\n         LOCK(pool.cs);\n         CCoinsViewMemPool viewMemPool(*pcoinsTip, pool);\n@@ -879,6 +880,8 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         // Bring the best block into scope\n         view.GetBestBlock();\n \n+        nValueIn = view.GetValueIn(tx);\n+\n         // we have all inputs cached now, so switch back to dummy, so we don't need to keep lock on mempool\n         view.SetBackend(dummy);\n         }\n@@ -891,7 +894,6 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         // you should add code here to check that the transaction does a\n         // reasonable number of ECDSA signature verifications.\n \n-        int64_t nValueIn = view.GetValueIn(tx);\n         int64_t nValueOut = tx.GetValueOut();\n         int64_t nFees = nValueIn-nValueOut;\n         double dPriority = view.GetPriority(tx, chainActive.Height());\n@@ -2017,11 +2019,7 @@ bool static ConnectTip(CValidationState &state, CBlockIndex *pindexNew) {\n         return false;\n     // Remove conflicting transactions from the mempool.\n     list<CTransaction> txConflicted;\n-    BOOST_FOREACH(const CTransaction &tx, block.vtx) {\n-        list<CTransaction> unused;\n-        mempool.remove(tx, unused);\n-        mempool.removeConflicts(tx, txConflicted);\n-    }\n+    mempool.removeForBlock(block.vtx, pindexNew->nHeight, txConflicted);\n     mempool.check(pcoinsTip);\n     // Update chainActive & related variables.\n     UpdateTip(pindexNew);"
      },
      {
        "sha": "23c86603761659106ac0a59a9e6202658f36e751",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 0,
        "deletions": 7,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/171ca7745e77c9f78f26556457fe64e5b2004a75/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/171ca7745e77c9f78f26556457fe64e5b2004a75/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=171ca7745e77c9f78f26556457fe64e5b2004a75",
        "patch": "@@ -292,13 +292,6 @@ unsigned int GetLegacySigOpCount(const CTransaction& tx);\n unsigned int GetP2SHSigOpCount(const CTransaction& tx, CCoinsViewCache& mapInputs);\n \n \n-inline bool AllowFree(double dPriority)\n-{\n-    // Large (in bytes) low-priority (new, small-coin) transactions\n-    // need a fee.\n-    return dPriority > COIN * 144 / 250;\n-}\n-\n // Check whether all inputs of this transaction are valid (no double spends, scripts & sigs, amounts)\n // This does not modify the UTXO set. If pvChecks is not NULL, script checks are pushed onto it\n // instead of being performed inline."
      },
      {
        "sha": "b89a95ad119c1ceb359f43c4ddb8259516569fe1",
        "filename": "src/rpcclient.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/171ca7745e77c9f78f26556457fe64e5b2004a75/src/rpcclient.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/171ca7745e77c9f78f26556457fe64e5b2004a75/src/rpcclient.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcclient.cpp?ref=171ca7745e77c9f78f26556457fe64e5b2004a75",
        "patch": "@@ -176,6 +176,8 @@ Array RPCConvertValues(const std::string &strMethod, const std::vector<std::stri\n     if (strMethod == \"verifychain\"            && n > 1) ConvertTo<int64_t>(params[1]);\n     if (strMethod == \"keypoolrefill\"          && n > 0) ConvertTo<int64_t>(params[0]);\n     if (strMethod == \"getrawmempool\"          && n > 0) ConvertTo<bool>(params[0]);\n+    if (strMethod == \"estimatefee\"            && n > 0) ConvertTo<boost::int64_t>(params[0]);\n+    if (strMethod == \"estimatepriority\"       && n > 0) ConvertTo<boost::int64_t>(params[0]);\n \n     return params;\n }"
      },
      {
        "sha": "dd148c6af1a010afd26b4c75c863a960f26d28e9",
        "filename": "src/rpcmining.cpp",
        "status": "modified",
        "additions": 61,
        "deletions": 0,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/171ca7745e77c9f78f26556457fe64e5b2004a75/src/rpcmining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/171ca7745e77c9f78f26556457fe64e5b2004a75/src/rpcmining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcmining.cpp?ref=171ca7745e77c9f78f26556457fe64e5b2004a75",
        "patch": "@@ -15,6 +15,7 @@\n #endif\n #include <stdint.h>\n \n+#include <boost/assign/list_of.hpp>\n #include \"json/json_spirit_utils.h\"\n #include \"json/json_spirit_value.h\"\n \n@@ -626,3 +627,63 @@ Value submitblock(const Array& params, bool fHelp)\n \n     return Value::null;\n }\n+\n+Value estimatefee(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\n+            \"estimatefee nblocks\\n\"\n+            \"\\nEstimates the approximate fee per kilobyte\\n\"\n+            \"needed for a transaction to get confirmed\\n\"\n+            \"within nblocks blocks.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. nblocks     (numeric)\\n\"\n+            \"\\nResult:\\n\"\n+            \"n :    (numeric) estimated fee-per-kilobyte\\n\"\n+            \"\\n\"\n+            \"-1.0 is returned if not enough transactions and\\n\"\n+            \"blocks have been observed to make an estimate.\\n\"\n+            \"\\nExample:\\n\"\n+            + HelpExampleCli(\"estimatefee\", \"6\")\n+            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(int_type));\n+\n+    int nBlocks = params[0].get_int();\n+    if (nBlocks < 1)\n+        nBlocks = 1;\n+\n+    CFeeRate feeRate = mempool.estimateFee(nBlocks);\n+    if (feeRate == CFeeRate(0))\n+        return -1.0;\n+\n+    return ValueFromAmount(feeRate.GetFeePerK());\n+}\n+\n+Value estimatepriority(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\n+            \"estimatepriority nblocks\\n\"\n+            \"\\nEstimates the approximate priority\\n\"\n+            \"a zero-fee transaction needs to get confirmed\\n\"\n+            \"within nblocks blocks.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. nblocks     (numeric)\\n\"\n+            \"\\nResult:\\n\"\n+            \"n :    (numeric) estimated priority\\n\"\n+            \"\\n\"\n+            \"-1.0 is returned if not enough transactions and\\n\"\n+            \"blocks have been observed to make an estimate.\\n\"\n+            \"\\nExample:\\n\"\n+            + HelpExampleCli(\"estimatepriority\", \"6\")\n+            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(int_type));\n+\n+    int nBlocks = params[0].get_int();\n+    if (nBlocks < 1)\n+        nBlocks = 1;\n+\n+    return mempool.estimatePriority(nBlocks);\n+}"
      },
      {
        "sha": "72a7fe83ef76e53d2dcbc3c3f71ea9d4fc0f1ebe",
        "filename": "src/rpcserver.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/171ca7745e77c9f78f26556457fe64e5b2004a75/src/rpcserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/171ca7745e77c9f78f26556457fe64e5b2004a75/src/rpcserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcserver.cpp?ref=171ca7745e77c9f78f26556457fe64e5b2004a75",
        "patch": "@@ -268,6 +268,8 @@ static const CRPCCommand vRPCCommands[] =\n     { \"createmultisig\",         &createmultisig,         true,      true ,      false },\n     { \"validateaddress\",        &validateaddress,        true,      false,      false }, /* uses wallet if enabled */\n     { \"verifymessage\",          &verifymessage,          false,     false,      false },\n+    { \"estimatefee\",            &estimatefee,            true,      true,       false },\n+    { \"estimatepriority\",       &estimatepriority,       true,      true,       false },\n \n #ifdef ENABLE_WALLET\n     /* Wallet */"
      },
      {
        "sha": "73e8b9426c4ec95998cf511664ef1fbd9f0b203b",
        "filename": "src/rpcserver.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/171ca7745e77c9f78f26556457fe64e5b2004a75/src/rpcserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/171ca7745e77c9f78f26556457fe64e5b2004a75/src/rpcserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcserver.h?ref=171ca7745e77c9f78f26556457fe64e5b2004a75",
        "patch": "@@ -133,6 +133,8 @@ extern json_spirit::Value getmininginfo(const json_spirit::Array& params, bool f\n extern json_spirit::Value getwork(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value getblocktemplate(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value submitblock(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value estimatefee(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value estimatepriority(const json_spirit::Array& params, bool fHelp);\n \n extern json_spirit::Value getnewaddress(const json_spirit::Array& params, bool fHelp); // in rpcwallet.cpp\n extern json_spirit::Value getaccountaddress(const json_spirit::Array& params, bool fHelp);"
      },
      {
        "sha": "4bf01d4848b1a07df931fed7707229e98b115dbb",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 370,
        "deletions": 0,
        "changes": 370,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/171ca7745e77c9f78f26556457fe64e5b2004a75/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/171ca7745e77c9f78f26556457fe64e5b2004a75/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=171ca7745e77c9f78f26556457fe64e5b2004a75",
        "patch": "@@ -6,6 +6,8 @@\n #include \"core.h\"\n #include \"txmempool.h\"\n \n+#include <boost/circular_buffer.hpp>\n+\n using namespace std;\n \n CTxMemPoolEntry::CTxMemPoolEntry()\n@@ -35,12 +37,311 @@ CTxMemPoolEntry::GetPriority(unsigned int currentHeight) const\n     return dResult;\n }\n \n+//\n+// Keep track of fee/priority for transactions confirmed within N blocks\n+//\n+class CBlockAverage\n+{\n+private:\n+    boost::circular_buffer<CFeeRate> feeSamples;\n+    boost::circular_buffer<double> prioritySamples;\n+\n+    template<typename T> std::vector<T> buf2vec(boost::circular_buffer<T> buf) const\n+    {\n+        std::vector<T> vec(buf.begin(), buf.end());\n+        return vec;\n+    }\n+\n+public:\n+    CBlockAverage() : feeSamples(100), prioritySamples(100) { }\n+\n+    void RecordFee(const CFeeRate& feeRate) {\n+        feeSamples.push_back(feeRate);\n+    }\n+\n+    void RecordPriority(double priority) {\n+        prioritySamples.push_back(priority);\n+    }\n+\n+    size_t FeeSamples() const { return feeSamples.size(); }\n+    size_t GetFeeSamples(std::vector<CFeeRate>& insertInto) const\n+    {\n+        BOOST_FOREACH(const CFeeRate& f, feeSamples)\n+            insertInto.push_back(f);\n+        return feeSamples.size();\n+    }\n+    size_t PrioritySamples() const { return prioritySamples.size(); }\n+    size_t GetPrioritySamples(std::vector<double>& insertInto) const\n+    {\n+        BOOST_FOREACH(double d, prioritySamples)\n+            insertInto.push_back(d);\n+        return prioritySamples.size();\n+    }\n+\n+    // Used as belt-and-suspenders check when reading to detect\n+    // file corruption\n+    bool AreSane(const std::vector<CFeeRate>& vecFee)\n+    {\n+        BOOST_FOREACH(CFeeRate fee, vecFee)\n+        {\n+            if (fee < CFeeRate(0))\n+                return false;\n+            if (fee.GetFee(1000) > CTransaction::minRelayTxFee.GetFee(1000) * 10000)\n+                return false;\n+        }\n+        return true;\n+    }\n+    bool AreSane(const std::vector<double> vecPriority)\n+    {\n+        BOOST_FOREACH(double priority, vecPriority)\n+        {\n+            if (priority < 0)\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    void Write(CAutoFile& fileout) const\n+    {\n+        std::vector<CFeeRate> vecFee = buf2vec(feeSamples);\n+        fileout << vecFee;\n+        std::vector<double> vecPriority = buf2vec(prioritySamples);\n+        fileout << vecPriority;\n+    }\n+\n+    void Read(CAutoFile& filein) {\n+        std::vector<CFeeRate> vecFee;\n+        filein >> vecFee;\n+        if (AreSane(vecFee))\n+            feeSamples.insert(feeSamples.end(), vecFee.begin(), vecFee.end());\n+        else\n+            throw runtime_error(\"Corrupt fee value in estimates file.\");\n+        std::vector<double> vecPriority;\n+        filein >> vecPriority;\n+        if (AreSane(vecPriority))\n+            prioritySamples.insert(prioritySamples.end(), vecPriority.begin(), vecPriority.end());\n+        else\n+            throw runtime_error(\"Corrupt priority value in estimates file.\");\n+        if (feeSamples.size() + prioritySamples.size() > 0)\n+            LogPrint(\"estimatefee\", \"Read %d fee samples and %d priority samples\\n\",\n+                     feeSamples.size(), prioritySamples.size());\n+    }\n+};\n+\n+class CMinerPolicyEstimator\n+{\n+private:\n+    // Records observed averages transactions that confirmed within one block, two blocks,\n+    // three blocks etc.\n+    std::vector<CBlockAverage> history;\n+    std::vector<CFeeRate> sortedFeeSamples;\n+    std::vector<double> sortedPrioritySamples;\n+\n+    int nBestSeenHeight;\n+\n+    // nBlocksAgo is 0 based, i.e. transactions that confirmed in the highest seen block are\n+    // nBlocksAgo == 0, transactions in the block before that are nBlocksAgo == 1 etc.\n+    void seenTxConfirm(CFeeRate feeRate, double dPriority, int nBlocksAgo)\n+    {\n+        // Last entry records \"everything else\".\n+        int nBlocksTruncated = min(nBlocksAgo, (int) history.size() - 1);\n+        assert(nBlocksTruncated >= 0);\n+\n+        // We need to guess why the transaction was included in a block-- either\n+        // because it is high-priority or because it has sufficient fees.\n+        bool sufficientFee = (feeRate > CTransaction::minRelayTxFee);\n+        bool sufficientPriority = AllowFree(dPriority);\n+        const char* assignedTo = \"unassigned\";\n+        if (sufficientFee && !sufficientPriority)\n+        {\n+            history[nBlocksTruncated].RecordFee(feeRate);\n+            assignedTo = \"fee\";\n+        }\n+        else if (sufficientPriority && !sufficientFee)\n+        {\n+            history[nBlocksTruncated].RecordPriority(dPriority);\n+            assignedTo = \"priority\";\n+        }\n+        else\n+        {\n+            // Neither or both fee and priority sufficient to get confirmed:\n+            // don't know why they got confirmed.\n+        }\n+        LogPrint(\"estimatefee\", \"Seen TX confirm: %s : %s fee/%g priority, took %d blocks\\n\",\n+                 assignedTo, feeRate.ToString(), dPriority, nBlocksAgo);\n+    }\n+\n+public:\n+    CMinerPolicyEstimator(int nEntries) : nBestSeenHeight(0)\n+    {\n+        history.resize(nEntries);\n+    }\n+\n+    void seenBlock(const std::vector<CTxMemPoolEntry>& entries, int nBlockHeight)\n+    {\n+        if (nBlockHeight <= nBestSeenHeight)\n+        {\n+            // Ignore side chains and re-orgs; assuming they are random\n+            // they don't affect the estimate.\n+            // And if an attacker can re-org the chain at will, then\n+            // you've got much bigger problems than \"attacker can influence\n+            // transaction fees.\"\n+            return;\n+        }\n+        nBestSeenHeight = nBlockHeight;\n+\n+        // Fill up the history buckets based on how long transactions took\n+        // to confirm.\n+        std::vector<std::vector<const CTxMemPoolEntry*> > entriesByConfirmations;\n+        entriesByConfirmations.resize(history.size());\n+        BOOST_FOREACH(const CTxMemPoolEntry& entry, entries)\n+        {\n+            // How many blocks did it take for miners to include this transaction?\n+            int delta = nBlockHeight - entry.GetHeight();\n+            if (delta <= 0)\n+            {\n+                // Re-org made us lose height, this should only happen if we happen\n+                // to re-org on a difficulty transition point: very rare!\n+                continue;\n+            }\n+            if ((delta-1) >= (int)history.size())\n+                delta = history.size(); // Last bucket is catch-all\n+            entriesByConfirmations[delta-1].push_back(&entry);\n+        }\n+        for (size_t i = 0; i < entriesByConfirmations.size(); i++)\n+        {\n+            std::vector<const CTxMemPoolEntry*> &e = entriesByConfirmations.at(i);\n+            // Insert at most 10 random entries per bucket, otherwise a single block\n+            // can dominate an estimate:\n+            if (e.size() > 10) {\n+                std::random_shuffle(e.begin(), e.end());\n+                e.resize(10);\n+            }\n+            BOOST_FOREACH(const CTxMemPoolEntry* entry, e)\n+            {\n+                // Fees are stored and reported as BTC-per-kb:\n+                CFeeRate feeRate(entry->GetFee(), entry->GetTxSize());\n+                double dPriority = entry->GetPriority(entry->GetHeight()); // Want priority when it went IN\n+                seenTxConfirm(feeRate, dPriority, i);\n+            }\n+        }\n+        for (size_t i = 0; i < history.size(); i++) {\n+            if (history[i].FeeSamples() + history[i].PrioritySamples() > 0)\n+                LogPrint(\"estimatefee\", \"estimates: for confirming within %d blocks based on %d/%d samples, fee=%s, prio=%g\\n\", \n+                         i,\n+                         history[i].FeeSamples(), history[i].PrioritySamples(),\n+                         estimateFee(i+1).ToString(), estimatePriority(i+1));\n+        }\n+        sortedFeeSamples.clear();\n+        sortedPrioritySamples.clear();\n+    }\n+\n+    // Can return CFeeRate(0) if we don't have any data for that many blocks back. nBlocksToConfirm is 1 based.\n+    CFeeRate estimateFee(int nBlocksToConfirm)\n+    {\n+        nBlocksToConfirm--;\n+\n+        if (nBlocksToConfirm < 0 || nBlocksToConfirm >= (int)history.size())\n+            return CFeeRate(0);\n+\n+        if (sortedFeeSamples.size() == 0)\n+        {\n+            for (size_t i = 0; i < history.size(); i++)\n+                history.at(i).GetFeeSamples(sortedFeeSamples);\n+            std::sort(sortedFeeSamples.begin(), sortedFeeSamples.end(),\n+                      std::greater<CFeeRate>());\n+        }\n+        if (sortedFeeSamples.size() == 0)\n+            return CFeeRate(0);\n+\n+        int nBucketSize = history.at(nBlocksToConfirm).FeeSamples();\n+\n+        // Estimates should not increase as number of confirmations goes up,\n+        // but the estimates are noisy because confirmations happen discretely\n+        // in blocks. To smooth out the estimates, use all samples in the history\n+        // and use the nth highest where n is (number of samples in previous bucket +\n+        // half the samples in nBlocksToConfirm bucket):\n+        size_t nPrevSize = 0;\n+        for (int i = 0; i < nBlocksToConfirm; i++)\n+            nPrevSize += history.at(i).FeeSamples();\n+        size_t index = min(nPrevSize + nBucketSize/2, sortedFeeSamples.size()-1);\n+        return sortedFeeSamples[index];\n+    }\n+    double estimatePriority(int nBlocksToConfirm)\n+    {\n+        nBlocksToConfirm--;\n+\n+        if (nBlocksToConfirm < 0 || nBlocksToConfirm >= (int)history.size())\n+            return -1;\n+\n+        if (sortedPrioritySamples.size() == 0)\n+        {\n+            for (size_t i = 0; i < history.size(); i++)\n+                history.at(i).GetPrioritySamples(sortedPrioritySamples);\n+            std::sort(sortedPrioritySamples.begin(), sortedPrioritySamples.end(),\n+                      std::greater<double>());\n+        }\n+        if (sortedPrioritySamples.size() == 0)\n+            return -1.0;\n+\n+        int nBucketSize = history.at(nBlocksToConfirm).PrioritySamples();\n+\n+        // Estimates should not increase as number of confirmations needed goes up,\n+        // but the estimates are noisy because confirmations happen discretely\n+        // in blocks. To smooth out the estimates, use all samples in the history\n+        // and use the nth highest where n is (number of samples in previous buckets +\n+        // half the samples in nBlocksToConfirm bucket).\n+        size_t nPrevSize = 0;\n+        for (int i = 0; i < nBlocksToConfirm; i++)\n+            nPrevSize += history.at(i).PrioritySamples();\n+        size_t index = min(nPrevSize + nBucketSize/2, sortedFeeSamples.size()-1);\n+        return sortedPrioritySamples[index];\n+    }\n+\n+    void Write(CAutoFile& fileout) const\n+    {\n+        fileout << nBestSeenHeight;\n+        fileout << history.size();\n+        BOOST_FOREACH(const CBlockAverage& entry, history)\n+        {\n+            entry.Write(fileout);\n+        }\n+    }\n+\n+    void Read(CAutoFile& filein)\n+    {\n+        filein >> nBestSeenHeight;\n+        size_t numEntries;\n+        filein >> numEntries;\n+        history.clear();\n+        for (size_t i = 0; i < numEntries; i++)\n+        {\n+            CBlockAverage entry;\n+            entry.Read(filein);\n+            history.push_back(entry);\n+        }\n+    }\n+};\n+\n+\n CTxMemPool::CTxMemPool()\n {\n     // Sanity checks off by default for performance, because otherwise\n     // accepting transactions becomes O(N^2) where N is the number\n     // of transactions in the pool\n     fSanityCheck = false;\n+\n+    // 25 blocks is a compromise between using a lot of disk/memory and\n+    // trying to give accurate estimates to people who might be willing\n+    // to wait a day or two to save a fraction of a penny in fees.\n+    // Confirmation times for very-low-fee transactions that take more\n+    // than an hour or three to confirm are highly variable.\n+    minerPolicyEstimator = new CMinerPolicyEstimator(25);\n+}\n+\n+CTxMemPool::~CTxMemPool()\n+{\n+    delete minerPolicyEstimator;\n }\n \n void CTxMemPool::pruneSpent(const uint256 &hashTx, CCoins &coins)\n@@ -128,6 +429,28 @@ void CTxMemPool::removeConflicts(const CTransaction &tx, std::list<CTransaction>\n     }\n }\n \n+// Called when a block is connected. Removes from mempool and updates the miner fee estimator.\n+void CTxMemPool::removeForBlock(const std::vector<CTransaction>& vtx, unsigned int nBlockHeight,\n+                                std::list<CTransaction>& conflicts)\n+{\n+    LOCK(cs);\n+    std::vector<CTxMemPoolEntry> entries;\n+    BOOST_FOREACH(const CTransaction& tx, vtx)\n+    {\n+        uint256 hash = tx.GetHash();\n+        if (mapTx.count(hash))\n+            entries.push_back(mapTx[hash]);\n+    }\n+    minerPolicyEstimator->seenBlock(entries, nBlockHeight);\n+    BOOST_FOREACH(const CTransaction& tx, vtx)\n+    {\n+        std::list<CTransaction> dummy;\n+        remove(tx, dummy, false);\n+        removeConflicts(tx, conflicts);\n+    }\n+}\n+\n+\n void CTxMemPool::clear()\n {\n     LOCK(cs);\n@@ -195,6 +518,53 @@ bool CTxMemPool::lookup(uint256 hash, CTransaction& result) const\n     return true;\n }\n \n+CFeeRate CTxMemPool::estimateFee(int nBlocks) const\n+{\n+    LOCK(cs);\n+    return minerPolicyEstimator->estimateFee(nBlocks);\n+}\n+double CTxMemPool::estimatePriority(int nBlocks) const\n+{\n+    LOCK(cs);\n+    return minerPolicyEstimator->estimatePriority(nBlocks);\n+}\n+\n+bool\n+CTxMemPool::WriteFeeEstimates(CAutoFile& fileout) const\n+{\n+    try {\n+        LOCK(cs);\n+        fileout << 99900; // version required to read: 0.9.99 or later\n+        fileout << CLIENT_VERSION; // version that wrote the file\n+        minerPolicyEstimator->Write(fileout);\n+    }\n+    catch (std::exception &e) {\n+        LogPrintf(\"CTxMemPool::WriteFeeEstimates() : unable to write policy estimator data (non-fatal)\");\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool\n+CTxMemPool::ReadFeeEstimates(CAutoFile& filein)\n+{\n+    try {\n+        int nVersionRequired, nVersionThatWrote;\n+        filein >> nVersionRequired >> nVersionThatWrote;\n+        if (nVersionRequired > CLIENT_VERSION)\n+            return error(\"CTxMemPool::ReadFeeEstimates() : up-version (%d) fee estimate file\", nVersionRequired);\n+\n+        LOCK(cs);\n+        minerPolicyEstimator->Read(filein);\n+    }\n+    catch (std::exception &e) {\n+        LogPrintf(\"CTxMemPool::ReadFeeEstimates() : unable to read policy estimator data (non-fatal)\");\n+        return false;\n+    }\n+    return true;\n+}\n+\n+\n CCoinsViewMemPool::CCoinsViewMemPool(CCoinsView &baseIn, CTxMemPool &mempoolIn) : CCoinsViewBacked(baseIn), mempool(mempoolIn) { }\n \n bool CCoinsViewMemPool::GetCoins(const uint256 &txid, CCoins &coins) {"
      },
      {
        "sha": "b2915aa842bd0c186a3bcf6fc3fc8f3e8f0d2975",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/171ca7745e77c9f78f26556457fe64e5b2004a75/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/171ca7745e77c9f78f26556457fe64e5b2004a75/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=171ca7745e77c9f78f26556457fe64e5b2004a75",
        "patch": "@@ -11,6 +11,13 @@\n #include \"core.h\"\n #include \"sync.h\"\n \n+inline bool AllowFree(double dPriority)\n+{\n+    // Large (in bytes) low-priority (new, small-coin) transactions\n+    // need a fee.\n+    return dPriority > COIN * 144 / 250;\n+}\n+\n /** Fake height value used in CCoins to signify they are only in the memory pool (since 0.8) */\n static const unsigned int MEMPOOL_HEIGHT = 0x7FFFFFFF;\n \n@@ -41,6 +48,8 @@ class CTxMemPoolEntry\n     unsigned int GetHeight() const { return nHeight; }\n };\n \n+class CMinerPolicyEstimator;\n+\n /*\n  * CTxMemPool stores valid-according-to-the-current-best-chain\n  * transactions that may be included in the next block.\n@@ -56,13 +65,15 @@ class CTxMemPool\n private:\n     bool fSanityCheck; // Normally false, true if -checkmempool or -regtest\n     unsigned int nTransactionsUpdated;\n+    CMinerPolicyEstimator* minerPolicyEstimator;\n \n public:\n     mutable CCriticalSection cs;\n     std::map<uint256, CTxMemPoolEntry> mapTx;\n     std::map<COutPoint, CInPoint> mapNextTx;\n \n     CTxMemPool();\n+    ~CTxMemPool();\n \n     /*\n      * If sanity-checking is turned on, check makes sure the pool is\n@@ -76,6 +87,8 @@ class CTxMemPool\n     bool addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry);\n     void remove(const CTransaction &tx, std::list<CTransaction>& removed, bool fRecursive = false);\n     void removeConflicts(const CTransaction &tx, std::list<CTransaction>& removed);\n+    void removeForBlock(const std::vector<CTransaction>& vtx, unsigned int nBlockHeight,\n+                        std::list<CTransaction>& conflicts);\n     void clear();\n     void queryHashes(std::vector<uint256>& vtxid);\n     void pruneSpent(const uint256& hash, CCoins &coins);\n@@ -95,6 +108,16 @@ class CTxMemPool\n     }\n \n     bool lookup(uint256 hash, CTransaction& result) const;\n+\n+    // Estimate fee rate needed to get into the next\n+    // nBlocks\n+    CFeeRate estimateFee(int nBlocks) const;\n+    // Estimate priority needed to get into the next\n+    // nBlocks\n+    double estimatePriority(int nBlocks) const;\n+    // Write/Read estimates to disk\n+    bool WriteFeeEstimates(CAutoFile& fileout) const;\n+    bool ReadFeeEstimates(CAutoFile& filein);\n };\n \n /** CCoinsView that brings transactions from a memorypool into view."
      }
    ]
  }
]