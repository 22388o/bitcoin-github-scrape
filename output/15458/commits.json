[
  {
    "sha": "53b310390cc72a034911a8d6236b472a22c62227",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1M2IzMTAzOTBjYzcyYTAzNDkxMWE4ZDYyMzZiNDcyYTIyYzYyMjI3",
    "commit": {
      "author": {
        "name": "Jo\u00e3o Barbosa",
        "email": "joao.paulo.barbosa@gmail.com",
        "date": "2019-02-21T15:26:29Z"
      },
      "committer": {
        "name": "Jo\u00e3o Barbosa",
        "email": "joao.paulo.barbosa@gmail.com",
        "date": "2019-02-21T16:19:29Z"
      },
      "message": "refactor: Drop redundant wallet reference",
      "tree": {
        "sha": "a69101753e2f0d64580ac8fef2a38dacac1bb7f7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a69101753e2f0d64580ac8fef2a38dacac1bb7f7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/53b310390cc72a034911a8d6236b472a22c62227",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/53b310390cc72a034911a8d6236b472a22c62227",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/53b310390cc72a034911a8d6236b472a22c62227",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/53b310390cc72a034911a8d6236b472a22c62227/comments",
    "author": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f9775a865597b3cc926ba3375fa692516c7415be",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f9775a865597b3cc926ba3375fa692516c7415be",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f9775a865597b3cc926ba3375fa692516c7415be"
      }
    ],
    "stats": {
      "total": 255,
      "additions": 127,
      "deletions": 128
    },
    "files": [
      {
        "sha": "0dac75834e09a2029ef1d2d5acf171addbe8306d",
        "filename": "src/interfaces/wallet.cpp",
        "status": "modified",
        "additions": 127,
        "deletions": 128,
        "changes": 255,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/53b310390cc72a034911a8d6236b472a22c62227/src/interfaces/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/53b310390cc72a034911a8d6236b472a22c62227/src/interfaces/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/wallet.cpp?ref=53b310390cc72a034911a8d6236b472a22c62227",
        "patch": "@@ -135,55 +135,55 @@ WalletTxOut MakeWalletTxOut(interfaces::Chain::Lock& locked_chain,\n class WalletImpl : public Wallet\n {\n public:\n-    explicit WalletImpl(const std::shared_ptr<CWallet>& wallet) : m_shared_wallet(wallet), m_wallet(*wallet.get()) {}\n+    explicit WalletImpl(const std::shared_ptr<CWallet>& wallet) : m_wallet(wallet) {}\n \n     bool encryptWallet(const SecureString& wallet_passphrase) override\n     {\n-        return m_wallet.EncryptWallet(wallet_passphrase);\n+        return m_wallet->EncryptWallet(wallet_passphrase);\n     }\n-    bool isCrypted() override { return m_wallet.IsCrypted(); }\n-    bool lock() override { return m_wallet.Lock(); }\n-    bool unlock(const SecureString& wallet_passphrase) override { return m_wallet.Unlock(wallet_passphrase); }\n-    bool isLocked() override { return m_wallet.IsLocked(); }\n+    bool isCrypted() override { return m_wallet->IsCrypted(); }\n+    bool lock() override { return m_wallet->Lock(); }\n+    bool unlock(const SecureString& wallet_passphrase) override { return m_wallet->Unlock(wallet_passphrase); }\n+    bool isLocked() override { return m_wallet->IsLocked(); }\n     bool changeWalletPassphrase(const SecureString& old_wallet_passphrase,\n         const SecureString& new_wallet_passphrase) override\n     {\n-        return m_wallet.ChangeWalletPassphrase(old_wallet_passphrase, new_wallet_passphrase);\n+        return m_wallet->ChangeWalletPassphrase(old_wallet_passphrase, new_wallet_passphrase);\n     }\n-    void abortRescan() override { m_wallet.AbortRescan(); }\n-    bool backupWallet(const std::string& filename) override { return m_wallet.BackupWallet(filename); }\n-    std::string getWalletName() override { return m_wallet.GetName(); }\n+    void abortRescan() override { m_wallet->AbortRescan(); }\n+    bool backupWallet(const std::string& filename) override { return m_wallet->BackupWallet(filename); }\n+    std::string getWalletName() override { return m_wallet->GetName(); }\n     bool getKeyFromPool(bool internal, CPubKey& pub_key) override\n     {\n-        return m_wallet.GetKeyFromPool(pub_key, internal);\n+        return m_wallet->GetKeyFromPool(pub_key, internal);\n     }\n-    bool getPubKey(const CKeyID& address, CPubKey& pub_key) override { return m_wallet.GetPubKey(address, pub_key); }\n-    bool getPrivKey(const CKeyID& address, CKey& key) override { return m_wallet.GetKey(address, key); }\n-    bool isSpendable(const CTxDestination& dest) override { return IsMine(m_wallet, dest) & ISMINE_SPENDABLE; }\n-    bool haveWatchOnly() override { return m_wallet.HaveWatchOnly(); };\n+    bool getPubKey(const CKeyID& address, CPubKey& pub_key) override { return m_wallet->GetPubKey(address, pub_key); }\n+    bool getPrivKey(const CKeyID& address, CKey& key) override { return m_wallet->GetKey(address, key); }\n+    bool isSpendable(const CTxDestination& dest) override { return IsMine(*m_wallet, dest) & ISMINE_SPENDABLE; }\n+    bool haveWatchOnly() override { return m_wallet->HaveWatchOnly(); };\n     bool setAddressBook(const CTxDestination& dest, const std::string& name, const std::string& purpose) override\n     {\n-        return m_wallet.SetAddressBook(dest, name, purpose);\n+        return m_wallet->SetAddressBook(dest, name, purpose);\n     }\n     bool delAddressBook(const CTxDestination& dest) override\n     {\n-        return m_wallet.DelAddressBook(dest);\n+        return m_wallet->DelAddressBook(dest);\n     }\n     bool getAddress(const CTxDestination& dest,\n         std::string* name,\n         isminetype* is_mine,\n         std::string* purpose) override\n     {\n-        LOCK(m_wallet.cs_wallet);\n-        auto it = m_wallet.mapAddressBook.find(dest);\n-        if (it == m_wallet.mapAddressBook.end()) {\n+        LOCK(m_wallet->cs_wallet);\n+        auto it = m_wallet->mapAddressBook.find(dest);\n+        if (it == m_wallet->mapAddressBook.end()) {\n             return false;\n         }\n         if (name) {\n             *name = it->second.name;\n         }\n         if (is_mine) {\n-            *is_mine = IsMine(m_wallet, dest);\n+            *is_mine = IsMine(*m_wallet, dest);\n         }\n         if (purpose) {\n             *purpose = it->second.purpose;\n@@ -192,52 +192,52 @@ class WalletImpl : public Wallet\n     }\n     std::vector<WalletAddress> getAddresses() override\n     {\n-        LOCK(m_wallet.cs_wallet);\n+        LOCK(m_wallet->cs_wallet);\n         std::vector<WalletAddress> result;\n-        for (const auto& item : m_wallet.mapAddressBook) {\n-            result.emplace_back(item.first, IsMine(m_wallet, item.first), item.second.name, item.second.purpose);\n+        for (const auto& item : m_wallet->mapAddressBook) {\n+            result.emplace_back(item.first, IsMine(*m_wallet, item.first), item.second.name, item.second.purpose);\n         }\n         return result;\n     }\n-    void learnRelatedScripts(const CPubKey& key, OutputType type) override { m_wallet.LearnRelatedScripts(key, type); }\n+    void learnRelatedScripts(const CPubKey& key, OutputType type) override { m_wallet->LearnRelatedScripts(key, type); }\n     bool addDestData(const CTxDestination& dest, const std::string& key, const std::string& value) override\n     {\n-        LOCK(m_wallet.cs_wallet);\n-        return m_wallet.AddDestData(dest, key, value);\n+        LOCK(m_wallet->cs_wallet);\n+        return m_wallet->AddDestData(dest, key, value);\n     }\n     bool eraseDestData(const CTxDestination& dest, const std::string& key) override\n     {\n-        LOCK(m_wallet.cs_wallet);\n-        return m_wallet.EraseDestData(dest, key);\n+        LOCK(m_wallet->cs_wallet);\n+        return m_wallet->EraseDestData(dest, key);\n     }\n     std::vector<std::string> getDestValues(const std::string& prefix) override\n     {\n-        LOCK(m_wallet.cs_wallet);\n-        return m_wallet.GetDestValues(prefix);\n+        LOCK(m_wallet->cs_wallet);\n+        return m_wallet->GetDestValues(prefix);\n     }\n     void lockCoin(const COutPoint& output) override\n     {\n-        auto locked_chain = m_wallet.chain().lock();\n-        LOCK(m_wallet.cs_wallet);\n-        return m_wallet.LockCoin(output);\n+        auto locked_chain = m_wallet->chain().lock();\n+        LOCK(m_wallet->cs_wallet);\n+        return m_wallet->LockCoin(output);\n     }\n     void unlockCoin(const COutPoint& output) override\n     {\n-        auto locked_chain = m_wallet.chain().lock();\n-        LOCK(m_wallet.cs_wallet);\n-        return m_wallet.UnlockCoin(output);\n+        auto locked_chain = m_wallet->chain().lock();\n+        LOCK(m_wallet->cs_wallet);\n+        return m_wallet->UnlockCoin(output);\n     }\n     bool isLockedCoin(const COutPoint& output) override\n     {\n-        auto locked_chain = m_wallet.chain().lock();\n-        LOCK(m_wallet.cs_wallet);\n-        return m_wallet.IsLockedCoin(output.hash, output.n);\n+        auto locked_chain = m_wallet->chain().lock();\n+        LOCK(m_wallet->cs_wallet);\n+        return m_wallet->IsLockedCoin(output.hash, output.n);\n     }\n     void listLockedCoins(std::vector<COutPoint>& outputs) override\n     {\n-        auto locked_chain = m_wallet.chain().lock();\n-        LOCK(m_wallet.cs_wallet);\n-        return m_wallet.ListLockedCoins(outputs);\n+        auto locked_chain = m_wallet->chain().lock();\n+        LOCK(m_wallet->cs_wallet);\n+        return m_wallet->ListLockedCoins(outputs);\n     }\n     std::unique_ptr<PendingWalletTx> createTransaction(const std::vector<CRecipient>& recipients,\n         const CCoinControl& coin_control,\n@@ -246,25 +246,25 @@ class WalletImpl : public Wallet\n         CAmount& fee,\n         std::string& fail_reason) override\n     {\n-        auto locked_chain = m_wallet.chain().lock();\n-        LOCK(m_wallet.cs_wallet);\n-        auto pending = MakeUnique<PendingWalletTxImpl>(m_wallet);\n-        if (!m_wallet.CreateTransaction(*locked_chain, recipients, pending->m_tx, pending->m_key, fee, change_pos,\n+        auto locked_chain = m_wallet->chain().lock();\n+        LOCK(m_wallet->cs_wallet);\n+        auto pending = MakeUnique<PendingWalletTxImpl>(*m_wallet);\n+        if (!m_wallet->CreateTransaction(*locked_chain, recipients, pending->m_tx, pending->m_key, fee, change_pos,\n                 fail_reason, coin_control, sign)) {\n             return {};\n         }\n         return std::move(pending);\n     }\n-    bool transactionCanBeAbandoned(const uint256& txid) override { return m_wallet.TransactionCanBeAbandoned(txid); }\n+    bool transactionCanBeAbandoned(const uint256& txid) override { return m_wallet->TransactionCanBeAbandoned(txid); }\n     bool abandonTransaction(const uint256& txid) override\n     {\n-        auto locked_chain = m_wallet.chain().lock();\n-        LOCK(m_wallet.cs_wallet);\n-        return m_wallet.AbandonTransaction(*locked_chain, txid);\n+        auto locked_chain = m_wallet->chain().lock();\n+        LOCK(m_wallet->cs_wallet);\n+        return m_wallet->AbandonTransaction(*locked_chain, txid);\n     }\n     bool transactionCanBeBumped(const uint256& txid) override\n     {\n-        return feebumper::TransactionCanBeBumped(&m_wallet, txid);\n+        return feebumper::TransactionCanBeBumped(m_wallet.get(), txid);\n     }\n     bool createBumpTransaction(const uint256& txid,\n         const CCoinControl& coin_control,\n@@ -274,46 +274,46 @@ class WalletImpl : public Wallet\n         CAmount& new_fee,\n         CMutableTransaction& mtx) override\n     {\n-        return feebumper::CreateTransaction(&m_wallet, txid, coin_control, total_fee, errors, old_fee, new_fee, mtx) ==\n+        return feebumper::CreateTransaction(m_wallet.get(), txid, coin_control, total_fee, errors, old_fee, new_fee, mtx) ==\n                feebumper::Result::OK;\n     }\n-    bool signBumpTransaction(CMutableTransaction& mtx) override { return feebumper::SignTransaction(&m_wallet, mtx); }\n+    bool signBumpTransaction(CMutableTransaction& mtx) override { return feebumper::SignTransaction(m_wallet.get(), mtx); }\n     bool commitBumpTransaction(const uint256& txid,\n         CMutableTransaction&& mtx,\n         std::vector<std::string>& errors,\n         uint256& bumped_txid) override\n     {\n-        return feebumper::CommitTransaction(&m_wallet, txid, std::move(mtx), errors, bumped_txid) ==\n+        return feebumper::CommitTransaction(m_wallet.get(), txid, std::move(mtx), errors, bumped_txid) ==\n                feebumper::Result::OK;\n     }\n     CTransactionRef getTx(const uint256& txid) override\n     {\n-        auto locked_chain = m_wallet.chain().lock();\n-        LOCK(m_wallet.cs_wallet);\n-        auto mi = m_wallet.mapWallet.find(txid);\n-        if (mi != m_wallet.mapWallet.end()) {\n+        auto locked_chain = m_wallet->chain().lock();\n+        LOCK(m_wallet->cs_wallet);\n+        auto mi = m_wallet->mapWallet.find(txid);\n+        if (mi != m_wallet->mapWallet.end()) {\n             return mi->second.tx;\n         }\n         return {};\n     }\n     WalletTx getWalletTx(const uint256& txid) override\n     {\n-        auto locked_chain = m_wallet.chain().lock();\n-        LOCK(m_wallet.cs_wallet);\n-        auto mi = m_wallet.mapWallet.find(txid);\n-        if (mi != m_wallet.mapWallet.end()) {\n-            return MakeWalletTx(*locked_chain, m_wallet, mi->second);\n+        auto locked_chain = m_wallet->chain().lock();\n+        LOCK(m_wallet->cs_wallet);\n+        auto mi = m_wallet->mapWallet.find(txid);\n+        if (mi != m_wallet->mapWallet.end()) {\n+            return MakeWalletTx(*locked_chain, *m_wallet, mi->second);\n         }\n         return {};\n     }\n     std::vector<WalletTx> getWalletTxs() override\n     {\n-        auto locked_chain = m_wallet.chain().lock();\n-        LOCK(m_wallet.cs_wallet);\n+        auto locked_chain = m_wallet->chain().lock();\n+        LOCK(m_wallet->cs_wallet);\n         std::vector<WalletTx> result;\n-        result.reserve(m_wallet.mapWallet.size());\n-        for (const auto& entry : m_wallet.mapWallet) {\n-            result.emplace_back(MakeWalletTx(*locked_chain, m_wallet, entry.second));\n+        result.reserve(m_wallet->mapWallet.size());\n+        for (const auto& entry : m_wallet->mapWallet) {\n+            result.emplace_back(MakeWalletTx(*locked_chain, *m_wallet, entry.second));\n         }\n         return result;\n     }\n@@ -322,16 +322,16 @@ class WalletImpl : public Wallet\n         int& num_blocks,\n         int64_t& block_time) override\n     {\n-        auto locked_chain = m_wallet.chain().lock(true /* try_lock */);\n+        auto locked_chain = m_wallet->chain().lock(true /* try_lock */);\n         if (!locked_chain) {\n             return false;\n         }\n-        TRY_LOCK(m_wallet.cs_wallet, locked_wallet);\n+        TRY_LOCK(m_wallet->cs_wallet, locked_wallet);\n         if (!locked_wallet) {\n             return false;\n         }\n-        auto mi = m_wallet.mapWallet.find(txid);\n-        if (mi == m_wallet.mapWallet.end()) {\n+        auto mi = m_wallet->mapWallet.find(txid);\n+        if (mi == m_wallet->mapWallet.end()) {\n             return false;\n         }\n         if (Optional<int> height = locked_chain->getHeight()) {\n@@ -350,162 +350,161 @@ class WalletImpl : public Wallet\n         bool& in_mempool,\n         int& num_blocks) override\n     {\n-        auto locked_chain = m_wallet.chain().lock();\n-        LOCK(m_wallet.cs_wallet);\n-        auto mi = m_wallet.mapWallet.find(txid);\n-        if (mi != m_wallet.mapWallet.end()) {\n+        auto locked_chain = m_wallet->chain().lock();\n+        LOCK(m_wallet->cs_wallet);\n+        auto mi = m_wallet->mapWallet.find(txid);\n+        if (mi != m_wallet->mapWallet.end()) {\n             num_blocks = locked_chain->getHeight().get_value_or(-1);\n             in_mempool = mi->second.InMempool();\n             order_form = mi->second.vOrderForm;\n             tx_status = MakeWalletTxStatus(*locked_chain, mi->second);\n-            return MakeWalletTx(*locked_chain, m_wallet, mi->second);\n+            return MakeWalletTx(*locked_chain, *m_wallet, mi->second);\n         }\n         return {};\n     }\n     WalletBalances getBalances() override\n     {\n         WalletBalances result;\n-        result.balance = m_wallet.GetBalance();\n-        result.unconfirmed_balance = m_wallet.GetUnconfirmedBalance();\n-        result.immature_balance = m_wallet.GetImmatureBalance();\n-        result.have_watch_only = m_wallet.HaveWatchOnly();\n+        result.balance = m_wallet->GetBalance();\n+        result.unconfirmed_balance = m_wallet->GetUnconfirmedBalance();\n+        result.immature_balance = m_wallet->GetImmatureBalance();\n+        result.have_watch_only = m_wallet->HaveWatchOnly();\n         if (result.have_watch_only) {\n-            result.watch_only_balance = m_wallet.GetBalance(ISMINE_WATCH_ONLY);\n-            result.unconfirmed_watch_only_balance = m_wallet.GetUnconfirmedWatchOnlyBalance();\n-            result.immature_watch_only_balance = m_wallet.GetImmatureWatchOnlyBalance();\n+            result.watch_only_balance = m_wallet->GetBalance(ISMINE_WATCH_ONLY);\n+            result.unconfirmed_watch_only_balance = m_wallet->GetUnconfirmedWatchOnlyBalance();\n+            result.immature_watch_only_balance = m_wallet->GetImmatureWatchOnlyBalance();\n         }\n         return result;\n     }\n     bool tryGetBalances(WalletBalances& balances, int& num_blocks) override\n     {\n-        auto locked_chain = m_wallet.chain().lock(true /* try_lock */);\n+        auto locked_chain = m_wallet->chain().lock(true /* try_lock */);\n         if (!locked_chain) return false;\n-        TRY_LOCK(m_wallet.cs_wallet, locked_wallet);\n+        TRY_LOCK(m_wallet->cs_wallet, locked_wallet);\n         if (!locked_wallet) {\n             return false;\n         }\n         balances = getBalances();\n         num_blocks = locked_chain->getHeight().get_value_or(-1);\n         return true;\n     }\n-    CAmount getBalance() override { return m_wallet.GetBalance(); }\n+    CAmount getBalance() override { return m_wallet->GetBalance(); }\n     CAmount getAvailableBalance(const CCoinControl& coin_control) override\n     {\n-        return m_wallet.GetAvailableBalance(&coin_control);\n+        return m_wallet->GetAvailableBalance(&coin_control);\n     }\n     isminetype txinIsMine(const CTxIn& txin) override\n     {\n-        auto locked_chain = m_wallet.chain().lock();\n-        LOCK(m_wallet.cs_wallet);\n-        return m_wallet.IsMine(txin);\n+        auto locked_chain = m_wallet->chain().lock();\n+        LOCK(m_wallet->cs_wallet);\n+        return m_wallet->IsMine(txin);\n     }\n     isminetype txoutIsMine(const CTxOut& txout) override\n     {\n-        auto locked_chain = m_wallet.chain().lock();\n-        LOCK(m_wallet.cs_wallet);\n-        return m_wallet.IsMine(txout);\n+        auto locked_chain = m_wallet->chain().lock();\n+        LOCK(m_wallet->cs_wallet);\n+        return m_wallet->IsMine(txout);\n     }\n     CAmount getDebit(const CTxIn& txin, isminefilter filter) override\n     {\n-        auto locked_chain = m_wallet.chain().lock();\n-        LOCK(m_wallet.cs_wallet);\n-        return m_wallet.GetDebit(txin, filter);\n+        auto locked_chain = m_wallet->chain().lock();\n+        LOCK(m_wallet->cs_wallet);\n+        return m_wallet->GetDebit(txin, filter);\n     }\n     CAmount getCredit(const CTxOut& txout, isminefilter filter) override\n     {\n-        auto locked_chain = m_wallet.chain().lock();\n-        LOCK(m_wallet.cs_wallet);\n-        return m_wallet.GetCredit(txout, filter);\n+        auto locked_chain = m_wallet->chain().lock();\n+        LOCK(m_wallet->cs_wallet);\n+        return m_wallet->GetCredit(txout, filter);\n     }\n     CoinsList listCoins() override\n     {\n-        auto locked_chain = m_wallet.chain().lock();\n-        LOCK(m_wallet.cs_wallet);\n+        auto locked_chain = m_wallet->chain().lock();\n+        LOCK(m_wallet->cs_wallet);\n         CoinsList result;\n-        for (const auto& entry : m_wallet.ListCoins(*locked_chain)) {\n+        for (const auto& entry : m_wallet->ListCoins(*locked_chain)) {\n             auto& group = result[entry.first];\n             for (const auto& coin : entry.second) {\n                 group.emplace_back(COutPoint(coin.tx->GetHash(), coin.i),\n-                    MakeWalletTxOut(*locked_chain, m_wallet, *coin.tx, coin.i, coin.nDepth));\n+                    MakeWalletTxOut(*locked_chain, *m_wallet, *coin.tx, coin.i, coin.nDepth));\n             }\n         }\n         return result;\n     }\n     std::vector<WalletTxOut> getCoins(const std::vector<COutPoint>& outputs) override\n     {\n-        auto locked_chain = m_wallet.chain().lock();\n-        LOCK(m_wallet.cs_wallet);\n+        auto locked_chain = m_wallet->chain().lock();\n+        LOCK(m_wallet->cs_wallet);\n         std::vector<WalletTxOut> result;\n         result.reserve(outputs.size());\n         for (const auto& output : outputs) {\n             result.emplace_back();\n-            auto it = m_wallet.mapWallet.find(output.hash);\n-            if (it != m_wallet.mapWallet.end()) {\n+            auto it = m_wallet->mapWallet.find(output.hash);\n+            if (it != m_wallet->mapWallet.end()) {\n                 int depth = it->second.GetDepthInMainChain(*locked_chain);\n                 if (depth >= 0) {\n-                    result.back() = MakeWalletTxOut(*locked_chain, m_wallet, it->second, output.n, depth);\n+                    result.back() = MakeWalletTxOut(*locked_chain, *m_wallet, it->second, output.n, depth);\n                 }\n             }\n         }\n         return result;\n     }\n-    CAmount getRequiredFee(unsigned int tx_bytes) override { return GetRequiredFee(m_wallet, tx_bytes); }\n+    CAmount getRequiredFee(unsigned int tx_bytes) override { return GetRequiredFee(*m_wallet, tx_bytes); }\n     CAmount getMinimumFee(unsigned int tx_bytes,\n         const CCoinControl& coin_control,\n         int* returned_target,\n         FeeReason* reason) override\n     {\n         FeeCalculation fee_calc;\n         CAmount result;\n-        result = GetMinimumFee(m_wallet, tx_bytes, coin_control, ::mempool, ::feeEstimator, &fee_calc);\n+        result = GetMinimumFee(*m_wallet, tx_bytes, coin_control, ::mempool, ::feeEstimator, &fee_calc);\n         if (returned_target) *returned_target = fee_calc.returnedTarget;\n         if (reason) *reason = fee_calc.reason;\n         return result;\n     }\n-    unsigned int getConfirmTarget() override { return m_wallet.m_confirm_target; }\n-    bool hdEnabled() override { return m_wallet.IsHDEnabled(); }\n-    bool canGetAddresses() override { return m_wallet.CanGetAddresses(); }\n-    bool IsWalletFlagSet(uint64_t flag) override { return m_wallet.IsWalletFlagSet(flag); }\n-    OutputType getDefaultAddressType() override { return m_wallet.m_default_address_type; }\n-    OutputType getDefaultChangeType() override { return m_wallet.m_default_change_type; }\n+    unsigned int getConfirmTarget() override { return m_wallet->m_confirm_target; }\n+    bool hdEnabled() override { return m_wallet->IsHDEnabled(); }\n+    bool canGetAddresses() override { return m_wallet->CanGetAddresses(); }\n+    bool IsWalletFlagSet(uint64_t flag) override { return m_wallet->IsWalletFlagSet(flag); }\n+    OutputType getDefaultAddressType() override { return m_wallet->m_default_address_type; }\n+    OutputType getDefaultChangeType() override { return m_wallet->m_default_change_type; }\n     void remove() override\n     {\n-        RemoveWallet(m_shared_wallet);\n+        RemoveWallet(m_wallet);\n     }\n     std::unique_ptr<Handler> handleUnload(UnloadFn fn) override\n     {\n-        return MakeHandler(m_wallet.NotifyUnload.connect(fn));\n+        return MakeHandler(m_wallet->NotifyUnload.connect(fn));\n     }\n     std::unique_ptr<Handler> handleShowProgress(ShowProgressFn fn) override\n     {\n-        return MakeHandler(m_wallet.ShowProgress.connect(fn));\n+        return MakeHandler(m_wallet->ShowProgress.connect(fn));\n     }\n     std::unique_ptr<Handler> handleStatusChanged(StatusChangedFn fn) override\n     {\n-        return MakeHandler(m_wallet.NotifyStatusChanged.connect([fn](CCryptoKeyStore*) { fn(); }));\n+        return MakeHandler(m_wallet->NotifyStatusChanged.connect([fn](CCryptoKeyStore*) { fn(); }));\n     }\n     std::unique_ptr<Handler> handleAddressBookChanged(AddressBookChangedFn fn) override\n     {\n-        return MakeHandler(m_wallet.NotifyAddressBookChanged.connect(\n+        return MakeHandler(m_wallet->NotifyAddressBookChanged.connect(\n             [fn](CWallet*, const CTxDestination& address, const std::string& label, bool is_mine,\n                 const std::string& purpose, ChangeType status) { fn(address, label, is_mine, purpose, status); }));\n     }\n     std::unique_ptr<Handler> handleTransactionChanged(TransactionChangedFn fn) override\n     {\n-        return MakeHandler(m_wallet.NotifyTransactionChanged.connect(\n+        return MakeHandler(m_wallet->NotifyTransactionChanged.connect(\n             [fn](CWallet*, const uint256& txid, ChangeType status) { fn(txid, status); }));\n     }\n     std::unique_ptr<Handler> handleWatchOnlyChanged(WatchOnlyChangedFn fn) override\n     {\n-        return MakeHandler(m_wallet.NotifyWatchonlyChanged.connect(fn));\n+        return MakeHandler(m_wallet->NotifyWatchonlyChanged.connect(fn));\n     }\n     std::unique_ptr<Handler> handleCanGetAddressesChanged(CanGetAddressesChangedFn fn) override\n     {\n-        return MakeHandler(m_wallet.NotifyCanGetAddressesChanged.connect(fn));\n+        return MakeHandler(m_wallet->NotifyCanGetAddressesChanged.connect(fn));\n     }\n \n-    std::shared_ptr<CWallet> m_shared_wallet;\n-    CWallet& m_wallet;\n+    std::shared_ptr<CWallet> m_wallet;\n };\n \n class WalletClientImpl : public ChainClient"
      }
    ]
  }
]