[
  {
    "sha": "ecc1360d7bef3bf9f78cb5dbbf9297e6106244d7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplY2MxMzYwZDdiZWYzYmY5Zjc4Y2I1ZGJiZjkyOTdlNjEwNjI0NGQ3",
    "commit": {
      "author": {
        "name": "Luke Dashjr",
        "email": "luke-jr+git@utopios.org",
        "date": "2014-07-07T15:42:59Z"
      },
      "committer": {
        "name": "Clinton Christian",
        "email": "clinton.chrisitan@me.com",
        "date": "2014-07-08T21:40:02Z"
      },
      "message": "test/bloom_tests: Use UL suffix for unsigned long number to ensure compatibility",
      "tree": {
        "sha": "7898576612cd3d1a6633748059da935f286b04cd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7898576612cd3d1a6633748059da935f286b04cd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ecc1360d7bef3bf9f78cb5dbbf9297e6106244d7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ecc1360d7bef3bf9f78cb5dbbf9297e6106244d7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ecc1360d7bef3bf9f78cb5dbbf9297e6106244d7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ecc1360d7bef3bf9f78cb5dbbf9297e6106244d7/comments",
    "author": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": null,
    "parents": [
      {
        "sha": "c6ac5fcfc233e5346c73b32eed79cfe8e9fa6392",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6ac5fcfc233e5346c73b32eed79cfe8e9fa6392",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c6ac5fcfc233e5346c73b32eed79cfe8e9fa6392"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "2cdafa4bdde7cdf755f083ebe861e5b63f170434",
        "filename": "src/test/bloom_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ecc1360d7bef3bf9f78cb5dbbf9297e6106244d7/src/test/bloom_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ecc1360d7bef3bf9f78cb5dbbf9297e6106244d7/src/test/bloom_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bloom_tests.cpp?ref=ecc1360d7bef3bf9f78cb5dbbf9297e6106244d7",
        "patch": "@@ -54,7 +54,7 @@ BOOST_AUTO_TEST_CASE(bloom_create_insert_serialize)\n BOOST_AUTO_TEST_CASE(bloom_create_insert_serialize_with_tweak)\n {\n     // Same test as bloom_create_insert_serialize, but we add a nTweak of 100\n-    CBloomFilter filter(3, 0.01, 2147483649, BLOOM_UPDATE_ALL);\n+    CBloomFilter filter(3, 0.01, 2147483649UL, BLOOM_UPDATE_ALL);\n \n     filter.insert(ParseHex(\"99108ad8ed9bb6274d3980bab5a85c048f0950c8\"));\n     BOOST_CHECK_MESSAGE( filter.contains(ParseHex(\"99108ad8ed9bb6274d3980bab5a85c048f0950c8\")), \"BloomFilter doesn't contain just-inserted object!\");"
      }
    ]
  },
  {
    "sha": "7f6fa9bc5cf0601c7f2f8dba933011f276d746cf",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZjZmYTliYzVjZjA2MDFjN2YyZjhkYmE5MzMwMTFmMjc2ZDc0NmNm",
    "commit": {
      "author": {
        "name": "Clinton Christian",
        "email": "Clinton.Christian@me.com",
        "date": "2014-07-08T03:22:23Z"
      },
      "committer": {
        "name": "Clinton Christian",
        "email": "clinton.chrisitan@me.com",
        "date": "2014-07-08T21:40:54Z"
      },
      "message": "Fix memory leak, refactor to be more pythonic, maintainable, and possibly faster.",
      "tree": {
        "sha": "2dd62504f54478431dabe77f00663abc3d835152",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2dd62504f54478431dabe77f00663abc3d835152"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7f6fa9bc5cf0601c7f2f8dba933011f276d746cf",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7f6fa9bc5cf0601c7f2f8dba933011f276d746cf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7f6fa9bc5cf0601c7f2f8dba933011f276d746cf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7f6fa9bc5cf0601c7f2f8dba933011f276d746cf/comments",
    "author": {
      "login": "pygeek",
      "id": 253664,
      "node_id": "MDQ6VXNlcjI1MzY2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/253664?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pygeek",
      "html_url": "https://github.com/pygeek",
      "followers_url": "https://api.github.com/users/pygeek/followers",
      "following_url": "https://api.github.com/users/pygeek/following{/other_user}",
      "gists_url": "https://api.github.com/users/pygeek/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pygeek/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pygeek/subscriptions",
      "organizations_url": "https://api.github.com/users/pygeek/orgs",
      "repos_url": "https://api.github.com/users/pygeek/repos",
      "events_url": "https://api.github.com/users/pygeek/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pygeek/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": null,
    "parents": [
      {
        "sha": "ecc1360d7bef3bf9f78cb5dbbf9297e6106244d7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ecc1360d7bef3bf9f78cb5dbbf9297e6106244d7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ecc1360d7bef3bf9f78cb5dbbf9297e6106244d7"
      }
    ],
    "stats": {
      "total": 457,
      "additions": 237,
      "deletions": 220
    },
    "files": [
      {
        "sha": "706a10b39d113abc58def71ee6311a1865637d53",
        "filename": "contrib/pyminer/pyminer.py",
        "status": "modified",
        "additions": 237,
        "deletions": 220,
        "changes": 457,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f6fa9bc5cf0601c7f2f8dba933011f276d746cf/contrib/pyminer/pyminer.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f6fa9bc5cf0601c7f2f8dba933011f276d746cf/contrib/pyminer/pyminer.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/pyminer/pyminer.py?ref=7f6fa9bc5cf0601c7f2f8dba933011f276d746cf",
        "patch": "@@ -5,248 +5,265 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n #\n \n+import sys\n+from multiprocessing import Process\n import time\n-import json\n-import pprint\n-import hashlib\n import struct\n-import re\n+import hashlib\n import base64\n+import re\n import httplib\n-import sys\n-from multiprocessing import Process\n+import json\n \n ERR_SLEEP = 15\n MAX_NONCE = 1000000L\n \n settings = {}\n-pp = pprint.PrettyPrinter(indent=4)\n+\n \n class BitcoinRPC:\n-\tOBJID = 1\n-\n-\tdef __init__(self, host, port, username, password):\n-\t\tauthpair = \"%s:%s\" % (username, password)\n-\t\tself.authhdr = \"Basic %s\" % (base64.b64encode(authpair))\n-\t\tself.conn = httplib.HTTPConnection(host, port, False, 30)\n-\tdef rpc(self, method, params=None):\n-\t\tself.OBJID += 1\n-\t\tobj = { 'version' : '1.1',\n-\t\t\t'method' : method,\n-\t\t\t'id' : self.OBJID }\n-\t\tif params is None:\n-\t\t\tobj['params'] = []\n-\t\telse:\n-\t\t\tobj['params'] = params\n-\t\tself.conn.request('POST', '/', json.dumps(obj),\n-\t\t\t{ 'Authorization' : self.authhdr,\n-\t\t\t  'Content-type' : 'application/json' })\n-\n-\t\tresp = self.conn.getresponse()\n-\t\tif resp is None:\n-\t\t\tprint \"JSON-RPC: no response\"\n-\t\t\treturn None\n-\n-\t\tbody = resp.read()\n-\t\tresp_obj = json.loads(body)\n-\t\tif resp_obj is None:\n-\t\t\tprint \"JSON-RPC: cannot JSON-decode body\"\n-\t\t\treturn None\n-\t\tif 'error' in resp_obj and resp_obj['error'] != None:\n-\t\t\treturn resp_obj['error']\n-\t\tif 'result' not in resp_obj:\n-\t\t\tprint \"JSON-RPC: no result in object\"\n-\t\t\treturn None\n-\n-\t\treturn resp_obj['result']\n-\tdef getblockcount(self):\n-\t\treturn self.rpc('getblockcount')\n-\tdef getwork(self, data=None):\n-\t\treturn self.rpc('getwork', data)\n+    object_id = 1\n+\n+    def __init__(self, host, port, username, password):\n+        authpair = \"{0}:{1}\".format(username, password)\n+        self.authhdr = \"Basic {0}\".format(base64.b64encode(authpair))\n+        self.conn = httplib.HTTPConnection(host, port, strict=False, timeout=30)\n+\n+    def rpc(self, method, params=None):\n+        self.object_id += 1\n+        obj = {'version' : '1.1',\n+               'method' : method,\n+               'id' : self.object_id,\n+               'params' : params or []}\n+\n+        self.conn.request('POST', '/', json.dumps(obj),\n+            { 'Authorization' : self.authhdr,\n+              'Content-type' : 'application/json' })\n+\n+        resp = self.conn.getresponse()\n+\n+        if resp is None:\n+            print(\"JSON-RPC: no response\")\n+            return None\n+\n+        body = resp.read()\n+        resp_obj = json.loads(body)\n+\n+        if resp_obj is None:\n+            print(\"JSON-RPC: cannot JSON-decode body\")\n+            return None\n+\n+        if 'error' in resp_obj and resp_obj['error'] != None:\n+            return resp_obj['error']\n+\n+        if 'result' not in resp_obj:\n+            print(\"JSON-RPC: no result in object\")\n+            return None\n+\n+        return resp_obj['result']\n+\n+    def getblockcount(self):\n+        return self.rpc('getblockcount')\n+\n+    def getwork(self, data=None):\n+        return self.rpc('getwork', data)\n \n def uint32(x):\n-\treturn x & 0xffffffffL\n+    return x & 0xffffffffL\n \n def bytereverse(x):\n-\treturn uint32(( ((x) << 24) | (((x) << 8) & 0x00ff0000) |\n-\t\t\t(((x) >> 8) & 0x0000ff00) | ((x) >> 24) ))\n+    return uint32(( ((x) << 24) | (((x) << 8) & 0x00ff0000) |\n+            (((x) >> 8) & 0x0000ff00) | ((x) >> 24) ))\n \n def bufreverse(in_buf):\n-\tout_words = []\n-\tfor i in range(0, len(in_buf), 4):\n-\t\tword = struct.unpack('@I', in_buf[i:i+4])[0]\n-\t\tout_words.append(struct.pack('@I', bytereverse(word)))\n-\treturn ''.join(out_words)\n+    out_words = []\n+\n+    for i in range(0, len(in_buf), 4):\n+        word = struct.unpack('@I', in_buf[i:i+4])[0]\n+        out_words.append(struct.pack('@I', bytereverse(word)))\n+\n+    return ''.join(out_words)\n \n def wordreverse(in_buf):\n-\tout_words = []\n-\tfor i in range(0, len(in_buf), 4):\n-\t\tout_words.append(in_buf[i:i+4])\n-\tout_words.reverse()\n-\treturn ''.join(out_words)\n+    out_words = []\n+\n+    for i in range(0, len(in_buf), 4):\n+        out_words.append(in_buf[i:i+4])\n+\n+    out_words.reverse()\n+\n+    return ''.join(out_words)\n+\n \n class Miner:\n-\tdef __init__(self, id):\n-\t\tself.id = id\n-\t\tself.max_nonce = MAX_NONCE\n-\n-\tdef work(self, datastr, targetstr):\n-\t\t# decode work data hex string to binary\n-\t\tstatic_data = datastr.decode('hex')\n-\t\tstatic_data = bufreverse(static_data)\n-\n-\t\t# the first 76b of 80b do not change\n-\t\tblk_hdr = static_data[:76]\n-\n-\t\t# decode 256-bit target value\n-\t\ttargetbin = targetstr.decode('hex')\n-\t\ttargetbin = targetbin[::-1]\t# byte-swap and dword-swap\n-\t\ttargetbin_str = targetbin.encode('hex')\n-\t\ttarget = long(targetbin_str, 16)\n-\n-\t\t# pre-hash first 76b of block header\n-\t\tstatic_hash = hashlib.sha256()\n-\t\tstatic_hash.update(blk_hdr)\n-\n-\t\tfor nonce in xrange(self.max_nonce):\n-\n-\t\t\t# encode 32-bit nonce value\n-\t\t\tnonce_bin = struct.pack(\"<I\", nonce)\n-\n-\t\t\t# hash final 4b, the nonce value\n-\t\t\thash1_o = static_hash.copy()\n-\t\t\thash1_o.update(nonce_bin)\n-\t\t\thash1 = hash1_o.digest()\n-\n-\t\t\t# sha256 hash of sha256 hash\n-\t\t\thash_o = hashlib.sha256()\n-\t\t\thash_o.update(hash1)\n-\t\t\thash = hash_o.digest()\n-\n-\t\t\t# quick test for winning solution: high 32 bits zero?\n-\t\t\tif hash[-4:] != '\\0\\0\\0\\0':\n-\t\t\t\tcontinue\n-\n-\t\t\t# convert binary hash to 256-bit Python long\n-\t\t\thash = bufreverse(hash)\n-\t\t\thash = wordreverse(hash)\n-\n-\t\t\thash_str = hash.encode('hex')\n-\t\t\tl = long(hash_str, 16)\n-\n-\t\t\t# proof-of-work test:  hash < target\n-\t\t\tif l < target:\n-\t\t\t\tprint time.asctime(), \"PROOF-OF-WORK found: %064x\" % (l,)\n-\t\t\t\treturn (nonce + 1, nonce_bin)\n-\t\t\telse:\n-\t\t\t\tprint time.asctime(), \"PROOF-OF-WORK false positive %064x\" % (l,)\n-#\t\t\t\treturn (nonce + 1, nonce_bin)\n-\n-\t\treturn (nonce + 1, None)\n-\n-\tdef submit_work(self, rpc, original_data, nonce_bin):\n-\t\tnonce_bin = bufreverse(nonce_bin)\n-\t\tnonce = nonce_bin.encode('hex')\n-\t\tsolution = original_data[:152] + nonce + original_data[160:256]\n-\t\tparam_arr = [ solution ]\n-\t\tresult = rpc.getwork(param_arr)\n-\t\tprint time.asctime(), \"--> Upstream RPC result:\", result\n-\n-\tdef iterate(self, rpc):\n-\t\twork = rpc.getwork()\n-\t\tif work is None:\n-\t\t\ttime.sleep(ERR_SLEEP)\n-\t\t\treturn\n-\t\tif 'data' not in work or 'target' not in work:\n-\t\t\ttime.sleep(ERR_SLEEP)\n-\t\t\treturn\n-\n-\t\ttime_start = time.time()\n-\n-\t\t(hashes_done, nonce_bin) = self.work(work['data'],\n-\t\t\t\t\t\t     work['target'])\n-\n-\t\ttime_end = time.time()\n-\t\ttime_diff = time_end - time_start\n-\n-\t\tself.max_nonce = long(\n-\t\t\t(hashes_done * settings['scantime']) / time_diff)\n-\t\tif self.max_nonce > 0xfffffffaL:\n-\t\t\tself.max_nonce = 0xfffffffaL\n-\n-\t\tif settings['hashmeter']:\n-\t\t\tprint \"HashMeter(%d): %d hashes, %.2f Khash/sec\" % (\n-\t\t\t      self.id, hashes_done,\n-\t\t\t      (hashes_done / 1000.0) / time_diff)\n-\n-\t\tif nonce_bin is not None:\n-\t\t\tself.submit_work(rpc, work['data'], nonce_bin)\n-\n-\tdef loop(self):\n-\t\trpc = BitcoinRPC(settings['host'], settings['port'],\n-\t\t\t\t settings['rpcuser'], settings['rpcpass'])\n-\t\tif rpc is None:\n-\t\t\treturn\n-\n-\t\twhile True:\n-\t\t\tself.iterate(rpc)\n+    def __init__(self, id):\n+        self.id = id\n+        self.max_nonce = MAX_NONCE\n+\n+    def work(self, datastr, targetstr):\n+        # decode work data hex string to binary\n+        static_data = datastr.decode('hex')\n+        static_data = bufreverse(static_data)\n+\n+        # the first 76b of 80b do not change\n+        blk_hdr = static_data[:76]\n+\n+        # decode 256-bit target value\n+        targetbin = targetstr.decode('hex')\n+        targetbin = targetbin[::-1]    # byte-swap and dword-swap\n+        targetbin_str = targetbin.encode('hex')\n+        target = long(targetbin_str, 16)\n+\n+        # pre-hash first 76b of block header\n+        static_hash = hashlib.sha256()\n+        static_hash.update(blk_hdr)\n+\n+        for nonce in xrange(self.max_nonce):\n+\n+            # encode 32-bit nonce value\n+            nonce_bin = struct.pack(\"<I\", nonce)\n+\n+            # hash final 4b, the nonce value\n+            hash1_o = static_hash.copy()\n+            hash1_o.update(nonce_bin)\n+            hash1 = hash1_o.digest()\n+\n+            # sha256 hash of sha256 hash\n+            hash_o = hashlib.sha256()\n+            hash_o.update(hash1)\n+            hash = hash_o.digest()\n+\n+            # quick test for winning solution: high 32 bits zero?\n+            if hash[-4:] != '\\0\\0\\0\\0':\n+                continue\n+\n+            # convert binary hash to 256-bit Python long\n+            hash = bufreverse(hash)\n+            hash = wordreverse(hash)\n+\n+            hash_str = hash.encode('hex')\n+            long_hash = long(hash_str, 16)\n+\n+            # proof-of-work test:  hash < target\n+            if long_hash < target:\n+                print(time.asctime(), \"PROOF-OF-WORK found: \"\n+                                      \"{0:064x}\".format(long_hash))\n+                return (nonce + 1, nonce_bin)\n+            else:\n+                print(time.asctime(), \"PROOF-OF-WORK false\"\n+                                      \"positive {0:064x}\".format(long_hash))\n+\n+        return (nonce + 1, None)\n+\n+    def submit_work(self, rpc, original_data, nonce_bin):\n+        nonce_bin = bufreverse(nonce_bin)\n+        nonce = nonce_bin.encode('hex')\n+        solution = original_data[:152] + nonce + original_data[160:256]\n+        param_arr = [ solution ]\n+        result = rpc.getwork(param_arr)\n+\n+        print(time.asctime(), \"--> Upstream RPC result:\", result)\n+\n+    def iterate(self, rpc):\n+        work = rpc.getwork()\n+\n+        if work is None:\n+            time.sleep(ERR_SLEEP)\n+            return\n+\n+        if 'data' not in work or 'target' not in work:\n+            time.sleep(ERR_SLEEP)\n+            return\n+\n+        time_start = time.time()\n+\n+        (hashes_done, nonce_bin) = self.work(work['data'],\n+                             work['target'])\n+\n+        time_end = time.time()\n+        time_diff = time_end - time_start\n+\n+        self.max_nonce = long(\n+            (hashes_done * settings['scantime']) / time_diff)\n+\n+        if self.max_nonce > 0xfffffffaL:\n+            self.max_nonce = 0xfffffffaL\n+\n+        if settings['hashmeter']:\n+            print(\"HashMeter({:d}): {:d} hashes, {:.2f} Khash/sec\".format(\n+                  self.id, hashes_done, (hashes_done / 1000.0) / time_diff))\n+\n+        if nonce_bin is not None:\n+            self.submit_work(rpc, work['data'], nonce_bin)\n+\n+    def loop(self):\n+        rpc = BitcoinRPC(settings['host'], settings['port'],\n+                 settings['rpcuser'], settings['rpcpass'])\n+\n+        if rpc is not None:\n+\n+            while True:\n+                self.iterate(rpc)\n+        \n+        self.conn.close()\n+\n \n def miner_thread(id):\n-\tminer = Miner(id)\n-\tminer.loop()\n+    miner = Miner(id)\n+    miner.loop()\n \n if __name__ == '__main__':\n-\tif len(sys.argv) != 2:\n-\t\tprint \"Usage: pyminer.py CONFIG-FILE\"\n-\t\tsys.exit(1)\n-\n-\tf = open(sys.argv[1])\n-\tfor line in f:\n-\t\t# skip comment lines\n-\t\tm = re.search('^\\s*#', line)\n-\t\tif m:\n-\t\t\tcontinue\n-\n-\t\t# parse key=value lines\n-\t\tm = re.search('^(\\w+)\\s*=\\s*(\\S.*)$', line)\n-\t\tif m is None:\n-\t\t\tcontinue\n-\t\tsettings[m.group(1)] = m.group(2)\n-\tf.close()\n-\n-\tif 'host' not in settings:\n-\t\tsettings['host'] = '127.0.0.1'\n-\tif 'port' not in settings:\n-\t\tsettings['port'] = 8332\n-\tif 'threads' not in settings:\n-\t\tsettings['threads'] = 1\n-\tif 'hashmeter' not in settings:\n-\t\tsettings['hashmeter'] = 0\n-\tif 'scantime' not in settings:\n-\t\tsettings['scantime'] = 30L\n-\tif 'rpcuser' not in settings or 'rpcpass' not in settings:\n-\t\tprint \"Missing username and/or password in cfg file\"\n-\t\tsys.exit(1)\n-\n-\tsettings['port'] = int(settings['port'])\n-\tsettings['threads'] = int(settings['threads'])\n-\tsettings['hashmeter'] = int(settings['hashmeter'])\n-\tsettings['scantime'] = long(settings['scantime'])\n-\n-\tthr_list = []\n-\tfor thr_id in range(settings['threads']):\n-\t\tp = Process(target=miner_thread, args=(thr_id,))\n-\t\tp.start()\n-\t\tthr_list.append(p)\n-\t\ttime.sleep(1)\t\t\t# stagger threads\n-\n-\tprint settings['threads'], \"mining threads started\"\n-\n-\tprint time.asctime(), \"Miner Starts - %s:%s\" % (settings['host'], settings['port'])\n-\ttry:\n-\t\tfor thr_proc in thr_list:\n-\t\t\tthr_proc.join()\n-\texcept KeyboardInterrupt:\n-\t\tpass\n-\tprint time.asctime(), \"Miner Stops - %s:%s\" % (settings['host'], settings['port'])\n-\n+    if len(sys.argv) != 2:\n+        print(\"Usage: pyminer.py CONFIG-FILE\")\n+        sys.exit(1)\n+\n+    with open(sys.argv[1]) as f:\n+\n+        for line in f:\n+            # skip comment lines\n+            m = re.search('^\\s*#', line)\n+            if m:\n+                continue\n+\n+            # parse key=value lines\n+            m = re.search('^(\\w+)\\s*=\\s*(\\S.*)$', line)\n+            if m is None:\n+                continue\n+\n+            settings[m.group(1)] = m.group(2)\n+\n+    settings.setdefault('host', '127.0.0.1')\n+    settings.setdefault('port', 8332)\n+    settings.setdefault('threads', 1)\n+    settings.setdefault('hashmeter', 0)\n+    settings.setdefault('scantime', 30L)\n+\n+    if 'rpcuser' not in settings or 'rpcpass' not in settings:\n+        print(\"Missing username and/or password in cfg file\")\n+        sys.exit(1)\n+\n+    settings['port'] = int(settings['port'])\n+    settings['threads'] = int(settings['threads'])\n+    settings['hashmeter'] = int(settings['hashmeter'])\n+    settings['scantime'] = long(settings['scantime'])\n+\n+    thread_list = []\n+\n+    for thread_id in range(settings['threads']):\n+        p = Process(target=miner_thread, args=(thread_id,))\n+        p.start()\n+        thread_list.append(p)\n+        time.sleep(1) # stagger threads\n+\n+    print(settings['threads'], \"mining threads started\")\n+\n+    print(time.asctime(), \"Miner Starts - {0}:{1}\".format(settings['host'],\n+                                                          settings['port']))\n+    try:\n+        for thread_process in thread_list:\n+            thread_process.join()\n+    except KeyboardInterrupt:\n+        pass\n+\n+    print(time.asctime(), \"Miner Stops - {0}:{1}\".format(settings['host'],\n+                                                         settings['port']))"
      }
    ]
  }
]